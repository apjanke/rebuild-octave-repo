# HG changeset patch
# User jwe
# Date 988301751 0
#      Thu Apr 26 16:15:51 2001 +0000
# Node ID 1f663ddfa35014b0ccbb498809ae712f66754282
# Parent  1a809dae77dba2ad745adc02a64950efe096ca46
[project @ 2001-04-26 16:15:28 by jwe]

diff --git a/readline/CHANGELOG b/readline/CHANGELOG
deleted file mode 100644
--- a/readline/CHANGELOG
+++ /dev/null
@@ -1,465 +0,0 @@
-[Readline-specific changelog.  Descriptions of changes to the source are
- found in the bash changelog.]
-
-				    6/9
-				    ---
-Makefile.in
-	- quote value of ${INSTALL_DATA} when passing it to makes in
-	  subdirectories
-
-				    7/1
-				    ---
-Makefile.in
-	- don't pass INSTALL_DATA to a make in the `doc' subdirectory; let
-	  autoconf set the value itself in the Makefile
-	- removed a stray `-' before $(RANLIB) in the `install' recipe
-
-doc/Makefile.in
-	- add a VPATH assignment so the documentation is not remade if it's
-	  already up-to-date in the distribution
-
-configure.in
-	- call AC_SUBST(LOCAL_LDFLAGS), since Makefile.in contains
-	  @LOCAL_LDFLAGS@
-
-				    7/9
-				    ---
-
-config.h.in
-	- add define lines for STRUCT_WINSIZE_IN_SYS_IOCTL and
-	  STRUCT_WINSIZE_IN_TERMIOS
-
-configure.in
-	- call BASH_STRUCT_WINSIZE to look for the definition of
-	  `struct winsize'
-
-				   7/17
-				   ----
-configure.in
-	- call AC_MINIX
-
-config.h.in
-	- add define line for AC_MINIX
-
-				   7/18
-				   ----
-Makefile.in
-	- add `install-shared' and `uninstall-shared' targets
-
-				    8/4
-				    ---
-Makefile.in
-	- install and uninstall libhistory.a in the `install' and
-	  `uninstall' targets
-
-				    9/4
-				    ---
-configure.in
-	- bumped LIBVERSION up to 2.1.1, indicating that this is patch
-	  level 1 to release 2.1
-
-
-				   9/16
-				   ----
-Makefile.in
-	- `make distclean' now descends into the `examples' subdir
-
-doc/Makefile.in
-	- the `distclean' and `maintainer-clean' targets should remove
-	  Makefile
-
-examples/Makefile.in
-	- added the various clean targets
-
-				    4/2
-				    ---
-configure.in
-	- bumped LIBVERSION up to 2.2
-
-				   4/18
-				   ----
-[readline-2.2 released]
-
-				   4/20
-				   ----
-Makefile.in
-	- make `libhistory.a' a dependency of `install'
-	- fixed a typo in the recipe for `install' that copied libreadline.a
-	  to libhistory.old right after installing it
-
-				   4/27
-				   ----
-doc/Makefile.in
-	- install {readline,history}.info out of the source directory if
-	  they are not found in the current (build) directory -- only an
-	  issue if the libraries are built in a different directory than
-	  the source directory
-
-				    5/1
-				    ---
-support/shobj-conf
-	- script from the bash distribution to do shared object and library
-	  configuration
-
-shlib/Makefile.in
-	- new directory and makefile to handle building shared versions of
-	  libreadline and libhistory, controlled by support/shobj-conf
-
-				    5/7
-				    ---
-doc/Makefile.in
-	- set SHELL to /bin/sh, rather than relying on make to be correct
-
-				   5/14
-				   ----
-savestring.c
-	- new file, moved from shell.c, for backwards compatibility
-
-Makefile.in, shlib/Makefile.in
-	- make sure savestring.c is compiled and added to libreadline and
-	  libhistory
-
-[THERE ARE NO MORE #ifdef SHELL LINES IN THE C SOURCE FILES.]
-
-				   5/15
-				   ----
-README
-	- updated description of shared library creation for the new scheme
-
-[THERE ARE NO MORE #ifdef SHELL LINES IN ANY OF THE SOURCE FILES.]
-
-Makefile.in
-	- bumped SHLIB_MAJOR up to 4 since we've augmented the library
-	  API
-	- rlconf.h is now one of the installed headers, so applications can
-	  find out whether things like vi-mode are available in the installed
-	  libreadline
-
-				   5/20
-				   ----
-configure.in
-	- changed RL_LIBRARY_VERSION to 4.0 to match the version of the
-	  installed shared libraries
-
-				    6/5
-				    ---
-rlstdc.h
-	- new file
-
-Makefile.in
-	- rlstdc.h is now one of the installed headers
-
-				    8/3
-				    ---
-shlib/Makefile.in
-	- made the suffix rule that creates xx.so from xx.c write the
-	  compiler output to `a.o', which is then mv'd to xx.so, because
-	  some compilers (Sun WSpro 4.2, for example) don't allow any
-	  suffixes other than `.o' for `cc -c' (not even `a.out')
-
-				   9/15
-				   ----
-
-Makefile.in
-	- AR and ARFLAGS are now substituted by configure, used in recipes
-	  that build the libraries
-
-configure.in
-	- use AC_CHECK_PROG to check for ar
-	- set ARFLAGS if it has not already been set in the environment
-
-				   10/5
-				   ----
-Makefile.in
-	- removed savestring.o from object file list
-
-				   10/28
-				   -----
-shlib/Makefile.in
-	- don't use a fixed filename in the .c.so suffix rule to avoid
-	  problems with parallel makes
-
-				   12/21
-				   -----
-support/shlib-install
-	- new script to install shared readline and history libraries
-
-shlib/Makefile.in
-	- changed to call shlib-install for install and uninstall targets
-
-[readline-4.0-beta1 frozen]
-
-				   12/22
-				   -----
-configure.in
-	- call AC_SUBST for SHOBJ_XLDFLAGS and SHLIB_LIBS
-
-shlib/Makefile.in
-	- SHOBJ_XLDFLAGS and SHLIB_LIBS are now substituted by configure
-	- add $(SHLIB_LIBS) at end of command line that builds the shared
-	  libraries (currently needed only by AIX 4.2)
-
-				   12/31
-				   -----
-MANIFEST, MANIFEST.doc
-	- the TOC html files are no longer generated and no longer part of
-	  the distribution
-
-				 2/18/1999
-				 ---------
-configure.in
-	- set MAKE_SHELL to /bin/sh and substitute into the Makefiles
-
-Makefile.in,{doc,examples,shlib}/Makefile.in
-	- set SHELL from @MAKE_SHELL@
-
-[readline-4.0 released]
-
-				   3/11
-				   ----
-doc/Makefile.in
-	- removed references to HTMLTOC, since separate HTML table-of-contents
-	  files are no longer created
-
-examples/Makefile.in
-	- remove `*.exe' in clean target for MS-DOS
-
-Makefile.in
-	- make `readline' target depend on ./libreadline.a
-	- configure now substitutes TERMCAP_LIB into Makefile.in
-	- use ${TERMCAP_LIB} instead of -ltermcap in recipe for `readline'
-	- clean target now removes readline and readline.exe in case they
-	  get built
-
-configure.in
-	- use `pwd.exe' to set BUILD_DIR on MS-DOS DJGPP
-
-				   3/15
-				   ----
-support/shlib-install
-	- Irix 5.x and Irix 6.x should install shared libraries like Solaris 2
-	- changes for installing on hp-ux 1[01].x
-
-				   3/23
-				   ----
-configure.in
-	- make sure that the $CC argument to shobj-conf is quoted
-
-				    4/8
-				    ---
-
-xmalloc.h, rlprivate.h, rlshell.h
-	- new files
-
-Makefile.in,shlib/Makefile.in
-	- add dependencies on xmalloc.h, rlshell.h
-	- add xmalloc.h, rlprivate.h, rlshell.h to list of header files
-
-MANIFEST
-	- add xmalloc.h, rlprivate.h, rlshell.h
-
-				    4/9
-				    ---
-Makefile.in,shlib/Makefile.in
-	- add dependencies on rlprivate.h
-
-				   4/13
-				   ----
-doc/Makefile.in
-	- add variable, PSDVI, which is the desired resolution of the
-	  generated postscript files.  Set to 300 because I don't have
-	  any 600-dpi printers
-	- set LANGUAGE= before calling makeinfo, so messages are in English
-	- add rluserman.{info,dvi,ps,html} to appropriate variables
-	- add rules to create rluserman.{info,dvi,ps,html}
-	- install and uninstall rluserman.info, but don't update the directory
-	  file in $(infodir) yet
-
-MANIFEST
-	- add doc/rluserman.{texinfo,info,dvi,ps,html}
-
-				   4/30
-				   ----
-configure.in
-	- updated library version to 4.1
-
-				    5/3
-				    ---
-configure.in
-	- SHLIB_MAJOR and SHLIB_MINOR shared library version numbers are
-	  constructed from $LIBRARY_VERSION and substituted into Makefiles
-
-				    5/5
-				    ---
-support/shlib-install
-	- OSF/1 installs shared libraries like Solaris
-
-Makefile.in
-	- broke the header file install and uninstall into two new targets:
-	  install-headers and uninstall-headers
-	- install and uninstall depend on install-headers and uninstall-headers
-	  respectively
-	- changed install-shared and uninstall-shared targets to depend on
-	  install-headers and uninstall-headers, respectively, so users may
-	  choose to install only the shared libraries.  I'm not sure about
-	  the uninstall one yet -- maybe it should check whether or not
-	  the static libraries are installed and not remove the header files
-	  if they are
-
-				    9/3
-				    ---
-configure.in, config.h.in
-	- added test for memmove (for later use)
-	- changed version to 4.1-beta1
-
-				   9/13
-				   ----
-examples/rlfe.c
-	- Per Bothner's `rlfe' readline front-end program
-
-examples/Makefile.in
-	- added rules to build rlfe
-
-				   9/21
-				   ----
-support/shlib-install
-	- changes to handle FreeBSD-3.x elf or a.out shared libraries, which
-	  have different semantics and need different naming conventions
-
-				 1/24/2000
-				 ---------
-doc/Makefile.in
-	- remove *.bt and *.bts on `make clean'
-
-				    2/4
-				    ---
-
-
-configure.in
-	- changed LIBVERSION to 4.1-beta5
-
-				 3/17/2000
-				 ---------
-[readline-4.1 released]
-
-				   3/23
-				   ----
-Makefile.in
-	- remove the `-t' argument to ranlib in the install recipe; some
-	  ranlibs don't have it and attempt to create a file named `-t'
-
-				   3/27
-				   ----
-support/shlib-install
-	- install shared libraries unwritable by anyone on HP-UX
-	- changed symlinks to relative pathnames on all platforms
-
-shlib/Makefile.in
-	- added missing `includedir' assignment, substituted by configure
-
-Makefile.in
-	- added missing @SET_MAKE@ so configure can set $MAKE appropriately
-
-configure.in
-	- add call to AC_PROG_MAKE_SET
-
-				   8/30
-				   ----
-shlib/Makefile.in
-	- change the soname bound into the shared libraries, so it includes
-	  only the major version number.  If it includes the minor version,
-	  programs depending on it must be rebuilt (which may or may not be
-	  a bad thing)
-
-				    9/6
-				    ---
-examples/rlfe.c
-	- add -l option to log input and output (-a option appends to logfile)
-	- add -n option to set readline application name
-	- add -v, -h options for version and help information
-	- change a few things because getopt() is now used to parse arguments
-
-				   9/12
-				   ----
-support/shlib-install
-	- fix up the libname on HPUX 11
-
-				   10/18
-				   -----
-configure.in
-	- changed library version to 4.2-alpha
-
-				   10/30
-				   -----
-configure.in
-	- add -fsigned-char to LOCAL_CFLAGS for Linux running on the IBM
-	  S/390
-
-Makefile.in
-	- added new file, rltypedefs.h, installed by default with `make install'
-
-				   11/2
-				   ----
-compat.c
-	- new file, with backwards-compatibility function definitions
-
-Makefile.in,shlib/Makefile.in
-	- make sure that compat.o/compat.so are built and linked apppropriately
-
-support/shobj-conf
-	- picked up bash version, which means that shared libs built on
-	  linux and BSD/OS 4.x will have an soname that does not include
-	  the minor version number
-
-				   11/13
-				   -----
-examples/rlfe.c
-	- rlfe can perform filename completion for relative pathnames in the
-	  inferior process's context if the OS supports /proc/PID/cwd (linux
-	  does it OK, Solaris is slightly warped, none of the BSDs have it)
-
-				11/17/2000
-				----------
-[readline-4.2-alpha released]
-
-				   11/27
-				   -----
-Makefile.in,shlib/Makefile.in
-	- added dependencies for rltypedefs.h
-
-shlib/Makefile.in
-	- changed dependencies on histlib.h to $(topdir)/histlib.h
-
-				   1/22
-				   ----
-configure.in
-	- changed release version to 4.2-beta
-
-				    2/2
-				    ---
-examples/Makefile.in
-	- build histexamp as part of the examples
-
-				    2/5
-				    ---
-doc/Makefile.in
-	- don't remove the dvi, postscript, html, info, and text `objects'
-	  on a `make distclean', only on a `make maintainer-clean'
-
-				    3/6
-				    ---
-doc/history.{0,3}, doc/history_3.ps
-	- new manual page for history library
-
-doc/Makefile.in
-	- rules to install and uninstall history.3 in ${man3dir}
-	- rules to build history.0 and history_3.ps
-
-				    4/2
-				    ---
-configure.in
-	- changed LIBVERSION to `4.2'
-
-				    4/5
-				    ---
-[readline-4.2 frozen]
diff --git a/readline/CHANGES b/readline/CHANGES
deleted file mode 100644
--- a/readline/CHANGES
+++ /dev/null
@@ -1,454 +0,0 @@
-This document details the changes between this version, readline-4.2,
-and the previous version, readline-4.1.
-
-1.  Changes to Readline
-
-a.  When setting the terminal attributes on systems using `struct termio',
-    readline waits for output to drain before changing the attributes.
-
-b.  A fix was made to the history word tokenization code to avoid attempts to
-    dereference a null pointer.
-
-c.  Readline now defaults rl_terminal_name to $TERM if the calling application
-    has left it unset, and tries to initialize with the resultant value.
-
-d.  Instead of calling (*rl_getc_function)() directly to get input in certain
-    places, readline now calls rl_read_key() consistently.
-
-e.  Fixed a bug in the completion code that allowed a backslash to quote a
-    single quote inside a single-quoted string.
-
-f.  rl_prompt is no longer assigned directly from the argument to readline(),
-    but uses memory allocated by readline.  This allows constant strings to
-    be passed to readline without problems arising when the prompt processing
-    code wants to modify the string.
-
-g.  Fixed a bug that caused non-interactive history searches to return the
-    wrong line when performing multiple searches backward for the same string.
-
-h.  Many variables, function arguments, and function return values are now
-    declared `const' where appropriate, to improve behavior when linking with
-    C++ code.
-
-i.  The control character detection code now works better on systems where
-    `char' is unsigned by default.
-
-j.  The vi-mode numeric argument is now capped at 999999, just like emacs mode.
-
-k.  The Function, CPFunction, CPPFunction, and VFunction typedefs have been
-    replaced with a set of specific prototyped typedefs, though they are
-    still in the readline header files for backwards compatibility.
-
-m.  Nearly all of the (undocumented) internal global variables in the library
-    now have an _rl_ prefix -- there were a number that did not, like
-    screenheight, screenwidth, alphabetic, etc.
-
-n.  The ding() convenience function has been renamed to rl_ding(), though the
-    old function is still defined for backwards compatibility.
-
-o.  The completion convenience functions filename_completion_function,
-    username_completion_function, and completion_matches now have an rl_
-    prefix, though the old names are still defined for backwards compatibility.
-
-p.  The functions shared by readline and bash (linkage is satisfied from bash
-    when compiling with bash, and internally otherwise) now have an sh_ prefix.
-
-q.  Changed the shared library creation procedure on Linux and BSD/OS 4.x so
-    that the `soname' contains only the major version number rather than the
-    major and minor numbers.
-
-r.  Fixed a redisplay bug that occurred when the prompt spanned more than one
-    physical line and contained invisible characters.
-
-s.  Added a missing `includedir' variable to the Makefile.
-
-t.  When installing the shared libraries, make sure symbolic links are relative.
-
-u.  Added configure test so that it can set `${MAKE}' appropriately.
-
-v.  Fixed a bug in rl_forward that could cause the point to be set to before
-    the beginning of the line in vi mode.
-
-w.  Fixed a bug in the callback read-char interface to make it work when a
-    readline function pushes some input onto the input stream with
-    rl_execute_next (like the incremental search functions).
-
-x.  Fixed a file descriptor leak in the history file manipulation code that
-    was tripped when attempting to truncate a non-regular file (like
-    /dev/null).
-
-y.  Changes to make all of the exported readline functions declared in
-    readline.h have an rl_ prefix (rltty_set_default_bindings is now
-    rl_tty_set_default_bindings, crlf is now rl_crlf, etc.)
-
-z.  The formatted documentation included in the base readline distribution
-    is no longer removed on a `make distclean'.
-
-aa. Some changes were made to avoid gcc warnings with -Wall.
-
-bb. rl_get_keymap_by_name now finds keymaps case-insensitively, so
-    `set keymap EMACS' works.
-
-cc. The history file writing and truncation functions now return a useful
-    status on error.
-
-dd. Fixed a bug that could cause applications to dereference a NULL pointer
-    if a NULL second argument was passed to history_expand().
-
-ee. If a hook function assigned to rl_event_hook sets rl_done to a non-zero
-    value, rl_read_key() now immediately returns '\n' (which is assumed to   
-    be bound to accept-line).
-
-2.  New Features in Readline
-
-a.  The blink timeout for paren matching is now settable by applications,
-    via the rl_set_paren_blink_timeout() function.
-
-b.  _rl_executing_macro has been renamed to rl_executing_macro, which means
-    it's now part of the public interface.
-
-c.  Readline has a new variable, rl_readline_state, which is a bitmap that
-    encapsulates the current state of the library; intended for use by
-    callbacks and hook functions.
-
-d.  rlfe has a new -l option to log input and output (-a appends to logfile),
-    a new -n option to set the readline application name, and -v and -h
-    options for version and help information.
-
-e.  rlfe can now perform filename completion for the inferior process if the
-    OS has a /proc/<PID>/cwd that can be read with readlink(2) to get the
-    inferior's current working directory.
-
-f.  A new file, rltypedefs.h, contains the new typedefs for function pointers
-    and is installed by `make install'.
-
-g.  New application-callable function rl_set_prompt(const char *prompt):
-    expands its prompt string argument and sets rl_prompt to the result.
-
-h.  New application-callable function rl_set_screen_size(int rows, int cols):
-    public method for applications to set readline's idea of the screen
-    dimensions.
-
-i.  The history example program (examples/histexamp.c) is now built as one
-    of the examples.
-
-j.  The documentation has been updated to cover nearly all of the public
-    functions and variables declared in readline.h.
-
-k.  New function, rl_get_screen_size (int *rows, int *columns), returns
-    readline's idea of the screen dimensions.
-
-l.  The timeout in rl_gather_tyi (readline keyboard input polling function)
-    is now settable via a function (rl_set_keyboard_input_timeout()).
-
-m.  Renamed the max_input_history variable to history_max_entries; the old
-    variable is maintained for backwards compatibility.
-
-n.  The list of characters that separate words for the history tokenizer is
-    now settable with a variable:  history_word_delimiters.  The default
-    value is as before.
-
-o.  There is a new history.3 manual page documenting the history library.
-
--------------------------------------------------------------------------------
-This document details the changes between this version, readline-4.1,
-and the previous version, readline-4.0.
-
-1.  Changes to Readline
-
-a.  Changed the HTML documents so that the table-of-contents is no longer
-    a separate file.
-
-b.  Changes to the shared object configuration for: Irix 5.x, Irix 6.x,
-    OSF/1.
-
-c.  The shared library major and minor versions are now constructed
-    automatically by configure and substituted into the makefiles.
-
-d.  It's now possible to install the shared libraries separately from the
-    static libraries.
-
-e.  The history library tries to truncate the history file only if it is a
-    regular file.
-
-f.  A bug that caused _rl_dispatch to address negative array indices on
-    systems with signed chars was fixed.
-
-g.  rl-yank-nth-arg now leaves the history position the same as when it was
-    called.
-
-h.  Changes to the completion code to handle MS-DOS drive-letter:pathname
-    filenames.
-
-i.  Completion is now case-insensitive by default on MS-DOS.
-
-j.  Fixes to the history file manipulation code for MS-DOS.
-
-k.  Readline attempts to bind the arrow keys to appropriate defaults on MS-DOS.
-
-l.  Some fixes were made to the redisplay code for better operation on MS-DOS.
-
-m.  The quoted-insert code will now insert tty special chars like ^C.
-
-n.  A bug was fixed that caused the display code to reference memory before
-    the start of the prompt string.
-
-o.  More support for __EMX__ (OS/2).
-
-p.  A bug was fixed in readline's signal handling that could cause infinite
-    recursion in signal handlers.
-
-q.  A bug was fixed that caused the point to be less than zero when rl_forward
-    was given a very large numeric argument.
-
-r.  The vi-mode code now gets characters via the application-settable value
-    of rl_getc_function rather than calling rl_getc directly.
-
-s.  The history file code now uses O_BINARY mode when reading and writing
-    the history file on cygwin32.
-
-t.  Fixed a bug in the redisplay code for lines with more than 256 line
-    breaks.
-
-u.  A bug was fixed which caused invisible character markers to not be
-    stripped from the prompt string if the terminal was in no-echo mode.
-    
-v.  Readline no longer tries to get the variables it needs for redisplay 
-    from the termcap entry if the calling application has specified its
-    own redisplay function.  Readline treats the terminal as `dumb' in
-    this case.
-
-w.  Fixes to the SIGWINCH code so that a multiple-line prompt with escape
-    sequences is redrawn correctly.
-
-x.  Changes to the install and install-shared targets so that the libraries
-    and header files are installed separately.
-
-2.  New Features in Readline
-
-a.  A new Readline `user manual' is in doc/rluserman.texinfo.
-
-b.  Parentheses matching is now always compiled into readline, and enabled
-    or disabled when the value of the `blink-matching-paren' variable is
-    changed.
-
-c.  MS-DOS systems now use ~/_inputrc as the last-ditch inputrc filename.
-
-d.  MS-DOS systems now use ~/_history as the default history file.
-
-e.  history-search-{forward,backward} now leave the point at the end of the
-    line when the string to search for is empty, like
-    {reverse,forward}-search-history.
-
-f.  history-search-{forward,backward} now leave the last history line found
-    in the readline buffer if the second or subsequent search fails.
-
-g.  New function for use by applications:  rl_on_new_line_with_prompt, used
-    when an application displays the prompt itself before calling readline().
-
-h.  New variable for use by applications:  rl_already_prompted.  An application
-    that displays the prompt itself before calling readline() must set this to
-    a non-zero value.
-
-i.  A new variable, rl_gnu_readline_p, always 1.  The intent is that an
-    application can verify whether or not it is linked with the `real'
-    readline library or some substitute.
-
-j.  Per Bothner's `rlfe' (pronounced `Ralphie') readline front-end program
-    is included in the examples subdirectory, though it is not built
-    by default.
-
--------------------------------------------------------------------------------
-This document details the changes between this version, readline-4.0,
-and the previous version, readline-2.2.
-
-1.  Changes to Readline
-
-a.  The version number is now 4.0, to match the major and minor version
-    numbers on the shared readline and history libraries.  Future
-    releases will maintain the identical numbering.
-
-b.  Fixed a typo in the `make install' recipe that copied libreadline.a
-    to libhistory.old right after installing it.
-
-c.  The readline and history info files are now installed out of the source
-    directory if they are not found in the build directory.
-
-d.  The library no longer exports a function named `savestring' -- backwards
-    compatibility be damned.
-
-e.  There is no longer any #ifdef SHELL code in the source files.
-
-f.  Some changes were made to the key binding code to fix memory leaks and
-    better support Win32 systems.
-
-g.  Fixed a silly typo in the paren matching code -- it's microseconds, not
-    milliseconds.
-
-h.  The readline library should be compilable by C++ compilers.
-
-i.  The readline.h public header file now includes function prototypes for
-    all readline functions, and some changes were made to fix errors in the
-    source files uncovered by the use of prototypes.
-
-j.  The maximum numeric argument is now clamped at 1000000.
-
-k.  Fixes to rl_yank_last_arg to make it behave better.
-
-l.  Fixed a bug in the display code that caused core dumps if the prompt
-    string length exceeded 1024 characters.
-
-m.  The menu completion code was fixed to properly insert a single completion
-    if there is only one match.
-
-n.  A bug was fixed that caused the display code to improperly display tabs
-    after newlines.
-
-o.  A fix was made to the completion code in which a typo caused the wrong
-    value to be passed to the function that computed the longest common
-    prefix of the list of matches.
-
-p.  The completion code now checks the value of rl_filename_completion_desired,
-    which is set by application-supplied completion functions to indicate
-    that filename completion is being performed, to decide whether or not to
-    call an application-supplied `ignore completions' function.
-
-q.  Code was added to the history library to catch history substitutions
-    using `&' without a previous history substitution or search having been
-    performed.
-
-
-2.  New Features in Readline
-
-a.  There is a new script, support/shobj-conf, to do system-specific shared
-    object and library configuration.  It generates variables for configure
-    to substitute into makefiles.  The README file provides a detailed
-    explanation of the shared library creation process.
-
-b.  Shared libraries and objects are now built in the `shlib' subdirectory.
-    There is a shlib/Makefile.in to control the build process.  `make shared'
-    from the top-level directory is still the right way to build shared
-    versions of the libraries.
-
-c.  rlconf.h is now installed, so applications can find out which features
-    have been compiled into the installed readline and history libraries.
-
-d.  rlstdc.h is now an installed header file.
-
-e.  Many changes to the signal handling:
-        o Readline now catches SIGQUIT and cleans up the tty before returning;
-        o A new variable, rl_catch_signals, is available to application writers 
-          to indicate to readline whether or not it should install its own
-          signal handlers for SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP,
-          SIGTTIN, and SIGTTOU;
-        o A new variable, rl_catch_sigwinch, is available to application
-          writers to indicate to readline whether or not it should install its
-          own signal handler for SIGWINCH, which will chain to the calling
-          applications's SIGWINCH handler, if one is installed;
-        o There is a new function, rl_free_line_state, for application signal
-          handlers to call to free up the state associated with the current
-          line after receiving a signal;
-        o There is a new function, rl_cleanup_after_signal, to clean up the
-          display and terminal state after receiving a signal;
-        o There is a new function, rl_reset_after_signal, to reinitialize the
-          terminal and display state after an application signal handler
-          returns and readline continues
-
-f.  There is a new function, rl_resize_terminal, to reset readline's idea of
-    the screen size after a SIGWINCH.
-
-g.  New public functions: rl_save_prompt and rl_restore_prompt.  These were
-    previously private functions with a `_' prefix.  These functions are
-    used when an application wants to write a message to the `message area'
-    with rl_message and have the prompt restored correctly when the message
-    is erased.
-
-h.  New function hook: rl_pre_input_hook, called just before readline starts
-    reading input, after initialization.
-
-i.  New function hook: rl_display_matches_hook, called when readline would
-    display the list of completion matches.  The new function
-    rl_display_match_list is what readline uses internally, and is available
-    for use by application functions called via this hook.
-
-j.  New bindable function, delete-char-or-list, like tcsh.
-
-k.  A new variable, rl_erase_empty_line, which, if set by an application using
-    readline, will cause readline to erase, prompt and all, lines on which the
-    only thing typed was a newline.
-
-l.  There is a new script, support/shlib-install, to install and uninstall
-    the shared readline and history libraries.
-
-m.  A new bindable variable, `isearch-terminators', which is a string
-    containing the set of characters that should terminate an incremental
-    search without being executed as a command.
-
-n.  A new bindable function, forward-backward-delete-char.
-
--------------------------------------------------------------------------------
-This document details the changes between this version, readline-2.2,
-and the previous version, readline-2.1.
-
-1.  Changes to Readline
-
-a.  Added a missing `extern' to a declaration in readline.h that kept
-    readline from compiling cleanly on some systems.
-
-b.  The history file is now opened with mode 0600 when it is written for
-    better security.
-
-c.  Changes were made to the SIGWINCH handling code so that prompt redisplay
-    is done better.
-
-d.  ^G now interrupts incremental searches correctly.
-
-e.  A bug that caused a core dump when the set of characters to be quoted
-    when completing words was empty was fixed.
-
-f.  Fixed a problem in the readline test program rltest.c that caused a core
-    dump.
-
-g.  The code that handles parser directives in inputrc files now displays
-    more error messages.
-
-h.  The history expansion code was fixed so that the appearance of the
-    history comment character at the beginning of a word inhibits history
-    expansion for that word and the rest of the input line.
-
-i.  The code that prints completion listings now behaves better if one or
-    more of the filenames contains non-printable characters.
-
-j.  The time delay when showing matching parentheses is now 0.5 seconds.
-
-
-2.  New Features in Readline
-
-a.  There is now an option for `iterative' yank-last-arg handline, so a user
-    can keep entering `M-.', yanking the last argument of successive history
-    lines.
-
-b.  New variable, `print-completions-horizontally', which causes completion
-    matches to be displayed across the screen (like `ls -x') rather than up
-    and down the screen (like `ls').
-
-c.  New variable, `completion-ignore-case', which causes filename completion
-    and matching to be performed case-insensitively.
-
-d.  There is a new bindable command, `magic-space', which causes history
-    expansion to be performed on the current readline buffer and a space to
-    be inserted into the result.
-
-e.  There is a new bindable command, `menu-complete', which enables tcsh-like
-    menu completion (successive executions of menu-complete insert a single
-    completion match, cycling through the list of possible completions).
-
-f.  There is a new bindable command, `paste-from-clipboard', for use on Win32
-    systems, to insert the text from the Win32 clipboard into the editing
-    buffer.
-
-g.  The key sequence translation code now understands printf-style backslash
-    escape sequences, including \NNN octal escapes.  These escape sequences
-    may be used in key sequence definitions or macro values.
-
-h.  An `$include' inputrc file parser directive has been added.
diff --git a/readline/COPYING b/readline/COPYING
deleted file mode 100644
--- a/readline/COPYING
+++ /dev/null
@@ -1,339 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                          59 Temple Place, Suite 330, Boston, MA 02111 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	Appendix: How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) 19yy  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) 19yy name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
diff --git a/readline/ChangeLog b/readline/ChangeLog
deleted file mode 100644
--- a/readline/ChangeLog
+++ /dev/null
@@ -1,480 +0,0 @@
-2001-04-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* Update to readline-4.2.
-
-2001-03-08  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* Makefile.in (install, uninstall): For Octave, do nothing.
-
-	* Update to readline-4.2-beta2.
-
-2001-02-07  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* skip-autoheader: New file.
-
-2001-02-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* terminal.c (rl_get_screen_size): New function.
-	* readline.h: Provide declaration.
-
-	* Makefile.in (install, uninstall): For Octave, do nothing.
-
-	* Update to readline-4.2-beta1.
-
-2000-02-25  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* support/config.guess: Update to latest from subversions.gnu.org.
-	* support/config.sub: Likewise.  Recognize sv1-cray as a basic_machine.
-
-2000-01-26  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* acconfig.h: Use #undef GWINSZ_IN_SYS_IOCTL, not
-	TIOCGWINSZ_IN_SYS_IOCTL to match AC_DEFINE in aclocal.m4.
-
-1999-10-13  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* terminal.c (rl_resize_terminal): Import from readline 4.0.
-
-Thu May 27 21:47:26 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* histfile.c [__CYGWIN__]: Define O_BINARY if not already defined.
-
-Mon Aug 31 12:07:02 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* config.sub: Accept armv4 everywhere arm is allowed.
-
-Wed Mar  4 14:59:11 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* parens.c (rl_insert_close): Make time delay for showing matching
-	parentheses 0.5 seconds.
-
-Sun Jan 25 02:19:15 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* aclocal.m4 (BASH_REINSTALL_SIGHANDLERS, BASH_FUNC_STRCOLL):
-	Provide defaults for cross compiling.
-
-Fri Jan 16 21:02:58 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* Makefile.in (install, uninstall): For Octave, do nothing.
-
-Tue Jan 13 14:59:56 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* readline.h (rl_dispatching): Add missing extern in declaration.
-
-Thu Jul 10 18:26:56 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* acconfig.h: Add #undefs for FIONREAD_IN_SYS_IOCTL,
-	HAVE_BSD_SIGNALS, HAVE_LSTAT, HAVE_POSIX_SIGNALS,
-	HAVE_POSIX_SIGSETJMP, HAVE_USG_SIGHOLD,
-	MUST_REINSTALL_SIGHANDLERS, SPEED_T_IN_SYS_TYPES, STRCOLL_BROKEN,
-	STRUCT_DIRENT_HAS_D_FILENO, and STRUCT_DIRENT_HAS_D_INO.
-
-Thu May 22 16:00:10 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
-
-	* history.h, readline.h [__cplusplus]: Add extern "C" declarations.
-
-	* rlconf.h: Enable paren matching.
-
-Tue Mar 23 14:36:51 1993  Brian Fox  (bfox@eos.crseo.ucsb.edu)
-
-	* readline.c (rl_copy): Changed name to rl_copy_text.
-
-Mon Mar 22 19:16:05 1993  Brian Fox  (bfox@eos.crseo.ucsb.edu)
-
-	* dispose_cmd.c, several other files. Declare dispose_xxx () as
-	"void".
-
-	* builtins/hashcom.h: Make declarations of hashed_filenames be
-	"extern" to keep the SGI compiler happy.
-
-	* readline.c (rl_initialize_everything): Assign values to
-	out_stream and in_stream immediately, since
-	output_character_function () can be called before
-	readline_internal () is called.
-
-Tue Dec  8 09:30:56 1992  Brian Fox  (bfox@cubit)
-
-	* readline.c (rl_init_terminal) Set PC from BC, not from *buffer.
-
-Mon Nov 30 09:35:47 1992  Brian Fox  (bfox@cubit)
-
-	* readline.c (invoking_keyseqs_in_map, rl_parse_and_bind) Allow
-	backslash to quote characters, such as backslash, double quote,
-	and space. Backslash quotes all character indiscriminately.
-
-	* funmap.c (vi_keymap) Fix type in "vi-replace" declaration.
-
-Fri Nov 20 10:55:05 1992  Brian Fox  (bfox@cubit)
-
-	* readline.c (init_terminal_io, rl_prep_terminal): FINALLY!
-	Declare and use termcap variable `ospeed' when setting up terminal
-	parameters.
-
-Thu Oct  8 08:53:07 1992  Brian J. Fox  (bfox@helios)
-
-	* Makefile, this directory: Include (as links to the canonical
-	sources), tilde.c, tilde.h, posixstat.h and xmalloc.c.
-
-Tue Sep 29 13:07:21 1992  Brian J. Fox  (bfox@helios)
-
-	* readline.c (init_terminal_io) Don't set arrow keys if the key
-	sequences that represent them are already set.
-
-	* readline.c (rl_function_of_keyseq) New function returns the first
-	function (or macro) found while searching a key sequence.
-
-Mon Sep 28 00:34:04 1992  Brian J. Fox  (bfox@helios)
-
-	* readline.c (LibraryVersion) New static char * contains current
-	version number.  Version is at 2.0.
-
-	* readline.c (rl_complete_internal): Incorporated clean changes
-	from gilmore (gnu@cygnus.com) to support quoted substrings within
-	completion functions.
-
-	* readline.c (many locations) Added support for the _GO32_,
-	whatever that is.  Patches supplied by Cygnus, typed in by hand,
-	with cleanups.
-
-Sun Aug 16 12:46:24 1992  Brian Fox  (bfox@cubit)
-
-	* readline.c (init_terminal_io): Find out the values of the keypad
-	arrows and bind them to appropriate RL functions if present.
-
-Mon Aug 10 18:13:24 1992  Brian Fox  (bfox@cubit)
-
-	* history.c (stifle_history): A negative argument to stifle
-	becomes zero.
-
-Tue Jul 28 09:28:41 1992  Brian Fox  (bfox@cubit)
-
-	* readline.c (rl_variable_bind): New local structure describes
-	booleans by name and address; code in rl_variable_bind () looks at
-	structure to set simple variables.
-
-	* parens.c (rl_insert_close): New variable rl_blink_matching_paren
-	is non-zero if we want to blink the matching open when a close is
-	inserted.  If FD_SET is defined, rl_blink_matching_paren defaults
-	to 1, else 0.  If FD_SET is not defined, and
-	rl_blink_matching_paren is non-zero, the close character(s) are/is
-	simply inserted.
-
-Wed Jul 22 20:03:59 1992  Brian Fox  (bfox@cubit)
-
-	* history.c, readline.c, vi_mode.c: Cause the functions strchr ()
-	and strrchr () to be used instead of index () and rindex ()
-	throughout the source.
-
-Mon Jul 13 11:34:07 1992  Brian Fox  (bfox@cubit)
-
-	* readline.c: (rl_variable_bind) New variable "meta-flag" if "on"
-	means force the use of the 8th bit as Meta bit.  Internal variable
-	is called meta_flag.
-
-Thu Jul  9 10:37:56 1992  Brian Fox  (bfox@cubit)
-
-	* history.c (get_history_event) Change INDEX to LOCAL_INDEX.  If
-	compiling for the shell, allow shell metacharacters to separate
-	history tokens as they would for shell tokens.
-
-Sat Jul  4 19:29:12 1992  Brian Fox  (bfox@cubit)
-
-	* vi_keymap.c: According to Posix, TAB self-inserts instead of
-	doing completion.
-
-	* vi_mode.c: (rl_vi_yank_arg) Enter VI insert mode after yanking
-	an arg from the previous line.
-
-	* search.c: New file takes over vi style searching and implements
-	non-incremental searching the history.
-
-	Makefile: Add search.c and search.o.
-
-	funmap.c: Add names for non-incremental-forward-search-history and
-	non-incremental-reverse-search-history.
-
-	readline.h: Add extern definitions for non-incremental searching.
-
-	vi_mode.c: Remove old search code; add calls to code in search.c.
-
-Fri Jul  3 10:36:33 1992  Brian Fox  (bfox@cubit)
-
-	* readline.c (rl_delete_horizontal_space); New function deletes
-	all whitespace surrounding point.
-
-	funmap.c: Add "delete-horizontal-space".
-	emacs_keymap.c: Put rl_delete_horizontal_space () on M-\.
-
-	* readline.c (rl_set_signals, rl_clear_signals); New function
-	rl_set_sighandler () is either defined in a Posix way (if
-	HAVE_POSIX_SIGNALS is defined) or in a BSD way.  Function is
-	called from rl_set_signals () and rl_clear_signals ().
-
-Fri May  8 12:50:15 1992  Brian Fox  (bfox@cubit)
-
-	* readline.c: (readline_default_bindings) Do comparisons with
-	_POSIX_VDISABLE casted to `unsigned char'.  Change tty characters
-	to be unsigned char.
-
-Thu Apr 30 12:36:35 1992  Brian Fox  (bfox@cubit)
-
-	* readline.c: (rl_getc) Handle "read would block" error on
-	non-blocking IO streams.
-
-	* readline.c: (rl_signal_handler): Unblock only the signal that we
-	have caught, not all signals.
-
-Sun Feb 23 03:33:09 1992  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c: Many functions.  Use only the macros META_CHAR and
-	UNMETA to deal with meta characters.  Prior to this, we used
-	numeric values and tests.
-
-	* readline.c (rl_complete_internal) Report exactly the number of
-	possible completions, not the number + 1.
-
-	* vi_mode.c (rl_do_move) Do not change the cursor position when
-	using `cw' or `cW'.
-
-	* vi_mode.c (rl_vi_complete) Enter insert mode after completing
-	with `*' or `\'.
-
-Fri Feb 21 05:58:18 1992  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c (rl_dispatch) Increment rl_key_sequence_length for
-	meta characters that map onto ESC map.
-
-Mon Feb 10 01:41:35 1992  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* history.c (history_do_write) Build a buffer of all of the lines
-	to write and write them in one fell swoop (lower overhead than
-	calling write () for each line).  Suggested by Peter Ho.
-
-	* readline.c: Include hbullx20 as well as hpux for determining
-	USGr3ness.
-
-	* readline.c (rl_unix_word_rubout) As per the "Now REMEMBER"
-	comment, pass arguments to rl_kill_text () in the correct order to
-	preserve prepending and appending of killed text.
-
-	* readline.c (rl_search_history) malloc (), realloc (), and free
-	() SEARCH_STRING so that there are no static limits on searching.
-
-	* vi_mode.c (rl_vi_subst) Don't forget to end the undo group.
-
-Fri Jan 31 14:51:02 1992  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c (rl_signal_handler): Zero the current history entry's
-	pointer after freeing the undo_list when SIGINT received.
-	Reformat a couple of functions.
-
-Sat Jan 25 13:47:35 1992  Brian Fox  (bfox at bears)
-
-        * readline.c (parser_if): free () TNAME after use.
-
-Tue Jan 21 01:01:35 1992  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c (rl_redisplay) and (rl_character_len): Display
-	Control characters as "^c" and Meta characters as "\234", instead
-	of "C-C" and "M-C".
-
-Sun Dec 29 10:59:00 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c (init_terminal_io) Default to environment variables
-	LINES and COLUMNS before termcap entry values.  If all else fails,
-	then assume 80x24 terminal.
-
-Sat Dec 28 16:33:11 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c: If this machine is USG and it is hpux, then define
-	USGr3.
-
-	* history.c: Cosmetic fixes.
-
-Thu Nov 21 00:10:12 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* vi_mode.c: (rl_do_move) Place cursor at end of line, never at
-	next to last character.
-
-Thu Nov 14 05:08:01 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* history.c (get_history_event) Non-anchored searches can have a
-	return index of greater than zero from get_history_event ().
-
-Fri Nov  1 07:02:13 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c (rl_translate_keyseq) Make C-? translate to RUBOUT
-	unconditionally.
-
-Mon Oct 28 11:34:52 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c; Use Posix directory routines and macros.
-
-	* funmap.c; Add entry for call-last-kbd-macro.
-
-	* readline.c (rl_prep_term); Use system EOF character on POSIX
-	systems also.
-
-Thu Oct  3 16:19:53 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c; Make a distinction between having a TERMIOS tty
-	driver, and having POSIX signal handling.  You might one without
-	the other.  New defines used HAVE_POSIX_SIGNALS, and
-	TERMIOS_TTY_DRIVER.
-
-Tue Jul 30 22:37:26 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c: rl_getc () If a call to read () returns without an
-	error, but with zero characters, the file is empty, so return EOF.
-
-Thu Jul 11 20:58:38 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c: (rl_get_next_history, rl_get_previous_history)
-	Reallocate the buffer space if the line being moved to is longer
-	the the current space allocated.  Amazing that no one has found
-	this bug until now.
-
-Sun Jul  7 02:37:05 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c:(rl_parse_and_bind) Allow leading whitespace.
-	  Make sure TERMIO and TERMIOS systems treat CR and NL
-	  disctinctly.
-	
-Tue Jun 25 04:09:27 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c: Rework parsing conditionals to pay attention to the
-	prior states of the conditional stack.  This makes $if statements
-	work correctly.
-
-Mon Jun 24 20:45:59 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c: support for displaying key binding information
-	includes the functions rl_list_funmap_names (),
-	invoking_keyseqs_in_map (), rl_invoking_keyseqs (),
-	rl_dump_functions (), and rl_function_dumper ().
-
-	funmap.c: support for same includes rl_funmap_names ().
-
-	readline.c, funmap.c: no longer define STATIC_MALLOC.  However,
-	update both version of xrealloc () to handle a null pointer.
-
-Thu Apr 25 12:03:49 1991  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* vi_mode.c (rl_vi_fword, fWord, etc.  All functions use
-	the macro `isident()'.  Fixed movement bug which prevents
-	continious movement through the text.
-
-Fri Jul 27 16:47:01 1990  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c (parser_if) Allow "$if term=foo" construct.
-
-Wed May 23 16:10:33 1990  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c (rl_dispatch) Correctly remember the last command
-	executed.  Fixed typo in username_completion_function ().
-
-Mon Apr  9 19:55:48 1990  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c: username_completion_function (); For text passed in
-	with a leading `~', remember that this could be a filename (after
-	it is completed).
-
-Thu Apr  5 13:44:24 1990  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c: rl_search_history (): Correctly handle case of an
-	unfound search string, but a graceful exit (as with ESC).
-
-	* readline.c: rl_restart_output ();  The Apollo passes the address
-	of the file descriptor to TIOCSTART, not the descriptor itself.
-
-Tue Mar 20 05:38:55 1990  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* readline.c: rl_complete (); second call in a row causes possible
-	completions to be listed.
-
-	* readline.c: rl_redisplay (), added prompt_this_line variable
-	which is the first character character following \n in prompt.
-
-Sun Mar 11 04:32:03 1990  Brian Fox  (bfox at gnuwest.fsf.org)
-
-	* Signals are now supposedly handled inside of SYSV compilation.
-
-Wed Jan 17 19:24:09 1990  Brian Fox  (bfox at sbphy.ucsb.edu)
-
-	* history.c: history_expand (); fixed overwriting memory error,
-	added needed argument to call to get_history_event ().
-
-Thu Jan 11 10:54:04 1990  Brian Fox  (bfox at sbphy.ucsb.edu)
-
-	* readline.c: added mark_modified_lines to control the
-	display of an asterisk on modified history lines.  Also
-	added a user variable called mark-modified-lines to the
-	`set' command.
-
-Thu Jan  4 10:38:05 1990  Brian Fox  (bfox at sbphy.ucsb.edu)
-
-	* readline.c: start_insert ().  Only use IC if we don't have an im
-	capability.
-
-Fri Sep  8 09:00:45 1989  Brian Fox  (bfox at aurel)
-
-	* readline.c: rl_prep_terminal ().  Only turn on 8th bit
-	  as meta-bit iff the terminal is not using parity.
-
-Sun Sep  3 08:57:40 1989  Brian Fox  (bfox at aurel)
-
-	* readline.c: start_insert ().  Uses multiple
-	  insertion call in cases where that makes sense.
-
-	  rl_insert ().  Read type-ahead buffer for additional
-	  keys that are bound to rl_insert, and insert them
-	  all at once.  Make insertion of single keys given
-	  with an argument much more efficient.
-
-Tue Aug  8 18:13:57 1989  Brian Fox  (bfox at aurel)
-
-	* readline.c: Changed handling of EOF.  readline () returns
-	 (char *)EOF or consed string.  The EOF character is read from the
-	 tty, or if the tty doesn't have one, defaults to C-d.
-
-	* readline.c: Added support for event driven programs.
-	  rl_event_hook is the address of a function you want called
-	  while Readline is waiting for input.
-
-	* readline.c: Cleanup time.  Functions without type declarations
-	  do not use return with a value.
-
-	* history.c: history_expand () has new variable which is the
-	  characters to ignore immediately following history_expansion_char.
-
-Sun Jul 16 08:14:00 1989  Brian Fox  (bfox at aurel)
-
-	* rl_prep_terminal ()
-	  BSD version turns off C-s, C-q, C-y, C-v.
-
-	* readline.c -- rl_prep_terminal ()
-	  SYSV version hacks readline_echoing_p.
-	  BSD version turns on passing of the 8th bit for the duration
-	  of reading the line.
-
-Tue Jul 11 06:25:01 1989  Brian Fox  (bfox at aurel)
-
-	* readline.c: new variable rl_tilde_expander.
-	  If non-null, this contains the address of a function to call if
-	  the standard meaning for expanding a tilde fails.  The function is
-	  called with the text sans tilde (as in "foo"), and returns a
-	  malloc()'ed string which is the expansion, or a NULL pointer if
-	  there is no expansion. 
-
-	* readline.h - new file chardefs.h
-	  Separates things that only readline.c needs from the standard
-	  header file publishing interesting things about readline.
-
-	* readline.c:
-	  readline_default_bindings () now looks at terminal chararacters
-	  and binds those as well.
-
-Wed Jun 28 20:20:51 1989  Brian Fox  (bfox at aurel)
-
-	* Made readline and history into independent libraries.
-
diff --git a/readline/INSTALL b/readline/INSTALL
deleted file mode 100644
--- a/readline/INSTALL
+++ /dev/null
@@ -1,176 +0,0 @@
-Basic Installation
-==================
-
-   These are generic installation instructions.
-
-   The `configure' shell script attempts to guess correct values for
-various system-dependent variables used during compilation.  It uses
-those values to create a `Makefile' in each directory of the package.
-It may also create one or more `.h' files containing system-dependent
-definitions.  Finally, it creates a shell script `config.status' that
-you can run in the future to recreate the current configuration, a file
-`config.cache' that saves the results of its tests to speed up
-reconfiguring, and a file `config.log' containing compiler output
-(useful mainly for debugging `configure').
-
-   If you need to do unusual things to compile the package, please try
-to figure out how `configure' could check whether to do them, and mail
-diffs or instructions to the address given in the `README' so they can
-be considered for the next release.  If at some point `config.cache'
-contains results you don't want to keep, you may remove or edit it.
-
-   The file `configure.in' is used to create `configure' by a program
-called `autoconf'.  You only need `configure.in' if you want to change
-it or regenerate `configure' using a newer version of `autoconf'.
-
-The simplest way to compile this package is:
-
-  1. `cd' to the directory containing the package's source code and type
-     `./configure' to configure the package for your system.  If you're
-     using `csh' on an old version of System V, you might need to type
-     `sh ./configure' instead to prevent `csh' from trying to execute
-     `configure' itself.
-
-     Running `configure' takes awhile.  While running, it prints some
-     messages telling which features it is checking for.
-
-  2. Type `make' to compile the package.
-
-  3. Optionally, type `make check' to run any self-tests that come with
-     the package.
-
-  4. Type `make install' to install the programs and any data files and
-     documentation.
-
-  5. You can remove the program binaries and object files from the
-     source code directory by typing `make clean'.  To also remove the
-     files that `configure' created (so you can compile the package for
-     a different kind of computer), type `make distclean'.  There is
-     also a `make maintainer-clean' target, but that is intended mainly
-     for the package's developers.  If you use it, you may have to get
-     all sorts of other programs in order to regenerate files that came
-     with the distribution.
-
-Compilers and Options
-=====================
-
-   Some systems require unusual options for compilation or linking that
-the `configure' script does not know about.  You can give `configure'
-initial values for variables by setting them in the environment.  Using
-a Bourne-compatible shell, you can do that on the command line like
-this:
-     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure
-
-Or on systems that have the `env' program, you can do it like this:
-     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
-
-Compiling For Multiple Architectures
-====================================
-
-   You can compile the package for more than one kind of computer at the
-same time, by placing the object files for each architecture in their
-own directory.  To do this, you must use a version of `make' that
-supports the `VPATH' variable, such as GNU `make'.  `cd' to the
-directory where you want the object files and executables to go and run
-the `configure' script.  `configure' automatically checks for the
-source code in the directory that `configure' is in and in `..'.
-
-   If you have to use a `make' that does not supports the `VPATH'
-variable, you have to compile the package for one architecture at a time
-in the source code directory.  After you have installed the package for
-one architecture, use `make distclean' before reconfiguring for another
-architecture.
-
-Installation Names
-==================
-
-   By default, `make install' will install the package's files in
-`/usr/local/bin', `/usr/local/man', etc.  You can specify an
-installation prefix other than `/usr/local' by giving `configure' the
-option `--prefix=PATH'.
-
-   You can specify separate installation prefixes for
-architecture-specific files and architecture-independent files.  If you
-give `configure' the option `--exec-prefix=PATH', the package will use
-PATH as the prefix for installing programs and libraries.
-Documentation and other data files will still use the regular prefix.
-
-   If the package supports it, you can cause programs to be installed
-with an extra prefix or suffix on their names by giving `configure' the
-option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
-
-Optional Features
-=================
-
-   Some packages pay attention to `--enable-FEATURE' options to
-`configure', where FEATURE indicates an optional part of the package.
-They may also pay attention to `--with-PACKAGE' options, where PACKAGE
-is something like `gnu-as' or `x' (for the X Window System).  The
-`README' should mention any `--enable-' and `--with-' options that the
-package recognizes.
-
-   For packages that use the X Window System, `configure' can usually
-find the X include and library files automatically, but if it doesn't,
-you can use the `configure' options `--x-includes=DIR' and
-`--x-libraries=DIR' to specify their locations.
-
-Specifying the System Type
-==========================
-
-   There may be some features `configure' can not figure out
-automatically, but needs to determine by the type of host the package
-will run on.  Usually `configure' can figure that out, but if it prints
-a message saying it can not guess the host type, give it the
-`--host=TYPE' option.  TYPE can either be a short name for the system
-type, such as `sun4', or a canonical name with three fields:
-     CPU-COMPANY-SYSTEM
-
-See the file `config.sub' for the possible values of each field.  If
-`config.sub' isn't included in this package, then this package doesn't
-need to know the host type.
-
-   If you are building compiler tools for cross-compiling, you can also
-use the `--target=TYPE' option to select the type of system they will
-produce code for and the `--build=TYPE' option to select the type of
-system on which you are compiling the package.
-
-Sharing Defaults
-================
-
-   If you want to set default values for `configure' scripts to share,
-you can create a site shell script called `config.site' that gives
-default values for variables like `CC', `cache_file', and `prefix'.
-`configure' looks for `PREFIX/share/config.site' if it exists, then
-`PREFIX/etc/config.site' if it exists.  Or, you can set the
-`CONFIG_SITE' environment variable to the location of the site script.
-A warning: not all `configure' scripts look for a site script.
-
-Operation Controls
-==================
-
-   `configure' recognizes the following options to control how it
-operates.
-
-`--cache-file=FILE'
-     Use and save the results of the tests in FILE instead of
-     `./config.cache'.  Set FILE to `/dev/null' to disable caching, for
-     debugging `configure'.
-
-`--help'
-     Print a summary of the options to `configure', and exit.
-
-`--quiet'
-`--silent'
-`-q'
-     Do not print messages saying which checks are being made.
-
-`--srcdir=DIR'
-     Look for the package's source code in directory DIR.  Usually
-     `configure' can determine that directory automatically.
-
-`--version'
-     Print the version of Autoconf used to generate the `configure'
-     script, and exit.
-
-`configure' also accepts some other, not widely useful, options.
-
diff --git a/readline/MANIFEST b/readline/MANIFEST
deleted file mode 100644
--- a/readline/MANIFEST
+++ /dev/null
@@ -1,119 +0,0 @@
-#
-# Master distribution manifest for the standalone readline distribution
-#
-doc		d
-examples	d
-support		d
-shlib		d
-COPYING		f
-README		f
-MANIFEST	f
-INSTALL		f
-CHANGELOG	f
-CHANGES		f
-USAGE		f
-aclocal.m4	f
-config.h.in	f
-configure	f
-configure.in	f
-Makefile.in	f
-ansi_stdlib.h	f
-chardefs.h	f
-history.h	f
-histlib.h	f
-keymaps.h	f
-posixdir.h	f
-posixjmp.h	f
-posixstat.h	f
-readline.h	f
-rlconf.h	f
-rldefs.h	f
-rlprivate.h	f
-rlshell.h	f
-rlstdc.h	f
-rltty.h		f
-rltypedefs.h	f
-rlwinsize.h	f
-tcap.h		f
-tilde.h		f
-xmalloc.h	f
-bind.c		f
-compat.c	f
-complete.c	f
-display.c	f
-emacs_keymap.c	f
-funmap.c	f
-input.c		f
-isearch.c	f
-keymaps.c	f
-kill.c		f
-macro.c		f
-nls.c		f
-parens.c	f
-readline.c	f
-rltty.c		f
-savestring.c	f
-search.c	f
-shell.c		f
-signals.c	f
-terminal.c	f
-tilde.c		f
-undo.c		f
-util.c		f
-vi_keymap.c	f
-vi_mode.c	f
-callback.c	f
-xmalloc.c	f
-history.c	f
-histexpand.c	f
-histfile.c	f
-histsearch.c	f
-shlib/Makefile.in	f
-support/config.guess	f
-support/config.sub	f
-support/install.sh	f
-support/mkdirs		f
-support/mkdist		f
-support/shobj-conf	f
-support/shlib-install	f
-doc/Makefile.in		f
-doc/texinfo.tex		f
-doc/manvers.texinfo	f
-doc/rlman.texinfo	f
-doc/rltech.texinfo	f
-doc/rluser.texinfo	f
-doc/rluserman.texinfo	f
-doc/hist.texinfo	f
-doc/hstech.texinfo	f
-doc/hsuser.texinfo	f
-doc/readline.3		f
-doc/history.3		f
-doc/texi2dvi		f
-doc/texi2html		f
-examples/Makefile.in	f
-examples/excallback.c	f
-examples/fileman.c	f
-examples/manexamp.c	f
-examples/rlfe.c		f
-examples/rltest.c	f
-examples/rl.c		f
-examples/rlversion.c	f
-examples/histexamp.c	f
-examples/Inputrc	f
-# formatted documentation, from MANIFEST.doc
-doc/readline.ps		f
-doc/history.ps		f
-doc/rluserman.ps	f
-doc/readline.dvi	f
-doc/history.dvi		f
-doc/rluserman.dvi	f
-doc/readline.info	f
-doc/history.info	f
-doc/rluserman.info	f
-doc/readline.html	f
-doc/history.html	f
-doc/rluserman.html	f
-doc/readline.0		f
-doc/history.0		f
-doc/readline_3.ps	f
-doc/history_3.ps	f
diff --git a/readline/Makefile.in b/readline/Makefile.in
deleted file mode 100644
--- a/readline/Makefile.in
+++ /dev/null
@@ -1,466 +0,0 @@
-## -*- text -*- ##
-# Master Makefile for the GNU readline library.
-# Copyright (C) 1994 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-RL_LIBRARY_VERSION = @LIBVERSION@
-RL_LIBRARY_NAME = readline
-
-srcdir = @srcdir@
-VPATH = .:@srcdir@
-top_srcdir = @top_srcdir@
-BUILD_DIR = @BUILD_DIR@
-
-INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
-
-CC = @CC@
-RANLIB = @RANLIB@
-AR = @AR@
-ARFLAGS = @ARFLAGS@
-RM = rm -f
-CP = cp
-MV = mv
-
-@SET_MAKE@
-SHELL = @MAKE_SHELL@
-
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-libdir = @libdir@
-mandir = @mandir@
-includedir = @includedir@
-
-infodir = @infodir@
-
-man3dir = $(mandir)/man3
-
-# Programs to make tags files.
-ETAGS = etags -tw
-CTAGS = ctags -tw
-
-CFLAGS = @CFLAGS@
-LOCAL_CFLAGS = @LOCAL_CFLAGS@ -DRL_LIBRARY_VERSION='"$(RL_LIBRARY_VERSION)"'
-CPPFLAGS = @CPPFLAGS@
-
-DEFS = @DEFS@
-LOCAL_DEFS = @LOCAL_DEFS@
-
-TERMCAP_LIB = @TERMCAP_LIB@
-
-# For libraries which include headers from other libraries.
-INCLUDES = -I. -I$(srcdir) -I$(includedir)
-
-XCCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES)
-CCFLAGS = $(XCCFLAGS) $(LOCAL_CFLAGS) $(CFLAGS)
-
-# could add -Werror here
-GCC_LINT_FLAGS = -ansi -Wall -Wshadow -Wpointer-arith -Wcast-qual \
-		 -Wwrite-strings -Wstrict-prototypes \
-		 -Wmissing-prototypes -Wno-implicit
-GCC_LINT_CFLAGS = $(XCCFLAGS) $(GCC_LINT_FLAGS) @CFLAGS@ @LOCAL_CFLAGS@
-
-.c.o:
-	${RM} $@
-	$(CC) -c $(CCFLAGS) $<
-
-# The name of the main library target.
-LIBRARY_NAME = libreadline.a
-STATIC_LIBS = libreadline.a libhistory.a
-
-# The C code source files for this library.
-CSOURCES = $(srcdir)/readline.c $(srcdir)/funmap.c $(srcdir)/keymaps.c \
-	   $(srcdir)/vi_mode.c $(srcdir)/parens.c $(srcdir)/rltty.c \
-	   $(srcdir)/complete.c $(srcdir)/bind.c $(srcdir)/isearch.c \
-	   $(srcdir)/display.c $(srcdir)/signals.c $(srcdir)/emacs_keymap.c \
-	   $(srcdir)/vi_keymap.c $(srcdir)/util.c $(srcdir)/kill.c \
-	   $(srcdir)/undo.c $(srcdir)/macro.c $(srcdir)/input.c \
-	   $(srcdir)/callback.c $(srcdir)/terminal.c $(srcdir)/xmalloc.c \
-	   $(srcdir)/history.c $(srcdir)/histsearch.c $(srcdir)/histexpand.c \
-	   $(srcdir)/histfile.c $(srcdir)/nls.c $(srcdir)/search.c \
-	   $(srcdir)/shell.c $(srcdir)/savestring.c $(srcdir)/tilde.c \
-	   $(srcdir)/compat.c
-
-# The header files for this library.
-HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
-	   posixstat.h posixdir.h posixjmp.h tilde.h rlconf.h rltty.h \
-	   ansi_stdlib.h tcap.h rlstdc.h xmalloc.h rlprivate.h rlshell.h \
-	   rltypedefs.h
-
-HISTOBJ = history.o histexpand.o histfile.o histsearch.o shell.o 
-TILDEOBJ = tilde.o
-OBJECTS = readline.o vi_mode.o funmap.o keymaps.o parens.o search.o \
-	  rltty.o complete.o bind.o isearch.o display.o signals.o \
-	  util.o kill.o undo.o macro.o input.o callback.o terminal.o \
-	  nls.o compat.o xmalloc.o $(HISTOBJ) $(TILDEOBJ)
-
-# The texinfo files which document this library.
-DOCSOURCE = doc/rlman.texinfo doc/rltech.texinfo doc/rluser.texinfo
-DOCOBJECT = doc/readline.dvi
-DOCSUPPORT = doc/Makefile
-DOCUMENTATION = $(DOCSOURCE) $(DOCOBJECT) $(DOCSUPPORT)
-
-CREATED_MAKEFILES = Makefile doc/Makefile examples/Makefile shlib/Makefile
-CREATED_CONFIGURE = config.status config.h config.cache config.log \
-		    stamp-config stamp-h
-CREATED_TAGS = TAGS tags
-
-INSTALLED_HEADERS = readline.h chardefs.h keymaps.h history.h tilde.h \
-		    rlstdc.h rlconf.h rltypedefs.h
-
-##########################################################################
-
-all: static
-
-everything: static shared examples
-
-static: $(STATIC_LIBS)
-
-libreadline.a: $(OBJECTS)
-	$(RM) $@
-	$(AR) $(ARFLAGS) $@ $(OBJECTS)
-	-test -n "$(RANLIB)" && $(RANLIB) $@
-
-libhistory.a: $(HISTOBJ) xmalloc.o
-	$(RM) $@
-	$(AR) $(ARFLAGS) $@ $(HISTOBJ) xmalloc.o
-	-test -n "$(RANLIB)" && $(RANLIB) $@
-
-readline: $(OBJECTS) readline.h rldefs.h chardefs.h ./libreadline.a
-	$(CC) $(CCFLAGS) -o $@ ./examples/rl.c ./libreadline.a ${TERMCAP_LIB}
-
-lint:	force
-	$(MAKE) $(MFLAGS) CCFLAGS='$(GCC_LINT_CFLAGS)' static
-
-Makefile makefile: config.status $(srcdir)/Makefile.in
-	CONFIG_FILES=Makefile CONFIG_HEADERS= $(SHELL) ./config.status
-
-Makefiles makefiles: config.status $(srcdir)/Makefile.in
-	@for mf in $(CREATED_MAKEFILES); do \
-		CONFIG_FILES=$$mf CONFIG_HEADERS= $(SHELL) ./config.status ; \
-	done
-
-config.status: configure
-	$(SHELL) ./config.status --recheck
-
-config.h:	stamp-h
-
-stamp-h: config.status $(srcdir)/config.h.in
-	CONFIG_FILES= CONFIG_HEADERS=config.h ./config.status
-	echo > $@
-
-#$(srcdir)/configure: $(srcdir)/configure.in	## Comment-me-out in distribution
-#	cd $(srcdir) && autoconf	## Comment-me-out in distribution
-
-
-shared:	force
-	-test -d shlib || mkdir shlib
-	-( cd shlib ; ${MAKE} ${MFLAGS} all )
-
-documentation: force
-	-test -d doc || mkdir doc
-	-( cd doc && $(MAKE) $(MFLAGS) )
-
-examples: force
-	-test -d examples || mkdir examples
-	-(cd examples && ${MAKE} ${MFLAGS} all )
-
-force:
-
-install-headers: installdirs ${INSTALLED_HEADERS}
-	for f in ${INSTALLED_HEADERS}; do \
-		$(INSTALL_DATA) $(srcdir)/$$f $(includedir)/readline ; \
-	done
-
-uninstall-headers:
-	-test -n "$(includedir)" && cd $(includedir)/readline && \
-		${RM} ${INSTALLED_HEADERS}
-
-maybe-uninstall-headers: uninstall-headers
-
-install uninstall:
-
-#install: installdirs $(STATIC_LIBS) install-headers
-#	-$(MV) $(libdir)/libreadline.a $(libdir)/libreadline.old
-#	$(INSTALL_DATA) libreadline.a $(libdir)/libreadline.a
-#	-test -n "$(RANLIB)" && $(RANLIB) $(libdir)/libreadline.a
-#	-$(MV) $(libdir)/libhistory.a $(libdir)/libhistory.old
-#	$(INSTALL_DATA) libhistory.a $(libdir)/libhistory.a
-#	-test -n "$(RANLIB)" && $(RANLIB) $(libdir)/libhistory.a
-#	-( if test -d doc ; then \
-#		cd doc && \
-#		${MAKE} ${MFLAGS} infodir=$(infodir) $@; \
-#	  fi )
-
-installdirs: $(srcdir)/support/mkdirs
-	-$(SHELL) $(srcdir)/support/mkdirs $(includedir) \
-		$(includedir)/readline $(libdir) $(infodir) $(man3dir)
-
-#uninstall: uninstall-headers
-#	-test -n "$(libdir)" && cd $(libdir) && \
-#		${RM} libreadline.a libreadline.old libhistory.a libhistory.old $(SHARED_LIBS)
-
-install-shared: installdirs install-headers shared
-	-( cd shlib ; ${MAKE} ${MFLAGS} install )
-
-uninstall-shared: maybe-uninstall-headers
-	-( cd shlib; ${MAKE} ${MFLAGS} uninstall )
-
-TAGS:	force
-	$(ETAGS) $(CSOURCES) $(HSOURCES)
-
-tags:	force
-	$(CTAGS) $(CSOURCES) $(HSOURCES)
-
-clean:	force
-	$(RM) $(OBJECTS) $(STATIC_LIBS)
-	$(RM) readline readline.exe
-	-( cd shlib && $(MAKE) $(MFLAGS) $@ )
-	-( cd doc && $(MAKE) $(MFLAGS) $@ )
-	-( cd examples && $(MAKE) $(MFLAGS) $@ )
-
-mostlyclean: clean
-	-( cd shlib && $(MAKE) $(MFLAGS) $@ )
-	-( cd doc && $(MAKE) $(MFLAGS) $@ )
-	-( cd examples && $(MAKE) $(MFLAGS) $@ )
-
-distclean maintainer-clean: clean
-	-( cd shlib && $(MAKE) $(MFLAGS) $@ )
-	-( cd doc && $(MAKE) $(MFLAGS) $@ )
-	-( cd examples && $(MAKE) $(MFLAGS) $@ )
-	$(RM) Makefile
-	$(RM) $(CREATED_CONFIGURE)
-	$(RM) $(CREATED_TAGS)
-
-info dvi:
-	-( cd doc && $(MAKE) $(MFLAGS) $@ )
-
-install-info:
-check:
-installcheck:
-
-dist:   force
-	@echo Readline distributions are created using $(srcdir)/support/mkdist.
-	@echo Here is a sample of the necessary commands:
-	@echo bash $(srcdir)/support/mkdist -m $(srcdir)/MANIFEST -s $(srcdir) -r $(RL_LIBRARY_NAME) $(RL_LIBRARY_VERSION)
-	@echo tar cf $(RL_LIBRARY_NAME)-${RL_LIBRARY_VERSION}.tar ${RL_LIBRARY_NAME}-$(RL_LIBRARY_VERSION)
-	@echo gzip $(RL_LIBRARY_NAME)-$(RL_LIBRARY_VERSION).tar
-
-# Tell versions [3.59,3.63) of GNU make not to export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
-
-# Dependencies
-bind.o: ansi_stdlib.h posixstat.h
-bind.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-bind.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
-bind.o: history.h
-callback.o: rlconf.h
-callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-callback.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
-compat.o: rlstdc.h
-complete.o: ansi_stdlib.h posixdir.h posixstat.h
-complete.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-complete.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
-display.o: ansi_stdlib.h posixstat.h
-display.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-display.o: tcap.h
-display.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-display.o: history.h rlstdc.h
-funmap.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-funmap.o: rlconf.h ansi_stdlib.h rlstdc.h
-funmap.o: ${BUILD_DIR}/config.h
-histexpand.o: ansi_stdlib.h
-histexpand.o: history.h histlib.h rlstdc.h rltypedefs.h
-histexpand.o: ${BUILD_DIR}/config.h
-histfile.o: ansi_stdlib.h
-histfile.o: history.h histlib.h rlstdc.h rltypedefs.h
-histfile.o: ${BUILD_DIR}/config.h
-history.o: ansi_stdlib.h
-history.o: history.h histlib.h rlstdc.h rltypedefs.h
-history.o: ${BUILD_DIR}/config.h
-histsearch.o: ansi_stdlib.h
-histsearch.o: history.h histlib.h rlstdc.h rltypedefs.h
-histsearch.o: ${BUILD_DIR}/config.h
-input.o: ansi_stdlib.h
-input.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-input.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
-isearch.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-isearch.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-isearch.o: ansi_stdlib.h history.h rlstdc.h
-keymaps.o: emacs_keymap.c vi_keymap.c
-keymaps.o: keymaps.h rltypedefs.h chardefs.h rlconf.h ansi_stdlib.h
-keymaps.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-keymaps.o: ${BUILD_DIR}/config.h rlstdc.h
-kill.o: ansi_stdlib.h
-kill.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-kill.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-kill.o: history.h rlstdc.h
-macro.o: ansi_stdlib.h
-macro.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-macro.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-macro.o: history.h rlstdc.h
-nls.o: ansi_stdlib.h
-nls.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-nls.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h  
-nls.o: history.h rlstdc.h  
-parens.o: rlconf.h
-parens.o: ${BUILD_DIR}/config.h
-parens.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
-readline.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-readline.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-readline.o: history.h rlstdc.h
-readline.o: posixstat.h ansi_stdlib.h posixjmp.h
-rltty.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-rltty.o: rltty.h
-rltty.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
-search.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-search.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-search.o: ansi_stdlib.h history.h rlstdc.h
-shell.o: ${BUILD_DIR}/config.h
-shell.o: ansi_stdlib.h
-signals.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-signals.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-signals.o: history.h rlstdc.h
-terminal.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-terminal.o: tcap.h
-terminal.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-terminal.o: history.h rlstdc.h
-tilde.o: ansi_stdlib.h
-tilde.o: ${BUILD_DIR}/config.h
-tilde.o: tilde.h
-undo.o: ansi_stdlib.h
-undo.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-undo.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-undo.o: history.h rlstdc.h
-util.o: posixjmp.h ansi_stdlib.h
-util.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-util.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
-vi_mode.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-vi_mode.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
-vi_mode.o: history.h ansi_stdlib.h rlstdc.h
-xmalloc.o: ${BUILD_DIR}/config.h
-xmalloc.o: ansi_stdlib.h
-
-bind.o: rlshell.h
-histfile.o: rlshell.h
-nls.o: rlshell.h
-readline.o: rlshell.h
-shell.o: rlshell.h
-terminal.o: rlshell.h
-histexpand.o: rlshell.h
-
-bind.o: rlprivate.h
-callback.o: rlprivate.h
-complete.o: rlprivate.h
-display.o: rlprivate.h
-input.o: rlprivate.h
-isearch.o: rlprivate.h
-kill.o: rlprivate.h
-macro.o: rlprivate.h
-nls.o: rlprivate.h   
-parens.o: rlprivate.h
-readline.o: rlprivate.h
-rltty.o: rlprivate.h 
-search.o: rlprivate.h
-signals.o: rlprivate.h
-terminal.o: rlprivate.h
-undo.o: rlprivate.h
-util.o: rlprivate.h
-vi_mode.o: rlprivate.h
-
-bind.o: xmalloc.h
-complete.o: xmalloc.h
-display.o: xmalloc.h
-funmap.o: xmalloc.h
-histexpand.o: xmalloc.h
-histfile.o: xmalloc.h
-history.o: xmalloc.h
-input.o: xmalloc.h
-isearch.o: xmalloc.h
-keymaps.o: xmalloc.h
-kill.o: xmalloc.h
-macro.o: xmalloc.h
-readline.o: xmalloc.h
-savestring.o: xmalloc.h
-search.o: xmalloc.h
-shell.o: xmalloc.h
-tilde.o: xmalloc.h
-tilde.o: xmalloc.h
-util.o: xmalloc.h
-vi_mode.o: xmalloc.h
-
-readline.o: $(srcdir)/readline.c
-vi_mode.o: $(srcdir)/vi_mode.c
-funmap.o: $(srcdir)/funmap.c
-keymaps.o: $(srcdir)/keymaps.c
-parens.o: $(srcdir)/parens.c
-search.o: $(srcdir)/search.c
-rltty.o: $(srcdir)/rltty.c
-compat.o: $(srcdir)/compat.c
-complete.o: $(srcdir)/complete.c
-bind.o: $(srcdir)/bind.c
-isearch.o: $(srcdir)/isearch.c
-display.o: $(srcdir)/display.c
-signals.o: $(srcdir)/signals.c
-util.o: $(srcdir)/util.c
-kill.o: $(srcdir)/kill.c
-undo.o: $(srcdir)/undo.c
-macro.o: $(srcdir)/macro.c
-input.o: $(srcdir)/input.c
-callback.o: $(srcdir)/callback.c
-terminal.o: $(srcdir)/terminal.c
-nls.o: $(srcdir)/nls.c
-xmalloc.o: $(srcdir)/xmalloc.c
-history.o: $(srcdir)/history.c
-histexpand.o: $(srcdir)/histexpand.c
-histfile.o: $(srcdir)/histfile.c
-histsearch.o: $(srcdir)/histsearch.c
-savestring.o: $(srcdir)/savestring.c
-shell.o: $(srcdir)/shell.c
-tilde.o: $(srcdir)/tilde.c
-
-readline.o: readline.c
-vi_mode.o: vi_mode.c
-funmap.o: funmap.c
-keymaps.o: keymaps.c
-parens.o: parens.c
-search.o: search.c
-rltty.o: rltty.c
-compat.o: compat.c
-complete.o: complete.c
-bind.o: bind.c
-isearch.o: isearch.c
-display.o: display.c
-signals.o: signals.c
-util.o: util.c
-kill.o: kill.c
-undo.o: undo.c
-macro.o: macro.c
-input.o: input.c
-callback.o: callback.c
-terminal.o: terminal.c
-nls.o: nls.c
-xmalloc.o: xmalloc.c
-history.o: history.c
-histexpand.o: histexpand.c
-histfile.o: histfile.c
-histsearch.o: histsearch.c
-savestring.o: savestring.c
-shell.o: shell.c
-tilde.o: tilde.c
diff --git a/readline/README b/readline/README
deleted file mode 100644
--- a/readline/README
+++ /dev/null
@@ -1,166 +0,0 @@
-Introduction
-============
-
-This is the Gnu Readline library, version 4.2.
-
-The Readline library provides a set of functions for use by applications
-that allow users to edit command lines as they are typed in.  Both
-Emacs and vi editing modes are available.  The Readline library includes
-additional functions to maintain a list of previously-entered command
-lines, to recall and perhaps reedit those lines, and perform csh-like
-history expansion on previous commands.
-
-The history facilites are also placed into a separate library, the
-History library, as part of the build process.  The History library
-may be used without Readline in applications which desire its
-capabilities.
-
-The Readline library is free software, distributed under the terms of
-the GNU Public License, version 2.  For more information, see the file
-COPYING.
-
-To build the library, try typing `./configure', then `make'.  The
-configuration process is automated, so no further intervention should
-be necessary.  Readline builds with `gcc' by default if it is
-available.  If you want to use `cc' instead, type
-
-        CC=cc ./configure
-
-if you are using a Bourne-style shell.  If you are not, the following
-may work:
-
-        env CC=cc ./configure
-
-Read the file INSTALL in this directory for more information about how
-to customize and control the build process.
-
-The file rlconf.h contains C preprocessor defines that enable and disable
-certain Readline features.
-
-The special make target `everything' will build the static and shared
-libraries (if the target platform supports them) and the examples.
-
-Examples
-========
-
-There are several example programs that use Readline features in the
-examples directory.  The `rl' program is of particular interest.  It
-is a command-line interface to Readline, suitable for use in shell
-scripts in place of `read'.
-
-Shared Libraries
-================
-
-There is skeletal support for building shared versions of the
-Readline and History libraries.  The configure script creates
-a Makefile in the `shlib' subdirectory, and typing `make shared'
-will cause shared versions of the Readline and History libraries
-to be built on supported platforms.
-
-Configure calls the script support/shobj-conf to test whether or
-not shared library creation is supported and to generate the values
-of variables that are substituted into shlib/Makefile.  If you
-try to build shared libraries on an unsupported platform, `make'
-will display a message asking you to update support/shobj-conf for
-your platform.
-
-If you need to update support/shobj-conf, you will need to create
-a `stanza' for your operating system and compiler.  The script uses
-the value of host_os and ${CC} as determined by configure.  For
-instance, FreeBSD 4.2 using the ELF object file format  with any
-version of gcc is identified as `freebsdelf4.2-gcc*'.
-
-In the stanza for your operating system-compiler pair, you will need to
-define several variables.  They are:
-
-SHOBJ_CC	The C compiler used to compile source files into shareable
-		object files.  This is normally set to the value of ${CC}
-		by configure, and should not need to be changed.
-
-SHOBJ_CFLAGS	Flags to pass to the C compiler ($SHOBJ_CC) to create
-		position-independent code.  If you are using gcc, this
-		should probably be set to `-fpic'.
-
-SHOBJ_LD	The link editor to be used to create the shared library from
-		the object files created by $SHOBJ_CC.  If you are using
-		gcc, a value of `gcc' will probably work.
-
-SHOBJ_LDFLAGS	Flags to pass to SHOBJ_LD to enable shared object creation.
-		If you are using gcc, `-shared' may be all that is necessary.
-		These should be the flags needed for generic shared object
-		creation.
-
-SHLIB_XLDFLAGS	Additional flags to pass to SHOBJ_LD for shared library
-		creation.  Many systems use the -R option to the link
-		editor to embed a path within the library for run-time
-		library searches.  A reasonable value for such systems would
-		be `-R$(libdir)'.
-
-SHLIB_LIBS	Any additional libraries that shared libraries should be
-		linked against when they are created.
-
-SHLIB_LIBSUFF	The suffix to add to `libreadline' and `libhistory' when
-		generating the filename of the shared library.  Many systems
-		use `so'; HP-UX uses `sl'.
-
-SHLIB_LIBVERSION The string to append to the filename to indicate the version
-		of the shared library.  It should begin with $(SHLIB_LIBSUFF),
-		and possibly include version information that allows the
-		run-time loader to load the version of the shared library
-		appropriate for a particular program.  Systems using shared
-		libraries similar to SunOS 4.x use major and minor library
-		version numbers; for those systems a value of
-		`$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)' is appropriate.
-		Systems based on System V Release 4 don't use minor version
-		numbers; use `$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)' on those systems.
-		Other Unix versions use different schemes.
-
-SHLIB_STATUS	Set this to `supported' when you have defined the other
-		necessary variables.  Make uses this to determine whether
-		or not shared library creation should be attempted.
-
-You should look at the existing stanzas in support/shobj-conf for ideas.
-
-Once you have updated support/shobj-conf, re-run configure and type
-`make shared'.  The shared libraries will be created in the shlib
-subdirectory.
-
-Since shared libraries are not created on all platforms, `make install'
-will not automatically install the shared libraries.  To install them,
-change the current directory to shlib and type `make install'.  Running
-`make install-shared' from the top-level build directory will also work.
-
-Documentation
-=============
-
-The documentation for the Readline and History libraries appears in the
-`doc' subdirectory.  There are two texinfo files and a Unix-style manual
-page describing the programming facilities available in the Readline
-library.  The texinfo files include both user and programmer's manuals.
-
-Reporting Bugs
-==============
-
-Bug reports for Readline should be sent to:
-
-        bug-readline@gnu.org
-
-When reporting a bug, please include the following information:
-
-        * the version number and release status of Readline (e.g., 4.2-release)
-        * the machine and OS that it is running on
-        * a list of the compilation flags or the contents of `config.h', if
-          appropriate
-        * a description of the bug
-        * a recipe for recreating the bug reliably
-        * a fix for the bug if you have one!
-
-If you would like to contact the Readline maintainer directly, send mail
-to bash-maintainers@gnu.org.
-
-Since Readline is developed along with bash, the bug-bash@gnu.org mailing
-list (mirrored to the Usenet newsgroup gnu.bash.bug) often contains
-Readline bug reports and fixes. 
-
-Chet Ramey
-chet@po.cwru.edu
diff --git a/readline/USAGE b/readline/USAGE
deleted file mode 100644
--- a/readline/USAGE
+++ /dev/null
@@ -1,37 +0,0 @@
-From rms@gnu.org Thu Jul 22 20:37:55 1999
-Flags: 10
-Return-Path: rms@gnu.org
-Received: from arthur.INS.CWRU.Edu (root@arthur.INS.CWRU.Edu [129.22.8.215]) by odin.INS.CWRU.Edu with ESMTP (8.8.6+cwru/CWRU-2.4-ins)
-	id UAA25349; Thu, 22 Jul 1999 20:37:54 -0400 (EDT) (from rms@gnu.org for <chet@odin.INS.CWRU.Edu>)
-Received: from nike.ins.cwru.edu (root@nike.INS.CWRU.Edu [129.22.8.219]) by arthur.INS.CWRU.Edu with ESMTP (8.8.8+cwru/CWRU-3.6)
-	id UAA05311; Thu, 22 Jul 1999 20:37:51 -0400 (EDT) (from rms@gnu.org for <chet@po.cwru.edu>)
-Received: from pele.santafe.edu (pele.santafe.edu [192.12.12.119]) by nike.ins.cwru.edu with ESMTP (8.8.7/CWRU-2.5-bsdi)
-	id UAA13350; Thu, 22 Jul 1999 20:37:50 -0400 (EDT) (from rms@gnu.org for <chet@nike.ins.cwru.edu>)
-Received: from wijiji.santafe.edu (wijiji [192.12.12.5])
-	by pele.santafe.edu (8.9.1/8.9.1) with ESMTP id SAA10831
-	for <chet@nike.ins.cwru.edu>; Thu, 22 Jul 1999 18:37:47 -0600 (MDT)
-Received: (from rms@localhost)
-	by wijiji.santafe.edu (8.9.1b+Sun/8.9.1) id SAA01089;
-	Thu, 22 Jul 1999 18:37:46 -0600 (MDT)
-Date: Thu, 22 Jul 1999 18:37:46 -0600 (MDT)
-Message-Id: <199907230037.SAA01089@wijiji.santafe.edu>
-X-Authentication-Warning: wijiji.santafe.edu: rms set sender to rms@gnu.org using -f
-From: Richard Stallman <rms@gnu.org>
-To: chet@nike.ins.cwru.edu
-Subject: Use of Readline
-Reply-to: rms@gnu.org
-
-I think Allbery's suggestion is a good one.  So please add this text
-in a suitable place.  Please don't put it in the GPL itself; that
-should be the same as the GPL everywhere else.  Putting it in the
-README and/or the documentation would be a good idea.
-
-
-======================================================================
-Our position on the use of Readline through a shared-library linking
-mechanism is that there is no legal difference between shared-library
-linking and static linking--either kind of linking combines various
-modules into a single larger work.  The conditions for using Readline
-in a larger work are stated in section 3 of the GNU GPL.
-
-
diff --git a/readline/aclocal.m4 b/readline/aclocal.m4
deleted file mode 100644
--- a/readline/aclocal.m4
+++ /dev/null
@@ -1,1463 +0,0 @@
-dnl
-dnl Bash specific tests
-dnl
-dnl Some derived from PDKSH 5.1.3 autoconf tests
-dnl
-dnl
-dnl Check if dup2() does not clear the close on exec flag
-dnl
-AC_DEFUN(BASH_DUP2_CLOEXEC_CHECK,
-[AC_MSG_CHECKING(if dup2 fails to clear the close-on-exec flag)
-AC_CACHE_VAL(bash_cv_dup2_broken,
-[AC_TRY_RUN([
-#include <sys/types.h>
-#include <fcntl.h>
-main()
-{
-  int fd1, fd2, fl;
-  fd1 = open("/dev/null", 2);
-  if (fcntl(fd1, 2, 1) < 0)
-    exit(1);
-  fd2 = dup2(fd1, 1);
-  if (fd2 < 0)
-    exit(2);
-  fl = fcntl(fd2, 1, 0);
-  /* fl will be 1 if dup2 did not reset the close-on-exec flag. */
-  exit(fl != 1);
-}
-], bash_cv_dup2_broken=yes, bash_cv_dup2_broken=no,
-    [AC_MSG_WARN(cannot check dup2 if cross compiling -- defaulting to no)
-     bash_cv_dup2_broken=no])
-])
-AC_MSG_RESULT($bash_cv_dup2_broken)
-if test $bash_cv_dup2_broken = yes; then
-AC_DEFINE(DUP2_BROKEN)
-fi
-])
-
-dnl Check type of signal routines (posix, 4.2bsd, 4.1bsd or v7)
-AC_DEFUN(BASH_SIGNAL_CHECK,
-[AC_REQUIRE([AC_TYPE_SIGNAL])
-AC_MSG_CHECKING(for type of signal functions)
-AC_CACHE_VAL(bash_cv_signal_vintage,
-[
-  AC_TRY_LINK([#include <signal.h>],[
-    sigset_t ss;
-    struct sigaction sa;
-    sigemptyset(&ss); sigsuspend(&ss);
-    sigaction(SIGINT, &sa, (struct sigaction *) 0);
-    sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
-  ], bash_cv_signal_vintage=posix,
-  [
-    AC_TRY_LINK([#include <signal.h>], [
-	int mask = sigmask(SIGINT);
-	sigsetmask(mask); sigblock(mask); sigpause(mask);
-    ], bash_cv_signal_vintage=4.2bsd,
-    [
-      AC_TRY_LINK([
-	#include <signal.h>
-	RETSIGTYPE foo() { }], [
-		int mask = sigmask(SIGINT);
-		sigset(SIGINT, foo); sigrelse(SIGINT);
-		sighold(SIGINT); sigpause(SIGINT);
-        ], bash_cv_signal_vintage=svr3, bash_cv_signal_vintage=v7
-    )]
-  )]
-)
-])
-AC_MSG_RESULT($bash_cv_signal_vintage)
-if test "$bash_cv_signal_vintage" = posix; then
-AC_DEFINE(HAVE_POSIX_SIGNALS)
-elif test "$bash_cv_signal_vintage" = "4.2bsd"; then
-AC_DEFINE(HAVE_BSD_SIGNALS)
-elif test "$bash_cv_signal_vintage" = svr3; then
-AC_DEFINE(HAVE_USG_SIGHOLD)
-fi
-])
-
-dnl Check if the pgrp of setpgrp() can't be the pid of a zombie process.
-AC_DEFUN(BASH_PGRP_SYNC,
-[AC_REQUIRE([AC_FUNC_GETPGRP])
-AC_MSG_CHECKING(whether pgrps need synchronization)
-AC_CACHE_VAL(bash_cv_pgrp_pipe,
-[AC_TRY_RUN([
-#ifdef HAVE_UNISTD_H
-#  include <unistd.h>
-#endif
-main()
-{
-# ifdef GETPGRP_VOID
-#  define getpgID()	getpgrp()
-# else
-#  define getpgID()	getpgrp(0)
-#  define setpgid(x,y)	setpgrp(x,y)
-# endif
-	int pid1, pid2, fds[2];
-	int status;
-	char ok;
-
-	switch (pid1 = fork()) {
-	  case -1:
-	    exit(1);
-	  case 0:
-	    setpgid(0, getpid());
-	    exit(0);
-	}
-	setpgid(pid1, pid1);
-
-	sleep(2);	/* let first child die */
-
-	if (pipe(fds) < 0)
-	  exit(2);
-
-	switch (pid2 = fork()) {
-	  case -1:
-	    exit(3);
-	  case 0:
-	    setpgid(0, pid1);
-	    ok = getpgID() == pid1;
-	    write(fds[1], &ok, 1);
-	    exit(0);
-	}
-	setpgid(pid2, pid1);
-
-	close(fds[1]);
-	if (read(fds[0], &ok, 1) != 1)
-	  exit(4);
-	wait(&status);
-	wait(&status);
-	exit(ok ? 0 : 5);
-}
-], bash_cv_pgrp_pipe=no,bash_cv_pgrp_pipe=yes,
-   [AC_MSG_WARN(cannot check pgrp synchronization if cross compiling -- defaulting to no)
-    bash_cv_pgrp_pipe=no])
-])
-AC_MSG_RESULT($bash_cv_pgrp_pipe)
-if test $bash_cv_pgrp_pipe = yes; then
-AC_DEFINE(PGRP_PIPE)
-fi
-])
-
-dnl
-dnl check for typedef'd symbols in header files, but allow the caller to
-dnl specify the include files to be checked in addition to the default
-dnl 
-dnl BASH_CHECK_TYPE(TYPE, HEADERS, DEFAULT[, VALUE-IF-FOUND])
-AC_DEFUN(BASH_CHECK_TYPE,
-[AC_REQUIRE([AC_HEADER_STDC])dnl
-AC_MSG_CHECKING(for $1)
-AC_CACHE_VAL(bash_cv_type_$1,
-[AC_EGREP_CPP($1, [#include <sys/types.h>
-#if STDC_HEADERS
-#include <stdlib.h>
-#endif
-$2
-], bash_cv_type_$1=yes, bash_cv_type_$1=no)])
-AC_MSG_RESULT($bash_cv_type_$1)
-ifelse($#, 4, [if test $bash_cv_type_$1 = yes; then
-	AC_DEFINE($4)
-	fi])
-if test $bash_cv_type_$1 = no; then
-  AC_DEFINE($1, $3)
-fi
-])
-
-dnl
-dnl Type of struct rlimit fields: some systems (OSF/1, NetBSD, RISC/os 5.0)
-dnl have a rlim_t, others (4.4BSD based systems) use quad_t, others use
-dnl long and still others use int (HP-UX 9.01, SunOS 4.1.3).  To simplify
-dnl matters, this just checks for rlim_t, quad_t, or long.
-dnl
-AC_DEFUN(BASH_RLIMIT_TYPE,
-[AC_MSG_CHECKING(for size and type of struct rlimit fields)
-AC_CACHE_VAL(bash_cv_type_rlimit,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/resource.h>],
-[rlim_t xxx;], bash_cv_type_rlimit=rlim_t,[
-AC_TRY_RUN([
-#include <sys/types.h>
-#include <sys/time.h>
-#include <sys/resource.h>
-main()
-{
-#ifdef HAVE_QUAD_T
-  struct rlimit rl;
-  if (sizeof(rl.rlim_cur) == sizeof(quad_t))
-    exit(0);
-#endif
-  exit(1);
-}], bash_cv_type_rlimit=quad_t, bash_cv_type_rlimit=long,
-        [AC_MSG_WARN(cannot check quad_t if cross compiling -- defaulting to long)
-         bash_cv_type_rlimit=long])])
-])
-AC_MSG_RESULT($bash_cv_type_rlimit)
-if test $bash_cv_type_rlimit = quad_t; then
-AC_DEFINE(RLIMTYPE, quad_t)
-elif test $bash_cv_type_rlimit = rlim_t; then
-AC_DEFINE(RLIMTYPE, rlim_t)
-fi
-])
-
-dnl
-dnl Check for sys_siglist[] or _sys_siglist[]
-dnl
-AC_DEFUN(BASH_DECL_UNDER_SYS_SIGLIST,
-[AC_MSG_CHECKING([for _sys_siglist in signal.h or unistd.h])
-AC_CACHE_VAL(bash_cv_decl_under_sys_siglist,
-[AC_TRY_COMPILE([
-#include <sys/types.h>
-#include <signal.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif], [ char *msg = _sys_siglist[2]; ],
-  bash_cv_decl_under_sys_siglist=yes, bash_cv_decl_under_sys_siglist=no,
-  [AC_MSG_WARN(cannot check for _sys_siglist[] if cross compiling -- defaulting to no)])])dnl
-AC_MSG_RESULT($bash_cv_decl_under_sys_siglist)
-if test $bash_cv_decl_under_sys_siglist = yes; then
-AC_DEFINE(UNDER_SYS_SIGLIST_DECLARED)
-fi
-])
-
-AC_DEFUN(BASH_UNDER_SYS_SIGLIST,
-[AC_REQUIRE([BASH_DECL_UNDER_SYS_SIGLIST])
-AC_MSG_CHECKING([for _sys_siglist in system C library])
-AC_CACHE_VAL(bash_cv_under_sys_siglist,
-[AC_TRY_RUN([
-#include <sys/types.h>
-#include <signal.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#ifndef UNDER_SYS_SIGLIST_DECLARED
-extern char *_sys_siglist[];
-#endif
-main()
-{
-char *msg = (char *)_sys_siglist[2];
-exit(msg == 0);
-}],
-	bash_cv_under_sys_siglist=yes, bash_cv_under_sys_siglist=no,
-	[AC_MSG_WARN(cannot check for _sys_siglist[] if cross compiling -- defaulting to no)
-	 bash_cv_under_sys_siglist=no])])
-AC_MSG_RESULT($bash_cv_under_sys_siglist)
-if test $bash_cv_under_sys_siglist = yes; then
-AC_DEFINE(HAVE_UNDER_SYS_SIGLIST)
-fi
-])
-
-AC_DEFUN(BASH_SYS_SIGLIST,
-[AC_REQUIRE([AC_DECL_SYS_SIGLIST])
-AC_MSG_CHECKING([for sys_siglist in system C library])
-AC_CACHE_VAL(bash_cv_sys_siglist,
-[AC_TRY_RUN([
-#include <sys/types.h>
-#include <signal.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#ifndef SYS_SIGLIST_DECLARED
-extern char *sys_siglist[];
-#endif
-main()
-{
-char *msg = sys_siglist[2];
-exit(msg == 0);
-}],
-	bash_cv_sys_siglist=yes, bash_cv_sys_siglist=no,
-	[AC_MSG_WARN(cannot check for sys_siglist if cross compiling -- defaulting to no)
-	 bash_cv_sys_siglist=no])])
-AC_MSG_RESULT($bash_cv_sys_siglist)
-if test $bash_cv_sys_siglist = yes; then
-AC_DEFINE(HAVE_SYS_SIGLIST)
-fi
-])
-
-dnl Check for sys_errlist[] and sys_nerr, check for declaration
-AC_DEFUN(BASH_SYS_ERRLIST,
-[AC_MSG_CHECKING([for sys_errlist and sys_nerr])
-AC_CACHE_VAL(bash_cv_sys_errlist,
-[AC_TRY_LINK([#include <errno.h>],
-[extern char *sys_errlist[];
- extern int sys_nerr;
- char *msg = sys_errlist[sys_nerr - 1];],
-    bash_cv_sys_errlist=yes, bash_cv_sys_errlist=no)])dnl
-AC_MSG_RESULT($bash_cv_sys_errlist)
-if test $bash_cv_sys_errlist = yes; then
-AC_DEFINE(HAVE_SYS_ERRLIST)
-fi
-])
-
-dnl Check to see if opendir will open non-directories (not a nice thing)
-AC_DEFUN(BASH_FUNC_OPENDIR_CHECK,
-[AC_REQUIRE([AC_HEADER_DIRENT])dnl
-AC_MSG_CHECKING(if opendir() opens non-directories)
-AC_CACHE_VAL(bash_cv_opendir_not_robust,
-[AC_TRY_RUN([
-#include <stdio.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-#if defined(HAVE_DIRENT_H)
-# include <dirent.h>
-#else
-# define dirent direct
-# ifdef HAVE_SYS_NDIR_H
-#  include <sys/ndir.h>
-# endif /* SYSNDIR */
-# ifdef HAVE_SYS_DIR_H
-#  include <sys/dir.h>
-# endif /* SYSDIR */
-# ifdef HAVE_NDIR_H
-#  include <ndir.h>
-# endif
-#endif /* HAVE_DIRENT_H */
-main()
-{
-DIR *dir;
-int fd, err;
-err = mkdir("/tmp/bash-aclocal", 0700);
-if (err < 0) {
-  perror("mkdir");
-  exit(1);
-}
-unlink("/tmp/bash-aclocal/not_a_directory");
-fd = open("/tmp/bash-aclocal/not_a_directory", O_WRONLY|O_CREAT|O_EXCL, 0666);
-write(fd, "\n", 1);
-close(fd);
-dir = opendir("/tmp/bash-aclocal/not_a_directory");
-unlink("/tmp/bash-aclocal/not_a_directory");
-rmdir("/tmp/bash-aclocal");
-exit (dir == 0);
-}], bash_cv_opendir_not_robust=yes,bash_cv_opendir_not_robust=no,
-    [AC_MSG_WARN(cannot check opendir if cross compiling -- defaulting to no)
-     bash_cv_opendir_not_robust=no]
-)])
-AC_MSG_RESULT($bash_cv_opendir_not_robust)
-if test $bash_cv_opendir_not_robust = yes; then
-AC_DEFINE(OPENDIR_NOT_ROBUST)
-fi
-])
-
-dnl
-AC_DEFUN(BASH_TYPE_SIGHANDLER,
-[AC_MSG_CHECKING([whether signal handlers are of type void])
-AC_CACHE_VAL(bash_cv_void_sighandler,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <signal.h>
-#ifdef signal
-#undef signal
-#endif
-#ifdef __cplusplus
-extern "C"
-#endif
-void (*signal ()) ();],
-[int i;], bash_cv_void_sighandler=yes, bash_cv_void_sighandler=no)])dnl
-AC_MSG_RESULT($bash_cv_void_sighandler)
-if test $bash_cv_void_sighandler = yes; then
-AC_DEFINE(VOID_SIGHANDLER)
-fi
-])
-
-dnl
-dnl A signed 16-bit integer quantity
-dnl
-AC_DEFUN(BASH_TYPE_BITS16_T,
-[
-if test "$ac_cv_sizeof_short" = 2; then
-  AC_CHECK_TYPE(bits16_t, short)
-elif test "$ac_cv_sizeof_char" = 2; then
-  AC_CHECK_TYPE(bits16_t, char)
-else
-  AC_CHECK_TYPE(bits16_t, short)
-fi
-])
-
-dnl
-dnl An unsigned 16-bit integer quantity
-dnl
-AC_DEFUN(BASH_TYPE_U_BITS16_T,
-[
-if test "$ac_cv_sizeof_short" = 2; then
-  AC_CHECK_TYPE(u_bits16_t, unsigned short)
-elif test "$ac_cv_sizeof_char" = 2; then
-  AC_CHECK_TYPE(u_bits16_t, unsigned char)
-else
-  AC_CHECK_TYPE(u_bits16_t, unsigned short)
-fi
-])
-
-dnl
-dnl A signed 32-bit integer quantity
-dnl
-AC_DEFUN(BASH_TYPE_BITS32_T,
-[
-if test "$ac_cv_sizeof_int" = 4; then
-  AC_CHECK_TYPE(bits32_t, int)
-elif test "$ac_cv_sizeof_long" = 4; then
-  AC_CHECK_TYPE(bits32_t, long)
-else
-  AC_CHECK_TYPE(bits32_t, int)
-fi
-])
-
-dnl
-dnl An unsigned 32-bit integer quantity
-dnl
-AC_DEFUN(BASH_TYPE_U_BITS32_T,
-[
-if test "$ac_cv_sizeof_int" = 4; then
-  AC_CHECK_TYPE(u_bits32_t, unsigned int)
-elif test "$ac_cv_sizeof_long" = 4; then
-  AC_CHECK_TYPE(u_bits32_t, unsigned long)
-else
-  AC_CHECK_TYPE(u_bits32_t, unsigned int)
-fi
-])
-
-AC_DEFUN(BASH_TYPE_PTRDIFF_T,
-[
-if test "$ac_cv_sizeof_int" = "$ac_cv_sizeof_char_p"; then
-  AC_CHECK_TYPE(ptrdiff_t, int)
-elif test "$ac_cv_sizeof_long" = "$ac_cv_sizeof_char_p"; then
-  AC_CHECK_TYPE(ptrdiff_t, long)
-else
-  AC_CHECK_TYPE(ptrdiff_t, int)
-fi
-])
-
-dnl
-dnl A signed 64-bit quantity
-dnl
-AC_DEFUN(BASH_TYPE_BITS64_T,
-[
-if test "$ac_sv_sizeof_char_p" = 8; then
-  AC_CHECK_TYPE(bits64_t, char *)
-elif test "$ac_cv_sizeof_double" = 8; then
-  AC_CHECK_TYPE(bits64_t, double)
-elif test "$ac_cv_sizeof_long" = 8; then
-  AC_CHECK_TYPE(bits64_t, long)
-else
-  AC_CHECK_TYPE(bits64_t, double)
-fi
-])
-
-AC_DEFUN(BASH_FUNC_STRSIGNAL,
-[AC_MSG_CHECKING([for the existence of strsignal])
-AC_CACHE_VAL(bash_cv_have_strsignal,
-[AC_TRY_LINK([#include <sys/types.h>
-#include <signal.h>],
-[char *s = (char *)strsignal(2);],
- bash_cv_have_strsignal=yes, bash_cv_have_strsignal=no)])
-AC_MSG_RESULT($bash_cv_have_strsignal)
-if test $bash_cv_have_strsignal = yes; then
-AC_DEFINE(HAVE_STRSIGNAL)
-fi
-])
-
-AC_DEFUN(BASH_FUNC_LSTAT,
-[dnl Cannot use AC_CHECK_FUNCS(lstat) because Linux defines lstat() as an
-dnl inline function in <sys/stat.h>.
-AC_CACHE_CHECK([for lstat], bash_cv_func_lstat,
-[AC_TRY_LINK([
-#include <sys/types.h>
-#include <sys/stat.h>
-],[ lstat(".",(struct stat *)0); ],
-bash_cv_func_lstat=yes, bash_cv_func_lstat=no)])
-if test $bash_cv_func_lstat = yes; then
-  AC_DEFINE(HAVE_LSTAT)
-fi
-])
-
-AC_DEFUN(BASH_FUNC_INET_ATON,
-[
-AC_CACHE_CHECK([for inet_aton], bash_cv_func_inet_aton,
-[AC_TRY_LINK([
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-struct in_addr ap;], [ inet_aton("127.0.0.1", &ap); ],
-bash_cv_func_inet_aton=yes, bash_cv_func_inet_aton=no)])
-if test $bash_cv_func_inet_aton = yes; then
-  AC_DEFINE(HAVE_INET_ATON)
-fi
-])
-
-AC_DEFUN(BASH_STRUCT_TERMIOS_LDISC,
-[AC_MSG_CHECKING([for a c_line member of struct termios])
-AC_CACHE_VAL(bash_cv_termios_ldisc,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <termios.h>],[struct termios t; int i; i = t.c_line;],
-  bash_cv_termios_ldisc=yes, bash_cv_termios_ldisc=no)])dnl
-AC_MSG_RESULT($bash_cv_termios_ldisc)
-if test $bash_cv_termios_ldisc = yes; then
-AC_DEFINE(TERMIOS_LDISC)
-fi
-])
-
-AC_DEFUN(BASH_STRUCT_TERMIO_LDISC,
-[AC_MSG_CHECKING([for a c_line member of struct termio])
-AC_CACHE_VAL(bash_cv_termio_ldisc,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <termio.h>],[struct termio t; int i; i = t.c_line;],
-  bash_cv_termio_ldisc=yes, bash_cv_termio_ldisc=no)])dnl
-AC_MSG_RESULT($bash_cv_termio_ldisc)
-if test $bash_cv_termio_ldisc = yes; then
-AC_DEFINE(TERMIO_LDISC)
-fi
-])
-
-AC_DEFUN(BASH_FUNC_GETENV,
-[AC_MSG_CHECKING(to see if getenv can be redefined)
-AC_CACHE_VAL(bash_cv_getenv_redef,
-[AC_TRY_RUN([
-#ifdef HAVE_UNISTD_H
-#  include <unistd.h>
-#endif
-#ifndef __STDC__
-#  ifndef const
-#    define const
-#  endif
-#endif
-char *
-getenv (name)
-#if defined (__linux__) || defined (__bsdi__) || defined (convex)
-     const char *name;
-#else
-     char const *name;
-#endif /* !__linux__ && !__bsdi__ && !convex */
-{
-return "42";
-}
-main()
-{
-char *s;
-/* The next allows this program to run, but does not allow bash to link
-   when it redefines getenv.  I'm not really interested in figuring out
-   why not. */
-#if defined (NeXT)
-exit(1);
-#endif
-s = getenv("ABCDE");
-exit(s == 0);	/* force optimizer to leave getenv in */
-}
-], bash_cv_getenv_redef=yes, bash_cv_getenv_redef=no,
-   [AC_MSG_WARN(cannot check getenv redefinition if cross compiling -- defaulting to yes)
-    bash_cv_getenv_redef=yes]
-)])
-AC_MSG_RESULT($bash_cv_getenv_redef)
-if test $bash_cv_getenv_redef = yes; then
-AC_DEFINE(CAN_REDEFINE_GETENV)
-fi
-])
-
-AC_DEFUN(BASH_FUNC_PRINTF,
-[AC_MSG_CHECKING(for declaration of printf in <stdio.h>)
-AC_CACHE_VAL(bash_cv_printf_declared,
-[AC_TRY_RUN([
-#include <stdio.h>
-#ifdef __STDC__
-typedef int (*_bashfunc)(const char *, ...);
-#else
-typedef int (*_bashfunc)();
-#endif
-main()
-{
-_bashfunc pf;
-pf = (_bashfunc) printf;
-exit(pf == 0);
-}
-], bash_cv_printf_declared=yes, bash_cv_printf_declared=no,
-   [AC_MSG_WARN(cannot check printf declaration if cross compiling -- defaulting to yes)
-    bash_cv_printf_declared=yes]
-)])
-AC_MSG_RESULT($bash_cv_printf_declared)
-if test $bash_cv_printf_declared = yes; then
-AC_DEFINE(PRINTF_DECLARED)
-fi
-])
-
-AC_DEFUN(BASH_FUNC_ULIMIT_MAXFDS,
-[AC_MSG_CHECKING(whether ulimit can substitute for getdtablesize)
-AC_CACHE_VAL(bash_cv_ulimit_maxfds,
-[AC_TRY_RUN([
-main()
-{
-long maxfds = ulimit(4, 0L);
-exit (maxfds == -1L);
-}
-], bash_cv_ulimit_maxfds=yes, bash_cv_ulimit_maxfds=no,
-   [AC_MSG_WARN(cannot check ulimit if cross compiling -- defaulting to no)
-    bash_cv_ulimit_maxfds=no]
-)])
-AC_MSG_RESULT($bash_cv_ulimit_maxfds)
-if test $bash_cv_ulimit_maxfds = yes; then
-AC_DEFINE(ULIMIT_MAXFDS)
-fi
-])
-
-AC_DEFUN(BASH_CHECK_LIB_TERMCAP,
-[
-if test "X$bash_cv_termcap_lib" = "X"; then
-_bash_needmsg=yes
-else
-AC_MSG_CHECKING(which library has the termcap functions)
-_bash_needmsg=
-fi
-AC_CACHE_VAL(bash_cv_termcap_lib,
-[AC_CHECK_LIB(termcap, tgetent, bash_cv_termcap_lib=libtermcap,
-    [AC_CHECK_LIB(curses, tgetent, bash_cv_termcap_lib=libcurses,
-	[AC_CHECK_LIB(ncurses, tgetent, bash_cv_termcap_lib=libncurses,
-	    bash_cv_termcap_lib=gnutermcap)])])])
-if test "X$_bash_needmsg" = "Xyes"; then
-AC_MSG_CHECKING(which library has the termcap functions)
-fi
-AC_MSG_RESULT(using $bash_cv_termcap_lib)
-if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
-LDFLAGS="$LDFLAGS -L./lib/termcap"
-TERMCAP_LIB="./lib/termcap/libtermcap.a"
-TERMCAP_DEP="./lib/termcap/libtermcap.a"
-elif test $bash_cv_termcap_lib = libtermcap && test -z "$prefer_curses"; then
-TERMCAP_LIB=-ltermcap
-TERMCAP_DEP=
-elif test $bash_cv_termcap_lib = libncurses; then
-TERMCAP_LIB=-lncurses
-TERMCAP_DEP=
-else
-TERMCAP_LIB=-lcurses
-TERMCAP_DEP=
-fi
-])
-
-AC_DEFUN(BASH_FUNC_GETCWD,
-[AC_MSG_CHECKING([if getcwd() calls popen()])
-AC_CACHE_VAL(bash_cv_getcwd_calls_popen,
-[AC_TRY_RUN([
-#include <stdio.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-#ifndef __STDC__
-#ifndef const
-#define const
-#endif
-#endif
-
-int popen_called;
-
-FILE *
-popen(command, type)
-     const char *command;
-     const char *type;
-{
-	popen_called = 1;
-	return (FILE *)NULL;
-}
-
-FILE *_popen(command, type)
-     const char *command;
-     const char *type;
-{
-  return (popen (command, type));
-}
-
-int
-pclose(stream)
-FILE *stream;
-{
-	return 0;
-}
-
-int
-_pclose(stream)
-FILE *stream;
-{
-	return 0;
-}
-
-main()
-{
-	char	lbuf[32];
-	popen_called = 0;
-	getcwd(lbuf, 32);
-	exit (popen_called);
-}
-], bash_cv_getcwd_calls_popen=no, bash_cv_getcwd_calls_popen=yes,
-   [AC_MSG_WARN(cannot check whether getcwd calls popen if cross compiling -- defaulting to no)
-    bash_cv_getcwd_calls_popen=no]
-)])
-AC_MSG_RESULT($bash_cv_getcwd_calls_popen)
-if test $bash_cv_getcwd_calls_popen = yes; then
-AC_DEFINE(GETCWD_BROKEN)
-fi
-])
-
-AC_DEFUN(BASH_STRUCT_DIRENT_D_INO,
-[AC_REQUIRE([AC_HEADER_DIRENT])
-AC_MSG_CHECKING(if struct dirent has a d_ino member)
-AC_CACHE_VAL(bash_cv_dirent_has_dino,
-[AC_TRY_COMPILE([
-#include <stdio.h>
-#include <sys/types.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-#if defined(HAVE_DIRENT_H)
-# include <dirent.h>
-#else
-# define dirent direct
-# ifdef HAVE_SYS_NDIR_H
-#  include <sys/ndir.h>
-# endif /* SYSNDIR */
-# ifdef HAVE_SYS_DIR_H
-#  include <sys/dir.h>
-# endif /* SYSDIR */
-# ifdef HAVE_NDIR_H
-#  include <ndir.h>
-# endif
-#endif /* HAVE_DIRENT_H */
-],[
-struct dirent d; int z; z = d.d_ino;
-], bash_cv_dirent_has_dino=yes, bash_cv_dirent_has_dino=no)])
-AC_MSG_RESULT($bash_cv_dirent_has_dino)
-if test $bash_cv_dirent_has_dino = yes; then
-AC_DEFINE(STRUCT_DIRENT_HAS_D_INO)
-fi
-])
-
-AC_DEFUN(BASH_STRUCT_DIRENT_D_FILENO,
-[AC_REQUIRE([AC_HEADER_DIRENT])
-AC_MSG_CHECKING(if struct dirent has a d_fileno member)
-AC_CACHE_VAL(bash_cv_dirent_has_d_fileno,
-[AC_TRY_COMPILE([
-#include <stdio.h>
-#include <sys/types.h>
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-#if defined(HAVE_DIRENT_H)
-# include <dirent.h>
-#else
-# define dirent direct
-# ifdef HAVE_SYS_NDIR_H
-#  include <sys/ndir.h>
-# endif /* SYSNDIR */
-# ifdef HAVE_SYS_DIR_H
-#  include <sys/dir.h>
-# endif /* SYSDIR */
-# ifdef HAVE_NDIR_H
-#  include <ndir.h>
-# endif
-#endif /* HAVE_DIRENT_H */
-],[
-struct dirent d; int z; z = d.d_fileno;
-], bash_cv_dirent_has_d_fileno=yes, bash_cv_dirent_has_d_fileno=no)])
-AC_MSG_RESULT($bash_cv_dirent_has_d_fileno)
-if test $bash_cv_dirent_has_d_fileno = yes; then
-AC_DEFINE(STRUCT_DIRENT_HAS_D_FILENO)
-fi
-])
-
-AC_DEFUN(BASH_REINSTALL_SIGHANDLERS,
-[AC_REQUIRE([AC_TYPE_SIGNAL])
-AC_REQUIRE([BASH_SIGNAL_CHECK])
-AC_MSG_CHECKING([if signal handlers must be reinstalled when invoked])
-AC_CACHE_VAL(bash_cv_must_reinstall_sighandlers,
-[AC_TRY_RUN([
-#include <signal.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-typedef RETSIGTYPE sigfunc();
-
-int nsigint;
-
-#ifdef HAVE_POSIX_SIGNALS
-sigfunc *
-set_signal_handler(sig, handler)
-     int sig;
-     sigfunc *handler;
-{
-  struct sigaction act, oact;
-  act.sa_handler = handler;
-  act.sa_flags = 0;
-  sigemptyset (&act.sa_mask);
-  sigemptyset (&oact.sa_mask);
-  sigaction (sig, &act, &oact);
-  return (oact.sa_handler);
-}
-#else
-#define set_signal_handler(s, h) signal(s, h)
-#endif
-
-RETSIGTYPE
-sigint(s)
-int s;
-{
-  nsigint++;
-}
-
-main()
-{
-	nsigint = 0;
-	set_signal_handler(SIGINT, sigint);
-	kill((int)getpid(), SIGINT);
-	kill((int)getpid(), SIGINT);
-	exit(nsigint != 2);
-}
-], bash_cv_must_reinstall_sighandlers=no, bash_cv_must_reinstall_sighandlers=yes,
-   [AC_MSG_WARN(cannot check signal handling if cross compiling -- defaulting to no)
-    bash_cv_must_reinstall_sighandlers=no]
-)])
-AC_MSG_RESULT($bash_cv_must_reinstall_sighandlers)
-if test $bash_cv_must_reinstall_sighandlers = yes; then
-AC_DEFINE(MUST_REINSTALL_SIGHANDLERS)
-fi
-])
-
-AC_DEFUN(BASH_FUNC_SBRK_DECLARED,
-[AC_MSG_CHECKING(for declaration of sbrk in <unistd.h>)
-AC_CACHE_VAL(bash_cv_sbrk_declared,
-[AC_EGREP_HEADER(sbrk, unistd.h,
- bash_cv_sbrk_declared=yes, bash_cv_sbrk_declared=no)])
-AC_MSG_RESULT($bash_cv_sbrk_declared)
-if test $bash_cv_sbrk_declared = yes; then
-AC_DEFINE(SBRK_DECLARED)
-fi
-])
-
-dnl check that some necessary job control definitions are present
-AC_DEFUN(BASH_JOB_CONTROL_MISSING,
-[AC_REQUIRE([BASH_SIGNAL_CHECK])
-AC_MSG_CHECKING(for presence of necessary job control definitions)
-AC_CACHE_VAL(bash_cv_job_control_missing,
-[AC_TRY_RUN([
-#include <sys/types.h>
-#ifdef HAVE_SYS_WAIT_H
-#include <sys/wait.h>
-#endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <signal.h>
-
-/* Add more tests in here as appropriate. */
-main()
-{
-/* signal type */
-#if !defined (HAVE_POSIX_SIGNALS) && !defined (HAVE_BSD_SIGNALS)
-exit(1);
-#endif
-
-/* signals and tty control. */
-#if !defined (SIGTSTP) || !defined (SIGSTOP) || !defined (SIGCONT)
-exit (1);
-#endif
-
-/* process control */
-#if !defined (WNOHANG) || !defined (WUNTRACED) 
-exit(1);
-#endif
-
-/* Posix systems have tcgetpgrp and waitpid. */
-#if defined (_POSIX_VERSION) && !defined (HAVE_TCGETPGRP)
-exit(1);
-#endif
-
-#if defined (_POSIX_VERSION) && !defined (HAVE_WAITPID)
-exit(1);
-#endif
-
-/* Other systems have TIOCSPGRP/TIOCGPRGP and wait3. */
-#if !defined (_POSIX_VERSION) && !defined (HAVE_WAIT3)
-exit(1);
-#endif
-
-exit(0);
-}], bash_cv_job_control_missing=present, bash_cv_job_control_missing=missing,
-    [AC_MSG_WARN(cannot check job control if cross-compiling -- defaulting to missing)
-     bash_cv_job_control_missing=missing]
-)])
-AC_MSG_RESULT($bash_cv_job_control_missing)
-if test $bash_cv_job_control_missing = missing; then
-AC_DEFINE(JOB_CONTROL_MISSING)
-fi
-])
-
-dnl check whether named pipes are present
-dnl this requires a previous check for mkfifo, but that is awkward to specify
-AC_DEFUN(BASH_SYS_NAMED_PIPES,
-[AC_MSG_CHECKING(for presence of named pipes)
-AC_CACHE_VAL(bash_cv_sys_named_pipes,
-[AC_TRY_RUN([
-#include <sys/types.h>
-#include <sys/stat.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-/* Add more tests in here as appropriate. */
-main()
-{
-int fd, err;
-
-#if defined (HAVE_MKFIFO)
-exit (0);
-#endif
-
-#if !defined (S_IFIFO) && (defined (_POSIX_VERSION) && !defined (S_ISFIFO))
-exit (1);
-#endif
-
-#if defined (NeXT)
-exit (1);
-#endif
-err = mkdir("/tmp/bash-aclocal", 0700);
-if (err < 0) {
-  perror ("mkdir");
-  exit(1);
-}
-fd = mknod ("/tmp/bash-aclocal/sh-np-autoconf", 0666 | S_IFIFO, 0);
-if (fd == -1) {
-  rmdir ("/tmp/bash-aclocal");
-  exit (1);
-}
-close(fd);
-unlink ("/tmp/bash-aclocal/sh-np-autoconf");
-rmdir ("/tmp/bash-aclocal");
-exit(0);
-}], bash_cv_sys_named_pipes=present, bash_cv_sys_named_pipes=missing,
-    [AC_MSG_WARN(cannot check for named pipes if cross-compiling -- defaulting to missing)
-     bash_cv_sys_named_pipes=missing]
-)])
-AC_MSG_RESULT($bash_cv_sys_named_pipes)
-if test $bash_cv_sys_named_pipes = missing; then
-AC_DEFINE(NAMED_PIPES_MISSING)
-fi
-])
-
-AC_DEFUN(BASH_FUNC_POSIX_SETJMP,
-[AC_REQUIRE([BASH_SIGNAL_CHECK])
-AC_MSG_CHECKING(for presence of POSIX-style sigsetjmp/siglongjmp)
-AC_CACHE_VAL(bash_cv_func_sigsetjmp,
-[AC_TRY_RUN([
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <sys/types.h>
-#include <signal.h>
-#include <setjmp.h>
-
-main()
-{
-#if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
-exit (1);
-#else
-
-int code;
-sigset_t set, oset;
-sigjmp_buf xx;
-
-/* get the mask */
-sigemptyset(&set);
-sigemptyset(&oset);
-sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &set);
-sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
-
-/* save it */
-code = sigsetjmp(xx, 1);
-if (code)
-  exit(0);	/* could get sigmask and compare to oset here. */
-
-/* change it */
-sigaddset(&set, SIGINT);
-sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
-
-/* and siglongjmp */
-siglongjmp(xx, 10);
-exit(1);
-#endif
-}], bash_cv_func_sigsetjmp=present, bash_cv_func_sigsetjmp=missing,
-    [AC_MSG_WARN(cannot check for sigsetjmp/siglongjmp if cross-compiling -- defaulting to missing)
-     bash_cv_func_sigsetjmp=missing]
-)])
-AC_MSG_RESULT($bash_cv_func_sigsetjmp)
-if test $bash_cv_func_sigsetjmp = present; then
-AC_DEFINE(HAVE_POSIX_SIGSETJMP)
-fi
-])
-
-AC_DEFUN(BASH_HAVE_TIOCGWINSZ,
-[AC_MSG_CHECKING(for TIOCGWINSZ in sys/ioctl.h)
-AC_CACHE_VAL(bash_cv_tiocgwinsz_in_ioctl,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/ioctl.h>], [int x = TIOCGWINSZ;],
-  bash_cv_tiocgwinsz_in_ioctl=yes,bash_cv_tiocgwinsz_in_ioctl=no)])
-AC_MSG_RESULT($bash_cv_tiocgwinsz_in_ioctl)
-if test $bash_cv_tiocgwinsz_in_ioctl = yes; then   
-AC_DEFINE(GWINSZ_IN_SYS_IOCTL)
-fi
-])
-
-AC_DEFUN(BASH_STRUCT_WINSIZE,
-[AC_MSG_CHECKING(for struct winsize in sys/ioctl.h and termios.h)
-AC_CACHE_VAL(bash_cv_struct_winsize_header,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/ioctl.h>], [struct winsize x;],
-  bash_cv_struct_winsize_header=ioctl_h,
-  [AC_TRY_COMPILE([#include <sys/types.h>
-#include <termios.h>], [struct winsize x;],
-  bash_cv_struct_winsize_header=termios_h, bash_cv_struct_winsize_header=other)
-])])
-if test $bash_cv_struct_winsize_header = ioctl_h; then
-  AC_MSG_RESULT(sys/ioctl.h)
-  AC_DEFINE(STRUCT_WINSIZE_IN_SYS_IOCTL)
-elif test $bash_cv_struct_winsize_header = termios_h; then
-  AC_MSG_RESULT(termios.h)
-  AC_DEFINE(STRUCT_WINSIZE_IN_TERMIOS)
-else
-  AC_MSG_RESULT(not found)
-fi
-])
-
-AC_DEFUN(BASH_HAVE_TIOCSTAT,
-[AC_MSG_CHECKING(for TIOCSTAT in sys/ioctl.h)
-AC_CACHE_VAL(bash_cv_tiocstat_in_ioctl,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/ioctl.h>], [int x = TIOCSTAT;],
-  bash_cv_tiocstat_in_ioctl=yes,bash_cv_tiocstat_in_ioctl=no)])
-AC_MSG_RESULT($bash_cv_tiocstat_in_ioctl)
-if test $bash_cv_tiocstat_in_ioctl = yes; then   
-AC_DEFINE(TIOCSTAT_IN_SYS_IOCTL)
-fi
-])
-
-AC_DEFUN(BASH_HAVE_FIONREAD,
-[AC_MSG_CHECKING(for FIONREAD in sys/ioctl.h)
-AC_CACHE_VAL(bash_cv_fionread_in_ioctl,
-[AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/ioctl.h>], [int x = FIONREAD;],
-  bash_cv_fionread_in_ioctl=yes,bash_cv_fionread_in_ioctl=no)])
-AC_MSG_RESULT($bash_cv_fionread_in_ioctl)
-if test $bash_cv_fionread_in_ioctl = yes; then   
-AC_DEFINE(FIONREAD_IN_SYS_IOCTL)
-fi
-])
-
-dnl
-dnl See if speed_t is declared in <sys/types.h>.  Some versions of linux
-dnl require a definition of speed_t each time <termcap.h> is included,
-dnl but you can only get speed_t if you include <termios.h> (on some
-dnl versions) or <sys/types.h> (on others).
-dnl
-AC_DEFUN(BASH_MISC_SPEED_T,
-[AC_MSG_CHECKING(for speed_t in sys/types.h)
-AC_CACHE_VAL(bash_cv_speed_t_in_sys_types,
-[AC_TRY_COMPILE([#include <sys/types.h>], [speed_t x;],
-  bash_cv_speed_t_in_sys_types=yes,bash_cv_speed_t_in_sys_types=no)])
-AC_MSG_RESULT($bash_cv_speed_t_in_sys_types)
-if test $bash_cv_speed_t_in_sys_types = yes; then   
-AC_DEFINE(SPEED_T_IN_SYS_TYPES)
-fi
-])
-
-AC_DEFUN(BASH_CHECK_GETPW_FUNCS,
-[AC_MSG_CHECKING(whether getpw functions are declared in pwd.h)
-AC_CACHE_VAL(bash_cv_getpw_declared,
-[AC_EGREP_CPP(getpwuid,
-[
-#include <sys/types.h>
-#ifdef HAVE_UNISTD_H
-#  include <unistd.h>
-#endif
-#include <pwd.h>
-],
-bash_cv_getpw_declared=yes,bash_cv_getpw_declared=no)])
-AC_MSG_RESULT($bash_cv_getpw_declared)
-if test $bash_cv_getpw_declared = yes; then
-AC_DEFINE(HAVE_GETPW_DECLS)
-fi
-])
-
-AC_DEFUN(BASH_CHECK_DEV_FD,
-[AC_MSG_CHECKING(whether /dev/fd is available)
-AC_CACHE_VAL(bash_cv_dev_fd,
-[if test -d /dev/fd  && test -r /dev/fd/0; then
-   bash_cv_dev_fd=standard
- elif test -d /proc/self/fd && test -r /proc/self/fd/0; then
-   bash_cv_dev_fd=whacky
- else
-   bash_cv_dev_fd=absent
- fi
-])
-AC_MSG_RESULT($bash_cv_dev_fd)
-if test $bash_cv_dev_fd = "standard"; then
-  AC_DEFINE(HAVE_DEV_FD)
-  AC_DEFINE(DEV_FD_PREFIX, "/dev/fd/")
-elif test $bash_cv_dev_fd = "whacky"; then
-  AC_DEFINE(HAVE_DEV_FD)
-  AC_DEFINE(DEV_FD_PREFIX, "/proc/self/fd/")
-fi
-])
-
-AC_DEFUN(BASH_CHECK_DEV_STDIN,
-[AC_MSG_CHECKING(whether /dev/stdin stdout stderr are available)
-AC_CACHE_VAL(bash_cv_dev_stdin,
-[if test -d /dev/fd && test -r /dev/stdin; then
-   bash_cv_dev_stdin=present
- elif test -d /proc/self/fd && test -r /dev/stdin; then
-   bash_cv_dev_stdin=present
- else
-   bash_cv_dev_stdin=absent
- fi
-])
-AC_MSG_RESULT($bash_cv_dev_stdin)
-if test $bash_cv_dev_stdin = "present"; then
-  AC_DEFINE(HAVE_DEV_STDIN)
-fi
-])
-
-dnl
-dnl Check for the presence of getpeername in libsocket.
-dnl If libsocket is present, check for libnsl and add it to LIBS if
-dnl it's there, since most systems with libsocket require linking
-dnl with libnsl as well.  This should only be called if getpeername
-dnl was not found in libc.
-dnl
-dnl NOTE: IF WE FIND GETPEERNAME, WE ASSUME THAT WE HAVE BIND/CONNECT
-dnl	  AS WELL
-dnl
-AC_DEFUN(BASH_CHECK_SOCKLIB,
-[
-if test "X$bash_cv_have_socklib" = "X"; then
-_bash_needmsg=
-else
-AC_MSG_CHECKING(for socket library)
-_bash_needmsg=yes
-fi
-AC_CACHE_VAL(bash_cv_have_socklib,
-[AC_CHECK_LIB(socket, getpeername,
-        bash_cv_have_socklib=yes, bash_cv_have_socklib=no, -lnsl)])
-if test "X$_bash_needmsg" = Xyes; then
-  AC_MSG_RESULT($bash_cv_have_socklib)
-  _bash_needmsg=
-fi
-if test $bash_cv_have_socklib = yes; then
-  # check for libnsl, add it to LIBS if present
-  if test "X$bash_cv_have_libnsl" = "X"; then
-    _bash_needmsg=
-  else
-    AC_MSG_CHECKING(for libnsl)
-    _bash_needmsg=yes
-  fi
-  AC_CACHE_VAL(bash_cv_have_libnsl,
-	   [AC_CHECK_LIB(nsl, t_open,
-		 bash_cv_have_libnsl=yes, bash_cv_have_libnsl=no)])
-  if test "X$_bash_needmsg" = Xyes; then
-    AC_MSG_RESULT($bash_cv_have_libnsl)
-    _bash_needmsg=
-  fi
-  if test $bash_cv_have_libnsl = yes; then
-    LIBS="-lsocket -lnsl $LIBS"
-  else
-    LIBS="-lsocket $LIBS"
-  fi
-  AC_DEFINE(HAVE_LIBSOCKET)
-  AC_DEFINE(HAVE_GETPEERNAME)
-fi
-])
-
-dnl
-dnl This needs BASH_CHECK_SOCKLIB, but since that's not called on every
-dnl system, we can't use AC_PREREQ
-dnl
-AC_DEFUN(BASH_FUNC_GETHOSTBYNAME,
-[if test "X$bash_cv_have_gethostbyname" = "X"; then
-_bash_needmsg=yes
-else
-AC_MSG_CHECKING(for gethostbyname in socket library)
-_bash_needmsg=
-fi
-AC_CACHE_VAL(bash_cv_have_gethostbyname,
-[AC_TRY_LINK([#include <netdb.h>],
-[ struct hostent *hp;
-  hp = gethostbyname("localhost");
-], bash_cv_have_gethostbyname=yes, bash_cv_have_gethostbyname=no)]
-)
-if test "X$_bash_needmsg" = Xyes; then
-    AC_MSG_CHECKING(for gethostbyname in socket library)
-fi
-AC_MSG_RESULT($bash_cv_have_gethostbyname)
-if test "$bash_cv_have_gethostbyname" = yes; then
-AC_DEFINE(HAVE_GETHOSTBYNAME)
-fi
-])
-
-AC_DEFUN(BASH_DEFAULT_MAIL_DIR,
-[AC_MSG_CHECKING(for default mail directory)
-AC_CACHE_VAL(bash_cv_mail_dir,
-[if test -d /var/mail; then
-   bash_cv_mail_dir=/var/mail
- elif test -d /usr/mail; then
-   bash_cv_mail_dir=/usr/mail
- elif test -d /var/spool/mail; then
-   bash_cv_mail_dir=/var/spool/mail
- elif test -d /usr/spool/mail; then
-   bash_cv_mail_dir=/usr/spool/mail
- else
-   bash_cv_mail_dir=unknown
- fi
-])
-AC_MSG_RESULT($bash_cv_mail_dir)
-if test $bash_cv_mail_dir = "/var/mail"; then
-   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/var/mail")
-elif test $bash_cv_mail_dir = "/usr/mail"; then
-   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/usr/mail")
-elif test $bash_cv_mail_dir = "/var/spool/mail"; then
-   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/var/spool/mail")
-elif test $bash_cv_mail_dir = "/usr/spool/mail"; then
-   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/usr/spool/mail")
-else
-   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "unknown")
-fi
-])
-
-dnl
-dnl Check if HPUX needs _KERNEL defined for RLIMIT_* definitions
-dnl
-AC_DEFUN(BASH_KERNEL_RLIMIT_CHECK,
-[AC_MSG_CHECKING([whether $host_os needs _KERNEL for RLIMIT defines])
-AC_CACHE_VAL(bash_cv_kernel_rlimit,
-[AC_TRY_COMPILE([
-#include <sys/types.h>
-#include <sys/resource.h>
-],
-[
-  int f;
-  f = RLIMIT_DATA;
-], bash_cv_kernel_rlimit=no,
-[AC_TRY_COMPILE([
-#include <sys/types.h>
-#define _KERNEL
-#include <sys/resource.h>
-#undef _KERNEL
-],
-[
-	int f;
-        f = RLIMIT_DATA;
-], bash_cv_kernel_rlimit=yes, bash_cv_kernel_rlimit=no)]
-)])
-AC_MSG_RESULT($bash_cv_kernel_rlimit)
-if test $bash_cv_kernel_rlimit = yes; then
-AC_DEFINE(RLIMIT_NEEDS_KERNEL)
-fi
-])
-
-AC_DEFUN(BASH_FUNC_STRCOLL,
-[
-AC_MSG_CHECKING(whether or not strcoll and strcmp differ)
-AC_CACHE_VAL(bash_cv_func_strcoll_broken,
-[AC_TRY_RUN([
-#include <stdio.h>
-#if defined (HAVE_LOCALE_H)
-#include <locale.h>
-#endif
-
-main(c, v)
-int     c;
-char    *v[];
-{
-        int     r1, r2;
-        char    *deflocale, *defcoll;
-
-#ifdef HAVE_SETLOCALE
-        deflocale = setlocale(LC_ALL, "");
-	defcoll = setlocale(LC_COLLATE, "");
-#endif
-
-#ifdef HAVE_STRCOLL
-	/* These two values are taken from tests/glob-test. */
-        r1 = strcoll("abd", "aXd");
-#else
-	r1 = 0;
-#endif
-        r2 = strcmp("abd", "aXd");
-
-	/* These two should both be greater than 0.  It is permissible for
-	   a system to return different values, as long as the sign is the
-	   same. */
-
-        /* Exit with 1 (failure) if these two values are both > 0, since
-	   this tests whether strcoll(3) is broken with respect to strcmp(3)
-	   in the default locale. */
-	exit (r1 > 0 && r2 > 0);
-}
-], bash_cv_func_strcoll_broken=yes, bash_cv_func_strcoll_broken=no,
-   [AC_MSG_WARN(cannot check strcoll if cross compiling -- defaulting to no)
-    bash_cv_func_strcoll_broken=no]
-)])
-AC_MSG_RESULT($bash_cv_func_strcoll_broken)
-if test $bash_cv_func_strcoll_broken = yes; then
-AC_DEFINE(STRCOLL_BROKEN)
-fi
-])
-
-dnl
-dnl If available, use support for large files unless the user specified
-dnl one of the CPPFLAGS, LDFLAGS, or LIBS variables (<eggert@twinsun.com>
-dnl via GNU patch 2.5)
-dnl
-AC_DEFUN(BASH_LARGE_FILE_SUPPORT,
-[AC_MSG_CHECKING(whether large file support needs explicit enabling)
-ac_getconfs=''
-ac_result=yes
-ac_set=''
-ac_shellvars='CPPFLAGS LDFLAGS LIBS'
-for ac_shellvar in $ac_shellvars; do
-  case $ac_shellvar in
-  CPPFLAGS) ac_lfsvar=LFS_CFLAGS ac_lfs64var=LFS64_CFLAGS ;;
-  *) ac_lfsvar=LFS_$ac_shellvar ac_lfs64var=LFS64_$ac_shellvar ;;
-  esac
-  eval test '"${'$ac_shellvar'+set}"' = set && ac_set=$ac_shellvar
-  (getconf $ac_lfsvar) >/dev/null 2>&1 || { ac_result=no; break; }
-  ac_getconf=`getconf $ac_lfsvar`
-  ac_getconf64=`getconf $ac_lfs64var`
-  ac_getconfs=$ac_getconfs$ac_getconf\ $ac_getconf64
-  eval ac_test_$ac_shellvar="\$ac_getconf\ \$ac_getconf64"
-done
-case "$ac_result$ac_getconfs" in
-yes) ac_result=no ;;
-esac
-case "$ac_result$ac_set" in
-yes?*) ac_result="yes, but $ac_set is already set, so use its settings"
-esac
-AC_MSG_RESULT($ac_result)
-case $ac_result in
-yes)
-  for ac_shellvar in $ac_shellvars; do
-    eval $ac_shellvar=\$ac_test_$ac_shellvar
-  done ;;
-esac
-])
-
-dnl
-dnl AC_SYS_RESTARTABLE_SYSCALLS tests only for restarted system calls
-dnl after a signal handler has been installed with signal().  Since
-dnl Bash uses sigaction() if it is available, we need to check whether
-dnl or not a signal handler installed with sigaction and SA_RESTART
-dnl causes system calls to be restarted after the signal is caught
-dnl
-AC_DEFUN(BASH_SYS_RESTARTABLE_SYSCALLS,
-[AC_REQUIRE([BASH_SIGNAL_CHECK])
-AC_CACHE_CHECK(whether posix sigaction restarts system calls by default,
-bash_cv_sys_restartable_syscalls,
-[AC_TRY_RUN(
-[/* Exit 0 (true) if wait returns something other than -1,
-   i.e. the pid of the child, which means that wait was restarted
-   after getting the signal.  */
-#ifdef HAVE_UNISTD_H
-#  include <unistd.h>
-#endif
-#include <sys/types.h>
-#include <signal.h>
-static int caught = 0;
-void ucatch (isig) int isig; { caught = 1; }
-main ()
-{
-#if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
-  exit (1);
-#else
-  struct sigaction act, oact;
-  int i, status;
-
-  act.sa_handler = ucatch;
-  /* Might want to add SA_RESTART here, but bash's set_signal_handler
-     does not. */
-  act.sa_flags = 0;
-  sigemptyset(&act.sa_mask);
-  sigemptyset(&oact.sa_mask);
-  i = fork ();
-  /* A possible race condition here, but in practice it never happens. */
-  if (i == 0) { sleep (3); kill (getppid (), SIGINT); sleep (3); exit (0); }
-  sigaction(SIGINT, &act, &oact);
-  status = wait(&i);
-  if (status == -1) wait(&i);
-  exit (status == -1);
-#endif
-}
-], bash_cv_sys_restartable_syscalls=yes, bash_cv_sys_restartable_syscalls=no,
-   AC_MSG_WARN(cannot check restartable syscalls if cross compiling))
-])
-if test $bash_cv_sys_restartable_syscalls = yes; then
-  AC_DEFINE(HAVE_RESTARTABLE_SYSCALLS)
-fi
-])
-dnl
-dnl Check for 64-bit off_t -- used for malloc alignment
-dnl
-dnl C does not allow duplicate case labels, so the compile will fail if
-dnl sizeof(off_t) is > 4.
-dnl
-AC_DEFUN(BASH_CHECK_OFF_T_64,
-[AC_CACHE_CHECK(for 64-bit off_t, bash_cv_off_t_64,
-AC_TRY_COMPILE([
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <sys/types.h>
-],[
-switch (0) case 0: case (sizeof (off_t) <= 4):;
-], bash_cv_off_t_64=no, bash_cv_off_t_64=yes))
-if test $bash_cv_off_t_64 = yes; then
-        AC_DEFINE(HAVE_OFF_T_64)
-fi])
-
-AC_DEFUN(BASH_STRUCT_TIMEVAL,
-[AC_MSG_CHECKING(for struct timeval in sys/time.h and time.h)
-AC_CACHE_VAL(bash_cv_struct_timeval,
-[
-AC_EGREP_HEADER(struct timeval, sys/time.h,
-		bash_cv_struct_timeval=yes,
-		AC_EGREP_HEADER(struct timeval, time.h,
-			bash_cv_struct_timeval=yes,
-			bash_cv_struct_timeval=no))
-])
-AC_MSG_RESULT($bash_cv_struct_timeval)
-if test $bash_cv_struct_timeval = yes; then
-  AC_DEFINE(HAVE_TIMEVAL)
-fi
-])
-
-AC_DEFUN(BASH_CHECK_RTSIGS,
-[AC_MSG_CHECKING(for unusable real-time signals due to large values)
-AC_CACHE_VAL(bash_cv_unusable_rtsigs,
-[AC_TRY_RUN([
-#include <sys/types.h>
-#include <signal.h>
-
-#ifndef NSIG
-#  define NSIG 64
-#endif
-
-main ()
-{
-  int n_sigs = 2 * NSIG;
-#ifdef SIGRTMIN
-  int rtmin = SIGRTMIN;
-#else
-  int rtmin = 0;
-#endif
-
-  exit(rtmin < n_sigs);
-}], bash_cv_unusable_rtsigs=yes, bash_cv_unusable_rtsigs=no,
-    [AC_MSG_WARN(cannot check real-time signals if cross compiling -- defaulting to yes)
-     bash_cv_unusable_rtsigs=yes]
-)])
-AC_MSG_RESULT($bash_cv_unusable_rtsigs)
-if test $bash_cv_unusable_rtsigs = yes; then
-AC_DEFINE(UNUSABLE_RT_SIGNALS)
-fi
-])
diff --git a/readline/ansi_stdlib.h b/readline/ansi_stdlib.h
deleted file mode 100644
--- a/readline/ansi_stdlib.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* ansi_stdlib.h -- An ANSI Standard stdlib.h. */
-/* A minimal stdlib.h containing extern declarations for those functions
-   that bash uses. */
-
-/* Copyright (C) 1993 Free Software Foundation, Inc.
-
-   This file is part of GNU Bash, the Bourne Again SHell.
-
-   Bash is free software; you can redistribute it and/or modify it under
-   the terms of the GNU General Public License as published by the Free
-   Software Foundation; either version 2, or (at your option) any later
-   version.
-
-   Bash is distributed in the hope that it will be useful, but WITHOUT ANY
-   WARRANTY; without even the implied warranty of MERCHANTABILITY or
-   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-   for more details.
-
-   You should have received a copy of the GNU General Public License along
-   with Bash; see the file COPYING.  If not, write to the Free Software
-   Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_STDLIB_H_)
-#define	_STDLIB_H_ 1
-
-/* String conversion functions. */
-extern int atoi ();
-extern long int atol ();
-
-extern double atof ();
-extern double strtod ();
-
-/* Memory allocation functions. */
-extern char *malloc ();
-extern char *realloc ();
-extern void free ();
-
-/* Other miscellaneous functions. */
-extern void abort ();
-extern void exit ();
-extern char *getenv ();
-extern void qsort ();
-
-#endif /* _STDLIB_H  */
diff --git a/readline/bind.c b/readline/bind.c
deleted file mode 100644
--- a/readline/bind.c
+++ /dev/null
@@ -1,2118 +0,0 @@
-/* bind.c -- key binding and startup file support for the readline library. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#if defined (HAVE_SYS_FILE_H)
-#  include <sys/file.h>
-#endif /* HAVE_SYS_FILE_H */
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include <errno.h>
-
-#if !defined (errno)
-extern int errno;
-#endif /* !errno */
-
-#include "posixstat.h"
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-/* Some standard library routines. */
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-#include "rlshell.h"
-#include "xmalloc.h"
-
-#if !defined (strchr) && !defined (__STDC__)
-extern char *strchr (), *strrchr ();
-#endif /* !strchr && !__STDC__ */
-
-/* Variables exported by this file. */
-Keymap rl_binding_keymap;
-
-static int _rl_read_init_file __P((const char *, int));
-static int glean_key_from_name __P((char *));
-static int substring_member_of_array __P((char *, const char **));
-
-static int currently_reading_init_file;
-
-/* used only in this file */
-static int _rl_prefer_visible_bell = 1;
-
-/* **************************************************************** */
-/*								    */
-/*			Binding keys				    */
-/*								    */
-/* **************************************************************** */
-
-/* rl_add_defun (char *name, rl_command_func_t *function, int key)
-   Add NAME to the list of named functions.  Make FUNCTION be the function
-   that gets called.  If KEY is not -1, then bind it. */
-int
-rl_add_defun (name, function, key)
-     const char *name;
-     rl_command_func_t *function;
-     int key;
-{
-  if (key != -1)
-    rl_bind_key (key, function);
-  rl_add_funmap_entry (name, function);
-  return 0;
-}
-
-/* Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range. */
-int
-rl_bind_key (key, function)
-     int key;
-     rl_command_func_t *function;
-{
-  if (key < 0)
-    return (key);
-
-  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
-    {
-      if (_rl_keymap[ESC].type == ISKMAP)
-	{
-	  Keymap escmap;
-
-	  escmap = FUNCTION_TO_KEYMAP (_rl_keymap, ESC);
-	  key = UNMETA (key);
-	  escmap[key].type = ISFUNC;
-	  escmap[key].function = function;
-	  return (0);
-	}
-      return (key);
-    }
-
-  _rl_keymap[key].type = ISFUNC;
-  _rl_keymap[key].function = function;
-  rl_binding_keymap = _rl_keymap;
-  return (0);
-}
-
-/* Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid
-   KEY. */
-int
-rl_bind_key_in_map (key, function, map)
-     int key;
-     rl_command_func_t *function;
-     Keymap map;
-{
-  int result;
-  Keymap oldmap;
-
-  oldmap = _rl_keymap;
-  _rl_keymap = map;
-  result = rl_bind_key (key, function);
-  _rl_keymap = oldmap;
-  return (result);
-}
-
-/* Make KEY do nothing in the currently selected keymap.
-   Returns non-zero in case of error. */
-int
-rl_unbind_key (key)
-     int key;
-{
-  return (rl_bind_key (key, (rl_command_func_t *)NULL));
-}
-
-/* Make KEY do nothing in MAP.
-   Returns non-zero in case of error. */
-int
-rl_unbind_key_in_map (key, map)
-     int key;
-     Keymap map;
-{
-  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
-}
-
-/* Unbind all keys bound to FUNCTION in MAP. */
-int
-rl_unbind_function_in_map (func, map)
-     rl_command_func_t *func;
-     Keymap map;
-{
-  register int i, rval;
-
-  for (i = rval = 0; i < KEYMAP_SIZE; i++)
-    {
-      if (map[i].type == ISFUNC && map[i].function == func)
-	{
-	  map[i].function = (rl_command_func_t *)NULL;
-	  rval = 1;
-	}
-    }
-  return rval;
-}
-
-int
-rl_unbind_command_in_map (command, map)
-     const char *command;
-     Keymap map;
-{
-  rl_command_func_t *func;
-
-  func = rl_named_function (command);
-  if (func == 0)
-    return 0;
-  return (rl_unbind_function_in_map (func, map));
-}
-
-/* Bind the key sequence represented by the string KEYSEQ to
-   FUNCTION.  This makes new keymaps as necessary.  The initial
-   place to do bindings is in MAP. */
-int
-rl_set_key (keyseq, function, map)
-     const char *keyseq;
-     rl_command_func_t *function;
-     Keymap map;
-{
-  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
-}
-
-/* Bind the key sequence represented by the string KEYSEQ to
-   the string of characters MACRO.  This makes new keymaps as
-   necessary.  The initial place to do bindings is in MAP. */
-int
-rl_macro_bind (keyseq, macro, map)
-     const char *keyseq, *macro;
-     Keymap map;
-{
-  char *macro_keys;
-  int macro_keys_len;
-
-  macro_keys = (char *)xmalloc ((2 * strlen (macro)) + 1);
-
-  if (rl_translate_keyseq (macro, macro_keys, &macro_keys_len))
-    {
-      free (macro_keys);
-      return -1;
-    }
-  rl_generic_bind (ISMACR, keyseq, macro_keys, map);
-  return 0;
-}
-
-/* Bind the key sequence represented by the string KEYSEQ to
-   the arbitrary pointer DATA.  TYPE says what kind of data is
-   pointed to by DATA, right now this can be a function (ISFUNC),
-   a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps
-   as necessary.  The initial place to do bindings is in MAP. */
-int
-rl_generic_bind (type, keyseq, data, map)
-     int type;
-     const char *keyseq;
-     char *data;
-     Keymap map;
-{
-  char *keys;
-  int keys_len;
-  register int i;
-
-  /* If no keys to bind to, exit right away. */
-  if (!keyseq || !*keyseq)
-    {
-      if (type == ISMACR)
-	free (data);
-      return -1;
-    }
-
-  keys = xmalloc (1 + (2 * strlen (keyseq)));
-
-  /* Translate the ASCII representation of KEYSEQ into an array of
-     characters.  Stuff the characters into KEYS, and the length of
-     KEYS into KEYS_LEN. */
-  if (rl_translate_keyseq (keyseq, keys, &keys_len))
-    {
-      free (keys);
-      return -1;
-    }
-
-  /* Bind keys, making new keymaps as necessary. */
-  for (i = 0; i < keys_len; i++)
-    {
-      int ic = (int) ((unsigned char)keys[i]);
-
-      if (_rl_convert_meta_chars_to_ascii && META_CHAR (ic))
-	{
-	  ic = UNMETA (ic);
-	  if (map[ESC].type == ISKMAP)
-	    map = FUNCTION_TO_KEYMAP (map, ESC);
-	}
-
-      if ((i + 1) < keys_len)
-	{
-	  if (map[ic].type != ISKMAP)
-	    {
-	      if (map[ic].type == ISMACR)
-		free ((char *)map[ic].function);
-
-	      map[ic].type = ISKMAP;
-	      map[ic].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap());
-	    }
-	  map = FUNCTION_TO_KEYMAP (map, ic);
-	}
-      else
-	{
-	  if (map[ic].type == ISMACR)
-	    free ((char *)map[ic].function);
-
-	  map[ic].function = KEYMAP_TO_FUNCTION (data);
-	  map[ic].type = type;
-	}
-
-      rl_binding_keymap = map;
-    }
-  free (keys);
-  return 0;
-}
-
-/* Translate the ASCII representation of SEQ, stuffing the values into ARRAY,
-   an array of characters.  LEN gets the final length of ARRAY.  Return
-   non-zero if there was an error parsing SEQ. */
-int
-rl_translate_keyseq (seq, array, len)
-     const char *seq;
-     char *array;
-     int *len;
-{
-  register int i, c, l, temp;
-
-  for (i = l = 0; c = seq[i]; i++)
-    {
-      if (c == '\\')
-	{
-	  c = seq[++i];
-
-	  if (c == 0)
-	    break;
-
-	  /* Handle \C- and \M- prefixes. */
-	  if ((c == 'C' || c == 'M') && seq[i + 1] == '-')
-	    {
-	      /* Handle special case of backwards define. */
-	      if (strncmp (&seq[i], "C-\\M-", 5) == 0)
-		{
-		  array[l++] = ESC;
-		  i += 5;
-		  array[l++] = CTRL (_rl_to_upper (seq[i]));
-		  if (seq[i] == '\0')
-		    i--;
-		}
-	      else if (c == 'M')
-		{
-		  i++;
-		  array[l++] = ESC;	/* XXX */
-		}
-	      else if (c == 'C')
-		{
-		  i += 2;
-		  /* Special hack for C-?... */
-		  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
-		}
-	      continue;
-	    }	      
-
-	  /* Translate other backslash-escaped characters.  These are the
-	     same escape sequences that bash's `echo' and `printf' builtins
-	     handle, with the addition of \d -> RUBOUT.  A backslash
-	     preceding a character that is not special is stripped. */
-	  switch (c)
-	    {
-	    case 'a':
-	      array[l++] = '\007';
-	      break;
-	    case 'b':
-	      array[l++] = '\b';
-	      break;
-	    case 'd':
-	      array[l++] = RUBOUT;	/* readline-specific */
-	      break;
-	    case 'e':
-	      array[l++] = ESC;
-	      break;
-	    case 'f':
-	      array[l++] = '\f';
-	      break;
-	    case 'n':
-	      array[l++] = NEWLINE;
-	      break;
-	    case 'r':
-	      array[l++] = RETURN;
-	      break;
-	    case 't':
-	      array[l++] = TAB;
-	      break;
-	    case 'v':
-	      array[l++] = 0x0B;
-	      break;
-	    case '\\':
-	      array[l++] = '\\';
-	      break;
-	    case '0': case '1': case '2': case '3':
-	    case '4': case '5': case '6': case '7':
-	      i++;
-	      for (temp = 2, c -= '0'; ISOCTAL (seq[i]) && temp--; i++)
-	        c = (c * 8) + OCTVALUE (seq[i]);
-	      i--;	/* auto-increment in for loop */
-	      array[l++] = c % (largest_char + 1);
-	      break;
-	    case 'x':
-	      i++;
-	      for (temp = 3, c = 0; isxdigit (seq[i]) && temp--; i++)
-	        c = (c * 16) + HEXVALUE (seq[i]);
-	      if (temp == 3)
-	        c = 'x';
-	      i--;	/* auto-increment in for loop */
-	      array[l++] = c % (largest_char + 1);
-	      break;
-	    default:	/* backslashes before non-special chars just add the char */
-	      array[l++] = c;
-	      break;	/* the backslash is stripped */
-	    }
-	  continue;
-	}
-
-      array[l++] = c;
-    }
-
-  *len = l;
-  array[l] = '\0';
-  return (0);
-}
-
-char *
-rl_untranslate_keyseq (seq)
-     int seq;
-{
-  static char kseq[16];
-  int i, c;
-
-  i = 0;
-  c = seq;
-  if (META_CHAR (c))
-    {
-      kseq[i++] = '\\';
-      kseq[i++] = 'M';
-      kseq[i++] = '-';
-      c = UNMETA (c);
-    }
-  else if (CTRL_CHAR (c))
-    {
-      kseq[i++] = '\\';
-      kseq[i++] = 'C';
-      kseq[i++] = '-';
-      c = _rl_to_lower (UNCTRL (c));
-    }
-  else if (c == RUBOUT)
-    {
-      kseq[i++] = '\\';
-      kseq[i++] = 'C';
-      kseq[i++] = '-';
-      c = '?';
-    }
-
-  if (c == ESC)
-    {
-      kseq[i++] = '\\';
-      c = 'e';
-    }
-  else if (c == '\\' || c == '"')
-    {
-      kseq[i++] = '\\';
-    }
-
-  kseq[i++] = (unsigned char) c;
-  kseq[i] = '\0';
-  return kseq;
-}
-
-static char *
-_rl_untranslate_macro_value (seq)
-     char *seq;
-{
-  char *ret, *r, *s;
-  int c;
-
-  r = ret = xmalloc (7 * strlen (seq) + 1);
-  for (s = seq; *s; s++)
-    {
-      c = *s;
-      if (META_CHAR (c))
-	{
-	  *r++ = '\\';
-	  *r++ = 'M';
-	  *r++ = '-';
-	  c = UNMETA (c);
-	}
-      else if (CTRL_CHAR (c) && c != ESC)
-	{
-	  *r++ = '\\';
-	  *r++ = 'C';
-	  *r++ = '-';
-	  c = _rl_to_lower (UNCTRL (c));
-	}
-      else if (c == RUBOUT)
- 	{
- 	  *r++ = '\\';
- 	  *r++ = 'C';
- 	  *r++ = '-';
- 	  c = '?';
- 	}
-
-      if (c == ESC)
-	{
-	  *r++ = '\\';
-	  c = 'e';
-	}
-      else if (c == '\\' || c == '"')
-	*r++ = '\\';
-
-      *r++ = (unsigned char)c;
-    }
-  *r = '\0';
-  return ret;
-}
-
-/* Return a pointer to the function that STRING represents.
-   If STRING doesn't have a matching function, then a NULL pointer
-   is returned. */
-rl_command_func_t *
-rl_named_function (string)
-     const char *string;
-{
-  register int i;
-
-  rl_initialize_funmap ();
-
-  for (i = 0; funmap[i]; i++)
-    if (_rl_stricmp (funmap[i]->name, string) == 0)
-      return (funmap[i]->function);
-  return ((rl_command_func_t *)NULL);
-}
-
-/* Return the function (or macro) definition which would be invoked via
-   KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is
-   used.  TYPE, if non-NULL, is a pointer to an int which will receive the
-   type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
-   or ISMACR (macro). */
-rl_command_func_t *
-rl_function_of_keyseq (keyseq, map, type)
-     const char *keyseq;
-     Keymap map;
-     int *type;
-{
-  register int i;
-
-  if (!map)
-    map = _rl_keymap;
-
-  for (i = 0; keyseq && keyseq[i]; i++)
-    {
-      int ic = keyseq[i];
-
-      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
-	{
-	  if (map[ESC].type != ISKMAP)
-	    {
-	      if (type)
-		*type = map[ESC].type;
-
-	      return (map[ESC].function);
-	    }
-	  else
-	    {
-	      map = FUNCTION_TO_KEYMAP (map, ESC);
-	      ic = UNMETA (ic);
-	    }
-	}
-
-      if (map[ic].type == ISKMAP)
-	{
-	  /* If this is the last key in the key sequence, return the
-	     map. */
-	  if (!keyseq[i + 1])
-	    {
-	      if (type)
-		*type = ISKMAP;
-
-	      return (map[ic].function);
-	    }
-	  else
-	    map = FUNCTION_TO_KEYMAP (map, ic);
-	}
-      else
-	{
-	  if (type)
-	    *type = map[ic].type;
-
-	  return (map[ic].function);
-	}
-    }
-  return ((rl_command_func_t *) NULL);
-}
-
-/* The last key bindings file read. */
-static char *last_readline_init_file = (char *)NULL;
-
-/* The file we're currently reading key bindings from. */
-static const char *current_readline_init_file;
-static int current_readline_init_include_level;
-static int current_readline_init_lineno;
-
-/* Read FILENAME into a locally-allocated buffer and return the buffer.
-   The size of the buffer is returned in *SIZEP.  Returns NULL if any
-   errors were encountered. */
-static char *
-_rl_read_file (filename, sizep)
-     char *filename;
-     size_t *sizep;
-{
-  struct stat finfo;
-  size_t file_size;
-  char *buffer;
-  int i, file;
-
-  if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY, 0666)) < 0)
-    return ((char *)NULL);
-
-  file_size = (size_t)finfo.st_size;
-
-  /* check for overflow on very large files */
-  if (file_size != finfo.st_size || file_size + 1 < file_size)
-    {
-      if (file >= 0)
-	close (file);
-#if defined (EFBIG)
-      errno = EFBIG;
-#endif
-      return ((char *)NULL);
-    }
-
-  /* Read the file into BUFFER. */
-  buffer = (char *)xmalloc (file_size + 1);
-  i = read (file, buffer, file_size);
-  close (file);
-
-#if 0
-  if (i < file_size)
-#else
-  if (i < 0)
-#endif
-    {
-      free (buffer);
-      return ((char *)NULL);
-    }
-
-#if 0
-  buffer[file_size] = '\0';
-  if (sizep)
-    *sizep = file_size;
-#else
-  buffer[i] = '\0';
-  if (sizep)
-    *sizep = i;
-#endif
-
-  return (buffer);
-}
-
-/* Re-read the current keybindings file. */
-int
-rl_re_read_init_file (count, ignore)
-     int count, ignore;
-{
-  int r;
-  r = rl_read_init_file ((const char *)NULL);
-  rl_set_keymap_from_edit_mode ();
-  return r;
-}
-
-/* Do key bindings from a file.  If FILENAME is NULL it defaults
-   to the first non-null filename from this list:
-     1. the filename used for the previous call
-     2. the value of the shell variable `INPUTRC'
-     3. ~/.inputrc
-   If the file existed and could be opened and read, 0 is returned,
-   otherwise errno is returned. */
-int
-rl_read_init_file (filename)
-     const char *filename;
-{
-  /* Default the filename. */
-  if (filename == 0)
-    {
-      filename = last_readline_init_file;
-      if (filename == 0)
-        filename = sh_get_env_value ("INPUTRC");
-      if (filename == 0)
-	filename = DEFAULT_INPUTRC;
-    }
-
-  if (*filename == 0)
-    filename = DEFAULT_INPUTRC;
-
-#if defined (__MSDOS__)
-  if (_rl_read_init_file (filename, 0) == 0)
-    return 0;
-  filename = "~/_inputrc";
-#endif
-  return (_rl_read_init_file (filename, 0));
-}
-
-static int
-_rl_read_init_file (filename, include_level)
-     const char *filename;
-     int include_level;
-{
-  register int i;
-  char *buffer, *openname, *line, *end;
-  size_t file_size;
-
-  current_readline_init_file = filename;
-  current_readline_init_include_level = include_level;
-
-  openname = tilde_expand (filename);
-  buffer = _rl_read_file (openname, &file_size);
-  free (openname);
-
-  if (buffer == 0)
-    return (errno);
-  
-  if (include_level == 0 && filename != last_readline_init_file)
-    {
-      FREE (last_readline_init_file);
-      last_readline_init_file = savestring (filename);
-    }
-
-  currently_reading_init_file = 1;
-
-  /* Loop over the lines in the file.  Lines that start with `#' are
-     comments; all other lines are commands for readline initialization. */
-  current_readline_init_lineno = 1;
-  line = buffer;
-  end = buffer + file_size;
-  while (line < end)
-    {
-      /* Find the end of this line. */
-      for (i = 0; line + i != end && line[i] != '\n'; i++);
-
-#if defined (__CYGWIN__)
-      /* ``Be liberal in what you accept.'' */
-      if (line[i] == '\n' && line[i-1] == '\r')
-	line[i - 1] = '\0';
-#endif
-
-      /* Mark end of line. */
-      line[i] = '\0';
-
-      /* Skip leading whitespace. */
-      while (*line && whitespace (*line))
-        {
-	  line++;
-	  i--;
-        }
-
-      /* If the line is not a comment, then parse it. */
-      if (*line && *line != '#')
-	rl_parse_and_bind (line);
-
-      /* Move to the next line. */
-      line += i + 1;
-      current_readline_init_lineno++;
-    }
-
-  free (buffer);
-  currently_reading_init_file = 0;
-  return (0);
-}
-
-static void
-_rl_init_file_error (msg)
-     char *msg;
-{
-  if (currently_reading_init_file)
-    fprintf (stderr, "readline: %s: line %d: %s\n", current_readline_init_file,
-		     current_readline_init_lineno, msg);
-  else
-    fprintf (stderr, "readline: %s\n", msg);
-}
-
-/* **************************************************************** */
-/*								    */
-/*			Parser Directives       		    */
-/*								    */
-/* **************************************************************** */
-
-typedef int _rl_parser_func_t __P((char *));
-
-/* Things that mean `Control'. */
-const char *_rl_possible_control_prefixes[] = {
-  "Control-", "C-", "CTRL-", (const char *)NULL
-};
-
-const char *_rl_possible_meta_prefixes[] = {
-  "Meta", "M-", (const char *)NULL
-};
-
-/* Conditionals. */
-
-/* Calling programs set this to have their argv[0]. */
-const char *rl_readline_name = "other";
-
-/* Stack of previous values of parsing_conditionalized_out. */
-static unsigned char *if_stack = (unsigned char *)NULL;
-static int if_stack_depth;
-static int if_stack_size;
-
-/* Push _rl_parsing_conditionalized_out, and set parser state based
-   on ARGS. */
-static int
-parser_if (args)
-     char *args;
-{
-  register int i;
-
-  /* Push parser state. */
-  if (if_stack_depth + 1 >= if_stack_size)
-    {
-      if (!if_stack)
-	if_stack = (unsigned char *)xmalloc (if_stack_size = 20);
-      else
-	if_stack = (unsigned char *)xrealloc (if_stack, if_stack_size += 20);
-    }
-  if_stack[if_stack_depth++] = _rl_parsing_conditionalized_out;
-
-  /* If parsing is turned off, then nothing can turn it back on except
-     for finding the matching endif.  In that case, return right now. */
-  if (_rl_parsing_conditionalized_out)
-    return 0;
-
-  /* Isolate first argument. */
-  for (i = 0; args[i] && !whitespace (args[i]); i++);
-
-  if (args[i])
-    args[i++] = '\0';
-
-  /* Handle "$if term=foo" and "$if mode=emacs" constructs.  If this
-     isn't term=foo, or mode=emacs, then check to see if the first
-     word in ARGS is the same as the value stored in rl_readline_name. */
-  if (rl_terminal_name && _rl_strnicmp (args, "term=", 5) == 0)
-    {
-      char *tem, *tname;
-
-      /* Terminals like "aaa-60" are equivalent to "aaa". */
-      tname = savestring (rl_terminal_name);
-      tem = strchr (tname, '-');
-      if (tem)
-	*tem = '\0';
-
-      /* Test the `long' and `short' forms of the terminal name so that
-	 if someone has a `sun-cmd' and does not want to have bindings
-	 that will be executed if the terminal is a `sun', they can put
-	 `$if term=sun-cmd' into their .inputrc. */
-      _rl_parsing_conditionalized_out = _rl_stricmp (args + 5, tname) &&
-					_rl_stricmp (args + 5, rl_terminal_name);
-      free (tname);
-    }
-#if defined (VI_MODE)
-  else if (_rl_strnicmp (args, "mode=", 5) == 0)
-    {
-      int mode;
-
-      if (_rl_stricmp (args + 5, "emacs") == 0)
-	mode = emacs_mode;
-      else if (_rl_stricmp (args + 5, "vi") == 0)
-	mode = vi_mode;
-      else
-	mode = no_mode;
-
-      _rl_parsing_conditionalized_out = mode != rl_editing_mode;
-    }
-#endif /* VI_MODE */
-  /* Check to see if the first word in ARGS is the same as the
-     value stored in rl_readline_name. */
-  else if (_rl_stricmp (args, rl_readline_name) == 0)
-    _rl_parsing_conditionalized_out = 0;
-  else
-    _rl_parsing_conditionalized_out = 1;
-  return 0;
-}
-
-/* Invert the current parser state if there is anything on the stack. */
-static int
-parser_else (args)
-     char *args;
-{
-  register int i;
-
-  if (if_stack_depth == 0)
-    {
-      _rl_init_file_error ("$else found without matching $if");
-      return 0;
-    }
-
-  /* Check the previous (n - 1) levels of the stack to make sure that
-     we haven't previously turned off parsing. */
-  for (i = 0; i < if_stack_depth - 1; i++)
-    if (if_stack[i] == 1)
-      return 0;
-
-  /* Invert the state of parsing if at top level. */
-  _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;
-  return 0;
-}
-
-/* Terminate a conditional, popping the value of
-   _rl_parsing_conditionalized_out from the stack. */
-static int
-parser_endif (args)
-     char *args;
-{
-  if (if_stack_depth)
-    _rl_parsing_conditionalized_out = if_stack[--if_stack_depth];
-  else
-    _rl_init_file_error ("$endif without matching $if");
-  return 0;
-}
-
-static int
-parser_include (args)
-     char *args;
-{
-  const char *old_init_file;
-  char *e;
-  int old_line_number, old_include_level, r;
-
-  if (_rl_parsing_conditionalized_out)
-    return (0);
-
-  old_init_file = current_readline_init_file;
-  old_line_number = current_readline_init_lineno;
-  old_include_level = current_readline_init_include_level;
-
-  e = strchr (args, '\n');
-  if (e)
-    *e = '\0';
-  r = _rl_read_init_file ((const char *)args, old_include_level + 1);
-
-  current_readline_init_file = old_init_file;
-  current_readline_init_lineno = old_line_number;
-  current_readline_init_include_level = old_include_level;
-
-  return r;
-}
-  
-/* Associate textual names with actual functions. */
-static struct {
-  const char *name;
-  _rl_parser_func_t *function;
-} parser_directives [] = {
-  { "if", parser_if },
-  { "endif", parser_endif },
-  { "else", parser_else },
-  { "include", parser_include },
-  { (char *)0x0, (_rl_parser_func_t *)0x0 }
-};
-
-/* Handle a parser directive.  STATEMENT is the line of the directive
-   without any leading `$'. */
-static int
-handle_parser_directive (statement)
-     char *statement;
-{
-  register int i;
-  char *directive, *args;
-
-  /* Isolate the actual directive. */
-
-  /* Skip whitespace. */
-  for (i = 0; whitespace (statement[i]); i++);
-
-  directive = &statement[i];
-
-  for (; statement[i] && !whitespace (statement[i]); i++);
-
-  if (statement[i])
-    statement[i++] = '\0';
-
-  for (; statement[i] && whitespace (statement[i]); i++);
-
-  args = &statement[i];
-
-  /* Lookup the command, and act on it. */
-  for (i = 0; parser_directives[i].name; i++)
-    if (_rl_stricmp (directive, parser_directives[i].name) == 0)
-      {
-	(*parser_directives[i].function) (args);
-	return (0);
-      }
-
-  /* display an error message about the unknown parser directive */
-  _rl_init_file_error ("unknown parser directive");
-  return (1);
-}
-
-/* Read the binding command from STRING and perform it.
-   A key binding command looks like: Keyname: function-name\0,
-   a variable binding command looks like: set variable value.
-   A new-style keybinding looks like "\C-x\C-x": exchange-point-and-mark. */
-int
-rl_parse_and_bind (string)
-     char *string;
-{
-  char *funname, *kname;
-  register int c, i;
-  int key, equivalency;
-
-  while (string && whitespace (*string))
-    string++;
-
-  if (!string || !*string || *string == '#')
-    return 0;
-
-  /* If this is a parser directive, act on it. */
-  if (*string == '$')
-    {
-      handle_parser_directive (&string[1]);
-      return 0;
-    }
-
-  /* If we aren't supposed to be parsing right now, then we're done. */
-  if (_rl_parsing_conditionalized_out)
-    return 0;
-
-  i = 0;
-  /* If this keyname is a complex key expression surrounded by quotes,
-     advance to after the matching close quote.  This code allows the
-     backslash to quote characters in the key expression. */
-  if (*string == '"')
-    {
-      int passc = 0;
-
-      for (i = 1; c = string[i]; i++)
-	{
-	  if (passc)
-	    {
-	      passc = 0;
-	      continue;
-	    }
-
-	  if (c == '\\')
-	    {
-	      passc++;
-	      continue;
-	    }
-
-	  if (c == '"')
-	    break;
-	}
-      /* If we didn't find a closing quote, abort the line. */
-      if (string[i] == '\0')
-        {
-          _rl_init_file_error ("no closing `\"' in key binding");
-          return 1;
-        }
-    }
-
-  /* Advance to the colon (:) or whitespace which separates the two objects. */
-  for (; (c = string[i]) && c != ':' && c != ' ' && c != '\t'; i++ );
-
-  equivalency = (c == ':' && string[i + 1] == '=');
-
-  /* Mark the end of the command (or keyname). */
-  if (string[i])
-    string[i++] = '\0';
-
-  /* If doing assignment, skip the '=' sign as well. */
-  if (equivalency)
-    string[i++] = '\0';
-
-  /* If this is a command to set a variable, then do that. */
-  if (_rl_stricmp (string, "set") == 0)
-    {
-      char *var = string + i;
-      char *value;
-
-      /* Make VAR point to start of variable name. */
-      while (*var && whitespace (*var)) var++;
-
-      /* Make value point to start of value string. */
-      value = var;
-      while (*value && !whitespace (*value)) value++;
-      if (*value)
-	*value++ = '\0';
-      while (*value && whitespace (*value)) value++;
-
-      rl_variable_bind (var, value);
-      return 0;
-    }
-
-  /* Skip any whitespace between keyname and funname. */
-  for (; string[i] && whitespace (string[i]); i++);
-  funname = &string[i];
-
-  /* Now isolate funname.
-     For straight function names just look for whitespace, since
-     that will signify the end of the string.  But this could be a
-     macro definition.  In that case, the string is quoted, so skip
-     to the matching delimiter.  We allow the backslash to quote the
-     delimiter characters in the macro body. */
-  /* This code exists to allow whitespace in macro expansions, which
-     would otherwise be gobbled up by the next `for' loop.*/
-  /* XXX - it may be desirable to allow backslash quoting only if " is
-     the quoted string delimiter, like the shell. */
-  if (*funname == '\'' || *funname == '"')
-    {
-      int delimiter = string[i++], passc;
-
-      for (passc = 0; c = string[i]; i++)
-	{
-	  if (passc)
-	    {
-	      passc = 0;
-	      continue;
-	    }
-
-	  if (c == '\\')
-	    {
-	      passc = 1;
-	      continue;
-	    }
-
-	  if (c == delimiter)
-	    break;
-	}
-      if (c)
-	i++;
-    }
-
-  /* Advance to the end of the string.  */
-  for (; string[i] && !whitespace (string[i]); i++);
-
-  /* No extra whitespace at the end of the string. */
-  string[i] = '\0';
-
-  /* Handle equivalency bindings here.  Make the left-hand side be exactly
-     whatever the right-hand evaluates to, including keymaps. */
-  if (equivalency)
-    {
-      return 0;
-    }
-
-  /* If this is a new-style key-binding, then do the binding with
-     rl_set_key ().  Otherwise, let the older code deal with it. */
-  if (*string == '"')
-    {
-      char *seq;
-      register int j, k, passc;
-
-      seq = xmalloc (1 + strlen (string));
-      for (j = 1, k = passc = 0; string[j]; j++)
-	{
-	  /* Allow backslash to quote characters, but leave them in place.
-	     This allows a string to end with a backslash quoting another
-	     backslash, or with a backslash quoting a double quote.  The
-	     backslashes are left in place for rl_translate_keyseq (). */
-	  if (passc || (string[j] == '\\'))
-	    {
-	      seq[k++] = string[j];
-	      passc = !passc;
-	      continue;
-	    }
-
-	  if (string[j] == '"')
-	    break;
-
-	  seq[k++] = string[j];
-	}
-      seq[k] = '\0';
-
-      /* Binding macro? */
-      if (*funname == '\'' || *funname == '"')
-	{
-	  j = strlen (funname);
-
-	  /* Remove the delimiting quotes from each end of FUNNAME. */
-	  if (j && funname[j - 1] == *funname)
-	    funname[j - 1] = '\0';
-
-	  rl_macro_bind (seq, &funname[1], _rl_keymap);
-	}
-      else
-	rl_set_key (seq, rl_named_function (funname), _rl_keymap);
-
-      free (seq);
-      return 0;
-    }
-
-  /* Get the actual character we want to deal with. */
-  kname = strrchr (string, '-');
-  if (!kname)
-    kname = string;
-  else
-    kname++;
-
-  key = glean_key_from_name (kname);
-
-  /* Add in control and meta bits. */
-  if (substring_member_of_array (string, _rl_possible_control_prefixes))
-    key = CTRL (_rl_to_upper (key));
-
-  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
-    key = META (key);
-
-  /* Temporary.  Handle old-style keyname with macro-binding. */
-  if (*funname == '\'' || *funname == '"')
-    {
-      unsigned char useq[2];
-      int fl = strlen (funname);
-
-      useq[0] = key; useq[1] = '\0';
-      if (fl && funname[fl - 1] == *funname)
-	funname[fl - 1] = '\0';
-
-      rl_macro_bind (useq, &funname[1], _rl_keymap);
-    }
-#if defined (PREFIX_META_HACK)
-  /* Ugly, but working hack to keep prefix-meta around. */
-  else if (_rl_stricmp (funname, "prefix-meta") == 0)
-    {
-      char seq[2];
-
-      seq[0] = key;
-      seq[1] = '\0';
-      rl_generic_bind (ISKMAP, seq, (char *)emacs_meta_keymap, _rl_keymap);
-    }
-#endif /* PREFIX_META_HACK */
-  else
-    rl_bind_key (key, rl_named_function (funname));
-  return 0;
-}
-
-/* Simple structure for boolean readline variables (i.e., those that can
-   have one of two values; either "On" or 1 for truth, or "Off" or 0 for
-   false. */
-
-#define V_SPECIAL	0x1
-
-static struct {
-  const char *name;
-  int *value;
-  int flags;
-} boolean_varlist [] = {
-  { "blink-matching-paren",	&rl_blink_matching_paren,	V_SPECIAL },
-  { "completion-ignore-case",	&_rl_completion_case_fold,	0 },
-  { "convert-meta",		&_rl_convert_meta_chars_to_ascii, 0 },
-  { "disable-completion",	&rl_inhibit_completion,		0 },
-  { "enable-keypad",		&_rl_enable_keypad,		0 },
-  { "expand-tilde",		&rl_complete_with_tilde_expansion, 0 },
-  { "horizontal-scroll-mode",	&_rl_horizontal_scroll_mode,	0 },
-  { "input-meta",		&_rl_meta_flag,			0 },
-  { "mark-directories",		&_rl_complete_mark_directories,	0 },
-  { "mark-modified-lines",	&_rl_mark_modified_lines,	0 },
-  { "meta-flag",		&_rl_meta_flag,			0 },
-  { "output-meta",		&_rl_output_meta_chars,		0 },
-  { "prefer-visible-bell",	&_rl_prefer_visible_bell,	V_SPECIAL },
-  { "print-completions-horizontally", &_rl_print_completions_horizontally, 0 },
-  { "show-all-if-ambiguous",	&_rl_complete_show_all,		0 },
-#if defined (VISIBLE_STATS)
-  { "visible-stats",		&rl_visible_stats,		0 },
-#endif /* VISIBLE_STATS */
-  { (char *)NULL, (int *)NULL }
-};
-
-static int
-find_boolean_var (name)
-     char *name;
-{
-  register int i;
-
-  for (i = 0; boolean_varlist[i].name; i++)
-    if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
-      return i;
-  return -1;
-}
-
-/* Hooks for handling special boolean variables, where a
-   function needs to be called or another variable needs
-   to be changed when they're changed. */
-static void
-hack_special_boolean_var (i)
-     int i;
-{
-  const char *name;
-
-  name = boolean_varlist[i].name;
-
-  if (_rl_stricmp (name, "blink-matching-paren") == 0)
-    _rl_enable_paren_matching (rl_blink_matching_paren);
-  else if (_rl_stricmp (name, "prefer-visible-bell") == 0)
-    {
-      if (_rl_prefer_visible_bell)
-	_rl_bell_preference = VISIBLE_BELL;
-      else
-	_rl_bell_preference = AUDIBLE_BELL;
-    }
-}
-
-typedef int _rl_sv_func_t __P((const char *));
-
-/* These *must* correspond to the array indices for the appropriate
-   string variable.  (Though they're not used right now.) */
-#define V_BELLSTYLE	0
-#define V_COMBEGIN	1
-#define V_EDITMODE	2
-#define V_ISRCHTERM	3
-#define V_KEYMAP	4
-
-#define	V_STRING	1
-#define V_INT		2
-
-/* Forward declarations */
-static int sv_bell_style __P((const char *));
-static int sv_combegin __P((const char *));
-static int sv_compquery __P((const char *));
-static int sv_editmode __P((const char *));
-static int sv_isrchterm __P((const char *));
-static int sv_keymap __P((const char *));
-
-static struct {
-  const char *name;
-  int flags;
-  _rl_sv_func_t *set_func;
-} string_varlist[] = {
-  { "bell-style",	V_STRING,	sv_bell_style },
-  { "comment-begin",	V_STRING,	sv_combegin },
-  { "completion-query-items", V_INT,	sv_compquery },
-  { "editing-mode",	V_STRING,	sv_editmode },
-  { "isearch-terminators", V_STRING,	sv_isrchterm },
-  { "keymap",		V_STRING,	sv_keymap },
-  { (char *)NULL,	0 }
-};
-
-static int
-find_string_var (name)
-     char *name;
-{
-  register int i;
-
-  for (i = 0; string_varlist[i].name; i++)
-    if (_rl_stricmp (name, string_varlist[i].name) == 0)
-      return i;
-  return -1;
-}
-
-/* A boolean value that can appear in a `set variable' command is true if
-   the value is null or empty, `on' (case-insenstive), or "1".  Any other
-   values result in 0 (false). */
-static int
-bool_to_int (value)
-     char *value;
-{
-  return (value == 0 || *value == '\0' ||
-		(_rl_stricmp (value, "on") == 0) ||
-		(value[0] == '1' && value[1] == '\0'));
-}
-
-int
-rl_variable_bind (name, value)
-     const char *name, *value;
-{
-  register int i;
-  int	v;
-
-  /* Check for simple variables first. */
-  i = find_boolean_var (name);
-  if (i >= 0)
-    {
-      *boolean_varlist[i].value = bool_to_int (value);
-      if (boolean_varlist[i].flags & V_SPECIAL)
-	hack_special_boolean_var (i);
-      return 0;
-    }
-
-  i = find_string_var (name);
-
-  /* For the time being, unknown variable names or string names without a
-     handler function are simply ignored. */
-  if (i < 0 || string_varlist[i].set_func == 0)
-    return 0;
-
-  v = (*string_varlist[i].set_func) (value);
-  return v;
-}
-
-static int
-sv_editmode (value)
-     const char *value;
-{
-  if (_rl_strnicmp (value, "vi", 2) == 0)
-    {
-#if defined (VI_MODE)
-      _rl_keymap = vi_insertion_keymap;
-      rl_editing_mode = vi_mode;
-#endif /* VI_MODE */
-      return 0;
-    }
-  else if (_rl_strnicmp (value, "emacs", 5) == 0)
-    {
-      _rl_keymap = emacs_standard_keymap;
-      rl_editing_mode = emacs_mode;
-      return 0;
-    }
-  return 1;
-}
-
-static int
-sv_combegin (value)
-     const char *value;
-{
-  if (value && *value)
-    {
-      FREE (_rl_comment_begin);
-      _rl_comment_begin = savestring (value);
-      return 0;
-    }
-  return 1;
-}
-
-static int
-sv_compquery (value)
-     const char *value;
-{
-  int nval = 100;
-
-  if (value && *value)
-    {
-      nval = atoi (value);
-      if (nval < 0)
-	nval = 0;
-    }
-  rl_completion_query_items = nval;
-  return 0;
-}
-
-static int
-sv_keymap (value)
-     const char *value;
-{
-  Keymap kmap;
-
-  kmap = rl_get_keymap_by_name (value);
-  if (kmap)
-    {
-      rl_set_keymap (kmap);
-      return 0;
-    }
-  return 1;
-}
-
-#define _SET_BELL(v)	do { _rl_bell_preference = v; return 0; } while (0)
-
-static int
-sv_bell_style (value)
-     const char *value;
-{
-  if (value == 0 || *value == '\0')
-    _SET_BELL (AUDIBLE_BELL);
-  else if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
-    _SET_BELL (NO_BELL);
-  else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
-    _SET_BELL (AUDIBLE_BELL);
-  else if (_rl_stricmp (value, "visible") == 0)
-    _SET_BELL (VISIBLE_BELL);
-  else
-    return 1;
-}
-#undef _SET_BELL
-
-static int
-sv_isrchterm (value)
-     const char *value;
-{
-  int beg, end, delim;
-  char *v;
-
-  if (value == 0)
-    return 1;
-
-  /* Isolate the value and translate it into a character string. */
-  v = savestring (value);
-  FREE (_rl_isearch_terminators);
-  if (v[0] == '"' || v[0] == '\'')
-    {
-      delim = v[0];
-      for (beg = end = 1; v[end] && v[end] != delim; end++)
-	;
-    }
-  else
-    {
-      for (beg = end = 0; whitespace (v[end]) == 0; end++)
-	;
-    }
-
-  v[end] = '\0';
-
-  /* The value starts at v + beg.  Translate it into a character string. */
-  _rl_isearch_terminators = (unsigned char *)xmalloc (2 * strlen (v) + 1);
-  rl_translate_keyseq (v + beg, _rl_isearch_terminators, &end);
-  _rl_isearch_terminators[end] = '\0';
-
-  free (v);
-  return 0;
-}
-      
-/* Return the character which matches NAME.
-   For example, `Space' returns ' '. */
-
-typedef struct {
-  const char *name;
-  int value;
-} assoc_list;
-
-static assoc_list name_key_alist[] = {
-  { "DEL", 0x7f },
-  { "ESC", '\033' },
-  { "Escape", '\033' },
-  { "LFD", '\n' },
-  { "Newline", '\n' },
-  { "RET", '\r' },
-  { "Return", '\r' },
-  { "Rubout", 0x7f },
-  { "SPC", ' ' },
-  { "Space", ' ' },
-  { "Tab", 0x09 },
-  { (char *)0x0, 0 }
-};
-
-static int
-glean_key_from_name (name)
-     char *name;
-{
-  register int i;
-
-  for (i = 0; name_key_alist[i].name; i++)
-    if (_rl_stricmp (name, name_key_alist[i].name) == 0)
-      return (name_key_alist[i].value);
-
-  return (*(unsigned char *)name);	/* XXX was return (*name) */
-}
-
-/* Auxiliary functions to manage keymaps. */
-static struct {
-  const char *name;
-  Keymap map;
-} keymap_names[] = {
-  { "emacs", emacs_standard_keymap },
-  { "emacs-standard", emacs_standard_keymap },
-  { "emacs-meta", emacs_meta_keymap },
-  { "emacs-ctlx", emacs_ctlx_keymap },
-#if defined (VI_MODE)
-  { "vi", vi_movement_keymap },
-  { "vi-move", vi_movement_keymap },
-  { "vi-command", vi_movement_keymap },
-  { "vi-insert", vi_insertion_keymap },
-#endif /* VI_MODE */
-  { (char *)0x0, (Keymap)0x0 }
-};
-
-Keymap
-rl_get_keymap_by_name (name)
-     const char *name;
-{
-  register int i;
-
-  for (i = 0; keymap_names[i].name; i++)
-    if (_rl_stricmp (name, keymap_names[i].name) == 0)
-      return (keymap_names[i].map);
-  return ((Keymap) NULL);
-}
-
-char *
-rl_get_keymap_name (map)
-     Keymap map;
-{
-  register int i;
-  for (i = 0; keymap_names[i].name; i++)
-    if (map == keymap_names[i].map)
-      return ((char *)keymap_names[i].name);
-  return ((char *)NULL);
-}
-  
-void
-rl_set_keymap (map)
-     Keymap map;
-{
-  if (map)
-    _rl_keymap = map;
-}
-
-Keymap
-rl_get_keymap ()
-{
-  return (_rl_keymap);
-}
-
-void
-rl_set_keymap_from_edit_mode ()
-{
-  if (rl_editing_mode == emacs_mode)
-    _rl_keymap = emacs_standard_keymap;
-#if defined (VI_MODE)
-  else if (rl_editing_mode == vi_mode)
-    _rl_keymap = vi_insertion_keymap;
-#endif /* VI_MODE */
-}
-
-char *
-rl_get_keymap_name_from_edit_mode ()
-{
-  if (rl_editing_mode == emacs_mode)
-    return "emacs";
-#if defined (VI_MODE)
-  else if (rl_editing_mode == vi_mode)
-    return "vi";
-#endif /* VI_MODE */
-  else
-    return "none";
-}
-
-/* **************************************************************** */
-/*								    */
-/*		  Key Binding and Function Information		    */
-/*								    */
-/* **************************************************************** */
-
-/* Each of the following functions produces information about the
-   state of keybindings and functions known to Readline.  The info
-   is always printed to rl_outstream, and in such a way that it can
-   be read back in (i.e., passed to rl_parse_and_bind (). */
-
-/* Print the names of functions known to Readline. */
-void
-rl_list_funmap_names ()
-{
-  register int i;
-  const char **funmap_names;
-
-  funmap_names = rl_funmap_names ();
-
-  if (!funmap_names)
-    return;
-
-  for (i = 0; funmap_names[i]; i++)
-    fprintf (rl_outstream, "%s\n", funmap_names[i]);
-
-  free (funmap_names);
-}
-
-static char *
-_rl_get_keyname (key)
-     int key;
-{
-  char *keyname;
-  int i, c;
-
-  keyname = (char *)xmalloc (8);
-
-  c = key;
-  /* Since this is going to be used to write out keysequence-function
-     pairs for possible inclusion in an inputrc file, we don't want to
-     do any special meta processing on KEY. */
-
-#if 0
-  /* We might want to do this, but the old version of the code did not. */
-
-  /* If this is an escape character, we don't want to do any more processing.
-     Just add the special ESC key sequence and return. */
-  if (c == ESC)
-    {
-      keyseq[0] = '\\';
-      keyseq[1] = 'e';
-      keyseq[2] = '\0';
-      return keyseq;
-    }
-#endif
-
-  /* RUBOUT is translated directly into \C-? */
-  if (key == RUBOUT)
-    {
-      keyname[0] = '\\';
-      keyname[1] = 'C';
-      keyname[2] = '-';
-      keyname[3] = '?';
-      keyname[4] = '\0';
-      return keyname;
-    }
-
-  i = 0;
-  /* Now add special prefixes needed for control characters.  This can
-     potentially change C. */
-  if (CTRL_CHAR (c))
-    {
-      keyname[i++] = '\\';
-      keyname[i++] = 'C';
-      keyname[i++] = '-';
-      c = _rl_to_lower (UNCTRL (c));
-    }
-
-  /* XXX experimental code.  Turn the characters that are not ASCII or
-     ISO Latin 1 (128 - 159) into octal escape sequences (\200 - \237).
-     This changes C. */
-  if (c >= 128 && c <= 159)
-    {
-      keyname[i++] = '\\';
-      keyname[i++] = '2';
-      c -= 128;
-      keyname[i++] = (c / 8) + '0';
-      c = (c % 8) + '0';
-    }
-
-  /* Now, if the character needs to be quoted with a backslash, do that. */
-  if (c == '\\' || c == '"')
-    keyname[i++] = '\\';
-
-  /* Now add the key, terminate the string, and return it. */
-  keyname[i++] = (char) c;
-  keyname[i] = '\0';
-
-  return keyname;
-}
-
-/* Return a NULL terminated array of strings which represent the key
-   sequences that are used to invoke FUNCTION in MAP. */
-char **
-rl_invoking_keyseqs_in_map (function, map)
-     rl_command_func_t *function;
-     Keymap map;
-{
-  register int key;
-  char **result;
-  int result_index, result_size;
-
-  result = (char **)NULL;
-  result_index = result_size = 0;
-
-  for (key = 0; key < KEYMAP_SIZE; key++)
-    {
-      switch (map[key].type)
-	{
-	case ISMACR:
-	  /* Macros match, if, and only if, the pointers are identical.
-	     Thus, they are treated exactly like functions in here. */
-	case ISFUNC:
-	  /* If the function in the keymap is the one we are looking for,
-	     then add the current KEY to the list of invoking keys. */
-	  if (map[key].function == function)
-	    {
-	      char *keyname;
-
-	      keyname = _rl_get_keyname (key);
-
-	      if (result_index + 2 > result_size)
-	        {
-	          result_size += 10;
-		  result = (char **) xrealloc (result, result_size * sizeof (char *));
-	        }
-
-	      result[result_index++] = keyname;
-	      result[result_index] = (char *)NULL;
-	    }
-	  break;
-
-	case ISKMAP:
-	  {
-	    char **seqs;
-	    register int i;
-
-	    /* Find the list of keyseqs in this map which have FUNCTION as
-	       their target.  Add the key sequences found to RESULT. */
-	    if (map[key].function)
-	      seqs =
-	        rl_invoking_keyseqs_in_map (function, FUNCTION_TO_KEYMAP (map, key));
-	    else
-	      break;
-
-	    if (seqs == 0)
-	      break;
-
-	    for (i = 0; seqs[i]; i++)
-	      {
-		char *keyname = (char *)xmalloc (6 + strlen (seqs[i]));
-
-		if (key == ESC)
-		  sprintf (keyname, "\\e");
-		else if (CTRL_CHAR (key))
-		  sprintf (keyname, "\\C-%c", _rl_to_lower (UNCTRL (key)));
-		else if (key == RUBOUT)
-		  sprintf (keyname, "\\C-?");
-		else if (key == '\\' || key == '"')
-		  {
-		    keyname[0] = '\\';
-		    keyname[1] = (char) key;
-		    keyname[2] = '\0';
-		  }
-		else
-		  {
-		    keyname[0] = (char) key;
-		    keyname[1] = '\0';
-		  }
-		
-		strcat (keyname, seqs[i]);
-		free (seqs[i]);
-
-		if (result_index + 2 > result_size)
-		  {
-		    result_size += 10;
-		    result = (char **) xrealloc (result, result_size * sizeof (char *));
-		  }
-
-		result[result_index++] = keyname;
-		result[result_index] = (char *)NULL;
-	      }
-
-	    free (seqs);
-	  }
-	  break;
-	}
-    }
-  return (result);
-}
-
-/* Return a NULL terminated array of strings which represent the key
-   sequences that can be used to invoke FUNCTION using the current keymap. */
-char **
-rl_invoking_keyseqs (function)
-     rl_command_func_t *function;
-{
-  return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
-}
-
-/* Print all of the functions and their bindings to rl_outstream.  If
-   PRINT_READABLY is non-zero, then print the output in such a way
-   that it can be read back in. */
-void
-rl_function_dumper (print_readably)
-     int print_readably;
-{
-  register int i;
-  const char **names;
-  const char *name;
-
-  names = rl_funmap_names ();
-
-  fprintf (rl_outstream, "\n");
-
-  for (i = 0; name = names[i]; i++)
-    {
-      rl_command_func_t *function;
-      char **invokers;
-
-      function = rl_named_function (name);
-      invokers = rl_invoking_keyseqs_in_map (function, _rl_keymap);
-
-      if (print_readably)
-	{
-	  if (!invokers)
-	    fprintf (rl_outstream, "# %s (not bound)\n", name);
-	  else
-	    {
-	      register int j;
-
-	      for (j = 0; invokers[j]; j++)
-		{
-		  fprintf (rl_outstream, "\"%s\": %s\n",
-			   invokers[j], name);
-		  free (invokers[j]);
-		}
-
-	      free (invokers);
-	    }
-	}
-      else
-	{
-	  if (!invokers)
-	    fprintf (rl_outstream, "%s is not bound to any keys\n",
-		     name);
-	  else
-	    {
-	      register int j;
-
-	      fprintf (rl_outstream, "%s can be found on ", name);
-
-	      for (j = 0; invokers[j] && j < 5; j++)
-		{
-		  fprintf (rl_outstream, "\"%s\"%s", invokers[j],
-			   invokers[j + 1] ? ", " : ".\n");
-		}
-
-	      if (j == 5 && invokers[j])
-		fprintf (rl_outstream, "...\n");
-
-	      for (j = 0; invokers[j]; j++)
-		free (invokers[j]);
-
-	      free (invokers);
-	    }
-	}
-    }
-}
-
-/* Print all of the current functions and their bindings to
-   rl_outstream.  If an explicit argument is given, then print
-   the output in such a way that it can be read back in. */
-int
-rl_dump_functions (count, key)
-     int count, key;
-{
-  if (rl_dispatching)
-    fprintf (rl_outstream, "\r\n");
-  rl_function_dumper (rl_explicit_arg);
-  rl_on_new_line ();
-  return (0);
-}
-
-static void
-_rl_macro_dumper_internal (print_readably, map, prefix)
-     int print_readably;
-     Keymap map;
-     char *prefix;
-{
-  register int key;
-  char *keyname, *out;
-  int prefix_len;
-
-  for (key = 0; key < KEYMAP_SIZE; key++)
-    {
-      switch (map[key].type)
-	{
-	case ISMACR:
-	  keyname = _rl_get_keyname (key);
-#if 0
-	  out = (char *)map[key].function;
-#else
-	  out = _rl_untranslate_macro_value ((char *)map[key].function);
-#endif
-	  if (print_readably)
-	    fprintf (rl_outstream, "\"%s%s\": \"%s\"\n", prefix ? prefix : "",
-						         keyname,
-						         out ? out : "");
-	  else
-	    fprintf (rl_outstream, "%s%s outputs %s\n", prefix ? prefix : "",
-							keyname,
-							out ? out : "");
-	  free (keyname);
-#if 1
-	  free (out);
-#endif
-	  break;
-	case ISFUNC:
-	  break;
-	case ISKMAP:
-	  prefix_len = prefix ? strlen (prefix) : 0;
-	  if (key == ESC)
-	    {
-	      keyname = xmalloc (3 + prefix_len);
-	      if (prefix)
-		strcpy (keyname, prefix);
-	      keyname[prefix_len] = '\\';
-	      keyname[prefix_len + 1] = 'e';
-	      keyname[prefix_len + 2] = '\0';
-	    }
-	  else
-	    {
-	      keyname = _rl_get_keyname (key);
-	      if (prefix)
-		{
-		  out = xmalloc (strlen (keyname) + prefix_len + 1);
-		  strcpy (out, prefix);
-		  strcpy (out + prefix_len, keyname);
-		  free (keyname);
-		  keyname = out;
-		}
-	    }
-
-	  _rl_macro_dumper_internal (print_readably, FUNCTION_TO_KEYMAP (map, key), keyname);
-	  free (keyname);
-	  break;
-	}
-    }
-}
-
-void
-rl_macro_dumper (print_readably)
-     int print_readably;
-{
-  _rl_macro_dumper_internal (print_readably, _rl_keymap, (char *)NULL);
-}
-
-int
-rl_dump_macros (count, key)
-     int count, key;
-{
-  if (rl_dispatching)
-    fprintf (rl_outstream, "\r\n");
-  rl_macro_dumper (rl_explicit_arg);
-  rl_on_new_line ();
-  return (0);
-}
-
-void
-rl_variable_dumper (print_readably)
-     int print_readably;
-{
-  int i;
-  const char *kname;
-
-  for (i = 0; boolean_varlist[i].name; i++)
-    {
-      if (print_readably)
-        fprintf (rl_outstream, "set %s %s\n", boolean_varlist[i].name,
-			       *boolean_varlist[i].value ? "on" : "off");
-      else
-        fprintf (rl_outstream, "%s is set to `%s'\n", boolean_varlist[i].name,
-			       *boolean_varlist[i].value ? "on" : "off");
-    }
-
-  /* bell-style */
-  switch (_rl_bell_preference)
-    {
-    case NO_BELL:
-      kname = "none"; break;
-    case VISIBLE_BELL:
-      kname = "visible"; break;
-    case AUDIBLE_BELL:
-    default:
-      kname = "audible"; break;
-    }
-  if (print_readably)
-    fprintf (rl_outstream, "set bell-style %s\n", kname);
-  else
-    fprintf (rl_outstream, "bell-style is set to `%s'\n", kname);
-
-  /* comment-begin */
-  if (print_readably)
-    fprintf (rl_outstream, "set comment-begin %s\n", _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
-  else
-    fprintf (rl_outstream, "comment-begin is set to `%s'\n", _rl_comment_begin ? _rl_comment_begin : "");
-
-  /* completion-query-items */
-  if (print_readably)
-    fprintf (rl_outstream, "set completion-query-items %d\n", rl_completion_query_items);
-  else
-    fprintf (rl_outstream, "completion-query-items is set to `%d'\n", rl_completion_query_items);
-
-  /* editing-mode */
-  if (print_readably)
-    fprintf (rl_outstream, "set editing-mode %s\n", (rl_editing_mode == emacs_mode) ? "emacs" : "vi");
-  else
-    fprintf (rl_outstream, "editing-mode is set to `%s'\n", (rl_editing_mode == emacs_mode) ? "emacs" : "vi");
-
-  /* keymap */
-  kname = rl_get_keymap_name (_rl_keymap);
-  if (kname == 0)
-    kname = rl_get_keymap_name_from_edit_mode ();
-  if (print_readably)
-    fprintf (rl_outstream, "set keymap %s\n", kname ? kname : "none");
-  else
-    fprintf (rl_outstream, "keymap is set to `%s'\n", kname ? kname : "none");
-
-  /* isearch-terminators */
-  if (_rl_isearch_terminators)
-    {
-      char *disp;
-
-      disp = _rl_untranslate_macro_value (_rl_isearch_terminators);
-
-      if (print_readably)
-	fprintf (rl_outstream, "set isearch-terminators \"%s\"\n", disp);
-      else
-	fprintf (rl_outstream, "isearch-terminators is set to \"%s\"\n", disp);
-
-      free (disp);
-    }
-}
-
-/* Print all of the current variables and their values to
-   rl_outstream.  If an explicit argument is given, then print
-   the output in such a way that it can be read back in. */
-int
-rl_dump_variables (count, key)
-     int count, key;
-{
-  if (rl_dispatching)
-    fprintf (rl_outstream, "\r\n");
-  rl_variable_dumper (rl_explicit_arg);
-  rl_on_new_line ();
-  return (0);
-}
-
-/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound. */
-void
-_rl_bind_if_unbound (keyseq, default_func)
-     const char *keyseq;
-     rl_command_func_t *default_func;
-{
-  rl_command_func_t *func;
-
-  if (keyseq)
-    {
-      func = rl_function_of_keyseq (keyseq, _rl_keymap, (int *)NULL);
-      if (!func || func == rl_do_lowercase_version)
-	rl_set_key (keyseq, default_func, _rl_keymap);
-    }
-}
-
-/* Return non-zero if any members of ARRAY are a substring in STRING. */
-static int
-substring_member_of_array (string, array)
-     char *string;
-     const char **array;
-{
-  while (*array)
-    {
-      if (_rl_strindex (string, *array))
-	return (1);
-      array++;
-    }
-  return (0);
-}
diff --git a/readline/callback.c b/readline/callback.c
deleted file mode 100644
--- a/readline/callback.c
+++ /dev/null
@@ -1,149 +0,0 @@
-/* callback.c -- functions to use readline as an X `callback' mechanism. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include "rlconf.h"
-
-#if defined (READLINE_CALLBACKS)
-
-#include <sys/types.h>
-#include <stdio.h>
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-#include "readline.h"
-#include "rlprivate.h"
-
-/* **************************************************************** */
-/*								    */
-/*			Callback Readline Functions                 */
-/*								    */
-/* **************************************************************** */
-
-/* Allow using readline in situations where a program may have multiple
-   things to handle at once, and dispatches them via select().  Call
-   rl_callback_handler_install() with the prompt and a function to call
-   whenever a complete line of input is ready.  The user must then
-   call rl_callback_read_char() every time some input is available, and 
-   rl_callback_read_char() will call the user's function with the complete
-   text read in at each end of line.  The terminal is kept prepped and
-   signals handled all the time, except during calls to the user's function. */
-
-rl_vcpfunc_t *rl_linefunc;		/* user callback function */
-static int in_handler;		/* terminal_prepped and signals set? */
-
-/* Make sure the terminal is set up, initialize readline, and prompt. */
-static void
-_rl_callback_newline ()
-{
-  rl_initialize ();
-
-  if (in_handler == 0)
-    {
-      in_handler = 1;
-
-      (*rl_prep_term_function) (_rl_meta_flag);
-
-#if defined (HANDLE_SIGNALS)
-      rl_set_signals ();
-#endif
-    }
-
-  readline_internal_setup ();
-}
-
-/* Install a readline handler, set up the terminal, and issue the prompt. */
-void
-rl_callback_handler_install (prompt, linefunc)
-     const char *prompt;
-     rl_vcpfunc_t *linefunc;
-{
-  rl_set_prompt (prompt);
-  rl_linefunc = linefunc;
-  _rl_callback_newline ();
-}
-
-/* Read one character, and dispatch to the handler if it ends the line. */
-void
-rl_callback_read_char ()
-{
-  char *line;
-  int eof;
-
-  if (rl_linefunc == NULL)
-    {
-      fprintf (stderr, "readline: readline_callback_read_char() called with no handler!\r\n");
-      abort ();
-    }
-
-  eof = readline_internal_char ();
-
-  /* We loop in case some function has pushed input back with rl_execute_next. */
-  for (;;)
-    {
-      if (rl_done)
-	{
-	  line = readline_internal_teardown (eof);
-
-	  (*rl_deprep_term_function) ();
-#if defined (HANDLE_SIGNALS)
-	  rl_clear_signals ();
-#endif
-	  in_handler = 0;
-	  (*rl_linefunc) (line);
-
-	  /* If the user did not clear out the line, do it for him. */
-	  if (rl_line_buffer[0])
-	    _rl_init_line_state ();
-
-	  /* Redisplay the prompt if readline_handler_{install,remove}
-	     not called. */
-	  if (in_handler == 0 && rl_linefunc)
-	    _rl_callback_newline ();
-	}
-      if (rl_pending_input)
-	eof = readline_internal_char ();
-      else
-        break;
-    }
-}
-
-/* Remove the handler, and make sure the terminal is in its normal state. */
-void
-rl_callback_handler_remove ()
-{
-  rl_linefunc = NULL;
-  if (in_handler)
-    {
-      in_handler = 0;
-      (*rl_deprep_term_function) ();
-#if defined (HANDLE_SIGNALS)
-      rl_clear_signals ();
-#endif
-    }
-}
-
-#endif
diff --git a/readline/chardefs.h b/readline/chardefs.h
deleted file mode 100644
--- a/readline/chardefs.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/* chardefs.h -- Character definitions for readline. */
-
-/* Copyright (C) 1994 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#ifndef _CHARDEFS_H_
-#define _CHARDEFS_H_
-
-#include <ctype.h>
-
-#if defined (HAVE_CONFIG_H)
-#  if defined (HAVE_STRING_H)
-#    include <string.h>
-#  else
-#    include <strings.h>
-#  endif /* HAVE_STRING_H */
-#else
-#  include <string.h>
-#endif /* !HAVE_CONFIG_H */
-
-#ifndef whitespace
-#define whitespace(c) (((c) == ' ') || ((c) == '\t'))
-#endif
-
-#ifdef CTRL
-#undef CTRL
-#endif
-
-/* Some character stuff. */
-#define control_character_threshold 0x020   /* Smaller than this is control. */
-#define control_character_mask 0x1f	    /* 0x20 - 1 */
-#define meta_character_threshold 0x07f	    /* Larger than this is Meta. */
-#define control_character_bit 0x40	    /* 0x000000, must be off. */
-#define meta_character_bit 0x080	    /* x0000000, must be on. */
-#define largest_char 255		    /* Largest character value. */
-
-#define CTRL_CHAR(c) ((c) < control_character_threshold && (((c) & 0x80) == 0))
-#define META_CHAR(c) ((c) > meta_character_threshold && (c) <= largest_char)
-
-#define CTRL(c) ((c) & control_character_mask)
-#define META(c) ((c) | meta_character_bit)
-
-#define UNMETA(c) ((c) & (~meta_character_bit))
-#define UNCTRL(c) _rl_to_upper(((c)|control_character_bit))
-
-/* Old versions
-#define _rl_lowercase_p(c) (((c) > ('a' - 1) && (c) < ('z' + 1)))
-#define _rl_uppercase_p(c) (((c) > ('A' - 1) && (c) < ('Z' + 1)))
-#define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
-*/
-
-#define _rl_lowercase_p(c) (islower(c))
-#define _rl_uppercase_p(c) (isupper(c))
-#define _rl_digit_p(x)  (isdigit (x))
-
-#define _rl_pure_alphabetic(c) (_rl_lowercase_p(c) || _rl_uppercase_p(c))
-#define ALPHABETIC(c)	(_rl_lowercase_p(c) || _rl_uppercase_p(c) || _rl_digit_p(c))
-
-/* Old versions
-#  define _rl_to_upper(c) (_rl_lowercase_p(c) ? ((c) - 32) : (c))
-#  define _rl_to_lower(c) (_rl_uppercase_p(c) ? ((c) + 32) : (c))
-*/
-
-#ifndef _rl_to_upper
-#  define _rl_to_upper(c) (islower(c) ? toupper(c) : (c))
-#  define _rl_to_lower(c) (isupper(c) ? tolower(c) : (c))
-#endif
-
-#ifndef _rl_digit_value
-#define _rl_digit_value(x) ((x) - '0')
-#endif
-
-#ifndef NEWLINE
-#define NEWLINE '\n'
-#endif
-
-#ifndef RETURN
-#define RETURN CTRL('M')
-#endif
-
-#ifndef RUBOUT
-#define RUBOUT 0x7f
-#endif
-
-#ifndef TAB
-#define TAB '\t'
-#endif
-
-#ifdef ABORT_CHAR
-#undef ABORT_CHAR
-#endif
-#define ABORT_CHAR CTRL('G')
-
-#ifdef PAGE
-#undef PAGE
-#endif
-#define PAGE CTRL('L')
-
-#ifdef SPACE
-#undef SPACE
-#endif
-#define SPACE ' '	/* XXX - was 0x20 */
-
-#ifdef ESC
-#undef ESC
-#endif
-#define ESC CTRL('[')
-
-#ifndef ISOCTAL
-#define ISOCTAL(c)      ((c) >= '0' && (c) <= '7')
-#endif
-#define OCTVALUE(c)     ((c) - '0')
-
-#ifndef isxdigit
-#  define isxdigit(c)   (isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))
-#endif
-
-#define HEXVALUE(c) \
-  (((c) >= 'a' && (c) <= 'f') \
-  	? (c)-'a'+10 \
-  	: (c) >= 'A' && (c) <= 'F' ? (c)-'A'+10 : (c)-'0')
-
-#endif  /* _CHARDEFS_H_ */
diff --git a/readline/compat.c b/readline/compat.c
deleted file mode 100644
--- a/readline/compat.c
+++ /dev/null
@@ -1,113 +0,0 @@
-/* compat.c -- backwards compatibility functions. */
-
-/* Copyright (C) 2000 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-
-#include "rlstdc.h"
-#include "rltypedefs.h"
-
-extern void rl_free_undo_list __P((void));
-extern int rl_maybe_save_line __P((void));
-extern int rl_maybe_unsave_line __P((void));
-extern int rl_maybe_replace_line __P((void));
-
-extern int rl_crlf __P((void));
-extern int rl_ding __P((void));
-extern int rl_alphabetic __P((int));
-
-extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
-extern char *rl_username_completion_function __P((const char *, int));
-extern char *rl_filename_completion_function __P((const char *, int));
-
-/* Provide backwards-compatible entry points for old function names. */
-
-void
-free_undo_list ()
-{
-  rl_free_undo_list ();
-}
-
-int
-maybe_replace_line ()
-{
-  return rl_maybe_replace_line ();
-}
-
-int
-maybe_save_line ()
-{
-  return rl_maybe_save_line ();
-}
-
-int
-maybe_unsave_line ()
-{
-  return rl_maybe_unsave_line ();
-}
-
-int
-ding ()
-{
-  return rl_ding ();
-}
-
-int
-crlf ()
-{
-  return rl_crlf ();
-}
-
-int
-alphabetic (c)
-     int c;
-{
-  return rl_alphabetic (c);
-}
-
-char **
-completion_matches (s, f)
-     const char *s;
-     rl_compentry_func_t *f;
-{
-  return rl_completion_matches (s, f);
-}
-
-char *
-username_completion_function (s, i)
-     const char *s;
-     int i;
-{
-  return rl_username_completion_function (s, i);
-}
-
-char *
-filename_completion_function (s, i)
-     const char *s;
-     int i;
-{
-  return rl_filename_completion_function (s, i);
-}
diff --git a/readline/complete.c b/readline/complete.c
deleted file mode 100644
--- a/readline/complete.c
+++ /dev/null
@@ -1,1753 +0,0 @@
-/* complete.c -- filename completion for readline. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-#include <fcntl.h>
-#if defined (HAVE_SYS_FILE_H)
-#include <sys/file.h>
-#endif
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include <stdio.h>
-
-#include <errno.h>
-#if !defined (errno)
-extern int errno;
-#endif /* !errno */
-
-#include <pwd.h>
-
-#include "posixdir.h"
-#include "posixstat.h"
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-/* Some standard library routines. */
-#include "readline.h"
-#include "xmalloc.h"
-#include "rlprivate.h"
-
-#ifdef __STDC__
-typedef int QSFUNC (const void *, const void *);
-#else
-typedef int QSFUNC ();
-#endif
-
-/* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
-   defined. */
-#if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
-extern struct passwd *getpwent __P((void));
-#endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */
-
-/* If non-zero, then this is the address of a function to call when
-   completing a word would normally display the list of possible matches.
-   This function is called instead of actually doing the display.
-   It takes three arguments: (char **matches, int num_matches, int max_length)
-   where MATCHES is the array of strings that matched, NUM_MATCHES is the
-   number of strings in that array, and MAX_LENGTH is the length of the
-   longest string in that array. */
-rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
-
-#if defined (VISIBLE_STATS)
-#  if !defined (X_OK)
-#    define X_OK 1
-#  endif
-static int stat_char __P((char *));
-#endif
-
-static char *rl_quote_filename __P((char *, int, char *));
-
-static char **remove_duplicate_matches __P((char **));
-static void insert_match __P((char *, int, int, char *));
-static int append_to_match __P((char *, int, int));
-static void insert_all_matches __P((char **, int, char *));
-static void display_matches __P((char **));
-static int compute_lcd_of_matches __P((char **, int, const char *));
-
-/* **************************************************************** */
-/*								    */
-/*	Completion matching, from readline's point of view.	    */
-/*								    */
-/* **************************************************************** */
-
-/* Variables known only to the readline library. */
-
-/* If non-zero, non-unique completions always show the list of matches. */
-int _rl_complete_show_all = 0;
-
-/* If non-zero, completed directory names have a slash appended. */
-int _rl_complete_mark_directories = 1;
-
-/* If non-zero, completions are printed horizontally in alphabetical order,
-   like `ls -x'. */
-int _rl_print_completions_horizontally;
-
-/* Non-zero means that case is not significant in filename completion. */
-#if defined (__MSDOS__) && !defined (__DJGPP__)
-int _rl_completion_case_fold = 1;
-#else
-int _rl_completion_case_fold;
-#endif
-
-/* Global variables available to applications using readline. */
-
-#if defined (VISIBLE_STATS)
-/* Non-zero means add an additional character to each filename displayed
-   during listing completion iff rl_filename_completion_desired which helps
-   to indicate the type of file being listed. */
-int rl_visible_stats = 0;
-#endif /* VISIBLE_STATS */
-
-/* If non-zero, then this is the address of a function to call when
-   completing on a directory name.  The function is called with
-   the address of a string (the current directory name) as an arg. */
-rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;
-
-rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;
-
-/* Non-zero means readline completion functions perform tilde expansion. */
-int rl_complete_with_tilde_expansion = 0;
-
-/* Pointer to the generator function for completion_matches ().
-   NULL means to use rl_filename_completion_function (), the default filename
-   completer. */
-rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;
-
-/* Pointer to alternative function to create matches.
-   Function is called with TEXT, START, and END.
-   START and END are indices in RL_LINE_BUFFER saying what the boundaries
-   of TEXT are.
-   If this function exists and returns NULL then call the value of
-   rl_completion_entry_function to try to match, otherwise use the
-   array of strings returned. */
-rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;
-
-/* Non-zero means to suppress normal filename completion after the
-   user-specified completion function has been called. */
-int rl_attempted_completion_over = 0;
-
-/* Set to a character indicating the type of completion being performed
-   by rl_complete_internal, available for use by application completion
-   functions. */
-int rl_completion_type = 0;
-
-/* Up to this many items will be displayed in response to a
-   possible-completions call.  After that, we ask the user if
-   she is sure she wants to see them all. */
-int rl_completion_query_items = 100;
-
-/* The basic list of characters that signal a break between words for the
-   completer routine.  The contents of this variable is what breaks words
-   in the shell, i.e. " \t\n\"\\'`@$><=" */
-const char *rl_basic_word_break_characters = " \t\n\"\\'`@$><=;|&{(";
-
-/* List of basic quoting characters. */
-const char *rl_basic_quote_characters = "\"'";
-
-/* The list of characters that signal a break between words for
-   rl_complete_internal.  The default list is the contents of
-   rl_basic_word_break_characters.  */
-const char *rl_completer_word_break_characters = (const char *)NULL;
-
-/* List of characters which can be used to quote a substring of the line.
-   Completion occurs on the entire substring, and within the substring
-   rl_completer_word_break_characters are treated as any other character,
-   unless they also appear within this list. */
-const char *rl_completer_quote_characters = (const char *)NULL;
-
-/* List of characters that should be quoted in filenames by the completer. */
-const char *rl_filename_quote_characters = (const char *)NULL;
-
-/* List of characters that are word break characters, but should be left
-   in TEXT when it is passed to the completion function.  The shell uses
-   this to help determine what kind of completing to do. */
-const char *rl_special_prefixes = (const char *)NULL;
-
-/* If non-zero, then disallow duplicates in the matches. */
-int rl_ignore_completion_duplicates = 1;
-
-/* Non-zero means that the results of the matches are to be treated
-   as filenames.  This is ALWAYS zero on entry, and can only be changed
-   within a completion entry finder function. */
-int rl_filename_completion_desired = 0;
-
-/* Non-zero means that the results of the matches are to be quoted using
-   double quotes (or an application-specific quoting mechanism) if the
-   filename contains any characters in rl_filename_quote_chars.  This is
-   ALWAYS non-zero on entry, and can only be changed within a completion
-   entry finder function. */
-int rl_filename_quoting_desired = 1;
-
-/* This function, if defined, is called by the completer when real
-   filename completion is done, after all the matching names have been
-   generated. It is passed a (char**) known as matches in the code below.
-   It consists of a NULL-terminated array of pointers to potential
-   matching strings.  The 1st element (matches[0]) is the maximal
-   substring that is common to all matches. This function can re-arrange
-   the list of matches as required, but all elements of the array must be
-   free()'d if they are deleted. The main intent of this function is
-   to implement FIGNORE a la SunOS csh. */
-rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;
-
-/* Set to a function to quote a filename in an application-specific fashion.
-   Called with the text to quote, the type of match found (single or multiple)
-   and a pointer to the quoting character to be used, which the function can
-   reset if desired. */
-rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;
-         
-/* Function to call to remove quoting characters from a filename.  Called
-   before completion is attempted, so the embedded quotes do not interfere
-   with matching names in the file system.  Readline doesn't do anything
-   with this; it's set only by applications. */
-rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;
-
-/* Function to call to decide whether or not a word break character is
-   quoted.  If a character is quoted, it does not break words for the
-   completer. */
-rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;
-
-/* Character appended to completed words when at the end of the line.  The
-   default is a space. */
-int rl_completion_append_character = ' ';
-
-/* If non-zero, inhibit completion (temporarily). */
-int rl_inhibit_completion;
-
-/* Variables local to this file. */
-
-/* Local variable states what happened during the last completion attempt. */
-static int completion_changed_buffer;
-
-/*************************************/
-/*				     */
-/*    Bindable completion functions  */
-/*				     */
-/*************************************/
-
-/* Complete the word at or before point.  You have supplied the function
-   that does the initial simple matching selection algorithm (see
-   rl_completion_matches ()).  The default is to do filename completion. */
-int
-rl_complete (ignore, invoking_key)
-     int ignore, invoking_key;
-{
-  if (rl_inhibit_completion)
-    return (rl_insert (ignore, invoking_key));
-  else if (rl_last_func == rl_complete && !completion_changed_buffer)
-    return (rl_complete_internal ('?'));
-  else if (_rl_complete_show_all)
-    return (rl_complete_internal ('!'));
-  else
-    return (rl_complete_internal (TAB));
-}
-
-/* List the possible completions.  See description of rl_complete (). */
-int
-rl_possible_completions (ignore, invoking_key)
-     int ignore, invoking_key;
-{
-  return (rl_complete_internal ('?'));
-}
-
-int
-rl_insert_completions (ignore, invoking_key)
-     int ignore, invoking_key;
-{
-  return (rl_complete_internal ('*'));
-}
-
-/************************************/
-/*				    */
-/*    Completion utility functions  */
-/*				    */
-/************************************/
-
-/* The user must press "y" or "n". Non-zero return means "y" pressed. */
-static int
-get_y_or_n ()
-{
-  int c;
-
-  for (;;)
-    {
-      RL_SETSTATE(RL_STATE_MOREINPUT);
-      c = rl_read_key ();
-      RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-      if (c == 'y' || c == 'Y' || c == ' ')
-	return (1);
-      if (c == 'n' || c == 'N' || c == RUBOUT)
-	return (0);
-      if (c == ABORT_CHAR)
-	_rl_abort_internal ();
-      rl_ding ();
-    }
-}
-
-#if defined (VISIBLE_STATS)
-/* Return the character which best describes FILENAME.
-     `@' for symbolic links
-     `/' for directories
-     `*' for executables
-     `=' for sockets
-     `|' for FIFOs
-     `%' for character special devices
-     `#' for block special devices */
-static int
-stat_char (filename)
-     char *filename;
-{
-  struct stat finfo;
-  int character, r;
-
-#if defined (HAVE_LSTAT) && defined (S_ISLNK)
-  r = lstat (filename, &finfo);
-#else
-  r = stat (filename, &finfo);
-#endif
-
-  if (r == -1)
-    return (0);
-
-  character = 0;
-  if (S_ISDIR (finfo.st_mode))
-    character = '/';
-#if defined (S_ISCHR)
-  else if (S_ISCHR (finfo.st_mode))
-    character = '%';
-#endif /* S_ISCHR */
-#if defined (S_ISBLK)
-  else if (S_ISBLK (finfo.st_mode))
-    character = '#';
-#endif /* S_ISBLK */
-#if defined (S_ISLNK)
-  else if (S_ISLNK (finfo.st_mode))
-    character = '@';
-#endif /* S_ISLNK */
-#if defined (S_ISSOCK)
-  else if (S_ISSOCK (finfo.st_mode))
-    character = '=';
-#endif /* S_ISSOCK */
-#if defined (S_ISFIFO)
-  else if (S_ISFIFO (finfo.st_mode))
-    character = '|';
-#endif
-  else if (S_ISREG (finfo.st_mode))
-    {
-      if (access (filename, X_OK) == 0)
-	character = '*';
-    }
-  return (character);
-}
-#endif /* VISIBLE_STATS */
-
-/* Return the portion of PATHNAME that should be output when listing
-   possible completions.  If we are hacking filename completion, we
-   are only interested in the basename, the portion following the
-   final slash.  Otherwise, we return what we were passed. */
-static char *
-printable_part (pathname)
-      char *pathname;
-{
-  char *temp;
-
-  temp = rl_filename_completion_desired ? strrchr (pathname, '/') : (char *)NULL;
-#if defined (__MSDOS__)
-  if (rl_filename_completion_desired && temp == 0 && isalpha (pathname[0]) && pathname[1] == ':')
-    temp = pathname + 1;
-#endif
-  return (temp ? ++temp : pathname);
-}
-
-/* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
-   are using it, check for and output a single character for `special'
-   filenames.  Return the number of characters we output. */
-
-#define PUTX(c) \
-    do { \
-      if (CTRL_CHAR (c)) \
-        { \
-          putc ('^', rl_outstream); \
-          putc (UNCTRL (c), rl_outstream); \
-          printed_len += 2; \
-        } \
-      else if (c == RUBOUT) \
-	{ \
-	  putc ('^', rl_outstream); \
-	  putc ('?', rl_outstream); \
-	  printed_len += 2; \
-	} \
-      else \
-	{ \
-	  putc (c, rl_outstream); \
-	  printed_len++; \
-	} \
-    } while (0)
-
-static int
-print_filename (to_print, full_pathname)
-     char *to_print, *full_pathname;
-{
-  int printed_len = 0;
-#if !defined (VISIBLE_STATS)
-  char *s;
-
-  for (s = to_print; *s; s++)
-    {
-      PUTX (*s);
-    }
-#else  
-  char *s, c, *new_full_pathname;
-  int extension_char, slen, tlen;
-
-  for (s = to_print; *s; s++)
-    {
-      PUTX (*s);
-    }
-
- if (rl_filename_completion_desired && rl_visible_stats)
-    {
-      /* If to_print != full_pathname, to_print is the basename of the
-	 path passed.  In this case, we try to expand the directory
-	 name before checking for the stat character. */
-      if (to_print != full_pathname)
-	{
-	  /* Terminate the directory name. */
-	  c = to_print[-1];
-	  to_print[-1] = '\0';
-
-	  /* If setting the last slash in full_pathname to a NUL results in
-	     full_pathname being the empty string, we are trying to complete
-	     files in the root directory.  If we pass a null string to the
-	     bash directory completion hook, for example, it will expand it
-	     to the current directory.  We just want the `/'. */
-	  s = tilde_expand (full_pathname && *full_pathname ? full_pathname : "/");
-	  if (rl_directory_completion_hook)
-	    (*rl_directory_completion_hook) (&s);
-
-	  slen = strlen (s);
-	  tlen = strlen (to_print);
-	  new_full_pathname = xmalloc (slen + tlen + 2);
-	  strcpy (new_full_pathname, s);
-	  new_full_pathname[slen] = '/';
-	  strcpy (new_full_pathname + slen + 1, to_print);
-
-	  extension_char = stat_char (new_full_pathname);
-
-	  free (new_full_pathname);
-	  to_print[-1] = c;
-	}
-      else
-	{
-	  s = tilde_expand (full_pathname);
-	  extension_char = stat_char (s);
-	}
-
-      free (s);
-      if (extension_char)
-	{
-	  putc (extension_char, rl_outstream);
-	  printed_len++;
-	}
-    }
-#endif /* VISIBLE_STATS */
-  return printed_len;
-}
-
-static char *
-rl_quote_filename (s, rtype, qcp)
-     char *s;
-     int rtype;
-     char *qcp;
-{
-  char *r;
-
-  r = xmalloc (strlen (s) + 2);
-  *r = *rl_completer_quote_characters;
-  strcpy (r + 1, s);
-  if (qcp)
-    *qcp = *rl_completer_quote_characters;
-  return r;
-}
-
-/* Find the bounds of the current word for completion purposes, and leave
-   rl_point set to the end of the word.  This function skips quoted
-   substrings (characters between matched pairs of characters in
-   rl_completer_quote_characters.  First we try to find an unclosed
-   quoted substring on which to do matching.  If one is not found, we use
-   the word break characters to find the boundaries of the current word.
-   We call an application-specific function to decide whether or not a
-   particular word break character is quoted; if that function returns a
-   non-zero result, the character does not break a word.  This function
-   returns the opening quote character if we found an unclosed quoted
-   substring, '\0' otherwise.  FP, if non-null, is set to a value saying
-   which (shell-like) quote characters we found (single quote, double
-   quote, or backslash) anywhere in the string.  DP, if non-null, is set to
-   the value of the delimiter character that caused a word break. */
-
-static char
-find_completion_word (fp, dp)
-     int *fp, *dp;
-{
-  int scan, end, found_quote, delimiter, pass_next, isbrk;
-  char quote_char;
-
-  end = rl_point;
-  found_quote = delimiter = 0;
-  quote_char = '\0';
-
-  if (rl_completer_quote_characters)
-    {
-      /* We have a list of characters which can be used in pairs to
-	 quote substrings for the completer.  Try to find the start
-	 of an unclosed quoted substring. */
-      /* FOUND_QUOTE is set so we know what kind of quotes we found. */
-      for (scan = pass_next = 0; scan < end; scan++)
-	{
-	  if (pass_next)
-	    {
-	      pass_next = 0;
-	      continue;
-	    }
-
-	  /* Shell-like semantics for single quotes -- don't allow backslash
-	     to quote anything in single quotes, especially not the closing
-	     quote.  If you don't like this, take out the check on the value
-	     of quote_char. */
-	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
-	    {
-	      pass_next = 1;
-	      found_quote |= RL_QF_BACKSLASH;
-	      continue;
-	    }
-
-	  if (quote_char != '\0')
-	    {
-	      /* Ignore everything until the matching close quote char. */
-	      if (rl_line_buffer[scan] == quote_char)
-		{
-		  /* Found matching close.  Abandon this substring. */
-		  quote_char = '\0';
-		  rl_point = end;
-		}
-	    }
-	  else if (strchr (rl_completer_quote_characters, rl_line_buffer[scan]))
-	    {
-	      /* Found start of a quoted substring. */
-	      quote_char = rl_line_buffer[scan];
-	      rl_point = scan + 1;
-	      /* Shell-like quoting conventions. */
-	      if (quote_char == '\'')
-		found_quote |= RL_QF_SINGLE_QUOTE;
-	      else if (quote_char == '"')
-		found_quote |= RL_QF_DOUBLE_QUOTE;
-	    }
-	}
-    }
-
-  if (rl_point == end && quote_char == '\0')
-    {
-      /* We didn't find an unclosed quoted substring upon which to do
-         completion, so use the word break characters to find the
-         substring on which to complete. */
-      while (--rl_point)
-	{
-	  scan = rl_line_buffer[rl_point];
-
-	  if (strchr (rl_completer_word_break_characters, scan) == 0)
-	    continue;
-
-	  /* Call the application-specific function to tell us whether
-	     this word break character is quoted and should be skipped. */
-	  if (rl_char_is_quoted_p && found_quote &&
-	      (*rl_char_is_quoted_p) (rl_line_buffer, rl_point))
-	    continue;
-
-	  /* Convoluted code, but it avoids an n^2 algorithm with calls
-	     to char_is_quoted. */
-	  break;
-	}
-    }
-
-  /* If we are at an unquoted word break, then advance past it. */
-  scan = rl_line_buffer[rl_point];
-
-  /* If there is an application-specific function to say whether or not
-     a character is quoted and we found a quote character, let that
-     function decide whether or not a character is a word break, even
-     if it is found in rl_completer_word_break_characters.  Don't bother
-     if we're at the end of the line, though. */
-  if (scan)
-    {
-      if (rl_char_is_quoted_p)
-	isbrk = (found_quote == 0 ||
-		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
-		strchr (rl_completer_word_break_characters, scan) != 0;
-      else
-	isbrk = strchr (rl_completer_word_break_characters, scan) != 0;
-
-      if (isbrk)
-	{
-	  /* If the character that caused the word break was a quoting
-	     character, then remember it as the delimiter. */
-	  if (rl_basic_quote_characters &&
-	      strchr (rl_basic_quote_characters, scan) &&
-	      (end - rl_point) > 1)
-	    delimiter = scan;
-
-	  /* If the character isn't needed to determine something special
-	     about what kind of completion to perform, then advance past it. */
-	  if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)
-	    rl_point++;
-	}
-    }
-
-  if (fp)
-    *fp = found_quote;
-  if (dp)
-    *dp = delimiter;
-
-  return (quote_char);
-}
-
-static char **
-gen_completion_matches (text, start, end, our_func, found_quote, quote_char)
-     char *text;
-     int start, end;
-     rl_compentry_func_t *our_func;
-     int found_quote, quote_char;
-{
-  char **matches, *temp;
-
-  /* If the user wants to TRY to complete, but then wants to give
-     up and use the default completion function, they set the
-     variable rl_attempted_completion_function. */
-  if (rl_attempted_completion_function)
-    {
-      matches = (*rl_attempted_completion_function) (text, start, end);
-
-      if (matches || rl_attempted_completion_over)
-	{
-	  rl_attempted_completion_over = 0;
-	  return (matches);
-	}
-    }
-
-  /* Beware -- we're stripping the quotes here.  Do this only if we know
-     we are doing filename completion and the application has defined a
-     filename dequoting function. */
-  temp = (char *)NULL;
-
-  if (found_quote && our_func == rl_filename_completion_function &&
-      rl_filename_dequoting_function)
-    {
-      /* delete single and double quotes */
-      temp = (*rl_filename_dequoting_function) (text, quote_char);
-      text = temp;	/* not freeing text is not a memory leak */
-    }
-
-  matches = rl_completion_matches (text, our_func);
-  FREE (temp);
-  return matches;  
-}
-
-/* Filter out duplicates in MATCHES.  This frees up the strings in
-   MATCHES. */
-static char **
-remove_duplicate_matches (matches)
-     char **matches;
-{
-  char *lowest_common;
-  int i, j, newlen;
-  char dead_slot;
-  char **temp_array;
-
-  /* Sort the items. */
-  for (i = 0; matches[i]; i++)
-    ;
-
-  /* Sort the array without matches[0], since we need it to
-     stay in place no matter what. */
-  if (i)
-    qsort (matches+1, i-1, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
-
-  /* Remember the lowest common denominator for it may be unique. */
-  lowest_common = savestring (matches[0]);
-
-  for (i = newlen = 0; matches[i + 1]; i++)
-    {
-      if (strcmp (matches[i], matches[i + 1]) == 0)
-	{
-	  free (matches[i]);
-	  matches[i] = (char *)&dead_slot;
-	}
-      else
-	newlen++;
-    }
-
-  /* We have marked all the dead slots with (char *)&dead_slot.
-     Copy all the non-dead entries into a new array. */
-  temp_array = (char **)xmalloc ((3 + newlen) * sizeof (char *));
-  for (i = j = 1; matches[i]; i++)
-    {
-      if (matches[i] != (char *)&dead_slot)
-	temp_array[j++] = matches[i];
-    }
-  temp_array[j] = (char *)NULL;
-
-  if (matches[0] != (char *)&dead_slot)
-    free (matches[0]);
-
-  /* Place the lowest common denominator back in [0]. */
-  temp_array[0] = lowest_common;
-
-  /* If there is one string left, and it is identical to the
-     lowest common denominator, then the LCD is the string to
-     insert. */
-  if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)
-    {
-      free (temp_array[1]);
-      temp_array[1] = (char *)NULL;
-    }
-  return (temp_array);
-}
-
-/* Find the common prefix of the list of matches, and put it into
-   matches[0]. */
-static int
-compute_lcd_of_matches (match_list, matches, text)
-     char **match_list;
-     int matches;
-     const char *text;
-{
-  register int i, c1, c2, si;
-  int low;		/* Count of max-matched characters. */
-
-  /* If only one match, just use that.  Otherwise, compare each
-     member of the list with the next, finding out where they
-     stop matching. */
-  if (matches == 1)
-    {
-      match_list[0] = match_list[1];
-      match_list[1] = (char *)NULL;
-      return 1;
-    }
-
-  for (i = 1, low = 100000; i < matches; i++)
-    {
-      if (_rl_completion_case_fold)
-	{
-	  for (si = 0;
-	       (c1 = _rl_to_lower(match_list[i][si])) &&
-	       (c2 = _rl_to_lower(match_list[i + 1][si]));
-	       si++)
-	    if (c1 != c2)
-	      break;
-	}
-      else
-	{
-	  for (si = 0;
-	       (c1 = match_list[i][si]) &&
-	       (c2 = match_list[i + 1][si]);
-	       si++)
-	    if (c1 != c2)
-	      break;
-	}
-
-      if (low > si)
-	low = si;
-    }
-
-  /* If there were multiple matches, but none matched up to even the
-     first character, and the user typed something, use that as the
-     value of matches[0]. */
-  if (low == 0 && text && *text)
-    {
-      match_list[0] = xmalloc (strlen (text) + 1);
-      strcpy (match_list[0], text);
-    }
-  else
-    {
-      match_list[0] = xmalloc (low + 1);
-      strncpy (match_list[0], match_list[1], low);
-      match_list[0][low] = '\0';
-    }
-
-  return matches;
-}
-
-static int
-postprocess_matches (matchesp, matching_filenames)
-     char ***matchesp;
-     int matching_filenames;
-{
-  char *t, **matches, **temp_matches;
-  int nmatch, i;
-
-  matches = *matchesp;
-
-  /* It seems to me that in all the cases we handle we would like
-     to ignore duplicate possiblilities.  Scan for the text to
-     insert being identical to the other completions. */
-  if (rl_ignore_completion_duplicates)
-    {
-      temp_matches = remove_duplicate_matches (matches);
-      free (matches);
-      matches = temp_matches;
-    }
-
-  /* If we are matching filenames, then here is our chance to
-     do clever processing by re-examining the list.  Call the
-     ignore function with the array as a parameter.  It can
-     munge the array, deleting matches as it desires. */
-  if (rl_ignore_some_completions_function && matching_filenames)
-    {
-      for (nmatch = 1; matches[nmatch]; nmatch++)
-	;
-      (void)(*rl_ignore_some_completions_function) (matches);
-      if (matches == 0 || matches[0] == 0)
-	{
-	  FREE (matches);
-	  *matchesp = (char **)0;
-	  return 0;
-        }
-      else
-	{
-	  /* If we removed some matches, recompute the common prefix. */
-	  for (i = 1; matches[i]; i++)
-	    ;
-	  if (i > 1 && i < nmatch)
-	    {
-	      t = matches[0];
-	      compute_lcd_of_matches (matches, i - 1, t);
-	      FREE (t);
-	    }
-	}
-    }
-
-  *matchesp = matches;
-  return (1);
-}
-
-/* A convenience function for displaying a list of strings in
-   columnar format on readline's output stream.  MATCHES is the list
-   of strings, in argv format, LEN is the number of strings in MATCHES,
-   and MAX is the length of the longest string in MATCHES. */
-void
-rl_display_match_list (matches, len, max)
-     char **matches;
-     int len, max;
-{
-  int count, limit, printed_len;
-  int i, j, k, l;
-  char *temp;
-
-  /* How many items of MAX length can we fit in the screen window? */
-  max += 2;
-  limit = _rl_screenwidth / max;
-  if (limit != 1 && (limit * max == _rl_screenwidth))
-    limit--;
-
-  /* Avoid a possible floating exception.  If max > _rl_screenwidth,
-     limit will be 0 and a divide-by-zero fault will result. */
-  if (limit == 0)
-    limit = 1;
-
-  /* How many iterations of the printing loop? */
-  count = (len + (limit - 1)) / limit;
-
-  /* Watch out for special case.  If LEN is less than LIMIT, then
-     just do the inner printing loop.
-	   0 < len <= limit  implies  count = 1. */
-
-  /* Sort the items if they are not already sorted. */
-  if (rl_ignore_completion_duplicates == 0)
-    qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
-
-  rl_crlf ();
-
-  if (_rl_print_completions_horizontally == 0)
-    {
-      /* Print the sorted items, up-and-down alphabetically, like ls. */
-      for (i = 1; i <= count; i++)
-	{
-	  for (j = 0, l = i; j < limit; j++)
-	    {
-	      if (l > len || matches[l] == 0)
-		break;
-	      else
-		{
-		  temp = printable_part (matches[l]);
-		  printed_len = print_filename (temp, matches[l]);
-
-		  if (j + 1 < limit)
-		    for (k = 0; k < max - printed_len; k++)
-		      putc (' ', rl_outstream);
-		}
-	      l += count;
-	    }
-	  rl_crlf ();
-	}
-    }
-  else
-    {
-      /* Print the sorted items, across alphabetically, like ls -x. */
-      for (i = 1; matches[i]; i++)
-	{
-	  temp = printable_part (matches[i]);
-	  printed_len = print_filename (temp, matches[i]);
-	  /* Have we reached the end of this line? */
-	  if (matches[i+1])
-	    {
-	      if (i && (limit > 1) && (i % limit) == 0)
-		rl_crlf ();
-	      else
-		for (k = 0; k < max - printed_len; k++)
-		  putc (' ', rl_outstream);
-	    }
-	}
-      rl_crlf ();
-    }
-}
-
-/* Display MATCHES, a list of matching filenames in argv format.  This
-   handles the simple case -- a single match -- first.  If there is more
-   than one match, we compute the number of strings in the list and the
-   length of the longest string, which will be needed by the display
-   function.  If the application wants to handle displaying the list of
-   matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the
-   address of a function, and we just call it.  If we're handling the
-   display ourselves, we just call rl_display_match_list.  We also check
-   that the list of matches doesn't exceed the user-settable threshold,
-   and ask the user if he wants to see the list if there are more matches
-   than RL_COMPLETION_QUERY_ITEMS. */
-static void
-display_matches (matches)
-     char **matches;
-{
-  int len, max, i;
-  char *temp;
-
-  /* Move to the last visible line of a possibly-multiple-line command. */
-  _rl_move_vert (_rl_vis_botlin);
-
-  /* Handle simple case first.  What if there is only one answer? */
-  if (matches[1] == 0)
-    {
-      temp = printable_part (matches[0]);
-      rl_crlf ();
-      print_filename (temp, matches[0]);
-      rl_crlf ();
-
-      rl_forced_update_display ();
-      rl_display_fixed = 1;
-
-      return;
-    }
-
-  /* There is more than one answer.  Find out how many there are,
-     and find the maximum printed length of a single entry. */
-  for (max = 0, i = 1; matches[i]; i++)
-    {
-      temp = printable_part (matches[i]);
-      len = strlen (temp);
-
-      if (len > max)
-	max = len;
-    }
-
-  len = i - 1;
-
-  /* If the caller has defined a display hook, then call that now. */
-  if (rl_completion_display_matches_hook)
-    {
-      (*rl_completion_display_matches_hook) (matches, len, max);
-      return;
-    }
-	
-  /* If there are many items, then ask the user if she really wants to
-     see them all. */
-  if (len >= rl_completion_query_items)
-    {
-      rl_crlf ();
-      fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
-      fflush (rl_outstream);
-      if (get_y_or_n () == 0)
-	{
-	  rl_crlf ();
-
-	  rl_forced_update_display ();
-	  rl_display_fixed = 1;
-
-	  return;
-	}
-    }
-
-  rl_display_match_list (matches, len, max);
-
-  rl_forced_update_display ();
-  rl_display_fixed = 1;
-}
-
-static char *
-make_quoted_replacement (match, mtype, qc)
-     char *match;
-     int mtype;
-     char *qc;	/* Pointer to quoting character, if any */
-{
-  int should_quote, do_replace;
-  char *replacement;
-
-  /* If we are doing completion on quoted substrings, and any matches
-     contain any of the completer_word_break_characters, then auto-
-     matically prepend the substring with a quote character (just pick
-     the first one from the list of such) if it does not already begin
-     with a quote string.  FIXME: Need to remove any such automatically
-     inserted quote character when it no longer is necessary, such as
-     if we change the string we are completing on and the new set of
-     matches don't require a quoted substring. */
-  replacement = match;
-
-  should_quote = match && rl_completer_quote_characters &&
-			rl_filename_completion_desired &&
-			rl_filename_quoting_desired;
-
-  if (should_quote)
-    should_quote = should_quote && (!qc || !*qc ||
-		     (rl_completer_quote_characters && strchr (rl_completer_quote_characters, *qc)));
-
-  if (should_quote)
-    {
-      /* If there is a single match, see if we need to quote it.
-         This also checks whether the common prefix of several
-	 matches needs to be quoted. */
-      should_quote = rl_filename_quote_characters
-			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
-			: 0;
-
-      do_replace = should_quote ? mtype : NO_MATCH;
-      /* Quote the replacement, since we found an embedded
-	 word break character in a potential match. */
-      if (do_replace != NO_MATCH && rl_filename_quoting_function)
-	replacement = (*rl_filename_quoting_function) (match, do_replace, qc);
-    }
-  return (replacement);
-}
-
-static void
-insert_match (match, start, mtype, qc)
-     char *match;
-     int start, mtype;
-     char *qc;
-{
-  char *replacement;
-  char oqc;
-
-  oqc = qc ? *qc : '\0';
-  replacement = make_quoted_replacement (match, mtype, qc);
-
-  /* Now insert the match. */
-  if (replacement)
-    {
-      /* Don't double an opening quote character. */
-      if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
-	    replacement[0] == *qc)
-	start--;
-      /* If make_quoted_replacement changed the quoting character, remove
-	 the opening quote and insert the (fully-quoted) replacement. */
-      else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&
-	    replacement[0] != oqc)
-	start--;
-      _rl_replace_text (replacement, start, rl_point - 1);
-      if (replacement != match)
-        free (replacement);
-    }
-}
-
-/* Append any necessary closing quote and a separator character to the
-   just-inserted match.  If the user has specified that directories
-   should be marked by a trailing `/', append one of those instead.  The
-   default trailing character is a space.  Returns the number of characters
-   appended. */
-static int
-append_to_match (text, delimiter, quote_char)
-     char *text;
-     int delimiter, quote_char;
-{
-  char temp_string[4], *filename;
-  int temp_string_index;
-  struct stat finfo;
-
-  temp_string_index = 0;
-  if (quote_char && rl_point && rl_line_buffer[rl_point - 1] != quote_char)
-    temp_string[temp_string_index++] = quote_char;
-
-  if (delimiter)
-    temp_string[temp_string_index++] = delimiter;
-  else if (rl_completion_append_character)
-    temp_string[temp_string_index++] = rl_completion_append_character;
-
-  temp_string[temp_string_index++] = '\0';
-
-  if (rl_filename_completion_desired)
-    {
-      filename = tilde_expand (text);
-      if (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
-	{
-	  if (_rl_complete_mark_directories && rl_line_buffer[rl_point] != '/')
-	    rl_insert_text ("/");
-	}
-      else
-	{
-	  if (rl_point == rl_end)
-	    rl_insert_text (temp_string);
-	}
-      free (filename);
-    }
-  else
-    {
-      if (rl_point == rl_end)
-	rl_insert_text (temp_string);
-    }
-
-  return (temp_string_index);
-}
-
-static void
-insert_all_matches (matches, point, qc)
-     char **matches;
-     int point;
-     char *qc;
-{
-  int i;
-  char *rp;
-
-  rl_begin_undo_group ();
-  /* remove any opening quote character; make_quoted_replacement will add
-     it back. */
-  if (qc && *qc && point && rl_line_buffer[point - 1] == *qc)
-    point--;
-  rl_delete_text (point, rl_point);
-  rl_point = point;
-
-  if (matches[1])
-    {
-      for (i = 1; matches[i]; i++)
-	{
-	  rp = make_quoted_replacement (matches[i], SINGLE_MATCH, qc);
-	  rl_insert_text (rp);
-	  rl_insert_text (" ");
-	  if (rp != matches[i])
-	    free (rp);
-	}
-    }
-  else
-    {
-      rp = make_quoted_replacement (matches[0], SINGLE_MATCH, qc);
-      rl_insert_text (rp);
-      rl_insert_text (" ");
-      if (rp != matches[0])
-	free (rp);
-    }
-  rl_end_undo_group ();
-}
-
-static void
-free_match_list (matches)
-     char **matches;
-{
-  register int i;
-
-  for (i = 0; matches[i]; i++)
-    free (matches[i]);
-  free (matches);
-}
-
-/* Complete the word at or before point.
-   WHAT_TO_DO says what to do with the completion.
-   `?' means list the possible completions.
-   TAB means do standard completion.
-   `*' means insert all of the possible completions.
-   `!' means to do standard completion, and list all possible completions if
-   there is more than one. */
-int
-rl_complete_internal (what_to_do)
-     int what_to_do;
-{
-  char **matches;
-  rl_compentry_func_t *our_func;
-  int start, end, delimiter, found_quote, i;
-  char *text, *saved_line_buffer;
-  char quote_char;
-
-  RL_SETSTATE(RL_STATE_COMPLETING);
-  /* Only the completion entry function can change these. */
-  rl_filename_completion_desired = 0;
-  rl_filename_quoting_desired = 1;
-  rl_completion_type = what_to_do;
-
-  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;
-  our_func = rl_completion_entry_function
-		? rl_completion_entry_function
-		: rl_filename_completion_function;
-
-  /* We now look backwards for the start of a filename/variable word. */
-  end = rl_point;
-  found_quote = delimiter = 0;
-  quote_char = '\0';
-
-  if (rl_point)
-    /* This (possibly) changes rl_point.  If it returns a non-zero char,
-       we know we have an open quote. */
-    quote_char = find_completion_word (&found_quote, &delimiter);
-
-  start = rl_point;
-  rl_point = end;
-
-  text = rl_copy_text (start, end);
-  matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);
-  free (text);
-
-  if (matches == 0)
-    {
-      rl_ding ();
-      FREE (saved_line_buffer);
-      RL_UNSETSTATE(RL_STATE_COMPLETING);
-      return (0);
-    }
-
-  /* If we are matching filenames, the attempted completion function will
-     have set rl_filename_completion_desired to a non-zero value.  The basic
-     rl_filename_completion_function does this. */
-  i = rl_filename_completion_desired;
-
-  if (postprocess_matches (&matches, i) == 0)
-    {
-      rl_ding ();
-      FREE (saved_line_buffer);
-      completion_changed_buffer = 0;
-      RL_UNSETSTATE(RL_STATE_COMPLETING);
-      return (0);
-    }
-
-  switch (what_to_do)
-    {
-    case TAB:
-    case '!':
-      /* Insert the first match with proper quoting. */
-      if (*matches[0])
-	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
-
-      /* If there are more matches, ring the bell to indicate.
-	 If we are in vi mode, Posix.2 says to not ring the bell.
-	 If the `show-all-if-ambiguous' variable is set, display
-	 all the matches immediately.  Otherwise, if this was the
-	 only match, and we are hacking files, check the file to
-	 see if it was a directory.  If so, and the `mark-directories'
-	 variable is set, add a '/' to the name.  If not, and we
-	 are at the end of the line, then add a space.  */
-      if (matches[1])
-	{
-	  if (what_to_do == '!')
-	    {
-	      display_matches (matches);
-	      break;
-	    }
-	  else if (rl_editing_mode != vi_mode)
-	    rl_ding ();	/* There are other matches remaining. */
-	}
-      else
-	append_to_match (matches[0], delimiter, quote_char);
-
-      break;
-
-    case '*':
-      insert_all_matches (matches, start, &quote_char);
-      break;
-
-    case '?':
-      display_matches (matches);
-      break;
-
-    default:
-      fprintf (stderr, "\r\nreadline: bad value %d for what_to_do in rl_complete\n", what_to_do);
-      rl_ding ();
-      FREE (saved_line_buffer);
-      RL_UNSETSTATE(RL_STATE_COMPLETING);
-      return 1;
-    }
-
-  free_match_list (matches);
-
-  /* Check to see if the line has changed through all of this manipulation. */
-  if (saved_line_buffer)
-    {
-      completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;
-      free (saved_line_buffer);
-    }
-
-  RL_UNSETSTATE(RL_STATE_COMPLETING);
-  return 0;
-}
-
-/***************************************************************/
-/*							       */
-/*  Application-callable completion match generator functions  */
-/*							       */
-/***************************************************************/
-
-/* Return an array of (char *) which is a list of completions for TEXT.
-   If there are no completions, return a NULL pointer.
-   The first entry in the returned array is the substitution for TEXT.
-   The remaining entries are the possible completions.
-   The array is terminated with a NULL pointer.
-
-   ENTRY_FUNCTION is a function of two args, and returns a (char *).
-     The first argument is TEXT.
-     The second is a state argument; it should be zero on the first call, and
-     non-zero on subsequent calls.  It returns a NULL pointer to the caller
-     when there are no more matches.
- */
-char **
-rl_completion_matches (text, entry_function)
-     const char *text;
-     rl_compentry_func_t *entry_function;
-{
-  /* Number of slots in match_list. */
-  int match_list_size;
-
-  /* The list of matches. */
-  char **match_list;
-
-  /* Number of matches actually found. */
-  int matches;
-
-  /* Temporary string binder. */
-  char *string;
-
-  matches = 0;
-  match_list_size = 10;
-  match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
-  match_list[1] = (char *)NULL;
-
-  while (string = (*entry_function) (text, matches))
-    {
-      if (matches + 1 == match_list_size)
-	match_list = (char **)xrealloc
-	  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));
-
-      match_list[++matches] = string;
-      match_list[matches + 1] = (char *)NULL;
-    }
-
-  /* If there were any matches, then look through them finding out the
-     lowest common denominator.  That then becomes match_list[0]. */
-  if (matches)
-    compute_lcd_of_matches (match_list, matches, text);
-  else				/* There were no matches. */
-    {
-      free (match_list);
-      match_list = (char **)NULL;
-    }
-  return (match_list);
-}
-
-/* A completion function for usernames.
-   TEXT contains a partial username preceded by a random
-   character (usually `~').  */
-char *
-rl_username_completion_function (text, state)
-     const char *text;
-     int state;
-{
-#if defined (__WIN32__) || defined (__OPENNT)
-  return (char *)NULL;
-#else /* !__WIN32__ && !__OPENNT) */
-  static char *username = (char *)NULL;
-  static struct passwd *entry;
-  static int namelen, first_char, first_char_loc;
-  char *value;
-
-  if (state == 0)
-    {
-      FREE (username);
-
-      first_char = *text;
-      first_char_loc = first_char == '~';
-
-      username = savestring (&text[first_char_loc]);
-      namelen = strlen (username);
-      setpwent ();
-    }
-
-  while (entry = getpwent ())
-    {
-      /* Null usernames should result in all users as possible completions. */
-      if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))
-	break;
-    }
-
-  if (entry == 0)
-    {
-      endpwent ();
-      return ((char *)NULL);
-    }
-  else
-    {
-      value = xmalloc (2 + strlen (entry->pw_name));
-
-      *value = *text;
-
-      strcpy (value + first_char_loc, entry->pw_name);
-
-      if (first_char == '~')
-	rl_filename_completion_desired = 1;
-
-      return (value);
-    }
-#endif /* !__WIN32__ && !__OPENNT */
-}
-
-/* Okay, now we write the entry_function for filename completion.  In the
-   general case.  Note that completion in the shell is a little different
-   because of all the pathnames that must be followed when looking up the
-   completion for a command. */
-char *
-rl_filename_completion_function (text, state)
-     const char *text;
-     int state;
-{
-  static DIR *directory = (DIR *)NULL;
-  static char *filename = (char *)NULL;
-  static char *dirname = (char *)NULL;
-  static char *users_dirname = (char *)NULL;
-  static int filename_len;
-  char *temp;
-  int dirlen;
-  struct dirent *entry;
-
-  /* If we don't have any state, then do some initialization. */
-  if (state == 0)
-    {
-      /* If we were interrupted before closing the directory or reading
-	 all of its contents, close it. */
-      if (directory)
-	{
-	  closedir (directory);
-	  directory = (DIR *)NULL;
-	}
-      FREE (dirname);
-      FREE (filename);
-      FREE (users_dirname);
-
-      filename = savestring (text);
-      if (*text == 0)
-	text = ".";
-      dirname = savestring (text);
-
-      temp = strrchr (dirname, '/');
-
-#if defined (__MSDOS__)
-      /* special hack for //X/... */
-      if (dirname[0] == '/' && dirname[1] == '/' && isalpha (dirname[2]) && dirname[3] == '/')
-        temp = strrchr (dirname + 3, '/');
-#endif
-
-      if (temp)
-	{
-	  strcpy (filename, ++temp);
-	  *temp = '\0';
-	}
-#if defined (__MSDOS__)
-      /* searches from current directory on the drive */
-      else if (isalpha (dirname[0]) && dirname[1] == ':')
-        {
-          strcpy (filename, dirname + 2);
-          dirname[2] = '\0';
-        }
-#endif
-      else
-	{
-	  dirname[0] = '.';
-	  dirname[1] = '\0';
-	}
-
-      /* We aren't done yet.  We also support the "~user" syntax. */
-
-      /* Save the version of the directory that the user typed. */
-      users_dirname = savestring (dirname);
-
-      if (*dirname == '~')
-	{
-	  temp = tilde_expand (dirname);
-	  free (dirname);
-	  dirname = temp;
-	}
-
-      if (rl_directory_rewrite_hook)
-	(*rl_directory_rewrite_hook) (&dirname);
-
-      if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
-	{
-	  free (users_dirname);
-	  users_dirname = savestring (dirname);
-	}
-
-      directory = opendir (dirname);
-      filename_len = strlen (filename);
-
-      rl_filename_completion_desired = 1;
-    }
-
-  /* At this point we should entertain the possibility of hacking wildcarded
-     filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name
-     contains globbing characters, then build an array of directories, and
-     then map over that list while completing. */
-  /* *** UNIMPLEMENTED *** */
-
-  /* Now that we have some state, we can read the directory. */
-
-  entry = (struct dirent *)NULL;
-  while (directory && (entry = readdir (directory)))
-    {
-      /* Special case for no filename.
-	 All entries except "." and ".." match. */
-      if (filename_len == 0)
-	{
-	  if (entry->d_name[0] != '.' ||
-	       (entry->d_name[1] &&
-		 (entry->d_name[1] != '.' || entry->d_name[2])))
-	    break;
-	}
-      else
-	{
-	  /* Otherwise, if these match up to the length of filename, then
-	     it is a match. */
-	  if (_rl_completion_case_fold)
-	    {
-	      if ((_rl_to_lower (entry->d_name[0]) == _rl_to_lower (filename[0])) &&
-		  (((int)D_NAMLEN (entry)) >= filename_len) &&
-		  (_rl_strnicmp (filename, entry->d_name, filename_len) == 0))
-		break;
-	    }
-	  else
-	    {
-	      if ((entry->d_name[0] == filename[0]) &&
-		  (((int)D_NAMLEN (entry)) >= filename_len) &&
-		  (strncmp (filename, entry->d_name, filename_len) == 0))
-		break;
-	    }
-	}
-    }
-
-  if (entry == 0)
-    {
-      if (directory)
-	{
-	  closedir (directory);
-	  directory = (DIR *)NULL;
-	}
-      if (dirname)
-	{
-	  free (dirname);
-	  dirname = (char *)NULL;
-	}
-      if (filename)
-	{
-	  free (filename);
-	  filename = (char *)NULL;
-	}
-      if (users_dirname)
-	{
-	  free (users_dirname);
-	  users_dirname = (char *)NULL;
-	}
-
-      return (char *)NULL;
-    }
-  else
-    {
-      /* dirname && (strcmp (dirname, ".") != 0) */
-      if (dirname && (dirname[0] != '.' || dirname[1]))
-	{
-	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
-	    {
-	      dirlen = strlen (dirname);
-	      temp = xmalloc (2 + dirlen + D_NAMLEN (entry));
-	      strcpy (temp, dirname);
-	      /* Canonicalization cuts off any final slash present.  We
-		 may need to add it back. */
-	      if (dirname[dirlen - 1] != '/')
-	        {
-	          temp[dirlen++] = '/';
-	          temp[dirlen] = '\0';
-	        }
-	    }
-	  else
-	    {
-	      dirlen = strlen (users_dirname);
-	      temp = xmalloc (2 + dirlen + D_NAMLEN (entry));
-	      strcpy (temp, users_dirname);
-	      /* Make sure that temp has a trailing slash here. */
-	      if (users_dirname[dirlen - 1] != '/')
-		temp[dirlen++] = '/';
-	    }
-
-	  strcpy (temp + dirlen, entry->d_name);
-	}
-      else
-	temp = savestring (entry->d_name);
-
-      return (temp);
-    }
-}
-
-/* An initial implementation of a menu completion function a la tcsh.  The
-   first time (if the last readline command was not rl_menu_complete), we
-   generate the list of matches.  This code is very similar to the code in
-   rl_complete_internal -- there should be a way to combine the two.  Then,
-   for each item in the list of matches, we insert the match in an undoable
-   fashion, with the appropriate character appended (this happens on the
-   second and subsequent consecutive calls to rl_menu_complete).  When we
-   hit the end of the match list, we restore the original unmatched text,
-   ring the bell, and reset the counter to zero. */
-int
-rl_menu_complete (count, ignore)
-     int count, ignore;
-{
-  rl_compentry_func_t *our_func;
-  int matching_filenames, found_quote;
-
-  static char *orig_text;
-  static char **matches = (char **)0;
-  static int match_list_index = 0;
-  static int match_list_size = 0;
-  static int orig_start, orig_end;
-  static char quote_char;
-  static int delimiter;
-
-  /* The first time through, we generate the list of matches and set things
-     up to insert them. */
-  if (rl_last_func != rl_menu_complete)
-    {
-      /* Clean up from previous call, if any. */
-      FREE (orig_text);
-      if (matches)
-	free_match_list (matches);
-
-      match_list_index = match_list_size = 0;
-      matches = (char **)NULL;
-
-      /* Only the completion entry function can change these. */
-      rl_filename_completion_desired = 0;
-      rl_filename_quoting_desired = 1;
-      rl_completion_type = '%';
-
-      our_func = rl_completion_entry_function
-			? rl_completion_entry_function
-			: rl_filename_completion_function;
-
-      /* We now look backwards for the start of a filename/variable word. */
-      orig_end = rl_point;
-      found_quote = delimiter = 0;
-      quote_char = '\0';
-
-      if (rl_point)
-	/* This (possibly) changes rl_point.  If it returns a non-zero char,
-	   we know we have an open quote. */
-	quote_char = find_completion_word (&found_quote, &delimiter);
-
-      orig_start = rl_point;
-      rl_point = orig_end;
-
-      orig_text = rl_copy_text (orig_start, orig_end);
-      matches = gen_completion_matches (orig_text, orig_start, orig_end,
-					our_func, found_quote, quote_char);
-
-      /* If we are matching filenames, the attempted completion function will
-	 have set rl_filename_completion_desired to a non-zero value.  The basic
-	 rl_filename_completion_function does this. */
-      matching_filenames = rl_filename_completion_desired;
-
-      if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
-	{
-    	  rl_ding ();
-	  FREE (matches);
-	  matches = (char **)0;
-	  FREE (orig_text);
-	  orig_text = (char *)0;
-    	  completion_changed_buffer = 0;
-          return (0);
-	}
-
-      for (match_list_size = 0; matches[match_list_size]; match_list_size++)
-        ;
-      /* matches[0] is lcd if match_list_size > 1, but the circular buffer
-	 code below should take care of it. */
-    }
-
-  /* Now we have the list of matches.  Replace the text between
-     rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with
-     matches[match_list_index], and add any necessary closing char. */
-
-  if (matches == 0 || match_list_size == 0) 
-    {
-      rl_ding ();
-      FREE (matches);
-      matches = (char **)0;
-      completion_changed_buffer = 0;
-      return (0);
-    }
-
-  match_list_index = (match_list_index + count) % match_list_size;
-  if (match_list_index < 0)
-    match_list_index += match_list_size;
-
-  if (match_list_index == 0 && match_list_size > 1)
-    {
-      rl_ding ();
-      insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);
-    }
-  else
-    {
-      insert_match (matches[match_list_index], orig_start, SINGLE_MATCH, &quote_char);
-      append_to_match (matches[match_list_index], delimiter, quote_char);
-    }
-
-  completion_changed_buffer = 1;
-  return (0);
-}
diff --git a/readline/config.h.in b/readline/config.h.in
deleted file mode 100644
--- a/readline/config.h.in
+++ /dev/null
@@ -1,147 +0,0 @@
-/* config.h.in.  Maintained by hand. */
-
-/* Define if on MINIX.  */
-#undef _MINIX
-
-/* Define as the return type of signal handlers (int or void).  */
-#undef RETSIGTYPE
-
-/* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
-#undef STAT_MACROS_BROKEN
-
-#undef VOID_SIGHANDLER
-
-/* Define if you have the lstat function. */
-#undef HAVE_LSTAT
-
-/* Define if you have the memmove function. */
-#undef HAVE_MEMMOVE
-
-/* Define if you have the putenv function.  */
-#undef HAVE_PUTENV
-
-/* Define if you have the select function.  */
-#undef HAVE_SELECT
-
-/* Define if you have the setenv function.  */
-#undef HAVE_SETENV
-
-/* Define if you have the strcasecmp function.  */
-#undef HAVE_STRCASECMP
-
-/* Define if you have the setlocale function. */
-#undef HAVE_SETLOCALE
-
-/* Define if you have the tcgetattr function.  */
-#undef HAVE_TCGETATTR
-
-/* Define if you have the strcoll function.  */
-#undef HAVE_STRCOLL
-
-#undef STRCOLL_BROKEN
-
-/* Define if you have the <dirent.h> header file.  */
-#undef HAVE_DIRENT_H
-
-/* Define if you have the <ndir.h> header file.  */
-#undef HAVE_NDIR_H
-
-/* Define if you have the <stdlib.h> header file.  */
-#undef HAVE_STDLIB_H
-
-/* Define if you have the <string.h> header file.  */
-#undef HAVE_STRING_H
-
-/* Define if you have the <sys/dir.h> header file.  */
-#undef HAVE_SYS_DIR_H
-
-/* Define if you have the <sys/file.h> header file.  */
-#undef HAVE_SYS_FILE_H
-
-/* Define if you have the <sys/ndir.h> header file.  */
-#undef HAVE_SYS_NDIR_H
-
-/* Define if you have the <sys/pte.h> header file.  */
-#undef HAVE_SYS_PTE_H
-
-/* Define if you have the <sys/ptem.h> header file.  */
-#undef HAVE_SYS_PTEM_H
-
-/* Define if you have the <sys/select.h> header file.  */
-#undef HAVE_SYS_SELECT_H
-
-/* Define if you have the <sys/stream.h> header file.  */
-#undef HAVE_SYS_STREAM_H
-
-/* Define if you have the <termcap.h> header file.  */
-#undef HAVE_TERMCAP_H
-
-/* Define if you have the <termio.h> header file.  */
-#undef HAVE_TERMIO_H
-
-/* Define if you have the <termios.h> header file.  */
-#undef HAVE_TERMIOS_H
-
-/* Define if you have the <unistd.h> header file.  */
-#undef HAVE_UNISTD_H
-
-/* Define if you have the <varargs.h> header file.  */
-#undef HAVE_VARARGS_H
-
-/* Define if you have the <stdarg.h> header file.  */
-#undef HAVE_STDARG_H
-
-#undef HAVE_LOCALE_H
-
-/* Definitions pulled in from aclocal.m4. */
-#undef VOID_SIGHANDLER
-
-#undef GWINSZ_IN_SYS_IOCTL
-
-#undef STRUCT_WINSIZE_IN_SYS_IOCTL
-
-#undef STRUCT_WINSIZE_IN_TERMIOS
-
-#undef TIOCSTAT_IN_SYS_IOCTL
-
-#undef FIONREAD_IN_SYS_IOCTL
-
-#undef SPEED_T_IN_SYS_TYPES
-
-#undef HAVE_GETPW_DECLS
-
-#undef STRUCT_DIRENT_HAS_D_INO
-
-#undef STRUCT_DIRENT_HAS_D_FILENO
-
-#undef HAVE_BSD_SIGNALS
-
-#undef HAVE_POSIX_SIGNALS
-
-#undef HAVE_USG_SIGHOLD
-
-#undef MUST_REINSTALL_SIGHANDLERS
-
-#undef HAVE_POSIX_SIGSETJMP
-
-/* modify settings or make new ones based on what autoconf tells us. */
-
-/* Ultrix botches type-ahead when switching from canonical to
-   non-canonical mode, at least through version 4.3 */
-#if !defined (HAVE_TERMIOS_H) || !defined (HAVE_TCGETATTR) || defined (ultrix)
-#  define TERMIOS_MISSING
-#endif
-
-#if defined (STRCOLL_BROKEN)
-#  undef HAVE_STRCOLL
-#endif
-
-#if defined (__STDC__) && defined (HAVE_STDARG_H)
-#  define PREFER_STDARG
-#  define USE_VARARGS
-#else
-#  if defined (HAVE_VARARGS_H)
-#    define PREFER_VARARGS
-#    define USE_VARARGS
-#  endif
-#endif
diff --git a/readline/configure.in b/readline/configure.in
deleted file mode 100644
--- a/readline/configure.in
+++ /dev/null
@@ -1,158 +0,0 @@
-dnl
-dnl Configure script for readline library
-dnl
-dnl report bugs to chet@po.cwru.edu
-dnl
-dnl Process this file with autoconf to produce a configure script.
-AC_REVISION([for Readline 4.2, version 2.26, from autoconf version] AC_ACVERSION)
-LIBVERSION=4.2
-
-AC_INIT(readline.h)
-AC_CONFIG_HEADER(config.h)
-
-dnl make sure we are using a recent autoconf version
-AC_PREREQ(2.10)
-
-AC_CONFIG_AUX_DIR(./support)
-
-AC_CANONICAL_HOST
-
-dnl configure defaults
-opt_curses=no
-opt_shared=no
-
-dnl arguments to configure
-AC_ARG_WITH(curses, --with-curses               use the curses library instead of the termcap library,opt_curses=$withval)
-
-if test "$opt_curses" = "yes"; then
-	prefer_curses=yes
-fi
-
-# We want these before the checks, so the checks can modify their values.
-test -z "$CFLAGS" && CFLAGS=-g auto_cflags=1
-
-AC_PROG_MAKE_SET
-AC_PROG_CC
-dnl AC_AIX
-AC_MINIX
-
-# If we're using gcc and the user hasn't specified CFLAGS, add -O to CFLAGS.
-test -n "$GCC" && test -n "$auto_cflags" && CFLAGS="$CFLAGS -O"
-
-AC_PROG_GCC_TRADITIONAL
-AC_PROG_INSTALL
-AC_CHECK_PROG(AR, ar, ar)
-dnl Set default for ARFLAGS, since autoconf does not have a macro for it.
-dnl This allows people to set it when running configure or make
-test -n "$ARFLAGS" || ARFLAGS="cr"
-AC_PROG_RANLIB
-
-MAKE_SHELL=/bin/sh
-AC_SUBST(MAKE_SHELL)
-
-AC_RETSIGTYPE
-
-AC_HEADER_STAT
-AC_HEADER_DIRENT
-
-AC_CHECK_FUNCS(lstat memmove putenv select setenv setlocale \
-		strcasecmp tcgetattr)
-
-AC_FUNC_STRCOLL
-
-AC_CHECK_HEADERS(unistd.h stdlib.h varargs.h stdarg.h string.h \
-		sys/ptem.h sys/pte.h sys/stream.h sys/select.h \
-		termcap.h termios.h termio.h sys/file.h locale.h)
-
-BASH_SIGNAL_CHECK
-BASH_REINSTALL_SIGHANDLERS
-
-BASH_FUNC_POSIX_SETJMP
-BASH_FUNC_LSTAT
-BASH_CHECK_GETPW_FUNCS
-BASH_FUNC_STRCOLL
-
-BASH_TYPE_SIGHANDLER
-BASH_HAVE_TIOCGWINSZ
-BASH_HAVE_TIOCSTAT
-BASH_HAVE_FIONREAD
-BASH_MISC_SPEED_T
-BASH_STRUCT_WINSIZE
-BASH_STRUCT_DIRENT_D_INO
-BASH_STRUCT_DIRENT_D_FILENO
-
-dnl yuck
-case "$host_os" in
-aix*)   prefer_curses=yes ;;
-esac
-BASH_CHECK_LIB_TERMCAP
-if test "$TERMCAP_LIB" = "./lib/termcap/libtermcap.a"; then
-	TERMCAP_LIB=-ltermcap	#default
-fi
-
-case "$host_cpu" in
-*cray*)	LOCAL_CFLAGS=-DCRAY ;;
-*s390*) LOCAL_CFLAGS=-fsigned-char ;;
-esac
-
-case "$host_os" in
-isc*)	LOCAL_CFLAGS=-Disc386 ;;
-esac
-
-# shared library configuration section
-#
-# Shared object configuration section.  These values are generated by
-# ${srcdir}/support/shobj-conf
-#
-if test -f ${srcdir}/support/shobj-conf; then
-        AC_MSG_CHECKING(configuration for building shared libraries)
-        eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c ${host_cpu} -o ${host_os} -v ${host_vendor}`
-        AC_SUBST(SHOBJ_CC)
-        AC_SUBST(SHOBJ_CFLAGS)
-        AC_SUBST(SHOBJ_LD)
-        AC_SUBST(SHOBJ_LDFLAGS)
-	AC_SUBST(SHOBJ_XLDFLAGS)
-        AC_SUBST(SHOBJ_LIBS)
-        AC_SUBST(SHOBJ_STATUS)
-	AC_SUBST(SHLIB_STATUS)
-	AC_SUBST(SHLIB_XLDFLAGS)
-	AC_SUBST(SHLIB_LIBSUFF)
-	AC_SUBST(SHLIB_LIBVERSION)
-	AC_SUBST(SHLIB_LIBS)
-        AC_MSG_RESULT($SHLIB_STATUS)
-
-	# shared library versioning
-	# quoted for m4 so I can use character classes
-	SHLIB_MAJOR=[`expr "$LIBVERSION" : '\([0-9]\)\..*'`]
-	SHLIB_MINOR=[`expr "$LIBVERSION" : '[0-9]\.\([0-9]\).*'`]
-	AC_SUBST(SHLIB_MAJOR)
-	AC_SUBST(SHLIB_MINOR)
-fi
-
-case "$host_os" in
-msdosdjgpp*)	BUILD_DIR=`pwd.exe` ;;	# to prevent //d/path/file
-*)		BUILD_DIR=`pwd` ;;
-esac
-
-AC_SUBST(BUILD_DIR)
-
-AC_SUBST(CFLAGS)
-AC_SUBST(LOCAL_CFLAGS)
-AC_SUBST(LOCAL_LDFLAGS)
-AC_SUBST(LOCAL_DEFS)
-
-AC_SUBST(AR)
-AC_SUBST(ARFLAGS)
-
-AC_SUBST(host_cpu)
-AC_SUBST(host_os)
-
-AC_SUBST(LIBVERSION)
-
-AC_SUBST(TERMCAP_LIB)
-
-AC_OUTPUT([Makefile doc/Makefile examples/Makefile shlib/Makefile],
-[
-# Makefile uses this timestamp file to record whether config.h is up to date.
-echo > stamp-h
-])
diff --git a/readline/display.c b/readline/display.c
deleted file mode 100644
--- a/readline/display.c
+++ /dev/null
@@ -1,1740 +0,0 @@
-/* display.c -- readline redisplay facility. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-#include "posixstat.h"
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include <stdio.h>
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-/* Termcap library stuff. */
-#include "tcap.h"
-
-/* Some standard library routines. */
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-#include "xmalloc.h"
-
-#if !defined (strchr) && !defined (__STDC__)
-extern char *strchr (), *strrchr ();
-#endif /* !strchr && !__STDC__ */
-
-#if defined (HACK_TERMCAP_MOTION)
-extern char *_rl_term_forward_char;
-#endif
-
-static void update_line __P((char *, char *, int, int, int, int));
-static void space_to_eol __P((int));
-static void delete_chars __P((int));
-static void insert_some_chars __P((char *, int));
-static void cr __P((void));
-
-static int *inv_lbreaks, *vis_lbreaks;
-static int inv_lbsize, vis_lbsize;
-
-/* Heuristic used to decide whether it is faster to move from CUR to NEW
-   by backing up or outputting a carriage return and moving forward. */
-#define CR_FASTER(new, cur) (((new) + 1) < ((cur) - (new)))
-
-/* **************************************************************** */
-/*								    */
-/*			Display stuff				    */
-/*								    */
-/* **************************************************************** */
-
-/* This is the stuff that is hard for me.  I never seem to write good
-   display routines in C.  Let's see how I do this time. */
-
-/* (PWP) Well... Good for a simple line updater, but totally ignores
-   the problems of input lines longer than the screen width.
-
-   update_line and the code that calls it makes a multiple line,
-   automatically wrapping line update.  Careful attention needs
-   to be paid to the vertical position variables. */
-
-/* Keep two buffers; one which reflects the current contents of the
-   screen, and the other to draw what we think the new contents should
-   be.  Then compare the buffers, and make whatever changes to the
-   screen itself that we should.  Finally, make the buffer that we
-   just drew into be the one which reflects the current contents of the
-   screen, and place the cursor where it belongs.
-
-   Commands that want to can fix the display themselves, and then let
-   this function know that the display has been fixed by setting the
-   RL_DISPLAY_FIXED variable.  This is good for efficiency. */
-
-/* Application-specific redisplay function. */
-rl_voidfunc_t *rl_redisplay_function = rl_redisplay;
-
-/* Global variables declared here. */
-/* What YOU turn on when you have handled all redisplay yourself. */
-int rl_display_fixed = 0;
-
-int _rl_suppress_redisplay = 0;
-
-/* The stuff that gets printed out before the actual text of the line.
-   This is usually pointing to rl_prompt. */
-char *rl_display_prompt = (char *)NULL;
-
-/* Pseudo-global variables declared here. */
-/* The visible cursor position.  If you print some text, adjust this. */
-int _rl_last_c_pos = 0;
-int _rl_last_v_pos = 0;
-
-/* Number of lines currently on screen minus 1. */
-int _rl_vis_botlin = 0;
-
-/* Variables used only in this file. */
-/* The last left edge of text that was displayed.  This is used when
-   doing horizontal scrolling.  It shifts in thirds of a screenwidth. */
-static int last_lmargin;
-
-/* The line display buffers.  One is the line currently displayed on
-   the screen.  The other is the line about to be displayed. */
-static char *visible_line = (char *)NULL;
-static char *invisible_line = (char *)NULL;
-
-/* A buffer for `modeline' messages. */
-static char msg_buf[128];
-
-/* Non-zero forces the redisplay even if we thought it was unnecessary. */
-static int forced_display;
-
-/* Default and initial buffer size.  Can grow. */
-static int line_size = 1024;
-
-/* Variables to keep track of the expanded prompt string, which may
-   include invisible characters. */
-
-static char *local_prompt, *local_prompt_prefix;
-static int prompt_visible_length, prompt_prefix_length;
-
-/* The number of invisible characters in the line currently being
-   displayed on the screen. */
-static int visible_wrap_offset;
-
-/* The number of invisible characters in the prompt string.  Static so it
-   can be shared between rl_redisplay and update_line */
-static int wrap_offset;
-
-/* The index of the last invisible character in the prompt string. */
-static int prompt_last_invisible;
-
-/* The length (buffer offset) of the first line of the last (possibly
-   multi-line) buffer displayed on the screen. */
-static int visible_first_line_len;
-
-/* Number of invisible characters on the first physical line of the prompt.
-   Only valid when the number of physical characters in the prompt exceeds
-   (or is equal to) _rl_screenwidth. */
-static int prompt_invis_chars_first_line;
-
-static int prompt_last_screen_line;
-
-/* Expand the prompt string S and return the number of visible
-   characters in *LP, if LP is not null.  This is currently more-or-less
-   a placeholder for expansion.  LIP, if non-null is a place to store the
-   index of the last invisible character in the returned string. NIFLP,
-   if non-zero, is a place to store the number of invisible characters in
-   the first prompt line. */
-
-/* Current implementation:
-	\001 (^A) start non-visible characters
-	\002 (^B) end non-visible characters
-   all characters except \001 and \002 (following a \001) are copied to
-   the returned string; all characters except those between \001 and
-   \002 are assumed to be `visible'. */	
-
-static char *
-expand_prompt (pmt, lp, lip, niflp)
-     char *pmt;
-     int *lp, *lip, *niflp;
-{
-  char *r, *ret, *p;
-  int l, rl, last, ignoring, ninvis, invfl;
-
-  /* Short-circuit if we can. */
-  if (strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
-    {
-      r = savestring (pmt);
-      if (lp)
-	*lp = strlen (r);
-      return r;
-    }
-
-  l = strlen (pmt);
-  r = ret = xmalloc (l + 1);
-
-  invfl = 0;	/* invisible chars in first line of prompt */
-
-  for (rl = ignoring = last = ninvis = 0, p = pmt; p && *p; p++)
-    {
-      /* This code strips the invisible character string markers
-	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
-      if (*p == RL_PROMPT_START_IGNORE)
-	{
-	  ignoring++;
-	  continue;
-	}
-      else if (ignoring && *p == RL_PROMPT_END_IGNORE)
-	{
-	  ignoring = 0;
-	  last = r - ret - 1;
-	  continue;
-	}
-      else
-	{
-	  *r++ = *p;
-	  if (!ignoring)
-	    rl++;
-	  else
-	    ninvis++;
-	  if (rl == _rl_screenwidth)
-	    invfl = ninvis;
-	}
-    }
-
-  if (rl < _rl_screenwidth)
-    invfl = ninvis;
-
-  *r = '\0';
-  if (lp)
-    *lp = rl;
-  if (lip)
-    *lip = last;
-  if (niflp)
-    *niflp = invfl;
-  return ret;
-}
-
-/* Just strip out RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE from
-   PMT and return the rest of PMT. */
-char *
-_rl_strip_prompt (pmt)
-     char *pmt;
-{
-  char *ret;
-
-  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL);
-  return ret;
-}
-
-/*
- * Expand the prompt string into the various display components, if
- * necessary.
- *
- * local_prompt = expanded last line of string in rl_display_prompt
- *		  (portion after the final newline)
- * local_prompt_prefix = portion before last newline of rl_display_prompt,
- *			 expanded via expand_prompt
- * prompt_visible_length = number of visible characters in local_prompt
- * prompt_prefix_length = number of visible characters in local_prompt_prefix
- *
- * This function is called once per call to readline().  It may also be
- * called arbitrarily to expand the primary prompt.
- *
- * The return value is the number of visible characters on the last line
- * of the (possibly multi-line) prompt.
- */
-int
-rl_expand_prompt (prompt)
-     char *prompt;
-{
-  char *p, *t;
-  int c;
-
-  /* Clear out any saved values. */
-  FREE (local_prompt);
-  FREE (local_prompt_prefix);
-
-  local_prompt = local_prompt_prefix = (char *)0;
-  prompt_last_invisible = prompt_visible_length = 0;
-
-  if (prompt == 0 || *prompt == 0)
-    return (0);
-
-  p = strrchr (prompt, '\n');
-  if (!p)
-    {
-      /* The prompt is only one logical line, though it might wrap. */
-      local_prompt = expand_prompt (prompt, &prompt_visible_length,
-					    &prompt_last_invisible,
-					    &prompt_invis_chars_first_line);
-      local_prompt_prefix = (char *)0;
-      return (prompt_visible_length);
-    }
-  else
-    {
-      /* The prompt spans multiple lines. */
-      t = ++p;
-      local_prompt = expand_prompt (p, &prompt_visible_length,
-				       &prompt_last_invisible,
-				       &prompt_invis_chars_first_line);
-      c = *t; *t = '\0';
-      /* The portion of the prompt string up to and including the
-	 final newline is now null-terminated. */
-      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
-						   (int *)NULL,
-						   &prompt_invis_chars_first_line);
-      *t = c;
-      return (prompt_prefix_length);
-    }
-}
-
-/* Initialize the VISIBLE_LINE and INVISIBLE_LINE arrays, and their associated
-   arrays of line break markers.  MINSIZE is the minimum size of VISIBLE_LINE
-   and INVISIBLE_LINE; if it is greater than LINE_SIZE, LINE_SIZE is
-   increased.  If the lines have already been allocated, this ensures that
-   they can hold at least MINSIZE characters. */
-static void
-init_line_structures (minsize)
-      int minsize;
-{
-  register int n;
-
-  if (invisible_line == 0)	/* initialize it */
-    {
-      if (line_size < minsize)
-	line_size = minsize;
-      visible_line = xmalloc (line_size);
-      invisible_line = xmalloc (line_size);
-    }
-  else if (line_size < minsize)	/* ensure it can hold MINSIZE chars */
-    {
-      line_size *= 2;
-      if (line_size < minsize)
-	line_size = minsize;
-      visible_line = xrealloc (visible_line, line_size);
-      invisible_line = xrealloc (invisible_line, line_size);
-    }
-
-  for (n = minsize; n < line_size; n++)
-    {
-      visible_line[n] = 0;
-      invisible_line[n] = 1;
-    }
-
-  if (vis_lbreaks == 0)
-    {
-      /* should be enough. */
-      inv_lbsize = vis_lbsize = 256;
-      inv_lbreaks = (int *)xmalloc (inv_lbsize * sizeof (int));
-      vis_lbreaks = (int *)xmalloc (vis_lbsize * sizeof (int));
-      inv_lbreaks[0] = vis_lbreaks[0] = 0;
-    }
-}
-  
-/* Basic redisplay algorithm. */
-void
-rl_redisplay ()
-{
-  register int in, out, c, linenum, cursor_linenum;
-  register char *line;
-  int c_pos, inv_botlin, lb_botlin, lb_linenum;
-  int newlines, lpos, temp;
-  char *prompt_this_line;
-
-  if (!readline_echoing_p)
-    return;
-
-  if (!rl_display_prompt)
-    rl_display_prompt = "";
-
-  if (invisible_line == 0)
-    {
-      init_line_structures (0);
-      rl_on_new_line ();
-    }
-
-  /* Draw the line into the buffer. */
-  c_pos = -1;
-
-  line = invisible_line;
-  out = inv_botlin = 0;
-
-  /* Mark the line as modified or not.  We only do this for history
-     lines. */
-  if (_rl_mark_modified_lines && current_history () && rl_undo_list)
-    {
-      line[out++] = '*';
-      line[out] = '\0';
-    }
-
-  /* If someone thought that the redisplay was handled, but the currently
-     visible line has a different modification state than the one about
-     to become visible, then correct the caller's misconception. */
-  if (visible_line[0] != invisible_line[0])
-    rl_display_fixed = 0;
-
-  /* If the prompt to be displayed is the `primary' readline prompt (the
-     one passed to readline()), use the values we have already expanded.
-     If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the
-     number of non-visible characters in the prompt string. */
-  if (rl_display_prompt == rl_prompt || local_prompt)
-    {
-      int local_len = local_prompt ? strlen (local_prompt) : 0;
-      if (local_prompt_prefix && forced_display)
-	_rl_output_some_chars (local_prompt_prefix, strlen (local_prompt_prefix));
-
-      if (local_len > 0)
-	{
-	  temp = local_len + out + 2;
-	  if (temp >= line_size)
-	    {
-	      line_size = (temp + 1024) - (temp % 1024);
-	      visible_line = xrealloc (visible_line, line_size);
-	      line = invisible_line = xrealloc (invisible_line, line_size);
-	    }
-	  strncpy (line + out, local_prompt, local_len);
-	  out += local_len;
-	}
-      line[out] = '\0';
-      wrap_offset = local_len - prompt_visible_length;
-    }
-  else
-    {
-      int pmtlen;
-      prompt_this_line = strrchr (rl_display_prompt, '\n');
-      if (!prompt_this_line)
-	prompt_this_line = rl_display_prompt;
-      else
-	{
-	  prompt_this_line++;
-	  pmtlen = prompt_this_line - rl_display_prompt;	/* temp var */
-	  if (forced_display)
-	    {
-	      _rl_output_some_chars (rl_display_prompt, pmtlen);
-	      /* Make sure we are at column zero even after a newline,
-		 regardless of the state of terminal output processing. */
-	      if (pmtlen < 2 || prompt_this_line[-2] != '\r')
-		cr ();
-	    }
-	}
-
-      pmtlen = strlen (prompt_this_line);
-      temp = pmtlen + out + 2;
-      if (temp >= line_size)
-	{
-	  line_size = (temp + 1024) - (temp % 1024);
-	  visible_line = xrealloc (visible_line, line_size);
-	  line = invisible_line = xrealloc (invisible_line, line_size);
-	}
-      strncpy (line + out,  prompt_this_line, pmtlen);
-      out += pmtlen;
-      line[out] = '\0';
-      wrap_offset = prompt_invis_chars_first_line = 0;
-    }
-
-#define CHECK_INV_LBREAKS() \
-      do { \
-	if (newlines >= (inv_lbsize - 2)) \
-	  { \
-	    inv_lbsize *= 2; \
-	    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
-	  } \
-      } while (0)
-	  
-#define CHECK_LPOS() \
-      do { \
-	lpos++; \
-	if (lpos >= _rl_screenwidth) \
-	  { \
-	    if (newlines >= (inv_lbsize - 2)) \
-	      { \
-		inv_lbsize *= 2; \
-		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \
-	      } \
-	    inv_lbreaks[++newlines] = out; \
-	    lpos = 0; \
-	  } \
-      } while (0)
-
-  /* inv_lbreaks[i] is where line i starts in the buffer. */
-  inv_lbreaks[newlines = 0] = 0;
-  lpos = out - wrap_offset;
-
-  /* prompt_invis_chars_first_line is the number of invisible characters in
-     the first physical line of the prompt.
-     wrap_offset - prompt_invis_chars_first_line is the number of invis
-     chars on the second line. */
-
-  /* what if lpos is already >= _rl_screenwidth before we start drawing the
-     contents of the command line? */
-  while (lpos >= _rl_screenwidth)
-    {
-      /* fix from Darin Johnson <darin@acuson.com> for prompt string with
-         invisible characters that is longer than the screen width.  The
-         prompt_invis_chars_first_line variable could be made into an array
-         saying how many invisible characters there are per line, but that's
-         probably too much work for the benefit gained.  How many people have
-         prompts that exceed two physical lines? */
-      temp = ((newlines + 1) * _rl_screenwidth) +
-             ((newlines == 0) ? prompt_invis_chars_first_line : 0) +
-             ((newlines == 1) ? wrap_offset : 0);
-
-      inv_lbreaks[++newlines] = temp;
-      lpos -= _rl_screenwidth;
-    }
-
-  prompt_last_screen_line = newlines;
-
-  /* Draw the rest of the line (after the prompt) into invisible_line, keeping
-     track of where the cursor is (c_pos), the number of the line containing
-     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).
-     It maintains an array of line breaks for display (inv_lbreaks).
-     This handles expanding tabs for display and displaying meta characters. */
-  lb_linenum = 0;
-  for (in = 0; in < rl_end; in++)
-    {
-      c = (unsigned char)rl_line_buffer[in];
-
-      if (out + 8 >= line_size)		/* XXX - 8 for \t */
-	{
-	  line_size *= 2;
-	  visible_line = xrealloc (visible_line, line_size);
-	  invisible_line = xrealloc (invisible_line, line_size);
-	  line = invisible_line;
-	}
-
-      if (in == rl_point)
-	{
-	  c_pos = out;
-	  lb_linenum = newlines;
-	}
-
-      if (META_CHAR (c))
-	{
-	  if (_rl_output_meta_chars == 0)
-	    {
-	      sprintf (line + out, "\\%o", c);
-
-	      if (lpos + 4 >= _rl_screenwidth)
-		{
-		  temp = _rl_screenwidth - lpos;
-		  CHECK_INV_LBREAKS ();
-		  inv_lbreaks[++newlines] = out + temp;
-		  lpos = 4 - temp;
-		}
-	      else
-		lpos += 4;
-
-	      out += 4;
-	    }
-	  else
-	    {
-	      line[out++] = c;
-	      CHECK_LPOS();
-	    }
-	}
-#if defined (DISPLAY_TABS)
-      else if (c == '\t')
-	{
-	  register int newout;
-
-#if 0
-	  newout = (out | (int)7) + 1;
-#else
-	  newout = out + 8 - lpos % 8;
-#endif
-	  temp = newout - out;
-	  if (lpos + temp >= _rl_screenwidth)
-	    {
-	      register int temp2;
-	      temp2 = _rl_screenwidth - lpos;
-	      CHECK_INV_LBREAKS ();
-	      inv_lbreaks[++newlines] = out + temp2;
-	      lpos = temp - temp2;
-	      while (out < newout)
-		line[out++] = ' ';
-	    }
-	  else
-	    {
-	      while (out < newout)
-		line[out++] = ' ';
-	      lpos += temp;
-	    }
-	}
-#endif
-      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
-	{
-	  line[out++] = '\0';	/* XXX - sentinel */
-	  CHECK_INV_LBREAKS ();
-	  inv_lbreaks[++newlines] = out;
-	  lpos = 0;
-	}
-      else if (CTRL_CHAR (c) || c == RUBOUT)
-	{
-	  line[out++] = '^';
-	  CHECK_LPOS();
-	  line[out++] = CTRL_CHAR (c) ? UNCTRL (c) : '?';
-	  CHECK_LPOS();
-	}
-      else
-	{
-	  line[out++] = c;
-	  CHECK_LPOS();
-	}
-    }
-  line[out] = '\0';
-  if (c_pos < 0)
-    {
-      c_pos = out;
-      lb_linenum = newlines;
-    }
-
-  inv_botlin = lb_botlin = newlines;
-  CHECK_INV_LBREAKS ();
-  inv_lbreaks[newlines+1] = out;
-  cursor_linenum = lb_linenum;
-
-  /* C_POS == position in buffer where cursor should be placed.
-     CURSOR_LINENUM == line number where the cursor should be placed. */
-
-  /* PWP: now is when things get a bit hairy.  The visible and invisible
-     line buffers are really multiple lines, which would wrap every
-     (screenwidth - 1) characters.  Go through each in turn, finding
-     the changed region and updating it.  The line order is top to bottom. */
-
-  /* If we can move the cursor up and down, then use multiple lines,
-     otherwise, let long lines display in a single terminal line, and
-     horizontally scroll it. */
-
-  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
-    {
-      int nleft, pos, changed_screen_line;
-
-      if (!rl_display_fixed || forced_display)
-	{
-	  forced_display = 0;
-
-	  /* If we have more than a screenful of material to display, then
-	     only display a screenful.  We should display the last screen,
-	     not the first.  */
-	  if (out >= _rl_screenchars)
-	    out = _rl_screenchars - 1;
-
-	  /* The first line is at character position 0 in the buffer.  The
-	     second and subsequent lines start at inv_lbreaks[N], offset by
-	     OFFSET (which has already been calculated above).  */
-
-#define W_OFFSET(line, offset) ((line) == 0 ? offset : 0)
-#define VIS_LLEN(l)	((l) > _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))
-#define INV_LLEN(l)	(inv_lbreaks[l+1] - inv_lbreaks[l])
-#define VIS_CHARS(line) (visible_line + vis_lbreaks[line])
-#define VIS_LINE(line) ((line) > _rl_vis_botlin) ? "" : VIS_CHARS(line)
-#define INV_LINE(line) (invisible_line + inv_lbreaks[line])
-
-	  /* For each line in the buffer, do the updating display. */
-	  for (linenum = 0; linenum <= inv_botlin; linenum++)
-	    {
-	      update_line (VIS_LINE(linenum), INV_LINE(linenum), linenum,
-			   VIS_LLEN(linenum), INV_LLEN(linenum), inv_botlin);
-
-	      /* If this is the line with the prompt, we might need to
-		 compensate for invisible characters in the new line. Do
-		 this only if there is not more than one new line (which
-		 implies that we completely overwrite the old visible line)
-		 and the new line is shorter than the old.  Make sure we are
-		 at the end of the new line before clearing. */
-	      if (linenum == 0 &&
-		  inv_botlin == 0 && _rl_last_c_pos == out &&
-		  (wrap_offset > visible_wrap_offset) &&
-		  (_rl_last_c_pos < visible_first_line_len))
-		{
-		  nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
-		  if (nleft)
-		    _rl_clear_to_eol (nleft);
-		}
-
-	      /* Since the new first line is now visible, save its length. */
-	      if (linenum == 0)
-		visible_first_line_len = (inv_botlin > 0) ? inv_lbreaks[1] : out - wrap_offset;
-	    }
-
-	  /* We may have deleted some lines.  If so, clear the left over
-	     blank ones at the bottom out. */
-	  if (_rl_vis_botlin > inv_botlin)
-	    {
-	      char *tt;
-	      for (; linenum <= _rl_vis_botlin; linenum++)
-		{
-		  tt = VIS_CHARS (linenum);
-		  _rl_move_vert (linenum);
-		  _rl_move_cursor_relative (0, tt);
-		  _rl_clear_to_eol
-		    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);
-		}
-	    }
-	  _rl_vis_botlin = inv_botlin;
-
-	  /* CHANGED_SCREEN_LINE is set to 1 if we have moved to a
-	     different screen line during this redisplay. */
-	  changed_screen_line = _rl_last_v_pos != cursor_linenum;
-	  if (changed_screen_line)
-	    {
-	      _rl_move_vert (cursor_linenum);
-	      /* If we moved up to the line with the prompt using _rl_term_up,
-		 the physical cursor position on the screen stays the same,
-		 but the buffer position needs to be adjusted to account
-		 for invisible characters. */
-	      if (cursor_linenum == 0 && wrap_offset)
-		_rl_last_c_pos += wrap_offset;
-	    }
-
-	  /* We have to reprint the prompt if it contains invisible
-	     characters, since it's not generally OK to just reprint
-	     the characters from the current cursor position.  But we
-	     only need to reprint it if the cursor is before the last
-	     invisible character in the prompt string. */
-	  nleft = prompt_visible_length + wrap_offset;
-	  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&
-	      _rl_last_c_pos <= prompt_last_invisible && local_prompt)
-	    {
-#if defined (__MSDOS__)
-	      putc ('\r', rl_outstream);
-#else
-	      if (_rl_term_cr)
-		tputs (_rl_term_cr, 1, _rl_output_character_function);
-#endif
-	      _rl_output_some_chars (local_prompt, nleft);
-	      _rl_last_c_pos = nleft;
-	    }
-
-	  /* Where on that line?  And where does that line start
-	     in the buffer? */
-	  pos = inv_lbreaks[cursor_linenum];
-	  /* nleft == number of characters in the line buffer between the
-	     start of the line and the cursor position. */
-	  nleft = c_pos - pos;
-
-	  /* Since _rl_backspace() doesn't know about invisible characters in the
-	     prompt, and there's no good way to tell it, we compensate for
-	     those characters here and call _rl_backspace() directly. */
-	  if (wrap_offset && cursor_linenum == 0 && nleft < _rl_last_c_pos)
-	    {
-	      _rl_backspace (_rl_last_c_pos - nleft);
-	      _rl_last_c_pos = nleft;
-	    }
-
-	  if (nleft != _rl_last_c_pos)
-	    _rl_move_cursor_relative (nleft, &invisible_line[pos]);
-	}
-    }
-  else				/* Do horizontal scrolling. */
-    {
-#define M_OFFSET(margin, offset) ((margin) == 0 ? offset : 0)
-      int lmargin, ndisp, nleft, phys_c_pos, t;
-
-      /* Always at top line. */
-      _rl_last_v_pos = 0;
-
-      /* Compute where in the buffer the displayed line should start.  This
-	 will be LMARGIN. */
-
-      /* The number of characters that will be displayed before the cursor. */
-      ndisp = c_pos - wrap_offset;
-      nleft  = prompt_visible_length + wrap_offset;
-      /* Where the new cursor position will be on the screen.  This can be
-	 longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
-      phys_c_pos = c_pos - (last_lmargin ? last_lmargin : wrap_offset);
-      t = _rl_screenwidth / 3;
-
-      /* If the number of characters had already exceeded the screenwidth,
-	 last_lmargin will be > 0. */
-
-      /* If the number of characters to be displayed is more than the screen
-	 width, compute the starting offset so that the cursor is about
-	 two-thirds of the way across the screen. */
-      if (phys_c_pos > _rl_screenwidth - 2)
-	{
-	  lmargin = c_pos - (2 * t);
-	  if (lmargin < 0)
-	    lmargin = 0;
-	  /* If the left margin would be in the middle of a prompt with
-	     invisible characters, don't display the prompt at all. */
-	  if (wrap_offset && lmargin > 0 && lmargin < nleft)
-	    lmargin = nleft;
-	}
-      else if (ndisp < _rl_screenwidth - 2)		/* XXX - was -1 */
-	lmargin = 0;
-      else if (phys_c_pos < 1)
-	{
-	  /* If we are moving back towards the beginning of the line and
-	     the last margin is no longer correct, compute a new one. */
-	  lmargin = ((c_pos - 1) / t) * t;	/* XXX */
-	  if (wrap_offset && lmargin > 0 && lmargin < nleft)
-	    lmargin = nleft;
-	}
-      else
-	lmargin = last_lmargin;
-
-      /* If the first character on the screen isn't the first character
-	 in the display line, indicate this with a special character. */
-      if (lmargin > 0)
-	line[lmargin] = '<';
-
-      /* If SCREENWIDTH characters starting at LMARGIN do not encompass
-	 the whole line, indicate that with a special character at the
-	 right edge of the screen.  If LMARGIN is 0, we need to take the
-	 wrap offset into account. */
-      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;
-      if (t < out)
-	line[t - 1] = '>';
-
-      if (!rl_display_fixed || forced_display || lmargin != last_lmargin)
-	{
-	  forced_display = 0;
-	  update_line (&visible_line[last_lmargin],
-		       &invisible_line[lmargin],
-		       0,
-		       _rl_screenwidth + visible_wrap_offset,
-		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
-		       0);
-
-	  /* If the visible new line is shorter than the old, but the number
-	     of invisible characters is greater, and we are at the end of
-	     the new line, we need to clear to eol. */
-	  t = _rl_last_c_pos - M_OFFSET (lmargin, wrap_offset);
-	  if ((M_OFFSET (lmargin, wrap_offset) > visible_wrap_offset) &&
-	      (_rl_last_c_pos == out) &&
-	      t < visible_first_line_len)
-	    {
-	      nleft = _rl_screenwidth - t;
-	      _rl_clear_to_eol (nleft);
-	    }
-	  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);
-	  if (visible_first_line_len > _rl_screenwidth)
-	    visible_first_line_len = _rl_screenwidth;
-
-	  _rl_move_cursor_relative (c_pos - lmargin, &invisible_line[lmargin]);
-	  last_lmargin = lmargin;
-	}
-    }
-  fflush (rl_outstream);
-
-  /* Swap visible and non-visible lines. */
-  {
-    char *vtemp = visible_line;
-    int *itemp = vis_lbreaks, ntemp = vis_lbsize;
-
-    visible_line = invisible_line;
-    invisible_line = vtemp;
-
-    vis_lbreaks = inv_lbreaks;
-    inv_lbreaks = itemp;
-
-    vis_lbsize = inv_lbsize;
-    inv_lbsize = ntemp;
-
-    rl_display_fixed = 0;
-    /* If we are displaying on a single line, and last_lmargin is > 0, we
-       are not displaying any invisible characters, so set visible_wrap_offset
-       to 0. */
-    if (_rl_horizontal_scroll_mode && last_lmargin)
-      visible_wrap_offset = 0;
-    else
-      visible_wrap_offset = wrap_offset;
-  }
-}
-
-/* PWP: update_line() is based on finding the middle difference of each
-   line on the screen; vis:
-
-			     /old first difference
-	/beginning of line   |	      /old last same       /old EOL
-	v		     v	      v		    v
-old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as
-new:	eddie> Oh, my little buggy says to me, as lurgid as
-	^		     ^	^			   ^
-	\beginning of line   |	\new last same	   \new end of line
-			     \new first difference
-
-   All are character pointers for the sake of speed.  Special cases for
-   no differences, as well as for end of line additions must be handled.
-
-   Could be made even smarter, but this works well enough */
-static void
-update_line (old, new, current_line, omax, nmax, inv_botlin)
-     register char *old, *new;
-     int current_line, omax, nmax, inv_botlin;
-{
-  register char *ofd, *ols, *oe, *nfd, *nls, *ne;
-  int temp, lendiff, wsatend, od, nd;
-  int current_invis_chars;
-
-  /* If we're at the right edge of a terminal that supports xn, we're
-     ready to wrap around, so do so.  This fixes problems with knowing
-     the exact cursor position and cut-and-paste with certain terminal
-     emulators.  In this calculation, TEMP is the physical screen
-     position of the cursor. */
-  temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
-  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
-      && _rl_last_v_pos == current_line - 1)
-    {
-      if (new[0])
-	putc (new[0], rl_outstream);
-      else
-	putc (' ', rl_outstream);
-      _rl_last_c_pos = 1;		/* XXX */
-      _rl_last_v_pos++;
-      if (old[0] && new[0])
-	old[0] = new[0];
-    }
-      
-  /* Find first difference. */
-  for (ofd = old, nfd = new;
-       (ofd - old < omax) && *ofd && (*ofd == *nfd);
-       ofd++, nfd++)
-    ;
-
-  /* Move to the end of the screen line.  ND and OD are used to keep track
-     of the distance between ne and new and oe and old, respectively, to
-     move a subtraction out of each loop. */
-  for (od = ofd - old, oe = ofd; od < omax && *oe; oe++, od++);
-  for (nd = nfd - new, ne = nfd; nd < nmax && *ne; ne++, nd++);
-
-  /* If no difference, continue to next line. */
-  if (ofd == oe && nfd == ne)
-    return;
-
-  wsatend = 1;			/* flag for trailing whitespace */
-  ols = oe - 1;			/* find last same */
-  nls = ne - 1;
-  while ((ols > ofd) && (nls > nfd) && (*ols == *nls))
-    {
-      if (*ols != ' ')
-	wsatend = 0;
-      ols--;
-      nls--;
-    }
-
-  if (wsatend)
-    {
-      ols = oe;
-      nls = ne;
-    }
-  else if (*ols != *nls)
-    {
-      if (*ols)			/* don't step past the NUL */
-	ols++;
-      if (*nls)
-	nls++;
-    }
-
-  /* count of invisible characters in the current invisible line. */
-  current_invis_chars = W_OFFSET (current_line, wrap_offset);
-  if (_rl_last_v_pos != current_line)
-    {
-      _rl_move_vert (current_line);
-      if (current_line == 0 && visible_wrap_offset)
-	_rl_last_c_pos += visible_wrap_offset;
-    }
-
-  /* If this is the first line and there are invisible characters in the
-     prompt string, and the prompt string has not changed, and the current
-     cursor position is before the last invisible character in the prompt,
-     and the index of the character to move to is past the end of the prompt
-     string, then redraw the entire prompt string.  We can only do this
-     reliably if the terminal supports a `cr' capability.
-
-     This is not an efficiency hack -- there is a problem with redrawing
-     portions of the prompt string if they contain terminal escape
-     sequences (like drawing the `unbold' sequence without a corresponding
-     `bold') that manifests itself on certain terminals. */
-
-  lendiff = local_prompt ? strlen (local_prompt) : 0;
-  od = ofd - old;	/* index of first difference in visible line */
-  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
-      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
-      od >= lendiff && _rl_last_c_pos <= prompt_last_invisible)
-    {
-#if defined (__MSDOS__)
-      putc ('\r', rl_outstream);
-#else
-      tputs (_rl_term_cr, 1, _rl_output_character_function);
-#endif
-      _rl_output_some_chars (local_prompt, lendiff);
-      _rl_last_c_pos = lendiff;
-    }
-
-  _rl_move_cursor_relative (od, old);
-
-  /* if (len (new) > len (old)) */
-  lendiff = (nls - nfd) - (ols - ofd);
-
-  /* If we are changing the number of invisible characters in a line, and
-     the spot of first difference is before the end of the invisible chars,
-     lendiff needs to be adjusted. */
-  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
-      current_invis_chars != visible_wrap_offset)
-    lendiff += visible_wrap_offset - current_invis_chars;
-
-  /* Insert (diff (len (old), len (new)) ch. */
-  temp = ne - nfd;
-  if (lendiff > 0)
-    {
-      /* Non-zero if we're increasing the number of lines. */
-      int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
-      /* Sometimes it is cheaper to print the characters rather than
-	 use the terminal's capabilities.  If we're growing the number
-	 of lines, make sure we actually cause the new line to wrap
-	 around on auto-wrapping terminals. */
-      if (_rl_terminal_can_insert && ((2 * temp) >= lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
-	{
-	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
-	     _rl_horizontal_scroll_mode == 1, inserting the characters with
-	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
-	     invisible characters.  We need to just draw them. */
-	  if (*ols && (!_rl_horizontal_scroll_mode || _rl_last_c_pos > 0 ||
-			lendiff <= prompt_visible_length || !current_invis_chars))
-	    {
-	      insert_some_chars (nfd, lendiff);
-	      _rl_last_c_pos += lendiff;
-	    }
-	  else if (*ols == 0)
-	    {
-	      /* At the end of a line the characters do not have to
-		 be "inserted".  They can just be placed on the screen. */
-	      /* However, this screws up the rest of this block, which
-		 assumes you've done the insert because you can. */
-	      _rl_output_some_chars (nfd, lendiff);
-	      _rl_last_c_pos += lendiff;
-	    }
-	  else
-	    {
-	      /* We have horizontal scrolling and we are not inserting at
-		 the end.  We have invisible characters in this line.  This
-		 is a dumb update. */
-	      _rl_output_some_chars (nfd, temp);
-	      _rl_last_c_pos += temp;
-	      return;
-	    }
-	  /* Copy (new) chars to screen from first diff to last match. */
-	  temp = nls - nfd;
-	  if ((temp - lendiff) > 0)
-	    {
-	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
-	      _rl_last_c_pos += temp - lendiff;
-	    }
-	}
-      else
-	{
-	  /* cannot insert chars, write to EOL */
-	  _rl_output_some_chars (nfd, temp);
-	  _rl_last_c_pos += temp;
-	}
-    }
-  else				/* Delete characters from line. */
-    {
-      /* If possible and inexpensive to use terminal deletion, then do so. */
-      if (_rl_term_dc && (2 * temp) >= -lendiff)
-	{
-	  /* If all we're doing is erasing the invisible characters in the
-	     prompt string, don't bother.  It screws up the assumptions
-	     about what's on the screen. */
-	  if (_rl_horizontal_scroll_mode && _rl_last_c_pos == 0 &&
-	      -lendiff == visible_wrap_offset)
-	    lendiff = 0;
-
-	  if (lendiff)
-	    delete_chars (-lendiff); /* delete (diff) characters */
-
-	  /* Copy (new) chars to screen from first diff to last match */
-	  temp = nls - nfd;
-	  if (temp > 0)
-	    {
-	      _rl_output_some_chars (nfd, temp);
-	      _rl_last_c_pos += temp;
-	    }
-	}
-      /* Otherwise, print over the existing material. */
-      else
-	{
-	  if (temp > 0)
-	    {
-	      _rl_output_some_chars (nfd, temp);
-	      _rl_last_c_pos += temp;
-	    }
-	  lendiff = (oe - old) - (ne - new);
-	  if (lendiff)
-	    {	  
-	      if (_rl_term_autowrap && current_line < inv_botlin)
-		space_to_eol (lendiff);
-	      else
-		_rl_clear_to_eol (lendiff);
-	    }
-	}
-    }
-}
-
-/* Tell the update routines that we have moved onto a new (empty) line. */
-int
-rl_on_new_line ()
-{
-  if (visible_line)
-    visible_line[0] = '\0';
-
-  _rl_last_c_pos = _rl_last_v_pos = 0;
-  _rl_vis_botlin = last_lmargin = 0;
-  if (vis_lbreaks)
-    vis_lbreaks[0] = vis_lbreaks[1] = 0;
-  visible_wrap_offset = 0;
-  return 0;
-}
-
-/* Tell the update routines that we have moved onto a new line with the
-   prompt already displayed.  Code originally from the version of readline
-   distributed with CLISP. */
-int
-rl_on_new_line_with_prompt ()
-{
-  int prompt_size, i, l, real_screenwidth, newlines;
-  char *prompt_last_line;
-
-  /* Initialize visible_line and invisible_line to ensure that they can hold
-     the already-displayed prompt. */
-  prompt_size = strlen (rl_prompt) + 1;
-  init_line_structures (prompt_size);
-
-  /* Make sure the line structures hold the already-displayed prompt for
-     redisplay. */
-  strcpy (visible_line, rl_prompt);
-  strcpy (invisible_line, rl_prompt);
-
-  /* If the prompt contains newlines, take the last tail. */
-  prompt_last_line = strrchr (rl_prompt, '\n');
-  if (!prompt_last_line)
-    prompt_last_line = rl_prompt;
-
-  l = strlen (prompt_last_line);
-  _rl_last_c_pos = l;
-
-  /* Dissect prompt_last_line into screen lines. Note that here we have
-     to use the real screenwidth. Readline's notion of screenwidth might be
-     one less, see terminal.c. */
-  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);
-  _rl_last_v_pos = l / real_screenwidth;
-  /* If the prompt length is a multiple of real_screenwidth, we don't know
-     whether the cursor is at the end of the last line, or already at the
-     beginning of the next line. Output a newline just to be safe. */
-  if (l > 0 && (l % real_screenwidth) == 0)
-    _rl_output_some_chars ("\n", 1);
-  last_lmargin = 0;
-
-  newlines = 0; i = 0;
-  while (i <= l)
-    {
-      _rl_vis_botlin = newlines;
-      vis_lbreaks[newlines++] = i;
-      i += real_screenwidth;
-    }
-  vis_lbreaks[newlines] = l;
-  visible_wrap_offset = 0;
-
-  return 0;
-}
-
-/* Actually update the display, period. */
-int
-rl_forced_update_display ()
-{
-  if (visible_line)
-    {
-      register char *temp = visible_line;
-
-      while (*temp)
-	*temp++ = '\0';
-    }
-  rl_on_new_line ();
-  forced_display++;
-  (*rl_redisplay_function) ();
-  return 0;
-}
-
-/* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.
-   DATA is the contents of the screen line of interest; i.e., where
-   the movement is being done. */
-void
-_rl_move_cursor_relative (new, data)
-     int new;
-     const char *data;
-{
-  register int i;
-
-  /* If we don't have to do anything, then return. */
-  if (_rl_last_c_pos == new) return;
-
-  /* It may be faster to output a CR, and then move forwards instead
-     of moving backwards. */
-  /* i == current physical cursor position. */
-  i = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
-  if (new == 0 || CR_FASTER (new, _rl_last_c_pos) ||
-      (_rl_term_autowrap && i == _rl_screenwidth))
-    {
-#if defined (__MSDOS__)
-      putc ('\r', rl_outstream);
-#else
-      tputs (_rl_term_cr, 1, _rl_output_character_function);
-#endif /* !__MSDOS__ */
-      _rl_last_c_pos = 0;
-    }
-
-  if (_rl_last_c_pos < new)
-    {
-      /* Move the cursor forward.  We do it by printing the command
-	 to move the cursor forward if there is one, else print that
-	 portion of the output buffer again.  Which is cheaper? */
-
-      /* The above comment is left here for posterity.  It is faster
-	 to print one character (non-control) than to print a control
-	 sequence telling the terminal to move forward one character.
-	 That kind of control is for people who don't know what the
-	 data is underneath the cursor. */
-#if defined (HACK_TERMCAP_MOTION)
-      if (_rl_term_forward_char)
-	for (i = _rl_last_c_pos; i < new; i++)
-	  tputs (_rl_term_forward_char, 1, _rl_output_character_function);
-      else
-	for (i = _rl_last_c_pos; i < new; i++)
-	  putc (data[i], rl_outstream);
-#else
-      for (i = _rl_last_c_pos; i < new; i++)
-	putc (data[i], rl_outstream);
-#endif /* HACK_TERMCAP_MOTION */
-    }
-  else if (_rl_last_c_pos > new)
-    _rl_backspace (_rl_last_c_pos - new);
-  _rl_last_c_pos = new;
-}
-
-/* PWP: move the cursor up or down. */
-void
-_rl_move_vert (to)
-     int to;
-{
-  register int delta, i;
-
-  if (_rl_last_v_pos == to || to > _rl_screenheight)
-    return;
-
-  if ((delta = to - _rl_last_v_pos) > 0)
-    {
-      for (i = 0; i < delta; i++)
-	putc ('\n', rl_outstream);
-#if defined (__MSDOS__)
-      putc ('\r', rl_outstream);
-#else
-      tputs (_rl_term_cr, 1, _rl_output_character_function);
-#endif
-      _rl_last_c_pos = 0;
-    }
-  else
-    {			/* delta < 0 */
-      if (_rl_term_up && *_rl_term_up)
-	for (i = 0; i < -delta; i++)
-	  tputs (_rl_term_up, 1, _rl_output_character_function);
-    }
-
-  _rl_last_v_pos = to;		/* Now TO is here */
-}
-
-/* Physically print C on rl_outstream.  This is for functions which know
-   how to optimize the display.  Return the number of characters output. */
-int
-rl_show_char (c)
-     int c;
-{
-  int n = 1;
-  if (META_CHAR (c) && (_rl_output_meta_chars == 0))
-    {
-      fprintf (rl_outstream, "M-");
-      n += 2;
-      c = UNMETA (c);
-    }
-
-#if defined (DISPLAY_TABS)
-  if ((CTRL_CHAR (c) && c != '\t') || c == RUBOUT)
-#else
-  if (CTRL_CHAR (c) || c == RUBOUT)
-#endif /* !DISPLAY_TABS */
-    {
-      fprintf (rl_outstream, "C-");
-      n += 2;
-      c = CTRL_CHAR (c) ? UNCTRL (c) : '?';
-    }
-
-  putc (c, rl_outstream);
-  fflush (rl_outstream);
-  return n;
-}
-
-int
-rl_character_len (c, pos)
-     register int c, pos;
-{
-  unsigned char uc;
-
-  uc = (unsigned char)c;
-
-  if (META_CHAR (uc))
-    return ((_rl_output_meta_chars == 0) ? 4 : 1);
-
-  if (uc == '\t')
-    {
-#if defined (DISPLAY_TABS)
-      return (((pos | 7) + 1) - pos);
-#else
-      return (2);
-#endif /* !DISPLAY_TABS */
-    }
-
-  if (CTRL_CHAR (c) || c == RUBOUT)
-    return (2);
-
-  return ((isprint (uc)) ? 1 : 2);
-}
-
-/* How to print things in the "echo-area".  The prompt is treated as a
-   mini-modeline. */
-
-#if defined (USE_VARARGS)
-int
-#if defined (PREFER_STDARG)
-rl_message (const char *format, ...)
-#else
-rl_message (va_alist)
-     va_dcl
-#endif
-{
-  va_list args;
-#if defined (PREFER_VARARGS)
-  char *format;
-#endif
-
-#if defined (PREFER_STDARG)
-  va_start (args, format);
-#else
-  va_start (args);
-  format = va_arg (args, char *);
-#endif
-
-  vsprintf (msg_buf, format, args);
-  va_end (args);
-
-  rl_display_prompt = msg_buf;
-  (*rl_redisplay_function) ();
-  return 0;
-}
-#else /* !USE_VARARGS */
-int
-rl_message (format, arg1, arg2)
-     char *format;
-{
-  sprintf (msg_buf, format, arg1, arg2);
-  rl_display_prompt = msg_buf;
-  (*rl_redisplay_function) ();
-  return 0;
-}
-#endif /* !USE_VARARGS */
-
-/* How to clear things from the "echo-area". */
-int
-rl_clear_message ()
-{
-  rl_display_prompt = rl_prompt;
-  (*rl_redisplay_function) ();
-  return 0;
-}
-
-int
-rl_reset_line_state ()
-{
-  rl_on_new_line ();
-
-  rl_display_prompt = rl_prompt ? rl_prompt : "";
-  forced_display = 1;
-  return 0;
-}
-
-static char *saved_local_prompt;
-static char *saved_local_prefix;
-static int saved_last_invisible;
-static int saved_visible_length;
-
-void
-rl_save_prompt ()
-{
-  saved_local_prompt = local_prompt;
-  saved_local_prefix = local_prompt_prefix;
-  saved_last_invisible = prompt_last_invisible;
-  saved_visible_length = prompt_visible_length;
-
-  local_prompt = local_prompt_prefix = (char *)0;
-  prompt_last_invisible = prompt_visible_length = 0;
-}
-
-void
-rl_restore_prompt ()
-{
-  FREE (local_prompt);
-  FREE (local_prompt_prefix);
-
-  local_prompt = saved_local_prompt;
-  local_prompt_prefix = saved_local_prefix;
-  prompt_last_invisible = saved_last_invisible;
-  prompt_visible_length = saved_visible_length;
-}
-
-char *
-_rl_make_prompt_for_search (pchar)
-     int pchar;
-{
-  int len;
-  char *pmt;
-
-  rl_save_prompt ();
-
-  if (saved_local_prompt == 0)
-    {
-      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
-      pmt = xmalloc (len + 2);
-      if (len)
-	strcpy (pmt, rl_prompt);
-      pmt[len] = pchar;
-      pmt[len+1] = '\0';
-    }
-  else
-    {
-      len = *saved_local_prompt ? strlen (saved_local_prompt) : 0;
-      pmt = xmalloc (len + 2);
-      if (len)
-	strcpy (pmt, saved_local_prompt);
-      pmt[len] = pchar;
-      pmt[len+1] = '\0';
-      local_prompt = savestring (pmt);
-      prompt_last_invisible = saved_last_invisible;
-      prompt_visible_length = saved_visible_length + 1;
-    }
-  return pmt;
-}
-
-/* Quick redisplay hack when erasing characters at the end of the line. */
-void
-_rl_erase_at_end_of_line (l)
-     int l;
-{
-  register int i;
-
-  _rl_backspace (l);
-  for (i = 0; i < l; i++)
-    putc (' ', rl_outstream);
-  _rl_backspace (l);
-  for (i = 0; i < l; i++)
-    visible_line[--_rl_last_c_pos] = '\0';
-  rl_display_fixed++;
-}
-
-/* Clear to the end of the line.  COUNT is the minimum
-   number of character spaces to clear, */
-void
-_rl_clear_to_eol (count)
-     int count;
-{
-  if (_rl_term_clreol)
-    tputs (_rl_term_clreol, 1, _rl_output_character_function);
-  else if (count)
-    space_to_eol (count);
-}
-
-/* Clear to the end of the line using spaces.  COUNT is the minimum
-   number of character spaces to clear, */
-static void
-space_to_eol (count)
-     int count;
-{
-  register int i;
-
-  for (i = 0; i < count; i++)
-   putc (' ', rl_outstream);
-
-  _rl_last_c_pos += count;
-}
-
-void
-_rl_clear_screen ()
-{
-  if (_rl_term_clrpag)
-    tputs (_rl_term_clrpag, 1, _rl_output_character_function);
-  else
-    rl_crlf ();
-}
-
-/* Insert COUNT characters from STRING to the output stream. */
-static void
-insert_some_chars (string, count)
-     char *string;
-     int count;
-{
-  /* If IC is defined, then we do not have to "enter" insert mode. */
-  if (_rl_term_IC)
-    {
-      char *buffer;
-      buffer = tgoto (_rl_term_IC, 0, count);
-      tputs (buffer, 1, _rl_output_character_function);
-      _rl_output_some_chars (string, count);
-    }
-  else
-    {
-      register int i;
-
-      /* If we have to turn on insert-mode, then do so. */
-      if (_rl_term_im && *_rl_term_im)
-	tputs (_rl_term_im, 1, _rl_output_character_function);
-
-      /* If there is a special command for inserting characters, then
-	 use that first to open up the space. */
-      if (_rl_term_ic && *_rl_term_ic)
-	{
-	  for (i = count; i--; )
-	    tputs (_rl_term_ic, 1, _rl_output_character_function);
-	}
-
-      /* Print the text. */
-      _rl_output_some_chars (string, count);
-
-      /* If there is a string to turn off insert mode, we had best use
-	 it now. */
-      if (_rl_term_ei && *_rl_term_ei)
-	tputs (_rl_term_ei, 1, _rl_output_character_function);
-    }
-}
-
-/* Delete COUNT characters from the display line. */
-static void
-delete_chars (count)
-     int count;
-{
-  if (count > _rl_screenwidth)	/* XXX */
-    return;
-
-  if (_rl_term_DC && *_rl_term_DC)
-    {
-      char *buffer;
-      buffer = tgoto (_rl_term_DC, count, count);
-      tputs (buffer, count, _rl_output_character_function);
-    }
-  else
-    {
-      if (_rl_term_dc && *_rl_term_dc)
-	while (count--)
-	  tputs (_rl_term_dc, 1, _rl_output_character_function);
-    }
-}
-
-void
-_rl_update_final ()
-{
-  int full_lines;
-
-  full_lines = 0;
-  /* If the cursor is the only thing on an otherwise-blank last line,
-     compensate so we don't print an extra CRLF. */
-  if (_rl_vis_botlin && _rl_last_c_pos == 0 &&
-	visible_line[vis_lbreaks[_rl_vis_botlin]] == 0)
-    {
-      _rl_vis_botlin--;
-      full_lines = 1;
-    }
-  _rl_move_vert (_rl_vis_botlin);
-  /* If we've wrapped lines, remove the final xterm line-wrap flag. */
-  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))
-    {
-      char *last_line;
-#if 0
-      last_line = &visible_line[inv_lbreaks[_rl_vis_botlin]];
-#else
-      last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];
-#endif
-      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);
-      _rl_clear_to_eol (0);
-      putc (last_line[_rl_screenwidth - 1], rl_outstream);
-    }
-  _rl_vis_botlin = 0;
-  rl_crlf ();
-  fflush (rl_outstream);
-  rl_display_fixed++;
-}
-
-/* Move to the start of the current line. */
-static void
-cr ()
-{
-  if (_rl_term_cr)
-    {
-#if defined (__MSDOS__)
-      putc ('\r', rl_outstream);
-#else
-      tputs (_rl_term_cr, 1, _rl_output_character_function);
-#endif
-      _rl_last_c_pos = 0;
-    }
-}
-
-/* Redraw the last line of a multi-line prompt that may possibly contain
-   terminal escape sequences.  Called with the cursor at column 0 of the
-   line to draw the prompt on. */
-static void
-redraw_prompt (t)
-     char *t;
-{
-  char *oldp, *oldl, *oldlprefix;
-  int oldlen, oldlast, oldplen, oldninvis;
-
-  /* Geez, I should make this a struct. */
-  oldp = rl_display_prompt;
-  oldl = local_prompt;
-  oldlprefix = local_prompt_prefix;
-  oldlen = prompt_visible_length;
-  oldplen = prompt_prefix_length;
-  oldlast = prompt_last_invisible;
-  oldninvis = prompt_invis_chars_first_line;
-
-  rl_display_prompt = t;
-  local_prompt = expand_prompt (t, &prompt_visible_length,
-				   &prompt_last_invisible,
-				   &prompt_invis_chars_first_line);
-  local_prompt_prefix = (char *)NULL;
-  rl_forced_update_display ();
-
-  rl_display_prompt = oldp;
-  local_prompt = oldl;
-  local_prompt_prefix = oldlprefix;
-  prompt_visible_length = oldlen;
-  prompt_prefix_length = oldplen;
-  prompt_last_invisible = oldlast;
-  prompt_invis_chars_first_line = oldninvis;
-}
-      
-/* Redisplay the current line after a SIGWINCH is received. */
-void
-_rl_redisplay_after_sigwinch ()
-{
-  char *t;
-
-  /* Clear the current line and put the cursor at column 0.  Make sure
-     the right thing happens if we have wrapped to a new screen line. */
-  if (_rl_term_cr)
-    {
-#if defined (__MSDOS__)
-      putc ('\r', rl_outstream);
-#else
-      tputs (_rl_term_cr, 1, _rl_output_character_function);
-#endif
-      _rl_last_c_pos = 0;
-#if defined (__MSDOS__)
-      space_to_eol (_rl_screenwidth);
-      putc ('\r', rl_outstream);
-#else
-      if (_rl_term_clreol)
-	tputs (_rl_term_clreol, 1, _rl_output_character_function);
-      else
-	{
-	  space_to_eol (_rl_screenwidth);
-	  tputs (_rl_term_cr, 1, _rl_output_character_function);
-	}
-#endif
-      if (_rl_last_v_pos > 0)
-	_rl_move_vert (0);
-    }
-  else
-    rl_crlf ();
-
-  /* Redraw only the last line of a multi-line prompt. */
-  t = strrchr (rl_display_prompt, '\n');
-  if (t)
-    redraw_prompt (++t);
-  else
-    rl_forced_update_display ();
-}
-
-void
-_rl_clean_up_for_exit ()
-{
-  if (readline_echoing_p)
-    {
-      _rl_move_vert (_rl_vis_botlin);
-      _rl_vis_botlin = 0;
-      fflush (rl_outstream);
-      rl_restart_output (1, 0);
-    }
-}
-
-void
-_rl_erase_entire_line ()
-{
-  cr ();
-  _rl_clear_to_eol (0);
-  cr ();
-  fflush (rl_outstream);
-}
-
-/* return the `current display line' of the cursor -- the number of lines to
-   move up to get to the first screen line of the current readline line. */
-int
-_rl_current_display_line ()
-{
-  int ret, nleft;
-
-  /* Find out whether or not there might be invisible characters in the
-     editing buffer. */
-  if (rl_display_prompt == rl_prompt)
-    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;
-  else
-    nleft = _rl_last_c_pos - _rl_screenwidth;
-
-  if (nleft > 0)
-    ret = 1 + nleft / _rl_screenwidth;
-  else
-    ret = 0;
-
-  return ret;
-}
diff --git a/readline/doc/Makefile.in b/readline/doc/Makefile.in
deleted file mode 100644
--- a/readline/doc/Makefile.in
+++ /dev/null
@@ -1,192 +0,0 @@
-# This makefile for Readline library documentation is in -*- text -*- mode.
-# Emacs likes it that way.
-
-# Copyright (C) 1996 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-topdir = @top_srcdir@
-srcdir = @srcdir@
-VPATH = .:@srcdir@
-
-prefix = @prefix@
-infodir = @infodir@
-
-mandir = @mandir@
-manpfx = man
-
-man1ext = 1
-man1dir = $(mandir)/$(manpfx)$(man1ext)
-man3ext = 3
-man3dir = $(mandir)/$(manpfx)$(man3ext)
-
-SHELL = @MAKE_SHELL@
-RM = rm -f
-
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-
-BUILD_DIR = @BUILD_DIR@
-TEXINPUTDIR = $(srcdir)
-
-MAKEINFO    = LANGUAGE= makeinfo
-TEXI2DVI    = $(srcdir)/texi2dvi
-TEXI2HTML   = $(srcdir)/texi2html
-QUIETPS     = #set this to -q to shut up dvips
-PAPERSIZE   = letter
-PSDPI       = 300	# I don't have any 600-dpi printers
-DVIPS       = dvips -D ${PSDPI} $(QUIETPS) -t ${PAPERSIZE} -o $@     # tricky
-
-RLSRC = $(srcdir)/rlman.texinfo $(srcdir)/rluser.texinfo \
-	$(srcdir)/rltech.texinfo $(srcdir)/manvers.texinfo \
-	$(srcdir)/rluserman.texinfo
-HISTSRC = $(srcdir)/hist.texinfo $(srcdir)/hsuser.texinfo \
-	  $(srcdir)/hstech.texinfo $(srcdir)/manvers.texinfo
-
-# This should be a program that converts troff to an ascii-readable format
-NROFF       = groff -Tascii
-
-# This should be a program that converts troff to postscript
-GROFF       = groff
-
-DVIOBJ = readline.dvi history.dvi rluserman.dvi
-INFOOBJ = readline.info history.info rluserman.info
-PSOBJ = readline.ps history.ps rluserman.ps readline_3.ps history_3.ps
-HTMLOBJ = readline.html history.html rluserman.html
-TEXTOBJ = readline.0 history.0
-
-INTERMEDIATE_OBJ = rlman.dvi hist.dvi rluserman.dvi
-
-DIST_DOCS = $(DVIOBJ) $(PSOBJ) $(HTMLOBJ) $(INFOOBJ) $(TEXTOBJ)
-
-.SUFFIXES:      .0 .3 .ps .txt .dvi
-
-.3.0:
-	$(RM) $@
-	-${NROFF} -man $< > $@
-
-all: info dvi html ps text
-nodvi: info html text
-
-readline.dvi: $(RLSRC)
-	TEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/rlman.texinfo
-	mv rlman.dvi readline.dvi
-
-readline.info: $(RLSRC)
-	$(MAKEINFO) --no-split -I $(TEXINPUTDIR) -o $@ $(srcdir)/rlman.texinfo
-
-rluserman.dvi: $(RLSRC)
-	TEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/rluserman.texinfo
-
-rluserman.info: $(RLSRC)
-	$(MAKEINFO) --no-split -I $(TEXINPUTDIR) -o $@ $(srcdir)/rluserman.texinfo
-
-history.dvi: ${HISTSRC}
-	TEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/hist.texinfo
-	mv hist.dvi history.dvi
-
-history.info: ${HISTSRC}
-	$(MAKEINFO) --no-split -I $(TEXINPUTDIR) -o $@ $(srcdir)/hist.texinfo
-
-readline.ps:	readline.dvi
-	$(RM) $@
-	$(DVIPS) readline.dvi
-
-rluserman.ps:	rluserman.dvi
-	$(RM) $@
-	$(DVIPS) rluserman.dvi
-
-history.ps:	history.dvi
-	$(RM) $@
-	$(DVIPS) history.dvi
-
-readline.html:	${RLSRC}
-	$(TEXI2HTML) -menu -monolithic -I $(TEXINPUTDIR) $(srcdir)/rlman.texinfo
-	sed -e 's:rlman.html:readline.html:g' rlman.html > readline.html
-	$(RM) rlman.html
-
-rluserman.html:	${RLSRC}
-	$(TEXI2HTML) -menu -monolithic -I $(TEXINPUTDIR) $(srcdir)/rluserman.texinfo
-
-history.html:	${HISTSRC}
-	$(TEXI2HTML) -menu -monolithic -I $(TEXINPUTDIR) $(srcdir)/hist.texinfo
-	sed -e 's:hist.html:history.html:g' hist.html > history.html
-	$(RM) hist.html
-
-info:	$(INFOOBJ)
-dvi:	$(DVIOBJ)
-ps:	$(PSOBJ)
-html:	$(HTMLOBJ)
-text:	$(TEXTOBJ)
-
-readline.0: readline.3
-
-readline_3.ps: readline.3
-	${RM} $@
-	${GROFF} -man < $(srcdir)/readline.3 > $@ 
-
-history.0: history.3
-
-history_3.ps: history.3
-	${RM} $@
-	${GROFF} -man < $(srcdir)/history.3 > $@ 
-
-clean:
-	$(RM) *.aux *.cp *.fn *.ky *.log *.pg *.toc *.tp *.vr *.cps *.pgs \
-	      *.fns *.kys *.tps *.vrs *.bt *.bts *.o core
-
-distclean: clean
-	$(RM) $(INTERMEDIATE_OBJ)
-	$(RM) Makefile
-
-mostlyclean: clean
-
-maintainer-clean: clean
-	$(RM) $(DIST_DOCS)
-	$(RM) $(INTERMEDIATE_OBJ)
-	$(RM) Makefile
-
-installdirs:	$(topdir)/support/mkdirs
-	-$(SHELL) $(topdir)/support/mkdirs $(infodir) $(man3dir)
-
-install:	installdirs
-	if test -f readline.info; then \
-		${INSTALL_DATA} readline.info $(infodir)/readline.info; \
-	else \
-		${INSTALL_DATA} $(srcdir)/readline.info $(infodir)/readline.info; \
-	fi
-	if test -f rluserman.info; then \
-		${INSTALL_DATA} rluserman.info $(infodir)/rluserman.info; \
-	else \
-		${INSTALL_DATA} $(srcdir)/rluserman.info $(infodir)/rluserman.info; \
-	fi
-	if test -f history.info; then \
-		${INSTALL_DATA} history.info $(infodir)/history.info; \
-	else \
-		${INSTALL_DATA} $(srcdir)/history.info $(infodir)/history.info; \
-	fi
-	-if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
-		install-info --dir-file=$(infodir)/dir $(infodir)/readline.info ; \
-		install-info --dir-file=$(infodir)/dir $(infodir)/history.info ; \
-	else true; fi
-	-${INSTALL_DATA} $(srcdir)/readline.3 $(man3dir)/readline.3
-	-${INSTALL_DATA} $(srcdir)/history.3 $(man3dir)/history.3
-
-uninstall:
-	$(RM) $(infodir)/readline.info
-	$(RM) $(infodir)/rluserman.info
-	$(RM) $(infodir)/history.info
-	$(RM) $(man3dir)/readline.3
-	$(RM) $(man3dir)/history.3
diff --git a/readline/doc/hist.texinfo b/readline/doc/hist.texinfo
deleted file mode 100644
--- a/readline/doc/hist.texinfo
+++ /dev/null
@@ -1,110 +0,0 @@
-\input texinfo    @c -*-texinfo-*-
-@c %**start of header (This is for running Texinfo on a region.)
-@setfilename history.info
-@settitle GNU History Library
-@c %**end of header (This is for running Texinfo on a region.)
-
-@setchapternewpage odd
-
-@include manvers.texinfo
-
-@ifinfo
-@dircategory Libraries
-@direntry
-* History: (history).       The GNU history library API
-@end direntry
-
-This document describes the GNU History library, a programming tool that
-provides a consistent user interface for recalling lines of previously
-typed input.
-
-Copyright (C) 1988-2001 Free Software Foundation, Inc.
-
-Permission is granted to make and distribute verbatim copies of
-this manual provided the copyright notice and this permission notice
-pare preserved on all copies.
-
-@ignore
-Permission is granted to process this file through TeX and print the
-results, provided the printed document carries copying permission
-notice identical to this one except for the removal of this paragraph
-(this paragraph not being relevant to the printed manual).
-@end ignore
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided that the entire
-resulting derived work is distributed under the terms of a permission
-notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions,
-except that this permission notice may be stated in a translation approved
-by the Free Software Foundation.
-@end ifinfo
-
-@titlepage
-@title GNU History Library
-@subtitle Edition @value{EDITION}, for @code{History Library} Version @value{VERSION}.
-@subtitle @value{UPDATE-MONTH}
-@author Brian Fox, Free Software Foundation
-@author Chet Ramey, Case Western Reserve University
-
-@page
-This document describes the GNU History library, a programming tool that
-provides a consistent user interface for recalling lines of previously
-typed input.
-
-Published by the Free Software Foundation @*
-59 Temple Place, Suite 330, @*
-Boston, MA 02111 USA
-
-Permission is granted to make and distribute verbatim copies of
-this manual provided the copyright notice and this permission notice
-are preserved on all copies.
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided that the entire
-resulting derived work is distributed under the terms of a permission
-notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions,
-except that this permission notice may be stated in a translation approved
-by the Free Software Foundation.
-
-@vskip 0pt plus 1filll
-Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
-@end titlepage
-
-@ifinfo
-@node Top
-@top GNU History Library
-
-This document describes the GNU History library, a programming tool that
-provides a consistent user interface for recalling lines of previously
-typed input.
-
-@menu
-* Using History Interactively::	  GNU History User's Manual.
-* Programming with GNU History::  GNU History Programmer's Manual.
-* Concept Index::		  Index of concepts described in this manual.
-* Function and Variable Index::	  Index of externally visible functions
-				  and variables.
-@end menu
-@end ifinfo
-
-@syncodeindex fn vr
-
-@include hsuser.texinfo
-@include hstech.texinfo
-
-@node Concept Index
-@appendix Concept Index
-@printindex cp
-
-@node Function and Variable Index
-@appendix Function and Variable Index
-@printindex vr
-
-@contents
-@bye
diff --git a/readline/doc/hstech.texinfo b/readline/doc/hstech.texinfo
deleted file mode 100644
--- a/readline/doc/hstech.texinfo
+++ /dev/null
@@ -1,549 +0,0 @@
-@ignore
-This file documents the user interface to the GNU History library.
-
-Copyright (C) 1988-2001 Free Software Foundation, Inc.
-Authored by Brian Fox and Chet Ramey.
-
-Permission is granted to make and distribute verbatim copies of this manual
-provided the copyright notice and this permission notice are preserved on
-all copies.
-
-Permission is granted to process this file through Tex and print the
-results, provided the printed document carries copying permission notice
-identical to this one except for the removal of this paragraph (this
-paragraph not being relevant to the printed manual).
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided also that the
-GNU Copyright statement is available to the distributee, and provided that
-the entire resulting derived work is distributed under the terms of a
-permission notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions.
-@end ignore
-
-@node Programming with GNU History
-@chapter Programming with GNU History
-
-This chapter describes how to interface programs that you write
-with the @sc{gnu} History Library.
-It should be considered a technical guide.
-For information on the interactive use of @sc{gnu} History, @pxref{Using
-History Interactively}.
-
-@menu
-* Introduction to History::	What is the GNU History library for?
-* History Storage::		How information is stored.
-* History Functions::		Functions that you can use.
-* History Variables::		Variables that control behaviour.
-* History Programming Example::	Example of using the GNU History Library.
-@end menu
-
-@node Introduction to History
-@section Introduction to History
-
-Many programs read input from the user a line at a time.  The @sc{gnu}
-History library is able to keep track of those lines, associate arbitrary
-data with each line, and utilize information from previous lines in
-composing new ones. 
-
-The programmer using the History library has available functions
-for remembering lines on a history list, associating arbitrary data
-with a line, removing lines from the list, searching through the list
-for a line containing an arbitrary text string, and referencing any line
-in the list directly.  In addition, a history @dfn{expansion} function
-is available which provides for a consistent user interface across
-different programs.
-
-The user using programs written with the History library has the
-benefit of a consistent user interface with a set of well-known
-commands for manipulating the text of previous lines and using that text
-in new commands.  The basic history manipulation commands are similar to
-the history substitution provided by @code{csh}.
-
-If the programmer desires, he can use the Readline library, which
-includes some history manipulation by default, and has the added
-advantage of command line editing.
-
-Before declaring any functions using any functionality the History
-library provides in other code, an application writer should include
-the file @code{<readline/history.h>} in any file that uses the
-History library's features.  It supplies extern declarations for all
-of the library's public functions and variables, and declares all of
-the public data structures.
-
-@node History Storage
-@section History Storage
-
-The history list is an array of history entries.  A history entry is
-declared as follows:
-
-@example
-typedef void *histdata_t;
-
-typedef struct _hist_entry @{
-  char *line;
-  histdata_t data;
-@} HIST_ENTRY;
-@end example
-
-The history list itself might therefore be declared as
-
-@example
-HIST_ENTRY **the_history_list;
-@end example
-
-The state of the History library is encapsulated into a single structure:
-
-@example
-/*
- * A structure used to pass around the current state of the history.
- */
-typedef struct _hist_state @{
-  HIST_ENTRY **entries; /* Pointer to the entries themselves. */
-  int offset;           /* The location pointer within this array. */
-  int length;           /* Number of elements within this array. */
-  int size;             /* Number of slots allocated to this array. */
-  int flags;
-@} HISTORY_STATE;
-@end example
-
-If the flags member includes @code{HS_STIFLED}, the history has been
-stifled.
-
-@node History Functions
-@section History Functions
-
-This section describes the calling sequence for the various functions
-exported by the @sc{gnu} History library.
-
-@menu
-* Initializing History and State Management::	Functions to call when you
-						want to use history in a
-						program.
-* History List Management::		Functions used to manage the list
-					of history entries.
-* Information About the History List::	Functions returning information about
-					the history list.
-* Moving Around the History List::	Functions used to change the position
-					in the history list.
-* Searching the History List::		Functions to search the history list
-					for entries containing a string.
-* Managing the History File::		Functions that read and write a file
-					containing the history list.
-* History Expansion::			Functions to perform csh-like history
-					expansion.
-@end menu
-
-@node Initializing History and State Management
-@subsection Initializing History and State Management
-
-This section describes functions used to initialize and manage
-the state of the History library when you want to use the history
-functions in your program.
-
-@deftypefun void using_history (void)
-Begin a session in which the history functions might be used.  This
-initializes the interactive variables.
-@end deftypefun
-
-@deftypefun {HISTORY_STATE *} history_get_history_state (void)
-Return a structure describing the current state of the input history.
-@end deftypefun
-
-@deftypefun void history_set_history_state (HISTORY_STATE *state)
-Set the state of the history list according to @var{state}.
-@end deftypefun
-
-@node History List Management
-@subsection History List Management
-
-These functions manage individual entries on the history list, or set
-parameters managing the list itself.
-
-@deftypefun void add_history (const char *string)
-Place @var{string} at the end of the history list.  The associated data
-field (if any) is set to @code{NULL}.
-@end deftypefun
-
-@deftypefun {HIST_ENTRY *} remove_history (int which)
-Remove history entry at offset @var{which} from the history.  The
-removed element is returned so you can free the line, data,
-and containing structure.
-@end deftypefun
-
-@deftypefun {HIST_ENTRY *} replace_history_entry (int which, const char *line, histdata_t data)
-Make the history entry at offset @var{which} have @var{line} and @var{data}.
-This returns the old entry so you can dispose of the data.  In the case
-of an invalid @var{which}, a @code{NULL} pointer is returned.
-@end deftypefun
-
-@deftypefun void clear_history (void)
-Clear the history list by deleting all the entries.
-@end deftypefun
-
-@deftypefun void stifle_history (int max)
-Stifle the history list, remembering only the last @var{max} entries.
-@end deftypefun
-
-@deftypefun int unstifle_history (void)
-Stop stifling the history.  This returns the previous amount the
-history was stifled.  The value is positive if the history was
-stifled, negative if it wasn't.
-@end deftypefun
-
-@deftypefun int history_is_stifled (void)
-Returns non-zero if the history is stifled, zero if it is not.
-@end deftypefun
-
-@node Information About the History List
-@subsection Information About the History List
-
-These functions return information about the entire history list or
-individual list entries.
-
-@deftypefun {HIST_ENTRY **} history_list (void)
-Return a @code{NULL} terminated array of @code{HIST_ENTRY *} which is the
-current input history.  Element 0 of this list is the beginning of time.
-If there is no history, return @code{NULL}.
-@end deftypefun
-
-@deftypefun int where_history (void)
-Returns the offset of the current history element.
-@end deftypefun
-
-@deftypefun {HIST_ENTRY *} current_history (void)
-Return the history entry at the current position, as determined by
-@code{where_history()}.  If there is no entry there, return a @code{NULL}
-pointer.
-@end deftypefun
-
-@deftypefun {HIST_ENTRY *} history_get (int offset)
-Return the history entry at position @var{offset}, starting from
-@code{history_base} (@pxref{History Variables}).
-If there is no entry there, or if @var{offset}
-is greater than the history length, return a @code{NULL} pointer.
-@end deftypefun
-
-@deftypefun int history_total_bytes (void)
-Return the number of bytes that the primary history entries are using.
-This function returns the sum of the lengths of all the lines in the
-history.
-@end deftypefun
-
-@node Moving Around the History List
-@subsection Moving Around the History List
-
-These functions allow the current index into the history list to be
-set or changed.
-
-@deftypefun int history_set_pos (int pos)
-Set the current history offset to @var{pos}, an absolute index
-into the list.
-Returns 1 on success, 0 if @var{pos} is less than zero or greater
-than the number of history entries.
-@end deftypefun
-
-@deftypefun {HIST_ENTRY *} previous_history (void)
-Back up the current history offset to the previous history entry, and
-return a pointer to that entry.  If there is no previous entry, return
-a @code{NULL} pointer.
-@end deftypefun
-
-@deftypefun {HIST_ENTRY *} next_history (void)
-Move the current history offset forward to the next history entry, and
-return the a pointer to that entry.  If there is no next entry, return
-a @code{NULL} pointer.
-@end deftypefun
-
-@node Searching the History List
-@subsection Searching the History List
-@cindex History Searching
-
-These functions allow searching of the history list for entries containing
-a specific string.  Searching may be performed both forward and backward
-from the current history position.  The search may be @dfn{anchored},
-meaning that the string must match at the beginning of the history entry.
-@cindex anchored search
-
-@deftypefun int history_search (const char *string, int direction)
-Search the history for @var{string}, starting at the current history offset.
-If @var{direction} is less than 0, then the search is through
-previous entries, otherwise through subsequent entries.
-If @var{string} is found, then
-the current history index is set to that history entry, and the value
-returned is the offset in the line of the entry where
-@var{string} was found.  Otherwise, nothing is changed, and a -1 is
-returned.
-@end deftypefun
-
-@deftypefun int history_search_prefix (const char *string, int direction)
-Search the history for @var{string}, starting at the current history
-offset.  The search is anchored: matching lines must begin with
-@var{string}.  If @var{direction} is less than 0, then the search is
-through previous entries, otherwise through subsequent entries.
-If @var{string} is found, then the
-current history index is set to that entry, and the return value is 0. 
-Otherwise, nothing is changed, and a -1 is returned. 
-@end deftypefun
-
-@deftypefun int history_search_pos (const char *string, int direction, int pos)
-Search for @var{string} in the history list, starting at @var{pos}, an
-absolute index into the list.  If @var{direction} is negative, the search
-proceeds backward from @var{pos}, otherwise forward.  Returns the absolute
-index of the history element where @var{string} was found, or -1 otherwise.
-@end deftypefun
-
-@node Managing the History File
-@subsection Managing the History File
-
-The History library can read the history from and write it to a file.
-This section documents the functions for managing a history file.
-
-@deftypefun int read_history (const char *filename)
-Add the contents of @var{filename} to the history list, a line at a time.
-If @var{filename} is @code{NULL}, then read from @file{~/.history}.
-Returns 0 if successful, or @code{errno} if not.
-@end deftypefun
-
-@deftypefun int read_history_range (const char *filename, int from, int to)
-Read a range of lines from @var{filename}, adding them to the history list.
-Start reading at line @var{from} and end at @var{to}.
-If @var{from} is zero, start at the beginning.  If @var{to} is less than
-@var{from}, then read until the end of the file.  If @var{filename} is
-@code{NULL}, then read from @file{~/.history}.  Returns 0 if successful,
-or @code{errno} if not.
-@end deftypefun
-
-@deftypefun int write_history (const char *filename)
-Write the current history to @var{filename}, overwriting @var{filename}
-if necessary.
-If @var{filename} is @code{NULL}, then write the history list to
-@file{~/.history}.
-Returns 0 on success, or @code{errno} on a read or write error.
-@end deftypefun
-
-@deftypefun int append_history (int nelements, const char *filename)
-Append the last @var{nelements} of the history list to @var{filename}.
-If @var{filename} is @code{NULL}, then append to @file{~/.history}.
-Returns 0 on success, or @code{errno} on a read or write error.
-@end deftypefun
-
-@deftypefun int history_truncate_file (const char *filename, int nlines)
-Truncate the history file @var{filename}, leaving only the last
-@var{nlines} lines.
-If @var{filename} is @code{NULL}, then @file{~/.history} is truncated.
-Returns 0 on success, or @code{errno} on failure.
-@end deftypefun
-
-@node History Expansion
-@subsection History Expansion
-
-These functions implement history expansion.
-
-@deftypefun int history_expand (char *string, char **output)
-Expand @var{string}, placing the result into @var{output}, a pointer
-to a string (@pxref{History Interaction}).  Returns:
-@table @code
-@item 0
-If no expansions took place (or, if the only change in
-the text was the removal of escape characters preceding the history expansion
-character);
-@item 1
-if expansions did take place;
-@item -1
-if there was an error in expansion;
-@item 2
-if the returned line should be displayed, but not executed,
-as with the @code{:p} modifier (@pxref{Modifiers}).
-@end table
-
-If an error ocurred in expansion, then @var{output} contains a descriptive
-error message.
-@end deftypefun
-
-@deftypefun {char *} get_history_event (const char *string, int *cindex, int qchar)
-Returns the text of the history event beginning at @var{string} +
-@var{*cindex}.  @var{*cindex} is modified to point to after the event
-specifier.  At function entry, @var{cindex} points to the index into
-@var{string} where the history event specification begins.  @var{qchar}
-is a character that is allowed to end the event specification in addition
-to the ``normal'' terminating characters.
-@end deftypefun
-
-@deftypefun {char **} history_tokenize (const char *string)
-Return an array of tokens parsed out of @var{string}, much as the
-shell might.  The tokens are split on the characters in the
-@var{history_word_delimiters} variable,
-and shell quoting conventions are obeyed.
-@end deftypefun
-
-@deftypefun {char *} history_arg_extract (int first, int last, const char *string)
-Extract a string segment consisting of the @var{first} through @var{last}
-arguments present in @var{string}.  Arguments are split using
-@code{history_tokenize}.
-@end deftypefun
-
-@node History Variables
-@section History Variables
-
-This section describes the externally-visible variables exported by
-the @sc{gnu} History Library.
-
-@deftypevar int history_base
-The logical offset of the first entry in the history list.
-@end deftypevar
-
-@deftypevar int history_length
-The number of entries currently stored in the history list.
-@end deftypevar
-
-@deftypevar int history_max_entries
-The maximum number of history entries.  This must be changed using
-@code{stifle_history()}.
-@end deftypevar
-
-@deftypevar char history_expansion_char
-The character that introduces a history event.  The default is @samp{!}.
-Setting this to 0 inhibits history expansion.
-@end deftypevar
-
-@deftypevar char history_subst_char
-The character that invokes word substitution if found at the start of
-a line.  The default is @samp{^}.
-@end deftypevar
-
-@deftypevar char history_comment_char
-During tokenization, if this character is seen as the first character
-of a word, then it and all subsequent characters up to a newline are
-ignored, suppressing history expansion for the remainder of the line.
-This is disabled by default.
-@end deftypevar
-
-@deftypevar {char *} history_word_delimiters
-The characters that separate tokens for \fBhistory_tokenize()\fP.
-The default value is @code{" \t\n()<>;&|"}.
-@end deftypevar
-
-@deftypevar {char *} history_no_expand_chars
-The list of characters which inhibit history expansion if found immediately
-following @var{history_expansion_char}.  The default is space, tab, newline,
-carriage return, and @samp{=}.
-@end deftypevar
-
-@deftypevar {char *} history_search_delimiter_chars
-The list of additional characters which can delimit a history search
-string, in addition to space, TAB, @samp{:} and @samp{?} in the case of
-a substring search.  The default is empty.
-@end deftypevar
-
-@deftypevar int history_quotes_inhibit_expansion
-If non-zero, single-quoted words are not scanned for the history expansion
-character.  The default value is 0.
-@end deftypevar
-
-@deftypevar {rl_linebuf_func_t *} history_inhibit_expansion_function
-This should be set to the address of a function that takes two arguments:
-a @code{char *} (@var{string})
-and an @code{int} index into that string (@var{i}).
-It should return a non-zero value if the history expansion starting at
-@var{string[i]} should not be performed; zero if the expansion should
-be done.
-It is intended for use by applications like Bash that use the history
-expansion character for additional purposes.
-By default, this variable is set to @code{NULL}.
-@end deftypevar
-
-@node History Programming Example
-@section History Programming Example
-
-The following program demonstrates simple use of the @sc{gnu} History Library.
-
-@smallexample
-#include <stdio.h>
-#include <readline/history.h>
-
-main (argc, argv)
-     int argc;
-     char **argv;
-@{
-  char line[1024], *t;
-  int len, done = 0;
-
-  line[0] = 0;
-
-  using_history ();
-  while (!done)
-    @{
-      printf ("history$ ");
-      fflush (stdout);
-      t = fgets (line, sizeof (line) - 1, stdin);
-      if (t && *t)
-        @{
-          len = strlen (t);
-          if (t[len - 1] == '\n')
-            t[len - 1] = '\0';
-        @}
-
-      if (!t)
-        strcpy (line, "quit");
-
-      if (line[0])
-        @{
-          char *expansion;
-          int result;
-
-          result = history_expand (line, &expansion);
-          if (result)
-            fprintf (stderr, "%s\n", expansion);
-
-          if (result < 0 || result == 2)
-            @{
-              free (expansion);
-              continue;
-            @}
-
-          add_history (expansion);
-          strncpy (line, expansion, sizeof (line) - 1);
-          free (expansion);
-        @}
-
-      if (strcmp (line, "quit") == 0)
-        done = 1;
-      else if (strcmp (line, "save") == 0)
-        write_history ("history_file");
-      else if (strcmp (line, "read") == 0)
-        read_history ("history_file");
-      else if (strcmp (line, "list") == 0)
-        @{
-          register HIST_ENTRY **the_list;
-          register int i;
-
-          the_list = history_list ();
-          if (the_list)
-            for (i = 0; the_list[i]; i++)
-              printf ("%d: %s\n", i + history_base, the_list[i]->line);
-        @}
-      else if (strncmp (line, "delete", 6) == 0)
-        @{
-          int which;
-          if ((sscanf (line + 6, "%d", &which)) == 1)
-            @{
-              HIST_ENTRY *entry = remove_history (which);
-              if (!entry)
-                fprintf (stderr, "No such entry %d\n", which);
-              else
-                @{
-                  free (entry->line);
-                  free (entry);
-                @}
-            @}
-          else
-            @{
-              fprintf (stderr, "non-numeric arg given to `delete'\n");
-            @}
-        @}
-    @}
-@}
-@end smallexample
diff --git a/readline/doc/hsuser.texinfo b/readline/doc/hsuser.texinfo
deleted file mode 100644
--- a/readline/doc/hsuser.texinfo
+++ /dev/null
@@ -1,437 +0,0 @@
-@ignore
-This file documents the user interface to the GNU History library.
-
-Copyright (C) 1988-1999 Free Software Foundation, Inc.
-Authored by Brian Fox and Chet Ramey.
-
-Permission is granted to make and distribute verbatim copies of this manual
-provided the copyright notice and this permission notice are preserved on
-all copies.
-
-Permission is granted to process this file through Tex and print the
-results, provided the printed document carries copying permission notice
-identical to this one except for the removal of this paragraph (this
-paragraph not being relevant to the printed manual).
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided also that the
-GNU Copyright statement is available to the distributee, and provided that
-the entire resulting derived work is distributed under the terms of a
-permission notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions.
-@end ignore
-
-@node Using History Interactively
-@chapter Using History Interactively
-
-@ifclear BashFeatures
-@defcodeindex bt
-@end ifclear
-
-@ifset BashFeatures
-This chapter describes how to use the @sc{gnu} History Library
-interactively, from a user's standpoint.
-It should be considered a user's guide.
-For information on using the @sc{gnu} History Library in other programs,
-see the @sc{gnu} Readline Library Manual.
-@end ifset
-@ifclear BashFeatures
-This chapter describes how to use the @sc{gnu} History Library interactively,
-from a user's standpoint.  It should be considered a user's guide.  For
-information on using the @sc{gnu} History Library in your own programs,
-@pxref{Programming with GNU History}.
-@end ifclear
-
-@ifset BashFeatures
-@menu
-* Bash History Facilities::	How Bash lets you manipulate your command
-				history.
-* Bash History Builtins::	The Bash builtin commands that manipulate
-				the command history.
-* History Interaction::		What it feels like using History as a user.
-@end menu
-@end ifset
-@ifclear BashFeatures
-@menu
-* History Interaction::		What it feels like using History as a user.
-@end menu
-@end ifclear
-
-@ifset BashFeatures
-@node Bash History Facilities
-@section Bash History Facilities
-@cindex command history
-@cindex history list
-
-When the @option{-o history} option to the @code{set} builtin
-is enabled (@pxref{The Set Builtin}),
-the shell provides access to the @dfn{command history},
-the list of commands previously typed.
-The value of the @env{HISTSIZE} shell variable is used as the
-number of commands to save in a history list.
-The text of the last @env{$HISTSIZE}
-commands (default 500) is saved.
-The shell stores each command in the history list prior to
-parameter and variable expansion
-but after history expansion is performed, subject to the
-values of the shell variables
-@env{HISTIGNORE} and @env{HISTCONTROL}.
-
-When the shell starts up, the history is initialized from the
-file named by the @env{HISTFILE} variable (default @file{~/.bash_history}).
-The file named by the value of @env{HISTFILE} is truncated, if
-necessary, to contain no more than the number of lines specified by
-the value of the @env{HISTFILESIZE} variable.
-When an interactive shell exits, the last
-@env{$HISTSIZE} lines are copied from the history list to the file
-named by @env{$HISTFILE}.
-If the @code{histappend} shell option is set (@pxref{Bash Builtins}),
-the lines are appended to the history file,
-otherwise the history file is overwritten.
-If @env{HISTFILE}
-is unset, or if the history file is unwritable, the history is
-not saved.  After saving the history, the history file is truncated
-to contain no more than @env{$HISTFILESIZE}
-lines.  If @env{HISTFILESIZE} is not set, no truncation is performed.
-
-The builtin command @code{fc} may be used to list or edit and re-execute
-a portion of the history list.
-The @code{history} builtin may be used to display or modify the history
-list and manipulate the history file.
-When using command-line editing, search commands
-are available in each editing mode that provide access to the
-history list (@pxref{Commands For History}).
-
-The shell allows control over which commands are saved on the history
-list.  The @env{HISTCONTROL} and @env{HISTIGNORE}
-variables may be set to cause the shell to save only a subset of the
-commands entered.
-The @code{cmdhist}
-shell option, if enabled, causes the shell to attempt to save each
-line of a multi-line command in the same history entry, adding
-semicolons where necessary to preserve syntactic correctness.
-The @code{lithist}
-shell option causes the shell to save the command with embedded newlines
-instead of semicolons.
-The @code{shopt} builtin is used to set these options.
-@xref{Bash Builtins}, for a description of @code{shopt}.
-
-@node Bash History Builtins
-@section Bash History Builtins
-@cindex history builtins
-
-Bash provides two builtin commands which manipulate the
-history list and history file.
-
-@table @code
-
-@item fc
-@btindex fc
-@example
-@code{fc [-e @var{ename}] [-nlr] [@var{first}] [@var{last}]}
-@code{fc -s [@var{pat}=@var{rep}] [@var{command}]}
-@end example
-
-Fix Command.  In the first form, a range of commands from @var{first} to
-@var{last} is selected from the history list.  Both @var{first} and
-@var{last} may be specified as a string (to locate the most recent
-command beginning with that string) or as a number (an index into the
-history list, where a negative number is used as an offset from the
-current command number).  If @var{last} is not specified it is set to
-@var{first}.  If @var{first} is not specified it is set to the previous
-command for editing and @minus{}16 for listing.  If the @option{-l} flag is
-given, the commands are listed on standard output.  The @option{-n} flag
-suppresses the command numbers when listing.  The @option{-r} flag
-reverses the order of the listing.  Otherwise, the editor given by
-@var{ename} is invoked on a file containing those commands.  If
-@var{ename} is not given, the value of the following variable expansion
-is used: @code{$@{FCEDIT:-$@{EDITOR:-vi@}@}}.  This says to use the
-value of the @env{FCEDIT} variable if set, or the value of the
-@env{EDITOR} variable if that is set, or @code{vi} if neither is set.
-When editing is complete, the edited commands are echoed and executed.
-
-In the second form, @var{command} is re-executed after each instance
-of @var{pat} in the selected command is replaced by @var{rep}.
-
-A useful alias to use with the @code{fc} command is @code{r='fc -s'}, so
-that typing @samp{r cc} runs the last command beginning with @code{cc}
-and typing @samp{r} re-executes the last command (@pxref{Aliases}).
-
-@item history
-@btindex history
-@example
-history [@var{n}]
-history -c
-history -d @var{offset}
-history [-anrw] [@var{filename}]
-history -ps @var{arg}
-@end example
-
-With no options, display the history list with line numbers.
-Lines prefixed with a @samp{*} have been modified.
-An argument of @var{n} lists only the last @var{n} lines.
-Options, if supplied, have the following meanings:
-
-@table @code
-@item -c
-Clear the history list.  This may be combined
-with the other options to replace the history list completely.
-
-@item -d @var{offset}
-Delete the history entry at position @var{offset}.
-@var{offset} should be specified as it appears when the history is
-displayed.
-
-@item -a
-Append the new
-history lines (history lines entered since the beginning of the
-current Bash session) to the history file.
-
-@item -n
-Append the history lines not already read from the history file
-to the current history list.  These are lines appended to the history
-file since the beginning of the current Bash session.
-
-@item -r
-Read the current history file and append its contents to
-the history list.
-
-@item -w
-Write out the current history to the history file.
-
-@item -p
-Perform history substitution on the @var{arg}s and display the result
-on the standard output, without storing the results in the history list.
-
-@item -s
-The @var{arg}s are added to the end of
-the history list as a single entry.
-
-@end table
-
-When any of the @option{-w}, @option{-r}, @option{-a}, or @option{-n} options is
-used, if @var{filename}
-is given, then it is used as the history file.  If not, then
-the value of the @env{HISTFILE} variable is used.
-
-@end table
-@end ifset
-
-@node History Interaction
-@section History Expansion
-@cindex history expansion
-
-The History library provides a history expansion feature that is similar
-to the history expansion provided by @code{csh}.  This section
-describes the syntax used to manipulate the history information.
-
-History expansions introduce words from the history list into
-the input stream, making it easy to repeat commands, insert the
-arguments to a previous command into the current input line, or
-fix errors in previous commands quickly.
-
-History expansion takes place in two parts.  The first is to determine
-which line from the history list should be used during substitution.
-The second is to select portions of that line for inclusion into the
-current one.  The line selected from the history is called the
-@dfn{event}, and the portions of that line that are acted upon are
-called @dfn{words}.  Various @dfn{modifiers} are available to manipulate
-the selected words.  The line is broken into words in the same fashion
-that Bash does, so that several words
-surrounded by quotes are considered one word.
-History expansions are introduced by the appearance of the
-history expansion character, which is @samp{!} by default.
-@ifset BashFeatures
-Only @samp{\} and @samp{'} may be used to escape the history expansion
-character.
-@end ifset
-
-@ifset BashFeatures
-Several shell options settable with the @code{shopt}
-builtin (@pxref{Bash Builtins}) may be used to tailor
-the behavior of history expansion.  If the
-@code{histverify} shell option is enabled, and Readline
-is being used, history substitutions are not immediately passed to
-the shell parser.
-Instead, the expanded line is reloaded into the Readline
-editing buffer for further modification.
-If Readline is being used, and the @code{histreedit}
-shell option is enabled, a failed history expansion will be
-reloaded into the Readline editing buffer for correction.
-The @option{-p} option to the @code{history} builtin command
-may be used to see what a history expansion will do before using it.
-The @option{-s} option to the @code{history} builtin may be used to
-add commands to the end of the history list without actually executing
-them, so that they are available for subsequent recall.
-This is most useful in conjunction with Readline.
-
-The shell allows control of the various characters used by the
-history expansion mechanism with the @code{histchars} variable.
-@end ifset
-
-@menu
-* Event Designators::	How to specify which history line to use.
-* Word Designators::	Specifying which words are of interest.
-* Modifiers::		Modifying the results of substitution.
-@end menu
-
-@node Event Designators
-@subsection Event Designators
-@cindex event designators
-
-An event designator is a reference to a command line entry in the
-history list.
-@cindex history events
-
-@table @asis
-
-@item @code{!}
-Start a history substitution, except when followed by a space, tab,
-the end of the line, @samp{=} or @samp{(}.
-
-@item @code{!@var{n}}
-Refer to command line @var{n}.
-
-@item @code{!-@var{n}}
-Refer to the command @var{n} lines back.
-
-@item @code{!!}
-Refer to the previous command.  This is a synonym for @samp{!-1}.
-
-@item @code{!@var{string}}
-Refer to the most recent command starting with @var{string}.
-
-@item @code{!?@var{string}[?]}
-Refer to the most recent command containing @var{string}.  The trailing
-@samp{?} may be omitted if the @var{string} is followed immediately by
-a newline.
-
-@item @code{^@var{string1}^@var{string2}^}
-Quick Substitution.  Repeat the last command, replacing @var{string1}
-with @var{string2}.  Equivalent to
-@code{!!:s/@var{string1}/@var{string2}/}.
-
-@item @code{!#}
-The entire command line typed so far.
-
-@end table
-
-@node Word Designators
-@subsection Word Designators
-
-Word designators are used to select desired words from the event.
-A @samp{:} separates the event specification from the word designator.  It
-may be omitted if the word designator begins with a @samp{^}, @samp{$},
-@samp{*}, @samp{-}, or @samp{%}.  Words are numbered from the beginning
-of the line, with the first word being denoted by 0 (zero).  Words are
-inserted into the current line separated by single spaces.
-
-@need 0.75
-For example,
-
-@table @code
-@item !!
-designates the preceding command.  When you type this, the preceding
-command is repeated in toto.
-
-@item !!:$
-designates the last argument of the preceding command.  This may be
-shortened to @code{!$}.
-
-@item !fi:2
-designates the second argument of the most recent command starting with
-the letters @code{fi}.
-@end table
-
-@need 0.75
-Here are the word designators:
- 
-@table @code
-
-@item 0 (zero)
-The @code{0}th word.  For many applications, this is the command word.
-
-@item @var{n}
-The @var{n}th word.
-
-@item ^
-The first argument; that is, word 1.
-
-@item $
-The last argument.
-
-@item %
-The word matched by the most recent @samp{?@var{string}?} search.
-
-@item @var{x}-@var{y}
-A range of words; @samp{-@var{y}} abbreviates @samp{0-@var{y}}.
-
-@item *
-All of the words, except the @code{0}th.  This is a synonym for @samp{1-$}.
-It is not an error to use @samp{*} if there is just one word in the event;
-the empty string is returned in that case.
-
-@item @var{x}*
-Abbreviates @samp{@var{x}-$}
-
-@item @var{x}-
-Abbreviates @samp{@var{x}-$} like @samp{@var{x}*}, but omits the last word.
-
-@end table
-
-If a word designator is supplied without an event specification, the
-previous command is used as the event.
-
-@node Modifiers
-@subsection Modifiers
-
-After the optional word designator, you can add a sequence of one or more
-of the following modifiers, each preceded by a @samp{:}.
-
-@table @code
-
-@item h
-Remove a trailing pathname component, leaving only the head.
-
-@item t
-Remove all leading  pathname  components, leaving the tail.
-
-@item r
-Remove a trailing suffix of the form @samp{.@var{suffix}}, leaving
-the basename.
-
-@item e
-Remove all but the trailing suffix.
-
-@item p
-Print the new command but do not execute it.
-
-@ifset BashFeatures
-@item q
-Quote the substituted words, escaping further substitutions.
-
-@item x
-Quote the substituted words as with @samp{q},
-but break into words at spaces, tabs, and newlines.
-@end ifset
-
-@item s/@var{old}/@var{new}/
-Substitute @var{new} for the first occurrence of @var{old} in the
-event line.  Any delimiter may be used in place of @samp{/}.
-The delimiter may be quoted in @var{old} and @var{new}
-with a single backslash.  If @samp{&} appears in @var{new},
-it is replaced by @var{old}.  A single backslash will quote
-the @samp{&}.  The final delimiter is optional if it is the last
-character on the input line.
-
-@item &
-Repeat the previous substitution.
-
-@item g
-Cause changes to be applied over the entire event line.  Used in
-conjunction with @samp{s}, as in @code{gs/@var{old}/@var{new}/},
-or with @samp{&}.
-
-@end table
diff --git a/readline/doc/manvers.texinfo b/readline/doc/manvers.texinfo
deleted file mode 100644
--- a/readline/doc/manvers.texinfo
+++ /dev/null
@@ -1,6 +0,0 @@
-@set EDITION 4.2
-@set VERSION 4.2
-@set UPDATED 2001 Apr 16
-@set UPDATE-MONTH Apr 2001
-
-@set LASTCHANGE Mon Apr 16 10:53:58 EDT 2001
diff --git a/readline/doc/readline.0 b/readline/doc/readline.0
deleted file mode 100644
--- a/readline/doc/readline.0
+++ /dev/null
@@ -1,1188 +0,0 @@
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-NNAAMMEE
-       readline - get a line from a user with editing
-
-SSYYNNOOPPSSIISS
-       ##iinncclluuddee <<ssttddiioo..hh>>
-       ##iinncclluuddee <<rreeaaddlliinnee//rreeaaddlliinnee..hh>>
-       ##iinncclluuddee <<rreeaaddlliinnee//hhiissttoorryy..hh>>
-
-       _c_h_a_r _*
-       rreeaaddlliinnee (_c_o_n_s_t _c_h_a_r _*_p_r_o_m_p_t);
-
-CCOOPPYYRRIIGGHHTT
-       Readline  is  Copyright (C) 1989-2001 by the Free Software
-       Foundation, Inc.
-
-DDEESSCCRRIIPPTTIIOONN
-       rreeaaddlliinnee will read a line from the terminal and return it,
-       using  pprroommpptt as a prompt.  If pprroommpptt is NNUULLLL or the empty
-       string, no prompt is issued.  The line returned  is  allo-
-       cated  with  _m_a_l_l_o_c(3);  the caller must free it when fin-
-       ished.  The line returned has the final  newline  removed,
-       so only the text of the line remains.
-
-       rreeaaddlliinnee  offers  editing  capabilities  while the user is
-       entering the line.  By default, the line editing  commands
-       are  similar  to  those of emacs.  A vi-style line editing
-       interface is also available.
-
-       This manual page describes only  the  most  basic  use  of
-       rreeaaddlliinnee.   Much  more functionality is available; see _T_h_e
-       _G_N_U _R_e_a_d_l_i_n_e _L_i_b_r_a_r_y and _T_h_e _G_N_U _H_i_s_t_o_r_y _L_i_b_r_a_r_y for addi-
-       tional information.
-
-RREETTUURRNN VVAALLUUEE
-       rreeaaddlliinnee  returns the text of the line read.  A blank line
-       returns the empty string.  If  EEOOFF  is  encountered  while
-       reading  a  line, and the line is empty, NNUULLLL is returned.
-       If an EEOOFF is read with a non-empty line, it is treated  as
-       a newline.
-
-NNOOTTAATTIIOONN
-       An  emacs-style  notation  is  used  to denote keystrokes.
-       Control keys are denoted by C-_k_e_y, e.g.,  C-n  means  Con-
-       trol-N.  Similarly, _m_e_t_a keys are denoted by M-_k_e_y, so M-x
-       means Meta-X.  (On keyboards without a _m_e_t_a key, M-_x means
-       ESC  _x,  i.e.,  press the Escape key then the _x key.  This
-       makes ESC the _m_e_t_a _p_r_e_f_i_x.  The  combination  M-C-_x  means
-       ESC-Control-_x,  or press the Escape key then hold the Con-
-       trol key while pressing the _x key.)
-
-       Readline commands may be given  numeric  _a_r_g_u_m_e_n_t_s,  which
-       normally act as a repeat count.  Sometimes, however, it is
-       the sign of the argument that is significant.   Passing  a
-       negative  argument  to  a command that acts in the forward
-
-
-
-GNU Readline 4.2            2001 Mar 5                          1
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-       direction (e.g., kkiillll--lliinnee) causes that command to act  in
-       a  backward direction.  Commands whose behavior with argu-
-       ments deviates from this are noted.
-
-       When a command is described  as  _k_i_l_l_i_n_g  text,  the  text
-       deleted  is saved for possible future retrieval (_y_a_n_k_i_n_g).
-       The killed text is saved  in  a  _k_i_l_l  _r_i_n_g.   Consecutive
-       kills  cause  the  text  to  be accumulated into one unit,
-       which can be yanked all at once.  Commands  which  do  not
-       kill text separate the chunks of text on the kill ring.
-
-IINNIITTIIAALLIIZZAATTIIOONN FFIILLEE
-       Readline  is customized by putting commands in an initial-
-       ization file (the _i_n_p_u_t_r_c file).  The name of this file is
-       taken  from the value of the IINNPPUUTTRRCC environment variable.
-       If that variable is  unset,  the  default  is  _~_/_._i_n_p_u_t_r_c.
-       When  a program which uses the readline library starts up,
-       the init file is read, and the key bindings and  variables
-       are set.  There are only a few basic constructs allowed in
-       the readline init file.  Blank lines are  ignored.   Lines
-       beginning with a ## are comments.  Lines beginning with a $$
-       indicate conditional constructs.  Other lines  denote  key
-       bindings  and  variable settings.  Each program using this
-       library may add its own commands and bindings.
-
-       For example, placing
-
-              M-Control-u: universal-argument
-       or
-              C-Meta-u: universal-argument
-
-       into the _i_n_p_u_t_r_c would make  M-C-u  execute  the  readline
-       command _u_n_i_v_e_r_s_a_l_-_a_r_g_u_m_e_n_t.
-
-       The  following  symbolic  character  names  are recognized
-       while processing key bindings: _D_E_L, _E_S_C, _E_S_C_A_P_E, _L_F_D, _N_E_W_-
-       _L_I_N_E, _R_E_T, _R_E_T_U_R_N, _R_U_B_O_U_T, _S_P_A_C_E, _S_P_C, and _T_A_B.
-
-       In  addition  to command names, readline allows keys to be
-       bound to a string that is inserted when the key is pressed
-       (a _m_a_c_r_o).
-
-
-   KKeeyy BBiinnddiinnggss
-       The  syntax  for  controlling  key bindings in the _i_n_p_u_t_r_c
-       file is simple.  All that is required is the name  of  the
-       command or the text of a macro and a key sequence to which
-       it should be bound. The name may be specified  in  one  of
-       two  ways:  as a symbolic key name, possibly with _M_e_t_a_- or
-       _C_o_n_t_r_o_l_- prefixes, or as a key sequence.
-
-       When using the form kkeeyynnaammee:_f_u_n_c_t_i_o_n_-_n_a_m_e or  _m_a_c_r_o,  _k_e_y_-
-       _n_a_m_e  is  the  name  of a key spelled out in English.  For
-       example:
-
-
-
-GNU Readline 4.2            2001 Mar 5                          2
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-              Control-u: universal-argument
-              Meta-Rubout: backward-kill-word
-              Control-o: "> output"
-
-       In the above example, _C_-_u is bound to the function uunniivveerr--
-       ssaall--aarrgguummeenntt,   _M_-_D_E_L  is  bound  to  the  function  bbaacckk--
-       wwaarrdd--kkiillll--wwoorrdd,  and  _C_-_o  is  bound  to  run  the   macro
-       expressed  on  the right hand side (that is, to insert the
-       text ``> output'' into the line).
-
-       In the second form, ""kkeeyysseeqq"":_f_u_n_c_t_i_o_n_-_n_a_m_e or _m_a_c_r_o,  kkeeyy--
-       sseeqq differs from kkeeyynnaammee above in that strings denoting an
-       entire key  sequence  may  be  specified  by  placing  the
-       sequence  within  double quotes.  Some GNU Emacs style key
-       escapes can be used, as in the following example, but  the
-       symbolic character names are not recognized.
-
-              "\C-u": universal-argument
-              "\C-x\C-r": re-read-init-file
-              "\e[11~": "Function Key 1"
-
-       In  this  example, _C_-_u is again bound to the function uunnii--
-       vveerrssaall--aarrgguummeenntt.   _C_-_x  _C_-_r  is  bound  to  the   function
-       rree--rreeaadd--iinniitt--ffiillee,  and _E_S_C _[ _1 _1 _~ is bound to insert the
-       text ``Function Key 1''.
-
-       The full set of GNU Emacs style escape sequences available
-       when specifying key sequences is
-              \\CC--    control prefix
-              \\MM--    meta prefix
-              \\ee     an escape character
-              \\\\     backslash
-              \\""     literal ", a double quote
-              \\''     literal ', a single quote
-
-       In  addition  to  the  GNU Emacs style escape sequences, a
-       second set of backslash escapes is available:
-              \\aa     alert (bell)
-              \\bb     backspace
-              \\dd     delete
-              \\ff     form feed
-              \\nn     newline
-              \\rr     carriage return
-              \\tt     horizontal tab
-              \\vv     vertical tab
-              \\_n_n_n   the character whose ASCII code is the  octal
-                     value _n_n_n (one to three digits)
-              \\xx_n_n_n  the  character  whose ASCII code is the hex-
-                     adecimal value _n_n_n (one to three digits)
-
-       When entering the text of a macro, single or double quotes
-       should  be  used to indicate a macro definition.  Unquoted
-       text is assumed to be a function name.  In the macro body,
-       the   backslash  escapes  described  above  are  expanded.
-
-
-
-GNU Readline 4.2            2001 Mar 5                          3
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-       Backslash will quote any  other  character  in  the  macro
-       text, including " and '.
-
-       BBaasshh  allows  the current readline key bindings to be dis-
-       played or modified with the  bbiinndd  builtin  command.   The
-       editing  mode  may  be  switched during interactive use by
-       using the --oo option to the  sseett  builtin  command.   Other
-       programs  using  this  library provide similar mechanisms.
-       The _i_n_p_u_t_r_c file may be edited and re-read  if  a  program
-       does  not provide any other means to incorporate new bind-
-       ings.
-
-   VVaarriiaabblleess
-       Readline has variables that can be used  to  further  cus-
-       tomize its behavior.  A variable may be set in the _i_n_p_u_t_r_c
-       file with a statement of the form
-
-              sseett _v_a_r_i_a_b_l_e_-_n_a_m_e _v_a_l_u_e
-
-       Except where noted, readline variables can take the values
-       OOnn  or  OOffff  (without  regard to case).  The variables and
-       their default values are:
-
-       bbeellll--ssttyyllee ((aauuddiibbllee))
-              Controls what happens when readline wants  to  ring
-              the  terminal bell.  If set to nnoonnee, readline never
-              rings the bell.  If set to vviissiibbllee, readline uses a
-              visible  bell if one is available.  If set to aauuddii--
-              bbllee, readline attempts to ring the terminal's bell.
-       ccoommmmeenntt--bbeeggiinn ((````##''''))
-              The  string  that  is  inserted in vvii mode when the
-              iinnsseerrtt--ccoommmmeenntt command is executed.   This  command
-              is  bound  to MM--## in emacs mode and to ## in vi com-
-              mand mode.
-       ccoommpplleettiioonn--iiggnnoorree--ccaassee ((OOffff))
-              If set to OOnn, readline performs  filename  matching
-              and completion in a case-insensitive fashion.
-       ccoommpplleettiioonn--qquueerryy--iitteemmss ((110000))
-              This  determines  when  the  user  is queried about
-              viewing the number of possible  completions  gener-
-              ated  by  the ppoossssiibbllee--ccoommpplleettiioonnss command.  It may
-              be set to any integer value greater than  or  equal
-              to  zero.  If the number of possible completions is
-              greater than or equal to the value  of  this  vari-
-              able, the user is asked whether or not he wishes to
-              view them; otherwise they are simply listed on  the
-              terminal.
-       ccoonnvveerrtt--mmeettaa ((OOnn))
-              If set to OOnn, readline will convert characters with
-              the eighth bit set to  an  ASCII  key  sequence  by
-              stripping  the  eighth bit and prefixing it with an
-              escape character (in effect, using  escape  as  the
-              _m_e_t_a _p_r_e_f_i_x).
-
-
-
-
-GNU Readline 4.2            2001 Mar 5                          4
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-       ddiissaabbllee--ccoommpplleettiioonn ((OOffff))
-              If  set  to  OOnn, readline will inhibit word comple-
-              tion.  Completion characters will be inserted  into
-              the line as if they had been mapped to sseellff--iinnsseerrtt.
-       eeddiittiinngg--mmooddee ((eemmaaccss))
-              Controls whether readline begins with a set of  key
-              bindings  similar to emacs or vi.  eeddiittiinngg--mmooddee can
-              be set to either eemmaaccss or vvii.
-       eennaabbllee--kkeeyyppaadd ((OOffff))
-              When set to OOnn, readline will  try  to  enable  the
-              application keypad when it is called.  Some systems
-              need this to enable the arrow keys.
-       eexxppaanndd--ttiillddee ((OOffff))
-              If set to oonn, tilde  expansion  is  performed  when
-              readline attempts word completion.
-       hhoorriizzoonnttaall--ssccrroollll--mmooddee ((OOffff))
-              When  set  to  OOnn, makes readline use a single line
-              for display, scrolling the input horizontally on  a
-              single  screen line when it becomes longer than the
-              screen width rather than wrapping to a new line.
-       iinnppuutt--mmeettaa ((OOffff))
-              If set to OOnn, readline will enable eight-bit  input
-              (that  is,  it will not clear the eighth bit in the
-              characters it reads), regardless of what the termi-
-              nal claims it can support.  The name mmeettaa--ffllaagg is a
-              synonym for this variable.
-       iisseeaarrcchh--tteerrmmiinnaattoorrss ((````CC--[[ CC--JJ''''))
-              The string of characters that should  terminate  an
-              incremental  search  without subsequently executing
-              the character as a command.  If this  variable  has
-              not  been given a value, the characters _E_S_C and _C_-_J
-              will terminate an incremental search.
-       kkeeyymmaapp ((eemmaaccss))
-              Set the current readline keymap.  The set of  legal
-              keymap  names is _e_m_a_c_s_, _e_m_a_c_s_-_s_t_a_n_d_a_r_d_, _e_m_a_c_s_-_m_e_t_a_,
-              _e_m_a_c_s_-_c_t_l_x_, _v_i_, _v_i_-_m_o_v_e_, _v_i_-_c_o_m_m_a_n_d, and _v_i_-_i_n_s_e_r_t.
-              _v_i is equivalent to _v_i_-_c_o_m_m_a_n_d; _e_m_a_c_s is equivalent
-              to _e_m_a_c_s_-_s_t_a_n_d_a_r_d.  The  default  value  is  _e_m_a_c_s.
-              The  value of eeddiittiinngg--mmooddee also affects the default
-              keymap.
-       mmaarrkk--ddiirreeccttoorriieess ((OOnn))
-              If set to OOnn,  completed  directory  names  have  a
-              slash appended.
-       mmaarrkk--mmooddiiffiieedd--lliinneess ((OOffff))
-              If set to OOnn, history lines that have been modified
-              are displayed with a preceding asterisk (**).
-       oouuttppuutt--mmeettaa ((OOffff))
-              If set to OOnn, readline will display characters with
-              the  eighth bit set directly rather than as a meta-
-              prefixed escape sequence.
-       pprriinntt--ccoommpplleettiioonnss--hhoorriizzoonnttaallllyy ((OOffff))
-              If set to OOnn,  readline  will  display  completions
-              with  matches  sorted  horizontally in alphabetical
-              order, rather than down the screen.
-
-
-
-GNU Readline 4.2            2001 Mar 5                          5
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-       sshhooww--aallll--iiff--aammbbiigguuoouuss ((OOffff))
-              This alters the default behavior of the  completion
-              functions.   If  set  to  oonn, words which have more
-              than one possible completion cause the  matches  to
-              be  listed immediately instead of ringing the bell.
-       vviissiibbllee--ssttaattss ((OOffff))
-              If set to OOnn, a character denoting a file's type as
-              reported  by  _s_t_a_t(2)  is  appended to the filename
-              when listing possible completions.
-
-   CCoonnddiittiioonnaall CCoonnssttrruuccttss
-       Readline implements a facility similar in  spirit  to  the
-       conditional  compilation  features  of  the C preprocessor
-       which allows key bindings and variable settings to be per-
-       formed  as  the  result  of  tests.  There are four parser
-       directives used.
-
-       $$iiff    The $$iiff construct allows bindings to be made  based
-              on  the  editing  mode, the terminal being used, or
-              the application using readline.  The  text  of  the
-              test  extends to the end of the line; no characters
-              are required to isolate it.
-
-              mmooddee   The mmooddee== form of the $$iiff directive is  used
-                     to  test  whether readline is in emacs or vi
-                     mode.  This may be used in conjunction  with
-                     the sseett kkeeyymmaapp command, for instance, to set
-                     bindings in the  _e_m_a_c_s_-_s_t_a_n_d_a_r_d  and  _e_m_a_c_s_-
-                     _c_t_l_x  keymaps  only  if readline is starting
-                     out in emacs mode.
-
-              tteerrmm   The tteerrmm== form may be used to include termi-
-                     nal-specific  key  bindings, perhaps to bind
-                     the key sequences output by  the  terminal's
-                     function  keys.   The word on the right side
-                     of the == is tested against the full name  of
-                     the terminal and the portion of the terminal
-                     name before the first --.  This allows _s_u_n to
-                     match both _s_u_n and _s_u_n_-_c_m_d, for instance.
-
-              aapppplliiccaattiioonn
-                     The aapppplliiccaattiioonn construct is used to include
-                     application-specific settings.  Each program
-                     using the readline library sets the _a_p_p_l_i_c_a_-
-                     _t_i_o_n _n_a_m_e, and an  initialization  file  can
-                     test  for a particular value.  This could be
-                     used to bind key sequences to functions use-
-                     ful  for  a specific program.  For instance,
-                     the following command adds  a  key  sequence
-                     that  quotes the current or previous word in
-                     Bash:
-
-                     $$iiff Bash
-                     # Quote the current or previous word
-
-
-
-GNU Readline 4.2            2001 Mar 5                          6
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-                     "\C-xq": "\eb\"\ef\""
-                     $$eennddiiff
-
-       $$eennddiiff This command, as seen in the previous example, ter-
-              minates an $$iiff command.
-
-       $$eellssee  Commands  in  this  branch of the $$iiff directive are
-              executed if the test fails.
-
-       $$iinncclluuddee
-              This directive takes a single filename as an  argu-
-              ment  and  reads  commands  and  bindings from that
-              file.  For example, the following  directive  would
-              read _/_e_t_c_/_i_n_p_u_t_r_c:
-
-              $$iinncclluuddee  _/_e_t_c_/_i_n_p_u_t_r_c
-
-SSEEAARRCCHHIINNGG
-       Readline  provides commands for searching through the com-
-       mand history for  lines  containing  a  specified  string.
-       There  are two search modes: _i_n_c_r_e_m_e_n_t_a_l and _n_o_n_-_i_n_c_r_e_m_e_n_-
-       _t_a_l.
-
-       Incremental searches begin before the  user  has  finished
-       typing the search string.  As each character of the search
-       string is typed, readline displays the next entry from the
-       history  matching the string typed so far.  An incremental
-       search requires only as many characters as needed to  find
-       the desired history entry.  To search backward in the his-
-       tory for  a  particular  string,  type  CC--rr.   Typing  CC--ss
-       searches forward through the history.  The characters pre-
-       sent in the value of the iisseeaarrcchh--tteerrmmiinnaattoorrss variable  are
-       used to terminate an incremental search.  If that variable
-       has not been assigned a value the _E_s_c_a_p_e and  CC--JJ  charac-
-       ters will terminate an incremental search.  CC--GG will abort
-       an incremental search and restore the original line.  When
-       the search is terminated, the history entry containing the
-       search string becomes the current line.
-
-       To find other matching entries in the history  list,  type
-       CC--ss  or  CC--rr as appropriate.  This will search backward or
-       forward in the history for  the  next  line  matching  the
-       search  string typed so far.  Any other key sequence bound
-       to a readline command will terminate the search  and  exe-
-       cute that command.  For instance, a newline will terminate
-       the search and accept the line, thereby executing the com-
-       mand  from the history list.  A movement command will ter-
-       minate the search, make the last line  found  the  current
-       line, and begin editing.
-
-       Non-incremental  searches  read  the  entire search string
-       before starting to search for matching history lines.  The
-       search  string  may be typed by the user or be part of the
-       contents of the current line.
-
-
-
-GNU Readline 4.2            2001 Mar 5                          7
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-EEDDIITTIINNGG CCOOMMMMAANNDDSS
-       The following is a list of the names of the  commands  and
-       the  default  key sequences to which they are bound.  Com-
-       mand  names  without  an  accompanying  key  sequence  are
-       unbound by default.
-
-       In the following descriptions, _p_o_i_n_t refers to the current
-       cursor position, and _m_a_r_k  refers  to  a  cursor  position
-       saved by the sseett--mmaarrkk command.  The text between the point
-       and mark is referred to as the _r_e_g_i_o_n.
-
-   CCoommmmaannddss ffoorr MMoovviinngg
-       bbeeggiinnnniinngg--ooff--lliinnee ((CC--aa))
-              Move to the start of the current line.
-       eenndd--ooff--lliinnee ((CC--ee))
-              Move to the end of the line.
-       ffoorrwwaarrdd--cchhaarr ((CC--ff))
-              Move forward a character.
-       bbaacckkwwaarrdd--cchhaarr ((CC--bb))
-              Move back a character.
-       ffoorrwwaarrdd--wwoorrdd ((MM--ff))
-              Move forward to the end of the  next  word.   Words
-              are  composed  of  alphanumeric characters (letters
-              and digits).
-       bbaacckkwwaarrdd--wwoorrdd ((MM--bb))
-              Move back to the start of the current  or  previous
-              word.   Words  are composed of alphanumeric charac-
-              ters (letters and digits).
-       cclleeaarr--ssccrreeeenn ((CC--ll))
-              Clear the screen leaving the current  line  at  the
-              top  of  the screen.  With an argument, refresh the
-              current line without clearing the screen.
-       rreeddrraaww--ccuurrrreenntt--lliinnee
-              Refresh the current line.
-
-   CCoommmmaannddss ffoorr MMaanniippuullaattiinngg tthhee HHiissttoorryy
-       aacccceepptt--lliinnee ((NNeewwlliinnee,, RReettuurrnn))
-              Accept the line regardless of where the cursor  is.
-              If  this  line is non-empty, it may be added to the
-              history list for future recall with  aadddd__hhiissttoorryy(()).
-              If the line is a modified history line, the history
-              line is restored to its original state.
-       pprreevviioouuss--hhiissttoorryy ((CC--pp))
-              Fetch the previous command from the  history  list,
-              moving back in the list.
-       nneexxtt--hhiissttoorryy ((CC--nn))
-              Fetch  the next command from the history list, mov-
-              ing forward in the list.
-       bbeeggiinnnniinngg--ooff--hhiissttoorryy ((MM--<<))
-              Move to the first line in the history.
-       eenndd--ooff--hhiissttoorryy ((MM-->>))
-              Move to the end of the  input  history,  i.e.,  the
-              line currently being entered.
-
-
-
-
-GNU Readline 4.2            2001 Mar 5                          8
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-       rreevveerrssee--sseeaarrcchh--hhiissttoorryy ((CC--rr))
-              Search  backward  starting  at the current line and
-              moving `up' through the history as necessary.  This
-              is an incremental search.
-       ffoorrwwaarrdd--sseeaarrcchh--hhiissttoorryy ((CC--ss))
-              Search  forward  starting  at  the current line and
-              moving `down' through  the  history  as  necessary.
-              This is an incremental search.
-       nnoonn--iinnccrreemmeennttaall--rreevveerrssee--sseeaarrcchh--hhiissttoorryy ((MM--pp))
-              Search backward through the history starting at the
-              current line using a non-incremental search  for  a
-              string supplied by the user.
-       nnoonn--iinnccrreemmeennttaall--ffoorrwwaarrdd--sseeaarrcchh--hhiissttoorryy ((MM--nn))
-              Search  forward  through  the  history using a non-
-              incremental search for a  string  supplied  by  the
-              user.
-       hhiissttoorryy--sseeaarrcchh--ffoorrwwaarrdd
-              Search  forward  through the history for the string
-              of characters between the start of the current line
-              and  the current cursor position (the _p_o_i_n_t).  This
-              is a non-incremental search.
-       hhiissttoorryy--sseeaarrcchh--bbaacckkwwaarrdd
-              Search backward through the history for the  string
-              of characters between the start of the current line
-              and the point.  This is a non-incremental search.
-       yyaannkk--nntthh--aarrgg ((MM--CC--yy))
-              Insert the first argument to the  previous  command
-              (usually  the  second word on the previous line) at
-              point.  With an argument _n,  insert  the  _nth  word
-              from  the previous command (the words in the previ-
-              ous command begin with word 0).  A  negative  argu-
-              ment  inserts the _nth word from the end of the pre-
-              vious command.
-       yyaannkk--llaasstt--aarrgg ((MM--..,, MM--__))
-              Insert the last argument to  the  previous  command
-              (the  last  word  of  the  previous history entry).
-              With an argument, behave exactly like yyaannkk--nntthh--aarrgg.
-              Successive calls to yyaannkk--llaasstt--aarrgg move back through
-              the history list, inserting the  last  argument  of
-              each line in turn.
-
-   CCoommmmaannddss ffoorr CChhaannggiinngg TTeexxtt
-       ddeelleettee--cchhaarr ((CC--dd))
-              Delete  the character at point.  If point is at the
-              beginning of the line, there are no  characters  in
-              the  line,  and  the  last  character typed was not
-              bound to ddeelleettee--cchhaarr, then return EEOOFF.
-       bbaacckkwwaarrdd--ddeelleettee--cchhaarr ((RRuubboouutt))
-              Delete the character behind the cursor.  When given
-              a  numeric  argument,  save the deleted text on the
-              kill ring.
-       ffoorrwwaarrdd--bbaacckkwwaarrdd--ddeelleettee--cchhaarr
-              Delete the character under the cursor,  unless  the
-              cursor is at the end of the line, in which case the
-
-
-
-GNU Readline 4.2            2001 Mar 5                          9
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-              character behind the cursor is deleted.
-       qquuootteedd--iinnsseerrtt ((CC--qq,, CC--vv))
-              Add the next character that you type  to  the  line
-              verbatim.   This  is  how to insert characters like
-              CC--qq, for example.
-       ttaabb--iinnsseerrtt ((MM--TTAABB))
-              Insert a tab character.
-       sseellff--iinnsseerrtt ((aa,, bb,, AA,, 11,, !!,, ......))
-              Insert the character typed.
-       ttrraannssppoossee--cchhaarrss ((CC--tt))
-              Drag the character before point  forward  over  the
-              character  at  point, moving point forward as well.
-              If point is at the  end  of  the  line,  then  this
-              transposes  the two characters before point.  Nega-
-              tive arguments have no effect.
-       ttrraannssppoossee--wwoorrddss ((MM--tt))
-              Drag the word before  point  past  the  word  after
-              point, moving point over that word as well.
-       uuppccaassee--wwoorrdd ((MM--uu))
-              Uppercase  the current (or following) word.  With a
-              negative argument, uppercase the previous word, but
-              do not move point.
-       ddoowwnnccaassee--wwoorrdd ((MM--ll))
-              Lowercase  the current (or following) word.  With a
-              negative argument, lowercase the previous word, but
-              do not move point.
-       ccaappiittaalliizzee--wwoorrdd ((MM--cc))
-              Capitalize the current (or following) word.  With a
-              negative argument, capitalize  the  previous  word,
-              but do not move point.
-
-   KKiilllliinngg aanndd YYaannkkiinngg
-       kkiillll--lliinnee ((CC--kk))
-              Kill the text from point to the end of the line.
-       bbaacckkwwaarrdd--kkiillll--lliinnee ((CC--xx RRuubboouutt))
-              Kill backward to the beginning of the line.
-       uunniixx--lliinnee--ddiissccaarrdd ((CC--uu))
-              Kill  backward  from  point to the beginning of the
-              line.  The killed text is saved on the kill-ring.
-       kkiillll--wwhhoollee--lliinnee
-              Kill all characters on the current line, no  matter
-              where point is.
-       kkiillll--wwoorrdd ((MM--dd))
-              Kill  from point the end of the current word, or if
-              between words, to the end of the next  word.   Word
-              boundaries  are  the  same  as  those  used by ffoorr--
-              wwaarrdd--wwoorrdd.
-       bbaacckkwwaarrdd--kkiillll--wwoorrdd ((MM--RRuubboouutt))
-              Kill the word behind point.   Word  boundaries  are
-              the same as those used by bbaacckkwwaarrdd--wwoorrdd.
-       uunniixx--wwoorrdd--rruubboouutt ((CC--ww))
-              Kill  the word behind point, using white space as a
-              word boundary.  The killed text  is  saved  on  the
-              kill-ring.
-
-
-
-GNU Readline 4.2            2001 Mar 5                         10
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-       ddeelleettee--hhoorriizzoonnttaall--ssppaaccee ((MM--\\))
-              Delete all spaces and tabs around point.
-       kkiillll--rreeggiioonn
-              Kill  the  text  between  the point and _m_a_r_k (saved
-              cursor position).  This text is referred to as  the
-              _r_e_g_i_o_n.
-       ccooppyy--rreeggiioonn--aass--kkiillll
-              Copy the text in the region to the kill buffer.
-       ccooppyy--bbaacckkwwaarrdd--wwoorrdd
-              Copy the word before point to the kill buffer.  The
-              word boundaries are the same as bbaacckkwwaarrdd--wwoorrdd.
-       ccooppyy--ffoorrwwaarrdd--wwoorrdd
-              Copy the word following point to the  kill  buffer.
-              The word boundaries are the same as ffoorrwwaarrdd--wwoorrdd.
-       yyaannkk ((CC--yy))
-              Yank  the  top  of the kill ring into the buffer at
-              point.
-       yyaannkk--ppoopp ((MM--yy))
-              Rotate the kill ring, and yank the new  top.   Only
-              works following yyaannkk or yyaannkk--ppoopp.
-
-   NNuummeerriicc AArrgguummeennttss
-       ddiiggiitt--aarrgguummeenntt ((MM--00,, MM--11,, ......,, MM----))
-              Add  this  digit to the argument already accumulat-
-              ing, or start a new argument.  M-- starts  a  nega-
-              tive argument.
-       uunniivveerrssaall--aarrgguummeenntt
-              This  is  another  way  to specify an argument.  If
-              this command is followed by  one  or  more  digits,
-              optionally  with a leading minus sign, those digits
-              define the argument.  If the command is followed by
-              digits, executing uunniivveerrssaall--aarrgguummeenntt again ends the
-              numeric argument, but is otherwise ignored.   As  a
-              special  case,  if this command is immediately fol-
-              lowed by a character that is  neither  a  digit  or
-              minus sign, the argument count for the next command
-              is multiplied by four.  The argument count is  ini-
-              tially  one,  so  executing this function the first
-              time makes the argument count four, a  second  time
-              makes the argument count sixteen, and so on.
-
-   CCoommpplleettiinngg
-       ccoommpplleettee ((TTAABB))
-              Attempt  to  perform  completion on the text before
-              point.  The actual completion performed is applica-
-              tion-specific.   BBaasshh,  for instance, attempts com-
-              pletion treating the text as  a  variable  (if  the
-              text  begins  with $$), username (if the text begins
-              with ~~), hostname (if the text begins with  @@),  or
-              command  (including aliases and functions) in turn.
-              If none of these produces a match, filename comple-
-              tion  is attempted.  GGddbb, on the other hand, allows
-              completion of program functions and variables,  and
-              only  attempts  filename  completion  under certain
-
-
-
-GNU Readline 4.2            2001 Mar 5                         11
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-              circumstances.
-       ppoossssiibbllee--ccoommpplleettiioonnss ((MM--??))
-              List the possible completions of  the  text  before
-              point.
-       iinnsseerrtt--ccoommpplleettiioonnss ((MM--**))
-              Insert  all  completions  of  the text before point
-              that would have been generated by  ppoossssiibbllee--ccoommppllee--
-              ttiioonnss.
-       mmeennuu--ccoommpplleettee
-              Similar  to  ccoommpplleettee,  but replaces the word to be
-              completed with a single match from the list of pos-
-              sible completions.  Repeated execution of mmeennuu--ccoomm--
-              pplleettee steps through the list  of  possible  comple-
-              tions, inserting each match in turn.  At the end of
-              the list of completions, the bell is rung  (subject
-              to  the  setting  of  Bbell-style)) aanndd tthhee oorriiggiinnaall
-              tteexxtt iiss rreessttoorreedd..  AAnn aarrgguummeenntt ooff _n mmoovveess  _n  ppoossii--
-              ttiioonnss  ffoorrwwaarrdd  iinn  tthhee lliisstt ooff mmaattcchheess;; aa nneeggaattiivvee
-              aarrgguummeenntt mmaayy bbee uusseedd ttoo mmoovvee bbaacckkwwaarrdd  tthhrroouugghh  tthhee
-              lliisstt..  TThhiiss ccoommmmaanndd iiss iinntteennddeedd ttoo bbee bboouunndd ttoo TTAABB,,
-              bbuutt iiss uunnbboouunndd bbyy ddeeffaauulltt..
-       ddeelleettee--cchhaarr--oorr--lliisstt
-              Deletes the character under the cursor  if  not  at
-              the  beginning  or  end  of  the line (like ddeelleettee--
-              cchhaarr).  If at the end of the line, behaves  identi-
-              cally to ppoossssiibbllee--ccoommpplleettiioonnss.
-
-   KKeeyybbooaarrdd MMaaccrrooss
-       ssttaarrtt--kkbbdd--mmaaccrroo ((CC--xx (())
-              Begin  saving the characters typed into the current
-              keyboard macro.
-       eenndd--kkbbdd--mmaaccrroo ((CC--xx ))))
-              Stop saving the characters typed into  the  current
-              keyboard macro and store the definition.
-       ccaallll--llaasstt--kkbbdd--mmaaccrroo ((CC--xx ee))
-              Re-execute the last keyboard macro defined, by mak-
-              ing the characters in the macro appear as if  typed
-              at the keyboard.
-
-   MMiisscceellllaanneeoouuss
-       rree--rreeaadd--iinniitt--ffiillee ((CC--xx CC--rr))
-              Read  in  the  contents  of  the  _i_n_p_u_t_r_c file, and
-              incorporate any bindings  or  variable  assignments
-              found there.
-       aabboorrtt ((CC--gg))
-              Abort the current editing command and ring the ter-
-              minal's   bell   (subject   to   the   setting   of
-              bbeellll--ssttyyllee).
-       ddoo--uuppppeerrccaassee--vveerrssiioonn ((MM--aa,, MM--bb,, MM--_x,, ......))
-              If  the  metafied character _x is lowercase, run the
-              command that is bound to the  corresponding  upper-
-              case character.
-       pprreeffiixx--mmeettaa ((EESSCC))
-              Metafy   the   next  character  typed.   EESSCC  ff  is
-
-
-
-GNU Readline 4.2            2001 Mar 5                         12
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-              equivalent to MMeettaa--ff.
-       uunnddoo ((CC--__,, CC--xx CC--uu))
-              Incremental undo, separately  remembered  for  each
-              line.
-       rreevveerrtt--lliinnee ((MM--rr))
-              Undo  all  changes made to this line.  This is like
-              executing the uunnddoo command enough times  to  return
-              the line to its initial state.
-       ttiillddee--eexxppaanndd ((MM--&&))
-              Perform tilde expansion on the current word.
-       sseett--mmaarrkk ((CC--@@,, MM--<<ssppaaccee>>))
-              Set  the  mark to the point.  If a numeric argument
-              is supplied, the mark is set to that position.
-       eexxcchhaannggee--ppooiinntt--aanndd--mmaarrkk ((CC--xx CC--xx))
-              Swap the point with the mark.  The  current  cursor
-              position  is set to the saved position, and the old
-              cursor position is saved as the mark.
-       cchhaarraacctteerr--sseeaarrcchh ((CC--]]))
-              A character is read and point is moved to the  next
-              occurrence  of  that  character.   A negative count
-              searches for previous occurrences.
-       cchhaarraacctteerr--sseeaarrcchh--bbaacckkwwaarrdd ((MM--CC--]]))
-              A character is read and point is moved to the  pre-
-              vious  occurrence  of  that  character.  A negative
-              count searches for subsequent occurrences.
-       iinnsseerrtt--ccoommmmeenntt ((MM--##))
-              The value of the readline ccoommmmeenntt--bbeeggiinn variable is
-              inserted  at the beginning of the current line, and
-              the line is accepted  as  if  a  newline  had  been
-              typed.   The  default  value of ccoommmmeenntt--bbeeggiinn makes
-              the current line a shell comment.
-       dduummpp--ffuunnccttiioonnss
-              Print all of the functions and their  key  bindings
-              to  the readline output stream.  If a numeric argu-
-              ment is supplied, the output is formatted in such a
-              way that it can be made part of an _i_n_p_u_t_r_c file.
-       dduummpp--vvaarriiaabblleess
-              Print  all of the settable variables and their val-
-              ues to the readline output stream.   If  a  numeric
-              argument  is  supplied,  the output is formatted in
-              such a way that it can be made part of  an  _i_n_p_u_t_r_c
-              file.
-       dduummpp--mmaaccrrooss
-              Print  all  of  the readline key sequences bound to
-              macros and the strings they ouput.   If  a  numeric
-              argument  is  supplied,  the output is formatted in
-              such a way that it can be made part of  an  _i_n_p_u_t_r_c
-              file.
-       eemmaaccss--eeddiittiinngg--mmooddee ((CC--ee))
-              When  in  vvii  editing mode, this causes a switch to
-              eemmaaccss editing mode.
-       vvii--eeddiittiinngg--mmooddee ((MM--CC--jj))
-              When in eemmaaccss editing mode, this causes a switch to
-              vvii editing mode.
-
-
-
-GNU Readline 4.2            2001 Mar 5                         13
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-DDEEFFAAUULLTT KKEEYY BBIINNDDIINNGGSS
-       The  following is a list of the default emacs and vi bind-
-       ings.  Characters with the eighth bit set are  written  as
-       M-<character>, and are referred to as _m_e_t_a_f_i_e_d characters.
-       The printable ASCII characters not mentioned in  the  list
-       of  emacs  standard  bindings are bound to the sseellff--iinnsseerrtt
-       function, which just inserts the given character into  the
-       input  line.   In  vi  insertion  mode, all characters not
-       specifically mentioned are bound to sseellff--iinnsseerrtt.   Charac-
-       ters  assigned to signal generation by _s_t_t_y(1) or the ter-
-       minal driver, such as C-Z or C-C,  retain  that  function.
-       Upper  and lower case metafied characters are bound to the
-       same function in the emacs mode meta keymap.  The  remain-
-       ing  characters are unbound, which causes readline to ring
-       the bell (subject to the setting of the  bbeellll--ssttyyllee  vari-
-       able).
-
-   EEmmaaccss MMooddee
-             Emacs Standard bindings
-
-             "C-@"  set-mark
-             "C-A"  beginning-of-line
-             "C-B"  backward-char
-             "C-D"  delete-char
-             "C-E"  end-of-line
-             "C-F"  forward-char
-             "C-G"  abort
-             "C-H"  backward-delete-char
-             "C-I"  complete
-             "C-J"  accept-line
-             "C-K"  kill-line
-             "C-L"  clear-screen
-             "C-M"  accept-line
-             "C-N"  next-history
-             "C-P"  previous-history
-             "C-Q"  quoted-insert
-             "C-R"  reverse-search-history
-             "C-S"  forward-search-history
-             "C-T"  transpose-chars
-             "C-U"  unix-line-discard
-             "C-V"  quoted-insert
-             "C-W"  unix-word-rubout
-             "C-Y"  yank
-             "C-]"  character-search
-             "C-_"  undo
-             " " to "/"  self-insert
-             "0"  to "9"  self-insert
-             ":"  to "~"  self-insert
-             "C-?"  backward-delete-char
-
-             Emacs Meta bindings
-
-             "M-C-G"  abort
-             "M-C-H"  backward-kill-word
-
-
-
-GNU Readline 4.2            2001 Mar 5                         14
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-             "M-C-I"  tab-insert
-             "M-C-J"  vi-editing-mode
-             "M-C-M"  vi-editing-mode
-             "M-C-R"  revert-line
-             "M-C-Y"  yank-nth-arg
-             "M-C-["  complete
-             "M-C-]"  character-search-backward
-             "M-space"  set-mark
-             "M-#"  insert-comment
-             "M-&"  tilde-expand
-             "M-*"  insert-completions
-             "M--"  digit-argument
-             "M-."  yank-last-arg
-             "M-0"  digit-argument
-             "M-1"  digit-argument
-             "M-2"  digit-argument
-             "M-3"  digit-argument
-             "M-4"  digit-argument
-             "M-5"  digit-argument
-             "M-6"  digit-argument
-             "M-7"  digit-argument
-             "M-8"  digit-argument
-             "M-9"  digit-argument
-             "M-<"  beginning-of-history
-             "M-="  possible-completions
-             "M->"  end-of-history
-             "M-?"  possible-completions
-             "M-B"  backward-word
-             "M-C"  capitalize-word
-             "M-D"  kill-word
-             "M-F"  forward-word
-             "M-L"  downcase-word
-             "M-N"  non-incremental-forward-search-history
-             "M-P"  non-incremental-reverse-search-history
-             "M-R"  revert-line
-             "M-T"  transpose-words
-             "M-U"  upcase-word
-             "M-Y"  yank-pop
-             "M-\"  delete-horizontal-space
-             "M-~"  tilde-expand
-             "M-C-?"  backward-kill-word
-             "M-_"  yank-last-arg
-
-             Emacs Control-X bindings
-
-             "C-XC-G"  abort
-             "C-XC-R"  re-read-init-file
-             "C-XC-U"  undo
-             "C-XC-X"  exchange-point-and-mark
-             "C-X("  start-kbd-macro
-             "C-X)"  end-kbd-macro
-             "C-XE"  call-last-kbd-macro
-             "C-XC-?"  backward-kill-line
-
-
-
-
-GNU Readline 4.2            2001 Mar 5                         15
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-   VVII MMooddee bbiinnddiinnggss
-             VI Insert Mode functions
-
-             "C-D"  vi-eof-maybe
-             "C-H"  backward-delete-char
-             "C-I"  complete
-             "C-J"  accept-line
-             "C-M"  accept-line
-             "C-R"  reverse-search-history
-             "C-S"  forward-search-history
-             "C-T"  transpose-chars
-             "C-U"  unix-line-discard
-             "C-V"  quoted-insert
-             "C-W"  unix-word-rubout
-             "C-Y"  yank
-             "C-["  vi-movement-mode
-             "C-_"  undo
-             " " to "~"  self-insert
-             "C-?"  backward-delete-char
-
-             VI Command Mode functions
-
-             "C-D"  vi-eof-maybe
-             "C-E"  emacs-editing-mode
-             "C-G"  abort
-             "C-H"  backward-char
-             "C-J"  accept-line
-             "C-K"  kill-line
-             "C-L"  clear-screen
-             "C-M"  accept-line
-             "C-N"  next-history
-             "C-P"  previous-history
-             "C-Q"  quoted-insert
-             "C-R"  reverse-search-history
-             "C-S"  forward-search-history
-             "C-T"  transpose-chars
-             "C-U"  unix-line-discard
-             "C-V"  quoted-insert
-             "C-W"  unix-word-rubout
-             "C-Y"  yank
-             "C-_"  vi-undo
-             " "  forward-char
-             "#"  insert-comment
-             "$"  end-of-line
-             "%"  vi-match
-             "&"  vi-tilde-expand
-             "*"  vi-complete
-             "+"  next-history
-             ","  vi-char-search
-             "-"  previous-history
-             "."  vi-redo
-             "/"  vi-search
-             "0"  beginning-of-line
-             "1" to "9"  vi-arg-digit
-
-
-
-GNU Readline 4.2            2001 Mar 5                         16
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-             ";"  vi-char-search
-             "="  vi-complete
-             "?"  vi-search
-             "A"  vi-append-eol
-             "B"  vi-prev-word
-             "C"  vi-change-to
-             "D"  vi-delete-to
-             "E"  vi-end-word
-             "F"  vi-char-search
-             "G"  vi-fetch-history
-             "I"  vi-insert-beg
-             "N"  vi-search-again
-             "P"  vi-put
-             "R"  vi-replace
-             "S"  vi-subst
-             "T"  vi-char-search
-             "U"  revert-line
-             "W"  vi-next-word
-             "X"  backward-delete-char
-             "Y"  vi-yank-to
-             "\"  vi-complete
-             "^"  vi-first-print
-             "_"  vi-yank-arg
-             "`"  vi-goto-mark
-             "a"  vi-append-mode
-             "b"  vi-prev-word
-             "c"  vi-change-to
-             "d"  vi-delete-to
-             "e"  vi-end-word
-             "f"  vi-char-search
-             "h"  backward-char
-             "i"  vi-insertion-mode
-             "j"  next-history
-             "k"  prev-history
-             "l"  forward-char
-             "m"  vi-set-mark
-             "n"  vi-search-again
-             "p"  vi-put
-             "r"  vi-change-char
-             "s"  vi-subst
-             "t"  vi-char-search
-             "u"  vi-undo
-             "w"  vi-next-word
-             "x"  vi-delete
-             "y"  vi-yank-to
-             "|"  vi-column
-             "~"  vi-change-case
-
-SSEEEE AALLSSOO
-       _T_h_e _G_n_u _R_e_a_d_l_i_n_e _L_i_b_r_a_r_y, Brian Fox and Chet Ramey
-       _T_h_e _G_n_u _H_i_s_t_o_r_y _L_i_b_r_a_r_y, Brian Fox and Chet Ramey
-       _b_a_s_h(1)
-
-
-
-
-
-GNU Readline 4.2            2001 Mar 5                         17
-
-
-
-
-
-READLINE(3)                                           READLINE(3)
-
-
-FFIILLEESS
-       _~_/_._i_n_p_u_t_r_c
-              Individual rreeaaddlliinnee initialization file
-
-AAUUTTHHOORRSS
-       Brian Fox, Free Software Foundation
-       bfox@gnu.org
-
-       Chet Ramey, Case Western Reserve University
-       chet@ins.CWRU.Edu
-
-BBUUGG RREEPPOORRTTSS
-       If  you find a bug in rreeaaddlliinnee,, you should report it.  But
-       first, you should make sure that it really is a  bug,  and
-       that  it  appears  in  the  latest version of the rreeaaddlliinnee
-       library that you have.
-
-       Once you have determined that a bug actually exists,  mail
-       a  bug report to _b_u_g_-_r_e_a_d_l_i_n_e@_g_n_u_._o_r_g.  If you have a fix,
-       you are welcome to mail that  as  well!   Suggestions  and
-       `philosophical'  bug  reports  may  be mailed to _b_u_g_-_r_e_a_d_-
-       _l_i_n_e@_g_n_u_._o_r_g   or   posted   to   the   Usenet   newsgroup
-       ggnnuu..bbaasshh..bbuugg.
-
-       Comments  and  bug  reports  concerning  this  manual page
-       should be directed to _c_h_e_t_@_i_n_s_._C_W_R_U_._E_d_u.
-
-BBUUGGSS
-       It's too big and too slow.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-GNU Readline 4.2            2001 Mar 5                         18
-
-
diff --git a/readline/doc/readline.3 b/readline/doc/readline.3
deleted file mode 100644
--- a/readline/doc/readline.3
+++ /dev/null
@@ -1,1231 +0,0 @@
-.\"
-.\" MAN PAGE COMMENTS to
-.\"
-.\"	Chet Ramey
-.\"	Information Network Services
-.\"	Case Western Reserve University
-.\"	chet@ins.CWRU.Edu
-.\"
-.\"	Last Change: Mon Mar  5 09:58:38 EST 2001
-.\"
-.TH READLINE 3 "2001 Mar 5" "GNU Readline 4.2"
-.\"
-.\" File Name macro.  This used to be `.PN', for Path Name,
-.\" but Sun doesn't seem to like that very much.
-.\"
-.de FN
-\fI\|\\$1\|\fP
-..
-.SH NAME
-readline \- get a line from a user with editing
-.SH SYNOPSIS
-.LP
-.nf
-.ft B
-#include <stdio.h>
-#include <readline/readline.h>
-#include <readline/history.h>
-.ft
-.fi
-.LP
-.nf
-\fIchar *\fP
-.br
-\fBreadline\fP (\fIconst char *prompt\fP);
-.fi
-.SH COPYRIGHT
-.if n Readline is Copyright (C) 1989\-2001 by the Free Software Foundation, Inc.
-.if t Readline is Copyright \(co 1989\-2001 by the Free Software Foundation, Inc.
-.SH DESCRIPTION
-.LP
-.B readline
-will read a line from the terminal
-and return it, using
-.B prompt
-as a prompt.  If 
-.B prompt
-is \fBNULL\fP or the empty string, no prompt is issued.
-The line returned is allocated with
-.IR malloc (3);
-the caller must free it when finished.  The line returned
-has the final newline removed, so only the text of the line
-remains.
-.LP
-.B readline
-offers editing capabilities while the user is entering the
-line.
-By default, the line editing commands
-are similar to those of emacs.
-A vi\-style line editing interface is also available.
-.LP
-This manual page describes only the most basic use of \fBreadline\fP.
-Much more functionality is available; see
-\fIThe GNU Readline Library\fP and \fIThe GNU History Library\fP
-for additional information.
-.SH RETURN VALUE
-.LP
-.B readline
-returns the text of the line read.  A blank line
-returns the empty string.  If
-.B EOF
-is encountered while reading a line, and the line is empty,
-.B NULL
-is returned.  If an
-.B EOF
-is read with a non\-empty line, it is
-treated as a newline.
-.SH NOTATION
-.LP
-An emacs-style notation is used to denote
-keystrokes.  Control keys are denoted by C\-\fIkey\fR, e.g., C\-n
-means Control\-N.  Similarly, 
-.I meta
-keys are denoted by M\-\fIkey\fR, so M\-x means Meta\-X.  (On keyboards
-without a 
-.I meta
-key, M\-\fIx\fP means ESC \fIx\fP, i.e., press the Escape key
-then the
-.I x
-key.  This makes ESC the \fImeta prefix\fP.
-The combination M\-C\-\fIx\fP means ESC\-Control\-\fIx\fP,
-or press the Escape key
-then hold the Control key while pressing the
-.I x
-key.)
-.PP
-Readline commands may be given numeric
-.IR arguments ,
-which normally act as a repeat count.  Sometimes, however, it is the
-sign of the argument that is significant.  Passing a negative argument
-to a command that acts in the forward direction (e.g., \fBkill\-line\fP)
-causes that command to act in a backward direction.  Commands whose
-behavior with arguments deviates from this are noted.
-.PP
-When a command is described as \fIkilling\fP text, the text
-deleted is saved for possible future retrieval
-(\fIyanking\fP).  The killed text is saved in a
-\fIkill ring\fP.  Consecutive kills cause the text to be
-accumulated into one unit, which can be yanked all at once. 
-Commands which do not kill text separate the chunks of text
-on the kill ring.
-.SH INITIALIZATION FILE
-.LP
-Readline is customized by putting commands in an initialization
-file (the \fIinputrc\fP file).
-The name of this file is taken from the value of the
-.B INPUTRC
-environment variable.  If that variable is unset, the default is
-.IR ~/.inputrc .
-When a program which uses the readline library starts up, the
-init file is read, and the key bindings and variables are set.
-There are only a few basic constructs allowed in the
-readline init file.  Blank lines are ignored.
-Lines beginning with a \fB#\fP are comments.
-Lines beginning with a \fB$\fP indicate conditional constructs.
-Other lines denote key bindings and variable settings.
-Each program using this library may add its own commands
-and bindings.
-.PP
-For example, placing
-.RS
-.PP
-M\-Control\-u: universal\-argument
-.RE
-or
-.RS
-C\-Meta\-u: universal\-argument
-.RE
-.sp
-into the 
-.I inputrc
-would make M\-C\-u execute the readline command
-.IR universal\-argument .
-.PP
-The following symbolic character names are recognized while
-processing key bindings:
-.IR DEL ,
-.IR ESC ,
-.IR ESCAPE ,
-.IR LFD ,
-.IR NEWLINE ,
-.IR RET ,
-.IR RETURN ,
-.IR RUBOUT ,
-.IR SPACE ,
-.IR SPC ,
-and
-.IR TAB .
-.PP
-In addition to command names, readline allows keys to be bound
-to a string that is inserted when the key is pressed (a \fImacro\fP).
-.PP
-.SS Key Bindings
-.PP
-The syntax for controlling key bindings in the
-.I inputrc
-file is simple.  All that is required is the name of the
-command or the text of a macro and a key sequence to which
-it should be bound. The name may be specified in one of two ways:
-as a symbolic key name, possibly with \fIMeta\-\fP or \fIControl\-\fP
-prefixes, or as a key sequence.
-.PP
-When using the form \fBkeyname\fP:\^\fIfunction-name\fP or \fImacro\fP,
-.I keyname
-is the name of a key spelled out in English.  For example:
-.sp
-.RS
-Control\-u: universal\-argument
-.br
-Meta\-Rubout: backward\-kill\-word
-.br
-Control\-o: "> output"
-.RE
-.LP
-In the above example,
-.I C\-u
-is bound to the function
-.BR universal\-argument ,
-.I M-DEL
-is bound to the function
-.BR backward\-kill\-word ,
-and
-.I C\-o
-is bound to run the macro
-expressed on the right hand side (that is, to insert the text
-.if t \f(CW> output\fP
-.if n ``> output''
-into the line).
-.PP
-In the second form, \fB"keyseq"\fP:\^\fIfunction\-name\fP or \fImacro\fP,
-.B keyseq
-differs from
-.B keyname
-above in that strings denoting
-an entire key sequence may be specified by placing the sequence
-within double quotes.  Some GNU Emacs style key escapes can be
-used, as in the following example, but the symbolic character names
-are not recognized.
-.sp
-.RS
-"\eC\-u": universal\-argument
-.br
-"\eC\-x\eC\-r": re\-read\-init\-file
-.br
-"\ee[11~": "Function Key 1"
-.RE
-.PP
-In this example,
-.I C-u
-is again bound to the function
-.BR universal\-argument .
-.I "C-x C-r"
-is bound to the function
-.BR re\-read\-init\-file ,
-and 
-.I "ESC [ 1 1 ~"
-is bound to insert the text
-.if t \f(CWFunction Key 1\fP.
-.if n ``Function Key 1''.
-.PP
-The full set of GNU Emacs style escape sequences available when specifying
-key sequences is
-.RS
-.PD 0
-.TP
-.B \eC\-
-control prefix
-.TP
-.B \eM\-
-meta prefix
-.TP
-.B \ee
-an escape character
-.TP
-.B \e\e
-backslash
-.TP
-.B \e"
-literal ", a double quote
-.TP
-.B \e'
-literal ', a single quote
-.RE
-.PD
-.PP
-In addition to the GNU Emacs style escape sequences, a second
-set of backslash escapes is available:
-.RS
-.PD 0
-.TP
-.B \ea
-alert (bell)
-.TP
-.B \eb
-backspace
-.TP
-.B \ed
-delete
-.TP
-.B \ef
-form feed
-.TP
-.B \en
-newline
-.TP
-.B \er
-carriage return
-.TP
-.B \et
-horizontal tab
-.TP
-.B \ev
-vertical tab
-.TP
-.B \e\fInnn\fP
-the character whose ASCII code is the octal value \fInnn\fP
-(one to three digits)
-.TP
-.B \ex\fInnn\fP
-the character whose ASCII code is the hexadecimal value \fInnn\fP
-(one to three digits)
-.RE
-.PD
-.PP
-When entering the text of a macro, single or double quotes should
-be used to indicate a macro definition.  Unquoted text
-is assumed to be a function name.
-In the macro body, the backslash escapes described above are expanded.
-Backslash will quote any other character in the macro text,
-including " and '.
-.PP
-.B Bash
-allows the current readline key bindings to be displayed or modified
-with the
-.B bind
-builtin command.  The editing mode may be switched during interactive
-use by using the
-.B \-o
-option to the
-.B set
-builtin command.  Other programs using this library provide
-similar mechanisms.  The
-.I inputrc
-file may be edited and re-read if a program does not provide
-any other means to incorporate new bindings.
-.SS Variables
-.PP
-Readline has variables that can be used to further customize its
-behavior.  A variable may be set in the
-.I inputrc
-file with a statement of the form
-.RS
-.PP
-\fBset\fP \fIvariable\-name\fP \fIvalue\fP
-.RE
-.PP
-Except where noted, readline variables can take the values
-.B On
-or
-.B Off
-(without regard to case).
-The variables and their default values are:
-.PP
-.PD 0
-.TP
-.B bell\-style (audible)
-Controls what happens when readline wants to ring the terminal bell.
-If set to \fBnone\fP, readline never rings the bell.  If set to
-\fBvisible\fP, readline uses a visible bell if one is available.
-If set to \fBaudible\fP, readline attempts to ring the terminal's bell.
-.TP
-.B comment\-begin (``#'')
-The string that is inserted in \fBvi\fP mode when the
-.B insert\-comment
-command is executed.
-This command is bound to
-.B M\-#
-in emacs mode and to
-.B #
-in vi command mode.
-.TP 
-.B completion\-ignore\-case (Off)
-If set to \fBOn\fP, readline performs filename matching and completion
-in a case\-insensitive fashion.
-.TP
-.B completion\-query\-items (100)
-This determines when the user is queried about viewing
-the number of possible completions
-generated by the \fBpossible\-completions\fP command.
-It may be set to any integer value greater than or equal to
-zero.  If the number of possible completions is greater than
-or equal to the value of this variable, the user is asked whether
-or not he wishes to view them; otherwise they are simply listed
-on the terminal.
-.TP
-.B convert\-meta (On)
-If set to \fBOn\fP, readline will convert characters with the
-eighth bit set to an ASCII key sequence
-by stripping the eighth bit and prefixing it with an
-escape character (in effect, using escape as the \fImeta prefix\fP).
-.TP
-.B disable\-completion (Off)
-If set to \fBOn\fP, readline will inhibit word completion.  Completion 
-characters will be inserted into the line as if they had been
-mapped to \fBself-insert\fP.
-.TP
-.B editing\-mode (emacs)
-Controls whether readline begins with a set of key bindings similar
-to emacs or vi.
-.B editing\-mode
-can be set to either
-.B emacs
-or
-.BR vi .
-.TP
-.B enable\-keypad (Off)
-When set to \fBOn\fP, readline will try to enable the application
-keypad when it is called.  Some systems need this to enable the
-arrow keys.
-.TP
-.B expand\-tilde (Off)
-If set to \fBon\fP, tilde expansion is performed when readline
-attempts word completion.
-.TP
-.B horizontal\-scroll\-mode (Off)
-When set to \fBOn\fP, makes readline use a single line for display,
-scrolling the input horizontally on a single screen line when it
-becomes longer than the screen width rather than wrapping to a new line.
-.TP
-.B input\-meta (Off)
-If set to \fBOn\fP, readline will enable eight-bit input (that is,
-it will not clear the eighth bit in the characters it reads),
-regardless of what the terminal claims it can support.  The name
-.B meta\-flag
-is a synonym for this variable.
-.TP
-.B isearch\-terminators (``C\-[ C\-J'')
-The string of characters that should terminate an incremental
-search without subsequently executing the character as a command.
-If this variable has not been given a value, the characters
-\fIESC\fP and \fIC\-J\fP will terminate an incremental search.
-.TP
-.B keymap (emacs)
-Set the current readline keymap.  The set of legal keymap names is
-\fIemacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,
-vi-command\fP, and
-.IR vi-insert .
-\fIvi\fP is equivalent to \fIvi-command\fP; \fIemacs\fP is
-equivalent to \fIemacs-standard\fP.  The default value is
-.IR emacs .
-The value of
-.B editing\-mode
-also affects the default keymap.
-.TP
-.B mark\-directories (On)
-If set to \fBOn\fP, completed directory names have a slash
-appended.
-.TP
-.B mark\-modified\-lines (Off)
-If set to \fBOn\fP, history lines that have been modified are displayed
-with a preceding asterisk (\fB*\fP).
-.TP
-.B output\-meta (Off)
-If set to \fBOn\fP, readline will display characters with the
-eighth bit set directly rather than as a meta-prefixed escape
-sequence.
-.TP
-.B print\-completions\-horizontally (Off)
-If set to \fBOn\fP, readline will display completions with matches
-sorted horizontally in alphabetical order, rather than down the screen.
-.TP
-.B show\-all\-if\-ambiguous (Off)
-This alters the default behavior of the completion functions.  If
-set to
-.BR on ,
-words which have more than one possible completion cause the
-matches to be listed immediately instead of ringing the bell.
-.TP
-.B visible\-stats (Off)
-If set to \fBOn\fP, a character denoting a file's type as reported  
-by \fIstat\fP(2) is appended to the filename when listing possible
-completions.
-.PD
-.SS Conditional Constructs
-.PP
-Readline implements a facility similar in spirit to the conditional
-compilation features of the C preprocessor which allows key
-bindings and variable settings to be performed as the result
-of tests.  There are four parser directives used.
-.IP \fB$if\fP
-The 
-.B $if
-construct allows bindings to be made based on the
-editing mode, the terminal being used, or the application using
-readline.  The text of the test extends to the end of the line;
-no characters are required to isolate it.
-.RS
-.IP \fBmode\fP
-The \fBmode=\fP form of the \fB$if\fP directive is used to test
-whether readline is in emacs or vi mode.
-This may be used in conjunction
-with the \fBset keymap\fP command, for instance, to set bindings in
-the \fIemacs-standard\fP and \fIemacs-ctlx\fP keymaps only if
-readline is starting out in emacs mode.
-.IP \fBterm\fP
-The \fBterm=\fP form may be used to include terminal-specific
-key bindings, perhaps to bind the key sequences output by the
-terminal's function keys.  The word on the right side of the
-.B =
-is tested against the full name of the terminal and the portion
-of the terminal name before the first \fB\-\fP.  This allows
-.I sun
-to match both
-.I sun
-and
-.IR sun\-cmd ,
-for instance.
-.IP \fBapplication\fP
-The \fBapplication\fP construct is used to include
-application-specific settings.  Each program using the readline
-library sets the \fIapplication name\fP, and an initialization
-file can test for a particular value.
-This could be used to bind key sequences to functions useful for
-a specific program.  For instance, the following command adds a
-key sequence that quotes the current or previous word in Bash:
-.sp 1
-.RS
-.nf
-\fB$if\fP Bash
-# Quote the current or previous word
-"\eC-xq": "\eeb\e"\eef\e""
-\fB$endif\fP
-.fi
-.RE
-.RE
-.IP \fB$endif\fP
-This command, as seen in the previous example, terminates an
-\fB$if\fP command.
-.IP \fB$else\fP
-Commands in this branch of the \fB$if\fP directive are executed if
-the test fails.
-.IP \fB$include\fP
-This directive takes a single filename as an argument and reads commands
-and bindings from that file.  For example, the following directive
-would read \fI/etc/inputrc\fP:
-.sp 1
-.RS
-.nf
-\fB$include\fP \^ \fI/etc/inputrc\fP
-.fi 
-.RE
-.SH SEARCHING
-.PP
-Readline provides commands for searching through the command history
-for lines containing a specified string.
-There are two search modes:
-.I incremental
-and
-.IR non-incremental .
-.PP
-Incremental searches begin before the user has finished typing the
-search string.
-As each character of the search string is typed, readline displays
-the next entry from the history matching the string typed so far.
-An incremental search requires only as many characters as needed to
-find the desired history entry.
-To search backward in the history for a particular string, type
-\fBC\-r\fP.  Typing \fBC\-s\fP searches forward through the history.
-The characters present in the value of the \fBisearch-terminators\fP
-variable are used to terminate an incremental search.
-If that variable has not been assigned a value the \fIEscape\fP and
-\fBC\-J\fP characters will terminate an incremental search.
-\fBC\-G\fP will abort an incremental search and restore the original
-line.
-When the search is terminated, the history entry containing the
-search string becomes the current line.
-.PP
-To find other matching entries in the history list, type \fBC\-s\fP or
-\fBC\-r\fP as appropriate.
-This will search backward or forward in the history for the next
-line matching the search string typed so far.
-Any other key sequence bound to a readline command will terminate
-the search and execute that command.
-For instance, a newline will terminate the search and accept
-the line, thereby executing the command from the history list.
-A movement command will terminate the search, make the last line found
-the current line, and begin editing.
-.PP
-Non-incremental searches read the entire search string before starting
-to search for matching history lines.  The search string may be
-typed by the user or be part of the contents of the current line.
-.SH EDITING COMMANDS
-.PP
-The following is a list of the names of the commands and the default
-key sequences to which they are bound.
-Command names without an accompanying key sequence are unbound by default.
-.PP
-In the following descriptions, \fIpoint\fP refers to the current cursor
-position, and \fImark\fP refers to a cursor position saved by the
-\fBset\-mark\fP command.
-The text between the point and mark is referred to as the \fIregion\fP.
-.SS Commands for Moving
-.PP
-.PD 0
-.TP
-.B beginning\-of\-line (C\-a)
-Move to the start of the current line.
-.TP
-.B end\-of\-line (C\-e)
-Move to the end of the line.
-.TP
-.B forward\-char (C\-f)
-Move forward a character.
-.TP
-.B backward\-char (C\-b)
-Move back a character.
-.TP
-.B forward\-word (M\-f)
-Move forward to the end of the next word.  Words are composed of
-alphanumeric characters (letters and digits).
-.TP
-.B backward\-word (M\-b)
-Move back to the start of the current or previous word.  Words are
-composed of alphanumeric characters (letters and digits).
-.TP
-.B clear\-screen (C\-l)
-Clear the screen leaving the current line at the top of the screen.
-With an argument, refresh the current line without clearing the
-screen.
-.TP
-.B redraw\-current\-line
-Refresh the current line.
-.PD
-.SS Commands for Manipulating the History
-.PP
-.PD 0
-.TP
-.B accept\-line (Newline, Return)
-Accept the line regardless of where the cursor is.
-If this line is
-non-empty, it may be added to the history list for future recall with
-\fBadd_history()\fP.
-If the line is a modified history line, the history line is restored to its original state.
-.TP
-.B previous\-history (C\-p)
-Fetch the previous command from the history list, moving back in
-the list.
-.TP
-.B next\-history (C\-n)
-Fetch the next command from the history list, moving forward in the
-list.
-.TP
-.B beginning\-of\-history (M\-<)
-Move to the first line in the history.
-.TP
-.B end\-of\-history (M\->)
-Move to the end of the input history, i.e., the line currently being
-entered.
-.TP
-.B reverse\-search\-history (C\-r)
-Search backward starting at the current line and moving `up' through
-the history as necessary.  This is an incremental search.
-.TP
-.B forward\-search\-history (C\-s)
-Search forward starting at the current line and moving `down' through
-the history as necessary.  This is an incremental search.
-.TP
-.B non\-incremental\-reverse\-search\-history (M\-p)
-Search backward through the history starting at the current line
-using a non-incremental search for a string supplied by the user.
-.TP
-.B non\-incremental\-forward\-search\-history (M\-n)
-Search forward through the history using a non-incremental search
-for a string supplied by the user.
-.TP
-.B history\-search\-forward
-Search forward through the history for the string of characters
-between the start of the current line and the current cursor
-position (the \fIpoint\fP).
-This is a non-incremental search.
-.TP
-.B history\-search\-backward
-Search backward through the history for the string of characters
-between the start of the current line and the point.
-This is a non-incremental search.
-.TP
-.B yank\-nth\-arg (M\-C\-y)
-Insert the first argument to the previous command (usually
-the second word on the previous line) at point.
-With an argument
-.IR n ,
-insert the \fIn\fPth word from the previous command (the words
-in the previous command begin with word 0).  A negative argument
-inserts the \fIn\fPth word from the end of the previous command.
-.TP
-.B
-yank\-last\-arg (M\-.\^, M\-_\^)
-Insert the last argument to the previous command (the last word of
-the previous history entry).  With an argument,
-behave exactly like \fByank\-nth\-arg\fP.
-Successive calls to \fByank\-last\-arg\fP move back through the history
-list, inserting the last argument of each line in turn.
-.PD
-.SS Commands for Changing Text
-.PP
-.PD 0
-.TP
-.B delete\-char (C\-d)
-Delete the character at point.  If point is at the
-beginning of the line, there are no characters in the line, and
-the last character typed was not bound to \fBdelete\-char\fP, then return
-.SM
-.BR EOF .
-.TP
-.B backward\-delete\-char (Rubout)
-Delete the character behind the cursor.  When given a numeric argument,
-save the deleted text on the kill ring.
-.TP
-.B forward\-backward\-delete\-char   
-Delete the character under the cursor, unless the cursor is at the
-end of the line, in which case the character behind the cursor is
-deleted.
-.TP
-.B quoted\-insert (C\-q, C\-v)
-Add the next character that you type to the line verbatim.  This is
-how to insert characters like \fBC\-q\fP, for example.
-.TP
-.B tab\-insert (M-TAB)
-Insert a tab character.
-.TP
-.B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
-Insert the character typed.
-.TP
-.B transpose\-chars (C\-t)
-Drag the character before point forward over the character at point,
-moving point forward as well.
-If point is at the end of the line, then this transposes
-the two characters before point.
-Negative arguments have no effect.
-.TP
-.B transpose\-words (M\-t)
-Drag the word before point past the word after point,
-moving point over that word as well.
-.TP
-.B upcase\-word (M\-u)
-Uppercase the current (or following) word.  With a negative argument,
-uppercase the previous word, but do not move point.
-.TP
-.B downcase\-word (M\-l)
-Lowercase the current (or following) word.  With a negative argument,
-lowercase the previous word, but do not move point.
-.TP
-.B capitalize\-word (M\-c)
-Capitalize the current (or following) word.  With a negative argument,
-capitalize the previous word, but do not move point.
-.PD
-.SS Killing and Yanking
-.PP
-.PD 0
-.TP
-.B kill\-line (C\-k)
-Kill the text from point to the end of the line.
-.TP
-.B backward\-kill\-line (C\-x Rubout)
-Kill backward to the beginning of the line.
-.TP
-.B unix\-line\-discard (C\-u)
-Kill backward from point to the beginning of the line.
-The killed text is saved on the kill-ring.
-.\" There is no real difference between this and backward-kill-line
-.TP
-.B kill\-whole\-line
-Kill all characters on the current line, no matter where point is.
-.TP
-.B kill\-word  (M\-d)
-Kill from point the end of the current word, or if between
-words, to the end of the next word.  Word boundaries are the same as
-those used by \fBforward\-word\fP.
-.TP
-.B backward\-kill\-word (M\-Rubout)
-Kill the word behind point.
-Word boundaries are the same as those used by \fBbackward\-word\fP.
-.TP
-.B unix\-word\-rubout (C\-w)
-Kill the word behind point, using white space as a word boundary.
-The killed text is saved on the kill-ring.
-.TP
-.B delete\-horizontal\-space (M\-\e)
-Delete all spaces and tabs around point.
-.TP
-.B kill\-region
-Kill the text between the point and \fImark\fP (saved cursor position).
-This text is referred to as the \fIregion\fP.
-.TP
-.B copy\-region\-as\-kill
-Copy the text in the region to the kill buffer.
-.TP
-.B copy\-backward\-word
-Copy the word before point to the kill buffer.
-The word boundaries are the same as \fBbackward\-word\fP.
-.TP
-.B copy\-forward\-word
-Copy the word following point to the kill buffer.
-The word boundaries are the same as \fBforward\-word\fP.
-.TP
-.B yank (C\-y)
-Yank the top of the kill ring into the buffer at point.
-.TP
-.B yank\-pop (M\-y)
-Rotate the kill ring, and yank the new top.  Only works following
-.B yank
-or
-.BR yank\-pop .
-.PD
-.SS Numeric Arguments
-.PP
-.PD 0
-.TP
-.B digit\-argument (M\-0, M\-1, ..., M\-\-)
-Add this digit to the argument already accumulating, or start a new
-argument.  M\-\- starts a negative argument.
-.TP
-.B universal\-argument
-This is another way to specify an argument.
-If this command is followed by one or more digits, optionally with a
-leading minus sign, those digits define the argument.
-If the command is followed by digits, executing
-.B universal\-argument
-again ends the numeric argument, but is otherwise ignored.
-As a special case, if this command is immediately followed by a
-character that is neither a digit or minus sign, the argument count
-for the next command is multiplied by four.
-The argument count is initially one, so executing this function the
-first time makes the argument count four, a second time makes the
-argument count sixteen, and so on.
-.PD
-.SS Completing
-.PP
-.PD 0
-.TP
-.B complete (TAB)
-Attempt to perform completion on the text before point.
-The actual completion performed is application-specific.
-.BR Bash ,
-for instance, attempts completion treating the text as a variable
-(if the text begins with \fB$\fP), username (if the text begins with
-\fB~\fP), hostname (if the text begins with \fB@\fP), or
-command (including aliases and functions) in turn.  If none
-of these produces a match, filename completion is attempted.
-.BR Gdb ,
-on the other hand,
-allows completion of program functions and variables, and
-only attempts filename completion under certain circumstances.
-.TP
-.B possible\-completions (M\-?)
-List the possible completions of the text before point.
-.TP
-.B insert\-completions (M\-*)
-Insert all completions of the text before point
-that would have been generated by
-\fBpossible\-completions\fP.
-.TP
-.B menu\-complete
-Similar to \fBcomplete\fP, but replaces the word to be completed
-with a single match from the list of possible completions.
-Repeated execution of \fBmenu\-complete\fP steps through the list
-of possible completions, inserting each match in turn.
-At the end of the list of completions, the bell is rung
-(subject to the setting of \Bbell\-style\fP)
-and the original text is restored.
-An argument of \fIn\fP moves \fIn\fP positions forward in the list
-of matches; a negative argument may be used to move backward 
-through the list.
-This command is intended to be bound to \fBTAB\fP, but is unbound
-by default.
-.TP
-.B delete\-char\-or\-list
-Deletes the character under the cursor if not at the beginning or
-end of the line (like \fBdelete-char\fP).
-If at the end of the line, behaves identically to
-\fBpossible-completions\fP.
-.PD
-.SS Keyboard Macros
-.PP
-.PD 0
-.TP
-.B start\-kbd\-macro (C\-x (\^)
-Begin saving the characters typed into the current keyboard macro.
-.TP
-.B end\-kbd\-macro (C\-x )\^)
-Stop saving the characters typed into the current keyboard macro
-and store the definition.
-.TP
-.B call\-last\-kbd\-macro (C\-x e)
-Re-execute the last keyboard macro defined, by making the characters
-in the macro appear as if typed at the keyboard.
-.PD
-.SS Miscellaneous
-.PP
-.PD 0
-.TP
-.B re\-read\-init\-file (C\-x C\-r)
-Read in the contents of the \fIinputrc\fP file, and incorporate
-any bindings or variable assignments found there.
-.TP
-.B abort (C\-g)
-Abort the current editing command and
-ring the terminal's bell (subject to the setting of
-.BR bell\-style ).
-.TP
-.B do\-uppercase\-version (M\-a, M\-b, M\-\fIx\fP, ...)
-If the metafied character \fIx\fP is lowercase, run the command
-that is bound to the corresponding uppercase character.
-.TP
-.B prefix\-meta (ESC)
-Metafy the next character typed.
-.SM
-.B ESC
-.B f
-is equivalent to
-.BR Meta\-f .
-.TP
-.B undo (C\-_, C\-x C\-u)
-Incremental undo, separately remembered for each line.
-.TP
-.B revert\-line (M\-r)
-Undo all changes made to this line.  This is like executing the
-.B undo
-command enough times to return the line to its initial state.
-.TP
-.B tilde\-expand (M\-&)
-Perform tilde expansion on the current word.
-.TP
-.B set\-mark (C\-@, M\-<space>)
-Set the mark to the point.  If a
-numeric argument is supplied, the mark is set to that position.
-.TP
-.B exchange\-point\-and\-mark (C\-x C\-x)
-Swap the point with the mark.  The current cursor position is set to
-the saved position, and the old cursor position is saved as the mark.
-.TP
-.B character\-search (C\-])
-A character is read and point is moved to the next occurrence of that
-character.  A negative count searches for previous occurrences.
-.TP
-.B character\-search\-backward (M\-C\-])
-A character is read and point is moved to the previous occurrence of that
-character.  A negative count searches for subsequent occurrences.
-.TP
-.B insert\-comment (M\-#)
-The value of the readline
-.B comment\-begin
-variable is inserted at the beginning of the current line, and the line
-is accepted as if a newline had been typed.  The default value of
-.B comment\-begin
-makes the current line a shell comment.
-.TP
-.B dump\-functions
-Print all of the functions and their key bindings to the
-readline output stream.  If a numeric argument is supplied,
-the output is formatted in such a way that it can be made part
-of an \fIinputrc\fP file.
-.TP
-.B dump\-variables
-Print all of the settable variables and their values to the
-readline output stream.  If a numeric argument is supplied,
-the output is formatted in such a way that it can be made part
-of an \fIinputrc\fP file.
-.TP
-.B dump\-macros
-Print all of the readline key sequences bound to macros and the
-strings they ouput.  If a numeric argument is supplied,
-the output is formatted in such a way that it can be made part
-of an \fIinputrc\fP file.
-.TP
-.B emacs\-editing\-mode (C\-e)
-When in
-.B vi
-editing mode, this causes a switch to
-.B emacs
-editing mode.
-.TP
-.B vi\-editing\-mode (M\-C\-j)
-When in
-.B emacs
-editing mode, this causes a switch to
-.B vi
-editing mode.
-.PD
-.SH DEFAULT KEY BINDINGS
-.LP
-The following is a list of the default emacs and vi bindings.
-Characters with the eighth bit set are written as M\-<character>, and
-are referred to as
-.I metafied
-characters.
-The printable ASCII characters not mentioned in the list of emacs
-standard bindings are bound to the
-.B self\-insert
-function, which just inserts the given character into the input line.
-In vi insertion mode, all characters not specifically mentioned are
-bound to
-.BR self\-insert .
-Characters assigned to signal generation by
-.IR stty (1)
-or the terminal driver, such as C-Z or C-C,
-retain that function.
-Upper and lower case metafied characters are bound to the same function in
-the emacs mode meta keymap.
-The remaining characters are unbound, which causes readline
-to ring the bell (subject to the setting of the
-.B bell\-style
-variable).
-.SS Emacs Mode
-.RS +.6i
-.nf
-.ta 2.5i
-.sp
-Emacs Standard bindings
-.sp
-"C-@"  set-mark
-"C-A"  beginning-of-line
-"C-B"  backward-char
-"C-D"  delete-char
-"C-E"  end-of-line
-"C-F"  forward-char
-"C-G"  abort
-"C-H"  backward-delete-char
-"C-I"  complete
-"C-J"  accept-line
-"C-K"  kill-line
-"C-L"  clear-screen
-"C-M"  accept-line
-"C-N"  next-history
-"C-P"  previous-history
-"C-Q"  quoted-insert
-"C-R"  reverse-search-history
-"C-S"  forward-search-history
-"C-T"  transpose-chars
-"C-U"  unix-line-discard
-"C-V"  quoted-insert
-"C-W"  unix-word-rubout
-"C-Y"  yank
-"C-]"  character-search
-"C-_"  undo
-"\^ " to "/"  self-insert
-"0"  to "9"  self-insert
-":"  to "~"  self-insert
-"C-?"  backward-delete-char
-.PP
-Emacs Meta bindings
-.sp
-"M-C-G"  abort
-"M-C-H"  backward-kill-word
-"M-C-I"  tab-insert
-"M-C-J"  vi-editing-mode
-"M-C-M"  vi-editing-mode
-"M-C-R"  revert-line
-"M-C-Y"  yank-nth-arg
-"M-C-["  complete
-"M-C-]"  character-search-backward
-"M-space"  set-mark
-"M-#"  insert-comment
-"M-&"  tilde-expand
-"M-*"  insert-completions
-"M--"  digit-argument
-"M-."  yank-last-arg
-"M-0"  digit-argument
-"M-1"  digit-argument
-"M-2"  digit-argument
-"M-3"  digit-argument
-"M-4"  digit-argument
-"M-5"  digit-argument
-"M-6"  digit-argument
-"M-7"  digit-argument
-"M-8"  digit-argument
-"M-9"  digit-argument
-"M-<"  beginning-of-history
-"M-="  possible-completions
-"M->"  end-of-history
-"M-?"  possible-completions
-"M-B"  backward-word
-"M-C"  capitalize-word
-"M-D"  kill-word
-"M-F"  forward-word
-"M-L"  downcase-word
-"M-N"  non-incremental-forward-search-history
-"M-P"  non-incremental-reverse-search-history
-"M-R"  revert-line
-"M-T"  transpose-words
-"M-U"  upcase-word
-"M-Y"  yank-pop
-"M-\e"  delete-horizontal-space
-"M-~"  tilde-expand
-"M-C-?"  backward-kill-word
-"M-_"  yank-last-arg
-.PP
-Emacs Control-X bindings
-.sp
-"C-XC-G"  abort
-"C-XC-R"  re-read-init-file
-"C-XC-U"  undo
-"C-XC-X"  exchange-point-and-mark
-"C-X("  start-kbd-macro
-"C-X)"  end-kbd-macro
-"C-XE"  call-last-kbd-macro
-"C-XC-?"  backward-kill-line
-.sp
-.RE
-.SS VI Mode bindings
-.RS +.6i
-.nf
-.ta 2.5i
-.sp
-.PP
-VI Insert Mode functions
-.sp
-"C-D"  vi-eof-maybe
-"C-H"  backward-delete-char
-"C-I"  complete
-"C-J"  accept-line
-"C-M"  accept-line
-"C-R"  reverse-search-history
-"C-S"  forward-search-history
-"C-T"  transpose-chars
-"C-U"  unix-line-discard
-"C-V"  quoted-insert
-"C-W"  unix-word-rubout
-"C-Y"  yank
-"C-["  vi-movement-mode
-"C-_"  undo
-"\^ " to "~"  self-insert
-"C-?"  backward-delete-char
-.PP
-VI Command Mode functions
-.sp
-"C-D"  vi-eof-maybe
-"C-E"  emacs-editing-mode
-"C-G"  abort
-"C-H"  backward-char
-"C-J"  accept-line
-"C-K"  kill-line
-"C-L"  clear-screen
-"C-M"  accept-line
-"C-N"  next-history
-"C-P"  previous-history
-"C-Q"  quoted-insert
-"C-R"  reverse-search-history
-"C-S"  forward-search-history
-"C-T"  transpose-chars
-"C-U"  unix-line-discard
-"C-V"  quoted-insert
-"C-W"  unix-word-rubout
-"C-Y"  yank
-"C-_"  vi-undo
-"\^ "  forward-char
-"#"  insert-comment
-"$"  end-of-line
-"%"  vi-match
-"&"  vi-tilde-expand
-"*"  vi-complete
-"+"  next-history
-","  vi-char-search
-"-"  previous-history
-"."  vi-redo
-"/"  vi-search
-"0"  beginning-of-line
-"1" to "9"  vi-arg-digit
-";"  vi-char-search
-"="  vi-complete
-"?"  vi-search
-"A"  vi-append-eol
-"B"  vi-prev-word
-"C"  vi-change-to
-"D"  vi-delete-to
-"E"  vi-end-word
-"F"  vi-char-search
-"G"  vi-fetch-history
-"I"  vi-insert-beg
-"N"  vi-search-again
-"P"  vi-put
-"R"  vi-replace
-"S"  vi-subst
-"T"  vi-char-search
-"U"  revert-line
-"W"  vi-next-word
-"X"  backward-delete-char
-"Y"  vi-yank-to
-"\e"  vi-complete
-"^"  vi-first-print
-"_"  vi-yank-arg
-"`"  vi-goto-mark
-"a"  vi-append-mode
-"b"  vi-prev-word
-"c"  vi-change-to
-"d"  vi-delete-to
-"e"  vi-end-word
-"f"  vi-char-search
-"h"  backward-char
-"i"  vi-insertion-mode
-"j"  next-history
-"k"  prev-history
-"l"  forward-char
-"m"  vi-set-mark
-"n"  vi-search-again
-"p"  vi-put
-"r"  vi-change-char
-"s"  vi-subst
-"t"  vi-char-search
-"u"  vi-undo
-"w"  vi-next-word
-"x"  vi-delete
-"y"  vi-yank-to
-"|"  vi-column
-"~"  vi-change-case
-.RE
-.SH "SEE ALSO"
-.PD 0
-.TP
-\fIThe Gnu Readline Library\fP, Brian Fox and Chet Ramey
-.TP
-\fIThe Gnu History Library\fP, Brian Fox and Chet Ramey
-.TP
-\fIbash\fP(1)
-.PD
-.SH FILES
-.PD 0
-.TP
-.FN ~/.inputrc
-Individual \fBreadline\fP initialization file
-.PD
-.SH AUTHORS
-Brian Fox, Free Software Foundation
-.br
-bfox@gnu.org
-.PP
-Chet Ramey, Case Western Reserve University
-.br
-chet@ins.CWRU.Edu
-.SH BUG REPORTS
-If you find a bug in
-.B readline,
-you should report it.  But first, you should
-make sure that it really is a bug, and that it appears in the latest
-version of the
-.B readline
-library that you have.
-.PP
-Once you have determined that a bug actually exists, mail a
-bug report to \fIbug\-readline\fP@\fIgnu.org\fP.
-If you have a fix, you are welcome to mail that
-as well!  Suggestions and `philosophical' bug reports may be mailed
-to \fPbug-readline\fP@\fIgnu.org\fP or posted to the Usenet
-newsgroup
-.BR gnu.bash.bug .
-.PP
-Comments and bug reports concerning
-this manual page should be directed to
-.IR chet@ins.CWRU.Edu .
-.SH BUGS
-.PP
-It's too big and too slow.
diff --git a/readline/doc/rlman.texinfo b/readline/doc/rlman.texinfo
deleted file mode 100644
--- a/readline/doc/rlman.texinfo
+++ /dev/null
@@ -1,108 +0,0 @@
-\input texinfo    @c -*-texinfo-*-
-@comment %**start of header (This is for running Texinfo on a region.)
-@setfilename readline.info
-@settitle GNU Readline Library
-@comment %**end of header (This is for running Texinfo on a region.)
-@synindex vr fn
-@setchapternewpage odd
-
-@include manvers.texinfo
-
-@ifinfo
-@dircategory Libraries
-@direntry
-* Readline: (readline).       The GNU readline library API
-@end direntry
-
-This document describes the GNU Readline Library, a utility which aids
-in the consistency of user interface across discrete programs that need
-to provide a command line interface.
-
-Copyright (C) 1988-2001 Free Software Foundation, Inc.
-
-Permission is granted to make and distribute verbatim copies of
-this manual provided the copyright notice and this permission notice
-pare preserved on all copies.
-
-@ignore
-Permission is granted to process this file through TeX and print the
-results, provided the printed document carries copying permission
-notice identical to this one except for the removal of this paragraph
-(this paragraph not being relevant to the printed manual).
-@end ignore
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided that the entire
-resulting derived work is distributed under the terms of a permission
-notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions,
-except that this permission notice may be stated in a translation approved
-by the Free Software Foundation.
-@end ifinfo
-
-@titlepage  
-@title GNU Readline Library
-@subtitle Edition @value{EDITION}, for @code{Readline Library} Version @value{VERSION}.
-@subtitle @value{UPDATE-MONTH}
-@author Brian Fox, Free Software Foundation
-@author Chet Ramey, Case Western Reserve University
-
-@page
-This document describes the GNU Readline Library, a utility which aids
-in the consistency of user interface across discrete programs that need
-to provide a command line interface.
-
-Published by the Free Software Foundation @*
-59 Temple Place, Suite 330, @*
-Boston, MA 02111 USA
-
-Permission is granted to make and distribute verbatim copies of
-this manual provided the copyright notice and this permission notice
-are preserved on all copies.
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided that the entire
-resulting derived work is distributed under the terms of a permission
-notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions,
-except that this permission notice may be stated in a translation approved
-by the Free Software Foundation.
-
-@vskip 0pt plus 1filll
-Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
-@end titlepage
-
-@ifinfo
-@node Top
-@top GNU Readline Library
-
-This document describes the GNU Readline Library, a utility which aids
-in the consistency of user interface across discrete programs that need
-to provide a command line interface.
-
-@menu
-* Command Line Editing::	   GNU Readline User's Manual.
-* Programming with GNU Readline::  GNU Readline Programmer's Manual.
-* Concept Index::		   Index of concepts described in this manual.
-* Function and Variable Index::	   Index of externally visible functions
-				   and variables.
-@end menu
-@end ifinfo
-
-@include rluser.texinfo
-@include rltech.texinfo
-
-@node Concept Index
-@unnumbered Concept Index
-@printindex cp
-
-@node Function and Variable Index
-@unnumbered Function and Variable Index
-@printindex fn
-
-@contents
-@bye
diff --git a/readline/doc/rltech.texinfo b/readline/doc/rltech.texinfo
deleted file mode 100644
--- a/readline/doc/rltech.texinfo
+++ /dev/null
@@ -1,2083 +0,0 @@
-@comment %**start of header (This is for running Texinfo on a region.)
-@setfilename rltech.info
-@comment %**end of header (This is for running Texinfo on a region.)
-@setchapternewpage odd
-
-@ifinfo
-This document describes the GNU Readline Library, a utility for aiding
-in the consitency of user interface across discrete programs that need
-to provide a command line interface.
-
-Copyright (C) 1988-2001 Free Software Foundation, Inc.
-
-Permission is granted to make and distribute verbatim copies of
-this manual provided the copyright notice and this permission notice
-pare preserved on all copies.
-
-@ignore
-Permission is granted to process this file through TeX and print the
-results, provided the printed document carries copying permission
-notice identical to this one except for the removal of this paragraph
-(this paragraph not being relevant to the printed manual).
-@end ignore
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided that the entire
-resulting derived work is distributed under the terms of a permission
-notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions,
-except that this permission notice may be stated in a translation approved
-by the Foundation.
-@end ifinfo
-
-@node Programming with GNU Readline
-@chapter Programming with GNU Readline
-
-This chapter describes the interface between the @sc{gnu} Readline Library and
-other programs.  If you are a programmer, and you wish to include the
-features found in @sc{gnu} Readline
-such as completion, line editing, and interactive history manipulation
-in your own programs, this section is for you.
-
-@menu
-* Basic Behavior::	Using the default behavior of Readline.
-* Custom Functions::	Adding your own functions to Readline.
-* Readline Variables::			Variables accessible to custom
-					functions.
-* Readline Convenience Functions::	Functions which Readline supplies to
-					aid in writing your own custom
-					functions.
-* Readline Signal Handling::	How Readline behaves when it receives signals.
-* Custom Completers::	Supplanting or supplementing Readline's
-			completion functions.
-@end menu
-
-@node Basic Behavior
-@section Basic Behavior
-
-Many programs provide a command line interface, such as @code{mail},
-@code{ftp}, and @code{sh}.  For such programs, the default behaviour of
-Readline is sufficient.  This section describes how to use Readline in
-the simplest way possible, perhaps to replace calls in your code to
-@code{gets()} or @code{fgets()}.
-
-@findex readline
-@cindex readline, function
-
-The function @code{readline()} prints a prompt @var{prompt}
-and then reads and returns a single line of text from the user.
-If @var{prompt} is @code{NULL} or the empty string, no prompt is displayed.
-The line @code{readline} returns is allocated with @code{malloc()};
-the caller should @code{free()} the line when it has finished with it.
-The declaration for @code{readline} in ANSI C is
-
-@example
-@code{char *readline (const char *@var{prompt});}
-@end example
-
-@noindent
-So, one might say
-@example
-@code{char *line = readline ("Enter a line: ");}
-@end example
-@noindent
-in order to read a line of text from the user.
-The line returned has the final newline removed, so only the
-text remains.
-
-If @code{readline} encounters an @code{EOF} while reading the line, and the
-line is empty at that point, then @code{(char *)NULL} is returned.
-Otherwise, the line is ended just as if a newline had been typed.
-
-If you want the user to be able to get at the line later, (with
-@key{C-p} for example), you must call @code{add_history()} to save the
-line away in a @dfn{history} list of such lines.
-
-@example
-@code{add_history (line)};
-@end example
-
-@noindent
-For full details on the GNU History Library, see the associated manual.
-
-It is preferable to avoid saving empty lines on the history list, since
-users rarely have a burning need to reuse a blank line.  Here is
-a function which usefully replaces the standard @code{gets()} library
-function, and has the advantage of no static buffer to overflow:
-
-@example
-/* A static variable for holding the line. */
-static char *line_read = (char *)NULL;
-
-/* Read a string, and return a pointer to it.  Returns NULL on EOF. */
-char *
-rl_gets ()
-@{
-  /* If the buffer has already been allocated, return the memory
-     to the free pool. */
-  if (line_read)
-    @{
-      free (line_read);
-      line_read = (char *)NULL;
-    @}
-
-  /* Get a line from the user. */
-  line_read = readline ("");
-
-  /* If the line has any text in it, save it on the history. */
-  if (line_read && *line_read)
-    add_history (line_read);
-
-  return (line_read);
-@}
-@end example
-
-This function gives the user the default behaviour of @key{TAB}
-completion: completion on file names.  If you do not want Readline to
-complete on filenames, you can change the binding of the @key{TAB} key
-with @code{rl_bind_key()}.
-
-@example
-@code{int rl_bind_key (int @var{key}, rl_command_func_t *@var{function});}
-@end example
-
-@code{rl_bind_key()} takes two arguments: @var{key} is the character that
-you want to bind, and @var{function} is the address of the function to
-call when @var{key} is pressed.  Binding @key{TAB} to @code{rl_insert()}
-makes @key{TAB} insert itself.
-@code{rl_bind_key()} returns non-zero if @var{key} is not a valid
-ASCII character code (between 0 and 255).
-
-Thus, to disable the default @key{TAB} behavior, the following suffices:
-@example
-@code{rl_bind_key ('\t', rl_insert);}
-@end example
-
-This code should be executed once at the start of your program; you
-might write a function called @code{initialize_readline()} which
-performs this and other desired initializations, such as installing
-custom completers (@pxref{Custom Completers}).
-
-@node Custom Functions
-@section Custom Functions
-
-Readline provides many functions for manipulating the text of
-the line, but it isn't possible to anticipate the needs of all
-programs.  This section describes the various functions and variables
-defined within the Readline library which allow a user program to add
-customized functionality to Readline.
-
-Before declaring any functions that customize Readline's behavior, or
-using any functionality Readline provides in other code, an
-application writer should include the file @code{<readline/readline.h>}
-in any file that uses Readline's features.  Since some of the definitions
-in @code{readline.h} use the @code{stdio} library, the file
-@code{<stdio.h>} should be included before @code{readline.h}.
-
-@menu
-* Readline Typedefs::	C declarations to make code readable.
-* Function Writing::	Variables and calling conventions.
-@end menu
-
-@node Readline Typedefs
-@subsection Readline Typedefs
-
-For readabilty, we declare a number of new object types, all pointers
-to functions.
-
-The reason for declaring these new types is to make it easier to write
-code describing pointers to C functions with appropriately prototyped
-arguments and return values.
-
-For instance, say we want to declare a variable @var{func} as a pointer
-to a function which takes two @code{int} arguments and returns an
-@code{int} (this is the type of all of the Readline bindable functions).
-Instead of the classic C declaration
-
-@code{int (*func)();}
-
-@noindent
-or the ANSI-C style declaration
-
-@code{int (*func)(int, int);}
-
-@noindent
-we may write
-
-@code{rl_command_func_t *func;}
-
-The full list of function pointer types available is
-
-@table @code
-@item typedef int rl_command_func_t (int, int);
-
-@item typedef char *rl_compentry_func_t (const char *, int);
-
-@item typedef char **rl_completion_func_t (const char *, int, int);
-
-@item typedef char *rl_quote_func_t (char *, int, char *);
-
-@item typedef char *rl_dequote_func_t (char *, int);
-
-@item typedef int rl_compignore_func_t (char **);
-
-@item typedef void rl_compdisp_func_t (char **, int, int);
-
-@item typedef int rl_hook_func_t (void);
-
-@item typedef int rl_getc_func_t (FILE *);
-
-@item typedef int rl_linebuf_func_t (char *, int);
-
-@item typedef int rl_intfunc_t (int);
-@item #define rl_ivoidfunc_t rl_hook_func_t
-@item typedef int rl_icpfunc_t (char *);
-@item typedef int rl_icppfunc_t (char **);
-
-@item typedef void rl_voidfunc_t (void);
-@item typedef void rl_vintfunc_t (int);
-@item typedef void rl_vcpfunc_t (char *);
-@item typedef void rl_vcppfunc_t (char **);
-
-@end table
-
-@node Function Writing
-@subsection Writing a New Function
-
-In order to write new functions for Readline, you need to know the
-calling conventions for keyboard-invoked functions, and the names of the
-variables that describe the current state of the line read so far.
-
-The calling sequence for a command @code{foo} looks like
-
-@example
-@code{foo (int count, int key)}
-@end example
-
-@noindent
-where @var{count} is the numeric argument (or 1 if defaulted) and
-@var{key} is the key that invoked this function.
-
-It is completely up to the function as to what should be done with the
-numeric argument.  Some functions use it as a repeat count, some
-as a flag, and others to choose alternate behavior (refreshing the current
-line as opposed to refreshing the screen, for example).  Some choose to
-ignore it.  In general, if a
-function uses the numeric argument as a repeat count, it should be able
-to do something useful with both negative and positive arguments.
-At the very least, it should be aware that it can be passed a
-negative argument.
-
-@node Readline Variables
-@section Readline Variables
-
-These variables are available to function writers.
-
-@deftypevar {char *} rl_line_buffer
-This is the line gathered so far.  You are welcome to modify the
-contents of the line, but see @ref{Allowing Undoing}.  The
-function @code{rl_extend_line_buffer} is available to increase
-the memory allocated to @code{rl_line_buffer}.
-@end deftypevar
-
-@deftypevar int rl_point
-The offset of the current cursor position in @code{rl_line_buffer}
-(the @emph{point}).
-@end deftypevar
-
-@deftypevar int rl_end
-The number of characters present in @code{rl_line_buffer}.  When
-@code{rl_point} is at the end of the line, @code{rl_point} and
-@code{rl_end} are equal.
-@end deftypevar
-
-@deftypevar int rl_mark
-The @var{mark} (saved position) in the current line.  If set, the mark
-and point define a @emph{region}.
-@end deftypevar
-
-@deftypevar int rl_done
-Setting this to a non-zero value causes Readline to return the current
-line immediately.
-@end deftypevar
-
-@deftypevar int rl_num_chars_to_read
-Setting this to a positive value before calling @code{readline()} causes
-Readline to return after accepting that many characters, rather
-than reading up to a character bound to @code{accept-line}.
-@end deftypevar
-
-@deftypevar int rl_pending_input
-Setting this to a value makes it the next keystroke read.  This is a
-way to stuff a single character into the input stream.
-@end deftypevar
-
-@deftypevar int rl_dispatching
-Set to a non-zero value if a function is being called from a key binding;
-zero otherwise.  Application functions can test this to discover whether
-they were called directly or by Readline's dispatching mechanism.
-@end deftypevar
-
-@deftypevar int rl_erase_empty_line
-Setting this to a non-zero value causes Readline to completely erase
-the current line, including any prompt, any time a newline is typed as
-the only character on an otherwise-empty line.  The cursor is moved to
-the beginning of the newly-blank line.
-@end deftypevar
-
-@deftypevar {char *} rl_prompt
-The prompt Readline uses.  This is set from the argument to
-@code{readline()}, and should not be assigned to directly.
-The @code{rl_set_prompt()} function (@pxref{Redisplay}) may
-be used to modify the prompt string after calling @code{readline()}.
-@end deftypevar
-
-@deftypevar int rl_already_prompted
-If an application wishes to display the prompt itself, rather than have
-Readline do it the first time @code{readline()} is called, it should set
-this variable to a non-zero value after displaying the prompt.
-The prompt must also be passed as the argument to @code{readline()} so
-the redisplay functions can update the display properly.
-The calling application is responsible for managing the value; Readline
-never sets it.
-@end deftypevar
-
-@deftypevar {const char *} rl_library_version
-The version number of this revision of the library.
-@end deftypevar
-
-@deftypevar {int} rl_gnu_readline_p
-Always set to 1, denoting that this is @sc{gnu} readline rather than some
-emulation.
-@end deftypevar
-
-@deftypevar {const char *} rl_terminal_name
-The terminal type, used for initialization.  If not set by the application,
-Readline sets this to the value of the @env{TERM} environment variable
-the first time it is called.
-@end deftypevar
-
-@deftypevar {const char *} rl_readline_name
-This variable is set to a unique name by each application using Readline.
-The value allows conditional parsing of the inputrc file
-(@pxref{Conditional Init Constructs}).
-@end deftypevar
-
-@deftypevar {FILE *} rl_instream
-The stdio stream from which Readline reads input.
-@end deftypevar
-
-@deftypevar {FILE *} rl_outstream
-The stdio stream to which Readline performs output.
-@end deftypevar
-
-@deftypevar {rl_command_func_t *} rl_last_func
-The address of the last command function Readline executed.  May be used to
-test whether or not a function is being executed twice in succession, for
-example.
-@end deftypevar
-
-@deftypevar {rl_hook_func_t *} rl_startup_hook
-If non-zero, this is the address of a function to call just
-before @code{readline} prints the first prompt.
-@end deftypevar
-
-@deftypevar {rl_hook_func_t *} rl_pre_input_hook
-If non-zero, this is the address of a function to call after
-the first prompt has been printed and just before @code{readline}
-starts reading input characters.
-@end deftypevar
-
-@deftypevar {rl_hook_func_t *} rl_event_hook
-If non-zero, this is the address of a function to call periodically
-when Readline is waiting for terminal input.
-By default, this will be called at most ten times a second if there
-is no keyboard input.
-@end deftypevar
-
-@deftypevar {rl_getc_func_t *} rl_getc_function
-If non-zero, Readline will call indirectly through this pointer
-to get a character from the input stream.  By default, it is set to
-@code{rl_getc}, the default Readline character input function
-(@pxref{Character Input}).
-@end deftypevar
-
-@deftypevar {rl_voidfunc_t *} rl_redisplay_function
-If non-zero, Readline will call indirectly through this pointer
-to update the display with the current contents of the editing buffer.
-By default, it is set to @code{rl_redisplay}, the default Readline
-redisplay function (@pxref{Redisplay}).
-@end deftypevar
-
-@deftypevar {rl_vintfunc_t *} rl_prep_term_function
-If non-zero, Readline will call indirectly through this pointer
-to initialize the terminal.  The function takes a single argument, an
-@code{int} flag that says whether or not to use eight-bit characters.
-By default, this is set to @code{rl_prep_terminal}
-(@pxref{Terminal Management}).
-@end deftypevar
-
-@deftypevar {rl_voidfunc_t *} rl_deprep_term_function
-If non-zero, Readline will call indirectly through this pointer
-to reset the terminal.  This function should undo the effects of
-@code{rl_prep_term_function}.
-By default, this is set to @code{rl_deprep_terminal}
-(@pxref{Terminal Management}).
-@end deftypevar
-
-@deftypevar {Keymap} rl_executing_keymap
-This variable is set to the keymap (@pxref{Keymaps}) in which the
-currently executing readline function was found.
-@end deftypevar 
-
-@deftypevar {Keymap} rl_binding_keymap
-This variable is set to the keymap (@pxref{Keymaps}) in which the
-last key binding occurred.
-@end deftypevar 
-
-@deftypevar {char *} rl_executing_macro
-This variable is set to the text of any currently-executing macro.
-@end deftypevar
-
-@deftypevar {int} rl_readline_state
-A variable with bit values that encapsulate the current Readline state.
-A bit is set with the @code{RL_SETSTATE} macro, and unset with the
-@code{RL_UNSETSTATE} macro.  Use the @code{RL_ISSTATE} macro to test
-whether a particular state bit is set.  Current state bits include:
-
-@table @code
-@item RL_STATE_NONE
-Readline has not yet been called, nor has it begun to intialize.
-@item RL_STATE_INITIALIZING
-Readline is initializing its internal data structures.
-@item RL_STATE_INITIALIZED
-Readline has completed its initialization.
-@item RL_STATE_TERMPREPPED
-Readline has modified the terminal modes to do its own input and redisplay.
-@item RL_STATE_READCMD
-Readline is reading a command from the keyboard.
-@item RL_STATE_METANEXT
-Readline is reading more input after reading the meta-prefix character.
-@item RL_STATE_DISPATCHING
-Readline is dispatching to a command.
-@item RL_STATE_MOREINPUT
-Readline is reading more input while executing an editing command.
-@item RL_STATE_ISEARCH
-Readline is performing an incremental history search.
-@item RL_STATE_NSEARCH
-Readline is performing a non-incremental history search.
-@item RL_STATE_SEARCH
-Readline is searching backward or forward through the history for a string.
-@item RL_STATE_NUMERICARG
-Readline is reading a numeric argument.
-@item RL_STATE_MACROINPUT
-Readline is currently getting its input from a previously-defined keyboard
-macro.
-@item RL_STATE_MACRODEF
-Readline is currently reading characters defining a keyboard macro.
-@item RL_STATE_OVERWRITE
-Readline is in overwrite mode.
-@item RL_STATE_COMPLETING
-Readline is performing word completion.
-@item RL_STATE_SIGHANDLER
-Readline is currently executing the readline signal handler.
-@item RL_STATE_UNDOING
-Readline is performing an undo.
-@item RL_STATE_DONE
-Readline has read a key sequence bound to @code{accept-line}
-and is about to return the line to the caller.
-@end table
-
-@end deftypevar
-
-@deftypevar {int} rl_explicit_arg
-Set to a non-zero value if an explicit numeric argument was specified by
-the user.  Only valid in a bindable command function.
-@end deftypevar
-
-@deftypevar {int} rl_numeric_arg
-Set to the value of any numeric argument explicitly specified by the user
-before executing the current Readline function.  Only valid in a bindable
-command function.
-@end deftypevar
-
-@deftypevar {int} rl_editing_mode
-Set to a value denoting Readline's current editing mode.  A value of
-@var{1} means Readline is currently in emacs mode; @var{0}
-means that vi mode is active.
-@end deftypevar
-
-
-@node Readline Convenience Functions
-@section Readline Convenience Functions
-
-@menu
-* Function Naming::	How to give a function you write a name.
-* Keymaps::		Making keymaps.
-* Binding Keys::	Changing Keymaps.
-* Associating Function Names and Bindings::	Translate function names to
-						key sequences.
-* Allowing Undoing::	How to make your functions undoable.
-* Redisplay::		Functions to control line display.
-* Modifying Text::	Functions to modify @code{rl_line_buffer}.
-* Character Input::	Functions to read keyboard input.
-* Terminal Management::	Functions to manage terminal settings.
-* Utility Functions::	Generally useful functions and hooks.
-* Miscellaneous Functions::	Functions that don't fall into any category.
-* Alternate Interface::	Using Readline in a `callback' fashion.
-* A Readline Example::		An example Readline function.
-@end menu
-
-@node Function Naming
-@subsection Naming a Function
-
-The user can dynamically change the bindings of keys while using
-Readline.  This is done by representing the function with a descriptive
-name.  The user is able to type the descriptive name when referring to
-the function.  Thus, in an init file, one might find
-
-@example
-Meta-Rubout:	backward-kill-word
-@end example
-
-This binds the keystroke @key{Meta-Rubout} to the function
-@emph{descriptively} named @code{backward-kill-word}.  You, as the
-programmer, should bind the functions you write to descriptive names as
-well.  Readline provides a function for doing that:
-
-@deftypefun int rl_add_defun (const char *name, rl_command_func_t *function, int key)
-Add @var{name} to the list of named functions.  Make @var{function} be
-the function that gets called.  If @var{key} is not -1, then bind it to
-@var{function} using @code{rl_bind_key()}.
-@end deftypefun
-
-Using this function alone is sufficient for most applications.  It is
-the recommended way to add a few functions to the default functions that
-Readline has built in.  If you need to do something other
-than adding a function to Readline, you may need to use the
-underlying functions described below.
-
-@node Keymaps
-@subsection Selecting a Keymap
-
-Key bindings take place on a @dfn{keymap}.  The keymap is the
-association between the keys that the user types and the functions that
-get run.  You can make your own keymaps, copy existing keymaps, and tell
-Readline which keymap to use.
-
-@deftypefun Keymap rl_make_bare_keymap (void)
-Returns a new, empty keymap.  The space for the keymap is allocated with
-@code{malloc()}; the caller should free it by calling
-@code{rl_discard_keymap()} when done.
-@end deftypefun
-
-@deftypefun Keymap rl_copy_keymap (Keymap map)
-Return a new keymap which is a copy of @var{map}.
-@end deftypefun
-
-@deftypefun Keymap rl_make_keymap (void)
-Return a new keymap with the printing characters bound to rl_insert,
-the lowercase Meta characters bound to run their equivalents, and
-the Meta digits bound to produce numeric arguments.
-@end deftypefun
-
-@deftypefun void rl_discard_keymap (Keymap keymap)
-Free the storage associated with @var{keymap}.
-@end deftypefun
-
-Readline has several internal keymaps.  These functions allow you to
-change which keymap is active.
-
-@deftypefun Keymap rl_get_keymap (void)
-Returns the currently active keymap.
-@end deftypefun
-
-@deftypefun void rl_set_keymap (Keymap keymap)
-Makes @var{keymap} the currently active keymap.
-@end deftypefun
-
-@deftypefun Keymap rl_get_keymap_by_name (const char *name)
-Return the keymap matching @var{name}.  @var{name} is one which would
-be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
-@end deftypefun
-
-@deftypefun {char *} rl_get_keymap_name (Keymap keymap)
-Return the name matching @var{keymap}.  @var{name} is one which would
-be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
-@end deftypefun
-
-@node Binding Keys
-@subsection Binding Keys
-
-Key sequences are associate with functions through the keymap.
-Readline has several internal keymaps: @code{emacs_standard_keymap},
-@code{emacs_meta_keymap}, @code{emacs_ctlx_keymap},
-@code{vi_movement_keymap}, and @code{vi_insertion_keymap}.
-@code{emacs_standard_keymap} is the default, and the examples in
-this manual assume that.
-
-Since @code{readline()} installs a set of default key bindings the first
-time it is called, there is always the danger that a custom binding
-installed before the first call to @code{readline()} will be overridden.
-An alternate mechanism is to install custom key bindings in an
-initialization function assigned to the @code{rl_startup_hook} variable
-(@pxref{Readline Variables}).
-
-These functions manage key bindings.
-
-@deftypefun int rl_bind_key (int key, rl_command_func_t *function)
-Binds @var{key} to @var{function} in the currently active keymap.
-Returns non-zero in the case of an invalid @var{key}.
-@end deftypefun
-
-@deftypefun int rl_bind_key_in_map (int key, rl_command_func_t *function, Keymap map)
-Bind @var{key} to @var{function} in @var{map}.  Returns non-zero in the case
-of an invalid @var{key}.
-@end deftypefun
-
-@deftypefun int rl_unbind_key (int key)
-Bind @var{key} to the null function in the currently active keymap.
-Returns non-zero in case of error.
-@end deftypefun
-
-@deftypefun int rl_unbind_key_in_map (int key, Keymap map)
-Bind @var{key} to the null function in @var{map}.
-Returns non-zero in case of error.
-@end deftypefun
-
-@deftypefun int rl_unbind_function_in_map (rl_command_func_t *function, Keymap map)
-Unbind all keys that execute @var{function} in @var{map}.
-@end deftypefun
-
-@deftypefun int rl_unbind_command_in_map (const char *command, Keymap map)
-Unbind all keys that are bound to @var{command} in @var{map}.
-@end deftypefun
-
-@deftypefun int rl_set_key (const char *keyseq, rl_command_func_t *function, Keymap map)
-Bind the key sequence represented by the string @var{keyseq} to the function
-@var{function}.  This makes new keymaps as
-necessary.  The initial keymap in which to do bindings is @var{map}.
-@end deftypefun
-
-@deftypefun int rl_generic_bind (int type, const char *keyseq, char *data, Keymap map)
-Bind the key sequence represented by the string @var{keyseq} to the arbitrary
-pointer @var{data}.  @var{type} says what kind of data is pointed to by
-@var{data}; this can be a function (@code{ISFUNC}), a macro
-(@code{ISMACR}), or a keymap (@code{ISKMAP}).  This makes new keymaps as
-necessary.  The initial keymap in which to do bindings is @var{map}.
-@end deftypefun
-
-@deftypefun int rl_parse_and_bind (char *line)
-Parse @var{line} as if it had been read from the @code{inputrc} file and
-perform any key bindings and variable assignments found
-(@pxref{Readline Init File}).
-@end deftypefun
-
-@deftypefun int rl_read_init_file (const char *filename)
-Read keybindings and variable assignments from @var{filename}
-(@pxref{Readline Init File}).
-@end deftypefun
-
-@node Associating Function Names and Bindings
-@subsection Associating Function Names and Bindings
-
-These functions allow you to find out what keys invoke named functions
-and the functions invoked by a particular key sequence.  You may also
-associate a new function name with an arbitrary function.
-
-@deftypefun {rl_command_func_t *} rl_named_function (const char *name)
-Return the function with name @var{name}.
-@end deftypefun
-
-@deftypefun {rl_command_func_t *} rl_function_of_keyseq (const char *keyseq, Keymap map, int *type)
-Return the function invoked by @var{keyseq} in keymap @var{map}.
-If @var{map} is @code{NULL}, the current keymap is used.  If @var{type} is
-not @code{NULL}, the type of the object is returned in the @code{int} variable
-it points to (one of @code{ISFUNC}, @code{ISKMAP}, or @code{ISMACR}).
-@end deftypefun
-
-@deftypefun {char **} rl_invoking_keyseqs (rl_command_func_t *function)
-Return an array of strings representing the key sequences used to
-invoke @var{function} in the current keymap.
-@end deftypefun
-
-@deftypefun {char **} rl_invoking_keyseqs_in_map (rl_command_func_t *function, Keymap map)
-Return an array of strings representing the key sequences used to
-invoke @var{function} in the keymap @var{map}.
-@end deftypefun
-
-@deftypefun void rl_function_dumper (int readable)
-Print the readline function names and the key sequences currently
-bound to them to @code{rl_outstream}.  If @var{readable} is non-zero,
-the list is formatted in such a way that it can be made part of an
-@code{inputrc} file and re-read.
-@end deftypefun
-
-@deftypefun void rl_list_funmap_names (void)
-Print the names of all bindable Readline functions to @code{rl_outstream}.
-@end deftypefun
-
-@deftypefun {const char **} rl_funmap_names (void)
-Return a NULL terminated array of known function names.  The array is
-sorted.  The array itself is allocated, but not the strings inside.  You
-should @code{free()} the array when you are done, but not the pointers.
-@end deftypefun
-
-@deftypefun int rl_add_funmap_entry (const char *name, rl_command_func_t *function)
-Add @var{name} to the list of bindable Readline command names, and make
-@var{function} the function to be called when @var{name} is invoked.
-@end deftypefun
-
-@node Allowing Undoing
-@subsection Allowing Undoing
-
-Supporting the undo command is a painless thing, and makes your
-functions much more useful.  It is certainly easy to try
-something if you know you can undo it.
-
-If your function simply inserts text once, or deletes text once, and
-uses @code{rl_insert_text()} or @code{rl_delete_text()} to do it, then
-undoing is already done for you automatically.
-
-If you do multiple insertions or multiple deletions, or any combination
-of these operations, you should group them together into one operation.
-This is done with @code{rl_begin_undo_group()} and
-@code{rl_end_undo_group()}.
-
-The types of events that can be undone are:
-
-@example
-enum undo_code @{ UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END @}; 
-@end example
-
-Notice that @code{UNDO_DELETE} means to insert some text, and
-@code{UNDO_INSERT} means to delete some text.  That is, the undo code
-tells what to undo, not how to undo it.  @code{UNDO_BEGIN} and
-@code{UNDO_END} are tags added by @code{rl_begin_undo_group()} and
-@code{rl_end_undo_group()}.
-
-@deftypefun int rl_begin_undo_group (void)
-Begins saving undo information in a group construct.  The undo
-information usually comes from calls to @code{rl_insert_text()} and
-@code{rl_delete_text()}, but could be the result of calls to
-@code{rl_add_undo()}.
-@end deftypefun
-
-@deftypefun int rl_end_undo_group (void)
-Closes the current undo group started with @code{rl_begin_undo_group
-()}.  There should be one call to @code{rl_end_undo_group()}
-for each call to @code{rl_begin_undo_group()}.
-@end deftypefun
-
-@deftypefun void rl_add_undo (enum undo_code what, int start, int end, char *text)
-Remember how to undo an event (according to @var{what}).  The affected
-text runs from @var{start} to @var{end}, and encompasses @var{text}.
-@end deftypefun
-
-@deftypefun void rl_free_undo_list (void)
-Free the existing undo list.
-@end deftypefun
-
-@deftypefun int rl_do_undo (void)
-Undo the first thing on the undo list.  Returns @code{0} if there was
-nothing to undo, non-zero if something was undone.
-@end deftypefun
-
-Finally, if you neither insert nor delete text, but directly modify the
-existing text (e.g., change its case), call @code{rl_modifying()}
-once, just before you modify the text.  You must supply the indices of
-the text range that you are going to modify.
-
-@deftypefun int rl_modifying (int start, int end)
-Tell Readline to save the text between @var{start} and @var{end} as a
-single undo unit.  It is assumed that you will subsequently modify
-that text.
-@end deftypefun
-
-@node Redisplay
-@subsection Redisplay
-
-@deftypefun void rl_redisplay (void)
-Change what's displayed on the screen to reflect the current contents
-of @code{rl_line_buffer}.
-@end deftypefun
-
-@deftypefun int rl_forced_update_display (void)
-Force the line to be updated and redisplayed, whether or not
-Readline thinks the screen display is correct.
-@end deftypefun
-
-@deftypefun int rl_on_new_line (void)
-Tell the update functions that we have moved onto a new (empty) line,
-usually after ouputting a newline.
-@end deftypefun
-
-@deftypefun int rl_on_new_line_with_prompt (void)
-Tell the update functions that we have moved onto a new line, with
-@var{rl_prompt} already displayed.
-This could be used by applications that want to output the prompt string
-themselves, but still need Readline to know the prompt string length for
-redisplay.
-It should be used after setting @var{rl_already_prompted}.
-@end deftypefun
-
-@deftypefun int rl_reset_line_state (void)
-Reset the display state to a clean state and redisplay the current line
-starting on a new line.
-@end deftypefun
-
-@deftypefun int rl_crlf (void)
-Move the cursor to the start of the next screen line.
-@end deftypefun
-
-@deftypefun int rl_show_char (int c)
-Display character @var{c} on @code{rl_outstream}.
-If Readline has not been set to display meta characters directly, this
-will convert meta characters to a meta-prefixed key sequence.
-This is intended for use by applications which wish to do their own
-redisplay.
-@end deftypefun
-
-@deftypefun int rl_message (const char *, @dots{})
-The arguments are a format string as would be supplied to @code{printf},
-possibly containing conversion specifications such as @samp{%d}, and
-any additional arguments necessary to satisfy the conversion specifications.
-The resulting string is displayed in the @dfn{echo area}.  The echo area
-is also used to display numeric arguments and search strings.
-@end deftypefun
-
-@deftypefun int rl_clear_message (void)
-Clear the message in the echo area.
-@end deftypefun
-
-@deftypefun void rl_save_prompt (void)
-Save the local Readline prompt display state in preparation for
-displaying a new message in the message area with @code{rl_message()}.
-@end deftypefun
-
-@deftypefun void rl_restore_prompt (void)
-Restore the local Readline prompt display state saved by the most
-recent call to @code{rl_save_prompt}.
-@end deftypefun
-
-@deftypefun int rl_expand_prompt (char *prompt)
-Expand any special character sequences in @var{prompt} and set up the
-local Readline prompt redisplay variables.
-This function is called by @code{readline()}.  It may also be called to
-expand the primary prompt if the @code{rl_on_new_line_with_prompt()}
-function or @code{rl_already_prompted} variable is used.
-It returns the number of visible characters on the last line of the
-(possibly multi-line) prompt.
-@end deftypefun
-
-@deftypefun int rl_set_prompt (const char *prompt)
-Make Readline use @var{prompt} for subsequent redisplay.  This calls
-@code{rl_expand_prompt()} to expand the prompt and sets @code{rl_prompt}
-to the result.
-@end deftypefun
-
-@node Modifying Text
-@subsection Modifying Text
-
-@deftypefun int rl_insert_text (const char *text)
-Insert @var{text} into the line at the current cursor position.
-@end deftypefun
-
-@deftypefun int rl_delete_text (int start, int end)
-Delete the text between @var{start} and @var{end} in the current line.
-@end deftypefun
-
-@deftypefun {char *} rl_copy_text (int start, int end)
-Return a copy of the text between @var{start} and @var{end} in
-the current line.
-@end deftypefun
-
-@deftypefun int rl_kill_text (int start, int end)
-Copy the text between @var{start} and @var{end} in the current line
-to the kill ring, appending or prepending to the last kill if the
-last command was a kill command.  The text is deleted.
-If @var{start} is less than @var{end},
-the text is appended, otherwise prepended.  If the last command was
-not a kill, a new kill ring slot is used.
-@end deftypefun
-
-@deftypefun int rl_push_macro_input (char *macro)
-Cause @var{macro} to be inserted into the line, as if it had been invoked
-by a key bound to a macro.  Not especially useful; use
-@code{rl_insert_text()} instead.
-@end deftypefun
-
-@node Character Input
-@subsection Character Input
-
-@deftypefun int rl_read_key (void)
-Return the next character available from Readline's current input stream.
-This handles input inserted into
-the input stream via @var{rl_pending_input} (@pxref{Readline Variables})
-and @code{rl_stuff_char()}, macros, and characters read from the keyboard.
-While waiting for input, this function will call any function assigned to
-the @code{rl_event_hook} variable.
-@end deftypefun
-
-@deftypefun int rl_getc (FILE *stream)
-Return the next character available from @var{stream}, which is assumed to
-be the keyboard.
-@end deftypefun
-
-@deftypefun int rl_stuff_char (int c)
-Insert @var{c} into the Readline input stream.  It will be "read"
-before Readline attempts to read characters from the terminal with
-@code{rl_read_key()}.
-@end deftypefun
-
-@deftypefun int rl_execute_next (int c)
-Make @var{c} be the next command to be executed when @code{rl_read_key()}
-is called.  This sets @var{rl_pending_input}.
-@end deftypefun
-
-@deftypefun int rl_clear_pending_input (void)
-Unset @var{rl_pending_input}, effectively negating the effect of any
-previous call to @code{rl_execute_next()}.  This works only if the
-pending input has not already been read with @code{rl_read_key()}.
-@end deftypefun
-
-@deftypefun int rl_set_keyboard_input_timeout (int u)
-While waiting for keyboard input in @code{rl_read_key()}, Readline will
-wait for @var{u} microseconds for input before calling any function
-assigned to @code{rl_event_hook}.  The default waiting period is
-one-tenth of a second.  Returns the old timeout value.
-@end deftypefun
-
-@node Terminal Management
-@subsection Terminal Management
-
-@deftypefun void rl_prep_terminal (int meta_flag)
-Modify the terminal settings for Readline's use, so @code{readline()}
-can read a single character at a time from the keyboard.
-The @var{meta_flag} argument should be non-zero if Readline should
-read eight-bit input.
-@end deftypefun
-
-@deftypefun void rl_deprep_terminal (void)
-Undo the effects of @code{rl_prep_terminal()}, leaving the terminal in
-the state in which it was before the most recent call to
-@code{rl_prep_terminal()}.
-@end deftypefun
-
-@deftypefun void rl_tty_set_default_bindings (Keymap kmap)
-Read the operating system's terminal editing characters (as would be displayed
-by @code{stty}) to their Readline equivalents.  The bindings are performed
-in @var{kmap}.
-@end deftypefun
-
-@deftypefun int rl_reset_terminal (const char *terminal_name)
-Reinitialize Readline's idea of the terminal settings using
-@var{terminal_name} as the terminal type (e.g., @code{vt100}).
-If @var{terminal_name} is @code{NULL}, the value of the @code{TERM}
-environment variable is used.
-@end deftypefun
-
-@node Utility Functions
-@subsection Utility Functions
-
-@deftypefun int rl_extend_line_buffer (int len)
-Ensure that @code{rl_line_buffer} has enough space to hold @var{len}
-characters, possibly reallocating it if necessary.
-@end deftypefun
-
-@deftypefun int rl_initialize (void)
-Initialize or re-initialize Readline's internal state.
-It's not strictly necessary to call this; @code{readline()} calls it before
-reading any input.
-@end deftypefun
-
-@deftypefun int rl_ding (void)
-Ring the terminal bell, obeying the setting of @code{bell-style}.
-@end deftypefun
-
-@deftypefun int rl_alphabetic (int c)
-Return 1 if @var{c} is an alphabetic character.
-@end deftypefun
-
-@deftypefun void rl_display_match_list (char **matches, int len, int max)
-A convenience function for displaying a list of strings in
-columnar format on Readline's output stream.  @code{matches} is the list
-of strings, in argv format, such as a list of completion matches.
-@code{len} is the number of strings in @code{matches}, and @code{max}
-is the length of the longest string in @code{matches}.  This function uses
-the setting of @code{print-completions-horizontally} to select how the
-matches are displayed (@pxref{Readline Init File Syntax}).
-@end deftypefun
-
-The following are implemented as macros, defined in @code{chardefs.h}.
-Applications should refrain from using them.
-
-@deftypefun int _rl_uppercase_p (int c)
-Return 1 if @var{c} is an uppercase alphabetic character.
-@end deftypefun
-
-@deftypefun int _rl_lowercase_p (int c)
-Return 1 if @var{c} is a lowercase alphabetic character.
-@end deftypefun
-
-@deftypefun int _rl_digit_p (int c)
-Return 1 if @var{c} is a numeric character.
-@end deftypefun
-
-@deftypefun int _rl_to_upper (int c)
-If @var{c} is a lowercase alphabetic character, return the corresponding
-uppercase character.
-@end deftypefun
-
-@deftypefun int _rl_to_lower (int c)
-If @var{c} is an uppercase alphabetic character, return the corresponding
-lowercase character.
-@end deftypefun
-
-@deftypefun int _rl_digit_value (int c)
-If @var{c} is a number, return the value it represents.
-@end deftypefun
-
-@node Miscellaneous Functions
-@subsection Miscellaneous Functions
-
-@deftypefun int rl_macro_bind (const char *keyseq, const char *macro, Keymap map)
-Bind the key sequence @var{keyseq} to invoke the macro @var{macro}.
-The binding is performed in @var{map}.  When @var{keyseq} is invoked, the
-@var{macro} will be inserted into the line.  This function is deprecated;
-use @code{rl_generic_bind()} instead.
-@end deftypefun
-
-@deftypefun void rl_macro_dumper (int readable)
-Print the key sequences bound to macros and their values, using
-the current keymap, to @code{rl_outstream}.
-If @var{readable} is non-zero, the list is formatted in such a way
-that it can be made part of an @code{inputrc} file and re-read.
-@end deftypefun
-
-@deftypefun int rl_variable_bind (const char *variable, const char *value)
-Make the Readline variable @var{variable} have @var{value}.
-This behaves as if the readline command
-@samp{set @var{variable} @var{value}} had been executed in an @code{inputrc}
-file (@pxref{Readline Init File Syntax}).
-@end deftypefun
-
-@deftypefun void rl_variable_dumper (int readable)
-Print the readline variable names and their current values
-to @code{rl_outstream}.
-If @var{readable} is non-zero, the list is formatted in such a way
-that it can be made part of an @code{inputrc} file and re-read.
-@end deftypefun
-
-@deftypefun int rl_set_paren_blink_timeout (int u)
-Set the time interval (in microseconds) that Readline waits when showing
-a balancing character when @code{blink-matching-paren} has been enabled.
-@end deftypefun
-
-@node Alternate Interface
-@subsection Alternate Interface
-
-An alternate interface is available to plain @code{readline()}.  Some
-applications need to interleave keyboard I/O with file, device, or
-window system I/O, typically by using a main loop to @code{select()}
-on various file descriptors.  To accomodate this need, readline can
-also be invoked as a `callback' function from an event loop.  There
-are functions available to make this easy.
-
-@deftypefun void rl_callback_handler_install (const char *prompt, rl_vcpfunc_t *lhandler)
-Set up the terminal for readline I/O and display the initial
-expanded value of @var{prompt}.  Save the value of @var{lhandler} to
-use as a function to call when a complete line of input has been entered.
-The function takes the text of the line as an argument.
-@end deftypefun
-
-@deftypefun void rl_callback_read_char (void)
-Whenever an application determines that keyboard input is available, it
-should call @code{rl_callback_read_char()}, which will read the next
-character from the current input source.  If that character completes the
-line, @code{rl_callback_read_char} will invoke the @var{lhandler}
-function saved by @code{rl_callback_handler_install} to process the
-line.  @code{EOF} is  indicated by calling @var{lhandler} with a
-@code{NULL} line.
-@end deftypefun
-
-@deftypefun void rl_callback_handler_remove (void)
-Restore the terminal to its initial state and remove the line handler.
-This may be called from within a callback as well as independently.
-@end deftypefun
-
-@node A Readline Example
-@subsection A Readline Example
-
-Here is a function which changes lowercase characters to their uppercase
-equivalents, and uppercase characters to lowercase.  If
-this function was bound to @samp{M-c}, then typing @samp{M-c} would
-change the case of the character under point.  Typing @samp{M-1 0 M-c}
-would change the case of the following 10 characters, leaving the cursor on
-the last character changed.
-
-@example
-/* Invert the case of the COUNT following characters. */
-int
-invert_case_line (count, key)
-     int count, key;
-@{
-  register int start, end, i;
-
-  start = rl_point;
-
-  if (rl_point >= rl_end)
-    return (0);
-
-  if (count < 0)
-    @{
-      direction = -1;
-      count = -count;
-    @}
-  else
-    direction = 1;
-      
-  /* Find the end of the range to modify. */
-  end = start + (count * direction);
-
-  /* Force it to be within range. */
-  if (end > rl_end)
-    end = rl_end;
-  else if (end < 0)
-    end = 0;
-
-  if (start == end)
-    return (0);
-
-  if (start > end)
-    @{
-      int temp = start;
-      start = end;
-      end = temp;
-    @}
-
-  /* Tell readline that we are modifying the line, so it will save
-     the undo information. */
-  rl_modifying (start, end);
-
-  for (i = start; i != end; i++)
-    @{
-      if (_rl_uppercase_p (rl_line_buffer[i]))
-        rl_line_buffer[i] = _rl_to_lower (rl_line_buffer[i]);
-      else if (_rl_lowercase_p (rl_line_buffer[i]))
-        rl_line_buffer[i] = _rl_to_upper (rl_line_buffer[i]);
-    @}
-  /* Move point to on top of the last character changed. */
-  rl_point = (direction == 1) ? end - 1 : start;
-  return (0);
-@}
-@end example
-
-@node Readline Signal Handling
-@section Readline Signal Handling
-
-Signals are asynchronous events sent to a process by the Unix kernel,
-sometimes on behalf of another process.  They are intended to indicate
-exceptional events, like a user pressing the interrupt key on his terminal,
-or a network connection being broken.  There is a class of signals that can
-be sent to the process currently reading input from the keyboard.  Since
-Readline changes the terminal attributes when it is called, it needs to
-perform special processing when such a signal is received in order to
-restore the terminal to a sane state, or provide application writers with
-functions to do so manually. 
-
-Readline contains an internal signal handler that is installed for a
-number of signals (@code{SIGINT}, @code{SIGQUIT}, @code{SIGTERM},
-@code{SIGALRM}, @code{SIGTSTP}, @code{SIGTTIN}, and @code{SIGTTOU}).
-When one of these signals is received, the signal handler
-will reset the terminal attributes to those that were in effect before
-@code{readline()} was called, reset the signal handling to what it was
-before @code{readline()} was called, and resend the signal to the calling
-application.
-If and when the calling application's signal handler returns, Readline
-will reinitialize the terminal and continue to accept input.
-When a @code{SIGINT} is received, the Readline signal handler performs
-some additional work, which will cause any partially-entered line to be
-aborted (see the description of @code{rl_free_line_state()} below).
-
-There is an additional Readline signal handler, for @code{SIGWINCH}, which
-the kernel sends to a process whenever the terminal's size changes (for
-example, if a user resizes an @code{xterm}).  The Readline @code{SIGWINCH}
-handler updates Readline's internal screen size information, and then calls
-any @code{SIGWINCH} signal handler the calling application has installed. 
-Readline calls the application's @code{SIGWINCH} signal handler without
-resetting the terminal to its original state.  If the application's signal
-handler does more than update its idea of the terminal size and return (for
-example, a @code{longjmp} back to a main processing loop), it @emph{must}
-call @code{rl_cleanup_after_signal()} (described below), to restore the
-terminal state. 
-
-Readline provides two variables that allow application writers to
-control whether or not it will catch certain signals and act on them
-when they are received.  It is important that applications change the
-values of these variables only when calling @code{readline()}, not in
-a signal handler, so Readline's internal signal state is not corrupted.
-
-@deftypevar int rl_catch_signals
-If this variable is non-zero, Readline will install signal handlers for
-@code{SIGINT}, @code{SIGQUIT}, @code{SIGTERM}, @code{SIGALRM},
-@code{SIGTSTP}, @code{SIGTTIN}, and @code{SIGTTOU}.
-
-The default value of @code{rl_catch_signals} is 1.
-@end deftypevar
-
-@deftypevar int rl_catch_sigwinch
-If this variable is non-zero, Readline will install a signal handler for
-@code{SIGWINCH}.
-
-The default value of @code{rl_catch_sigwinch} is 1.
-@end deftypevar
-
-If an application does not wish to have Readline catch any signals, or
-to handle signals other than those Readline catches (@code{SIGHUP},
-for example), 
-Readline provides convenience functions to do the necessary terminal
-and internal state cleanup upon receipt of a signal.
-
-@deftypefun void rl_cleanup_after_signal (void)
-This function will reset the state of the terminal to what it was before
-@code{readline()} was called, and remove the Readline signal handlers for
-all signals, depending on the values of @code{rl_catch_signals} and
-@code{rl_catch_sigwinch}.
-@end deftypefun
-
-@deftypefun void rl_free_line_state (void)
-This will free any partial state associated with the current input line
-(undo information, any partial history entry, any partially-entered
-keyboard macro, and any partially-entered numeric argument).  This
-should be called before @code{rl_cleanup_after_signal()}.  The
-Readline signal handler for @code{SIGINT} calls this to abort the
-current input line.
-@end deftypefun
-
-@deftypefun void rl_reset_after_signal (void)
-This will reinitialize the terminal and reinstall any Readline signal
-handlers, depending on the values of @code{rl_catch_signals} and
-@code{rl_catch_sigwinch}.
-@end deftypefun
-
-If an application does not wish Readline to catch @code{SIGWINCH}, it may
-call @code{rl_resize_terminal()} or @code{rl_set_screen_size()} to force
-Readline to update its idea of the terminal size when a @code{SIGWINCH}
-is received.
-
-@deftypefun void rl_resize_terminal (void)
-Update Readline's internal screen size by reading values from the kernel.
-@end deftypefun
-
-@deftypefun void rl_set_screen_size (int rows, int cols)
-Set Readline's idea of the terminal size to @var{rows} rows and
-@var{cols} columns.
-@end deftypefun
-
-If an application does not want to install a @code{SIGWINCH} handler, but
-is still interested in the screen dimensions, Readline's idea of the screen
-size may be queried.
-
-@deftypefun void rl_get_screen_size (int *rows, int *cols)
-Return Readline's idea of the terminal's size in the
-variables pointed to by the arguments.
-@end deftypefun
-
-The following functions install and remove Readline's signal handlers.
-
-@deftypefun int rl_set_signals (void)
-Install Readline's signal handler for @code{SIGINT}, @code{SIGQUIT},
-@code{SIGTERM}, @code{SIGALRM}, @code{SIGTSTP}, @code{SIGTTIN},
-@code{SIGTTOU}, and @code{SIGWINCH}, depending on the values of
-@code{rl_catch_signals} and @code{rl_catch_sigwinch}.
-@end deftypefun
-
-@deftypefun int rl_clear_signals (void)
-Remove all of the Readline signal handlers installed by
-@code{rl_set_signals()}.
-@end deftypefun
-
-@node Custom Completers
-@section Custom Completers
-
-Typically, a program that reads commands from the user has a way of
-disambiguating commands and data.  If your program is one of these, then
-it can provide completion for commands, data, or both.
-The following sections describe how your program and Readline
-cooperate to provide this service.
-
-@menu
-* How Completing Works::	The logic used to do completion.
-* Completion Functions::	Functions provided by Readline.
-* Completion Variables::	Variables which control completion.
-* A Short Completion Example::	An example of writing completer subroutines.
-@end menu
-
-@node How Completing Works
-@subsection How Completing Works
-
-In order to complete some text, the full list of possible completions
-must be available.  That is, it is not possible to accurately
-expand a partial word without knowing all of the possible words
-which make sense in that context.  The Readline library provides
-the user interface to completion, and two of the most common
-completion functions:  filename and username.  For completing other types
-of text, you must write your own completion function.  This section
-describes exactly what such functions must do, and provides an example.
-
-There are three major functions used to perform completion:
-
-@enumerate
-@item
-The user-interface function @code{rl_complete()}.  This function is
-called with the same arguments as other bindable Readline functions:
-@var{count} and @var{invoking_key}.
-It isolates the word to be completed and calls
-@code{rl_completion_matches()} to generate a list of possible completions.
-It then either lists the possible completions, inserts the possible
-completions, or actually performs the
-completion, depending on which behavior is desired.
-
-@item
-The internal function @code{rl_completion_matches()} uses an
-application-supplied @dfn{generator} function to generate the list of
-possible matches, and then returns the array of these matches.
-The caller should place the address of its generator function in
-@code{rl_completion_entry_function}.
-
-@item
-The generator function is called repeatedly from
-@code{rl_completion_matches()}, returning a string each time.  The
-arguments to the generator function are @var{text} and @var{state}.
-@var{text} is the partial word to be completed.  @var{state} is zero the
-first time the function is called, allowing the generator to perform
-any necessary initialization, and a positive non-zero integer for
-each subsequent call.  The generator function returns
-@code{(char *)NULL} to inform @code{rl_completion_matches()} that there are
-no more possibilities left.  Usually the generator function computes the
-list of possible completions when @var{state} is zero, and returns them
-one at a time on subsequent calls.  Each string the generator function
-returns as a match must be allocated with @code{malloc()}; Readline
-frees the strings when it has finished with them.
-
-@end enumerate
-
-@deftypefun int rl_complete (int ignore, int invoking_key)
-Complete the word at or before point.  You have supplied the function
-that does the initial simple matching selection algorithm (see
-@code{rl_completion_matches()}).  The default is to do filename completion.
-@end deftypefun
-
-@deftypevar {rl_compentry_func_t *} rl_completion_entry_function
-This is a pointer to the generator function for
-@code{rl_completion_matches()}.
-If the value of @code{rl_completion_entry_function} is
-@code{NULL} then the default filename generator
-function, @code{rl_filename_completion_function()}, is used.
-@end deftypevar
-
-@node Completion Functions
-@subsection Completion Functions
-
-Here is the complete list of callable completion functions present in
-Readline.
-
-@deftypefun int rl_complete_internal (int what_to_do)
-Complete the word at or before point.  @var{what_to_do} says what to do
-with the completion.  A value of @samp{?} means list the possible
-completions.  @samp{TAB} means do standard completion.  @samp{*} means
-insert all of the possible completions.  @samp{!} means to display
-all of the possible completions, if there is more than one, as well as
-performing partial completion.
-@end deftypefun
-
-@deftypefun int rl_complete (int ignore, int invoking_key)
-Complete the word at or before point.  You have supplied the function
-that does the initial simple matching selection algorithm (see
-@code{rl_completion_matches()} and @code{rl_completion_entry_function}).
-The default is to do filename
-completion.  This calls @code{rl_complete_internal()} with an
-argument depending on @var{invoking_key}.
-@end deftypefun
-
-@deftypefun int rl_possible_completions (int count, int invoking_key)
-List the possible completions.  See description of @code{rl_complete
-()}.  This calls @code{rl_complete_internal()} with an argument of
-@samp{?}.
-@end deftypefun
-
-@deftypefun int rl_insert_completions (int count, int invoking_key)
-Insert the list of possible completions into the line, deleting the
-partially-completed word.  See description of @code{rl_complete()}.
-This calls @code{rl_complete_internal()} with an argument of @samp{*}.
-@end deftypefun
-
-@deftypefun {char **} rl_completion_matches (const char *text, rl_compentry_func_t *entry_func)
-Returns an array of strings which is a list of completions for
-@var{text}.  If there are no completions, returns @code{NULL}.
-The first entry in the returned array is the substitution for @var{text}.
-The remaining entries are the possible completions.  The array is
-terminated with a @code{NULL} pointer.
-
-@var{entry_func} is a function of two args, and returns a
-@code{char *}.  The first argument is @var{text}.  The second is a
-state argument; it is zero on the first call, and non-zero on subsequent
-calls.  @var{entry_func} returns a @code{NULL}  pointer to the caller
-when there are no more matches.
-@end deftypefun
-
-@deftypefun {char *} rl_filename_completion_function (const char *text, int state)
-A generator function for filename completion in the general case.
-@var{text} is a partial filename.
-The Bash source is a useful reference for writing custom
-completion functions (the Bash completion functions call this and other
-Readline functions).
-@end deftypefun
-
-@deftypefun {char *} rl_username_completion_function (const char *text, int state)
-A completion generator for usernames.  @var{text} contains a partial
-username preceded by a random character (usually @samp{~}).  As with all
-completion generators, @var{state} is zero on the first call and non-zero
-for subsequent calls.
-@end deftypefun
-
-@node Completion Variables
-@subsection Completion Variables
-
-@deftypevar {rl_compentry_func_t *} rl_completion_entry_function
-A pointer to the generator function for @code{rl_completion_matches()}.
-@code{NULL} means to use @code{rl_filename_completion_function()}, the default
-filename completer.
-@end deftypevar
-
-@deftypevar {rl_completion_func_t *} rl_attempted_completion_function
-A pointer to an alternative function to create matches.
-The function is called with @var{text}, @var{start}, and @var{end}.
-@var{start} and @var{end} are indices in @code{rl_line_buffer} defining
-the boundaries of @var{text}, which is a character string.
-If this function exists and returns @code{NULL}, or if this variable is
-set to @code{NULL}, then @code{rl_complete()} will call the value of
-@code{rl_completion_entry_function} to generate matches, otherwise the
-array of strings returned will be used.
-If this function sets the @code{rl_attempted_completion_over}
-variable to a non-zero value, Readline will not perform its default
-completion even if this function returns no matches.
-@end deftypevar
-
-@deftypevar {rl_quote_func_t *} rl_filename_quoting_function
-A pointer to a function that will quote a filename in an
-application-specific fashion.  This is called if filename completion is being
-attempted and one of the characters in @code{rl_filename_quote_characters}
-appears in a completed filename.  The function is called with
-@var{text}, @var{match_type}, and @var{quote_pointer}.  The @var{text}
-is the filename to be quoted.  The @var{match_type} is either
-@code{SINGLE_MATCH}, if there is only one completion match, or
-@code{MULT_MATCH}.  Some functions use this to decide whether or not to
-insert a closing quote character.  The @var{quote_pointer} is a pointer
-to any opening quote character the user typed.  Some functions choose
-to reset this character.
-@end deftypevar
-
-@deftypevar {rl_dequote_func_t *} rl_filename_dequoting_function
-A pointer to a function that will remove application-specific quoting
-characters from a filename before completion is attempted, so those
-characters do not interfere with matching the text against names in
-the filesystem.  It is called with @var{text}, the text of the word
-to be dequoted, and @var{quote_char}, which is the quoting character 
-that delimits the filename (usually @samp{'} or @samp{"}).  If
-@var{quote_char} is zero, the filename was not in an embedded string.
-@end deftypevar
-
-@deftypevar {rl_linebuf_func_t *} rl_char_is_quoted_p
-A pointer to a function to call that determines whether or not a specific
-character in the line buffer is quoted, according to whatever quoting
-mechanism the program calling Readline uses.  The function is called with
-two arguments: @var{text}, the text of the line, and @var{index}, the
-index of the character in the line.  It is used to decide whether a
-character found in @code{rl_completer_word_break_characters} should be
-used to break words for the completer.
-@end deftypevar
-
-@deftypevar int rl_completion_query_items
-Up to this many items will be displayed in response to a
-possible-completions call.  After that, we ask the user if she is sure
-she wants to see them all.  The default value is 100.
-@end deftypevar
-
-@deftypevar {const char *} rl_basic_word_break_characters
-The basic list of characters that signal a break between words for the
-completer routine.  The default value of this variable is the characters
-which break words for completion in Bash:
-@code{" \t\n\"\\'`@@$><=;|&@{("}.
-@end deftypevar
-
-@deftypevar {const char *} rl_basic_quote_characters
-A list of quote characters which can cause a word break.
-@end deftypevar
-
-@deftypevar {const char *} rl_completer_word_break_characters
-The list of characters that signal a break between words for
-@code{rl_complete_internal()}.  The default list is the value of
-@code{rl_basic_word_break_characters}.
-@end deftypevar
-
-@deftypevar {const char *} rl_completer_quote_characters
-A list of characters which can be used to quote a substring of the line.
-Completion occurs on the entire substring, and within the substring
-@code{rl_completer_word_break_characters} are treated as any other character,
-unless they also appear within this list.
-@end deftypevar
-
-@deftypevar {const char *} rl_filename_quote_characters
-A list of characters that cause a filename to be quoted by the completer
-when they appear in a completed filename.  The default is the null string.
-@end deftypevar
-
-@deftypevar {const char *} rl_special_prefixes
-The list of characters that are word break characters, but should be
-left in @var{text} when it is passed to the completion function.
-Programs can use this to help determine what kind of completing to do.
-For instance, Bash sets this variable to "$@@" so that it can complete
-shell variables and hostnames.
-@end deftypevar
-
-@deftypevar {int} rl_completion_append_character
-When a single completion alternative matches at the end of the command
-line, this character is appended to the inserted completion text.  The
-default is a space character (@samp{ }).  Setting this to the null
-character (@samp{\0}) prevents anything being appended automatically.
-This can be changed in custom completion functions to
-provide the ``most sensible word separator character'' according to
-an application-specific command line syntax specification.
-@end deftypevar
-
-@deftypevar int rl_ignore_completion_duplicates
-If non-zero, then duplicates in the matches are removed.
-The default is 1.
-@end deftypevar
-
-@deftypevar int rl_filename_completion_desired
-Non-zero means that the results of the matches are to be treated as
-filenames.  This is @emph{always} zero on entry, and can only be changed
-within a completion entry generator function.  If it is set to a non-zero
-value, directory names have a slash appended and Readline attempts to
-quote completed filenames if they contain any characters in
-@code{rl_filename_quote_characters} and @code{rl_filename_quoting_desired}
-is set to a non-zero value.
-@end deftypevar
-
-@deftypevar int rl_filename_quoting_desired
-Non-zero means that the results of the matches are to be quoted using
-double quotes (or an application-specific quoting mechanism) if the
-completed filename contains any characters in
-@code{rl_filename_quote_chars}.  This is @emph{always} non-zero
-on entry, and can only be changed within a completion entry generator
-function.  The quoting is effected via a call to the function pointed to
-by @code{rl_filename_quoting_function}.
-@end deftypevar
-
-@deftypevar int rl_attempted_completion_over
-If an application-specific completion function assigned to
-@code{rl_attempted_completion_function} sets this variable to a non-zero
-value, Readline will not perform its default filename completion even
-if the application's completion function returns no matches.
-It should be set only by an application's completion function.
-@end deftypevar
-
-@deftypevar int rl_completion_type
-Set to a character describing the type of completion Readline is currently
-attempting; see the description of @code{rl_complete_internal()}
-(@pxref{Completion Functions}) for the list of characters.
-@end deftypevar
-
-@deftypevar int rl_inhibit_completion
-If this variable is non-zero, completion is inhibited.  The completion
-character will be inserted as any other bound to @code{self-insert}.
-@end deftypevar
-
-@deftypevar {rl_compignore_func_t *} rl_ignore_some_completions_function
-This function, if defined, is called by the completer when real filename
-completion is done, after all the matching names have been generated.
-It is passed a @code{NULL} terminated array of matches.
-The first element (@code{matches[0]}) is the
-maximal substring common to all matches. This function can
-re-arrange the list of matches as required, but each element deleted
-from the array must be freed.
-@end deftypevar
-
-@deftypevar {rl_icppfunc_t *} rl_directory_completion_hook
-This function, if defined, is allowed to modify the directory portion
-of filenames Readline completes.  It is called with the address of a
-string (the current directory name) as an argument, and may modify that string.
-If the string is replaced with a new string, the old value should be freed.
-Any modified directory name should have a trailing slash.
-The modified value will be displayed as part of the completion, replacing
-the directory portion of the pathname the user typed.
-It returns an integer that should be non-zero if the function modifies
-its directory argument.
-It could be used to expand symbolic links or shell variables in pathnames.
-@end deftypevar
-
-@deftypevar {rl_compdisp_func_t *} rl_completion_display_matches_hook
-If non-zero, then this is the address of a function to call when
-completing a word would normally display the list of possible matches.
-This function is called in lieu of Readline displaying the list.
-It takes three arguments:
-(@code{char **}@var{matches}, @code{int} @var{num_matches}, @code{int} @var{max_length})
-where @var{matches} is the array of matching strings,
-@var{num_matches} is the number of strings in that array, and
-@var{max_length} is the length of the longest string in that array.
-Readline provides a convenience function, @code{rl_display_match_list},
-that takes care of doing the display to Readline's output stream.  That
-function may be called from this hook.
-@end deftypevar
-
-@node A Short Completion Example
-@subsection A Short Completion Example
-
-Here is a small application demonstrating the use of the GNU Readline
-library.  It is called @code{fileman}, and the source code resides in
-@file{examples/fileman.c}.  This sample application provides
-completion of command names, line editing features, and access to the
-history list.
-
-@page
-@smallexample
-/* fileman.c -- A tiny application which demonstrates how to use the
-   GNU Readline library.  This application interactively allows users
-   to manipulate files and their modes. */
-
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/file.h>
-#include <sys/stat.h>
-#include <sys/errno.h>
-
-#include <readline/readline.h>
-#include <readline/history.h>
-
-extern char *xmalloc ();
-
-/* The names of functions that actually do the manipulation. */
-int com_list __P((char *));
-int com_view __P((char *));
-int com_rename __P((char *));
-int com_stat __P((char *));
-int com_pwd __P((char *));
-int com_delete __P((char *));
-int com_help __P((char *));
-int com_cd __P((char *));
-int com_quit __P((char *));
-
-/* A structure which contains information on the commands this program
-   can understand. */
-
-typedef struct @{
-  char *name;			/* User printable name of the function. */
-  rl_icpfunc_t *func;		/* Function to call to do the job. */
-  char *doc;			/* Documentation for this function.  */
-@} COMMAND;
-
-COMMAND commands[] = @{
-  @{ "cd", com_cd, "Change to directory DIR" @},
-  @{ "delete", com_delete, "Delete FILE" @},
-  @{ "help", com_help, "Display this text" @},
-  @{ "?", com_help, "Synonym for `help'" @},
-  @{ "list", com_list, "List files in DIR" @},
-  @{ "ls", com_list, "Synonym for `list'" @},
-  @{ "pwd", com_pwd, "Print the current working directory" @},
-  @{ "quit", com_quit, "Quit using Fileman" @},
-  @{ "rename", com_rename, "Rename FILE to NEWNAME" @},
-  @{ "stat", com_stat, "Print out statistics on FILE" @},
-  @{ "view", com_view, "View the contents of FILE" @},
-  @{ (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL @}
-@};
-
-/* Forward declarations. */
-char *stripwhite ();
-COMMAND *find_command ();
-
-/* The name of this program, as taken from argv[0]. */
-char *progname;
-
-/* When non-zero, this means the user is done using this program. */
-int done;
-
-char *
-dupstr (s)
-     int s;
-@{
-  char *r;
-
-  r = xmalloc (strlen (s) + 1);
-  strcpy (r, s);
-  return (r);
-@}
-
-main (argc, argv)
-     int argc;
-     char **argv;
-@{
-  char *line, *s;
-
-  progname = argv[0];
-
-  initialize_readline ();	/* Bind our completer. */
-
-  /* Loop reading and executing lines until the user quits. */
-  for ( ; done == 0; )
-    @{
-      line = readline ("FileMan: ");
-
-      if (!line)
-        break;
-
-      /* Remove leading and trailing whitespace from the line.
-         Then, if there is anything left, add it to the history list
-         and execute it. */
-      s = stripwhite (line);
-
-      if (*s)
-        @{
-          add_history (s);
-          execute_line (s);
-        @}
-
-      free (line);
-    @}
-  exit (0);
-@}
-
-/* Execute a command line. */
-int
-execute_line (line)
-     char *line;
-@{
-  register int i;
-  COMMAND *command;
-  char *word;
-
-  /* Isolate the command word. */
-  i = 0;
-  while (line[i] && whitespace (line[i]))
-    i++;
-  word = line + i;
-
-  while (line[i] && !whitespace (line[i]))
-    i++;
-
-  if (line[i])
-    line[i++] = '\0';
-
-  command = find_command (word);
-
-  if (!command)
-    @{
-      fprintf (stderr, "%s: No such command for FileMan.\n", word);
-      return (-1);
-    @}
-
-  /* Get argument to command, if any. */
-  while (whitespace (line[i]))
-    i++;
-
-  word = line + i;
-
-  /* Call the function. */
-  return ((*(command->func)) (word));
-@}
-
-/* Look up NAME as the name of a command, and return a pointer to that
-   command.  Return a NULL pointer if NAME isn't a command name. */
-COMMAND *
-find_command (name)
-     char *name;
-@{
-  register int i;
-
-  for (i = 0; commands[i].name; i++)
-    if (strcmp (name, commands[i].name) == 0)
-      return (&commands[i]);
-
-  return ((COMMAND *)NULL);
-@}
-
-/* Strip whitespace from the start and end of STRING.  Return a pointer
-   into STRING. */
-char *
-stripwhite (string)
-     char *string;
-@{
-  register char *s, *t;
-
-  for (s = string; whitespace (*s); s++)
-    ;
-    
-  if (*s == 0)
-    return (s);
-
-  t = s + strlen (s) - 1;
-  while (t > s && whitespace (*t))
-    t--;
-  *++t = '\0';
-
-  return s;
-@}
-
-/* **************************************************************** */
-/*                                                                  */
-/*                  Interface to Readline Completion                */
-/*                                                                  */
-/* **************************************************************** */
-
-char *command_generator __P((const char *, int));
-char **fileman_completion __P((const char *, int, int));
-
-/* Tell the GNU Readline library how to complete.  We want to try to
-   complete on command names if this is the first word in the line, or
-   on filenames if not. */
-initialize_readline ()
-@{
-  /* Allow conditional parsing of the ~/.inputrc file. */
-  rl_readline_name = "FileMan";
-
-  /* Tell the completer that we want a crack first. */
-  rl_attempted_completion_function = fileman_completion;
-@}
-
-/* Attempt to complete on the contents of TEXT.  START and END
-   bound the region of rl_line_buffer that contains the word to
-   complete.  TEXT is the word to complete.  We can use the entire
-   contents of rl_line_buffer in case we want to do some simple
-   parsing.  Returnthe array of matches, or NULL if there aren't any. */
-char **
-fileman_completion (text, start, end)
-     const char *text;
-     int start, end;
-@{
-  char **matches;
-
-  matches = (char **)NULL;
-
-  /* If this word is at the start of the line, then it is a command
-     to complete.  Otherwise it is the name of a file in the current
-     directory. */
-  if (start == 0)
-    matches = rl_completion_matches (text, command_generator);
-
-  return (matches);
-@}
-
-/* Generator function for command completion.  STATE lets us
-   know whether to start from scratch; without any state
-   (i.e. STATE == 0), then we start at the top of the list. */
-char *
-command_generator (text, state)
-     const char *text;
-     int state;
-@{
-  static int list_index, len;
-  char *name;
-
-  /* If this is a new word to complete, initialize now.  This
-     includes saving the length of TEXT for efficiency, and
-     initializing the index variable to 0. */
-  if (!state)
-    @{
-      list_index = 0;
-      len = strlen (text);
-    @}
-
-  /* Return the next name which partially matches from the
-     command list. */
-  while (name = commands[list_index].name)
-    @{
-      list_index++;
-
-      if (strncmp (name, text, len) == 0)
-        return (dupstr(name));
-    @}
-
-  /* If no names matched, then return NULL. */
-  return ((char *)NULL);
-@}
-
-/* **************************************************************** */
-/*                                                                  */
-/*                       FileMan Commands                           */
-/*                                                                  */
-/* **************************************************************** */
-
-/* String to pass to system ().  This is for the LIST, VIEW and RENAME
-   commands. */
-static char syscom[1024];
-
-/* List the file(s) named in arg. */
-com_list (arg)
-     char *arg;
-@{
-  if (!arg)
-    arg = "";
-
-  sprintf (syscom, "ls -FClg %s", arg);
-  return (system (syscom));
-@}
-
-com_view (arg)
-     char *arg;
-@{
-  if (!valid_argument ("view", arg))
-    return 1;
-
-  sprintf (syscom, "more %s", arg);
-  return (system (syscom));
-@}
-
-com_rename (arg)
-     char *arg;
-@{
-  too_dangerous ("rename");
-  return (1);
-@}
-
-com_stat (arg)
-     char *arg;
-@{
-  struct stat finfo;
-
-  if (!valid_argument ("stat", arg))
-    return (1);
-
-  if (stat (arg, &finfo) == -1)
-    @{
-      perror (arg);
-      return (1);
-    @}
-
-  printf ("Statistics for `%s':\n", arg);
-
-  printf ("%s has %d link%s, and is %d byte%s in length.\n", arg,
-          finfo.st_nlink,
-          (finfo.st_nlink == 1) ? "" : "s",
-          finfo.st_size,
-          (finfo.st_size == 1) ? "" : "s");
-  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
-  printf ("      Last access at: %s", ctime (&finfo.st_atime));
-  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
-  return (0);
-@}
-
-com_delete (arg)
-     char *arg;
-@{
-  too_dangerous ("delete");
-  return (1);
-@}
-
-/* Print out help for ARG, or for all of the commands if ARG is
-   not present. */
-com_help (arg)
-     char *arg;
-@{
-  register int i;
-  int printed = 0;
-
-  for (i = 0; commands[i].name; i++)
-    @{
-      if (!*arg || (strcmp (arg, commands[i].name) == 0))
-        @{
-          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
-          printed++;
-        @}
-    @}
-
-  if (!printed)
-    @{
-      printf ("No commands match `%s'.  Possibilties are:\n", arg);
-
-      for (i = 0; commands[i].name; i++)
-        @{
-          /* Print in six columns. */
-          if (printed == 6)
-            @{
-              printed = 0;
-              printf ("\n");
-            @}
-
-          printf ("%s\t", commands[i].name);
-          printed++;
-        @}
-
-      if (printed)
-        printf ("\n");
-    @}
-  return (0);
-@}
-
-/* Change to the directory ARG. */
-com_cd (arg)
-     char *arg;
-@{
-  if (chdir (arg) == -1)
-    @{
-      perror (arg);
-      return 1;
-    @}
-
-  com_pwd ("");
-  return (0);
-@}
-
-/* Print out the current working directory. */
-com_pwd (ignore)
-     char *ignore;
-@{
-  char dir[1024], *s;
-
-  s = getcwd (dir, sizeof(dir) - 1);
-  if (s == 0)
-    @{
-      printf ("Error getting pwd: %s\n", dir);
-      return 1;
-    @}
-
-  printf ("Current directory is %s\n", dir);
-  return 0;
-@}
-
-/* The user wishes to quit using this program.  Just set DONE
-   non-zero. */
-com_quit (arg)
-     char *arg;
-@{
-  done = 1;
-  return (0);
-@}
-
-/* Function which tells you that you can't do this. */
-too_dangerous (caller)
-     char *caller;
-@{
-  fprintf (stderr,
-           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
-           caller);
-@}
-
-/* Return non-zero if ARG is a valid argument for CALLER, else print
-   an error message and return zero. */
-int
-valid_argument (caller, arg)
-     char *caller, *arg;
-@{
-  if (!arg || !*arg)
-    @{
-      fprintf (stderr, "%s: Argument required.\n", caller);
-      return (0);
-    @}
-
-  return (1);
-@}
-@end smallexample
diff --git a/readline/doc/rluser.texinfo b/readline/doc/rluser.texinfo
deleted file mode 100644
--- a/readline/doc/rluser.texinfo
+++ /dev/null
@@ -1,1702 +0,0 @@
-@comment %**start of header (This is for running Texinfo on a region.)
-@setfilename rluser.info
-@comment %**end of header (This is for running Texinfo on a region.)
-@setchapternewpage odd
-
-@ignore
-This file documents the end user interface to the GNU command line
-editing features.  It is to be an appendix to manuals for programs which
-use these features.  There is a document entitled "readline.texinfo"
-which contains both end-user and programmer documentation for the
-GNU Readline Library.
-
-Copyright (C) 1988-2000 Free Software Foundation, Inc.
-
-Authored by Brian Fox and Chet Ramey.
-
-Permission is granted to process this file through Tex and print the
-results, provided the printed document carries copying permission notice
-identical to this one except for the removal of this paragraph (this
-paragraph not being relevant to the printed manual).
-
-Permission is granted to make and distribute verbatim copies of this manual
-provided the copyright notice and this permission notice are preserved on
-all copies.
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided also that the
-GNU Copyright statement is available to the distributee, and provided that
-the entire resulting derived work is distributed under the terms of a
-permission notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions.
-@end ignore
-
-@comment If you are including this manual as an appendix, then set the
-@comment variable readline-appendix.
-
-@ifclear BashFeatures
-@defcodeindex bt
-@end ifclear
-
-@node Command Line Editing
-@chapter Command Line Editing
-
-This chapter describes the basic features of the @sc{gnu}
-command line editing interface.
-@ifset BashFeatures
-Command line editing is provided by the Readline library, which is
-used by several different programs, including Bash.
-@end ifset
-
-@menu
-* Introduction and Notation::	Notation used in this text.
-* Readline Interaction::	The minimum set of commands for editing a line.
-* Readline Init File::		Customizing Readline from a user's view.
-* Bindable Readline Commands::	A description of most of the Readline commands
-				available for binding
-* Readline vi Mode::		A short description of how to make Readline
-				behave like the vi editor.
-@ifset BashFeatures
-* Programmable Completion::	How to specify the possible completions for
-				a specific command.
-* Programmable Completion Builtins::	Builtin commands to specify how to
-				complete arguments for a particular command.
-@end ifset
-@end menu
-
-@node Introduction and Notation
-@section Introduction to Line Editing
-
-The following paragraphs describe the notation used to represent
-keystrokes.
-
-The text @kbd{C-k} is read as `Control-K' and describes the character
-produced when the @key{k} key is pressed while the Control key
-is depressed.
-
-The text @kbd{M-k} is read as `Meta-K' and describes the character
-produced when the Meta key (if you have one) is depressed, and the @key{k}
-key is pressed.
-The Meta key is labeled @key{ALT} on many keyboards.
-On keyboards with two keys labeled @key{ALT} (usually to either side of
-the space bar), the @key{ALT} on the left side is generally set to
-work as a Meta key.
-The @key{ALT} key on the right may also be configured to work as a
-Meta key or may be configured as some other modifier, such as a
-Compose key for typing accented characters.
-
-If you do not have a Meta or @key{ALT} key, or another key working as
-a Meta key, the identical keystroke can be generated by typing @key{ESC}
-@emph{first}, and then typing @key{k}.
-Either process is known as @dfn{metafying} the @key{k} key.
-
-The text @kbd{M-C-k} is read as `Meta-Control-k' and describes the
-character produced by @dfn{metafying} @kbd{C-k}.
-
-In addition, several keys have their own names.  Specifically,
-@key{DEL}, @key{ESC}, @key{LFD}, @key{SPC}, @key{RET}, and @key{TAB} all
-stand for themselves when seen in this text, or in an init file
-(@pxref{Readline Init File}).
-If your keyboard lacks a @key{LFD} key, typing @key{C-j} will
-produce the desired character.
-The @key{RET} key may be labeled @key{Return} or @key{Enter} on
-some keyboards.
-
-@node Readline Interaction
-@section Readline Interaction
-@cindex interaction, readline
-
-Often during an interactive session you type in a long line of text,
-only to notice that the first word on the line is misspelled.  The
-Readline library gives you a set of commands for manipulating the text
-as you type it in, allowing you to just fix your typo, and not forcing
-you to retype the majority of the line.  Using these editing commands,
-you move the cursor to the place that needs correction, and delete or
-insert the text of the corrections.  Then, when you are satisfied with
-the line, you simply press @key{RET}.  You do not have to be at the
-end of the line to press @key{RET}; the entire line is accepted
-regardless of the location of the cursor within the line.
-
-@menu
-* Readline Bare Essentials::	The least you need to know about Readline.
-* Readline Movement Commands::	Moving about the input line.
-* Readline Killing Commands::	How to delete text, and how to get it back!
-* Readline Arguments::		Giving numeric arguments to commands.
-* Searching::			Searching through previous lines.
-@end menu
-
-@node Readline Bare Essentials
-@subsection Readline Bare Essentials
-@cindex notation, readline
-@cindex command editing
-@cindex editing command lines
-
-In order to enter characters into the line, simply type them.  The typed
-character appears where the cursor was, and then the cursor moves one
-space to the right.  If you mistype a character, you can use your
-erase character to back up and delete the mistyped character.
-
-Sometimes you may mistype a character, and
-not notice the error until you have typed several other characters.  In
-that case, you can type @kbd{C-b} to move the cursor to the left, and then
-correct your mistake.  Afterwards, you can move the cursor to the right
-with @kbd{C-f}.
-
-When you add text in the middle of a line, you will notice that characters
-to the right of the cursor are `pushed over' to make room for the text
-that you have inserted.  Likewise, when you delete text behind the cursor,
-characters to the right of the cursor are `pulled back' to fill in the
-blank space created by the removal of the text.  A list of the bare
-essentials for editing the text of an input line follows.
-
-@table @asis
-@item @kbd{C-b}
-Move back one character.
-@item @kbd{C-f}
-Move forward one character.
-@item @key{DEL} or @key{Backspace}
-Delete the character to the left of the cursor.
-@item @kbd{C-d}
-Delete the character underneath the cursor.
-@item @w{Printing characters}
-Insert the character into the line at the cursor.
-@item @kbd{C-_} or @kbd{C-x C-u}
-Undo the last editing command.  You can undo all the way back to an
-empty line.
-@end table
-
-@noindent
-(Depending on your configuration, the @key{Backspace} key be set to
-delete the character to the left of the cursor and the @key{DEL} key set
-to delete the character underneath the cursor, like @kbd{C-d}, rather
-than the character to the left of the cursor.)
-
-@node Readline Movement Commands
-@subsection Readline Movement Commands
-
-
-The above table describes the most basic keystrokes that you need
-in order to do editing of the input line.  For your convenience, many
-other commands have been added in addition to @kbd{C-b}, @kbd{C-f},
-@kbd{C-d}, and @key{DEL}.  Here are some commands for moving more rapidly
-about the line.
-
-@table @kbd
-@item C-a
-Move to the start of the line.
-@item C-e
-Move to the end of the line.
-@item M-f
-Move forward a word, where a word is composed of letters and digits.
-@item M-b
-Move backward a word.
-@item C-l
-Clear the screen, reprinting the current line at the top.
-@end table
-
-Notice how @kbd{C-f} moves forward a character, while @kbd{M-f} moves
-forward a word.  It is a loose convention that control keystrokes
-operate on characters while meta keystrokes operate on words.
-
-@node Readline Killing Commands
-@subsection Readline Killing Commands
-
-@cindex killing text
-@cindex yanking text
-
-@dfn{Killing} text means to delete the text from the line, but to save
-it away for later use, usually by @dfn{yanking} (re-inserting)
-it back into the line.
-(`Cut' and `paste' are more recent jargon for `kill' and `yank'.)
-
-If the description for a command says that it `kills' text, then you can
-be sure that you can get the text back in a different (or the same)
-place later.
-
-When you use a kill command, the text is saved in a @dfn{kill-ring}.
-Any number of consecutive kills save all of the killed text together, so
-that when you yank it back, you get it all.  The kill
-ring is not line specific; the text that you killed on a previously
-typed line is available to be yanked back later, when you are typing
-another line.
-@cindex kill ring
-
-Here is the list of commands for killing text.
-
-@table @kbd
-@item C-k
-Kill the text from the current cursor position to the end of the line.
-
-@item M-d
-Kill from the cursor to the end of the current word, or, if between
-words, to the end of the next word.
-Word boundaries are the same as those used by @kbd{M-f}.
-
-@item M-@key{DEL}
-Kill from the cursor the start of the previous word, or, if between
-words, to the start of the previous word.
-Word boundaries are the same as those used by @kbd{M-b}.
-
-@item C-w
-Kill from the cursor to the previous whitespace.  This is different than
-@kbd{M-@key{DEL}} because the word boundaries differ.
-
-@end table
-
-Here is how to @dfn{yank} the text back into the line.  Yanking
-means to copy the most-recently-killed text from the kill buffer.
-
-@table @kbd
-@item C-y
-Yank the most recently killed text back into the buffer at the cursor.
-
-@item M-y
-Rotate the kill-ring, and yank the new top.  You can only do this if
-the prior command is @kbd{C-y} or @kbd{M-y}.
-@end table
-
-@node Readline Arguments
-@subsection Readline Arguments
-
-You can pass numeric arguments to Readline commands.  Sometimes the
-argument acts as a repeat count, other times it is the @i{sign} of the
-argument that is significant.  If you pass a negative argument to a
-command which normally acts in a forward direction, that command will
-act in a backward direction.  For example, to kill text back to the
-start of the line, you might type @samp{M-- C-k}.
-
-The general way to pass numeric arguments to a command is to type meta
-digits before the command.  If the first `digit' typed is a minus
-sign (@samp{-}), then the sign of the argument will be negative.  Once
-you have typed one meta digit to get the argument started, you can type
-the remainder of the digits, and then the command.  For example, to give
-the @kbd{C-d} command an argument of 10, you could type @samp{M-1 0 C-d},
-which will delete the next ten characters on the input line.
-
-@node Searching
-@subsection Searching for Commands in the History
-
-Readline provides commands for searching through the command history
-@ifset BashFeatures
-(@pxref{Bash History Facilities})
-@end ifset
-for lines containing a specified string.
-There are two search modes:  @dfn{incremental} and @dfn{non-incremental}.
-
-Incremental searches begin before the user has finished typing the
-search string.
-As each character of the search string is typed, Readline displays
-the next entry from the history matching the string typed so far.
-An incremental search requires only as many characters as needed to
-find the desired history entry.
-To search backward in the history for a particular string, type
-@kbd{C-r}.  Typing @kbd{C-s} searches forward through the history.
-The characters present in the value of the @code{isearch-terminators} variable
-are used to terminate an incremental search.
-If that variable has not been assigned a value, the @key{ESC} and
-@kbd{C-J} characters will terminate an incremental search.
-@kbd{C-g} will abort an incremental search and restore the original line.
-When the search is terminated, the history entry containing the
-search string becomes the current line.
-
-To find other matching entries in the history list, type @kbd{C-r} or
-@kbd{C-s} as appropriate.
-This will search backward or forward in the history for the next
-entry matching the search string typed so far.
-Any other key sequence bound to a Readline command will terminate
-the search and execute that command.
-For instance, a @key{RET} will terminate the search and accept
-the line, thereby executing the command from the history list.
-A movement command will terminate the search, make the last line found
-the current line, and begin editing.
-
-Non-incremental searches read the entire search string before starting
-to search for matching history lines.  The search string may be
-typed by the user or be part of the contents of the current line.
-
-@node Readline Init File
-@section Readline Init File
-@cindex initialization file, readline
-
-Although the Readline library comes with a set of Emacs-like
-keybindings installed by default, it is possible to use a different set
-of keybindings.
-Any user can customize programs that use Readline by putting
-commands in an @dfn{inputrc} file, conventionally in his home directory.
-The name of this
-@ifset BashFeatures
-file is taken from the value of the shell variable @env{INPUTRC}.  If
-@end ifset
-@ifclear BashFeatures
-file is taken from the value of the environment variable @env{INPUTRC}.  If
-@end ifclear
-that variable is unset, the default is @file{~/.inputrc}.
-
-When a program which uses the Readline library starts up, the
-init file is read, and the key bindings are set.
-
-In addition, the @code{C-x C-r} command re-reads this init file, thus
-incorporating any changes that you might have made to it.
-
-@menu
-* Readline Init File Syntax::	Syntax for the commands in the inputrc file.
-
-* Conditional Init Constructs::	Conditional key bindings in the inputrc file.
-
-* Sample Init File::		An example inputrc file.
-@end menu
-
-@node Readline Init File Syntax
-@subsection Readline Init File Syntax
-
-There are only a few basic constructs allowed in the
-Readline init file.  Blank lines are ignored.
-Lines beginning with a @samp{#} are comments.
-Lines beginning with a @samp{$} indicate conditional
-constructs (@pxref{Conditional Init Constructs}).  Other lines
-denote variable settings and key bindings.
-
-@table @asis
-@item Variable Settings
-You can modify the run-time behavior of Readline by
-altering the values of variables in Readline
-using the @code{set} command within the init file.
-The syntax is simple:
-
-@example
-set @var{variable} @var{value}
-@end example
-
-@noindent
-Here, for example, is how to
-change from the default Emacs-like key binding to use
-@code{vi} line editing commands:
-
-@example
-set editing-mode vi
-@end example
-
-Variable names and values, where appropriate, are recognized without regard
-to case. 
-
-@ifset BashFeatures
-The @w{@code{bind -V}} command lists the current Readline variable names
-and values.  @xref{Bash Builtins}.
-@end ifset
-
-A great deal of run-time behavior is changeable with the following
-variables.
-
-@cindex variables, readline
-@table @code
-
-@item bell-style
-@vindex bell-style
-Controls what happens when Readline wants to ring the terminal bell.
-If set to @samp{none}, Readline never rings the bell.  If set to
-@samp{visible}, Readline uses a visible bell if one is available.
-If set to @samp{audible} (the default), Readline attempts to ring
-the terminal's bell.
-
-@item comment-begin
-@vindex comment-begin
-The string to insert at the beginning of the line when the
-@code{insert-comment} command is executed.  The default value
-is @code{"#"}.
-
-@item completion-ignore-case
-If set to @samp{on}, Readline performs filename matching and completion
-in a case-insensitive fashion.
-The default value is @samp{off}.
-
-@item completion-query-items
-@vindex completion-query-items
-The number of possible completions that determines when the user is
-asked whether he wants to see the list of possibilities.  If the
-number of possible completions is greater than this value,
-Readline will ask the user whether or not he wishes to view
-them; otherwise, they are simply listed.
-This variable must be set to an integer value greater than or equal to 0.
-The default limit is @code{100}.
-
-@item convert-meta
-@vindex convert-meta
-If set to @samp{on}, Readline will convert characters with the
-eighth bit set to an @sc{ascii} key sequence by stripping the eighth
-bit and prefixing an @key{ESC} character, converting them to a
-meta-prefixed key sequence.  The default value is @samp{on}.
-
-@item disable-completion
-@vindex disable-completion
-If set to @samp{On}, Readline will inhibit word completion.
-Completion  characters will be inserted into the line as if they had
-been mapped to @code{self-insert}.  The default is @samp{off}.
-
-@item editing-mode
-@vindex editing-mode
-The @code{editing-mode} variable controls which default set of
-key bindings is used.  By default, Readline starts up in Emacs editing
-mode, where the keystrokes are most similar to Emacs.  This variable can be
-set to either @samp{emacs} or @samp{vi}.
-
-@item enable-keypad
-@vindex enable-keypad
-When set to @samp{on}, Readline will try to enable the application
-keypad when it is called.  Some systems need this to enable the
-arrow keys.  The default is @samp{off}.
-
-@item expand-tilde
-@vindex expand-tilde
-If set to @samp{on}, tilde expansion is performed when Readline
-attempts word completion.  The default is @samp{off}.
-
-@item horizontal-scroll-mode
-@vindex horizontal-scroll-mode
-This variable can be set to either @samp{on} or @samp{off}.  Setting it
-to @samp{on} means that the text of the lines being edited will scroll
-horizontally on a single screen line when they are longer than the width
-of the screen, instead of wrapping onto a new screen line.  By default,
-this variable is set to @samp{off}.
-
-@item input-meta
-@vindex input-meta
-@vindex meta-flag
-If set to @samp{on}, Readline will enable eight-bit input (it
-will not clear the eighth bit in the characters it reads),
-regardless of what the terminal claims it can support.  The
-default value is @samp{off}.  The name @code{meta-flag} is a
-synonym for this variable.
-
-@item isearch-terminators
-@vindex isearch-terminators
-The string of characters that should terminate an incremental search without
-subsequently executing the character as a command (@pxref{Searching}).
-If this variable has not been given a value, the characters @key{ESC} and
-@kbd{C-J} will terminate an incremental search.
-
-@item keymap
-@vindex keymap
-Sets Readline's idea of the current keymap for key binding commands.
-Acceptable @code{keymap} names are
-@code{emacs},
-@code{emacs-standard},
-@code{emacs-meta},
-@code{emacs-ctlx},
-@code{vi},
-@code{vi-move},
-@code{vi-command}, and
-@code{vi-insert}.
-@code{vi} is equivalent to @code{vi-command}; @code{emacs} is
-equivalent to @code{emacs-standard}.  The default value is @code{emacs}.
-The value of the @code{editing-mode} variable also affects the
-default keymap.
-
-@item mark-directories
-If set to @samp{on}, completed directory names have a slash
-appended.  The default is @samp{on}.
-
-@item mark-modified-lines
-@vindex mark-modified-lines
-This variable, when set to @samp{on}, causes Readline to display an
-asterisk (@samp{*}) at the start of history lines which have been modified.
-This variable is @samp{off} by default.
-
-@item output-meta
-@vindex output-meta
-If set to @samp{on}, Readline will display characters with the
-eighth bit set directly rather than as a meta-prefixed escape
-sequence.  The default is @samp{off}.
-
-@item print-completions-horizontally
-If set to @samp{on}, Readline will display completions with matches
-sorted horizontally in alphabetical order, rather than down the screen.
-The default is @samp{off}.
-
-@item show-all-if-ambiguous
-@vindex show-all-if-ambiguous
-This alters the default behavior of the completion functions.  If
-set to @samp{on}, 
-words which have more than one possible completion cause the
-matches to be listed immediately instead of ringing the bell.
-The default value is @samp{off}.
-
-@item visible-stats
-@vindex visible-stats
-If set to @samp{on}, a character denoting a file's type
-is appended to the filename when listing possible
-completions.  The default is @samp{off}.
-
-@end table
-
-@item Key Bindings
-The syntax for controlling key bindings in the init file is
-simple.  First you need to find the name of the command that you
-want to change.  The following sections contain tables of the command
-name, the default keybinding, if any, and a short description of what
-the command does.
-
-Once you know the name of the command, simply place on a line
-in the init file the name of the key
-you wish to bind the command to, a colon, and then the name of the
-command.  The name of the key
-can be expressed in different ways, depending on what you find most
-comfortable.
-
-In addition to command names, readline allows keys to be bound
-to a string that is inserted when the key is pressed (a @var{macro}).
-
-@ifset BashFeatures
-The @w{@code{bind -p}} command displays Readline function names and
-bindings in a format that can put directly into an initialization file.
-@xref{Bash Builtins}.
-@end ifset
-
-@table @asis
-@item @w{@var{keyname}: @var{function-name} or @var{macro}}
-@var{keyname} is the name of a key spelled out in English.  For example:
-@example
-Control-u: universal-argument
-Meta-Rubout: backward-kill-word
-Control-o: "> output"
-@end example
-
-In the above example, @kbd{C-u} is bound to the function
-@code{universal-argument},
-@kbd{M-DEL} is bound to the function @code{backward-kill-word}, and
-@kbd{C-o} is bound to run the macro
-expressed on the right hand side (that is, to insert the text
-@samp{> output} into the line).
-
-A number of symbolic character names are recognized while
-processing this key binding syntax:
-@var{DEL},
-@var{ESC},
-@var{ESCAPE},
-@var{LFD},
-@var{NEWLINE},
-@var{RET},
-@var{RETURN},
-@var{RUBOUT},
-@var{SPACE},
-@var{SPC},
-and
-@var{TAB}.
-
-@item @w{"@var{keyseq}": @var{function-name} or @var{macro}}
-@var{keyseq} differs from @var{keyname} above in that strings
-denoting an entire key sequence can be specified, by placing
-the key sequence in double quotes.  Some @sc{gnu} Emacs style key
-escapes can be used, as in the following example, but the
-special character names are not recognized.
-
-@example
-"\C-u": universal-argument
-"\C-x\C-r": re-read-init-file
-"\e[11~": "Function Key 1"
-@end example
-
-In the above example, @kbd{C-u} is again bound to the function
-@code{universal-argument} (just as it was in the first example),
-@samp{@kbd{C-x} @kbd{C-r}} is bound to the function @code{re-read-init-file},
-and @samp{@key{ESC} @key{[} @key{1} @key{1} @key{~}} is bound to insert
-the text @samp{Function Key 1}.
-
-@end table
-
-The following @sc{gnu} Emacs style escape sequences are available when
-specifying key sequences:
-
-@table @code
-@item @kbd{\C-}
-control prefix
-@item @kbd{\M-}
-meta prefix
-@item @kbd{\e}
-an escape character
-@item @kbd{\\}
-backslash
-@item @kbd{\"}
-@key{"}, a double quotation mark
-@item @kbd{\'}
-@key{'}, a single quote or apostrophe
-@end table
-
-In addition to the @sc{gnu} Emacs style escape sequences, a second
-set of backslash escapes is available:
-
-@table @code
-@item \a
-alert (bell)
-@item \b
-backspace
-@item \d
-delete
-@item \f
-form feed
-@item \n
-newline
-@item \r
-carriage return
-@item \t
-horizontal tab
-@item \v
-vertical tab
-@item \@var{nnn}
-the character whose @sc{ascii} code is the octal value @var{nnn}
-(one to three digits)
-@item \x@var{nnn}
-the character whose @sc{ascii} code is the hexadecimal value @var{nnn}
-(one to three digits)
-@end table
-
-When entering the text of a macro, single or double quotes must
-be used to indicate a macro definition.
-Unquoted text is assumed to be a function name.
-In the macro body, the backslash escapes described above are expanded.
-Backslash will quote any other character in the macro text,
-including @samp{"} and @samp{'}.
-For example, the following binding will make @samp{@kbd{C-x} \}
-insert a single @samp{\} into the line:
-@example
-"\C-x\\": "\\"
-@end example
-
-@end table
-
-@node Conditional Init Constructs
-@subsection Conditional Init Constructs
-
-Readline implements a facility similar in spirit to the conditional
-compilation features of the C preprocessor which allows key
-bindings and variable settings to be performed as the result
-of tests.  There are four parser directives used.
-
-@table @code
-@item $if
-The @code{$if} construct allows bindings to be made based on the
-editing mode, the terminal being used, or the application using
-Readline.  The text of the test extends to the end of the line;
-no characters are required to isolate it.
-
-@table @code
-@item mode
-The @code{mode=} form of the @code{$if} directive is used to test
-whether Readline is in @code{emacs} or @code{vi} mode.
-This may be used in conjunction
-with the @samp{set keymap} command, for instance, to set bindings in
-the @code{emacs-standard} and @code{emacs-ctlx} keymaps only if
-Readline is starting out in @code{emacs} mode.
-
-@item term
-The @code{term=} form may be used to include terminal-specific
-key bindings, perhaps to bind the key sequences output by the
-terminal's function keys.  The word on the right side of the
-@samp{=} is tested against both the full name of the terminal and
-the portion of the terminal name before the first @samp{-}.  This
-allows @code{sun} to match both @code{sun} and @code{sun-cmd},
-for instance.
-
-@item application
-The @var{application} construct is used to include
-application-specific settings.  Each program using the Readline
-library sets the @var{application name}, and you can test for
-a particular value. 
-This could be used to bind key sequences to functions useful for
-a specific program.  For instance, the following command adds a
-key sequence that quotes the current or previous word in Bash:
-@example
-$if Bash
-# Quote the current or previous word
-"\C-xq": "\eb\"\ef\""
-$endif
-@end example
-@end table
-
-@item $endif
-This command, as seen in the previous example, terminates an
-@code{$if} command.
-
-@item $else
-Commands in this branch of the @code{$if} directive are executed if
-the test fails.
-
-@item $include
-This directive takes a single filename as an argument and reads commands
-and bindings from that file.
-For example, the following directive reads from @file{/etc/inputrc}:
-@example
-$include /etc/inputrc
-@end example
-@end table
-
-@node Sample Init File
-@subsection Sample Init File
-
-Here is an example of an @var{inputrc} file.  This illustrates key
-binding, variable assignment, and conditional syntax.
-
-@example
-@page
-# This file controls the behaviour of line input editing for
-# programs that use the Gnu Readline library.  Existing programs
-# include FTP, Bash, and Gdb.
-#
-# You can re-read the inputrc file with C-x C-r.
-# Lines beginning with '#' are comments.
-#
-# First, include any systemwide bindings and variable assignments from
-# /etc/Inputrc
-$include /etc/Inputrc
-
-#
-# Set various bindings for emacs mode.
-
-set editing-mode emacs 
-
-$if mode=emacs
-
-Meta-Control-h:	backward-kill-word	Text after the function name is ignored
-
-#
-# Arrow keys in keypad mode
-#
-#"\M-OD":        backward-char
-#"\M-OC":        forward-char
-#"\M-OA":        previous-history
-#"\M-OB":        next-history
-#
-# Arrow keys in ANSI mode
-#
-"\M-[D":        backward-char
-"\M-[C":        forward-char
-"\M-[A":        previous-history
-"\M-[B":        next-history
-#
-# Arrow keys in 8 bit keypad mode
-#
-#"\M-\C-OD":       backward-char
-#"\M-\C-OC":       forward-char
-#"\M-\C-OA":       previous-history
-#"\M-\C-OB":       next-history
-#
-# Arrow keys in 8 bit ANSI mode
-#
-#"\M-\C-[D":       backward-char
-#"\M-\C-[C":       forward-char
-#"\M-\C-[A":       previous-history
-#"\M-\C-[B":       next-history
-
-C-q: quoted-insert
-
-$endif
-
-# An old-style binding.  This happens to be the default.
-TAB: complete
-
-# Macros that are convenient for shell interaction
-$if Bash
-# edit the path
-"\C-xp": "PATH=$@{PATH@}\e\C-e\C-a\ef\C-f"
-# prepare to type a quoted word -- insert open and close double quotes
-# and move to just after the open quote
-"\C-x\"": "\"\"\C-b"
-# insert a backslash (testing backslash escapes in sequences and macros)
-"\C-x\\": "\\"
-# Quote the current or previous word
-"\C-xq": "\eb\"\ef\""
-# Add a binding to refresh the line, which is unbound
-"\C-xr": redraw-current-line
-# Edit variable on current line.
-"\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
-$endif
-
-# use a visible bell if one is available
-set bell-style visible
-
-# don't strip characters to 7 bits when reading
-set input-meta on
-
-# allow iso-latin1 characters to be inserted rather than converted to
-# prefix-meta sequences
-set convert-meta off
-
-# display characters with the eighth bit set directly rather than
-# as meta-prefixed characters
-set output-meta on
-
-# if there are more than 150 possible completions for a word, ask the
-# user if he wants to see all of them
-set completion-query-items 150
-
-# For FTP
-$if Ftp
-"\C-xg": "get \M-?"
-"\C-xt": "put \M-?"
-"\M-.": yank-last-arg
-$endif
-@end example
-
-@node Bindable Readline Commands
-@section Bindable Readline Commands
-
-@menu
-* Commands For Moving::		Moving about the line.
-* Commands For History::	Getting at previous lines.
-* Commands For Text::		Commands for changing text.
-* Commands For Killing::	Commands for killing and yanking.
-* Numeric Arguments::		Specifying numeric arguments, repeat counts.
-* Commands For Completion::	Getting Readline to do the typing for you.
-* Keyboard Macros::		Saving and re-executing typed characters
-* Miscellaneous Commands::	Other miscellaneous commands.
-@end menu
-
-This section describes Readline commands that may be bound to key
-sequences.
-@ifset BashFeatures
-You can list your key bindings by executing
-@w{@code{bind -P}} or, for a more terse format, suitable for an
-@var{inputrc} file, @w{@code{bind -p}}.  (@xref{Bash Builtins}.)
-@end ifset
-Command names without an accompanying key sequence are unbound by default.
-
-In the following descriptions, @dfn{point} refers to the current cursor
-position, and @dfn{mark} refers to a cursor position saved by the
-@code{set-mark} command.
-The text between the point and mark is referred to as the @dfn{region}.
-
-@node Commands For Moving
-@subsection Commands For Moving
-@ftable @code
-@item beginning-of-line (C-a)
-Move to the start of the current line.
-
-@item end-of-line (C-e)
-Move to the end of the line.
-
-@item forward-char (C-f)
-Move forward a character.
-
-@item backward-char (C-b)
-Move back a character.
-
-@item forward-word (M-f)
-Move forward to the end of the next word.  Words are composed of
-letters and digits.
-
-@item backward-word (M-b)
-Move back to the start of the current or previous word.  Words are
-composed of letters and digits.
-
-@item clear-screen (C-l)
-Clear the screen and redraw the current line,
-leaving the current line at the top of the screen.
-
-@item redraw-current-line ()
-Refresh the current line.  By default, this is unbound.
-
-@end ftable
-
-@node Commands For History
-@subsection Commands For Manipulating The History
-
-@ftable @code
-@item accept-line (Newline or Return)
-@ifset BashFeatures
-Accept the line regardless of where the cursor is.
-If this line is
-non-empty, add it to the history list according to the setting of
-the @env{HISTCONTROL} and @env{HISTIGNORE} variables.
-If this line is a modified history line, then restore the history line
-to its original state.
-@end ifset
-@ifclear BashFeatures
-Accept the line regardless of where the cursor is.
-If this line is
-non-empty, it may be added to the history list for future recall with
-@code{add_history()}.
-If this line is a modified history line, the history line is restored
-to its original state.
-@end ifclear
-
-@item previous-history (C-p)
-Move `back' through the history list, fetching the previous command.
-
-@item next-history (C-n)
-Move `forward' through the history list, fetching the next command.
-
-@item beginning-of-history (M-<)
-Move to the first line in the history.
-
-@item end-of-history (M->)
-Move to the end of the input history, i.e., the line currently
-being entered.
-
-@item reverse-search-history (C-r)
-Search backward starting at the current line and moving `up' through
-the history as necessary.  This is an incremental search.
-
-@item forward-search-history (C-s)
-Search forward starting at the current line and moving `down' through
-the the history as necessary.  This is an incremental search.
-
-@item non-incremental-reverse-search-history (M-p)
-Search backward starting at the current line and moving `up'
-through the history as necessary using a non-incremental search
-for a string supplied by the user.
-
-@item non-incremental-forward-search-history (M-n)
-Search forward starting at the current line and moving `down'
-through the the history as necessary using a non-incremental search
-for a string supplied by the user.
-
-@item history-search-forward ()
-Search forward through the history for the string of characters
-between the start of the current line and the point.
-This is a non-incremental search.
-By default, this command is unbound.
-
-@item history-search-backward ()
-Search backward through the history for the string of characters
-between the start of the current line and the point.  This
-is a non-incremental search.  By default, this command is unbound.
-
-@item yank-nth-arg (M-C-y)
-Insert the first argument to the previous command (usually
-the second word on the previous line) at point.
-With an argument @var{n},
-insert the @var{n}th word from the previous command (the words
-in the previous command begin with word 0).  A negative argument
-inserts the @var{n}th word from the end of the previous command.
-
-@item yank-last-arg (M-. or M-_)
-Insert last argument to the previous command (the last word of the
-previous history entry).  With an
-argument, behave exactly like @code{yank-nth-arg}.
-Successive calls to @code{yank-last-arg} move back through the history
-list, inserting the last argument of each line in turn.
-
-@end ftable
-
-@node Commands For Text
-@subsection Commands For Changing Text
-
-@ftable @code
-@item delete-char (C-d)
-Delete the character at point.  If point is at the
-beginning of the line, there are no characters in the line, and
-the last character typed was not bound to @code{delete-char}, then
-return @sc{eof}.
-
-@item backward-delete-char (Rubout)
-Delete the character behind the cursor.  A numeric argument means
-to kill the characters instead of deleting them.
-
-@item forward-backward-delete-char ()
-Delete the character under the cursor, unless the cursor is at the
-end of the line, in which case the character behind the cursor is
-deleted.  By default, this is not bound to a key.
-
-@item quoted-insert (C-q or C-v)
-Add the next character typed to the line verbatim.  This is
-how to insert key sequences like @kbd{C-q}, for example.
-
-@ifclear BashFeatures
-@item tab-insert (M-@key{TAB})
-Insert a tab character.
-@end ifclear
-
-@item self-insert (a, b, A, 1, !, @dots{})
-Insert yourself.
-
-@item transpose-chars (C-t)
-Drag the character before the cursor forward over
-the character at the cursor, moving the
-cursor forward as well.  If the insertion point
-is at the end of the line, then this
-transposes the last two characters of the line.
-Negative arguments have no effect.
-
-@item transpose-words (M-t)
-Drag the word before point past the word after point,
-moving point past that word as well.
-
-@item upcase-word (M-u)
-Uppercase the current (or following) word.  With a negative argument,
-uppercase the previous word, but do not move the cursor.
-
-@item downcase-word (M-l)
-Lowercase the current (or following) word.  With a negative argument,
-lowercase the previous word, but do not move the cursor.
-
-@item capitalize-word (M-c)
-Capitalize the current (or following) word.  With a negative argument,
-capitalize the previous word, but do not move the cursor.
-
-@end ftable
-
-@node Commands For Killing
-@subsection Killing And Yanking
-
-@ftable @code
-
-@item kill-line (C-k)
-Kill the text from point to the end of the line.
-
-@item backward-kill-line (C-x Rubout)
-Kill backward to the beginning of the line.
-
-@item unix-line-discard (C-u)
-Kill backward from the cursor to the beginning of the current line.
-
-@item kill-whole-line ()
-Kill all characters on the current line, no matter where point is.
-By default, this is unbound.
-
-@item kill-word (M-d)
-Kill from point to the end of the current word, or if between
-words, to the end of the next word.
-Word boundaries are the same as @code{forward-word}.
-
-@item backward-kill-word (M-@key{DEL})
-Kill the word behind point.
-Word boundaries are the same as @code{backward-word}.
-
-@item unix-word-rubout (C-w)
-Kill the word behind point, using white space as a word boundary.
-The killed text is saved on the kill-ring.
-
-@item delete-horizontal-space ()
-Delete all spaces and tabs around point.  By default, this is unbound.
-
-@item kill-region ()
-Kill the text in the current region.
-By default, this command is unbound.
-
-@item copy-region-as-kill ()
-Copy the text in the region to the kill buffer, so it can be yanked
-right away.  By default, this command is unbound.
-
-@item copy-backward-word ()
-Copy the word before point to the kill buffer.
-The word boundaries are the same as @code{backward-word}.
-By default, this command is unbound.
-
-@item copy-forward-word ()
-Copy the word following point to the kill buffer.
-The word boundaries are the same as @code{forward-word}.
-By default, this command is unbound.
-
-@item yank (C-y)
-Yank the top of the kill ring into the buffer at point.
-
-@item yank-pop (M-y)
-Rotate the kill-ring, and yank the new top.  You can only do this if
-the prior command is @code{yank} or @code{yank-pop}.
-@end ftable
-
-@node Numeric Arguments
-@subsection Specifying Numeric Arguments
-@ftable @code
-
-@item digit-argument (@kbd{M-0}, @kbd{M-1}, @dots{} @kbd{M--})
-Add this digit to the argument already accumulating, or start a new
-argument.  @kbd{M--} starts a negative argument.
-
-@item universal-argument ()
-This is another way to specify an argument.
-If this command is followed by one or more digits, optionally with a
-leading minus sign, those digits define the argument.
-If the command is followed by digits, executing @code{universal-argument}
-again ends the numeric argument, but is otherwise ignored.
-As a special case, if this command is immediately followed by a
-character that is neither a digit or minus sign, the argument count
-for the next command is multiplied by four.
-The argument count is initially one, so executing this function the
-first time makes the argument count four, a second time makes the
-argument count sixteen, and so on.
-By default, this is not bound to a key.
-@end ftable
-
-@node Commands For Completion
-@subsection Letting Readline Type For You
-
-@ftable @code
-@item complete (@key{TAB})
-Attempt to perform completion on the text before point.
-The actual completion performed is application-specific.
-@ifset BashFeatures
-Bash attempts completion treating the text as a variable (if the
-text begins with @samp{$}), username (if the text begins with
-@samp{~}), hostname (if the text begins with @samp{@@}), or
-command (including aliases and functions) in turn.  If none 
-of these produces a match, filename completion is attempted.
-@end ifset
-@ifclear BashFeatures
-The default is filename completion.
-@end ifclear
-
-@item possible-completions (M-?)
-List the possible completions of the text before point.
-
-@item insert-completions (M-*)
-Insert all completions of the text before point that would have
-been generated by @code{possible-completions}.
-
-@item menu-complete ()
-Similar to @code{complete}, but replaces the word to be completed
-with a single match from the list of possible completions.
-Repeated execution of @code{menu-complete} steps through the list
-of possible completions, inserting each match in turn.
-At the end of the list of completions, the bell is rung
-(subject to the setting of @code{bell-style})
-and the original text is restored.
-An argument of @var{n} moves @var{n} positions forward in the list
-of matches; a negative argument may be used to move backward
-through the list.
-This command is intended to be bound to @key{TAB}, but is unbound
-by default.
-
-@item delete-char-or-list ()
-Deletes the character under the cursor if not at the beginning or
-end of the line (like @code{delete-char}).
-If at the end of the line, behaves identically to
-@code{possible-completions}.
-This command is unbound by default.
-
-@ifset BashFeatures
-@item complete-filename (M-/)
-Attempt filename completion on the text before point.
-
-@item possible-filename-completions (C-x /)
-List the possible completions of the text before point,
-treating it as a filename.
-
-@item complete-username (M-~)
-Attempt completion on the text before point, treating
-it as a username.
-
-@item possible-username-completions (C-x ~)
-List the possible completions of the text before point,
-treating it as a username.
-
-@item complete-variable (M-$)
-Attempt completion on the text before point, treating
-it as a shell variable.
-
-@item possible-variable-completions (C-x $)
-List the possible completions of the text before point,
-treating it as a shell variable.
-
-@item complete-hostname (M-@@)
-Attempt completion on the text before point, treating
-it as a hostname.
-
-@item possible-hostname-completions (C-x @@)
-List the possible completions of the text before point,
-treating it as a hostname.
-
-@item complete-command (M-!)
-Attempt completion on the text before point, treating
-it as a command name.  Command completion attempts to
-match the text against aliases, reserved words, shell
-functions, shell builtins, and finally executable filenames,
-in that order.
-
-@item possible-command-completions (C-x !)
-List the possible completions of the text before point,
-treating it as a command name.
-
-@item dynamic-complete-history (M-@key{TAB})
-Attempt completion on the text before point, comparing
-the text against lines from the history list for possible
-completion matches.
-
-@item complete-into-braces (M-@{)
-Perform filename completion and insert the list of possible completions
-enclosed within braces so the list is available to the shell
-(@pxref{Brace Expansion}).
-
-@end ifset
-@end ftable
-
-@node Keyboard Macros
-@subsection Keyboard Macros
-@ftable @code
-
-@item start-kbd-macro (C-x ()
-Begin saving the characters typed into the current keyboard macro.
-
-@item end-kbd-macro (C-x ))
-Stop saving the characters typed into the current keyboard macro
-and save the definition.
-
-@item call-last-kbd-macro (C-x e)
-Re-execute the last keyboard macro defined, by making the characters
-in the macro appear as if typed at the keyboard.
-
-@end ftable
-
-@node Miscellaneous Commands
-@subsection Some Miscellaneous Commands
-@ftable @code
-
-@item re-read-init-file (C-x C-r)
-Read in the contents of the @var{inputrc} file, and incorporate
-any bindings or variable assignments found there.
-
-@item abort (C-g)
-Abort the current editing command and
-ring the terminal's bell (subject to the setting of
-@code{bell-style}).
-
-@item do-uppercase-version (M-a, M-b, M-@var{x}, @dots{})
-If the metafied character @var{x} is lowercase, run the command
-that is bound to the corresponding uppercase character.
-
-@item prefix-meta (@key{ESC})
-Metafy the next character typed.  This is for keyboards
-without a meta key.  Typing @samp{@key{ESC} f} is equivalent to typing
-@kbd{M-f}.
-
-@item undo (C-_ or C-x C-u)
-Incremental undo, separately remembered for each line.
-
-@item revert-line (M-r)
-Undo all changes made to this line.  This is like executing the @code{undo}
-command enough times to get back to the beginning.
-
-@ifset BashFeatures
-@item tilde-expand (M-&)
-@end ifset
-@ifclear BashFeatures
-@item tilde-expand (M-~)
-@end ifclear
-Perform tilde expansion on the current word.
-
-@item set-mark (C-@@)
-Set the mark to the point.  If a
-numeric argument is supplied, the mark is set to that position.
-
-@item exchange-point-and-mark (C-x C-x)
-Swap the point with the mark.  The current cursor position is set to
-the saved position, and the old cursor position is saved as the mark.
-
-@item character-search (C-])
-A character is read and point is moved to the next occurrence of that
-character.  A negative count searches for previous occurrences.
-
-@item character-search-backward (M-C-])
-A character is read and point is moved to the previous occurrence
-of that character.  A negative count searches for subsequent
-occurrences.
-
-@item insert-comment (M-#)
-The value of the @code{comment-begin}
-variable is inserted at the beginning of the current line,
-and the line is accepted as if a newline had been typed.
-@ifset BashFeatures
-The default value of @code{comment-begin} causes this command
-to make the current line a shell comment.
-@end ifset
-
-@item dump-functions ()
-Print all of the functions and their key bindings to the
-Readline output stream.  If a numeric argument is supplied,
-the output is formatted in such a way that it can be made part
-of an @var{inputrc} file.  This command is unbound by default.
-
-@item dump-variables ()
-Print all of the settable variables and their values to the
-Readline output stream.  If a numeric argument is supplied,
-the output is formatted in such a way that it can be made part
-of an @var{inputrc} file.  This command is unbound by default.
-
-@item dump-macros ()
-Print all of the Readline key sequences bound to macros and the
-strings they output.  If a numeric argument is supplied,
-the output is formatted in such a way that it can be made part
-of an @var{inputrc} file.  This command is unbound by default.
-
-@ifset BashFeatures
-@item glob-expand-word (C-x *)
-The word before point is treated as a pattern for pathname expansion,
-and the list of matching file names is inserted, replacing the word.
-
-@item glob-list-expansions (C-x g)
-The list of expansions that would have been generated by
-@code{glob-expand-word} is displayed, and the line is redrawn.
-
-@item display-shell-version (C-x C-v)
-Display version information about the current instance of Bash.
-
-@item shell-expand-line (M-C-e)
-Expand the line as the shell does.
-This performs alias and history expansion as well as all of the shell
-word expansions (@pxref{Shell Expansions}).
-
-@item history-expand-line (M-^)
-Perform history expansion on the current line.
-
-@item magic-space ()
-Perform history expansion on the current line and insert a space
-(@pxref{History Interaction}).
-
-@item alias-expand-line ()
-Perform alias expansion on the current line (@pxref{Aliases}).
-
-@item history-and-alias-expand-line ()
-Perform history and alias expansion on the current line.
-
-@item insert-last-argument (M-. or M-_)
-A synonym for @code{yank-last-arg}.
-
-@item operate-and-get-next (C-o)
-Accept the current line for execution and fetch the next line
-relative to the current line from the history for editing.  Any
-argument is ignored.
-
-@item emacs-editing-mode (C-e)
-When in @code{vi} editing mode, this causes a switch back to
-@code{emacs} editing mode, as if the command @samp{set -o emacs} had
-been executed.
-
-@end ifset
-
-@end ftable
-
-@node Readline vi Mode
-@section Readline vi Mode
-
-While the Readline library does not have a full set of @code{vi}
-editing functions, it does contain enough to allow simple editing
-of the line.  The Readline @code{vi} mode behaves as specified in
-the @sc{posix} 1003.2 standard.
-
-@ifset BashFeatures
-In order to switch interactively between @code{emacs} and @code{vi}
-editing modes, use the @samp{set -o emacs} and @samp{set -o vi}
-commands (@pxref{The Set Builtin}).
-@end ifset
-@ifclear BashFeatures
-In order to switch interactively between @code{emacs} and @code{vi}
-editing modes, use the command @kbd{M-C-j} (bound to emacs-editing-mode
-when in @code{vi} mode and to vi-editing-mode in @code{emacs} mode).
-@end ifclear
-The Readline default is @code{emacs} mode.
-
-When you enter a line in @code{vi} mode, you are already placed in
-`insertion' mode, as if you had typed an @samp{i}.  Pressing @key{ESC}
-switches you into `command' mode, where you can edit the text of the
-line with the standard @code{vi} movement keys, move to previous
-history lines with @samp{k} and subsequent lines with @samp{j}, and
-so forth.
-
-@ifset BashFeatures
-@node Programmable Completion
-@section Programmable Completion
-@cindex programmable completion
-
-When word completion is attempted for an argument to a command for
-which a completion specification (a @var{compspec}) has been defined
-using the @code{complete} builtin (@pxref{Programmable Completion Builtins}),
-the programmable completion facilities are invoked. 
-
-First, the command name is identified.
-If a compspec has been defined for that command, the
-compspec is used to generate the list of possible completions for the word.
-If the command word is a full pathname, a compspec for the full
-pathname is searched for first.
-If no compspec is found for the full pathname, an attempt is made to
-find a compspec for the portion following the final slash.
-
-Once a compspec has been found, it is used to generate the list of
-matching words.
-If a compspec is not found, the default Bash completion
-described above (@pxref{Commands For Completion}) is performed.
-
-First, the actions specified by the compspec are used.
-Only matches which are prefixed by the word being completed are
-returned.
-When the @option{-f} or @option{-d} option is used for filename or
-directory name completion, the shell variable @env{FIGNORE} is
-used to filter the matches.
-@xref{Bash Variables}, for a description of @env{FIGNORE}.
-
-Any completions specified by a filename expansion pattern to the
-@option{-G} option are generated next.
-The words generated by the pattern need not match the word being completed.
-The @env{GLOBIGNORE} shell variable is not used to filter the matches,
-but the @env{FIGNORE} shell variable is used.
-
-Next, the string specified as the argument to the @option{-W} option
-is considered.
-The string is first split using the characters in the @env{IFS}
-special variable as delimiters.
-Shell quoting is honored.
-Each word is then expanded using
-brace expansion, tilde expansion, parameter and variable expansion,
-command substitution, arithmetic expansion, and pathname expansion,
-as described above (@pxref{Shell Expansions}).
-The results are split using the rules described above
-(@pxref{Word Splitting}).
-The results of the expansion are prefix-matched against the word being
-completed, and the matching words become the possible completions.
-
-After these matches have been generated, any shell function or command
-specified with the @option{-F} and @option{-C} options is invoked.
-When the command or function is invoked, the @env{COMP_LINE} and
-@env{COMP_POINT} variables are assigned values as described above
-(@pxref{Bash Variables}).
-If a shell function is being invoked, the @env{COMP_WORDS} and
-@env{COMP_CWORD} variables are also set.
-When the function or command is invoked, the first argument is the
-name of the command whose arguments are being completed, the
-second argument is the word being completed, and the third argument
-is the word preceding the word being completed on the current command line.
-No filtering of the generated completions against the word being completed
-is performed; the function or command has complete freedom in generating
-the matches.
-
-Any function specified with @option{-F} is invoked first.
-The function may use any of the shell facilities, including the
-@code{compgen} builtin described below
-(@pxref{Programmable Completion Builtins}), to generate the matches.
-It must put the possible completions in the @env{COMPREPLY} array
-variable.
-
-Next, any command specified with the @option{-C} option is invoked
-in an environment equivalent to command substitution.
-It should print a list of completions, one per line, to
-the standard output.
-Backslash may be used to escape a newline, if necessary.
-
-After all of the possible completions are generated, any filter
-specified with the @option{-X} option is applied to the list.
-The filter is a pattern as used for pathname expansion; a @samp{&}
-in the pattern is replaced with the text of the word being completed.
-A literal @samp{&} may be escaped with a backslash; the backslash
-is removed before attempting a match.
-Any completion that matches the pattern will be removed from the list.
-A leading @samp{!} negates the pattern; in this case any completion
-not matching the pattern will be removed.
-
-Finally, any prefix and suffix specified with the @option{-P} and @option{-S}
-options are added to each member of the completion list, and the result is
-returned to the Readline completion code as the list of possible
-completions.
-
-If the previously-applied actions do not generate any matches, and the
-@option{-o dirnames} option was supplied to @code{complete} when the
-compspec was defined, directory name completion is attempted. 
-
-By default, if a compspec is found, whatever it generates is returned to
-the completion code as the full set of possible completions.
-The default Bash completions are not attempted, and the Readline default
-of filename completion is disabled.
-If the @option{-o default} option was supplied to @code{complete} when the
-compspec was defined, Readline's default completion will be performed
-if the compspec generates no matches.
-
-@node Programmable Completion Builtins
-@section Programmable Completion Builtins
-@cindex completion builtins
-
-Two builtin commands are available to manipulate the programmable completion
-facilities.
-
-@table @code
-@item compgen
-@btindex compgen
-@example
-@code{compgen [@var{option}] [@var{word}]}
-@end example
-
-Generate possible completion matches for @var{word} according to
-the @var{option}s, which may be any option accepted by the
-@code{complete}
-builtin with the exception of @option{-p} and @option{-r}, and write
-the matches to the standard output.
-When using the @option{-F} or @option{-C} options, the various shell variables
-set by the programmable completion facilities, while available, will not
-have useful values.
-
-The matches will be generated in the same way as if the programmable
-completion code had generated them directly from a completion specification
-with the same flags.
-If @var{word} is specified, only those completions matching @var{word}
-will be displayed.
-
-The return value is true unless an invalid option is supplied, or no
-matches were generated.
-
-@item complete
-@btindex complete
-@example
-@code{complete [-abcdefjkvu] [-o @var{comp-option}] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]
-[-P @var{prefix}] [-S @var{suffix}] [-X @var{filterpat}] [-F @var{function}]
-[-C @var{command}] @var{name} [@var{name} @dots{}]}
-@code{complete -pr [@var{name} @dots{}]}
-@end example
-
-Specify how arguments to each @var{name} should be completed.
-If the @option{-p} option is supplied, or if no options are supplied, existing
-completion specifications are printed in a way that allows them to be
-reused as input.
-The @option{-r} option removes a completion specification for
-each @var{name}, or, if no @var{name}s are supplied, all
-completion specifications.
-
-The process of applying these completion specifications when word completion
-is attempted is described above (@pxref{Programmable Completion}).
-
-Other options, if specified, have the following meanings.
-The arguments to the @option{-G}, @option{-W}, and @option{-X} options
-(and, if necessary, the @option{-P} and @option{-S} options)
-should be quoted to protect them from expansion before the
-@code{complete} builtin is invoked.
-
-
-@table @code
-@item -o @var{comp-option}
-The @var{comp-option} controls several aspects of the compspec's behavior
-beyond the simple generation of completions.
-@var{comp-option} may be one of: 
-
-@table @code
-
-@item default
-Use readline's default completion if the compspec generates no matches.
-
-@item dirnames
-Perform directory name completion if the compspec generates no matches.
-
-@item filenames
-Tell Readline that the compspec generates filenames, so it can perform any
-filename\-specific processing (like adding a slash to directory names or
-suppressing trailing spaces).  This option is intended to be used with
-shell functions specified with @option{-F}.
-@end table
-
-@item -A @var{action}
-The @var{action} may be one of the following to generate a list of possible
-completions:
-
-@table @code
-@item alias
-Alias names.  May also be specified as @option{-a}.
-
-@item arrayvar
-Array variable names.
-
-@item binding
-Readline key binding names (@pxref{Bindable Readline Commands}).
-
-@item builtin
-Names of shell builtin commands.  May also be specified as @option{-b}.
-
-@item command
-Command names.  May also be specified as @option{-c}.
-
-@item directory
-Directory names.  May also be specified as @option{-d}.
-
-@item disabled
-Names of disabled shell builtins.
-
-@item enabled
-Names of enabled shell builtins.
-
-@item export
-Names of exported shell variables.  May also be specified as @option{-e}.
-
-@item file
-File names.  May also be specified as @option{-f}.
-
-@item function
-Names of shell functions.
-
-@item helptopic
-Help topics as accepted by the @code{help} builtin (@pxref{Bash Builtins}).
-
-@item hostname
-Hostnames, as taken from the file specified by the
-@env{HOSTFILE} shell variable (@pxref{Bash Variables}).
-
-@item job
-Job names, if job control is active.  May also be specified as @option{-j}.
-
-@item keyword
-Shell reserved words.  May also be specified as @option{-k}.
-
-@item running
-Names of running jobs, if job control is active.
-
-@item setopt
-Valid arguments for the @option{-o} option to the @code{set} builtin
-(@pxref{The Set Builtin}).
-
-@item shopt
-Shell option names as accepted by the @code{shopt} builtin
-(@pxref{Bash Builtins}).
-
-@item signal
-Signal names.
-
-@item stopped
-Names of stopped jobs, if job control is active.
-
-@item user
-User names.  May also be specified as @option{-u}.
-
-@item variable
-Names of all shell variables.  May also be specified as @option{-v}.
-@end table
-
-@item -G @var{globpat}
-The filename expansion pattern @var{globpat} is expanded to generate
-the possible completions.
-
-@item -W @var{wordlist}
-The @var{wordlist} is split using the characters in the
-@env{IFS} special variable as delimiters, and each resultant word
-is expanded.
-The possible completions are the members of the resultant list which
-match the word being completed.
-
-@item -C @var{command}
-@var{command} is executed in a subshell environment, and its output is
-used as the possible completions.
-
-@item -F @var{function}
-The shell function @var{function} is executed in the current shell
-environment.
-When it finishes, the possible completions are retrieved from the value
-of the @env{COMPREPLY} array variable.
-
-@item -X @var{filterpat}
-@var{filterpat} is a pattern as used for filename expansion.
-It is applied to the list of possible completions generated by the
-preceding options and arguments, and each completion matching
-@var{filterpat} is removed from the list.
-A leading @samp{!} in @var{filterpat} negates the pattern; in this
-case, any completion not matching @var{filterpat} is removed.
-
-@item -P @var{prefix}
-@var{prefix} is added at the beginning of each possible completion
-after all other options have been applied.
-
-@item -S @var{suffix}
-@var{suffix} is appended to each possible completion
-after all other options have been applied.
-@end table
-
-The return value is true unless an invalid option is supplied, an option
-other than @option{-p} or @option{-r} is supplied without a @var{name}
-argument, an attempt is made to remove a completion specification for
-a @var{name} for which no specification exists, or
-an error occurs adding a completion specification.
-
-@end table
-@end ifset
diff --git a/readline/doc/rluserman.texinfo b/readline/doc/rluserman.texinfo
deleted file mode 100644
--- a/readline/doc/rluserman.texinfo
+++ /dev/null
@@ -1,94 +0,0 @@
-\input texinfo    @c -*-texinfo-*-
-@comment %**start of header (This is for running Texinfo on a region.)
-@setfilename rluserman.info
-@settitle GNU Readline Library
-@comment %**end of header (This is for running Texinfo on a region.)
-@setchapternewpage odd
-
-@include manvers.texinfo
-
-@ifinfo
-@dircategory Libraries
-@direntry
-* RLuserman: (rluserman).       The GNU readline library User's Manual.
-@end direntry
-
-This document describes the end user interface of the GNU Readline Library,
-a utility which aids in the consistency of user interface across discrete
-programs that need to provide a command line interface.
-
-Copyright (C) 1988-2001 Free Software Foundation, Inc.
-
-Permission is granted to make and distribute verbatim copies of
-this manual provided the copyright notice and this permission notice
-pare preserved on all copies.
-
-@ignore
-Permission is granted to process this file through TeX and print the
-results, provided the printed document carries copying permission
-notice identical to this one except for the removal of this paragraph
-(this paragraph not being relevant to the printed manual).
-@end ignore
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided that the entire
-resulting derived work is distributed under the terms of a permission
-notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions,
-except that this permission notice may be stated in a translation approved
-by the Free Software Foundation.
-@end ifinfo
-
-@titlepage  
-@title GNU Readline Library User Interface
-@subtitle Edition @value{EDITION}, for @code{Readline Library} Version @value{VERSION}.
-@subtitle @value{UPDATE-MONTH}
-@author Brian Fox, Free Software Foundation
-@author Chet Ramey, Case Western Reserve University
-
-@page
-This document describes the end user interface of the GNU Readline Library,
-a utility which aids in the consistency of user interface across discrete
-programs that need to provide a command line interface.
-
-Published by the Free Software Foundation @*
-59 Temple Place, Suite 330, @*
-Boston, MA 02111 USA
-
-Permission is granted to make and distribute verbatim copies of
-this manual provided the copyright notice and this permission notice
-are preserved on all copies.
-
-Permission is granted to copy and distribute modified versions of this
-manual under the conditions for verbatim copying, provided that the entire
-resulting derived work is distributed under the terms of a permission
-notice identical to this one.
-
-Permission is granted to copy and distribute translations of this manual
-into another language, under the above conditions for modified versions,
-except that this permission notice may be stated in a translation approved
-by the Free Software Foundation.
-
-@vskip 0pt plus 1filll
-Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
-@end titlepage
-
-@ifinfo
-@node Top
-@top GNU Readline Library
-
-This document describes the end user interface of the GNU Readline Library,
-a utility which aids in the consistency of user interface across discrete
-programs that need to provide a command line interface.
-
-@menu
-* Command Line Editing::	   GNU Readline User's Manual.
-@end menu
-@end ifinfo
-
-@include rluser.texinfo
-
-@contents
-@bye
diff --git a/readline/doc/texi2dvi b/readline/doc/texi2dvi
deleted file mode 100755
--- a/readline/doc/texi2dvi
+++ /dev/null
@@ -1,362 +0,0 @@
-#! /bin/sh
-# texi2dvi --- smartly produce DVI files from texinfo sources
-# $Id: texi2dvi,v 1.3 2001-02-07 08:23:27 jwe Exp $
-#
-# Copyright (C) 1992, 93, 94, 95, 96, 97, 98 Free Software Foundation, Inc.
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, you can either send email to this
-# program's maintainer or write to: The Free Software Foundation,
-# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.
-#
-# Commentary:
-#
-# Author: Noah Friedman <friedman@gnu.org>
-#
-# Please send bug reports, etc. to bug-texinfo@gnu.org.
-# If possible, please send a copy of the output of the script called with
-# the `--debug' option when making a bug report.
-#
-# In the interest of general portability, some common bourne shell
-# constructs were avoided because they weren't guaranteed to be available
-# in some earlier implementations.  I've tried to make this program as
-# portable as possible.  Welcome to unix, where the lowest common
-# denominator is rapidly diminishing.
-#
-# Among the more interesting lossages I noticed among Bourne shells:
-#     * No shell functions.
-#     * No `unset' builtin.
-#     * `shift' cannot take a numeric argument, and signals an error if
-#       there are no arguments to shift.
-#
-# Code:
-
-# Name by which this script was invoked.
-progname=`echo "$0" | sed -e 's/[^\/]*\///g'`
-
-# This string is expanded by rcs automatically when this file is checked out.
-rcs_revision='$Revision: 1.3 $'
-version=`set - $rcs_revision; echo $2`
-
-# To prevent hairy quoting and escaping later.
-bq='`'
-eq="'"
-
-usage="Usage: $0 [OPTION]... FILE...
-Run a Texinfo document through TeX.
-
-Options:
--b, --batch          No interaction (\nonstopmode in TeX).
--c, --clean          Remove all auxiliary files.
--D, --debug          Turn on shell debugging ($bq${bq}set -x$eq$eq).
--t, --texinfo CMD    Insert CMD after @setfilename before running TeX.
---verbose            Report on what is done.
--h, --help           Display this help and exit.
--v, --version        Display version information and exit.
-
-The values of the TEX, TEXINDEX, and MAKEINFO environment variables are
-used to run those commands, if they are set.
-
-Email bug reports to bug-texinfo@gnu.org."
-
-# Initialize variables.
-# Don't use `unset' since old bourne shells don't have this command.
-# Instead, assign them an empty value.
-# Some of these, like TEX and TEXINDEX, may be inherited from the environment.
-backup_extension=.bak # these files get deleted if all goes well.
-batch=
-clean=
-debug=
-orig_pwd="`pwd`"
-textra=
-verbose=false
-makeinfo="${MAKEINFO-makeinfo}"
-texindex="${TEXINDEX-texindex}"
-tex="${TEX-tex}"
-
-# Save this so we can construct a new TEXINPUTS path for each file.
-TEXINPUTS_orig="$TEXINPUTS"
-export TEXINPUTS
-
-# Parse command line arguments.
-# Make sure that all wildcarded options are long enough to be unambiguous.
-# It's a good idea to document the full long option name in each case.
-# Long options which take arguments will need a `*' appended to the
-# canonical name to match the value appended after the `=' character.
-while :; do
-  test $# -eq 0 && break
-  
-  case "$1" in
-    -b | --batch | --b* ) batch=t; shift ;;
-    -c | --clean | --c* ) clean=t; shift ;;
-    -D | --debug | --d* ) debug=t; shift ;;
-    -h | --help | --h* )   echo "$usage"; exit 0 ;;
-    # OK, we should do real option parsing here, but be lazy for now.
-    -t | --texinfo | --t*) shift; textra="$textra $1"; shift ;; 
-    -v | --vers* )
-      echo "$progname (GNU Texinfo 3.12) $version"
-      echo "Copyright (C) 1998 Free Software Foundation, Inc.
-There is NO warranty.  You may redistribute this software
-under the terms of the GNU General Public License.
-For more information about these matters, see the files named COPYING."
-      exit 0 ;;
-    --verb* )            verbose=echo; shift ;;
-    -- )     # Stop option processing
-      shift
-      break ;;
-    -* )
-      case "$1" in
-        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
-        * )     arg="$1" ;;
-      esac
-      exec 1>&2
-      echo "$progname: Unknown or ambiguous option $bq$arg$eq."
-      echo "$progname: Try $bq--help$eq for more information."
-      exit 1 ;;
-    * ) break ;;
-   esac
-done
-
-# See if there are any command line args left (which will be interpreted as
-# filename arguments).
-if test $# -eq 0; then
-  exec 1>&2
-  echo "$progname: At least one file name is required as an argument."
-  echo "$progname: Try $bq--help$eq for more information."
-  exit 2
-fi
-
-test "$debug" = t && set -x
-
-# Texify files
-for command_line_filename in ${1+"$@"}; do
-  $verbose "Processing $command_line_filename ..."
-
-  # See if file exists.  If it doesn't we're in trouble since, even
-  # though the user may be able to reenter a valid filename at the tex
-  # prompt (assuming they're attending the terminal), this script won't
-  # be able to find the right index files and so forth.
-  if test ! -r "${command_line_filename}"; then
-    echo "$0: Could not read ${command_line_filename}." >&2
-    continue
-  fi
-
-  # Roughly equivalent to `dirname ...`, but more portable
-  directory="`echo ${command_line_filename} | sed 's/\/[^\/]*$//'`"
-  filename_texi="`basename ${command_line_filename}`"
-  # Strip off the last extension part (probably .texinfo or .texi)
-  filename_noext="`echo ${filename_texi} | sed 's/\.[^.]*$//'`"
-
-  # Use same basename since we want to generate aux files with the same
-  # basename as the manual.  Use extension .texi for the temp file so
-  # that TeX will ignore it.  Thus, we must use a subdirectory.
-  #
-  # Output the macro-expanded file to here.  The vastly abbreviated
-  # temporary directory name is so we don't have collisions on 8.3 or
-  # 14-character filesystems.
-  tmp_dir=${TMPDIR-/tmp}/txi2d.$$
-  filename_tmp=$tmp_dir/$filename_noext.texi
-  # Output the file with the user's extra commands to here.
-  tmp_dir2=${tmp_dir}.2
-  filename_tmp2=$tmp_dir2/$filename_noext.texi
-  mkdir $tmp_dir $tmp_dir2
-  # Always remove the temporary directories.
-  trap "rm -rf $tmp_dir $tmp_dir2" 1 2 15
-
-  # If directory and file are the same, then it's probably because there's
-  # no pathname component.  Set dirname to `.', the current directory.
-  if test "z${directory}" = "z${command_line_filename}"; then
-    directory=.
-  fi
-
-  # Source file might @include additional texinfo sources.  Put `.' and
-  # directory where source file(s) reside in TEXINPUTS before anything
-  # else.  `.' goes first to ensure that any old .aux, .cps, etc. files in
-  # ${directory} don't get used in preference to fresher files in `.'.
-  TEXINPUTS=".:${directory}:${TEXINPUTS_orig}"
-
-  # Expand macro commands in the original source file using Makeinfo;
-  #   the macro syntax bfox implemented is impossible to implement in TeX.
-  # Always use `end' footnote style, since the `separate' style
-  #   generates different output (arguably this is a bug in -E).
-  # Discard main info output, the user asked to run TeX, not makeinfo.
-  # Redirect output to /dev/null to throw away `Making info file...' msg.
-  $verbose "Macro-expanding $command_line_filename to $filename_tmp ..."
-  $makeinfo --footnote-style=end -E $filename_tmp -o /dev/null \
-    $command_line_filename >/dev/null
-
-  # But if there were no macros, or makeinfo failed for some reason,
-  # just use the original file.  (It shouldn't make any difference, but
-  # let's be safe.)
-  if test $? -ne 0 || cmp -s $filename_tmp $command_line_filename; then
-    $verbose "Reverting to $command_line_filename ..."
-    cp -p $command_line_filename $filename_tmp
-  fi
-  filename_input=$filename_tmp
-  dirname_input=$tmp_dir
-
-  # Used most commonly for @finalout, @smallbook, etc.
-  if test -n "$textra"; then
-    $verbose "Inserting extra commands: $textra."
-    sed '/^@setfilename/a\
-'"$textra" $filename_input >$filename_tmp2
-   filename_input=$filename_tmp2
-   dirname_input=$tmp_dir2
-  fi
-
-  # If clean mode was specified, then move to the temporary directory.
-  if test "$clean" = t; then
-    $verbose "cd $dirname_input"
-    cd $dirname_input || exit 1
-    filename_input=`basename $filename_input`
-  fi
-
-  while true; do # will break out of loop below
-    # "Unset" variables that might have values from previous iterations and
-    # which won't be completely reset later.
-    definite_index_files=
-
-    # Find all files having root filename with a two-letter extension,
-    # determine whether they're really index files, and save them.  Foo.aux
-    # is actually the cross-references file, but we need to keep track of
-    # that too.
-    possible_index_files="`eval echo ${filename_noext}.?? ${filename_noext}.aux`"
-    for this_file in ${possible_index_files}; do
-      # If file is empty, forget it.
-      test -s "${this_file}" || continue
-
-      # Examine first character of file.  If it's not suitable to be an
-      # index or xref file, don't process it.
-      first_character="`sed -n '1s/^\(.\).*$/\1/p;q' ${this_file}`"
-      if test "x${first_character}" = "x\\" \
-         || test "x${first_character}" = "x'"; then
-        definite_index_files="${definite_index_files} ${this_file}"
-      fi
-    done
-    orig_index_files="${definite_index_files}"
-    orig_index_files_sans_aux="`echo ${definite_index_files} \
-                                 | sed 's/'${filename_noext}'\.aux//;
-                                        s/^[ ]*//;s/[ ]*$//;'`"
-
-    # Now save copies of original index files so we have some means of
-    # comparison later.
-    $verbose "Backing up current index files: $orig_index_files ..."  
-    for index_file_to_save in ${orig_index_files}; do
-      cp "${index_file_to_save}" "${index_file_to_save}${backup_extension}"
-    done
-
-    # Run texindex on current index files.  If they already exist, and
-    # after running TeX a first time the index files don't change, then
-    # there's no reason to run TeX again.  But we won't know that if the
-    # index files are out of date or nonexistent.
-    if test -n "${orig_index_files_sans_aux}"; then
-      $verbose "Running $texindex $orig_index_files_sans_aux ..."
-      ${texindex} ${orig_index_files_sans_aux}
-    fi
-
-    # Finally, run TeX.
-    if test "$batch" = t; then
-      tex_mode='\nonstopmode'
-    else
-      tex_mode=
-    fi
-    $verbose "Running $tex $filename_input ..."
-    cmd="$tex $tex_mode \\input $filename_input"
-    $cmd
-
-    # Check if index files changed.
-    # 
-    definite_index_files=
-    # Get list of new index files.
-    possible_index_files="`eval echo ${filename_noext}.?? ${filename_noext}.aux`"
-    for this_file in ${possible_index_files}; do
-       # If file is empty, forget it.
-       test -s "${this_file}" || continue
-
-       # Examine first character of file.  If it's not a backslash or
-       # single quote, then it's definitely not an index or xref file.
-       # (Will have to check for @ when we switch to Texinfo syntax in
-       # all these files...)
-       first_character="`sed -n '1s/^\(.\).*$/\1/p;q' ${this_file}`"
-       if test "x${first_character}" = "x\\" \
-          || test "x${first_character}" = "x'"; then
-         definite_index_files="${definite_index_files} ${this_file}"
-       fi
-    done
-    new_index_files="${definite_index_files}"
-    new_index_files_sans_aux="`echo ${definite_index_files} \
-                               | sed 's/'${filename_noext}'\.aux//;
-                                      s/^[ ]*//;s/[ ]*$//;'`"
-
-    # If old and new list don't at least have the same file list, then one
-    # file or another has definitely changed.
-    $verbose "Original index files =$orig_index_files"
-    $verbose "New index files =$new_index_files"
-    if test "z${orig_index_files}" != "z${new_index_files}"; then
-      index_files_changed_p=t
-    else
-      # File list is the same.  We must compare each file until we find a
-      # difference.
-      index_files_changed_p=
-      for this_file in ${new_index_files}; do
-        $verbose "Comparing index file $this_file ..."
-        # cmp -s will return nonzero exit status if files differ.
-        cmp -s "${this_file}" "${this_file}${backup_extension}"
-        if test $? -ne 0; then
-          # We only need to keep comparing until we find *one* that
-          # differs, because we'll have to run texindex & tex no
-          # matter what.
-          index_files_changed_p=t
-          $verbose "Index file $this_file differed:"
-          test $verbose = echo \
-          && diff -c "${this_file}${backup_extension}" "${this_file}"
-          break
-        fi
-      done
-    fi
-
-    # If index files have changed since TeX has been run, or if the aux
-    # file wasn't present originally, run texindex and TeX again.
-    if test "${index_files_changed_p}"; then :; else
-      # Nothing changed.  We're done with TeX.
-      break
-    fi
-  done
-
-  # If we were in clean mode, compilation was in a tmp directory.
-  # Copy the DVI file into the directory where the compilation
-  # has been done.  (The temp dir is about to get removed anyway.)
-  # We also return to the original directory so that
-  # - the next file is processed in correct conditions
-  # - the temporary file can be removed
-  if test -n "$clean"; then
-    $verbose "Copying DVI file from `pwd` to $orig_pwd"
-    cp -p $filename_noext.dvi $orig_pwd
-    cd $orig_pwd || exit 1
-  fi
-
-  # Generate list of files to delete, then call rm once with the entire
-  # list.  This is significantly faster than multiple executions of rm.
-  file_list=
-  for file in ${orig_index_files}; do
-    file_list="${file_list} ${file}${backup_extension}"
-  done
-  if test -n "${file_list}"; then
-    $verbose "Removing $file_list $tmp_dir $tmp_dir2 ..."
-    rm -f ${file_list}
-    rm -rf $tmp_dir $tmp_dir2
-  fi
-done
-
-$verbose "$0 done."
-true # exit successfully.
diff --git a/readline/doc/texi2html b/readline/doc/texi2html
deleted file mode 100755
--- a/readline/doc/texi2html
+++ /dev/null
@@ -1,2081 +0,0 @@
-#!/usr/local/bin/perl
-'di ';
-'ig 00 ';
-#+##############################################################################
-#                                                                              #
-# File: texi2html                                                              #
-#                                                                              #
-# Description: Program to transform most Texinfo documents to HTML             #
-#                                                                              #
-#-##############################################################################
-
-# @(#)texi2html	1.52 01/05/98	Written (mainly) by Lionel Cons, Lionel.Cons@cern.ch
-
-# The man page for this program is included at the end of this file and can be
-# viewed using the command 'nroff -man texi2html'.
-# Please read the copyright at the end of the man page.
-
-#+++############################################################################
-#                                                                              #
-# Constants                                                                    #
-#                                                                              #
-#---############################################################################
-
-$DEBUG_TOC   =  1;
-$DEBUG_INDEX =  2;
-$DEBUG_BIB   =  4;
-$DEBUG_GLOSS =  8;
-$DEBUG_DEF   = 16;
-$DEBUG_HTML  = 32;
-$DEBUG_USER  = 64;
-
-$BIBRE = '\[[\w\/-]+\]';		# RE for a bibliography reference
-$FILERE = '[\/\w.+-]+';			# RE for a file name
-$VARRE = '[^\s\{\}]+';			# RE for a variable name
-$NODERE = '[^@{}:\'`",]+';		# RE for a node name
-$NODESRE = '[^@{}:\'`"]+';		# RE for a list of node names
-$XREFRE = '[^@{}]+';			# RE for a xref (should use NODERE)
-
-$ERROR = "***";			        # prefix for errors and warnings
-$THISPROG = "texi2html 1.52";			# program name and version
-$HOMEPAGE = "http://wwwinfo.cern.ch/dis/texi2html/"; # program home page
-$TODAY = &pretty_date;			# like "20 September 1993"
-$SPLITTAG = "<!-- SPLIT HERE -->\n";	# tag to know where to split
-$PROTECTTAG = "_ThisIsProtected_";	# tag to recognize protected sections
-$html2_doctype = '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0 Strict Level 2//EN">';
-
-#
-# language dependent constants
-#
-#$LDC_SEE = 'see';
-#$LDC_SECTION = 'section';
-#$LDC_IN = 'in';
-#$LDC_TOC = 'Table of Contents';
-#$LDC_GOTO = 'Go to the';
-#$LDC_FOOT = 'Footnotes';
-# TODO: @def* shortcuts
-
-#
-# pre-defined indices
-#
-%predefined_index = (
-		    'cp', 'c',
-		    'fn', 'f',
-		    'vr', 'v',
-		    'ky', 'k',
-		    'pg', 'p',
-		    'tp', 't',
-	            );
-
-#
-# valid indices
-#
-%valid_index = (
-		    'c', 1,
-		    'f', 1,
-		    'v', 1,
-		    'k', 1,
-		    'p', 1,
-		    't', 1,
-		);
-
-#
-# texinfo section names to level
-#
-%sec2level = (
-	      'top', 0,
-	      'chapter', 1,
-	      'unnumbered', 1,
-	      'majorheading', 1,
-	      'chapheading', 1,
-	      'appendix', 1,
-	      'section', 2,
-	      'unnumberedsec', 2,
-	      'heading', 2,
-	      'appendixsec', 2,
-	      'appendixsection', 2,
-	      'subsection', 3,
-	      'unnumberedsubsec', 3,
-	      'subheading', 3,
-	      'appendixsubsec', 3,
-	      'subsubsection', 4,
-	      'unnumberedsubsubsec', 4,
-	      'subsubheading', 4,
-	      'appendixsubsubsec', 4,
-	      );
-
-#
-# accent map, TeX command to ISO name
-#
-%accent_map = (
-	       '"',  'uml',
-	       '~',  'tilde',
-	       '^',  'circ',
-	       '`',  'grave',
-	       '\'', 'acute',
-	       );
-
-#
-# texinfo "simple things" (@foo) to HTML ones
-#
-%simple_map = (
-	       # cf. makeinfo.c
-	       "*", "<BR>",		# HTML+
-	       " ", " ",
-	       "\n", "\n",
-	       "|", "",
-	       # spacing commands
-	       ":", "",
-	       "!", "!",
-	       "?", "?",
-	       ".", ".",
-	       "-", "",
-	       );
-
-#
-# texinfo "things" (@foo{}) to HTML ones
-#
-%things_map = (
-	       'TeX', 'TeX',
-	       'br', '<P>',		# paragraph break
-	       'bullet', '*',
-	       'copyright', '(C)',
-	       'dots', '...',
-	       'equiv', '==',
-	       'error', 'error-->',
-	       'expansion', '==>',
-	       'minus', '-',
-	       'point', '-!-',
-	       'print', '-|',
-	       'result', '=>',
-	       'today', $TODAY,
-	       );
-
-#
-# texinfo styles (@foo{bar}) to HTML ones
-#
-%style_map = (
-	      'asis', '',
-	      'b', 'B',
-	      'cite', 'CITE',
-	      'code', 'CODE',
-	      'ctrl', '&do_ctrl',	# special case
-	      'dfn', 'EM',		# DFN tag is illegal in the standard
-	      'dmn', '',		# useless
-	      'email', '&do_email',     # insert a clickable email address
-	      'emph', 'EM',
-	      'file', '"TT',		# will put quotes, cf. &apply_style
-	      'i', 'I',
-	      'kbd', 'KBD',
-	      'key', 'KBD',
-	      'math', 'EM',
-	      'r', '',			# unsupported
-	      'samp', '"SAMP',		# will put quotes, cf. &apply_style
-	      'sc', '&do_sc',		# special case
-	      'strong', 'STRONG',
-	      't', 'TT',
-	      'titlefont', '',		# useless
-	      'uref', '&do_uref',       # insert a clickable URL
-	      'url', '&do_url',         # insert a clickable URL
-	      'var', 'VAR',
-	      'w', '',			# unsupported
-	      );
-
-#
-# texinfo format (@foo/@end foo) to HTML ones
-#
-%format_map = (
-	       'display', 'PRE',
-	       'example', 'PRE',
-	       'format', 'PRE',
-	       'lisp', 'PRE',
-	       'quotation', 'BLOCKQUOTE',
-	       'smallexample', 'PRE',
-	       'smalllisp', 'PRE',
-	       # lists
-	       'itemize', 'UL',
-	       'enumerate', 'OL',
-	       # poorly supported
-	       'flushleft', 'PRE',
-	       'flushright', 'PRE',
-	       );
-
-#
-# texinfo definition shortcuts to real ones
-#
-%def_map = (
-	    # basic commands
-	    'deffn', 0,
-	    'defvr', 0,
-	    'deftypefn', 0,
-	    'deftypevr', 0,
-	    'defcv', 0,
-	    'defop', 0,
-	    'deftp', 0,
-	    # basic x commands
-	    'deffnx', 0,
-	    'defvrx', 0,
-	    'deftypefnx', 0,
-	    'deftypevrx', 0,
-	    'defcvx', 0,
-	    'defopx', 0,
-	    'deftpx', 0,
-	    # shortcuts
-	    'defun', 'deffn Function',
-	    'defmac', 'deffn Macro',
-	    'defspec', 'deffn {Special Form}',
-	    'defvar', 'defvr Variable',
-	    'defopt', 'defvr {User Option}',
-	    'deftypefun', 'deftypefn Function',
-	    'deftypevar', 'deftypevr Variable',
-	    'defivar', 'defcv {Instance Variable}',
-	    'defmethod', 'defop Method',
-	    # x shortcuts
-	    'defunx', 'deffnx Function',
-	    'defmacx', 'deffnx Macro',
-	    'defspecx', 'deffnx {Special Form}',
-	    'defvarx', 'defvrx Variable',
-	    'defoptx', 'defvrx {User Option}',
-	    'deftypefunx', 'deftypefnx Function',
-	    'deftypevarx', 'deftypevrx Variable',
-	    'defivarx', 'defcvx {Instance Variable}',
-	    'defmethodx', 'defopx Method',
-	    );
-
-#
-# things to skip
-#
-%to_skip = (
-	    # comments
-	    'c', 1,
-	    'comment', 1,
-	    # useless
-	    'contents', 1,
-	    'shortcontents', 1,
-	    'summarycontents', 1,
-	    'footnotestyle', 1,
-	    'end ifclear', 1,
-	    'end ifset', 1,
-	    'titlepage', 1,
-	    'end titlepage', 1,
-	    # unsupported commands (formatting)
-	    'afourpaper', 1,
-	    'cropmarks', 1,
-	    'finalout', 1,
-	    'headings', 1,
-	    'need', 1,
-	    'page', 1,
-	    'setchapternewpage', 1,
-	    'everyheading', 1,
-	    'everyfooting', 1,
-	    'evenheading', 1,
-	    'evenfooting', 1,
-	    'oddheading', 1,
-	    'oddfooting', 1,
-	    'smallbook', 1,
-	    'vskip', 1,
-	    'filbreak', 1,
-	    'paragraphindent', 1,
-	    # unsupported formats
-	    'cartouche', 1,
-	    'end cartouche', 1,
-	    'group', 1,
-	    'end group', 1,
-	    );
-
-#+++############################################################################
-#                                                                              #
-# Argument parsing, initialisation                                             #
-#                                                                              #
-#---############################################################################
-
-%value = ();				# hold texinfo variables, see also -D
-
-$use_bibliography = 1;
-$use_acc = 0;
-$debug = 0;
-$doctype = '';
-$check = 0;
-$expandinfo = 0;
-$use_glossary = 0;
-$invisible_mark = '';
-$use_iso = 0;
-@include_dirs = ();
-$show_menu = 0;
-$number_sections = 0;
-$split_node = 0;
-$split_chapter = 0;
-$monolithic = 0;
-$verbose = 0;
-$usage = <<EOT;
-This is $THISPROG
-To convert a Texinfo file to HMTL: $0 [options] file
-  where options can be:
-    -expandinfo    : use \@ifinfo sections, not \@iftex
-    -glossary      : handle a glossary
-    -invisible name: use 'name' as an invisible anchor
-    -Dname         : define name like with \@set
-    -I dir         : search also for files in 'dir'
-    -menu          : handle menus
-    -monolithic    : output only one file including ToC
-    -number        : number sections
-    -split_chapter : split on main sections
-    -split_node    : split on nodes
-    -usage         : print usage instructions
-    -verbose       : verbose output
-To check converted files: $0 -check [-verbose] files
-EOT
-
-while (@ARGV && $ARGV[0] =~ /^-/) {
-    $_ = shift(@ARGV);
-    if (/^-acc$/)            { $use_acc = 1; next; }
-    if (/^-d(ebug)?(\d+)?$/) { $debug = $2 || shift(@ARGV); next; }
-    if (/^-doctype$/)        { $doctype = shift(@ARGV); next; }
-    if (/^-c(heck)?$/)       { $check = 1; next; }
-    if (/^-e(xpandinfo)?$/)  { $expandinfo = 1; next; }
-    if (/^-g(lossary)?$/)    { $use_glossary = 1; next; }
-    if (/^-i(nvisible)?$/)   { $invisible_mark = shift(@ARGV); next; }
-    if (/^-iso$/)            { $use_iso = 1; next; }
-    if (/^-D(.+)?$/)         { $value{$1 || shift(@ARGV)} = 1; next; }
-    if (/^-I(.+)?$/)         { push(@include_dirs, $1 || shift(@ARGV)); next; }
-    if (/^-m(enu)?$/)        { $show_menu = 1; next; }
-    if (/^-mono(lithic)?$/)  { $monolithic = 1; next; }
-    if (/^-n(umber)?$/)      { $number_sections = 1; next; }
-    if (/^-s(plit)?_?(n(ode)?|c(hapter)?)?$/) {
-	if ($2 =~ /^n/) {
-	    $split_node = 1;
-	} else {
-	    $split_chapter = 1;
-	}
-	next;
-    }
-    if (/^-v(erbose)?$/)     { $verbose = 1; next; }
-    die $usage;
-}
-if ($check) {
-    die $usage unless @ARGV > 0;
-    &check;
-    exit;
-}
-
-if (($split_node || $split_chapter) && $monolithic) {
-    warn "Can't use -monolithic with -split, -monolithic ignored.\n";
-    $monolithic = 0;
-}
-if ($expandinfo) {
-    $to_skip{'ifinfo'}++;
-    $to_skip{'end ifinfo'}++;
-} else {
-    $to_skip{'iftex'}++;
-    $to_skip{'end iftex'}++;
-}
-$invisible_mark = '<IMG SRC="invisible.xbm">' if $invisible_mark eq 'xbm';
-die $usage unless @ARGV == 1;
-$docu = shift(@ARGV);
-if ($docu =~ /.*\//) {
-    chop($docu_dir = $&);
-    $docu_name = $';
-} else {
-    $docu_dir = '.';
-    $docu_name = $docu;
-}
-unshift(@include_dirs, $docu_dir);
-$docu_name =~ s/\.te?x(i|info)?$//;	# basename of the document
-
-$docu_doc = "$docu_name.html";		# document's contents
-if ($monolithic) {
-    $docu_toc = $docu_foot = $docu_doc;
-} else {
-    $docu_toc  = "${docu_name}_toc.html";  # document's table of contents
-    $docu_foot = "${docu_name}_foot.html"; # document's footnotes
-}
-
-#
-# variables
-#
-$value{'html'} = 1;			# predefine html (the output format)
-$value{'texi2html'} = '1.52';		# predefine texi2html (the translator)
-# _foo: internal to track @foo
-foreach ('_author', '_title', '_subtitle',
-	 '_settitle', '_setfilename') {
-    $value{$_} = '';		        # prevent -w warnings
-}
-%node2sec = ();				# node to section name
-%node2href = ();			# node to HREF
-%bib2href = ();				# bibliography reference to HREF
-%gloss2href = ();			# glossary term to HREF
-@sections = ();				# list of sections
-%tag2pro = ();				# protected sections
-
-#
-# initial indexes
-#
-$bib_num = 0;
-$foot_num = 0;
-$gloss_num = 0;
-$idx_num = 0;
-$sec_num = 0;
-$doc_num = 0;
-$html_num = 0;
-
-#
-# can I use ISO8879 characters? (HTML+)
-#
-if ($use_iso) {
-    $things_map{'bullet'} = "&bull;";
-    $things_map{'copyright'} = "&copy;";
-    $things_map{'dots'} = "&hellip;";
-    $things_map{'equiv'} = "&equiv;";
-    $things_map{'expansion'} = "&rarr;";
-    $things_map{'point'} = "&lowast;";
-    $things_map{'result'} = "&rArr;";
-}
-
-#
-# read texi2html extensions (if any)
-#
-$extensions = 'texi2html.ext'; # extensions in working directory
-if (-f $extensions) {
-    print "# reading extensions from $extensions\n" if $verbose;
-    require($extensions);
-}
-($progdir = $0) =~ s/[^\/]+$//;
-if ($progdir && ($progdir ne './')) {
-    $extensions = "${progdir}texi2html.ext"; # extensions in texi2html directory
-    if (-f $extensions) {
-	print "# reading extensions from $extensions\n" if $verbose;
-	require($extensions);
-    }
-}
-
-print "# reading from $docu\n" if $verbose;
-
-#+++############################################################################
-#                                                                              #
-# Pass 1: read source, handle command, variable, simple substitution           #
-#                                                                              #
-#---############################################################################
-
-@lines = ();				# whole document
-@toc_lines = ();			# table of contents
-$toplevel = 0;			        # top level seen in hierarchy
-$curlevel = 0;				# current level in TOC
-$node = '';				# current node name
-$in_table = 0;				# am I inside a table
-$table_type = '';			# type of table ('', 'f', 'v', 'multi')
-@tables = ();			        # nested table support
-$in_bibliography = 0;			# am I inside a bibliography
-$in_glossary = 0;			# am I inside a glossary
-$in_top = 0;				# am I inside the top node
-$in_pre = 0;				# am I inside a preformatted section
-$in_list = 0;				# am I inside a list
-$in_html = 0;				# am I inside an HTML section
-$first_line = 1;		        # is it the first line
-$dont_html = 0;				# don't protect HTML on this line
-$split_num = 0;				# split index
-$deferred_ref = '';			# deferred reference for indexes
-@html_stack = ();			# HTML elements stack
-$html_element = '';			# current HTML element
-&html_reset;
-
-# build code for simple substitutions
-# the maps used (%simple_map and %things_map) MUST be aware of this
-# watch out for regexps, / and escaped characters!
-$subst_code = '';
-foreach (keys(%simple_map)) {
-    ($re = $_) =~ s/(\W)/\\$1/g; # protect regexp chars
-    $subst_code .= "s/\\\@$re/$simple_map{$_}/g;\n";
-}
-foreach (keys(%things_map)) {
-    $subst_code .= "s/\\\@$_\\{\\}/$things_map{$_}/g;\n";
-}
-if ($use_acc) {
-    # accentuated characters
-    foreach (keys(%accent_map)) {
-	if ($_ eq "`") {
-	    $subst_code .= "s/$;3";
-	} elsif ($_ eq "'") {
-	    $subst_code .= "s/$;4";
-	} else {
-	    $subst_code .= "s/\\\@\\$_";
-	}
-	$subst_code .= "([aeiou])/&\${1}$accent_map{$_};/gi;\n";
-    }
-}
-eval("sub simple_substitutions { $subst_code }");
-
-&init_input;
-while ($_ = &next_line) {
-    #
-    # remove \input on the first lines only
-    #
-    if ($first_line) {
-	next if /^\\input/;
-	$first_line = 0;
-    }
-    #
-    # parse texinfo tags
-    #
-    $tag = '';
-    $end_tag = '';
-    if (/^\@end\s+(\w+)\b/) {
-	$end_tag = $1;
-    } elsif (/^\@(\w+)\b/) {
-	$tag = $1;
-    }
-    #
-    # handle @ifhtml / @end ifhtml
-    #
-    if ($in_html) {
-	if ($end_tag eq 'ifhtml') {
-	    $in_html = 0;
-	} else {
-	    $tag2pro{$in_html} .= $_;
-	}
-	next;
-    } elsif ($tag eq 'ifhtml') {
-	$in_html = $PROTECTTAG . ++$html_num;
-	push(@lines, $in_html);
-	next;
-    }
-    #
-    # try to skip the line
-    #
-    if ($end_tag) {
-	next if $to_skip{"end $end_tag"};
-    } elsif ($tag) {
-	next if $to_skip{$tag};
-	last if $tag eq 'bye';
-    }
-    if ($in_top) {
-	# parsing the top node
-	if ($tag eq 'node' || $tag eq 'include' || $sec2level{$tag}) {
-	    # no more in top
-	    $in_top = 0;
-	} else {
-	    # skip it
-	    next;
-	}
-    }
-    #
-    # try to remove inlined comments
-    # syntax from tex-mode.el comment-start-skip
-    #
-    s/((^|[^\@])(\@\@)*)\@c(omment)? .*/$1/;
-    # non-@ substitutions cf. texinfmt.el
-    unless ($in_pre) {
-	s/``/\"/g;
-	s/''/\"/g;
-	s/([\w ])---([\w ])/$1--$2/g;
-    }
-    #
-    # analyze the tag
-    #
-    if ($tag) {
-	# skip lines
-	&skip_until($tag), next if $tag eq 'ignore';
-	if ($expandinfo) {
-	    &skip_until($tag), next if $tag eq 'iftex';
-	} else {
-	    &skip_until($tag), next if $tag eq 'ifinfo';
-	}
-	&skip_until($tag), next if $tag eq 'tex';
-	# handle special tables
-	if ($tag =~ /^(|f|v|multi)table$/) {
-	    $table_type = $1;
-	    $tag = 'table';
-	}
-	# special cases
-	if ($tag eq 'top' || ($tag eq 'node' && /^\@node\s+top\s*,/i)) {
-	    $in_top = 1;
-	    @lines = (); # ignore all lines before top (title page garbage)
-	    next;
-	} elsif ($tag eq 'node') {
-	    $in_top = 0;
-	    warn "$ERROR Bad node line: $_" unless $_ =~ /^\@node\s$NODESRE$/o;
-	    $_ = &protect_html($_); # if node contains '&' for instance
-	    s/^\@node\s+//;
-	    ($node) = split(/,/);
-	    &normalise_node($node);
-	    if ($split_node) {
-		&next_doc;
-		push(@lines, $SPLITTAG) if $split_num++;
-		push(@sections, $node);
-	    }
-	    next;
-	} elsif ($tag eq 'include') {
-	    if (/^\@include\s+($FILERE)\s*$/o) {
-		$file = $1;
-		unless (-e $file) {
-		    foreach $dir (@include_dirs) {
-			$file = "$dir/$1";
-			last if -e $file;
-		    }
-		}
-		if (-e $file) {
-		    &open($file);
-		    print "# including $file\n" if $verbose;
-		} else {
-		    warn "$ERROR Can't find $file, skipping";
-		}
-	    } else {
-		warn "$ERROR Bad include line: $_";
-	    }
-	    next;
-	} elsif ($tag eq 'ifclear') {
-	    if (/^\@ifclear\s+($VARRE)\s*$/o) {
-		next unless defined($value{$1});
-		&skip_until($tag);
-	    } else {
-		warn "$ERROR Bad ifclear line: $_";
-	    }
-	    next;
-	} elsif ($tag eq 'ifset') {
-	    if (/^\@ifset\s+($VARRE)\s*$/o) {
-		next if defined($value{$1});
-		&skip_until($tag);
-	    } else {
-		warn "$ERROR Bad ifset line: $_";
-	    }
-	    next;
-	} elsif ($tag eq 'menu') {
-	    unless ($show_menu) {
-		&skip_until($tag);
-		next;
-	    }
-	    &html_push_if($tag);
-	    push(@lines, &html_debug("\n", __LINE__));
-	} elsif ($format_map{$tag}) {
-	    $in_pre = 1 if $format_map{$tag} eq 'PRE';
-	    &html_push_if($format_map{$tag});
-	    push(@lines, &html_debug("\n", __LINE__));
-	    $in_list++ if $format_map{$tag} eq 'UL' || $format_map{$tag} eq 'OL' ;
-	    push(@lines, &debug("<$format_map{$tag}>\n", __LINE__));
-	    next;
-	} elsif ($tag eq 'table') {
-	    if (/^\@(|f|v|multi)table\s+\@(\w+)/) {
-		$in_table = $2;
-		unshift(@tables, join($;, $table_type, $in_table));
-		if ($table_type eq "multi") {
-		    push(@lines, &debug("<TABLE BORDER>\n", __LINE__));
-		    &html_push_if('TABLE');
-		} else {
-		    push(@lines, &debug("<DL COMPACT>\n", __LINE__));
-		    &html_push_if('DL');
-		}
-		push(@lines, &html_debug("\n", __LINE__));
-	    } else {
-		warn "$ERROR Bad table line: $_";
-	    }
-	    next;
-	} elsif ($tag eq 'synindex' || $tag eq 'syncodeindex') {
-	    if (/^\@$tag\s+(\w)\w\s+(\w)\w\s*$/) {
-		eval("*${1}index = *${2}index");
-	    } else {
-		warn "$ERROR Bad syn*index line: $_";
-	    }
-	    next;
-	} elsif ($tag eq 'sp') {
-	    push(@lines, &debug("<P>\n", __LINE__));
-	    next;
-	} elsif ($tag eq 'setref') {
-	    &protect_html; # if setref contains '&' for instance
-	    if (/^\@$tag\s*{($NODERE)}\s*$/) {
-		$setref = $1;
-		$setref =~ s/\s+/ /g; # normalize
-		$setref =~ s/ $//;
-		$node2sec{$setref} = $name;
-		$node2href{$setref} = "$docu_doc#$docid";
-	    } else {
-		warn "$ERROR Bad setref line: $_";
-	    }
-	    next;
-	} elsif ($tag eq 'defindex' || $tag eq 'defcodeindex') {
-	    if (/^\@$tag\s+(\w\w)\s*$/) {
-		$valid_index{$1} = 1;
-	    } else {
-		warn "$ERROR Bad defindex line: $_";
-	    }
-	    next;
-	} elsif (defined($def_map{$tag})) {
-	    if ($def_map{$tag}) {
-		s/^\@$tag\s+//;
-		$tag = $def_map{$tag};
-		$_ = "\@$tag $_";
-		$tag =~ s/\s.*//;
-	    }
-	} elsif (defined($user_sub{$tag})) {
-	    s/^\@$tag\s+//;
-	    $sub = $user_sub{$tag};
-	    print "# user $tag = $sub, arg: $_" if $debug & $DEBUG_USER;
-	    if (defined(&$sub)) {
-		chop($_);
-		&$sub($_);
-	    } else {
-		warn "$ERROR Bad user sub for $tag: $sub\n";
-	    }
-	    next;
-	}
-	if (defined($def_map{$tag})) {
-	    s/^\@$tag\s+//;
-	    if ($tag =~ /x$/) {
-		# extra definition line
-		$tag = $`;
-		$is_extra = 1;
-	    } else {
-		$is_extra = 0;
-	    }
-	    while (/\{([^\{\}]*)\}/) {
-		# this is a {} construct
-		($before, $contents, $after) = ($`, $1, $');
-		# protect spaces
-		$contents =~ s/\s+/$;9/g;
-		# restore $_ protecting {}
-		$_ = "$before$;7$contents$;8$after";
-	    }
-	    @args = split(/\s+/, &protect_html($_));
-	    foreach (@args) {
-		s/$;9/ /g;	# unprotect spaces
-		s/$;7/\{/g;	# ... {
-		s/$;8/\}/g;	# ... }
-	    }
-	    $type = shift(@args);
-	    $type =~ s/^\{(.*)\}$/$1/;
-	    print "# def ($tag): {$type} ", join(', ', @args), "\n"
-		if $debug & $DEBUG_DEF;
-	    $type .= ':'; # it's nicer like this
-	    $name = shift(@args);
-	    $name =~ s/^\{(.*)\}$/$1/;
-	    if ($is_extra) {
-		$_ = &debug("<DT>", __LINE__);
-	    } else {
-		$_ = &debug("<DL>\n<DT>", __LINE__);
-	    }
-	    if ($tag eq 'deffn' || $tag eq 'defvr' || $tag eq 'deftp') {
-		$_ .= "<U>$type</U> <B>$name</B>";
-		$_ .= " <I>@args</I>" if @args;
-	    } elsif ($tag eq 'deftypefn' || $tag eq 'deftypevr'
-		     || $tag eq 'defcv' || $tag eq 'defop') {
-		$ftype = $name;
-		$name = shift(@args);
-		$name =~ s/^\{(.*)\}$/$1/;
-		$_ .= "<U>$type</U> $ftype <B>$name</B>";
-		$_ .= " <I>@args</I>" if @args;
-	    } else {
-		warn "$ERROR Unknown definition type: $tag\n";
-		$_ .= "<U>$type</U> <B>$name</B>";
-		$_ .= " <I>@args</I>" if @args;
-	    }
- 	    $_ .= &debug("\n<DD>", __LINE__);
-	    $name = &unprotect_html($name);
-	    if ($tag eq 'deffn' || $tag eq 'deftypefn') {
-		unshift(@input_spool, "\@findex $name\n");
-	    } elsif ($tag eq 'defop') {
-		unshift(@input_spool, "\@findex $name on $ftype\n");
-	    } elsif ($tag eq 'defvr' || $tag eq 'deftypevr' || $tag eq 'defcv') {
-		unshift(@input_spool, "\@vindex $name\n");
-	    } else {
-		unshift(@input_spool, "\@tindex $name\n");
-	    }
-	    $dont_html = 1;
-	}
-    } elsif ($end_tag) {
-	if ($format_map{$end_tag}) {
-	    $in_pre = 0 if $format_map{$end_tag} eq 'PRE';
-	    $in_list-- if $format_map{$end_tag} eq 'UL' || $format_map{$end_tag} eq 'OL' ;
-	    &html_pop_if('LI', 'P');
-	    &html_pop_if();
-	    push(@lines, &debug("</$format_map{$end_tag}>\n", __LINE__));
-	    push(@lines, &html_debug("\n", __LINE__));
-	} elsif ($end_tag =~ /^(|f|v|multi)table$/) {
-	    unless (@tables) {
-		warn "$ERROR \@end $end_tag without \@*table\n";
-		next;
-	    }
-	    ($table_type, $in_table) = split($;, shift(@tables));
-	    unless ($1 eq $table_type) {
-		warn "$ERROR \@end $end_tag without matching \@$end_tag\n";
-		next;
-	    }
-	    if ($table_type eq "multi") {
-		push(@lines, "</TR></TABLE>\n");
-		&html_pop_if('TR');
-	    } else {
-		push(@lines, "</DL>\n");
-		&html_pop_if('DD');
-	    }
-	    &html_pop_if();
-	    if (@tables) {
-		($table_type, $in_table) = split($;, $tables[0]);
-	    } else {
-		$in_table = 0;
-	    }
-	} elsif (defined($def_map{$end_tag})) {
- 	    push(@lines, &debug("</DL>\n", __LINE__));
-	} elsif ($end_tag eq 'menu') {
-	    &html_pop_if();
-	    push(@lines, $_); # must keep it for pass 2
-	}
-	next;
-    }
-    #
-    # misc things
-    #
-    # protect texi and HTML things
-    &protect_texi;
-    $_ = &protect_html($_) unless $dont_html;
-    $dont_html = 0;
-    # substitution (unsupported things)
-    s/^\@center\s+//g;
-    s/^\@exdent\s+//g;
-    s/\@noindent\s+//g;
-    s/\@refill\s+//g;
-    # other substitutions
-    &simple_substitutions;
-    s/\@value{($VARRE)}/$value{$1}/eg;
-    s/\@footnote\{/\@footnote$docu_doc\{/g; # mark footnotes, cf. pass 4
-    #
-    # analyze the tag again
-    #
-    if ($tag) {
-	if (defined($sec2level{$tag}) && $sec2level{$tag} > 0) {
-	    if (/^\@$tag\s+(.+)$/) {
-		$name = $1;
-		$name =~ s/\s+$//;
-		$level = $sec2level{$tag};
-		$name = &update_sec_num($tag, $level) . "  $name"
-		    if $number_sections && $tag !~ /^unnumbered/;
-		if ($tag =~ /heading$/) {
-		    push(@lines, &html_debug("\n", __LINE__));
-		    if ($html_element ne 'body') {
-			# We are in a nice pickle here. We are trying to get a H? heading
-			# even though we are not in the body level. So, we convert it to a
-			# nice, bold, line by itself.
-			$_ = &debug("\n\n<P><STRONG>$name</STRONG></P>\n\n", __LINE__);
-		    } else {
-			$_ = &debug("<H$level>$name</H$level>\n", __LINE__);
-			&html_push_if('body');
-		    }
-		    print "# heading, section $name, level $level\n"
-			if $debug & $DEBUG_TOC;
-		} else {
-		    if ($split_chapter) {
-			unless ($toplevel) {
-			    # first time we see a "section"
-			    unless ($level == 1) {
-				warn "$ERROR The first section found is not of level 1: $_";
-				warn "$ERROR I'll split on sections of level $level...\n";
-			    }
-			    $toplevel = $level;
-			}
-			if ($level == $toplevel) {
-			    &next_doc;
-			    push(@lines, $SPLITTAG) if $split_num++;
-			    push(@sections, $name);
-			}
-		    }
-		    $sec_num++;
-		    $docid = "SEC$sec_num";
-		    $tocid = "TOC$sec_num";
-		    # check biblio and glossary
-		    $in_bibliography = ($name =~ /^([A-Z]|\d+)?(\.\d+)*\s*bibliography$/i);
-		    $in_glossary = ($name =~ /^([A-Z]|\d+)?(\.\d+)*\s*glossary$/i);
-		    # check node
-		    if ($node) {
-			if ($node2sec{$node}) {
-			    warn "$ERROR Duplicate node found: $node\n";
-			} else {
-			    $node2sec{$node} = $name;
-			    $node2href{$node} = "$docu_doc#$docid";
-			    print "# node $node, section $name, level $level\n"
-				if $debug & $DEBUG_TOC;
-			}
-			$node = '';
-		    } else {
-			print "# no node, section $name, level $level\n"
-			    if $debug & $DEBUG_TOC;
-		    }
-		    # update TOC
-		    while ($level > $curlevel) {
-			$curlevel++;
-			push(@toc_lines, "<UL>\n");
-		    }
-		    while ($level < $curlevel) {
-			$curlevel--;
-			push(@toc_lines, "</UL>\n");
-		    }
-		    $_ = "<LI>" . &anchor($tocid, "$docu_doc#$docid", $name, 1);
-		    push(@toc_lines, &substitute_style($_));
-		    # update DOC
-		    push(@lines, &html_debug("\n", __LINE__));
-		    &html_reset;
-		    $_ =  "<H$level>".&anchor($docid, "$docu_toc#$tocid", $name)."</H$level>\n";
-		    $_ = &debug($_, __LINE__);
-		    push(@lines, &html_debug("\n", __LINE__));
-		}
-		# update DOC
-		foreach $line (split(/\n+/, $_)) {
-		    push(@lines, "$line\n");
-		}
-		next;
-	    } else {
-		warn "$ERROR Bad section line: $_";
-	    }
-	} else {
-	    # track variables
-	    $value{$1} = $2, next if /^\@set\s+($VARRE)\s+(.*)$/o;
-	    delete $value{$1}, next if /^\@clear\s+($VARRE)\s*$/o;
-	    # store things
-	    $value{'_setfilename'}   = $1, next if /^\@setfilename\s+(.*)$/;
-	    $value{'_settitle'}      = $1, next if /^\@settitle\s+(.*)$/;
-	    $value{'_author'}   .= "$1\n", next if /^\@author\s+(.*)$/;
-	    $value{'_subtitle'} .= "$1\n", next if /^\@subtitle\s+(.*)$/;
-	    $value{'_title'}    .= "$1\n", next if /^\@title\s+(.*)$/;
-	    # index
-	    if (/^\@(..?)index\s+/) {
-		unless ($valid_index{$1}) {
-		    warn "$ERROR Undefined index command: $_";
-		    next;
-		}
-		$id = 'IDX' . ++$idx_num;
-		$index = $1 . 'index';
-		$what = &substitute_style($');
-		$what =~ s/\s+$//;
-		print "# found $index for '$what' id $id\n"
-		    if $debug & $DEBUG_INDEX;
-		eval(<<EOC);
-		if (defined(\$$index\{\$what\})) {
-		    \$$index\{\$what\} .= "$;$docu_doc#$id";
-		} else {
-		    \$$index\{\$what\} = "$docu_doc#$id";
-		}
-EOC
-		#
-		# dirty hack to see if I can put an invisible anchor...
-		#
-		if ($html_element eq 'P' ||
-		    $html_element eq 'LI' ||
-		    $html_element eq 'DT' ||
-		    $html_element eq 'DD' ||
-		    $html_element eq 'ADDRESS' ||
-		    $html_element eq 'B' ||
-		    $html_element eq 'BLOCKQUOTE' ||
-		    $html_element eq 'PRE' ||
-		    $html_element eq 'SAMP') {
-                    push(@lines, &anchor($id, '', $invisible_mark, !$in_pre));
-                } elsif ($html_element eq 'body') {
-		    push(@lines, &debug("<P>\n", __LINE__));
-                    push(@lines, &anchor($id, '', $invisible_mark, !$in_pre));
-		    &html_push('P');
-		} elsif ($html_element eq 'DL' ||
-			 $html_element eq 'UL' ||
-			 $html_element eq 'OL' ) {
-		    $deferred_ref .= &anchor($id, '', $invisible_mark, !$in_pre) . " ";
-		}
-		next;
-	    }
-	    # list item
-	    if (/^\@itemx?\s+/) {
-		$what = $';
-		$what =~ s/\s+$//;
-		if ($in_bibliography && $use_bibliography) {
-		    if ($what =~ /^$BIBRE$/o) {
-			$id = 'BIB' . ++$bib_num;
-			$bib2href{$what} = "$docu_doc#$id";
-			print "# found bibliography for '$what' id $id\n"
-			    if $debug & $DEBUG_BIB;
-			$what = &anchor($id, '', $what);
-		    }
-		} elsif ($in_glossary && $use_glossary) {
-		    $id = 'GLOSS' . ++$gloss_num;
-		    $entry = $what;
-		    $entry =~ tr/A-Z/a-z/ unless $entry =~ /^[A-Z\s]+$/;
-		    $gloss2href{$entry} = "$docu_doc#$id";
-		    print "# found glossary for '$entry' id $id\n"
-			if $debug & $DEBUG_GLOSS;
-		    $what = &anchor($id, '', $what);
-		}
-		&html_pop_if('P');
-		if ($html_element eq 'DL' || $html_element eq 'DD') {
-		    if ($things_map{$in_table} && !$what) {
-			# special case to allow @table @bullet for instance
-			push(@lines, &debug("<DT>$things_map{$in_table}\n", __LINE__));
-		    } else {
-			push(@lines, &debug("<DT>\@$in_table\{$what\}\n", __LINE__));
-		    }
-		    push(@lines, "<DD>");
-		    &html_push('DD') unless $html_element eq 'DD';
-		    if ($table_type) { # add also an index
-			unshift(@input_spool, "\@${table_type}index $what\n");
-		    }
-		} elsif ($html_element eq 'TABLE') {
-		    push(@lines, &debug("<TR><TD>$what</TD>\n", __LINE__));
-		    &html_push('TR');
-		} elsif ($html_element eq 'TR') {
-		    push(@lines, &debug("</TR>\n", __LINE__));
-		    push(@lines, &debug("<TR><TD>$what</TD>\n", __LINE__));
-		} else {
-		    push(@lines, &debug("<LI>$what\n", __LINE__));
-		    &html_push('LI') unless $html_element eq 'LI';
-		}
-		push(@lines, &html_debug("\n", __LINE__));
-		if ($deferred_ref) {
-		    push(@lines, &debug("$deferred_ref\n", __LINE__));
-		    $deferred_ref = '';
-		}
-		next;
-	    } elsif (/^\@tab\s+(.*)$/) {
-		push(@lines, "<TD>$1</TD>\n");
-		next;
-	    }
-	}
-    }
-    # paragraph separator
-    if ($_ eq "\n") {
-	next if $#lines >= 0 && $lines[$#lines] eq "\n";
-	if ($html_element eq 'P') {
-	    push(@lines, "\n");
-	    $_ = &debug("</P>\n", __LINE__);
-	    &html_pop;
-	}
-    } elsif ($html_element eq 'body' || $html_element eq 'BLOCKQUOTE') {
-	push(@lines, "<P>\n");
-	&html_push('P');
-	$_ = &debug($_, __LINE__);
-    }
-    # otherwise
-    push(@lines, $_);
-}
-
-# finish TOC
-$level = 0;
-while ($level < $curlevel) {
-    $curlevel--;
-    push(@toc_lines, "</UL>\n");
-}
-
-print "# end of pass 1\n" if $verbose;
-
-#+++############################################################################
-#                                                                              #
-# Pass 2/3: handle style, menu, index, cross-reference                         #
-#                                                                              #
-#---############################################################################
-
-@lines2 = ();				# whole document (2nd pass)
-@lines3 = ();				# whole document (3rd pass)
-$in_menu = 0;				# am I inside a menu
-
-while (@lines) {
-    $_ = shift(@lines);
-    #
-    # special case (protected sections)
-    #
-    if (/^$PROTECTTAG/o) {
-	push(@lines2, $_);
-	next;
-    }
-    #
-    # menu
-    #
-    $in_menu = 1, push(@lines2, &debug("<UL>\n", __LINE__)), next if /^\@menu\b/;
-    $in_menu = 0, push(@lines2, &debug("</UL>\n", __LINE__)), next if /^\@end\s+menu\b/;
-    if ($in_menu) {
-	if (/^\*\s+($NODERE)::/o) {
-	    $descr = $';
-	    chop($descr);
-	    &menu_entry($1, $1, $descr);
-	} elsif (/^\*\s+(.+):\s+([^\t,\.\n]+)[\t,\.\n]/) {
-	    $descr = $';
-	    chop($descr);
-	    &menu_entry($1, $2, $descr);
-	} elsif (/^\*/) {
-	    warn "$ERROR Bad menu line: $_";
-	} else { # description continued?
-	    push(@lines2, $_);
-	}
-	next;
-    }
-    #
-    # printindex
-    #
-    if (/^\@printindex\s+(\w\w)\b/) {
-	local($index, *ary, @keys, $key, $letter, $last_letter, @refs);
-	if ($predefined_index{$1}) {
-	    $index = $predefined_index{$1} . 'index';
-	} else {
-	    $index = $1 . 'index';
-	}
-	eval("*ary = *$index");
-	@keys = keys(%ary);
-	foreach $key (@keys) {
-	    $_ = $key;
-	    1 while s/<(\w+)>\`(.*)\'<\/\1>/$2/; # remove HTML tags with quotes
-	    1 while s/<(\w+)>(.*)<\/\1>/$2/;     # remove HTML tags
-	    $_ = &unprotect_html($_);
-	    &unprotect_texi;
-	    tr/A-Z/a-z/; # lowercase
-	    $key2alpha{$key} = $_;
-	    print "# index $key sorted as $_\n"
-		if $key ne $_ && $debug & $DEBUG_INDEX;
-	}
-	push(@lines2, "Jump to:\n");
-	$last_letter = undef;
-	foreach $key (sort byalpha @keys) {
-	    $letter = substr($key2alpha{$key}, 0, 1);
-	    $letter = substr($key2alpha{$key}, 0, 2) if $letter eq $;;
-	    if (!defined($last_letter) || $letter ne $last_letter) {
-		push(@lines2, "-\n") if defined($last_letter);
-		push(@lines2, "<A HREF=\"#$index\_$letter\">" . &protect_html($letter) . "</A>\n");
-		$last_letter = $letter;
-	    }
-	}
-	push(@lines2, "<P>\n");
-	$last_letter = undef;
-	foreach $key (sort byalpha @keys) {
-	    $letter = substr($key2alpha{$key}, 0, 1);
-	    $letter = substr($key2alpha{$key}, 0, 2) if $letter eq $;;
-	    if (!defined($last_letter) || $letter ne $last_letter) {
-		push(@lines2, "</DIR>\n") if defined($last_letter);
-		push(@lines2, "<H2><A NAME=\"$index\_$letter\">" . &protect_html($letter) . "</A></H2>\n");
-		push(@lines2, "<DIR>\n");
-		$last_letter = $letter;
-	    }
-	    @refs = ();
-	    foreach (split(/$;/, $ary{$key})) {
-		push(@refs, &anchor('', $_, $key, 0));
-	    }
-	    push(@lines2, "<LI>" . join(", ", @refs) . "\n");
-	}
-	push(@lines2, "</DIR>\n") if defined($last_letter);
-	next;
-    }
-    #
-    # simple style substitutions
-    #
-    $_ = &substitute_style($_);
-    #
-    # xref
-    #
-    while (/\@(x|px|info|)ref{($XREFRE)(}?)/o) {
-	# note: Texinfo may accept other characters
-	($type, $nodes, $full) = ($1, $2, $3);
-	($before, $after) = ($`, $');
-	if (! $full && $after) {
-	    warn "$ERROR Bad xref (no ending } on line): $_";
-	    $_ = "$before$;0${type}ref\{$nodes$after";
-	    next; # while xref
-	}
-	if ($type eq 'x') {
-	    $type = 'See ';
-	} elsif ($type eq 'px') {
-	    $type = 'see ';
-	} elsif ($type eq 'info') {
-	    $type = 'See Info';
-	} else {
-	    $type = '';
-	}
-	unless ($full) {
-	    $next = shift(@lines);
-	    $next = &substitute_style($next);
-	    chop($nodes); # remove final newline
-	    if ($next =~ /\}/) { # split on 2 lines
-		$nodes .= " $`";
-		$after = $';
-	    } else {
-		$nodes .= " $next";
-		$next = shift(@lines);
-		$next = &substitute_style($next);
-		chop($nodes);
-		if ($next =~ /\}/) { # split on 3 lines
-		    $nodes .= " $`";
-		    $after = $';
-		} else {
-		    warn "$ERROR Bad xref (no ending }): $_";
-		    $_ = "$before$;0xref\{$nodes$after";
-		    unshift(@lines, $next);
-		    next; # while xref
-		}
-	    }
-	}
-	$nodes =~ s/\s+/ /g; # remove useless spaces
-	@args = split(/\s*,\s*/, $nodes);
-	$node = $args[0]; # the node is always the first arg
-	&normalise_node($node);
-	$sec = $node2sec{$node};
-	if (@args == 5) { # reference to another manual
-	    $sec = $args[2] || $node;
-	    $man = $args[4] || $args[3];
-	    $_ = "${before}${type}section `$sec' in \@cite{$man}$after";
-	} elsif ($type =~ /Info/) { # inforef
-	    warn "$ERROR Wrong number of arguments: $_" unless @args == 3;
-	    ($nn, $_, $in) = @args;
-	    $_ = "${before}${type} file `$in', node `$nn'$after";
-	} elsif ($sec) {
-	    $href = $node2href{$node};
-	    $_ = "${before}${type}section " . &anchor('', $href, $sec) . $after;
-	} else {
-	    warn "$ERROR Undefined node ($node): $_";
-	    $_ = "$before$;0xref{$nodes}$after";
-	}
-    }
-    #
-    # try to guess bibliography references or glossary terms
-    #
-    unless (/^<H\d><A NAME=\"SEC\d/) {
-	if ($use_bibliography) {
-	    $done = '';
-	    while (/$BIBRE/o) {
-		($pre, $what, $post) = ($`, $&, $');
-		$href = $bib2href{$what};
-		if (defined($href) && $post !~ /^[^<]*<\/A>/) {
-		    $done .= $pre . &anchor('', $href, $what);
-		} else {
-		    $done .= "$pre$what";
-		}
-		$_ = $post;
-	    }
-	    $_ = $done . $_;
-	}
-	if ($use_glossary) {
-	    $done = '';
-	    while (/\b\w+\b/) {
-		($pre, $what, $post) = ($`, $&, $');
-		$entry = $what;
-		$entry =~ tr/A-Z/a-z/ unless $entry =~ /^[A-Z\s]+$/;
-		$href = $gloss2href{$entry};
-		if (defined($href) && $post !~ /^[^<]*<\/A>/) {
-		    $done .= $pre . &anchor('', $href, $what);
-		} else {
-		    $done .= "$pre$what";
-		}
-		$_ = $post;
-	    }
-	    $_ = $done . $_;
-	}
-    }
-    # otherwise
-    push(@lines2, $_);
-}
-print "# end of pass 2\n" if $verbose;
-
-#
-# split style substitutions
-#
-while (@lines2) {
-    $_ = shift(@lines2);
-    #
-    # special case (protected sections)
-    #
-    if (/^$PROTECTTAG/o) {
-	push(@lines3, $_);
-	next;
-    }
-    #
-    # split style substitutions
-    #
-    $old = '';
-    while ($old ne $_) {
-        $old = $_;
-	if (/\@(\w+)\{/) {
-	    ($before, $style, $after) = ($`, $1, $');
-	    if (defined($style_map{$style})) {
-		$_ = $after;
-		$text = '';
-		$after = '';
-		$failed = 1;
-		while (@lines2) {
-		    if (/\}/) {
-			$text .= $`;
-			$after = $';
-			$failed = 0;
-			last;
-		    } else {
-			$text .= $_;
-			$_ = shift(@lines2);
-		    }
-		}
-		if ($failed) {
-		    die "* Bad syntax (\@$style) after: $before\n";
-		} else {
-		    $text = &apply_style($style, $text);
-		    $_ = "$before$text$after";
-		}
-	    }
-	}
-    }
-    # otherwise
-    push(@lines3, $_);
-}
-print "# end of pass 3\n" if $verbose;
-
-#+++############################################################################
-#                                                                              #
-# Pass 4: foot notes, final cleanup                                            #
-#                                                                              #
-#---############################################################################
-
-@foot_lines = ();			# footnotes
-@doc_lines = ();			# final document
-$end_of_para = 0;			# true if last line is <P>
-
-while (@lines3) {
-    $_ = shift(@lines3);
-    #
-    # special case (protected sections)
-    #
-    if (/^$PROTECTTAG/o) {
-	push(@doc_lines, $_);
-	$end_of_para = 0;
-	next;
-    }
-    #
-    # footnotes
-    #
-    while (/\@footnote([^\{\s]+)\{/) {
-	($before, $d, $after) = ($`, $1, $');
-	$_ = $after;
-	$text = '';
-	$after = '';
-	$failed = 1;
-	while (@lines3) {
-	    if (/\}/) {
-		$text .= $`;
-		$after = $';
-		$failed = 0;
-		last;
-	    } else {
-		$text .= $_;
-		$_ = shift(@lines3);
-	    }
-	}
-	if ($failed) {
-	    die "* Bad syntax (\@footnote) after: $before\n";
-	} else {
-	    $foot_num++;
-	    $docid  = "DOCF$foot_num";
-	    $footid = "FOOT$foot_num";
-	    $foot = "($foot_num)";
-	    push(@foot_lines, "<H3>" . &anchor($footid, "$d#$docid", $foot) . "</H3>\n");
-	    $text = "<P>$text" unless $text =~ /^\s*<P>/;
-	    push(@foot_lines, "$text\n");
-	    $_ = $before . &anchor($docid, "$docu_foot#$footid", $foot) . $after;
-	}
-    }
-    #
-    # remove unnecessary <P>
-    #
-    if (/^\s*<P>\s*$/) {
-	next if $end_of_para++;
-    } else {
-	$end_of_para = 0;
-    }
-    # otherwise
-    push(@doc_lines, $_);
-}
-print "# end of pass 4\n" if $verbose;
-
-#+++############################################################################
-#                                                                              #
-# Pass 5: print things                                                         #
-#                                                                              #
-#---############################################################################
-
-$header = <<EOT;
-<!-- This HTML file has been created by $THISPROG
-     from $docu on $TODAY -->
-EOT
-
-$full_title = $value{'_title'} || $value{'_settitle'} || "Untitled Document";
-$title = $value{'_settitle'} || $full_title;
-$_ = &substitute_style($full_title);
-&unprotect_texi;
-s/\n$//; # rmv last \n (if any)
-$full_title = "<H1>" . join("</H1>\n<H1>", split(/\n/, $_)) . "</H1>\n";
-
-#
-# print ToC
-#
-if (!$monolithic && @toc_lines) {
-    if (open(FILE, "> $docu_toc")) {
-	print "# creating $docu_toc...\n" if $verbose;
-	&print_toplevel_header("$title - Table of Contents");
-	&print_ruler;
-	&print(*toc_lines, FILE);
-	&print_toplevel_footer;
-	close(FILE);
-    } else {
-	warn "$ERROR Can't write to $docu_toc: $!\n";
-    }
-}
-
-#
-# print footnotes
-#
-if (!$monolithic && @foot_lines) {
-    if (open(FILE, "> $docu_foot")) {
-	print "# creating $docu_foot...\n" if $verbose;
-	&print_toplevel_header("$title - Footnotes");
-	&print_ruler;
-        &print(*foot_lines, FILE);
-	&print_toplevel_footer;
-	close(FILE);
-    } else {
-	warn "$ERROR Can't write to $docu_foot: $!\n";
-    }
-}
-
-#
-# print document
-#
-if ($split_chapter || $split_node) { # split
-    $doc_num = 0;
-    $last_num = scalar(@sections);
-    $first_doc = &doc_name(1);
-    $last_doc = &doc_name($last_num);
-    while (@sections) {
-	$section = shift(@sections);
-	&next_doc;
-	if (open(FILE, "> $docu_doc")) {
-	    print "# creating $docu_doc...\n" if $verbose;
-	    &print_header("$title - $section");
-	    $prev_doc = ($doc_num == 1 ? undef : &doc_name($doc_num - 1));
-	    $next_doc = ($doc_num == $last_num ? undef : &doc_name($doc_num + 1));
-	    $navigation = "Go to the ";
-	    $navigation .= ($prev_doc ? &anchor('', $first_doc, "first") : "first");
-	    $navigation .= ", ";
-	    $navigation .= ($prev_doc ? &anchor('', $prev_doc, "previous") : "previous");
-	    $navigation .= ", ";
-	    $navigation .= ($next_doc ? &anchor('', $next_doc, "next") : "next");
-	    $navigation .= ", ";
-	    $navigation .= ($next_doc ? &anchor('', $last_doc, "last") : "last");
-	    $navigation .= " section, " . &anchor('', $docu_toc, "table of contents") . ".\n";
-	    print FILE $navigation;
-	    &print_ruler;
-	    # find corresponding lines
-            @tmp_lines = ();
-            while (@doc_lines) {
-		$_ = shift(@doc_lines);
-		last if ($_ eq $SPLITTAG);
-		push(@tmp_lines, $_);
-	    }
-            &print(*tmp_lines, FILE);
-	    &print_ruler;
-	    print FILE $navigation;
-	    &print_footer;
-	    close(FILE);
-	} else {
-	    warn "$ERROR Can't write to $docu_doc: $!\n";
-	}
-    }
-} else { # not split
-    if (open(FILE, "> $docu_doc")) {
-	print "# creating $docu_doc...\n" if $verbose;
-	if ($monolithic || !@toc_lines) {
-	    &print_toplevel_header($title);
-	} else {
-	    &print_header($title);
-	    print FILE $full_title;
-	}
-	if ($monolithic && @toc_lines) {
-	    &print_ruler;
- 	    print FILE "<H1>Table of Contents</H1>\n";
- 	    &print(*toc_lines, FILE);
-	}
-	&print_ruler;
-        &print(*doc_lines, FILE);
-	if ($monolithic && @foot_lines) {
-	    &print_ruler;
- 	    print FILE "<H1>Footnotes</H1>\n";
- 	    &print(*foot_lines, FILE);
-	}
-	if ($monolithic || !@toc_lines) {
-	    &print_toplevel_footer;
-	} else {
-	    &print_footer;
-	}
-	close(FILE);
-    } else {
-	warn "$ERROR Can't write to $docu_doc: $!\n";
-    }
-}
-
-print "# that's all folks\n" if $verbose;
-
-#+++############################################################################
-#                                                                              #
-# Low level functions                                                          #
-#                                                                              #
-#---############################################################################
-
-sub update_sec_num {
-    local($name, $level) = @_;
-
-    $level--; # here we start at 0
-    if ($name =~ /^appendix/) {
-	# appendix style
-	if (defined(@appendix_sec_num)) {
-	    &incr_sec_num($level, @appendix_sec_num);
-	} else {
-	    @appendix_sec_num = ('A', 0, 0, 0);
-	}
-	return(join('.', @appendix_sec_num[0..$level]));
-    } else {
-	# normal style
-	if (defined(@normal_sec_num)) {
-	    &incr_sec_num($level, @normal_sec_num);
-	} else {
-	    @normal_sec_num = (1, 0, 0, 0);
-	}
-	return(join('.', @normal_sec_num[0..$level]));
-    }
-}
-
-sub incr_sec_num {
-    local($level, $l);
-    $level = shift(@_);
-    $_[$level]++;
-    foreach $l ($level+1 .. 3) {
-	$_[$l] = 0;
-    }
-}
-
-sub check {
-    local($_, %seen, %context, $before, $match, $after);
-
-    while (<>) {
-	if (/\@(\*|\.|\:|\@|\{|\})/) {
-	    $seen{$&}++;
-	    $context{$&} .= "> $_" if $verbose;
-	    $_ = "$`XX$'";
-	    redo;
-	}
-	if (/\@(\w+)/) {
-	    ($before, $match, $after) = ($`, $&, $');
-	    if ($before =~ /\b[\w-]+$/ && $after =~ /^[\w-.]*\b/) { # e-mail address
-		$seen{'e-mail address'}++;
-		$context{'e-mail address'} .= "> $_" if $verbose;
-	    } else {
-		$seen{$match}++;
-		$context{$match} .= "> $_" if $verbose;
-	    }
-	    $match =~ s/^\@/X/;
-	    $_ = "$before$match$after";
-	    redo;
-	}
-    }
-    
-    foreach (sort(keys(%seen))) {
-	if ($verbose) {
-	    print "$_\n";
-	    print $context{$_};
-	} else {
-	    print "$_ ($seen{$_})\n";
-	}
-    }
-}
-
-sub open {
-    local($name) = @_;
-
-    ++$fh_name;
-    if (open($fh_name, $name)) {
-	unshift(@fhs, $fh_name);
-    } else {
-	warn "$ERROR Can't read file $name: $!\n";
-    }
-}
-
-sub init_input {
-    @fhs = ();			# hold the file handles to read
-    @input_spool = ();		# spooled lines to read
-    $fh_name = 'FH000';
-    &open($docu);
-}
-
-sub next_line {
-    local($fh, $line);
-
-    if (@input_spool) {
-	$line = shift(@input_spool);
-	return($line);
-    }
-    while (@fhs) {
-	$fh = $fhs[0];
-	$line = <$fh>;
-	return($line) if $line;
-	close($fh);
-	shift(@fhs);
-    }
-    return(undef);
-}
-
-# used in pass 1, use &next_line
-sub skip_until {
-    local($tag) = @_;
-    local($_);
-
-    while ($_ = &next_line) {
-	return if /^\@end\s+$tag\s*$/;
-    }
-    die "* Failed to find '$tag' after: " . $lines[$#lines];
-}
-
-#
-# HTML stacking to have a better HTML output
-#
-
-sub html_reset {
-    @html_stack = ('html');
-    $html_element = 'body';
-}
-
-sub html_push {
-    local($what) = @_;
-    push(@html_stack, $html_element);
-    $html_element = $what;
-}
-
-sub html_push_if {
-    local($what) = @_;
-    push(@html_stack, $html_element)
-	if ($html_element && $html_element ne 'P');
-    $html_element = $what;
-}
-
-sub html_pop {
-    $html_element = pop(@html_stack);
-}
-
-sub html_pop_if {
-    local($elt);
-
-    if (@_) {
-	foreach $elt (@_) {
-	    if ($elt eq $html_element) {
-		$html_element = pop(@html_stack) if @html_stack;
-		last;
-	    }
-	}
-    } else {
-	$html_element = pop(@html_stack) if @html_stack;
-    }
-}
-
-sub html_debug {
-    local($what, $line) = @_;
-    return("<!-- $line @html_stack, $html_element -->$what")
-	if $debug & $DEBUG_HTML;
-    return($what);
-}
-
-# to debug the output...
-sub debug {
-    local($what, $line) = @_;
-    return("<!-- $line -->$what")
-	if $debug & $DEBUG_HTML;
-    return($what);
-}
-
-sub normalise_node {
-    $_[0] =~ s/\s+/ /g;
-    $_[0] =~ s/ $//;
-    $_[0] =~ s/^ //;
-}
-
-sub menu_entry {
-    local($entry, $node, $descr) = @_;
-    local($href);
-
-    &normalise_node($node);
-    $href = $node2href{$node};
-    if ($href) {
-	$descr =~ s/^\s+//;
-	$descr = ": $descr" if $descr;
-	push(@lines2, "<LI>" . &anchor('', $href, $entry) . "$descr\n");
-    } else {
-	warn "$ERROR Undefined node ($node): $_";
-    }
-}
-
-sub do_ctrl { "^$_[0]" }
-
-sub do_email {
-    local($addr, $text) = split(/,\s*/, $_[0]);
-
-    $text = $addr unless $text;
-    &anchor('', "mailto:$addr", $text);
-}
-
-sub do_sc { "\U$_[0]\E" }
-
-sub do_uref {
-    local($url, $text) = split(/,\s*/, $_[0]);
-
-    $text = $url unless $text;
-    &anchor('', $url, $text);
-}
-
-sub do_url { &anchor('', $_[0], $_[0]) }
-
-sub apply_style {
-    local($texi_style, $text) = @_;
-    local($style);
-
-    $style = $style_map{$texi_style};
-    if (defined($style)) { # known style
-	if ($style =~ /^\"/) { # add quotes
-	    $style = $';
-	    $text = "\`$text\'";
-	}
-	if ($style =~ /^\&/) { # custom
-	    $style = $';
-	    $text = &$style($text);
-	} elsif ($style) { # good style
-	    $text = "<$style>$text</$style>";
-	} else { # no style
-	}
-    } else { # unknown style
-	$text = undef;
-    }
-    return($text);
-}
-
-# remove Texinfo styles
-sub remove_style {
-    local($_) = @_;
-    s/\@\w+{([^\{\}]+)}/$1/g;
-    return($_);
-}
-
-sub substitute_style {
-    local($_) = @_;
-    local($changed, $done, $style, $text);
-
-    $changed = 1;
-    while ($changed) {
-	$changed = 0;
-	$done = '';
-	while (/\@(\w+){([^\{\}]+)}/) {
-	    $text = &apply_style($1, $2);
-	    if ($text) {
-		$_ = "$`$text$'";
-		$changed = 1;
-	    } else {
-		$done .= "$`\@$1";
-		$_ = "{$2}$'";
-	    }
-	}
-        $_ = $done . $_;
-    }
-    return($_);
-}
-
-sub anchor {
-    local($name, $href, $text, $newline) = @_;
-    local($result);
-
-    $result = "<A";
-    $result .= " NAME=\"$name\"" if $name;
-    $result .= " HREF=\"$href\"" if $href;
-    $result .= ">$text</A>";
-    $result .= "\n" if $newline;
-    return($result);
-}
-
-sub pretty_date {
-    local(@MoY, $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);
-
-    @MoY = ('January', 'Febuary', 'March', 'April', 'May', 'June',
-	    'July', 'August', 'September', 'October', 'November', 'December');
-    ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
-    $year += ($year < 70) ? 2000 : 1900;
-    return("$mday $MoY[$mon] $year");
-}
-
-sub doc_name {
-    local($num) = @_;
-
-    return("${docu_name}_$num.html");
-}
-
-sub next_doc {
-    $docu_doc = &doc_name(++$doc_num);
-}
-
-sub print {
-    local(*lines, $fh) = @_;
-    local($_);
-
-    while (@lines) {
-	$_ = shift(@lines);
-	if (/^$PROTECTTAG/o) {
-	    $_ = $tag2pro{$_};
-	} else {
-	    &unprotect_texi;
-	}
-	print $fh $_;
-    }
-}
-
-sub print_ruler {
-    print FILE "<P><HR><P>\n";
-}
-
-sub print_header {
-    local($_);
-
-    # clean the title
-    $_ = &remove_style($_[0]);
-    &unprotect_texi;
-    # print the header
-    if ($doctype eq 'html2') {
-	print FILE $html2_doctype;
-    } elsif ($doctype) {
-	print FILE $doctype;
-    }
-    print FILE <<EOT;
-<HTML>
-<HEAD>
-$header
-<TITLE>$_</TITLE>
-</HEAD>
-<BODY>
-EOT
-}
-
-sub print_toplevel_header {
-    local($_);
-
-    &print_header; # pass given arg...
-    print FILE $full_title;
-    if ($value{'_subtitle'}) {
-	$value{'_subtitle'} =~ s/\n+$//;
-	foreach (split(/\n/, $value{'_subtitle'})) {
-	    $_ = &substitute_style($_);
-	    &unprotect_texi;
-	    print FILE "<H2>$_</H2>\n";
-	}
-    }
-    if ($value{'_author'}) {
-	$value{'_author'} =~ s/\n+$//;
-	foreach (split(/\n/, $value{'_author'})) {
-	    $_ = &substitute_style($_);
-	    &unprotect_texi;
-	    s/[\w.-]+\@[\w.-]+/<A HREF="mailto:$&">$&<\/A>/g;
-	    print FILE "<ADDRESS>$_</ADDRESS>\n";
-	}
-    }
-    print FILE "<P>\n";
-}
-
-sub print_footer {
-    print FILE <<EOT;
-</BODY>
-</HTML>
-EOT
-}
-
-sub print_toplevel_footer {
-    &print_ruler;
-    print FILE <<EOT;
-This document was generated on $TODAY using the
-<A HREF=\"$HOMEPAGE\">texi2html</A>
-translator version 1.52.</P>
-EOT
-    &print_footer;
-}
-
-sub protect_texi {
-    # protect @ { } ` '
-    s/\@\@/$;0/go;
-    s/\@\{/$;1/go;
-    s/\@\}/$;2/go;
-    s/\@\`/$;3/go;
-    s/\@\'/$;4/go;
-}
-
-sub protect_html {
-    local($what) = @_;
-    # protect & < >
-    $what =~ s/\&/\&\#38;/g;
-    $what =~ s/\</\&\#60;/g;
-    $what =~ s/\>/\&\#62;/g;
-    # but recognize some HTML things
-    $what =~ s/\&\#60;\/A\&\#62;/<\/A>/g;	      # </A>
-    $what =~ s/\&\#60;A ([^\&]+)\&\#62;/<A $1>/g;     # <A [^&]+>
-    $what =~ s/\&\#60;IMG ([^\&]+)\&\#62;/<IMG $1>/g; # <IMG [^&]+>
-    return($what);
-}
-
-sub unprotect_texi {
-    s/$;0/\@/go;
-    s/$;1/\{/go;
-    s/$;2/\}/go;
-    s/$;3/\`/go;
-    s/$;4/\'/go;
-}
-
-sub unprotect_html {
-    local($what) = @_;
-    $what =~ s/\&\#38;/\&/g;
-    $what =~ s/\&\#60;/\</g;
-    $what =~ s/\&\#62;/\>/g;
-    return($what);
-}
-
-sub byalpha {
-    $key2alpha{$a} cmp $key2alpha{$b};
-}
-
-##############################################################################
-
-	# These next few lines are legal in both Perl and nroff.
-
-.00 ;			# finish .ig
- 
-'di			\" finish diversion--previous line must be blank
-.nr nl 0-1		\" fake up transition to first page again
-.nr % 0			\" start at page 1
-'; __END__ ############# From here on it's a standard manual page ############
-.TH TEXI2HTML 1 "01/05/98"
-.AT 3
-.SH NAME
-texi2html \- a Texinfo to HTML converter
-.SH SYNOPSIS
-.B texi2html [options] file
-.PP
-.B texi2html -check [-verbose] files
-.SH DESCRIPTION
-.I Texi2html
-converts the given Texinfo file to a set of HTML files. It tries to handle
-most of the Texinfo commands. It creates hypertext links for cross-references,
-footnotes...
-.PP
-It also tries to add links from a reference to its corresponding entry in the
-bibliography (if any). It may also handle a glossary (see the
-.B \-glossary
-option).
-.PP
-.I Texi2html
-creates several files depending on the contents of the Texinfo file and on
-the chosen options (see FILES).
-.PP
-The HTML files created by
-.I texi2html
-are closer to TeX than to Info, that's why
-.I texi2html
-converts @iftex sections and not @ifinfo ones by default. You can reverse
-this with the \-expandinfo option.
-.SH OPTIONS
-.TP 12
-.B \-check
-Check the given file and give the list of all things that may be Texinfo commands.
-This may be used to check the output of
-.I texi2html
-to find the Texinfo commands that have been left in the HTML file.
-.TP
-.B \-expandinfo
-Expand @ifinfo sections, not @iftex ones.
-.TP
-.B \-glossary
-Use the section named 'Glossary' to build a list of terms and put links in the HTML
-document from each term toward its definition.
-.TP
-.B \-invisible \fIname\fP
-Use \fIname\fP to create invisible destination anchors for index links
-(you can for instance use the invisible.xbm file shipped with this program).
-This is a workaround for a known bug of many WWW browsers, including netscape.
-.TP
-.B \-I \fIdir\fP
-Look also in \fIdir\fP to find included files.
-.TP
-.B \-menu
-Show the Texinfo menus; by default they are ignored.
-.TP
-.B \-monolithic
-Output only one file, including the table of contents and footnotes.
-.TP
-.B \-number
-Number the sections.
-.TP
-.B \-split_chapter
-Split the output into several HTML files (one per main section:
-chapter, appendix...).
-.TP
-.B \-split_node
-Split the output into several HTML files (one per node).
-.TP
-.B \-usage
-Print usage instructions, listing the current available command-line options.
-.TP
-.B \-verbose
-Give a verbose output. Can be used with the
-.B \-check
-option.
-.PP
-.SH FILES
-By default
-.I texi2html
-creates the following files (foo being the name of the Texinfo file):
-.TP 16
-.B foo_toc.html
-The table of contents.
-.TP
-.B foo.html
-The document's contents.
-.TP
-.B foo_foot.html
-The footnotes (if any).
-.PP
-When used with the
-.B \-split
-option, it creates several files (one per chapter or node), named
-.B foo_n.html
-(n being the indice of the chapter or node), instead of the single
-.B foo.html
-file.
-.PP
-When used with the
-.B \-monolithic
-option, it creates only one file:
-.B foo.html
-.SH VARIABLES
-.I texi2html
-predefines the following variables: \fBhtml\fP, \fBtexi2html\fP.
-.SH ADDITIONAL COMMANDS
-.I texi2html
-implements the following non-Texinfo commands (maybe they are in Texinfo now...):
-.TP 16
-.B @ifhtml
-This indicates the start of an HTML section, this section will passed through
-without any modification.
-.TP
-.B @end ifhtml
-This indicates the end of an HTML section.
-.SH VERSION
-This is \fItexi2html\fP version 1.52, 01/05/98.
-.PP
-The latest version of \fItexi2html\fP can be found in WWW, cf. URL
-http://wwwinfo.cern.ch/dis/texi2html/
-.SH AUTHOR
-The main author is Lionel Cons, CERN IT/DIS/OSE, Lionel.Cons@cern.ch.
-Many other people around the net contributed to this program.
-.SH COPYRIGHT
-This program is the intellectual property of the European
-Laboratory for Particle Physics (known as CERN). No guarantee whatsoever is
-provided by CERN. No liability whatsoever is accepted for any loss or damage
-of any kind resulting from any defect or inaccuracy in this information or
-code.
-.PP
-CERN, 1211 Geneva 23, Switzerland
-.SH "SEE ALSO"
-GNU Texinfo Documentation Format,
-HyperText Markup Language (HTML),
-World Wide Web (WWW).
-.SH BUGS
-This program does not understand all Texinfo commands (yet).
-.PP
-TeX specific commands (normally enclosed in @iftex) will be
-passed unmodified.
-.ex
diff --git a/readline/doc/texinfo.tex b/readline/doc/texinfo.tex
deleted file mode 100644
--- a/readline/doc/texinfo.tex
+++ /dev/null
@@ -1,5992 +0,0 @@
-% texinfo.tex -- TeX macros to handle Texinfo files.
-%
-% Load plain if necessary, i.e., if running under initex.
-\expandafter\ifx\csname fmtname\endcsname\relax\input plain\fi
-%
-\def\texinfoversion{1999-09-25.10}
-%
-% Copyright (C) 1985, 86, 88, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99
-% Free Software Foundation, Inc.
-%
-% This texinfo.tex file is free software; you can redistribute it and/or
-% modify it under the terms of the GNU General Public License as
-% published by the Free Software Foundation; either version 2, or (at
-% your option) any later version.
-%
-% This texinfo.tex file is distributed in the hope that it will be
-% useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-% of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-% General Public License for more details.
-%
-% You should have received a copy of the GNU General Public License
-% along with this texinfo.tex file; see the file COPYING.  If not, write
-% to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-% Boston, MA 02111-1307, USA.
-%
-% In other words, you are welcome to use, share and improve this program.
-% You are forbidden to forbid anyone else to use, share and improve
-% what you give them.   Help stamp out software-hoarding!
-%
-% Please try the latest version of texinfo.tex before submitting bug
-% reports; you can get the latest version from:
-%   ftp://ftp.gnu.org/gnu/texinfo.tex
-%   (and all GNU mirrors, see http://www.gnu.org/order/ftp.html)
-%   ftp://texinfo.org/tex/texinfo.tex
-%   ftp://us.ctan.org/macros/texinfo/texinfo.tex
-%   (and all CTAN mirrors, finger ctan@us.ctan.org for a list).
-%   /home/gd/gnu/doc/texinfo.tex on the GNU machines.
-% The texinfo.tex in any given Texinfo distribution could well be out
-% of date, so if that's what you're using, please check.
-% Texinfo has a small home page at http://texinfo.org/.
-%
-% Send bug reports to bug-texinfo@gnu.org.  Please include including a
-% complete document in each bug report with which we can reproduce the
-% problem.  Patches are, of course, greatly appreciated.
-%
-% To process a Texinfo manual with TeX, it's most reliable to use the
-% texi2dvi shell script that comes with the distribution.  For a simple
-% manual foo.texi, however, you can get away with this:
-%   tex foo.texi
-%   texindex foo.??
-%   tex foo.texi
-%   tex foo.texi
-%   dvips foo.dvi -o # or whatever, to process the dvi file; this makes foo.ps.
-% The extra runs of TeX get the cross-reference information correct.
-% Sometimes one run after texindex suffices, and sometimes you need more
-% than two; texi2dvi does it as many times as necessary.
-%
-% It is possible to adapt texinfo.tex for other languages.  You can get
-% the existing language-specific files from ftp://ftp.gnu.org/gnu/texinfo/.
-
-\message{Loading texinfo [version \texinfoversion]:}
-
-% If in a .fmt file, print the version number
-% and turn on active characters that we couldn't do earlier because
-% they might have appeared in the input file name.
-\everyjob{\message{[Texinfo version \texinfoversion]}%
-  \catcode`+=\active \catcode`\_=\active}
-
-% Save some parts of plain tex whose names we will redefine.
-\let\ptexb=\b
-\let\ptexbullet=\bullet
-\let\ptexc=\c
-\let\ptexcomma=\,
-\let\ptexdot=\.
-\let\ptexdots=\dots
-\let\ptexend=\end
-\let\ptexequiv=\equiv
-\let\ptexexclam=\!
-\let\ptexi=\i
-\let\ptexlbrace=\{
-\let\ptexrbrace=\}
-\let\ptexstar=\*
-\let\ptext=\t
-
-% We never want plain's outer \+ definition in Texinfo.
-% For @tex, we can use \tabalign.
-\let\+ = \relax
-
-\message{Basics,}
-\chardef\other=12
-
-% If this character appears in an error message or help string, it
-% starts a new line in the output.
-\newlinechar = `^^J
-
-% Set up fixed words for English if not already set.
-\ifx\putwordAppendix\undefined  \gdef\putwordAppendix{Appendix}\fi
-\ifx\putwordChapter\undefined   \gdef\putwordChapter{Chapter}\fi
-\ifx\putwordfile\undefined      \gdef\putwordfile{file}\fi
-\ifx\putwordin\undefined        \gdef\putwordin{in}\fi
-\ifx\putwordIndexIsEmpty\undefined     \gdef\putwordIndexIsEmpty{(Index is empty)}\fi
-\ifx\putwordIndexNonexistent\undefined \gdef\putwordIndexNonexistent{(Index is nonexistent)}\fi
-\ifx\putwordInfo\undefined      \gdef\putwordInfo{Info}\fi
-\ifx\putwordInstanceVariableof\undefined \gdef\putwordInstanceVariableof{Instance Variable of}\fi
-\ifx\putwordMethodon\undefined  \gdef\putwordMethodon{Method on}\fi
-\ifx\putwordNoTitle\undefined   \gdef\putwordNoTitle{No Title}\fi
-\ifx\putwordof\undefined        \gdef\putwordof{of}\fi
-\ifx\putwordon\undefined        \gdef\putwordon{on}\fi
-\ifx\putwordpage\undefined      \gdef\putwordpage{page}\fi
-\ifx\putwordsection\undefined   \gdef\putwordsection{section}\fi
-\ifx\putwordSection\undefined   \gdef\putwordSection{Section}\fi
-\ifx\putwordsee\undefined       \gdef\putwordsee{see}\fi
-\ifx\putwordSee\undefined       \gdef\putwordSee{See}\fi
-\ifx\putwordShortTOC\undefined  \gdef\putwordShortTOC{Short Contents}\fi
-\ifx\putwordTOC\undefined       \gdef\putwordTOC{Table of Contents}\fi
-%
-\ifx\putwordMJan\undefined \gdef\putwordMJan{January}\fi
-\ifx\putwordMFeb\undefined \gdef\putwordMFeb{February}\fi
-\ifx\putwordMMar\undefined \gdef\putwordMMar{March}\fi
-\ifx\putwordMApr\undefined \gdef\putwordMApr{April}\fi
-\ifx\putwordMMay\undefined \gdef\putwordMMay{May}\fi
-\ifx\putwordMJun\undefined \gdef\putwordMJun{June}\fi
-\ifx\putwordMJul\undefined \gdef\putwordMJul{July}\fi
-\ifx\putwordMAug\undefined \gdef\putwordMAug{August}\fi
-\ifx\putwordMSep\undefined \gdef\putwordMSep{September}\fi
-\ifx\putwordMOct\undefined \gdef\putwordMOct{October}\fi
-\ifx\putwordMNov\undefined \gdef\putwordMNov{November}\fi
-\ifx\putwordMDec\undefined \gdef\putwordMDec{December}\fi
-%
-\ifx\putwordDefmac\undefined    \gdef\putwordDefmac{Macro}\fi
-\ifx\putwordDefspec\undefined   \gdef\putwordDefspec{Special Form}\fi
-\ifx\putwordDefvar\undefined    \gdef\putwordDefvar{Variable}\fi
-\ifx\putwordDefopt\undefined    \gdef\putwordDefopt{User Option}\fi
-\ifx\putwordDeftypevar\undefined\gdef\putwordDeftypevar{Variable}\fi
-\ifx\putwordDeffunc\undefined   \gdef\putwordDeffunc{Function}\fi
-\ifx\putwordDeftypefun\undefined\gdef\putwordDeftypefun{Function}\fi
-
-% Ignore a token.
-%
-\def\gobble#1{}
-
-\hyphenation{ap-pen-dix}
-\hyphenation{mini-buf-fer mini-buf-fers}
-\hyphenation{eshell}
-\hyphenation{white-space}
-
-% Margin to add to right of even pages, to left of odd pages.
-\newdimen \bindingoffset
-\newdimen \normaloffset
-\newdimen\pagewidth \newdimen\pageheight
-
-% Sometimes it is convenient to have everything in the transcript file
-% and nothing on the terminal.  We don't just call \tracingall here,
-% since that produces some useless output on the terminal.
-%
-\def\gloggingall{\begingroup \globaldefs = 1 \loggingall \endgroup}%
-\ifx\eTeXversion\undefined
-\def\loggingall{\tracingcommands2 \tracingstats2
-   \tracingpages1 \tracingoutput1 \tracinglostchars1
-   \tracingmacros2 \tracingparagraphs1 \tracingrestores1
-   \showboxbreadth\maxdimen\showboxdepth\maxdimen
-}%
-\else
-\def\loggingall{\tracingcommands3 \tracingstats2
-   \tracingpages1 \tracingoutput1 \tracinglostchars1
-   \tracingmacros2 \tracingparagraphs1 \tracingrestores1
-   \tracingscantokens1 \tracingassigns1 \tracingifs1
-   \tracinggroups1 \tracingnesting2
-   \showboxbreadth\maxdimen\showboxdepth\maxdimen
-}%
-\fi
-
-% For @cropmarks command.
-% Do @cropmarks to get crop marks.
-%
-\newif\ifcropmarks
-\let\cropmarks = \cropmarkstrue
-%
-% Dimensions to add cropmarks at corners.
-% Added by P. A. MacKay, 12 Nov. 1986
-%
-\newdimen\outerhsize \newdimen\outervsize % set by the paper size routines
-\newdimen\cornerlong  \cornerlong=1pc
-\newdimen\cornerthick \cornerthick=.3pt
-\newdimen\topandbottommargin \topandbottommargin=.75in
-
-% Main output routine.
-\chardef\PAGE = 255
-\output = {\onepageout{\pagecontents\PAGE}}
-
-\newbox\headlinebox
-\newbox\footlinebox
-
-% \onepageout takes a vbox as an argument.  Note that \pagecontents
-% does insertions, but you have to call it yourself.
-\def\onepageout#1{%
-  \ifcropmarks \hoffset=0pt \else \hoffset=\normaloffset \fi
-  %
-  \ifodd\pageno  \advance\hoffset by \bindingoffset
-  \else \advance\hoffset by -\bindingoffset\fi
-  %
-  % Do this outside of the \shipout so @code etc. will be expanded in
-  % the headline as they should be, not taken literally (outputting ''code).
-  \setbox\headlinebox = \vbox{\let\hsize=\pagewidth \makeheadline}%
-  \setbox\footlinebox = \vbox{\let\hsize=\pagewidth \makefootline}%
-  %
-  {%
-    % Have to do this stuff outside the \shipout because we want it to
-    % take effect in \write's, yet the group defined by the \vbox ends
-    % before the \shipout runs.
-    %
-    \escapechar = `\\     % use backslash in output files.
-    \indexdummies         % don't expand commands in the output.
-    \normalturnoffactive  % \ in index entries must not stay \, e.g., if
-                   % the page break happens to be in the middle of an example.
-    \shipout\vbox{%
-      \ifcropmarks \vbox to \outervsize\bgroup
-        \hsize = \outerhsize
-        \vskip-\topandbottommargin
-        \vtop to0pt{%
-          \line{\ewtop\hfil\ewtop}%
-          \nointerlineskip
-          \line{%
-            \vbox{\moveleft\cornerthick\nstop}%
-            \hfill
-            \vbox{\moveright\cornerthick\nstop}%
-          }%
-          \vss}%
-        \vskip\topandbottommargin
-        \line\bgroup
-          \hfil % center the page within the outer (page) hsize.
-          \ifodd\pageno\hskip\bindingoffset\fi
-          \vbox\bgroup
-      \fi
-      %
-      \unvbox\headlinebox
-      \pagebody{#1}%
-      \ifdim\ht\footlinebox > 0pt
-        % Only leave this space if the footline is nonempty.
-        % (We lessened \vsize for it in \oddfootingxxx.)
-        % The \baselineskip=24pt in plain's \makefootline has no effect.
-        \vskip 2\baselineskip
-        \unvbox\footlinebox
-      \fi
-      %
-      \ifpdfmakepagedest \pdfmkdest{\the\pageno} \fi
-      %
-      \ifcropmarks
-          \egroup % end of \vbox\bgroup
-        \hfil\egroup % end of (centering) \line\bgroup
-        \vskip\topandbottommargin plus1fill minus1fill
-        \boxmaxdepth = \cornerthick
-        \vbox to0pt{\vss
-          \line{%
-            \vbox{\moveleft\cornerthick\nsbot}%
-            \hfill
-            \vbox{\moveright\cornerthick\nsbot}%
-          }%
-          \nointerlineskip
-          \line{\ewbot\hfil\ewbot}%
-        }%
-      \egroup % \vbox from first cropmarks clause
-      \fi
-    }% end of \shipout\vbox
-  }% end of group with \turnoffactive
-  \advancepageno
-  \ifnum\outputpenalty>-20000 \else\dosupereject\fi
-}
-
-\newinsert\margin \dimen\margin=\maxdimen
-
-\def\pagebody#1{\vbox to\pageheight{\boxmaxdepth=\maxdepth #1}}
-{\catcode`\@ =11
-\gdef\pagecontents#1{\ifvoid\topins\else\unvbox\topins\fi
-% marginal hacks, juha@viisa.uucp (Juha Takala)
-\ifvoid\margin\else % marginal info is present
-  \rlap{\kern\hsize\vbox to\z@{\kern1pt\box\margin \vss}}\fi
-\dimen@=\dp#1 \unvbox#1
-\ifvoid\footins\else\vskip\skip\footins\footnoterule \unvbox\footins\fi
-\ifr@ggedbottom \kern-\dimen@ \vfil \fi}
-}
-
-% Here are the rules for the cropmarks.  Note that they are
-% offset so that the space between them is truly \outerhsize or \outervsize
-% (P. A. MacKay, 12 November, 1986)
-%
-\def\ewtop{\vrule height\cornerthick depth0pt width\cornerlong}
-\def\nstop{\vbox
-  {\hrule height\cornerthick depth\cornerlong width\cornerthick}}
-\def\ewbot{\vrule height0pt depth\cornerthick width\cornerlong}
-\def\nsbot{\vbox
-  {\hrule height\cornerlong depth\cornerthick width\cornerthick}}
-
-% Parse an argument, then pass it to #1.  The argument is the rest of
-% the input line (except we remove a trailing comment).  #1 should be a
-% macro which expects an ordinary undelimited TeX argument.
-%
-\def\parsearg#1{%
-  \let\next = #1%
-  \begingroup
-    \obeylines
-    \futurelet\temp\parseargx
-}
-
-% If the next token is an obeyed space (from an @example environment or
-% the like), remove it and recurse.  Otherwise, we're done.
-\def\parseargx{%
-  % \obeyedspace is defined far below, after the definition of \sepspaces.
-  \ifx\obeyedspace\temp
-    \expandafter\parseargdiscardspace
-  \else
-    \expandafter\parseargline
-  \fi
-}
-
-% Remove a single space (as the delimiter token to the macro call).
-{\obeyspaces %
- \gdef\parseargdiscardspace {\futurelet\temp\parseargx}}
-
-{\obeylines %
-  \gdef\parseargline#1^^M{%
-    \endgroup % End of the group started in \parsearg.
-    %
-    % First remove any @c comment, then any @comment.
-    % Result of each macro is put in \toks0.
-    \argremovec #1\c\relax %
-    \expandafter\argremovecomment \the\toks0 \comment\relax %
-    %
-    % Call the caller's macro, saved as \next in \parsearg.
-    \expandafter\next\expandafter{\the\toks0}%
-  }%
-}
-
-% Since all \c{,omment} does is throw away the argument, we can let TeX
-% do that for us.  The \relax here is matched by the \relax in the call
-% in \parseargline; it could be more or less anything, its purpose is
-% just to delimit the argument to the \c.
-\def\argremovec#1\c#2\relax{\toks0 = {#1}}
-\def\argremovecomment#1\comment#2\relax{\toks0 = {#1}}
-
-% \argremovec{,omment} might leave us with trailing spaces, though; e.g.,
-%    @end itemize  @c foo
-% will have two active spaces as part of the argument with the
-% `itemize'.  Here we remove all active spaces from #1, and assign the
-% result to \toks0.
-%
-% This loses if there are any *other* active characters besides spaces
-% in the argument -- _ ^ +, for example -- since they get expanded.
-% Fortunately, Texinfo does not define any such commands.  (If it ever
-% does, the catcode of the characters in questionwill have to be changed
-% here.)  But this means we cannot call \removeactivespaces as part of
-% \argremovec{,omment}, since @c uses \parsearg, and thus the argument
-% that \parsearg gets might well have any character at all in it.
-%
-\def\removeactivespaces#1{%
-  \begingroup
-    \ignoreactivespaces
-    \edef\temp{#1}%
-    \global\toks0 = \expandafter{\temp}%
-  \endgroup
-}
-
-% Change the active space to expand to nothing.
-%
-\begingroup
-  \obeyspaces
-  \gdef\ignoreactivespaces{\obeyspaces\let =\empty}
-\endgroup
-
-
-\def\flushcr{\ifx\par\lisppar \def\next##1{}\else \let\next=\relax \fi \next}
-
-%% These are used to keep @begin/@end levels from running away
-%% Call \inENV within environments (after a \begingroup)
-\newif\ifENV \ENVfalse \def\inENV{\ifENV\relax\else\ENVtrue\fi}
-\def\ENVcheck{%
-\ifENV\errmessage{Still within an environment; press RETURN to continue}
-\endgroup\fi} % This is not perfect, but it should reduce lossage
-
-% @begin foo  is the same as @foo, for now.
-\newhelp\EMsimple{Press RETURN to continue.}
-
-\outer\def\begin{\parsearg\beginxxx}
-
-\def\beginxxx #1{%
-\expandafter\ifx\csname #1\endcsname\relax
-{\errhelp=\EMsimple \errmessage{Undefined command @begin #1}}\else
-\csname #1\endcsname\fi}
-
-% @end foo executes the definition of \Efoo.
-%
-\def\end{\parsearg\endxxx}
-\def\endxxx #1{%
-  \removeactivespaces{#1}%
-  \edef\endthing{\the\toks0}%
-  %
-  \expandafter\ifx\csname E\endthing\endcsname\relax
-    \expandafter\ifx\csname \endthing\endcsname\relax
-      % There's no \foo, i.e., no ``environment'' foo.
-      \errhelp = \EMsimple
-      \errmessage{Undefined command `@end \endthing'}%
-    \else
-      \unmatchedenderror\endthing
-    \fi
-  \else
-    % Everything's ok; the right environment has been started.
-    \csname E\endthing\endcsname
-  \fi
-}
-
-% There is an environment #1, but it hasn't been started.  Give an error.
-%
-\def\unmatchedenderror#1{%
-  \errhelp = \EMsimple
-  \errmessage{This `@end #1' doesn't have a matching `@#1'}%
-}
-
-% Define the control sequence \E#1 to give an unmatched @end error.
-%
-\def\defineunmatchedend#1{%
-  \expandafter\def\csname E#1\endcsname{\unmatchedenderror{#1}}%
-}
-
-
-% Single-spacing is done by various environments (specifically, in
-% \nonfillstart and \quotations).
-\newskip\singlespaceskip \singlespaceskip = 12.5pt
-\def\singlespace{%
-  % Why was this kern here?  It messes up equalizing space above and below
-  % environments.  --karl, 6may93
-  %{\advance \baselineskip by -\singlespaceskip
-  %\kern \baselineskip}%
-  \setleading \singlespaceskip
-}
-
-%% Simple single-character @ commands
-
-% @@ prints an @
-% Kludge this until the fonts are right (grr).
-\def\@{{\tt\char64}}
-
-% This is turned off because it was never documented
-% and you can use @w{...} around a quote to suppress ligatures.
-%% Define @` and @' to be the same as ` and '
-%% but suppressing ligatures.
-%\def\`{{`}}
-%\def\'{{'}}
-
-% Used to generate quoted braces.
-\def\mylbrace {{\tt\char123}}
-\def\myrbrace {{\tt\char125}}
-\let\{=\mylbrace
-\let\}=\myrbrace
-\begingroup
-  % Definitions to produce actual \{ & \} command in an index.
-  \catcode`\{ = 12 \catcode`\} = 12
-  \catcode`\[ = 1 \catcode`\] = 2
-  \catcode`\@ = 0 \catcode`\\ = 12
-  @gdef@lbracecmd[\{]%
-  @gdef@rbracecmd[\}]%
-@endgroup
-
-% Accents: @, @dotaccent @ringaccent @ubaraccent @udotaccent
-% Others are defined by plain TeX: @` @' @" @^ @~ @= @v @H.
-\let\, = \c
-\let\dotaccent = \.
-\def\ringaccent#1{{\accent23 #1}}
-\let\tieaccent = \t
-\let\ubaraccent = \b
-\let\udotaccent = \d
-
-% Other special characters: @questiondown @exclamdown
-% Plain TeX defines: @AA @AE @O @OE @L (and lowercase versions) @ss.
-\def\questiondown{?`}
-\def\exclamdown{!`}
-
-% Dotless i and dotless j, used for accents.
-\def\imacro{i}
-\def\jmacro{j}
-\def\dotless#1{%
-  \def\temp{#1}%
-  \ifx\temp\imacro \ptexi
-  \else\ifx\temp\jmacro \j
-  \else \errmessage{@dotless can be used only with i or j}%
-  \fi\fi
-}
-
-% Be sure we're in horizontal mode when doing a tie, since we make space
-% equivalent to this in @example-like environments. Otherwise, a space
-% at the beginning of a line will start with \penalty -- and
-% since \penalty is valid in vertical mode, we'd end up putting the
-% penalty on the vertical list instead of in the new paragraph.
-{\catcode`@ = 11
- % Avoid using \@M directly, because that causes trouble
- % if the definition is written into an index file.
- \global\let\tiepenalty = \@M
- \gdef\tie{\leavevmode\penalty\tiepenalty\ }
-}
-
-% @: forces normal size whitespace following.
-\def\:{\spacefactor=1000 }
-
-% @* forces a line break.
-\def\*{\hfil\break\hbox{}\ignorespaces}
-
-% @. is an end-of-sentence period.
-\def\.{.\spacefactor=3000 }
-
-% @! is an end-of-sentence bang.
-\def\!{!\spacefactor=3000 }
-
-% @? is an end-of-sentence query.
-\def\?{?\spacefactor=3000 }
-
-% @w prevents a word break.  Without the \leavevmode, @w at the
-% beginning of a paragraph, when TeX is still in vertical mode, would
-% produce a whole line of output instead of starting the paragraph.
-\def\w#1{\leavevmode\hbox{#1}}
-
-% @group ... @end group forces ... to be all on one page, by enclosing
-% it in a TeX vbox.  We use \vtop instead of \vbox to construct the box
-% to keep its height that of a normal line.  According to the rules for
-% \topskip (p.114 of the TeXbook), the glue inserted is
-% max (\topskip - \ht (first item), 0).  If that height is large,
-% therefore, no glue is inserted, and the space between the headline and
-% the text is small, which looks bad.
-%
-\def\group{\begingroup
-  \ifnum\catcode13=\active \else
-    \errhelp = \groupinvalidhelp
-    \errmessage{@group invalid in context where filling is enabled}%
-  \fi
-  %
-  % The \vtop we start below produces a box with normal height and large
-  % depth; thus, TeX puts \baselineskip glue before it, and (when the
-  % next line of text is done) \lineskip glue after it.  (See p.82 of
-  % the TeXbook.)  Thus, space below is not quite equal to space
-  % above.  But it's pretty close.
-  \def\Egroup{%
-    \egroup           % End the \vtop.
-    \endgroup         % End the \group.
-  }%
-  %
-  \vtop\bgroup
-    % We have to put a strut on the last line in case the @group is in
-    % the midst of an example, rather than completely enclosing it.
-    % Otherwise, the interline space between the last line of the group
-    % and the first line afterwards is too small.  But we can't put the
-    % strut in \Egroup, since there it would be on a line by itself.
-    % Hence this just inserts a strut at the beginning of each line.
-    \everypar = {\strut}%
-    %
-    % Since we have a strut on every line, we don't need any of TeX's
-    % normal interline spacing.
-    \offinterlineskip
-    %
-    % OK, but now we have to do something about blank
-    % lines in the input in @example-like environments, which normally
-    % just turn into \lisppar, which will insert no space now that we've
-    % turned off the interline space.  Simplest is to make them be an
-    % empty paragraph.
-    \ifx\par\lisppar
-      \edef\par{\leavevmode \par}%
-      %
-      % Reset ^^M's definition to new definition of \par.
-      \obeylines
-    \fi
-    %
-    % Do @comment since we are called inside an environment such as
-    % @example, where each end-of-line in the input causes an
-    % end-of-line in the output.  We don't want the end-of-line after
-    % the `@group' to put extra space in the output.  Since @group
-    % should appear on a line by itself (according to the Texinfo
-    % manual), we don't worry about eating any user text.
-    \comment
-}
-%
-% TeX puts in an \escapechar (i.e., `@') at the beginning of the help
-% message, so this ends up printing `@group can only ...'.
-%
-\newhelp\groupinvalidhelp{%
-group can only be used in environments such as @example,^^J%
-where each line of input produces a line of output.}
-
-% @need space-in-mils
-% forces a page break if there is not space-in-mils remaining.
-
-\newdimen\mil  \mil=0.001in
-
-\def\need{\parsearg\needx}
-
-% Old definition--didn't work.
-%\def\needx #1{\par %
-%% This method tries to make TeX break the page naturally
-%% if the depth of the box does not fit.
-%{\baselineskip=0pt%
-%\vtop to #1\mil{\vfil}\kern -#1\mil\nobreak
-%\prevdepth=-1000pt
-%}}
-
-\def\needx#1{%
-  % Ensure vertical mode, so we don't make a big box in the middle of a
-  % paragraph.
-  \par
-  %
-  % If the @need value is less than one line space, it's useless.
-  \dimen0 = #1\mil
-  \dimen2 = \ht\strutbox
-  \advance\dimen2 by \dp\strutbox
-  \ifdim\dimen0 > \dimen2
-    %
-    % Do a \strut just to make the height of this box be normal, so the
-    % normal leading is inserted relative to the preceding line.
-    % And a page break here is fine.
-    \vtop to #1\mil{\strut\vfil}%
-    %
-    % TeX does not even consider page breaks if a penalty added to the
-    % main vertical list is 10000 or more.  But in order to see if the
-    % empty box we just added fits on the page, we must make it consider
-    % page breaks.  On the other hand, we don't want to actually break the
-    % page after the empty box.  So we use a penalty of 9999.
-    %
-    % There is an extremely small chance that TeX will actually break the
-    % page at this \penalty, if there are no other feasible breakpoints in
-    % sight.  (If the user is using lots of big @group commands, which
-    % almost-but-not-quite fill up a page, TeX will have a hard time doing
-    % good page breaking, for example.)  However, I could not construct an
-    % example where a page broke at this \penalty; if it happens in a real
-    % document, then we can reconsider our strategy.
-    \penalty9999
-    %
-    % Back up by the size of the box, whether we did a page break or not.
-    \kern -#1\mil
-    %
-    % Do not allow a page break right after this kern.
-    \nobreak
-  \fi
-}
-
-% @br   forces paragraph break
-
-\let\br = \par
-
-% @dots{} output an ellipsis using the current font.
-% We do .5em per period so that it has the same spacing in a typewriter
-% font as three actual period characters.
-%
-\def\dots{%
-  \leavevmode
-  \hbox to 1.5em{%
-    \hskip 0pt plus 0.25fil minus 0.25fil
-    .\hss.\hss.%
-    \hskip 0pt plus 0.5fil minus 0.5fil
-  }%
-}
-
-% @enddots{} is an end-of-sentence ellipsis.
-%
-\def\enddots{%
-  \leavevmode
-  \hbox to 2em{%
-    \hskip 0pt plus 0.25fil minus 0.25fil
-    .\hss.\hss.\hss.%
-    \hskip 0pt plus 0.5fil minus 0.5fil
-  }%
-  \spacefactor=3000
-}
-
-
-% @page    forces the start of a new page
-%
-\def\page{\par\vfill\supereject}
-
-% @exdent text....
-% outputs text on separate line in roman font, starting at standard page margin
-
-% This records the amount of indent in the innermost environment.
-% That's how much \exdent should take out.
-\newskip\exdentamount
-
-% This defn is used inside fill environments such as @defun.
-\def\exdent{\parsearg\exdentyyy}
-\def\exdentyyy #1{{\hfil\break\hbox{\kern -\exdentamount{\rm#1}}\hfil\break}}
-
-% This defn is used inside nofill environments such as @example.
-\def\nofillexdent{\parsearg\nofillexdentyyy}
-\def\nofillexdentyyy #1{{\advance \leftskip by -\exdentamount
-\leftline{\hskip\leftskip{\rm#1}}}}
-
-% @inmargin{TEXT} puts TEXT in the margin next to the current paragraph.
-
-\def\inmargin#1{%
-\strut\vadjust{\nobreak\kern-\strutdepth
-  \vtop to \strutdepth{\baselineskip\strutdepth\vss
-  \llap{\rightskip=\inmarginspacing \vbox{\noindent #1}}\null}}}
-\newskip\inmarginspacing \inmarginspacing=1cm
-\def\strutdepth{\dp\strutbox}
-
-%\hbox{{\rm#1}}\hfil\break}}
-
-% @include file    insert text of that file as input.
-% Allow normal characters that  we make active in the argument (a file name).
-\def\include{\begingroup
-  \catcode`\\=12
-  \catcode`~=12
-  \catcode`^=12
-  \catcode`_=12
-  \catcode`|=12
-  \catcode`<=12
-  \catcode`>=12
-  \catcode`+=12
-  \parsearg\includezzz}
-% Restore active chars for included file.
-\def\includezzz#1{\endgroup\begingroup
-  % Read the included file in a group so nested @include's work.
-  \def\thisfile{#1}%
-  \input\thisfile
-\endgroup}
-
-\def\thisfile{}
-
-% @center line   outputs that line, centered
-
-\def\center{\parsearg\centerzzz}
-\def\centerzzz #1{{\advance\hsize by -\leftskip
-\advance\hsize by -\rightskip
-\centerline{#1}}}
-
-% @sp n   outputs n lines of vertical space
-
-\def\sp{\parsearg\spxxx}
-\def\spxxx #1{\vskip #1\baselineskip}
-
-% @comment ...line which is ignored...
-% @c is the same as @comment
-% @ignore ... @end ignore  is another way to write a comment
-
-\def\comment{\begingroup \catcode`\^^M=\other%
-\catcode`\@=\other \catcode`\{=\other \catcode`\}=\other%
-\commentxxx}
-{\catcode`\^^M=\other \gdef\commentxxx#1^^M{\endgroup}}
-
-\let\c=\comment
-
-% @paragraphindent NCHARS
-% We'll use ems for NCHARS, close enough.
-% We cannot implement @paragraphindent asis, though.
-% 
-\def\asisword{asis} % no translation, these are keywords
-\def\noneword{none}
-%
-\def\paragraphindent{\parsearg\doparagraphindent}
-\def\doparagraphindent#1{%
-  \def\temp{#1}%
-  \ifx\temp\asisword
-  \else
-    \ifx\temp\noneword
-      \defaultparindent = 0pt
-    \else
-      \defaultparindent = #1em
-    \fi
-  \fi
-  \parindent = \defaultparindent
-}
-
-% @exampleindent NCHARS
-% We'll use ems for NCHARS like @paragraphindent.
-% It seems @exampleindent asis isn't necessary, but
-% I preserve it to make it similar to @paragraphindent.
-\def\exampleindent{\parsearg\doexampleindent}
-\def\doexampleindent#1{%
-  \def\temp{#1}%
-  \ifx\temp\asisword
-  \else
-    \ifx\temp\noneword
-      \lispnarrowing = 0pt
-    \else
-      \lispnarrowing = #1em
-    \fi
-  \fi
-}
-
-% @asis just yields its argument.  Used with @table, for example.
-%
-\def\asis#1{#1}
-
-% @math means output in math mode.
-% We don't use $'s directly in the definition of \math because control
-% sequences like \math are expanded when the toc file is written.  Then,
-% we read the toc file back, the $'s will be normal characters (as they
-% should be, according to the definition of Texinfo).  So we must use a
-% control sequence to switch into and out of math mode.
-%
-% This isn't quite enough for @math to work properly in indices, but it
-% seems unlikely it will ever be needed there.
-%
-\let\implicitmath = $
-\def\math#1{\implicitmath #1\implicitmath}
-
-% @bullet and @minus need the same treatment as @math, just above.
-\def\bullet{\implicitmath\ptexbullet\implicitmath}
-\def\minus{\implicitmath-\implicitmath}
-
-% @refill is a no-op.
-\let\refill=\relax
-
-% If working on a large document in chapters, it is convenient to
-% be able to disable indexing, cross-referencing, and contents, for test runs.
-% This is done with @novalidate (before @setfilename).
-%
-\newif\iflinks \linkstrue % by default we want the aux files.
-\let\novalidate = \linksfalse
-
-% @setfilename is done at the beginning of every texinfo file.
-% So open here the files we need to have open while reading the input.
-% This makes it possible to make a .fmt file for texinfo.
-\def\setfilename{%
-   \iflinks
-     \readauxfile
-   \fi % \openindices needs to do some work in any case.
-   \openindices
-   \fixbackslash  % Turn off hack to swallow `\input texinfo'.
-   \global\let\setfilename=\comment % Ignore extra @setfilename cmds.
-   %
-   % If texinfo.cnf is present on the system, read it.
-   % Useful for site-wide @afourpaper, etc.
-   % Just to be on the safe side, close the input stream before the \input.
-   \openin 1 texinfo.cnf
-   \ifeof1 \let\temp=\relax \else \def\temp{\input texinfo.cnf }\fi
-   \closein1
-   \temp
-   %
-   \comment % Ignore the actual filename.
-}
-
-% Called from \setfilename.
-%
-\def\openindices{%
-  \newindex{cp}%
-  \newcodeindex{fn}%
-  \newcodeindex{vr}%
-  \newcodeindex{tp}%
-  \newcodeindex{ky}%
-  \newcodeindex{pg}%
-}
-
-% @bye.
-\outer\def\bye{\pagealignmacro\tracingstats=1\ptexend}
-
-
-\message{pdf,}
-% adobe `portable' document format
-\newcount\tempnum
-\newcount\lnkcount
-\newtoks\filename
-\newcount\filenamelength
-\newcount\pgn
-\newtoks\toksA
-\newtoks\toksB
-\newtoks\toksC
-\newtoks\toksD
-\newbox\boxA
-\newcount\countA
-\newif\ifpdf
-\newif\ifpdfmakepagedest
-
-\ifx\pdfoutput\undefined
-  \pdffalse
-  \let\pdfmkdest = \gobble
-  \let\pdfurl = \gobble
-  \let\endlink = \relax
-  \let\linkcolor = \relax
-  \let\pdfmakeoutlines = \relax
-\else
-  \pdftrue
-  \pdfoutput = 1
-  \input pdfcolor
-  \def\dopdfimage#1#2#3{%
-    \def\imagewidth{#2}%
-    \def\imageheight{#3}%
-    \ifnum\pdftexversion < 14
-      \pdfimage
-    \else
-      \pdfximage
-    \fi
-      \ifx\empty\imagewidth\else width \imagewidth \fi
-      \ifx\empty\imageheight\else height \imageheight \fi
-      {#1.pdf}%
-    \ifnum\pdftexversion < 14 \else
-      \pdfrefximage \pdflastximage
-    \fi}
-  \def\pdfmkdest#1{\pdfdest name{#1@} xyz}
-  \def\pdfmkpgn#1{#1@}
-  \let\linkcolor = \Cyan
-  \def\endlink{\Black\pdfendlink}
-  % Adding outlines to PDF; macros for calculating structure of outlines
-  % come from Petr Olsak
-  \def\expnumber#1{\expandafter\ifx\csname#1\endcsname\relax 0%
-    \else \csname#1\endcsname \fi}
-  \def\advancenumber#1{\tempnum=\expnumber{#1}\relax
-    \advance\tempnum by1
-    \expandafter\xdef\csname#1\endcsname{\the\tempnum}}
-  \def\pdfmakeoutlines{{%
-    \openin 1 \jobname.toc
-    \ifeof 1\else\bgroup
-      \closein 1 
-      \indexnofonts
-      \def\tt{}
-      % thanh's hack / proper braces in bookmarks  
-      \edef\mylbrace{\iftrue \string{\else}\fi}\let\{=\mylbrace
-      \edef\myrbrace{\iffalse{\else\string}\fi}\let\}=\myrbrace
-      %
-      \def\chapentry ##1##2##3{}
-      \def\unnumbchapentry ##1##2{}
-      \def\secentry ##1##2##3##4{\advancenumber{chap##2}}
-      \def\unnumbsecentry ##1##2{}
-      \def\subsecentry ##1##2##3##4##5{\advancenumber{sec##2.##3}}
-      \def\unnumbsubsecentry ##1##2{}
-      \def\subsubsecentry ##1##2##3##4##5##6{\advancenumber{subsec##2.##3.##4}}
-      \def\unnumbsubsubsecentry ##1##2{}
-      \input \jobname.toc
-      \def\chapentry ##1##2##3{%
-        \pdfoutline goto name{\pdfmkpgn{##3}}count-\expnumber{chap##2}{##1}}
-      \def\unnumbchapentry ##1##2{%
-        \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
-      \def\secentry ##1##2##3##4{%
-        \pdfoutline goto name{\pdfmkpgn{##4}}count-\expnumber{sec##2.##3}{##1}}
-      \def\unnumbsecentry ##1##2{%
-        \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
-      \def\subsecentry ##1##2##3##4##5{%
-        \pdfoutline goto name{\pdfmkpgn{##5}}count-\expnumber{subsec##2.##3.##4}{##1}}
-      \def\unnumbsubsecentry ##1##2{%
-        \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
-      \def\subsubsecentry ##1##2##3##4##5##6{%
-        \pdfoutline goto name{\pdfmkpgn{##6}}{##1}}
-      \def\unnumbsubsubsecentry ##1##2{%
-        \pdfoutline goto name{\pdfmkpgn{##2}}{##1}}
-      \input \jobname.toc
-    \egroup\fi
-  }}
-  \def\makelinks #1,{%
-    \def\params{#1}\def\E{END}%
-    \ifx\params\E
-      \let\nextmakelinks=\relax
-    \else
-      \let\nextmakelinks=\makelinks
-      \ifnum\lnkcount>0,\fi
-      \picknum{#1}%
-      \startlink attr{/Border [0 0 0]} 
-        goto name{\pdfmkpgn{\the\pgn}}%
-      \linkcolor #1%
-      \advance\lnkcount by 1%
-      \endlink
-    \fi
-    \nextmakelinks
-  }
-  \def\picknum#1{\expandafter\pn#1}
-  \def\pn#1{%
-    \def\p{#1}%
-    \ifx\p\lbrace
-      \let\nextpn=\ppn
-    \else
-      \let\nextpn=\ppnn
-      \def\first{#1}
-    \fi
-    \nextpn
-  }
-  \def\ppn#1{\pgn=#1\gobble}
-  \def\ppnn{\pgn=\first}
-  \def\pdfmklnk#1{\lnkcount=0\makelinks #1,END,}
-  \def\addtokens#1#2{\edef\addtoks{\noexpand#1={\the#1#2}}\addtoks}
-  \def\skipspaces#1{\def\PP{#1}\def\D{|}%
-    \ifx\PP\D\let\nextsp\relax
-    \else\let\nextsp\skipspaces
-      \ifx\p\space\else\addtokens{\filename}{\PP}%
-        \advance\filenamelength by 1
-      \fi
-    \fi
-    \nextsp}
-  \def\getfilename#1{\filenamelength=0\expandafter\skipspaces#1|\relax}
-  \ifnum\pdftexversion < 14
-    \let \startlink \pdfannotlink
-  \else
-    \let \startlink \pdfstartlink
-  \fi
-  \def\pdfurl#1{%
-    \begingroup
-      \normalturnoffactive\def\@{@}%
-      \leavevmode\Red
-      \startlink attr{/Border [0 0 0]}%
-        user{/Subtype /Link /A << /S /URI /URI (#1) >>}%
-        % #1
-    \endgroup}
-  \def\pdfgettoks#1.{\setbox\boxA=\hbox{\toksA={#1.}\toksB={}\maketoks}}
-  \def\addtokens#1#2{\edef\addtoks{\noexpand#1={\the#1#2}}\addtoks}
-  \def\adn#1{\addtokens{\toksC}{#1}\global\countA=1\let\next=\maketoks}
-  \def\poptoks#1#2|ENDTOKS|{\let\first=#1\toksD={#1}\toksA={#2}}
-  \def\maketoks{%
-    \expandafter\poptoks\the\toksA|ENDTOKS|
-    \ifx\first0\adn0
-    \else\ifx\first1\adn1 \else\ifx\first2\adn2 \else\ifx\first3\adn3
-    \else\ifx\first4\adn4 \else\ifx\first5\adn5 \else\ifx\first6\adn6
-    \else\ifx\first7\adn7 \else\ifx\first8\adn8 \else\ifx\first9\adn9 
-    \else
-      \ifnum0=\countA\else\makelink\fi
-      \ifx\first.\let\next=\done\else
-        \let\next=\maketoks
-        \addtokens{\toksB}{\the\toksD}
-        \ifx\first,\addtokens{\toksB}{\space}\fi
-      \fi
-    \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
-    \next}
-  \def\makelink{\addtokens{\toksB}%
-    {\noexpand\pdflink{\the\toksC}}\toksC={}\global\countA=0}
-  \def\pdflink#1{%
-    \startlink attr{/Border [0 0 0]} goto name{\mkpgn{#1}}
-    \linkcolor #1\endlink}
-  \def\mkpgn#1{#1@} 
-  \def\done{\edef\st{\global\noexpand\toksA={\the\toksB}}\st}
-\fi % \ifx\pdfoutput
-
-
-\message{fonts,}
-% Font-change commands.
-
-% Texinfo sort of supports the sans serif font style, which plain TeX does not.
-% So we set up a \sf analogous to plain's \rm, etc.
-\newfam\sffam
-\def\sf{\fam=\sffam \tensf}
-\let\li = \sf % Sometimes we call it \li, not \sf.
-
-% We don't need math for this one.
-\def\ttsl{\tenttsl}
-
-% Use Computer Modern fonts at \magstephalf (11pt).
-\newcount\mainmagstep
-\mainmagstep=\magstephalf
-
-% Set the font macro #1 to the font named #2, adding on the
-% specified font prefix (normally `cm').
-% #3 is the font's design size, #4 is a scale factor
-\def\setfont#1#2#3#4{\font#1=\fontprefix#2#3 scaled #4}
-
-% Use cm as the default font prefix.
-% To specify the font prefix, you must define \fontprefix
-% before you read in texinfo.tex.
-\ifx\fontprefix\undefined
-\def\fontprefix{cm}
-\fi
-% Support font families that don't use the same naming scheme as CM.
-\def\rmshape{r}
-\def\rmbshape{bx}               %where the normal face is bold
-\def\bfshape{b}
-\def\bxshape{bx}
-\def\ttshape{tt}
-\def\ttbshape{tt}
-\def\ttslshape{sltt}
-\def\itshape{ti}
-\def\itbshape{bxti}
-\def\slshape{sl}
-\def\slbshape{bxsl}
-\def\sfshape{ss}
-\def\sfbshape{ss}
-\def\scshape{csc}
-\def\scbshape{csc}
-
-\ifx\bigger\relax
-\let\mainmagstep=\magstep1
-\setfont\textrm\rmshape{12}{1000}
-\setfont\texttt\ttshape{12}{1000}
-\else
-\setfont\textrm\rmshape{10}{\mainmagstep}
-\setfont\texttt\ttshape{10}{\mainmagstep}
-\fi
-% Instead of cmb10, you many want to use cmbx10.
-% cmbx10 is a prettier font on its own, but cmb10
-% looks better when embedded in a line with cmr10.
-\setfont\textbf\bfshape{10}{\mainmagstep}
-\setfont\textit\itshape{10}{\mainmagstep}
-\setfont\textsl\slshape{10}{\mainmagstep}
-\setfont\textsf\sfshape{10}{\mainmagstep}
-\setfont\textsc\scshape{10}{\mainmagstep}
-\setfont\textttsl\ttslshape{10}{\mainmagstep}
-\font\texti=cmmi10 scaled \mainmagstep
-\font\textsy=cmsy10 scaled \mainmagstep
-
-% A few fonts for @defun, etc.
-\setfont\defbf\bxshape{10}{\magstep1} %was 1314
-\setfont\deftt\ttshape{10}{\magstep1}
-\def\df{\let\tentt=\deftt \let\tenbf = \defbf \bf}
-
-% Fonts for indices, footnotes, small examples (9pt).
-\setfont\smallrm\rmshape{9}{1000}
-\setfont\smalltt\ttshape{9}{1000}
-\setfont\smallbf\bfshape{10}{900}
-\setfont\smallit\itshape{9}{1000}
-\setfont\smallsl\slshape{9}{1000}
-\setfont\smallsf\sfshape{9}{1000}
-\setfont\smallsc\scshape{10}{900}
-\setfont\smallttsl\ttslshape{10}{900}
-\font\smalli=cmmi9
-\font\smallsy=cmsy9
-
-% Fonts for title page:
-\setfont\titlerm\rmbshape{12}{\magstep3}
-\setfont\titleit\itbshape{10}{\magstep4}
-\setfont\titlesl\slbshape{10}{\magstep4}
-\setfont\titlett\ttbshape{12}{\magstep3}
-\setfont\titlettsl\ttslshape{10}{\magstep4}
-\setfont\titlesf\sfbshape{17}{\magstep1}
-\let\titlebf=\titlerm
-\setfont\titlesc\scbshape{10}{\magstep4}
-\font\titlei=cmmi12 scaled \magstep3
-\font\titlesy=cmsy10 scaled \magstep4
-\def\authorrm{\secrm}
-
-% Chapter (and unnumbered) fonts (17.28pt).
-\setfont\chaprm\rmbshape{12}{\magstep2}
-\setfont\chapit\itbshape{10}{\magstep3}
-\setfont\chapsl\slbshape{10}{\magstep3}
-\setfont\chaptt\ttbshape{12}{\magstep2}
-\setfont\chapttsl\ttslshape{10}{\magstep3}
-\setfont\chapsf\sfbshape{17}{1000}
-\let\chapbf=\chaprm
-\setfont\chapsc\scbshape{10}{\magstep3}
-\font\chapi=cmmi12 scaled \magstep2
-\font\chapsy=cmsy10 scaled \magstep3
-
-% Section fonts (14.4pt).
-\setfont\secrm\rmbshape{12}{\magstep1}
-\setfont\secit\itbshape{10}{\magstep2}
-\setfont\secsl\slbshape{10}{\magstep2}
-\setfont\sectt\ttbshape{12}{\magstep1}
-\setfont\secttsl\ttslshape{10}{\magstep2}
-\setfont\secsf\sfbshape{12}{\magstep1}
-\let\secbf\secrm
-\setfont\secsc\scbshape{10}{\magstep2}
-\font\seci=cmmi12 scaled \magstep1
-\font\secsy=cmsy10 scaled \magstep2
-
-% \setfont\ssecrm\bxshape{10}{\magstep1}    % This size an font looked bad.
-% \setfont\ssecit\itshape{10}{\magstep1}    % The letters were too crowded.
-% \setfont\ssecsl\slshape{10}{\magstep1}
-% \setfont\ssectt\ttshape{10}{\magstep1}
-% \setfont\ssecsf\sfshape{10}{\magstep1}
-
-%\setfont\ssecrm\bfshape{10}{1315}      % Note the use of cmb rather than cmbx.
-%\setfont\ssecit\itshape{10}{1315}      % Also, the size is a little larger than
-%\setfont\ssecsl\slshape{10}{1315}      % being scaled magstep1.
-%\setfont\ssectt\ttshape{10}{1315}
-%\setfont\ssecsf\sfshape{10}{1315}
-
-%\let\ssecbf=\ssecrm
-
-% Subsection fonts (13.15pt).
-\setfont\ssecrm\rmbshape{12}{\magstephalf}
-\setfont\ssecit\itbshape{10}{1315}
-\setfont\ssecsl\slbshape{10}{1315}
-\setfont\ssectt\ttbshape{12}{\magstephalf}
-\setfont\ssecttsl\ttslshape{10}{1315}
-\setfont\ssecsf\sfbshape{12}{\magstephalf}
-\let\ssecbf\ssecrm
-\setfont\ssecsc\scbshape{10}{\magstep1}
-\font\sseci=cmmi12 scaled \magstephalf
-\font\ssecsy=cmsy10 scaled 1315
-% The smallcaps and symbol fonts should actually be scaled \magstep1.5,
-% but that is not a standard magnification.
-
-% In order for the font changes to affect most math symbols and letters,
-% we have to define the \textfont of the standard families.  Since
-% texinfo doesn't allow for producing subscripts and superscripts, we
-% don't bother to reset \scriptfont and \scriptscriptfont (which would
-% also require loading a lot more fonts).
-%
-\def\resetmathfonts{%
-  \textfont0 = \tenrm \textfont1 = \teni \textfont2 = \tensy
-  \textfont\itfam = \tenit \textfont\slfam = \tensl \textfont\bffam = \tenbf
-  \textfont\ttfam = \tentt \textfont\sffam = \tensf
-}
-
-
-% The font-changing commands redefine the meanings of \tenSTYLE, instead
-% of just \STYLE.  We do this so that font changes will continue to work
-% in math mode, where it is the current \fam that is relevant in most
-% cases, not the current font.  Plain TeX does \def\bf{\fam=\bffam
-% \tenbf}, for example.  By redefining \tenbf, we obviate the need to
-% redefine \bf itself.
-\def\textfonts{%
-  \let\tenrm=\textrm \let\tenit=\textit \let\tensl=\textsl
-  \let\tenbf=\textbf \let\tentt=\texttt \let\smallcaps=\textsc
-  \let\tensf=\textsf \let\teni=\texti \let\tensy=\textsy \let\tenttsl=\textttsl
-  \resetmathfonts}
-\def\titlefonts{%
-  \let\tenrm=\titlerm \let\tenit=\titleit \let\tensl=\titlesl
-  \let\tenbf=\titlebf \let\tentt=\titlett \let\smallcaps=\titlesc
-  \let\tensf=\titlesf \let\teni=\titlei \let\tensy=\titlesy
-  \let\tenttsl=\titlettsl
-  \resetmathfonts \setleading{25pt}}
-\def\titlefont#1{{\titlefonts\rm #1}}
-\def\chapfonts{%
-  \let\tenrm=\chaprm \let\tenit=\chapit \let\tensl=\chapsl
-  \let\tenbf=\chapbf \let\tentt=\chaptt \let\smallcaps=\chapsc
-  \let\tensf=\chapsf \let\teni=\chapi \let\tensy=\chapsy \let\tenttsl=\chapttsl
-  \resetmathfonts \setleading{19pt}}
-\def\secfonts{%
-  \let\tenrm=\secrm \let\tenit=\secit \let\tensl=\secsl
-  \let\tenbf=\secbf \let\tentt=\sectt \let\smallcaps=\secsc
-  \let\tensf=\secsf \let\teni=\seci \let\tensy=\secsy \let\tenttsl=\secttsl
-  \resetmathfonts \setleading{16pt}}
-\def\subsecfonts{%
-  \let\tenrm=\ssecrm \let\tenit=\ssecit \let\tensl=\ssecsl
-  \let\tenbf=\ssecbf \let\tentt=\ssectt \let\smallcaps=\ssecsc
-  \let\tensf=\ssecsf \let\teni=\sseci \let\tensy=\ssecsy \let\tenttsl=\ssecttsl
-  \resetmathfonts \setleading{15pt}}
-\let\subsubsecfonts = \subsecfonts % Maybe make sssec fonts scaled magstephalf?
-\def\smallfonts{%
-  \let\tenrm=\smallrm \let\tenit=\smallit \let\tensl=\smallsl
-  \let\tenbf=\smallbf \let\tentt=\smalltt \let\smallcaps=\smallsc
-  \let\tensf=\smallsf \let\teni=\smalli \let\tensy=\smallsy
-  \let\tenttsl=\smallttsl
-  \resetmathfonts \setleading{11pt}}
-
-% Set up the default fonts, so we can use them for creating boxes.
-%
-\textfonts
-
-% Define these so they can be easily changed for other fonts.
-\def\angleleft{$\langle$}
-\def\angleright{$\rangle$}
-
-% Count depth in font-changes, for error checks
-\newcount\fontdepth \fontdepth=0
-
-% Fonts for short table of contents.
-\setfont\shortcontrm\rmshape{12}{1000}
-\setfont\shortcontbf\bxshape{12}{1000}
-\setfont\shortcontsl\slshape{12}{1000}
-
-%% Add scribe-like font environments, plus @l for inline lisp (usually sans
-%% serif) and @ii for TeX italic
-
-% \smartitalic{ARG} outputs arg in italics, followed by an italic correction
-% unless the following character is such as not to need one.
-\def\smartitalicx{\ifx\next,\else\ifx\next-\else\ifx\next.\else\/\fi\fi\fi}
-\def\smartslanted#1{{\sl #1}\futurelet\next\smartitalicx}
-\def\smartitalic#1{{\it #1}\futurelet\next\smartitalicx}
-
-\let\i=\smartitalic
-\let\var=\smartslanted
-\let\dfn=\smartslanted
-\let\emph=\smartitalic
-\let\cite=\smartslanted
-
-\def\b#1{{\bf #1}}
-\let\strong=\b
-
-% We can't just use \exhyphenpenalty, because that only has effect at
-% the end of a paragraph.  Restore normal hyphenation at the end of the
-% group within which \nohyphenation is presumably called.
-%
-\def\nohyphenation{\hyphenchar\font = -1  \aftergroup\restorehyphenation}
-\def\restorehyphenation{\hyphenchar\font = `- }
-
-\def\t#1{%
-  {\tt \rawbackslash \frenchspacing #1}%
-  \null
-}
-\let\ttfont=\t
-\def\samp#1{`\tclose{#1}'\null}
-\setfont\keyrm\rmshape{8}{1000}
-\font\keysy=cmsy9
-\def\key#1{{\keyrm\textfont2=\keysy \leavevmode\hbox{%
-  \raise0.4pt\hbox{\angleleft}\kern-.08em\vtop{%
-    \vbox{\hrule\kern-0.4pt
-     \hbox{\raise0.4pt\hbox{\vphantom{\angleleft}}#1}}%
-    \kern-0.4pt\hrule}%
-  \kern-.06em\raise0.4pt\hbox{\angleright}}}}
-% The old definition, with no lozenge:
-%\def\key #1{{\ttsl \nohyphenation \uppercase{#1}}\null}
-\def\ctrl #1{{\tt \rawbackslash \hat}#1}
-
-% @file, @option are the same as @samp.
-\let\file=\samp
-\let\option=\samp
-
-% @code is a modification of @t,
-% which makes spaces the same size as normal in the surrounding text.
-\def\tclose#1{%
-  {%
-    % Change normal interword space to be same as for the current font.
-    \spaceskip = \fontdimen2\font
-    %
-    % Switch to typewriter.
-    \tt
-    %
-    % But `\ ' produces the large typewriter interword space.
-    \def\ {{\spaceskip = 0pt{} }}%
-    %
-    % Turn off hyphenation.
-    \nohyphenation
-    %
-    \rawbackslash
-    \frenchspacing
-    #1%
-  }%
-  \null
-}
-
-% We *must* turn on hyphenation at `-' and `_' in \code.
-% Otherwise, it is too hard to avoid overfull hboxes
-% in the Emacs manual, the Library manual, etc.
-
-% Unfortunately, TeX uses one parameter (\hyphenchar) to control
-% both hyphenation at - and hyphenation within words.
-% We must therefore turn them both off (\tclose does that)
-% and arrange explicitly to hyphenate at a dash.
-%  -- rms.
-{
-  \catcode`\-=\active
-  \catcode`\_=\active
-  %
-  \global\def\code{\begingroup
-    \catcode`\-=\active \let-\codedash
-    \catcode`\_=\active \let_\codeunder
-    \codex
-  }
-  %
-  % If we end up with any active - characters when handling the index,
-  % just treat them as a normal -.
-  \global\def\indexbreaks{\catcode`\-=\active \let-\realdash}
-}
-
-\def\realdash{-}
-\def\codedash{-\discretionary{}{}{}}
-\def\codeunder{\ifusingtt{\normalunderscore\discretionary{}{}{}}{\_}}
-\def\codex #1{\tclose{#1}\endgroup}
-
-%\let\exp=\tclose  %Was temporary
-
-% @kbd is like @code, except that if the argument is just one @key command,
-% then @kbd has no effect.
-
-% @kbdinputstyle -- arg is `distinct' (@kbd uses slanted tty font always),
-%   `example' (@kbd uses ttsl only inside of @example and friends),
-%   or `code' (@kbd uses normal tty font always).
-\def\kbdinputstyle{\parsearg\kbdinputstylexxx}
-\def\kbdinputstylexxx#1{%
-  \def\arg{#1}%
-  \ifx\arg\worddistinct
-    \gdef\kbdexamplefont{\ttsl}\gdef\kbdfont{\ttsl}%
-  \else\ifx\arg\wordexample
-    \gdef\kbdexamplefont{\ttsl}\gdef\kbdfont{\tt}%
-  \else\ifx\arg\wordcode
-    \gdef\kbdexamplefont{\tt}\gdef\kbdfont{\tt}%
-  \fi\fi\fi
-}
-\def\worddistinct{distinct}
-\def\wordexample{example}
-\def\wordcode{code}
-
-% Default is kbdinputdistinct.  (Too much of a hassle to call the macro,
-% the catcodes are wrong for parsearg to work.)
-\gdef\kbdexamplefont{\ttsl}\gdef\kbdfont{\ttsl}
-
-\def\xkey{\key}
-\def\kbdfoo#1#2#3\par{\def\one{#1}\def\three{#3}\def\threex{??}%
-\ifx\one\xkey\ifx\threex\three \key{#2}%
-\else{\tclose{\kbdfont\look}}\fi
-\else{\tclose{\kbdfont\look}}\fi}
-
-% For @url, @env, @command quotes seem unnecessary, so use \code.
-\let\url=\code
-\let\env=\code
-\let\command=\code
-
-% @uref (abbreviation for `urlref') takes an optional (comma-separated)
-% second argument specifying the text to display and an optional third
-% arg as text to display instead of (rather than in addition to) the url
-% itself.  First (mandatory) arg is the url.  Perhaps eventually put in
-% a hypertex \special here.
-%
-\def\uref#1{\douref #1,,,\finish}
-\def\douref#1,#2,#3,#4\finish{\begingroup
-  \unsepspaces
-  \pdfurl{#1}%
-  \setbox0 = \hbox{\ignorespaces #3}%
-  \ifdim\wd0 > 0pt
-    \unhbox0 % third arg given, show only that
-  \else
-    \setbox0 = \hbox{\ignorespaces #2}%
-    \ifdim\wd0 > 0pt
-      \ifpdf
-        \unhbox0             % PDF: 2nd arg given, show only it
-      \else
-        \unhbox0\ (\code{#1})% DVI: 2nd arg given, show both it and url
-      \fi
-    \else
-      \code{#1}% only url given, so show it
-    \fi
-  \fi
-  \endlink
-\endgroup}
-
-% rms does not like angle brackets --karl, 17may97.
-% So now @email is just like @uref, unless we are pdf.
-% 
-%\def\email#1{\angleleft{\tt #1}\angleright}
-\ifpdf
-  \def\email#1{\doemail#1,,\finish}
-  \def\doemail#1,#2,#3\finish{\begingroup
-    \unsepspaces
-    \pdfurl{mailto:#1}%
-    \setbox0 = \hbox{\ignorespaces #2}%
-    \ifdim\wd0>0pt\unhbox0\else\code{#1}\fi
-    \endlink
-  \endgroup}
-\else
-  \let\email=\uref
-\fi
-
-% Check if we are currently using a typewriter font.  Since all the
-% Computer Modern typewriter fonts have zero interword stretch (and
-% shrink), and it is reasonable to expect all typewriter fonts to have
-% this property, we can check that font parameter.
-%
-\def\ifmonospace{\ifdim\fontdimen3\font=0pt }
-
-% Typeset a dimension, e.g., `in' or `pt'.  The only reason for the
-% argument is to make the input look right: @dmn{pt} instead of @dmn{}pt.
-%
-\def\dmn#1{\thinspace #1}
-
-\def\kbd#1{\def\look{#1}\expandafter\kbdfoo\look??\par}
-
-% @l was never documented to mean ``switch to the Lisp font'',
-% and it is not used as such in any manual I can find.  We need it for
-% Polish suppressed-l.  --karl, 22sep96.
-%\def\l#1{{\li #1}\null}
-
-% Explicit font changes: @r, @sc, undocumented @ii.
-\def\r#1{{\rm #1}}              % roman font
-\def\sc#1{{\smallcaps#1}}       % smallcaps font
-\def\ii#1{{\it #1}}             % italic font
-
-% @acronym downcases the argument and prints in smallcaps.
-\def\acronym#1{{\smallcaps \lowercase{#1}}}
-
-% @pounds{} is a sterling sign.
-\def\pounds{{\it\$}}
-
-
-\message{page headings,}
-
-\newskip\titlepagetopglue \titlepagetopglue = 1.5in
-\newskip\titlepagebottomglue \titlepagebottomglue = 2pc
-
-% First the title page.  Must do @settitle before @titlepage.
-\newif\ifseenauthor
-\newif\iffinishedtitlepage
-
-% Do an implicit @contents or @shortcontents after @end titlepage if the
-% user says @setcontentsaftertitlepage or @setshortcontentsaftertitlepage.
-%
-\newif\ifsetcontentsaftertitlepage
- \let\setcontentsaftertitlepage = \setcontentsaftertitlepagetrue
-\newif\ifsetshortcontentsaftertitlepage
- \let\setshortcontentsaftertitlepage = \setshortcontentsaftertitlepagetrue
-
-\def\shorttitlepage{\parsearg\shorttitlepagezzz}
-\def\shorttitlepagezzz #1{\begingroup\hbox{}\vskip 1.5in \chaprm \centerline{#1}%
-        \endgroup\page\hbox{}\page}
-
-\def\titlepage{\begingroup \parindent=0pt \textfonts
-   \let\subtitlerm=\tenrm
-   \def\subtitlefont{\subtitlerm \normalbaselineskip = 13pt \normalbaselines}%
-   %
-   \def\authorfont{\authorrm \normalbaselineskip = 16pt \normalbaselines}%
-   %
-   % Leave some space at the very top of the page.
-   \vglue\titlepagetopglue
-   %
-   % Now you can print the title using @title.
-   \def\title{\parsearg\titlezzz}%
-   \def\titlezzz##1{\leftline{\titlefonts\rm ##1}
-                    % print a rule at the page bottom also.
-                    \finishedtitlepagefalse
-                    \vskip4pt \hrule height 4pt width \hsize \vskip4pt}%
-   % No rule at page bottom unless we print one at the top with @title.
-   \finishedtitlepagetrue
-   %
-   % Now you can put text using @subtitle.
-   \def\subtitle{\parsearg\subtitlezzz}%
-   \def\subtitlezzz##1{{\subtitlefont \rightline{##1}}}%
-   %
-   % @author should come last, but may come many times.
-   \def\author{\parsearg\authorzzz}%
-   \def\authorzzz##1{\ifseenauthor\else\vskip 0pt plus 1filll\seenauthortrue\fi
-      {\authorfont \leftline{##1}}}%
-   %
-   % Most title ``pages'' are actually two pages long, with space
-   % at the top of the second.  We don't want the ragged left on the second.
-   \let\oldpage = \page
-   \def\page{%
-      \iffinishedtitlepage\else
-         \finishtitlepage
-      \fi
-      \oldpage
-      \let\page = \oldpage
-      \hbox{}}%
-%   \def\page{\oldpage \hbox{}}
-}
-
-\def\Etitlepage{%
-   \iffinishedtitlepage\else
-      \finishtitlepage
-   \fi
-   % It is important to do the page break before ending the group,
-   % because the headline and footline are only empty inside the group.
-   % If we use the new definition of \page, we always get a blank page
-   % after the title page, which we certainly don't want.
-   \oldpage
-   \endgroup
-   %
-   % If they want short, they certainly want long too.
-   \ifsetshortcontentsaftertitlepage
-     \shortcontents
-     \contents
-     \global\let\shortcontents = \relax
-     \global\let\contents = \relax
-   \fi
-   %
-   \ifsetcontentsaftertitlepage
-     \contents
-     \global\let\contents = \relax
-     \global\let\shortcontents = \relax
-   \fi
-   %
-   \ifpdf \pdfmakepagedesttrue \fi
-   %
-   \HEADINGSon
-}
-
-\def\finishtitlepage{%
-   \vskip4pt \hrule height 2pt width \hsize
-   \vskip\titlepagebottomglue
-   \finishedtitlepagetrue
-}
-
-%%% Set up page headings and footings.
-
-\let\thispage=\folio
-
-\newtoks\evenheadline    % headline on even pages
-\newtoks\oddheadline     % headline on odd pages
-\newtoks\evenfootline    % footline on even pages
-\newtoks\oddfootline     % footline on odd pages
-
-% Now make Tex use those variables
-\headline={{\textfonts\rm \ifodd\pageno \the\oddheadline
-                            \else \the\evenheadline \fi}}
-\footline={{\textfonts\rm \ifodd\pageno \the\oddfootline
-                            \else \the\evenfootline \fi}\HEADINGShook}
-\let\HEADINGShook=\relax
-
-% Commands to set those variables.
-% For example, this is what  @headings on  does
-% @evenheading @thistitle|@thispage|@thischapter
-% @oddheading @thischapter|@thispage|@thistitle
-% @evenfooting @thisfile||
-% @oddfooting ||@thisfile
-
-\def\evenheading{\parsearg\evenheadingxxx}
-\def\oddheading{\parsearg\oddheadingxxx}
-\def\everyheading{\parsearg\everyheadingxxx}
-
-\def\evenfooting{\parsearg\evenfootingxxx}
-\def\oddfooting{\parsearg\oddfootingxxx}
-\def\everyfooting{\parsearg\everyfootingxxx}
-
-{\catcode`\@=0 %
-
-\gdef\evenheadingxxx #1{\evenheadingyyy #1@|@|@|@|\finish}
-\gdef\evenheadingyyy #1@|#2@|#3@|#4\finish{%
-\global\evenheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
-
-\gdef\oddheadingxxx #1{\oddheadingyyy #1@|@|@|@|\finish}
-\gdef\oddheadingyyy #1@|#2@|#3@|#4\finish{%
-\global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
-
-\gdef\everyheadingxxx#1{\oddheadingxxx{#1}\evenheadingxxx{#1}}%
-
-\gdef\evenfootingxxx #1{\evenfootingyyy #1@|@|@|@|\finish}
-\gdef\evenfootingyyy #1@|#2@|#3@|#4\finish{%
-\global\evenfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
-
-\gdef\oddfootingxxx #1{\oddfootingyyy #1@|@|@|@|\finish}
-\gdef\oddfootingyyy #1@|#2@|#3@|#4\finish{%
-  \global\oddfootline = {\rlap{\centerline{#2}}\line{#1\hfil#3}}%
-  %
-  % Leave some space for the footline.  Hopefully ok to assume
-  % @evenfooting will not be used by itself.
-  \global\advance\pageheight by -\baselineskip
-  \global\advance\vsize by -\baselineskip
-}
-
-\gdef\everyfootingxxx#1{\oddfootingxxx{#1}\evenfootingxxx{#1}}
-%
-}% unbind the catcode of @.
-
-% @headings double      turns headings on for double-sided printing.
-% @headings single      turns headings on for single-sided printing.
-% @headings off         turns them off.
-% @headings on          same as @headings double, retained for compatibility.
-% @headings after       turns on double-sided headings after this page.
-% @headings doubleafter turns on double-sided headings after this page.
-% @headings singleafter turns on single-sided headings after this page.
-% By default, they are off at the start of a document,
-% and turned `on' after @end titlepage.
-
-\def\headings #1 {\csname HEADINGS#1\endcsname}
-
-\def\HEADINGSoff{
-\global\evenheadline={\hfil} \global\evenfootline={\hfil}
-\global\oddheadline={\hfil} \global\oddfootline={\hfil}}
-\HEADINGSoff
-% When we turn headings on, set the page number to 1.
-% For double-sided printing, put current file name in lower left corner,
-% chapter name on inside top of right hand pages, document
-% title on inside top of left hand pages, and page numbers on outside top
-% edge of all pages.
-\def\HEADINGSdouble{
-\global\pageno=1
-\global\evenfootline={\hfil}
-\global\oddfootline={\hfil}
-\global\evenheadline={\line{\folio\hfil\thistitle}}
-\global\oddheadline={\line{\thischapter\hfil\folio}}
-\global\let\contentsalignmacro = \chapoddpage
-}
-\let\contentsalignmacro = \chappager
-
-% For single-sided printing, chapter title goes across top left of page,
-% page number on top right.
-\def\HEADINGSsingle{
-\global\pageno=1
-\global\evenfootline={\hfil}
-\global\oddfootline={\hfil}
-\global\evenheadline={\line{\thischapter\hfil\folio}}
-\global\oddheadline={\line{\thischapter\hfil\folio}}
-\global\let\contentsalignmacro = \chappager
-}
-\def\HEADINGSon{\HEADINGSdouble}
-
-\def\HEADINGSafter{\let\HEADINGShook=\HEADINGSdoublex}
-\let\HEADINGSdoubleafter=\HEADINGSafter
-\def\HEADINGSdoublex{%
-\global\evenfootline={\hfil}
-\global\oddfootline={\hfil}
-\global\evenheadline={\line{\folio\hfil\thistitle}}
-\global\oddheadline={\line{\thischapter\hfil\folio}}
-\global\let\contentsalignmacro = \chapoddpage
-}
-
-\def\HEADINGSsingleafter{\let\HEADINGShook=\HEADINGSsinglex}
-\def\HEADINGSsinglex{%
-\global\evenfootline={\hfil}
-\global\oddfootline={\hfil}
-\global\evenheadline={\line{\thischapter\hfil\folio}}
-\global\oddheadline={\line{\thischapter\hfil\folio}}
-\global\let\contentsalignmacro = \chappager
-}
-
-% Subroutines used in generating headings
-% Produces Day Month Year style of output.
-\def\today{%
-  \number\day\space
-  \ifcase\month
-  \or\putwordMJan\or\putwordMFeb\or\putwordMMar\or\putwordMApr
-  \or\putwordMMay\or\putwordMJun\or\putwordMJul\or\putwordMAug
-  \or\putwordMSep\or\putwordMOct\or\putwordMNov\or\putwordMDec
-  \fi
-  \space\number\year}
-
-% @settitle line...  specifies the title of the document, for headings.
-% It generates no output of its own.
-\def\thistitle{\putwordNoTitle}
-\def\settitle{\parsearg\settitlezzz}
-\def\settitlezzz #1{\gdef\thistitle{#1}}
-
-
-\message{tables,}
-% Tables -- @table, @ftable, @vtable, @item(x), @kitem(x), @xitem(x).
-
-% default indentation of table text
-\newdimen\tableindent \tableindent=.8in
-% default indentation of @itemize and @enumerate text
-\newdimen\itemindent  \itemindent=.3in
-% margin between end of table item and start of table text.
-\newdimen\itemmargin  \itemmargin=.1in
-
-% used internally for \itemindent minus \itemmargin
-\newdimen\itemmax
-
-% Note @table, @vtable, and @vtable define @item, @itemx, etc., with
-% these defs.
-% They also define \itemindex
-% to index the item name in whatever manner is desired (perhaps none).
-
-\newif\ifitemxneedsnegativevskip
-
-\def\itemxpar{\par\ifitemxneedsnegativevskip\nobreak\vskip-\parskip\nobreak\fi}
-
-\def\internalBitem{\smallbreak \parsearg\itemzzz}
-\def\internalBitemx{\itemxpar \parsearg\itemzzz}
-
-\def\internalBxitem "#1"{\def\xitemsubtopix{#1} \smallbreak \parsearg\xitemzzz}
-\def\internalBxitemx "#1"{\def\xitemsubtopix{#1} \itemxpar \parsearg\xitemzzz}
-
-\def\internalBkitem{\smallbreak \parsearg\kitemzzz}
-\def\internalBkitemx{\itemxpar \parsearg\kitemzzz}
-
-\def\kitemzzz #1{\dosubind {kw}{\code{#1}}{for {\bf \lastfunction}}%
-                 \itemzzz {#1}}
-
-\def\xitemzzz #1{\dosubind {kw}{\code{#1}}{for {\bf \xitemsubtopic}}%
-                 \itemzzz {#1}}
-
-\def\itemzzz #1{\begingroup %
-  \advance\hsize by -\rightskip
-  \advance\hsize by -\tableindent
-  \setbox0=\hbox{\itemfont{#1}}%
-  \itemindex{#1}%
-  \nobreak % This prevents a break before @itemx.
-  %
-  % If the item text does not fit in the space we have, put it on a line
-  % by itself, and do not allow a page break either before or after that
-  % line.  We do not start a paragraph here because then if the next
-  % command is, e.g., @kindex, the whatsit would get put into the
-  % horizontal list on a line by itself, resulting in extra blank space.
-  \ifdim \wd0>\itemmax
-    %
-    % Make this a paragraph so we get the \parskip glue and wrapping,
-    % but leave it ragged-right.
-    \begingroup
-      \advance\leftskip by-\tableindent
-      \advance\hsize by\tableindent
-      \advance\rightskip by0pt plus1fil
-      \leavevmode\unhbox0\par
-    \endgroup
-    %
-    % We're going to be starting a paragraph, but we don't want the
-    % \parskip glue -- logically it's part of the @item we just started.
-    \nobreak \vskip-\parskip
-    %
-    % Stop a page break at the \parskip glue coming up.  Unfortunately
-    % we can't prevent a possible page break at the following
-    % \baselineskip glue.
-    \nobreak
-    \endgroup
-    \itemxneedsnegativevskipfalse
-  \else
-    % The item text fits into the space.  Start a paragraph, so that the
-    % following text (if any) will end up on the same line.
-    \noindent
-    % Do this with kerns and \unhbox so that if there is a footnote in
-    % the item text, it can migrate to the main vertical list and
-    % eventually be printed.
-    \nobreak\kern-\tableindent
-    \dimen0 = \itemmax  \advance\dimen0 by \itemmargin \advance\dimen0 by -\wd0
-    \unhbox0
-    \nobreak\kern\dimen0
-    \endgroup
-    \itemxneedsnegativevskiptrue
-  \fi
-}
-
-\def\item{\errmessage{@item while not in a table}}
-\def\itemx{\errmessage{@itemx while not in a table}}
-\def\kitem{\errmessage{@kitem while not in a table}}
-\def\kitemx{\errmessage{@kitemx while not in a table}}
-\def\xitem{\errmessage{@xitem while not in a table}}
-\def\xitemx{\errmessage{@xitemx while not in a table}}
-
-% Contains a kludge to get @end[description] to work.
-\def\description{\tablez{\dontindex}{1}{}{}{}{}}
-
-% @table, @ftable, @vtable.
-\def\table{\begingroup\inENV\obeylines\obeyspaces\tablex}
-{\obeylines\obeyspaces%
-\gdef\tablex #1^^M{%
-\tabley\dontindex#1        \endtabley}}
-
-\def\ftable{\begingroup\inENV\obeylines\obeyspaces\ftablex}
-{\obeylines\obeyspaces%
-\gdef\ftablex #1^^M{%
-\tabley\fnitemindex#1        \endtabley
-\def\Eftable{\endgraf\afterenvbreak\endgroup}%
-\let\Etable=\relax}}
-
-\def\vtable{\begingroup\inENV\obeylines\obeyspaces\vtablex}
-{\obeylines\obeyspaces%
-\gdef\vtablex #1^^M{%
-\tabley\vritemindex#1        \endtabley
-\def\Evtable{\endgraf\afterenvbreak\endgroup}%
-\let\Etable=\relax}}
-
-\def\dontindex #1{}
-\def\fnitemindex #1{\doind {fn}{\code{#1}}}%
-\def\vritemindex #1{\doind {vr}{\code{#1}}}%
-
-{\obeyspaces %
-\gdef\tabley#1#2 #3 #4 #5 #6 #7\endtabley{\endgroup%
-\tablez{#1}{#2}{#3}{#4}{#5}{#6}}}
-
-\def\tablez #1#2#3#4#5#6{%
-\aboveenvbreak %
-\begingroup %
-\def\Edescription{\Etable}% Necessary kludge.
-\let\itemindex=#1%
-\ifnum 0#3>0 \advance \leftskip by #3\mil \fi %
-\ifnum 0#4>0 \tableindent=#4\mil \fi %
-\ifnum 0#5>0 \advance \rightskip by #5\mil \fi %
-\def\itemfont{#2}%
-\itemmax=\tableindent %
-\advance \itemmax by -\itemmargin %
-\advance \leftskip by \tableindent %
-\exdentamount=\tableindent
-\parindent = 0pt
-\parskip = \smallskipamount
-\ifdim \parskip=0pt \parskip=2pt \fi%
-\def\Etable{\endgraf\afterenvbreak\endgroup}%
-\let\item = \internalBitem %
-\let\itemx = \internalBitemx %
-\let\kitem = \internalBkitem %
-\let\kitemx = \internalBkitemx %
-\let\xitem = \internalBxitem %
-\let\xitemx = \internalBxitemx %
-}
-
-% This is the counter used by @enumerate, which is really @itemize
-
-\newcount \itemno
-
-\def\itemize{\parsearg\itemizezzz}
-
-\def\itemizezzz #1{%
-  \begingroup % ended by the @end itemize
-  \itemizey {#1}{\Eitemize}
-}
-
-\def\itemizey #1#2{%
-\aboveenvbreak %
-\itemmax=\itemindent %
-\advance \itemmax by -\itemmargin %
-\advance \leftskip by \itemindent %
-\exdentamount=\itemindent
-\parindent = 0pt %
-\parskip = \smallskipamount %
-\ifdim \parskip=0pt \parskip=2pt \fi%
-\def#2{\endgraf\afterenvbreak\endgroup}%
-\def\itemcontents{#1}%
-\let\item=\itemizeitem}
-
-% Set sfcode to normal for the chars that usually have another value.
-% These are `.?!:;,'
-\def\frenchspacing{\sfcode46=1000 \sfcode63=1000 \sfcode33=1000
-  \sfcode58=1000 \sfcode59=1000 \sfcode44=1000 }
-
-% \splitoff TOKENS\endmark defines \first to be the first token in
-% TOKENS, and \rest to be the remainder.
-%
-\def\splitoff#1#2\endmark{\def\first{#1}\def\rest{#2}}%
-
-% Allow an optional argument of an uppercase letter, lowercase letter,
-% or number, to specify the first label in the enumerated list.  No
-% argument is the same as `1'.
-%
-\def\enumerate{\parsearg\enumeratezzz}
-\def\enumeratezzz #1{\enumeratey #1  \endenumeratey}
-\def\enumeratey #1 #2\endenumeratey{%
-  \begingroup % ended by the @end enumerate
-  %
-  % If we were given no argument, pretend we were given `1'.
-  \def\thearg{#1}%
-  \ifx\thearg\empty \def\thearg{1}\fi
-  %
-  % Detect if the argument is a single token.  If so, it might be a
-  % letter.  Otherwise, the only valid thing it can be is a number.
-  % (We will always have one token, because of the test we just made.
-  % This is a good thing, since \splitoff doesn't work given nothing at
-  % all -- the first parameter is undelimited.)
-  \expandafter\splitoff\thearg\endmark
-  \ifx\rest\empty
-    % Only one token in the argument.  It could still be anything.
-    % A ``lowercase letter'' is one whose \lccode is nonzero.
-    % An ``uppercase letter'' is one whose \lccode is both nonzero, and
-    %   not equal to itself.
-    % Otherwise, we assume it's a number.
-    %
-    % We need the \relax at the end of the \ifnum lines to stop TeX from
-    % continuing to look for a <number>.
-    %
-    \ifnum\lccode\expandafter`\thearg=0\relax
-      \numericenumerate % a number (we hope)
-    \else
-      % It's a letter.
-      \ifnum\lccode\expandafter`\thearg=\expandafter`\thearg\relax
-        \lowercaseenumerate % lowercase letter
-      \else
-        \uppercaseenumerate % uppercase letter
-      \fi
-    \fi
-  \else
-    % Multiple tokens in the argument.  We hope it's a number.
-    \numericenumerate
-  \fi
-}
-
-% An @enumerate whose labels are integers.  The starting integer is
-% given in \thearg.
-%
-\def\numericenumerate{%
-  \itemno = \thearg
-  \startenumeration{\the\itemno}%
-}
-
-% The starting (lowercase) letter is in \thearg.
-\def\lowercaseenumerate{%
-  \itemno = \expandafter`\thearg
-  \startenumeration{%
-    % Be sure we're not beyond the end of the alphabet.
-    \ifnum\itemno=0
-      \errmessage{No more lowercase letters in @enumerate; get a bigger
-                  alphabet}%
-    \fi
-    \char\lccode\itemno
-  }%
-}
-
-% The starting (uppercase) letter is in \thearg.
-\def\uppercaseenumerate{%
-  \itemno = \expandafter`\thearg
-  \startenumeration{%
-    % Be sure we're not beyond the end of the alphabet.
-    \ifnum\itemno=0
-      \errmessage{No more uppercase letters in @enumerate; get a bigger
-                  alphabet}
-    \fi
-    \char\uccode\itemno
-  }%
-}
-
-% Call itemizey, adding a period to the first argument and supplying the
-% common last two arguments.  Also subtract one from the initial value in
-% \itemno, since @item increments \itemno.
-%
-\def\startenumeration#1{%
-  \advance\itemno by -1
-  \itemizey{#1.}\Eenumerate\flushcr
-}
-
-% @alphaenumerate and @capsenumerate are abbreviations for giving an arg
-% to @enumerate.
-%
-\def\alphaenumerate{\enumerate{a}}
-\def\capsenumerate{\enumerate{A}}
-\def\Ealphaenumerate{\Eenumerate}
-\def\Ecapsenumerate{\Eenumerate}
-
-% Definition of @item while inside @itemize.
-
-\def\itemizeitem{%
-\advance\itemno by 1
-{\let\par=\endgraf \smallbreak}%
-\ifhmode \errmessage{In hmode at itemizeitem}\fi
-{\parskip=0in \hskip 0pt
-\hbox to 0pt{\hss \itemcontents\hskip \itemmargin}%
-\vadjust{\penalty 1200}}%
-\flushcr}
-
-% @multitable macros
-% Amy Hendrickson, 8/18/94, 3/6/96
-%
-% @multitable ... @end multitable will make as many columns as desired.
-% Contents of each column will wrap at width given in preamble.  Width
-% can be specified either with sample text given in a template line,
-% or in percent of \hsize, the current width of text on page.
-
-% Table can continue over pages but will only break between lines.
-
-% To make preamble:
-%
-% Either define widths of columns in terms of percent of \hsize:
-%   @multitable @columnfractions .25 .3 .45
-%   @item ...
-%
-%   Numbers following @columnfractions are the percent of the total
-%   current hsize to be used for each column. You may use as many
-%   columns as desired.
-
-
-% Or use a template:
-%   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
-%   @item ...
-%   using the widest term desired in each column.
-%
-% For those who want to use more than one line's worth of words in
-% the preamble, break the line within one argument and it
-% will parse correctly, i.e.,
-%
-%     @multitable {Column 1 template} {Column 2 template} {Column 3
-%      template}
-% Not:
-%     @multitable {Column 1 template} {Column 2 template}
-%      {Column 3 template}
-
-% Each new table line starts with @item, each subsequent new column
-% starts with @tab. Empty columns may be produced by supplying @tab's
-% with nothing between them for as many times as empty columns are needed,
-% ie, @tab@tab@tab will produce two empty columns.
-
-% @item, @tab, @multitable or @end multitable do not need to be on their
-% own lines, but it will not hurt if they are.
-
-% Sample multitable:
-
-%   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
-%   @item first col stuff @tab second col stuff @tab third col
-%   @item
-%   first col stuff
-%   @tab
-%   second col stuff
-%   @tab
-%   third col
-%   @item first col stuff @tab second col stuff
-%   @tab Many paragraphs of text may be used in any column.
-%
-%         They will wrap at the width determined by the template.
-%   @item@tab@tab This will be in third column.
-%   @end multitable
-
-% Default dimensions may be reset by user.
-% @multitableparskip is vertical space between paragraphs in table.
-% @multitableparindent is paragraph indent in table.
-% @multitablecolmargin is horizontal space to be left between columns.
-% @multitablelinespace is space to leave between table items, baseline
-%                                                            to baseline.
-%   0pt means it depends on current normal line spacing.
-%
-\newskip\multitableparskip
-\newskip\multitableparindent
-\newdimen\multitablecolspace
-\newskip\multitablelinespace
-\multitableparskip=0pt
-\multitableparindent=6pt
-\multitablecolspace=12pt
-\multitablelinespace=0pt
-
-% Macros used to set up halign preamble:
-%
-\let\endsetuptable\relax
-\def\xendsetuptable{\endsetuptable}
-\let\columnfractions\relax
-\def\xcolumnfractions{\columnfractions}
-\newif\ifsetpercent
-
-% #1 is the part of the @columnfraction before the decimal point, which
-% is presumably either 0 or the empty string (but we don't check, we
-% just throw it away).  #2 is the decimal part, which we use as the
-% percent of \hsize for this column.
-\def\pickupwholefraction#1.#2 {%
-  \global\advance\colcount by 1
-  \expandafter\xdef\csname col\the\colcount\endcsname{.#2\hsize}%
-  \setuptable
-}
-
-\newcount\colcount
-\def\setuptable#1{%
-  \def\firstarg{#1}%
-  \ifx\firstarg\xendsetuptable
-    \let\go = \relax
-  \else
-    \ifx\firstarg\xcolumnfractions
-      \global\setpercenttrue
-    \else
-      \ifsetpercent
-         \let\go\pickupwholefraction
-      \else
-         \global\advance\colcount by 1
-         \setbox0=\hbox{#1\unskip }% Add a normal word space as a separator;
-                            % typically that is always in the input, anyway.
-         \expandafter\xdef\csname col\the\colcount\endcsname{\the\wd0}%
-      \fi
-    \fi
-    \ifx\go\pickupwholefraction
-      % Put the argument back for the \pickupwholefraction call, so
-      % we'll always have a period there to be parsed.
-      \def\go{\pickupwholefraction#1}%
-    \else
-      \let\go = \setuptable
-    \fi%
-  \fi
-  \go
-}
-
-% This used to have \hskip1sp.  But then the space in a template line is
-% not enough.  That is bad.  So let's go back to just & until we
-% encounter the problem it was intended to solve again.
-% --karl, nathan@acm.org, 20apr99.
-\def\tab{&}
-
-% @multitable ... @end multitable definitions:
-%
-\def\multitable{\parsearg\dotable}
-\def\dotable#1{\bgroup
-  \vskip\parskip
-  \let\item\crcr
-  \tolerance=9500
-  \hbadness=9500
-  \setmultitablespacing
-  \parskip=\multitableparskip
-  \parindent=\multitableparindent
-  \overfullrule=0pt
-  \global\colcount=0
-  \def\Emultitable{\global\setpercentfalse\cr\egroup\egroup}%
-  %
-  % To parse everything between @multitable and @item:
-  \setuptable#1 \endsetuptable
-  %
-  % \everycr will reset column counter, \colcount, at the end of
-  % each line. Every column entry will cause \colcount to advance by one.
-  % The table preamble
-  % looks at the current \colcount to find the correct column width.
-  \everycr{\noalign{%
-  %
-  % \filbreak%% keeps underfull box messages off when table breaks over pages.
-  % Maybe so, but it also creates really weird page breaks when the table
-  % breaks over pages. Wouldn't \vfil be better?  Wait until the problem
-  % manifests itself, so it can be fixed for real --karl.
-    \global\colcount=0\relax}}%
-  %
-  % This preamble sets up a generic column definition, which will
-  % be used as many times as user calls for columns.
-  % \vtop will set a single line and will also let text wrap and
-  % continue for many paragraphs if desired.
-  \halign\bgroup&\global\advance\colcount by 1\relax
-    \multistrut\vtop{\hsize=\expandafter\csname col\the\colcount\endcsname
-  %
-  % In order to keep entries from bumping into each other
-  % we will add a \leftskip of \multitablecolspace to all columns after
-  % the first one.
-  %
-  % If a template has been used, we will add \multitablecolspace
-  % to the width of each template entry.
-  %
-  % If the user has set preamble in terms of percent of \hsize we will
-  % use that dimension as the width of the column, and the \leftskip
-  % will keep entries from bumping into each other.  Table will start at
-  % left margin and final column will justify at right margin.
-  %
-  % Make sure we don't inherit \rightskip from the outer environment.
-  \rightskip=0pt
-  \ifnum\colcount=1
-    % The first column will be indented with the surrounding text.
-    \advance\hsize by\leftskip
-  \else
-    \ifsetpercent \else
-      % If user has not set preamble in terms of percent of \hsize
-      % we will advance \hsize by \multitablecolspace.
-      \advance\hsize by \multitablecolspace
-    \fi
-   % In either case we will make \leftskip=\multitablecolspace:
-  \leftskip=\multitablecolspace
-  \fi
-  % Ignoring space at the beginning and end avoids an occasional spurious
-  % blank line, when TeX decides to break the line at the space before the
-  % box from the multistrut, so the strut ends up on a line by itself.
-  % For example:
-  % @multitable @columnfractions .11 .89
-  % @item @code{#}
-  % @tab Legal holiday which is valid in major parts of the whole country.
-  % Is automatically provided with highlighting sequences respectively marking
-  % characters.
-  \noindent\ignorespaces##\unskip\multistrut}\cr
-}
-
-\def\setmultitablespacing{% test to see if user has set \multitablelinespace.
-% If so, do nothing. If not, give it an appropriate dimension based on
-% current baselineskip.
-\ifdim\multitablelinespace=0pt
-\setbox0=\vbox{X}\global\multitablelinespace=\the\baselineskip
-\global\advance\multitablelinespace by-\ht0
-%% strut to put in table in case some entry doesn't have descenders,
-%% to keep lines equally spaced
-\let\multistrut = \strut
-\else
-%% FIXME: what is \box0 supposed to be?
-\gdef\multistrut{\vrule height\multitablelinespace depth\dp0
-width0pt\relax} \fi
-%% Test to see if parskip is larger than space between lines of
-%% table. If not, do nothing.
-%%        If so, set to same dimension as multitablelinespace.
-\ifdim\multitableparskip>\multitablelinespace
-\global\multitableparskip=\multitablelinespace
-\global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
-                                      %% than skip between lines in the table.
-\fi%
-\ifdim\multitableparskip=0pt
-\global\multitableparskip=\multitablelinespace
-\global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
-                                      %% than skip between lines in the table.
-\fi}
-
-
-\message{conditionals,}
-% Prevent errors for section commands.
-% Used in @ignore and in failing conditionals.
-\def\ignoresections{%
-  \let\chapter=\relax
-  \let\unnumbered=\relax
-  \let\top=\relax
-  \let\unnumberedsec=\relax
-  \let\unnumberedsection=\relax
-  \let\unnumberedsubsec=\relax
-  \let\unnumberedsubsection=\relax
-  \let\unnumberedsubsubsec=\relax
-  \let\unnumberedsubsubsection=\relax
-  \let\section=\relax
-  \let\subsec=\relax
-  \let\subsubsec=\relax
-  \let\subsection=\relax
-  \let\subsubsection=\relax
-  \let\appendix=\relax
-  \let\appendixsec=\relax
-  \let\appendixsection=\relax
-  \let\appendixsubsec=\relax
-  \let\appendixsubsection=\relax
-  \let\appendixsubsubsec=\relax
-  \let\appendixsubsubsection=\relax
-  \let\contents=\relax
-  \let\smallbook=\relax
-  \let\titlepage=\relax
-}
-
-% Used in nested conditionals, where we have to parse the Texinfo source
-% and so want to turn off most commands, in case they are used
-% incorrectly.
-%
-\def\ignoremorecommands{%
-  \let\defcodeindex = \relax
-  \let\defcv = \relax
-  \let\deffn = \relax
-  \let\deffnx = \relax
-  \let\defindex = \relax
-  \let\defivar = \relax
-  \let\defmac = \relax
-  \let\defmethod = \relax
-  \let\defop = \relax
-  \let\defopt = \relax
-  \let\defspec = \relax
-  \let\deftp = \relax
-  \let\deftypefn = \relax
-  \let\deftypefun = \relax
-  \let\deftypeivar = \relax
-  \let\deftypeop = \relax
-  \let\deftypevar = \relax
-  \let\deftypevr = \relax
-  \let\defun = \relax
-  \let\defvar = \relax
-  \let\defvr = \relax
-  \let\ref = \relax
-  \let\xref = \relax
-  \let\printindex = \relax
-  \let\pxref = \relax
-  \let\settitle = \relax
-  \let\setchapternewpage = \relax
-  \let\setchapterstyle = \relax
-  \let\everyheading = \relax
-  \let\evenheading = \relax
-  \let\oddheading = \relax
-  \let\everyfooting = \relax
-  \let\evenfooting = \relax
-  \let\oddfooting = \relax
-  \let\headings = \relax
-  \let\include = \relax
-  \let\lowersections = \relax
-  \let\down = \relax
-  \let\raisesections = \relax
-  \let\up = \relax
-  \let\set = \relax
-  \let\clear = \relax
-  \let\item = \relax
-}
-
-% Ignore @ignore ... @end ignore.
-%
-\def\ignore{\doignore{ignore}}
-
-% Ignore @ifinfo, @ifhtml, @ifnottex, @html, @menu, and @direntry text.
-%
-\def\ifinfo{\doignore{ifinfo}}
-\def\ifhtml{\doignore{ifhtml}}
-\def\ifnottex{\doignore{ifnottex}}
-\def\html{\doignore{html}}
-\def\menu{\doignore{menu}}
-\def\direntry{\doignore{direntry}}
-
-% @dircategory CATEGORY  -- specify a category of the dir file
-% which this file should belong to.  Ignore this in TeX.
-\let\dircategory = \comment
-
-% Ignore text until a line `@end #1'.
-%
-\def\doignore#1{\begingroup
-  % Don't complain about control sequences we have declared \outer.
-  \ignoresections
-  %
-  % Define a command to swallow text until we reach `@end #1'.
-  % This @ is a catcode 12 token (that is the normal catcode of @ in
-  % this texinfo.tex file).  We change the catcode of @ below to match.
-  \long\def\doignoretext##1@end #1{\enddoignore}%
-  %
-  % Make sure that spaces turn into tokens that match what \doignoretext wants.
-  \catcode32 = 10
-  %
-  % Ignore braces, too, so mismatched braces don't cause trouble.
-  \catcode`\{ = 9
-  \catcode`\} = 9
-  %
-  % We must not have @c interpreted as a control sequence.
-  \catcode`\@ = 12
-  %
-  % Make the letter c a comment character so that the rest of the line
-  % will be ignored. This way, the document can have (for example)
-  %   @c @end ifinfo
-  % and the @end ifinfo will be properly ignored.
-  % (We've just changed @ to catcode 12.)
-  \catcode`\c = 14
-  %
-  % And now expand that command.
-  \doignoretext
-}
-
-% What we do to finish off ignored text.
-%
-\def\enddoignore{\endgroup\ignorespaces}%
-
-\newif\ifwarnedobs\warnedobsfalse
-\def\obstexwarn{%
-  \ifwarnedobs\relax\else
-  % We need to warn folks that they may have trouble with TeX 3.0.
-  % This uses \immediate\write16 rather than \message to get newlines.
-    \immediate\write16{}
-    \immediate\write16{WARNING: for users of Unix TeX 3.0!}
-    \immediate\write16{This manual trips a bug in TeX version 3.0 (tex hangs).}
-    \immediate\write16{If you are running another version of TeX, relax.}
-    \immediate\write16{If you are running Unix TeX 3.0, kill this TeX process.}
-    \immediate\write16{  Then upgrade your TeX installation if you can.}
-    \immediate\write16{  (See ftp://ftp.gnu.org/pub/gnu/TeX.README.)}
-    \immediate\write16{If you are stuck with version 3.0, run the}
-    \immediate\write16{  script ``tex3patch'' from the Texinfo distribution}
-    \immediate\write16{  to use a workaround.}
-    \immediate\write16{}
-    \global\warnedobstrue
-    \fi
-}
-
-% **In TeX 3.0, setting text in \nullfont hangs tex.  For a
-% workaround (which requires the file ``dummy.tfm'' to be installed),
-% uncomment the following line:
-%%%%%\font\nullfont=dummy\let\obstexwarn=\relax
-
-% Ignore text, except that we keep track of conditional commands for
-% purposes of nesting, up to an `@end #1' command.
-%
-\def\nestedignore#1{%
-  \obstexwarn
-  % We must actually expand the ignored text to look for the @end
-  % command, so that nested ignore constructs work.  Thus, we put the
-  % text into a \vbox and then do nothing with the result.  To minimize
-  % the change of memory overflow, we follow the approach outlined on
-  % page 401 of the TeXbook: make the current font be a dummy font.
-  %
-  \setbox0 = \vbox\bgroup
-    % Don't complain about control sequences we have declared \outer.
-    \ignoresections
-    %
-    % Define `@end #1' to end the box, which will in turn undefine the
-    % @end command again.
-    \expandafter\def\csname E#1\endcsname{\egroup\ignorespaces}%
-    %
-    % We are going to be parsing Texinfo commands.  Most cause no
-    % trouble when they are used incorrectly, but some commands do
-    % complicated argument parsing or otherwise get confused, so we
-    % undefine them.
-    %
-    % We can't do anything about stray @-signs, unfortunately;
-    % they'll produce `undefined control sequence' errors.
-    \ignoremorecommands
-    %
-    % Set the current font to be \nullfont, a TeX primitive, and define
-    % all the font commands to also use \nullfont.  We don't use
-    % dummy.tfm, as suggested in the TeXbook, because not all sites
-    % might have that installed.  Therefore, math mode will still
-    % produce output, but that should be an extremely small amount of
-    % stuff compared to the main input.
-    %
-    \nullfont
-    \let\tenrm=\nullfont \let\tenit=\nullfont \let\tensl=\nullfont
-    \let\tenbf=\nullfont \let\tentt=\nullfont \let\smallcaps=\nullfont
-    \let\tensf=\nullfont
-    % Similarly for index fonts (mostly for their use in smallexample).
-    \let\smallrm=\nullfont \let\smallit=\nullfont \let\smallsl=\nullfont
-    \let\smallbf=\nullfont \let\smalltt=\nullfont \let\smallsc=\nullfont
-    \let\smallsf=\nullfont
-    %
-    % Don't complain when characters are missing from the fonts.
-    \tracinglostchars = 0
-    %
-    % Don't bother to do space factor calculations.
-    \frenchspacing
-    %
-    % Don't report underfull hboxes.
-    \hbadness = 10000
-    %
-    % Do minimal line-breaking.
-    \pretolerance = 10000
-    %
-    % Do not execute instructions in @tex
-    \def\tex{\doignore{tex}}%
-    % Do not execute macro definitions.
-    % `c' is a comment character, so the word `macro' will get cut off.
-    \def\macro{\doignore{ma}}%
-}
-
-% @set VAR sets the variable VAR to an empty value.
-% @set VAR REST-OF-LINE sets VAR to the value REST-OF-LINE.
-%
-% Since we want to separate VAR from REST-OF-LINE (which might be
-% empty), we can't just use \parsearg; we have to insert a space of our
-% own to delimit the rest of the line, and then take it out again if we
-% didn't need it.  Make sure the catcode of space is correct to avoid
-% losing inside @example, for instance.
-%
-\def\set{\begingroup\catcode` =10
-  \catcode`\-=12 \catcode`\_=12 % Allow - and _ in VAR.
-  \parsearg\setxxx}
-\def\setxxx#1{\setyyy#1 \endsetyyy}
-\def\setyyy#1 #2\endsetyyy{%
-  \def\temp{#2}%
-  \ifx\temp\empty \global\expandafter\let\csname SET#1\endcsname = \empty
-  \else \setzzz{#1}#2\endsetzzz % Remove the trailing space \setxxx inserted.
-  \fi
-  \endgroup
-}
-% Can't use \xdef to pre-expand #2 and save some time, since \temp or
-% \next or other control sequences that we've defined might get us into
-% an infinite loop. Consider `@set foo @cite{bar}'.
-\def\setzzz#1#2 \endsetzzz{\expandafter\gdef\csname SET#1\endcsname{#2}}
-
-% @clear VAR clears (i.e., unsets) the variable VAR.
-%
-\def\clear{\parsearg\clearxxx}
-\def\clearxxx#1{\global\expandafter\let\csname SET#1\endcsname=\relax}
-
-% @value{foo} gets the text saved in variable foo.
-{
-  \catcode`\_ = \active
-  %
-  % We might end up with active _ or - characters in the argument if
-  % we're called from @code, as @code{@value{foo-bar_}}.  So \let any
-  % such active characters to their normal equivalents.
-  \gdef\value{\begingroup
-    \catcode`\-=12 \catcode`\_=12
-    \indexbreaks \let_\normalunderscore
-    \valuexxx}
-}
-\def\valuexxx#1{\expandablevalue{#1}\endgroup}
-
-% We have this subroutine so that we can handle at least some @value's
-% properly in indexes (we \let\value to this in \indexdummies).  Ones
-% whose names contain - or _ still won't work, but we can't do anything
-% about that.  The command has to be fully expandable, since the result
-% winds up in the index file.  This means that if the variable's value
-% contains other Texinfo commands, it's almost certain it will fail
-% (although perhaps we could fix that with sufficient work to do a
-% one-level expansion on the result, instead of complete).
-%
-\def\expandablevalue#1{%
-  \expandafter\ifx\csname SET#1\endcsname\relax
-    {[No value for ``#1'']}%
-  \else
-    \csname SET#1\endcsname
-  \fi
-}
-
-% @ifset VAR ... @end ifset reads the `...' iff VAR has been defined
-% with @set.
-%
-\def\ifset{\parsearg\ifsetxxx}
-\def\ifsetxxx #1{%
-  \expandafter\ifx\csname SET#1\endcsname\relax
-    \expandafter\ifsetfail
-  \else
-    \expandafter\ifsetsucceed
-  \fi
-}
-\def\ifsetsucceed{\conditionalsucceed{ifset}}
-\def\ifsetfail{\nestedignore{ifset}}
-\defineunmatchedend{ifset}
-
-% @ifclear VAR ... @end ifclear reads the `...' iff VAR has never been
-% defined with @set, or has been undefined with @clear.
-%
-\def\ifclear{\parsearg\ifclearxxx}
-\def\ifclearxxx #1{%
-  \expandafter\ifx\csname SET#1\endcsname\relax
-    \expandafter\ifclearsucceed
-  \else
-    \expandafter\ifclearfail
-  \fi
-}
-\def\ifclearsucceed{\conditionalsucceed{ifclear}}
-\def\ifclearfail{\nestedignore{ifclear}}
-\defineunmatchedend{ifclear}
-
-% @iftex, @ifnothtml, @ifnotinfo always succeed; we read the text
-% following, through the first @end iftex (etc.).  Make `@end iftex'
-% (etc.) valid only after an @iftex.
-%
-\def\iftex{\conditionalsucceed{iftex}}
-\def\ifnothtml{\conditionalsucceed{ifnothtml}}
-\def\ifnotinfo{\conditionalsucceed{ifnotinfo}}
-\defineunmatchedend{iftex}
-\defineunmatchedend{ifnothtml}
-\defineunmatchedend{ifnotinfo}
-
-% We can't just want to start a group at @iftex (for example) and end it
-% at @end iftex, since then @set commands inside the conditional have no
-% effect (they'd get reverted at the end of the group).  So we must
-% define \Eiftex to redefine itself to be its previous value.  (We can't
-% just define it to fail again with an ``unmatched end'' error, since
-% the @ifset might be nested.)
-%
-\def\conditionalsucceed#1{%
-  \edef\temp{%
-    % Remember the current value of \E#1.
-    \let\nece{prevE#1} = \nece{E#1}%
-    %
-    % At the `@end #1', redefine \E#1 to be its previous value.
-    \def\nece{E#1}{\let\nece{E#1} = \nece{prevE#1}}%
-  }%
-  \temp
-}
-
-% We need to expand lots of \csname's, but we don't want to expand the
-% control sequences after we've constructed them.
-%
-\def\nece#1{\expandafter\noexpand\csname#1\endcsname}
-
-% @defininfoenclose.
-\let\definfoenclose=\comment
-
-
-\message{indexing,}
-% Index generation facilities
-
-% Define \newwrite to be identical to plain tex's \newwrite
-% except not \outer, so it can be used within \newindex.
-{\catcode`\@=11
-\gdef\newwrite{\alloc@7\write\chardef\sixt@@n}}
-
-% \newindex {foo} defines an index named foo.
-% It automatically defines \fooindex such that
-% \fooindex ...rest of line... puts an entry in the index foo.
-% It also defines \fooindfile to be the number of the output channel for
-% the file that accumulates this index.  The file's extension is foo.
-% The name of an index should be no more than 2 characters long
-% for the sake of vms.
-%
-\def\newindex#1{%
-  \iflinks
-    \expandafter\newwrite \csname#1indfile\endcsname
-    \openout \csname#1indfile\endcsname \jobname.#1 % Open the file
-  \fi
-  \expandafter\xdef\csname#1index\endcsname{%     % Define @#1index
-    \noexpand\doindex{#1}}
-}
-
-% @defindex foo  ==  \newindex{foo}
-
-\def\defindex{\parsearg\newindex}
-
-% Define @defcodeindex, like @defindex except put all entries in @code.
-
-\def\newcodeindex#1{%
-  \iflinks
-    \expandafter\newwrite \csname#1indfile\endcsname
-    \openout \csname#1indfile\endcsname \jobname.#1
-  \fi
-  \expandafter\xdef\csname#1index\endcsname{%
-    \noexpand\docodeindex{#1}}
-}
-
-\def\defcodeindex{\parsearg\newcodeindex}
-
-% @synindex foo bar    makes index foo feed into index bar.
-% Do this instead of @defindex foo if you don't want it as a separate index.
-% The \closeout helps reduce unnecessary open files; the limit on the
-% Acorn RISC OS is a mere 16 files.
-\def\synindex#1 #2 {%
-  \expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
-  \expandafter\closeout\csname#1indfile\endcsname
-  \expandafter\let\csname#1indfile\endcsname=\synindexfoo
-  \expandafter\xdef\csname#1index\endcsname{% define \xxxindex
-    \noexpand\doindex{#2}}%
-}
-
-% @syncodeindex foo bar   similar, but put all entries made for index foo
-% inside @code.
-\def\syncodeindex#1 #2 {%
-  \expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
-  \expandafter\closeout\csname#1indfile\endcsname
-  \expandafter\let\csname#1indfile\endcsname=\synindexfoo
-  \expandafter\xdef\csname#1index\endcsname{% define \xxxindex
-    \noexpand\docodeindex{#2}}%
-}
-
-% Define \doindex, the driver for all \fooindex macros.
-% Argument #1 is generated by the calling \fooindex macro,
-%  and it is "foo", the name of the index.
-
-% \doindex just uses \parsearg; it calls \doind for the actual work.
-% This is because \doind is more useful to call from other macros.
-
-% There is also \dosubind {index}{topic}{subtopic}
-% which makes an entry in a two-level index such as the operation index.
-
-\def\doindex#1{\edef\indexname{#1}\parsearg\singleindexer}
-\def\singleindexer #1{\doind{\indexname}{#1}}
-
-% like the previous two, but they put @code around the argument.
-\def\docodeindex#1{\edef\indexname{#1}\parsearg\singlecodeindexer}
-\def\singlecodeindexer #1{\doind{\indexname}{\code{#1}}}
-
-\def\indexdummies{%
-\def\ { }%
-% Take care of the plain tex accent commands.
-\def\"{\realbackslash "}%
-\def\`{\realbackslash `}%
-\def\'{\realbackslash '}%
-\def\^{\realbackslash ^}%
-\def\~{\realbackslash ~}%
-\def\={\realbackslash =}%
-\def\b{\realbackslash b}%
-\def\c{\realbackslash c}%
-\def\d{\realbackslash d}%
-\def\u{\realbackslash u}%
-\def\v{\realbackslash v}%
-\def\H{\realbackslash H}%
-% Take care of the plain tex special European modified letters.
-\def\oe{\realbackslash oe}%
-\def\ae{\realbackslash ae}%
-\def\aa{\realbackslash aa}%
-\def\OE{\realbackslash OE}%
-\def\AE{\realbackslash AE}%
-\def\AA{\realbackslash AA}%
-\def\o{\realbackslash o}%
-\def\O{\realbackslash O}%
-\def\l{\realbackslash l}%
-\def\L{\realbackslash L}%
-\def\ss{\realbackslash ss}%
-% Take care of texinfo commands likely to appear in an index entry.
-% (Must be a way to avoid doing expansion at all, and thus not have to
-% laboriously list every single command here.)
-\def\@{@}% will be @@ when we switch to @ as escape char.
-% Need these in case \tex is in effect and \{ is a \delimiter again.
-% But can't use \lbracecmd and \rbracecmd because texindex assumes
-% braces and backslashes are used only as delimiters.  
-\let\{ = \mylbrace
-\let\} = \myrbrace
-\def\_{{\realbackslash _}}%
-\def\w{\realbackslash w }%
-\def\bf{\realbackslash bf }%
-%\def\rm{\realbackslash rm }%
-\def\sl{\realbackslash sl }%
-\def\sf{\realbackslash sf}%
-\def\tt{\realbackslash tt}%
-\def\gtr{\realbackslash gtr}%
-\def\less{\realbackslash less}%
-\def\hat{\realbackslash hat}%
-\def\TeX{\realbackslash TeX}%
-\def\dots{\realbackslash dots }%
-\def\result{\realbackslash result}%
-\def\equiv{\realbackslash equiv}%
-\def\expansion{\realbackslash expansion}%
-\def\print{\realbackslash print}%
-\def\error{\realbackslash error}%
-\def\point{\realbackslash point}%
-\def\copyright{\realbackslash copyright}%
-\def\tclose##1{\realbackslash tclose {##1}}%
-\def\code##1{\realbackslash code {##1}}%
-\def\uref##1{\realbackslash uref {##1}}%
-\def\url##1{\realbackslash url {##1}}%
-\def\env##1{\realbackslash env {##1}}%
-\def\command##1{\realbackslash command {##1}}%
-\def\option##1{\realbackslash option {##1}}%
-\def\dotless##1{\realbackslash dotless {##1}}%
-\def\samp##1{\realbackslash samp {##1}}%
-\def\,##1{\realbackslash ,{##1}}%
-\def\t##1{\realbackslash t {##1}}%
-\def\r##1{\realbackslash r {##1}}%
-\def\i##1{\realbackslash i {##1}}%
-\def\b##1{\realbackslash b {##1}}%
-\def\sc##1{\realbackslash sc {##1}}%
-\def\cite##1{\realbackslash cite {##1}}%
-\def\key##1{\realbackslash key {##1}}%
-\def\file##1{\realbackslash file {##1}}%
-\def\var##1{\realbackslash var {##1}}%
-\def\kbd##1{\realbackslash kbd {##1}}%
-\def\dfn##1{\realbackslash dfn {##1}}%
-\def\emph##1{\realbackslash emph {##1}}%
-\def\acronym##1{\realbackslash acronym {##1}}%
-%
-% Handle some cases of @value -- where the variable name does not
-% contain - or _, and the value does not contain any
-% (non-fully-expandable) commands.
-\let\value = \expandablevalue
-%
-\unsepspaces
-% Turn off macro expansion
-\turnoffmacros
-}
-
-% If an index command is used in an @example environment, any spaces
-% therein should become regular spaces in the raw index file, not the
-% expansion of \tie (\\leavevmode \penalty \@M \ ).
-{\obeyspaces
- \gdef\unsepspaces{\obeyspaces\let =\space}}
-
-% \indexnofonts no-ops all font-change commands.
-% This is used when outputting the strings to sort the index by.
-\def\indexdummyfont#1{#1}
-\def\indexdummytex{TeX}
-\def\indexdummydots{...}
-
-\def\indexnofonts{%
-% Just ignore accents.
-\let\,=\indexdummyfont
-\let\"=\indexdummyfont
-\let\`=\indexdummyfont
-\let\'=\indexdummyfont
-\let\^=\indexdummyfont
-\let\~=\indexdummyfont
-\let\==\indexdummyfont
-\let\b=\indexdummyfont
-\let\c=\indexdummyfont
-\let\d=\indexdummyfont
-\let\u=\indexdummyfont
-\let\v=\indexdummyfont
-\let\H=\indexdummyfont
-\let\dotless=\indexdummyfont
-% Take care of the plain tex special European modified letters.
-\def\oe{oe}%
-\def\ae{ae}%
-\def\aa{aa}%
-\def\OE{OE}%
-\def\AE{AE}%
-\def\AA{AA}%
-\def\o{o}%
-\def\O{O}%
-\def\l{l}%
-\def\L{L}%
-\def\ss{ss}%
-\let\w=\indexdummyfont
-\let\t=\indexdummyfont
-\let\r=\indexdummyfont
-\let\i=\indexdummyfont
-\let\b=\indexdummyfont
-\let\emph=\indexdummyfont
-\let\strong=\indexdummyfont
-\let\cite=\indexdummyfont
-\let\sc=\indexdummyfont
-%Don't no-op \tt, since it isn't a user-level command
-% and is used in the definitions of the active chars like <, >, |...
-%\let\tt=\indexdummyfont
-\let\tclose=\indexdummyfont
-\let\code=\indexdummyfont
-\let\url=\indexdummyfont
-\let\uref=\indexdummyfont
-\let\env=\indexdummyfont
-\let\acronym=\indexdummyfont
-\let\command=\indexdummyfont
-\let\option=\indexdummyfont
-\let\file=\indexdummyfont
-\let\samp=\indexdummyfont
-\let\kbd=\indexdummyfont
-\let\key=\indexdummyfont
-\let\var=\indexdummyfont
-\let\TeX=\indexdummytex
-\let\dots=\indexdummydots
-\def\@{@}%
-}
-
-% To define \realbackslash, we must make \ not be an escape.
-% We must first make another character (@) an escape
-% so we do not become unable to do a definition.
-
-{\catcode`\@=0 \catcode`\\=\other
- @gdef@realbackslash{\}}
-
-\let\indexbackslash=0  %overridden during \printindex.
-\let\SETmarginindex=\relax % put index entries in margin (undocumented)?
-
-% For \ifx comparisons.
-\def\emptymacro{\empty}
-
-% Most index entries go through here, but \dosubind is the general case.
-%
-\def\doind#1#2{\dosubind{#1}{#2}\empty}
-
-% Workhorse for all \fooindexes.
-% #1 is name of index, #2 is stuff to put there, #3 is subentry --
-% \empty if called from \doind, as we usually are.  The main exception
-% is with defuns, which call us directly.
-%
-\def\dosubind#1#2#3{%
-  % Put the index entry in the margin if desired.
-  \ifx\SETmarginindex\relax\else
-    \insert\margin{\hbox{\vrule height8pt depth3pt width0pt #2}}%
-  \fi
-  {%
-    \count255=\lastpenalty
-    {%
-      \indexdummies % Must do this here, since \bf, etc expand at this stage
-      \escapechar=`\\
-      {%
-        \let\folio = 0% We will expand all macros now EXCEPT \folio.
-        \def\rawbackslashxx{\indexbackslash}% \indexbackslash isn't defined now
-        % so it will be output as is; and it will print as backslash.
-        %
-        \def\thirdarg{#3}%
-        %
-        % If third arg is present, precede it with space in sort key.
-        \ifx\thirdarg\emptymacro
-          \let\subentry = \empty
-        \else
-          \def\subentry{ #3}%
-        \fi
-        %
-        % First process the index entry with all font commands turned
-        % off to get the string to sort by.
-        {\indexnofonts \xdef\indexsorttmp{#2\subentry}}%
-        %
-        % Now the real index entry with the fonts.
-        \toks0 = {#2}%
-        %
-        % If third (subentry) arg is present, add it to the index
-        % string.  And include a space.
-        \ifx\thirdarg\emptymacro \else
-          \toks0 = \expandafter{\the\toks0 \space #3}%
-        \fi
-        %
-        % Set up the complete index entry, with both the sort key
-        % and the original text, including any font commands.  We write
-        % three arguments to \entry to the .?? file, texindex reduces to
-        % two when writing the .??s sorted result.
-        \edef\temp{%
-          \write\csname#1indfile\endcsname{%
-            \realbackslash entry{\indexsorttmp}{\folio}{\the\toks0}}%
-        }%
-        %
-        % If a skip is the last thing on the list now, preserve it
-        % by backing up by \lastskip, doing the \write, then inserting
-        % the skip again.  Otherwise, the whatsit generated by the
-        % \write will make \lastskip zero.  The result is that sequences
-        % like this:
-        % @end defun
-        % @tindex whatever
-        % @defun ...
-        % will have extra space inserted, because the \medbreak in the
-        % start of the @defun won't see the skip inserted by the @end of
-        % the previous defun.
-        %
-        % But don't do any of this if we're not in vertical mode.  We
-        % don't want to do a \vskip and prematurely end a paragraph.
-        %
-        % Avoid page breaks due to these extra skips, too.
-        %
-        \iflinks
-          \ifvmode
-            \skip0 = \lastskip
-            \ifdim\lastskip = 0pt \else \nobreak\vskip-\lastskip \fi
-          \fi
-          %
-          \temp % do the write
-          %
-          %
-          \ifvmode \ifdim\skip0 = 0pt \else \nobreak\vskip\skip0 \fi \fi
-        \fi
-      }%
-    }%
-    \penalty\count255
-  }%
-}
-
-% The index entry written in the file actually looks like
-%  \entry {sortstring}{page}{topic}
-% or
-%  \entry {sortstring}{page}{topic}{subtopic}
-% The texindex program reads in these files and writes files
-% containing these kinds of lines:
-%  \initial {c}
-%     before the first topic whose initial is c
-%  \entry {topic}{pagelist}
-%     for a topic that is used without subtopics
-%  \primary {topic}
-%     for the beginning of a topic that is used with subtopics
-%  \secondary {subtopic}{pagelist}
-%     for each subtopic.
-
-% Define the user-accessible indexing commands
-% @findex, @vindex, @kindex, @cindex.
-
-\def\findex {\fnindex}
-\def\kindex {\kyindex}
-\def\cindex {\cpindex}
-\def\vindex {\vrindex}
-\def\tindex {\tpindex}
-\def\pindex {\pgindex}
-
-\def\cindexsub {\begingroup\obeylines\cindexsub}
-{\obeylines %
-\gdef\cindexsub "#1" #2^^M{\endgroup %
-\dosubind{cp}{#2}{#1}}}
-
-% Define the macros used in formatting output of the sorted index material.
-
-% @printindex causes a particular index (the ??s file) to get printed.
-% It does not print any chapter heading (usually an @unnumbered).
-%
-\def\printindex{\parsearg\doprintindex}
-\def\doprintindex#1{\begingroup
-  \dobreak \chapheadingskip{10000}%
-  %
-  \smallfonts \rm
-  \tolerance = 9500
-  \indexbreaks
-  %
-  % See if the index file exists and is nonempty.
-  % Change catcode of @ here so that if the index file contains
-  % \initial {@}
-  % as its first line, TeX doesn't complain about mismatched braces
-  % (because it thinks @} is a control sequence).
-  \catcode`\@ = 11
-  \openin 1 \jobname.#1s
-  \ifeof 1
-    % \enddoublecolumns gets confused if there is no text in the index,
-    % and it loses the chapter title and the aux file entries for the
-    % index.  The easiest way to prevent this problem is to make sure
-    % there is some text.
-    \putwordIndexNonexistent
-  \else
-    %
-    % If the index file exists but is empty, then \openin leaves \ifeof
-    % false.  We have to make TeX try to read something from the file, so
-    % it can discover if there is anything in it.
-    \read 1 to \temp
-    \ifeof 1
-      \putwordIndexIsEmpty
-    \else
-      % Index files are almost Texinfo source, but we use \ as the escape
-      % character.  It would be better to use @, but that's too big a change
-      % to make right now.
-      \def\indexbackslash{\rawbackslashxx}%
-      \catcode`\\ = 0
-      \escapechar = `\\
-      \begindoublecolumns
-      \input \jobname.#1s
-      \enddoublecolumns
-    \fi
-  \fi
-  \closein 1
-\endgroup}
-
-% These macros are used by the sorted index file itself.
-% Change them to control the appearance of the index.
-
-\def\initial#1{{%
-  % Some minor font changes for the special characters.
-  \let\tentt=\sectt \let\tt=\sectt \let\sf=\sectt
-  %
-  % Remove any glue we may have, we'll be inserting our own.
-  \removelastskip
-  %
-  % We like breaks before the index initials, so insert a bonus.
-  \penalty -300
-  %
-  % Typeset the initial.  Making this add up to a whole number of
-  % baselineskips increases the chance of the dots lining up from column
-  % to column.  It still won't often be perfect, because of the stretch
-  % we need before each entry, but it's better.
-  %
-  % No shrink because it confuses \balancecolumns.
-  \vskip 1.67\baselineskip plus .5\baselineskip
-  \leftline{\secbf #1}%
-  \vskip .33\baselineskip plus .1\baselineskip
-  %
-  % Do our best not to break after the initial.
-  \nobreak
-}}
-
-% This typesets a paragraph consisting of #1, dot leaders, and then #2
-% flush to the right margin.  It is used for index and table of contents
-% entries.  The paragraph is indented by \leftskip.
-%
-\def\entry#1#2{\begingroup
-  %
-  % Start a new paragraph if necessary, so our assignments below can't
-  % affect previous text.
-  \par
-  %
-  % Do not fill out the last line with white space.
-  \parfillskip = 0in
-  %
-  % No extra space above this paragraph.
-  \parskip = 0in
-  %
-  % Do not prefer a separate line ending with a hyphen to fewer lines.
-  \finalhyphendemerits = 0
-  %
-  % \hangindent is only relevant when the entry text and page number
-  % don't both fit on one line.  In that case, bob suggests starting the
-  % dots pretty far over on the line.  Unfortunately, a large
-  % indentation looks wrong when the entry text itself is broken across
-  % lines.  So we use a small indentation and put up with long leaders.
-  %
-  % \hangafter is reset to 1 (which is the value we want) at the start
-  % of each paragraph, so we need not do anything with that.
-  \hangindent = 2em
-  %
-  % When the entry text needs to be broken, just fill out the first line
-  % with blank space.
-  \rightskip = 0pt plus1fil
-  %
-  % A bit of stretch before each entry for the benefit of balancing columns.
-  \vskip 0pt plus1pt
-  %
-  % Start a ``paragraph'' for the index entry so the line breaking
-  % parameters we've set above will have an effect.
-  \noindent
-  %
-  % Insert the text of the index entry.  TeX will do line-breaking on it.
-  #1%
-  % The following is kludged to not output a line of dots in the index if
-  % there are no page numbers.  The next person who breaks this will be
-  % cursed by a Unix daemon.
-  \def\tempa{{\rm }}%
-  \def\tempb{#2}%
-  \edef\tempc{\tempa}%
-  \edef\tempd{\tempb}%
-  \ifx\tempc\tempd\ \else%
-    %
-    % If we must, put the page number on a line of its own, and fill out
-    % this line with blank space.  (The \hfil is overwhelmed with the
-    % fill leaders glue in \indexdotfill if the page number does fit.)
-    \hfil\penalty50
-    \null\nobreak\indexdotfill % Have leaders before the page number.
-    %
-    % The `\ ' here is removed by the implicit \unskip that TeX does as
-    % part of (the primitive) \par.  Without it, a spurious underfull
-    % \hbox ensues.
-    \ifpdf
-      \pdfgettoks#2.\ \the\toksA % The page number ends the paragraph.
-    \else
-      \ #2% The page number ends the paragraph.
-    \fi
-  \fi%
-  \par
-\endgroup}
-
-% Like \dotfill except takes at least 1 em.
-\def\indexdotfill{\cleaders
-  \hbox{$\mathsurround=0pt \mkern1.5mu ${\it .}$ \mkern1.5mu$}\hskip 1em plus 1fill}
-
-\def\primary #1{\line{#1\hfil}}
-
-\newskip\secondaryindent \secondaryindent=0.5cm
-
-\def\secondary #1#2{
-{\parfillskip=0in \parskip=0in
-\hangindent =1in \hangafter=1
-\noindent\hskip\secondaryindent\hbox{#1}\indexdotfill #2\par
-}}
-
-% Define two-column mode, which we use to typeset indexes.
-% Adapted from the TeXbook, page 416, which is to say,
-% the manmac.tex format used to print the TeXbook itself.
-\catcode`\@=11
-
-\newbox\partialpage
-\newdimen\doublecolumnhsize
-
-\def\begindoublecolumns{\begingroup % ended by \enddoublecolumns
-  % Grab any single-column material above us.
-  \output = {%
-    %
-    % Here is a possibility not foreseen in manmac: if we accumulate a
-    % whole lot of material, we might end up calling this \output
-    % routine twice in a row (see the doublecol-lose test, which is
-    % essentially a couple of indexes with @setchapternewpage off).  In
-    % that case we just ship out what is in \partialpage with the normal
-    % output routine.  Generally, \partialpage will be empty when this
-    % runs and this will be a no-op.  See the indexspread.tex test case.
-    \ifvoid\partialpage \else
-      \onepageout{\pagecontents\partialpage}%
-    \fi
-    %
-    \global\setbox\partialpage = \vbox{%
-      % Unvbox the main output page.
-      \unvbox\PAGE
-      \kern-\topskip \kern\baselineskip
-    }%
-  }%
-  \eject % run that output routine to set \partialpage
-  %
-  % Use the double-column output routine for subsequent pages.
-  \output = {\doublecolumnout}%
-  %
-  % Change the page size parameters.  We could do this once outside this
-  % routine, in each of @smallbook, @afourpaper, and the default 8.5x11
-  % format, but then we repeat the same computation.  Repeating a couple
-  % of assignments once per index is clearly meaningless for the
-  % execution time, so we may as well do it in one place.
-  %
-  % First we halve the line length, less a little for the gutter between
-  % the columns.  We compute the gutter based on the line length, so it
-  % changes automatically with the paper format.  The magic constant
-  % below is chosen so that the gutter has the same value (well, +-<1pt)
-  % as it did when we hard-coded it.
-  %
-  % We put the result in a separate register, \doublecolumhsize, so we
-  % can restore it in \pagesofar, after \hsize itself has (potentially)
-  % been clobbered.
-  %
-  \doublecolumnhsize = \hsize
-    \advance\doublecolumnhsize by -.04154\hsize
-    \divide\doublecolumnhsize by 2
-  \hsize = \doublecolumnhsize
-  %
-  % Double the \vsize as well.  (We don't need a separate register here,
-  % since nobody clobbers \vsize.)
-  \advance\vsize by -\ht\partialpage
-  \vsize = 2\vsize
-}
-
-% The double-column output routine for all double-column pages except
-% the last.
-%
-\def\doublecolumnout{%
-  \splittopskip=\topskip \splitmaxdepth=\maxdepth
-  % Get the available space for the double columns -- the normal
-  % (undoubled) page height minus any material left over from the
-  % previous page.
-  \dimen@ = \vsize
-  \divide\dimen@ by 2
-  %
-  % box0 will be the left-hand column, box2 the right.
-  \setbox0=\vsplit255 to\dimen@ \setbox2=\vsplit255 to\dimen@
-  \onepageout\pagesofar
-  \unvbox255
-  \penalty\outputpenalty
-}
-\def\pagesofar{%
-  % Re-output the contents of the output page -- any previous material,
-  % followed by the two boxes we just split, in box0 and box2.
-  \unvbox\partialpage
-  %
-  \hsize = \doublecolumnhsize
-  \wd0=\hsize \wd2=\hsize
-  \hbox to\pagewidth{\box0\hfil\box2}%
-}
-\def\enddoublecolumns{%
-  \output = {%
-    % Split the last of the double-column material.  Leave it on the
-    % current page, no automatic page break.
-    \balancecolumns
-    %
-    % If we end up splitting too much material for the current page,
-    % though, there will be another page break right after this \output
-    % invocation ends.  Having called \balancecolumns once, we do not
-    % want to call it again.  Therefore, reset \output to its normal
-    % definition right away.  (We hope \balancecolumns will never be
-    % called on to balance too much material, but if it is, this makes
-    % the output somewhat more palatable.)
-    \global\output = {\onepageout{\pagecontents\PAGE}}%
-  }%
-  \eject
-  \endgroup % started in \begindoublecolumns
-  %
-  % \pagegoal was set to the doubled \vsize above, since we restarted
-  % the current page.  We're now back to normal single-column
-  % typesetting, so reset \pagegoal to the normal \vsize (after the
-  % \endgroup where \vsize got restored).
-  \pagegoal = \vsize
-}
-\def\balancecolumns{%
-  % Called at the end of the double column material.
-  \setbox0 = \vbox{\unvbox255}% like \box255 but more efficient, see p.120.
-  \dimen@ = \ht0
-  \advance\dimen@ by \topskip
-  \advance\dimen@ by-\baselineskip
-  \divide\dimen@ by 2 % target to split to
-  %debug\message{final 2-column material height=\the\ht0, target=\the\dimen@.}%
-  \splittopskip = \topskip
-  % Loop until we get a decent breakpoint.
-  {%
-    \vbadness = 10000
-    \loop
-      \global\setbox3 = \copy0
-      \global\setbox1 = \vsplit3 to \dimen@
-    \ifdim\ht3>\dimen@
-      \global\advance\dimen@ by 1pt
-    \repeat
-  }%
-  %debug\message{split to \the\dimen@, column heights: \the\ht1, \the\ht3.}%
-  \setbox0=\vbox to\dimen@{\unvbox1}%
-  \setbox2=\vbox to\dimen@{\unvbox3}%
-  %
-  \pagesofar
-}
-\catcode`\@ = \other
-
-
-\message{sectioning,}
-% Chapters, sections, etc.
-
-\newcount\chapno
-\newcount\secno        \secno=0
-\newcount\subsecno     \subsecno=0
-\newcount\subsubsecno  \subsubsecno=0
-
-% This counter is funny since it counts through charcodes of letters A, B, ...
-\newcount\appendixno  \appendixno = `\@
-% \def\appendixletter{\char\the\appendixno}
-% We do the following for the sake of pdftex, which needs the actual
-% letter in the expansion, not just typeset.
-\def\appendixletter{%
-  \ifnum\appendixno=`A A%
-  \else\ifnum\appendixno=`B B%
-  \else\ifnum\appendixno=`C C%
-  \else\ifnum\appendixno=`D D%
-  \else\ifnum\appendixno=`E E%
-  \else\ifnum\appendixno=`F F%
-  \else\ifnum\appendixno=`G G%
-  \else\ifnum\appendixno=`H H%
-  \else\ifnum\appendixno=`I I%
-  \else\ifnum\appendixno=`J J%
-  \else\ifnum\appendixno=`K K%
-  \else\ifnum\appendixno=`L L%
-  \else\ifnum\appendixno=`M M%
-  \else\ifnum\appendixno=`N N%
-  \else\ifnum\appendixno=`O O%
-  \else\ifnum\appendixno=`P P%
-  \else\ifnum\appendixno=`Q Q%
-  \else\ifnum\appendixno=`R R%
-  \else\ifnum\appendixno=`S S%
-  \else\ifnum\appendixno=`T T%
-  \else\ifnum\appendixno=`U U%
-  \else\ifnum\appendixno=`V V%
-  \else\ifnum\appendixno=`W W%
-  \else\ifnum\appendixno=`X X%
-  \else\ifnum\appendixno=`Y Y%
-  \else\ifnum\appendixno=`Z Z%
-  % The \the is necessary, despite appearances, because \appendixletter is
-  % expanded while writing the .toc file.  \char\appendixno is not
-  % expandable, thus it is written literally, thus all appendixes come out
-  % with the same letter (or @) in the toc without it.
-  \else\char\the\appendixno
-  \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
-  \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi}
-
-% Each @chapter defines this as the name of the chapter.
-% page headings and footings can use it.  @section does likewise.
-\def\thischapter{}
-\def\thissection{}
-
-\newcount\absseclevel % used to calculate proper heading level
-\newcount\secbase\secbase=0 % @raise/lowersections modify this count
-
-% @raisesections: treat @section as chapter, @subsection as section, etc.
-\def\raisesections{\global\advance\secbase by -1}
-\let\up=\raisesections % original BFox name
-
-% @lowersections: treat @chapter as section, @section as subsection, etc.
-\def\lowersections{\global\advance\secbase by 1}
-\let\down=\lowersections % original BFox name
-
-% Choose a numbered-heading macro
-% #1 is heading level if unmodified by @raisesections or @lowersections
-% #2 is text for heading
-\def\numhead#1#2{\absseclevel=\secbase\advance\absseclevel by #1
-\ifcase\absseclevel
-  \chapterzzz{#2}
-\or
-  \seczzz{#2}
-\or
-  \numberedsubseczzz{#2}
-\or
-  \numberedsubsubseczzz{#2}
-\else
-  \ifnum \absseclevel<0
-    \chapterzzz{#2}
-  \else
-    \numberedsubsubseczzz{#2}
-  \fi
-\fi
-}
-
-% like \numhead, but chooses appendix heading levels
-\def\apphead#1#2{\absseclevel=\secbase\advance\absseclevel by #1
-\ifcase\absseclevel
-  \appendixzzz{#2}
-\or
-  \appendixsectionzzz{#2}
-\or
-  \appendixsubseczzz{#2}
-\or
-  \appendixsubsubseczzz{#2}
-\else
-  \ifnum \absseclevel<0
-    \appendixzzz{#2}
-  \else
-    \appendixsubsubseczzz{#2}
-  \fi
-\fi
-}
-
-% like \numhead, but chooses numberless heading levels
-\def\unnmhead#1#2{\absseclevel=\secbase\advance\absseclevel by #1
-\ifcase\absseclevel
-  \unnumberedzzz{#2}
-\or
-  \unnumberedseczzz{#2}
-\or
-  \unnumberedsubseczzz{#2}
-\or
-  \unnumberedsubsubseczzz{#2}
-\else
-  \ifnum \absseclevel<0
-    \unnumberedzzz{#2}
-  \else
-    \unnumberedsubsubseczzz{#2}
-  \fi
-\fi
-}
-
-% @chapter, @appendix, @unnumbered.
-\def\thischaptername{No Chapter Title}
-\outer\def\chapter{\parsearg\chapteryyy}
-\def\chapteryyy #1{\numhead0{#1}} % normally numhead0 calls chapterzzz
-\def\chapterzzz #1{%
-\secno=0 \subsecno=0 \subsubsecno=0
-\global\advance \chapno by 1 \message{\putwordChapter\space \the\chapno}%
-\chapmacro {#1}{\the\chapno}%
-\gdef\thissection{#1}%
-\gdef\thischaptername{#1}%
-% We don't substitute the actual chapter name into \thischapter
-% because we don't want its macros evaluated now.
-\xdef\thischapter{\putwordChapter{} \the\chapno: \noexpand\thischaptername}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash chapentry{\the\toks0}%
-                                  {\the\chapno}}}%
-\temp
-\donoderef
-\global\let\section = \numberedsec
-\global\let\subsection = \numberedsubsec
-\global\let\subsubsection = \numberedsubsubsec
-}
-
-\outer\def\appendix{\parsearg\appendixyyy}
-\def\appendixyyy #1{\apphead0{#1}} % normally apphead0 calls appendixzzz
-\def\appendixzzz #1{%
-\secno=0 \subsecno=0 \subsubsecno=0
-\global\advance \appendixno by 1
-\message{\putwordAppendix\space \appendixletter}%
-\chapmacro {#1}{\putwordAppendix{} \appendixletter}%
-\gdef\thissection{#1}%
-\gdef\thischaptername{#1}%
-\xdef\thischapter{\putwordAppendix{} \appendixletter: \noexpand\thischaptername}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash chapentry{\the\toks0}%
-                       {\putwordAppendix{} \appendixletter}}}%
-\temp
-\appendixnoderef
-\global\let\section = \appendixsec
-\global\let\subsection = \appendixsubsec
-\global\let\subsubsection = \appendixsubsubsec
-}
-
-% @centerchap is like @unnumbered, but the heading is centered.
-\outer\def\centerchap{\parsearg\centerchapyyy}
-\def\centerchapyyy #1{{\let\unnumbchapmacro=\centerchapmacro \unnumberedyyy{#1}}}
-
-% @top is like @unnumbered.
-\outer\def\top{\parsearg\unnumberedyyy}
-
-\outer\def\unnumbered{\parsearg\unnumberedyyy}
-\def\unnumberedyyy #1{\unnmhead0{#1}} % normally unnmhead0 calls unnumberedzzz
-\def\unnumberedzzz #1{%
-\secno=0 \subsecno=0 \subsubsecno=0
-%
-% This used to be simply \message{#1}, but TeX fully expands the
-% argument to \message.  Therefore, if #1 contained @-commands, TeX
-% expanded them.  For example, in `@unnumbered The @cite{Book}', TeX
-% expanded @cite (which turns out to cause errors because \cite is meant
-% to be executed, not expanded).
-%
-% Anyway, we don't want the fully-expanded definition of @cite to appear
-% as a result of the \message, we just want `@cite' itself.  We use
-% \the<toks register> to achieve this: TeX expands \the<toks> only once,
-% simply yielding the contents of <toks register>.  (We also do this for
-% the toc entries.)
-\toks0 = {#1}\message{(\the\toks0)}%
-%
-\unnumbchapmacro {#1}%
-\gdef\thischapter{#1}\gdef\thissection{#1}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash unnumbchapentry{\the\toks0}}}%
-\temp
-\unnumbnoderef
-\global\let\section = \unnumberedsec
-\global\let\subsection = \unnumberedsubsec
-\global\let\subsubsection = \unnumberedsubsubsec
-}
-
-% Sections.
-\outer\def\numberedsec{\parsearg\secyyy}
-\def\secyyy #1{\numhead1{#1}} % normally calls seczzz
-\def\seczzz #1{%
-\subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
-\gdef\thissection{#1}\secheading {#1}{\the\chapno}{\the\secno}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash secentry{\the\toks0}%
-                                  {\the\chapno}{\the\secno}}}%
-\temp
-\donoderef
-\nobreak
-}
-
-\outer\def\appendixsection{\parsearg\appendixsecyyy}
-\outer\def\appendixsec{\parsearg\appendixsecyyy}
-\def\appendixsecyyy #1{\apphead1{#1}} % normally calls appendixsectionzzz
-\def\appendixsectionzzz #1{%
-\subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
-\gdef\thissection{#1}\secheading {#1}{\appendixletter}{\the\secno}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash secentry{\the\toks0}%
-                                  {\appendixletter}{\the\secno}}}%
-\temp
-\appendixnoderef
-\nobreak
-}
-
-\outer\def\unnumberedsec{\parsearg\unnumberedsecyyy}
-\def\unnumberedsecyyy #1{\unnmhead1{#1}} % normally calls unnumberedseczzz
-\def\unnumberedseczzz #1{%
-\plainsecheading {#1}\gdef\thissection{#1}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash unnumbsecentry{\the\toks0}}}%
-\temp
-\unnumbnoderef
-\nobreak
-}
-
-% Subsections.
-\outer\def\numberedsubsec{\parsearg\numberedsubsecyyy}
-\def\numberedsubsecyyy #1{\numhead2{#1}} % normally calls numberedsubseczzz
-\def\numberedsubseczzz #1{%
-\gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
-\subsecheading {#1}{\the\chapno}{\the\secno}{\the\subsecno}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash subsecentry{\the\toks0}%
-                                    {\the\chapno}{\the\secno}{\the\subsecno}}}%
-\temp
-\donoderef
-\nobreak
-}
-
-\outer\def\appendixsubsec{\parsearg\appendixsubsecyyy}
-\def\appendixsubsecyyy #1{\apphead2{#1}} % normally calls appendixsubseczzz
-\def\appendixsubseczzz #1{%
-\gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
-\subsecheading {#1}{\appendixletter}{\the\secno}{\the\subsecno}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash subsecentry{\the\toks0}%
-                                {\appendixletter}{\the\secno}{\the\subsecno}}}%
-\temp
-\appendixnoderef
-\nobreak
-}
-
-\outer\def\unnumberedsubsec{\parsearg\unnumberedsubsecyyy}
-\def\unnumberedsubsecyyy #1{\unnmhead2{#1}} %normally calls unnumberedsubseczzz
-\def\unnumberedsubseczzz #1{%
-\plainsubsecheading {#1}\gdef\thissection{#1}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash unnumbsubsecentry%
-                                    {\the\toks0}}}%
-\temp
-\unnumbnoderef
-\nobreak
-}
-
-% Subsubsections.
-\outer\def\numberedsubsubsec{\parsearg\numberedsubsubsecyyy}
-\def\numberedsubsubsecyyy #1{\numhead3{#1}} % normally numberedsubsubseczzz
-\def\numberedsubsubseczzz #1{%
-\gdef\thissection{#1}\global\advance \subsubsecno by 1 %
-\subsubsecheading {#1}
-  {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash subsubsecentry{\the\toks0}%
-  {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}}}%
-\temp
-\donoderef
-\nobreak
-}
-
-\outer\def\appendixsubsubsec{\parsearg\appendixsubsubsecyyy}
-\def\appendixsubsubsecyyy #1{\apphead3{#1}} % normally appendixsubsubseczzz
-\def\appendixsubsubseczzz #1{%
-\gdef\thissection{#1}\global\advance \subsubsecno by 1 %
-\subsubsecheading {#1}
-  {\appendixletter}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash subsubsecentry{\the\toks0}%
-  {\appendixletter}{\the\secno}{\the\subsecno}{\the\subsubsecno}}}%
-\temp
-\appendixnoderef
-\nobreak
-}
-
-\outer\def\unnumberedsubsubsec{\parsearg\unnumberedsubsubsecyyy}
-\def\unnumberedsubsubsecyyy #1{\unnmhead3{#1}} %normally unnumberedsubsubseczzz
-\def\unnumberedsubsubseczzz #1{%
-\plainsubsubsecheading {#1}\gdef\thissection{#1}%
-\toks0 = {#1}%
-\edef\temp{\noexpand\writetocentry{\realbackslash unnumbsubsubsecentry%
-                                    {\the\toks0}}}%
-\temp
-\unnumbnoderef
-\nobreak
-}
-
-% These are variants which are not "outer", so they can appear in @ifinfo.
-% Actually, they should now be obsolete; ordinary section commands should work.
-\def\infotop{\parsearg\unnumberedzzz}
-\def\infounnumbered{\parsearg\unnumberedzzz}
-\def\infounnumberedsec{\parsearg\unnumberedseczzz}
-\def\infounnumberedsubsec{\parsearg\unnumberedsubseczzz}
-\def\infounnumberedsubsubsec{\parsearg\unnumberedsubsubseczzz}
-
-\def\infoappendix{\parsearg\appendixzzz}
-\def\infoappendixsec{\parsearg\appendixseczzz}
-\def\infoappendixsubsec{\parsearg\appendixsubseczzz}
-\def\infoappendixsubsubsec{\parsearg\appendixsubsubseczzz}
-
-\def\infochapter{\parsearg\chapterzzz}
-\def\infosection{\parsearg\sectionzzz}
-\def\infosubsection{\parsearg\subsectionzzz}
-\def\infosubsubsection{\parsearg\subsubsectionzzz}
-
-% These macros control what the section commands do, according
-% to what kind of chapter we are in (ordinary, appendix, or unnumbered).
-% Define them by default for a numbered chapter.
-\global\let\section = \numberedsec
-\global\let\subsection = \numberedsubsec
-\global\let\subsubsection = \numberedsubsubsec
-
-% Define @majorheading, @heading and @subheading
-
-% NOTE on use of \vbox for chapter headings, section headings, and such:
-%       1) We use \vbox rather than the earlier \line to permit
-%          overlong headings to fold.
-%       2) \hyphenpenalty is set to 10000 because hyphenation in a
-%          heading is obnoxious; this forbids it.
-%       3) Likewise, headings look best if no \parindent is used, and
-%          if justification is not attempted.  Hence \raggedright.
-
-
-\def\majorheading{\parsearg\majorheadingzzz}
-\def\majorheadingzzz #1{%
-{\advance\chapheadingskip by 10pt \chapbreak }%
-{\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
-                  \parindent=0pt\raggedright
-                  \rm #1\hfill}}\bigskip \par\penalty 200}
-
-\def\chapheading{\parsearg\chapheadingzzz}
-\def\chapheadingzzz #1{\chapbreak %
-{\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
-                  \parindent=0pt\raggedright
-                  \rm #1\hfill}}\bigskip \par\penalty 200}
-
-% @heading, @subheading, @subsubheading.
-\def\heading{\parsearg\plainsecheading}
-\def\subheading{\parsearg\plainsubsecheading}
-\def\subsubheading{\parsearg\plainsubsubsecheading}
-
-% These macros generate a chapter, section, etc. heading only
-% (including whitespace, linebreaking, etc. around it),
-% given all the information in convenient, parsed form.
-
-%%% Args are the skip and penalty (usually negative)
-\def\dobreak#1#2{\par\ifdim\lastskip<#1\removelastskip\penalty#2\vskip#1\fi}
-
-\def\setchapterstyle #1 {\csname CHAPF#1\endcsname}
-
-%%% Define plain chapter starts, and page on/off switching for it
-% Parameter controlling skip before chapter headings (if needed)
-
-\newskip\chapheadingskip
-
-\def\chapbreak{\dobreak \chapheadingskip {-4000}}
-\def\chappager{\par\vfill\supereject}
-\def\chapoddpage{\chappager \ifodd\pageno \else \hbox to 0pt{} \chappager\fi}
-
-\def\setchapternewpage #1 {\csname CHAPPAG#1\endcsname}
-
-\def\CHAPPAGoff{%
-\global\let\contentsalignmacro = \chappager
-\global\let\pchapsepmacro=\chapbreak
-\global\let\pagealignmacro=\chappager}
-
-\def\CHAPPAGon{%
-\global\let\contentsalignmacro = \chappager
-\global\let\pchapsepmacro=\chappager
-\global\let\pagealignmacro=\chappager
-\global\def\HEADINGSon{\HEADINGSsingle}}
-
-\def\CHAPPAGodd{
-\global\let\contentsalignmacro = \chapoddpage
-\global\let\pchapsepmacro=\chapoddpage
-\global\let\pagealignmacro=\chapoddpage
-\global\def\HEADINGSon{\HEADINGSdouble}}
-
-\CHAPPAGon
-
-\def\CHAPFplain{
-\global\let\chapmacro=\chfplain
-\global\let\unnumbchapmacro=\unnchfplain
-\global\let\centerchapmacro=\centerchfplain}
-
-% Plain chapter opening.
-% #1 is the text, #2 the chapter number or empty if unnumbered.
-\def\chfplain#1#2{%
-  \pchapsepmacro
-  {%
-    \chapfonts \rm
-    \def\chapnum{#2}%
-    \setbox0 = \hbox{#2\ifx\chapnum\empty\else\enspace\fi}%
-    \vbox{\hyphenpenalty=10000 \tolerance=5000 \parindent=0pt \raggedright
-          \hangindent = \wd0 \centerparametersmaybe
-          \unhbox0 #1\par}%
-  }%
-  \nobreak\bigskip % no page break after a chapter title
-  \nobreak
-}
-
-% Plain opening for unnumbered.
-\def\unnchfplain#1{\chfplain{#1}{}}
-
-% @centerchap -- centered and unnumbered.
-\let\centerparametersmaybe = \relax
-\def\centerchfplain#1{{%
-  \def\centerparametersmaybe{%
-    \advance\rightskip by 3\rightskip
-    \leftskip = \rightskip
-    \parfillskip = 0pt
-  }%
-  \chfplain{#1}{}%
-}}
-
-\CHAPFplain % The default
-
-\def\unnchfopen #1{%
-\chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
-                       \parindent=0pt\raggedright
-                       \rm #1\hfill}}\bigskip \par\nobreak
-}
-
-\def\chfopen #1#2{\chapoddpage {\chapfonts
-\vbox to 3in{\vfil \hbox to\hsize{\hfil #2} \hbox to\hsize{\hfil #1} \vfil}}%
-\par\penalty 5000 %
-}
-
-\def\centerchfopen #1{%
-\chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
-                       \parindent=0pt
-                       \hfill {\rm #1}\hfill}}\bigskip \par\nobreak
-}
-
-\def\CHAPFopen{
-\global\let\chapmacro=\chfopen
-\global\let\unnumbchapmacro=\unnchfopen
-\global\let\centerchapmacro=\centerchfopen}
-
-
-% Section titles.
-\newskip\secheadingskip
-\def\secheadingbreak{\dobreak \secheadingskip {-1000}}
-\def\secheading#1#2#3{\sectionheading{sec}{#2.#3}{#1}}
-\def\plainsecheading#1{\sectionheading{sec}{}{#1}}
-
-% Subsection titles.
-\newskip \subsecheadingskip
-\def\subsecheadingbreak{\dobreak \subsecheadingskip {-500}}
-\def\subsecheading#1#2#3#4{\sectionheading{subsec}{#2.#3.#4}{#1}}
-\def\plainsubsecheading#1{\sectionheading{subsec}{}{#1}}
-
-% Subsubsection titles.
-\let\subsubsecheadingskip = \subsecheadingskip
-\let\subsubsecheadingbreak = \subsecheadingbreak
-\def\subsubsecheading#1#2#3#4#5{\sectionheading{subsubsec}{#2.#3.#4.#5}{#1}}
-\def\plainsubsubsecheading#1{\sectionheading{subsubsec}{}{#1}}
-
-
-% Print any size section title.
-%
-% #1 is the section type (sec/subsec/subsubsec), #2 is the section
-% number (maybe empty), #3 the text.
-\def\sectionheading#1#2#3{%
-  {%
-    \expandafter\advance\csname #1headingskip\endcsname by \parskip
-    \csname #1headingbreak\endcsname
-  }%
-  {%
-    % Switch to the right set of fonts.
-    \csname #1fonts\endcsname \rm
-    %
-    % Only insert the separating space if we have a section number.
-    \def\secnum{#2}%
-    \setbox0 = \hbox{#2\ifx\secnum\empty\else\enspace\fi}%
-    %
-    \vbox{\hyphenpenalty=10000 \tolerance=5000 \parindent=0pt \raggedright
-          \hangindent = \wd0 % zero if no section number
-          \unhbox0 #3}%
-  }%
-  \ifdim\parskip<10pt \nobreak\kern10pt\nobreak\kern-\parskip\fi \nobreak
-}
-
-
-\message{toc,}
-% Table of contents.
-\newwrite\tocfile
-
-% Write an entry to the toc file, opening it if necessary.
-% Called from @chapter, etc.  We supply {\folio} at the end of the
-% argument, which will end up as the last argument to the \...entry macro.
-%
-% We open the .toc file here instead of at @setfilename or any other
-% given time so that @contents can be put in the document anywhere.
-%
-\newif\iftocfileopened
-\def\writetocentry#1{%
-  \iftocfileopened\else
-    \immediate\openout\tocfile = \jobname.toc
-    \global\tocfileopenedtrue
-  \fi
-  \iflinks \write\tocfile{#1{\folio}}\fi
-}
-
-\newskip\contentsrightmargin \contentsrightmargin=1in
-\newcount\savepageno
-\newcount\lastnegativepageno \lastnegativepageno = -1
-
-% Finish up the main text and prepare to read what we've written
-% to \tocfile.
-%
-\def\startcontents#1{%
-   % If @setchapternewpage on, and @headings double, the contents should
-   % start on an odd page, unlike chapters.  Thus, we maintain
-   % \contentsalignmacro in parallel with \pagealignmacro.
-   % From: Torbjorn Granlund <tege@matematik.su.se>
-   \contentsalignmacro
-   \immediate\closeout\tocfile
-   %
-   % Don't need to put `Contents' or `Short Contents' in the headline.
-   % It is abundantly clear what they are.
-   \unnumbchapmacro{#1}\def\thischapter{}%
-   \savepageno = \pageno
-   \begingroup                  % Set up to handle contents files properly.
-      \catcode`\\=0  \catcode`\{=1  \catcode`\}=2  \catcode`\@=11
-      % We can't do this, because then an actual ^ in a section
-      % title fails, e.g., @chapter ^ -- exponentiation.  --karl, 9jul97.
-      %\catcode`\^=7 % to see ^^e4 as \"a etc. juha@piuha.ydi.vtt.fi
-      \raggedbottom             % Worry more about breakpoints than the bottom.
-      \advance\hsize by -\contentsrightmargin % Don't use the full line length.
-      %
-      % Roman numerals for page numbers.
-      \ifnum \pageno>0 \pageno = \lastnegativepageno \fi
-}
-
-
-% Normal (long) toc.
-\def\contents{%
-   \startcontents{\putwordTOC}%
-     \openin 1 \jobname.toc
-     \ifeof 1 \else
-       \closein 1
-       \input \jobname.toc
-     \fi
-     \vfill \eject
-     \contentsalignmacro % in case @setchapternewpage odd is in effect
-     \pdfmakeoutlines
-   \endgroup
-   \lastnegativepageno = \pageno
-   \pageno = \savepageno
-}
-
-% And just the chapters.
-\def\summarycontents{%
-   \startcontents{\putwordShortTOC}%
-      %
-      \let\chapentry = \shortchapentry
-      \let\unnumbchapentry = \shortunnumberedentry
-      % We want a true roman here for the page numbers.
-      \secfonts
-      \let\rm=\shortcontrm \let\bf=\shortcontbf \let\sl=\shortcontsl
-      \rm
-      \hyphenpenalty = 10000
-      \advance\baselineskip by 1pt % Open it up a little.
-      \def\secentry ##1##2##3##4{}
-      \def\unnumbsecentry ##1##2{}
-      \def\subsecentry ##1##2##3##4##5{}
-      \def\unnumbsubsecentry ##1##2{}
-      \def\subsubsecentry ##1##2##3##4##5##6{}
-      \def\unnumbsubsubsecentry ##1##2{}
-      \openin 1 \jobname.toc
-      \ifeof 1 \else
-        \closein 1
-        \input \jobname.toc
-      \fi
-     \vfill \eject
-     \contentsalignmacro % in case @setchapternewpage odd is in effect
-   \endgroup
-   \lastnegativepageno = \pageno
-   \pageno = \savepageno
-}
-\let\shortcontents = \summarycontents
-
-\ifpdf
-  \pdfcatalog{/PageMode /UseOutlines}%
-\fi
-
-% These macros generate individual entries in the table of contents.
-% The first argument is the chapter or section name.
-% The last argument is the page number.
-% The arguments in between are the chapter number, section number, ...
-
-% Chapter-level things, for both the long and short contents.
-\def\chapentry#1#2#3{\dochapentry{#2\labelspace#1}{#3}}
-
-% See comments in \dochapentry re vbox and related settings
-\def\shortchapentry#1#2#3{%
-  \tocentry{\shortchaplabel{#2}\labelspace #1}{\doshortpageno\bgroup#3\egroup}%
-}
-
-% Typeset the label for a chapter or appendix for the short contents.
-% The arg is, e.g. `Appendix A' for an appendix, or `3' for a chapter.
-% We could simplify the code here by writing out an \appendixentry
-% command in the toc file for appendices, instead of using \chapentry
-% for both, but it doesn't seem worth it.
-%
-\newdimen\shortappendixwidth
-%
-\def\shortchaplabel#1{%
-  % Compute width of word "Appendix", may change with language.
-  \setbox0 = \hbox{\shortcontrm \putwordAppendix}%
-  \shortappendixwidth = \wd0
-  %
-  % We typeset #1 in a box of constant width, regardless of the text of
-  % #1, so the chapter titles will come out aligned.
-  \setbox0 = \hbox{#1}%
-  \dimen0 = \ifdim\wd0 > \shortappendixwidth \shortappendixwidth \else 0pt \fi
-  %
-  % This space should be plenty, since a single number is .5em, and the
-  % widest letter (M) is 1em, at least in the Computer Modern fonts.
-  % (This space doesn't include the extra space that gets added after
-  % the label; that gets put in by \shortchapentry above.)
-  \advance\dimen0 by 1.1em
-  \hbox to \dimen0{#1\hfil}%
-}
-
-\def\unnumbchapentry#1#2{\dochapentry{#1}{#2}}
-\def\shortunnumberedentry#1#2{\tocentry{#1}{\doshortpageno\bgroup#2\egroup}}
-
-% Sections.
-\def\secentry#1#2#3#4{\dosecentry{#2.#3\labelspace#1}{#4}}
-\def\unnumbsecentry#1#2{\dosecentry{#1}{#2}}
-
-% Subsections.
-\def\subsecentry#1#2#3#4#5{\dosubsecentry{#2.#3.#4\labelspace#1}{#5}}
-\def\unnumbsubsecentry#1#2{\dosubsecentry{#1}{#2}}
-
-% And subsubsections.
-\def\subsubsecentry#1#2#3#4#5#6{%
-  \dosubsubsecentry{#2.#3.#4.#5\labelspace#1}{#6}}
-\def\unnumbsubsubsecentry#1#2{\dosubsubsecentry{#1}{#2}}
-
-% This parameter controls the indentation of the various levels.
-\newdimen\tocindent \tocindent = 3pc
-
-% Now for the actual typesetting. In all these, #1 is the text and #2 is the
-% page number.
-%
-% If the toc has to be broken over pages, we want it to be at chapters
-% if at all possible; hence the \penalty.
-\def\dochapentry#1#2{%
-   \penalty-300 \vskip1\baselineskip plus.33\baselineskip minus.25\baselineskip
-   \begingroup
-     \chapentryfonts
-     \tocentry{#1}{\dopageno\bgroup#2\egroup}%
-   \endgroup
-   \nobreak\vskip .25\baselineskip plus.1\baselineskip
-}
-
-\def\dosecentry#1#2{\begingroup
-  \secentryfonts \leftskip=\tocindent
-  \tocentry{#1}{\dopageno\bgroup#2\egroup}%
-\endgroup}
-
-\def\dosubsecentry#1#2{\begingroup
-  \subsecentryfonts \leftskip=2\tocindent
-  \tocentry{#1}{\dopageno\bgroup#2\egroup}%
-\endgroup}
-
-\def\dosubsubsecentry#1#2{\begingroup
-  \subsubsecentryfonts \leftskip=3\tocindent
-  \tocentry{#1}{\dopageno\bgroup#2\egroup}%
-\endgroup}
-
-% Final typesetting of a toc entry; we use the same \entry macro as for
-% the index entries, but we want to suppress hyphenation here.  (We
-% can't do that in the \entry macro, since index entries might consist
-% of hyphenated-identifiers-that-do-not-fit-on-a-line-and-nothing-else.)
-\def\tocentry#1#2{\begingroup
-  \vskip 0pt plus1pt % allow a little stretch for the sake of nice page breaks
-  % Do not use \turnoffactive in these arguments.  Since the toc is
-  % typeset in cmr, so characters such as _ would come out wrong; we
-  % have to do the usual translation tricks.
-  \entry{#1}{#2}%
-\endgroup}
-
-% Space between chapter (or whatever) number and the title.
-\def\labelspace{\hskip1em \relax}
-
-\def\dopageno#1{{\rm #1}}
-\def\doshortpageno#1{{\rm #1}}
-
-\def\chapentryfonts{\secfonts \rm}
-\def\secentryfonts{\textfonts}
-\let\subsecentryfonts = \textfonts
-\let\subsubsecentryfonts = \textfonts
-
-
-\message{environments,}
-% @foo ... @end foo.
-
-% Since these characters are used in examples, it should be an even number of
-% \tt widths. Each \tt character is 1en, so two makes it 1em.
-% Furthermore, these definitions must come after we define our fonts.
-\newbox\dblarrowbox    \newbox\longdblarrowbox
-\newbox\pushcharbox    \newbox\bullbox
-\newbox\equivbox       \newbox\errorbox
-
-%{\tentt
-%\global\setbox\dblarrowbox = \hbox to 1em{\hfil$\Rightarrow$\hfil}
-%\global\setbox\longdblarrowbox = \hbox to 1em{\hfil$\mapsto$\hfil}
-%\global\setbox\pushcharbox = \hbox to 1em{\hfil$\dashv$\hfil}
-%\global\setbox\equivbox = \hbox to 1em{\hfil$\ptexequiv$\hfil}
-% Adapted from the manmac format (p.420 of TeXbook)
-%\global\setbox\bullbox = \hbox to 1em{\kern.15em\vrule height .75ex width .85ex
-%                                      depth .1ex\hfil}
-%}
-
-% @point{}, @result{}, @expansion{}, @print{}, @equiv{}.
-\def\point{$\star$}
-\def\result{\leavevmode\raise.15ex\hbox to 1em{\hfil$\Rightarrow$\hfil}}
-\def\expansion{\leavevmode\raise.1ex\hbox to 1em{\hfil$\mapsto$\hfil}}
-\def\print{\leavevmode\lower.1ex\hbox to 1em{\hfil$\dashv$\hfil}}
-\def\equiv{\leavevmode\lower.1ex\hbox to 1em{\hfil$\ptexequiv$\hfil}}
-
-% Adapted from the TeXbook's \boxit.
-{\tentt \global\dimen0 = 3em}% Width of the box.
-\dimen2 = .55pt % Thickness of rules
-% The text. (`r' is open on the right, `e' somewhat less so on the left.)
-\setbox0 = \hbox{\kern-.75pt \tensf error\kern-1.5pt}
-
-\global\setbox\errorbox=\hbox to \dimen0{\hfil
-   \hsize = \dimen0 \advance\hsize by -5.8pt % Space to left+right.
-   \advance\hsize by -2\dimen2 % Rules.
-   \vbox{
-      \hrule height\dimen2
-      \hbox{\vrule width\dimen2 \kern3pt          % Space to left of text.
-         \vtop{\kern2.4pt \box0 \kern2.4pt}% Space above/below.
-         \kern3pt\vrule width\dimen2}% Space to right.
-      \hrule height\dimen2}
-    \hfil}
-
-% The @error{} command.
-\def\error{\leavevmode\lower.7ex\copy\errorbox}
-
-% @tex ... @end tex    escapes into raw Tex temporarily.
-% One exception: @ is still an escape character, so that @end tex works.
-% But \@ or @@ will get a plain tex @ character.
-
-\def\tex{\begingroup
-  \catcode `\\=0 \catcode `\{=1 \catcode `\}=2
-  \catcode `\$=3 \catcode `\&=4 \catcode `\#=6
-  \catcode `\^=7 \catcode `\_=8 \catcode `\~=13 \let~=\tie
-  \catcode `\%=14
-  \catcode 43=12 % plus
-  \catcode`\"=12
-  \catcode`\==12
-  \catcode`\|=12
-  \catcode`\<=12
-  \catcode`\>=12
-  \escapechar=`\\
-  %
-  \let\b=\ptexb
-  \let\bullet=\ptexbullet
-  \let\c=\ptexc
-  \let\,=\ptexcomma
-  \let\.=\ptexdot
-  \let\dots=\ptexdots
-  \let\equiv=\ptexequiv
-  \let\!=\ptexexclam
-  \let\i=\ptexi
-  \let\{=\ptexlbrace
-  \let\+=\tabalign
-  \let\}=\ptexrbrace
-  \let\*=\ptexstar
-  \let\t=\ptext
-  %
-  \def\endldots{\mathinner{\ldots\ldots\ldots\ldots}}%
-  \def\enddots{\relax\ifmmode\endldots\else$\mathsurround=0pt \endldots\,$\fi}%
-  \def\@{@}%
-\let\Etex=\endgroup}
-
-% Define @lisp ... @endlisp.
-% @lisp does a \begingroup so it can rebind things,
-% including the definition of @endlisp (which normally is erroneous).
-
-% Amount to narrow the margins by for @lisp.
-\newskip\lispnarrowing \lispnarrowing=0.4in
-
-% This is the definition that ^^M gets inside @lisp, @example, and other
-% such environments.  \null is better than a space, since it doesn't
-% have any width.
-\def\lisppar{\null\endgraf}
-
-% Make each space character in the input produce a normal interword
-% space in the output.  Don't allow a line break at this space, as this
-% is used only in environments like @example, where each line of input
-% should produce a line of output anyway.
-%
-{\obeyspaces %
-\gdef\sepspaces{\obeyspaces\let =\tie}}
-
-% Define \obeyedspace to be our active space, whatever it is.  This is
-% for use in \parsearg.
-{\sepspaces%
-\global\let\obeyedspace= }
-
-% This space is always present above and below environments.
-\newskip\envskipamount \envskipamount = 0pt
-
-% Make spacing and below environment symmetrical.  We use \parskip here
-% to help in doing that, since in @example-like environments \parskip
-% is reset to zero; thus the \afterenvbreak inserts no space -- but the
-% start of the next paragraph will insert \parskip
-%
-\def\aboveenvbreak{{\advance\envskipamount by \parskip
-\endgraf \ifdim\lastskip<\envskipamount
-\removelastskip \penalty-50 \vskip\envskipamount \fi}}
-
-\let\afterenvbreak = \aboveenvbreak
-
-% \nonarrowing is a flag.  If "set", @lisp etc don't narrow margins.
-\let\nonarrowing=\relax
-
-% @cartouche ... @end cartouche: draw rectangle w/rounded corners around
-% environment contents.
-\font\circle=lcircle10
-\newdimen\circthick
-\newdimen\cartouter\newdimen\cartinner
-\newskip\normbskip\newskip\normpskip\newskip\normlskip
-\circthick=\fontdimen8\circle
-%
-\def\ctl{{\circle\char'013\hskip -6pt}}% 6pt from pl file: 1/2charwidth
-\def\ctr{{\hskip 6pt\circle\char'010}}
-\def\cbl{{\circle\char'012\hskip -6pt}}
-\def\cbr{{\hskip 6pt\circle\char'011}}
-\def\carttop{\hbox to \cartouter{\hskip\lskip
-        \ctl\leaders\hrule height\circthick\hfil\ctr
-        \hskip\rskip}}
-\def\cartbot{\hbox to \cartouter{\hskip\lskip
-        \cbl\leaders\hrule height\circthick\hfil\cbr
-        \hskip\rskip}}
-%
-\newskip\lskip\newskip\rskip
-
-\long\def\cartouche{%
-\begingroup
-        \lskip=\leftskip \rskip=\rightskip
-        \leftskip=0pt\rightskip=0pt %we want these *outside*.
-        \cartinner=\hsize \advance\cartinner by-\lskip
-                          \advance\cartinner by-\rskip
-        \cartouter=\hsize
-        \advance\cartouter by 18.4pt % allow for 3pt kerns on either
-%                                    side, and for 6pt waste from
-%                                    each corner char, and rule thickness
-        \normbskip=\baselineskip \normpskip=\parskip \normlskip=\lineskip
-        % Flag to tell @lisp, etc., not to narrow margin.
-        \let\nonarrowing=\comment
-        \vbox\bgroup
-                \baselineskip=0pt\parskip=0pt\lineskip=0pt
-                \carttop
-                \hbox\bgroup
-                        \hskip\lskip
-                        \vrule\kern3pt
-                        \vbox\bgroup
-                                \hsize=\cartinner
-                                \kern3pt
-                                \begingroup
-                                        \baselineskip=\normbskip
-                                        \lineskip=\normlskip
-                                        \parskip=\normpskip
-                                        \vskip -\parskip
-\def\Ecartouche{%
-                                \endgroup
-                                \kern3pt
-                        \egroup
-                        \kern3pt\vrule
-                        \hskip\rskip
-                \egroup
-                \cartbot
-        \egroup
-\endgroup
-}}
-
-
-% This macro is called at the beginning of all the @example variants,
-% inside a group.
-\def\nonfillstart{%
-  \aboveenvbreak
-  \inENV % This group ends at the end of the body
-  \hfuzz = 12pt % Don't be fussy
-  \sepspaces % Make spaces be word-separators rather than space tokens.
-  \singlespace
-  \let\par = \lisppar % don't ignore blank lines
-  \obeylines % each line of input is a line of output
-  \parskip = 0pt
-  \parindent = 0pt
-  \emergencystretch = 0pt % don't try to avoid overfull boxes
-  % @cartouche defines \nonarrowing to inhibit narrowing
-  % at next level down.
-  \ifx\nonarrowing\relax
-    \advance \leftskip by \lispnarrowing
-    \exdentamount=\lispnarrowing
-    \let\exdent=\nofillexdent
-    \let\nonarrowing=\relax
-  \fi
-}
-
-% Define the \E... control sequence only if we are inside the particular
-% environment, so the error checking in \end will work.
-%
-% To end an @example-like environment, we first end the paragraph (via
-% \afterenvbreak's vertical glue), and then the group.  That way we keep
-% the zero \parskip that the environments set -- \parskip glue will be
-% inserted at the beginning of the next paragraph in the document, after
-% the environment.
-%
-\def\nonfillfinish{\afterenvbreak\endgroup}
-
-% @lisp: indented, narrowed, typewriter font.
-\def\lisp{\begingroup
-  \nonfillstart
-  \let\Elisp = \nonfillfinish
-  \tt
-  \let\kbdfont = \kbdexamplefont % Allow @kbd to do something special.
-  \gobble       % eat return
-}
-
-% @example: Same as @lisp.
-\def\example{\begingroup \def\Eexample{\nonfillfinish\endgroup}\lisp}
-
-% @small... is usually equivalent to the non-small (@smallbook
-% redefines).  We must call \example (or whatever) last in the
-% definition, since it reads the return following the @example (or
-% whatever) command.
-%
-% This actually allows (for example) @end display inside an
-% @smalldisplay.  Too bad, but makeinfo will catch the error anyway.
-%
-\def\smalldisplay{\begingroup\def\Esmalldisplay{\nonfillfinish\endgroup}\display}
-\def\smallexample{\begingroup\def\Esmallexample{\nonfillfinish\endgroup}\lisp}
-\def\smallformat{\begingroup\def\Esmallformat{\nonfillfinish\endgroup}\format}
-\def\smalllisp{\begingroup\def\Esmalllisp{\nonfillfinish\endgroup}\lisp}
-
-% Real @smallexample and @smalllisp (when @smallbook): use smaller fonts.
-% Originally contributed by Pavel@xerox.
-\def\smalllispx{\begingroup
-  \def\Esmalllisp{\nonfillfinish\endgroup}%
-  \def\Esmallexample{\nonfillfinish\endgroup}%
-  \smallfonts
-  \lisp
-}
-
-% @display: same as @lisp except keep current font.
-%
-\def\display{\begingroup
-  \nonfillstart
-  \let\Edisplay = \nonfillfinish
-  \gobble
-}
-
-% @smalldisplay (when @smallbook): @display plus smaller fonts.
-%
-\def\smalldisplayx{\begingroup
-  \def\Esmalldisplay{\nonfillfinish\endgroup}%
-  \smallfonts \rm
-  \display
-}
-
-% @format: same as @display except don't narrow margins.
-%
-\def\format{\begingroup
-  \let\nonarrowing = t
-  \nonfillstart
-  \let\Eformat = \nonfillfinish
-  \gobble
-}
-
-% @smallformat (when @smallbook): @format plus smaller fonts.
-%
-\def\smallformatx{\begingroup
-  \def\Esmallformat{\nonfillfinish\endgroup}%
-  \smallfonts \rm
-  \format
-}
-
-% @flushleft (same as @format).
-%
-\def\flushleft{\begingroup \def\Eflushleft{\nonfillfinish\endgroup}\format}
-
-% @flushright.
-%
-\def\flushright{\begingroup
-  \let\nonarrowing = t
-  \nonfillstart
-  \let\Eflushright = \nonfillfinish
-  \advance\leftskip by 0pt plus 1fill
-  \gobble
-}
-
-% @quotation does normal linebreaking (hence we can't use \nonfillstart)
-% and narrows the margins.
-%
-\def\quotation{%
-  \begingroup\inENV %This group ends at the end of the @quotation body
-  {\parskip=0pt \aboveenvbreak}% because \aboveenvbreak inserts \parskip
-  \singlespace
-  \parindent=0pt
-  % We have retained a nonzero parskip for the environment, since we're
-  % doing normal filling. So to avoid extra space below the environment...
-  \def\Equotation{\parskip = 0pt \nonfillfinish}%
-  %
-  % @cartouche defines \nonarrowing to inhibit narrowing at next level down.
-  \ifx\nonarrowing\relax
-    \advance\leftskip by \lispnarrowing
-    \advance\rightskip by \lispnarrowing
-    \exdentamount = \lispnarrowing
-    \let\nonarrowing = \relax
-  \fi
-}
-
-
-\message{defuns,}
-% @defun etc.
-
-% Allow user to change definition object font (\df) internally
-\def\setdeffont #1 {\csname DEF#1\endcsname}
-
-\newskip\defbodyindent \defbodyindent=.4in
-\newskip\defargsindent \defargsindent=50pt
-\newskip\deftypemargin \deftypemargin=12pt
-\newskip\deflastargmargin \deflastargmargin=18pt
-
-\newcount\parencount
-% define \functionparens, which makes ( and ) and & do special things.
-% \functionparens affects the group it is contained in.
-\def\activeparens{%
-\catcode`\(=\active \catcode`\)=\active \catcode`\&=\active
-\catcode`\[=\active \catcode`\]=\active}
-
-% Make control sequences which act like normal parenthesis chars.
-\let\lparen = ( \let\rparen = )
-
-{\activeparens % Now, smart parens don't turn on until &foo (see \amprm)
-
-% Be sure that we always have a definition for `(', etc.  For example,
-% if the fn name has parens in it, \boldbrax will not be in effect yet,
-% so TeX would otherwise complain about undefined control sequence.
-\global\let(=\lparen \global\let)=\rparen
-\global\let[=\lbrack \global\let]=\rbrack
-
-\gdef\functionparens{\boldbrax\let&=\amprm\parencount=0 }
-\gdef\boldbrax{\let(=\opnr\let)=\clnr\let[=\lbrb\let]=\rbrb}
-% This is used to turn on special parens
-% but make & act ordinary (given that it's active).
-\gdef\boldbraxnoamp{\let(=\opnr\let)=\clnr\let[=\lbrb\let]=\rbrb\let&=\ampnr}
-
-% Definitions of (, ) and & used in args for functions.
-% This is the definition of ( outside of all parentheses.
-\gdef\oprm#1 {{\rm\char`\(}#1 \bf \let(=\opnested
-  \global\advance\parencount by 1
-}
-%
-% This is the definition of ( when already inside a level of parens.
-\gdef\opnested{\char`\(\global\advance\parencount by 1 }
-%
-\gdef\clrm{% Print a paren in roman if it is taking us back to depth of 0.
-  % also in that case restore the outer-level definition of (.
-  \ifnum \parencount=1 {\rm \char `\)}\sl \let(=\oprm \else \char `\) \fi
-  \global\advance \parencount by -1 }
-% If we encounter &foo, then turn on ()-hacking afterwards
-\gdef\amprm#1 {{\rm\&#1}\let(=\oprm \let)=\clrm\ }
-%
-\gdef\normalparens{\boldbrax\let&=\ampnr}
-} % End of definition inside \activeparens
-%% These parens (in \boldbrax) actually are a little bolder than the
-%% contained text.  This is especially needed for [ and ]
-\def\opnr{{\sf\char`\(}\global\advance\parencount by 1 }
-\def\clnr{{\sf\char`\)}\global\advance\parencount by -1 }
-\let\ampnr = \&
-\def\lbrb{{\bf\char`\[}}
-\def\rbrb{{\bf\char`\]}}
-
-% Active &'s sneak into the index arguments, so make sure it's defined.
-{
-  \catcode`& = 13
-  \global\let& = \ampnr
-}
-
-% First, defname, which formats the header line itself.
-% #1 should be the function name.
-% #2 should be the type of definition, such as "Function".
-
-\def\defname #1#2{%
-% Get the values of \leftskip and \rightskip as they were
-% outside the @def...
-\dimen2=\leftskip
-\advance\dimen2 by -\defbodyindent
-\noindent
-\setbox0=\hbox{\hskip \deflastargmargin{\rm #2}\hskip \deftypemargin}%
-\dimen0=\hsize \advance \dimen0 by -\wd0 % compute size for first line
-\dimen1=\hsize \advance \dimen1 by -\defargsindent %size for continuations
-\parshape 2 0in \dimen0 \defargsindent \dimen1
-% Now output arg 2 ("Function" or some such)
-% ending at \deftypemargin from the right margin,
-% but stuck inside a box of width 0 so it does not interfere with linebreaking
-{% Adjust \hsize to exclude the ambient margins,
-% so that \rightline will obey them.
-\advance \hsize by -\dimen2
-\rlap{\rightline{{\rm #2}\hskip -1.25pc }}}%
-% Make all lines underfull and no complaints:
-\tolerance=10000 \hbadness=10000
-\advance\leftskip by -\defbodyindent
-\exdentamount=\defbodyindent
-{\df #1}\enskip        % Generate function name
-}
-
-% Actually process the body of a definition
-% #1 should be the terminating control sequence, such as \Edefun.
-% #2 should be the "another name" control sequence, such as \defunx.
-% #3 should be the control sequence that actually processes the header,
-%    such as \defunheader.
-
-\def\defparsebody #1#2#3{\begingroup\inENV% Environment for definitionbody
-\medbreak %
-% Define the end token that this defining construct specifies
-% so that it will exit this group.
-\def#1{\endgraf\endgroup\medbreak}%
-\def#2{\begingroup\obeylines\activeparens\spacesplit#3}%
-\parindent=0in
-\advance\leftskip by \defbodyindent
-\exdentamount=\defbodyindent
-\begingroup %
-\catcode 61=\active % 61 is `='
-\obeylines\activeparens\spacesplit#3}
-
-% #1 is the \E... control sequence to end the definition (which we define).
-% #2 is the \...x control sequence for consecutive fns (which we define).
-% #3 is the control sequence to call to resume processing.
-% #4, delimited by the space, is the class name.
-%
-\def\defmethparsebody#1#2#3#4 {\begingroup\inENV %
-\medbreak %
-% Define the end token that this defining construct specifies
-% so that it will exit this group.
-\def#1{\endgraf\endgroup\medbreak}%
-\def#2##1 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}}}%
-\parindent=0in
-\advance\leftskip by \defbodyindent
-\exdentamount=\defbodyindent
-\begingroup\obeylines\activeparens\spacesplit{#3{#4}}}
-
-% Used for @deftypemethod and @deftypeivar.
-% #1 is the \E... control sequence to end the definition (which we define).
-% #2 is the \...x control sequence for consecutive fns (which we define).
-% #3 is the control sequence to call to resume processing.
-% #4, delimited by a space, is the class name.
-% #5 is the method's return type.
-%
-\def\deftypemethparsebody#1#2#3#4 #5 {\begingroup\inENV
-  \medbreak
-  \def#1{\endgraf\endgroup\medbreak}%
-  \def#2##1 ##2 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}{##2}}}%
-  \parindent=0in
-  \advance\leftskip by \defbodyindent
-  \exdentamount=\defbodyindent
-  \begingroup\obeylines\activeparens\spacesplit{#3{#4}{#5}}}
-
-% Used for @deftypeop.  The change from \deftypemethparsebody is an
-% extra argument at the beginning which is the `category', instead of it
-% being the hardwired string `Method' or `Instance Variable'.  We have
-% to account for this both in the \...x definition and in parsing the
-% input at hand.  Thus also need a control sequence (passed as #5) for
-% the \E... definition to assign the category name to.
-% 
-\def\deftypeopparsebody#1#2#3#4#5 #6 {\begingroup\inENV
-  \medbreak
-  \def#1{\endgraf\endgroup\medbreak}%
-  \def#2##1 ##2 ##3 {%
-    \def#4{##1}%
-    \begingroup\obeylines\activeparens\spacesplit{#3{##2}{##3}}}%
-  \parindent=0in
-  \advance\leftskip by \defbodyindent
-  \exdentamount=\defbodyindent
-  \begingroup\obeylines\activeparens\spacesplit{#3{#5}{#6}}}
-
-\def\defopparsebody #1#2#3#4#5 {\begingroup\inENV %
-\medbreak %
-% Define the end token that this defining construct specifies
-% so that it will exit this group.
-\def#1{\endgraf\endgroup\medbreak}%
-\def#2##1 ##2 {\def#4{##1}%
-\begingroup\obeylines\activeparens\spacesplit{#3{##2}}}%
-\parindent=0in
-\advance\leftskip by \defbodyindent
-\exdentamount=\defbodyindent
-\begingroup\obeylines\activeparens\spacesplit{#3{#5}}}
-
-% These parsing functions are similar to the preceding ones
-% except that they do not make parens into active characters.
-% These are used for "variables" since they have no arguments.
-
-\def\defvarparsebody #1#2#3{\begingroup\inENV% Environment for definitionbody
-\medbreak %
-% Define the end token that this defining construct specifies
-% so that it will exit this group.
-\def#1{\endgraf\endgroup\medbreak}%
-\def#2{\begingroup\obeylines\spacesplit#3}%
-\parindent=0in
-\advance\leftskip by \defbodyindent
-\exdentamount=\defbodyindent
-\begingroup %
-\catcode 61=\active %
-\obeylines\spacesplit#3}
-
-% This is used for \def{tp,vr}parsebody.  It could probably be used for
-% some of the others, too, with some judicious conditionals.
-%
-\def\parsebodycommon#1#2#3{%
-  \begingroup\inENV %
-  \medbreak %
-  % Define the end token that this defining construct specifies
-  % so that it will exit this group.
-  \def#1{\endgraf\endgroup\medbreak}%
-  \def#2##1 {\begingroup\obeylines\spacesplit{#3{##1}}}%
-  \parindent=0in
-  \advance\leftskip by \defbodyindent
-  \exdentamount=\defbodyindent
-  \begingroup\obeylines
-}
-
-\def\defvrparsebody#1#2#3#4 {%
-  \parsebodycommon{#1}{#2}{#3}%
-  \spacesplit{#3{#4}}%
-}
-
-% This loses on `@deftp {Data Type} {struct termios}' -- it thinks the
-% type is just `struct', because we lose the braces in `{struct
-% termios}' when \spacesplit reads its undelimited argument.  Sigh.
-% \let\deftpparsebody=\defvrparsebody
-%
-% So, to get around this, we put \empty in with the type name.  That
-% way, TeX won't find exactly `{...}' as an undelimited argument, and
-% won't strip off the braces.
-%
-\def\deftpparsebody #1#2#3#4 {%
-  \parsebodycommon{#1}{#2}{#3}%
-  \spacesplit{\parsetpheaderline{#3{#4}}}\empty
-}
-
-% Fine, but then we have to eventually remove the \empty *and* the
-% braces (if any).  That's what this does.
-%
-\def\removeemptybraces\empty#1\relax{#1}
-
-% After \spacesplit has done its work, this is called -- #1 is the final
-% thing to call, #2 the type name (which starts with \empty), and #3
-% (which might be empty) the arguments.
-%
-\def\parsetpheaderline#1#2#3{%
-  #1{\removeemptybraces#2\relax}{#3}%
-}%
-
-\def\defopvarparsebody #1#2#3#4#5 {\begingroup\inENV %
-\medbreak %
-% Define the end token that this defining construct specifies
-% so that it will exit this group.
-\def#1{\endgraf\endgroup\medbreak}%
-\def#2##1 ##2 {\def#4{##1}%
-\begingroup\obeylines\spacesplit{#3{##2}}}%
-\parindent=0in
-\advance\leftskip by \defbodyindent
-\exdentamount=\defbodyindent
-\begingroup\obeylines\spacesplit{#3{#5}}}
-
-% Split up #2 at the first space token.
-% call #1 with two arguments:
-%  the first is all of #2 before the space token,
-%  the second is all of #2 after that space token.
-% If #2 contains no space token, all of it is passed as the first arg
-% and the second is passed as empty.
-
-{\obeylines
-\gdef\spacesplit#1#2^^M{\endgroup\spacesplitfoo{#1}#2 \relax\spacesplitfoo}%
-\long\gdef\spacesplitfoo#1#2 #3#4\spacesplitfoo{%
-\ifx\relax #3%
-#1{#2}{}\else #1{#2}{#3#4}\fi}}
-
-% So much for the things common to all kinds of definitions.
-
-% Define @defun.
-
-% First, define the processing that is wanted for arguments of \defun
-% Use this to expand the args and terminate the paragraph they make up
-
-\def\defunargs#1{\functionparens \sl
-% Expand, preventing hyphenation at `-' chars.
-% Note that groups don't affect changes in \hyphenchar.
-% Set the font temporarily and use \font in case \setfont made \tensl a macro.
-{\tensl\hyphenchar\font=0}%
-#1%
-{\tensl\hyphenchar\font=45}%
-\ifnum\parencount=0 \else \errmessage{Unbalanced parentheses in @def}\fi%
-\interlinepenalty=10000
-\advance\rightskip by 0pt plus 1fil
-\endgraf\nobreak\vskip -\parskip\nobreak
-}
-
-\def\deftypefunargs #1{%
-% Expand, preventing hyphenation at `-' chars.
-% Note that groups don't affect changes in \hyphenchar.
-% Use \boldbraxnoamp, not \functionparens, so that & is not special.
-\boldbraxnoamp
-\tclose{#1}% avoid \code because of side effects on active chars
-\interlinepenalty=10000
-\advance\rightskip by 0pt plus 1fil
-\endgraf\nobreak\vskip -\parskip\nobreak
-}
-
-% Do complete processing of one @defun or @defunx line already parsed.
-
-% @deffn Command forward-char nchars
-
-\def\deffn{\defmethparsebody\Edeffn\deffnx\deffnheader}
-
-\def\deffnheader #1#2#3{\doind {fn}{\code{#2}}%
-\begingroup\defname {#2}{#1}\defunargs{#3}\endgroup %
-\catcode 61=\other % Turn off change made in \defparsebody
-}
-
-% @defun == @deffn Function
-
-\def\defun{\defparsebody\Edefun\defunx\defunheader}
-
-\def\defunheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
-\begingroup\defname {#1}{\putwordDeffunc}%
-\defunargs {#2}\endgroup %
-\catcode 61=\other % Turn off change made in \defparsebody
-}
-
-% @deftypefun int foobar (int @var{foo}, float @var{bar})
-
-\def\deftypefun{\defparsebody\Edeftypefun\deftypefunx\deftypefunheader}
-
-% #1 is the data type.  #2 is the name and args.
-\def\deftypefunheader #1#2{\deftypefunheaderx{#1}#2 \relax}
-% #1 is the data type, #2 the name, #3 the args.
-\def\deftypefunheaderx #1#2 #3\relax{%
-\doind {fn}{\code{#2}}% Make entry in function index
-\begingroup\defname {\defheaderxcond#1\relax$$$#2}{\putwordDeftypefun}%
-\deftypefunargs {#3}\endgroup %
-\catcode 61=\other % Turn off change made in \defparsebody
-}
-
-% @deftypefn {Library Function} int foobar (int @var{foo}, float @var{bar})
-
-\def\deftypefn{\defmethparsebody\Edeftypefn\deftypefnx\deftypefnheader}
-
-% \defheaderxcond#1\relax$$$
-% puts #1 in @code, followed by a space, but does nothing if #1 is null.
-\def\defheaderxcond#1#2$$${\ifx#1\relax\else\code{#1#2} \fi}
-
-% #1 is the classification.  #2 is the data type.  #3 is the name and args.
-\def\deftypefnheader #1#2#3{\deftypefnheaderx{#1}{#2}#3 \relax}
-% #1 is the classification, #2 the data type, #3 the name, #4 the args.
-\def\deftypefnheaderx #1#2#3 #4\relax{%
-\doind {fn}{\code{#3}}% Make entry in function index
-\begingroup
-\normalparens % notably, turn off `&' magic, which prevents
-%               at least some C++ text from working
-\defname {\defheaderxcond#2\relax$$$#3}{#1}%
-\deftypefunargs {#4}\endgroup %
-\catcode 61=\other % Turn off change made in \defparsebody
-}
-
-% @defmac == @deffn Macro
-
-\def\defmac{\defparsebody\Edefmac\defmacx\defmacheader}
-
-\def\defmacheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
-\begingroup\defname {#1}{\putwordDefmac}%
-\defunargs {#2}\endgroup %
-\catcode 61=\other % Turn off change made in \defparsebody
-}
-
-% @defspec == @deffn Special Form
-
-\def\defspec{\defparsebody\Edefspec\defspecx\defspecheader}
-
-\def\defspecheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
-\begingroup\defname {#1}{\putwordDefspec}%
-\defunargs {#2}\endgroup %
-\catcode 61=\other % Turn off change made in \defparsebody
-}
-
-% @defop CATEGORY CLASS OPERATION ARG...
-%
-\def\defop #1 {\def\defoptype{#1}%
-\defopparsebody\Edefop\defopx\defopheader\defoptype}
-%
-\def\defopheader#1#2#3{%
-\dosubind {fn}{\code{#2}}{\putwordon\ #1}% Make entry in function index
-\begingroup\defname {#2}{\defoptype\ \putwordon\ #1}%
-\defunargs {#3}\endgroup %
-}
-
-% @deftypeop CATEGORY CLASS TYPE OPERATION ARG...
-%
-\def\deftypeop #1 {\def\deftypeopcategory{#1}%
-  \deftypeopparsebody\Edeftypeop\deftypeopx\deftypeopheader
-                       \deftypeopcategory}
-%
-% #1 is the class name, #2 the data type, #3 the operation name, #4 the args.
-\def\deftypeopheader#1#2#3#4{%
-  \dosubind{fn}{\code{#3}}{\putwordon\ \code{#1}}% entry in function index
-  \begingroup
-    \defname{\defheaderxcond#2\relax$$$#3}
-            {\deftypeopcategory\ \putwordon\ \code{#1}}%
-    \deftypefunargs{#4}%
-  \endgroup
-}
-
-% @deftypemethod CLASS TYPE METHOD ARG...
-%
-\def\deftypemethod{%
-  \deftypemethparsebody\Edeftypemethod\deftypemethodx\deftypemethodheader}
-%
-% #1 is the class name, #2 the data type, #3 the method name, #4 the args.
-\def\deftypemethodheader#1#2#3#4{%
-  \dosubind{fn}{\code{#3}}{\putwordon\ \code{#1}}% entry in function index
-  \begingroup
-    \defname{\defheaderxcond#2\relax$$$#3}{\putwordMethodon\ \code{#1}}%
-    \deftypefunargs{#4}%
-  \endgroup
-}
-
-% @deftypeivar CLASS TYPE VARNAME
-%
-\def\deftypeivar{%
-  \deftypemethparsebody\Edeftypeivar\deftypeivarx\deftypeivarheader}
-%
-% #1 is the class name, #2 the data type, #3 the variable name.
-\def\deftypeivarheader#1#2#3{%
-  \dosubind{vr}{\code{#3}}{\putwordof\ \code{#1}}% entry in variable index
-  \begingroup
-    \defname{#3}{\putwordInstanceVariableof\ \code{#1}}%
-    \defvarargs{#3}%
-  \endgroup
-}
-
-% @defmethod == @defop Method
-%
-\def\defmethod{\defmethparsebody\Edefmethod\defmethodx\defmethodheader}
-%
-% #1 is the class name, #2 the method name, #3 the args.
-\def\defmethodheader#1#2#3{%
-  \dosubind{fn}{\code{#2}}{\putwordon\ \code{#1}}% entry in function index
-  \begingroup
-    \defname{#2}{\putwordMethodon\ \code{#1}}%
-    \defunargs{#3}%
-  \endgroup
-}
-
-% @defcv {Class Option} foo-class foo-flag
-
-\def\defcv #1 {\def\defcvtype{#1}%
-\defopvarparsebody\Edefcv\defcvx\defcvarheader\defcvtype}
-
-\def\defcvarheader #1#2#3{%
-\dosubind {vr}{\code{#2}}{\putwordof\ #1}% Make entry in var index
-\begingroup\defname {#2}{\defcvtype\ \putwordof\ #1}%
-\defvarargs {#3}\endgroup %
-}
-
-% @defivar CLASS VARNAME == @defcv {Instance Variable} CLASS VARNAME
-%
-\def\defivar{\defvrparsebody\Edefivar\defivarx\defivarheader}
-%
-\def\defivarheader#1#2#3{%
-  \dosubind {vr}{\code{#2}}{\putwordof\ #1}% entry in var index
-  \begingroup
-    \defname{#2}{\putwordInstanceVariableof\ #1}%
-    \defvarargs{#3}%
-  \endgroup
-}
-
-% @defvar
-% First, define the processing that is wanted for arguments of @defvar.
-% This is actually simple: just print them in roman.
-% This must expand the args and terminate the paragraph they make up
-\def\defvarargs #1{\normalparens #1%
-\interlinepenalty=10000
-\endgraf\nobreak\vskip -\parskip\nobreak}
-
-% @defvr Counter foo-count
-
-\def\defvr{\defvrparsebody\Edefvr\defvrx\defvrheader}
-
-\def\defvrheader #1#2#3{\doind {vr}{\code{#2}}%
-\begingroup\defname {#2}{#1}\defvarargs{#3}\endgroup}
-
-% @defvar == @defvr Variable
-
-\def\defvar{\defvarparsebody\Edefvar\defvarx\defvarheader}
-
-\def\defvarheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
-\begingroup\defname {#1}{\putwordDefvar}%
-\defvarargs {#2}\endgroup %
-}
-
-% @defopt == @defvr {User Option}
-
-\def\defopt{\defvarparsebody\Edefopt\defoptx\defoptheader}
-
-\def\defoptheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
-\begingroup\defname {#1}{\putwordDefopt}%
-\defvarargs {#2}\endgroup %
-}
-
-% @deftypevar int foobar
-
-\def\deftypevar{\defvarparsebody\Edeftypevar\deftypevarx\deftypevarheader}
-
-% #1 is the data type.  #2 is the name, perhaps followed by text that
-% is actually part of the data type, which should not be put into the index.
-\def\deftypevarheader #1#2{%
-\dovarind#2 \relax% Make entry in variables index
-\begingroup\defname {\defheaderxcond#1\relax$$$#2}{\putwordDeftypevar}%
-\interlinepenalty=10000
-\endgraf\nobreak\vskip -\parskip\nobreak
-\endgroup}
-\def\dovarind#1 #2\relax{\doind{vr}{\code{#1}}}
-
-% @deftypevr {Global Flag} int enable
-
-\def\deftypevr{\defvrparsebody\Edeftypevr\deftypevrx\deftypevrheader}
-
-\def\deftypevrheader #1#2#3{\dovarind#3 \relax%
-\begingroup\defname {\defheaderxcond#2\relax$$$#3}{#1}
-\interlinepenalty=10000
-\endgraf\nobreak\vskip -\parskip\nobreak
-\endgroup}
-
-% Now define @deftp
-% Args are printed in bold, a slight difference from @defvar.
-
-\def\deftpargs #1{\bf \defvarargs{#1}}
-
-% @deftp Class window height width ...
-
-\def\deftp{\deftpparsebody\Edeftp\deftpx\deftpheader}
-
-\def\deftpheader #1#2#3{\doind {tp}{\code{#2}}%
-\begingroup\defname {#2}{#1}\deftpargs{#3}\endgroup}
-
-% These definitions are used if you use @defunx (etc.)
-% anywhere other than immediately after a @defun or @defunx.
-% 
-\def\defcvx#1 {\errmessage{@defcvx in invalid context}}
-\def\deffnx#1 {\errmessage{@deffnx in invalid context}}
-\def\defivarx#1 {\errmessage{@defivarx in invalid context}}
-\def\defmacx#1 {\errmessage{@defmacx in invalid context}}
-\def\defmethodx#1 {\errmessage{@defmethodx in invalid context}}
-\def\defoptx #1 {\errmessage{@defoptx in invalid context}}
-\def\defopx#1 {\errmessage{@defopx in invalid context}}
-\def\defspecx#1 {\errmessage{@defspecx in invalid context}}
-\def\deftpx#1 {\errmessage{@deftpx in invalid context}}
-\def\deftypefnx#1 {\errmessage{@deftypefnx in invalid context}}
-\def\deftypefunx#1 {\errmessage{@deftypefunx in invalid context}}
-\def\deftypeivarx#1 {\errmessage{@deftypeivarx in invalid context}}
-\def\deftypemethodx#1 {\errmessage{@deftypemethodx in invalid context}}
-\def\deftypeopx#1 {\errmessage{@deftypeopx in invalid context}}
-\def\deftypevarx#1 {\errmessage{@deftypevarx in invalid context}}
-\def\deftypevrx#1 {\errmessage{@deftypevrx in invalid context}}
-\def\defunx#1 {\errmessage{@defunx in invalid context}}
-\def\defvarx#1 {\errmessage{@defvarx in invalid context}}
-\def\defvrx#1 {\errmessage{@defvrx in invalid context}}
-
-
-\message{macros,}
-% @macro.
-
-% To do this right we need a feature of e-TeX, \scantokens,
-% which we arrange to emulate with a temporary file in ordinary TeX.
-\ifx\eTeXversion\undefined
- \newwrite\macscribble
- \def\scanmacro#1{%
-   \begingroup \newlinechar`\^^M
-   % Undo catcode changes of \startcontents and \doprintindex
-   \catcode`\@=0 \catcode`\\=12 \escapechar=`\@
-   % Append \endinput to make sure that TeX does not see the ending newline.
-   \toks0={#1\endinput}%
-   \immediate\openout\macscribble=\jobname.tmp
-   \immediate\write\macscribble{\the\toks0}%
-   \immediate\closeout\macscribble
-   \let\xeatspaces\eatspaces
-   \input \jobname.tmp
-   \endgroup
-}
-\else
-\def\scanmacro#1{%
-\begingroup \newlinechar`\^^M
-% Undo catcode changes of \startcontents and \doprintindex
-\catcode`\@=0 \catcode`\\=12 \escapechar=`\@
-\let\xeatspaces\eatspaces\scantokens{#1\endinput}\endgroup}
-\fi
-
-\newcount\paramno   % Count of parameters
-\newtoks\macname    % Macro name
-\newif\ifrecursive  % Is it recursive?
-\def\macrolist{}    % List of all defined macros in the form
-                    % \do\macro1\do\macro2...
-
-% Utility routines.
-% Thisdoes \let #1 = #2, except with \csnames.
-\def\cslet#1#2{%
-\expandafter\expandafter
-\expandafter\let
-\expandafter\expandafter
-\csname#1\endcsname
-\csname#2\endcsname}
-
-% Trim leading and trailing spaces off a string.
-% Concepts from aro-bend problem 15 (see CTAN).
-{\catcode`\@=11
-\gdef\eatspaces #1{\expandafter\trim@\expandafter{#1 }}
-\gdef\trim@ #1{\trim@@ @#1 @ #1 @ @@}
-\gdef\trim@@ #1@ #2@ #3@@{\trim@@@\empty #2 @}
-\def\unbrace#1{#1}
-\unbrace{\gdef\trim@@@ #1 } #2@{#1}
-}
-
-% Trim a single trailing ^^M off a string.
-{\catcode`\^^M=12\catcode`\Q=3%
-\gdef\eatcr #1{\eatcra #1Q^^MQ}%
-\gdef\eatcra#1^^MQ{\eatcrb#1Q}%
-\gdef\eatcrb#1Q#2Q{#1}%
-}
-
-% Macro bodies are absorbed as an argument in a context where
-% all characters are catcode 10, 11 or 12, except \ which is active
-% (as in normal texinfo). It is necessary to change the definition of \.
-
-% It's necessary to have hard CRs when the macro is executed. This is
-% done by  making ^^M (\endlinechar) catcode 12 when reading the macro
-% body, and then making it the \newlinechar in \scanmacro.
-
-\def\macrobodyctxt{%
-  \catcode`\~=12
-  \catcode`\^=12
-  \catcode`\_=12
-  \catcode`\|=12
-  \catcode`\<=12
-  \catcode`\>=12
-  \catcode`\+=12
-  \catcode`\{=12
-  \catcode`\}=12
-  \catcode`\@=12
-  \catcode`\^^M=12
-  \usembodybackslash}
-
-\def\macroargctxt{%
-  \catcode`\~=12
-  \catcode`\^=12
-  \catcode`\_=12
-  \catcode`\|=12
-  \catcode`\<=12
-  \catcode`\>=12
-  \catcode`\+=12
-  \catcode`\@=12
-  \catcode`\\=12}
-
-% \mbodybackslash is the definition of \ in @macro bodies.
-% It maps \foo\ => \csname macarg.foo\endcsname => #N
-% where N is the macro parameter number.
-% We define \csname macarg.\endcsname to be \realbackslash, so
-% \\ in macro replacement text gets you a backslash.
-
-{\catcode`@=0 @catcode`@\=@active
- @gdef@usembodybackslash{@let\=@mbodybackslash}
- @gdef@mbodybackslash#1\{@csname macarg.#1@endcsname}
-}
-\expandafter\def\csname macarg.\endcsname{\realbackslash}
-
-\def\macro{\recursivefalse\parsearg\macroxxx}
-\def\rmacro{\recursivetrue\parsearg\macroxxx}
-
-\def\macroxxx#1{%
-  \getargs{#1}%           now \macname is the macname and \argl the arglist
-  \ifx\argl\empty       % no arguments
-     \paramno=0%
-  \else
-     \expandafter\parsemargdef \argl;%
-  \fi
-  \if1\csname ismacro.\the\macname\endcsname
-     \message{Warning: redefining \the\macname}%
-  \else
-     \expandafter\ifx\csname \the\macname\endcsname \relax
-     \else \errmessage{The name \the\macname\space is reserved}\fi
-     \global\cslet{macsave.\the\macname}{\the\macname}%
-     \global\expandafter\let\csname ismacro.\the\macname\endcsname=1%
-     % Add the macroname to \macrolist
-     \toks0 = \expandafter{\macrolist\do}%
-     \xdef\macrolist{\the\toks0
-       \expandafter\noexpand\csname\the\macname\endcsname}%
-  \fi
-  \begingroup \macrobodyctxt
-  \ifrecursive \expandafter\parsermacbody
-  \else \expandafter\parsemacbody
-  \fi}
-
-\def\unmacro{\parsearg\unmacroxxx}
-\def\unmacroxxx#1{%
-  \if1\csname ismacro.#1\endcsname
-    \global\cslet{#1}{macsave.#1}%
-    \global\expandafter\let \csname ismacro.#1\endcsname=0%
-    % Remove the macro name from \macrolist
-    \begingroup
-      \edef\tempa{\expandafter\noexpand\csname#1\endcsname}%
-      \def\do##1{%
-        \def\tempb{##1}%
-        \ifx\tempa\tempb
-          % remove this
-        \else
-          \toks0 = \expandafter{\newmacrolist\do}%
-          \edef\newmacrolist{\the\toks0\expandafter\noexpand\tempa}%
-        \fi}%
-      \def\newmacrolist{}%
-      % Execute macro list to define \newmacrolist
-      \macrolist
-      \global\let\macrolist\newmacrolist
-    \endgroup
-  \else
-    \errmessage{Macro #1 not defined}%
-  \fi
-}
-
-% This makes use of the obscure feature that if the last token of a
-% <parameter list> is #, then the preceding argument is delimited by
-% an opening brace, and that opening brace is not consumed.
-\def\getargs#1{\getargsxxx#1{}}
-\def\getargsxxx#1#{\getmacname #1 \relax\getmacargs}
-\def\getmacname #1 #2\relax{\macname={#1}}
-\def\getmacargs#1{\def\argl{#1}}
-
-% Parse the optional {params} list.  Set up \paramno and \paramlist
-% so \defmacro knows what to do.  Define \macarg.blah for each blah
-% in the params list, to be ##N where N is the position in that list.
-% That gets used by \mbodybackslash (above).
-
-% We need to get `macro parameter char #' into several definitions.
-% The technique used is stolen from LaTeX:  let \hash be something
-% unexpandable, insert that wherever you need a #, and then redefine
-% it to # just before using the token list produced.
-%
-% The same technique is used to protect \eatspaces till just before
-% the macro is used.
-
-\def\parsemargdef#1;{\paramno=0\def\paramlist{}%
-        \let\hash\relax\let\xeatspaces\relax\parsemargdefxxx#1,;,}
-\def\parsemargdefxxx#1,{%
-  \if#1;\let\next=\relax
-  \else \let\next=\parsemargdefxxx
-    \advance\paramno by 1%
-    \expandafter\edef\csname macarg.\eatspaces{#1}\endcsname
-        {\xeatspaces{\hash\the\paramno}}%
-    \edef\paramlist{\paramlist\hash\the\paramno,}%
-  \fi\next}
-
-% These two commands read recursive and nonrecursive macro bodies.
-% (They're different since rec and nonrec macros end differently.)
-
-\long\def\parsemacbody#1@end macro%
-{\xdef\temp{\eatcr{#1}}\endgroup\defmacro}%
-\long\def\parsermacbody#1@end rmacro%
-{\xdef\temp{\eatcr{#1}}\endgroup\defmacro}%
-
-% This defines the macro itself. There are six cases: recursive and
-% nonrecursive macros of zero, one, and many arguments.
-% Much magic with \expandafter here.
-% \xdef is used so that macro definitions will survive the file
-% they're defined in; @include reads the file inside a group.
-\def\defmacro{%
-  \let\hash=##% convert placeholders to macro parameter chars
-  \ifrecursive
-    \ifcase\paramno
-    % 0
-      \expandafter\xdef\csname\the\macname\endcsname{%
-        \noexpand\scanmacro{\temp}}%
-    \or % 1
-      \expandafter\xdef\csname\the\macname\endcsname{%
-         \bgroup\noexpand\macroargctxt
-         \noexpand\braceorline
-         \expandafter\noexpand\csname\the\macname xxx\endcsname}%
-      \expandafter\xdef\csname\the\macname xxx\endcsname##1{%
-         \egroup\noexpand\scanmacro{\temp}}%
-    \else % many
-      \expandafter\xdef\csname\the\macname\endcsname{%
-         \bgroup\noexpand\macroargctxt
-         \noexpand\csname\the\macname xx\endcsname}%
-      \expandafter\xdef\csname\the\macname xx\endcsname##1{%
-          \expandafter\noexpand\csname\the\macname xxx\endcsname ##1,}%
-      \expandafter\expandafter
-      \expandafter\xdef
-      \expandafter\expandafter
-        \csname\the\macname xxx\endcsname
-          \paramlist{\egroup\noexpand\scanmacro{\temp}}%
-    \fi
-  \else
-    \ifcase\paramno
-    % 0
-      \expandafter\xdef\csname\the\macname\endcsname{%
-        \noexpand\norecurse{\the\macname}%
-        \noexpand\scanmacro{\temp}\egroup}%
-    \or % 1
-      \expandafter\xdef\csname\the\macname\endcsname{%
-         \bgroup\noexpand\macroargctxt
-         \noexpand\braceorline
-         \expandafter\noexpand\csname\the\macname xxx\endcsname}%
-      \expandafter\xdef\csname\the\macname xxx\endcsname##1{%
-        \egroup
-        \noexpand\norecurse{\the\macname}%
-        \noexpand\scanmacro{\temp}\egroup}%
-    \else % many
-      \expandafter\xdef\csname\the\macname\endcsname{%
-         \bgroup\noexpand\macroargctxt
-         \expandafter\noexpand\csname\the\macname xx\endcsname}%
-      \expandafter\xdef\csname\the\macname xx\endcsname##1{%
-          \expandafter\noexpand\csname\the\macname xxx\endcsname ##1,}%
-      \expandafter\expandafter
-      \expandafter\xdef
-      \expandafter\expandafter
-      \csname\the\macname xxx\endcsname
-      \paramlist{%
-          \egroup
-          \noexpand\norecurse{\the\macname}%
-          \noexpand\scanmacro{\temp}\egroup}%
-    \fi
-  \fi}
-
-\def\norecurse#1{\bgroup\cslet{#1}{macsave.#1}}
-
-% \braceorline decides whether the next nonwhitespace character is a
-% {.  If so it reads up to the closing }, if not, it reads the whole
-% line.  Whatever was read is then fed to the next control sequence
-% as an argument (by \parsebrace or \parsearg)
-\def\braceorline#1{\let\next=#1\futurelet\nchar\braceorlinexxx}
-\def\braceorlinexxx{%
-  \ifx\nchar\bgroup\else
-    \expandafter\parsearg
-  \fi \next}
-
-% We mant to disable all macros during \shipout so that they are not
-% expanded by \write.
-\def\turnoffmacros{\begingroup \def\do##1{\let\noexpand##1=\relax}%
-  \edef\next{\macrolist}\expandafter\endgroup\next}
-
-
-% @alias.
-% We need some trickery to remove the optional spaces around the equal
-% sign.  Just make them active and then expand them all to nothing.
-\def\alias{\begingroup\obeyspaces\parsearg\aliasxxx}
-\def\aliasxxx #1{\aliasyyy#1\relax}
-\def\aliasyyy #1=#2\relax{\ignoreactivespaces
-\edef\next{\global\let\expandafter\noexpand\csname#1\endcsname=%
-           \expandafter\noexpand\csname#2\endcsname}%
-\expandafter\endgroup\next}
-
-
-\message{cross references,}
-% @xref etc.
-
-\newwrite\auxfile
-
-\newif\ifhavexrefs    % True if xref values are known.
-\newif\ifwarnedxrefs  % True if we warned once that they aren't known.
-
-% @inforef is relatively simple.
-\def\inforef #1{\inforefzzz #1,,,,**}
-\def\inforefzzz #1,#2,#3,#4**{\putwordSee{} \putwordInfo{} \putwordfile{} \file{\ignorespaces #3{}},
-  node \samp{\ignorespaces#1{}}}
-
-% @node's job is to define \lastnode.
-\def\node{\ENVcheck\parsearg\nodezzz}
-\def\nodezzz#1{\nodexxx [#1,]}
-\def\nodexxx[#1,#2]{\gdef\lastnode{#1}}
-\let\nwnode=\node
-\let\lastnode=\relax
-
-% The sectioning commands (@chapter, etc.) call these.
-\def\donoderef{%
-  \ifx\lastnode\relax\else
-    \expandafter\expandafter\expandafter\setref{\lastnode}%
-      {Ysectionnumberandtype}%
-    \global\let\lastnode=\relax
-  \fi
-}
-\def\unnumbnoderef{%
-  \ifx\lastnode\relax\else
-    \expandafter\expandafter\expandafter\setref{\lastnode}{Ynothing}%
-    \global\let\lastnode=\relax
-  \fi
-}
-\def\appendixnoderef{%
-  \ifx\lastnode\relax\else
-    \expandafter\expandafter\expandafter\setref{\lastnode}%
-      {Yappendixletterandtype}%
-    \global\let\lastnode=\relax
-  \fi
-}
-
-
-% @anchor{NAME} -- define xref target at arbitrary point.
-%
-\newcount\savesfregister
-\gdef\savesf{\relax \ifhmode \savesfregister=\spacefactor \fi}
-\gdef\restoresf{\relax \ifhmode \spacefactor=\savesfregister \fi}
-\gdef\anchor#1{\savesf \setref{#1}{Ynothing}\restoresf \ignorespaces}
-
-% \setref{NAME}{SNT} defines a cross-reference point NAME, namely
-% NAME-title, NAME-pg, and NAME-SNT.  Called from \foonoderef.  We have
-% to set \indexdummies so commands such as @code in a section title
-% aren't expanded.  It would be nicer not to expand the titles in the
-% first place, but there's so many layers that that is hard to do.
-%
-\def\setref#1#2{{%
-  \indexdummies
-  \pdfmkdest{#1}%
-  \dosetq{#1-title}{Ytitle}%
-  \dosetq{#1-pg}{Ypagenumber}%
-  \dosetq{#1-snt}{#2}%
-}}
-
-% @xref, @pxref, and @ref generate cross-references.  For \xrefX, #1 is
-% the node name, #2 the name of the Info cross-reference, #3 the printed
-% node name, #4 the name of the Info file, #5 the name of the printed
-% manual.  All but the node name can be omitted.
-%
-\def\pxref#1{\putwordsee{} \xrefX[#1,,,,,,,]}
-\def\xref#1{\putwordSee{} \xrefX[#1,,,,,,,]}
-\def\ref#1{\xrefX[#1,,,,,,,]}
-\def\xrefX[#1,#2,#3,#4,#5,#6]{\begingroup
-  \unsepspaces
-  \def\printedmanual{\ignorespaces #5}%
-  \def\printednodename{\ignorespaces #3}%
-  \setbox1=\hbox{\printedmanual}%
-  \setbox0=\hbox{\printednodename}%
-  \ifdim \wd0 = 0pt
-    % No printed node name was explicitly given.
-    \expandafter\ifx\csname SETxref-automatic-section-title\endcsname\relax
-      % Use the node name inside the square brackets.
-      \def\printednodename{\ignorespaces #1}%
-    \else
-      % Use the actual chapter/section title appear inside
-      % the square brackets.  Use the real section title if we have it.
-      \ifdim \wd1 > 0pt
-        % It is in another manual, so we don't have it.
-        \def\printednodename{\ignorespaces #1}%
-      \else
-        \ifhavexrefs
-          % We know the real title if we have the xref values.
-          \def\printednodename{\refx{#1-title}{}}%
-        \else
-          % Otherwise just copy the Info node name.
-          \def\printednodename{\ignorespaces #1}%
-        \fi%
-      \fi
-    \fi
-  \fi
-  %
-  % If we use \unhbox0 and \unhbox1 to print the node names, TeX does not
-  % insert empty discretionaries after hyphens, which means that it will
-  % not find a line break at a hyphen in a node names.  Since some manuals
-  % are best written with fairly long node names, containing hyphens, this
-  % is a loss.  Therefore, we give the text of the node name again, so it
-  % is as if TeX is seeing it for the first time.
-  \ifpdf
-    \leavevmode
-    \getfilename{#4}%
-    \ifnum\filenamelength>0
-      \startlink attr{/Border [0 0 0]}%
-        goto file{\the\filename.pdf} name{#1@}%
-    \else
-      \startlink attr{/Border [0 0 0]}%
-        goto name{#1@}%
-    \fi
-    \linkcolor
-  \fi
-  %
-  \ifdim \wd1 > 0pt
-    \putwordsection{} ``\printednodename'' \putwordin{} \cite{\printedmanual}%
-  \else
-    % _ (for example) has to be the character _ for the purposes of the
-    % control sequence corresponding to the node, but it has to expand
-    % into the usual \leavevmode...\vrule stuff for purposes of
-    % printing. So we \turnoffactive for the \refx-snt, back on for the
-    % printing, back off for the \refx-pg.
-    {\normalturnoffactive
-     % Only output a following space if the -snt ref is nonempty; for
-     % @unnumbered and @anchor, it won't be.
-     \setbox2 = \hbox{\ignorespaces \refx{#1-snt}{}}%
-     \ifdim \wd2 > 0pt \refx{#1-snt}\space\fi
-    }%
-    % [mynode],
-    [\printednodename],\space
-    % page 3
-    \turnoffactive \putwordpage\tie\refx{#1-pg}{}%
-  \fi
-  \endlink
-\endgroup}
-
-% \dosetq is the interface for calls from other macros
-
-% Use \normalturnoffactive so that punctuation chars such as underscore
-% and backslash work in node names.  (\turnoffactive doesn't do \.)
-\def\dosetq#1#2{%
-  {\let\folio=0%
-   \normalturnoffactive
-   \edef\next{\write\auxfile{\internalsetq{#1}{#2}}}%
-   \iflinks
-     \next
-   \fi
-  }%
-}
-
-% \internalsetq {foo}{page} expands into
-% CHARACTERS 'xrdef {foo}{...expansion of \Ypage...}
-% When the aux file is read, ' is the escape character
-
-\def\internalsetq #1#2{'xrdef {#1}{\csname #2\endcsname}}
-
-% Things to be expanded by \internalsetq
-
-\def\Ypagenumber{\folio}
-
-\def\Ytitle{\thissection}
-
-\def\Ynothing{}
-
-\def\Ysectionnumberandtype{%
-\ifnum\secno=0 \putwordChapter\xreftie\the\chapno %
-\else \ifnum \subsecno=0 \putwordSection\xreftie\the\chapno.\the\secno %
-\else \ifnum \subsubsecno=0 %
-\putwordSection\xreftie\the\chapno.\the\secno.\the\subsecno %
-\else %
-\putwordSection\xreftie\the\chapno.\the\secno.\the\subsecno.\the\subsubsecno %
-\fi \fi \fi }
-
-\def\Yappendixletterandtype{%
-\ifnum\secno=0 \putwordAppendix\xreftie'char\the\appendixno{}%
-\else \ifnum \subsecno=0 \putwordSection\xreftie'char\the\appendixno.\the\secno %
-\else \ifnum \subsubsecno=0 %
-\putwordSection\xreftie'char\the\appendixno.\the\secno.\the\subsecno %
-\else %
-\putwordSection\xreftie'char\the\appendixno.\the\secno.\the\subsecno.\the\subsubsecno %
-\fi \fi \fi }
-
-\gdef\xreftie{'tie}
-
-% Use TeX 3.0's \inputlineno to get the line number, for better error
-% messages, but if we're using an old version of TeX, don't do anything.
-%
-\ifx\inputlineno\thisisundefined
-  \let\linenumber = \empty % Non-3.0.
-\else
-  \def\linenumber{\the\inputlineno:\space}
-\fi
-
-% Define \refx{NAME}{SUFFIX} to reference a cross-reference string named NAME.
-% If its value is nonempty, SUFFIX is output afterward.
-
-\def\refx#1#2{%
-  \expandafter\ifx\csname X#1\endcsname\relax
-    % If not defined, say something at least.
-    \angleleft un\-de\-fined\angleright
-    \iflinks
-      \ifhavexrefs
-        \message{\linenumber Undefined cross reference `#1'.}%
-      \else
-        \ifwarnedxrefs\else
-          \global\warnedxrefstrue
-          \message{Cross reference values unknown; you must run TeX again.}%
-        \fi
-      \fi
-    \fi
-  \else
-    % It's defined, so just use it.
-    \csname X#1\endcsname
-  \fi
-  #2% Output the suffix in any case.
-}
-
-% This is the macro invoked by entries in the aux file.
-%
-\def\xrdef#1{\begingroup
-  % Reenable \ as an escape while reading the second argument.
-  \catcode`\\ = 0
-  \afterassignment\endgroup
-  \expandafter\gdef\csname X#1\endcsname
-}
-
-% Read the last existing aux file, if any.  No error if none exists.
-\def\readauxfile{\begingroup
-  \catcode`\^^@=\other
-  \catcode`\^^A=\other
-  \catcode`\^^B=\other
-  \catcode`\^^C=\other
-  \catcode`\^^D=\other
-  \catcode`\^^E=\other
-  \catcode`\^^F=\other
-  \catcode`\^^G=\other
-  \catcode`\^^H=\other
-  \catcode`\^^K=\other
-  \catcode`\^^L=\other
-  \catcode`\^^N=\other
-  \catcode`\^^P=\other
-  \catcode`\^^Q=\other
-  \catcode`\^^R=\other
-  \catcode`\^^S=\other
-  \catcode`\^^T=\other
-  \catcode`\^^U=\other
-  \catcode`\^^V=\other
-  \catcode`\^^W=\other
-  \catcode`\^^X=\other
-  \catcode`\^^Z=\other
-  \catcode`\^^[=\other
-  \catcode`\^^\=\other
-  \catcode`\^^]=\other
-  \catcode`\^^^=\other
-  \catcode`\^^_=\other
-  \catcode`\@=\other
-  \catcode`\^=\other
-  % It was suggested to define this as 7, which would allow ^^e4 etc.
-  % in xref tags, i.e., node names.  But since ^^e4 notation isn't
-  % supported in the main text, it doesn't seem desirable.  Furthermore,
-  % that is not enough: for node names that actually contain a ^
-  % character, we would end up writing a line like this: 'xrdef {'hat
-  % b-title}{'hat b} and \xrdef does a \csname...\endcsname on the first
-  % argument, and \hat is not an expandable control sequence.  It could
-  % all be worked out, but why?  Either we support ^^ or we don't.
-  %
-  % The other change necessary for this was to define \auxhat:
-  % \def\auxhat{\def^{'hat }}% extra space so ok if followed by letter
-  % and then to call \auxhat in \setq.
-  %
-  \catcode`\~=\other
-  \catcode`\[=\other
-  \catcode`\]=\other
-  \catcode`\"=\other
-  \catcode`\_=\other
-  \catcode`\|=\other
-  \catcode`\<=\other
-  \catcode`\>=\other
-  \catcode`\$=\other
-  \catcode`\#=\other
-  \catcode`\&=\other
-  \catcode`+=\other % avoid \+ for paranoia even though we've turned it off
-  % Make the characters 128-255 be printing characters
-  {%
-    \count 1=128
-    \def\loop{%
-      \catcode\count 1=\other
-      \advance\count 1 by 1
-      \ifnum \count 1<256 \loop \fi
-    }%
-  }%
-  % The aux file uses ' as the escape (for now).
-  % Turn off \ as an escape so we do not lose on
-  % entries which were dumped with control sequences in their names.
-  % For example, 'xrdef {$\leq $-fun}{page ...} made by @defun ^^
-  % Reference to such entries still does not work the way one would wish,
-  % but at least they do not bomb out when the aux file is read in.
-  \catcode`\{=1
-  \catcode`\}=2
-  \catcode`\%=\other
-  \catcode`\'=0
-  \catcode`\\=\other
-  %
-  \openin 1 \jobname.aux
-  \ifeof 1 \else
-    \closein 1
-    \input \jobname.aux
-    \global\havexrefstrue
-    \global\warnedobstrue
-  \fi
-  % Open the new aux file.  TeX will close it automatically at exit.
-  \openout\auxfile=\jobname.aux
-\endgroup}
-
-
-% Footnotes.
-
-\newcount \footnoteno
-
-% The trailing space in the following definition for supereject is
-% vital for proper filling; pages come out unaligned when you do a
-% pagealignmacro call if that space before the closing brace is
-% removed. (Generally, numeric constants should always be followed by a
-% space to prevent strange expansion errors.)
-\def\supereject{\par\penalty -20000\footnoteno =0 }
-
-% @footnotestyle is meaningful for info output only.
-\let\footnotestyle=\comment
-
-\let\ptexfootnote=\footnote
-
-{\catcode `\@=11
-%
-% Auto-number footnotes.  Otherwise like plain.
-\gdef\footnote{%
-  \global\advance\footnoteno by \@ne
-  \edef\thisfootno{$^{\the\footnoteno}$}%
-  %
-  % In case the footnote comes at the end of a sentence, preserve the
-  % extra spacing after we do the footnote number.
-  \let\@sf\empty
-  \ifhmode\edef\@sf{\spacefactor\the\spacefactor}\/\fi
-  %
-  % Remove inadvertent blank space before typesetting the footnote number.
-  \unskip
-  \thisfootno\@sf
-  \footnotezzz
-}%
-
-% Don't bother with the trickery in plain.tex to not require the
-% footnote text as a parameter.  Our footnotes don't need to be so general.
-%
-% Oh yes, they do; otherwise, @ifset and anything else that uses
-% \parseargline fail inside footnotes because the tokens are fixed when
-% the footnote is read.  --karl, 16nov96.
-%
-\long\gdef\footnotezzz{\insert\footins\bgroup
-  % We want to typeset this text as a normal paragraph, even if the
-  % footnote reference occurs in (for example) a display environment.
-  % So reset some parameters.
-  \interlinepenalty\interfootnotelinepenalty
-  \splittopskip\ht\strutbox % top baseline for broken footnotes
-  \splitmaxdepth\dp\strutbox
-  \floatingpenalty\@MM
-  \leftskip\z@skip
-  \rightskip\z@skip
-  \spaceskip\z@skip
-  \xspaceskip\z@skip
-  \parindent\defaultparindent
-  %
-  \smallfonts \rm
-  %
-  % Hang the footnote text off the number.
-  \hang
-  \textindent{\thisfootno}%
-  %
-  % Don't crash into the line above the footnote text.  Since this
-  % expands into a box, it must come within the paragraph, lest it
-  % provide a place where TeX can split the footnote.
-  \footstrut
-  \futurelet\next\fo@t
-}
-\def\fo@t{\ifcat\bgroup\noexpand\next \let\next\f@@t
-  \else\let\next\f@t\fi \next}
-\def\f@@t{\bgroup\aftergroup\@foot\let\next}
-\def\f@t#1{#1\@foot}
-\def\@foot{\strut\par\egroup}
-
-}%end \catcode `\@=11
-
-% Set the baselineskip to #1, and the lineskip and strut size
-% correspondingly.  There is no deep meaning behind these magic numbers
-% used as factors; they just match (closely enough) what Knuth defined.
-%
-\def\lineskipfactor{.08333}
-\def\strutheightpercent{.70833}
-\def\strutdepthpercent {.29167}
-%
-\def\setleading#1{%
-  \normalbaselineskip = #1\relax
-  \normallineskip = \lineskipfactor\normalbaselineskip
-  \normalbaselines
-  \setbox\strutbox =\hbox{%
-    \vrule width0pt height\strutheightpercent\baselineskip
-                    depth \strutdepthpercent \baselineskip
-  }%
-}
-
-% @| inserts a changebar to the left of the current line.  It should
-% surround any changed text.  This approach does *not* work if the
-% change spans more than two lines of output.  To handle that, we would
-% have adopt a much more difficult approach (putting marks into the main
-% vertical list for the beginning and end of each change).
-%
-\def\|{%
-  % \vadjust can only be used in horizontal mode.
-  \leavevmode
-  %
-  % Append this vertical mode material after the current line in the output.
-  \vadjust{%
-    % We want to insert a rule with the height and depth of the current
-    % leading; that is exactly what \strutbox is supposed to record.
-    \vskip-\baselineskip
-    %
-    % \vadjust-items are inserted at the left edge of the type.  So
-    % the \llap here moves out into the left-hand margin.
-    \llap{%
-      %
-      % For a thicker or thinner bar, change the `1pt'.
-      \vrule height\baselineskip width1pt
-      %
-      % This is the space between the bar and the text.
-      \hskip 12pt
-    }%
-  }%
-}
-
-% For a final copy, take out the rectangles
-% that mark overfull boxes (in case you have decided
-% that the text looks ok even though it passes the margin).
-%
-\def\finalout{\overfullrule=0pt}
-
-% @image.  We use the macros from epsf.tex to support this.
-% If epsf.tex is not installed and @image is used, we complain.
-%
-% Check for and read epsf.tex up front.  If we read it only at @image
-% time, we might be inside a group, and then its definitions would get
-% undone and the next image would fail.
-\openin 1 = epsf.tex
-\ifeof 1 \else
-  \closein 1
-  % Do not bother showing banner with post-v2.7 epsf.tex (available in
-  % doc/epsf.tex until it shows up on ctan).
-  \def\epsfannounce{\toks0 = }%
-  \input epsf.tex
-\fi
-%
-% We will only complain once about lack of epsf.tex.
-\newif\ifwarnednoepsf
-\newhelp\noepsfhelp{epsf.tex must be installed for images to
-  work.  It is also included in the Texinfo distribution, or you can get
-  it from ftp://tug.org/tex/epsf.tex.}
-%
-\def\image#1{%
-  \ifx\epsfbox\undefined
-    \ifwarnednoepsf \else
-      \errhelp = \noepsfhelp
-      \errmessage{epsf.tex not found, images will be ignored}%
-      \global\warnednoepsftrue
-    \fi
-  \else
-    \imagexxx #1,,,\finish
-  \fi
-}
-%
-% Arguments to @image:
-% #1 is (mandatory) image filename; we tack on .eps extension.
-% #2 is (optional) width, #3 is (optional) height.
-% #4 is just the usual extra ignored arg for parsing this stuff.
-\def\imagexxx#1,#2,#3,#4\finish{%
-  \ifpdf
-    \centerline{\dopdfimage{#1}{#2}{#3}}%
-  \else
-    % \epsfbox itself resets \epsf?size at each figure.
-    \setbox0 = \hbox{\ignorespaces #2}\ifdim\wd0 > 0pt \epsfxsize=#2\relax \fi
-    \setbox0 = \hbox{\ignorespaces #3}\ifdim\wd0 > 0pt \epsfysize=#3\relax \fi
-    \begingroup
-      \catcode`\^^M = 5 % in case we're inside an example
-      % If the image is by itself, center it.
-      \ifvmode
-        \nobreak\bigskip
-        % Usually we'll have text after the image which will insert
-        % \parskip glue, so insert it here too to equalize the space
-        % above and below. 
-        \nobreak\vskip\parskip
-        \nobreak
-        \centerline{\epsfbox{#1.eps}}%
-        \bigbreak
-      \else
-        % In the middle of a paragraph, no extra space.
-        \epsfbox{#1.eps}%
-      \fi
-    \endgroup
-  \fi
-}
-
-
-\message{localization,}
-% and i18n.
-
-% @documentlanguage is usually given very early, just after
-% @setfilename.  If done too late, it may not override everything
-% properly.  Single argument is the language abbreviation.
-% It would be nice if we could set up a hyphenation file here.
-%
-\def\documentlanguage{\parsearg\dodocumentlanguage}
-\def\dodocumentlanguage#1{%
-  \tex % read txi-??.tex file in plain TeX.
-  % Read the file if it exists.
-  \openin 1 txi-#1.tex
-  \ifeof1
-    \errhelp = \nolanghelp
-    \errmessage{Cannot read language file txi-#1.tex}%
-    \let\temp = \relax
-  \else
-    \def\temp{\input txi-#1.tex }%
-  \fi
-  \temp
-  \endgroup
-}
-\newhelp\nolanghelp{The given language definition file cannot be found or
-is empty.  Maybe you need to install it?  In the current directory
-should work if nowhere else does.}
-
-
-% @documentencoding should change something in TeX eventually, most
-% likely, but for now just recognize it.
-\let\documentencoding = \comment
-
-
-% Page size parameters.
-%
-\newdimen\defaultparindent \defaultparindent = 15pt
-
-\chapheadingskip = 15pt plus 4pt minus 2pt
-\secheadingskip = 12pt plus 3pt minus 2pt
-\subsecheadingskip = 9pt plus 2pt minus 2pt
-
-% Prevent underfull vbox error messages.
-\vbadness = 10000
-
-% Don't be so finicky about underfull hboxes, either.
-\hbadness = 2000
-
-% Following George Bush, just get rid of widows and orphans.
-\widowpenalty=10000
-\clubpenalty=10000
-
-% Use TeX 3.0's \emergencystretch to help line breaking, but if we're
-% using an old version of TeX, don't do anything.  We want the amount of
-% stretch added to depend on the line length, hence the dependence on
-% \hsize.  We call this whenever the paper size is set.
-%
-\def\setemergencystretch{%
-  \ifx\emergencystretch\thisisundefined
-    % Allow us to assign to \emergencystretch anyway.
-    \def\emergencystretch{\dimen0}%
-  \else
-    \emergencystretch = .15\hsize
-  \fi
-}
-
-% Parameters in order: 1) textheight; 2) textwidth; 3) voffset;
-% 4) hoffset; 5) binding offset; 6) topskip.  Then whoever calls us can
-% set \parskip and call \setleading for \baselineskip.
-%
-\def\internalpagesizes#1#2#3#4#5#6{%
-  \voffset = #3\relax
-  \topskip = #6\relax
-  \splittopskip = \topskip
-  %
-  \vsize = #1\relax
-  \advance\vsize by \topskip
-  \outervsize = \vsize
-  \advance\outervsize by 2\topandbottommargin
-  \pageheight = \vsize
-  %
-  \hsize = #2\relax
-  \outerhsize = \hsize
-  \advance\outerhsize by 0.5in
-  \pagewidth = \hsize
-  %
-  \normaloffset = #4\relax
-  \bindingoffset = #5\relax
-  %
-  \parindent = \defaultparindent
-  \setemergencystretch
-}
-
-% @letterpaper (the default).
-\def\letterpaper{{\globaldefs = 1
-  \parskip = 3pt plus 2pt minus 1pt
-  \setleading{13.2pt}%
-  %
-  % If page is nothing but text, make it come out even.
-  \internalpagesizes{46\baselineskip}{6in}{\voffset}{.25in}{\bindingoffset}{36pt}%
-}}
-
-% Use @smallbook to reset parameters for 7x9.5 (or so) format.
-\def\smallbook{{\globaldefs = 1
-  \parskip = 2pt plus 1pt
-  \setleading{12pt}%
-  %
-  \internalpagesizes{7.5in}{5.in}{\voffset}{.25in}{\bindingoffset}{16pt}%
-  %
-  \lispnarrowing = 0.3in
-  \tolerance = 700
-  \hfuzz = 1pt
-  \contentsrightmargin = 0pt
-  \deftypemargin = 0pt
-  \defbodyindent = .5cm
-  %
-  \let\smalldisplay = \smalldisplayx
-  \let\smallexample = \smalllispx
-  \let\smallformat = \smallformatx
-  \let\smalllisp = \smalllispx
-}}
-
-% Use @afourpaper to print on European A4 paper.
-\def\afourpaper{{\globaldefs = 1
-  \setleading{12pt}%
-  \parskip = 3pt plus 2pt minus 1pt
-  %
-  \internalpagesizes{53\baselineskip}{160mm}{\voffset}{4mm}{\bindingoffset}{44pt}%
-  %
-  \tolerance = 700
-  \hfuzz = 1pt
-}}
-
-% A specific text layout, 24x15cm overall, intended for A4 paper.  Top margin
-% 29mm, hence bottom margin 28mm, nominal side margin 3cm.
-\def\afourlatex{{\globaldefs = 1
-  \setleading{13.6pt}%
-  %
-  \afourpaper
-  \internalpagesizes{237mm}{150mm}{3.6mm}{3.6mm}{3mm}{7mm}%
-  %
-  \globaldefs = 0
-}}
-
-% Use @afourwide to print on European A4 paper in wide format.
-\def\afourwide{%
-  \afourpaper
-  \internalpagesizes{9.5in}{6.5in}{\hoffset}{\normaloffset}{\bindingoffset}{7mm}%
-  %
-  \globaldefs = 0
-}
-
-% @pagesizes TEXTHEIGHT[,TEXTWIDTH]
-% Perhaps we should allow setting the margins, \topskip, \parskip,
-% and/or leading, also. Or perhaps we should compute them somehow.
-%
-\def\pagesizes{\parsearg\pagesizesxxx}
-\def\pagesizesxxx#1{\pagesizesyyy #1,,\finish}
-\def\pagesizesyyy#1,#2,#3\finish{{%
-  \setbox0 = \hbox{\ignorespaces #2}\ifdim\wd0 > 0pt \hsize=#2\relax \fi
-  \globaldefs = 1
-  %
-  \parskip = 3pt plus 2pt minus 1pt
-  \setleading{13.2pt}%
-  %
-  \internalpagesizes{#1}{\hsize}{\voffset}{\normaloffset}{\bindingoffset}{44pt}%
-}}
-
-% Set default to letter.
-%
-\letterpaper
-
-
-\message{and turning on texinfo input format.}
-
-% Define macros to output various characters with catcode for normal text.
-\catcode`\"=\other
-\catcode`\~=\other
-\catcode`\^=\other
-\catcode`\_=\other
-\catcode`\|=\other
-\catcode`\<=\other
-\catcode`\>=\other
-\catcode`\+=\other
-\catcode`\$=\other
-\def\normaldoublequote{"}
-\def\normaltilde{~}
-\def\normalcaret{^}
-\def\normalunderscore{_}
-\def\normalverticalbar{|}
-\def\normalless{<}
-\def\normalgreater{>}
-\def\normalplus{+}
-\def\normaldollar{$}
-
-% This macro is used to make a character print one way in ttfont
-% where it can probably just be output, and another way in other fonts,
-% where something hairier probably needs to be done.
-%
-% #1 is what to print if we are indeed using \tt; #2 is what to print
-% otherwise.  Since all the Computer Modern typewriter fonts have zero
-% interword stretch (and shrink), and it is reasonable to expect all
-% typewriter fonts to have this, we can check that font parameter.
-%
-\def\ifusingtt#1#2{\ifdim \fontdimen3\font=0pt #1\else #2\fi}
-
-% Same as above, but check for italic font.  Actually this also catches
-% non-italic slanted fonts since it is impossible to distinguish them from
-% italic fonts.  But since this is only used by $ and it uses \sl anyway
-% this is not a problem.
-\def\ifusingit#1#2{\ifdim \fontdimen1\font>0pt #1\else #2\fi}
-
-% Turn off all special characters except @
-% (and those which the user can use as if they were ordinary).
-% Most of these we simply print from the \tt font, but for some, we can
-% use math or other variants that look better in normal text.
-
-\catcode`\"=\active
-\def\activedoublequote{{\tt\char34}}
-\let"=\activedoublequote
-\catcode`\~=\active
-\def~{{\tt\char126}}
-\chardef\hat=`\^
-\catcode`\^=\active
-\def^{{\tt \hat}}
-
-\catcode`\_=\active
-\def_{\ifusingtt\normalunderscore\_}
-% Subroutine for the previous macro.
-\def\_{\leavevmode \kern.06em \vbox{\hrule width.3em height.1ex}}
-
-\catcode`\|=\active
-\def|{{\tt\char124}}
-\chardef \less=`\<
-\catcode`\<=\active
-\def<{{\tt \less}}
-\chardef \gtr=`\>
-\catcode`\>=\active
-\def>{{\tt \gtr}}
-\catcode`\+=\active
-\def+{{\tt \char 43}}
-\catcode`\$=\active
-\def${\ifusingit{{\sl\$}}\normaldollar}
-%\catcode 27=\active
-%\def^^[{$\diamondsuit$}
-
-% Set up an active definition for =, but don't enable it most of the time.
-{\catcode`\==\active
-\global\def={{\tt \char 61}}}
-
-\catcode`+=\active
-\catcode`\_=\active
-
-% If a .fmt file is being used, characters that might appear in a file
-% name cannot be active until we have parsed the command line.
-% So turn them off again, and have \everyjob (or @setfilename) turn them on.
-% \otherifyactive is called near the end of this file.
-\def\otherifyactive{\catcode`+=\other \catcode`\_=\other}
-
-\catcode`\@=0
-
-% \rawbackslashxx output one backslash character in current font
-\global\chardef\rawbackslashxx=`\\
-%{\catcode`\\=\other
-%@gdef@rawbackslashxx{\}}
-
-% \rawbackslash redefines \ as input to do \rawbackslashxx.
-{\catcode`\\=\active
-@gdef@rawbackslash{@let\=@rawbackslashxx }}
-
-% \normalbackslash outputs one backslash in fixed width font.
-\def\normalbackslash{{\tt\rawbackslashxx}}
-
-% \catcode 17=0   % Define control-q
-\catcode`\\=\active
-
-% Used sometimes to turn off (effectively) the active characters
-% even after parsing them.
-@def@turnoffactive{@let"=@normaldoublequote
-@let\=@realbackslash
-@let~=@normaltilde
-@let^=@normalcaret
-@let_=@normalunderscore
-@let|=@normalverticalbar
-@let<=@normalless
-@let>=@normalgreater
-@let+=@normalplus
-@let$=@normaldollar}
-
-@def@normalturnoffactive{@let"=@normaldoublequote
-@let\=@normalbackslash
-@let~=@normaltilde
-@let^=@normalcaret
-@let_=@normalunderscore
-@let|=@normalverticalbar
-@let<=@normalless
-@let>=@normalgreater
-@let+=@normalplus
-@let$=@normaldollar}
-
-% Make _ and + \other characters, temporarily.
-% This is canceled by @fixbackslash.
-@otherifyactive
-
-% If a .fmt file is being used, we don't want the `\input texinfo' to show up.
-% That is what \eatinput is for; after that, the `\' should revert to printing
-% a backslash.
-%
-@gdef@eatinput input texinfo{@fixbackslash}
-@global@let\ = @eatinput
-
-% On the other hand, perhaps the file did not have a `\input texinfo'. Then
-% the first `\{ in the file would cause an error. This macro tries to fix
-% that, assuming it is called before the first `\' could plausibly occur.
-% Also back turn on active characters that might appear in the input
-% file name, in case not using a pre-dumped format.
-%
-@gdef@fixbackslash{%
-  @ifx\@eatinput @let\ = @normalbackslash @fi
-  @catcode`+=@active
-  @catcode`@_=@active
-}
-
-% Say @foo, not \foo, in error messages.
-@escapechar = `@@
-
-% These look ok in all fonts, so just make them not special.  
-@catcode`@& = @other
-@catcode`@# = @other
-@catcode`@% = @other
-
-@c Set initial fonts.
-@textfonts
-@rm
-
-
-@c Local variables:
-@c eval: (add-hook 'write-file-hooks 'time-stamp)
-@c page-delimiter: "^\\\\message"
-@c time-stamp-start: "def\\\\texinfoversion{"
-@c time-stamp-format: "%:y-%02m-%02d.%02H"
-@c time-stamp-end: "}"
-@c End:
diff --git a/readline/emacs_keymap.c b/readline/emacs_keymap.c
deleted file mode 100644
--- a/readline/emacs_keymap.c
+++ /dev/null
@@ -1,873 +0,0 @@
-/* emacs_keymap.c -- the keymap for emacs_mode in readline (). */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (BUFSIZ)
-#include <stdio.h>
-#endif /* !BUFSIZ */
-
-#include "readline.h"
-
-/* An array of function pointers, one for each possible key.
-   If the type byte is ISKMAP, then the pointer is the address of
-   a keymap. */
-
-KEYMAP_ENTRY_ARRAY emacs_standard_keymap = {
-
-  /* Control keys. */
-  { ISFUNC, rl_set_mark },			/* Control-@ */
-  { ISFUNC, rl_beg_of_line },			/* Control-a */
-  { ISFUNC, rl_backward },			/* Control-b */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
-  { ISFUNC, rl_delete },			/* Control-d */
-  { ISFUNC, rl_end_of_line },			/* Control-e */
-  { ISFUNC, rl_forward },			/* Control-f */
-  { ISFUNC, rl_abort },				/* Control-g */
-  { ISFUNC, rl_rubout },			/* Control-h */
-  { ISFUNC, rl_complete },			/* Control-i */
-  { ISFUNC, rl_newline },			/* Control-j */
-  { ISFUNC, rl_kill_line },			/* Control-k */
-  { ISFUNC, rl_clear_screen },			/* Control-l */
-  { ISFUNC, rl_newline },			/* Control-m */
-  { ISFUNC, rl_get_next_history },		/* Control-n */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
-  { ISFUNC, rl_get_previous_history },		/* Control-p */
-  { ISFUNC, rl_quoted_insert },			/* Control-q */
-  { ISFUNC, rl_reverse_search_history },	/* Control-r */
-  { ISFUNC, rl_forward_search_history },	/* Control-s */
-  { ISFUNC, rl_transpose_chars },		/* Control-t */
-  { ISFUNC, rl_unix_line_discard },		/* Control-u */
-  { ISFUNC, rl_quoted_insert },			/* Control-v */
-  { ISFUNC, rl_unix_word_rubout },		/* Control-w */
-  { ISKMAP, (rl_command_func_t *)emacs_ctlx_keymap },	/* Control-x */
-  { ISFUNC, rl_yank },				/* Control-y */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
-  { ISKMAP, (rl_command_func_t *)emacs_meta_keymap }, /* Control-[ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
-  { ISFUNC, rl_char_search },			/* Control-] */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
-  { ISFUNC, rl_undo_command },			/* Control-_ */
-
-  /* The start of printing characters. */
-  { ISFUNC, rl_insert },		/* SPACE */
-  { ISFUNC, rl_insert },		/* ! */
-  { ISFUNC, rl_insert },		/* " */
-  { ISFUNC, rl_insert },		/* # */
-  { ISFUNC, rl_insert },		/* $ */
-  { ISFUNC, rl_insert },		/* % */
-  { ISFUNC, rl_insert },		/* & */
-  { ISFUNC, rl_insert },		/* ' */
-  { ISFUNC, rl_insert },		/* ( */
-  { ISFUNC, rl_insert },		/* ) */
-  { ISFUNC, rl_insert },		/* * */
-  { ISFUNC, rl_insert },		/* + */
-  { ISFUNC, rl_insert },		/* , */
-  { ISFUNC, rl_insert },		/* - */
-  { ISFUNC, rl_insert },		/* . */
-  { ISFUNC, rl_insert },		/* / */
-	
-	  /* Regular digits. */
-  { ISFUNC, rl_insert },		/* 0 */
-  { ISFUNC, rl_insert },		/* 1 */
-  { ISFUNC, rl_insert },		/* 2 */
-  { ISFUNC, rl_insert },		/* 3 */
-  { ISFUNC, rl_insert },		/* 4 */
-  { ISFUNC, rl_insert },		/* 5 */
-  { ISFUNC, rl_insert },		/* 6 */
-  { ISFUNC, rl_insert },		/* 7 */
-  { ISFUNC, rl_insert },		/* 8 */
-  { ISFUNC, rl_insert },		/* 9 */
-
-  /* A little more punctuation. */
-  { ISFUNC, rl_insert },		/* : */
-  { ISFUNC, rl_insert },		/* ; */
-  { ISFUNC, rl_insert },		/* < */
-  { ISFUNC, rl_insert },		/* = */
-  { ISFUNC, rl_insert },		/* > */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* @ */
-
-  /* Uppercase alphabet. */
-  { ISFUNC, rl_insert },		/* A */
-  { ISFUNC, rl_insert },		/* B */
-  { ISFUNC, rl_insert },		/* C */
-  { ISFUNC, rl_insert },		/* D */
-  { ISFUNC, rl_insert },		/* E */
-  { ISFUNC, rl_insert },		/* F */
-  { ISFUNC, rl_insert },		/* G */
-  { ISFUNC, rl_insert },		/* H */
-  { ISFUNC, rl_insert },		/* I */
-  { ISFUNC, rl_insert },		/* J */
-  { ISFUNC, rl_insert },		/* K */
-  { ISFUNC, rl_insert },		/* L */
-  { ISFUNC, rl_insert },		/* M */
-  { ISFUNC, rl_insert },		/* N */
-  { ISFUNC, rl_insert },		/* O */
-  { ISFUNC, rl_insert },		/* P */
-  { ISFUNC, rl_insert },		/* Q */
-  { ISFUNC, rl_insert },		/* R */
-  { ISFUNC, rl_insert },		/* S */
-  { ISFUNC, rl_insert },		/* T */
-  { ISFUNC, rl_insert },		/* U */
-  { ISFUNC, rl_insert },		/* V */
-  { ISFUNC, rl_insert },		/* W */
-  { ISFUNC, rl_insert },		/* X */
-  { ISFUNC, rl_insert },		/* Y */
-  { ISFUNC, rl_insert },		/* Z */
-
-  /* Some more punctuation. */
-  { ISFUNC, rl_insert },		/* [ */
-  { ISFUNC, rl_insert },		/* \ */
-  { ISFUNC, rl_insert },		/* ] */
-  { ISFUNC, rl_insert },		/* ^ */
-  { ISFUNC, rl_insert },		/* _ */
-  { ISFUNC, rl_insert },		/* ` */
-
-  /* Lowercase alphabet. */
-  { ISFUNC, rl_insert },		/* a */
-  { ISFUNC, rl_insert },		/* b */
-  { ISFUNC, rl_insert },		/* c */
-  { ISFUNC, rl_insert },		/* d */
-  { ISFUNC, rl_insert },		/* e */
-  { ISFUNC, rl_insert },		/* f */
-  { ISFUNC, rl_insert },		/* g */
-  { ISFUNC, rl_insert },		/* h */
-  { ISFUNC, rl_insert },		/* i */
-  { ISFUNC, rl_insert },		/* j */
-  { ISFUNC, rl_insert },		/* k */
-  { ISFUNC, rl_insert },		/* l */
-  { ISFUNC, rl_insert },		/* m */
-  { ISFUNC, rl_insert },		/* n */
-  { ISFUNC, rl_insert },		/* o */
-  { ISFUNC, rl_insert },		/* p */
-  { ISFUNC, rl_insert },		/* q */
-  { ISFUNC, rl_insert },		/* r */
-  { ISFUNC, rl_insert },		/* s */
-  { ISFUNC, rl_insert },		/* t */
-  { ISFUNC, rl_insert },		/* u */
-  { ISFUNC, rl_insert },		/* v */
-  { ISFUNC, rl_insert },		/* w */
-  { ISFUNC, rl_insert },		/* x */
-  { ISFUNC, rl_insert },		/* y */
-  { ISFUNC, rl_insert },		/* z */
-
-  /* Final punctuation. */
-  { ISFUNC, rl_insert },		/* { */
-  { ISFUNC, rl_insert },		/* | */
-  { ISFUNC, rl_insert },		/* } */
-  { ISFUNC, rl_insert },		/* ~ */
-  { ISFUNC, rl_rubout },		/* RUBOUT */
-
-#if KEYMAP_SIZE > 128
-  /* Pure 8-bit characters (128 - 159).
-     These might be used in some
-     character sets. */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* ? */
-
-  /* ISO Latin-1 characters (160 - 255) */
-  { ISFUNC, rl_insert },	/* No-break space */
-  { ISFUNC, rl_insert },	/* Inverted exclamation mark */
-  { ISFUNC, rl_insert },	/* Cent sign */
-  { ISFUNC, rl_insert },	/* Pound sign */
-  { ISFUNC, rl_insert },	/* Currency sign */
-  { ISFUNC, rl_insert },	/* Yen sign */
-  { ISFUNC, rl_insert },	/* Broken bar */
-  { ISFUNC, rl_insert },	/* Section sign */
-  { ISFUNC, rl_insert },	/* Diaeresis */
-  { ISFUNC, rl_insert },	/* Copyright sign */
-  { ISFUNC, rl_insert },	/* Feminine ordinal indicator */
-  { ISFUNC, rl_insert },	/* Left pointing double angle quotation mark */
-  { ISFUNC, rl_insert },	/* Not sign */
-  { ISFUNC, rl_insert },	/* Soft hyphen */
-  { ISFUNC, rl_insert },	/* Registered sign */
-  { ISFUNC, rl_insert },	/* Macron */
-  { ISFUNC, rl_insert },	/* Degree sign */
-  { ISFUNC, rl_insert },	/* Plus-minus sign */
-  { ISFUNC, rl_insert },	/* Superscript two */
-  { ISFUNC, rl_insert },	/* Superscript three */
-  { ISFUNC, rl_insert },	/* Acute accent */
-  { ISFUNC, rl_insert },	/* Micro sign */
-  { ISFUNC, rl_insert },	/* Pilcrow sign */
-  { ISFUNC, rl_insert },	/* Middle dot */
-  { ISFUNC, rl_insert },	/* Cedilla */
-  { ISFUNC, rl_insert },	/* Superscript one */
-  { ISFUNC, rl_insert },	/* Masculine ordinal indicator */
-  { ISFUNC, rl_insert },	/* Right pointing double angle quotation mark */
-  { ISFUNC, rl_insert },	/* Vulgar fraction one quarter */
-  { ISFUNC, rl_insert },	/* Vulgar fraction one half */
-  { ISFUNC, rl_insert },	/* Vulgar fraction three quarters */
-  { ISFUNC, rl_insert },	/* Inverted questionk mark */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with tilde */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with ring above */
-  { ISFUNC, rl_insert },	/* Latin capital letter ae */
-  { ISFUNC, rl_insert },	/* Latin capital letter c with cedilla */
-  { ISFUNC, rl_insert },	/* Latin capital letter e with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter e with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter e with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter e with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin capital letter i with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter i with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter i with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter i with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin capital letter eth (Icelandic) */
-  { ISFUNC, rl_insert },	/* Latin capital letter n with tilde */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with tilde */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with diaeresis */
-  { ISFUNC, rl_insert },	/* Multiplication sign */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with stroke */
-  { ISFUNC, rl_insert },	/* Latin capital letter u with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter u with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter u with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter u with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin capital letter Y with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter thorn (Icelandic) */
-  { ISFUNC, rl_insert },	/* Latin small letter sharp s (German) */
-  { ISFUNC, rl_insert },	/* Latin small letter a with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter a with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter a with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter a with tilde */
-  { ISFUNC, rl_insert },	/* Latin small letter a with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin small letter a with ring above */
-  { ISFUNC, rl_insert },	/* Latin small letter ae */
-  { ISFUNC, rl_insert },	/* Latin small letter c with cedilla */
-  { ISFUNC, rl_insert },	/* Latin small letter e with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter e with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter e with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter e with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin small letter i with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter i with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter i with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter i with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin small letter eth (Icelandic) */
-  { ISFUNC, rl_insert },	/* Latin small letter n with tilde */
-  { ISFUNC, rl_insert },	/* Latin small letter o with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter o with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter o with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter o with tilde */
-  { ISFUNC, rl_insert },	/* Latin small letter o with diaeresis */
-  { ISFUNC, rl_insert },	/* Division sign */
-  { ISFUNC, rl_insert },	/* Latin small letter o with stroke */
-  { ISFUNC, rl_insert },	/* Latin small letter u with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter u with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter u with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter u with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin small letter y with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter thorn (Icelandic) */
-  { ISFUNC, rl_insert }		/* Latin small letter y with diaeresis */
-#endif /* KEYMAP_SIZE > 128 */
-};
-
-KEYMAP_ENTRY_ARRAY emacs_meta_keymap = {
-
-  /* Meta keys.  Just like above, but the high bit is set. */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-@ */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-a */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-b */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-c */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-d */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-e */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-f */
-  { ISFUNC, rl_abort },			/* Meta-Control-g */
-  { ISFUNC, rl_backward_kill_word },	/* Meta-Control-h */
-  { ISFUNC, rl_tab_insert },		/* Meta-Control-i */
-  { ISFUNC, rl_vi_editing_mode },	/* Meta-Control-j */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-k */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-l */
-  { ISFUNC, rl_vi_editing_mode }, 	/* Meta-Control-m */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-n */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-o */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-p */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-q */
-  { ISFUNC, rl_revert_line },		/* Meta-Control-r */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-s */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-t */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-u */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-v */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-w */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-x */
-  { ISFUNC, rl_yank_nth_arg },		/* Meta-Control-y */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-z */
-
-  { ISFUNC, rl_complete },		/* Meta-Control-[ */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-\ */
-  { ISFUNC, rl_backward_char_search },	/* Meta-Control-] */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-^ */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-_ */
-
-  /* The start of printing characters. */
-  { ISFUNC, rl_set_mark },		/* Meta-SPACE */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-! */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-" */
-  { ISFUNC, rl_insert_comment },	/* Meta-# */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-$ */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-% */
-  { ISFUNC, rl_tilde_expand },		/* Meta-& */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-' */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-( */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-) */
-  { ISFUNC, rl_insert_completions },	/* Meta-* */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-+ */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-, */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-- */
-  { ISFUNC, rl_yank_last_arg},		/* Meta-. */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-/ */
-
-  /* Regular digits. */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-0 */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-1 */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-2 */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-3 */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-4 */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-5 */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-6 */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-7 */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-8 */
-  { ISFUNC, rl_digit_argument }, 	/* Meta-9 */
-
-  /* A little more punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-: */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-; */
-  { ISFUNC, rl_beginning_of_history },	/* Meta-< */
-  { ISFUNC, rl_possible_completions },	/* Meta-= */
-  { ISFUNC, rl_end_of_history },	/* Meta-> */
-  { ISFUNC, rl_possible_completions },	/* Meta-? */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-@ */
-
-  /* Uppercase alphabet. */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-A */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-B */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-C */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-D */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-E */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-F */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-G */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-H */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-I */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-J */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-K */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-L */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-M */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-N */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-O */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-P */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-Q */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-R */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-S */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-T */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-U */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-V */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-W */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-X */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-Y */
-  { ISFUNC, rl_do_lowercase_version },	/* Meta-Z */
-
-  /* Some more punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-[ */	/* was rl_arrow_keys */
-  { ISFUNC, rl_delete_horizontal_space },	/* Meta-\ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-] */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-^ */
-  { ISFUNC, rl_yank_last_arg },			/* Meta-_ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-` */
-
-  /* Lowercase alphabet. */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-a */
-  { ISFUNC, rl_backward_word },		/* Meta-b */
-  { ISFUNC, rl_capitalize_word }, 	/* Meta-c */
-  { ISFUNC, rl_kill_word },		/* Meta-d */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-e */
-  { ISFUNC, rl_forward_word },		/* Meta-f */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-g */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-h */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-i */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-j */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-k */
-  { ISFUNC, rl_downcase_word },		/* Meta-l */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-m */
-  { ISFUNC, rl_noninc_forward_search },	/* Meta-n */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-o */	/* was rl_arrow_keys */
-  { ISFUNC, rl_noninc_reverse_search },	/* Meta-p */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-q */
-  { ISFUNC, rl_revert_line },		/* Meta-r */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-s */
-  { ISFUNC, rl_transpose_words }, 	/* Meta-t */
-  { ISFUNC, rl_upcase_word },		/* Meta-u */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-v */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-w */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-x */
-  { ISFUNC, rl_yank_pop },		/* Meta-y */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-z */
-
-  /* Final punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-{ */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-| */
-  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-} */
-  { ISFUNC, rl_tilde_expand },		/* Meta-~ */
-  { ISFUNC, rl_backward_kill_word },	/* Meta-rubout */
-
-#if KEYMAP_SIZE > 128
-  /* Undefined keys. */
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 }
-#endif /* KEYMAP_SIZE > 128 */
-};
-
-KEYMAP_ENTRY_ARRAY emacs_ctlx_keymap = {
-
-  /* Control keys. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-d */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-e */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
-  { ISFUNC, rl_abort },				/* Control-g */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-h */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-j */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-k */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-l */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-m */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-n */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-p */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-q */
-  { ISFUNC, rl_re_read_init_file },		/* Control-r */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-s */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-t */
-  { ISFUNC, rl_undo_command },			/* Control-u */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-v */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-w */
-  { ISFUNC, rl_exchange_point_and_mark },	/* Control-x */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-y */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-[ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-_ */
-
-  /* The start of printing characters. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* SPACE */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* # */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* $ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* % */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* & */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
-  { ISFUNC, rl_start_kbd_macro },		/* ( */
-  { ISFUNC, rl_end_kbd_macro  },		/* ) */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* * */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* + */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* , */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* - */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* . */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* / */
-
-  /* Regular digits. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 0 */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 1 */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 2 */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 3 */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 4 */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 5 */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 6 */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 7 */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 8 */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* 9 */
-
-  /* A little more punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ; */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* = */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ? */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
-
-  /* Uppercase alphabet. */
-  { ISFUNC, rl_do_lowercase_version },		/* A */
-  { ISFUNC, rl_do_lowercase_version },		/* B */
-  { ISFUNC, rl_do_lowercase_version },		/* C */
-  { ISFUNC, rl_do_lowercase_version },		/* D */
-  { ISFUNC, rl_do_lowercase_version },		/* E */
-  { ISFUNC, rl_do_lowercase_version },		/* F */
-  { ISFUNC, rl_do_lowercase_version },		/* G */
-  { ISFUNC, rl_do_lowercase_version },		/* H */
-  { ISFUNC, rl_do_lowercase_version },		/* I */
-  { ISFUNC, rl_do_lowercase_version },		/* J */
-  { ISFUNC, rl_do_lowercase_version },		/* K */
-  { ISFUNC, rl_do_lowercase_version },		/* L */
-  { ISFUNC, rl_do_lowercase_version },		/* M */
-  { ISFUNC, rl_do_lowercase_version },		/* N */
-  { ISFUNC, rl_do_lowercase_version },		/* O */
-  { ISFUNC, rl_do_lowercase_version },		/* P */
-  { ISFUNC, rl_do_lowercase_version },		/* Q */
-  { ISFUNC, rl_do_lowercase_version },		/* R */
-  { ISFUNC, rl_do_lowercase_version },		/* S */
-  { ISFUNC, rl_do_lowercase_version },		/* T */
-  { ISFUNC, rl_do_lowercase_version },		/* U */
-  { ISFUNC, rl_do_lowercase_version },		/* V */
-  { ISFUNC, rl_do_lowercase_version },		/* W */
-  { ISFUNC, rl_do_lowercase_version },		/* X */
-  { ISFUNC, rl_do_lowercase_version },		/* Y */
-  { ISFUNC, rl_do_lowercase_version },		/* Z */
-
-  /* Some more punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* [ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* \ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ^ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* _ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ` */
-
-  /* Lowercase alphabet. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* a */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* b */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* c */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* d */
-  { ISFUNC, rl_call_last_kbd_macro },		/* e */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* f */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* h */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* i */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* j */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* k */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* l */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* m */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* n */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* p */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* r */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* s */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* t */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* u */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* w */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* x */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* y */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
-
-  /* Final punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* | */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ~ */
-  { ISFUNC, rl_backward_kill_line },		/* RUBOUT */
-
-#if KEYMAP_SIZE > 128
-  /* Undefined keys. */
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 }
-#endif /* KEYMAP_SIZE > 128 */
-};
diff --git a/readline/examples/Inputrc b/readline/examples/Inputrc
deleted file mode 100644
--- a/readline/examples/Inputrc
+++ /dev/null
@@ -1,65 +0,0 @@
-# My ~/.inputrc file is in -*- text -*- for easy editing with Emacs.
-#
-# Notice the various bindings which are conditionalized depending
-# on which program is running, or what terminal is active.
-#
-
-# In all programs, all terminals, make sure this is bound.
-"\C-x\C-r": re-read-init-file
-
-# Hp terminals (and some others) have ugly default behaviour for C-h.
-"\C-h": backward-delete-char
-"\e\C-h": backward-kill-word
-"\C-xd": dump-functions
-
-# In xterm windows, make the arrow keys do the right thing.
-$if TERM=xterm
-"\e[A": previous-history
-"\e[B": next-history
-"\e[C": forward-char
-"\e[D": backward-char
-
-# alternate arrow key prefix
-"\eOA": previous-history
-"\eOB": next-history
-"\eOC": forward-char
-"\eOD": backward-char
-
-# Under Xterm in Bash, we bind local Function keys to do something useful.
-$if Bash
-"\e[11~": "Function Key 1"
-"\e[12~": "Function Key 2"
-"\e[13~": "Function Key 3"
-"\e[14~": "Function Key 4"
-"\e[15~": "Function Key 5"
-
-# I know the following escape sequence numbers are 1 greater than
-# the function key.  Don't ask me why, I didn't design the xterm terminal.
-"\e[17~": "Function Key 6"
-"\e[18~": "Function Key 7"
-"\e[19~": "Function Key 8"
-"\e[20~": "Function Key 9"
-"\e[21~": "Function Key 10"
-$endif
-$endif
-
-# For Bash, all terminals, add some Bash specific hacks.
-$if Bash
-"\C-xv": show-bash-version
-"\C-x\C-e": shell-expand-line
-
-# Here is one for editing my path.
-"\C-xp": "$PATH\C-x\C-e\C-e\"\C-aPATH=\":\C-b"
-
-# Make C-x r read my mail in emacs.
-# "\C-xr": "emacs -f rmail\C-j"
-$endif
-
-# For FTP, different hacks:
-$if Ftp
-"\C-xg": "get \M-?"
-"\C-xt": "put \M-?"
-"\M-.": yank-last-arg
-$endif
-
-" ": self-insert
diff --git a/readline/examples/Makefile.in b/readline/examples/Makefile.in
deleted file mode 100644
--- a/readline/examples/Makefile.in
+++ /dev/null
@@ -1,98 +0,0 @@
-#
-# This is the Makefile for the readline examples subdirectory.
-#
-# Copyright (C) 1994 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-RL_LIBRARY_VERSION = @LIBVERSION@
-
-SHELL = @MAKE_SHELL@
-RM = rm -f
-
-srcdir = @srcdir@
-VPATH = .:@srcdir@
-top_srcdir = @top_srcdir@
-BUILD_DIR = .
-
-DEFS = @DEFS@
-CC = @CC@
-CFLAGS = @CFLAGS@
-LOCAL_CFLAGS = @LOCAL_CFLAGS@ -DREADLINE_LIBRARY -DRL_LIBRARY_VERSION='"$(RL_LIBRARY_VERSION)"'
-CPPFLAGS = @CPPFLAGS@
-
-INCLUDES = -I$(srcdir) -I$(top_srcdir) -I..
-
-CCFLAGS  = $(DEFS) $(LOCAL_CFLAGS) $(CPPFLAGS) $(INCLUDES) $(CFLAGS)
-LDFLAGS = -g -L..
-
-READLINE_LIB = ../libreadline.a
-HISTORY_LIB = ../libhistory.a
-
-TERMCAP_LIB = @TERMCAP_LIB@
-
-.c.o:
-	${RM} $@
-	$(CC) $(CCFLAGS) -c $<
-
-EXECUTABLES = fileman rltest rl rlversion histexamp
-OBJECTS = fileman.o rltest.o rl.o rlversion.o histexamp.o
-
-all: $(EXECUTABLES)
-everything: all rlfe
-
-rl: rl.o
-	$(CC) $(LDFLAGS) -o $@ rl.o -lreadline $(TERMCAP_LIB)
-
-fileman: fileman.o
-	$(CC) $(LDFLAGS) -o $@ fileman.o -lreadline $(TERMCAP_LIB)
-
-rltest: rltest.o
-	$(CC) $(LDFLAGS) -o $@ rltest.o -lreadline $(TERMCAP_LIB)
-
-rlversion: rlversion.o $(READLINE_LIB)
-	$(CC) $(LDFLAGS) -o $@ rlversion.o -lreadline $(TERMCAP_LIB)
-
-histexamp: histexamp.o $(HISTORY_LIB)
-	$(CC) $(LDFLAGS) -o $@ histexamp.o -lhistory $(TERMCAP_LIB)
-
-clean mostlyclean:
-	$(RM) $(OBJECTS)
-	$(RM) $(EXECUTABLES) *.exe
-	$(RM) rlfe.o rlfe
-
-distclean maintainer-clean: clean
-	$(RM) Makefile
-
-fileman.o: fileman.c
-rltest.o: rltest.c
-rl.o: rl.c
-rlversion.o: rlversion.c
-histexamp.o: histexamp.c
-
-fileman.o: $(top_srcdir)/readline.h
-rltest.o: $(top_srcdir)/readline.h
-rl.o: $(top_srcdir)/readline.h
-rlversion.o: $(top_srcdir)/readline.h
-histexamp.o: $(top_srcdir)/history.h
-
-# Stuff for Per Bothner's `rlfe' program
- 
-rlfe: rlfe.o $(READLINE_LIB) $(HISTORY_LIB)
-	$(CC) $(LDFLAGS) -o $@ rlfe.o -lreadline -lhistory ${TERMCAP_LIB}
-
-rlfe.o: rlfe.c
-
-rlfe.o: $(top_srcdir)/readline.h
-rlfe.o: $(top_srcdir)/history.h
diff --git a/readline/examples/excallback.c b/readline/examples/excallback.c
deleted file mode 100644
--- a/readline/examples/excallback.c
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
-From: Jeff Solomon <jsolomon@stanford.edu>
-Date: Fri,  9 Apr 1999 10:13:27 -0700 (PDT)
-To: chet@po.cwru.edu
-Subject: new readline example
-Message-ID: <14094.12094.527305.199695@mrclean.Stanford.EDU>
-
-Chet,
-
-I've been using readline 4.0. Specifically, I've been using the perl
-version Term::ReadLine::Gnu. It works great.
-
-Anyway, I've been playing around the alternate interface and I wanted
-to contribute a little C program, callback.c, to you that you could
-use as an example of the alternate interface in the /examples
-directory of the readline distribution.
-
-My example shows how, using the alternate interface, you can
-interactively change the prompt (which is very nice imo). Also, I
-point out that you must roll your own terminal setting when using the
-alternate interface because readline depreps (using your parlance) the
-terminal while in the user callback. I try to demostrate what I mean
-with an example. I've included the program below.
-
-To compile, I just put the program in the examples directory and made
-the appropriate changes to the EXECUTABLES and OBJECTS line and added
-an additional target 'callback'.
-
-I compiled on my Sun Solaris2.6 box using Sun's cc.
-
-Let me know what you think.
-
-Jeff
-*/
-
-#if defined (HAVE_CONFIG_H)
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <sys/types.h>
-
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-#include <termios.h>	/* xxx - should make this more general */
-
-#ifdef READLINE_LIBRARY
-#  include "readline.h"
-#else
-#  include <readline/readline.h>
-#endif
-
-/* This little examples demonstrates the alternate interface to using readline.
- * In the alternate interface, the user maintains control over program flow and
- * only calls readline when STDIN is readable. Using the alternate interface,
- * you can do anything else while still using readline (like talking to a
- * network or another program) without blocking.
- *
- * Specifically, this program highlights two importants features of the
- * alternate interface. The first is the ability to interactively change the
- * prompt, which can't be done using the regular interface since rl_prompt is
- * read-only.
- * 
- * The second feature really highlights a subtle point when using the alternate
- * interface. That is, readline will not alter the terminal when inside your
- * callback handler. So let's so, your callback executes a user command that
- * takes a non-trivial amount of time to complete (seconds). While your
- * executing the command, the user continues to type keystrokes and expects them
- * to be re-echoed on the new prompt when it returns. Unfortunately, the default
- * terminal configuration doesn't do this. After the prompt returns, the user
- * must hit one additional keystroke and then will see all of his previous
- * keystrokes. To illustrate this, compile and run this program. Type "sleep" at
- * the prompt and then type "bar" before the prompt returns (you have 3
- * seconds). Notice how "bar" is re-echoed on the prompt after the prompt
- * returns? This is what you expect to happen. Now comment out the 4 lines below
- * the line that says COMMENT LINE BELOW. Recompile and rerun the program and do
- * the same thing. When the prompt returns, you should not see "bar". Now type
- * "f", see how "barf" magically appears? This behavior is un-expected and not
- * desired.
- */
-
-void process_line(char *line);
-int  change_prompt(void);
-char *get_prompt(void);
-
-int prompt = 1;
-char prompt_buf[40], line_buf[256];
-tcflag_t old_lflag;
-cc_t     old_vtime;
-struct termios term;
-
-int 
-main()
-{
-    fd_set fds;
-
-    /* Adjust the terminal slightly before the handler is installed. Disable
-     * canonical mode processing and set the input character time flag to be
-     * non-blocking.
-     */
-    if( tcgetattr(STDIN_FILENO, &term) < 0 ) {
-        perror("tcgetattr");
-        exit(1);
-    }
-    old_lflag = term.c_lflag;
-    old_vtime = term.c_cc[VTIME];
-    term.c_lflag &= ~ICANON;
-    term.c_cc[VTIME] = 1;
-    /* COMMENT LINE BELOW - see above */
-    if( tcsetattr(STDIN_FILENO, TCSANOW, &term) < 0 ) {
-        perror("tcsetattr");
-        exit(1);
-    }
-
-    rl_add_defun("change-prompt", change_prompt, CTRL('t'));
-    rl_callback_handler_install(get_prompt(), process_line);
-
-    while(1) {
-      FD_ZERO(&fds);
-      FD_SET(fileno(stdin), &fds);
-
-      if( select(FD_SETSIZE, &fds, NULL, NULL, NULL) < 0) {
-        perror("select");
-        exit(1);
-      }
-
-      if( FD_ISSET(fileno(stdin), &fds) ) {
-        rl_callback_read_char();
-      }
-    }
-}
-
-void
-process_line(char *line)
-{
-  if( line == NULL ) {
-    fprintf(stderr, "\n", line);
-
-    /* reset the old terminal setting before exiting */
-    term.c_lflag     = old_lflag;
-    term.c_cc[VTIME] = old_vtime;
-    if( tcsetattr(STDIN_FILENO, TCSANOW, &term) < 0 ) {
-        perror("tcsetattr");
-        exit(1);
-    }
-    exit(0);
-  }
-
-  if( strcmp(line, "sleep") == 0 ) {
-    sleep(3);
-  } else {
-    fprintf(stderr, "|%s|\n", line);
-  }
-
-  free (line);
-}
-
-int
-change_prompt(void)
-{
-  /* toggle the prompt variable */
-  prompt = !prompt;
-
-  /* save away the current contents of the line */
-  strcpy(line_buf, rl_line_buffer);
-
-  /* install a new handler which will change the prompt and erase the current line */
-  rl_callback_handler_install(get_prompt(), process_line);
-
-  /* insert the old text on the new line */
-  rl_insert_text(line_buf);
-
-  /* redraw the current line - this is an undocumented function. It invokes the
-   * redraw-current-line command.
-   */
-  rl_refresh_line(0, 0);
-}
-
-char *
-get_prompt(void)
-{
-  /* The prompts can even be different lengths! */
-  sprintf(prompt_buf, "%s", 
-    prompt ? "Hit ctrl-t to toggle prompt> " : "Pretty cool huh?> ");
-  return prompt_buf;
-}
diff --git a/readline/examples/fileman.c b/readline/examples/fileman.c
deleted file mode 100644
--- a/readline/examples/fileman.c
+++ /dev/null
@@ -1,465 +0,0 @@
-/* fileman.c -- A tiny application which demonstrates how to use the
-   GNU Readline library.  This application interactively allows users
-   to manipulate files and their modes. */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-#ifdef HAVE_SYS_FILE_H
-#  include <sys/file.h>
-#endif
-#include <sys/stat.h>
-
-#ifdef HAVE_UNISTD_H
-#  include <unistd.h>
-#endif
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <errno.h>
-
-#if defined (HAVE_STRING_H)
-#  include <string.h>
-#else /* !HAVE_STRING_H */
-#  include <strings.h>
-#endif /* !HAVE_STRING_H */
-
-#ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-#endif
-
-#ifdef READLINE_LIBRARY
-#  include "readline.h"
-#  include "history.h"
-#else
-#  include <readline/readline.h>
-#  include <readline/history.h>
-#endif
-
-extern char *xmalloc ();
-
-/* The names of functions that actually do the manipulation. */
-int com_list __P((char *));
-int com_view __P((char *));
-int com_rename __P((char *));
-int com_stat __P((char *));
-int com_pwd __P((char *));
-int com_delete __P((char *));
-int com_help __P((char *));
-int com_cd __P((char *));
-int com_quit __P((char *));
-
-/* A structure which contains information on the commands this program
-   can understand. */
-
-typedef struct {
-  char *name;			/* User printable name of the function. */
-  rl_icpfunc_t *func;		/* Function to call to do the job. */
-  char *doc;			/* Documentation for this function.  */
-} COMMAND;
-
-COMMAND commands[] = {
-  { "cd", com_cd, "Change to directory DIR" },
-  { "delete", com_delete, "Delete FILE" },
-  { "help", com_help, "Display this text" },
-  { "?", com_help, "Synonym for `help'" },
-  { "list", com_list, "List files in DIR" },
-  { "ls", com_list, "Synonym for `list'" },
-  { "pwd", com_pwd, "Print the current working directory" },
-  { "quit", com_quit, "Quit using Fileman" },
-  { "rename", com_rename, "Rename FILE to NEWNAME" },
-  { "stat", com_stat, "Print out statistics on FILE" },
-  { "view", com_view, "View the contents of FILE" },
-  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
-};
-
-/* Forward declarations. */
-char *stripwhite ();
-COMMAND *find_command ();
-
-/* The name of this program, as taken from argv[0]. */
-char *progname;
-
-/* When non-zero, this global means the user is done using this program. */
-int done;
-
-char *
-dupstr (s)
-     char *s;
-{
-  char *r;
-
-  r = xmalloc (strlen (s) + 1);
-  strcpy (r, s);
-  return (r);
-}
-
-main (argc, argv)
-     int argc;
-     char **argv;
-{
-  char *line, *s;
-
-  progname = argv[0];
-
-  initialize_readline ();	/* Bind our completer. */
-
-  /* Loop reading and executing lines until the user quits. */
-  for ( ; done == 0; )
-    {
-      line = readline ("FileMan: ");
-
-      if (!line)
-        break;
-
-      /* Remove leading and trailing whitespace from the line.
-         Then, if there is anything left, add it to the history list
-         and execute it. */
-      s = stripwhite (line);
-
-      if (*s)
-        {
-          add_history (s);
-          execute_line (s);
-        }
-
-      free (line);
-    }
-  exit (0);
-}
-
-/* Execute a command line. */
-int
-execute_line (line)
-     char *line;
-{
-  register int i;
-  COMMAND *command;
-  char *word;
-
-  /* Isolate the command word. */
-  i = 0;
-  while (line[i] && whitespace (line[i]))
-    i++;
-  word = line + i;
-
-  while (line[i] && !whitespace (line[i]))
-    i++;
-
-  if (line[i])
-    line[i++] = '\0';
-
-  command = find_command (word);
-
-  if (!command)
-    {
-      fprintf (stderr, "%s: No such command for FileMan.\n", word);
-      return (-1);
-    }
-
-  /* Get argument to command, if any. */
-  while (whitespace (line[i]))
-    i++;
-
-  word = line + i;
-
-  /* Call the function. */
-  return ((*(command->func)) (word));
-}
-
-/* Look up NAME as the name of a command, and return a pointer to that
-   command.  Return a NULL pointer if NAME isn't a command name. */
-COMMAND *
-find_command (name)
-     char *name;
-{
-  register int i;
-
-  for (i = 0; commands[i].name; i++)
-    if (strcmp (name, commands[i].name) == 0)
-      return (&commands[i]);
-
-  return ((COMMAND *)NULL);
-}
-
-/* Strip whitespace from the start and end of STRING.  Return a pointer
-   into STRING. */
-char *
-stripwhite (string)
-     char *string;
-{
-  register char *s, *t;
-
-  for (s = string; whitespace (*s); s++)
-    ;
-    
-  if (*s == 0)
-    return (s);
-
-  t = s + strlen (s) - 1;
-  while (t > s && whitespace (*t))
-    t--;
-  *++t = '\0';
-
-  return s;
-}
-
-/* **************************************************************** */
-/*                                                                  */
-/*                  Interface to Readline Completion                */
-/*                                                                  */
-/* **************************************************************** */
-
-char *command_generator __P((const char *, int));
-char **fileman_completion __P((const char *, int, int));
-
-/* Tell the GNU Readline library how to complete.  We want to try to complete
-   on command names if this is the first word in the line, or on filenames
-   if not. */
-initialize_readline ()
-{
-  /* Allow conditional parsing of the ~/.inputrc file. */
-  rl_readline_name = "FileMan";
-
-  /* Tell the completer that we want a crack first. */
-  rl_attempted_completion_function = fileman_completion;
-}
-
-/* Attempt to complete on the contents of TEXT.  START and END bound the
-   region of rl_line_buffer that contains the word to complete.  TEXT is
-   the word to complete.  We can use the entire contents of rl_line_buffer
-   in case we want to do some simple parsing.  Return the array of matches,
-   or NULL if there aren't any. */
-char **
-fileman_completion (text, start, end)
-     const char *text;
-     int start, end;
-{
-  char **matches;
-
-  matches = (char **)NULL;
-
-  /* If this word is at the start of the line, then it is a command
-     to complete.  Otherwise it is the name of a file in the current
-     directory. */
-  if (start == 0)
-    matches = rl_completion_matches (text, command_generator);
-
-  return (matches);
-}
-
-/* Generator function for command completion.  STATE lets us know whether
-   to start from scratch; without any state (i.e. STATE == 0), then we
-   start at the top of the list. */
-char *
-command_generator (text, state)
-     const char *text;
-     int state;
-{
-  static int list_index, len;
-  char *name;
-
-  /* If this is a new word to complete, initialize now.  This includes
-     saving the length of TEXT for efficiency, and initializing the index
-     variable to 0. */
-  if (!state)
-    {
-      list_index = 0;
-      len = strlen (text);
-    }
-
-  /* Return the next name which partially matches from the command list. */
-  while (name = commands[list_index].name)
-    {
-      list_index++;
-
-      if (strncmp (name, text, len) == 0)
-        return (dupstr(name));
-    }
-
-  /* If no names matched, then return NULL. */
-  return ((char *)NULL);
-}
-
-/* **************************************************************** */
-/*                                                                  */
-/*                       FileMan Commands                           */
-/*                                                                  */
-/* **************************************************************** */
-
-/* String to pass to system ().  This is for the LIST, VIEW and RENAME
-   commands. */
-static char syscom[1024];
-
-/* List the file(s) named in arg. */
-com_list (arg)
-     char *arg;
-{
-  if (!arg)
-    arg = "";
-
-  sprintf (syscom, "ls -FClg %s", arg);
-  return (system (syscom));
-}
-
-com_view (arg)
-     char *arg;
-{
-  if (!valid_argument ("view", arg))
-    return 1;
-
-#if defined (__MSDOS__)
-  /* more.com doesn't grok slashes in pathnames */
-  sprintf (syscom, "less %s", arg);
-#else
-  sprintf (syscom, "more %s", arg);
-#endif
-  return (system (syscom));
-}
-
-com_rename (arg)
-     char *arg;
-{
-  too_dangerous ("rename");
-  return (1);
-}
-
-com_stat (arg)
-     char *arg;
-{
-  struct stat finfo;
-
-  if (!valid_argument ("stat", arg))
-    return (1);
-
-  if (stat (arg, &finfo) == -1)
-    {
-      perror (arg);
-      return (1);
-    }
-
-  printf ("Statistics for `%s':\n", arg);
-
-  printf ("%s has %d link%s, and is %d byte%s in length.\n",
-	  arg,
-          finfo.st_nlink,
-          (finfo.st_nlink == 1) ? "" : "s",
-          finfo.st_size,
-          (finfo.st_size == 1) ? "" : "s");
-  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
-  printf ("      Last access at: %s", ctime (&finfo.st_atime));
-  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
-  return (0);
-}
-
-com_delete (arg)
-     char *arg;
-{
-  too_dangerous ("delete");
-  return (1);
-}
-
-/* Print out help for ARG, or for all of the commands if ARG is
-   not present. */
-com_help (arg)
-     char *arg;
-{
-  register int i;
-  int printed = 0;
-
-  for (i = 0; commands[i].name; i++)
-    {
-      if (!*arg || (strcmp (arg, commands[i].name) == 0))
-        {
-          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
-          printed++;
-        }
-    }
-
-  if (!printed)
-    {
-      printf ("No commands match `%s'.  Possibilties are:\n", arg);
-
-      for (i = 0; commands[i].name; i++)
-        {
-          /* Print in six columns. */
-          if (printed == 6)
-            {
-              printed = 0;
-              printf ("\n");
-            }
-
-          printf ("%s\t", commands[i].name);
-          printed++;
-        }
-
-      if (printed)
-        printf ("\n");
-    }
-  return (0);
-}
-
-/* Change to the directory ARG. */
-com_cd (arg)
-     char *arg;
-{
-  if (chdir (arg) == -1)
-    {
-      perror (arg);
-      return 1;
-    }
-
-  com_pwd ("");
-  return (0);
-}
-
-/* Print out the current working directory. */
-com_pwd (ignore)
-     char *ignore;
-{
-  char dir[1024], *s;
-
-  s = getcwd (dir, sizeof(dir) - 1);
-  if (s == 0)
-    {
-      printf ("Error getting pwd: %s\n", dir);
-      return 1;
-    }
-
-  printf ("Current directory is %s\n", dir);
-  return 0;
-}
-
-/* The user wishes to quit using this program.  Just set DONE non-zero. */
-com_quit (arg)
-     char *arg;
-{
-  done = 1;
-  return (0);
-}
-
-/* Function which tells you that you can't do this. */
-too_dangerous (caller)
-     char *caller;
-{
-  fprintf (stderr,
-           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
-           caller);
-}
-
-/* Return non-zero if ARG is a valid argument for CALLER, else print
-   an error message and return zero. */
-int
-valid_argument (caller, arg)
-     char *caller, *arg;
-{
-  if (!arg || !*arg)
-    {
-      fprintf (stderr, "%s: Argument required.\n", caller);
-      return (0);
-    }
-
-  return (1);
-}
diff --git a/readline/examples/histexamp.c b/readline/examples/histexamp.c
deleted file mode 100644
--- a/readline/examples/histexamp.c
+++ /dev/null
@@ -1,92 +0,0 @@
-#include <stdio.h>
-
-#ifdef READLINE_LIBRARY
-#  include "history.h"
-#else
-#  include <readline/history.h>
-#endif
-
-main (argc, argv)
-     int argc;
-     char **argv;
-{
-  char line[1024], *t;
-  int len, done = 0;
-
-  line[0] = 0;
-
-  using_history ();
-  while (!done)
-    {
-      printf ("history$ ");
-      fflush (stdout);
-      t = fgets (line, sizeof (line) - 1, stdin);
-      if (t && *t)
-        {
-          len = strlen (t);
-          if (t[len - 1] == '\n')
-            t[len - 1] = '\0';
-        }
-
-      if (!t)
-        strcpy (line, "quit");
-
-      if (line[0])
-        {
-          char *expansion;
-          int result;
-
-          using_history ();
-
-          result = history_expand (line, &expansion);
-          if (result)
-            fprintf (stderr, "%s\n", expansion);
-
-          if (result < 0 || result == 2)
-            {
-              free (expansion);
-              continue;
-            }
-
-          add_history (expansion);
-          strncpy (line, expansion, sizeof (line) - 1);
-          free (expansion);
-        }
-
-      if (strcmp (line, "quit") == 0)
-        done = 1;
-      else if (strcmp (line, "save") == 0)
-        write_history ("history_file");
-      else if (strcmp (line, "read") == 0)
-        read_history ("history_file");
-      else if (strcmp (line, "list") == 0)
-        {
-          register HIST_ENTRY **the_list;
-          register int i;
-
-          the_list = history_list ();
-          if (the_list)
-            for (i = 0; the_list[i]; i++)
-              printf ("%d: %s\n", i + history_base, the_list[i]->line);
-        }
-      else if (strncmp (line, "delete", 6) == 0)
-        {
-          int which;
-          if ((sscanf (line + 6, "%d", &which)) == 1)
-            {
-              HIST_ENTRY *entry = remove_history (which);
-              if (!entry)
-                fprintf (stderr, "No such entry %d\n", which);
-              else
-                {
-                  free (entry->line);
-                  free (entry);
-                }
-            }
-          else
-            {
-              fprintf (stderr, "non-numeric arg given to `delete'\n");
-            }
-        }
-    }
-}
diff --git a/readline/examples/manexamp.c b/readline/examples/manexamp.c
deleted file mode 100644
--- a/readline/examples/manexamp.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/* manexamp.c -- The examples which appear in the documentation are here. */
-
-#include <stdio.h>
-#include <readline/readline.h>
-
-/* **************************************************************** */
-/*                                                                  */
-/*   			How to Emulate gets ()			    */
-/*                                                                  */
-/* **************************************************************** */
-
-/* A static variable for holding the line. */
-static char *line_read = (char *)NULL;
-
-/* Read a string, and return a pointer to it.  Returns NULL on EOF. */
-char *
-rl_gets ()
-{
-  /* If the buffer has already been allocated, return the memory
-     to the free pool. */
-  if (line_read)
-    {
-      free (line_read);
-      line_read = (char *)NULL;
-    }
-
-  /* Get a line from the user. */
-  line_read = readline ("");
-
-  /* If the line has any text in it, save it on the history. */
-  if (line_read && *line_read)
-    add_history (line_read);
-
-  return (line_read);
-}
-
-/* **************************************************************** */
-/*                                                                  */
-/*        Writing a Function to be Called by Readline.              */
-/*                                                                  */
-/* **************************************************************** */
-
-/* Invert the case of the COUNT following characters. */
-invert_case_line (count, key)
-     int count, key;
-{
-  register int start, end;
-
-  start = rl_point;
-
-  if (count < 0)
-    {
-      direction = -1;
-      count = -count;
-    }
-  else
-    direction = 1;
-      
-  /* Find the end of the range to modify. */
-  end = start + (count * direction);
-
-  /* Force it to be within range. */
-  if (end > rl_end)
-    end = rl_end;
-  else if (end < 0)
-    end = -1;
-
-  if (start > end)
-    {
-      int temp = start;
-      start = end;
-      end = temp;
-    }
-
-  if (start == end)
-    return;
-
-  /* Tell readline that we are modifying the line, so save the undo
-     information. */
-  rl_modifying (start, end);
-
-  for (; start != end; start += direction)
-    {
-      if (_rl_uppercase_p (rl_line_buffer[start]))
-	rl_line_buffer[start] = _rl_to_lower (rl_line_buffer[start]);
-      else if (_rl_lowercase_p (rl_line_buffer[start]))
-	rl_line_buffer[start] = _rl_to_upper (rl_line_buffer[start]);
-    }
-
-  /* Move point to on top of the last character changed. */
-  rl_point = end - direction;
-}
diff --git a/readline/examples/rl.c b/readline/examples/rl.c
deleted file mode 100644
--- a/readline/examples/rl.c
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * rl - command-line interface to read a line from the standard input
- *      (or another fd) using readline.
- *
- * usage: rl [-p prompt] [-u unit] [-d default] [-n nchars]
- */
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-#include <sys/types.h>
-#include "posixstat.h"
-
-#if defined (READLINE_LIBRARY)
-#  include "readline.h"
-#  include "history.h"
-#else
-#  include <readline/readline.h>
-#  include <readline/history.h>
-#endif
-
-extern int optind;
-extern char *optarg;
-
-#if !defined (strchr) && !defined (__STDC__)
-extern char *strrchr();
-#endif
-
-static char *progname;
-static char *deftext;
-
-static int
-set_deftext ()
-{
-  if (deftext)
-    {
-      rl_insert_text (deftext);
-      deftext = (char *)NULL;
-      rl_startup_hook = (rl_hook_func_t *)NULL;
-    }
-  return 0;
-}
-
-static void
-usage()
-{
-  fprintf (stderr, "%s: usage: %s [-p prompt] [-u unit] [-d default] [-n nchars]\n",
-		progname, progname);
-}
-
-int
-main (argc, argv)
-     int argc;
-     char **argv;
-{
-  char *temp, *prompt;
-  struct stat sb;
-  int opt, fd, nch;
-  FILE *ifp;
-
-  progname = strrchr(argv[0], '/');
-  if (progname == 0)
-    progname = argv[0];
-  else
-    progname++;
-
-  /* defaults */
-  prompt = "readline$ ";
-  fd = nch = 0;
-  deftext = (char *)0;
-
-  while ((opt = getopt(argc, argv, "p:u:d:n:")) != EOF)
-    {
-      switch (opt)
-	{
-	case 'p':
-	  prompt = optarg;
-	  break;
-	case 'u':
-	  fd = atoi(optarg);
-	  if (fd < 0)
-	    {
-	      fprintf (stderr, "%s: bad file descriptor `%s'\n", progname, optarg);
-	      exit (2);
-	    }
-	  break;
-	case 'd':
-	  deftext = optarg;
-	  break;
-	case 'n':
-	  nch = atoi(optarg);
-	  if (nch < 0)
-	    {
-	      fprintf (stderr, "%s: bad value for -n: `%s'\n", progname, optarg);
-	      exit (2);
-	    }
-	  break;
-	default:
-	  usage ();
-	  exit (2);
-	}
-    }
-
-  if (fd != 0)
-    {
-      if (fstat (fd, &sb) < 0)
-	{
-	  fprintf (stderr, "%s: %d: bad file descriptor\n", progname, fd);
-	  exit (1);
-	}
-      ifp = fdopen (fd, "r");
-      rl_instream = ifp;
-    }
-
-  if (deftext && *deftext)
-    rl_startup_hook = set_deftext;
-
-  if (nch > 0)
-    rl_num_chars_to_read = nch;
-
-  temp = readline (prompt);
-
-  /* Test for EOF. */
-  if (temp == 0)
-    exit (1);
-
-  printf ("%s\n", temp);
-  exit (0);
-}
diff --git a/readline/examples/rlfe.c b/readline/examples/rlfe.c
deleted file mode 100644
--- a/readline/examples/rlfe.c
+++ /dev/null
@@ -1,1042 +0,0 @@
-/* A front-end using readline to "cook" input lines for Kawa.
- *
- * Copyright (C) 1999  Per Bothner
- * 
- * This front-end program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * Some code from Johnson & Troan: "Linux Application Development"
- * (Addison-Wesley, 1998) was used directly or for inspiration.
- */
-
-/* PROBLEMS/TODO:
- *
- * Only tested under Linux;  needs to be ported.
- *
- * When running mc -c under the Linux console, mc does not recognize
- * mouse clicks, which mc does when not running under fep.
- *
- * Pasting selected text containing tabs is like hitting the tab character,
- * which invokes readline completion.  We don't want this.  I don't know
- * if this is fixable without integrating fep into a terminal emulator.
- *
- * Echo suppression is a kludge, but can only be avoided with better kernel
- * support: We need a tty mode to disable "real" echoing, while still
- * letting the inferior think its tty driver to doing echoing.
- * Stevens's book claims SCR$ and BSD4.3+ have TIOCREMOTE.
- *
- * The latest readline may have some hooks we can use to avoid having
- * to back up the prompt.
- *
- * Desirable readline feature:  When in cooked no-echo mode (e.g. password),
- * echo characters are they are types with '*', but remove them when done.
- *
- * A synchronous output while we're editing an input line should be
- * inserted in the output view *before* the input line, so that the
- * lines being edited (with the prompt) float at the end of the input.
- *
- * A "page mode" option to emulate more/less behavior:  At each page of
- * output, pause for a user command.  This required parsing the output
- * to keep track of line lengths.  It also requires remembering the
- * output, if we want an option to scroll back, which suggests that
- * this should be integrated with a terminal emulator like xterm.
- */
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <signal.h>
-#include <netdb.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <grp.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <sys/ioctl.h>
-#include <termios.h>
-#include <limits.h>
-#include <dirent.h>
-
-#ifdef READLINE_LIBRARY
-#  include "readline.h"
-#  include "history.h"
-#else
-#  include <readline/readline.h>
-#  include <readline/history.h>
-#endif
-
-#ifndef COMMAND
-#define COMMAND "/bin/sh"
-#endif
-#ifndef COMMAND_ARGS
-#define COMMAND_ARGS COMMAND
-#endif
-
-#ifndef HAVE_MEMMOVE
-#ifndef memmove
-#  if __GNUC__ > 1
-#    define memmove(d, s, n)	__builtin_memcpy(d, s, n)
-#  else
-#    define memmove(d, s, n)	memcpy(d, s, n)
-#  endif
-#else
-#  define memmove(d, s, n)	memcpy(d, s, n)
-#endif
-#endif
-
-#define APPLICATION_NAME "Rlfe"
-
-#ifndef errno
-extern int errno;
-#endif
-
-extern int optind;
-extern char *optarg;
-
-static char *progname;
-static char *progversion;
-
-static int in_from_inferior_fd;
-static int out_to_inferior_fd;
-
-/* Unfortunately, we cannot safely display echo from the inferior process.
-   The reason is that the echo bit in the pty is "owned" by the inferior,
-   and if we try to turn it off, we could confuse the inferior.
-   Thus, when echoing, we get echo twice:  First readline echoes while
-   we're actually editing. Then we send the line to the inferior, and the
-   terminal driver send back an extra echo.
-   The work-around is to remember the input lines, and when we see that
-   line come back, we supress the output.
-   A better solution (supposedly available on SVR4) would be a smarter
-   terminal driver, with more flags ... */
-#define ECHO_SUPPRESS_MAX 1024
-char echo_suppress_buffer[ECHO_SUPPRESS_MAX];
-int echo_suppress_start = 0;
-int echo_suppress_limit = 0;
-
-/* #define DEBUG */
-
-static FILE *logfile = NULL;
-
-#ifdef DEBUG
-FILE *debugfile = NULL;
-#define DPRINT0(FMT) (fprintf(debugfile, FMT), fflush(debugfile))
-#define DPRINT1(FMT, V1) (fprintf(debugfile, FMT, V1), fflush(debugfile))
-#define DPRINT2(FMT, V1, V2) (fprintf(debugfile, FMT, V1, V2), fflush(debugfile))
-#else
-#define DPRINT0(FMT) /* Do nothing */
-#define DPRINT1(FMT, V1) /* Do nothing */
-#define DPRINT2(FMT, V1, V2) /* Do nothing */
-#endif
-
-struct termios orig_term;
-
-static int rlfe_directory_completion_hook __P((char **));
-static int rlfe_directory_rewrite_hook __P((char **));
-static char *rlfe_filename_completion_function __P((const char *, int));
-
-/* Pid of child process. */
-static pid_t child = -1;
-
-static void
-sig_child (int signo)
-{
-  int status;
-  wait (&status);
-  DPRINT0 ("(Child process died.)\n");
-  tcsetattr(STDIN_FILENO, TCSANOW, &orig_term);
-  exit (0);
-}
-
-volatile int propagate_sigwinch = 0;
-
-/* sigwinch_handler
- * propagate window size changes from input file descriptor to
- * master side of pty.
- */
-void sigwinch_handler(int signal) { 
-   propagate_sigwinch = 1;
-}
-
-/* get_master_pty() takes a double-indirect character pointer in which
- * to put a slave name, and returns an integer file descriptor.
- * If it returns < 0, an error has occurred.
- * Otherwise, it has returned the master pty file descriptor, and fills
- * in *name with the name of the corresponding slave pty.
- * Once the slave pty has been opened, you are responsible to free *name.
- */
-
-int get_master_pty(char **name) { 
-   int i, j;
-   /* default to returning error */
-   int master = -1;
-
-   /* create a dummy name to fill in */
-   *name = strdup("/dev/ptyXX");
-
-   /* search for an unused pty */
-   for (i=0; i<16 && master <= 0; i++) {
-      for (j=0; j<16 && master <= 0; j++) {
-         (*name)[5] = 'p';
-         (*name)[8] = "pqrstuvwxyzPQRST"[i];
-         (*name)[9] = "0123456789abcdef"[j];
-         /* open the master pty */
-         if ((master = open(*name, O_RDWR)) < 0) {
-            if (errno == ENOENT) {
-               /* we are out of pty devices */
-               free (*name);
-               return (master);
-            }
-         }
-         else {
-           /* By substituting a letter, we change the master pty
-            * name into the slave pty name.
-            */
-           (*name)[5] = 't';
-           if (access(*name, R_OK|W_OK) != 0)
-             {
-               close(master);
-               master = -1;
-             }
-         }
-      }
-   }
-   if ((master < 0) && (i == 16) && (j == 16)) {
-      /* must have tried every pty unsuccessfully */
-      free (*name);
-      return (master);
-   }
-
-   (*name)[5] = 't';
-
-   return (master);
-}
-
-/* get_slave_pty() returns an integer file descriptor.
- * If it returns < 0, an error has occurred.
- * Otherwise, it has returned the slave file descriptor.
- */
-
-int get_slave_pty(char *name) { 
-   struct group *gptr;
-   gid_t gid;
-   int slave = -1;
-
-   /* chown/chmod the corresponding pty, if possible.
-    * This will only work if the process has root permissions.
-    * Alternatively, write and exec a small setuid program that
-    * does just this.
-    */
-   if ((gptr = getgrnam("tty")) != 0) {
-      gid = gptr->gr_gid;
-   } else {
-      /* if the tty group does not exist, don't change the
-       * group on the slave pty, only the owner
-       */
-      gid = -1;
-   }
-
-   /* Note that we do not check for errors here.  If this is code
-    * where these actions are critical, check for errors!
-    */
-   chown(name, getuid(), gid);
-   /* This code only makes the slave read/writeable for the user.
-    * If this is for an interactive shell that will want to
-    * receive "write" and "wall" messages, OR S_IWGRP into the
-    * second argument below.
-    */
-   chmod(name, S_IRUSR|S_IWUSR);
-
-   /* open the corresponding slave pty */
-   slave = open(name, O_RDWR);
-   return (slave);
-}
-
-/* Certain special characters, such as ctrl/C, we want to pass directly
-   to the inferior, rather than letting readline handle them. */
-
-static char special_chars[20];
-static int special_chars_count;
-
-static void
-add_special_char(int ch)
-{
-  if (ch != 0)
-    special_chars[special_chars_count++] = ch;
-}
-
-static int eof_char;
-
-static int
-is_special_char(int ch)
-{
-  int i;
-#if 0
-  if (ch == eof_char && rl_point == rl_end)
-    return 1;
-#endif
-  for (i = special_chars_count;  --i >= 0; )
-    if (special_chars[i] == ch)
-      return 1;
-  return 0;
-}
-
-static char buf[1024];
-/* buf[0 .. buf_count-1] is the what has been emitted on the current line.
-   It is used as the readline prompt. */
-static int buf_count = 0;
-
-int num_keys = 0;
-
-static void
-null_prep_terminal (int meta)
-{
-}
-
-static void
-null_deprep_terminal ()
-{
-}
-
-char pending_special_char;
-
-static void
-line_handler (char *line)
-{
-  if (line == NULL)
-    {
-      char buf[1];
-      DPRINT0("saw eof!\n");
-      buf[0] = '\004'; /* ctrl/d */
-      write (out_to_inferior_fd, buf, 1);
-    }
-  else
-    {
-      static char enter[] = "\r";
-      /*  Send line to inferior: */
-      int length = strlen (line);
-      if (length > ECHO_SUPPRESS_MAX-2)
-	{
-	  echo_suppress_start = 0;
-	  echo_suppress_limit = 0;
-	}
-      else
-	{
-	  if (echo_suppress_limit + length > ECHO_SUPPRESS_MAX - 2)
-	    {
-	      if (echo_suppress_limit - echo_suppress_start + length
-		  <= ECHO_SUPPRESS_MAX - 2)
-		{
-		  memmove (echo_suppress_buffer,
-			   echo_suppress_buffer + echo_suppress_start,
-			   echo_suppress_limit - echo_suppress_start);
-		  echo_suppress_limit -= echo_suppress_start;
-		  echo_suppress_start = 0;
-		}
-	      else
-		{
-		  echo_suppress_limit = 0;
-		}
-	      echo_suppress_start = 0;
-	    }
-	  memcpy (echo_suppress_buffer + echo_suppress_limit,
-		  line, length);
-	  echo_suppress_limit += length;
-	  echo_suppress_buffer[echo_suppress_limit++] = '\r';
-	  echo_suppress_buffer[echo_suppress_limit++] = '\n';
-	}
-      write (out_to_inferior_fd, line, length);
-      if (pending_special_char == 0)
-        {
-          write (out_to_inferior_fd, enter, sizeof(enter)-1);
-          if (*line)
-            add_history (line);
-        }
-      free (line);
-    }
-  rl_callback_handler_remove ();
-  buf_count = 0;
-  num_keys = 0;
-  if (pending_special_char != 0)
-    {
-      write (out_to_inferior_fd, &pending_special_char, 1);
-      pending_special_char = 0;
-    }
-}
-
-/* Value of rl_getc_function.
-   Use this because readline should read from stdin, not rl_instream,
-   points to the pty (so readline has monitor its terminal modes). */
-
-int
-my_rl_getc (FILE *dummy)
-{
-  int ch = rl_getc (stdin);
-  if (is_special_char (ch))
-    {
-      pending_special_char = ch;
-      return '\r';
-    }
-  return ch;
-}
-
-static void
-usage()
-{
-  fprintf (stderr, "%s: usage: %s [-l filename] [-a] [-n appname] [-hv] [command [arguments...]]\n",
-		   progname, progname);
-}
-
-int
-main(int argc, char** argv)
-{
-  char *path;
-  int i, append;
-  int master;
-  char *name, *logfname, *appname;
-  int in_from_tty_fd;
-  struct sigaction act;
-  struct winsize ws;
-  struct termios t;
-  int maxfd;
-  fd_set in_set;
-  static char empty_string[1] = "";
-  char *prompt = empty_string;
-  int ioctl_err = 0;
-
-  if ((progname = strrchr (argv[0], '/')) == 0)
-    progname = argv[0];
-  else
-    progname++;
-  progversion = RL_LIBRARY_VERSION;
-
-  append = 0;
-  appname = APPLICATION_NAME;
-  logfname = (char *)NULL;
-
-  while ((i = getopt (argc, argv, "ahl:n:v")) != EOF)
-    {
-      switch (i)
-	{
-	case 'l':
-	  logfname = optarg;
-	  break;
-	case 'n':
-	  appname = optarg;
-	  break;
-	case 'a':
-	  append = 1;
-	  break;
-	case 'h':
-	  usage ();
-	  exit (0);
-	case 'v':
-	  fprintf (stderr, "%s version %s\n", progname, progversion);
-	  exit (0);
-	default:
-	  usage ();
-	  exit (2);
-	}
-    }
-
-  argc -= optind;
-  argv += optind;
-
-  if (logfname)
-    {
-      logfile = fopen (logfname, append ? "a" : "w");
-      if (logfile == 0)
-	fprintf (stderr, "%s: warning: could not open log file %s: %s\n",
-			 progname, logfname, strerror (errno));
-    }
-    
-  rl_readline_name = appname;
-  
-#ifdef DEBUG
-  debugfile = fopen("LOG", "w");
-#endif
-
-  if ((master = get_master_pty(&name)) < 0)
-    {
-      perror("ptypair: could not open master pty");
-      exit(1);
-    }
-
-  DPRINT1("pty name: '%s'\n", name);
-
-  /* set up SIGWINCH handler */
-  act.sa_handler = sigwinch_handler;
-  sigemptyset(&(act.sa_mask));
-  act.sa_flags = 0;
-  if (sigaction(SIGWINCH, &act, NULL) < 0)
-    {
-      perror("ptypair: could not handle SIGWINCH ");
-      exit(1);
-    }
-
-  if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) < 0)
-    {
-      perror("ptypair: could not get window size");
-      exit(1);
-    }
-
-  if ((child = fork()) < 0)
-    {
-      perror("cannot fork");
-      exit(1);
-    }
-
-  if (child == 0)
-    { 
-      int slave;  /* file descriptor for slave pty */
-
-      /* We are in the child process */
-      close(master);
-
-#ifdef TIOCSCTTY
-      if ((slave = get_slave_pty(name)) < 0)
-	{
-	  perror("ptypair: could not open slave pty");
-	  exit(1);
-	}
-      free(name);
-#endif
-
-      /* We need to make this process a session group leader, because
-       * it is on a new PTY, and things like job control simply will
-       * not work correctly unless there is a session group leader
-       * and process group leader (which a session group leader
-       * automatically is). This also disassociates us from our old
-       * controlling tty. 
-       */
-      if (setsid() < 0)
-	{
-	  perror("could not set session leader");
-	}
-
-      /* Tie us to our new controlling tty. */
-#ifdef TIOCSCTTY
-      if (ioctl(slave, TIOCSCTTY, NULL))
-	{
-	  perror("could not set new controlling tty");
-	}
-#else
-      if ((slave = get_slave_pty(name)) < 0)
-	{
-	  perror("ptypair: could not open slave pty");
-	  exit(1);
-	}
-      free(name);
-#endif
-
-      /* make slave pty be standard in, out, and error */
-      dup2(slave, STDIN_FILENO);
-      dup2(slave, STDOUT_FILENO);
-      dup2(slave, STDERR_FILENO);
-
-      /* at this point the slave pty should be standard input */
-      if (slave > 2)
-	{
-	  close(slave);
-	}
-
-      /* Try to restore window size; failure isn't critical */
-      if (ioctl(STDOUT_FILENO, TIOCSWINSZ, &ws) < 0)
-	{
-	  perror("could not restore window size");
-	}
-
-      /* now start the shell */
-      {
-	static char* command_args[] = { COMMAND_ARGS, NULL };
-	if (argc < 1)
-	  execvp(COMMAND, command_args);
-	else
-	  execvp(argv[0], &argv[0]);
-      }
-
-      /* should never be reached */
-      exit(1);
-    }
-
-  /* parent */
-  signal (SIGCHLD, sig_child);
-  free(name);
-
-  /* Note that we only set termios settings for standard input;
-   * the master side of a pty is NOT a tty.
-   */
-  tcgetattr(STDIN_FILENO, &orig_term);
-
-  t = orig_term;
-  eof_char = t.c_cc[VEOF];
-  /*  add_special_char(t.c_cc[VEOF]);*/
-  add_special_char(t.c_cc[VINTR]);
-  add_special_char(t.c_cc[VQUIT]);
-  add_special_char(t.c_cc[VSUSP]);
-#if defined (VDISCARD)
-  add_special_char(t.c_cc[VDISCARD]);
-#endif
-
-#if 0
-  t.c_lflag |= (ICANON | ISIG | ECHO | ECHOCTL | ECHOE | \
-		ECHOK | ECHOKE | ECHONL | ECHOPRT );
-#else
-  t.c_lflag &= ~(ICANON | ISIG | ECHO | ECHOCTL | ECHOE | \
-		 ECHOK | ECHOKE | ECHONL | ECHOPRT );
-#endif
-  t.c_iflag |= IGNBRK;
-  t.c_cc[VMIN] = 1;
-  t.c_cc[VTIME] = 0;
-  tcsetattr(STDIN_FILENO, TCSANOW, &t);
-  in_from_inferior_fd = master;
-  out_to_inferior_fd = master;
-  rl_instream = fdopen (master, "r");
-  rl_getc_function = my_rl_getc;
-
-  rl_prep_term_function = null_prep_terminal; 
-  rl_deprep_term_function = null_deprep_terminal; 
-  rl_callback_handler_install (prompt, line_handler);
-
-#if 1
-  rl_directory_completion_hook = rlfe_directory_completion_hook;
-  rl_completion_entry_function = rlfe_filename_completion_function;
-#else
-  rl_directory_rewrite_hook = rlfe_directory_rewrite_hook;
-#endif
-
-  in_from_tty_fd = STDIN_FILENO;
-  FD_ZERO (&in_set);
-  maxfd = in_from_inferior_fd > in_from_tty_fd ? in_from_inferior_fd
-    : in_from_tty_fd;
-  for (;;)
-    {
-      int num;
-      FD_SET (in_from_inferior_fd, &in_set);
-      FD_SET (in_from_tty_fd, &in_set);
-
-      num = select(maxfd+1, &in_set, NULL, NULL, NULL);
-
-      if (propagate_sigwinch)
-	{
-	  struct winsize ws;
-	  if (ioctl (STDIN_FILENO, TIOCGWINSZ, &ws) >= 0)
-	    {
-	      ioctl (master, TIOCSWINSZ, &ws);
-	    }
-	  propagate_sigwinch = 0;
-	  continue;
-	}
-
-      if (num <= 0)
-	{
-	  perror ("select");
-	  exit (-1);
-	}
-      if (FD_ISSET (in_from_tty_fd, &in_set))
-	{
-	  extern int readline_echoing_p;
-	  struct termios term_master;
-	  int do_canon = 1;
-	  int ioctl_ret;
-
-	  DPRINT1("[tty avail num_keys:%d]\n", num_keys);
-
-	  /* If we can't get tty modes for the master side of the pty, we
-	     can't handle non-canonical-mode programs.  Always assume the
-	     master is in canonical echo mode if we can't tell. */
-	  ioctl_ret = tcgetattr(master, &term_master);
-
-	  if (ioctl_ret >= 0)
-	    {
-	      DPRINT2 ("echo:%d, canon:%d\n",
-			(term_master.c_lflag & ECHO) != 0,
-			(term_master.c_lflag & ICANON) != 0);
-	      do_canon = (term_master.c_lflag & ICANON) != 0;
-	      readline_echoing_p = (term_master.c_lflag & ECHO) != 0;
-	    }
-	  else
-	    {
-	      if (ioctl_err == 0)
-		DPRINT1("tcgetattr on master fd failed: errno = %d\n", errno);
-	      ioctl_err = 1;
-	    }
-
-	  if (do_canon == 0 && num_keys == 0)
-	    {
-	      char ch[10];
-	      int count = read (STDIN_FILENO, ch, sizeof(ch));
-	      write (out_to_inferior_fd, ch, count);
-	    }
-	  else
-	    {
-	      if (num_keys == 0)
-		{
-		  int i;
-		  /* Re-install callback handler for new prompt. */
-		  if (prompt != empty_string)
-		    free (prompt);
-		  prompt = malloc (buf_count + 1);
-		  if (prompt == NULL)
-		    prompt = empty_string;
-		  else
-		    {
-		      memcpy (prompt, buf, buf_count);
-		      prompt[buf_count] = '\0';
-		      DPRINT1("New prompt '%s'\n", prompt);
-#if 0 /* ifdef HAVE_RL_ALREADY_PROMPTED -- doesn't work */
-		      rl_already_prompted = buf_count > 0;
-#else
-		      if (buf_count > 0)
-			write (1, "\r", 1);
-#endif
-		    }
-		  rl_callback_handler_install (prompt, line_handler);
-		}
-	      num_keys++;
-	      rl_callback_read_char ();
-	    }
-	}
-      else /* input from inferior. */
-	{
-	  int i;
-	  int count;
-	  int old_count;
-	  if (buf_count > (sizeof(buf) >> 2))
-	    buf_count = 0;
-	  count = read (in_from_inferior_fd, buf+buf_count,
-			sizeof(buf) - buf_count);
-	  if (count <= 0)
-	    {
-	      DPRINT0 ("(Connection closed by foreign host.)\n");
-	      tcsetattr(STDIN_FILENO, TCSANOW, &orig_term);
-	      exit (0);
-	    }
-	  old_count = buf_count;
-
-	  /* Do some minimal carriage return translation and backspace
-	     processing before logging the input line. */
-	  if (logfile)
-	    {
-#ifndef __GNUC__
-	      char *b;
-#else
-	      char b[count + 1];
-#endif
-	      int i, j;
-
-#ifndef __GNUC__
-	      b = malloc (count + 1);
-	      if (b) {
-#endif
-	      for (i = 0; i < count; i++)
-	        b[i] = buf[buf_count + i];
-	      b[i] = '\0';
-	      for (i = j = 0; i <= count; i++)
-		{
-		  if (b[i] == '\r')
-		    {
-		      if (b[i+1] != '\n')
-		        b[j++] = '\n';
-		    }
-		  else if (b[i] == '\b')
-		    {
-		      if (i)
-			j--;
-		    }
-		  else
-		    b[j++] = b[i];
-		}
-	      fprintf (logfile, "%s", b);
-
-#ifndef __GNUC__
-	      free (b);
-	      }
-#endif
-	    }
-
-          /* Look for any pending echo that we need to suppress. */
-	  while (echo_suppress_start < echo_suppress_limit
-		 && count > 0
-		 && buf[buf_count] == echo_suppress_buffer[echo_suppress_start])
-	    {
-	      count--;
-	      buf_count++;
-	      echo_suppress_start++;
-	    }
-
-          /* Write to the terminal anything that was not suppressed. */
-          if (count > 0)
-            write (1, buf + buf_count, count);
-
-          /* Finally, look for a prompt candidate.
-           * When we get around to going input (from the keyboard),
-           * we will consider the prompt to be anything since the last
-           * line terminator.  So we need to save that text in the
-           * initial part of buf.  However, anything before the
-           * most recent end-of-line is not interesting. */
-	  buf_count += count;
-#if 1
-	  for (i = buf_count;  --i >= old_count; )
-#else
-	  for (i = buf_count - 1;  i-- >= buf_count - count; )
-#endif
-	    {
-	      if (buf[i] == '\n' || buf[i] == '\r')
-		{
-		  i++;
-		  memmove (buf, buf+i, buf_count - i);
-		  buf_count -= i;
-		  break;
-		}
-	    }
-	  DPRINT2("-> i: %d, buf_count: %d\n", i, buf_count);
-	}
-    }
-}
-
-/*
- *
- * FILENAME COMPLETION FOR RLFE
- *
- */
-
-#ifndef PATH_MAX
-#  define PATH_MAX 1024
-#endif
-
-#define DIRSEP		'/'
-#define ISDIRSEP(x)	((x) == '/')
-#define PATHSEP(x)	(ISDIRSEP(x) || (x) == 0)
-
-#define DOT_OR_DOTDOT(x) \
-	((x)[0] == '.' && (PATHSEP((x)[1]) || \
-			  ((x)[1] == '.' && PATHSEP((x)[2]))))
-
-#define FREE(x)		if (x) free(x)
-
-#define STRDUP(s, x)	do { \
-			  s = strdup (x);\
-			  if (s == 0) \
-			    return ((char *)NULL); \
-			} while (0)
-
-static int
-get_inferior_cwd (path, psize)
-     char *path;
-     size_t psize;
-{
-  int n;
-  static char procfsbuf[PATH_MAX] = { '\0' };
-
-  if (procfsbuf[0] == '\0')
-    sprintf (procfsbuf, "/proc/%d/cwd", (int)child);
-  n = readlink (procfsbuf, path, psize);
-  if (n < 0)
-    return n;
-  if (n > psize)
-    return -1;
-  path[n] = '\0';
-  return n;
-}
-
-static int
-rlfe_directory_rewrite_hook (dirnamep)
-     char **dirnamep;
-{
-  char *ldirname, cwd[PATH_MAX], *retdir, *ld;
-  int n, ldlen;
-
-  ldirname = *dirnamep;
-
-  if (*ldirname == '/')
-    return 0;
-
-  n = get_inferior_cwd (cwd, sizeof(cwd) - 1);
-  if (n < 0)
-    return 0;
-  if (n == 0)	/* current directory */
-    {
-      cwd[0] = '.';
-      cwd[1] = '\0';
-      n = 1;
-    }
-
-  /* Minimally canonicalize ldirname by removing leading `./' */
-  for (ld = ldirname; *ld; )
-    {
-      if (ISDIRSEP (ld[0]))
-	ld++;
-      else if (ld[0] == '.' && PATHSEP(ld[1]))
-	ld++;
-      else
-	break;
-    }
-  ldlen = (ld && *ld) ? strlen (ld) : 0;
-
-  retdir = (char *)malloc (n + ldlen + 3);
-  if (retdir == 0)
-    return 0;
-  if (ldlen)
-    sprintf (retdir, "%s/%s", cwd, ld);
-  else
-    strcpy (retdir, cwd);
-  free (ldirname);
-
-  *dirnamep = retdir;
-
-  DPRINT1("rl_directory_rewrite_hook returns %s\n", retdir);
-  return 1;
-}
-
-/* Translate *DIRNAMEP to be relative to the inferior's CWD.  Leave a trailing
-   slash on the result. */
-static int
-rlfe_directory_completion_hook (dirnamep)
-     char **dirnamep;
-{
-  char *ldirname, *retdir;
-  int n, ldlen;
-
-  ldirname = *dirnamep;
-
-  if (*ldirname == '/')
-    return 0;
-
-  n = rlfe_directory_rewrite_hook (dirnamep);
-  if (n == 0)
-    return 0;
-
-  ldirname = *dirnamep;
-  ldlen = (ldirname && *ldirname) ? strlen (ldirname) : 0;
-
-  if (ldlen == 0 || ldirname[ldlen - 1] != '/')
-    {
-      retdir = (char *)malloc (ldlen + 3);
-      if (retdir == 0)
-	return 0;
-      if (ldlen)
-	strcpy (retdir, ldirname);
-      else
-	retdir[ldlen++] = '.';
-      retdir[ldlen] = '/';
-      retdir[ldlen+1] = '\0';
-      free (ldirname);
-
-      *dirnamep = retdir;
-    }
-
-  DPRINT1("rl_directory_completion_hook returns %s\n", retdir);
-  return 1;
-}
-
-static char *
-rlfe_filename_completion_function (text, state)
-     const char *text;
-     int state;
-{
-  static DIR *directory;
-  static char *filename = (char *)NULL;
-  static char *dirname = (char *)NULL, *ud = (char *)NULL;
-  static int flen, udlen;
-  char *temp;
-  struct dirent *dentry;
-
-  if (state == 0)
-    {
-      if (directory)
-	{
-	  closedir (directory);
-	  directory = 0;
-	}
-      FREE (dirname);
-      FREE (filename);
-      FREE (ud);
-
-      if (text && *text)
-        STRDUP (filename, text);
-      else
-	{
-	  filename = malloc(1); 
-	  if (filename == 0)
-	    return ((char *)NULL);
-	  filename[0] = '\0';
-	}
-      dirname = (text && *text) ? strdup (text) : strdup (".");
-      if (dirname == 0)
-        return ((char *)NULL);
-
-      temp = strrchr (dirname, '/');
-      if (temp)
-	{
-	  strcpy (filename, ++temp);
-	  *temp = '\0';
-	}
-      else
-	{
-	  dirname[0] = '.';
-	  dirname[1] = '\0';
-	}
-
-      STRDUP (ud, dirname);
-      udlen = strlen (ud);
-
-      rlfe_directory_completion_hook (&dirname);
-
-      directory = opendir (dirname);
-      flen = strlen (filename);
-
-      rl_filename_completion_desired = 1;
-    }
-
-  dentry = 0;
-  while (directory && (dentry = readdir (directory)))
-    {
-      if (flen == 0)
-	{
-          if (DOT_OR_DOTDOT(dentry->d_name) == 0)
-            break;
-	}
-      else
-	{
-	  if ((dentry->d_name[0] == filename[0]) &&
-	      (strlen (dentry->d_name) >= flen) &&
-	      (strncmp (filename, dentry->d_name, flen) == 0))
-	    break;
-	}
-    }
-
-  if (dentry == 0)
-    {
-      if (directory)
-	{
-	  closedir (directory);
-	  directory = 0;
-	}
-      FREE (dirname);
-      FREE (filename);
-      FREE (ud);
-      dirname = filename = ud = 0;
-      return ((char *)NULL);
-    }
-
-  if (ud == 0 || (ud[0] == '.' && ud[1] == '\0'))
-    temp = strdup (dentry->d_name);
-  else
-    {
-      temp = malloc (1 + udlen + strlen (dentry->d_name));
-      strcpy (temp, ud);
-      strcpy (temp + udlen, dentry->d_name);
-    }
-  return (temp);
-}
diff --git a/readline/examples/rltest.c b/readline/examples/rltest.c
deleted file mode 100644
--- a/readline/examples/rltest.c
+++ /dev/null
@@ -1,67 +0,0 @@
-/* **************************************************************** */
-/*								    */
-/*			Testing Readline			    */
-/*								    */
-/* **************************************************************** */
-
-#if defined (HAVE_CONFIG_H)
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <sys/types.h>
-
-#ifdef READLINE_LIBRARY
-#  include "readline.h"
-#  include "history.h"
-#else
-#  include <readline/readline.h>
-#  include <readline/history.h>
-#endif
-
-extern HIST_ENTRY **history_list ();
-
-main ()
-{
-  char *temp, *prompt;
-  int done;
-
-  temp = (char *)NULL;
-  prompt = "readline$ ";
-  done = 0;
-
-  while (!done)
-    {
-      temp = readline (prompt);
-
-      /* Test for EOF. */
-      if (!temp)
-	exit (1);
-
-      /* If there is anything on the line, print it and remember it. */
-      if (*temp)
-	{
-	  fprintf (stderr, "%s\r\n", temp);
-	  add_history (temp);
-	}
-
-      /* Check for `command' that we handle. */
-      if (strcmp (temp, "quit") == 0)
-	done = 1;
-
-      if (strcmp (temp, "list") == 0)
-	{
-	  HIST_ENTRY **list;
-	  register int i;
-
-	  list = history_list ();
-	  if (list)
-	    {
-	      for (i = 0; list[i]; i++)
-		fprintf (stderr, "%d: %s\r\n", i, list[i]->line);
-	    }
-	}
-      free (temp);
-    }
-  exit (0);
-}
diff --git a/readline/examples/rlversion.c b/readline/examples/rlversion.c
deleted file mode 100644
--- a/readline/examples/rlversion.c
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * rlversion -- print out readline's version number
- */
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-#include <sys/types.h>
-#include "posixstat.h"
-
-#ifdef READLINE_LIBRARY
-#  include "readline.h"
-#else
-#  include <readline/readline.h>
-#endif
-
-main()
-{
-	printf ("%s\n", rl_library_version ? rl_library_version : "unknown");
-	exit (0);
-}
diff --git a/readline/funmap.c b/readline/funmap.c
deleted file mode 100644
--- a/readline/funmap.c
+++ /dev/null
@@ -1,250 +0,0 @@
-/* funmap.c -- attach names to functions. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#if !defined (BUFSIZ)
-#include <stdio.h>
-#endif /* BUFSIZ */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include "rlconf.h"
-#include "readline.h"
-
-#include "xmalloc.h"
-
-#ifdef __STDC__
-typedef int QSFUNC (const void *, const void *);
-#else
-typedef int QSFUNC ();
-#endif
-
-extern int _rl_qsort_string_compare __P((char **, char **));
-
-FUNMAP **funmap;
-static int funmap_size;
-static int funmap_entry;
-
-/* After initializing the function map, this is the index of the first
-   program specific function. */
-int funmap_program_specific_entry_start;
-
-static FUNMAP default_funmap[] = {
-  { "abort", rl_abort },
-  { "accept-line", rl_newline },
-  { "arrow-key-prefix", rl_arrow_keys },
-  { "backward-char", rl_backward },
-  { "backward-delete-char", rl_rubout },
-  { "backward-kill-line", rl_backward_kill_line },
-  { "backward-kill-word", rl_backward_kill_word },
-  { "backward-word", rl_backward_word },
-  { "beginning-of-history", rl_beginning_of_history },
-  { "beginning-of-line", rl_beg_of_line },
-  { "call-last-kbd-macro", rl_call_last_kbd_macro },
-  { "capitalize-word", rl_capitalize_word },
-  { "character-search", rl_char_search },
-  { "character-search-backward", rl_backward_char_search },
-  { "clear-screen", rl_clear_screen },
-  { "complete", rl_complete },
-  { "copy-backward-word", rl_copy_backward_word },
-  { "copy-forward-word", rl_copy_forward_word },
-  { "copy-region-as-kill", rl_copy_region_to_kill },
-  { "delete-char", rl_delete },
-  { "delete-char-or-list", rl_delete_or_show_completions },
-  { "delete-horizontal-space", rl_delete_horizontal_space },
-  { "digit-argument", rl_digit_argument },
-  { "do-lowercase-version", rl_do_lowercase_version },
-  { "downcase-word", rl_downcase_word },
-  { "dump-functions", rl_dump_functions },
-  { "dump-macros", rl_dump_macros },
-  { "dump-variables", rl_dump_variables },
-  { "emacs-editing-mode", rl_emacs_editing_mode },
-  { "end-kbd-macro", rl_end_kbd_macro },
-  { "end-of-history", rl_end_of_history },
-  { "end-of-line", rl_end_of_line },
-  { "exchange-point-and-mark", rl_exchange_point_and_mark },
-  { "forward-backward-delete-char", rl_rubout_or_delete },
-  { "forward-char", rl_forward },
-  { "forward-search-history", rl_forward_search_history },
-  { "forward-word", rl_forward_word },
-  { "history-search-backward", rl_history_search_backward },
-  { "history-search-forward", rl_history_search_forward },
-  { "insert-comment", rl_insert_comment },
-  { "insert-completions", rl_insert_completions },
-  { "kill-whole-line", rl_kill_full_line },
-  { "kill-line", rl_kill_line },
-  { "kill-region", rl_kill_region },
-  { "kill-word", rl_kill_word },
-  { "menu-complete", rl_menu_complete },
-  { "next-history", rl_get_next_history },
-  { "non-incremental-forward-search-history", rl_noninc_forward_search },
-  { "non-incremental-reverse-search-history", rl_noninc_reverse_search },
-  { "non-incremental-forward-search-history-again", rl_noninc_forward_search_again },
-  { "non-incremental-reverse-search-history-again", rl_noninc_reverse_search_again },
-#ifdef __CYGWIN__
-  { "paste-from-clipboard", rl_paste_from_clipboard },
-#endif
-  { "possible-completions", rl_possible_completions },
-  { "previous-history", rl_get_previous_history },
-  { "quoted-insert", rl_quoted_insert },
-  { "re-read-init-file", rl_re_read_init_file },
-  { "redraw-current-line", rl_refresh_line},
-  { "reverse-search-history", rl_reverse_search_history },
-  { "revert-line", rl_revert_line },
-  { "self-insert", rl_insert },
-  { "set-mark", rl_set_mark },
-  { "start-kbd-macro", rl_start_kbd_macro },
-  { "tab-insert", rl_tab_insert },
-  { "tilde-expand", rl_tilde_expand },
-  { "transpose-chars", rl_transpose_chars },
-  { "transpose-words", rl_transpose_words },
-  { "tty-status", rl_tty_status },
-  { "undo", rl_undo_command },
-  { "universal-argument", rl_universal_argument },
-  { "unix-line-discard", rl_unix_line_discard },
-  { "unix-word-rubout", rl_unix_word_rubout },
-  { "upcase-word", rl_upcase_word },
-  { "yank", rl_yank },
-  { "yank-last-arg", rl_yank_last_arg },
-  { "yank-nth-arg", rl_yank_nth_arg },
-  { "yank-pop", rl_yank_pop },
-
-#if defined (VI_MODE)
-  { "vi-append-eol", rl_vi_append_eol },
-  { "vi-append-mode", rl_vi_append_mode },
-  { "vi-arg-digit", rl_vi_arg_digit },
-  { "vi-back-to-indent", rl_vi_back_to_indent },
-  { "vi-bWord", rl_vi_bWord },
-  { "vi-bword", rl_vi_bword },
-  { "vi-change-case", rl_vi_change_case },
-  { "vi-change-char", rl_vi_change_char },
-  { "vi-change-to", rl_vi_change_to },
-  { "vi-char-search", rl_vi_char_search },
-  { "vi-column", rl_vi_column },
-  { "vi-complete", rl_vi_complete },
-  { "vi-delete", rl_vi_delete },
-  { "vi-delete-to", rl_vi_delete_to },
-  { "vi-eWord", rl_vi_eWord },
-  { "vi-editing-mode", rl_vi_editing_mode },
-  { "vi-end-word", rl_vi_end_word },
-  { "vi-eof-maybe", rl_vi_eof_maybe },
-  { "vi-eword", rl_vi_eword },
-  { "vi-fWord", rl_vi_fWord },
-  { "vi-fetch-history", rl_vi_fetch_history },
-  { "vi-first-print", rl_vi_first_print },
-  { "vi-fword", rl_vi_fword },
-  { "vi-goto-mark", rl_vi_goto_mark },
-  { "vi-insert-beg", rl_vi_insert_beg },
-  { "vi-insertion-mode", rl_vi_insertion_mode },
-  { "vi-match", rl_vi_match },
-  { "vi-movement-mode", rl_vi_movement_mode },
-  { "vi-next-word", rl_vi_next_word },
-  { "vi-overstrike", rl_vi_overstrike },
-  { "vi-overstrike-delete", rl_vi_overstrike_delete },
-  { "vi-prev-word", rl_vi_prev_word },
-  { "vi-put", rl_vi_put },
-  { "vi-redo", rl_vi_redo },
-  { "vi-replace", rl_vi_replace },
-  { "vi-search", rl_vi_search },
-  { "vi-search-again", rl_vi_search_again },
-  { "vi-set-mark", rl_vi_set_mark },
-  { "vi-subst", rl_vi_subst },
-  { "vi-tilde-expand", rl_vi_tilde_expand },
-  { "vi-yank-arg", rl_vi_yank_arg },
-  { "vi-yank-to", rl_vi_yank_to },
-#endif /* VI_MODE */
-
- {(char *)NULL, (rl_command_func_t *)NULL }
-};
-
-int
-rl_add_funmap_entry (name, function)
-     const char *name;
-     rl_command_func_t *function;
-{
-  if (funmap_entry + 2 >= funmap_size)
-    {
-      funmap_size += 64;
-      funmap = (FUNMAP **)xrealloc (funmap, funmap_size * sizeof (FUNMAP *));
-    }
-  
-  funmap[funmap_entry] = (FUNMAP *)xmalloc (sizeof (FUNMAP));
-  funmap[funmap_entry]->name = name;
-  funmap[funmap_entry]->function = function;
-
-  funmap[++funmap_entry] = (FUNMAP *)NULL;
-  return funmap_entry;
-}
-
-static int funmap_initialized;
-
-/* Make the funmap contain all of the default entries. */
-void
-rl_initialize_funmap ()
-{
-  register int i;
-
-  if (funmap_initialized)
-    return;
-
-  for (i = 0; default_funmap[i].name; i++)
-    rl_add_funmap_entry (default_funmap[i].name, default_funmap[i].function);
-
-  funmap_initialized = 1;
-  funmap_program_specific_entry_start = i;
-}
-
-/* Produce a NULL terminated array of known function names.  The array
-   is sorted.  The array itself is allocated, but not the strings inside.
-   You should free () the array when you done, but not the pointrs. */
-const char **
-rl_funmap_names ()
-{
-  const char **result;
-  int result_size, result_index;
-
-  /* Make sure that the function map has been initialized. */
-  rl_initialize_funmap ();
-
-  for (result_index = result_size = 0, result = (const char **)NULL; funmap[result_index]; result_index++)
-    {
-      if (result_index + 2 > result_size)
-	{
-	  result_size += 20;
-	  result = (const char **)xrealloc (result, result_size * sizeof (char *));
-	}
-
-      result[result_index] = funmap[result_index]->name;
-      result[result_index + 1] = (char *)NULL;
-    }
-
-  qsort (result, result_index, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
-  return (result);
-}
diff --git a/readline/histexpand.c b/readline/histexpand.c
deleted file mode 100644
--- a/readline/histexpand.c
+++ /dev/null
@@ -1,1371 +0,0 @@
-/* histexpand.c -- history expansion. */
-
-/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
-
-   This file contains the GNU History Library (the Library), a set of
-   routines for managing the text of previously typed lines.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#if defined (HAVE_UNISTD_H)
-#  ifndef _MINIX
-#    include <sys/types.h>
-#  endif
-#  include <unistd.h>
-#endif
-
-#if defined (HAVE_STRING_H)
-#  include <string.h>
-#else
-#  include <strings.h>
-#endif /* !HAVE_STRING_H */
-
-#include "history.h"
-#include "histlib.h"
-
-#include "rlshell.h"
-#include "xmalloc.h"
-
-#define HISTORY_WORD_DELIMITERS		" \t\n;&()|<>"
-#define HISTORY_QUOTE_CHARACTERS	"\"'`"
-
-typedef int _hist_search_func_t __P((const char *, int));
-
-static char error_pointer;
-
-static char *subst_lhs;
-static char *subst_rhs;
-static int subst_lhs_len;
-static int subst_rhs_len;
-
-static char *get_history_word_specifier __P((char *, char *, int *));
-static char *history_find_word __P((char *, int));
-
-static char *quote_breaks __P((char *));
-
-/* Variables exported by this file. */
-/* The character that represents the start of a history expansion
-   request.  This is usually `!'. */
-char history_expansion_char = '!';
-
-/* The character that invokes word substitution if found at the start of
-   a line.  This is usually `^'. */
-char history_subst_char = '^';
-
-/* During tokenization, if this character is seen as the first character
-   of a word, then it, and all subsequent characters upto a newline are
-   ignored.  For a Bourne shell, this should be '#'.  Bash special cases
-   the interactive comment character to not be a comment delimiter. */
-char history_comment_char = '\0';
-
-/* The list of characters which inhibit the expansion of text if found
-   immediately following history_expansion_char. */
-char *history_no_expand_chars = " \t\n\r=";
-
-/* If set to a non-zero value, single quotes inhibit history expansion.
-   The default is 0. */
-int history_quotes_inhibit_expansion = 0;
-
-/* Used to split words by history_tokenize_internal. */
-char *history_word_delimiters = HISTORY_WORD_DELIMITERS;
-
-/* If set, this points to a function that is called to verify that a
-   particular history expansion should be performed. */
-rl_linebuf_func_t *history_inhibit_expansion_function;
-
-/* **************************************************************** */
-/*								    */
-/*			History Expansion			    */
-/*								    */
-/* **************************************************************** */
-
-/* Hairy history expansion on text, not tokens.  This is of general
-   use, and thus belongs in this library. */
-
-/* The last string searched for by a !?string? search. */
-static char *search_string;
-
-/* The last string matched by a !?string? search. */
-static char *search_match;
-
-/* Return the event specified at TEXT + OFFSET modifying OFFSET to
-   point to after the event specifier.  Just a pointer to the history
-   line is returned; NULL is returned in the event of a bad specifier.
-   You pass STRING with *INDEX equal to the history_expansion_char that
-   begins this specification.
-   DELIMITING_QUOTE is a character that is allowed to end the string
-   specification for what to search for in addition to the normal
-   characters `:', ` ', `\t', `\n', and sometimes `?'.
-   So you might call this function like:
-   line = get_history_event ("!echo:p", &index, 0);  */
-char *
-get_history_event (string, caller_index, delimiting_quote)
-     const char *string;
-     int *caller_index;
-     int delimiting_quote;
-{
-  register int i;
-  register char c;
-  HIST_ENTRY *entry;
-  int which, sign, local_index, substring_okay;
-  _hist_search_func_t *search_func;
-  char *temp;
-
-  /* The event can be specified in a number of ways.
-
-     !!   the previous command
-     !n   command line N
-     !-n  current command-line minus N
-     !str the most recent command starting with STR
-     !?str[?]
-	  the most recent command containing STR
-
-     All values N are determined via HISTORY_BASE. */
-
-  i = *caller_index;
-
-  if (string[i] != history_expansion_char)
-    return ((char *)NULL);
-
-  /* Move on to the specification. */
-  i++;
-
-  sign = 1;
-  substring_okay = 0;
-
-#define RETURN_ENTRY(e, w) \
-	return ((e = history_get (w)) ? e->line : (char *)NULL)
-
-  /* Handle !! case. */
-  if (string[i] == history_expansion_char)
-    {
-      i++;
-      which = history_base + (history_length - 1);
-      *caller_index = i;
-      RETURN_ENTRY (entry, which);
-    }
-
-  /* Hack case of numeric line specification. */
-  if (string[i] == '-')
-    {
-      sign = -1;
-      i++;
-    }
-
-  if (_rl_digit_p (string[i]))
-    {
-      /* Get the extent of the digits and compute the value. */
-      for (which = 0; _rl_digit_p (string[i]); i++)
-	which = (which * 10) + _rl_digit_value (string[i]);
-
-      *caller_index = i;
-
-      if (sign < 0)
-	which = (history_length + history_base) - which;
-
-      RETURN_ENTRY (entry, which);
-    }
-
-  /* This must be something to search for.  If the spec begins with
-     a '?', then the string may be anywhere on the line.  Otherwise,
-     the string must be found at the start of a line. */
-  if (string[i] == '?')
-    {
-      substring_okay++;
-      i++;
-    }
-
-  /* Only a closing `?' or a newline delimit a substring search string. */
-  for (local_index = i; c = string[i]; i++)
-    if ((!substring_okay && (whitespace (c) || c == ':' ||
-	(history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
-	string[i] == delimiting_quote)) ||
-	string[i] == '\n' ||
-	(substring_okay && string[i] == '?'))
-      break;
-
-  which = i - local_index;
-  temp = xmalloc (1 + which);
-  if (which)
-    strncpy (temp, string + local_index, which);
-  temp[which] = '\0';
-
-  if (substring_okay && string[i] == '?')
-    i++;
-
-  *caller_index = i;
-
-#define FAIL_SEARCH() \
-  do { \
-    history_offset = history_length; free (temp) ; return (char *)NULL; \
-  } while (0)
-
-  /* If there is no search string, try to use the previous search string,
-     if one exists.  If not, fail immediately. */
-  if (*temp == '\0' && substring_okay)
-    {
-      if (search_string)
-        {
-          free (temp);
-          temp = savestring (search_string);
-        }
-      else
-        FAIL_SEARCH ();
-    }
-
-  search_func = substring_okay ? history_search : history_search_prefix;
-  while (1)
-    {
-      local_index = (*search_func) (temp, -1);
-
-      if (local_index < 0)
-	FAIL_SEARCH ();
-
-      if (local_index == 0 || substring_okay)
-	{
-	  entry = current_history ();
-	  history_offset = history_length;
-	
-	  /* If this was a substring search, then remember the
-	     string that we matched for word substitution. */
-	  if (substring_okay)
-	    {
-	      FREE (search_string);
-	      search_string = temp;
-
-	      FREE (search_match);
-	      search_match = history_find_word (entry->line, local_index);
-	    }
-	  else
-	    free (temp);
-
-	  return (entry->line);
-	}
-
-      if (history_offset)
-	history_offset--;
-      else
-	FAIL_SEARCH ();
-    }
-#undef FAIL_SEARCH
-#undef RETURN_ENTRY
-}
-
-/* Function for extracting single-quoted strings.  Used for inhibiting
-   history expansion within single quotes. */
-
-/* Extract the contents of STRING as if it is enclosed in single quotes.
-   SINDEX, when passed in, is the offset of the character immediately
-   following the opening single quote; on exit, SINDEX is left pointing
-   to the closing single quote. */
-static void
-hist_string_extract_single_quoted (string, sindex)
-     char *string;
-     int *sindex;
-{
-  register int i;
-
-  for (i = *sindex; string[i] && string[i] != '\''; i++)
-    ;
-
-  *sindex = i;
-}
-
-static char *
-quote_breaks (s)
-     char *s;
-{
-  register char *p, *r;
-  char *ret;
-  int len = 3;
-
-  for (p = s; p && *p; p++, len++)
-    {
-      if (*p == '\'')
-	len += 3;
-      else if (whitespace (*p) || *p == '\n')
-	len += 2;
-    }
-
-  r = ret = xmalloc (len);
-  *r++ = '\'';
-  for (p = s; p && *p; )
-    {
-      if (*p == '\'')
-	{
-	  *r++ = '\'';
-	  *r++ = '\\';
-	  *r++ = '\'';
-	  *r++ = '\'';
-	  p++;
-	}
-      else if (whitespace (*p) || *p == '\n')
-	{
-	  *r++ = '\'';
-	  *r++ = *p++;
-	  *r++ = '\'';
-	}
-      else
-	*r++ = *p++;
-    }
-  *r++ = '\'';
-  *r = '\0';
-  return ret;
-}
-
-static char *
-hist_error(s, start, current, errtype)
-      char *s;
-      int start, current, errtype;
-{
-  char *temp;
-  const char *emsg;
-  int ll, elen;
-
-  ll = current - start;
-
-  switch (errtype)
-    {
-    case EVENT_NOT_FOUND:
-      emsg = "event not found";
-      elen = 15;
-      break;
-    case BAD_WORD_SPEC:
-      emsg = "bad word specifier";
-      elen = 18;
-      break;
-    case SUBST_FAILED:
-      emsg = "substitution failed";
-      elen = 19;
-      break;
-    case BAD_MODIFIER:
-      emsg = "unrecognized history modifier";
-      elen = 29;
-      break;
-    case NO_PREV_SUBST:
-      emsg = "no previous substitution";
-      elen = 24;
-      break;
-    default:
-      emsg = "unknown expansion error";
-      elen = 23;
-      break;
-    }
-
-  temp = xmalloc (ll + elen + 3);
-  strncpy (temp, s + start, ll);
-  temp[ll] = ':';
-  temp[ll + 1] = ' ';
-  strcpy (temp + ll + 2, emsg);
-  return (temp);
-}
-
-/* Get a history substitution string from STR starting at *IPTR
-   and return it.  The length is returned in LENPTR.
-
-   A backslash can quote the delimiter.  If the string is the
-   empty string, the previous pattern is used.  If there is
-   no previous pattern for the lhs, the last history search
-   string is used.
-
-   If IS_RHS is 1, we ignore empty strings and set the pattern
-   to "" anyway.  subst_lhs is not changed if the lhs is empty;
-   subst_rhs is allowed to be set to the empty string. */
-
-static char *
-get_subst_pattern (str, iptr, delimiter, is_rhs, lenptr)
-     char *str;
-     int *iptr, delimiter, is_rhs, *lenptr;
-{
-  register int si, i, j, k;
-  char *s = (char *) NULL;
-
-  i = *iptr;
-
-  for (si = i; str[si] && str[si] != delimiter; si++)
-    if (str[si] == '\\' && str[si + 1] == delimiter)
-      si++;
-
-  if (si > i || is_rhs)
-    {
-      s = xmalloc (si - i + 1);
-      for (j = 0, k = i; k < si; j++, k++)
-	{
-	  /* Remove a backslash quoting the search string delimiter. */
-	  if (str[k] == '\\' && str[k + 1] == delimiter)
-	    k++;
-	  s[j] = str[k];
-	}
-      s[j] = '\0';
-      if (lenptr)
-	*lenptr = j;
-    }
-
-  i = si;
-  if (str[i])
-    i++;
-  *iptr = i;
-
-  return s;
-}
-
-static void
-postproc_subst_rhs ()
-{
-  char *new;
-  int i, j, new_size;
-
-  new = xmalloc (new_size = subst_rhs_len + subst_lhs_len);
-  for (i = j = 0; i < subst_rhs_len; i++)
-    {
-      if (subst_rhs[i] == '&')
-	{
-	  if (j + subst_lhs_len >= new_size)
-	    new = xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
-	  strcpy (new + j, subst_lhs);
-	  j += subst_lhs_len;
-	}
-      else
-	{
-	  /* a single backslash protects the `&' from lhs interpolation */
-	  if (subst_rhs[i] == '\\' && subst_rhs[i + 1] == '&')
-	    i++;
-	  if (j >= new_size)
-	    new = xrealloc (new, new_size *= 2);
-	  new[j++] = subst_rhs[i];
-	}
-    }
-  new[j] = '\0';
-  free (subst_rhs);
-  subst_rhs = new;
-  subst_rhs_len = j;
-}
-
-/* Expand the bulk of a history specifier starting at STRING[START].
-   Returns 0 if everything is OK, -1 if an error occurred, and 1
-   if the `p' modifier was supplied and the caller should just print
-   the returned string.  Returns the new index into string in
-   *END_INDEX_PTR, and the expanded specifier in *RET_STRING. */
-static int
-history_expand_internal (string, start, end_index_ptr, ret_string, current_line)
-     char *string;
-     int start, *end_index_ptr;
-     char **ret_string;
-     char *current_line;	/* for !# */
-{
-  int i, n, starting_index;
-  int substitute_globally, want_quotes, print_only;
-  char *event, *temp, *result, *tstr, *t, c, *word_spec;
-  int result_len;
-
-  result = xmalloc (result_len = 128);
-
-  i = start;
-
-  /* If it is followed by something that starts a word specifier,
-     then !! is implied as the event specifier. */
-
-  if (member (string[i + 1], ":$*%^"))
-    {
-      char fake_s[3];
-      int fake_i = 0;
-      i++;
-      fake_s[0] = fake_s[1] = history_expansion_char;
-      fake_s[2] = '\0';
-      event = get_history_event (fake_s, &fake_i, 0);
-    }
-  else if (string[i + 1] == '#')
-    {
-      i += 2;
-      event = current_line;
-    }
-  else
-    {
-      int quoted_search_delimiter = 0;
-
-      /* If the character before this `!' is a double or single
-	 quote, then this expansion takes place inside of the
-	 quoted string.  If we have to search for some text ("!foo"),
-	 allow the delimiter to end the search string. */
-      if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
-	quoted_search_delimiter = string[i - 1];
-      event = get_history_event (string, &i, quoted_search_delimiter);
-    }
-	  
-  if (event == 0)
-    {
-      *ret_string = hist_error (string, start, i, EVENT_NOT_FOUND);
-      free (result);
-      return (-1);
-    }
-
-  /* If a word specifier is found, then do what that requires. */
-  starting_index = i;
-  word_spec = get_history_word_specifier (string, event, &i);
-
-  /* There is no such thing as a `malformed word specifier'.  However,
-     it is possible for a specifier that has no match.  In that case,
-     we complain. */
-  if (word_spec == (char *)&error_pointer)
-    {
-      *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);
-      free (result);
-      return (-1);
-    }
-
-  /* If no word specifier, than the thing of interest was the event. */
-  temp = word_spec ? savestring (word_spec) : savestring (event);
-  FREE (word_spec);
-
-  /* Perhaps there are other modifiers involved.  Do what they say. */
-  want_quotes = substitute_globally = print_only = 0;
-  starting_index = i;
-
-  while (string[i] == ':')
-    {
-      c = string[i + 1];
-
-      if (c == 'g')
-	{
-	  substitute_globally = 1;
-	  i++;
-	  c = string[i + 1];
-	}
-
-      switch (c)
-	{
-	default:
-	  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);
-	  free (result);
-	  free (temp);
-	  return -1;
-
-	case 'q':
-	  want_quotes = 'q';
-	  break;
-
-	case 'x':
-	  want_quotes = 'x';
-	  break;
-
-	  /* :p means make this the last executed line.  So we
-	     return an error state after adding this line to the
-	     history. */
-	case 'p':
-	  print_only++;
-	  break;
-
-	  /* :t discards all but the last part of the pathname. */
-	case 't':
-	  tstr = strrchr (temp, '/');
-	  if (tstr)
-	    {
-	      tstr++;
-	      t = savestring (tstr);
-	      free (temp);
-	      temp = t;
-	    }
-	  break;
-
-	  /* :h discards the last part of a pathname. */
-	case 'h':
-	  tstr = strrchr (temp, '/');
-	  if (tstr)
-	    *tstr = '\0';
-	  break;
-
-	  /* :r discards the suffix. */
-	case 'r':
-	  tstr = strrchr (temp, '.');
-	  if (tstr)
-	    *tstr = '\0';
-	  break;
-
-	  /* :e discards everything but the suffix. */
-	case 'e':
-	  tstr = strrchr (temp, '.');
-	  if (tstr)
-	    {
-	      t = savestring (tstr);
-	      free (temp);
-	      temp = t;
-	    }
-	  break;
-
-	/* :s/this/that substitutes `that' for the first
-	   occurrence of `this'.  :gs/this/that substitutes `that'
-	   for each occurrence of `this'.  :& repeats the last
-	   substitution.  :g& repeats the last substitution
-	   globally. */
-
-	case '&':
-	case 's':
-	  {
-	    char *new_event;
-	    int delimiter, failed, si, l_temp;
-
-	    if (c == 's')
-	      {
-		if (i + 2 < (int)strlen (string))
-		  delimiter = string[i + 2];
-		else
-		  break;	/* no search delimiter */
-
-		i += 3;
-
-		t = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);
-		/* An empty substitution lhs with no previous substitution
-		   uses the last search string as the lhs. */
-		if (t)
-		  {
-		    FREE (subst_lhs);
-		    subst_lhs = t;
-		  }
-		else if (!subst_lhs)
-		  {
-		    if (search_string && *search_string)
-		      {
-			subst_lhs = savestring (search_string);
-			subst_lhs_len = strlen (subst_lhs);
-		      }
-		    else
-		      {
-			subst_lhs = (char *) NULL;
-			subst_lhs_len = 0;
-		      }
-		  }
-
-		FREE (subst_rhs);
-		subst_rhs = get_subst_pattern (string, &i, delimiter, 1, &subst_rhs_len);
-
-		/* If `&' appears in the rhs, it's supposed to be replaced
-		   with the lhs. */
-		if (member ('&', subst_rhs))
-		  postproc_subst_rhs ();
-	      }
-	    else
-	      i += 2;
-
-	    /* If there is no lhs, the substitution can't succeed. */
-	    if (subst_lhs_len == 0)
-	      {
-		*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);
-		free (result);
-		free (temp);
-		return -1;
-	      }
-
-	    l_temp = strlen (temp);
-	    /* Ignore impossible cases. */
-	    if (subst_lhs_len > l_temp)
-	      {
-		*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
-		free (result);
-		free (temp);
-		return (-1);
-	      }
-
-	    /* Find the first occurrence of THIS in TEMP. */
-	    si = 0;
-	    for (failed = 1; (si + subst_lhs_len) <= l_temp; si++)
-	      if (STREQN (temp+si, subst_lhs, subst_lhs_len))
-		{
-		  int len = subst_rhs_len - subst_lhs_len + l_temp;
-		  new_event = xmalloc (1 + len);
-		  strncpy (new_event, temp, si);
-		  strncpy (new_event + si, subst_rhs, subst_rhs_len);
-		  strncpy (new_event + si + subst_rhs_len,
-			   temp + si + subst_lhs_len,
-			   l_temp - (si + subst_lhs_len));
-		  new_event[len] = '\0';
-		  free (temp);
-		  temp = new_event;
-
-		  failed = 0;
-
-		  if (substitute_globally)
-		    {
-		      si += subst_rhs_len;
-		      l_temp = strlen (temp);
-		      substitute_globally++;
-		      continue;
-		    }
-		  else
-		    break;
-		}
-
-	    if (substitute_globally > 1)
-	      {
-		substitute_globally = 0;
-		continue;	/* don't want to increment i */
-	      }
-
-	    if (failed == 0)
-	      continue;		/* don't want to increment i */
-
-	    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
-	    free (result);
-	    free (temp);
-	    return (-1);
-	  }
-	}
-      i += 2;
-    }
-  /* Done with modfiers. */
-  /* Believe it or not, we have to back the pointer up by one. */
-  --i;
-
-  if (want_quotes)
-    {
-      char *x;
-
-      if (want_quotes == 'q')
-	x = sh_single_quote (temp);
-      else if (want_quotes == 'x')
-	x = quote_breaks (temp);
-      else
-	x = savestring (temp);
-
-      free (temp);
-      temp = x;
-    }
-
-  n = strlen (temp);
-  if (n >= result_len)
-    result = xrealloc (result, n + 2);
-  strcpy (result, temp);
-  free (temp);
-
-  *end_index_ptr = i;
-  *ret_string = result;
-  return (print_only);
-}
-
-/* Expand the string STRING, placing the result into OUTPUT, a pointer
-   to a string.  Returns:
-
-  -1) If there was an error in expansion.
-   0) If no expansions took place (or, if the only change in
-      the text was the de-slashifying of the history expansion
-      character)
-   1) If expansions did take place
-   2) If the `p' modifier was given and the caller should print the result
-
-  If an error ocurred in expansion, then OUTPUT contains a descriptive
-  error message. */
-
-#define ADD_STRING(s) \
-	do \
-	  { \
-	    int sl = strlen (s); \
-	    j += sl; \
-	    if (j >= result_len) \
-	      { \
-		while (j >= result_len) \
-		  result_len += 128; \
-		result = xrealloc (result, result_len); \
-	      } \
-	    strcpy (result + j - sl, s); \
-	  } \
-	while (0)
-
-#define ADD_CHAR(c) \
-	do \
-	  { \
-	    if (j >= result_len - 1) \
-	      result = xrealloc (result, result_len += 64); \
-	    result[j++] = c; \
-	    result[j] = '\0'; \
-	  } \
-	while (0)
-
-int
-history_expand (hstring, output)
-     char *hstring;
-     char **output;
-{
-  register int j;
-  int i, r, l, passc, cc, modified, eindex, only_printing;
-  char *string;
-
-  /* The output string, and its length. */
-  int result_len;
-  char *result;
-
-  /* Used when adding the string. */
-  char *temp;
-
-  if (output == 0)
-    return 0;
-
-  /* Setting the history expansion character to 0 inhibits all
-     history expansion. */
-  if (history_expansion_char == 0)
-    {
-      *output = savestring (hstring);
-      return (0);
-    }
-    
-  /* Prepare the buffer for printing error messages. */
-  result = xmalloc (result_len = 256);
-  result[0] = '\0';
-
-  only_printing = modified = 0;
-  l = strlen (hstring);
-
-  /* Grovel the string.  Only backslash and single quotes can quote the
-     history escape character.  We also handle arg specifiers. */
-
-  /* Before we grovel forever, see if the history_expansion_char appears
-     anywhere within the text. */
-
-  /* The quick substitution character is a history expansion all right.  That
-     is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,
-     that is the substitution that we do. */
-  if (hstring[0] == history_subst_char)
-    {
-      string = xmalloc (l + 5);
-
-      string[0] = string[1] = history_expansion_char;
-      string[2] = ':';
-      string[3] = 's';
-      strcpy (string + 4, hstring);
-      l += 4;
-    }
-  else
-    {
-      string = hstring;
-      /* If not quick substitution, still maybe have to do expansion. */
-
-      /* `!' followed by one of the characters in history_no_expand_chars
-	 is NOT an expansion. */
-      for (i = 0; string[i]; i++)
-	{
-	  cc = string[i + 1];
-	  /* The history_comment_char, if set, appearing that the beginning
-	     of a word signifies that the rest of the line should not have
-	     history expansion performed on it.
-	     Skip the rest of the line and break out of the loop. */
-	  if (history_comment_char && string[i] == history_comment_char &&
-	      (i == 0 || member (string[i - 1], history_word_delimiters)))
-	    {
-	      while (string[i])
-		i++;
-	      break;
-	    }
-	  else if (string[i] == history_expansion_char)
-	    {
-	      if (!cc || member (cc, history_no_expand_chars))
-		continue;
-	      /* If the calling application has set
-		 history_inhibit_expansion_function to a function that checks
-		 for special cases that should not be history expanded,
-		 call the function and skip the expansion if it returns a
-		 non-zero value. */
-	      else if (history_inhibit_expansion_function &&
-			(*history_inhibit_expansion_function) (string, i))
-		continue;
-	      else
-		break;
-	    }
-	  /* XXX - at some point, might want to extend this to handle
-		   double quotes as well. */
-	  else if (history_quotes_inhibit_expansion && string[i] == '\'')
-	    {
-	      /* If this is bash, single quotes inhibit history expansion. */
-	      i++;
-	      hist_string_extract_single_quoted (string, &i);
-	    }
-	  else if (history_quotes_inhibit_expansion && string[i] == '\\')
-	    {
-	      /* If this is bash, allow backslashes to quote single
-		 quotes and the history expansion character. */
-	      if (cc == '\'' || cc == history_expansion_char)
-		i++;
-	    }
-	}
-	  
-      if (string[i] != history_expansion_char)
-	{
-	  free (result);
-	  *output = savestring (string);
-	  return (0);
-	}
-    }
-
-  /* Extract and perform the substitution. */
-  for (passc = i = j = 0; i < l; i++)
-    {
-      int tchar = string[i];
-
-      if (passc)
-	{
-	  passc = 0;
-	  ADD_CHAR (tchar);
-	  continue;
-	}
-
-      if (tchar == history_expansion_char)
-	tchar = -3;
-      else if (tchar == history_comment_char)
-	tchar = -2;
-
-      switch (tchar)
-	{
-	default:
-	  ADD_CHAR (string[i]);
-	  break;
-
-	case '\\':
-	  passc++;
-	  ADD_CHAR (tchar);
-	  break;
-
-	case '\'':
-	  {
-	    /* If history_quotes_inhibit_expansion is set, single quotes
-	       inhibit history expansion. */
-	    if (history_quotes_inhibit_expansion)
-	      {
-		int quote, slen;
-
-		quote = i++;
-		hist_string_extract_single_quoted (string, &i);
-
-		slen = i - quote + 2;
-		temp = xmalloc (slen);
-		strncpy (temp, string + quote, slen);
-		temp[slen - 1] = '\0';
-		ADD_STRING (temp);
-		free (temp);
-	      }
-	    else
-	      ADD_CHAR (string[i]);
-	    break;
-	  }
-
-	case -2:		/* history_comment_char */
-	  if (i == 0 || member (string[i - 1], history_word_delimiters))
-	    {
-	      temp = xmalloc (l - i + 1);
-	      strcpy (temp, string + i);
-	      ADD_STRING (temp);
-	      free (temp);
-	      i = l;
-	    }
-	  else
-	    ADD_CHAR (string[i]);
-	  break;
-
-	case -3:		/* history_expansion_char */
-	  cc = string[i + 1];
-
-	  /* If the history_expansion_char is followed by one of the
-	     characters in history_no_expand_chars, then it is not a
-	     candidate for expansion of any kind. */
-	  if (member (cc, history_no_expand_chars))
-	    {
-	      ADD_CHAR (string[i]);
-	      break;
-	    }
-
-#if defined (NO_BANG_HASH_MODIFIERS)
-	  /* There is something that is listed as a `word specifier' in csh
-	     documentation which means `the expanded text to this point'.
-	     That is not a word specifier, it is an event specifier.  If we
-	     don't want to allow modifiers with `!#', just stick the current
-	     output line in again. */
-	  if (cc == '#')
-	    {
-	      if (result)
-		{
-		  temp = xmalloc (1 + strlen (result));
-		  strcpy (temp, result);
-		  ADD_STRING (temp);
-		  free (temp);
-		}
-	      i++;
-	      break;
-	    }
-#endif
-
-	  r = history_expand_internal (string, i, &eindex, &temp, result);
-	  if (r < 0)
-	    {
-	      *output = temp;
-	      free (result);
-	      if (string != hstring)
-		free (string);
-	      return -1;
-	    }
-	  else
-	    {
-	      if (temp)
-		{
-		  modified++;
-		  if (*temp)
-		    ADD_STRING (temp);
-		  free (temp);
-		}
-	      only_printing = r == 1;
-	      i = eindex;
-	    }
-	  break;
-	}
-    }
-
-  *output = result;
-  if (string != hstring)
-    free (string);
-
-  if (only_printing)
-    {
-      add_history (result);
-      return (2);
-    }
-
-  return (modified != 0);
-}
-
-/* Return a consed string which is the word specified in SPEC, and found
-   in FROM.  NULL is returned if there is no spec.  The address of
-   ERROR_POINTER is returned if the word specified cannot be found.
-   CALLER_INDEX is the offset in SPEC to start looking; it is updated
-   to point to just after the last character parsed. */
-static char *
-get_history_word_specifier (spec, from, caller_index)
-     char *spec, *from;
-     int *caller_index;
-{
-  register int i = *caller_index;
-  int first, last;
-  int expecting_word_spec = 0;
-  char *result;
-
-  /* The range of words to return doesn't exist yet. */
-  first = last = 0;
-  result = (char *)NULL;
-
-  /* If we found a colon, then this *must* be a word specification.  If
-     it isn't, then it is an error. */
-  if (spec[i] == ':')
-    {
-      i++;
-      expecting_word_spec++;
-    }
-
-  /* Handle special cases first. */
-
-  /* `%' is the word last searched for. */
-  if (spec[i] == '%')
-    {
-      *caller_index = i + 1;
-      return (search_match ? savestring (search_match) : savestring (""));
-    }
-
-  /* `*' matches all of the arguments, but not the command. */
-  if (spec[i] == '*')
-    {
-      *caller_index = i + 1;
-      result = history_arg_extract (1, '$', from);
-      return (result ? result : savestring (""));
-    }
-
-  /* `$' is last arg. */
-  if (spec[i] == '$')
-    {
-      *caller_index = i + 1;
-      return (history_arg_extract ('$', '$', from));
-    }
-
-  /* Try to get FIRST and LAST figured out. */
-
-  if (spec[i] == '-')
-    first = 0;
-  else if (spec[i] == '^')
-    first = 1;
-  else if (_rl_digit_p (spec[i]) && expecting_word_spec)
-    {
-      for (first = 0; _rl_digit_p (spec[i]); i++)
-	first = (first * 10) + _rl_digit_value (spec[i]);
-    }
-  else
-    return ((char *)NULL);	/* no valid `first' for word specifier */
-
-  if (spec[i] == '^' || spec[i] == '*')
-    {
-      last = (spec[i] == '^') ? 1 : '$';	/* x* abbreviates x-$ */
-      i++;
-    }
-  else if (spec[i] != '-')
-    last = first;
-  else
-    {
-      i++;
-
-      if (_rl_digit_p (spec[i]))
-	{
-	  for (last = 0; _rl_digit_p (spec[i]); i++)
-	    last = (last * 10) + _rl_digit_value (spec[i]);
-	}
-      else if (spec[i] == '$')
-	{
-	  i++;
-	  last = '$';
-	}
-      else if (!spec[i] || spec[i] == ':')  /* could be modifier separator */
-	last = -1;		/* x- abbreviates x-$ omitting word `$' */
-    }
-
-  *caller_index = i;
-
-  if (last >= first || last == '$' || last < 0)
-    result = history_arg_extract (first, last, from);
-
-  return (result ? result : (char *)&error_pointer);
-}
-
-/* Extract the args specified, starting at FIRST, and ending at LAST.
-   The args are taken from STRING.  If either FIRST or LAST is < 0,
-   then make that arg count from the right (subtract from the number of
-   tokens, so that FIRST = -1 means the next to last token on the line).
-   If LAST is `$' the last arg from STRING is used. */
-char *
-history_arg_extract (first, last, string)
-     int first, last;
-     const char *string;
-{
-  register int i, len;
-  char *result;
-  int size, offset;
-  char **list;
-
-  /* XXX - think about making history_tokenize return a struct array,
-     each struct in array being a string and a length to avoid the
-     calls to strlen below. */
-  if ((list = history_tokenize (string)) == NULL)
-    return ((char *)NULL);
-
-  for (len = 0; list[len]; len++)
-    ;
-
-  if (last < 0)
-    last = len + last - 1;
-
-  if (first < 0)
-    first = len + first - 1;
-
-  if (last == '$')
-    last = len - 1;
-
-  if (first == '$')
-    first = len - 1;
-
-  last++;
-
-  if (first >= len || last > len || first < 0 || last < 0 || first > last)
-    result = ((char *)NULL);
-  else
-    {
-      for (size = 0, i = first; i < last; i++)
-	size += strlen (list[i]) + 1;
-      result = xmalloc (size + 1);
-      result[0] = '\0';
-
-      for (i = first, offset = 0; i < last; i++)
-	{
-	  strcpy (result + offset, list[i]);
-	  offset += strlen (list[i]);
-	  if (i + 1 < last)
-	    {
-      	      result[offset++] = ' ';
-	      result[offset] = 0;
-	    }
-	}
-    }
-
-  for (i = 0; i < len; i++)
-    free (list[i]);
-  free (list);
-
-  return (result);
-}
-
-#define slashify_in_quotes "\\`\"$"
-
-/* Parse STRING into tokens and return an array of strings.  If WIND is
-   not -1 and INDP is not null, we also want the word surrounding index
-   WIND.  The position in the returned array of strings is returned in
-   *INDP. */
-static char **
-history_tokenize_internal (string, wind, indp)
-     const char *string;
-     int wind, *indp;
-{
-  char **result;
-  register int i, start, result_index, size;
-  int len, delimiter;
-
-  /* If we're searching for a string that's not part of a word (e.g., " "),
-     make sure we set *INDP to a reasonable value. */
-  if (indp && wind != -1)
-    *indp = -1;
-
-  /* Get a token, and stuff it into RESULT.  The tokens are split
-     exactly where the shell would split them. */
-  for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
-    {
-      delimiter = 0;
-
-      /* Skip leading whitespace. */
-      for (; string[i] && whitespace (string[i]); i++)
-	;
-      if (string[i] == 0 || string[i] == history_comment_char)
-	return (result);
-
-      start = i;
-      
-      if (member (string[i], "()\n"))
-	{
-	  i++;
-	  goto got_token;
-	}
-
-      if (member (string[i], "<>;&|$"))
-	{
-	  int peek = string[i + 1];
-
-	  if (peek == string[i] && peek != '$')
-	    {
-	      if (peek == '<' && string[i + 2] == '-')
-		i++;
-	      i += 2;
-	      goto got_token;
-	    }
-	  else
-	    {
-	      if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||
-		  ((peek == '>') && (string[i] == '&')) ||
-		  ((peek == '(') && (string[i] == '$')))
-		{
-		  i += 2;
-		  goto got_token;
-		}
-	    }
-	  if (string[i] != '$')
-	    {
-	      i++;
-	      goto got_token;
-	    }
-	}
-
-      /* Get word from string + i; */
-
-      if (member (string[i], HISTORY_QUOTE_CHARACTERS))
-	delimiter = string[i++];
-
-      for (; string[i]; i++)
-	{
-	  if (string[i] == '\\' && string[i + 1] == '\n')
-	    {
-	      i++;
-	      continue;
-	    }
-
-	  if (string[i] == '\\' && delimiter != '\'' &&
-	      (delimiter != '"' || member (string[i], slashify_in_quotes)))
-	    {
-	      i++;
-	      continue;
-	    }
-
-	  if (delimiter && string[i] == delimiter)
-	    {
-	      delimiter = 0;
-	      continue;
-	    }
-
-	  if (!delimiter && (member (string[i], history_word_delimiters)))
-	    break;
-
-	  if (!delimiter && member (string[i], HISTORY_QUOTE_CHARACTERS))
-	    delimiter = string[i];
-	}
-
-    got_token:
-
-      /* If we are looking for the word in which the character at a
-	 particular index falls, remember it. */
-      if (indp && wind != -1 && wind >= start && wind < i)
-        *indp = result_index;
-
-      len = i - start;
-      if (result_index + 2 >= size)
-	result = (char **)xrealloc (result, ((size += 10) * sizeof (char *)));
-      result[result_index] = xmalloc (1 + len);
-      strncpy (result[result_index], string + start, len);
-      result[result_index][len] = '\0';
-      result[++result_index] = (char *)NULL;
-    }
-
-  return (result);
-}
-
-/* Return an array of tokens, much as the shell might.  The tokens are
-   parsed out of STRING. */
-char **
-history_tokenize (string)
-     const char *string;
-{
-  return (history_tokenize_internal (string, -1, (int *)NULL));
-}
-
-/* Find and return the word which contains the character at index IND
-   in the history line LINE.  Used to save the word matched by the
-   last history !?string? search. */
-static char *
-history_find_word (line, ind)
-     char *line;
-     int ind;
-{
-  char **words, *s;
-  int i, wind;
-
-  words = history_tokenize_internal (line, ind, &wind);
-  if (wind == -1 || words == 0)
-    return ((char *)NULL);
-  s = words[wind];
-  for (i = 0; i < wind; i++)
-    free (words[i]);
-  for (i = wind + 1; words[i]; i++)
-    free (words[i]);
-  free (words);
-  return s;
-}
diff --git a/readline/histfile.c b/readline/histfile.c
deleted file mode 100644
--- a/readline/histfile.c
+++ /dev/null
@@ -1,409 +0,0 @@
-/* histfile.c - functions to manipulate the history file. */
-
-/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
-
-   This file contains the GNU History Library (the Library), a set of
-   routines for managing the text of previously typed lines.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-/* The goal is to make the implementation transparent, so that you
-   don't have to know what data types are used, just what functions
-   you can call.  I think I have done that. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-
-#include <sys/types.h>
-#ifndef _MINIX
-#  include <sys/file.h>
-#endif
-#include "posixstat.h"
-#include <fcntl.h>
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif
-
-#if defined (HAVE_STRING_H)
-#  include <string.h>
-#else
-#  include <strings.h>
-#endif /* !HAVE_STRING_H */
-
-
-/* If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment
-   on win 95/98/nt), we want to open files with O_BINARY mode so that there
-   is no \n -> \r\n conversion performed.  On other systems, we don't want to
-   mess around with O_BINARY at all, so we ensure that it's defined to 0. */
-#if defined (__EMX__) || defined (__CYGWIN__)
-#  ifndef O_BINARY
-#    define O_BINARY 0
-#  endif
-#else /* !__EMX__ && !__CYGWIN__ */
-#  undef O_BINARY
-#  define O_BINARY 0
-#endif /* !__EMX__ && !__CYGWIN__ */
-
-#include <errno.h>
-#if !defined (errno)
-extern int errno;
-#endif /* !errno */
-
-#include "history.h"
-#include "histlib.h"
-
-#include "rlshell.h"
-#include "xmalloc.h"
-
-/* Return the string that should be used in the place of this
-   filename.  This only matters when you don't specify the
-   filename to read_history (), or write_history (). */
-static char *
-history_filename (filename)
-     const char *filename;
-{
-  char *return_val;
-  const char *home;
-  int home_len;
-
-  return_val = filename ? savestring (filename) : (char *)NULL;
-
-  if (return_val)
-    return (return_val);
-  
-  home = sh_get_env_value ("HOME");
-
-  if (home == 0)
-    {
-      home = ".";
-      home_len = 1;
-    }
-  else
-    home_len = strlen (home);
-
-  return_val = xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
-  strcpy (return_val, home);
-  return_val[home_len] = '/';
-#if defined (__MSDOS__)
-  strcpy (return_val + home_len + 1, "_history");
-#else
-  strcpy (return_val + home_len + 1, ".history");
-#endif
-
-  return (return_val);
-}
-
-/* Add the contents of FILENAME to the history list, a line at a time.
-   If FILENAME is NULL, then read from ~/.history.  Returns 0 if
-   successful, or errno if not. */
-int
-read_history (filename)
-     const char *filename;
-{
-  return (read_history_range (filename, 0, -1));
-}
-
-/* Read a range of lines from FILENAME, adding them to the history list.
-   Start reading at the FROM'th line and end at the TO'th.  If FROM
-   is zero, start at the beginning.  If TO is less than FROM, read
-   until the end of the file.  If FILENAME is NULL, then read from
-   ~/.history.  Returns 0 if successful, or errno if not. */
-int
-read_history_range (filename, from, to)
-     const char *filename;
-     int from, to;
-{
-  register int line_start, line_end;
-  char *input, *buffer;
-  int file, current_line, chars_read;
-  struct stat finfo;
-  size_t file_size;
-
-  buffer = (char *)NULL;
-  input = history_filename (filename);
-  file = open (input, O_RDONLY|O_BINARY, 0666);
-
-  if ((file < 0) || (fstat (file, &finfo) == -1))
-    goto error_and_exit;
-
-  file_size = (size_t)finfo.st_size;
-
-  /* check for overflow on very large files */
-  if (file_size != finfo.st_size || file_size + 1 < file_size)
-    {
-#if defined (EFBIG)
-      errno = EFBIG;
-#endif
-      goto error_and_exit;
-    }
-
-  buffer = xmalloc (file_size + 1);
-
-  chars_read = read (file, buffer, file_size);
-  if (chars_read < 0)
-    {
-  error_and_exit:
-      if (file >= 0)
-	close (file);
-
-      FREE (input);
-      FREE (buffer);
-
-      return (errno);
-    }
-
-  close (file);
-
-  /* Set TO to larger than end of file if negative. */
-  if (to < 0)
-    to = chars_read;
-
-  /* Start at beginning of file, work to end. */
-  line_start = line_end = current_line = 0;
-
-  /* Skip lines until we are at FROM. */
-  while (line_start < chars_read && current_line < from)
-    {
-      for (line_end = line_start; line_end < chars_read; line_end++)
-	if (buffer[line_end] == '\n')
-	  {
-	    current_line++;
-	    line_start = line_end + 1;
-	    if (current_line == from)
-	      break;
-	  }
-    }
-
-  /* If there are lines left to gobble, then gobble them now. */
-  for (line_end = line_start; line_end < chars_read; line_end++)
-    if (buffer[line_end] == '\n')
-      {
-	buffer[line_end] = '\0';
-
-	if (buffer[line_start])
-	  add_history (buffer + line_start);
-
-	current_line++;
-
-	if (current_line >= to)
-	  break;
-
-	line_start = line_end + 1;
-      }
-
-  FREE (input);
-  FREE (buffer);
-
-  return (0);
-}
-
-/* Truncate the history file FNAME, leaving only LINES trailing lines.
-   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
-   on failure. */
-int
-history_truncate_file (fname, lines)
-     const char *fname;
-     int lines;
-{
-  register int i;
-  int file, chars_read, rv;
-  char *buffer, *filename;
-  struct stat finfo;
-  size_t file_size;
-
-  buffer = (char *)NULL;
-  filename = history_filename (fname);
-  file = open (filename, O_RDONLY|O_BINARY, 0666);
-  rv = 0;
-
-  /* Don't try to truncate non-regular files. */
-  if (file == -1 || fstat (file, &finfo) == -1)
-    {
-      rv = errno;
-      if (file != -1)
-	close (file);
-      goto truncate_exit;
-    }
-
-  if (S_ISREG (finfo.st_mode) == 0)
-    {
-      close (file);
-#ifdef EFTYPE
-      rv = EFTYPE;
-#else
-      rv = EINVAL;
-#endif
-      goto truncate_exit;
-    }
-
-  file_size = (size_t)finfo.st_size;
-
-  /* check for overflow on very large files */
-  if (file_size != finfo.st_size || file_size + 1 < file_size)
-    {
-      close (file);
-#if defined (EFBIG)
-      rv = errno = EFBIG;
-#elif defined (EOVERFLOW)
-      rv = errno = EOVERFLOW;
-#else
-      rv = errno = EINVAL;
-#endif
-      goto truncate_exit;
-    }
-
-  buffer = xmalloc (file_size + 1);
-  chars_read = read (file, buffer, file_size);
-  close (file);
-
-  if (chars_read <= 0)
-    {
-      rv = (chars_read < 0) ? errno : 0;
-      goto truncate_exit;
-    }
-
-  /* Count backwards from the end of buffer until we have passed
-     LINES lines. */
-  for (i = chars_read - 1; lines && i; i--)
-    {
-      if (buffer[i] == '\n')
-	lines--;
-    }
-
-  /* If this is the first line, then the file contains exactly the
-     number of lines we want to truncate to, so we don't need to do
-     anything.  It's the first line if we don't find a newline between
-     the current value of i and 0.  Otherwise, write from the start of
-     this line until the end of the buffer. */
-  for ( ; i; i--)
-    if (buffer[i] == '\n')
-      {
-	i++;
-	break;
-      }
-
-  /* Write only if there are more lines in the file than we want to
-     truncate to. */
-  if (i && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))
-    {
-      write (file, buffer + i, chars_read - i);
-
-#if defined (__BEOS__)
-      /* BeOS ignores O_TRUNC. */
-      ftruncate (file, chars_read - i);
-#endif
-
-      close (file);
-    }
-
- truncate_exit:
-
-  FREE (buffer);
-
-  free (filename);
-  return rv;
-}
-
-/* Workhorse function for writing history.  Writes NELEMENT entries
-   from the history list to FILENAME.  OVERWRITE is non-zero if you
-   wish to replace FILENAME with the entries. */
-static int
-history_do_write (filename, nelements, overwrite)
-     const char *filename;
-     int nelements, overwrite;
-{
-  register int i;
-  char *output;
-  int file, mode, rv;
-
-  mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
-  output = history_filename (filename);
-  rv = 0;
-
-  if ((file = open (output, mode, 0600)) == -1)
-    {
-      FREE (output);
-      return (errno);
-    }
-
-  if (nelements > history_length)
-    nelements = history_length;
-
-  /* Build a buffer of all the lines to write, and write them in one syscall.
-     Suggested by Peter Ho (peter@robosts.oxford.ac.uk). */
-  {
-    HIST_ENTRY **the_history;	/* local */
-    register int j;
-    int buffer_size;
-    char *buffer;
-
-    the_history = history_list ();
-    /* Calculate the total number of bytes to write. */
-    for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)
-      buffer_size += 1 + strlen (the_history[i]->line);
-
-    /* Allocate the buffer, and fill it. */
-    buffer = xmalloc (buffer_size);
-
-    for (j = 0, i = history_length - nelements; i < history_length; i++)
-      {
-	strcpy (buffer + j, the_history[i]->line);
-	j += strlen (the_history[i]->line);
-	buffer[j++] = '\n';
-      }
-
-    if (write (file, buffer, buffer_size) < 0)
-      rv = errno;
-    free (buffer);
-  }
-
-  close (file);
-
-  FREE (output);
-
-  return (rv);
-}
-
-/* Append NELEMENT entries to FILENAME.  The entries appended are from
-   the end of the list minus NELEMENTs up to the end of the list. */
-int
-append_history (nelements, filename)
-     int nelements;
-     const char *filename;
-{
-  return (history_do_write (filename, nelements, HISTORY_APPEND));
-}
-
-/* Overwrite FILENAME with the current history.  If FILENAME is NULL,
-   then write the history list to ~/.history.  Values returned
-   are as in read_history ().*/
-int
-write_history (filename)
-     const char *filename;
-{
-  return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
-}
diff --git a/readline/histlib.h b/readline/histlib.h
deleted file mode 100644
--- a/readline/histlib.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/* histlib.h -- internal definitions for the history library. */
-/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
-
-   This file contains the GNU History Library (the Library), a set of
-   routines for managing the text of previously typed lines.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_HISTLIB_H_)
-#define _HISTLIB_H_
-
-#if !defined (STREQ)
-#define STREQ(a, b)	(((a)[0] == (b)[0]) && (strcmp ((a), (b)) == 0))
-#define STREQN(a, b, n) (((n) == 0) ? (1) \
-				    : ((a)[0] == (b)[0]) && (strncmp ((a), (b), (n)) == 0))
-#endif
-
-#ifndef savestring
-#  ifndef strcpy
-extern char *strcpy ();
-#  endif
-#define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
-#endif
-
-#ifndef whitespace
-#define whitespace(c) (((c) == ' ') || ((c) == '\t'))
-#endif
-
-#ifndef _rl_digit_p
-#define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
-#endif
-
-#ifndef _rl_digit_value
-#define _rl_digit_value(c) ((c) - '0')
-#endif
-
-#ifndef member
-#  ifndef strchr
-extern char *strchr ();
-#  endif
-#define member(c, s) ((c) ? ((char *)strchr ((s), (c)) != (char *)NULL) : 0)
-#endif
-
-#ifndef FREE
-#  define FREE(x)	if (x) free (x)
-#endif
-
-/* Possible history errors passed to hist_error. */
-#define EVENT_NOT_FOUND 0
-#define BAD_WORD_SPEC	1
-#define SUBST_FAILED	2
-#define BAD_MODIFIER	3
-#define NO_PREV_SUBST	4
-
-/* Possible definitions for history starting point specification. */
-#define ANCHORED_SEARCH 1
-#define NON_ANCHORED_SEARCH 0
-
-/* Possible definitions for what style of writing the history file we want. */
-#define HISTORY_APPEND 0
-#define HISTORY_OVERWRITE 1
-
-/* Some variable definitions shared across history source files. */
-extern int history_offset;
-
-#endif /* !_HISTLIB_H_ */
diff --git a/readline/history.c b/readline/history.c
deleted file mode 100644
--- a/readline/history.c
+++ /dev/null
@@ -1,387 +0,0 @@
-/* History.c -- standalone history library */
-
-/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
-
-   This file contains the GNU History Library (the Library), a set of
-   routines for managing the text of previously typed lines.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-/* The goal is to make the implementation transparent, so that you
-   don't have to know what data types are used, just what functions
-   you can call.  I think I have done that. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#if defined (HAVE_UNISTD_H)
-#  ifdef _MINIX
-#    include <sys/types.h>
-#  endif
-#  include <unistd.h>
-#endif
-
-#if defined (HAVE_STRING_H)
-#  include <string.h>
-#else
-#  include <strings.h>
-#endif /* !HAVE_STRING_H */
-
-#include "history.h"
-#include "histlib.h"
-
-#include "xmalloc.h"
-
-/* The number of slots to increase the_history by. */
-#define DEFAULT_HISTORY_GROW_SIZE 50
-
-/* **************************************************************** */
-/*								    */
-/*			History Functions			    */
-/*								    */
-/* **************************************************************** */
-
-/* An array of HIST_ENTRY.  This is where we store the history. */
-static HIST_ENTRY **the_history = (HIST_ENTRY **)NULL;
-
-/* Non-zero means that we have enforced a limit on the amount of
-   history that we save. */
-static int history_stifled;
-
-/* If HISTORY_STIFLED is non-zero, then this is the maximum number of
-   entries to remember. */
-int history_max_entries;
-int max_input_history;	/* backwards compatibility */
-
-/* The current location of the interactive history pointer.  Just makes
-   life easier for outside callers. */
-int history_offset;
-
-/* The number of strings currently stored in the history list. */
-int history_length;
-
-/* The current number of slots allocated to the input_history. */
-static int history_size;
-
-/* The logical `base' of the history array.  It defaults to 1. */
-int history_base = 1;
-
-/* Return the current HISTORY_STATE of the history. */
-HISTORY_STATE *
-history_get_history_state ()
-{
-  HISTORY_STATE *state;
-
-  state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));
-  state->entries = the_history;
-  state->offset = history_offset;
-  state->length = history_length;
-  state->size = history_size;
-  state->flags = 0;
-  if (history_stifled)
-    state->flags |= HS_STIFLED;
-
-  return (state);
-}
-
-/* Set the state of the current history array to STATE. */
-void
-history_set_history_state (state)
-     HISTORY_STATE *state;
-{
-  the_history = state->entries;
-  history_offset = state->offset;
-  history_length = state->length;
-  history_size = state->size;
-  if (state->flags & HS_STIFLED)
-    history_stifled = 1;
-}
-
-/* Begin a session in which the history functions might be used.  This
-   initializes interactive variables. */
-void
-using_history ()
-{
-  history_offset = history_length;
-}
-
-/* Return the number of bytes that the primary history entries are using.
-   This just adds up the lengths of the_history->lines. */
-int
-history_total_bytes ()
-{
-  register int i, result;
-
-  for (i = result = 0; the_history && the_history[i]; i++)
-    result += strlen (the_history[i]->line);
-
-  return (result);
-}
-
-/* Returns the magic number which says what history element we are
-   looking at now.  In this implementation, it returns history_offset. */
-int
-where_history ()
-{
-  return (history_offset);
-}
-
-/* Make the current history item be the one at POS, an absolute index.
-   Returns zero if POS is out of range, else non-zero. */
-int
-history_set_pos (pos)
-     int pos;
-{
-  if (pos > history_length || pos < 0 || !the_history)
-    return (0);
-  history_offset = pos;
-  return (1);
-}
- 
-/* Return the current history array.  The caller has to be carefull, since this
-   is the actual array of data, and could be bashed or made corrupt easily.
-   The array is terminated with a NULL pointer. */
-HIST_ENTRY **
-history_list ()
-{
-  return (the_history);
-}
-
-/* Return the history entry at the current position, as determined by
-   history_offset.  If there is no entry there, return a NULL pointer. */
-HIST_ENTRY *
-current_history ()
-{
-  return ((history_offset == history_length) || the_history == 0)
-		? (HIST_ENTRY *)NULL
-		: the_history[history_offset];
-}
-
-/* Back up history_offset to the previous history entry, and return
-   a pointer to that entry.  If there is no previous entry then return
-   a NULL pointer. */
-HIST_ENTRY *
-previous_history ()
-{
-  return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)NULL;
-}
-
-/* Move history_offset forward to the next history entry, and return
-   a pointer to that entry.  If there is no next entry then return a
-   NULL pointer. */
-HIST_ENTRY *
-next_history ()
-{
-  return (history_offset == history_length) ? (HIST_ENTRY *)NULL : the_history[++history_offset];
-}
-
-/* Return the history entry which is logically at OFFSET in the history array.
-   OFFSET is relative to history_base. */
-HIST_ENTRY *
-history_get (offset)
-     int offset;
-{
-  int local_index;
-
-  local_index = offset - history_base;
-  return (local_index >= history_length || local_index < 0 || !the_history)
-		? (HIST_ENTRY *)NULL
-		: the_history[local_index];
-}
-
-/* Place STRING at the end of the history list.  The data field
-   is  set to NULL. */
-void
-add_history (string)
-     const char *string;
-{
-  HIST_ENTRY *temp;
-
-  if (history_stifled && (history_length == history_max_entries))
-    {
-      register int i;
-
-      /* If the history is stifled, and history_length is zero,
-	 and it equals history_max_entries, we don't save items. */
-      if (history_length == 0)
-	return;
-
-      /* If there is something in the slot, then remove it. */
-      if (the_history[0])
-	{
-	  free (the_history[0]->line);
-	  free (the_history[0]);
-	}
-
-      /* Copy the rest of the entries, moving down one slot. */
-      for (i = 0; i < history_length; i++)
-	the_history[i] = the_history[i + 1];
-
-      history_base++;
-    }
-  else
-    {
-      if (history_size == 0)
-	{
-	  history_size = DEFAULT_HISTORY_GROW_SIZE;
-	  the_history = (HIST_ENTRY **)xmalloc (history_size * sizeof (HIST_ENTRY *));
-	  history_length = 1;
-	}
-      else
-	{
-	  if (history_length == (history_size - 1))
-	    {
-	      history_size += DEFAULT_HISTORY_GROW_SIZE;
-	      the_history = (HIST_ENTRY **)
-		xrealloc (the_history, history_size * sizeof (HIST_ENTRY *));
-	    }
-	  history_length++;
-	}
-    }
-
-  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-  temp->line = savestring (string);
-  temp->data = (char *)NULL;
-
-  the_history[history_length] = (HIST_ENTRY *)NULL;
-  the_history[history_length - 1] = temp;
-}
-
-/* Make the history entry at WHICH have LINE and DATA.  This returns
-   the old entry so you can dispose of the data.  In the case of an
-   invalid WHICH, a NULL pointer is returned. */
-HIST_ENTRY *
-replace_history_entry (which, line, data)
-     int which;
-     const char *line;
-     histdata_t data;
-{
-  HIST_ENTRY *temp, *old_value;
-
-  if (which >= history_length)
-    return ((HIST_ENTRY *)NULL);
-
-  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-  old_value = the_history[which];
-
-  temp->line = savestring (line);
-  temp->data = data;
-  the_history[which] = temp;
-
-  return (old_value);
-}
-
-/* Remove history element WHICH from the history.  The removed
-   element is returned to you so you can free the line, data,
-   and containing structure. */
-HIST_ENTRY *
-remove_history (which)
-     int which;
-{
-  HIST_ENTRY *return_value;
-  register int i;
-
-  if (which >= history_length || !history_length)
-    return_value = (HIST_ENTRY *)NULL;
-  else
-    {
-      return_value = the_history[which];
-
-      for (i = which; i < history_length; i++)
-	the_history[i] = the_history[i + 1];
-
-      history_length--;
-    }
-
-  return (return_value);
-}
-
-/* Stifle the history list, remembering only MAX number of lines. */
-void
-stifle_history (max)
-     int max;
-{
-  register int i, j;
-
-  if (max < 0)
-    max = 0;
-
-  if (history_length > max)
-    {
-      /* This loses because we cannot free the data. */
-      for (i = 0, j = history_length - max; i < j; i++)
-	{
-	  free (the_history[i]->line);
-	  free (the_history[i]);
-	}
-
-      history_base = i;
-      for (j = 0, i = history_length - max; j < max; i++, j++)
-	the_history[j] = the_history[i];
-      the_history[j] = (HIST_ENTRY *)NULL;
-      history_length = j;
-    }
-
-  history_stifled = 1;
-  max_input_history = history_max_entries = max;
-}
-
-/* Stop stifling the history.  This returns the previous amount the 
-   history was stifled by.  The value is positive if the history was
-   stifled,  negative if it wasn't. */
-int
-unstifle_history ()
-{
-  if (history_stifled)
-    {
-      history_stifled = 0;
-      return (-history_max_entries);
-    }
-
-  return (history_max_entries);
-}
-
-int
-history_is_stifled ()
-{
-  return (history_stifled);
-}
-
-void
-clear_history ()
-{
-  register int i;
-
-  /* This loses because we cannot free the data. */
-  for (i = 0; i < history_length; i++)
-    {
-      free (the_history[i]->line);
-      free (the_history[i]);
-      the_history[i] = (HIST_ENTRY *)NULL;
-    }
-
-  history_offset = history_length = 0;
-}
diff --git a/readline/history.h b/readline/history.h
deleted file mode 100644
--- a/readline/history.h
+++ /dev/null
@@ -1,246 +0,0 @@
-/* History.h -- the names of functions that you can call in history. */
-/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
-
-   This file contains the GNU History Library (the Library), a set of
-   routines for managing the text of previously typed lines.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#ifndef _HISTORY_H_
-#define _HISTORY_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if defined READLINE_LIBRARY
-#  include "rlstdc.h"
-#  include "rltypedefs.h"
-#else
-#  include <readline/rlstdc.h>
-#  include <readline/rltypedefs.h>
-#endif
-
-#ifdef __STDC__
-typedef void *histdata_t;
-#else
-typedef char *histdata_t;
-#endif
-
-/* The structure used to store a history entry. */
-typedef struct _hist_entry {
-  char *line;
-  histdata_t data;
-} HIST_ENTRY;
-
-/* A structure used to pass the current state of the history stuff around. */
-typedef struct _hist_state {
-  HIST_ENTRY **entries;		/* Pointer to the entries themselves. */
-  int offset;			/* The location pointer within this array. */
-  int length;			/* Number of elements within this array. */
-  int size;			/* Number of slots allocated to this array. */
-  int flags;
-} HISTORY_STATE;
-
-/* Flag values for the `flags' member of HISTORY_STATE. */
-#define HS_STIFLED	0x01
-
-/* Initialization and state management. */
-
-/* Begin a session in which the history functions might be used.  This
-   just initializes the interactive variables. */
-extern void using_history __P((void));
-
-/* Return the current HISTORY_STATE of the history. */
-extern HISTORY_STATE *history_get_history_state __P((void));
-
-/* Set the state of the current history array to STATE. */
-extern void history_set_history_state __P((HISTORY_STATE *));
-
-/* Manage the history list. */
-
-/* Place STRING at the end of the history list.
-   The associated data field (if any) is set to NULL. */
-extern void add_history __P((const char *));
-
-/* A reasonably useless function, only here for completeness.  WHICH
-   is the magic number that tells us which element to delete.  The
-   elements are numbered from 0. */
-extern HIST_ENTRY *remove_history __P((int));
-
-/* Make the history entry at WHICH have LINE and DATA.  This returns
-   the old entry so you can dispose of the data.  In the case of an
-   invalid WHICH, a NULL pointer is returned. */
-extern HIST_ENTRY *replace_history_entry __P((int, const char *, histdata_t));
-
-/* Clear the history list and start over. */
-extern void clear_history __P((void));
-
-/* Stifle the history list, remembering only MAX number of entries. */
-extern void stifle_history __P((int));
-
-/* Stop stifling the history.  This returns the previous amount the
-   history was stifled by.  The value is positive if the history was
-   stifled, negative if it wasn't. */
-extern int unstifle_history __P((void));
-
-/* Return 1 if the history is stifled, 0 if it is not. */
-extern int history_is_stifled __P((void));
-
-/* Information about the history list. */
-
-/* Return a NULL terminated array of HIST_ENTRY which is the current input
-   history.  Element 0 of this list is the beginning of time.  If there
-   is no history, return NULL. */
-extern HIST_ENTRY **history_list __P((void));
-
-/* Returns the number which says what history element we are now
-   looking at.  */
-extern int where_history __P((void));
-  
-/* Return the history entry at the current position, as determined by
-   history_offset.  If there is no entry there, return a NULL pointer. */
-extern HIST_ENTRY *current_history __P((void));
-
-/* Return the history entry which is logically at OFFSET in the history
-   array.  OFFSET is relative to history_base. */
-extern HIST_ENTRY *history_get __P((int));
-
-/* Return the number of bytes that the primary history entries are using.
-   This just adds up the lengths of the_history->lines. */
-extern int history_total_bytes __P((void));
-
-/* Moving around the history list. */
-
-/* Set the position in the history list to POS. */
-extern int history_set_pos __P((int));
-
-/* Back up history_offset to the previous history entry, and return
-   a pointer to that entry.  If there is no previous entry, return
-   a NULL pointer. */
-extern HIST_ENTRY *previous_history __P((void));
-
-/* Move history_offset forward to the next item in the input_history,
-   and return the a pointer to that entry.  If there is no next entry,
-   return a NULL pointer. */
-extern HIST_ENTRY *next_history __P((void));
-
-/* Searching the history list. */
-
-/* Search the history for STRING, starting at history_offset.
-   If DIRECTION < 0, then the search is through previous entries,
-   else through subsequent.  If the string is found, then
-   current_history () is the history entry, and the value of this function
-   is the offset in the line of that history entry that the string was
-   found in.  Otherwise, nothing is changed, and a -1 is returned. */
-extern int history_search __P((const char *, int));
-
-/* Search the history for STRING, starting at history_offset.
-   The search is anchored: matching lines must begin with string.
-   DIRECTION is as in history_search(). */
-extern int history_search_prefix __P((const char *, int));
-
-/* Search for STRING in the history list, starting at POS, an
-   absolute index into the list.  DIR, if negative, says to search
-   backwards from POS, else forwards.
-   Returns the absolute index of the history element where STRING
-   was found, or -1 otherwise. */
-extern int history_search_pos __P((const char *, int, int));
-
-/* Managing the history file. */
-
-/* Add the contents of FILENAME to the history list, a line at a time.
-   If FILENAME is NULL, then read from ~/.history.  Returns 0 if
-   successful, or errno if not. */
-extern int read_history __P((const char *));
-
-/* Read a range of lines from FILENAME, adding them to the history list.
-   Start reading at the FROM'th line and end at the TO'th.  If FROM
-   is zero, start at the beginning.  If TO is less than FROM, read
-   until the end of the file.  If FILENAME is NULL, then read from
-   ~/.history.  Returns 0 if successful, or errno if not. */
-extern int read_history_range __P((const char *, int, int));
-
-/* Write the current history to FILENAME.  If FILENAME is NULL,
-   then write the history list to ~/.history.  Values returned
-   are as in read_history ().  */
-extern int write_history __P((const char *));
-
-/* Append NELEMENT entries to FILENAME.  The entries appended are from
-   the end of the list minus NELEMENTs up to the end of the list. */
-extern int append_history __P((int, const char *));
-
-/* Truncate the history file, leaving only the last NLINES lines. */
-extern int history_truncate_file __P((const char *, int));
-
-/* History expansion. */
-
-/* Expand the string STRING, placing the result into OUTPUT, a pointer
-   to a string.  Returns:
-
-   0) If no expansions took place (or, if the only change in
-      the text was the de-slashifying of the history expansion
-      character)
-   1) If expansions did take place
-  -1) If there was an error in expansion.
-   2) If the returned line should just be printed.
-
-  If an error ocurred in expansion, then OUTPUT contains a descriptive
-  error message. */
-extern int history_expand __P((char *, char **));
-
-/* Extract a string segment consisting of the FIRST through LAST
-   arguments present in STRING.  Arguments are broken up as in
-   the shell. */
-extern char *history_arg_extract __P((int, int, const char *));
-
-/* Return the text of the history event beginning at the current
-   offset into STRING.  Pass STRING with *INDEX equal to the
-   history_expansion_char that begins this specification.
-   DELIMITING_QUOTE is a character that is allowed to end the string
-   specification for what to search for in addition to the normal
-   characters `:', ` ', `\t', `\n', and sometimes `?'. */
-extern char *get_history_event __P((const char *, int *, int));
-
-/* Return an array of tokens, much as the shell might.  The tokens are
-   parsed out of STRING. */
-extern char **history_tokenize __P((const char *));
-
-/* Exported history variables. */
-extern int history_base;
-extern int history_length;
-extern int history_max_entries;
-extern char history_expansion_char;
-extern char history_subst_char;
-extern char *history_word_delimiters;
-extern char history_comment_char;
-extern char *history_no_expand_chars;
-extern char *history_search_delimiter_chars;
-extern int history_quotes_inhibit_expansion;
-
-/* Backwards compatibility */
-extern int max_input_history;
-
-/* If set, this function is called to decide whether or not a particular
-   history expansion should be treated as a special case for the calling
-   application and not expanded. */
-extern rl_linebuf_func_t *history_inhibit_expansion_function;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* !_HISTORY_H_ */
diff --git a/readline/histsearch.c b/readline/histsearch.c
deleted file mode 100644
--- a/readline/histsearch.c
+++ /dev/null
@@ -1,197 +0,0 @@
-/* histsearch.c -- searching the history list. */
-
-/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
-
-   This file contains the GNU History Library (the Library), a set of
-   routines for managing the text of previously typed lines.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-#if defined (HAVE_UNISTD_H)
-#  ifdef _MINIX
-#    include <sys/types.h>
-#  endif
-#  include <unistd.h>
-#endif
-#if defined (HAVE_STRING_H)
-#  include <string.h>
-#else
-#  include <strings.h>
-#endif /* !HAVE_STRING_H */
-
-#include "history.h"
-#include "histlib.h"
-
-/* The list of alternate characters that can delimit a history search
-   string. */
-char *history_search_delimiter_chars = (char *)NULL;
-
-/* Search the history for STRING, starting at history_offset.
-   If DIRECTION < 0, then the search is through previous entries, else
-   through subsequent.  If ANCHORED is non-zero, the string must
-   appear at the beginning of a history line, otherwise, the string
-   may appear anywhere in the line.  If the string is found, then
-   current_history () is the history entry, and the value of this
-   function is the offset in the line of that history entry that the
-   string was found in.  Otherwise, nothing is changed, and a -1 is
-   returned. */
-
-static int
-history_search_internal (string, direction, anchored)
-     const char *string;
-     int direction, anchored;
-{
-  register int i, reverse;
-  register char *line;
-  register int line_index;
-  int string_len;
-  HIST_ENTRY **the_history; 	/* local */
-
-  i = history_offset;
-  reverse = (direction < 0);
-
-  /* Take care of trivial cases first. */
-  if (string == 0 || *string == '\0')
-    return (-1);
-
-  if (!history_length || ((i == history_length) && !reverse))
-    return (-1);
-
-  if (reverse && (i == history_length))
-    i--;
-
-#define NEXT_LINE() do { if (reverse) i--; else i++; } while (0)
-
-  the_history = history_list ();
-  string_len = strlen (string);
-  while (1)
-    {
-      /* Search each line in the history list for STRING. */
-
-      /* At limit for direction? */
-      if ((reverse && i < 0) || (!reverse && i == history_length))
-	return (-1);
-
-      line = the_history[i]->line;
-      line_index = strlen (line);
-
-      /* If STRING is longer than line, no match. */
-      if (string_len > line_index)
-	{
-	  NEXT_LINE ();
-	  continue;
-	}
-
-      /* Handle anchored searches first. */
-      if (anchored == ANCHORED_SEARCH)
-	{
-	  if (STREQN (string, line, string_len))
-	    {
-	      history_offset = i;
-	      return (0);
-	    }
-
-	  NEXT_LINE ();
-	  continue;
-	}
-
-      /* Do substring search. */
-      if (reverse)
-	{
-	  line_index -= string_len;
-
-	  while (line_index >= 0)
-	    {
-	      if (STREQN (string, line + line_index, string_len))
-		{
-		  history_offset = i;
-		  return (line_index);
-		}
-	      line_index--;
-	    }
-	}
-      else
-	{
-	  register int limit;
-
-	  limit = line_index - string_len + 1;
-	  line_index = 0;
-
-	  while (line_index < limit)
-	    {
-	      if (STREQN (string, line + line_index, string_len))
-		{
-		  history_offset = i;
-		  return (line_index);
-		}
-	      line_index++;
-	    }
-	}
-      NEXT_LINE ();
-    }
-}
-
-/* Do a non-anchored search for STRING through the history in DIRECTION. */
-int
-history_search (string, direction)
-     const char *string;
-     int direction;
-{
-  return (history_search_internal (string, direction, NON_ANCHORED_SEARCH));
-}
-
-/* Do an anchored search for string through the history in DIRECTION. */
-int
-history_search_prefix (string, direction)
-     const char *string;
-     int direction;
-{
-  return (history_search_internal (string, direction, ANCHORED_SEARCH));
-}
-
-/* Search for STRING in the history list.  DIR is < 0 for searching
-   backwards.  POS is an absolute index into the history list at
-   which point to begin searching. */
-int
-history_search_pos (string, dir, pos)
-     const char *string;
-     int dir, pos;
-{
-  int ret, old;
-
-  old = where_history ();
-  history_set_pos (pos);
-  if (history_search (string, dir) == -1)
-    {
-      history_set_pos (old);
-      return (-1);
-    }
-  ret = where_history ();
-  history_set_pos (old);
-  return ret;
-}
diff --git a/readline/input.c b/readline/input.c
deleted file mode 100644
--- a/readline/input.c
+++ /dev/null
@@ -1,436 +0,0 @@
-/* input.c -- character input functions for readline. */
-
-/* Copyright (C) 1994 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-#include <fcntl.h>
-#if defined (HAVE_SYS_FILE_H)
-#  include <sys/file.h>
-#endif /* HAVE_SYS_FILE_H */
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#if defined (HAVE_SELECT)
-#  if !defined (HAVE_SYS_SELECT_H) || !defined (M_UNIX)
-#    include <sys/time.h>
-#  endif
-#endif /* HAVE_SELECT */
-#if defined (HAVE_SYS_SELECT_H)
-#  include <sys/select.h>
-#endif
-
-#if defined (FIONREAD_IN_SYS_IOCTL)
-#  include <sys/ioctl.h>
-#endif
-
-#include <stdio.h>
-#include <errno.h>
-
-#if !defined (errno)
-extern int errno;
-#endif /* !errno */
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-/* Some standard library routines. */
-#include "readline.h"
-
-#include "rlprivate.h"
-#include "rlshell.h"
-#include "xmalloc.h"
-
-/* What kind of non-blocking I/O do we have? */
-#if !defined (O_NDELAY) && defined (O_NONBLOCK)
-#  define O_NDELAY O_NONBLOCK	/* Posix style */
-#endif
-
-/* Non-null means it is a pointer to a function to run while waiting for
-   character input. */
-rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;
-
-rl_getc_func_t *rl_getc_function = rl_getc;
-
-static int _keyboard_input_timeout = 100000;		/* 0.1 seconds; it's in usec */
-
-/* **************************************************************** */
-/*								    */
-/*			Character Input Buffering       	    */
-/*								    */
-/* **************************************************************** */
-
-static int pop_index, push_index;
-static unsigned char ibuffer[512];
-static int ibuffer_len = sizeof (ibuffer) - 1;
-
-#define any_typein (push_index != pop_index)
-
-int
-_rl_any_typein ()
-{
-  return any_typein;
-}
-
-/* Return the amount of space available in the buffer for stuffing
-   characters. */
-static int
-ibuffer_space ()
-{
-  if (pop_index > push_index)
-    return (pop_index - push_index - 1);
-  else
-    return (ibuffer_len - (push_index - pop_index));
-}
-
-/* Get a key from the buffer of characters to be read.
-   Return the key in KEY.
-   Result is KEY if there was a key, or 0 if there wasn't. */
-static int
-rl_get_char (key)
-     int *key;
-{
-  if (push_index == pop_index)
-    return (0);
-
-  *key = ibuffer[pop_index++];
-
-  if (pop_index >= ibuffer_len)
-    pop_index = 0;
-
-  return (1);
-}
-
-/* Stuff KEY into the *front* of the input buffer.
-   Returns non-zero if successful, zero if there is
-   no space left in the buffer. */
-static int
-rl_unget_char (key)
-     int key;
-{
-  if (ibuffer_space ())
-    {
-      pop_index--;
-      if (pop_index < 0)
-	pop_index = ibuffer_len - 1;
-      ibuffer[pop_index] = key;
-      return (1);
-    }
-  return (0);
-}
-
-/* If a character is available to be read, then read it
-   and stuff it into IBUFFER.  Otherwise, just return. */
-static void
-rl_gather_tyi ()
-{
-  int tty;
-  register int tem, result;
-  int chars_avail;
-  char input;
-#if defined(HAVE_SELECT)
-  fd_set readfds, exceptfds;
-  struct timeval timeout;
-#endif
-
-  tty = fileno (rl_instream);
-
-#if defined (HAVE_SELECT)
-  FD_ZERO (&readfds);
-  FD_ZERO (&exceptfds);
-  FD_SET (tty, &readfds);
-  FD_SET (tty, &exceptfds);
-  timeout.tv_sec = 0;
-  timeout.tv_usec = _keyboard_input_timeout;
-  if (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) <= 0)
-    return;	/* Nothing to read. */
-#endif
-
-  result = -1;
-#if defined (FIONREAD)
-  result = ioctl (tty, FIONREAD, &chars_avail);
-#endif
-
-#if defined (O_NDELAY)
-  if (result == -1)
-    {
-      tem = fcntl (tty, F_GETFL, 0);
-
-      fcntl (tty, F_SETFL, (tem | O_NDELAY));
-      chars_avail = read (tty, &input, 1);
-
-      fcntl (tty, F_SETFL, tem);
-      if (chars_avail == -1 && errno == EAGAIN)
-	return;
-    }
-#endif /* O_NDELAY */
-
-  /* If there's nothing available, don't waste time trying to read
-     something. */
-  if (chars_avail <= 0)
-    return;
-
-  tem = ibuffer_space ();
-
-  if (chars_avail > tem)
-    chars_avail = tem;
-
-  /* One cannot read all of the available input.  I can only read a single
-     character at a time, or else programs which require input can be
-     thwarted.  If the buffer is larger than one character, I lose.
-     Damn! */
-  if (tem < ibuffer_len)
-    chars_avail = 0;
-
-  if (result != -1)
-    {
-      while (chars_avail--)
-	rl_stuff_char ((*rl_getc_function) (rl_instream));
-    }
-  else
-    {
-      if (chars_avail)
-	rl_stuff_char (input);
-    }
-}
-
-int
-rl_set_keyboard_input_timeout (u)
-     int u;
-{
-  int o;
-
-  o = _keyboard_input_timeout;
-  if (u > 0)
-    _keyboard_input_timeout = u;
-  return (o);
-}
-
-/* Is there input available to be read on the readline input file
-   descriptor?  Only works if the system has select(2) or FIONREAD. */
-int
-_rl_input_available ()
-{
-#if defined(HAVE_SELECT)
-  fd_set readfds, exceptfds;
-  struct timeval timeout;
-#endif
-#if defined(FIONREAD)
-  int chars_avail;
-#endif
-  int tty;
-
-  tty = fileno (rl_instream);
-
-#if defined (HAVE_SELECT)
-  FD_ZERO (&readfds);
-  FD_ZERO (&exceptfds);
-  FD_SET (tty, &readfds);
-  FD_SET (tty, &exceptfds);
-  timeout.tv_sec = 0;
-  timeout.tv_usec = _keyboard_input_timeout;
-  return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);
-#endif
-
-#if defined (FIONREAD)
-  if (ioctl (tty, FIONREAD, &chars_avail) == 0)
-    return (chars_avail);
-#endif
-
-  return 0;
-}
-
-void
-_rl_insert_typein (c)
-     int c;     
-{    	
-  int key, t, i;
-  char *string;
-
-  i = key = 0;
-  string = xmalloc (ibuffer_len + 1);
-  string[i++] = (char) c;
-
-  while ((t = rl_get_char (&key)) &&
-	 _rl_keymap[key].type == ISFUNC &&
-	 _rl_keymap[key].function == rl_insert)
-    string[i++] = key;
-
-  if (t)
-    rl_unget_char (key);
-
-  string[i] = '\0';
-  rl_insert_text (string);
-  free (string);
-}
-
-/* Add KEY to the buffer of characters to be read.  Returns 1 if the
-   character was stuffed correctly; 0 otherwise. */
-int
-rl_stuff_char (key)
-     int key;
-{
-  if (ibuffer_space () == 0)
-    return 0;
-
-  if (key == EOF)
-    {
-      key = NEWLINE;
-      rl_pending_input = EOF;
-      RL_SETSTATE (RL_STATE_INPUTPENDING);
-    }
-  ibuffer[push_index++] = key;
-  if (push_index >= ibuffer_len)
-    push_index = 0;
-
-  return 1;
-}
-
-/* Make C be the next command to be executed. */
-int
-rl_execute_next (c)
-     int c;
-{
-  rl_pending_input = c;
-  RL_SETSTATE (RL_STATE_INPUTPENDING);
-  return 0;
-}
-
-/* Clear any pending input pushed with rl_execute_next() */
-int
-rl_clear_pending_input ()
-{
-  rl_pending_input = 0;
-  RL_UNSETSTATE (RL_STATE_INPUTPENDING);
-  return 0;
-}
-
-/* **************************************************************** */
-/*								    */
-/*			     Character Input			    */
-/*								    */
-/* **************************************************************** */
-
-/* Read a key, including pending input. */
-int
-rl_read_key ()
-{
-  int c;
-
-  rl_key_sequence_length++;
-
-  if (rl_pending_input)
-    {
-      c = rl_pending_input;
-      rl_clear_pending_input ();
-    }
-  else
-    {
-      /* If input is coming from a macro, then use that. */
-      if (c = _rl_next_macro_key ())
-	return (c);
-
-      /* If the user has an event function, then call it periodically. */
-      if (rl_event_hook)
-	{
-	  while (rl_event_hook && rl_get_char (&c) == 0)
-	    {
-	      (*rl_event_hook) ();
-	      if (rl_done)		/* XXX - experimental */
-		return ('\n');
-	      rl_gather_tyi ();
-	    }
-	}
-      else
-	{
-	  if (rl_get_char (&c) == 0)
-	    c = (*rl_getc_function) (rl_instream);
-	}
-    }
-
-  return (c);
-}
-
-int
-rl_getc (stream)
-     FILE *stream;
-{
-  int result;
-  unsigned char c;
-
-  while (1)
-    {
-      result = read (fileno (stream), &c, sizeof (unsigned char));
-
-      if (result == sizeof (unsigned char))
-	return (c);
-
-      /* If zero characters are returned, then the file that we are
-	 reading from is empty!  Return EOF in that case. */
-      if (result == 0)
-	return (EOF);
-
-#if defined (__BEOS__)
-      if (errno == EINTR)
-	continue;
-#endif
-
-#if defined (EWOULDBLOCK)
-#  define X_EWOULDBLOCK EWOULDBLOCK
-#else
-#  define X_EWOULDBLOCK -99
-#endif
-
-#if defined (EAGAIN)
-#  define X_EAGAIN EAGAIN
-#else
-#  define X_EAGAIN -99
-#endif
-
-      if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)
-	{
-	  if (sh_unset_nodelay_mode (fileno (stream)) < 0)
-	    return (EOF);
-	  continue;
-	}
-
-#undef X_EWOULDBLOCK
-#undef X_EAGAIN
-
-      /* If the error that we received was SIGINT, then try again,
-	 this is simply an interrupted system call to read ().
-	 Otherwise, some error ocurred, also signifying EOF. */
-      if (errno != EINTR)
-	return (EOF);
-    }
-}
diff --git a/readline/isearch.c b/readline/isearch.c
deleted file mode 100644
--- a/readline/isearch.c
+++ /dev/null
@@ -1,452 +0,0 @@
-/* **************************************************************** */
-/*								    */
-/*			I-Search and Searching			    */
-/*								    */
-/* **************************************************************** */
-
-/* Copyright (C) 1987,1989 Free Software Foundation, Inc.
-
-   This file contains the Readline Library (the Library), a set of
-   routines for providing Emacs style line input to programs that ask
-   for it.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-
-#include <stdio.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif
-
-#include "rldefs.h"
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-#include "xmalloc.h"
-
-/* Variables exported to other files in the readline library. */
-unsigned char *_rl_isearch_terminators = (unsigned char *)NULL;
-
-/* Variables imported from other files in the readline library. */
-extern HIST_ENTRY *_rl_saved_line_for_history;
-
-/* Forward declarations */
-static int rl_search_history __P((int, int));
-
-/* Last line found by the current incremental search, so we don't `find'
-   identical lines many times in a row. */
-static char *prev_line_found;
-
-static unsigned char *default_isearch_terminators = "\033\012";
-
-/* Search backwards through the history looking for a string which is typed
-   interactively.  Start with the current line. */
-int
-rl_reverse_search_history (sign, key)
-     int sign, key;
-{
-  return (rl_search_history (-sign, key));
-}
-
-/* Search forwards through the history looking for a string which is typed
-   interactively.  Start with the current line. */
-int
-rl_forward_search_history (sign, key)
-     int sign, key;
-{
-  return (rl_search_history (sign, key));
-}
-
-/* Display the current state of the search in the echo-area.
-   SEARCH_STRING contains the string that is being searched for,
-   DIRECTION is zero for forward, or 1 for reverse,
-   WHERE is the history list number of the current line.  If it is
-   -1, then this line is the starting one. */
-static void
-rl_display_search (search_string, reverse_p, where)
-     char *search_string;
-     int reverse_p, where;
-{
-  char *message;
-  int msglen, searchlen;
-
-  searchlen = (search_string && *search_string) ? strlen (search_string) : 0;
-
-  message = xmalloc (searchlen + 33);
-  msglen = 0;
-
-#if defined (NOTDEF)
-  if (where != -1)
-    {
-      sprintf (message, "[%d]", where + history_base);
-      msglen = strlen (message);
-    }
-#endif /* NOTDEF */
-
-  message[msglen++] = '(';
-
-  if (reverse_p)
-    {
-      strcpy (message + msglen, "reverse-");
-      msglen += 8;
-    }
-
-  strcpy (message + msglen, "i-search)`");
-  msglen += 10;
-
-  if (search_string)
-    {
-      strcpy (message + msglen, search_string);
-      msglen += searchlen;
-    }
-
-  strcpy (message + msglen, "': ");
-
-  rl_message ("%s", message, 0);
-  free (message);
-  (*rl_redisplay_function) ();
-}
-
-/* Search through the history looking for an interactively typed string.
-   This is analogous to i-search.  We start the search in the current line.
-   DIRECTION is which direction to search; >= 0 means forward, < 0 means
-   backwards. */
-static int
-rl_search_history (direction, invoking_key)
-     int direction, invoking_key;
-{
-  /* The string that the user types in to search for. */
-  char *search_string;
-
-  /* The current length of SEARCH_STRING. */
-  int search_string_index;
-
-  /* The amount of space that SEARCH_STRING has allocated to it. */
-  int search_string_size;
-
-  /* The list of lines to search through. */
-  char **lines, *allocated_line;
-
-  /* The length of LINES. */
-  int hlen;
-
-  /* Where we get LINES from. */
-  HIST_ENTRY **hlist;
-
-  register int i;
-  int orig_point, orig_line, last_found_line;
-  int c, found, failed, sline_len;
-
-  /* The line currently being searched. */
-  char *sline;
-
-  /* Offset in that line. */
-  int line_index;
-
-  /* Non-zero if we are doing a reverse search. */
-  int reverse;
-
-  /* The list of characters which terminate the search, but are not
-     subsequently executed.  If the variable isearch-terminators has
-     been set, we use that value, otherwise we use ESC and C-J. */
-  unsigned char *isearch_terminators;
-
-  RL_SETSTATE(RL_STATE_ISEARCH);
-  orig_point = rl_point;
-  last_found_line = orig_line = where_history ();
-  reverse = direction < 0;
-  hlist = history_list ();
-  allocated_line = (char *)NULL;
-
-  isearch_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
-						: default_isearch_terminators;
-
-  /* Create an arrary of pointers to the lines that we want to search. */
-  rl_maybe_replace_line ();
-  i = 0;
-  if (hlist)
-    for (i = 0; hlist[i]; i++);
-
-  /* Allocate space for this many lines, +1 for the current input line,
-     and remember those lines. */
-  lines = (char **)xmalloc ((1 + (hlen = i)) * sizeof (char *));
-  for (i = 0; i < hlen; i++)
-    lines[i] = hlist[i]->line;
-
-  if (_rl_saved_line_for_history)
-    lines[i] = _rl_saved_line_for_history->line;
-  else
-    {
-      /* Keep track of this so we can free it. */
-      allocated_line = xmalloc (1 + strlen (rl_line_buffer));
-      strcpy (allocated_line, &rl_line_buffer[0]);
-      lines[i] = allocated_line;
-    }
-
-  hlen++;
-
-  /* The line where we start the search. */
-  i = orig_line;
-
-  rl_save_prompt ();
-
-  /* Initialize search parameters. */
-  search_string = xmalloc (search_string_size = 128);
-  *search_string = '\0';
-  search_string_index = 0;
-  prev_line_found = (char *)0;		/* XXX */
-
-  /* Normalize DIRECTION into 1 or -1. */
-  direction = (direction >= 0) ? 1 : -1;
-
-  rl_display_search (search_string, reverse, -1);
-
-  sline = rl_line_buffer;
-  sline_len = strlen (sline);
-  line_index = rl_point;
-
-  found = failed = 0;
-  for (;;)
-    {
-      rl_command_func_t *f = (rl_command_func_t *)NULL;
-
-      /* Read a key and decide how to proceed. */
-      RL_SETSTATE(RL_STATE_MOREINPUT);
-      c = rl_read_key ();
-      RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-      if (_rl_keymap[c].type == ISFUNC)
-	{
-	  f = _rl_keymap[c].function;
-
-	  if (f == rl_reverse_search_history)
-	    c = reverse ? -1 : -2;
-	  else if (f == rl_forward_search_history)
-	    c =  !reverse ? -1 : -2;
-	}
-
-#if 0
-      /* Let NEWLINE (^J) terminate the search for people who don't like
-	 using ESC.  ^M can still be used to terminate the search and
-	 immediately execute the command. */
-      if (c == ESC || c == NEWLINE)
-#else
-      /* The characters in isearch_terminators (set from the user-settable
-	 variable isearch-terminators) are used to terminate the search but
-	 not subsequently execute the character as a command.  The default
-	 value is "\033\012" (ESC and C-J). */
-      if (strchr (isearch_terminators, c))
-#endif
-	{
-	  /* ESC still terminates the search, but if there is pending
-	     input or if input arrives within 0.1 seconds (on systems
-	     with select(2)) it is used as a prefix character
-	     with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
-	     to allow the arrow keys to be used like ^F and ^B are used
-	     to terminate the search and execute the movement command. */
-	  if (c == ESC && _rl_input_available ())	/* XXX */
-	    rl_execute_next (ESC);
-	  break;
-	}
-
-      if (c >= 0 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT) && c != CTRL ('G'))
-	{
-	  /* This sets rl_pending_input to c; it will be picked up the next
-	     time rl_read_key is called. */
-	  rl_execute_next (c);
-	  break;
-	}
-
-      switch (c)
-	{
-	case -1:
-	  if (search_string_index == 0)
-	    continue;
-	  else if (reverse)
-	    --line_index;
-	  else if (line_index != sline_len)
-	    ++line_index;
-	  else
-	    rl_ding ();
-	  break;
-
-	  /* switch directions */
-	case -2:
-	  direction = -direction;
-	  reverse = direction < 0;
-	  break;
-
-	case CTRL ('G'):
-	  strcpy (rl_line_buffer, lines[orig_line]);
-	  rl_point = orig_point;
-	  rl_end = strlen (rl_line_buffer);
-	  rl_restore_prompt();
-	  rl_clear_message ();
-	  if (allocated_line)
-	    free (allocated_line);
-	  free (lines);
-	  RL_UNSETSTATE(RL_STATE_ISEARCH);
-	  return 0;
-
-#if 0
-	/* delete character from search string. */
-	case -3:
-	  if (search_string_index == 0)
-	    rl_ding ();
-	  else
-	    {
-	      search_string[--search_string_index] = '\0';
-	      /* This is tricky.  To do this right, we need to keep a
-		 stack of search positions for the current search, with
-		 sentinels marking the beginning and end. */
-	    }
-	  break;
-#endif
-
-	default:
-	  /* Add character to search string and continue search. */
-	  if (search_string_index + 2 >= search_string_size)
-	    {
-	      search_string_size += 128;
-	      search_string = xrealloc (search_string, search_string_size);
-	    }
-	  search_string[search_string_index++] = c;
-	  search_string[search_string_index] = '\0';
-	  break;
-	}
-
-      for (found = failed = 0;;)
-	{
-	  int limit = sline_len - search_string_index + 1;
-
-	  /* Search the current line. */
-	  while (reverse ? (line_index >= 0) : (line_index < limit))
-	    {
-	      if (STREQN (search_string, sline + line_index, search_string_index))
-		{
-		  found++;
-		  break;
-		}
-	      else
-		line_index += direction;
-	    }
-	  if (found)
-	    break;
-
-	  /* Move to the next line, but skip new copies of the line
-	     we just found and lines shorter than the string we're
-	     searching for. */
-	  do
-	    {
-	      /* Move to the next line. */
-	      i += direction;
-
-	      /* At limit for direction? */
-	      if (reverse ? (i < 0) : (i == hlen))
-		{
-		  failed++;
-		  break;
-		}
-
-	      /* We will need these later. */
-	      sline = lines[i];
-	      sline_len = strlen (sline);
-	    }
-	  while ((prev_line_found && STREQ (prev_line_found, lines[i])) ||
-		 (search_string_index > sline_len));
-
-	  if (failed)
-	    break;
-
-	  /* Now set up the line for searching... */
-	  line_index = reverse ? sline_len - search_string_index : 0;
-	}
-
-      if (failed)
-	{
-	  /* We cannot find the search string.  Ding the bell. */
-	  rl_ding ();
-	  i = last_found_line;
-	  continue; 		/* XXX - was break */
-	}
-
-      /* We have found the search string.  Just display it.  But don't
-	 actually move there in the history list until the user accepts
-	 the location. */
-      if (found)
-	{
-	  int line_len;
-
-	  prev_line_found = lines[i];
-	  line_len = strlen (lines[i]);
-
-	  if (line_len >= rl_line_buffer_len)
-	    rl_extend_line_buffer (line_len);
-
-	  strcpy (rl_line_buffer, lines[i]);
-	  rl_point = line_index;
-	  rl_end = line_len;
-	  last_found_line = i;
-	  rl_display_search (search_string, reverse, (i == orig_line) ? -1 : i);
-	}
-    }
-
-  /* The searching is over.  The user may have found the string that she
-     was looking for, or else she may have exited a failing search.  If
-     LINE_INDEX is -1, then that shows that the string searched for was
-     not found.  We use this to determine where to place rl_point. */
-
-  /* First put back the original state. */
-  strcpy (rl_line_buffer, lines[orig_line]);
-
-  rl_restore_prompt ();
-
-  /* Free the search string. */
-  free (search_string);
-
-  if (last_found_line < orig_line)
-    rl_get_previous_history (orig_line - last_found_line, 0);
-  else
-    rl_get_next_history (last_found_line - orig_line, 0);
-
-  /* If the string was not found, put point at the end of the line. */
-  if (line_index < 0)
-    line_index = strlen (rl_line_buffer);
-  rl_point = line_index;
-  rl_clear_message ();
-
-  if (allocated_line)
-    free (allocated_line);
-  free (lines);
-
-  RL_UNSETSTATE(RL_STATE_ISEARCH);
-
-  return 0;
-}
diff --git a/readline/keymaps.c b/readline/keymaps.c
deleted file mode 100644
--- a/readline/keymaps.c
+++ /dev/null
@@ -1,150 +0,0 @@
-/* keymaps.c -- Functions and keymaps for the GNU Readline library. */
-
-/* Copyright (C) 1988,1989 Free Software Foundation, Inc.
-
-   This file is part of GNU Readline, a library for reading lines
-   of text with interactive input and history editing.
-
-   Readline is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by the
-   Free Software Foundation; either version 2, or (at your option) any
-   later version.
-
-   Readline is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Readline; see the file COPYING.  If not, write to the Free
-   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include <stdio.h>	/* for FILE * definition for readline.h */
-
-#include "readline.h"
-#include "rlconf.h"
-
-#include "emacs_keymap.c"
-
-#if defined (VI_MODE)
-#include "vi_keymap.c"
-#endif
-
-#include "xmalloc.h"
-
-/* **************************************************************** */
-/*								    */
-/*		      Functions for manipulating Keymaps.	    */
-/*								    */
-/* **************************************************************** */
-
-
-/* Return a new, empty keymap.
-   Free it with free() when you are done. */
-Keymap
-rl_make_bare_keymap ()
-{
-  register int i;
-  Keymap keymap = (Keymap)xmalloc (KEYMAP_SIZE * sizeof (KEYMAP_ENTRY));
-
-  for (i = 0; i < KEYMAP_SIZE; i++)
-    {
-      keymap[i].type = ISFUNC;
-      keymap[i].function = (rl_command_func_t *)NULL;
-    }
-
-  for (i = 'A'; i < ('Z' + 1); i++)
-    {
-      keymap[i].type = ISFUNC;
-      keymap[i].function = rl_do_lowercase_version;
-    }
-
-  return (keymap);
-}
-
-/* Return a new keymap which is a copy of MAP. */
-Keymap
-rl_copy_keymap (map)
-     Keymap map;
-{
-  register int i;
-  Keymap temp = rl_make_bare_keymap ();
-
-  for (i = 0; i < KEYMAP_SIZE; i++)
-    {
-      temp[i].type = map[i].type;
-      temp[i].function = map[i].function;
-    }
-  return (temp);
-}
-
-/* Return a new keymap with the printing characters bound to rl_insert,
-   the uppercase Meta characters bound to run their lowercase equivalents,
-   and the Meta digits bound to produce numeric arguments. */
-Keymap
-rl_make_keymap ()
-{
-  register int i;
-  Keymap newmap;
-
-  newmap = rl_make_bare_keymap ();
-
-  /* All ASCII printing characters are self-inserting. */
-  for (i = ' '; i < 127; i++)
-    newmap[i].function = rl_insert;
-
-  newmap[TAB].function = rl_insert;
-  newmap[RUBOUT].function = rl_rubout;	/* RUBOUT == 127 */
-  newmap[CTRL('H')].function = rl_rubout;
-
-#if KEYMAP_SIZE > 128
-  /* Printing characters in some 8-bit character sets. */
-  for (i = 128; i < 160; i++)
-    newmap[i].function = rl_insert;
-
-  /* ISO Latin-1 printing characters should self-insert. */
-  for (i = 160; i < 256; i++)
-    newmap[i].function = rl_insert;
-#endif /* KEYMAP_SIZE > 128 */
-
-  return (newmap);
-}
-
-/* Free the storage associated with MAP. */
-void
-rl_discard_keymap (map)
-     Keymap map;
-{
-  int i;
-
-  if (!map)
-    return;
-
-  for (i = 0; i < KEYMAP_SIZE; i++)
-    {
-      switch (map[i].type)
-	{
-	case ISFUNC:
-	  break;
-
-	case ISKMAP:
-	  rl_discard_keymap ((Keymap)map[i].function);
-	  break;
-
-	case ISMACR:
-	  free ((char *)map[i].function);
-	  break;
-	}
-    }
-}
diff --git a/readline/keymaps.h b/readline/keymaps.h
deleted file mode 100644
--- a/readline/keymaps.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/* keymaps.h -- Manipulation of readline keymaps. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#ifndef _KEYMAPS_H_
-#define _KEYMAPS_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if defined (READLINE_LIBRARY)
-#  include "rlstdc.h"
-#  include "chardefs.h"
-#  include "rltypedefs.h"
-#else
-#  include <readline/rlstdc.h>
-#  include <readline/chardefs.h>
-#  include <readline/rltypedefs.h>
-#endif
-
-/* A keymap contains one entry for each key in the ASCII set.
-   Each entry consists of a type and a pointer.
-   FUNCTION is the address of a function to run, or the
-   address of a keymap to indirect through.
-   TYPE says which kind of thing FUNCTION is. */
-typedef struct _keymap_entry {
-  char type;
-  rl_command_func_t *function;
-} KEYMAP_ENTRY;
-
-/* This must be large enough to hold bindings for all of the characters
-   in a desired character set (e.g, 128 for ASCII, 256 for ISO Latin-x,
-   and so on). */
-#define KEYMAP_SIZE 256
-
-/* I wanted to make the above structure contain a union of:
-   union { rl_command_func_t *function; struct _keymap_entry *keymap; } value;
-   but this made it impossible for me to create a static array.
-   Maybe I need C lessons. */
-
-typedef KEYMAP_ENTRY KEYMAP_ENTRY_ARRAY[KEYMAP_SIZE];
-typedef KEYMAP_ENTRY *Keymap;
-
-/* The values that TYPE can have in a keymap entry. */
-#define ISFUNC 0
-#define ISKMAP 1
-#define ISMACR 2
-
-extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap, emacs_meta_keymap, emacs_ctlx_keymap;
-extern KEYMAP_ENTRY_ARRAY vi_insertion_keymap, vi_movement_keymap;
-
-/* Return a new, empty keymap.
-   Free it with free() when you are done. */
-extern Keymap rl_make_bare_keymap __P((void));
-
-/* Return a new keymap which is a copy of MAP. */
-extern Keymap rl_copy_keymap __P((Keymap));
-
-/* Return a new keymap with the printing characters bound to rl_insert,
-   the lowercase Meta characters bound to run their equivalents, and
-   the Meta digits bound to produce numeric arguments. */
-extern Keymap rl_make_keymap __P((void));
-
-/* Free the storage associated with a keymap. */
-extern void rl_discard_keymap __P((Keymap));
-
-/* These functions actually appear in bind.c */
-
-/* Return the keymap corresponding to a given name.  Names look like
-   `emacs' or `emacs-meta' or `vi-insert'.  */
-extern Keymap rl_get_keymap_by_name __P((const char *));
-
-/* Return the current keymap. */
-extern Keymap rl_get_keymap __P((void));
-
-/* Set the current keymap to MAP. */
-extern void rl_set_keymap __P((Keymap));
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _KEYMAPS_H_ */
diff --git a/readline/kill.c b/readline/kill.c
deleted file mode 100644
--- a/readline/kill.c
+++ /dev/null
@@ -1,628 +0,0 @@
-/* kill.c -- kill ring management. */
-
-/* Copyright (C) 1994 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>           /* for _POSIX_VERSION */
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include <stdio.h>
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-/* Some standard library routines. */
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-#include "xmalloc.h"
-
-/* **************************************************************** */
-/*								    */
-/*			Killing Mechanism			    */
-/*								    */
-/* **************************************************************** */
-
-/* What we assume for a max number of kills. */
-#define DEFAULT_MAX_KILLS 10
-
-/* The real variable to look at to find out when to flush kills. */
-static int rl_max_kills =  DEFAULT_MAX_KILLS;
-
-/* Where to store killed text. */
-static char **rl_kill_ring = (char **)NULL;
-
-/* Where we are in the kill ring. */
-static int rl_kill_index;
-
-/* How many slots we have in the kill ring. */
-static int rl_kill_ring_length;
-
-/* How to say that you only want to save a certain amount
-   of kill material. */
-int
-rl_set_retained_kills (num)
-     int num;
-{
-  return 0;
-}
-
-/* Add TEXT to the kill ring, allocating a new kill ring slot as necessary.
-   This uses TEXT directly, so the caller must not free it.  If APPEND is
-   non-zero, and the last command was a kill, the text is appended to the
-   current kill ring slot, otherwise prepended. */
-static int
-_rl_copy_to_kill_ring (text, append)
-     char *text;
-     int append;
-{
-  char *old, *new;
-  int slot;
-
-  /* First, find the slot to work with. */
-  if (_rl_last_command_was_kill == 0)
-    {
-      /* Get a new slot.  */
-      if (rl_kill_ring == 0)
-	{
-	  /* If we don't have any defined, then make one. */
-	  rl_kill_ring = (char **)
-	    xmalloc (((rl_kill_ring_length = 1) + 1) * sizeof (char *));
-	  rl_kill_ring[slot = 0] = (char *)NULL;
-	}
-      else
-	{
-	  /* We have to add a new slot on the end, unless we have
-	     exceeded the max limit for remembering kills. */
-	  slot = rl_kill_ring_length;
-	  if (slot == rl_max_kills)
-	    {
-	      register int i;
-	      free (rl_kill_ring[0]);
-	      for (i = 0; i < slot; i++)
-		rl_kill_ring[i] = rl_kill_ring[i + 1];
-	    }
-	  else
-	    {
-	      slot = rl_kill_ring_length += 1;
-	      rl_kill_ring = (char **)xrealloc (rl_kill_ring, slot * sizeof (char *));
-	    }
-	  rl_kill_ring[--slot] = (char *)NULL;
-	}
-    }
-  else
-    slot = rl_kill_ring_length - 1;
-
-  /* If the last command was a kill, prepend or append. */
-  if (_rl_last_command_was_kill && rl_editing_mode != vi_mode)
-    {
-      old = rl_kill_ring[slot];
-      new = xmalloc (1 + strlen (old) + strlen (text));
-
-      if (append)
-	{
-	  strcpy (new, old);
-	  strcat (new, text);
-	}
-      else
-	{
-	  strcpy (new, text);
-	  strcat (new, old);
-	}
-      free (old);
-      free (text);
-      rl_kill_ring[slot] = new;
-    }
-  else
-    rl_kill_ring[slot] = text;
-
-  rl_kill_index = slot;
-  return 0;
-}
-
-/* The way to kill something.  This appends or prepends to the last
-   kill, if the last command was a kill command.  if FROM is less
-   than TO, then the text is appended, otherwise prepended.  If the
-   last command was not a kill command, then a new slot is made for
-   this kill. */
-int
-rl_kill_text (from, to)
-     int from, to;
-{
-  char *text;
-
-  /* Is there anything to kill? */
-  if (from == to)
-    {
-      _rl_last_command_was_kill++;
-      return 0;
-    }
-
-  text = rl_copy_text (from, to);
-
-  /* Delete the copied text from the line. */
-  rl_delete_text (from, to);
-
-  _rl_copy_to_kill_ring (text, from < to);
-
-  _rl_last_command_was_kill++;
-  return 0;
-}
-
-/* Now REMEMBER!  In order to do prepending or appending correctly, kill
-   commands always make rl_point's original position be the FROM argument,
-   and rl_point's extent be the TO argument. */
-
-/* **************************************************************** */
-/*								    */
-/*			Killing Commands			    */
-/*								    */
-/* **************************************************************** */
-
-/* Delete the word at point, saving the text in the kill ring. */
-int
-rl_kill_word (count, key)
-     int count, key;
-{
-  int orig_point = rl_point;
-
-  if (count < 0)
-    return (rl_backward_kill_word (-count, key));
-  else
-    {
-      rl_forward_word (count, key);
-
-      if (rl_point != orig_point)
-	rl_kill_text (orig_point, rl_point);
-
-      rl_point = orig_point;
-    }
-  return 0;
-}
-
-/* Rubout the word before point, placing it on the kill ring. */
-int
-rl_backward_kill_word (count, ignore)
-     int count, ignore;
-{
-  int orig_point = rl_point;
-
-  if (count < 0)
-    return (rl_kill_word (-count, ignore));
-  else
-    {
-      rl_backward_word (count, ignore);
-
-      if (rl_point != orig_point)
-	rl_kill_text (orig_point, rl_point);
-    }
-  return 0;
-}
-
-/* Kill from here to the end of the line.  If DIRECTION is negative, kill
-   back to the line start instead. */
-int
-rl_kill_line (direction, ignore)
-     int direction, ignore;
-{
-  int orig_point = rl_point;
-
-  if (direction < 0)
-    return (rl_backward_kill_line (1, ignore));
-  else
-    {
-      rl_end_of_line (1, ignore);
-      if (orig_point != rl_point)
-	rl_kill_text (orig_point, rl_point);
-      rl_point = orig_point;
-    }
-  return 0;
-}
-
-/* Kill backwards to the start of the line.  If DIRECTION is negative, kill
-   forwards to the line end instead. */
-int
-rl_backward_kill_line (direction, ignore)
-     int direction, ignore;
-{
-  int orig_point = rl_point;
-
-  if (direction < 0)
-    return (rl_kill_line (1, ignore));
-  else
-    {
-      if (!rl_point)
-	rl_ding ();
-      else
-	{
-	  rl_beg_of_line (1, ignore);
-	  rl_kill_text (orig_point, rl_point);
-	}
-    }
-  return 0;
-}
-
-/* Kill the whole line, no matter where point is. */
-int
-rl_kill_full_line (count, ignore)
-     int count, ignore;
-{
-  rl_begin_undo_group ();
-  rl_point = 0;
-  rl_kill_text (rl_point, rl_end);
-  rl_end_undo_group ();
-  return 0;
-}
-
-/* The next two functions mimic unix line editing behaviour, except they
-   save the deleted text on the kill ring.  This is safer than not saving
-   it, and since we have a ring, nobody should get screwed. */
-
-/* This does what C-w does in Unix.  We can't prevent people from
-   using behaviour that they expect. */
-int
-rl_unix_word_rubout (count, key)
-     int count, key;
-{
-  int orig_point;
-
-  if (rl_point == 0)
-    rl_ding ();
-  else
-    {
-      orig_point = rl_point;
-      if (count <= 0)
-	count = 1;
-
-      while (count--)
-	{
-	  while (rl_point && whitespace (rl_line_buffer[rl_point - 1]))
-	    rl_point--;
-
-	  while (rl_point && (whitespace (rl_line_buffer[rl_point - 1]) == 0))
-	    rl_point--;
-	}
-
-      rl_kill_text (orig_point, rl_point);
-    }
-  return 0;
-}
-
-/* Here is C-u doing what Unix does.  You don't *have* to use these
-   key-bindings.  We have a choice of killing the entire line, or
-   killing from where we are to the start of the line.  We choose the
-   latter, because if you are a Unix weenie, then you haven't backspaced
-   into the line at all, and if you aren't, then you know what you are
-   doing. */
-int
-rl_unix_line_discard (count, key)
-     int count, key;
-{
-  if (rl_point == 0)
-    rl_ding ();
-  else
-    {
-      rl_kill_text (rl_point, 0);
-      rl_point = 0;
-    }
-  return 0;
-}
-
-/* Copy the text in the `region' to the kill ring.  If DELETE is non-zero,
-   delete the text from the line as well. */
-static int
-region_kill_internal (delete)
-     int delete;
-{
-  char *text;
-
-  if (rl_mark == rl_point)
-    {
-      _rl_last_command_was_kill++;
-      return 0;
-    }
-
-  text = rl_copy_text (rl_point, rl_mark);
-  if (delete)
-    rl_delete_text (rl_point, rl_mark);
-  _rl_copy_to_kill_ring (text, rl_point < rl_mark);
-
-  _rl_last_command_was_kill++;
-  return 0;
-}
-
-/* Copy the text in the region to the kill ring. */
-int
-rl_copy_region_to_kill (count, ignore)
-     int count, ignore;
-{
-  return (region_kill_internal (0));
-}
-
-/* Kill the text between the point and mark. */
-int
-rl_kill_region (count, ignore)
-     int count, ignore;
-{
-  int r, npoint;
-
-  npoint = (rl_point < rl_mark) ? rl_point : rl_mark;
-  r = region_kill_internal (1);
-  _rl_fix_point (1);
-  rl_point = npoint;
-  return r;
-}
-
-/* Copy COUNT words to the kill ring.  DIR says which direction we look
-   to find the words. */
-static int
-_rl_copy_word_as_kill (count, dir)
-     int count, dir;
-{
-  int om, op, r;
-
-  om = rl_mark;
-  op = rl_point;
-
-  if (dir > 0)
-    rl_forward_word (count, 0);
-  else
-    rl_backward_word (count, 0);
-
-  rl_mark = rl_point;
-
-  if (dir > 0)
-    rl_backward_word (count, 0);
-  else
-    rl_forward_word (count, 0);
-
-  r = region_kill_internal (0);
-
-  rl_mark = om;
-  rl_point = op;
-
-  return r;
-}
-
-int
-rl_copy_forward_word (count, key)
-     int count, key;
-{
-  if (count < 0)
-    return (rl_copy_backward_word (-count, key));
-
-  return (_rl_copy_word_as_kill (count, 1));
-}
-
-int
-rl_copy_backward_word (count, key)
-     int count, key;
-{
-  if (count < 0)
-    return (rl_copy_forward_word (-count, key));
-
-  return (_rl_copy_word_as_kill (count, -1));
-}
-  
-/* Yank back the last killed text.  This ignores arguments. */
-int
-rl_yank (count, ignore)
-     int count, ignore;
-{
-  if (rl_kill_ring == 0)
-    {
-      _rl_abort_internal ();
-      return -1;
-    }
-
-  _rl_set_mark_at_pos (rl_point);
-  rl_insert_text (rl_kill_ring[rl_kill_index]);
-  return 0;
-}
-
-/* If the last command was yank, or yank_pop, and the text just
-   before point is identical to the current kill item, then
-   delete that text from the line, rotate the index down, and
-   yank back some other text. */
-int
-rl_yank_pop (count, key)
-     int count, key;
-{
-  int l, n;
-
-  if (((rl_last_func != rl_yank_pop) && (rl_last_func != rl_yank)) ||
-      !rl_kill_ring)
-    {
-      _rl_abort_internal ();
-      return -1;
-    }
-
-  l = strlen (rl_kill_ring[rl_kill_index]);
-  n = rl_point - l;
-  if (n >= 0 && STREQN (rl_line_buffer + n, rl_kill_ring[rl_kill_index], l))
-    {
-      rl_delete_text (n, rl_point);
-      rl_point = n;
-      rl_kill_index--;
-      if (rl_kill_index < 0)
-	rl_kill_index = rl_kill_ring_length - 1;
-      rl_yank (1, 0);
-      return 0;
-    }
-  else
-    {
-      _rl_abort_internal ();
-      return -1;
-    }
-}
-
-/* Yank the COUNTh argument from the previous history line, skipping
-   HISTORY_SKIP lines before looking for the `previous line'. */
-static int
-rl_yank_nth_arg_internal (count, ignore, history_skip)
-     int count, ignore, history_skip;
-{
-  register HIST_ENTRY *entry;
-  char *arg;
-  int i, pos;
-
-  pos = where_history ();
-
-  if (history_skip)
-    {
-      for (i = 0; i < history_skip; i++)
-	entry = previous_history ();
-    }
-
-  entry = previous_history ();
-
-  history_set_pos (pos);
-
-  if (entry == 0)
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  arg = history_arg_extract (count, count, entry->line);
-  if (!arg || !*arg)
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  rl_begin_undo_group ();
-
-#if defined (VI_MODE)
-  /* Vi mode always inserts a space before yanking the argument, and it
-     inserts it right *after* rl_point. */
-  if (rl_editing_mode == vi_mode)
-    {
-      rl_vi_append_mode (1, ignore);
-      rl_insert_text (" ");
-    }
-#endif /* VI_MODE */
-
-  rl_insert_text (arg);
-  free (arg);
-
-  rl_end_undo_group ();
-  return 0;
-}
-
-/* Yank the COUNTth argument from the previous history line. */
-int
-rl_yank_nth_arg (count, ignore)
-     int count, ignore;
-{
-  return (rl_yank_nth_arg_internal (count, ignore, 0));
-}
-
-/* Yank the last argument from the previous history line.  This `knows'
-   how rl_yank_nth_arg treats a count of `$'.  With an argument, this
-   behaves the same as rl_yank_nth_arg. */
-int
-rl_yank_last_arg (count, key)
-     int count, key;
-{
-  static int history_skip = 0;
-  static int explicit_arg_p = 0;
-  static int count_passed = 1;
-  static int direction = 1;
-  static int undo_needed = 0;
-  int retval;
-
-  if (rl_last_func != rl_yank_last_arg)
-    {
-      history_skip = 0;
-      explicit_arg_p = rl_explicit_arg;
-      count_passed = count;
-      direction = 1;
-    }
-  else
-    {
-      if (undo_needed)
-	rl_do_undo ();
-      if (count < 1)
-        direction = -direction;
-      history_skip += direction;
-      if (history_skip < 0)
-	history_skip = 0;
-    }
- 
-  if (explicit_arg_p)
-    retval = rl_yank_nth_arg_internal (count_passed, key, history_skip);
-  else
-    retval = rl_yank_nth_arg_internal ('$', key, history_skip);
-
-  undo_needed = retval == 0;
-  return retval;
-}
-
-/* A special paste command for users of Cygnus's cygwin32. */
-#if defined (__CYGWIN__)
-#include <windows.h>
-
-int
-rl_paste_from_clipboard (count, key)
-     int count, key;
-{
-  char *data, *ptr;
-  int len;
-
-  if (OpenClipboard (NULL) == 0)
-    return (0);
-
-  data = (char *)GetClipboardData (CF_TEXT);
-  if (data)
-    {
-      ptr = strchr (data, '\r');
-      if (ptr)
-	{
-	  len = ptr - data;
-	  ptr = xmalloc (len + 1);
-	  ptr[len] = '\0';
-	  strncpy (ptr, data, len);
-	}
-      else
-        ptr = data;
-      rl_insert_text (ptr);
-      if (ptr != data)
-	free (ptr);
-      CloseClipboard ();
-    }
-  return (0);
-}
-#endif /* __CYGWIN__ */
diff --git a/readline/macro.c b/readline/macro.c
deleted file mode 100644
--- a/readline/macro.c
+++ /dev/null
@@ -1,270 +0,0 @@
-/* macro.c -- keyboard macros for readline. */
-
-/* Copyright (C) 1994 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>           /* for _POSIX_VERSION */
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include <stdio.h>
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-/* Some standard library routines. */
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-#include "xmalloc.h"
-
-#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
-
-/* **************************************************************** */
-/*								    */
-/*			Hacking Keyboard Macros 		    */
-/*								    */
-/* **************************************************************** */
-
-/* The currently executing macro string.  If this is non-zero,
-   then it is a malloc ()'ed string where input is coming from. */
-char *rl_executing_macro = (char *)NULL;
-
-/* Non-zero means to save keys that we dispatch on in a kbd macro. */
-int _rl_defining_kbd_macro = 0;
-
-/* The offset in the above string to the next character to be read. */
-static int executing_macro_index;
-
-/* The current macro string being built.  Characters get stuffed
-   in here by add_macro_char (). */
-static char *current_macro = (char *)NULL;
-
-/* The size of the buffer allocated to current_macro. */
-static int current_macro_size;
-
-/* The index at which characters are being added to current_macro. */
-static int current_macro_index;
-
-/* A structure used to save nested macro strings.
-   It is a linked list of string/index for each saved macro. */
-struct saved_macro {
-  struct saved_macro *next;
-  char *string;
-  int sindex;
-};
-
-/* The list of saved macros. */
-static struct saved_macro *macro_list = (struct saved_macro *)NULL;
-
-/* Set up to read subsequent input from STRING.
-   STRING is free ()'ed when we are done with it. */
-void
-_rl_with_macro_input (string)
-     char *string;
-{
-  _rl_push_executing_macro ();
-  rl_executing_macro = string;
-  executing_macro_index = 0;
-  RL_SETSTATE(RL_STATE_MACROINPUT);
-}
-
-/* Return the next character available from a macro, or 0 if
-   there are no macro characters. */
-int
-_rl_next_macro_key ()
-{
-  if (rl_executing_macro == 0)
-    return (0);
-
-  if (rl_executing_macro[executing_macro_index] == 0)
-    {
-      _rl_pop_executing_macro ();
-      return (_rl_next_macro_key ());
-    }
-
-  return (rl_executing_macro[executing_macro_index++]);
-}
-
-/* Save the currently executing macro on a stack of saved macros. */
-void
-_rl_push_executing_macro ()
-{
-  struct saved_macro *saver;
-
-  saver = (struct saved_macro *)xmalloc (sizeof (struct saved_macro));
-  saver->next = macro_list;
-  saver->sindex = executing_macro_index;
-  saver->string = rl_executing_macro;
-
-  macro_list = saver;
-}
-
-/* Discard the current macro, replacing it with the one
-   on the top of the stack of saved macros. */
-void
-_rl_pop_executing_macro ()
-{
-  struct saved_macro *macro;
-
-  FREE (rl_executing_macro);
-  rl_executing_macro = (char *)NULL;
-  executing_macro_index = 0;
-
-  if (macro_list)
-    {
-      macro = macro_list;
-      rl_executing_macro = macro_list->string;
-      executing_macro_index = macro_list->sindex;
-      macro_list = macro_list->next;
-      free (macro);
-    }
-
-  if (rl_executing_macro == 0)
-    RL_UNSETSTATE(RL_STATE_MACROINPUT);
-}
-
-/* Add a character to the macro being built. */
-void
-_rl_add_macro_char (c)
-     int c;
-{
-  if (current_macro_index + 1 >= current_macro_size)
-    {
-      if (current_macro == 0)
-	current_macro = xmalloc (current_macro_size = 25);
-      else
-	current_macro = xrealloc (current_macro, current_macro_size += 25);
-    }
-
-  current_macro[current_macro_index++] = c;
-  current_macro[current_macro_index] = '\0';
-}
-
-void
-_rl_kill_kbd_macro ()
-{
-  if (current_macro)
-    {
-      free (current_macro);
-      current_macro = (char *) NULL;
-    }
-  current_macro_size = current_macro_index = 0;
-
-  FREE (rl_executing_macro);
-  rl_executing_macro = (char *) NULL;
-  executing_macro_index = 0;
-
-  _rl_defining_kbd_macro = 0;
-  RL_UNSETSTATE(RL_STATE_MACRODEF);
-}
-
-/* Begin defining a keyboard macro.
-   Keystrokes are recorded as they are executed.
-   End the definition with rl_end_kbd_macro ().
-   If a numeric argument was explicitly typed, then append this
-   definition to the end of the existing macro, and start by
-   re-executing the existing macro. */
-int
-rl_start_kbd_macro (ignore1, ignore2)
-     int ignore1, ignore2;
-{
-  if (_rl_defining_kbd_macro)
-    {
-      _rl_abort_internal ();
-      return -1;
-    }
-
-  if (rl_explicit_arg)
-    {
-      if (current_macro)
-	_rl_with_macro_input (savestring (current_macro));
-    }
-  else
-    current_macro_index = 0;
-
-  _rl_defining_kbd_macro = 1;
-  RL_SETSTATE(RL_STATE_MACRODEF);
-  return 0;
-}
-
-/* Stop defining a keyboard macro.
-   A numeric argument says to execute the macro right now,
-   that many times, counting the definition as the first time. */
-int
-rl_end_kbd_macro (count, ignore)
-     int count, ignore;
-{
-  if (_rl_defining_kbd_macro == 0)
-    {
-      _rl_abort_internal ();
-      return -1;
-    }
-
-  current_macro_index -= rl_key_sequence_length - 1;
-  current_macro[current_macro_index] = '\0';
-
-  _rl_defining_kbd_macro = 0;
-  RL_UNSETSTATE(RL_STATE_MACRODEF);
-
-  return (rl_call_last_kbd_macro (--count, 0));
-}
-
-/* Execute the most recently defined keyboard macro.
-   COUNT says how many times to execute it. */
-int
-rl_call_last_kbd_macro (count, ignore)
-     int count, ignore;
-{
-  if (current_macro == 0)
-    _rl_abort_internal ();
-
-  if (_rl_defining_kbd_macro)
-    {
-      rl_ding ();		/* no recursive macros */
-      current_macro[--current_macro_index] = '\0';	/* erase this char */
-      return 0;
-    }
-
-  while (count--)
-    _rl_with_macro_input (savestring (current_macro));
-  return 0;
-}
-
-void
-rl_push_macro_input (macro)
-     char *macro;
-{
-  _rl_with_macro_input (macro);
-}
diff --git a/readline/nls.c b/readline/nls.c
deleted file mode 100644
--- a/readline/nls.c
+++ /dev/null
@@ -1,225 +0,0 @@
-/* nls.c -- skeletal internationalization code. */
-
-/* Copyright (C) 1996 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-
-#include <stdio.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#if defined (HAVE_LOCALE_H)
-#  include <locale.h>
-#endif
-
-#include <ctype.h>
-
-#include "rldefs.h"
-#include "readline.h"
-#include "rlshell.h"
-#include "rlprivate.h"
-
-#if !defined (HAVE_SETLOCALE)    
-/* A list of legal values for the LANG or LC_CTYPE environment variables.
-   If a locale name in this list is the value for the LC_ALL, LC_CTYPE,
-   or LANG environment variable (using the first of those with a value),
-   readline eight-bit mode is enabled. */
-static char *legal_lang_values[] =
-{
- "iso88591",
- "iso88592",
- "iso88593",
- "iso88594",
- "iso88595",
- "iso88596",
- "iso88597",
- "iso88598",
- "iso88599",
- "iso885910",
- "koi8r",
-  0
-};
-
-static char *normalize_codeset __P((char *));
-static char *find_codeset __P((char *, size_t *));
-#endif /* !HAVE_SETLOCALE */
-
-/* Check for LC_ALL, LC_CTYPE, and LANG and use the first with a value
-   to decide the defaults for 8-bit character input and output.  Returns
-   1 if we set eight-bit mode. */
-int
-_rl_init_eightbit ()
-{
-/* If we have setlocale(3), just check the current LC_CTYPE category
-   value, and go into eight-bit mode if it's not C or POSIX. */
-#if defined (HAVE_SETLOCALE)
-  char *t;
-
-  /* Set the LC_CTYPE locale category from environment variables. */
-  t = setlocale (LC_CTYPE, "");
-  if (t && *t && (t[0] != 'C' || t[1]) && (STREQ (t, "POSIX") == 0))
-    {
-      _rl_meta_flag = 1;
-      _rl_convert_meta_chars_to_ascii = 0;
-      _rl_output_meta_chars = 1;
-      return (1);
-    }
-  else
-    return (0);
-
-#else /* !HAVE_SETLOCALE */
-  char *lspec, *t;
-  int i;
-
-  /* We don't have setlocale.  Finesse it.  Check the environment for the
-     appropriate variables and set eight-bit mode if they have the right
-     values. */
-  lspec = sh_get_env_value ("LC_ALL");
-  if (lspec == 0) lspec = sh_get_env_value ("LC_CTYPE");
-  if (lspec == 0) lspec = sh_get_env_value ("LANG");
-  if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)
-    return (0);
-  for (i = 0; t && legal_lang_values[i]; i++)
-    if (STREQ (t, legal_lang_values[i]))
-      {
-	_rl_meta_flag = 1;
-	_rl_convert_meta_chars_to_ascii = 0;
-	_rl_output_meta_chars = 1;
-	break;
-      }
-  free (t);
-  return (legal_lang_values[i] ? 1 : 0);
-
-#endif /* !HAVE_SETLOCALE */
-}
-
-#if !defined (HAVE_SETLOCALE)
-static char *
-normalize_codeset (codeset)
-     char *codeset;
-{
-  size_t namelen, i;
-  int len, all_digits;
-  char *wp, *retval;
-
-  codeset = find_codeset (codeset, &namelen);
-
-  if (codeset == 0)
-    return (codeset);
-
-  all_digits = 1;
-  for (len = 0, i = 0; i < namelen; i++)
-    {
-      if (isalnum (codeset[i]))
-	{
-	  len++;
-	  all_digits &= isdigit (codeset[i]);
-	}
-    }
-
-  retval = (char *)malloc ((all_digits ? 3 : 0) + len + 1);
-  if (retval == 0)
-    return ((char *)0);
-
-  wp = retval;
-  /* Add `iso' to beginning of an all-digit codeset */
-  if (all_digits)
-    {
-      *wp++ = 'i';
-      *wp++ = 's';
-      *wp++ = 'o';
-    }
-
-  for (i = 0; i < namelen; i++)
-    if (isalpha (codeset[i]))
-      *wp++ = (isupper (codeset[i])) ? tolower (codeset[i]) : codeset[i];
-    else if (isdigit (codeset[i]))
-      *wp++ = codeset[i];
-  *wp = '\0';
-
-  return retval;
-}
-
-/* Isolate codeset portion of locale specification. */
-static char *
-find_codeset (name, lenp)
-     char *name;
-     size_t *lenp;
-{
-  char *cp, *language, *result;
-
-  cp = language = name;
-  result = (char *)0;
-
-  while (*cp && *cp != '_' && *cp != '@' && *cp != '+' && *cp != ',')
-    cp++;
-
-  /* This does not make sense: language has to be specified.  As
-     an exception we allow the variable to contain only the codeset
-     name.  Perhaps there are funny codeset names.  */
-  if (language == cp) 
-    {
-      *lenp = strlen (language);
-      result = language;
-    }
-  else
-    {
-      /* Next is the territory. */
-      if (*cp == '_')
-	do
-	  ++cp;
-	while (*cp && *cp != '.' && *cp != '@' && *cp != '+' && *cp != ',' && *cp != '_');
-
-      /* Now, finally, is the codeset. */
-      result = cp;
-      if (*cp == '.')
-	do
-	  ++cp;
-	while (*cp && *cp != '@');
-
-      if (cp - result > 2)
-	{
-	  result++;
-	  *lenp = cp - result;
-	}
-      else
-	{
-	  *lenp = strlen (language);
-	  result = language;
-	}
-    }
-
-  return result;
-}
-#endif /* !HAVE_SETLOCALE */
diff --git a/readline/parens.c b/readline/parens.c
deleted file mode 100644
--- a/readline/parens.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/* parens.c -- Implementation of matching parentheses feature. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#include "rlconf.h"
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>
-#include <sys/types.h>
-
-#if defined (FD_SET) && !defined (HAVE_SELECT)
-#  define HAVE_SELECT
-#endif
-
-#if defined (HAVE_SELECT)
-#  include <sys/time.h>
-#endif /* HAVE_SELECT */
-#if defined (HAVE_SYS_SELECT_H)
-#  include <sys/select.h>
-#endif
-
-#if defined (HAVE_STRING_H)
-#  include <string.h>
-#else /* !HAVE_STRING_H */
-#  include <strings.h>
-#endif /* !HAVE_STRING_H */
-
-#if !defined (strchr) && !defined (__STDC__)
-extern char *strchr (), *strrchr ();
-#endif /* !strchr && !__STDC__ */
-
-#include "readline.h"
-#include "rlprivate.h"
-
-static int find_matching_open __P((char *, int, int));
-
-/* Non-zero means try to blink the matching open parenthesis when the
-   close parenthesis is inserted. */
-#if defined (HAVE_SELECT)
-int rl_blink_matching_paren = 1;
-#else /* !HAVE_SELECT */
-int rl_blink_matching_paren = 0;
-#endif /* !HAVE_SELECT */
-
-static int _paren_blink_usec = 500000;
-
-/* Change emacs_standard_keymap to have bindings for paren matching when
-   ON_OR_OFF is 1, change them back to self_insert when ON_OR_OFF == 0. */
-void
-_rl_enable_paren_matching (on_or_off)
-     int on_or_off;
-{
-  if (on_or_off)
-    {	/* ([{ */
-      rl_bind_key_in_map (')', rl_insert_close, emacs_standard_keymap);
-      rl_bind_key_in_map (']', rl_insert_close, emacs_standard_keymap);
-      rl_bind_key_in_map ('}', rl_insert_close, emacs_standard_keymap);
-    }
-  else
-    {	/* ([{ */
-      rl_bind_key_in_map (')', rl_insert, emacs_standard_keymap);
-      rl_bind_key_in_map (']', rl_insert, emacs_standard_keymap);
-      rl_bind_key_in_map ('}', rl_insert, emacs_standard_keymap);
-    }
-}
-
-int
-rl_set_paren_blink_timeout (u)
-     int u;
-{
-  int o;
-
-  o = _paren_blink_usec;
-  if (u > 0)
-    _paren_blink_usec = u;
-  return (o);
-}
-
-int
-rl_insert_close (count, invoking_key)
-     int count, invoking_key;
-{
-  if (rl_explicit_arg || !rl_blink_matching_paren)
-    rl_insert (count, invoking_key);
-  else
-    {
-#if defined (HAVE_SELECT)
-      int orig_point, match_point, ready;
-      struct timeval timer;
-      fd_set readfds;
-
-      rl_insert (1, invoking_key);
-      (*rl_redisplay_function) ();
-      match_point =
-	find_matching_open (rl_line_buffer, rl_point - 2, invoking_key);
-
-      /* Emacs might message or ring the bell here, but I don't. */
-      if (match_point < 0)
-	return -1;
-
-      FD_ZERO (&readfds);
-      FD_SET (fileno (rl_instream), &readfds);
-      timer.tv_sec = 0;
-      timer.tv_usec = _paren_blink_usec;
-
-      orig_point = rl_point;
-      rl_point = match_point;
-      (*rl_redisplay_function) ();
-      ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
-      rl_point = orig_point;
-#else /* !HAVE_SELECT */
-      rl_insert (count, invoking_key);
-#endif /* !HAVE_SELECT */
-    }
-  return 0;
-}
-
-static int
-find_matching_open (string, from, closer)
-     char *string;
-     int from, closer;
-{
-  register int i;
-  int opener, level, delimiter;
-
-  switch (closer)
-    {
-    case ']': opener = '['; break;
-    case '}': opener = '{'; break;
-    case ')': opener = '('; break;
-    default:
-      return (-1);
-    }
-
-  level = 1;			/* The closer passed in counts as 1. */
-  delimiter = 0;		/* Delimited state unknown. */
-
-  for (i = from; i > -1; i--)
-    {
-      if (delimiter && (string[i] == delimiter))
-	delimiter = 0;
-      else if (rl_basic_quote_characters && strchr (rl_basic_quote_characters, string[i]))
-	delimiter = string[i];
-      else if (!delimiter && (string[i] == closer))
-	level++;
-      else if (!delimiter && (string[i] == opener))
-	level--;
-
-      if (!level)
-	break;
-    }
-  return (i);
-}
diff --git a/readline/posixdir.h b/readline/posixdir.h
deleted file mode 100644
--- a/readline/posixdir.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/* posixdir.h -- Posix directory reading includes and defines. */
-
-/* Copyright (C) 1987,1991 Free Software Foundation, Inc.
-
-   This file is part of GNU Bash, the Bourne Again SHell.
-
-   Bash is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   Bash is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Bash; see the file COPYING.  If not, write to the Free
-   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-/* This file should be included instead of <dirent.h> or <sys/dir.h>. */
-
-#if !defined (_POSIXDIR_H_)
-#define _POSIXDIR_H_
-
-#if defined (HAVE_DIRENT_H)
-#  include <dirent.h>
-#  define D_NAMLEN(d)   (strlen ((d)->d_name))
-#else
-#  if defined (HAVE_SYS_NDIR_H)
-#    include <sys/ndir.h>
-#  endif
-#  if defined (HAVE_SYS_DIR_H)
-#    include <sys/dir.h>
-#  endif
-#  if defined (HAVE_NDIR_H)
-#    include <ndir.h>
-#  endif
-#  if !defined (dirent)
-#    define dirent direct
-#  endif /* !dirent */
-#  define D_NAMLEN(d)   ((d)->d_namlen)
-#endif /* !HAVE_DIRENT_H */
-
-#if defined (STRUCT_DIRENT_HAS_D_INO) && !defined (STRUCT_DIRENT_HAS_D_FILENO)
-#  define d_fileno d_ino
-#endif
-
-#endif /* !_POSIXDIR_H_ */
diff --git a/readline/posixjmp.h b/readline/posixjmp.h
deleted file mode 100644
--- a/readline/posixjmp.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* posixjmp.h -- wrapper for setjmp.h with changes for POSIX systems. */
-
-/* Copyright (C) 1987,1991 Free Software Foundation, Inc.
-
-   This file is part of GNU Bash, the Bourne Again SHell.
-
-   Bash is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   Bash is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Bash; see the file COPYING.  If not, write to the Free
-   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#ifndef _POSIXJMP_H_
-#define _POSIXJMP_H_
-
-#include <setjmp.h>
-
-/* This *must* be included *after* config.h */
-
-#if defined (HAVE_POSIX_SIGSETJMP)
-#  define procenv_t	sigjmp_buf
-#  if !defined (__OPENNT)
-#    undef setjmp
-#    define setjmp(x)	sigsetjmp((x), 1)
-#    undef longjmp
-#    define longjmp(x, n)	siglongjmp((x), (n))
-#  endif /* !__OPENNT */
-#else
-#  define procenv_t	jmp_buf
-#endif
-
-#endif /* _POSIXJMP_H_ */
diff --git a/readline/posixstat.h b/readline/posixstat.h
deleted file mode 100644
--- a/readline/posixstat.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/* posixstat.h -- Posix stat(2) definitions for systems that
-   don't have them. */
-
-/* Copyright (C) 1987,1991 Free Software Foundation, Inc.
-
-   This file is part of GNU Bash, the Bourne Again SHell.
-
-   Bash is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   Bash is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Bash; see the file COPYING.  If not, write to the Free
-   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-/* This file should be included instead of <sys/stat.h>.
-   It relies on the local sys/stat.h to work though. */
-#if !defined (_POSIXSTAT_H_)
-#define _POSIXSTAT_H_
-
-#include <sys/stat.h>
-
-#if defined (STAT_MACROS_BROKEN)
-#  undef S_ISBLK
-#  undef S_ISCHR
-#  undef S_ISDIR
-#  undef S_ISFIFO
-#  undef S_ISREG
-#  undef S_ISLNK
-#endif /* STAT_MACROS_BROKEN */
-
-/* These are guaranteed to work only on isc386 */
-#if !defined (S_IFDIR) && !defined (S_ISDIR)
-#  define S_IFDIR 0040000
-#endif /* !S_IFDIR && !S_ISDIR */
-#if !defined (S_IFMT)
-#  define S_IFMT  0170000
-#endif /* !S_IFMT */
-
-/* Posix 1003.1 5.6.1.1 <sys/stat.h> file types */
-
-/* Some Posix-wannabe systems define _S_IF* macros instead of S_IF*, but
-   do not provide the S_IS* macros that Posix requires. */
-
-#if defined (_S_IFMT) && !defined (S_IFMT)
-#define S_IFMT _S_IFMT
-#endif
-#if defined (_S_IFIFO) && !defined (S_IFIFO)
-#define S_IFIFO _S_IFIFO
-#endif
-#if defined (_S_IFCHR) && !defined (S_IFCHR)
-#define S_IFCHR _S_IFCHR
-#endif
-#if defined (_S_IFDIR) && !defined (S_IFDIR)
-#define S_IFDIR _S_IFDIR
-#endif
-#if defined (_S_IFBLK) && !defined (S_IFBLK)
-#define S_IFBLK _S_IFBLK
-#endif
-#if defined (_S_IFREG) && !defined (S_IFREG)
-#define S_IFREG _S_IFREG
-#endif
-#if defined (_S_IFLNK) && !defined (S_IFLNK)
-#define S_IFLNK _S_IFLNK
-#endif
-#if defined (_S_IFSOCK) && !defined (S_IFSOCK)
-#define S_IFSOCK _S_IFSOCK
-#endif
-
-/* Test for each symbol individually and define the ones necessary (some
-   systems claiming Posix compatibility define some but not all). */
-
-#if defined (S_IFBLK) && !defined (S_ISBLK)
-#define	S_ISBLK(m)	(((m)&S_IFMT) == S_IFBLK)	/* block device */
-#endif
-
-#if defined (S_IFCHR) && !defined (S_ISCHR)
-#define	S_ISCHR(m)	(((m)&S_IFMT) == S_IFCHR)	/* character device */
-#endif
-
-#if defined (S_IFDIR) && !defined (S_ISDIR)
-#define	S_ISDIR(m)	(((m)&S_IFMT) == S_IFDIR)	/* directory */
-#endif
-
-#if defined (S_IFREG) && !defined (S_ISREG)
-#define	S_ISREG(m)	(((m)&S_IFMT) == S_IFREG)	/* file */
-#endif
-
-#if defined (S_IFIFO) && !defined (S_ISFIFO)
-#define	S_ISFIFO(m)	(((m)&S_IFMT) == S_IFIFO)	/* fifo - named pipe */
-#endif
-
-#if defined (S_IFLNK) && !defined (S_ISLNK)
-#define	S_ISLNK(m)	(((m)&S_IFMT) == S_IFLNK)	/* symbolic link */
-#endif
-
-#if defined (S_IFSOCK) && !defined (S_ISSOCK)
-#define	S_ISSOCK(m)	(((m)&S_IFMT) == S_IFSOCK)	/* socket */
-#endif
-
-/*
- * POSIX 1003.1 5.6.1.2 <sys/stat.h> File Modes
- */
-
-#if !defined (S_IRWXU)
-#  if !defined (S_IREAD)
-#    define S_IREAD	00400
-#    define S_IWRITE	00200
-#    define S_IEXEC	00100
-#  endif /* S_IREAD */
-
-#  if !defined (S_IRUSR)
-#    define S_IRUSR	S_IREAD			/* read, owner */
-#    define S_IWUSR	S_IWRITE		/* write, owner */
-#    define S_IXUSR	S_IEXEC			/* execute, owner */
-
-#    define S_IRGRP	(S_IREAD  >> 3)		/* read, group */
-#    define S_IWGRP	(S_IWRITE >> 3)		/* write, group */
-#    define S_IXGRP	(S_IEXEC  >> 3)		/* execute, group */
-
-#    define S_IROTH	(S_IREAD  >> 6)		/* read, other */
-#    define S_IWOTH	(S_IWRITE >> 6)		/* write, other */
-#    define S_IXOTH	(S_IEXEC  >> 6)		/* execute, other */
-#  endif /* !S_IRUSR */
-
-#  define S_IRWXU	(S_IRUSR | S_IWUSR | S_IXUSR)
-#  define S_IRWXG	(S_IRGRP | S_IWGRP | S_IXGRP)
-#  define S_IRWXO	(S_IROTH | S_IWOTH | S_IXOTH)
-#endif /* !S_IRWXU */
-
-/* These are non-standard, but are used in builtins.c$symbolic_umask() */
-#define S_IRUGO		(S_IRUSR | S_IRGRP | S_IROTH)
-#define S_IWUGO		(S_IWUSR | S_IWGRP | S_IWOTH)
-#define S_IXUGO		(S_IXUSR | S_IXGRP | S_IXOTH)
-
-#endif /* _POSIXSTAT_H_ */
diff --git a/readline/readline.c b/readline/readline.c
deleted file mode 100644
--- a/readline/readline.c
+++ /dev/null
@@ -1,2159 +0,0 @@
-/* readline.c -- a general facility for reading lines of input
-   with emacs style editing and completion. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-#include "posixstat.h"
-#include <fcntl.h>
-#if defined (HAVE_SYS_FILE_H)
-#  include <sys/file.h>
-#endif /* HAVE_SYS_FILE_H */
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#if defined (HAVE_LOCALE_H)
-#  include <locale.h>
-#endif
-
-#include <stdio.h>
-#include "posixjmp.h"
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-#if defined (__EMX__)
-#  define INCL_DOSPROCESS
-#  include <os2.h>
-#endif /* __EMX__ */
-
-/* Some standard library routines. */
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-#include "rlshell.h"
-#include "xmalloc.h"
-
-#ifndef RL_LIBRARY_VERSION
-#  define RL_LIBRARY_VERSION "4.2"
-#endif
-
-/* Evaluates its arguments multiple times. */
-#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
-
-/* Forward declarations used in this file. */
-void _rl_free_history_entry __P((HIST_ENTRY *));
-
-static char *readline_internal __P((void));
-static void readline_initialize_everything __P((void));
-static void start_using_history __P((void));
-static void bind_arrow_keys __P((void));
-static int rl_change_case __P((int, int));
-
-static void readline_default_bindings __P((void));
-
-/* **************************************************************** */
-/*								    */
-/*			Line editing input utility		    */
-/*								    */
-/* **************************************************************** */
-
-const char *rl_library_version = RL_LIBRARY_VERSION;
-
-/* True if this is `real' readline as opposed to some stub substitute. */
-int rl_gnu_readline_p = 1;
-
-/* A pointer to the keymap that is currently in use.
-   By default, it is the standard emacs keymap. */
-Keymap _rl_keymap = emacs_standard_keymap;
-
-/* The current style of editing. */
-int rl_editing_mode = emacs_mode;
-
-/* Non-zero if we called this function from _rl_dispatch().  It's present
-   so functions can find out whether they were called from a key binding
-   or directly from an application. */
-int rl_dispatching;
-
-/* Non-zero if the previous command was a kill command. */
-int _rl_last_command_was_kill = 0;
-
-/* The current value of the numeric argument specified by the user. */
-int rl_numeric_arg = 1;
-
-/* Non-zero if an argument was typed. */
-int rl_explicit_arg = 0;
-
-/* Temporary value used while generating the argument. */
-int rl_arg_sign = 1;
-
-/* Non-zero means we have been called at least once before. */
-static int rl_initialized;
-
-#if 0
-/* If non-zero, this program is running in an EMACS buffer. */
-static int running_in_emacs;
-#endif
-
-/* Flags word encapsulating the current readline state. */
-int rl_readline_state = RL_STATE_NONE;
-
-/* The current offset in the current input line. */
-int rl_point;
-
-/* Mark in the current input line. */
-int rl_mark;
-
-/* Length of the current input line. */
-int rl_end;
-
-/* Make this non-zero to return the current input_line. */
-int rl_done;
-
-/* The last function executed by readline. */
-rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;
-
-/* Top level environment for readline_internal (). */
-procenv_t readline_top_level;
-
-/* The streams we interact with. */
-FILE *_rl_in_stream, *_rl_out_stream;
-
-/* The names of the streams that we do input and output to. */
-FILE *rl_instream = (FILE *)NULL;
-FILE *rl_outstream = (FILE *)NULL;
-
-/* Non-zero means echo characters as they are read. */
-int readline_echoing_p = 1;
-
-/* Current prompt. */
-char *rl_prompt = (char *)NULL;
-int rl_visible_prompt_length = 0;
-
-/* Set to non-zero by calling application if it has already printed rl_prompt
-   and does not want readline to do it the first time. */
-int rl_already_prompted = 0;
-
-/* The number of characters read in order to type this complete command. */
-int rl_key_sequence_length = 0;
-
-/* If non-zero, then this is the address of a function to call just
-   before readline_internal_setup () prints the first prompt. */
-rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;
-
-/* If non-zero, this is the address of a function to call just before
-   readline_internal_setup () returns and readline_internal starts
-   reading input characters. */
-rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;
-
-/* What we use internally.  You should always refer to RL_LINE_BUFFER. */
-static char *the_line;
-
-/* The character that can generate an EOF.  Really read from
-   the terminal driver... just defaulted here. */
-int _rl_eof_char = CTRL ('D');
-
-/* Non-zero makes this the next keystroke to read. */
-int rl_pending_input = 0;
-
-/* Pointer to a useful terminal name. */
-const char *rl_terminal_name = (const char *)NULL;
-
-/* Non-zero means to always use horizontal scrolling in line display. */
-int _rl_horizontal_scroll_mode = 0;
-
-/* Non-zero means to display an asterisk at the starts of history lines
-   which have been modified. */
-int _rl_mark_modified_lines = 0;  
-
-/* The style of `bell' notification preferred.  This can be set to NO_BELL,
-   AUDIBLE_BELL, or VISIBLE_BELL. */
-int _rl_bell_preference = AUDIBLE_BELL;
-     
-/* String inserted into the line by rl_insert_comment (). */
-char *_rl_comment_begin;
-
-/* Keymap holding the function currently being executed. */
-Keymap rl_executing_keymap;
-
-/* Non-zero means to erase entire line, including prompt, on empty input lines. */
-int rl_erase_empty_line = 0;
-
-/* Non-zero means to read only this many characters rather than up to a
-   character bound to accept-line. */
-int rl_num_chars_to_read;
-
-/* Line buffer and maintenence. */
-char *rl_line_buffer = (char *)NULL;
-int rl_line_buffer_len = 0;
-
-/* Forward declarations used by the display and termcap code. */
-
-/* **************************************************************** */
-/*								    */
-/*			`Forward' declarations  		    */
-/*								    */
-/* **************************************************************** */
-
-/* Non-zero means do not parse any lines other than comments and
-   parser directives. */
-unsigned char _rl_parsing_conditionalized_out = 0;
-
-/* Non-zero means to convert characters with the meta bit set to
-   escape-prefixed characters so we can indirect through
-   emacs_meta_keymap or vi_escape_keymap. */
-int _rl_convert_meta_chars_to_ascii = 1;
-
-/* Non-zero means to output characters with the meta bit set directly
-   rather than as a meta-prefixed escape sequence. */
-int _rl_output_meta_chars = 0;
-
-/* **************************************************************** */
-/*								    */
-/*			Top Level Functions			    */
-/*								    */
-/* **************************************************************** */
-
-/* Non-zero means treat 0200 bit in terminal input as Meta bit. */
-int _rl_meta_flag = 0;	/* Forward declaration */
-
-/* Set up the prompt and expand it.  Called from readline() and
-   rl_callback_handler_install (). */
-int
-rl_set_prompt (prompt)
-     const char *prompt;
-{
-  FREE (rl_prompt);
-  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
-
-  rl_visible_prompt_length = (rl_prompt && *rl_prompt)
-				? rl_expand_prompt (rl_prompt)
-				: 0;
-  return 0;
-}
-  
-/* Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
-   none.  A return value of NULL means that EOF was encountered. */
-char *
-readline (prompt)
-     const char *prompt;
-{
-  char *value;
-
-  /* If we are at EOF return a NULL string. */
-  if (rl_pending_input == EOF)
-    {
-      rl_clear_pending_input ();
-      return ((char *)NULL);
-    }
-
-  rl_set_prompt (prompt);
-
-  rl_initialize ();
-  (*rl_prep_term_function) (_rl_meta_flag);
-
-#if defined (HANDLE_SIGNALS)
-  rl_set_signals ();
-#endif
-
-  value = readline_internal ();
-  (*rl_deprep_term_function) ();
-
-#if defined (HANDLE_SIGNALS)
-  rl_clear_signals ();
-#endif
-
-  return (value);
-}
-
-#if defined (READLINE_CALLBACKS)
-#  define STATIC_CALLBACK
-#else
-#  define STATIC_CALLBACK static
-#endif
-
-STATIC_CALLBACK void
-readline_internal_setup ()
-{
-  char *nprompt;
-
-  _rl_in_stream = rl_instream;
-  _rl_out_stream = rl_outstream;
-
-  if (rl_startup_hook)
-    (*rl_startup_hook) ();
-
-  if (readline_echoing_p == 0)
-    {
-      if (rl_prompt && rl_already_prompted == 0)
-	{
-	  nprompt = _rl_strip_prompt (rl_prompt);
-	  fprintf (_rl_out_stream, "%s", nprompt);
-	  fflush (_rl_out_stream);
-	  free (nprompt);
-	}
-    }
-  else
-    {
-      if (rl_prompt && rl_already_prompted)
-	rl_on_new_line_with_prompt ();
-      else
-	rl_on_new_line ();
-      (*rl_redisplay_function) ();
-#if defined (VI_MODE)
-      if (rl_editing_mode == vi_mode)
-	rl_vi_insertion_mode (1, 0);
-#endif /* VI_MODE */
-    }
-
-  if (rl_pre_input_hook)
-    (*rl_pre_input_hook) ();
-}
-
-STATIC_CALLBACK char *
-readline_internal_teardown (eof)
-     int eof;
-{
-  char *temp;
-  HIST_ENTRY *entry;
-
-  /* Restore the original of this history line, iff the line that we
-     are editing was originally in the history, AND the line has changed. */
-  entry = current_history ();
-
-  if (entry && rl_undo_list)
-    {
-      temp = savestring (the_line);
-      rl_revert_line (1, 0);
-      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
-      _rl_free_history_entry (entry);
-
-      strcpy (the_line, temp);
-      free (temp);
-    }
-
-  /* At any rate, it is highly likely that this line has an undo list.  Get
-     rid of it now. */
-  if (rl_undo_list)
-    rl_free_undo_list ();
-
-  return (eof ? (char *)NULL : savestring (the_line));
-}
-
-STATIC_CALLBACK int
-#if defined (READLINE_CALLBACKS)
-readline_internal_char ()
-#else
-readline_internal_charloop ()
-#endif
-{
-  static int lastc, eof_found;
-  int c, code, lk;
-
-  lastc = -1;
-  eof_found = 0;
-
-#if !defined (READLINE_CALLBACKS)
-  while (rl_done == 0)
-    {
-#endif
-      lk = _rl_last_command_was_kill;
-
-      code = setjmp (readline_top_level);
-
-      if (code)
-	(*rl_redisplay_function) ();
-
-      if (rl_pending_input == 0)
-	{
-	  /* Then initialize the argument and number of keys read. */
-	  _rl_init_argument ();
-	  rl_key_sequence_length = 0;
-	}
-
-      RL_SETSTATE(RL_STATE_READCMD);
-      c = rl_read_key ();
-      RL_UNSETSTATE(RL_STATE_READCMD);
-
-      /* EOF typed to a non-blank line is a <NL>. */
-      if (c == EOF && rl_end)
-	c = NEWLINE;
-
-      /* The character _rl_eof_char typed to blank line, and not as the
-	 previous character is interpreted as EOF. */
-      if (((c == _rl_eof_char && lastc != c) || c == EOF) && !rl_end)
-	{
-#if defined (READLINE_CALLBACKS)
-	  RL_SETSTATE(RL_STATE_DONE);
-	  return (rl_done = 1);
-#else
-	  eof_found = 1;
-	  break;
-#endif
-	}
-
-      lastc = c;
-      _rl_dispatch ((unsigned char)c, _rl_keymap);
-
-      /* If there was no change in _rl_last_command_was_kill, then no kill
-	 has taken place.  Note that if input is pending we are reading
-	 a prefix command, so nothing has changed yet. */
-      if (rl_pending_input == 0 && lk == _rl_last_command_was_kill)
-	_rl_last_command_was_kill = 0;
-
-#if defined (VI_MODE)
-      /* In vi mode, when you exit insert mode, the cursor moves back
-	 over the previous character.  We explicitly check for that here. */
-      if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)
-	rl_vi_check ();
-#endif /* VI_MODE */
-
-      if (rl_num_chars_to_read && rl_end >= rl_num_chars_to_read)
-        {
-          (*rl_redisplay_function) ();
-          rl_newline (1, '\n');
-        }
-
-      if (rl_done == 0)
-	(*rl_redisplay_function) ();
-
-      /* If the application writer has told us to erase the entire line if
-	  the only character typed was something bound to rl_newline, do so. */
-      if (rl_erase_empty_line && rl_done && rl_last_func == rl_newline &&
-	  rl_point == 0 && rl_end == 0)
-	_rl_erase_entire_line ();
-
-#if defined (READLINE_CALLBACKS)
-      return 0;
-#else
-    }
-
-  return (eof_found);
-#endif
-}
-
-#if defined (READLINE_CALLBACKS)
-static int
-readline_internal_charloop ()
-{
-  int eof = 1;
-
-  while (rl_done == 0)
-    eof = readline_internal_char ();
-  return (eof);
-}
-#endif /* READLINE_CALLBACKS */
-
-/* Read a line of input from the global rl_instream, doing output on
-   the global rl_outstream.
-   If rl_prompt is non-null, then that is our prompt. */
-static char *
-readline_internal ()
-{
-  int eof;
-
-  readline_internal_setup ();
-  eof = readline_internal_charloop ();
-  return (readline_internal_teardown (eof));
-}
-
-void
-_rl_init_line_state ()
-{
-  rl_point = rl_end = 0;
-  the_line = rl_line_buffer;
-  the_line[0] = 0;
-}
-
-void
-_rl_set_the_line ()
-{
-  the_line = rl_line_buffer;
-}
-
-/* Do the command associated with KEY in MAP.
-   If the associated command is really a keymap, then read
-   another key, and dispatch into that map. */
-int
-_rl_dispatch (key, map)
-     register int key;
-     Keymap map;
-{
-  int r, newkey;
-  char *macro;
-  rl_command_func_t *func;
-
-  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
-    {
-      if (map[ESC].type == ISKMAP)
-	{
-	  if (_rl_defining_kbd_macro)
-	    _rl_add_macro_char (ESC);
-	  map = FUNCTION_TO_KEYMAP (map, ESC);
-	  key = UNMETA (key);
-	  rl_key_sequence_length += 2;
-	  return (_rl_dispatch (key, map));
-	}
-      else
-	rl_ding ();
-      return 0;
-    }
-
-  if (_rl_defining_kbd_macro)
-    _rl_add_macro_char (key);
-
-  r = 0;
-  switch (map[key].type)
-    {
-    case ISFUNC:
-      func = map[key].function;
-      if (func)
-	{
-	  /* Special case rl_do_lowercase_version (). */
-	  if (func == rl_do_lowercase_version)
-	    return (_rl_dispatch (_rl_to_lower (key), map));
-
-	  rl_executing_keymap = map;
-
-#if 0
-	  _rl_suppress_redisplay = (map[key].function == rl_insert) && _rl_input_available ();
-#endif
-
-	  rl_dispatching = 1;
-	  RL_SETSTATE(RL_STATE_DISPATCHING);
-	  r = (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
-	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
-	  rl_dispatching = 0;
-
-	  /* If we have input pending, then the last command was a prefix
-	     command.  Don't change the state of rl_last_func.  Otherwise,
-	     remember the last command executed in this variable. */
-	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
-	    rl_last_func = map[key].function;
-	}
-      else
-	{
-	  _rl_abort_internal ();
-	  return -1;
-	}
-      break;
-
-    case ISKMAP:
-      if (map[key].function != 0)
-	{
-	  rl_key_sequence_length++;
-
-	  if (key == ESC)
-	    RL_SETSTATE(RL_STATE_METANEXT);
-	  RL_SETSTATE(RL_STATE_MOREINPUT);
-	  newkey = rl_read_key ();
-	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
-	  if (key == ESC)
-	    RL_UNSETSTATE(RL_STATE_METANEXT);
-
-	  r = _rl_dispatch (newkey, FUNCTION_TO_KEYMAP (map, key));
-	}
-      else
-	{
-	  _rl_abort_internal ();
-	  return -1;
-	}
-      break;
-
-    case ISMACR:
-      if (map[key].function != 0)
-	{
-	  macro = savestring ((char *)map[key].function);
-	  _rl_with_macro_input (macro);
-	  return 0;
-	}
-      break;
-    }
-#if defined (VI_MODE)
-  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
-      _rl_vi_textmod_command (key))
-    _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);
-#endif
-  return (r);
-}
-
-/* **************************************************************** */
-/*								    */
-/*			Initializations 			    */
-/*								    */
-/* **************************************************************** */
-
-/* Initialize readline (and terminal if not already). */
-int
-rl_initialize ()
-{
-  /* If we have never been called before, initialize the
-     terminal and data structures. */
-  if (!rl_initialized)
-    {
-      RL_SETSTATE(RL_STATE_INITIALIZING);
-      readline_initialize_everything ();
-      RL_UNSETSTATE(RL_STATE_INITIALIZING);
-      rl_initialized++;
-      RL_SETSTATE(RL_STATE_INITIALIZED);
-    }
-
-  /* Initalize the current line information. */
-  _rl_init_line_state ();
-
-  /* We aren't done yet.  We haven't even gotten started yet! */
-  rl_done = 0;
-  RL_UNSETSTATE(RL_STATE_DONE);
-
-  /* Tell the history routines what is going on. */
-  start_using_history ();
-
-  /* Make the display buffer match the state of the line. */
-  rl_reset_line_state ();
-
-  /* No such function typed yet. */
-  rl_last_func = (rl_command_func_t *)NULL;
-
-  /* Parsing of key-bindings begins in an enabled state. */
-  _rl_parsing_conditionalized_out = 0;
-
-#if defined (VI_MODE)
-  if (rl_editing_mode == vi_mode)
-    _rl_vi_initialize_line ();
-#endif
-
-  return 0;
-}
-
-#if 0
-#if defined (__EMX__)
-static void
-_emx_build_environ ()
-{
-  TIB *tibp;
-  PIB *pibp;
-  char *t, **tp;
-  int c;
-
-  DosGetInfoBlocks (&tibp, &pibp);
-  t = pibp->pib_pchenv;
-  for (c = 1; *t; c++)
-    t += strlen (t) + 1;
-  tp = environ = (char **)xmalloc ((c + 1) * sizeof (char *));
-  t = pibp->pib_pchenv;
-  while (*t)
-    {
-      *tp++ = t;
-      t += strlen (t) + 1;
-    }
-  *tp = 0;
-}
-#endif /* __EMX__ */
-#endif
-
-/* Initialize the entire state of the world. */
-static void
-readline_initialize_everything ()
-{
-#if 0
-#if defined (__EMX__)
-  if (environ == 0)
-    _emx_build_environ ();
-#endif
-#endif
-
-#if 0
-  /* Find out if we are running in Emacs -- UNUSED. */
-  running_in_emacs = sh_get_env_value ("EMACS") != (char *)0;
-#endif
-
-  /* Set up input and output if they are not already set up. */
-  if (!rl_instream)
-    rl_instream = stdin;
-
-  if (!rl_outstream)
-    rl_outstream = stdout;
-
-  /* Bind _rl_in_stream and _rl_out_stream immediately.  These values
-     may change, but they may also be used before readline_internal ()
-     is called. */
-  _rl_in_stream = rl_instream;
-  _rl_out_stream = rl_outstream;
-
-  /* Allocate data structures. */
-  if (rl_line_buffer == 0)
-    rl_line_buffer = xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
-
-  /* Initialize the terminal interface. */
-  if (rl_terminal_name == 0)
-    rl_terminal_name = sh_get_env_value ("TERM");
-  _rl_init_terminal_io (rl_terminal_name);
-
-  /* Bind tty characters to readline functions. */
-  readline_default_bindings ();
-
-  /* Initialize the function names. */
-  rl_initialize_funmap ();
-
-  /* Decide whether we should automatically go into eight-bit mode. */
-  _rl_init_eightbit ();
-      
-  /* Read in the init file. */
-  rl_read_init_file ((char *)NULL);
-
-  /* XXX */
-  if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
-    {
-      _rl_screenwidth--;
-      _rl_screenchars -= _rl_screenheight;
-    }
-
-  /* Override the effect of any `set keymap' assignments in the
-     inputrc file. */
-  rl_set_keymap_from_edit_mode ();
-
-  /* Try to bind a common arrow key prefix, if not already bound. */
-  bind_arrow_keys ();
-
-  /* Enable the meta key, if this terminal has one. */
-  if (_rl_enable_meta)
-    _rl_enable_meta_key ();
-
-  /* If the completion parser's default word break characters haven't
-     been set yet, then do so now. */
-  if (rl_completer_word_break_characters == (char *)NULL)
-    rl_completer_word_break_characters = rl_basic_word_break_characters;
-}
-
-/* If this system allows us to look at the values of the regular
-   input editing characters, then bind them to their readline
-   equivalents, iff the characters are not bound to keymaps. */
-static void
-readline_default_bindings ()
-{
-  rl_tty_set_default_bindings (_rl_keymap);
-}
-
-static void
-bind_arrow_keys_internal ()
-{
-  rl_command_func_t *f;
-
-#if defined (__MSDOS__)
-  f = rl_function_of_keyseq ("\033[0A", _rl_keymap, (int *)NULL);
-  if (!f || f == rl_do_lowercase_version)
-    {
-       _rl_bind_if_unbound ("\033[0A", rl_get_previous_history);
-       _rl_bind_if_unbound ("\033[0B", rl_backward);
-       _rl_bind_if_unbound ("\033[0C", rl_forward);
-       _rl_bind_if_unbound ("\033[0D", rl_get_next_history);
-    }
-#endif
-	
-  f = rl_function_of_keyseq ("\033[A", _rl_keymap, (int *)NULL);
-  if (!f || f == rl_do_lowercase_version)
-    {
-      _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
-      _rl_bind_if_unbound ("\033[B", rl_get_next_history);
-      _rl_bind_if_unbound ("\033[C", rl_forward);
-      _rl_bind_if_unbound ("\033[D", rl_backward);
-    }
-
-  f = rl_function_of_keyseq ("\033OA", _rl_keymap, (int *)NULL);
-  if (!f || f == rl_do_lowercase_version)
-    {
-      _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
-      _rl_bind_if_unbound ("\033OB", rl_get_next_history);
-      _rl_bind_if_unbound ("\033OC", rl_forward);
-      _rl_bind_if_unbound ("\033OD", rl_backward);
-    }
-}
-
-/* Try and bind the common arrow key prefix after giving termcap and
-   the inputrc file a chance to bind them and create `real' keymaps
-   for the arrow key prefix. */
-static void
-bind_arrow_keys ()
-{
-  Keymap xkeymap;
-
-  xkeymap = _rl_keymap;
-
-  _rl_keymap = emacs_standard_keymap;
-  bind_arrow_keys_internal ();
-
-#if defined (VI_MODE)
-  _rl_keymap = vi_movement_keymap;
-  bind_arrow_keys_internal ();
-#endif
-
-  _rl_keymap = xkeymap;
-}
-
-
-/* **************************************************************** */
-/*								    */
-/*			Numeric Arguments			    */
-/*								    */
-/* **************************************************************** */
-
-/* Handle C-u style numeric args, as well as M--, and M-digits. */
-static int
-rl_digit_loop ()
-{
-  int key, c, sawminus, sawdigits;
-
-  rl_save_prompt ();
-
-  RL_SETSTATE(RL_STATE_NUMERICARG);
-  sawminus = sawdigits = 0;
-  while (1)
-    {
-      if (rl_numeric_arg > 1000000)
-	{
-	  sawdigits = rl_explicit_arg = rl_numeric_arg = 0;
-	  rl_ding ();
-	  rl_restore_prompt ();
-	  rl_clear_message ();
-	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
-	  return 1;
-	}
-      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
-      RL_SETSTATE(RL_STATE_MOREINPUT);
-      key = c = rl_read_key ();
-      RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-      /* If we see a key bound to `universal-argument' after seeing digits,
-	 it ends the argument but is otherwise ignored. */
-      if (_rl_keymap[c].type == ISFUNC &&
-	  _rl_keymap[c].function == rl_universal_argument)
-	{
-	  if (sawdigits == 0)
-	    {
-	      rl_numeric_arg *= 4;
-	      continue;
-	    }
-	  else
-	    {
-	      RL_SETSTATE(RL_STATE_MOREINPUT);
-	      key = rl_read_key ();
-	      RL_UNSETSTATE(RL_STATE_MOREINPUT);
-	      rl_restore_prompt ();
-	      rl_clear_message ();
-	      RL_UNSETSTATE(RL_STATE_NUMERICARG);
-	      return (_rl_dispatch (key, _rl_keymap));
-	    }
-	}
-
-      c = UNMETA (c);
-
-      if (_rl_digit_p (c))
-	{
-	  rl_numeric_arg = rl_explicit_arg ? (rl_numeric_arg * 10) + c - '0' : c - '0';
-	  sawdigits = rl_explicit_arg = 1;
-	}
-      else if (c == '-' && rl_explicit_arg == 0)
-	{
-	  rl_numeric_arg = sawminus = 1;
-	  rl_arg_sign = -1;
-	}
-      else
-	{
-	  /* Make M-- command equivalent to M--1 command. */
-	  if (sawminus && rl_numeric_arg == 1 && rl_explicit_arg == 0)
-	    rl_explicit_arg = 1;
-	  rl_restore_prompt ();
-	  rl_clear_message ();
-	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
-	  return (_rl_dispatch (key, _rl_keymap));
-	}
-    }
-
-  RL_UNSETSTATE(RL_STATE_NUMERICARG);
-  return 0;
-}
-
-/* Add the current digit to the argument in progress. */
-int
-rl_digit_argument (ignore, key)
-     int ignore, key;
-{
-  rl_execute_next (key);
-  return (rl_digit_loop ());
-}
-
-/* What to do when you abort reading an argument. */
-int
-rl_discard_argument ()
-{
-  rl_ding ();
-  rl_clear_message ();
-  _rl_init_argument ();
-  return 0;
-}
-
-/* Create a default argument. */
-int
-_rl_init_argument ()
-{
-  rl_numeric_arg = rl_arg_sign = 1;
-  rl_explicit_arg = 0;
-  return 0;
-}
-
-/* C-u, universal argument.  Multiply the current argument by 4.
-   Read a key.  If the key has nothing to do with arguments, then
-   dispatch on it.  If the key is the abort character then abort. */
-int
-rl_universal_argument (count, key)
-     int count, key;
-{
-  rl_numeric_arg *= 4;
-  return (rl_digit_loop ());
-}
-
-/* **************************************************************** */
-/*								    */
-/*			Insert and Delete			    */
-/*								    */
-/* **************************************************************** */
-
-/* Insert a string of text into the line at point.  This is the only
-   way that you should do insertion.  rl_insert () calls this
-   function. */
-int
-rl_insert_text (string)
-     const char *string;
-{
-  register int i, l = strlen (string);
-
-  if (rl_end + l >= rl_line_buffer_len)
-    rl_extend_line_buffer (rl_end + l);
-
-  for (i = rl_end; i >= rl_point; i--)
-    the_line[i + l] = the_line[i];
-  strncpy (the_line + rl_point, string, l);
-
-  /* Remember how to undo this if we aren't undoing something. */
-  if (!_rl_doing_an_undo)
-    {
-      /* If possible and desirable, concatenate the undos. */
-      if ((l == 1) &&
-	  rl_undo_list &&
-	  (rl_undo_list->what == UNDO_INSERT) &&
-	  (rl_undo_list->end == rl_point) &&
-	  (rl_undo_list->end - rl_undo_list->start < 20))
-	rl_undo_list->end++;
-      else
-	rl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);
-    }
-  rl_point += l;
-  rl_end += l;
-  the_line[rl_end] = '\0';
-  return l;
-}
-
-/* Delete the string between FROM and TO.  FROM is
-   inclusive, TO is not. */
-int
-rl_delete_text (from, to)
-     int from, to;
-{
-  register char *text;
-  register int diff, i;
-
-  /* Fix it if the caller is confused. */
-  if (from > to)
-    SWAP (from, to);
-
-  /* fix boundaries */
-  if (to > rl_end)
-    {
-      to = rl_end;
-      if (from > to)
-        from = to;
-    }
-
-  text = rl_copy_text (from, to);
-
-  /* Some versions of strncpy() can't handle overlapping arguments. */
-  diff = to - from;
-  for (i = from; i < rl_end - diff; i++)
-    the_line[i] = the_line[i + diff];
-
-  /* Remember how to undo this delete. */
-  if (_rl_doing_an_undo == 0)
-    rl_add_undo (UNDO_DELETE, from, to, text);
-  else
-    free (text);
-
-  rl_end -= diff;
-  the_line[rl_end] = '\0';
-  return (diff);
-}
-
-/* Fix up point so that it is within the line boundaries after killing
-   text.  If FIX_MARK_TOO is non-zero, the mark is forced within line
-   boundaries also. */
-
-#define _RL_FIX_POINT(x) \
-	do { \
-	if (x > rl_end) \
-	  x = rl_end; \
-	else if (x < 0) \
-	  x = 0; \
-	} while (0)
-
-void
-_rl_fix_point (fix_mark_too)
-     int fix_mark_too;
-{
-  _RL_FIX_POINT (rl_point);
-  if (fix_mark_too)
-    _RL_FIX_POINT (rl_mark);
-}
-#undef _RL_FIX_POINT
-
-void
-_rl_replace_text (text, start, end)
-     const char *text;
-     int start, end;
-{
-  rl_begin_undo_group ();
-  rl_delete_text (start, end + 1);
-  rl_point = start;
-  rl_insert_text (text);
-  rl_end_undo_group ();
-}
-
-/* **************************************************************** */
-/*								    */
-/*			Readline character functions		    */
-/*								    */
-/* **************************************************************** */
-
-/* This is not a gap editor, just a stupid line input routine.  No hair
-   is involved in writing any of the functions, and none should be. */
-
-/* Note that:
-
-   rl_end is the place in the string that we would place '\0';
-   i.e., it is always safe to place '\0' there.
-
-   rl_point is the place in the string where the cursor is.  Sometimes
-   this is the same as rl_end.
-
-   Any command that is called interactively receives two arguments.
-   The first is a count: the numeric arg pased to this command.
-   The second is the key which invoked this command.
-*/
-
-/* **************************************************************** */
-/*								    */
-/*			Movement Commands			    */
-/*								    */
-/* **************************************************************** */
-
-/* Note that if you `optimize' the display for these functions, you cannot
-   use said functions in other functions which do not do optimizing display.
-   I.e., you will have to update the data base for rl_redisplay, and you
-   might as well let rl_redisplay do that job. */
-
-/* Move forward COUNT characters. */
-int
-rl_forward (count, key)
-     int count, key;
-{
-  if (count < 0)
-    rl_backward (-count, key);
-  else if (count > 0)
-    {
-      int end = rl_point + count;
-#if defined (VI_MODE)
-      int lend = rl_end > 0 ? rl_end - (rl_editing_mode == vi_mode) : rl_end;
-#else
-      int lend = rl_end;
-#endif
-
-      if (end > lend)
-	{
-	  rl_point = lend;
-	  rl_ding ();
-	}
-      else
-	rl_point = end;
-    }
-
-  if (rl_end < 0)
-    rl_end = 0;
-
-  return 0;
-}
-
-/* Move backward COUNT characters. */
-int
-rl_backward (count, key)
-     int count, key;
-{
-  if (count < 0)
-    rl_forward (-count, key);
-  else if (count > 0)
-    {
-      if (rl_point < count)
-	{
-	  rl_point = 0;
-	  rl_ding ();
-	}
-      else
-        rl_point -= count;
-    }
-  return 0;
-}
-
-/* Move to the beginning of the line. */
-int
-rl_beg_of_line (count, key)
-     int count, key;
-{
-  rl_point = 0;
-  return 0;
-}
-
-/* Move to the end of the line. */
-int
-rl_end_of_line (count, key)
-     int count, key;
-{
-  rl_point = rl_end;
-  return 0;
-}
-
-/* Move forward a word.  We do what Emacs does. */
-int
-rl_forward_word (count, key)
-     int count, key;
-{
-  int c;
-
-  if (count < 0)
-    {
-      rl_backward_word (-count, key);
-      return 0;
-    }
-
-  while (count)
-    {
-      if (rl_point == rl_end)
-	return 0;
-
-      /* If we are not in a word, move forward until we are in one.
-	 Then, move forward until we hit a non-alphabetic character. */
-      c = the_line[rl_point];
-      if (rl_alphabetic (c) == 0)
-	{
-	  while (++rl_point < rl_end)
-	    {
-	      c = the_line[rl_point];
-	      if (rl_alphabetic (c))
-		break;
-	    }
-	}
-      if (rl_point == rl_end)
-	return 0;
-      while (++rl_point < rl_end)
-	{
-	  c = the_line[rl_point];
-	  if (rl_alphabetic (c) == 0)
-	    break;
-	}
-      --count;
-    }
-  return 0;
-}
-
-/* Move backward a word.  We do what Emacs does. */
-int
-rl_backward_word (count, key)
-     int count, key;
-{
-  int c;
-
-  if (count < 0)
-    {
-      rl_forward_word (-count, key);
-      return 0;
-    }
-
-  while (count)
-    {
-      if (!rl_point)
-	return 0;
-
-      /* Like rl_forward_word (), except that we look at the characters
-	 just before point. */
-
-      c = the_line[rl_point - 1];
-      if (rl_alphabetic (c) == 0)
-	{
-	  while (--rl_point)
-	    {
-	      c = the_line[rl_point - 1];
-	      if (rl_alphabetic (c))
-		break;
-	    }
-	}
-
-      while (rl_point)
-	{
-	  c = the_line[rl_point - 1];
-	  if (rl_alphabetic (c) == 0)
-	    break;
-	  else
-	    --rl_point;
-	}
-      --count;
-    }
-  return 0;
-}
-
-/* Clear the current line.  Numeric argument to C-l does this. */
-int
-rl_refresh_line (ignore1, ignore2)
-     int ignore1, ignore2;
-{
-  int curr_line;
-
-  curr_line = _rl_current_display_line ();
-
-  _rl_move_vert (curr_line);
-  _rl_move_cursor_relative (0, the_line);   /* XXX is this right */
-
-  _rl_clear_to_eol (0);		/* arg of 0 means to not use spaces */
-
-  rl_forced_update_display ();
-  rl_display_fixed = 1;
-
-  return 0;
-}
-
-/* C-l typed to a line without quoting clears the screen, and then reprints
-   the prompt and the current input line.  Given a numeric arg, redraw only
-   the current line. */
-int
-rl_clear_screen (count, key)
-     int count, key;
-{
-  if (rl_explicit_arg)
-    {
-      rl_refresh_line (count, key);
-      return 0;
-    }
-
-  _rl_clear_screen ();		/* calls termcap function to clear screen */
-  rl_forced_update_display ();
-  rl_display_fixed = 1;
-
-  return 0;
-}
-
-int
-rl_arrow_keys (count, c)
-     int count, c;
-{
-  int ch;
-
-  RL_SETSTATE(RL_STATE_MOREINPUT);
-  ch = rl_read_key ();
-  RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-  switch (_rl_to_upper (ch))
-    {
-    case 'A':
-      rl_get_previous_history (count, ch);
-      break;
-
-    case 'B':
-      rl_get_next_history (count, ch);
-      break;
-
-    case 'C':
-      rl_forward (count, ch);
-      break;
-
-    case 'D':
-      rl_backward (count, ch);
-      break;
-
-    default:
-      rl_ding ();
-    }
-  return 0;
-}
-
-
-/* **************************************************************** */
-/*								    */
-/*			Text commands				    */
-/*								    */
-/* **************************************************************** */
-
-/* Insert the character C at the current location, moving point forward. */
-int
-rl_insert (count, c)
-     int count, c;
-{
-  register int i;
-  char *string;
-
-  if (count <= 0)
-    return 0;
-
-  /* If we can optimize, then do it.  But don't let people crash
-     readline because of extra large arguments. */
-  if (count > 1 && count <= 1024)
-    {
-      string = xmalloc (1 + count);
-
-      for (i = 0; i < count; i++)
-	string[i] = c;
-
-      string[i] = '\0';
-      rl_insert_text (string);
-      free (string);
-
-      return 0;
-    }
-
-  if (count > 1024)
-    {
-      int decreaser;
-      char str[1024+1];
-
-      for (i = 0; i < 1024; i++)
-	str[i] = c;
-
-      while (count)
-	{
-	  decreaser = (count > 1024 ? 1024 : count);
-	  str[decreaser] = '\0';
-	  rl_insert_text (str);
-	  count -= decreaser;
-	}
-
-      return 0;
-    }
-
-  /* We are inserting a single character.
-     If there is pending input, then make a string of all of the
-     pending characters that are bound to rl_insert, and insert
-     them all. */
-  if (_rl_any_typein ())
-    _rl_insert_typein (c);
-  else
-    {
-      /* Inserting a single character. */
-      char str[2];
-
-      str[1] = '\0';
-      str[0] = c;
-      rl_insert_text (str);
-    }
-  return 0;
-}
-
-/* Insert the next typed character verbatim. */
-int
-rl_quoted_insert (count, key)
-     int count, key;
-{
-  int c;
-
-#if defined (HANDLE_SIGNALS)
-  _rl_disable_tty_signals ();
-#endif
-
-  RL_SETSTATE(RL_STATE_MOREINPUT);
-  c = rl_read_key ();
-  RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-#if defined (HANDLE_SIGNALS)
-  _rl_restore_tty_signals ();
-#endif
-
-  return (rl_insert (count, c));  
-}
-
-/* Insert a tab character. */
-int
-rl_tab_insert (count, key)
-     int count, key;
-{
-  return (rl_insert (count, '\t'));
-}
-
-/* What to do when a NEWLINE is pressed.  We accept the whole line.
-   KEY is the key that invoked this command.  I guess it could have
-   meaning in the future. */
-int
-rl_newline (count, key)
-     int count, key;
-{
-  rl_done = 1;
-  RL_SETSTATE(RL_STATE_DONE);
-
-#if defined (VI_MODE)
-  if (rl_editing_mode == vi_mode)
-    {
-      _rl_vi_done_inserting ();
-      _rl_vi_reset_last ();
-    }
-#endif /* VI_MODE */
-
-  /* If we've been asked to erase empty lines, suppress the final update,
-     since _rl_update_final calls rl_crlf(). */
-  if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
-    return 0;
-
-  if (readline_echoing_p)
-    _rl_update_final ();
-  return 0;
-}
-
-/* What to do for some uppercase characters, like meta characters,
-   and some characters appearing in emacs_ctlx_keymap.  This function
-   is just a stub, you bind keys to it and the code in _rl_dispatch ()
-   is special cased. */
-int
-rl_do_lowercase_version (ignore1, ignore2)
-     int ignore1, ignore2;
-{
-  return 0;
-}
-
-/* Rubout the character behind point. */
-int
-rl_rubout (count, key)
-     int count, key;
-{
-  if (count < 0)
-    {
-      rl_delete (-count, key);
-      return 0;
-    }
-
-  if (!rl_point)
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  if (count > 1 || rl_explicit_arg)
-    {
-      int orig_point = rl_point;
-      rl_backward (count, key);
-      rl_kill_text (orig_point, rl_point);
-    }
-  else
-    {
-      int c = the_line[--rl_point];
-      rl_delete_text (rl_point, rl_point + 1);
-
-      if (rl_point == rl_end && isprint (c) && _rl_last_c_pos)
-	{
-	  int l;
-	  l = rl_character_len (c, rl_point);
-	  _rl_erase_at_end_of_line (l);
-	}
-    }
-  return 0;
-}
-
-/* Delete the character under the cursor.  Given a numeric argument,
-   kill that many characters instead. */
-int
-rl_delete (count, key)
-     int count, key;
-{
-  if (count < 0)
-    return (rl_rubout (-count, key));
-
-  if (rl_point == rl_end)
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  if (count > 1 || rl_explicit_arg)
-    {
-      int orig_point = rl_point;
-      rl_forward (count, key);
-      rl_kill_text (orig_point, rl_point);
-      rl_point = orig_point;
-      return 0;
-    }
-  else
-    return (rl_delete_text (rl_point, rl_point + 1));
-}
-
-/* Delete the character under the cursor, unless the insertion
-   point is at the end of the line, in which case the character
-   behind the cursor is deleted.  COUNT is obeyed and may be used
-   to delete forward or backward that many characters. */      
-int
-rl_rubout_or_delete (count, key)
-     int count, key;
-{
-  if (rl_end != 0 && rl_point == rl_end)
-    return (rl_rubout (count, key));
-  else
-    return (rl_delete (count, key));
-}  
-
-/* Delete all spaces and tabs around point. */
-int
-rl_delete_horizontal_space (count, ignore)
-     int count, ignore;
-{
-  int start = rl_point;
-
-  while (rl_point && whitespace (the_line[rl_point - 1]))
-    rl_point--;
-
-  start = rl_point;
-
-  while (rl_point < rl_end && whitespace (the_line[rl_point]))
-    rl_point++;
-
-  if (start != rl_point)
-    {
-      rl_delete_text (start, rl_point);
-      rl_point = start;
-    }
-  return 0;
-}
-
-/* Like the tcsh editing function delete-char-or-list.  The eof character
-   is caught before this is invoked, so this really does the same thing as
-   delete-char-or-list-or-eof, as long as it's bound to the eof character. */
-int
-rl_delete_or_show_completions (count, key)
-     int count, key;
-{
-  if (rl_end != 0 && rl_point == rl_end)
-    return (rl_possible_completions (count, key));
-  else
-    return (rl_delete (count, key));
-}
-
-#ifndef RL_COMMENT_BEGIN_DEFAULT
-#define RL_COMMENT_BEGIN_DEFAULT "#"
-#endif
-
-/* Turn the current line into a comment in shell history.
-   A K*rn shell style function. */
-int
-rl_insert_comment (count, key)
-     int count, key;
-{
-  rl_beg_of_line (1, key);
-  rl_insert_text (_rl_comment_begin ? _rl_comment_begin
-				    : RL_COMMENT_BEGIN_DEFAULT);
-  (*rl_redisplay_function) ();
-  rl_newline (1, '\n');
-  return (0);
-}
-
-/* **************************************************************** */
-/*								    */
-/*			Changing Case				    */
-/*								    */
-/* **************************************************************** */
-
-/* The three kinds of things that we know how to do. */
-#define UpCase 1
-#define DownCase 2
-#define CapCase 3
-
-/* Uppercase the word at point. */
-int
-rl_upcase_word (count, key)
-     int count, key;
-{
-  return (rl_change_case (count, UpCase));
-}
-
-/* Lowercase the word at point. */
-int
-rl_downcase_word (count, key)
-     int count, key;
-{
-  return (rl_change_case (count, DownCase));
-}
-
-/* Upcase the first letter, downcase the rest. */
-int
-rl_capitalize_word (count, key)
-     int count, key;
-{
- return (rl_change_case (count, CapCase));
-}
-
-/* The meaty function.
-   Change the case of COUNT words, performing OP on them.
-   OP is one of UpCase, DownCase, or CapCase.
-   If a negative argument is given, leave point where it started,
-   otherwise, leave it where it moves to. */
-static int
-rl_change_case (count, op)
-     int count, op;
-{
-  register int start, end;
-  int inword, c;
-
-  start = rl_point;
-  rl_forward_word (count, 0);
-  end = rl_point;
-
-  if (count < 0)
-    SWAP (start, end);
-
-  /* We are going to modify some text, so let's prepare to undo it. */
-  rl_modifying (start, end);
-
-  for (inword = 0; start < end; start++)
-    {
-      c = the_line[start];
-      switch (op)
-	{
-	case UpCase:
-	  the_line[start] = _rl_to_upper (c);
-	  break;
-
-	case DownCase:
-	  the_line[start] = _rl_to_lower (c);
-	  break;
-
-	case CapCase:
-	  the_line[start] = (inword == 0) ? _rl_to_upper (c) : _rl_to_lower (c);
-	  inword = rl_alphabetic (the_line[start]);
-	  break;
-
-	default:
-	  rl_ding ();
-	  return -1;
-	}
-    }
-  rl_point = end;
-  return 0;
-}
-
-/* **************************************************************** */
-/*								    */
-/*			Transposition				    */
-/*								    */
-/* **************************************************************** */
-
-/* Transpose the words at point. */
-int
-rl_transpose_words (count, key)
-     int count, key;
-{
-  char *word1, *word2;
-  int w1_beg, w1_end, w2_beg, w2_end;
-  int orig_point = rl_point;
-
-  if (!count)
-    return 0;
-
-  /* Find the two words. */
-  rl_forward_word (count, key);
-  w2_end = rl_point;
-  rl_backward_word (1, key);
-  w2_beg = rl_point;
-  rl_backward_word (count, key);
-  w1_beg = rl_point;
-  rl_forward_word (1, key);
-  w1_end = rl_point;
-
-  /* Do some check to make sure that there really are two words. */
-  if ((w1_beg == w2_beg) || (w2_beg < w1_end))
-    {
-      rl_ding ();
-      rl_point = orig_point;
-      return -1;
-    }
-
-  /* Get the text of the words. */
-  word1 = rl_copy_text (w1_beg, w1_end);
-  word2 = rl_copy_text (w2_beg, w2_end);
-
-  /* We are about to do many insertions and deletions.  Remember them
-     as one operation. */
-  rl_begin_undo_group ();
-
-  /* Do the stuff at word2 first, so that we don't have to worry
-     about word1 moving. */
-  rl_point = w2_beg;
-  rl_delete_text (w2_beg, w2_end);
-  rl_insert_text (word1);
-
-  rl_point = w1_beg;
-  rl_delete_text (w1_beg, w1_end);
-  rl_insert_text (word2);
-
-  /* This is exactly correct since the text before this point has not
-     changed in length. */
-  rl_point = w2_end;
-
-  /* I think that does it. */
-  rl_end_undo_group ();
-  free (word1);
-  free (word2);
-
-  return 0;
-}
-
-/* Transpose the characters at point.  If point is at the end of the line,
-   then transpose the characters before point. */
-int
-rl_transpose_chars (count, key)
-     int count, key;
-{
-  char dummy[2];
-
-  if (!count)
-    return 0;
-
-  if (!rl_point || rl_end < 2)
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  rl_begin_undo_group ();
-
-  if (rl_point == rl_end)
-    {
-      --rl_point;
-      count = 1;
-    }
-  rl_point--;
-
-  dummy[0] = the_line[rl_point];
-  dummy[1] = '\0';
-
-  rl_delete_text (rl_point, rl_point + 1);
-
-  rl_point += count;
-  _rl_fix_point (0);
-  rl_insert_text (dummy);
-
-  rl_end_undo_group ();
-  return 0;
-}
-
-/* **************************************************************** */
-/*								    */
-/*			Character Searching			    */
-/*								    */
-/* **************************************************************** */
-
-int
-_rl_char_search_internal (count, dir, schar)
-     int count, dir, schar;
-{
-  int pos, inc;
-
-  pos = rl_point;
-  inc = (dir < 0) ? -1 : 1;
-  while (count)
-    {
-      if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
-	{
-	  rl_ding ();
-	  return -1;
-	}
-
-      pos += inc;
-      do
-	{
-	  if (rl_line_buffer[pos] == schar)
-	    {
-	      count--;
-	      if (dir < 0)
-	        rl_point = (dir == BTO) ? pos + 1 : pos;
-	      else
-		rl_point = (dir == FTO) ? pos - 1 : pos;
-	      break;
-	    }
-	}
-      while ((dir < 0) ? pos-- : ++pos < rl_end);
-    }
-  return (0);
-}
-
-/* Search COUNT times for a character read from the current input stream.
-   FDIR is the direction to search if COUNT is non-negative; otherwise
-   the search goes in BDIR. */
-static int
-_rl_char_search (count, fdir, bdir)
-     int count, fdir, bdir;
-{
-  int c;
-
-  RL_SETSTATE(RL_STATE_MOREINPUT);
-  c = rl_read_key ();
-  RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-  if (count < 0)
-    return (_rl_char_search_internal (-count, bdir, c));
-  else
-    return (_rl_char_search_internal (count, fdir, c));
-}
-
-int
-rl_char_search (count, key)
-     int count, key;
-{
-  return (_rl_char_search (count, FFIND, BFIND));
-}
-
-int
-rl_backward_char_search (count, key)
-     int count, key;
-{
-  return (_rl_char_search (count, BFIND, FFIND));
-}
-
-/* **************************************************************** */
-/*								    */
-/*			History Utilities			    */
-/*								    */
-/* **************************************************************** */
-
-/* We already have a history library, and that is what we use to control
-   the history features of readline.  This is our local interface to
-   the history mechanism. */
-
-/* While we are editing the history, this is the saved
-   version of the original line. */
-HIST_ENTRY *_rl_saved_line_for_history = (HIST_ENTRY *)NULL;
-
-/* Set the history pointer back to the last entry in the history. */
-static void
-start_using_history ()
-{
-  using_history ();
-  if (_rl_saved_line_for_history)
-    _rl_free_history_entry (_rl_saved_line_for_history);
-
-  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
-}
-
-/* Free the contents (and containing structure) of a HIST_ENTRY. */
-void
-_rl_free_history_entry (entry)
-     HIST_ENTRY *entry;
-{
-  if (entry == 0)
-    return;
-  if (entry->line)
-    free (entry->line);
-  free (entry);
-}
-
-/* Perhaps put back the current line if it has changed. */
-int
-rl_maybe_replace_line ()
-{
-  HIST_ENTRY *temp;
-
-  temp = current_history ();
-  /* If the current line has changed, save the changes. */
-  if (temp && ((UNDO_LIST *)(temp->data) != rl_undo_list))
-    {
-      temp = replace_history_entry (where_history (), the_line, (histdata_t)rl_undo_list);
-      free (temp->line);
-      free (temp);
-    }
-  return 0;
-}
-
-/* Restore the _rl_saved_line_for_history if there is one. */
-int
-rl_maybe_unsave_line ()
-{
-  int line_len;
-
-  if (_rl_saved_line_for_history)
-    {
-      line_len = strlen (_rl_saved_line_for_history->line);
-
-      if (line_len >= rl_line_buffer_len)
-	rl_extend_line_buffer (line_len);
-
-      strcpy (the_line, _rl_saved_line_for_history->line);
-      rl_undo_list = (UNDO_LIST *)_rl_saved_line_for_history->data;
-      _rl_free_history_entry (_rl_saved_line_for_history);
-      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
-      rl_end = rl_point = strlen (the_line);
-    }
-  else
-    rl_ding ();
-  return 0;
-}
-
-/* Save the current line in _rl_saved_line_for_history. */
-int
-rl_maybe_save_line ()
-{
-  if (_rl_saved_line_for_history == 0)
-    {
-      _rl_saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-      _rl_saved_line_for_history->line = savestring (the_line);
-      _rl_saved_line_for_history->data = (char *)rl_undo_list;
-    }
-  return 0;
-}
-
-int
-_rl_free_saved_history_line ()
-{
-  if (_rl_saved_line_for_history)
-    {
-      _rl_free_history_entry (_rl_saved_line_for_history);
-      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
-    }
-  return 0;
-}      
-
-/* **************************************************************** */
-/*								    */
-/*			History Commands			    */
-/*								    */
-/* **************************************************************** */
-
-/* Meta-< goes to the start of the history. */
-int
-rl_beginning_of_history (count, key)
-     int count, key;
-{
-  return (rl_get_previous_history (1 + where_history (), key));
-}
-
-/* Meta-> goes to the end of the history.  (The current line). */
-int
-rl_end_of_history (count, key)
-     int count, key;
-{
-  rl_maybe_replace_line ();
-  using_history ();
-  rl_maybe_unsave_line ();
-  return 0;
-}
-
-/* Move down to the next history line. */
-int
-rl_get_next_history (count, key)
-     int count, key;
-{
-  HIST_ENTRY *temp;
-  int line_len;
-
-  if (count < 0)
-    return (rl_get_previous_history (-count, key));
-
-  if (count == 0)
-    return 0;
-
-  rl_maybe_replace_line ();
-
-  temp = (HIST_ENTRY *)NULL;
-  while (count)
-    {
-      temp = next_history ();
-      if (!temp)
-	break;
-      --count;
-    }
-
-  if (temp == 0)
-    rl_maybe_unsave_line ();
-  else
-    {
-      line_len = strlen (temp->line);
-
-      if (line_len >= rl_line_buffer_len)
-	rl_extend_line_buffer (line_len);
-
-      strcpy (the_line, temp->line);
-      rl_undo_list = (UNDO_LIST *)temp->data;
-      rl_end = rl_point = strlen (the_line);
-#if defined (VI_MODE)
-      if (rl_editing_mode == vi_mode)
-	rl_point = 0;
-#endif /* VI_MODE */
-    }
-  return 0;
-}
-
-/* Get the previous item out of our interactive history, making it the current
-   line.  If there is no previous history, just ding. */
-int
-rl_get_previous_history (count, key)
-     int count, key;
-{
-  HIST_ENTRY *old_temp, *temp;
-  int line_len;
-
-  if (count < 0)
-    return (rl_get_next_history (-count, key));
-
-  if (count == 0)
-    return 0;
-
-  /* If we don't have a line saved, then save this one. */
-  rl_maybe_save_line ();
-
-  /* If the current line has changed, save the changes. */
-  rl_maybe_replace_line ();
-
-  temp = old_temp = (HIST_ENTRY *)NULL;
-  while (count)
-    {
-      temp = previous_history ();
-      if (temp == 0)
-	break;
-
-      old_temp = temp;
-      --count;
-    }
-
-  /* If there was a large argument, and we moved back to the start of the
-     history, that is not an error.  So use the last value found. */
-  if (!temp && old_temp)
-    temp = old_temp;
-
-  if (temp == 0)
-    rl_ding ();
-  else
-    {
-      line_len = strlen (temp->line);
-
-      if (line_len >= rl_line_buffer_len)
-	rl_extend_line_buffer (line_len);
-
-      strcpy (the_line, temp->line);
-      rl_undo_list = (UNDO_LIST *)temp->data;
-      rl_end = rl_point = line_len;
-
-#if defined (VI_MODE)
-      if (rl_editing_mode == vi_mode)
-	rl_point = 0;
-#endif /* VI_MODE */
-    }
-  return 0;
-}
-
-/* **************************************************************** */
-/*								    */
-/*		   The Mark and the Region.			    */
-/*								    */
-/* **************************************************************** */
-
-/* Set the mark at POSITION. */
-int
-_rl_set_mark_at_pos (position)
-     int position;
-{
-  if (position > rl_end)
-    return -1;
-
-  rl_mark = position;
-  return 0;
-}
-
-/* A bindable command to set the mark. */
-int
-rl_set_mark (count, key)
-     int count, key;
-{
-  return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));
-}
-
-/* Exchange the position of mark and point. */
-int
-rl_exchange_point_and_mark (count, key)
-     int count, key;
-{
-  if (rl_mark > rl_end)
-    rl_mark = -1;
-
-  if (rl_mark == -1)
-    {
-      rl_ding ();
-      return -1;
-    }
-  else
-    SWAP (rl_point, rl_mark);
-
-  return 0;
-}
-
-/* **************************************************************** */
-/*								    */
-/*			    Editing Modes			    */
-/*								    */
-/* **************************************************************** */
-/* How to toggle back and forth between editing modes. */
-int
-rl_vi_editing_mode (count, key)
-     int count, key;
-{
-#if defined (VI_MODE)
-  rl_editing_mode = vi_mode;
-  rl_vi_insertion_mode (1, key);
-#endif /* VI_MODE */
-  return 0;
-}
-
-int
-rl_emacs_editing_mode (count, key)
-     int count, key;
-{
-  rl_editing_mode = emacs_mode;
-  _rl_keymap = emacs_standard_keymap;
-  return 0;
-}
diff --git a/readline/readline.h b/readline/readline.h
deleted file mode 100644
--- a/readline/readline.h
+++ /dev/null
@@ -1,725 +0,0 @@
-/* Readline.h -- the names of functions callable from within readline. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_READLINE_H_)
-#define _READLINE_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if defined (READLINE_LIBRARY)
-#  include "rlstdc.h"
-#  include "keymaps.h"
-#  include "tilde.h"
-#else
-#  include <readline/rlstdc.h>
-#  include <readline/keymaps.h>
-#  include <readline/tilde.h>
-#endif
-
-/* Readline data structures. */
-
-/* Maintaining the state of undo.  We remember individual deletes and inserts
-   on a chain of things to do. */
-
-/* The actions that undo knows how to undo.  Notice that UNDO_DELETE means
-   to insert some text, and UNDO_INSERT means to delete some text.   I.e.,
-   the code tells undo what to undo, not how to undo it. */
-enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };
-
-/* What an element of THE_UNDO_LIST looks like. */
-typedef struct undo_list {
-  struct undo_list *next;
-  int start, end;		/* Where the change took place. */
-  char *text;			/* The text to insert, if undoing a delete. */
-  enum undo_code what;		/* Delete, Insert, Begin, End. */
-} UNDO_LIST;
-
-/* The current undo list for RL_LINE_BUFFER. */
-extern UNDO_LIST *rl_undo_list;
-
-/* The data structure for mapping textual names to code addresses. */
-typedef struct _funmap {
-  const char *name;
-  rl_command_func_t *function;
-} FUNMAP;
-
-extern FUNMAP **funmap;
-
-/* **************************************************************** */
-/*								    */
-/*	     Functions available to bind to key sequences	    */
-/*								    */
-/* **************************************************************** */
-
-/* Bindable commands for numeric arguments. */
-extern int rl_digit_argument __P((int, int));
-extern int rl_universal_argument __P((int, int));
-
-/* Bindable commands for moving the cursor. */
-extern int rl_forward __P((int, int));
-extern int rl_backward __P((int, int));
-extern int rl_beg_of_line __P((int, int));
-extern int rl_end_of_line __P((int, int));
-extern int rl_forward_word __P((int, int));
-extern int rl_backward_word __P((int, int));
-extern int rl_refresh_line __P((int, int));
-extern int rl_clear_screen __P((int, int));
-extern int rl_arrow_keys __P((int, int));
-
-/* Bindable commands for inserting and deleting text. */
-extern int rl_insert __P((int, int));
-extern int rl_quoted_insert __P((int, int));
-extern int rl_tab_insert __P((int, int));
-extern int rl_newline __P((int, int));
-extern int rl_do_lowercase_version __P((int, int));
-extern int rl_rubout __P((int, int));
-extern int rl_delete __P((int, int));
-extern int rl_rubout_or_delete __P((int, int));
-extern int rl_delete_horizontal_space __P((int, int));
-extern int rl_delete_or_show_completions __P((int, int));
-extern int rl_insert_comment __P((int, int));
-
-/* Bindable commands for changing case. */
-extern int rl_upcase_word __P((int, int));
-extern int rl_downcase_word __P((int, int));
-extern int rl_capitalize_word __P((int, int));
-
-/* Bindable commands for transposing characters and words. */
-extern int rl_transpose_words __P((int, int));
-extern int rl_transpose_chars __P((int, int));
-
-/* Bindable commands for searching within a line. */
-extern int rl_char_search __P((int, int));
-extern int rl_backward_char_search __P((int, int));
-
-/* Bindable commands for readline's interface to the command history. */
-extern int rl_beginning_of_history __P((int, int));
-extern int rl_end_of_history __P((int, int));
-extern int rl_get_next_history __P((int, int));
-extern int rl_get_previous_history __P((int, int));
-
-/* Bindable commands for managing the mark and region. */
-extern int rl_set_mark __P((int, int));
-extern int rl_exchange_point_and_mark __P((int, int));
-
-/* Bindable commands to set the editing mode (emacs or vi). */
-extern int rl_vi_editing_mode __P((int, int));
-extern int rl_emacs_editing_mode __P((int, int));
-
-/* Bindable commands for managing key bindings. */
-extern int rl_re_read_init_file __P((int, int));
-extern int rl_dump_functions __P((int, int));
-extern int rl_dump_macros __P((int, int));
-extern int rl_dump_variables __P((int, int));
-
-/* Bindable commands for word completion. */
-extern int rl_complete __P((int, int));
-extern int rl_possible_completions __P((int, int));
-extern int rl_insert_completions __P((int, int));
-extern int rl_menu_complete __P((int, int));
-
-/* Bindable commands for killing and yanking text, and managing the kill ring. */
-extern int rl_kill_word __P((int, int));
-extern int rl_backward_kill_word __P((int, int));
-extern int rl_kill_line __P((int, int));
-extern int rl_backward_kill_line __P((int, int));
-extern int rl_kill_full_line __P((int, int));
-extern int rl_unix_word_rubout __P((int, int));
-extern int rl_unix_line_discard __P((int, int));
-extern int rl_copy_region_to_kill __P((int, int));
-extern int rl_kill_region __P((int, int));
-extern int rl_copy_forward_word __P((int, int));
-extern int rl_copy_backward_word __P((int, int));
-extern int rl_yank __P((int, int));
-extern int rl_yank_pop __P((int, int));
-extern int rl_yank_nth_arg __P((int, int));
-extern int rl_yank_last_arg __P((int, int));
-/* Not available unless __CYGWIN__ is defined. */
-#ifdef __CYGWIN__
-extern int rl_paste_from_clipboard __P((int, int));
-#endif
-
-/* Bindable commands for incremental searching. */
-extern int rl_reverse_search_history __P((int, int));
-extern int rl_forward_search_history __P((int, int));
-
-/* Bindable keyboard macro commands. */
-extern int rl_start_kbd_macro __P((int, int));
-extern int rl_end_kbd_macro __P((int, int));
-extern int rl_call_last_kbd_macro __P((int, int));
-
-/* Bindable undo commands. */
-extern int rl_revert_line __P((int, int));
-extern int rl_undo_command __P((int, int));
-
-/* Bindable tilde expansion commands. */
-extern int rl_tilde_expand __P((int, int));
-
-/* Bindable terminal control commands. */
-extern int rl_restart_output __P((int, int));
-extern int rl_stop_output __P((int, int));
-
-/* Miscellaneous bindable commands. */
-extern int rl_abort __P((int, int));
-extern int rl_tty_status __P((int, int));
-
-/* Bindable commands for incremental and non-incremental history searching. */
-extern int rl_history_search_forward __P((int, int));
-extern int rl_history_search_backward __P((int, int));
-extern int rl_noninc_forward_search __P((int, int));
-extern int rl_noninc_reverse_search __P((int, int));
-extern int rl_noninc_forward_search_again __P((int, int));
-extern int rl_noninc_reverse_search_again __P((int, int));
-
-/* Bindable command used when inserting a matching close character. */
-extern int rl_insert_close __P((int, int));
-
-/* Not available unless READLINE_CALLBACKS is defined. */
-extern void rl_callback_handler_install __P((const char *, rl_vcpfunc_t *));
-extern void rl_callback_read_char __P((void));
-extern void rl_callback_handler_remove __P((void));
-
-/* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
-/* VI-mode bindable commands. */
-extern int rl_vi_redo __P((int, int));
-extern int rl_vi_undo __P((int, int));
-extern int rl_vi_yank_arg __P((int, int));
-extern int rl_vi_fetch_history __P((int, int));
-extern int rl_vi_search_again __P((int, int));
-extern int rl_vi_search __P((int, int));
-extern int rl_vi_complete __P((int, int));
-extern int rl_vi_tilde_expand __P((int, int));
-extern int rl_vi_prev_word __P((int, int));
-extern int rl_vi_next_word __P((int, int));
-extern int rl_vi_end_word __P((int, int));
-extern int rl_vi_insert_beg __P((int, int));
-extern int rl_vi_append_mode __P((int, int));
-extern int rl_vi_append_eol __P((int, int));
-extern int rl_vi_eof_maybe __P((int, int));
-extern int rl_vi_insertion_mode __P((int, int));
-extern int rl_vi_movement_mode __P((int, int));
-extern int rl_vi_arg_digit __P((int, int));
-extern int rl_vi_change_case __P((int, int));
-extern int rl_vi_put __P((int, int));
-extern int rl_vi_column __P((int, int));
-extern int rl_vi_delete_to __P((int, int));
-extern int rl_vi_change_to __P((int, int));
-extern int rl_vi_yank_to __P((int, int));
-extern int rl_vi_delete __P((int, int));
-extern int rl_vi_back_to_indent __P((int, int));
-extern int rl_vi_first_print __P((int, int));
-extern int rl_vi_char_search __P((int, int));
-extern int rl_vi_match __P((int, int));
-extern int rl_vi_change_char __P((int, int));
-extern int rl_vi_subst __P((int, int));
-extern int rl_vi_overstrike __P((int, int));
-extern int rl_vi_overstrike_delete __P((int, int));
-extern int rl_vi_replace __P((int, int));
-extern int rl_vi_set_mark __P((int, int));
-extern int rl_vi_goto_mark __P((int, int));
-
-/* VI-mode utility functions. */
-extern int rl_vi_check __P((void));
-extern int rl_vi_domove __P((int, int *));
-extern int rl_vi_bracktype __P((int));
-
-/* VI-mode pseudo-bindable commands, used as utility functions. */
-extern int rl_vi_fWord __P((int, int));
-extern int rl_vi_bWord __P((int, int));
-extern int rl_vi_eWord __P((int, int));
-extern int rl_vi_fword __P((int, int));
-extern int rl_vi_bword __P((int, int));
-extern int rl_vi_eword __P((int, int));
-
-/* **************************************************************** */
-/*								    */
-/*			Well Published Functions		    */
-/*								    */
-/* **************************************************************** */
-
-/* Readline functions. */
-/* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
-extern char *readline __P((const char *));
-
-extern int rl_set_prompt __P((const char *));
-extern int rl_expand_prompt __P((char *));
-
-extern int rl_initialize __P((void));
-
-/* Undocumented; unused by readline */
-extern int rl_discard_argument __P((void));
-
-/* Utility functions to bind keys to readline commands. */
-extern int rl_add_defun __P((const char *, rl_command_func_t *, int));
-extern int rl_bind_key __P((int, rl_command_func_t *));
-extern int rl_bind_key_in_map __P((int, rl_command_func_t *, Keymap));
-extern int rl_unbind_key __P((int));
-extern int rl_unbind_key_in_map __P((int, Keymap));
-extern int rl_unbind_function_in_map __P((rl_command_func_t *, Keymap));
-extern int rl_unbind_command_in_map __P((const char *, Keymap));
-extern int rl_set_key __P((const char *, rl_command_func_t *, Keymap));
-extern int rl_generic_bind __P((int, const char *, char *, Keymap));
-extern int rl_variable_bind __P((const char *, const char *));
-
-/* Backwards compatibility, use rl_generic_bind instead. */
-extern int rl_macro_bind __P((const char *, const char *, Keymap));
-
-/* Undocumented in the texinfo manual; not really useful to programs. */
-extern int rl_translate_keyseq __P((const char *, char *, int *));
-extern char *rl_untranslate_keyseq __P((int));
-
-extern rl_command_func_t *rl_named_function __P((const char *));
-extern rl_command_func_t *rl_function_of_keyseq __P((const char *, Keymap, int *));
-
-extern void rl_list_funmap_names __P((void));
-extern char **rl_invoking_keyseqs_in_map __P((rl_command_func_t *, Keymap));
-extern char **rl_invoking_keyseqs __P((rl_command_func_t *));
- 
-extern void rl_function_dumper __P((int));
-extern void rl_macro_dumper __P((int));
-extern void rl_variable_dumper __P((int));
-
-extern int rl_read_init_file __P((const char *));
-extern int rl_parse_and_bind __P((char *));
-
-/* Functions for manipulating keymaps. */
-extern Keymap rl_make_bare_keymap __P((void));
-extern Keymap rl_copy_keymap __P((Keymap));
-extern Keymap rl_make_keymap __P((void));
-extern void rl_discard_keymap __P((Keymap));
-
-extern Keymap rl_get_keymap_by_name __P((const char *));
-extern char *rl_get_keymap_name __P((Keymap));
-extern void rl_set_keymap __P((Keymap));
-extern Keymap rl_get_keymap __P((void));
-/* Undocumented; used internally only. */
-extern void rl_set_keymap_from_edit_mode __P((void));
-extern char *rl_get_keymap_name_from_edit_mode __P((void));
-
-/* Functions for manipulating the funmap, which maps command names to functions. */
-extern int rl_add_funmap_entry __P((const char *, rl_command_func_t *));
-extern const char **rl_funmap_names __P((void));
-/* Undocumented, only used internally -- there is only one funmap, and this
-   function may be called only once. */
-extern void rl_initialize_funmap __P((void));
-
-/* Utility functions for managing keyboard macros. */
-extern void rl_push_macro_input __P((char *));
-
-/* Functions for undoing, from undo.c */
-extern void rl_add_undo __P((enum undo_code, int, int, char *));
-extern void rl_free_undo_list __P((void));
-extern int rl_do_undo __P((void));
-extern int rl_begin_undo_group __P((void));
-extern int rl_end_undo_group __P((void));
-extern int rl_modifying __P((int, int));
-
-/* Functions for redisplay. */
-extern void rl_redisplay __P((void));
-extern int rl_on_new_line __P((void));
-extern int rl_on_new_line_with_prompt __P((void));
-extern int rl_forced_update_display __P((void));
-extern int rl_clear_message __P((void));
-extern int rl_reset_line_state __P((void));
-extern int rl_crlf __P((void));
-
-#if (defined (__STDC__) || defined (__cplusplus)) && defined (USE_VARARGS) && defined (PREFER_STDARG)
-extern int rl_message (const char *, ...);
-#else
-extern int rl_message ();
-#endif
-
-extern int rl_show_char __P((int));
-
-/* Undocumented in texinfo manual. */
-extern int rl_character_len __P((int, int));
-
-/* Save and restore internal prompt redisplay information. */
-extern void rl_save_prompt __P((void));
-extern void rl_restore_prompt __P((void));
-
-/* Modifying text. */
-extern int rl_insert_text __P((const char *));
-extern int rl_delete_text __P((int, int));
-extern int rl_kill_text __P((int, int));
-extern char *rl_copy_text __P((int, int));
-
-/* Terminal and tty mode management. */
-extern void rl_prep_terminal __P((int));
-extern void rl_deprep_terminal __P((void));
-extern void rl_tty_set_default_bindings __P((Keymap));
-
-extern int rl_reset_terminal __P((const char *));
-extern void rl_resize_terminal __P((void));
-extern void rl_set_screen_size __P((int, int));
-extern void rl_get_screen_size __P((int *, int *));
-
-/* Functions for character input. */
-extern int rl_stuff_char __P((int));
-extern int rl_execute_next __P((int));
-extern int rl_clear_pending_input __P((void));
-extern int rl_read_key __P((void));
-extern int rl_getc __P((FILE *));
-extern int rl_set_keyboard_input_timeout __P((int));
-
-/* `Public' utility functions . */
-extern void rl_extend_line_buffer __P((int));
-extern int rl_ding __P((void));
-extern int rl_alphabetic __P((int));
-
-/* Readline signal handling, from signals.c */
-extern int rl_set_signals __P((void));
-extern int rl_clear_signals __P((void));
-extern void rl_cleanup_after_signal __P((void));
-extern void rl_reset_after_signal __P((void));
-extern void rl_free_line_state __P((void));
- 
-/* Undocumented. */
-extern int rl_set_paren_blink_timeout __P((int));
-
-/* Undocumented. */
-extern int rl_maybe_save_line __P((void));
-extern int rl_maybe_unsave_line __P((void));
-extern int rl_maybe_replace_line __P((void));
-
-/* Completion functions. */
-extern int rl_complete_internal __P((int));
-extern void rl_display_match_list __P((char **, int, int));
-
-extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
-extern char *rl_username_completion_function __P((const char *, int));
-extern char *rl_filename_completion_function __P((const char *, int));
-
-#if 0
-/* Backwards compatibility (compat.c).  These will go away sometime. */
-extern void free_undo_list __P((void));
-extern int maybe_save_line __P((void));
-extern int maybe_unsave_line __P((void));
-extern int maybe_replace_line __P((void));
-
-extern int ding __P((void));
-extern int alphabetic __P((int));
-extern int crlf __P((void));
-
-extern char **completion_matches __P((char *, rl_compentry_func_t *));
-extern char *username_completion_function __P((const char *, int));
-extern char *filename_completion_function __P((const char *, int));
-#endif
-
-/* **************************************************************** */
-/*								    */
-/*			Well Published Variables		    */
-/*								    */
-/* **************************************************************** */
-
-/* The version of this incarnation of the readline library. */
-extern const char *rl_library_version;
-
-/* True if this is real GNU readline. */
-extern int rl_gnu_readline_p;
-
-/* Flags word encapsulating the current readline state. */
-extern int rl_readline_state;
-
-/* Says which editing mode readline is currently using.  1 means emacs mode;
-   0 means vi mode. */
-extern int rl_editing_mode;
-
-/* The name of the calling program.  You should initialize this to
-   whatever was in argv[0].  It is used when parsing conditionals. */
-extern const char *rl_readline_name;
-
-/* The prompt readline uses.  This is set from the argument to
-   readline (), and should not be assigned to directly. */
-extern char *rl_prompt;
-
-/* The line buffer that is in use. */
-extern char *rl_line_buffer;
-
-/* The location of point, and end. */
-extern int rl_point;
-extern int rl_end;
-
-/* The mark, or saved cursor position. */
-extern int rl_mark;
-
-/* Flag to indicate that readline has finished with the current input
-   line and should return it. */
-extern int rl_done;
-
-/* If set to a character value, that will be the next keystroke read. */
-extern int rl_pending_input;
-
-/* Non-zero if we called this function from _rl_dispatch().  It's present
-   so functions can find out whether they were called from a key binding
-   or directly from an application. */
-extern int rl_dispatching;
-
-/* Non-zero if the user typed a numeric argument before executing the
-   current function. */
-extern int rl_explicit_arg;
-
-/* The current value of the numeric argument specified by the user. */
-extern int rl_numeric_arg;
-
-/* The address of the last command function Readline executed. */
-extern rl_command_func_t *rl_last_func;
-
-/* The name of the terminal to use. */
-extern const char *rl_terminal_name;
-
-/* The input and output streams. */
-extern FILE *rl_instream;
-extern FILE *rl_outstream;
-
-/* If non-zero, then this is the address of a function to call just
-   before readline_internal () prints the first prompt. */
-extern rl_hook_func_t *rl_startup_hook;
-
-/* If non-zero, this is the address of a function to call just before
-   readline_internal_setup () returns and readline_internal starts
-   reading input characters. */
-extern rl_hook_func_t *rl_pre_input_hook;
-      
-/* The address of a function to call periodically while Readline is
-   awaiting character input, or NULL, for no event handling. */
-extern rl_hook_func_t *rl_event_hook;
-
-/* The address of the function to call to fetch a character from the current
-   Readline input stream */
-extern rl_getc_func_t *rl_getc_function;
-
-extern rl_voidfunc_t *rl_redisplay_function;
-
-extern rl_vintfunc_t *rl_prep_term_function;
-extern rl_voidfunc_t *rl_deprep_term_function;
-
-/* Dispatch variables. */
-extern Keymap rl_executing_keymap;
-extern Keymap rl_binding_keymap;
-
-/* Display variables. */
-/* If non-zero, readline will erase the entire line, including any prompt,
-   if the only thing typed on an otherwise-blank line is something bound to
-   rl_newline. */
-extern int rl_erase_empty_line;
-
-/* If non-zero, the application has already printed the prompt (rl_prompt)
-   before calling readline, so readline should not output it the first time
-   redisplay is done. */
-extern int rl_already_prompted;
-
-/* A non-zero value means to read only this many characters rather than
-   up to a character bound to accept-line. */
-extern int rl_num_chars_to_read;
-
-/* The text of a currently-executing keyboard macro. */
-extern char *rl_executing_macro;
-
-/* Variables to control readline signal handling. */
-/* If non-zero, readline will install its own signal handlers for
-   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
-extern int rl_catch_signals;
-
-/* If non-zero, readline will install a signal handler for SIGWINCH
-   that also attempts to call any calling application's SIGWINCH signal
-   handler.  Note that the terminal is not cleaned up before the
-   application's signal handler is called; use rl_cleanup_after_signal()
-   to do that. */
-extern int rl_catch_sigwinch;
-
-/* Completion variables. */
-/* Pointer to the generator function for completion_matches ().
-   NULL means to use filename_entry_function (), the default filename
-   completer. */
-extern rl_compentry_func_t *rl_completion_entry_function;
-
-/* If rl_ignore_some_completions_function is non-NULL it is the address
-   of a function to call after all of the possible matches have been
-   generated, but before the actual completion is done to the input line.
-   The function is called with one argument; a NULL terminated array
-   of (char *).  If your function removes any of the elements, they
-   must be free()'ed. */
-extern rl_compignore_func_t *rl_ignore_some_completions_function;
-
-/* Pointer to alternative function to create matches.
-   Function is called with TEXT, START, and END.
-   START and END are indices in RL_LINE_BUFFER saying what the boundaries
-   of TEXT are.
-   If this function exists and returns NULL then call the value of
-   rl_completion_entry_function to try to match, otherwise use the
-   array of strings returned. */
-extern rl_completion_func_t *rl_attempted_completion_function;
-
-/* The basic list of characters that signal a break between words for the
-   completer routine.  The initial contents of this variable is what
-   breaks words in the shell, i.e. "n\"\\'`@$>". */
-extern const char *rl_basic_word_break_characters;
-
-/* The list of characters that signal a break between words for
-   rl_complete_internal.  The default list is the contents of
-   rl_basic_word_break_characters.  */
-extern const char *rl_completer_word_break_characters;
-
-/* List of characters which can be used to quote a substring of the line.
-   Completion occurs on the entire substring, and within the substring   
-   rl_completer_word_break_characters are treated as any other character,
-   unless they also appear within this list. */
-extern const char *rl_completer_quote_characters;
-
-/* List of quote characters which cause a word break. */
-extern const char *rl_basic_quote_characters;
-
-/* List of characters that need to be quoted in filenames by the completer. */
-extern const char *rl_filename_quote_characters;
-
-/* List of characters that are word break characters, but should be left
-   in TEXT when it is passed to the completion function.  The shell uses
-   this to help determine what kind of completing to do. */
-extern const char *rl_special_prefixes;
-
-/* If non-zero, then this is the address of a function to call when
-   completing on a directory name.  The function is called with
-   the address of a string (the current directory name) as an arg.  It
-   changes what is displayed when the possible completions are printed
-   or inserted. */
-extern rl_icppfunc_t *rl_directory_completion_hook;
-
-/* If non-zero, this is the address of a function to call when completing
-   a directory name.  This function takes the address of the directory name
-   to be modified as an argument.  Unlike rl_directory_completion_hook, it
-   only modifies the directory name used in opendir(2), not what is displayed
-   when the possible completions are printed or inserted.  It is called
-   before rl_directory_completion_hook.  I'm not happy with how this works
-   yet, so it's undocumented. */
-extern rl_icppfunc_t *rl_directory_rewrite_hook;
-
-/* Backwards compatibility with previous versions of readline. */
-#define rl_symbolic_link_hook rl_directory_completion_hook
-
-/* If non-zero, then this is the address of a function to call when
-   completing a word would normally display the list of possible matches.
-   This function is called instead of actually doing the display.
-   It takes three arguments: (char **matches, int num_matches, int max_length)
-   where MATCHES is the array of strings that matched, NUM_MATCHES is the
-   number of strings in that array, and MAX_LENGTH is the length of the
-   longest string in that array. */
-extern rl_compdisp_func_t *rl_completion_display_matches_hook;
-
-/* Non-zero means that the results of the matches are to be treated
-   as filenames.  This is ALWAYS zero on entry, and can only be changed
-   within a completion entry finder function. */
-extern int rl_filename_completion_desired;
-
-/* Non-zero means that the results of the matches are to be quoted using
-   double quotes (or an application-specific quoting mechanism) if the
-   filename contains any characters in rl_word_break_chars.  This is
-   ALWAYS non-zero on entry, and can only be changed within a completion
-   entry finder function. */
-extern int rl_filename_quoting_desired;
-
-/* Set to a function to quote a filename in an application-specific fashion.
-   Called with the text to quote, the type of match found (single or multiple)
-   and a pointer to the quoting character to be used, which the function can
-   reset if desired. */
-extern rl_quote_func_t *rl_filename_quoting_function;
-
-/* Function to call to remove quoting characters from a filename.  Called
-   before completion is attempted, so the embedded quotes do not interfere
-   with matching names in the file system. */
-extern rl_dequote_func_t *rl_filename_dequoting_function;
-
-/* Function to call to decide whether or not a word break character is
-   quoted.  If a character is quoted, it does not break words for the
-   completer. */
-extern rl_linebuf_func_t *rl_char_is_quoted_p;
-
-/* Non-zero means to suppress normal filename completion after the
-   user-specified completion function has been called. */
-extern int rl_attempted_completion_over;
-
-/* Set to a character describing the type of completion being attempted by
-   rl_complete_internal; available for use by application completion
-   functions. */
-extern int rl_completion_type;
-
-/* Character appended to completed words when at the end of the line.  The
-   default is a space.  Nothing is added if this is '\0'. */
-extern int rl_completion_append_character;
-
-/* Up to this many items will be displayed in response to a
-   possible-completions call.  After that, we ask the user if she
-   is sure she wants to see them all.  The default value is 100. */
-extern int rl_completion_query_items;
-
-/* If non-zero, then disallow duplicates in the matches. */
-extern int rl_ignore_completion_duplicates;
-
-/* If this is non-zero, completion is (temporarily) inhibited, and the
-   completion character will be inserted as any other. */
-extern int rl_inhibit_completion;
-   
-/* Definitions available for use by readline clients. */
-#define RL_PROMPT_START_IGNORE	'\001'
-#define RL_PROMPT_END_IGNORE	'\002'
-
-/* Possible values for do_replace argument to rl_filename_quoting_function,
-   called by rl_complete_internal. */
-#define NO_MATCH        0
-#define SINGLE_MATCH    1
-#define MULT_MATCH      2
-
-/* Possible state values for rl_readline_state */
-#define RL_STATE_NONE		0x00000		/* no state; before first call */
-
-#define RL_STATE_INITIALIZING	0x00001		/* initializing */
-#define RL_STATE_INITIALIZED	0x00002		/* initialization done */
-#define RL_STATE_TERMPREPPED	0x00004		/* terminal is prepped */
-#define RL_STATE_READCMD	0x00008		/* reading a command key */
-#define RL_STATE_METANEXT	0x00010		/* reading input after ESC */
-#define RL_STATE_DISPATCHING	0x00020		/* dispatching to a command */
-#define RL_STATE_MOREINPUT	0x00040		/* reading more input in a command function */
-#define RL_STATE_ISEARCH	0x00080		/* doing incremental search */
-#define RL_STATE_NSEARCH	0x00100		/* doing non-inc search */
-#define RL_STATE_SEARCH		0x00200		/* doing a history search */
-#define RL_STATE_NUMERICARG	0x00400		/* reading numeric argument */
-#define RL_STATE_MACROINPUT	0x00800		/* getting input from a macro */
-#define RL_STATE_MACRODEF	0x01000		/* defining keyboard macro */
-#define RL_STATE_OVERWRITE	0x02000		/* overwrite mode */
-#define RL_STATE_COMPLETING	0x04000		/* doing completion */
-#define RL_STATE_SIGHANDLER	0x08000		/* in readline sighandler */
-#define RL_STATE_UNDOING	0x10000		/* doing an undo */
-#define RL_STATE_INPUTPENDING	0x20000		/* rl_execute_next called */
-
-#define RL_STATE_DONE		0x80000		/* done; accepted line */
-
-#define RL_SETSTATE(x)		(rl_readline_state |= (x))
-#define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
-#define RL_ISSTATE(x)		(rl_readline_state & (x))
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _READLINE_H_ */
diff --git a/readline/rlconf.h b/readline/rlconf.h
deleted file mode 100644
--- a/readline/rlconf.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* rlconf.h -- readline configuration definitions */
-
-/* Copyright (C) 1994 Free Software Foundation, Inc.
-
-   This file contains the Readline Library (the Library), a set of
-   routines for providing Emacs style line input to programs that ask
-   for it.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_RLCONF_H_)
-#define _RLCONF_H_
-
-/* Define this if you want the vi-mode editing available. */
-#define VI_MODE
-
-/* Define this to get an indication of file type when listing completions. */
-#define VISIBLE_STATS
-
-/* This definition is needed by readline.c, rltty.c, and signals.c. */
-/* If on, then readline handles signals in a way that doesn't screw. */
-#define HANDLE_SIGNALS
-
-/* Ugly but working hack for binding prefix meta. */
-#define PREFIX_META_HACK
-
-/* The final, last-ditch effort file name for an init file. */
-#define DEFAULT_INPUTRC "~/.inputrc"
-
-/* If defined, expand tabs to spaces. */
-#define DISPLAY_TABS
-
-/* If defined, use the terminal escape sequence to move the cursor forward
-   over a character when updating the line rather than rewriting it. */
-/* #define HACK_TERMCAP_MOTION */
-
-/* The string inserted by the `insert comment' command. */
-#define RL_COMMENT_BEGIN_DEFAULT "#"
-
-/* Define this if you want code that allows readline to be used in an
-   X `callback' style. */
-#define READLINE_CALLBACKS
-
-#endif /* _RLCONF_H_ */
diff --git a/readline/rldefs.h b/readline/rldefs.h
deleted file mode 100644
--- a/readline/rldefs.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/* rldefs.h -- an attempt to isolate some of the system-specific defines
-   for readline.  This should be included after any files that define
-   system-specific constants like _POSIX_VERSION or USG. */
-
-/* Copyright (C) 1987,1989 Free Software Foundation, Inc.
-
-   This file contains the Readline Library (the Library), a set of
-   routines for providing Emacs style line input to programs that ask
-   for it.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_RLDEFS_H_)
-#define _RLDEFS_H_
-
-#if defined (HAVE_CONFIG_H)
-#  include "config.h"
-#endif
-
-#include "rlstdc.h"
-
-#if defined (_POSIX_VERSION) && !defined (TERMIOS_MISSING)
-#  define TERMIOS_TTY_DRIVER
-#else
-#  if defined (HAVE_TERMIO_H)
-#    define TERMIO_TTY_DRIVER
-#  else
-#    define NEW_TTY_DRIVER
-#  endif
-#endif
-
-/* Posix macro to check file in statbuf for directory-ness.
-   This requires that <sys/stat.h> be included before this test. */
-#if defined (S_IFDIR) && !defined (S_ISDIR)
-#  define S_ISDIR(m) (((m)&S_IFMT) == S_IFDIR)
-#endif
-
-/* Decide which flavor of the header file describing the C library
-   string functions to include and include it. */
-
-#if defined (HAVE_STRING_H)
-#  include <string.h>
-#else /* !HAVE_STRING_H */
-#  include <strings.h>
-#endif /* !HAVE_STRING_H */
-
-#if !defined (strchr) && !defined (__STDC__)
-extern char *strchr (), *strrchr ();
-#endif /* !strchr && !__STDC__ */
-
-#if defined (PREFER_STDARG)
-#  include <stdarg.h>
-#else
-#  if defined (PREFER_VARARGS)
-#    include <varargs.h>
-#  endif
-#endif
-
-#if defined (HAVE_STRCASECMP)
-#define _rl_stricmp strcasecmp
-#define _rl_strnicmp strncasecmp
-#else
-extern int _rl_stricmp __P((char *, char *);
-extern int _rl_strnicmp __P((char *, char *));
-#endif
-
-#if !defined (emacs_mode)
-#  define no_mode -1
-#  define vi_mode 0
-#  define emacs_mode 1
-#endif
-
-/* If you cast map[key].function to type (Keymap) on a Cray,
-   the compiler takes the value of map[key].function and
-   divides it by 4 to convert between pointer types (pointers
-   to functions and pointers to structs are different sizes).
-   This is not what is wanted. */
-#if defined (CRAY)
-#  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)((int)map[key].function)
-#  define KEYMAP_TO_FUNCTION(data)	(rl_command_func_t *)((int)(data))
-#else
-#  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)(map[key].function)
-#  define KEYMAP_TO_FUNCTION(data)	(rl_command_func_t *)(data)
-#endif
-
-#ifndef savestring
-extern char *xmalloc __P((int));
-#define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
-#endif
-
-/* Possible values for _rl_bell_preference. */
-#define NO_BELL 0
-#define AUDIBLE_BELL 1
-#define VISIBLE_BELL 2
-
-/* Definitions used when searching the line for characters. */
-/* NOTE: it is necessary that opposite directions are inverses */
-#define	FTO	 1		/* forward to */
-#define BTO	-1		/* backward to */
-#define FFIND	 2		/* forward find */
-#define BFIND	-2		/* backward find */
-
-/* Possible values for the found_quote flags word used by the completion
-   functions.  It says what kind of (shell-like) quoting we found anywhere
-   in the line. */
-#define RL_QF_SINGLE_QUOTE	0x1
-#define RL_QF_DOUBLE_QUOTE	0x2
-#define RL_QF_BACKSLASH		0x4
-
-/* Default readline line buffer length. */
-#define DEFAULT_BUFFER_SIZE 256
-
-#if !defined (STREQ)
-#define STREQ(a, b)	(((a)[0] == (b)[0]) && (strcmp ((a), (b)) == 0))
-#define STREQN(a, b, n)	(((n) == 0) ? (1) \
-				    : ((a)[0] == (b)[0]) && (strncmp ((a), (b), (n)) == 0))
-#endif
-
-#if !defined (FREE)
-#  define FREE(x)	if (x) free (x)
-#endif
-
-/* CONFIGURATION SECTION */
-#include "rlconf.h"
-
-#endif /* !_RLDEFS_H_ */
diff --git a/readline/rlprivate.h b/readline/rlprivate.h
deleted file mode 100644
--- a/readline/rlprivate.h
+++ /dev/null
@@ -1,269 +0,0 @@
-/* rlprivate.h -- functions and variables global to the readline library,
-		  but not intended for use by applications. */
-
-/* Copyright (C) 1999 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_RL_PRIVATE_H_)
-#define _RL_PRIVATE_H_
-
-#include "rlconf.h"	/* for VISIBLE_STATS */
-#include "rlstdc.h"
-#include "posixjmp.h" /* defines procenv_t */
-
-/*************************************************************************
- *									 *
- * Global functions undocumented in texinfo manual and not in readline.h *
- *									 *
- *************************************************************************/
-
-/* terminal.c */
-extern char *rl_get_termcap __P((const char *));
-
-/*************************************************************************
- *									 *
- * Global variables undocumented in texinfo manual and not in readline.h *
- *									 *
- *************************************************************************/
-
-/* complete.c */
-extern int rl_complete_with_tilde_expansion;
-#if defined (VISIBLE_STATS)
-extern int rl_visible_stats;
-#endif /* VISIBLE_STATS */
-
-/* readline.c */
-extern int rl_line_buffer_len;
-extern int rl_arg_sign;
-extern int rl_visible_prompt_length;
-extern int readline_echoing_p;
-extern int rl_key_sequence_length;
-
-/* display.c */
-extern int rl_display_fixed;
-
-/* parens.c */
-extern int rl_blink_matching_paren;
-
-/*************************************************************************
- *									 *
- * Global functions and variables unsed and undocumented		 *
- *									 *
- *************************************************************************/
-
-/* bind.c */
-extern char *rl_untranslate_keyseq __P((int));
-
-/* kill.c */
-extern int rl_set_retained_kills __P((int));
-
-/* readline.c */
-extern int rl_discard_argument __P((void));
-
-/* rltty.c */
-extern int rl_stop_output __P((int, int));
-
-/* terminal.c */
-extern void _rl_set_screen_size __P((int, int));
-
-/* undo.c */
-extern int _rl_fix_last_undo_of_type __P((int, int, int));
-
-/* util.c */
-extern char *_rl_savestring __P((const char *));
-
-/*************************************************************************
- *									 *
- * Functions and variables private to the readline library		 *
- *									 *
- *************************************************************************/
-
-/* NOTE: Functions and variables prefixed with `_rl_' are
-   pseudo-global: they are global so they can be shared
-   between files in the readline library, but are not intended
-   to be visible to readline callers. */
-
-/*************************************************************************
- * Undocumented private functions					 *
- *************************************************************************/
-
-#if defined(READLINE_CALLBACKS)
-
-/* readline.c */
-extern void readline_internal_setup __P((void));
-extern char *readline_internal_teardown __P((int));
-extern int readline_internal_char __P((void));
-
-#endif /* READLINE_CALLBACKS */
-
-/* bind.c */
-extern void _rl_bind_if_unbound __P((const char *, rl_command_func_t *));
-
-/* display.c */
-extern char *_rl_strip_prompt __P((char *));
-extern void _rl_move_cursor_relative __P((int, const char *));
-extern void _rl_move_vert __P((int));
-extern void _rl_save_prompt __P((void));
-extern void _rl_restore_prompt __P((void));
-extern char *_rl_make_prompt_for_search __P((int));
-extern void _rl_erase_at_end_of_line __P((int));
-extern void _rl_clear_to_eol __P((int));
-extern void _rl_clear_screen __P((void));
-extern void _rl_update_final __P((void));
-extern void _rl_redisplay_after_sigwinch __P((void));
-extern void _rl_clean_up_for_exit __P((void));
-extern void _rl_erase_entire_line __P((void));
-extern int _rl_current_display_line __P((void));
-
-/* input.c */
-extern int _rl_any_typein __P((void));
-extern int _rl_input_available __P((void));
-extern void _rl_insert_typein __P((int));
-
-/* macro.c */
-extern void _rl_with_macro_input __P((char *));
-extern int _rl_next_macro_key __P((void));
-extern void _rl_push_executing_macro __P((void));
-extern void _rl_pop_executing_macro __P((void));
-extern void _rl_add_macro_char __P((int));
-extern void _rl_kill_kbd_macro __P((void));
-
-/* nls.c */
-extern int _rl_init_eightbit __P((void));
-
-/* parens.c */
-extern void _rl_enable_paren_matching __P((int));
-
-/* readline.c */
-extern void _rl_init_line_state __P((void));
-extern void _rl_set_the_line __P((void));
-extern int _rl_dispatch __P((int, Keymap));
-extern int _rl_init_argument __P((void));
-extern void _rl_fix_point __P((int));
-extern void _rl_replace_text __P((const char *, int, int));
-extern int _rl_char_search_internal __P((int, int, int));
-extern int _rl_set_mark_at_pos __P((int));
-extern int _rl_free_saved_history_line __P((void));
-
-/* rltty.c */
-extern int _rl_disable_tty_signals __P((void));
-extern int _rl_restore_tty_signals __P((void));
-
-/* terminal.c */
-extern void _rl_get_screen_size __P((int, int));
-extern int _rl_init_terminal_io __P((const char *));
-#ifdef _MINIX
-extern void _rl_output_character_function __P((int));
-#else
-extern int _rl_output_character_function __P((int));
-#endif
-extern void _rl_output_some_chars __P((const char *, int));
-extern int _rl_backspace __P((int));
-extern void _rl_enable_meta_key __P((void));
-extern void _rl_control_keypad __P((int));
-
-/* util.c */
-extern int rl_alphabetic __P((int));
-extern int _rl_abort_internal __P((void));
-extern char *_rl_strindex __P((const char *, const char *));
-extern char *_rl_strpbrk __P((const char *, const char *));
-extern int _rl_qsort_string_compare __P((char **, char **));
-extern int (_rl_uppercase_p) __P((int));
-extern int (_rl_lowercase_p) __P((int));
-extern int (_rl_pure_alphabetic) __P((int));
-extern int (_rl_digit_p) __P((int));
-extern int (_rl_to_lower) __P((int));
-extern int (_rl_to_upper) __P((int));
-extern int (_rl_digit_value) __P((int));
-
-/* vi_mode.c */
-extern void _rl_vi_initialize_line __P((void));
-extern void _rl_vi_reset_last __P((void));
-extern void _rl_vi_set_last __P((int, int, int));
-extern int _rl_vi_textmod_command __P((int));
-extern void _rl_vi_done_inserting __P((void));
-
-/*************************************************************************
- * Undocumented private variables					 *
- *************************************************************************/
-
-/* bind.c */
-extern const char *_rl_possible_control_prefixes[];
-extern const char *_rl_possible_meta_prefixes[];
-
-/* complete.c */
-extern int _rl_complete_show_all;
-extern int _rl_complete_mark_directories;
-extern int _rl_print_completions_horizontally;
-extern int _rl_completion_case_fold;
-
-/* display.c */
-extern int _rl_vis_botlin;
-extern int _rl_last_c_pos;
-extern int _rl_suppress_redisplay;
-extern char *rl_display_prompt;
-
-/* isearch.c */
-extern unsigned char *_rl_isearch_terminators;
-
-/* macro.c */
-extern int _rl_defining_kbd_macro;
-extern char *_rl_executing_macro;
-
-/* readline.c */
-extern int _rl_horizontal_scroll_mode;
-extern int _rl_mark_modified_lines;
-extern int _rl_bell_preference;
-extern int _rl_meta_flag;
-extern int _rl_convert_meta_chars_to_ascii;
-extern int _rl_output_meta_chars;
-extern char *_rl_comment_begin;
-extern unsigned char _rl_parsing_conditionalized_out;
-extern Keymap _rl_keymap;
-extern FILE *_rl_in_stream;
-extern FILE *_rl_out_stream;
-extern int _rl_last_command_was_kill;
-extern int _rl_eof_char;
-extern procenv_t readline_top_level;
-
-/* terminal.c */
-extern int _rl_enable_keypad;
-extern int _rl_enable_meta;
-extern char *_rl_term_clreol;
-extern char *_rl_term_clrpag;
-extern char *_rl_term_im;
-extern char *_rl_term_ic;
-extern char *_rl_term_ei;
-extern char *_rl_term_DC;
-extern char *_rl_term_up;
-extern char *_rl_term_dc;
-extern char *_rl_term_cr;
-extern char *_rl_term_IC;
-extern int _rl_screenheight;
-extern int _rl_screenwidth;
-extern int _rl_screenchars;
-extern int _rl_terminal_can_insert;
-extern int _rl_term_autowrap;
-
-/* undo.c */
-extern int _rl_doing_an_undo;
-extern int _rl_undo_group_level;
-
-#endif /* _RL_PRIVATE_H_ */
diff --git a/readline/rlshell.h b/readline/rlshell.h
deleted file mode 100644
--- a/readline/rlshell.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* rlshell.h -- utility functions normally provided by bash. */
-
-/* Copyright (C) 1999 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_RL_SHELL_H_)
-#define _RL_SHELL_H_
-
-#include "rlstdc.h"
-
-extern char *sh_single_quote __P((char *));
-extern void sh_set_lines_and_columns __P((int, int));
-extern char *sh_get_env_value __P((const char *));
-extern char *sh_get_home_dir __P((void));
-extern int sh_unset_nodelay_mode __P((int));
-
-#endif /* _RL_SHELL_H_ */
diff --git a/readline/rlstdc.h b/readline/rlstdc.h
deleted file mode 100644
--- a/readline/rlstdc.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* stdc.h -- macros to make source compile on both ANSI C and K&R C
-   compilers. */
-
-/* Copyright (C) 1993 Free Software Foundation, Inc.
-
-   This file is part of GNU Bash, the Bourne Again SHell.
-
-   Bash is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   Bash is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Bash; see the file COPYING.  If not, write to the Free
-   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_RL_STDC_H_)
-#define _RL_STDC_H_
-
-/* Adapted from BSD /usr/include/sys/cdefs.h. */
-
-/* A function can be defined using prototypes and compile on both ANSI C
-   and traditional C compilers with something like this:
-	extern char *func __P((char *, char *, int)); */
-
-#if !defined (__P)
-#  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
-#    define __P(protos) protos
-#  else
-#    define __P(protos) ()
-#  endif
-#endif
-
-#if !defined (__STDC__) && !defined (__cplusplus)
-#  if defined (__GNUC__)	/* gcc with -traditional */
-#    if !defined (const)
-#      define const __const
-#    endif /* !const */
-#  else /* !__GNUC__ */
-#    if !defined (const)
-#      define const
-#    endif /* !const */
-#  endif /* !__GNUC__ */
-#endif /* !__STDC__ && !__cplusplus */
-
-#endif /* !_RL_STDC_H_ */
diff --git a/readline/rltty.c b/readline/rltty.c
deleted file mode 100644
--- a/readline/rltty.c
+++ /dev/null
@@ -1,882 +0,0 @@
-/* rltty.c -- functions to prepare and restore the terminal for readline's
-   use. */
-
-/* Copyright (C) 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-#include <signal.h>
-#include <errno.h>
-#include <stdio.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-#include "rldefs.h"
-
-#if defined (GWINSZ_IN_SYS_IOCTL)
-#  include <sys/ioctl.h>
-#endif /* GWINSZ_IN_SYS_IOCTL */
-
-#include "rltty.h"
-#include "readline.h"
-#include "rlprivate.h"
-
-#if !defined (errno)
-extern int errno;
-#endif /* !errno */
-
-rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
-rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;
-
-/* **************************************************************** */
-/*								    */
-/*			   Signal Management			    */
-/*								    */
-/* **************************************************************** */
-
-#if defined (HAVE_POSIX_SIGNALS)
-static sigset_t sigint_set, sigint_oset;
-#else /* !HAVE_POSIX_SIGNALS */
-#  if defined (HAVE_BSD_SIGNALS)
-static int sigint_oldmask;
-#  endif /* HAVE_BSD_SIGNALS */
-#endif /* !HAVE_POSIX_SIGNALS */
-
-static int sigint_blocked;
-
-/* Cause SIGINT to not be delivered until the corresponding call to
-   release_sigint(). */
-static void
-block_sigint ()
-{
-  if (sigint_blocked)
-    return;
-
-#if defined (HAVE_POSIX_SIGNALS)
-  sigemptyset (&sigint_set);
-  sigemptyset (&sigint_oset);
-  sigaddset (&sigint_set, SIGINT);
-  sigprocmask (SIG_BLOCK, &sigint_set, &sigint_oset);
-#else /* !HAVE_POSIX_SIGNALS */
-#  if defined (HAVE_BSD_SIGNALS)
-  sigint_oldmask = sigblock (sigmask (SIGINT));
-#  else /* !HAVE_BSD_SIGNALS */
-#    if defined (HAVE_USG_SIGHOLD)
-  sighold (SIGINT);
-#    endif /* HAVE_USG_SIGHOLD */
-#  endif /* !HAVE_BSD_SIGNALS */
-#endif /* !HAVE_POSIX_SIGNALS */
-
-  sigint_blocked = 1;
-}
-
-/* Allow SIGINT to be delivered. */
-static void
-release_sigint ()
-{
-  if (sigint_blocked == 0)
-    return;
-
-#if defined (HAVE_POSIX_SIGNALS)
-  sigprocmask (SIG_SETMASK, &sigint_oset, (sigset_t *)NULL);
-#else
-#  if defined (HAVE_BSD_SIGNALS)
-  sigsetmask (sigint_oldmask);
-#  else /* !HAVE_BSD_SIGNALS */
-#    if defined (HAVE_USG_SIGHOLD)
-  sigrelse (SIGINT);
-#    endif /* HAVE_USG_SIGHOLD */
-#  endif /* !HAVE_BSD_SIGNALS */
-#endif /* !HAVE_POSIX_SIGNALS */
-
-  sigint_blocked = 0;
-}
-
-/* **************************************************************** */
-/*								    */
-/*		      Saving and Restoring the TTY	    	    */
-/*								    */
-/* **************************************************************** */
-
-/* Non-zero means that the terminal is in a prepped state. */
-static int terminal_prepped;
-
-static _RL_TTY_CHARS _rl_tty_chars, _rl_last_tty_chars;
-
-/* If non-zero, means that this process has called tcflow(fd, TCOOFF)
-   and output is suspended. */
-#if defined (__ksr1__)
-static int ksrflow;
-#endif
-
-/* Dummy call to force a backgrounded readline to stop before it tries
-   to get the tty settings. */
-static void
-set_winsize (tty)
-     int tty;
-{
-#if defined (TIOCGWINSZ)
-  struct winsize w;
-
-  if (ioctl (tty, TIOCGWINSZ, &w) == 0)
-      (void) ioctl (tty, TIOCSWINSZ, &w);
-#endif /* TIOCGWINSZ */
-}
-
-#if defined (NEW_TTY_DRIVER)
-
-/* Values for the `flags' field of a struct bsdtty.  This tells which
-   elements of the struct bsdtty have been fetched from the system and
-   are valid. */
-#define SGTTY_SET	0x01
-#define LFLAG_SET	0x02
-#define TCHARS_SET	0x04
-#define LTCHARS_SET	0x08
-
-struct bsdtty {
-  struct sgttyb sgttyb;	/* Basic BSD tty driver information. */
-  int lflag;		/* Local mode flags, like LPASS8. */
-#if defined (TIOCGETC)
-  struct tchars tchars;	/* Terminal special characters, including ^S and ^Q. */
-#endif
-#if defined (TIOCGLTC)
-  struct ltchars ltchars; /* 4.2 BSD editing characters */
-#endif
-  int flags;		/* Bitmap saying which parts of the struct are valid. */
-};
-
-#define TIOTYPE struct bsdtty
-
-static TIOTYPE otio;
-
-static void
-save_tty_chars (tiop)
-     TIOTYPE *tiop;
-{
-  _rl_last_tty_chars = _rl_tty_chars;
-
-  if (tiop->flags & SGTTY_SET)
-    {
-      _rl_tty_chars.t_erase = tiop->sgttyb.sg_erase;
-      _rl_tty_chars.t_kill = tiop->sgttyb.sg_kill;
-    }
-
-  if (tiop->flags & TCHARS_SET)
-    {
-      _rl_tty_chars.t_intr = tiop->tchars.t_intrc;
-      _rl_tty_chars.t_quit = tiop->tchars.t_quitc;
-      _rl_tty_chars.t_start = tiop->tchars.t_startc;
-      _rl_tty_chars.t_stop = tiop->tchars.t_stopc;
-      _rl_tty_chars.t_eof = tiop->tchars.t_eofc;
-      _rl_tty_chars.t_eol = '\n';
-      _rl_tty_chars.t_eol2 = tiop->tchars.t_brkc;
-    }
-
-  if (tiop->flags & LTCHARS_SET)
-    {
-      _rl_tty_chars.t_susp = tiop->ltchars.t_suspc;
-      _rl_tty_chars.t_dsusp = tiop->ltchars.t_dsuspc;
-      _rl_tty_chars.t_reprint = tiop->ltchars.t_rprntc;
-      _rl_tty_chars.t_flush = tiop->ltchars.t_flushc;
-      _rl_tty_chars.t_werase = tiop->ltchars.t_werasc;
-      _rl_tty_chars.t_lnext = tiop->ltchars.t_lnextc;
-    }
-
-  _rl_tty_chars.t_status = -1;
-}
-
-static int
-get_tty_settings (tty, tiop)
-     int tty;
-     TIOTYPE *tiop;
-{
-  set_winsize (tty);
-
-  tiop->flags = tiop->lflag = 0;
-
-  if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)
-    return -1;
-  tiop->flags |= SGTTY_SET;
-
-#if defined (TIOCLGET)
-  if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)
-    tiop->flags |= LFLAG_SET;
-#endif
-
-#if defined (TIOCGETC)
-  if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)
-    tiop->flags |= TCHARS_SET;
-#endif
-
-#if defined (TIOCGLTC)
-  if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)
-    tiop->flags |= LTCHARS_SET;
-#endif
-
-  return 0;
-}
-
-static int
-set_tty_settings (tty, tiop)
-     int tty;
-     TIOTYPE *tiop;
-{
-  if (tiop->flags & SGTTY_SET)
-    {
-      ioctl (tty, TIOCSETN, &(tiop->sgttyb));
-      tiop->flags &= ~SGTTY_SET;
-    }
-  readline_echoing_p = 1;
-
-#if defined (TIOCLSET)
-  if (tiop->flags & LFLAG_SET)
-    {
-      ioctl (tty, TIOCLSET, &(tiop->lflag));
-      tiop->flags &= ~LFLAG_SET;
-    }
-#endif
-
-#if defined (TIOCSETC)
-  if (tiop->flags & TCHARS_SET)
-    {
-      ioctl (tty, TIOCSETC, &(tiop->tchars));
-      tiop->flags &= ~TCHARS_SET;
-    }
-#endif
-
-#if defined (TIOCSLTC)
-  if (tiop->flags & LTCHARS_SET)
-    {
-      ioctl (tty, TIOCSLTC, &(tiop->ltchars));
-      tiop->flags &= ~LTCHARS_SET;
-    }
-#endif
-
-  return 0;
-}
-
-static void
-prepare_terminal_settings (meta_flag, oldtio, tiop)
-     int meta_flag;
-     TIOTYPE oldtio, *tiop;
-{
-  readline_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
-
-  /* Copy the original settings to the structure we're going to use for
-     our settings. */
-  tiop->sgttyb = oldtio.sgttyb;
-  tiop->lflag = oldtio.lflag;
-#if defined (TIOCGETC)
-  tiop->tchars = oldtio.tchars;
-#endif
-#if defined (TIOCGLTC)
-  tiop->ltchars = oldtio.ltchars;
-#endif
-  tiop->flags = oldtio.flags;
-
-  /* First, the basic settings to put us into character-at-a-time, no-echo
-     input mode. */
-  tiop->sgttyb.sg_flags &= ~(ECHO | CRMOD);
-  tiop->sgttyb.sg_flags |= CBREAK;
-
-  /* If this terminal doesn't care how the 8th bit is used, then we can
-     use it for the meta-key.  If only one of even or odd parity is
-     specified, then the terminal is using parity, and we cannot. */
-#if !defined (ANYP)
-#  define ANYP (EVENP | ODDP)
-#endif
-  if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||
-      ((oldtio.sgttyb.sg_flags & ANYP) == 0))
-    {
-      tiop->sgttyb.sg_flags |= ANYP;
-
-      /* Hack on local mode flags if we can. */
-#if defined (TIOCLGET)
-#  if defined (LPASS8)
-      tiop->lflag |= LPASS8;
-#  endif /* LPASS8 */
-#endif /* TIOCLGET */
-    }
-
-#if defined (TIOCGETC)
-#  if defined (USE_XON_XOFF)
-  /* Get rid of terminal output start and stop characters. */
-  tiop->tchars.t_stopc = -1; /* C-s */
-  tiop->tchars.t_startc = -1; /* C-q */
-
-  /* If there is an XON character, bind it to restart the output. */
-  if (oldtio.tchars.t_startc != -1)
-    rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);
-#  endif /* USE_XON_XOFF */
-
-  /* If there is an EOF char, bind _rl_eof_char to it. */
-  if (oldtio.tchars.t_eofc != -1)
-    _rl_eof_char = oldtio.tchars.t_eofc;
-
-#  if defined (NO_KILL_INTR)
-  /* Get rid of terminal-generated SIGQUIT and SIGINT. */
-  tiop->tchars.t_quitc = -1; /* C-\ */
-  tiop->tchars.t_intrc = -1; /* C-c */
-#  endif /* NO_KILL_INTR */
-#endif /* TIOCGETC */
-
-#if defined (TIOCGLTC)
-  /* Make the interrupt keys go away.  Just enough to make people happy. */
-  tiop->ltchars.t_dsuspc = -1;	/* C-y */
-  tiop->ltchars.t_lnextc = -1;	/* C-v */
-#endif /* TIOCGLTC */
-}
-
-#else  /* !defined (NEW_TTY_DRIVER) */
-
-#if !defined (VMIN)
-#  define VMIN VEOF
-#endif
-
-#if !defined (VTIME)
-#  define VTIME VEOL
-#endif
-
-#if defined (TERMIOS_TTY_DRIVER)
-#  define TIOTYPE struct termios
-#  define DRAIN_OUTPUT(fd)	tcdrain (fd)
-#  define GETATTR(tty, tiop)	(tcgetattr (tty, tiop))
-#  ifdef M_UNIX
-#    define SETATTR(tty, tiop)	(tcsetattr (tty, TCSANOW, tiop))
-#  else
-#    define SETATTR(tty, tiop)	(tcsetattr (tty, TCSADRAIN, tiop))
-#  endif /* !M_UNIX */
-#else
-#  define TIOTYPE struct termio
-#  define DRAIN_OUTPUT(fd)
-#  define GETATTR(tty, tiop)	(ioctl (tty, TCGETA, tiop))
-#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETAW, tiop))
-#endif /* !TERMIOS_TTY_DRIVER */
-
-static TIOTYPE otio;
-
-#if defined (FLUSHO)
-#  define OUTPUT_BEING_FLUSHED(tp)  (tp->c_lflag & FLUSHO)
-#else
-#  define OUTPUT_BEING_FLUSHED(tp)  0
-#endif
-
-static void
-save_tty_chars (tiop)
-     TIOTYPE *tiop;
-{
-  _rl_last_tty_chars = _rl_tty_chars;
-
-  _rl_tty_chars.t_eof = tiop->c_cc[VEOF];
-  _rl_tty_chars.t_eol = tiop->c_cc[VEOL];
-#ifdef VEOL2
-  _rl_tty_chars.t_eol2 = tiop->c_cc[VEOL2];
-#endif
-  _rl_tty_chars.t_erase = tiop->c_cc[VERASE];
-#ifdef VWERASE
-  _rl_tty_chars.t_werase = tiop->c_cc[VWERASE];
-#endif
-  _rl_tty_chars.t_kill = tiop->c_cc[VKILL];
-#ifdef VREPRINT
-  _rl_tty_chars.t_reprint = tiop->c_cc[VREPRINT];
-#endif
-  _rl_tty_chars.t_intr = tiop->c_cc[VINTR];
-  _rl_tty_chars.t_quit = tiop->c_cc[VQUIT];
-#ifdef VSUSP
-  _rl_tty_chars.t_susp = tiop->c_cc[VSUSP];
-#endif
-#ifdef VDSUSP
-  _rl_tty_chars.t_dsusp = tiop->c_cc[VDSUSP];
-#endif
-#ifdef VSTART
-  _rl_tty_chars.t_start = tiop->c_cc[VSTART];
-#endif
-#ifdef VSTOP
-  _rl_tty_chars.t_stop = tiop->c_cc[VSTOP];
-#endif
-#ifdef VLNEXT
-  _rl_tty_chars.t_lnext = tiop->c_cc[VLNEXT];
-#endif
-#ifdef VDISCARD
-  _rl_tty_chars.t_flush = tiop->c_cc[VDISCARD];
-#endif
-#ifdef VSTATUS
-  _rl_tty_chars.t_status = tiop->c_cc[VSTATUS];
-#endif
-}
-
-#if defined (_AIX) || defined (_AIX41)
-/* Currently this is only used on AIX */
-static void
-rltty_warning (msg)
-     char *msg;
-{
-  fprintf (stderr, "readline: warning: %s\n", msg);
-}
-#endif
-
-#if defined (_AIX)
-void
-setopost(tp)
-TIOTYPE *tp;
-{
-  if ((tp->c_oflag & OPOST) == 0)
-    {
-      rltty_warning ("turning on OPOST for terminal\r");
-      tp->c_oflag |= OPOST|ONLCR;
-    }
-}
-#endif
-
-static int
-_get_tty_settings (tty, tiop)
-     int tty;
-     TIOTYPE *tiop;
-{
-  int ioctl_ret;
-
-  while (1)
-    {
-      ioctl_ret = GETATTR (tty, tiop);
-      if (ioctl_ret < 0)
-	{
-	  if (errno != EINTR)
-	    return -1;
-	  else
-	    continue;
-	}
-      if (OUTPUT_BEING_FLUSHED (tiop))
-	{
-#if defined (FLUSHO) && defined (_AIX41)
-	  rltty_warning ("turning off output flushing");
-	  tiop->c_lflag &= ~FLUSHO;
-	  break;
-#else
-	  continue;
-#endif
-	}
-      break;
-    }
-
-  return 0;
-}
-
-static int
-get_tty_settings (tty, tiop)
-     int tty;
-     TIOTYPE *tiop;
-{
-  set_winsize (tty);
-
-  if (_get_tty_settings (tty, tiop) < 0)
-    return -1;
-
-#if defined (_AIX)
-  setopost(tiop);
-#endif
-
-  return 0;
-}
-
-static int
-_set_tty_settings (tty, tiop)
-     int tty;
-     TIOTYPE *tiop;
-{
-  while (SETATTR (tty, tiop) < 0)
-    {
-      if (errno != EINTR)
-	return -1;
-      errno = 0;
-    }
-  return 0;
-}
-
-static int
-set_tty_settings (tty, tiop)
-     int tty;
-     TIOTYPE *tiop;
-{
-  if (_set_tty_settings (tty, tiop) < 0)
-    return -1;
-    
-#if 0
-
-#if defined (TERMIOS_TTY_DRIVER)
-#  if defined (__ksr1__)
-  if (ksrflow)
-    {
-      ksrflow = 0;
-      tcflow (tty, TCOON);
-    }
-#  else /* !ksr1 */
-  tcflow (tty, TCOON);		/* Simulate a ^Q. */
-#  endif /* !ksr1 */
-#else
-  ioctl (tty, TCXONC, 1);	/* Simulate a ^Q. */
-#endif /* !TERMIOS_TTY_DRIVER */
-
-#endif /* 0 */
-
-  return 0;
-}
-
-static void
-prepare_terminal_settings (meta_flag, oldtio, tiop)
-     int meta_flag;
-     TIOTYPE oldtio, *tiop;
-{
-  readline_echoing_p = (oldtio.c_lflag & ECHO);
-
-  tiop->c_lflag &= ~(ICANON | ECHO);
-
-  if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
-    _rl_eof_char = oldtio.c_cc[VEOF];
-
-#if defined (USE_XON_XOFF)
-#if defined (IXANY)
-  tiop->c_iflag &= ~(IXON | IXOFF | IXANY);
-#else
-  /* `strict' Posix systems do not define IXANY. */
-  tiop->c_iflag &= ~(IXON | IXOFF);
-#endif /* IXANY */
-#endif /* USE_XON_XOFF */
-
-  /* Only turn this off if we are using all 8 bits. */
-  if (((tiop->c_cflag & CSIZE) == CS8) || meta_flag)
-    tiop->c_iflag &= ~(ISTRIP | INPCK);
-
-  /* Make sure we differentiate between CR and NL on input. */
-  tiop->c_iflag &= ~(ICRNL | INLCR);
-
-#if !defined (HANDLE_SIGNALS)
-  tiop->c_lflag &= ~ISIG;
-#else
-  tiop->c_lflag |= ISIG;
-#endif
-
-  tiop->c_cc[VMIN] = 1;
-  tiop->c_cc[VTIME] = 0;
-
-#if defined (FLUSHO)
-  if (OUTPUT_BEING_FLUSHED (tiop))
-    {
-      tiop->c_lflag &= ~FLUSHO;
-      oldtio.c_lflag &= ~FLUSHO;
-    }
-#endif
-
-  /* Turn off characters that we need on Posix systems with job control,
-     just to be sure.  This includes ^Y and ^V.  This should not really
-     be necessary.  */
-#if defined (TERMIOS_TTY_DRIVER) && defined (_POSIX_VDISABLE)
-
-#if defined (VLNEXT)
-  tiop->c_cc[VLNEXT] = _POSIX_VDISABLE;
-#endif
-
-#if defined (VDSUSP)
-  tiop->c_cc[VDSUSP] = _POSIX_VDISABLE;
-#endif
-
-#endif /* TERMIOS_TTY_DRIVER && _POSIX_VDISABLE */
-}
-#endif  /* NEW_TTY_DRIVER */
-
-/* Put the terminal in CBREAK mode so that we can detect key presses. */
-void
-rl_prep_terminal (meta_flag)
-     int meta_flag;
-{
-  int tty;
-  TIOTYPE tio;
-
-  if (terminal_prepped)
-    return;
-
-  /* Try to keep this function from being INTerrupted. */
-  block_sigint ();
-
-  tty = fileno (rl_instream);
-
-  if (get_tty_settings (tty, &tio) < 0)
-    {
-      release_sigint ();
-      return;
-    }
-
-  otio = tio;
-
-  save_tty_chars (&otio);
-
-  prepare_terminal_settings (meta_flag, otio, &tio);
-
-  if (set_tty_settings (tty, &tio) < 0)
-    {
-      release_sigint ();
-      return;
-    }
-
-  if (_rl_enable_keypad)
-    _rl_control_keypad (1);
-
-  fflush (rl_outstream);
-  terminal_prepped = 1;
-  RL_SETSTATE(RL_STATE_TERMPREPPED);
-
-  release_sigint ();
-}
-
-/* Restore the terminal's normal settings and modes. */
-void
-rl_deprep_terminal ()
-{
-  int tty;
-
-  if (!terminal_prepped)
-    return;
-
-  /* Try to keep this function from being interrupted. */
-  block_sigint ();
-
-  tty = fileno (rl_instream);
-
-  if (_rl_enable_keypad)
-    _rl_control_keypad (0);
-
-  fflush (rl_outstream);
-
-  if (set_tty_settings (tty, &otio) < 0)
-    {
-      release_sigint ();
-      return;
-    }
-
-  terminal_prepped = 0;
-  RL_UNSETSTATE(RL_STATE_TERMPREPPED);
-
-  release_sigint ();
-}
-
-/* **************************************************************** */
-/*								    */
-/*			Bogus Flow Control      		    */
-/*								    */
-/* **************************************************************** */
-
-int
-rl_restart_output (count, key)
-     int count, key;
-{
-  int fildes = fileno (rl_outstream);
-#if defined (TIOCSTART)
-#if defined (apollo)
-  ioctl (&fildes, TIOCSTART, 0);
-#else
-  ioctl (fildes, TIOCSTART, 0);
-#endif /* apollo */
-
-#else /* !TIOCSTART */
-#  if defined (TERMIOS_TTY_DRIVER)
-#    if defined (__ksr1__)
-  if (ksrflow)
-    {
-      ksrflow = 0;
-      tcflow (fildes, TCOON);
-    }
-#    else /* !ksr1 */
-  tcflow (fildes, TCOON);		/* Simulate a ^Q. */
-#    endif /* !ksr1 */
-#  else /* !TERMIOS_TTY_DRIVER */
-#    if defined (TCXONC)
-  ioctl (fildes, TCXONC, TCOON);
-#    endif /* TCXONC */
-#  endif /* !TERMIOS_TTY_DRIVER */
-#endif /* !TIOCSTART */
-
-  return 0;
-}
-
-int
-rl_stop_output (count, key)
-     int count, key;
-{
-  int fildes = fileno (rl_instream);
-
-#if defined (TIOCSTOP)
-# if defined (apollo)
-  ioctl (&fildes, TIOCSTOP, 0);
-# else
-  ioctl (fildes, TIOCSTOP, 0);
-# endif /* apollo */
-#else /* !TIOCSTOP */
-# if defined (TERMIOS_TTY_DRIVER)
-#  if defined (__ksr1__)
-  ksrflow = 1;
-#  endif /* ksr1 */
-  tcflow (fildes, TCOOFF);
-# else
-#   if defined (TCXONC)
-  ioctl (fildes, TCXONC, TCOON);
-#   endif /* TCXONC */
-# endif /* !TERMIOS_TTY_DRIVER */
-#endif /* !TIOCSTOP */
-
-  return 0;
-}
-
-/* **************************************************************** */
-/*								    */
-/*			Default Key Bindings			    */
-/*								    */
-/* **************************************************************** */
-
-/* Set the system's default editing characters to their readline equivalents
-   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
-void
-rltty_set_default_bindings (kmap)
-     Keymap kmap;
-{
-  TIOTYPE ttybuff;
-  int tty = fileno (rl_instream);
-
-#if defined (NEW_TTY_DRIVER)
-
-#define SET_SPECIAL(sc, func) \
-  do \
-    { \
-      int ic; \
-      ic = sc; \
-      if (ic != -1 && kmap[ic].type == ISFUNC) \
-	kmap[ic].function = func; \
-    } \
-  while (0)
-
-  if (get_tty_settings (tty, &ttybuff) == 0)
-    {
-      if (ttybuff.flags & SGTTY_SET)
-	{
-	  SET_SPECIAL (ttybuff.sgttyb.sg_erase, rl_rubout);
-	  SET_SPECIAL (ttybuff.sgttyb.sg_kill, rl_unix_line_discard);
-	}
-
-#  if defined (TIOCGLTC)
-      if (ttybuff.flags & LTCHARS_SET)
-	{
-	  SET_SPECIAL (ttybuff.ltchars.t_werasc, rl_unix_word_rubout);
-	  SET_SPECIAL (ttybuff.ltchars.t_lnextc, rl_quoted_insert);
-	}
-#  endif /* TIOCGLTC */
-    }
-
-#else /* !NEW_TTY_DRIVER */
-
-#define SET_SPECIAL(sc, func) \
-  do \
-    { \
-      unsigned char uc; \
-      uc = ttybuff.c_cc[sc]; \
-      if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC) \
-	kmap[uc].function = func; \
-    } \
-  while (0)
-
-  if (get_tty_settings (tty, &ttybuff) == 0)
-    {
-      SET_SPECIAL (VERASE, rl_rubout);
-      SET_SPECIAL (VKILL, rl_unix_line_discard);
-
-#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)
-      SET_SPECIAL (VLNEXT, rl_quoted_insert);
-#  endif /* VLNEXT && TERMIOS_TTY_DRIVER */
-
-#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)
-      SET_SPECIAL (VWERASE, rl_unix_word_rubout);
-#  endif /* VWERASE && TERMIOS_TTY_DRIVER */
-    }
-#endif /* !NEW_TTY_DRIVER */
-}
-
-/* New public way to set the system default editing chars to their readline
-   equivalents. */
-void
-rl_tty_set_default_bindings (kmap)
-     Keymap kmap;
-{
-  rltty_set_default_bindings (kmap);
-}
-
-#if defined (HANDLE_SIGNALS)
-
-#if defined (NEW_TTY_DRIVER)
-int
-_rl_disable_tty_signals ()
-{
-  return 0;
-}
-
-int
-_rl_restore_tty_signals ()
-{
-  return 0;
-}
-#else
-
-static TIOTYPE sigstty, nosigstty;
-static int tty_sigs_disabled = 0;
-
-int
-_rl_disable_tty_signals ()
-{
-  if (tty_sigs_disabled)
-    return 0;
-
-  if (_get_tty_settings (fileno (rl_instream), &sigstty) < 0)
-    return -1;
-
-  nosigstty = sigstty;
-
-  nosigstty.c_lflag &= ~ISIG;
-
-  if (_set_tty_settings (fileno (rl_instream), &nosigstty) < 0)
-    return (_set_tty_settings (fileno (rl_instream), &sigstty));
-
-  tty_sigs_disabled = 1;
-  return 0;
-}
-
-int
-_rl_restore_tty_signals ()
-{
-  if (tty_sigs_disabled == 0)
-    return 0;
-
-  return (_set_tty_settings (fileno (rl_instream), &sigstty));
-}
-#endif /* !NEW_TTY_DRIVER */
-
-#endif /* HANDLE_SIGNALS */
diff --git a/readline/rltty.h b/readline/rltty.h
deleted file mode 100644
--- a/readline/rltty.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/* rltty.h - tty driver-related definitions used by some library files. */
-
-/* Copyright (C) 1995 Free Software Foundation, Inc.
-
-   This file contains the Readline Library (the Library), a set of
-   routines for providing Emacs style line input to programs that ask
-   for it.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_RLTTY_H_)
-#define _RLTTY_H_
-
-/* Posix systems use termios and the Posix signal functions. */
-#if defined (TERMIOS_TTY_DRIVER)
-#  include <termios.h>
-#endif /* TERMIOS_TTY_DRIVER */
-
-/* System V machines use termio. */
-#if defined (TERMIO_TTY_DRIVER)
-#  include <termio.h>
-#  if !defined (TCOON)
-#    define TCOON 1
-#  endif
-#endif /* TERMIO_TTY_DRIVER */
-
-/* Other (BSD) machines use sgtty. */
-#if defined (NEW_TTY_DRIVER)
-#  include <sgtty.h>
-#endif
-
-#include "rlwinsize.h"
-
-/* Define _POSIX_VDISABLE if we are not using the `new' tty driver and
-   it is not already defined.  It is used both to determine if a
-   special character is disabled and to disable certain special
-   characters.  Posix systems should set to 0, USG systems to -1. */
-#if !defined (NEW_TTY_DRIVER) && !defined (_POSIX_VDISABLE)
-#  if defined (_SVR4_VDISABLE)
-#    define _POSIX_VDISABLE _SVR4_VDISABLE
-#  else
-#    if defined (_POSIX_VERSION)
-#      define _POSIX_VDISABLE 0
-#    else /* !_POSIX_VERSION */
-#      define _POSIX_VDISABLE -1
-#    endif /* !_POSIX_VERSION */
-#  endif /* !_SVR4_DISABLE */
-#endif /* !NEW_TTY_DRIVER && !_POSIX_VDISABLE */
-
-typedef struct _rl_tty_chars {
-  char t_eof;
-  char t_eol;
-  char t_eol2;
-  char t_erase;
-  char t_werase;
-  char t_kill;
-  char t_reprint;
-  char t_intr;
-  char t_quit;
-  char t_susp;
-  char t_dsusp;
-  char t_start;
-  char t_stop;
-  char t_lnext;
-  char t_flush;
-  char t_status;
-} _RL_TTY_CHARS;
-
-#endif /* _RLTTY_H_ */
diff --git a/readline/rltypedefs.h b/readline/rltypedefs.h
deleted file mode 100644
--- a/readline/rltypedefs.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/* rltypedefs.h -- Type declarations for readline functions. */
-
-/* Copyright (C) 2000 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#ifndef _RL_TYPEDEFS_H_
-#define _RL_TYPEDEFS_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Old-style */
-
-#if !defined (_FUNCTION_DEF)
-#  define _FUNCTION_DEF
-
-typedef int Function ();
-typedef void VFunction ();
-typedef char *CPFunction ();
-typedef char **CPPFunction ();
-
-#endif /* _FUNCTION_DEF */
-
-/* New style. */
-
-#if !defined (_RL_FUNCTION_TYPEDEF)
-#  define _RL_FUNCTION_TYPEDEF
-
-/* Bindable functions */
-typedef int rl_command_func_t __P((int, int));
-
-/* Typedefs for the completion system */
-typedef char *rl_compentry_func_t __P((const char *, int));
-typedef char **rl_completion_func_t __P((const char *, int, int));
-
-typedef char *rl_quote_func_t __P((char *, int, char *));
-typedef char *rl_dequote_func_t __P((char *, int));
-
-typedef int rl_compignore_func_t __P((char **));
-
-typedef void rl_compdisp_func_t __P((char **, int, int));
-
-/* Type for input and pre-read hook functions like rl_event_hook */
-typedef int rl_hook_func_t __P((void));
-
-/* Input function type */
-typedef int rl_getc_func_t __P((FILE *));
-
-/* Generic function that takes a character buffer (which could be the readline
-   line buffer) and an index into it (which could be rl_point) and returns
-   an int. */
-typedef int rl_linebuf_func_t __P((char *, int));
-
-/* `Generic' function pointer typedefs */
-typedef int rl_intfunc_t __P((int));
-#define rl_ivoidfunc_t rl_hook_func_t
-typedef int rl_icpfunc_t __P((char *));
-typedef int rl_icppfunc_t __P((char **));
-
-typedef void rl_voidfunc_t __P((void));
-typedef void rl_vintfunc_t __P((int));
-typedef void rl_vcpfunc_t __P((char *));
-typedef void rl_vcppfunc_t __P((char **));
-#endif /* _RL_FUNCTION_TYPEDEF */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _RL_TYPEDEFS_H_ */
diff --git a/readline/rlwinsize.h b/readline/rlwinsize.h
deleted file mode 100644
--- a/readline/rlwinsize.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* rlwinsize.h -- an attempt to isolate some of the system-specific defines
-   for `struct winsize' and TIOCGWINSZ. */
-
-/* Copyright (C) 1997 Free Software Foundation, Inc.
-
-   This file contains the Readline Library (the Library), a set of
-   routines for providing Emacs style line input to programs that ask
-   for it.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_RLWINSIZE_H_)
-#define _RLWINSIZE_H_
-
-#if defined (HAVE_CONFIG_H)
-#  include "config.h"
-#endif
-
-/* Try to find the definitions of `struct winsize' and TIOGCWINSZ */
-
-#if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
-#  include <sys/ioctl.h>
-#endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */
-
-#if defined (STRUCT_WINSIZE_IN_TERMIOS) && !defined (STRUCT_WINSIZE_IN_SYS_IOCTL)
-#  include <termios.h>
-#endif /* STRUCT_WINSIZE_IN_TERMIOS && !STRUCT_WINSIZE_IN_SYS_IOCTL */
-
-/* Not in either of the standard places, look around. */
-#if !defined (STRUCT_WINSIZE_IN_TERMIOS) && !defined (STRUCT_WINSIZE_IN_SYS_IOCTL)
-#  if defined (HAVE_SYS_STREAM_H)
-#    include <sys/stream.h>
-#  endif /* HAVE_SYS_STREAM_H */
-#  if defined (HAVE_SYS_PTEM_H) /* SVR4.2, at least, has it here */
-#    include <sys/ptem.h>
-#    define _IO_PTEM_H          /* work around SVR4.2 1.1.4 bug */
-#  endif /* HAVE_SYS_PTEM_H */
-#  if defined (HAVE_SYS_PTE_H)  /* ??? */
-#    include <sys/pte.h>
-#  endif /* HAVE_SYS_PTE_H */
-#endif /* !STRUCT_WINSIZE_IN_TERMIOS && !STRUCT_WINSIZE_IN_SYS_IOCTL */
-
-#endif /* _RL_WINSIZE_H */
-
diff --git a/readline/savestring.c b/readline/savestring.c
deleted file mode 100644
--- a/readline/savestring.c
+++ /dev/null
@@ -1,33 +0,0 @@
-/* savestring.c  */
-
-/* Copyright (C) 1998 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-extern char *strcpy ();
-extern char *xmalloc ();
-
-/* Backwards compatibility, now that savestring has been removed from
-   all `public' readline header files. */
-char *
-savestring (s)
-     const char *s;
-{
-  return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
-}
diff --git a/readline/search.c b/readline/search.c
deleted file mode 100644
--- a/readline/search.c
+++ /dev/null
@@ -1,439 +0,0 @@
-/* search.c - code for non-incremental searching in emacs and vi modes. */
-
-/* Copyright (C) 1992 Free Software Foundation, Inc.
-
-   This file is part of the Readline Library (the Library), a set of
-   routines for providing Emacs style line input to programs that ask
-   for it.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-#include <stdio.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif
-
-#include "rldefs.h"
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-#include "xmalloc.h"
-
-#ifdef abs
-#  undef abs
-#endif
-#define abs(x)		(((x) >= 0) ? (x) : -(x))
-
-extern HIST_ENTRY *_rl_saved_line_for_history;
-
-/* Functions imported from the rest of the library. */
-extern int _rl_free_history_entry __P((HIST_ENTRY *));
-
-static char *noninc_search_string = (char *) NULL;
-static int noninc_history_pos;
-
-static char *prev_line_found = (char *) NULL;
-
-static int rl_history_search_len;
-static int rl_history_search_pos;
-static char *history_search_string;
-static int history_string_size;
-
-/* Make the data from the history entry ENTRY be the contents of the
-   current line.  This doesn't do anything with rl_point; the caller
-   must set it. */
-static void
-make_history_line_current (entry)
-     HIST_ENTRY *entry;
-{
-  int line_len;
-
-  line_len = strlen (entry->line);
-  if (line_len >= rl_line_buffer_len)
-    rl_extend_line_buffer (line_len);
-  strcpy (rl_line_buffer, entry->line);
-
-  rl_undo_list = (UNDO_LIST *)entry->data;
-  rl_end = line_len;
-
-  if (_rl_saved_line_for_history)
-    _rl_free_history_entry (_rl_saved_line_for_history);
-  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
-}
-
-/* Search the history list for STRING starting at absolute history position
-   POS.  If STRING begins with `^', the search must match STRING at the
-   beginning of a history line, otherwise a full substring match is performed
-   for STRING.  DIR < 0 means to search backwards through the history list,
-   DIR >= 0 means to search forward. */
-static int
-noninc_search_from_pos (string, pos, dir)
-     char *string;
-     int pos, dir;
-{
-  int ret, old;
-
-  if (pos < 0)
-    return -1;
-
-  old = where_history ();
-  if (history_set_pos (pos) == 0)
-    return -1;
-
-  RL_SETSTATE(RL_STATE_SEARCH);
-  if (*string == '^')
-    ret = history_search_prefix (string + 1, dir);
-  else
-    ret = history_search (string, dir);
-  RL_UNSETSTATE(RL_STATE_SEARCH);
-
-  if (ret != -1)
-    ret = where_history ();
-
-  history_set_pos (old);
-  return (ret);
-}
-
-/* Search for a line in the history containing STRING.  If DIR is < 0, the
-   search is backwards through previous entries, else through subsequent
-   entries. */
-static void
-noninc_dosearch (string, dir)
-     char *string;
-     int dir;
-{
-  int oldpos, pos;
-  HIST_ENTRY *entry;
-
-  if (string == 0 || *string == '\0' || noninc_history_pos < 0)
-    {
-      rl_ding ();
-      return;
-    }
-
-  pos = noninc_search_from_pos (string, noninc_history_pos + dir, dir);
-  if (pos == -1)
-    {
-      /* Search failed, current history position unchanged. */
-      rl_maybe_unsave_line ();
-      rl_clear_message ();
-      rl_point = 0;
-      rl_ding ();
-      return;
-    }
-
-  noninc_history_pos = pos;
-
-  oldpos = where_history ();
-  history_set_pos (noninc_history_pos);
-  entry = current_history ();
-#if defined (VI_MODE)
-  if (rl_editing_mode != vi_mode)
-#endif
-  history_set_pos (oldpos);
-
-  make_history_line_current (entry);
-
-  rl_point = 0;
-  rl_clear_message ();
-}
-
-/* Search non-interactively through the history list.  DIR < 0 means to
-   search backwards through the history of previous commands; otherwise
-   the search is for commands subsequent to the current position in the
-   history list.  PCHAR is the character to use for prompting when reading
-   the search string; if not specified (0), it defaults to `:'. */
-static void
-noninc_search (dir, pchar)
-     int dir;
-     int pchar;
-{
-  int saved_point, c;
-  char *p;
-
-  rl_maybe_save_line ();
-  saved_point = rl_point;
-
-  /* Use the line buffer to read the search string. */
-  rl_line_buffer[0] = 0;
-  rl_end = rl_point = 0;
-
-  p = _rl_make_prompt_for_search (pchar ? pchar : ':');
-  rl_message (p, 0, 0);
-  free (p);
-
-#define SEARCH_RETURN rl_restore_prompt (); RL_UNSETSTATE(RL_STATE_NSEARCH); return
-
-  RL_SETSTATE(RL_STATE_NSEARCH);
-  /* Read the search string. */
-  while (1)
-    {
-      RL_SETSTATE(RL_STATE_MOREINPUT);
-      c = rl_read_key ();
-      RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-      if (c == 0)
-	break;
-
-      switch (c)
-	{
-	case CTRL('H'):
-	case RUBOUT:
-	  if (rl_point == 0)
-	    {
-	      rl_maybe_unsave_line ();
-	      rl_clear_message ();
-	      rl_point = saved_point;
-	      SEARCH_RETURN;
-	    }
-	  rl_rubout (1, c);
-	  break;
-
-	case CTRL('W'):
-	  rl_unix_word_rubout (1, c);
-	  break;
-
-	case CTRL('U'):
-	  rl_unix_line_discard (1, c);
-	  break;
-
-	case RETURN:
-	case NEWLINE:
-	  goto dosearch;
-	  /* NOTREACHED */
-	  break;
-
-	case CTRL('C'):
-	case CTRL('G'):
-	  rl_maybe_unsave_line ();
-	  rl_clear_message ();
-	  rl_point = saved_point;
-	  rl_ding ();
-	  SEARCH_RETURN;
-
-	default:
-	  rl_insert (1, c);
-	  break;
-	}
-      (*rl_redisplay_function) ();
-    }
-
- dosearch:
-  /* If rl_point == 0, we want to re-use the previous search string and
-     start from the saved history position.  If there's no previous search
-     string, punt. */
-  if (rl_point == 0)
-    {
-      if (!noninc_search_string)
-	{
-	  rl_ding ();
-	  SEARCH_RETURN;
-	}
-    }
-  else
-    {
-      /* We want to start the search from the current history position. */
-      noninc_history_pos = where_history ();
-      FREE (noninc_search_string);
-      noninc_search_string = savestring (rl_line_buffer);
-    }
-
-  rl_restore_prompt ();
-  noninc_dosearch (noninc_search_string, dir);
-  RL_UNSETSTATE(RL_STATE_NSEARCH);
-}
-
-/* Search forward through the history list for a string.  If the vi-mode
-   code calls this, KEY will be `?'. */
-int
-rl_noninc_forward_search (count, key)
-     int count, key;
-{
-  noninc_search (1, (key == '?') ? '?' : 0);
-  return 0;
-}
-
-/* Reverse search the history list for a string.  If the vi-mode code
-   calls this, KEY will be `/'. */
-int
-rl_noninc_reverse_search (count, key)
-     int count, key;
-{
-  noninc_search (-1, (key == '/') ? '/' : 0);
-  return 0;
-}
-
-/* Search forward through the history list for the last string searched
-   for.  If there is no saved search string, abort. */
-int
-rl_noninc_forward_search_again (count, key)
-     int count, key;
-{
-  if (!noninc_search_string)
-    {
-      rl_ding ();
-      return (-1);
-    }
-  noninc_dosearch (noninc_search_string, 1);
-  return 0;
-}
-
-/* Reverse search in the history list for the last string searched
-   for.  If there is no saved search string, abort. */
-int
-rl_noninc_reverse_search_again (count, key)
-     int count, key;
-{
-  if (!noninc_search_string)
-    {
-      rl_ding ();
-      return (-1);
-    }
-  noninc_dosearch (noninc_search_string, -1);
-  return 0;
-}
-
-static int
-rl_history_search_internal (count, dir)
-     int count, dir;
-{
-  HIST_ENTRY *temp;
-  int ret, oldpos;
-
-  rl_maybe_save_line ();
-  temp = (HIST_ENTRY *)NULL;
-
-  /* Search COUNT times through the history for a line whose prefix
-     matches history_search_string.  When this loop finishes, TEMP,
-     if non-null, is the history line to copy into the line buffer. */
-  while (count)
-    {
-      ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir);
-      if (ret == -1)
-	break;
-
-      /* Get the history entry we found. */
-      rl_history_search_pos = ret;
-      oldpos = where_history ();
-      history_set_pos (rl_history_search_pos);
-      temp = current_history ();
-      history_set_pos (oldpos);
-
-      /* Don't find multiple instances of the same line. */
-      if (prev_line_found && STREQ (prev_line_found, temp->line))
-        continue;
-      prev_line_found = temp->line;
-      count--;
-    }
-
-  /* If we didn't find anything at all, return. */
-  if (temp == 0)
-    {
-      rl_maybe_unsave_line ();
-      rl_ding ();
-      /* If you don't want the saved history line (last match) to show up
-         in the line buffer after the search fails, change the #if 0 to
-         #if 1 */
-#if 0
-      if (rl_point > rl_history_search_len)
-        {
-          rl_point = rl_end = rl_history_search_len;
-          rl_line_buffer[rl_end] = '\0';
-        }
-#else
-      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
-#endif
-      return 1;
-    }
-
-  /* Copy the line we found into the current line buffer. */
-  make_history_line_current (temp);
-
-  rl_point = rl_history_search_len;
-  return 0;
-}
-
-static void
-rl_history_search_reinit ()
-{
-  rl_history_search_pos = where_history ();
-  rl_history_search_len = rl_point;
-  prev_line_found = (char *)NULL;
-  if (rl_point)
-    {
-      if (rl_history_search_len >= history_string_size - 2)
-	{
-	  history_string_size = rl_history_search_len + 2;
-	  history_search_string = xrealloc (history_search_string, history_string_size);
-	}
-      history_search_string[0] = '^';
-      strncpy (history_search_string + 1, rl_line_buffer, rl_point);
-      history_search_string[rl_point + 1] = '\0';
-    }
-  _rl_free_saved_history_line ();
-}
-
-/* Search forward in the history for the string of characters
-   from the start of the line to rl_point.  This is a non-incremental
-   search. */
-int
-rl_history_search_forward (count, ignore)
-     int count, ignore;
-{
-  if (count == 0)
-    return (0);
-
-  if (rl_last_func != rl_history_search_forward &&
-      rl_last_func != rl_history_search_backward)
-    rl_history_search_reinit ();
-
-  if (rl_history_search_len == 0)
-    return (rl_get_next_history (count, ignore));
-  return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));
-}
-
-/* Search backward through the history for the string of characters
-   from the start of the line to rl_point.  This is a non-incremental
-   search. */
-int
-rl_history_search_backward (count, ignore)
-     int count, ignore;
-{
-  if (count == 0)
-    return (0);
-
-  if (rl_last_func != rl_history_search_forward &&
-      rl_last_func != rl_history_search_backward)
-    rl_history_search_reinit ();
-
-  if (rl_history_search_len == 0)
-    return (rl_get_previous_history (count, ignore));
-  return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));
-}
diff --git a/readline/shell.c b/readline/shell.c
deleted file mode 100644
--- a/readline/shell.c
+++ /dev/null
@@ -1,176 +0,0 @@
-/* shell.c -- readline utility functions that are normally provided by
-	      bash when readline is linked as part of the shell. */
-
-/* Copyright (C) 1997 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#if defined (HAVE_STRING_H)
-#  include <string.h>
-#else
-#  include <strings.h>
-#endif /* !HAVE_STRING_H */
-
-#include <fcntl.h>
-#include <pwd.h>
-
-#include <stdio.h>
-
-#include "rlstdc.h"
-#include "rlshell.h"
-#include "xmalloc.h"
-
-#if !defined (HAVE_GETPW_DECLS)
-extern struct passwd *getpwuid __P((uid_t));
-#endif /* !HAVE_GETPW_DECLS */
-
-#ifndef NULL
-#  define NULL 0
-#endif
-
-/* All of these functions are resolved from bash if we are linking readline
-   as part of bash. */
-
-/* Does shell-like quoting using single quotes. */
-char *
-sh_single_quote (string)
-     char *string;
-{
-  register int c;
-  char *result, *r, *s;
-
-  result = (char *)xmalloc (3 + (4 * strlen (string)));
-  r = result;
-  *r++ = '\'';
-
-  for (s = string; s && (c = *s); s++)
-    {
-      *r++ = c;
-
-      if (c == '\'')
-	{
-	  *r++ = '\\';	/* insert escaped single quote */
-	  *r++ = '\'';
-	  *r++ = '\'';	/* start new quoted string */
-	}
-    }
-
-  *r++ = '\'';
-  *r = '\0';
-
-  return (result);
-}
-
-/* Set the environment variables LINES and COLUMNS to lines and cols,
-   respectively. */
-void
-sh_set_lines_and_columns (lines, cols)
-     int lines, cols;
-{
-  char *b;
-
-#if defined (HAVE_PUTENV)
-  b = xmalloc (24);
-  sprintf (b, "LINES=%d", lines);
-  putenv (b);
-  b = xmalloc (24);
-  sprintf (b, "COLUMNS=%d", cols);
-  putenv (b);
-#else /* !HAVE_PUTENV */
-#  if defined (HAVE_SETENV)
-  b = xmalloc (8);
-  sprintf (b, "%d", lines);
-  setenv ("LINES", b, 1);
-  b = xmalloc (8);
-  sprintf (b, "%d", cols);
-  setenv ("COLUMNS", b, 1);
-#  endif /* HAVE_SETENV */
-#endif /* !HAVE_PUTENV */
-}
-
-char *
-sh_get_env_value (varname)
-     const char *varname;
-{
-  return ((char *)getenv (varname));
-}
-
-char *
-sh_get_home_dir ()
-{
-  char *home_dir;
-  struct passwd *entry;
-
-  home_dir = (char *)NULL;
-  entry = getpwuid (getuid ());
-  if (entry)
-    home_dir = entry->pw_dir;
-  return (home_dir);
-}
-
-#if !defined (O_NDELAY)
-#  if defined (FNDELAY)
-#    define O_NDELAY FNDELAY
-#  endif
-#endif
-
-int
-sh_unset_nodelay_mode (fd)
-     int fd;
-{
-  int flags, bflags;
-
-  if ((flags = fcntl (fd, F_GETFL, 0)) < 0)
-    return -1;
-
-  bflags = 0;
-
-#ifdef O_NONBLOCK
-  bflags |= O_NONBLOCK;
-#endif
-
-#ifdef O_NDELAY
-  bflags |= O_NDELAY;
-#endif
-
-  if (flags & bflags)
-    {
-      flags &= ~bflags;
-      return (fcntl (fd, F_SETFL, flags));
-    }
-
-  return 0;
-}
diff --git a/readline/shlib/Makefile.in b/readline/shlib/Makefile.in
deleted file mode 100644
--- a/readline/shlib/Makefile.in
+++ /dev/null
@@ -1,390 +0,0 @@
-## -*- text -*- ##
-# Makefile for the GNU readline library shared library support.
-#
-# Copyright (C) 1998 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-RL_LIBRARY_VERSION = @LIBVERSION@
-RL_LIBRARY_NAME = readline
-
-srcdir = @srcdir@
-VPATH = .:@top_srcdir@
-topdir = @top_srcdir@
-BUILD_DIR = @BUILD_DIR@
-
-INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
-
-CC = @CC@
-RANLIB = @RANLIB@
-AR = @AR@
-ARFLAGS = @ARFLAGS@
-RM = rm -f
-CP = cp
-MV = mv
-LN = ln
-
-SHELL = @MAKE_SHELL@
-
-host_os = @host_os@
-
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-includedir = @includedir@
-libdir = @libdir@
-
-CFLAGS = @CFLAGS@
-LOCAL_CFLAGS = @LOCAL_CFLAGS@ -DRL_LIBRARY_VERSION='"$(RL_LIBRARY_VERSION)"'
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@ @LOCAL_LDFLAGS@ @CFLAGS@
-
-DEFS = @DEFS@
-LOCAL_DEFS = @LOCAL_DEFS@
-
-#
-# These values are generated for configure by ${topdir}/support/shobj-conf.
-# If your system is not supported by that script, but includes facilities for
-# dynamic loading of shared objects, please update the script and send the
-# changes to bash-maintainers@gnu.org.
-#
-SHOBJ_CC = @SHOBJ_CC@
-SHOBJ_CFLAGS = @SHOBJ_CFLAGS@
-SHOBJ_LD = @SHOBJ_LD@
-
-SHOBJ_LDFLAGS = @SHOBJ_LDFLAGS@
-SHOBJ_XLDFLAGS = @SHOBJ_XLDFLAGS@
-SHOBJ_LIBS = @SHOBJ_LIBS@
-
-SHLIB_XLDFLAGS = @SHLIB_XLDFLAGS@
-SHLIB_LIBS = @SHLIB_LIBS@
-SHLIB_LIBSUFF = @SHLIB_LIBSUFF@
-
-SHLIB_LIBVERSION = @SHLIB_LIBVERSION@
-
-SHLIB_STATUS = @SHLIB_STATUS@
-
-# shared library versioning
-SHLIB_MAJOR=		@SHLIB_MAJOR@
-# shared library systems like SVR4's do not use minor versions
-SHLIB_MINOR=		.@SHLIB_MINOR@
-
-# For libraries which include headers from other libraries.
-INCLUDES = -I. -I.. -I$(topdir) -I$(includedir)
-
-CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES) $(LOCAL_CFLAGS) $(CFLAGS)
-
-.SUFFIXES:	.so
-
-.c.so:
-	${RM} $@
-	$(SHOBJ_CC) -c $(CCFLAGS) $(SHOBJ_CFLAGS) -o $*.o $< 
-	$(MV) $*.o $@
-
-# The name of the main library target.
-
-SHARED_READLINE = libreadline.$(SHLIB_LIBVERSION)
-SHARED_HISTORY = libhistory.$(SHLIB_LIBVERSION)
-SHARED_LIBS = $(SHARED_READLINE) $(SHARED_HISTORY)
-
-# The C code source files for this library.
-CSOURCES = $(topdir)/readline.c $(topdir)/funmap.c $(topdir)/keymaps.c \
-	   $(topdir)/vi_mode.c $(topdir)/parens.c $(topdir)/rltty.c \
-	   $(topdir)/complete.c $(topdir)/bind.c $(topdir)/isearch.c \
-	   $(topdir)/display.c $(topdir)/signals.c $(topdir)/emacs_keymap.c \
-	   $(topdir)/vi_keymap.c $(topdir)/util.c $(topdir)/kill.c \
-	   $(topdir)/undo.c $(topdir)/macro.c $(topdir)/input.c \
-	   $(topdir)/callback.c $(topdir)/terminal.c $(topdir)/xmalloc.c \
-	   $(topdir)/history.c $(topdir)/histsearch.c $(topdir)/histexpand.c \
-	   $(topdir)/histfile.c $(topdir)/nls.c $(topdir)/search.c \
-	   $(topdir)/shell.c $(topdir)/savestring.c $(topdir)/compat.c \
-	   $(topdir)/tilde.c
-
-# The header files for this library.
-HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
-	   posixstat.h posixdir.h posixjmp.h tilde.h rlconf.h rltty.h \
-	   ansi_stdlib.h tcap.h xmalloc.h rlprivate.h rlshell.h
-
-SHARED_HISTOBJ = history.so histexpand.so histfile.so histsearch.so shell.so
-SHARED_TILDEOBJ = tilde.so
-SHARED_OBJ = readline.so vi_mode.so funmap.so keymaps.so parens.so search.so \
-	  rltty.so complete.so bind.so isearch.so display.so signals.so \
-	  util.so kill.so undo.so macro.so input.so callback.so terminal.so \
-	  nls.so xmalloc.so $(SHARED_HISTOBJ) $(SHARED_TILDEOBJ) compat.so
-
-##########################################################################
-
-all: $(SHLIB_STATUS)
-
-supported: $(SHARED_LIBS)
-
-unsupported:
-	@echo "Your system and compiler (${host_os}-${CC}) are not supported by the"
-	@echo "${topdir}/support/shobj-conf script."
-	@echo "If your operating system provides facilities for creating"
-	@echo "shared libraries, please update the script and re-run configure."
-	@echo "Please send the changes you made to bash-maintainers@gnu.org"
-	@echo "for inclusion in future bash and readline releases."
-
-$(SHARED_READLINE):	$(SHARED_OBJ)
-	$(RM) $@
-	$(SHOBJ_LD) ${SHOBJ_LDFLAGS} ${SHLIB_XLDFLAGS} -o $@ $(SHARED_OBJ) $(SHLIB_LIBS)
-
-$(SHARED_HISTORY):	$(SHARED_HISTOBJ) xmalloc.so
-	$(RM) $@
-	$(SHOBJ_LD) ${SHOBJ_LDFLAGS} ${SHLIB_XLDFLAGS} -o $@ $(SHARED_HISTOBJ) xmalloc.so $(SHLIB_LIBS)
-
-installdirs: $(topdir)/support/mkdirs
-	-$(SHELL) $(topdir)/support/mkdirs $(libdir)
-
-install: installdirs $(SHLIB_STATUS)
-	$(SHELL) $(topdir)/support/shlib-install -O $(host_os) -d $(libdir) -i "$(INSTALL_DATA)" $(SHARED_HISTORY)
-	$(SHELL) $(topdir)/support/shlib-install -O $(host_os) -d $(libdir) -i "$(INSTALL_DATA)" $(SHARED_READLINE)
-	@echo install: you may need to run ldconfig
-
-uninstall:
-	$(SHELL) $(topdir)/support/shlib-install -O $(host_os) -d $(libdir) -U $(SHARED_HISTORY)
-	$(SHELL) $(topdir)/support/shlib-install -O $(host_os) -d $(libdir) -U $(SHARED_READLINE)
-	@echo uninstall: you may need to run ldconfig
-
-clean mostlyclean:	force
-	$(RM) $(SHARED_OBJ) $(SHARED_LIBS)
-
-distclean maintainer-clean: clean
-	$(RM) Makefile
-
-force:
-
-# Tell versions [3.59,3.63) of GNU make not to export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
-
-# Dependencies
-bind.so: $(topdir)/ansi_stdlib.h $(topdir)/posixstat.h
-bind.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-bind.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-bind.so: $(topdir)/rltypedefs.h
-bind.so: $(topdir)/tilde.h $(topdir)/history.h
-compat.so: $(topdir)/rlstdc.h
-callback.so: $(topdir)/rlconf.h
-callback.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h
-callback.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-callback.so: $(topdir)/rltypedefs.h
-callback.so: $(topdir)/tilde.h
-complete.so: $(topdir)/ansi_stdlib.h posixdir.h $(topdir)/posixstat.h
-complete.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-complete.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-complete.so: $(topdir)/rltypedefs.h
-complete.so: $(topdir)/tilde.h
-display.so: $(topdir)/ansi_stdlib.h $(topdir)/posixstat.h
-display.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-display.so: $(topdir)/tcap.h
-display.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-display.so: $(topdir)/rltypedefs.h
-display.so: $(topdir)/tilde.h $(topdir)/history.h
-funmap.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-funmap.so: $(topdir)/rltypedefs.h
-funmap.so: $(topdir)/rlconf.h $(topdir)/ansi_stdlib.h
-funmap.so: ${BUILD_DIR}/config.h $(topdir)/tilde.h
-histexpand.so: $(topdir)/ansi_stdlib.h
-histexpand.so: $(topdir)/history.h $(topdir)/histlib.h $(topdir)/rltypedefs.h
-histexpand.so: ${BUILD_DIR}/config.h
-histfile.so: $(topdir)/ansi_stdlib.h
-histfile.so: $(topdir)/history.h $(topdir)/histlib.h $(topdir)/rltypedefs.h
-histfile.so: ${BUILD_DIR}/config.h
-history.so: $(topdir)/ansi_stdlib.h
-history.so: $(topdir)/history.h $(topdir)/histlib.h $(topdir)/rltypedefs.h
-history.so: ${BUILD_DIR}/config.h
-histsearch.so: $(topdir)/ansi_stdlib.h
-histsearch.so: $(topdir)/history.h $(topdir)/histlib.h $(topdir)/rltypedefs.h
-histsearch.so: ${BUILD_DIR}/config.h
-input.so: $(topdir)/ansi_stdlib.h
-input.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-input.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-input.so: $(topdir)/rltypedefs.h
-input.so: $(topdir)/tilde.h
-isearch.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-isearch.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-isearch.so: $(topdir)/rltypedefs.h
-isearch.so: $(topdir)/ansi_stdlib.h $(topdir)/history.h $(topdir)/tilde.h
-keymaps.so: emacs_keymap.c vi_keymap.c
-keymaps.so: $(topdir)/keymaps.h $(topdir)/chardefs.h $(topdir)/rlconf.h
-keymaps.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-keymaps.so: $(topdir)/rltypedefs.h
-keymaps.so: ${BUILD_DIR}/config.h $(topdir)/ansi_stdlib.h $(topdir)/tilde.h
-kill.so: $(topdir)/ansi_stdlib.h
-kill.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-kill.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-kill.so: $(topdir)/tilde.h $(topdir)/history.h  $(topdir)/rltypedefs.h
-macro.so: $(topdir)/ansi_stdlib.h
-macro.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-macro.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-macro.so: $(topdir)/tilde.h $(topdir)/history.h $(topdir)/rltypedefs.h
-nls.so: $(topdir)/ansi_stdlib.h
-nls.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-nls.o: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-nls.o: $(topdir)/rltypedefs.h
-nls.o: $(topdir)/tilde.h $(topdir)/history.h $(topdir)/rlstdc.h  
-parens.so: $(topdir)/rlconf.h ${BUILD_DIR}/config.h
-parens.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-parens.so: $(topdir)/rltypedefs.h
-parens.so: $(topdir)/tilde.h
-readline.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-readline.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-readline.so: $(topdir)/rltypedefs.h
-readline.so: $(topdir)/history.h $(topdir)/tilde.h
-readline.so: $(topdir)/posixstat.h $(topdir)/ansi_stdlib.h $(topdir)/posixjmp.h
-rltty.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-rltty.so: $(topdir)/rltty.h $(topdir)/tilde.h
-rltty.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-rltty.so: $(topdir)/rltypedefs.h
-search.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-search.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-search.so: $(topdir)/ansi_stdlib.h $(topdir)/history.h $(topdir)/tilde.h
-search.so: $(topdir)/rltypedefs.h
-signals.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-signals.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-signals.so: $(topdir)/history.h $(topdir)/tilde.h
-signals.so: $(topdir)/rltypedefs.h
-terminal.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-terminal.so: $(topdir)/tcap.h
-terminal.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-terminal.so: $(topdir)/tilde.h $(topdir)/history.h
-terminal.so: $(topdir)/rltypedefs.h
-tilde.so: $(topdir)/ansi_stdlib.h ${BUILD_DIR}/config.h $(topdir)/tilde.h
-undo.so: $(topdir)/ansi_stdlib.h
-undo.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-undo.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-undo.so: $(topdir)/rltypedefs.h
-undo.so: $(topdir)/tilde.h $(topdir)/history.h
-util.so: $(topdir)/posixjmp.h $(topdir)/ansi_stdlib.h
-util.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-util.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-util.so: $(topdir)/rltypedefs.h $(topdir)/tilde.h
-vi_mode.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
-vi_mode.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-vi_mode.so: $(topdir)/history.h $(topdir)/ansi_stdlib.h $(topdir)/tilde.h
-vi_mode.so: $(topdir)/rltypedefs.h
-xmalloc.so: ${BUILD_DIR}/config.h
-xmalloc.so: $(topdir)/ansi_stdlib.h
-
-bind.so: $(topdir)/rlshell.h
-histfile.so: $(topdir)/rlshell.h
-nls.so: $(topdir)/rlshell.h
-readline.so: $(topdir)/rlshell.h
-shell.so: $(topdir)/rlshell.h
-terminal.so: $(topdir)/rlshell.h
-histexpand.so: $(topdir)/rlshell.h
-
-bind.so: $(topdir)/rlprivate.h
-callback.so: $(topdir)/rlprivate.h
-complete.so: $(topdir)/rlprivate.h
-display.so: $(topdir)/rlprivate.h
-input.so: $(topdir)/rlprivate.h
-isearch.so: $(topdir)/rlprivate.h
-kill.so: $(topdir)/rlprivate.h
-macro.so: $(topdir)/rlprivate.h
-nls.so: $(topdir)/rlprivate.h   
-parens.so: $(topdir)/rlprivate.h
-readline.so: $(topdir)/rlprivate.h
-rltty.so: $(topdir)/rlprivate.h 
-search.so: $(topdir)/rlprivate.h
-signals.so: $(topdir)/rlprivate.h
-terminal.so: $(topdir)/rlprivate.h
-undo.so: $(topdir)/rlprivate.h
-util.so: $(topdir)/rlprivate.h
-vi_mode.so: $(topdir)/rlprivate.h
-
-bind.so: $(topdir)/xmalloc.h
-complete.so: $(topdir)/xmalloc.h
-display.so: $(topdir)/xmalloc.h
-funmap.so: $(topdir)/xmalloc.h
-histexpand.so: $(topdir)/xmalloc.h
-histfile.so: $(topdir)/xmalloc.h
-history.so: $(topdir)/xmalloc.h
-input.so: $(topdir)/xmalloc.h
-isearch.so: $(topdir)/xmalloc.h
-keymaps.so: $(topdir)/xmalloc.h
-kill.so: $(topdir)/xmalloc.h
-macro.so: $(topdir)/xmalloc.h
-readline.so: $(topdir)/xmalloc.h
-savestring.so: $(topdir)/xmalloc.h
-search.so: $(topdir)/xmalloc.h
-shell.so: $(topdir)/xmalloc.h
-tilde.so: $(topdir)/xmalloc.h
-tilde.so: $(topdir)/xmalloc.h
-util.so: $(topdir)/xmalloc.h
-vi_mode.so: $(topdir)/xmalloc.h
-
-readline.so: $(topdir)/readline.c
-vi_mode.so: $(topdir)/vi_mode.c
-funmap.so: $(topdir)/funmap.c
-keymaps.so: $(topdir)/keymaps.c
-parens.so: $(topdir)/parens.c
-search.so: $(topdir)/search.c
-rltty.so: $(topdir)/rltty.c
-compat.so: $(topdir)/compat.c
-complete.so: $(topdir)/complete.c
-bind.so: $(topdir)/bind.c
-isearch.so: $(topdir)/isearch.c
-display.so: $(topdir)/display.c
-signals.so: $(topdir)/signals.c
-util.so: $(topdir)/util.c
-kill.so: $(topdir)/kill.c
-undo.so: $(topdir)/undo.c
-macro.so: $(topdir)/macro.c
-input.so: $(topdir)/input.c
-callback.so: $(topdir)/callback.c
-terminal.so: $(topdir)/terminal.c
-nls.so: $(topdir)/nls.c
-xmalloc.so: $(topdir)/xmalloc.c
-history.so: $(topdir)/history.c
-histexpand.so: $(topdir)/histexpand.c
-histfile.so: $(topdir)/histfile.c
-histsearch.so: $(topdir)/histsearch.c
-savestring.so: $(topdir)/savestring.c
-shell.so: $(topdir)/shell.c
-tilde.so: $(topdir)/tilde.c
-
-readline.so: readline.c
-vi_mode.so: vi_mode.c
-funmap.so: funmap.c
-keymaps.so: keymaps.c
-parens.so: parens.c
-search.so: search.c
-rltty.so: rltty.c
-comapt.so: compat.c
-complete.so: complete.c
-bind.so: bind.c
-isearch.so: isearch.c
-display.so: display.c
-signals.so: signals.c
-util.so: util.c
-kill.so: kill.c
-undo.so: undo.c
-macro.so: macro.c
-input.so: input.c
-callback.so: callback.c
-terminal.so: terminal.c
-nls.so: nls.c
-xmalloc.so: xmalloc.c
-history.so: history.c
-histexpand.so: histexpand.c
-histfile.so: histfile.c
-histsearch.so: histsearch.c
-savestring.so: savestring.c
-shell.so: shell.c
-tilde.so: tilde.c
diff --git a/readline/signals.c b/readline/signals.c
deleted file mode 100644
--- a/readline/signals.c
+++ /dev/null
@@ -1,397 +0,0 @@
-/* signals.c -- signal handling support for readline. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <stdio.h>		/* Just for NULL.  Yuck. */
-#include <sys/types.h>
-#include <signal.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-#if defined (GWINSZ_IN_SYS_IOCTL)
-#  include <sys/ioctl.h>
-#endif /* GWINSZ_IN_SYS_IOCTL */
-
-#if defined (HANDLE_SIGNALS)
-/* Some standard library routines. */
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-
-#if !defined (RETSIGTYPE)
-#  if defined (VOID_SIGHANDLER)
-#    define RETSIGTYPE void
-#  else
-#    define RETSIGTYPE int
-#  endif /* !VOID_SIGHANDLER */
-#endif /* !RETSIGTYPE */
-
-#if defined (VOID_SIGHANDLER)
-#  define SIGHANDLER_RETURN return
-#else
-#  define SIGHANDLER_RETURN return (0)
-#endif
-
-/* This typedef is equivalent to the one for Function; it allows us
-   to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
-typedef RETSIGTYPE SigHandler ();
-
-#if defined (HAVE_POSIX_SIGNALS)
-typedef struct sigaction sighandler_cxt;
-#  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
-#else
-typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags; } sighandler_cxt;
-#  define sigemptyset(m)
-#endif /* !HAVE_POSIX_SIGNALS */
-
-static SigHandler *rl_set_sighandler __P((int, SigHandler *, sighandler_cxt *));
-
-/* Exported variables for use by applications. */
-
-/* If non-zero, readline will install its own signal handlers for
-   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
-int rl_catch_signals = 1;
-
-/* If non-zero, readline will install a signal handler for SIGWINCH. */
-#ifdef SIGWINCH
-int rl_catch_sigwinch = 1;
-#endif
-
-static int signals_set_flag;
-static int sigwinch_set_flag;
-
-/* **************************************************************** */
-/*					        		    */
-/*			   Signal Handling                          */
-/*								    */
-/* **************************************************************** */
-
-static sighandler_cxt old_int, old_term, old_alrm, old_quit;
-#if defined (SIGTSTP)
-static sighandler_cxt old_tstp, old_ttou, old_ttin;
-#endif
-#if defined (SIGWINCH)
-static sighandler_cxt old_winch;
-#endif
-
-/* Readline signal handler functions. */
-
-static RETSIGTYPE
-rl_signal_handler (sig)
-     int sig;
-{
-#if defined (HAVE_POSIX_SIGNALS)
-  sigset_t set;
-#else /* !HAVE_POSIX_SIGNALS */
-#  if defined (HAVE_BSD_SIGNALS)
-  long omask;
-#  else /* !HAVE_BSD_SIGNALS */
-  sighandler_cxt dummy_cxt;	/* needed for rl_set_sighandler call */
-#  endif /* !HAVE_BSD_SIGNALS */
-#endif /* !HAVE_POSIX_SIGNALS */
-
-  RL_SETSTATE(RL_STATE_SIGHANDLER);
-
-#if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)
-  /* Since the signal will not be blocked while we are in the signal
-     handler, ignore it until rl_clear_signals resets the catcher. */
-  if (sig == SIGINT || sig == SIGALRM)
-    rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);
-#endif /* !HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS */
-
-  switch (sig)
-    {
-    case SIGINT:
-      rl_free_line_state ();
-      /* FALLTHROUGH */
-
-#if defined (SIGTSTP)
-    case SIGTSTP:
-    case SIGTTOU:
-    case SIGTTIN:
-#endif /* SIGTSTP */
-    case SIGALRM:
-    case SIGTERM:
-    case SIGQUIT:
-      rl_cleanup_after_signal ();
-
-#if defined (HAVE_POSIX_SIGNALS)
-      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);
-      sigdelset (&set, sig);
-#else /* !HAVE_POSIX_SIGNALS */
-#  if defined (HAVE_BSD_SIGNALS)
-      omask = sigblock (0);
-#  endif /* HAVE_BSD_SIGNALS */
-#endif /* !HAVE_POSIX_SIGNALS */
-
-#if defined (__EMX__)
-      signal (sig, SIG_ACK);
-#endif
-
-      kill (getpid (), sig);
-
-      /* Let the signal that we just sent through.  */
-#if defined (HAVE_POSIX_SIGNALS)
-      sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);
-#else /* !HAVE_POSIX_SIGNALS */
-#  if defined (HAVE_BSD_SIGNALS)
-      sigsetmask (omask & ~(sigmask (sig)));
-#  endif /* HAVE_BSD_SIGNALS */
-#endif /* !HAVE_POSIX_SIGNALS */
-
-      rl_reset_after_signal ();
-    }
-
-  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
-  SIGHANDLER_RETURN;
-}
-
-#if defined (SIGWINCH)
-static RETSIGTYPE
-rl_sigwinch_handler (sig)
-     int sig;
-{
-  SigHandler *oh;
-
-#if defined (MUST_REINSTALL_SIGHANDLERS)
-  sighandler_cxt dummy_winch;
-
-  /* We don't want to change old_winch -- it holds the state of SIGWINCH
-     disposition set by the calling application.  We need this state
-     because we call the application's SIGWINCH handler after updating
-     our own idea of the screen size. */
-  rl_set_sighandler (SIGWINCH, rl_sigwinch_handler, &dummy_winch);
-#endif
-
-  RL_SETSTATE(RL_STATE_SIGHANDLER);
-  rl_resize_terminal ();
-
-  /* If another sigwinch handler has been installed, call it. */
-  oh = (SigHandler *)old_winch.sa_handler;
-  if (oh &&  oh != (SigHandler *)SIG_IGN && oh != (SigHandler *)SIG_DFL)
-    (*oh) (sig);
-
-  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
-  SIGHANDLER_RETURN;
-}
-#endif  /* SIGWINCH */
-
-/* Functions to manage signal handling. */
-
-#if !defined (HAVE_POSIX_SIGNALS)
-static int
-rl_sigaction (sig, nh, oh)
-     int sig;
-     sighandler_cxt *nh, *oh;
-{
-  oh->sa_handler = signal (sig, nh->sa_handler);
-  return 0;
-}
-#endif /* !HAVE_POSIX_SIGNALS */
-
-/* Set up a readline-specific signal handler, saving the old signal
-   information in OHANDLER.  Return the old signal handler, like
-   signal(). */
-static SigHandler *
-rl_set_sighandler (sig, handler, ohandler)
-     int sig;
-     SigHandler *handler;
-     sighandler_cxt *ohandler;
-{
-  sighandler_cxt old_handler;
-#if defined (HAVE_POSIX_SIGNALS)
-  struct sigaction act;
-
-  act.sa_handler = handler;
-  act.sa_flags = 0;
-  sigemptyset (&act.sa_mask);
-  sigemptyset (&ohandler->sa_mask);
-  sigaction (sig, &act, &old_handler);
-#else
-  old_handler.sa_handler = (SigHandler *)signal (sig, handler);
-#endif /* !HAVE_POSIX_SIGNALS */
-
-  /* XXX -- assume we have memcpy */
-  /* If rl_set_signals is called twice in a row, don't set the old handler to
-     rl_signal_handler, because that would cause infinite recursion. */
-  if (handler != rl_signal_handler || old_handler.sa_handler != rl_signal_handler)
-    memcpy (ohandler, &old_handler, sizeof (sighandler_cxt));
-
-  return (ohandler->sa_handler);
-}
-
-static void
-rl_maybe_set_sighandler (sig, handler, ohandler)
-     int sig;
-     SigHandler *handler;
-     sighandler_cxt *ohandler;
-{
-  sighandler_cxt dummy;
-  SigHandler *oh;
-
-  sigemptyset (&dummy.sa_mask);
-  oh = rl_set_sighandler (sig, handler, ohandler);
-  if (oh == (SigHandler *)SIG_IGN)
-    rl_sigaction (sig, ohandler, &dummy);
-}
-
-int
-rl_set_signals ()
-{
-  sighandler_cxt dummy;
-  SigHandler *oh;
-
-  if (rl_catch_signals && signals_set_flag == 0)
-    {
-      rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);
-      rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
-      rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);
-
-      oh = rl_set_sighandler (SIGALRM, rl_signal_handler, &old_alrm);
-      if (oh == (SigHandler *)SIG_IGN)
-	rl_sigaction (SIGALRM, &old_alrm, &dummy);
-#if defined (HAVE_POSIX_SIGNALS) && defined (SA_RESTART)
-      /* If the application using readline has already installed a signal
-	 handler with SA_RESTART, SIGALRM will cause reads to be restarted
-	 automatically, so readline should just get out of the way.  Since
-	 we tested for SIG_IGN above, we can just test for SIG_DFL here. */
-      if (oh != (SigHandler *)SIG_DFL && (old_alrm.sa_flags & SA_RESTART))
-	rl_sigaction (SIGALRM, &old_alrm, &dummy);
-#endif /* HAVE_POSIX_SIGNALS */
-
-#if defined (SIGTSTP)
-      rl_maybe_set_sighandler (SIGTSTP, rl_signal_handler, &old_tstp);
-#endif /* SIGTSTP */
-
-#if defined (SIGTTOU)
-      rl_maybe_set_sighandler (SIGTTOU, rl_signal_handler, &old_ttou);
-#endif /* SIGTTOU */
-
-#if defined (SIGTTIN)
-      rl_maybe_set_sighandler (SIGTTIN, rl_signal_handler, &old_ttin);
-#endif /* SIGTTIN */
-
-      signals_set_flag = 1;
-    }
-
-#if defined (SIGWINCH)
-  if (rl_catch_sigwinch && sigwinch_set_flag == 0)
-    {
-      rl_maybe_set_sighandler (SIGWINCH, rl_sigwinch_handler, &old_winch);
-      sigwinch_set_flag = 1;
-    }
-#endif /* SIGWINCH */
-
-  return 0;
-}
-
-int
-rl_clear_signals ()
-{
-  sighandler_cxt dummy;
-
-  if (rl_catch_signals && signals_set_flag == 1)
-    {
-      sigemptyset (&dummy.sa_mask);
-
-      rl_sigaction (SIGINT, &old_int, &dummy);
-      rl_sigaction (SIGTERM, &old_term, &dummy);
-      rl_sigaction (SIGQUIT, &old_quit, &dummy);
-      rl_sigaction (SIGALRM, &old_alrm, &dummy);
-
-#if defined (SIGTSTP)
-      rl_sigaction (SIGTSTP, &old_tstp, &dummy);
-#endif /* SIGTSTP */
-
-#if defined (SIGTTOU)
-      rl_sigaction (SIGTTOU, &old_ttou, &dummy);
-#endif /* SIGTTOU */
-
-#if defined (SIGTTIN)
-      rl_sigaction (SIGTTIN, &old_ttin, &dummy);
-#endif /* SIGTTIN */
-
-      signals_set_flag = 0;
-    }
-
-#if defined (SIGWINCH)
-  if (rl_catch_sigwinch && sigwinch_set_flag == 1)
-    {
-      sigemptyset (&dummy.sa_mask);
-      rl_sigaction (SIGWINCH, &old_winch, &dummy);
-      sigwinch_set_flag = 0;
-    }
-#endif
-
-  return 0;
-}
-
-/* Clean up the terminal and readline state after catching a signal, before
-   resending it to the calling application. */
-void
-rl_cleanup_after_signal ()
-{
-  _rl_clean_up_for_exit ();
-  (*rl_deprep_term_function) ();
-  rl_clear_signals ();
-  rl_clear_pending_input ();
-}
-
-/* Reset the terminal and readline state after a signal handler returns. */
-void
-rl_reset_after_signal ()
-{
-  (*rl_prep_term_function) (_rl_meta_flag);
-  rl_set_signals ();
-}
-
-/* Free up the readline variable line state for the current line (undo list,
-   any partial history entry, any keyboard macros in progress, and any
-   numeric arguments in process) after catching a signal, before calling
-   rl_cleanup_after_signal(). */ 
-void
-rl_free_line_state ()
-{
-  register HIST_ENTRY *entry;
-
-  rl_free_undo_list ();
-
-  entry = current_history ();
-  if (entry)
-    entry->data = (char *)NULL;
-
-  _rl_kill_kbd_macro ();
-  rl_clear_message ();
-  _rl_init_argument ();
-}
-
-#endif  /* HANDLE_SIGNALS */
diff --git a/readline/skip-autoheader b/readline/skip-autoheader
deleted file mode 100644
diff --git a/readline/support/config.guess b/readline/support/config.guess
deleted file mode 100755
--- a/readline/support/config.guess
+++ /dev/null
@@ -1,1341 +0,0 @@
-#! /bin/sh
-# Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
-#
-# This file is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful, but
-# WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-#
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# Written by Per Bothner <bothner@cygnus.com>.
-# The master version of this file is at the FSF in /home/gd/gnu/lib.
-#
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
-#
-# The plan is that this can be called by configure scripts if you
-# don't specify an explicit system type (host/target name).
-#
-# Only a few systems have been added to this list; please add others
-# (but try to keep the structure clean).
-#
-
-# Use $HOST_CC if defined. $CC may point to a cross-compiler
-if test x"$CC_FOR_BUILD" = x; then
-  if test x"$HOST_CC" != x; then
-    CC_FOR_BUILD="$HOST_CC"
-  else
-    if test x"$CC" != x; then
-      CC_FOR_BUILD="$CC"
-    else
-      CC_FOR_BUILD=cc
-    fi
-  fi
-fi
-
-# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
-# (ghazi@noc.rutgers.edu 8/24/94.)
-if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
-	PATH=$PATH:/.attbin ; export PATH
-elif (test -f /usr/5bin/uname) >/dev/null 2>&1 ; then
-	PATH=$PATH:/usr/5bin
-fi
-
-UNAME=`(uname) 2>/dev/null` || UNAME=unknown
-UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
-UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
-UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
-
-RELEASE=`expr "$UNAME_RELEASE" : '[^0-9]*\([0-9]*\)'` # 4
-case "$RELEASE" in
-"")	RELEASE=0 ;;
-*)	RELEASE=`expr "$RELEASE" + 0` ;;
-esac
-REL_LEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.\([0-9]*\)'`    # 1
-REL_SUBLEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.[0-9]*.\([0-9]*\)'` # 2
-
-dummy=dummy-$$
-trap 'rm -f $dummy.c $dummy.o $dummy; exit 1' 1 2 15
-
-# Some versions of i386 SVR4.2 make `uname' equivalent to `uname -n', which
-# is contrary to all other versions of uname
-if [ -n "$UNAME" ] && [ "$UNAME_S" != "$UNAME" ] && [ "$UNAME_S" = UNIX_SV ]; then
-	UNAME=UNIX_SV
-fi
-
-# Note: order is significant - the case branches are not exclusive.
-
-case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
-    # Begin cases added for Bash
-    alpha:NetBSD:*:*)
-	echo alpha-dec-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    alpha:OpenBSD:*:*)
-	echo alpha-dec-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    i?86:NetBSD:*:*)
-	echo ${UNAME_MACHINE}-pc-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-	exit 0 ;;
-    i?86:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-pc-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-	exit 0 ;;
-    sparc:NetBSD:*:*)
-	echo sparc-unknown-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sparc:OpenBSD:*:*)
-	echo sparc-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    vax:NetBSD:*:*)
-	echo vax-dec-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    vax:OpenBSD:*:*)
-	echo vax-dec-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:machten:*:*)
-	echo mac68k-apple-machten${UNAME_RELEASE}
-	exit 0 ;;
-    concurrent*:*:*:*)
-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
-		echo concurrent-concurrent-sysv3
-	else
-		echo concurrent-concurrent-bsd
-	fi
-	exit 0 ;;
-    ppc*:SunOS:5.*:*)
-	echo ppc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    sparc:UNIX_SV:4.*:*)
-	echo sparc-unknown-sysv${UNAME_RELEASE}
-	exit 0 ;;
-    mips:UNIX_SV:4.*:*)
-	echo mips-mips-sysv${UNAME_RELEASE}
-	exit 0 ;;
-    mips:OSF*1:*:*)
-	echo mips-mips-osf1
-	exit 0 ;;
-    mips:4.4BSD:*:*)
-	echo mips-mips-bsd4.4
-	exit 0 ;;
-    MIServer-S:SMP_DC.OSx:*:dcosx)
-	echo mips-pyramid-sysv4
-	exit 0 ;;
-    news*:NEWS*:*:*)
-	echo mips-sony-newsos${UNAME_RELEASE}
-	exit 0 ;;
-    i?86:NEXTSTEP:*:*)
-	echo i386-next-nextstep${RELEASE}
-	exit 0 ;;
-    *680?0:NEXTSTEP:*:*)
-	echo m68k-next-nextstep${RELEASE}
-	exit 0 ;;    
-    *370:AIX:*:*)
-	echo ibm370-ibm-aix
-	exit 0 ;;
-    ksr1:OSF*1:*:*)
-	echo ksr1-ksr-osf1
-	exit 0 ;;
-    esa:OSF*1:*:* | ESA:OSF*:*:*)
-	echo esa-ibm-osf1
-	exit 0 ;;
-    DNP*:DNIX:*:*)
-	echo m68k-dnix-sysv
-	exit 0 ;;
-    *3b2*:*:*:*)
-	echo we32k-att-sysv3
-	exit 0 ;;
-    *:QNX:*:42*)
-	echo i386-qssl-qnx`echo ${UNAME_VERSION}`
-	exit 0 ;;
-    Alpha*:Windows:NT:*:SP*)
-	echo alpha-pc-opennt
-	exit 0 ;;
-    *:Windows:NT:*:SP*)
-	echo intel-pc-opennt
-	exit 0 ;;
-    *:NonStop-UX:*:*)
-	echo mips-compaq-nonstopux
-	exit 0 ;;
-    # end cases added for Bash
-    alpha:OSF1:*:*)
-	# TEST CHANGED FOR BASH to handle `letter version' releases
-	UNAME_MAJOR=`echo "$UNAME_RELEASE" | sed -e 's/^.\([0-9]\).*/\1/'`
-	if test X"$UNAME_MAJOR" != X"" && test $UNAME_MAJOR = 4 ; then
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
-	elif test X"$UNAME_MAJOR" != X"" && test $UNAME_MAJOR -gt 4 ; then
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`		
-	fi
-	# A Vn.n version is a released version.
-	# A Tn.n version is a released field test version.
-	# A Xn.n version is an unreleased experimental baselevel.
-	# 1.2 uses "1.2" for uname -r.
-	cat <<EOF >$dummy.s
-	.globl main
-	.ent main
-main:
-	.frame \$30,0,\$26,0
-	.prologue 0
-	.long 0x47e03d80 # implver $0
-	lda \$2,259
-	.long 0x47e20c21 # amask $2,$1
-	srl \$1,8,\$2
-	sll \$2,2,\$2
-	sll \$0,3,\$0
-	addl \$1,\$0,\$0
-	addl \$2,\$0,\$0
-	ret \$31,(\$26),1
-	.end main
-EOF
-	$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null
-	if test "$?" = 0 ; then
-		./$dummy
-		case "$?" in
-			7)
-				UNAME_MACHINE="alpha"
-				;;
-			15)
-				UNAME_MACHINE="alphaev5"
-				;;
-			14)
-				UNAME_MACHINE="alphaev56"
-				;;
-			10)
-				UNAME_MACHINE="alphapca56"
-				;;
-			16)
-				UNAME_MACHINE="alphaev6"
-				;;
-		esac
-	fi
-	rm -f $dummy.s $dummy
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit 0 ;;
-    Alpha\ *:Windows_NT*:*)
-        # How do we know it's Interix rather than the generic POSIX subsystem?
-        # Should we change UNAME_MACHINE based on the output of uname instead
-        # of the specific Alpha model?
-        echo alpha-pc-interix
-        exit 0 ;;
-    21064:Windows_NT:50:3)
-	echo alpha-dec-winnt3.5
-	exit 0 ;;
-    Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-cbm-sysv4
-	exit 0;;
-    amiga:NetBSD:*:*)
-	echo m68k-cbm-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    amiga:OpenBSD:*:*)
-	echo m68k-cbm-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    *:[Aa]miga[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-amigaos
-	exit 0 ;;
-    arc64:OpenBSD:*:*)
-	echo mips64el-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    arc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    hkmips:OpenBSD:*:*)
-	echo mips-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    pmax:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sgi:OpenBSD:*:*)
-	echo mips-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    wgrisc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit 0;;
-    arm32:NetBSD:*:*)
-	echo arm-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-	exit 0 ;;
-    SR2?01:HI-UX/MPP:*:*)
-	echo hppa1.1-hitachi-hiuxmpp
-	exit 0;;
-    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
-	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
-		echo pyramid-pyramid-sysv3
-	else
-		echo pyramid-pyramid-bsd
-	fi
-	exit 0 ;;
-    NILE:*:*:*:dcosx)
-	echo pyramid-pyramid-svr4
-	exit 0 ;;
-    sun4H:SunOS:5.*:*)
-        echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-        exit 0 ;;
-    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    i86pc:SunOS:5.*:*)
-	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    sun4*:SunOS:6*:*)
-	# According to config.sub, this is the proper way to canonicalize
-	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
-	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    sun4*:SunOS:*:*)
-	case "`/usr/bin/arch -k`" in
-	    Series*|S4*)
-		UNAME_RELEASE=`uname -v`
-		;;
-	esac
-	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit 0 ;;
-    sun3*:SunOS:*:*)
-	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit 0 ;;
-    sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(head -1 /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
-	case "`/bin/arch`" in
-	    sun3)
-		echo m68k-sun-sunos${UNAME_RELEASE}
-		;;
-	    sun4)
-		echo sparc-sun-sunos${UNAME_RELEASE}
-		;;
-	esac
-	exit 0 ;;
-    aushp:SunOS:*:*)
-	echo sparc-auspex-sunos${UNAME_RELEASE}
-	exit 0 ;;
-    atari*:NetBSD:*:*)
-	echo m68k-atari-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    atari*:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    # The situation for MiNT is a little confusing.  The machine name
-    # can be virtually everything (everything which is not
-    # "atarist" or "atariste" at least should have a processor 
-    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
-    # to the lowercase version "mint" (or "freemint").  Finally
-    # the system name "TOS" denotes a system which is actually not
-    # MiNT.  But MiNT is downward compatible to TOS, so this should
-    # be no problem.
-    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-       echo m68k-atari-mint${UNAME_RELEASE}
-       exit 0 ;;
-    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-       echo m68k-atari-mint${UNAME_RELEASE}
-       exit 0 ;;
-    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-       echo m68k-atari-mint${UNAME_RELEASE}
-       exit 0 ;;
-    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
-        exit 0 ;;
-    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
-        exit 0 ;;
-    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
-        exit 0 ;;
-    sun3*:NetBSD:*:*)
-	echo m68k-sun-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sun3*:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:NetBSD:*:*)
-	echo m68k-apple-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme88k:OpenBSD:*:*)
-	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    *:"Mac OS":*:*)
-	echo `uname -p`-apple-macos${UNAME_RELEASE}
-	exit 0 ;;
-    powerpc:machten:*:*)
-	echo powerpc-apple-machten${UNAME_RELEASE}
-	exit 0 ;;
-    macppc:NetBSD:*:*)
-        echo powerpc-apple-netbsd${UNAME_RELEASE}
-        exit 0 ;;
-    RISC*:Mach:*:*)
-	echo mips-dec-mach_bsd4.3
-	exit 0 ;;
-    RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
-    VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
-    2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix${UNAME_RELEASE}
-	exit 0 ;;
-    mips:*:*:UMIPS | mips:*:*:RISCos)
-	sed 's/^	//' << EOF >$dummy.c
-#ifdef __cplusplus
-	int main (int argc, char *argv[]) {
-#else
-	int main (argc, argv) int argc; char *argv[]; {
-#endif
-	#if defined (host_mips) && defined (MIPSEB)
-	#if defined (SYSTYPE_SYSV)
-	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_SVR4)
-	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
-	#endif
-	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
-	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
-	#endif
-	#endif
-	  exit (-1);
-	}
-EOF
-	$CC_FOR_BUILD $dummy.c -o $dummy \
-	  && ./$dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
-	  && rm $dummy.c $dummy && exit 0
-	rm -f $dummy.c $dummy
-	echo mips-mips-riscos${UNAME_RELEASE}
-	exit 0 ;;
-    Night_Hawk:Power_UNIX:*:*)
-	echo powerpc-harris-powerunix
-	exit 0 ;;
-    m88k:CX/UX:7*:*)
-	echo m88k-harris-cxux7
-	exit 0 ;;
-    m88k:*:4*:R4*)
-	echo m88k-motorola-sysv4
-	exit 0 ;;
-    m88k:*:3*:R3*)
-	echo m88k-motorola-sysv3
-	exit 0 ;;
-    AViiON:dgux:*:*)
-	# DG/UX returns AViiON for all architectures
-	UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88110 ] ; then
-	  if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
-	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
-		echo m88k-dg-dgux${UNAME_RELEASE}
-	  else
-		echo m88k-dg-dguxbcs${UNAME_RELEASE}
-	  fi
-	else
-	  echo i586-dg-dgux${UNAME_RELEASE}
-	fi
- 	exit 0 ;;
-    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
-	echo m88k-dolphin-sysv3
-	exit 0 ;;
-    M88*:*:R3*:*)
-	# Delta 88k system running SVR3
-	echo m88k-motorola-sysv3
-	exit 0 ;;
-    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
-	echo m88k-tektronix-sysv3
-	exit 0 ;;
-    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
-	echo m68k-tektronix-bsd
-	exit 0 ;;
-    *:IRIX*:*:*)
-	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit 0 ;;
-    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
-	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
-    i?86:AIX:*:*)
-	echo i386-ibm-aix
-	exit 0 ;;
-    *:AIX:2:3)
-	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		sed 's/^		//' << EOF >$dummy.c
-		#include <sys/systemcfg.h>
-
-		main()
-			{
-			if (!__power_pc())
-				exit(1);
-			puts("powerpc-ibm-aix3.2.5");
-			exit(0);
-			}
-EOF
-		$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm $dummy.c $dummy && exit 0
-		rm -f $dummy.c $dummy
-		echo rs6000-ibm-aix3.2.5
-	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
-		echo rs6000-ibm-aix3.2.4
-	else
-		echo rs6000-ibm-aix3.2
-	fi
-	exit 0 ;;
-    *:AIX:*:4)
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -1 | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -EHl ${IBM_CPU_ID} | grep POWER >/dev/null 2>&1; then
-		IBM_ARCH=rs6000
-	else
-		IBM_ARCH=powerpc
-	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	elif grep bos410 /usr/include/stdio.h >/dev/null 2>&1; then
-		IBM_REV=4.1
-	elif grep bos411 /usr/include/stdio.h >/dev/null 2>&1; then
-		IBM_REV=4.1.1
-	else
-		IBM_REV=4.${UNAME_RELEASE}
-	fi
-	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit 0 ;;
-    *:AIX:*:*)
-	echo rs6000-ibm-aix
-	exit 0 ;;
-    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
-	echo romp-ibm-bsd4.4
-	exit 0 ;;
-    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
-	exit 0 ;;                           # report: romp-ibm BSD 4.3
-    *:BOSX:*:*)
-	echo rs6000-bull-bosx
-	exit 0 ;;
-    DPX/2?00:B.O.S.:*:*)
-	echo m68k-bull-sysv3
-	exit 0 ;;
-    9000/[34]??:4.3bsd:1.*:*)
-	echo m68k-hp-bsd
-	exit 0 ;;
-    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
-	echo m68k-hp-bsd4.4
-	exit 0 ;;
-    9000/[34678]??:HP-UX:*:*)
-	case "${UNAME_MACHINE}" in
-	    9000/31? )		HP_ARCH=m68000 ;;
-	    9000/[34]?? )	HP_ARCH=m68k ;;
-	    9000/[678][0-9][0-9])
-              sed 's/^              //' << EOF >$dummy.c
-              #include <stdlib.h>
-              #include <unistd.h>
-
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
-
-                  switch (cpu)
-              	{
-              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
-              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
-              		{
-              		case 64: puts ("hppa2.0w"); break;
-              		case 32: puts ("hppa2.0n"); break;
-              		default: puts ("hppa2.0"); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts ("hppa2.0"); break;
-              #endif
-              	default: puts ("hppa1.0"); break;
-              	}
-                  exit (0);
-              }
-EOF
-	($CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null ) && HP_ARCH=`./$dummy`
-	rm -f $dummy.c $dummy
-	esac
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit 0 ;;
-    3050*:HI-UX:*:*)
-	sed 's/^	//' << EOF >$dummy.c
-	#include <unistd.h>
-	int
-	main ()
-	{
-	  long cpu = sysconf (_SC_CPU_VERSION);
-	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
-	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
-	     results, however.  */
-	  if (CPU_IS_PA_RISC (cpu))
-	    {
-	      switch (cpu)
-		{
-		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
-		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
-		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
-		  default: puts ("hppa-hitachi-hiuxwe2"); break;
-		}
-	    }
-	  else if (CPU_IS_HP_MC68K (cpu))
-	    puts ("m68k-hitachi-hiuxwe2");
-	  else puts ("unknown-hitachi-hiuxwe2");
-	  exit (0);
-	}
-EOF
-	$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm $dummy.c $dummy && exit 0
-	rm -f $dummy.c $dummy
-	echo unknown-hitachi-hiuxwe2
-	exit 0 ;;
-    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
-	echo hppa1.1-hp-bsd
-	exit 0 ;;
-    9000/8??:4.3bsd:*:*)
-	echo hppa1.0-hp-bsd
-	exit 0 ;;
-    *9??*:MPE/iX:*:*)
-        echo hppa1.0-hp-mpeix
-        exit 0 ;;
-    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
-	echo hppa1.1-hp-osf
-	exit 0 ;;
-    hp8??:OSF1:*:*)
-	echo hppa1.0-hp-osf
-	exit 0 ;;
-    i?86:OSF1:*:*)
-	if [ -x /usr/sbin/sysversion ] ; then
-	    echo ${UNAME_MACHINE}-unknown-osf1mk
-	else
-	    echo ${UNAME_MACHINE}-unknown-osf1
-	fi
-	exit 0 ;;
-    parisc*:Lites*:*:*)
-	echo hppa1.1-hp-lites
-	exit 0 ;;
-    hppa*:OpenBSD:*:*)
-        echo hppa-unknown-openbsd
-        exit 0 ;;
-    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
-	echo c1-convex-bsd
-        exit 0 ;;
-    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-        exit 0 ;;
-    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
-	echo c34-convex-bsd
-        exit 0 ;;
-    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
-	echo c38-convex-bsd
-        exit 0 ;;
-    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
-	echo c4-convex-bsd
-        exit 0 ;;
-    CRAY*X-MP:*:*:*)
-	echo xmp-cray-unicos
-        exit 0 ;;
-    CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE}
-	exit 0 ;;
-    CRAY*[A-Z]90:*:*:*)
-	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
-	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
-	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
-	exit 0 ;;
-    CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE}
-	exit 0 ;;
-    CRAY*T3E:*:*:*)
-        echo alpha-cray-unicosmk${UNAME_RELEASE}
-        exit 0 ;;
-    CRAY-2:*:*:*)
-	echo cray2-cray-unicos
-        exit 0 ;;
-    F300:UNIX_System_V:*:*)
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-	echo "f300-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-	exit 0 ;;
-    F301:UNIX_System_V:*:*)
-	echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
-	exit 0 ;;
-    hp3[0-9][05]:NetBSD:*:*)
-	echo m68k-hp-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    hp300:OpenBSD:*:*)
-        echo m68k-unknown-openbsd${UNAME_RELEASE}
-        exit 0 ;;
-    i?86:BSD/386:*:* | i?86:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
-	exit 0 ;;
-    sparc*:BSD/OS:*:*)
-        echo sparc-unknown-bsdi${UNAME_RELEASE}
-        exit 0 ;;
-    *:BSD/OS:*:*)
-        echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-        exit 0 ;;
-    *:FreeBSD:*:*)
-	if test -x /usr/bin/objformat; then
-	    if test "elf" = "`/usr/bin/objformat`"; then
-		echo ${UNAME_MACHINE}-unknown-freebsdelf`echo ${UNAME_RELEASE}|sed -e 's/[-_].*//'`
-		exit 0
-	    fi
-	fi
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-=(].*//'`
-	exit 0 ;;
-    *:NetBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-	exit 0 ;;
-    *:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-	exit 0 ;;
-    i*:CYGWIN*:*)
-	echo ${UNAME_MACHINE}-pc-cygwin
-	exit 0 ;;
-    i*:MINGW*:*)
-	echo ${UNAME_MACHINE}-pc-mingw32
-	exit 0 ;;
-    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-        # How do we know it's Interix rather than the generic POSIX subsystem?
-        # It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
-        # UNAME_MACHINE based on the output of uname instead of i386?
-        echo i386-pc-interix
-        exit 0 ;;
-    i*:UWIN*:*)
-        echo ${UNAME_MACHINE}-pc-uwin
-        exit 0 ;;
-    p*:CYGWIN*:*)
-	echo powerpcle-unknown-cygwin
-	exit 0 ;;    
-    prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
-    *:GNU:*:*)
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit 0 ;;
-    *:Linux:*:*)
-        # uname on the ARM produces all sorts of strangeness, and we need to
-        # filter it out.
-        case "$UNAME_MACHINE" in
-          armv*)                      UNAME_MACHINE=$UNAME_MACHINE ;;
-          arm* | sa110*)              UNAME_MACHINE="arm" ;;
-        esac
-
-	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us.  cd to the root directory to prevent
-	# problems with other programs or directories called `ld' in the path.
-	ld_help_string=`cd /; ld --help 2>&1`
-	ld_supported_emulations=`echo $ld_help_string \
-			 | sed -ne '/supported emulations:/!d
-				    s/[ 	][ 	]*/ /g
-				    s/.*supported emulations: *//
-				    s/ .*//
-				    p'`
-	case "$ld_supported_emulations" in
-	  *ia64)      echo "${UNAME_MACHINE}-unknown-linux"         ; exit 0 ;;
-	  i?86linux)  echo "${UNAME_MACHINE}-pc-linux-gnuaout"      ; exit 0 ;;
-	  i?86coff)   echo "${UNAME_MACHINE}-pc-linux-gnucoff"      ; exit 0 ;;
-	  sparclinux) echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
-	  armlinux)   echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
-	  m68klinux)  echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
-	  elf32ppc | elf32ppclinux)
-		# Determine Lib Version
-		cat >$dummy.c <<EOF
-#include <features.h>
-#if defined(__GLIBC__)
-extern char __libc_version[];
-extern char __libc_release[];
-#endif
-main(argc, argv)
-     int argc;
-     char *argv[];
-{
-#if defined(__GLIBC__)
-  printf("%s %s\n", __libc_version, __libc_release);
-#else
-  printf("unkown\n");
-#endif
-  return 0;
-}
-EOF
-		LIBC=""
-		$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null
-		if test "$?" = 0 ; then
-			./$dummy | grep 1\.99 > /dev/null
-			if test "$?" = 0 ; then
-				LIBC="libc1"
-			fi
-		fi	
-		rm -f $dummy.c $dummy
-		echo powerpc-unknown-linux-gnu${LIBC} ; exit 0 ;;
- 	esac
-
-	if test "${UNAME_MACHINE}" = "alpha" ; then
-		sed 's/^	//'  <<EOF >$dummy.s
-		.globl main
-		.ent main
-	main:
-		.frame \$30,0,\$26,0
-		.prologue 0
-		.long 0x47e03d80 # implver $0
-		lda \$2,259
-		.long 0x47e20c21 # amask $2,$1
-		srl \$1,8,\$2
-		sll \$2,2,\$2
-		sll \$0,3,\$0
-		addl \$1,\$0,\$0
-		addl \$2,\$0,\$0
-		ret \$31,(\$26),1
-		.end main
-EOF
-		LIBC=""
-		$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null
-		if test "$?" = 0 ; then
-			./$dummy
-			case "$?" in
-			7)
-				UNAME_MACHINE="alpha"
-				;;
-			15)
-				UNAME_MACHINE="alphaev5"
-				;;
-			14)
-				UNAME_MACHINE="alphaev56"
-				;;
-			10)
-				UNAME_MACHINE="alphapca56"
-				;;
-			16)
-				UNAME_MACHINE="alphaev6"
-				;;
-			esac
-
-			objdump --private-headers $dummy | \
-			  grep ld.so.1 > /dev/null
-			if test "$?" = 0 ; then
-				LIBC="libc1"
-			fi
-		fi
-		rm -f $dummy.s $dummy
-		echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC} ; exit 0
-	elif test "${UNAME_MACHINE}" = "mips" ; then
-	  cat >$dummy.c <<EOF
-#ifdef __cplusplus
-int main (int argc, char *argv[]) {
-#else
-int main (argc, argv) int argc; char *argv[]; {
-#endif
-#ifdef __MIPSEB__
-  printf ("%s-unknown-linux-gnu\n", argv[1]);
-#endif
-#ifdef __MIPSEL__
-  printf ("%sel-unknown-linux-gnu\n", argv[1]);
-#endif
-  return 0;
-}
-EOF
-	  $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm $dummy.c $dummy && exit 0
-	  rm -f $dummy.c $dummy
-	else
-	  # Either a pre-BFD a.out linker (linux-gnuoldld)
-	  # or one that does not give us useful --help.
-	  # GCC wants to distinguish between linux-gnuoldld and linux-gnuaout.
-	  # If ld does not provide *any* "supported emulations:"
-	  # that means it is gnuoldld.
-	  echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations:"
-	  test $? != 0 && echo "${UNAME_MACHINE}-pc-linux-gnuoldld" && exit 0
-
-	  case "${UNAME_MACHINE}" in
-	  i?86)
-	    VENDOR=pc;
-	    ;;
-	  *)
-	    VENDOR=unknown;
-	    ;;
-	  esac
-	  # Determine whether the default compiler is a.out or elf
-	  cat >$dummy.c <<EOF
-#include <features.h>
-#ifdef __cplusplus
-	int main (int argc, char *argv[]) {
-#else
-	int main (argc, argv) int argc; char *argv[]; {
-#endif
-#ifdef __ELF__
-# ifdef __GLIBC__
-#  if __GLIBC__ >= 2
-    printf ("%s-${VENDOR}-linux-gnu\n", argv[1]);
-#  else
-    printf ("%s-${VENDOR}-linux-gnulibc1\n", argv[1]);
-#  endif
-# else
-   printf ("%s-${VENDOR}-linux-gnulibc1\n", argv[1]);
-# endif
-#else
-  printf ("%s-${VENDOR}-linux-gnuaout\n", argv[1]);
-#endif
-  return 0;
-}
-EOF
-	  ${CC-cc} $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm $dummy.c $dummy && exit 0
-	  rm -f $dummy.c $dummy
-	fi ;;
-# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
-# are messed up and put the nodename in both sysname and nodename.
-    i?86:DYNIX/ptx:4*:*)
-	echo i386-sequent-sysv4
-	exit 0 ;;
-# added by chet for bash based on usenet posting from <hops@sco.com> and
-# documentation on SCO's web site -- UnixWare 7 (SVR5)
-#    i?86:UnixWare:5*:*)
-#	echo ${UNAME_MACHINE}-pc-sysv5uw${UNAME_VERSION}
-#	exit 0 ;;
-    i?86:UNIX_SV:4.2MP:2.*)
-	# Unixware is an offshoot of SVR4, but it has its own version
-	# number series starting with 2...
-	# I am not positive that other SVR4 systems won't match this,
-	# I just have to hope.  -- rms.
-	# Use sysv4.2uw... so that sysv4* matches it.
-	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
-	exit 0 ;;
-    i?86:*:4.*:* | i?86:SYSTEM_V:4.*:* | i?86:UNIX_SV:4.*:*)
-	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
-	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
-	fi
-	exit 0 ;;
-    i?86:*:5:7*)
-        UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
-        (/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
-        (/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) && UNAME_MACHINE=i586
-        (/bin/uname -X|egrep '^Machine.*Pent.*II' >/dev/null) && UNAME_MACHINE=i686
-        (/bin/uname -X|egrep '^Machine.*Pentium Pro' >/dev/null) && UNAME_MACHINE=i585
-        echo ${UNAME_MACHINE}-${UNAME_SYSTEM}${UNAME_VERSION}-sysv${UNAME_RELEASE}
-        exit 0 ;;
-    i?86:*:3.2:*)
-	if test -f /usr/options/cb.name; then
-		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
-	elif /bin/uname -X 2>/dev/null >/dev/null ; then
-		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
-		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
-		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
-			&& UNAME_MACHINE=i586
-		(/bin/uname -X|egrep '^Machine.*Pent ?II' >/dev/null) \
-			&& UNAME_MACHINE=i686
-		(/bin/uname -X|egrep '^Machine.*Pentium Pro' >/dev/null) \
-			&& UNAME_MACHINE=i686
-		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
-	else
-		echo ${UNAME_MACHINE}-pc-sysv32
-	fi
-	exit 0 ;;
-    pc:*:*:*)
-	# uname -m prints for DJGPP always 'pc', but it prints nothing about
-	# the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
-	exit 0 ;;
-    Intel:Mach:3*:*)
-	echo i386-pc-mach3
-	exit 0 ;;
-    paragon:*:*:*)
-	echo i860-intel-osf1
-	exit 0 ;;
-    i860:*:4.*:*) # i860-SVR4
-	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
-	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
-	fi
-	exit 0 ;;
-    mini*:CTIX:SYS*5:*)
-	# "miniframe"
-	echo m68010-convergent-sysv
-	exit 0 ;;
-    M68*:*:R3V[567]*:*)
-	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)
-	OS_REL=''
-	test -r /etc/.relid \
-	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
-	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
-	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
-    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && echo i486-ncr-sysv4 && exit 0 ;;
-    mc68030:UNIX_System_V:4.*:*)
-	echo m68k-atari-sysv4
-	exit 0 ;;
-    m68*:LynxOS:2.*:*)
-	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    i?86:LynxOS:2.*:* | i?86:LynxOS:3.[01]*:*)
-	echo i386-pc-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    *:LynxOS:*:*)
-	echo ${UNAME_MACHINE}-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv${UNAME_RELEASE}
-	exit 0 ;;
-    RM*:SINIX-*:*:* | RM*:ReliantUNIX-*:*:*)
-	echo mips-sni-sysv4
-	exit 0 ;;
-    *:SINIX-*:*:*)
-	if uname -p 2>/dev/null >/dev/null ; then
-		UNAME_MACHINE=`(uname -p) 2>/dev/null`
-		echo ${UNAME_MACHINE}-sni-sysv4
-	else
-		echo ns32k-sni-sysv
-	fi
-	exit 0 ;;
-    PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-			   # says <Richard.M.Bartel@ccMail.Census.GOV>
-	echo i586-unisys-sysv4
-	exit 0 ;;
-    *:UNIX_System_V:4*:FTX*)
-	# From Gerald Hewes <hewes@openmarket.com>.
-	# How about differentiating between stratus architectures? -djm
-	echo hppa1.1-stratus-sysv4
-	exit 0 ;;
-    *:*:*:FTX*)
-	# From seanf@swdc.stratus.com.
-	echo i860-stratus-sysv4
-	exit 0 ;;              
-    mc68*:A/UX:*:*)
-	echo m68k-apple-aux${UNAME_RELEASE}
-	exit 0 ;;
-    news*:NEWS-OS:*:6*)
-	echo mips-sony-newsos6
-	exit 0 ;;
-    R3000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
-	if [ -d /usr/nec ]; then
-		echo mips-nec-sysv${UNAME_RELEASE}
-	else
-		echo mips-unknown-sysv${UNAME_RELEASE}
-	fi
-	exit 0 ;;
-    BeBox:BeOS:*:*)    # BeOS running on hardware made by Be, PPC only.
-	echo powerpc-apple-beos
-	exit 0 ;;
-    BeMac:BeOS:*:*)
-	echo powerpc-apple-beos
-	exit 0 ;;
-    BePC:BeOS:*:*)
-	echo i586-pc-beos
-	exit 0 ;;
-    SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
-    SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux${UNAME_RELEASE}
-	exit 0 ;;
-    Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
-    *:Rhapsody:*:*)
-	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
-    Power*:Darwin:*:*)
-	echo powerpc-apple-darwin${UNAME_RELEASE}
-	exit 0 ;;
-    *:Darwin:*:*)
-	echo ${UNAME_MACHINE}-apple-darwin${UNAME_RELEASE}
-	exit 0 ;;
-esac
-
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-cat >$dummy.c <<EOF
-#ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
-#endif
-main ()
-{
-#if defined (sony)
-#if defined (MIPSEB)
-  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
-     I don't know....  */
-  printf ("mips-sony-bsd\n"); exit (0);
-#else
-#include <sys/param.h>
-  printf ("m68k-sony-newsos%s\n",
-#ifdef NEWSOS4
-          "4"
-#else
-	  ""
-#endif
-         ); exit (0);
-#endif
-#endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp9000) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
-#if defined (NeXT)
-#if !defined (__ARCHITECTURE__)
-#define __ARCHITECTURE__ "m68k"
-#endif
-  int version;
-  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  if (version < 4)
-    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
-  else
-    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
-  exit (0);
-#endif
-
-#if defined (MULTIMAX) || defined (n16)
-#if defined (UMAXV)
-  printf ("ns32k-encore-sysv\n"); exit (0);
-#else
-#if defined (CMU)
-  printf ("ns32k-encore-mach\n"); exit (0);
-#else
-  printf ("ns32k-encore-bsd\n"); exit (0);
-#endif
-#endif
-#endif
-
-#if defined (__386BSD__)
-  printf ("i386-pc-bsd\n"); exit (0);
-#endif
-
-#if defined (sequent)
-#if defined (i386)
-  printf ("i386-sequent-dynix\n"); exit (0);
-#endif
-#if defined (ns32000)
-  printf ("ns32k-sequent-dynix\n"); exit (0);
-#endif
-#endif
-
-#if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
-
-#endif
-
-#if defined (vax)
-#if !defined (ultrix)
-  printf ("vax-dec-bsd\n"); exit (0);
-#else
-  printf ("vax-dec-ultrix\n"); exit (0);
-#endif
-#endif
-
-#if defined (alliant) && defined (i860)
-  printf ("i860-alliant-bsd\n"); exit (0);
-#endif
-
-/* Begin cases added for Bash */
-#if defined (tahoe)
-  printf ("tahoe-cci-bsd\n"); exit (0);
-#endif
-
-#if defined (nec_ews)
-#  if defined (SYSTYPE_SYSV)
-  printf ("ews4800-nec-sysv4\n"); exit 0;
-#  else
-  printf ("ews4800-nec-bsd\n"); exit (0);
-#  endif
-#endif
-
-#if defined (sony)
-#  if defined (SYSTYPE_SYSV)
-  printf ("mips-sony-sysv4\n"); exit 0;
-#  else
-  printf ("mips-sony-bsd\n"); exit (0);
-#  endif
-#endif
-
-#if defined (ardent)
-  printf ("titan-ardent-bsd\n"); exit (0);
-#endif
-
-#if defined (stardent)
-  printf ("stardent-stardent-sysv\n"); exit (0);
-#endif
-
-#if defined (ibm032)
-  printf ("ibmrt-ibm-bsd4.3\n"); exit (0);
-#endif
-
-#if defined (sequent) && defined (i386)
-  printf ("i386-sequent-bsd\n"); exit (0);
-#endif
-
-#if defined (qnx) && defined (i386)
-  printf ("i386-pc-qnx\n"); exit (0);
-#endif
-
-#if defined (gould)
-  printf ("gould-gould-bsd\n"); exit (0);
-#endif
-
-#if defined (unixpc)
-  printf ("unixpc-att-sysv\n"); exit (0);
-#endif
-
-#if defined (att386)
-  printf ("i386-att-sysv3\n"); exit (0);
-#endif
-
-#if defined (__m88k) && defined (__UMAXV__)
-  printf ("m88k-encore-sysv3\n"); exit (0);
-#endif
-
-#if defined (drs6000)
-  printf ("drs6000-icl-sysv4.2\n"); exit (0);
-#endif
-
-#if defined (clipper)
-  printf ("clipper-orion-bsd\n"); exit (0);
-#endif
-
-#if defined (is68k)
-  printf ("m68k-isi-bsd\n"); exit (0);
-#endif
-
-#if defined (luna88k)
-  printf ("luna88k-omron-bsd\n"); exit (0);
-#endif
-
-#if defined (butterfly) && defined (BFLY1)
-  printf ("butterfly-bbn-mach\n"); exit (0);
-#endif
-
-#if defined (tower32)
-  printf ("tower32-ncr-sysv4\n"); exit (0);
-#endif
-
-#if defined (MagicStation)
-  printf ("magicstation-unknown-bsd\n"); exit (0);
-#endif
-
-#if defined (scs)
-  printf ("symmetric-scs-bsd4.2\n"); exit (0);
-#endif
-
-#if defined (tandem)
-  printf ("tandem-tandem-sysv\n"); exit (0);
-#endif
-
-#if defined (cadmus)
-  printf ("cadmus-pcs-sysv\n"); exit (0);
-#endif
-
-#if defined (masscomp)
-  printf ("masscomp-masscomp-sysv3\n"); exit (0);
-#endif
-
-#if defined (hbullx20)
-  printf ("hbullx20-bull-sysv3\n"); exit (0);
-#endif
-
-/* End cases added for Bash */
-
-  exit (1);
-}
-EOF
-
-${CC-cc} $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm $dummy.c $dummy && exit 0
-rm -f $dummy.c $dummy
-
-# Apollos put the system type in the environment.
-
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
-
-# Convex versions that predate uname can use getsysinfo(1)
-
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit 0 ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit 0 ;;
-    c34*)
-	echo c34-convex-bsd
-	exit 0 ;;
-    c38*)
-	echo c38-convex-bsd
-	exit 0 ;;
-    c4*)
-	echo c4-convex-bsd
-	exit 0 ;;
-    esac
-fi
-
-# Begin cases added for Bash
-case "$UNAME" in
-uts) echo uts-amdahl-sysv${UNAME_RELEASE}; exit 0 ;;
-esac
-
-if [ -d /usr/amiga ]; then
-	echo m68k-cbm-sysv${UNAME_RELEASE}; exit 0;
-fi
-
-if [ -f /bin/fxc.info ]; then
-	echo fxc-alliant-concentrix
-	exit 0
-fi
-# end cases added for Bash
-
-#echo '(Unable to guess system type)' 1>&2
-
-exit 1
diff --git a/readline/support/config.sub b/readline/support/config.sub
deleted file mode 100755
--- a/readline/support/config.sub
+++ /dev/null
@@ -1,1265 +0,0 @@
-#! /bin/sh
-# Configuration validation subroutine script, version 1.1.
-#   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA 02111-1307, USA.
-
-# As a special exception to the GNU General Public License, if you
-# distribute this file as part of a program that contains a
-# configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-# Configuration subroutine to validate and canonicalize a configuration type.
-# Supply the specified configuration type as an argument.
-# If it is invalid, we print an error message on stderr and exit with code 1.
-# Otherwise, we print the canonical config type on stdout and succeed.
-
-# This file is supposed to be the same for all GNU packages
-# and recognize all the CPU types, system types and aliases
-# that are meaningful with *any* GNU software.
-# Each package is responsible for reporting which valid configurations
-# it does not support.  The user should be able to distinguish
-# a failure to support a valid configuration from a meaningless
-# configuration.
-
-# The goal of this file is to map all the various variations of a given
-# machine specification into a single specification in the form:
-#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
-# or in some cases, the newer four-part form:
-#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
-# It is wrong to echo any other type of specification.
-
-if [ x$1 = x ]
-then
-	echo Configuration name missing. 1>&2
-	echo "Usage: $0 CPU-MFR-OPSYS" 1>&2
-	echo "or     $0 ALIAS" 1>&2
-	echo where ALIAS is a recognized configuration type. 1>&2
-	exit 1
-fi
-
-# First pass through any local machine types.
-case $1 in
-	*local*)
-		echo $1
-		exit 0
-		;;
-	*)
-	;;
-esac
-
-# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
-# Here we must recognize all the valid KERNEL-OS combinations.
-maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
-case $maybe_os in
-  linux-gnu*)
-    os=-$maybe_os
-    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
-    ;;
-  *)
-    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
-    if [ $basic_machine != $1 ]
-    then os=`echo $1 | sed 's/.*-/-/'`
-    else os=; fi
-    ;;
-esac
-
-### Let's recognize common machines as not being operating systems so
-### that things like config.sub decstation-3100 work.  We also
-### recognize some manufacturers as not being operating systems, so we
-### can provide default operating systems below.
-case $os in
-	-sun*os*)
-		# Prevent following clause from handling this invalid input.
-		;;
-	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
-	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
-	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
-	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
-	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
-	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple )
-		os=
-		basic_machine=$1
-		;;
-	-sim | -cisco | -oki | -wec | -winbond)
-		os=
-		basic_machine=$1
-		;;
-	-scout)
-		;;
-	-wrs)
-		os=vxworks
-		basic_machine=$1
-		;;
-	-hiux*)
-		os=-hiuxwe2
-		;;
-	-sco5)
-		os=-sco3.2v5
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco4)
-		os=-sco3.2v4
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2.[4-9]*)
-		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco3.2v[4-9]*)
-		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-sco*)
-		os=-sco3.2v2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-udk*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-isc)
-		os=-isc2.2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-clix*)
-		basic_machine=clipper-intergraph
-		;;
-	-isc*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
-		;;
-	-lynx*)
-		os=-lynxos
-		;;
-	-ptx*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
-		;;
-	-windowsnt*)
-		os=`echo $os | sed -e 's/windowsnt/winnt/'`
-		;;
-	-psos*)
-		os=-psos
-		;;
-esac
-
-# Decode aliases for certain CPU-COMPANY combinations.
-case $basic_machine in
-	# Recognize the basic CPU types without company name.
-	# Some are omitted here because they have special meanings below.
-	tahoe | i860 | ia64 | m32r | m68k | m68000 | m88k | ns32k | arc | arm \
-		| arme[lb] | pyramid | mn10200 | mn10300 | tron | a29k \
-		| 580 | i960 | h8300 \
-		| hppa | hppa1.0 | hppa1.1 | hppa2.0 | hppa2.0w | hppa2.0n \
-		| alpha | alphaev[4-7] | alphaev56 | alphapca5[67] \
-		| we32k | ns16k | clipper | i370 | sh | powerpc | powerpcle \
-		| 1750a | dsp16xx | pdp11 | mips16 | mips64 | mipsel | mips64el \
-		| mips64orion | mips64orionel | mipstx39 | mipstx39el \
-		| mips64vr4300 | mips64vr4300el | mips64vr4100 | mips64vr4100el \
-		| mips64vr5000 | miprs64vr5000el | mcore \
-		| sparc | sparclet | sparclite | sparc64 | sparcv9 | v850 | c4x \
-	        | thumb | d10v | s390)
-		basic_machine=$basic_machine-unknown
-		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | z8k | v70 | h8500 | w65)
-		;;
-
-	# We use `pc' rather than `unknown'
-	# because (1) that's what they normally are, and
-	# (2) the word "unknown" tends to confuse beginning users.
-	i[34567]86)
-	  basic_machine=$basic_machine-pc
-	  ;;
-	# Object if more than one company name word.
-	*-*-*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
-		;;
-	# Recognize the basic CPU types with company name.
-	# FIXME: clean up the formatting here.
-	vax-* | tahoe-* | i[34567]86-* | i860-* | ia64-* | m32r-* | m68k-* | m68000-* \
-	      | m88k-* | sparc-* | ns32k-* | fx80-* | arc-* | arm-* | c[123]* \
-	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \
-	      | power-* | none-* | 580-* | cray2-* | h8300-* | h8500-* | i960-* \
-	      | xmp-* | ymp-* \
-	      | hppa-* | hppa1.0-* | hppa1.1-* | hppa2.0-* | hppa2.0w-* | hppa2.0n-* \
-	      | alpha-* | alphaev[4-7]-* | alphaev56-* | alphapca5[67]-* \
-	      | we32k-* | cydra-* | ns16k-* | pn-* | np1-* | xps100-* \
-	      | clipper-* | orion-* \
-	      | sparclite-* | pdp11-* | sh-* | powerpc-* | powerpcle-* \
-	      | sparc64-* | sparcv9-* | sparc86x-* | mips16-* | mips64-* | mipsel-* \
-	      | mips64el-* | mips64orion-* | mips64orionel-* \
-	      | mips64vr4100-* | mips64vr4100el-* | mips64vr4300-* | mips64vr4300el-* \
-	      | mipstx39-* | mipstx39el-* | mcore-* \
-	      | f301-* | armv*-* | t3e-* \
-	      | m88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | d10v-* \
-	      | thumb-* | v850-* | d30v-* | tic30-* | c30-* )
-		;;
-	# BEGIN cases added for Bash
-	butterfly-bbn* | cadmus-* | ews*-nec | ibmrt-ibm* | masscomp-masscomp \
-	      | tandem-* | symmetric-* | drs6000-icl | *-*ardent | gould-gould \
-	      | concurrent-* | ksr1-* | esa-ibm | fxc-alliant | *370-amdahl \
-	      | *-convex | sx[45]*-nec )
-		;;
-	# END cases added for Bash
-
-	# Recognize the various machine names and aliases which stand
-	# for a CPU type and a company and sometimes even an OS.
-	386bsd)
-		basic_machine=i386-unknown
-		os=-bsd
-		;;
-	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
-		basic_machine=m68000-att
-		;;
-	3b*)
-		basic_machine=we32k-att
-		;;
-	a29khif)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	adobe68k)
-		basic_machine=m68010-adobe
-		os=-scout
-		;;
-	alliant | fx80)
-		basic_machine=fx80-alliant
-		;;
-	altos | altos3068)
-		basic_machine=m68k-altos
-		;;
-	am29k)
-		basic_machine=a29k-none
-		os=-bsd
-		;;
-	amdahl)
-		basic_machine=580-amdahl
-		os=-sysv
-		;;
-	amiga | amiga-*)
-#		basic_machine=m68k-cbm
-		basic_machine=m68k-unknown
-		;;
-	amigaos | amigados)
-		basic_machine=m68k-cbm
-		os=-amigaos
-		;;
-	amigaunix | amix)
-		basic_machine=m68k-cbm
-		os=-sysv4
-		;;
-	apollo68)
-		basic_machine=m68k-apollo
-		os=-sysv
-		;;
-	apollo68bsd)
-		basic_machine=m68k-apollo
-		os=-bsd
-		;;
-	aux)
-		basic_machine=m68k-apple
-		os=-aux
-		;;
-	balance)
-		basic_machine=ns32k-sequent
-		os=-dynix
-		;;
-	convex-c1)
-		basic_machine=c1-convex
-		os=-bsd
-		;;
-	convex-c2)
-		basic_machine=c2-convex
-		os=-bsd
-		;;
-	convex-c32)
-		basic_machine=c32-convex
-		os=-bsd
-		;;
-	convex-c34)
-		basic_machine=c34-convex
-		os=-bsd
-		;;
-	convex-c38)
-		basic_machine=c38-convex
-		os=-bsd
-		;;
-	cray | ymp)
-		basic_machine=ymp-cray
-		os=-unicos
-		;;
-	cray2)
-		basic_machine=cray2-cray
-		os=-unicos
-		;;
-	[ctj]90-cray)
-		basic_machine=c90-cray
-		os=-unicos
-		;;
-	crds | unos)
-		basic_machine=m68k-crds
-		;;
-	da30 | da30-*)
-		basic_machine=m68k-da30
-		;;
-	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
-		basic_machine=mips-dec
-		;;
-	delta | 3300 | motorola-3300 | motorola-delta \
-	      | 3300-motorola | delta-motorola)
-		basic_machine=m68k-motorola
-		;;
-	delta88)
-		basic_machine=m88k-motorola
-		os=-sysv3
-		;;
-	dpx20 | dpx20-*)
-		basic_machine=rs6000-bull
-		os=-bosx
-		;;
-	dpx2* | dpx2*-bull)
-		basic_machine=m68k-bull
-		os=-sysv3
-		;;
-	hbullx20-bull)
-		basic_machine=m68k-bull
-		;;
-	ebmon29k)
-		basic_machine=a29k-amd
-		os=-ebmon
-		;;
-	elxsi)
-		basic_machine=elxsi-elxsi
-		os=-bsd
-		;;
-	encore | umax | mmax | multimax)
-		basic_machine=ns32k-encore
-		;;
-	es1800 | OSE68k | ose68k | ose | OSE)
-		basic_machine=m68k-ericsson
-		os=-ose
-		;;
-	fx2800)
-		basic_machine=i860-alliant
-		;;
-	genix)
-		basic_machine=ns32k-ns
-		;;
-	gmicro)
-		basic_machine=tron-gmicro
-		os=-sysv
-		;;
-	h3050r* | hiux*)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	h8300hms)
-		basic_machine=h8300-hitachi
-		os=-hms
-		;;
-	h8300xray)
-		basic_machine=h8300-hitachi
-		os=-xray
-		;;
-	h8500hms)
-		basic_machine=h8500-hitachi
-		os=-hms
-		;;
-	harris)
-		basic_machine=m88k-harris
-		os=-sysv3
-		;;
-	hp300-*)
-		basic_machine=m68k-hp
-		;;
-	hp300bsd)
-		basic_machine=m68k-hp
-		os=-bsd
-		;;
-	hp300hpux)
-		basic_machine=m68k-hp
-		os=-hpux
-		;;
-	hp3k9[0-9][0-9] | hp9[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k2[0-9][0-9] | hp9k31[0-9])
-		basic_machine=m68000-hp
-		;;
-	hp9k3[2-9][0-9])
-		basic_machine=m68k-hp
-		;;
-	hp9k6[0-9][0-9] | hp6[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hp9k7[0-79][0-9] | hp7[0-79][0-9])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k78[0-9] | hp78[0-9])
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
-		# FIXME: really hppa2.0-hp
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][13679] | hp8[0-9][13679])
-		basic_machine=hppa1.1-hp
-		;;
-	hp9k8[0-9][0-9] | hp8[0-9][0-9])
-		basic_machine=hppa1.0-hp
-		;;
-	hppa-next)
-		os=-nextstep3
-		;;
-	hppaosf)
-		basic_machine=hppa1.1-hp
-		os=-osf
-		;;
-	hppro)
-		basic_machine=hppa1.1-hp
-		os=-proelf
-		;;
-	ibm032-*)
-		basic_machine=ibmrt-ibm
-		;;
-	i370-ibm* | ibm*)
-		basic_machine=i370-ibm
-		os=-mvs
-		;;
-# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
-	i[34567]86v32)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv32
-		;;
-	i[34567]86v4*)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv4
-		;;
-	i[34567]86v)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-sysv
-		;;
-	i[34567]86sol2)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
-		os=-solaris2
-		;;
-	i386mach)
-		basic_machine=i386-mach
-		os=-mach
-		;;
-	i386-vsta | vsta)
-		basic_machine=i386-unknown
-		os=-vsta
-		;;
-	i386-go32 | go32)
-		basic_machine=i386-unknown
-		os=-go32
-		;;
-	i386-mingw32 | mingw32)
-		basic_machine=i386-unknown
-		os=-mingw32
-		;;
-	iris | iris4d)
-		basic_machine=mips-sgi
-		case $os in
-		    -irix*)
-			;;
-		    *)
-			os=-irix4
-			;;
-		esac
-		;;
-	isi68 | isi)
-		basic_machine=m68k-isi
-		os=-sysv
-		;;
-	luna88k-omron* | m88k-omron*)
-		basic_machine=m88k-omron
-		;;
-	magicstation*)
-		basic_machine=magicstation-unknown
-		;;
-	magnum | m3230)
-		basic_machine=mips-mips
-		os=-sysv
-		;;
-	merlin)
-		basic_machine=ns32k-utek
-		os=-sysv
-		;;
-	miniframe)
-		basic_machine=m68000-convergent
-		;;
-	*mint | *MiNT)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
-	mipsel*-linux*)
-		basic_machine=mipsel-unknown
-		os=-linux-gnu
-		;;
-	mips*-linux*)
-		basic_machine=mips-unknown
-		os=-linux-gnu
-		;;
-	mips3*-*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
-		;;
-	mips3*)
-		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
-		;;
-	monitor)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
-	msdos)
-		basic_machine=i386-unknown
-		os=-msdos
-		;;
-	ncr3000)
-		basic_machine=i486-ncr
-		os=-sysv4
-		;;
-	netbsd386)
-		basic_machine=i386-unknown
-		os=-netbsd
-		;;
-	netwinder)
-		basic_machine=armv4l-corel
-		os=-linux
-		;;
-	news | news700 | news800 | news900)
-		basic_machine=m68k-sony
-		os=-newsos
-		;;
-	news1000)
-		basic_machine=m68030-sony
-		os=-newsos
-		;;
-	news-3600 | risc-news)
-		basic_machine=mips-sony
-		os=-newsos
-		;;
-        necv70)
-                basic_machine=v70-nec
-                os=-sysv
-                ;;
-	next | m*-next )
-		basic_machine=m68k-next
-		case $os in
-		    -nextstep* )
-			;;
-		    -ns2*)
-		      os=-nextstep2
-			;;
-		    *)
-		      os=-nextstep3
-			;;
-		esac
-		;;
-	nh3000)
-		basic_machine=m68k-harris
-		os=-cxux
-		;;
-	nh[45]000)
-		basic_machine=m88k-harris
-		os=-cxux
-		;;
-	nindy960)
-		basic_machine=i960-intel
-		os=-nindy
-		;;
-        mon960)
-                basic_machine=i960-intel
-                os=-mon960
-                ;;
-	np1)
-		basic_machine=np1-gould
-		;;
-	osr5 | sco5)	# SCO Open Server
-		basic_machine=i386-pc
-		os=-sco3.2v5
-		;;
-	odt | odt3 | odt4)	# SCO Open Desktop
-		basic_machine=i386-pc
-		os=-sco3.2v4
-		;;
-        op50n-* | op60c-*)
-                basic_machine=hppa1.1-oki
-                os=-proelf
-                ;;
-        OSE68000 | ose68000)
-                basic_machine=m68000-ericsson
-                os=-ose
-                ;;
-        os68k)
-                basic_machine=m68k-none
-                os=-os68k
-                ;;
-	pa-hitachi)
-		basic_machine=hppa1.1-hitachi
-		os=-hiuxwe2
-		;;
-	paragon)
-		basic_machine=i860-intel
-		os=-osf
-		;;
-	pbd)
-		basic_machine=sparc-tti
-		;;
-	pbb)
-		basic_machine=m68k-tti
-		;;
-	pc532 | pc532-*)
-		basic_machine=ns32k-pc532
-		;;
-	pentium | p5 | k5 | k6 | nexen)
-		basic_machine=i586-intel
-		;;
-        pentiumpro | p6 | 6x86)
-                basic_machine=i686-pc
-                ;;
-	pentiumii | pentium2)
-		basic_machine=i786-pc
-		;;
-	pentium-* | p5-* | k5-* | k6-* | nexen-*)
-		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumpro-* | p6-* | 6x86*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pentiumii-* | pentium2-*)
-		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	pn)
-		basic_machine=pn-gould
-		;;
-	power)	basic_machine=rs6000-ibm
-		;;
-	ppc)	basic_machine=powerpc-unknown
-		;;
-	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppcle | powerpclittle | ppc-le | powerpc-little)
-		basic_machine=powerpcle-unknown
-		;;
-	ppcle-* | powerpclittle-*)
-		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ps2)
-		basic_machine=i386-ibm
-		;;
-        rom68k)
-                basic_machine=m68k-rom68k
-                os=-coff
-                ;;
-	rm[46]00)
-		basic_machine=mips-siemens
-		;;
-	rtpc | rtpc-*)
-		basic_machine=romp-ibm
-		;;
-	s390-*)
-		basic_machine=s390-ibm
-		os=-linux
-		;;
-        sa29200)
-                basic_machine=a29k-amd
-                os=-udi
-                ;;
-	sequent)
-		basic_machine=i386-sequent
-		;;
-	sh)
-		basic_machine=sh-hitachi
-		os=-hms
-		;;
-        sparclite-wrs)
-                basic_machine=sparclite-wrs
-                os=-vxworks
-                ;;
-	sps7)
-		basic_machine=m68k-bull
-		os=-sysv2
-		;;
-	spur)
-		basic_machine=spur-unknown
-		;;
-        st2000)
-                basic_machine=m68k-tandem
-                ;;
-        stratus)
-                basic_machine=i860-stratus
-                os=-sysv4
-                ;;
-	sun2)
-		basic_machine=m68000-sun
-		;;
-	sun2os3)
-		basic_machine=m68000-sun
-		os=-sunos3
-		;;
-	sun2os4)
-		basic_machine=m68000-sun
-		os=-sunos4
-		;;
-	sun3os3)
-		basic_machine=m68k-sun
-		os=-sunos3
-		;;
-	sun3os4)
-		basic_machine=m68k-sun
-		os=-sunos4
-		;;
-	sun4os3)
-		basic_machine=sparc-sun
-		os=-sunos3
-		;;
-	sun4os4)
-		basic_machine=sparc-sun
-		os=-sunos4
-		;;
-	sun4sol2)
-		basic_machine=sparc-sun
-		os=-solaris2
-		;;
-	sun3 | sun3-*)
-		basic_machine=m68k-sun
-		;;
-	sun4)
-		basic_machine=sparc-sun
-		;;
-	sun386 | sun386i | roadrunner)
-		basic_machine=i386-sun
-		;;
-	symmetry)
-		basic_machine=i386-sequent
-		os=-dynix
-		;;
-        t3e)
-                basic_machine=t3e-cray
-                os=-unicos
-                ;;
-        tx39)
-                basic_machine=mipstx39-unknown
-                ;;
-        tx39el)
-                basic_machine=mipstx39el-unknown
-                ;;
-	tower | tower-32)
-		basic_machine=m68k-ncr
-		;;
-	udi29k)
-		basic_machine=a29k-amd
-		os=-udi
-		;;
-	ultra3)
-		basic_machine=a29k-nyu
-		os=-sym1
-		;;
-	uw2 | unixware | unixware2)
-		basic_machine=i386-pc
-		os=-sysv4.2uw2.1
-		;;
-	uw7 | unixware7)
-		basic_machine=i386-pc
-		os=-sysv5uw7
-		;;
-        v810 | necv810)
-                basic_machine=v810-nec
-                os=-none
-                ;;
-	vaxv)
-		basic_machine=vax-dec
-		os=-sysv
-		;;
-	vms)
-		basic_machine=vax-dec
-		os=-vms
-		;;
-	vpp*|vx|vx-*)
-		basic_machine=f301-fujitsu
-		;;
-	vxworks960)
-		basic_machine=i960-wrs
-		os=-vxworks
-		;;
-	vxworks68)
-		basic_machine=m68k-wrs
-		os=-vxworks
-		;;
-	vxworks29k)
-		basic_machine=a29k-wrs
-		os=-vxworks
-		;;
-        w65*)
-                basic_machine=w65-wdc
-                os=-none
-                ;;
-        w89k-*)
-                basic_machine=hppa1.1-winbond
-                os=-proelf
-                ;;
-	xmp)
-		basic_machine=xmp-cray
-		os=-unicos
-		;;
-	xps | xps100)
-		basic_machine=xps100-honeywell
-		;;
-        z8k-*-coff)
-                basic_machine=z8k-unknown
-                os=-sim
-                ;;
-	none)
-		basic_machine=none-none
-		os=-none
-		;;
-
-# Here we handle the default manufacturer of certain CPU types.  It is in
-# some cases the only manufacturer, in others, it is the most popular.
-        w89k)
-                basic_machine=hppa1.1-winbond
-                ;;
-        op50n)
-                basic_machine=hppa1.1-oki
-                ;;
-        op60c)
-                basic_machine=hppa1.1-oki
-                ;;
-	mips)
-		if test "x$os" = "x-linux-gnu" ; then
-			basic_machine=mips-unknown
-		else
-			basic_machine=mips-mips
-		fi
-		;;
-	romp)
-		basic_machine=romp-ibm
-		;;
-	rs6000)
-		basic_machine=rs6000-ibm
-		;;
-	vax)
-		basic_machine=vax-dec
-		;;
-	pdp11)
-		basic_machine=pdp11-dec
-		;;
-	we32k)
-		basic_machine=we32k-att
-		;;
-	sparc | sparcv9)
-		basic_machine=sparc-sun
-		;;
-	cydra)
-		basic_machine=cydra-cydrome
-		;;
-	orion)
-		basic_machine=orion-highlevel
-		;;
-	orion105)
-		basic_machine=clipper-highlevel
-		;;
-        mac | mpw | mac-mpw)
-                basic_machine=m68k-apple
-                ;;
-        pmac | pmac-mpw)
-                basic_machine=powerpc-apple
-                ;;
-        c4x*)
-                basic_machine=c4x-none
-                os=-coff
-                ;;
-	*)
-		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
-		exit 1
-		;;
-esac
-
-# Here we canonicalize certain aliases for manufacturers.
-case $basic_machine in
-	*-digital*)
-		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
-		;;
-	*-commodore*)
-		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
-		;;
-	*)
-		;;
-esac
-
-# Decode manufacturer-specific aliases for certain operating systems.
-
-if [ x"$os" != x"" ]
-then
-case $os in
-	# First match some system type aliases
-	# that might get confused with valid system types.
-	# -solaris* is a basic system type, with this one exception.
-	-solaris1 | -solaris1.*)
-		os=`echo $os | sed -e 's|solaris1|sunos4|'`
-		;;
-	-solaris)
-		os=-solaris2
-		;;
-	-svr4*)
-		os=-sysv4
-		;;
-	-unixware | -uw | -unixware2* | -uw2*)
-		os=-sysv4.2uw2.1
-		;;
-	-unixware7* | -uw7*)
-		os=-sysv5uw7
-		;;
-        -unixware*)
-                os=-sysv4.2uw
-		;;
-	-gnu/linux*)
-		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
-		;;
-	# First accept the basic system types.
-	# The portable systems comes first.
-	# Each alternative MUST END IN A *, to match a version number.
-	# -sysv* is not here because it comes later, after sysvr4.
-	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
-	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
-	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* \
-	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
-	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
-	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
-	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
-	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -rhapsody* | -openstep* | -oskit*)
-	# Remember, each alternative MUST END IN *, to match a version number.
-		;;
-	# BEGIN CASES ADDED FOR Bash
-	-qnx* | -powerux* | -superux* | -darwin* | -nonstopux*)
-		;;
-	# END CASES ADDED FOR Bash
-        -sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-              | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
-              | -macos* | -mpw* | -magic* | -mon960* | -lnews*)
-                ;;
-        -mac*)
-                os=`echo $os | sed -e 's|mac|macos|'`
-                ;;
-
-	-linux*)
-		os=`echo $os | sed -e 's|linux|linux-gnu|'`
-		;;
-	-sunos5*)
-		os=`echo $os | sed -e 's|sunos5|solaris2|'`
-		;;
-	-sunos6*)
-		os=`echo $os | sed -e 's|sunos6|solaris3|'`
-		;;
-	-osfrose*)
-		os=-osfrose
-		;;
-	-osf*)
-		os=-osf
-		;;
-	-utek*)
-		os=-bsd
-		;;
-	-dynix*)
-		os=-bsd
-		;;
-	-acis*)
-		os=-aos
-		;;
-        -386bsd)
-                os=-bsd
-                ;;
-	-ctix* | -uts*)
-		os=-sysv
-		;;
-	-ns2 )
-		os=-nextstep2
-		;;
-	# Preserve the version number of sinix5.
-	-sinix5.*)
-		os=`echo $os | sed -e 's|sinix|sysv|'`
-		;;
-	-sinix*)
-		os=-sysv4
-		;;
-	-triton*)
-		os=-sysv3
-		;;
-	-oss*)
-		os=-sysv3
-		;;
-	-svr4)
-		os=-sysv4
-		;;
-	-svr3)
-		os=-sysv3
-		;;
-	-sysvr4)
-		os=-sysv4
-		;;
-	-sysvr5)
-		os=-sysv5
-		;;
-	# This must come after -sysvr[45].
-	-sysv*)
-		;;
-        -ose*)
-                os=-ose
-                ;;
-        -es1800*)
-                os=-ose
-                ;;
-	-xenix)
-		os=-xenix
-		;;
-        -*mint | -*MiNT)
-                os=-mint
-                ;;
-	-none)
-		;;
-	*)
-		# Get rid of the `-' at the beginning of $os.
-		os=`echo $os | sed 's/[^-]*-//'`
-		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
-		exit 1
-		;;
-esac
-else
-
-# Here we handle the default operating systems that come with various machines.
-# The value should be what the vendor currently ships out the door with their
-# machine or put another way, the most popular os provided with the machine.
-
-# Note that if you're going to try to match "-MANUFACTURER" here (say,
-# "-sun"), then you have to tell the case statement up towards the top
-# that MANUFACTURER isn't an operating system.  Otherwise, code above
-# will signal an error saying that MANUFACTURER isn't an operating
-# system, and we'll never get to this point.
-
-case $basic_machine in
-	*-acorn)
-		os=-riscix1.2
-		;;
-	arm*-semi)
-		os=-aout
-		;;
-	pdp11-*)
-		os=-none
-		;;
-	*-dec | vax-*)
-		os=-ultrix4.2
-		;;
-	m68*-apollo)
-		os=-domain
-		;;
-	i386-sun)
-		os=-sunos4.0.2
-		;;
-	m68000-sun)
-		os=-sunos3
-		# This also exists in the configure program, but was not the
-		# default.
-		# os=-sunos4
-		;;
-        m68*-cisco)
-                os=-aout
-                ;;
-        mips*-cisco)
-                os=-elf
-                ;;
-        mips*-*)
-                os=-elf
-                ;;
-	*-tti)	# must be before sparc entry or we get the wrong os.
-		os=-sysv3
-		;;
-	sparc-* | *-sun)
-		os=-sunos4.1.1
-		;;
-	*-be)
-		os=-beos
-		;;
-	*-ibm)
-		os=-aix
-		;;
-        *-wec)
-                os=-proelf
-                ;;
-        *-winbond)
-                os=-proelf
-                ;;
-        *-oki)
-                os=-proelf
-                ;;
-	*-hp)
-		os=-hpux
-		;;
-	*-hitachi)
-		os=-hiux
-		;;
-	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
-		os=-sysv
-		;;
-	*-cbm)
-		os=-amigaos
-		;;
-	*-dg)
-		os=-dgux
-		;;
-	*-dolphin)
-		os=-sysv3
-		;;
-	m68k-ccur)
-		os=-rtu
-		;;
-	m88k-omron*)
-		os=-luna
-		;;
-	*-next )
-		os=-nextstep
-		;;
-	*-sequent)
-		os=-ptx
-		;;
-	*-crds)
-		os=-unos
-		;;
-	*-ns)
-		os=-genix
-		;;
-	i370-*)
-		os=-mvs
-		;;
-	*-next)
-		os=-nextstep3
-		;;
-	*-gould)
-		os=-sysv
-		;;
-	*-highlevel)
-		os=-bsd
-		;;
-	*-encore)
-		os=-bsd
-		;;
-	*-sgi)
-		os=-irix
-		;;
-	*-siemens)
-		os=-sysv4
-		;;
-	*-masscomp)
-		os=-rtu
-		;;
-	f301-fujitsu)
-		os=-uxpv
-		;;
-        *-rom68k)
-                os=-coff
-                ;;
-        *-*bug)
-                os=-coff
-                ;;
-        *-apple)
-                os=-macos
-                ;;
-        *-atari*)
-                os=-mint
-                ;;
-	*)
-		os=-none
-		;;
-esac
-fi
-
-# Here we handle the case where we know the os, and the CPU type, but not the
-# manufacturer.  We pick the logical manufacturer.
-vendor=unknown
-case $basic_machine in
-	*-unknown)
-		case $os in
-			-riscix*)
-				vendor=acorn
-				;;
-			-sunos*)
-				vendor=sun
-				;;
-			-lynxos*)
-				vendor=lynx
-				;;
-			-aix*)
-				vendor=ibm
-				;;
-                        -beos*)
-                                vendor=be
-                                ;;
-			-hpux*)
-				vendor=hp
-				;;
-			-hiux*)
-				vendor=hitachi
-				;;
-			-unos*)
-				vendor=crds
-				;;
-			-dgux*)
-				vendor=dg
-				;;
-			-luna*)
-				vendor=omron
-				;;
-			-genix*)
-				vendor=ns
-				;;
-			-mvs*)
-				vendor=ibm
-				;;
-			-ptx*)
-				vendor=sequent
-				;;
-			-vxsim* | -vxworks*)
-				vendor=wrs
-				;;
-			-aux*)
-				vendor=apple
-				;;
-                        -hms*)
-                                vendor=hitachi
-                                ;;
-                        -mpw* | -macos*)
-                                vendor=apple
-                                ;;
-                        -*mint | -*MiNT)
-                                vendor=atari
-                                ;;
-		esac
-		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
-		;;
-esac
-
-echo $basic_machine$os
diff --git a/readline/support/install.sh b/readline/support/install.sh
deleted file mode 100755
--- a/readline/support/install.sh
+++ /dev/null
@@ -1,235 +0,0 @@
-#!/bin/sh
-#
-# install - install a program, script, or datafile
-# This comes from X11R5.
-#
-# $XConsortium: install.sh,v 1.2 89/12/18 14:47:22 jim Exp $
-#
-# This script is compatible with the BSD install script, but was written
-# from scratch.
-#
-
-# set DOITPROG to echo to test this script
-
-# Don't use :- since 4.3BSD and earlier shells don't like it.
-doit="${DOITPROG-}"
-
-
-# put in absolute paths if you don't have them in your path; or use env. vars.
-
-mvprog="${MVPROG-mv}"
-cpprog="${CPPROG-cp}"
-chmodprog="${CHMODPROG-chmod}"
-chownprog="${CHOWNPROG-chown}"
-chgrpprog="${CHGRPPROG-chgrp}"
-stripprog="${STRIPPROG-strip}"
-rmprog="${RMPROG-rm}"
-mkdirprog="${MKDIRPROG-mkdir}"
-
-tranformbasename=""
-transform_arg=""
-instcmd="$mvprog"
-chmodcmd="$chmodprog 0755"
-chowncmd=""
-chgrpcmd=""
-stripcmd=""
-rmcmd="$rmprog -f"
-mvcmd="$mvprog"
-src=""
-dst=""
-dir_arg=""
-
-while [ x"$1" != x ]; do
-    case $1 in
-	-c) instcmd="$cpprog"
-	    shift
-	    continue;;
-
-	-d) dir_arg=true
-	    shift
-	    continue;;
-
-	-m) chmodcmd="$chmodprog $2"
-	    shift
-	    shift
-	    continue;;
-
-	-o) chowncmd="$chownprog $2"
-	    shift
-	    shift
-	    continue;;
-
-	-g) chgrpcmd="$chgrpprog $2"
-	    shift
-	    shift
-	    continue;;
-
-	-s) stripcmd="$stripprog"
-	    shift
-	    continue;;
-
-	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
-	    shift
-	    continue;;
-
-	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
-	    shift
-	    continue;;
-
-	*)  if [ x"$src" = x ]
-	    then
-		src=$1
-	    else
-		# this colon is to work around a 386BSD /bin/sh bug
-		:
-		dst=$1
-	    fi
-	    shift
-	    continue;;
-    esac
-done
-
-if [ x"$src" = x ]
-then
-	echo "install:	no input file specified"
-	exit 1
-else
-	true
-fi
-
-if [ x"$dir_arg" != x ]; then
-	dst=$src
-	src=""
-	
-	if [ -d $dst ]; then
-		instcmd=:
-	else
-		instcmd=mkdir
-	fi
-else
-
-# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
-# might cause directories to be created, which would be especially bad 
-# if $src (and thus $dsttmp) contains '*'.
-
-	if [ -f $src -o -d $src ]
-	then
-		true
-	else
-		echo "install:  $src does not exist"
-		exit 1
-	fi
-	
-	if [ x"$dst" = x ]
-	then
-		echo "install:	no destination specified"
-		exit 1
-	else
-		true
-	fi
-
-# If destination is a directory, append the input filename; if your system
-# does not like double slashes in filenames, you may need to add some logic
-
-	if [ -d $dst ]
-	then
-		dst="$dst"/`basename $src`
-	else
-		true
-	fi
-fi
-
-## this sed command emulates the dirname command
-dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
-
-# Make sure that the destination directory exists.
-#  this part is taken from Noah Friedman's mkinstalldirs script
-
-# Skip lots of stat calls in the usual case.
-if [ ! -d "$dstdir" ]; then
-defaultIFS='	
-'
-IFS="${IFS-${defaultIFS}}"
-
-oIFS="${IFS}"
-# Some sh's can't handle IFS=/ for some reason.
-IFS='%'
-set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
-IFS="${oIFS}"
-
-pathcomp=''
-
-while [ $# -ne 0 ] ; do
-	pathcomp="${pathcomp}${1}"
-	shift
-
-	if [ ! -d "${pathcomp}" ] ;
-        then
-		$mkdirprog "${pathcomp}"
-	else
-		true
-	fi
-
-	pathcomp="${pathcomp}/"
-done
-fi
-
-if [ x"$dir_arg" != x ]
-then
-	$doit $instcmd $dst &&
-
-	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
-	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
-	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
-	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
-else
-
-# If we're going to rename the final executable, determine the name now.
-
-	if [ x"$transformarg" = x ] 
-	then
-		dstfile=`basename $dst`
-	else
-		dstfile=`basename $dst $transformbasename | 
-			sed $transformarg`$transformbasename
-	fi
-
-# don't allow the sed command to completely eliminate the filename
-
-	if [ x"$dstfile" = x ] 
-	then
-		dstfile=`basename $dst`
-	else
-		true
-	fi
-
-# Make a temp file name in the proper directory.
-
-	dsttmp=$dstdir/#inst.$$#
-
-# Move or copy the file name to the temp name
-
-	$doit $instcmd $src $dsttmp &&
-
-	trap "rm -f ${dsttmp}" 0 &&
-
-# and set any options; do chmod last to preserve setuid bits
-
-# If any of these fail, we abort the whole thing.  If we want to
-# ignore errors from any of these, just make sure not to ignore
-# errors from the above "$doit $instcmd $src $dsttmp" command.
-
-	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
-	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
-	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
-	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
-
-# Now rename the file to the real destination.
-
-	$doit $rmcmd -f $dstdir/$dstfile &&
-	$doit $mvcmd $dsttmp $dstdir/$dstfile 
-
-fi &&
-
-
-exit 0
diff --git a/readline/support/mkdirs b/readline/support/mkdirs
deleted file mode 100755
--- a/readline/support/mkdirs
+++ /dev/null
@@ -1,32 +0,0 @@
-#! /bin/sh
-#
-# mkdirs - a work-alike for `mkdir -p'
-#
-# Chet Ramey
-# chet@po.cwru.edu
-
-for dir
-do
-
-	test -d "$dir" && continue
-
-	tomake=$dir
-	while test -n "$dir" ; do
-		# dir=${dir%/*}
-		# dir=`expr "$dir" ':' '\(/.*\)/[^/]*'`
-		if dir=`expr "$dir" ':' '\(.*\)/[^/]*'`; then
-			tomake="$dir $tomake"
-		else
-			dir=
-		fi
-	done
-
-	for d in $tomake
-	do
-		test -d "$d" && continue
-		echo mkdir "$d"
-		mkdir "$d"
-	done
-done
-
-exit 0
diff --git a/readline/support/mkdist b/readline/support/mkdist
deleted file mode 100755
--- a/readline/support/mkdist
+++ /dev/null
@@ -1,100 +0,0 @@
-#! /bin/bash -
-#
-# mkdist - make a distribution directory from a master manifest file
-#
-# usage: mkdist [-m manifest] [-s srcdir] [-r rootname] [-v] version
-#
-# SRCDIR defaults to src
-# MANIFEST defaults to $SRCDIR/MANIFEST
-#
-
-SRCDIR=src
-ROOTNAME=bash
-
-usage()
-{
-	echo usage: mkdist [-m manifest] [-s srcdir] [-r rootname] [-v] version 1>&2
-	exit 2
-}
-
-vmsg()
-{
-	if [ -n "$verbose" ]; then
-		echo mkdist: "$@"
-	fi
-}
-
-while getopts m:s:r:v name
-do
-	case $name in
-	m)	MANIFEST=$OPTARG ;;
-	s)	SRCDIR=$OPTARG ;;
-	r)	ROOTNAME=$OPTARG ;;
-	v)	verbose=yes ;;
-	?)	usage ;;
-	esac
-done
-
-: ${MANIFEST:=$SRCDIR/MANIFEST}
-
-vmsg using $MANIFEST
-
-shift $(( $OPTIND - 1 ))
-
-if [ $# -lt 1 ]; then
-	usage
-fi
-
-version=$1
-newdir=${ROOTNAME}-$version
-
-vmsg creating distribution for $ROOTNAME version $version in $newdir
-
-if [ ! -d $newdir ]; then
-	mkdir $newdir || { echo $0: cannot make directory $newdir 1>&2 ; exit 1; }
-fi
-
-dirmode=755
-filmode=644
-
-while read fname type mode
-do
-	[ -z "$fname" ] && continue
-
-	case "$fname" in
-	\#*)	continue ;;
-	esac
-
-	case "$type" in
-	d)	mkdir $newdir/$fname ;;
-	f)	cp -p $SRCDIR/$fname $newdir/$fname ;;
-	*)	echo "unknown file type $type" 1>&2 ;;
-	esac
-
-	if [ -n "$mode" ]; then
-		chmod $mode $newdir/$fname
-	fi
-
-done < $MANIFEST
-
-# cut off the `-alpha' in something like `2.0-alpha', leaving just the
-# numeric version
-#version=${version%%-*}
-
-#case "$version" in
-#*.*.*)	vers=${version%.*} ;;
-#*.*)	vers=${version} ;;
-#esac
-
-#echo $vers > $newdir/.distribution
-
-#case "$version" in
-#*.*.*)	plevel=${version##*.} ;;
-#*)	plevel=0 ;;
-#esac
-#[ -z "$plevel" ] && plevel=0
-#echo ${plevel} > $newdir/.patchlevel
-
-vmsg $newdir created
-
-exit 0
diff --git a/readline/support/shlib-install b/readline/support/shlib-install
deleted file mode 100755
--- a/readline/support/shlib-install
+++ /dev/null
@@ -1,152 +0,0 @@
-#! /bin/sh
-#
-# shlib-install - install a shared library and do any necessary host-specific
-#		  post-installation configuration (like ldconfig)
-#
-# usage: shlib-install [-D] -O host_os -d installation-dir -i install-prog [-U] library
-#
-# Chet Ramey
-# chet@po.cwru.edu
-
-#
-# defaults
-#
-INSTALLDIR=/usr/local/lib
-LDCONFIG=ldconfig
-
-PROGNAME=`basename $0`
-USAGE="$PROGNAME [-D] -O host_os -d installation-dir -i install-prog [-U] library"
-
-# process options
-
-while [ $# -gt 0 ]; do
-	case "$1" in
-	-O)	shift; host_os="$1"; shift ;;
-	-d)	shift; INSTALLDIR="$1"; shift ;;
-	-i)	shift; INSTALLPROG="$1" ; shift ;;
-	-D)	echo=echo ; shift ;;
-	-U)	uninstall=true ; shift ;;
-	-*)	echo "$USAGE" >&2 ; exit 2;;
-	*)	break ;;
-	esac
-done
-
-# set install target name
-LIBNAME="$1"
-
-if [ -z "$LIBNAME" ]; then
-	echo "$USAGE" >&2
-	exit 2
-fi
-
-OLDSUFF=old
-MV=mv
-RM="rm -f"
-LN="ln -s"
-
-# pre-install
-
-if [ -z "$uninstall" ]; then
-	${echo} $RM ${INSTALLDIR}/${LIBNAME}.${OLDSUFF}
-	if [ -f "$INSTALLDIR/$LIBNAME" ]; then
-		${echo} $MV $INSTALLDIR/$LIBNAME ${INSTALLDIR}/${LIBNAME}.${OLDSUFF}
-	fi
-fi
-
-# install/uninstall
-
-if [ -z "$uninstall" ] ; then
-	${echo} eval ${INSTALLPROG} $LIBNAME ${INSTALLDIR}/${LIBNAME}
-else
-	${echo} ${RM} ${INSTALLDIR}/${LIBNAME}
-fi
-
-# post-install/uninstall
-
-# HP-UX requires that a shared library have execute permission
-case "$host_os" in
-hpux*)	if [ -z "$uninstall" ]; then
-		chmod 555 ${INSTALLDIR}/${LIBNAME}
-	fi ;;
-*)	;;
-esac
-
-case "$LIBNAME" in
-*.*.[0-9].[0-9])	# libname.so.M.N
-	LINK2=`echo $LIBNAME | sed 's:\(.*\..*\.[0-9]\)\.[0-9]:\1:'`	# libname.so.M
-	LINK1=`echo $LIBNAME | sed 's:\(.*\..*\)\.[0-9]\.[0-9]:\1:'`	# libname.so
-	;;
-*.*.[0-9])		# libname.so.M
-	LINK1=`echo $LIBNAME | sed 's:\(.*\..*\)\.[0-9]:\1:'`		# libname.so
-	;;
-*.[0-9])		# libname.M
-	LINK1=`echo $LIBNAME | sed 's:\(.*\)\.[0-9]:\1:'`		# libname
-	;;
-esac
-
-INSTALL_LINK1='cd $INSTALLDIR ; ln -s $LIBNAME $LINK1'
-INSTALL_LINK2='cd $INSTALLDIR ; ln -s $LIBNAME $LINK2'
-
-#
-# Create symlinks to the installed library.  This section is incomplete.
-#
-case "$host_os" in
-*linux*|bsdi4*)
-	# libname.so.M -> libname.so.M.N
-	${echo} ${RM} ${INSTALLDIR}/$LINK2
-	if [ -z "$uninstall" ]; then
-		${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK2
-	fi
-
-	# libname.so -> libname.so.M.N
-	${echo} ${RM} ${INSTALLDIR}/$LINK1
-	if [ -z "$uninstall" ]; then
-		${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK1
-	fi
-	;;
-
-solaris2*|aix4.[2-9]*|osf*|irix[56]*)
-	# libname.so -> libname.so.M
-	${echo} ${RM} ${INSTALLDIR}/$LINK1
-	if [ -z "$uninstall" ]; then
-		${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK1
-	fi
-	;;
-
-
-# FreeBSD 3.x can have either a.out or ELF shared libraries
-freebsd3*)
-	if [ -x /usr/bin/objformat ] && [ "`/usr/bin/objformat`" = "elf" ]; then
-		# libname.so -> libname.so.M
-		${echo} ${RM} ${INSTALLDIR}/$LINK1
-		if [ -z "$uninstall" ]; then
-			${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK1
-		fi
-	else
-		# libname.so.M -> libname.so.M.N
-		${echo} ${RM} ${INSTALLDIR}/$LINK2
-		if [ -z "$uninstall" ]; then
-			${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK2
-		fi
-
-		# libname.so -> libname.so.M.N
-		${echo} ${RM} ${INSTALLDIR}/$LINK1
-		if [ -z "$uninstall" ]; then
-			${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK1
-		fi
-	fi
-	;;
-
-hpux1*)
-	# libname.sl -> libname.M
-	${echo} ${RM} ${INSTALLDIR}/$LINK1.sl
-	if [ -z "$uninstall" ]; then
-#		${echo} ln -s $LIBNAME ${INSTALLDIR}/${LINK1}.sl
-		${echo} ln -s $LIBNAME ${INSTALLDIR}/${LINK1}
-	fi
-	;;
-
-*)	;;
-esac
-
-exit 0
diff --git a/readline/support/shobj-conf b/readline/support/shobj-conf
deleted file mode 100755
--- a/readline/support/shobj-conf
+++ /dev/null
@@ -1,406 +0,0 @@
-#! /bin/sh
-#
-# shobj-conf -- output a series of variable assignments to be substituted
-#		into a Makefile by configure which specify system-dependent
-#		information for creating shared objects that may be loaded
-#		into bash with `enable -f'
-#
-# usage: shobj-conf [-C compiler] -c host_cpu -o host_os -v host_vendor
-#
-# Chet Ramey
-# chet@po.cwru.edu
-
-#
-# defaults
-#
-SHOBJ_STATUS=supported
-SHLIB_STATUS=supported
-
-SHOBJ_CC=cc
-SHOBJ_CFLAGS=
-SHOBJ_LD=
-SHOBJ_LDFLAGS=
-SHOBJ_XLDFLAGS=
-SHOBJ_LIBS=
-
-SHLIB_XLDFLAGS=
-SHLIB_LIBS=
-SHLIB_LIBSUFF='so'
-
-SHLIB_LIBVERSION='$(SHLIB_LIBSUFF)'
-
-PROGNAME=`basename $0`
-USAGE="$PROGNAME [-C compiler] -c host_cpu -o host_os -v host_vendor"
-
-while [ $# -gt 0 ]; do
-	case "$1" in
-	-C)	shift; SHOBJ_CC="$1"; shift ;;
-	-c)	shift; host_cpu="$1"; shift ;;
-	-o)	shift; host_os="$1"; shift ;;
-	-v)	shift; host_vendor="$1"; shift ;;
-	*)	echo "$USAGE" >&2 ; exit 2;;
-	esac
-done
-
-case "${host_os}-${SHOBJ_CC}" in
-sunos4*-*gcc*)
-	SHOBJ_CFLAGS=-fpic
-	SHOBJ_LD=/usr/bin/ld
-	SHOBJ_LDFLAGS='-assert pure-text'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
-	;;
-
-sunos4*)
-	SHOBJ_CFLAGS=-pic
-	SHOBJ_LD=/usr/bin/ld
-	SHOBJ_LDFLAGS='-assert pure-text'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
-	;;
-
-sunos5*-*gcc*|solaris2*-*gcc*)
-	SHOBJ_CFLAGS=-fpic
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared -Wl,-i -Wl,-h,$@'
-
-#	SHLIB_XLDFLAGS='-R $(libdir)'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-sunos5*|solaris2*)
-	SHOBJ_CFLAGS='-K pic'
-	SHOBJ_LD=/usr/ccs/bin/ld
-	SHOBJ_LDFLAGS='-G -dy -z text -i -h $@'
-
-#	SHLIB_XLDFLAGS='-R $(libdir)'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-freebsd2* | netbsd* | openbsd*)
-	SHOBJ_CFLAGS=-fpic
-	SHOBJ_LD=ld
-	SHOBJ_LDFLAGS='-x -Bshareable'
-
-	SHLIB_XLDFLAGS='-R$(libdir)'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
-	;;
-
-# FreeBSD-3.x can have either a.out or ELF object files
-#freebsd3*)
-#	SHOBJ_CFLAGS=-fpic
-#	SHOBJ_LD='${CC}'
-#	SHOBJ_LDFLAGS='-shared'
-#
-#	SHLIB_XLDFLAGS='-R$(libdir)'
-#	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
-#	;;
-
-# FreeBSD-3.x ELF
-freebsd[3-9]*|freebsdelf[3-9]*|freebsdaout[3-9]*)
-	SHOBJ_CFLAGS=-fpic
-	SHOBJ_LD='${CC}'
-
-	if [ -x /usr/bin/objformat ] && [ "`/usr/bin/objformat`" = "elf" ]; then
-		SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
-
-		SHLIB_XLDFLAGS='-Wl,-rpath,$(libdir)'
-		SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	else
-		SHOBJ_LDFLAGS='-shared'
-
-		SHLIB_XLDFLAGS='-R$(libdir)'
-		SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
-	fi
-	;;
-# All versions of Linux or the semi-mythical GNU Hurd.
-linux*|gnu*)
-	SHOBJ_CFLAGS=-fPIC
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
-
-	SHLIB_XLDFLAGS='-Wl,-rpath,$(libdir) -Wl,-soname,`basename $@ $(SHLIB_MINOR)`'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
-	;;
-
-bsdi2*)
-	SHOBJ_CC=shlicc2
-	SHOBJ_CFLAGS=
-	SHOBJ_LD=ld
-	SHOBJ_LDFLAGS=-r
-	SHOBJ_LIBS=-lc_s.2.1.0
-
-	# BSD/OS 2.x and 3.x `shared libraries' are too much of a pain in
-	# the ass -- they require changing {/usr/lib,etc}/shlib.map on
-	# each system, and the library creation process is byzantine
-	SHLIB_STATUS=unsupported
-	;;
-
-bsdi3*)
-	SHOBJ_CC=shlicc2
-	SHOBJ_CFLAGS=
-	SHOBJ_LD=ld
-	SHOBJ_LDFLAGS=-r
-	SHOBJ_LIBS=-lc_s.3.0.0
-
-	# BSD/OS 2.x and 3.x `shared libraries' are too much of a pain in
-	# the ass -- they require changing {/usr/lib,etc}/shlib.map on
-	# each system, and the library creation process is byzantine
-	SHLIB_STATUS=unsupported
-	;;
-
-bsdi4*)
-	# BSD/OS 4.x now supports ELF and SunOS-style dynamically-linked
-	# shared libraries.  gcc 2.x is the standard compiler, and the
-	# `normal' gcc options should work as they do in Linux.
-
-	SHOBJ_CFLAGS=-fPIC
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
-
-	SHLIB_XLDFLAGS='-Wl,-soname,`basename $@ $(SHLIB_MINOR)`'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
-	;;
-
-osf*-*gcc*)
-	# Fix to use gcc linker driver from bfischer@TechFak.Uni-Bielefeld.DE
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
-
-	SHLIB_XLDFLAGS='-rpath $(libdir)'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-osf*)
-	SHOBJ_LD=ld
-	SHOBJ_LDFLAGS='-shared -soname $@ -expect_unresolved "*"'
-
-	SHLIB_XLDFLAGS='-rpath $(libdir)'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-aix4.[2-9]*-*gcc*)		# lightly tested by jik@cisco.com
-	SHOBJ_CFLAGS=-fpic
-	SHOBJ_LD='ld'
-	SHOBJ_LDFLAGS='-bdynamic -bnoentry -bexpall'
-	SHOBJ_XLDFLAGS='-G'
-
-	SHLIB_XLDFLAGS='-bM:SRE'
-	SHLIB_LIBS='-lcurses -lc'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-aix4.[2-9]*)
-	SHOBJ_CFLAGS=-K
-	SHOBJ_LD='ld'
-	SHOBJ_LDFLAGS='-bdynamic -bnoentry -bexpall'
-	SHOBJ_XLDFLAGS='-G'
-
-	SHLIB_XLDFLAGS='-bM:SRE'
-	SHLIB_LIBS='-lcurses -lc'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-#
-# THE FOLLOWING ARE UNTESTED -- and some may not support the dlopen interface
-#
-irix[56]*-*gcc*)
-	SHOBJ_CFLAGS='-fpic'
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
-
-	SHLIB_XLDFLAGS='-Wl,-rpath,$(libdir)'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-irix[56]*)
-	SHOBJ_CFLAGS='-K PIC'
-	SHOBJ_LD=ld
-#	SHOBJ_LDFLAGS='-call_shared -hidden_symbol -no_unresolved -soname $@'
-#	Change from David Kaelbling <drk@sgi.com>.  If you have problems,
-#	remove the `-no_unresolved'
-	SHOBJ_LDFLAGS='-shared -no_unresolved -soname $@'
-
-	SHLIB_XLDFLAGS='-rpath $(libdir)'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-hpux9*-*gcc*)
-	# must use gcc; the bundled cc cannot compile PIC code
-	SHOBJ_CFLAGS='-fpic'
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared -Wl,-b -Wl,+s'
-
-	SHLIB_XLDFLAGS='-Wl,+b,$(libdir)'
-	SHLIB_LIBSUFF='sl'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-hpux9*)
-	SHOBJ_STATUS=unsupported
-	SHLIB_STATUS=unsupported
-	;;
-
-hpux10*-*gcc*)
-	# must use gcc; the bundled cc cannot compile PIC code
-	SHOBJ_CFLAGS='-fpic'
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared -Wl,-b -Wl,+s'
-
-	SHLIB_XLDFLAGS='-Wl,+h,$@ -Wl,+b,$(libdir)'
-	SHLIB_LIBSUFF='sl'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-hpux10*)
-	SHOBJ_STATUS=unsupported
-	SHLIB_STATUS=unsupported
-
-	# If you are using the HP ANSI C compiler, you can uncomment and use
-	# this code
-#	SHOBJ_STATUS=unsupported
-#	SHLIB_STATUS=unsupported
-#
-#	SHOBJ_CFLAGS='+z'
-#	SHOBJ_LD='ld'
-#	SHOBJ_LDFLAGS='-b'
-#
-#	SHLIB_XLDFLAGS=''
-#	SHLIB_LIBSUFF='sl'
-#	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
-	;;
-
-hpux11*-*gcc*)
-	# must use gcc; the bundled cc cannot compile PIC code
-	SHOBJ_CFLAGS='-fpic'
-	SHOBJ_LD='${CC}'
-#	SHOBJ_LDFLAGS='-shared -Wl,-b -Wl,-B,symbolic -Wl,+s -Wl,+std -Wl,+h,$@'
-	SHOBJ_LDFLAGS='-shared -fpic -Wl,-b -Wl,+s -Wl,+h,$@'
-
-	SHLIB_XLDFLAGS='-Wl,+b,$(libdir)'
-	SHLIB_LIBSUFF='sl'
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-hpux11*)
-	SHOBJ_STATUS=unsupported
-	SHLIB_STATUS=unsupported
-
-	# If you are using the HP ANSI C compiler, you can uncomment and use
-	# this code
-#	SHOBJ_STATUS=unsupported
-#	SHLIB_STATUS=unsupported
-#
-#	SHOBJ_CFLAGS='+z'
-#	SHOBJ_LD='ld'
-#	SHOBJ_LDFLAGS='-b'
-#
-#	SHLIB_XLDFLAGS=''
-#	SHLIB_LIBSUFF='sl'
-#	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
-
-	;;
-
-sysv4*-*gcc*)
-	SHOBJ_CFLAGS=-shared
-	SHOBJ_LDFLAGS='-shared -h $@'
-	SHOBJ_LD='${CC}'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-sysv4*)
-	SHOBJ_CFLAGS='-K PIC'
-	SHOBJ_LD=ld
-	SHOBJ_LDFLAGS='-dy -z text -G -h $@'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-sco3.2v5*-*gcc*)
-	SHOBJ_CFLAGS='-fpic'		# DEFAULTS TO ELF
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-sco3.2v5*)
-	SHOBJ_CFLAGS='-K pic -b elf'
-	SHOBJ_LD=ld
-	SHOBJ_LDFLAGS='-G -b elf -dy -z text -h $@'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-sysv5uw7*-*gcc*)
-	SHOBJ_CFLAGS='-fpic'
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-sysv5uw7*)
-	SHOBJ_CFLAGS='-K PIC'
-	SHOBJ_LD=ld
-	SHOBJ_LDFLAGS='-G -dy -z text -h $@'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-	
-dgux*-*gcc*)
-	SHOBJ_CFLAGS=-fpic
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-dgux*)
-	SHOBJ_CFLAGS='-K pic'
-	SHOBJ_LD=ld
-	SHOBJ_LDFLAGS='-G -dy -h $@'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-msdos*)
-	SHOBJ_STATUS=unsupported
-	SHLIB_STATUS=unsupported
-	;;
-
-#
-# Rely on correct gcc configuration for everything else
-#
-*-*gcc*)
-	SHOBJ_CFLAGS=-fpic
-	SHOBJ_LD='${CC}'
-	SHOBJ_LDFLAGS='-shared'
-
-	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
-	;;
-
-*)
-	SHOBJ_STATUS=unsupported
-	SHLIB_STATUS=unsupported
-	;;
-
-esac
-
-echo SHOBJ_CC=\'"$SHOBJ_CC"\'
-echo SHOBJ_CFLAGS=\'"$SHOBJ_CFLAGS"\'
-echo SHOBJ_LD=\'"$SHOBJ_LD"\'
-echo SHOBJ_LDFLAGS=\'"$SHOBJ_LDFLAGS"\'
-echo SHOBJ_XLDFLAGS=\'"$SHOBJ_XLDFLAGS"\'
-echo SHOBJ_LIBS=\'"$SHOBJ_LIBS"\'
-
-echo SHLIB_XLDFLAGS=\'"$SHLIB_XLDFLAGS"\'
-echo SHLIB_LIBS=\'"$SHLIB_LIBS"\'
-echo SHLIB_LIBSUFF=\'"$SHLIB_LIBSUFF"\'
-echo SHLIB_LIBVERSION=\'"$SHLIB_LIBVERSION"\'
-
-echo SHOBJ_STATUS=\'"$SHOBJ_STATUS"\'
-echo SHLIB_STATUS=\'"$SHLIB_STATUS"\'
-
-exit 0
diff --git a/readline/tcap.h b/readline/tcap.h
deleted file mode 100644
--- a/readline/tcap.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* tcap.h -- termcap library functions and variables. */
-
-/* Copyright (C) 1996 Free Software Foundation, Inc.
-
-   This file contains the Readline Library (the Library), a set of
-   routines for providing Emacs style line input to programs that ask
-   for it.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_RLTCAP_H_)
-#define _RLTCAP_H_
-
-#if defined (HAVE_CONFIG_H)
-#  include "config.h"
-#endif
-
-#if defined (HAVE_TERMCAP_H)
-#  if defined (__linux__) && !defined (SPEED_T_IN_SYS_TYPES)
-#    include "rltty.h"
-#  endif
-#  include <termcap.h>
-#else
-
-/* On Solaris2, sys/types.h #includes sys/reg.h, which #defines PC.
-   Unfortunately, PC is a global variable used by the termcap library. */
-#ifdef PC
-#  undef PC
-#endif
-
-extern char PC;
-extern char *UP, *BC;
-
-extern short ospeed;
-
-extern int tgetent ();
-extern int tgetflag ();
-extern int tgetnum ();
-extern char *tgetstr ();
-
-extern int tputs ();
-
-extern char *tgoto ();
-
-#endif /* HAVE_TERMCAP_H */
-
-#endif /* !_RLTCAP_H_ */
diff --git a/readline/terminal.c b/readline/terminal.c
deleted file mode 100644
--- a/readline/terminal.c
+++ /dev/null
@@ -1,607 +0,0 @@
-/* terminal.c -- controlling the terminal with termcap. */
-
-/* Copyright (C) 1996 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-#include "posixstat.h"
-#include <fcntl.h>
-#if defined (HAVE_SYS_FILE_H)
-#  include <sys/file.h>
-#endif /* HAVE_SYS_FILE_H */
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#if defined (HAVE_LOCALE_H)
-#  include <locale.h>
-#endif
-
-#include <stdio.h>
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-#if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
-#  include <sys/ioctl.h>
-#endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */
-
-#include "rltty.h"
-#include "tcap.h"
-
-/* Some standard library routines. */
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-#include "rlshell.h"
-
-/* **************************************************************** */
-/*								    */
-/*			Terminal and Termcap			    */
-/*								    */
-/* **************************************************************** */
-
-static char *term_buffer = (char *)NULL;
-static char *term_string_buffer = (char *)NULL;
-
-static int tcap_initialized;
-
-#if !defined (__linux__)
-#  if defined (__EMX__) || defined (NEED_EXTERN_PC)
-extern 
-#  endif /* __EMX__ || NEED_EXTERN_PC */
-char PC, *BC, *UP;
-#endif /* __linux__ */
-
-/* Some strings to control terminal actions.  These are output by tputs (). */
-char *_rl_term_clreol;
-char *_rl_term_clrpag;
-char *_rl_term_cr;
-char *_rl_term_backspace;
-char *_rl_term_goto;
-char *_rl_term_pc;
-
-/* Non-zero if we determine that the terminal can do character insertion. */
-int _rl_terminal_can_insert = 0;
-
-/* How to insert characters. */
-char *_rl_term_im;
-char *_rl_term_ei;
-char *_rl_term_ic;
-char *_rl_term_ip;
-char *_rl_term_IC;
-
-/* How to delete characters. */
-char *_rl_term_dc;
-char *_rl_term_DC;
-
-#if defined (HACK_TERMCAP_MOTION)
-char *_rl_term_forward_char;
-#endif  /* HACK_TERMCAP_MOTION */
-
-/* How to go up a line. */
-char *_rl_term_up;
-
-/* A visible bell; char if the terminal can be made to flash the screen. */
-static char *_rl_visible_bell;
-
-/* Non-zero means the terminal can auto-wrap lines. */
-int _rl_term_autowrap;
-
-/* Non-zero means that this terminal has a meta key. */
-static int term_has_meta;
-
-/* The sequences to write to turn on and off the meta key, if this
-   terminal has one. */
-static char *_rl_term_mm;
-static char *_rl_term_mo;
-
-/* The key sequences output by the arrow keys, if this terminal has any. */
-static char *_rl_term_ku;
-static char *_rl_term_kd;
-static char *_rl_term_kr;
-static char *_rl_term_kl;
-
-/* How to initialize and reset the arrow keys, if this terminal has any. */
-static char *_rl_term_ks;
-static char *_rl_term_ke;
-
-/* The key sequences sent by the Home and End keys, if any. */
-static char *_rl_term_kh;
-static char *_rl_term_kH;
-
-/* Variables that hold the screen dimensions, used by the display code. */
-int _rl_screenwidth, _rl_screenheight, _rl_screenchars;
-
-/* Non-zero means the user wants to enable the keypad. */
-int _rl_enable_keypad;
-
-/* Non-zero means the user wants to enable a meta key. */
-int _rl_enable_meta = 1;
-
-#if defined (__EMX__)
-static void
-_emx_get_screensize (swp, shp)
-     int *swp, *shp;
-{
-  int sz[2];
-
-  _scrsize (sz);
-
-  if (swp)
-    *swp = sz[0];
-  if (shp)
-    *shp = sz[1];
-}
-#endif
-
-/* Get readline's idea of the screen size.  TTY is a file descriptor open
-   to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
-   values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being
-   non-null serve to check whether or not we have initialized termcap. */
-void
-_rl_get_screen_size (tty, ignore_env)
-     int tty, ignore_env;
-{
-  char *ss;
-#if defined (TIOCGWINSZ)
-  struct winsize window_size;
-#endif /* TIOCGWINSZ */
-
-#if defined (TIOCGWINSZ)
-  if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)
-    {
-      _rl_screenwidth = (int) window_size.ws_col;
-      _rl_screenheight = (int) window_size.ws_row;
-    }
-#endif /* TIOCGWINSZ */
-
-#if defined (__EMX__)
-  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
-#endif
-
-  /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
-     is unset. */
-  if (_rl_screenwidth <= 0)
-    {
-      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
-	_rl_screenwidth = atoi (ss);
-
-#if !defined (__DJGPP__)
-      if (_rl_screenwidth <= 0 && term_string_buffer)
-	_rl_screenwidth = tgetnum ("co");
-#endif
-    }
-
-  /* Environment variable LINES overrides setting of "li" if IGNORE_ENV
-     is unset. */
-  if (_rl_screenheight <= 0)
-    {
-      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
-	_rl_screenheight = atoi (ss);
-
-#if !defined (__DJGPP__)
-      if (_rl_screenheight <= 0 && term_string_buffer)
-	_rl_screenheight = tgetnum ("li");
-#endif
-    }
-
-  /* If all else fails, default to 80x24 terminal. */
-  if (_rl_screenwidth <= 1)
-    _rl_screenwidth = 80;
-
-  if (_rl_screenheight <= 0)
-    _rl_screenheight = 24;
-
-  /* If we're being compiled as part of bash, set the environment
-     variables $LINES and $COLUMNS to new values.  Otherwise, just
-     do a pair of putenv () or setenv () calls. */
-  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);
-
-  if (_rl_term_autowrap == 0)
-    _rl_screenwidth--;
-
-  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
-}
-
-void
-_rl_set_screen_size (rows, cols)
-     int rows, cols;
-{
-  if (rows == 0 || cols == 0)
-    return;
-
-  _rl_screenheight = rows;
-  _rl_screenwidth = cols;
-
-  if (_rl_term_autowrap == 0)
-    _rl_screenwidth--;
-
-  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
-}
-
-void
-rl_set_screen_size (rows, cols)
-     int rows, cols;
-{
-  _rl_set_screen_size (rows, cols);
-}
-
-void
-rl_get_screen_size (rows, cols)
-     int *rows, *cols;
-{
-  if (rows)
-    *rows = _rl_screenheight;
-  if (cols)
-    *cols = _rl_screenwidth;
-}
-     
-void
-rl_resize_terminal ()
-{
-  if (readline_echoing_p)
-    {
-      _rl_get_screen_size (fileno (rl_instream), 1);
-      _rl_redisplay_after_sigwinch ();
-    }
-}
-
-struct _tc_string {
-     const char *tc_var;
-     char **tc_value;
-};
-
-/* This should be kept sorted, just in case we decide to change the
-   search algorithm to something smarter. */
-static struct _tc_string tc_strings[] =
-{
-  { "DC", &_rl_term_DC },
-  { "IC", &_rl_term_IC },
-  { "ce", &_rl_term_clreol },
-  { "cl", &_rl_term_clrpag },
-  { "cr", &_rl_term_cr },
-  { "dc", &_rl_term_dc },
-  { "ei", &_rl_term_ei },
-  { "ic", &_rl_term_ic },
-  { "im", &_rl_term_im },
-  { "kd", &_rl_term_kd },
-  { "kh", &_rl_term_kh },	/* home */
-  { "kH", &_rl_term_kH },	/* end */
-  { "kl", &_rl_term_kl },
-  { "kr", &_rl_term_kr },
-  { "ku", &_rl_term_ku },
-  { "ks", &_rl_term_ks },
-  { "ke", &_rl_term_ke },
-  { "le", &_rl_term_backspace },
-  { "mm", &_rl_term_mm },
-  { "mo", &_rl_term_mo },
-#if defined (HACK_TERMCAP_MOTION)
-  { "nd", &_rl_term_forward_char },
-#endif
-  { "pc", &_rl_term_pc },
-  { "up", &_rl_term_up },
-  { "vb", &_rl_visible_bell },
-};
-
-#define NUM_TC_STRINGS (sizeof (tc_strings) / sizeof (struct _tc_string))
-
-/* Read the desired terminal capability strings into BP.  The capabilities
-   are described in the TC_STRINGS table. */
-static void
-get_term_capabilities (bp)
-     char **bp;
-{
-#if !defined (__DJGPP__)	/* XXX - doesn't DJGPP have a termcap library? */
-  register int i;
-
-  for (i = 0; i < NUM_TC_STRINGS; i++)
-    *(tc_strings[i].tc_value) = tgetstr (tc_strings[i].tc_var, bp);
-#endif
-  tcap_initialized = 1;
-}
-
-#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
-#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)
-
-int
-_rl_init_terminal_io (terminal_name)
-     const char *terminal_name;
-{
-  const char *term;
-  char *buffer;
-  int tty, tgetent_ret;
-  Keymap xkeymap;
-
-  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
-  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
-  tty = rl_instream ? fileno (rl_instream) : 0;
-  _rl_screenwidth = _rl_screenheight = 0;
-
-  if (term == 0)
-    term = "dumb";
-
-  /* I've separated this out for later work on not calling tgetent at all
-     if the calling application has supplied a custom redisplay function,
-     (and possibly if the application has supplied a custom input function). */
-  if (CUSTOM_REDISPLAY_FUNC())
-    {
-      tgetent_ret = -1;
-    }
-  else
-    {
-      if (term_string_buffer == 0)
-	term_string_buffer = xmalloc(2032);
-
-      if (term_buffer == 0)
-	term_buffer = xmalloc(4080);
-
-      buffer = term_string_buffer;
-
-      tgetent_ret = tgetent (term_buffer, term);
-    }
-
-  if (tgetent_ret <= 0)
-    {
-      FREE (term_string_buffer);
-      FREE (term_buffer);
-      buffer = term_buffer = term_string_buffer = (char *)NULL;
-
-      _rl_term_autowrap = 0;	/* used by _rl_get_screen_size */
-
-#if defined (__EMX__)
-      _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
-      _rl_screenwidth--;
-#else /* !__EMX__ */
-      _rl_get_screen_size (tty, 0);
-#endif /* !__EMX__ */
-
-      /* Defaults. */
-      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
-        {
-	  _rl_screenwidth = 79;
-	  _rl_screenheight = 24;
-        }
-
-      /* Everything below here is used by the redisplay code (tputs). */
-      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
-      _rl_term_cr = "\r";
-      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
-      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
-      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
-      _rl_term_mm = _rl_term_mo = (char *)NULL;
-#if defined (HACK_TERMCAP_MOTION)
-      term_forward_char = (char *)NULL;
-#endif
-      _rl_terminal_can_insert = term_has_meta = 0;
-
-      /* Reasonable defaults for tgoto().  Readline currently only uses
-         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
-         change that later... */
-      PC = '\0';
-      BC = _rl_term_backspace = "\b";
-      UP = _rl_term_up;
-
-      return 0;
-    }
-
-  get_term_capabilities (&buffer);
-
-  /* Set up the variables that the termcap library expects the application
-     to provide. */
-  PC = _rl_term_pc ? *_rl_term_pc : 0;
-  BC = _rl_term_backspace;
-  UP = _rl_term_up;
-
-  if (!_rl_term_cr)
-    _rl_term_cr = "\r";
-
-  _rl_term_autowrap = tgetflag ("am") && tgetflag ("xn");
-
-  _rl_get_screen_size (tty, 0);
-
-  /* "An application program can assume that the terminal can do
-      character insertion if *any one of* the capabilities `IC',
-      `im', `ic' or `ip' is provided."  But we can't do anything if
-      only `ip' is provided, so... */
-  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);
-
-  /* Check to see if this terminal has a meta key and clear the capability
-     variables if there is none. */
-  term_has_meta = (tgetflag ("km") || tgetflag ("MT"));
-  if (!term_has_meta)
-    _rl_term_mm = _rl_term_mo = (char *)NULL;
-
-  /* Attempt to find and bind the arrow keys.  Do not override already
-     bound keys in an overzealous attempt, however. */
-  xkeymap = _rl_keymap;
-
-  _rl_keymap = emacs_standard_keymap;
-  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
-  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
-  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
-  _rl_bind_if_unbound (_rl_term_kl, rl_backward);
-
-  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
-  _rl_bind_if_unbound (_rl_term_kH, rl_end_of_line);	/* End */
-
-#if defined (VI_MODE)
-  _rl_keymap = vi_movement_keymap;
-  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
-  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
-  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
-  _rl_bind_if_unbound (_rl_term_kl, rl_backward);
-
-  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
-  _rl_bind_if_unbound (_rl_term_kH, rl_end_of_line);	/* End */
-#endif /* VI_MODE */
-
-  _rl_keymap = xkeymap;
-
-  return 0;
-}
-
-char *
-rl_get_termcap (cap)
-     const char *cap;
-{
-  register int i;
-
-  if (tcap_initialized == 0)
-    return ((char *)NULL);
-  for (i = 0; i < NUM_TC_STRINGS; i++)
-    {
-      if (tc_strings[i].tc_var[0] == cap[0] && strcmp (tc_strings[i].tc_var, cap) == 0)
-        return *(tc_strings[i].tc_value);
-    }
-  return ((char *)NULL);
-}
-
-/* Re-initialize the terminal considering that the TERM/TERMCAP variable
-   has changed. */
-int
-rl_reset_terminal (terminal_name)
-     const char *terminal_name;
-{
-  _rl_init_terminal_io (terminal_name);
-  return 0;
-}
-
-/* A function for the use of tputs () */
-#ifdef _MINIX
-void
-_rl_output_character_function (c)
-     int c;
-{
-  putc (c, _rl_out_stream);
-}
-#else /* !_MINIX */
-int
-_rl_output_character_function (c)
-     int c;
-{
-  return putc (c, _rl_out_stream);
-}
-#endif /* !_MINIX */
-
-/* Write COUNT characters from STRING to the output stream. */
-void
-_rl_output_some_chars (string, count)
-     const char *string;
-     int count;
-{
-  fwrite (string, 1, count, _rl_out_stream);
-}
-
-/* Move the cursor back. */
-int
-_rl_backspace (count)
-     int count;
-{
-  register int i;
-
-  if (_rl_term_backspace)
-    for (i = 0; i < count; i++)
-      tputs (_rl_term_backspace, 1, _rl_output_character_function);
-  else
-    for (i = 0; i < count; i++)
-      putc ('\b', _rl_out_stream);
-  return 0;
-}
-
-/* Move to the start of the next line. */
-int
-rl_crlf ()
-{
-#if defined (NEW_TTY_DRIVER)
-  if (_rl_term_cr)
-    tputs (_rl_term_cr, 1, _rl_output_character_function);
-#endif /* NEW_TTY_DRIVER */
-  putc ('\n', _rl_out_stream);
-  return 0;
-}
-
-/* Ring the terminal bell. */
-int
-rl_ding ()
-{
-  if (readline_echoing_p)
-    {
-      switch (_rl_bell_preference)
-        {
-	case NO_BELL:
-	default:
-	  break;
-	case VISIBLE_BELL:
-	  if (_rl_visible_bell)
-	    {
-	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
-	      break;
-	    }
-	  /* FALLTHROUGH */
-	case AUDIBLE_BELL:
-	  fprintf (stderr, "\007");
-	  fflush (stderr);
-	  break;
-        }
-      return (0);
-    }
-  return (-1);
-}
-
-/* **************************************************************** */
-/*								    */
-/*	 	Controlling the Meta Key and Keypad		    */
-/*								    */
-/* **************************************************************** */
-
-void
-_rl_enable_meta_key ()
-{
-#if !defined (__DJGPP__)
-  if (term_has_meta && _rl_term_mm)
-    tputs (_rl_term_mm, 1, _rl_output_character_function);
-#endif
-}
-
-void
-_rl_control_keypad (on)
-     int on;
-{
-#if !defined (__DJGPP__)
-  if (on && _rl_term_ks)
-    tputs (_rl_term_ks, 1, _rl_output_character_function);
-  else if (!on && _rl_term_ke)
-    tputs (_rl_term_ke, 1, _rl_output_character_function);
-#endif
-}
diff --git a/readline/tilde.c b/readline/tilde.c
deleted file mode 100644
--- a/readline/tilde.c
+++ /dev/null
@@ -1,456 +0,0 @@
-/* tilde.c -- Tilde expansion code (~/foo := $HOME/foo). */
-
-/* Copyright (C) 1988,1989 Free Software Foundation, Inc.
-
-   This file is part of GNU Readline, a library for reading lines
-   of text with interactive input and history editing.
-
-   Readline is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by the
-   Free Software Foundation; either version 2, or (at your option) any
-   later version.
-
-   Readline is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Readline; see the file COPYING.  If not, write to the Free
-   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#if defined (HAVE_UNISTD_H)
-#  ifdef _MINIX
-#    include <sys/types.h>
-#  endif
-#  include <unistd.h>
-#endif
-
-#if defined (HAVE_STRING_H)
-#  include <string.h>
-#else /* !HAVE_STRING_H */
-#  include <strings.h>
-#endif /* !HAVE_STRING_H */  
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include <sys/types.h>
-#include <pwd.h>
-
-#include "tilde.h"
-
-#if defined (TEST) || defined (STATIC_MALLOC)
-static char *xmalloc (), *xrealloc ();
-#else
-extern char *xmalloc __P((int));
-extern char *xrealloc __P((void *, int));
-#endif /* TEST || STATIC_MALLOC */
-
-#if !defined (HAVE_GETPW_DECLS)
-extern struct passwd *getpwuid __P((uid_t));
-extern struct passwd *getpwnam __P((const char *));
-#endif /* !HAVE_GETPW_DECLS */
-
-#if !defined (savestring)
-#  ifndef strcpy
-extern char *strcpy ();
-#  endif
-#define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
-#endif /* !savestring */
-
-#if !defined (NULL)
-#  if defined (__STDC__)
-#    define NULL ((void *) 0)
-#  else
-#    define NULL 0x0
-#  endif /* !__STDC__ */
-#endif /* !NULL */
-
-/* If being compiled as part of bash, these will be satisfied from
-   variables.o.  If being compiled as part of readline, they will
-   be satisfied from shell.o. */
-extern char *sh_get_home_dir __P((void));
-extern char *sh_get_env_value __P((const char *));
-
-/* The default value of tilde_additional_prefixes.  This is set to
-   whitespace preceding a tilde so that simple programs which do not
-   perform any word separation get desired behaviour. */
-static const char *default_prefixes[] =
-  { " ~", "\t~", (const char *)NULL };
-
-/* The default value of tilde_additional_suffixes.  This is set to
-   whitespace or newline so that simple programs which do not
-   perform any word separation get desired behaviour. */
-static const char *default_suffixes[] =
-  { " ", "\n", (const char *)NULL };
-
-/* If non-null, this contains the address of a function that the application
-   wants called before trying the standard tilde expansions.  The function
-   is called with the text sans tilde, and returns a malloc()'ed string
-   which is the expansion, or a NULL pointer if the expansion fails. */
-tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;
-
-/* If non-null, this contains the address of a function to call if the
-   standard meaning for expanding a tilde fails.  The function is called
-   with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
-   which is the expansion, or a NULL pointer if there is no expansion. */
-tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;
-
-/* When non-null, this is a NULL terminated array of strings which
-   are duplicates for a tilde prefix.  Bash uses this to expand
-   `=~' and `:~'. */
-char **tilde_additional_prefixes = (char **)default_prefixes;
-
-/* When non-null, this is a NULL terminated array of strings which match
-   the end of a username, instead of just "/".  Bash sets this to
-   `:' and `=~'. */
-char **tilde_additional_suffixes = (char **)default_suffixes;
-
-/* Find the start of a tilde expansion in STRING, and return the index of
-   the tilde which starts the expansion.  Place the length of the text
-   which identified this tilde starter in LEN, excluding the tilde itself. */
-static int
-tilde_find_prefix (string, len)
-     char *string;
-     int *len;
-{
-  register int i, j, string_len;
-  register char **prefixes;
-
-  prefixes = tilde_additional_prefixes;
-
-  string_len = strlen (string);
-  *len = 0;
-
-  if (*string == '\0' || *string == '~')
-    return (0);
-
-  if (prefixes)
-    {
-      for (i = 0; i < string_len; i++)
-	{
-	  for (j = 0; prefixes[j]; j++)
-	    {
-	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
-		{
-		  *len = strlen (prefixes[j]) - 1;
-		  return (i + *len);
-		}
-	    }
-	}
-    }
-  return (string_len);
-}
-
-/* Find the end of a tilde expansion in STRING, and return the index of
-   the character which ends the tilde definition.  */
-static int
-tilde_find_suffix (string)
-     char *string;
-{
-  register int i, j, string_len;
-  register char **suffixes;
-
-  suffixes = tilde_additional_suffixes;
-  string_len = strlen (string);
-
-  for (i = 0; i < string_len; i++)
-    {
-#if defined (__MSDOS__)
-      if (string[i] == '/' || string[i] == '\\' /* || !string[i] */)
-#else
-      if (string[i] == '/' /* || !string[i] */)
-#endif
-	break;
-
-      for (j = 0; suffixes && suffixes[j]; j++)
-	{
-	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
-	    return (i);
-	}
-    }
-  return (i);
-}
-
-/* Return a new string which is the result of tilde expanding STRING. */
-char *
-tilde_expand (string)
-     const char *string;
-{
-  char *result;
-  int result_size, result_index;
-
-  result_index = result_size = 0;
-  if (result = strchr (string, '~'))
-    result = xmalloc (result_size = (strlen (string) + 16));
-  else
-    result = xmalloc (result_size = (strlen (string) + 1));
-
-  /* Scan through STRING expanding tildes as we come to them. */
-  while (1)
-    {
-      register int start, end;
-      char *tilde_word, *expansion;
-      int len;
-
-      /* Make START point to the tilde which starts the expansion. */
-      start = tilde_find_prefix (string, &len);
-
-      /* Copy the skipped text into the result. */
-      if ((result_index + start + 1) > result_size)
-	result = xrealloc (result, 1 + (result_size += (start + 20)));
-
-      strncpy (result + result_index, string, start);
-      result_index += start;
-
-      /* Advance STRING to the starting tilde. */
-      string += start;
-
-      /* Make END be the index of one after the last character of the
-	 username. */
-      end = tilde_find_suffix (string);
-
-      /* If both START and END are zero, we are all done. */
-      if (!start && !end)
-	break;
-
-      /* Expand the entire tilde word, and copy it into RESULT. */
-      tilde_word = xmalloc (1 + end);
-      strncpy (tilde_word, string, end);
-      tilde_word[end] = '\0';
-      string += end;
-
-      expansion = tilde_expand_word (tilde_word);
-      free (tilde_word);
-
-      len = strlen (expansion);
-#ifdef __CYGWIN__
-      /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
-	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
-      if (len > 1 || *expansion != '/' || *string != '/')
-#endif
-	{
-	  if ((result_index + len + 1) > result_size)
-	    result = xrealloc (result, 1 + (result_size += (len + 20)));
-
-	  strcpy (result + result_index, expansion);
-	  result_index += len;
-	}
-      free (expansion);
-    }
-
-  result[result_index] = '\0';
-
-  return (result);
-}
-
-/* Take FNAME and return the tilde prefix we want expanded.  If LENP is
-   non-null, the index of the end of the prefix into FNAME is returned in
-   the location it points to. */
-static char *
-isolate_tilde_prefix (fname, lenp)
-     char *fname;
-     int *lenp;
-{
-  char *ret;
-  int i;
-
-  ret = xmalloc (strlen (fname));
-#if defined (__MSDOS__)
-  for (i = 1; fname[i] && fname[i] != '/' && fname[i] != '\\'; i++)
-#else
-  for (i = 1; fname[i] && fname[i] != '/'; i++)
-#endif
-    ret[i - 1] = fname[i];
-  ret[i - 1] = '\0';
-  if (lenp)
-    *lenp = i;
-  return ret;
-}
-
-/* Return a string that is PREFIX concatenated with SUFFIX starting at
-   SUFFIND. */
-static char *
-glue_prefix_and_suffix (prefix, suffix, suffind)
-     char *prefix, *suffix;
-     int suffind;
-{
-  char *ret;
-  int plen, slen;
-
-  plen = (prefix && *prefix) ? strlen (prefix) : 0;
-  slen = strlen (suffix + suffind);
-  ret = xmalloc (plen + slen + 1);
-  if (plen)
-    strcpy (ret, prefix);
-  strcpy (ret + plen, suffix + suffind);
-  return ret;
-}
-
-/* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
-   tilde.  If there is no expansion, call tilde_expansion_failure_hook.
-   This always returns a newly-allocated string, never static storage. */
-char *
-tilde_expand_word (filename)
-     const char *filename;
-{
-  char *dirname, *expansion, *username;
-  int user_len;
-  struct passwd *user_entry;
-
-  if (filename == 0)
-    return ((char *)NULL);
-
-  if (*filename != '~')
-    return (savestring (filename));
-
-  /* A leading `~/' or a bare `~' is *always* translated to the value of
-     $HOME or the home directory of the current user, regardless of any
-     preexpansion hook. */
-  if (filename[1] == '\0' || filename[1] == '/')
-    {
-      /* Prefix $HOME to the rest of the string. */
-      expansion = sh_get_env_value ("HOME");
-
-      /* If there is no HOME variable, look up the directory in
-	 the password database. */
-      if (expansion == 0)
-	expansion = sh_get_home_dir ();
-
-      return (glue_prefix_and_suffix (expansion, filename, 1));
-    }
-
-  username = isolate_tilde_prefix (filename, &user_len);
-
-  if (tilde_expansion_preexpansion_hook)
-    {
-      expansion = (*tilde_expansion_preexpansion_hook) (username);
-      if (expansion)
-	{
-	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
-	  free (username);
-	  free (expansion);
-	  return (dirname);
-	}
-    }
-
-  /* No preexpansion hook, or the preexpansion hook failed.  Look in the
-     password database. */
-  dirname = (char *)NULL;
-  user_entry = getpwnam (username);
-  if (user_entry == 0)
-    {
-      /* If the calling program has a special syntax for expanding tildes,
-	 and we couldn't find a standard expansion, then let them try. */
-      if (tilde_expansion_failure_hook)
-	{
-	  expansion = (*tilde_expansion_failure_hook) (username);
-	  if (expansion)
-	    {
-	      dirname = glue_prefix_and_suffix (expansion, filename, user_len);
-	      free (expansion);
-	    }
-	}
-      free (username);
-      /* If we don't have a failure hook, or if the failure hook did not
-	 expand the tilde, return a copy of what we were passed. */
-      if (dirname == 0)
-	dirname = savestring (filename);
-    }
-  else
-    {
-      free (username);
-      dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
-    }
-
-  endpwent ();
-  return (dirname);
-}
-
-
-#if defined (TEST)
-#undef NULL
-#include <stdio.h>
-
-main (argc, argv)
-     int argc;
-     char **argv;
-{
-  char *result, line[512];
-  int done = 0;
-
-  while (!done)
-    {
-      printf ("~expand: ");
-      fflush (stdout);
-
-      if (!gets (line))
-	strcpy (line, "done");
-
-      if ((strcmp (line, "done") == 0) ||
-	  (strcmp (line, "quit") == 0) ||
-	  (strcmp (line, "exit") == 0))
-	{
-	  done = 1;
-	  break;
-	}
-
-      result = tilde_expand (line);
-      printf ("  --> %s\n", result);
-      free (result);
-    }
-  exit (0);
-}
-
-static void memory_error_and_abort ();
-
-static char *
-xmalloc (bytes)
-     int bytes;
-{
-  char *temp = (char *)malloc (bytes);
-
-  if (!temp)
-    memory_error_and_abort ();
-  return (temp);
-}
-
-static char *
-xrealloc (pointer, bytes)
-     char *pointer;
-     int bytes;
-{
-  char *temp;
-
-  if (!pointer)
-    temp = (char *)malloc (bytes);
-  else
-    temp = (char *)realloc (pointer, bytes);
-
-  if (!temp)
-    memory_error_and_abort ();
-
-  return (temp);
-}
-
-static void
-memory_error_and_abort ()
-{
-  fprintf (stderr, "readline: out of virtual memory\n");
-  abort ();
-}
-
-/*
- * Local variables:
- * compile-command: "gcc -g -DTEST -o tilde tilde.c"
- * end:
- */
-#endif /* TEST */
diff --git a/readline/tilde.h b/readline/tilde.h
deleted file mode 100644
--- a/readline/tilde.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/* tilde.h: Externally available variables and function in libtilde.a. */
-
-/* Copyright (C) 1992 Free Software Foundation, Inc.
-
-   This file contains the Readline Library (the Library), a set of
-   routines for providing Emacs style line input to programs that ask
-   for it.
-
-   The Library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   The Library is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_TILDE_H_)
-#  define _TILDE_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* A function can be defined using prototypes and compile on both ANSI C
-   and traditional C compilers with something like this:
-	extern char *func __P((char *, char *, int)); */
-
-#if !defined (__P)
-#  if defined (__STDC__) || defined (__GNUC__) || defined (__cplusplus)
-#    define __P(protos) protos
-#  else
-#    define __P(protos) ()
-#  endif
-#endif
-
-#if !defined (__STDC__) && !defined (__cplusplus)
-#  if defined (__GNUC__)	/* gcc with -traditional */
-#    if !defined (const)
-#      define const __const
-#    endif /* !const */
-#  else /* !__GNUC__ */
-#    if !defined (const)
-#      define const
-#    endif /* !const */
-#  endif /* !__GNUC__ */
-#endif /* !__STDC__ && !__cplusplus */
-
-typedef char *tilde_hook_func_t __P((char *));
-
-/* If non-null, this contains the address of a function that the application
-   wants called before trying the standard tilde expansions.  The function
-   is called with the text sans tilde, and returns a malloc()'ed string
-   which is the expansion, or a NULL pointer if the expansion fails. */
-extern tilde_hook_func_t *tilde_expansion_preexpansion_hook;
-
-/* If non-null, this contains the address of a function to call if the
-   standard meaning for expanding a tilde fails.  The function is called
-   with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
-   which is the expansion, or a NULL pointer if there is no expansion. */
-extern tilde_hook_func_t *tilde_expansion_failure_hook;
-
-/* When non-null, this is a NULL terminated array of strings which
-   are duplicates for a tilde prefix.  Bash uses this to expand
-   `=~' and `:~'. */
-extern char **tilde_additional_prefixes;
-
-/* When non-null, this is a NULL terminated array of strings which match
-   the end of a username, instead of just "/".  Bash sets this to
-   `:' and `=~'. */
-extern char **tilde_additional_suffixes;
-
-/* Return a new string which is the result of tilde expanding STRING. */
-extern char *tilde_expand __P((const char *));
-
-/* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
-   tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
-extern char *tilde_expand_word __P((const char *));
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _TILDE_H_ */
diff --git a/readline/undo.c b/readline/undo.c
deleted file mode 100644
--- a/readline/undo.c
+++ /dev/null
@@ -1,264 +0,0 @@
-/* readline.c -- a general facility for reading lines of input
-   with emacs style editing and completion. */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>           /* for _POSIX_VERSION */
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include <stdio.h>
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-/* Some standard library routines. */
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-
-#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
-
-/* Non-zero tells rl_delete_text and rl_insert_text to not add to
-   the undo list. */
-int _rl_doing_an_undo = 0;
-
-/* How many unclosed undo groups we currently have. */
-int _rl_undo_group_level = 0;
-
-/* The current undo list for THE_LINE. */
-UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;
-
-/* **************************************************************** */
-/*								    */
-/*			Undo, and Undoing			    */
-/*								    */
-/* **************************************************************** */
-
-/* Remember how to undo something.  Concatenate some undos if that
-   seems right. */
-void
-rl_add_undo (what, start, end, text)
-     enum undo_code what;
-     int start, end;
-     char *text;
-{
-  UNDO_LIST *temp = (UNDO_LIST *)xmalloc (sizeof (UNDO_LIST));
-  temp->what = what;
-  temp->start = start;
-  temp->end = end;
-  temp->text = text;
-  temp->next = rl_undo_list;
-  rl_undo_list = temp;
-}
-
-/* Free the existing undo list. */
-void
-rl_free_undo_list ()
-{
-  while (rl_undo_list)
-    {
-      UNDO_LIST *release = rl_undo_list;
-      rl_undo_list = rl_undo_list->next;
-
-      if (release->what == UNDO_DELETE)
-	free (release->text);
-
-      free (release);
-    }
-  rl_undo_list = (UNDO_LIST *)NULL;
-}
-
-/* Undo the next thing in the list.  Return 0 if there
-   is nothing to undo, or non-zero if there was. */
-int
-rl_do_undo ()
-{
-  UNDO_LIST *release;
-  int waiting_for_begin, start, end;
-
-#define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))
-
-  start = end = waiting_for_begin = 0;
-  do
-    {
-      if (!rl_undo_list)
-	return (0);
-
-      _rl_doing_an_undo = 1;
-      RL_SETSTATE(RL_STATE_UNDOING);
-
-      /* To better support vi-mode, a start or end value of -1 means
-	 rl_point, and a value of -2 means rl_end. */
-      if (rl_undo_list->what == UNDO_DELETE || rl_undo_list->what == UNDO_INSERT)
-	{
-	  start = TRANS (rl_undo_list->start);
-	  end = TRANS (rl_undo_list->end);
-	}
-
-      switch (rl_undo_list->what)
-	{
-	/* Undoing deletes means inserting some text. */
-	case UNDO_DELETE:
-	  rl_point = start;
-	  rl_insert_text (rl_undo_list->text);
-	  free (rl_undo_list->text);
-	  break;
-
-	/* Undoing inserts means deleting some text. */
-	case UNDO_INSERT:
-	  rl_delete_text (start, end);
-	  rl_point = start;
-	  break;
-
-	/* Undoing an END means undoing everything 'til we get to a BEGIN. */
-	case UNDO_END:
-	  waiting_for_begin++;
-	  break;
-
-	/* Undoing a BEGIN means that we are done with this group. */
-	case UNDO_BEGIN:
-	  if (waiting_for_begin)
-	    waiting_for_begin--;
-	  else
-	    rl_ding ();
-	  break;
-	}
-
-      _rl_doing_an_undo = 0;
-      RL_UNSETSTATE(RL_STATE_UNDOING);
-
-      release = rl_undo_list;
-      rl_undo_list = rl_undo_list->next;
-      free (release);
-    }
-  while (waiting_for_begin);
-
-  return (1);
-}
-#undef TRANS
-
-int
-_rl_fix_last_undo_of_type (type, start, end)
-     int type, start, end;
-{
-  UNDO_LIST *rl;
-
-  for (rl = rl_undo_list; rl; rl = rl->next)
-    {
-      if (rl->what == type)
-	{
-	  rl->start = start;
-	  rl->end = end;
-	  return 0;
-	}
-    }
-  return 1;
-}
-
-/* Begin a group.  Subsequent undos are undone as an atomic operation. */
-int
-rl_begin_undo_group ()
-{
-  rl_add_undo (UNDO_BEGIN, 0, 0, 0);
-  _rl_undo_group_level++;
-  return 0;
-}
-
-/* End an undo group started with rl_begin_undo_group (). */
-int
-rl_end_undo_group ()
-{
-  rl_add_undo (UNDO_END, 0, 0, 0);
-  _rl_undo_group_level--;
-  return 0;
-}
-
-/* Save an undo entry for the text from START to END. */
-int
-rl_modifying (start, end)
-     int start, end;
-{
-  if (start > end)
-    {
-      SWAP (start, end);
-    }
-
-  if (start != end)
-    {
-      char *temp = rl_copy_text (start, end);
-      rl_begin_undo_group ();
-      rl_add_undo (UNDO_DELETE, start, end, temp);
-      rl_add_undo (UNDO_INSERT, start, end, (char *)NULL);
-      rl_end_undo_group ();
-    }
-  return 0;
-}
-
-/* Revert the current line to its previous state. */
-int
-rl_revert_line (count, key)
-     int count, key;
-{
-  if (!rl_undo_list)
-    rl_ding ();
-  else
-    {
-      while (rl_undo_list)
-	rl_do_undo ();
-    }
-  return 0;
-}
-
-/* Do some undoing of things that were done. */
-int
-rl_undo_command (count, key)
-     int count, key;
-{
-  if (count < 0)
-    return 0;	/* Nothing to do. */
-
-  while (count)
-    {
-      if (rl_do_undo ())
-	count--;
-      else
-	{
-	  rl_ding ();
-	  break;
-	}
-    }
-  return 0;
-}
diff --git a/readline/util.c b/readline/util.c
deleted file mode 100644
--- a/readline/util.c
+++ /dev/null
@@ -1,370 +0,0 @@
-/* util.c -- readline utility functions */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-#include <fcntl.h>
-#include "posixjmp.h"
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>           /* for _POSIX_VERSION */
-#endif /* HAVE_UNISTD_H */
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include <stdio.h>
-#include <ctype.h>
-
-/* System-specific feature definitions and include files. */
-#include "rldefs.h"
-
-#if defined (TIOCSTAT_IN_SYS_IOCTL)
-#  include <sys/ioctl.h>
-#endif /* TIOCSTAT_IN_SYS_IOCTL */
-
-/* Some standard library routines. */
-#include "readline.h"
-
-#include "rlprivate.h"
-#include "xmalloc.h"
-
-#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
-
-/* **************************************************************** */
-/*								    */
-/*			Utility Functions			    */
-/*								    */
-/* **************************************************************** */
-
-/* Return 0 if C is not a member of the class of characters that belong
-   in words, or 1 if it is. */
-
-int _rl_allow_pathname_alphabetic_chars = 0;
-static const char *pathname_alphabetic_chars = "/-_=~.#$";
-
-int
-rl_alphabetic (c)
-     int c;
-{
-  if (ALPHABETIC (c))
-    return (1);
-
-  return (_rl_allow_pathname_alphabetic_chars &&
-	    strchr (pathname_alphabetic_chars, c) != NULL);
-}
-
-/* How to abort things. */
-int
-_rl_abort_internal ()
-{
-  rl_ding ();
-  rl_clear_message ();
-  _rl_init_argument ();
-  rl_clear_pending_input ();
-
-  _rl_defining_kbd_macro = 0;
-  while (rl_executing_macro)
-    _rl_pop_executing_macro ();
-
-  rl_last_func = (rl_command_func_t *)NULL;
-  longjmp (readline_top_level, 1);
-  return (0);
-}
-
-int
-rl_abort (count, key)
-     int count, key;
-{
-  return (_rl_abort_internal ());
-}
-
-int
-rl_tty_status (count, key)
-     int count, key;
-{
-#if defined (TIOCSTAT)
-  ioctl (1, TIOCSTAT, (char *)0);
-  rl_refresh_line (count, key);
-#else
-  rl_ding ();
-#endif
-  return 0;
-}
-
-/* Return a copy of the string between FROM and TO.
-   FROM is inclusive, TO is not. */
-char *
-rl_copy_text (from, to)
-     int from, to;
-{
-  register int length;
-  char *copy;
-
-  /* Fix it if the caller is confused. */
-  if (from > to)
-    SWAP (from, to);
-
-  length = to - from;
-  copy = xmalloc (1 + length);
-  strncpy (copy, rl_line_buffer + from, length);
-  copy[length] = '\0';
-  return (copy);
-}
-
-/* Increase the size of RL_LINE_BUFFER until it has enough space to hold
-   LEN characters. */
-void
-rl_extend_line_buffer (len)
-     int len;
-{
-  while (len >= rl_line_buffer_len)
-    {
-      rl_line_buffer_len += DEFAULT_BUFFER_SIZE;
-      rl_line_buffer = xrealloc (rl_line_buffer, rl_line_buffer_len);
-    }
-
-  _rl_set_the_line ();
-}
-
-
-/* A function for simple tilde expansion. */
-int
-rl_tilde_expand (ignore, key)
-     int ignore, key;
-{
-  register int start, end;
-  char *homedir, *temp;
-  int len;
-
-  end = rl_point;
-  start = end - 1;
-
-  if (rl_point == rl_end && rl_line_buffer[rl_point] == '~')
-    {
-      homedir = tilde_expand ("~");
-      _rl_replace_text (homedir, start, end);
-      return (0);
-    }
-  else if (rl_line_buffer[start] != '~')
-    {
-      for (; !whitespace (rl_line_buffer[start]) && start >= 0; start--)
-        ;
-      start++;
-    }
-
-  end = start;
-  do
-    end++;
-  while (whitespace (rl_line_buffer[end]) == 0 && end < rl_end);
-
-  if (whitespace (rl_line_buffer[end]) || end >= rl_end)
-    end--;
-
-  /* If the first character of the current word is a tilde, perform
-     tilde expansion and insert the result.  If not a tilde, do
-     nothing. */
-  if (rl_line_buffer[start] == '~')
-    {
-      len = end - start + 1;
-      temp = xmalloc (len + 1);
-      strncpy (temp, rl_line_buffer + start, len);
-      temp[len] = '\0';
-      homedir = tilde_expand (temp);
-      free (temp);
-
-      _rl_replace_text (homedir, start, end);
-    }
-
-  return (0);
-}
-
-/* **************************************************************** */
-/*								    */
-/*			String Utility Functions		    */
-/*								    */
-/* **************************************************************** */
-
-/* Determine if s2 occurs in s1.  If so, return a pointer to the
-   match in s1.  The compare is case insensitive. */
-char *
-_rl_strindex (s1, s2)
-     register const char *s1, *s2;
-{
-  register int i, l, len;
-
-  for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)
-    if (_rl_strnicmp (s1 + i, s2, l) == 0)
-      return ((char *) (s1 + i));
-  return ((char *)NULL);
-}
-
-/* Find the first occurrence in STRING1 of any character from STRING2.
-   Return a pointer to the character in STRING1. */
-char *
-_rl_strpbrk (string1, string2)
-     const char *string1, *string2;
-{
-  register const char *scan;
-
-  for (; *string1; string1++)
-    {
-      for (scan = string2; *scan; scan++)
-	{
-	  if (*string1 == *scan)
-	    return ((char *)string1);
-	}
-    }
-  return ((char *)NULL);
-}
-
-#if !defined (HAVE_STRCASECMP)
-/* Compare at most COUNT characters from string1 to string2.  Case
-   doesn't matter. */
-int
-_rl_strnicmp (string1, string2, count)
-     char *string1, *string2;
-     int count;
-{
-  register char ch1, ch2;
-
-  while (count)
-    {
-      ch1 = *string1++;
-      ch2 = *string2++;
-      if (_rl_to_upper(ch1) == _rl_to_upper(ch2))
-	count--;
-      else
-        break;
-    }
-  return (count);
-}
-
-/* strcmp (), but caseless. */
-int
-_rl_stricmp (string1, string2)
-     char *string1, *string2;
-{
-  register char ch1, ch2;
-
-  while (*string1 && *string2)
-    {
-      ch1 = *string1++;
-      ch2 = *string2++;
-      if (_rl_to_upper(ch1) != _rl_to_upper(ch2))
-	return (1);
-    }
-  return (*string1 - *string2);
-}
-#endif /* !HAVE_STRCASECMP */
-
-/* Stupid comparison routine for qsort () ing strings. */
-int
-_rl_qsort_string_compare (s1, s2)
-  char **s1, **s2;
-{
-#if defined (HAVE_STRCOLL)
-  return (strcoll (*s1, *s2));
-#else
-  int result;
-
-  result = **s1 - **s2;
-  if (result == 0)
-    result = strcmp (*s1, *s2);
-
-  return result;
-#endif
-}
-
-/* Function equivalents for the macros defined in chartypes.h. */
-#undef _rl_uppercase_p
-int
-_rl_uppercase_p (c)
-     int c;
-{
-  return (isupper (c));
-}
-
-#undef _rl_lowercase_p
-int
-_rl_lowercase_p (c)
-     int c;
-{
-  return (islower (c));
-}
-
-#undef _rl_pure_alphabetic
-int
-_rl_pure_alphabetic (c)
-     int c;
-{
-  return (isupper (c) || islower (c));
-}
-
-#undef _rl_digit_p
-int
-_rl_digit_p (c)
-     int c;
-{
-  return (isdigit (c));
-}
-
-#undef _rl_to_lower
-int
-_rl_to_lower (c)
-     int c;
-{
-  return (isupper (c) ? tolower (c) : c);
-}
-
-#undef _rl_to_upper
-int
-_rl_to_upper (c)
-     int c;
-{
-  return (islower (c) ? toupper (c) : c);
-}
-
-#undef _rl_digit_value
-int
-_rl_digit_value (c)
-     int c;
-{
-  return (isdigit (c) ? c - '0' : c);
-}
-
-/* Backwards compatibility, now that savestring has been removed from
-   all `public' readline header files. */
-#undef _rl_savestring
-char *
-_rl_savestring (s)
-     const char *s;
-{
-  return (strcpy (xmalloc (1 + (int)strlen (s)), (s)));
-}
diff --git a/readline/vi_keymap.c b/readline/vi_keymap.c
deleted file mode 100644
--- a/readline/vi_keymap.c
+++ /dev/null
@@ -1,877 +0,0 @@
-/* vi_keymap.c -- the keymap for vi_mode in readline (). */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (BUFSIZ)
-#include <stdio.h>
-#endif /* !BUFSIZ */
-
-#include "readline.h"
-
-#if 0
-extern KEYMAP_ENTRY_ARRAY vi_escape_keymap;
-#endif
-
-/* The keymap arrays for handling vi mode. */
-KEYMAP_ENTRY_ARRAY vi_movement_keymap = {
-  /* The regular control keys come first. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
-  { ISFUNC, rl_vi_eof_maybe },			/* Control-d */
-  { ISFUNC, rl_emacs_editing_mode },		/* Control-e */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
-  { ISFUNC, rl_abort },				/* Control-g */
-  { ISFUNC, rl_backward },			/* Control-h */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
-  { ISFUNC, rl_newline },			/* Control-j */
-  { ISFUNC, rl_kill_line },			/* Control-k */
-  { ISFUNC, rl_clear_screen },			/* Control-l */
-  { ISFUNC, rl_newline },			/* Control-m */
-  { ISFUNC, rl_get_next_history },		/* Control-n */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
-  { ISFUNC, rl_get_previous_history },		/* Control-p */
-  { ISFUNC, rl_quoted_insert },			/* Control-q */
-  { ISFUNC, rl_reverse_search_history },	/* Control-r */
-  { ISFUNC, rl_forward_search_history },	/* Control-s */
-  { ISFUNC, rl_transpose_chars },		/* Control-t */
-  { ISFUNC, rl_unix_line_discard },		/* Control-u */
-  { ISFUNC, rl_quoted_insert },			/* Control-v */
-  { ISFUNC, rl_unix_word_rubout },		/* Control-w */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-x */
-  { ISFUNC, rl_yank },				/* Control-y */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
-
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-[ */	/* vi_escape_keymap */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
-  { ISFUNC, rl_vi_undo },			/* Control-_ */
-
-  /* The start of printing characters. */
-  { ISFUNC, rl_forward },			/* SPACE */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
-  { ISFUNC, rl_insert_comment },		/* # */
-  { ISFUNC, rl_end_of_line },			/* $ */
-  { ISFUNC, rl_vi_match },			/* % */
-  { ISFUNC, rl_vi_tilde_expand },		/* & */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ( */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ) */
-  { ISFUNC, rl_vi_complete },			/* * */
-  { ISFUNC, rl_get_next_history},		/* + */
-  { ISFUNC, rl_vi_char_search },		/* , */
-  { ISFUNC, rl_get_previous_history },		/* - */
-  { ISFUNC, rl_vi_redo },			/* . */
-  { ISFUNC, rl_vi_search },			/* / */
-
-  /* Regular digits. */
-  { ISFUNC, rl_beg_of_line },			/* 0 */
-  { ISFUNC, rl_vi_arg_digit },			/* 1 */
-  { ISFUNC, rl_vi_arg_digit },			/* 2 */
-  { ISFUNC, rl_vi_arg_digit },			/* 3 */
-  { ISFUNC, rl_vi_arg_digit },			/* 4 */
-  { ISFUNC, rl_vi_arg_digit },			/* 5 */
-  { ISFUNC, rl_vi_arg_digit },			/* 6 */
-  { ISFUNC, rl_vi_arg_digit },			/* 7 */
-  { ISFUNC, rl_vi_arg_digit },			/* 8 */
-  { ISFUNC, rl_vi_arg_digit },			/* 9 */
-
-  /* A little more punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
-  { ISFUNC, rl_vi_char_search },		/* ; */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
-  { ISFUNC, rl_vi_complete },			/* = */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
-  { ISFUNC, rl_vi_search },			/* ? */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
-
-  /* Uppercase alphabet. */
-  { ISFUNC, rl_vi_append_eol },			/* A */
-  { ISFUNC, rl_vi_prev_word},			/* B */
-  { ISFUNC, rl_vi_change_to },			/* C */
-  { ISFUNC, rl_vi_delete_to },			/* D */
-  { ISFUNC, rl_vi_end_word },			/* E */
-  { ISFUNC, rl_vi_char_search },		/* F */
-  { ISFUNC, rl_vi_fetch_history },		/* G */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* H */
-  { ISFUNC, rl_vi_insert_beg },			/* I */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* J */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* K */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* L */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* M */
-  { ISFUNC, rl_vi_search_again },		/* N */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* O */
-  { ISFUNC, rl_vi_put },			/* P */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Q */
-  { ISFUNC, rl_vi_replace },			/* R */
-  { ISFUNC, rl_vi_subst },			/* S */
-  { ISFUNC, rl_vi_char_search },		/* T */
-  { ISFUNC, rl_revert_line },			/* U */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* V */
-  { ISFUNC, rl_vi_next_word },			/* W */
-  { ISFUNC, rl_rubout },			/* X */
-  { ISFUNC, rl_vi_yank_to },			/* Y */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Z */
-
-  /* Some more punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* [ */
-  { ISFUNC, rl_vi_complete },			/* \ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
-  { ISFUNC, rl_vi_first_print },		/* ^ */
-  { ISFUNC, rl_vi_yank_arg },			/* _ */
-  { ISFUNC, rl_vi_goto_mark },			/* ` */
-
-  /* Lowercase alphabet. */
-  { ISFUNC, rl_vi_append_mode },		/* a */
-  { ISFUNC, rl_vi_prev_word },			/* b */
-  { ISFUNC, rl_vi_change_to },			/* c */
-  { ISFUNC, rl_vi_delete_to },			/* d */
-  { ISFUNC, rl_vi_end_word },			/* e */
-  { ISFUNC, rl_vi_char_search },		/* f */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
-  { ISFUNC, rl_backward },			/* h */
-  { ISFUNC, rl_vi_insertion_mode },		/* i */
-  { ISFUNC, rl_get_next_history },		/* j */
-  { ISFUNC, rl_get_previous_history },		/* k */
-  { ISFUNC, rl_forward },			/* l */
-  { ISFUNC, rl_vi_set_mark },			/* m */
-  { ISFUNC, rl_vi_search_again },		/* n */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
-  { ISFUNC, rl_vi_put },			/* p */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
-  { ISFUNC, rl_vi_change_char },		/* r */
-  { ISFUNC, rl_vi_subst },			/* s */
-  { ISFUNC, rl_vi_char_search },		/* t */
-  { ISFUNC, rl_vi_undo },			/* u */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
-  { ISFUNC, rl_vi_next_word },			/* w */
-  { ISFUNC, rl_vi_delete },			/* x */
-  { ISFUNC, rl_vi_yank_to },			/* y */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
-
-  /* Final punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
-  { ISFUNC, rl_vi_column },			/* | */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
-  { ISFUNC, rl_vi_change_case },		/* ~ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* RUBOUT */
-
-#if KEYMAP_SIZE > 128
-  /* Undefined keys. */
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 }
-#endif /* KEYMAP_SIZE > 128 */
-};
-
-
-KEYMAP_ENTRY_ARRAY vi_insertion_keymap = {
-  /* The regular control keys come first. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
-  { ISFUNC, rl_insert },			/* Control-a */
-  { ISFUNC, rl_insert },			/* Control-b */
-  { ISFUNC, rl_insert },			/* Control-c */
-  { ISFUNC, rl_vi_eof_maybe },			/* Control-d */
-  { ISFUNC, rl_insert },			/* Control-e */
-  { ISFUNC, rl_insert },			/* Control-f */
-  { ISFUNC, rl_insert },			/* Control-g */
-  { ISFUNC, rl_rubout },			/* Control-h */
-  { ISFUNC, rl_complete },			/* Control-i */
-  { ISFUNC, rl_newline },			/* Control-j */
-  { ISFUNC, rl_insert },			/* Control-k */
-  { ISFUNC, rl_insert },			/* Control-l */
-  { ISFUNC, rl_newline },			/* Control-m */
-  { ISFUNC, rl_insert },			/* Control-n */
-  { ISFUNC, rl_insert },			/* Control-o */
-  { ISFUNC, rl_insert },			/* Control-p */
-  { ISFUNC, rl_insert },			/* Control-q */
-  { ISFUNC, rl_reverse_search_history },	/* Control-r */
-  { ISFUNC, rl_forward_search_history },	/* Control-s */
-  { ISFUNC, rl_transpose_chars },		/* Control-t */
-  { ISFUNC, rl_unix_line_discard },		/* Control-u */
-  { ISFUNC, rl_quoted_insert },			/* Control-v */
-  { ISFUNC, rl_unix_word_rubout },		/* Control-w */
-  { ISFUNC, rl_insert },			/* Control-x */
-  { ISFUNC, rl_yank },				/* Control-y */
-  { ISFUNC, rl_insert },			/* Control-z */
-
-  { ISFUNC, rl_vi_movement_mode },		/* Control-[ */
-  { ISFUNC, rl_insert },			/* Control-\ */
-  { ISFUNC, rl_insert },			/* Control-] */
-  { ISFUNC, rl_insert },			/* Control-^ */
-  { ISFUNC, rl_vi_undo },			/* Control-_ */
-
-  /* The start of printing characters. */
-  { ISFUNC, rl_insert },			/* SPACE */
-  { ISFUNC, rl_insert },			/* ! */
-  { ISFUNC, rl_insert },			/* " */
-  { ISFUNC, rl_insert },			/* # */
-  { ISFUNC, rl_insert },			/* $ */
-  { ISFUNC, rl_insert },			/* % */
-  { ISFUNC, rl_insert },			/* & */
-  { ISFUNC, rl_insert },			/* ' */
-  { ISFUNC, rl_insert },			/* ( */
-  { ISFUNC, rl_insert },			/* ) */
-  { ISFUNC, rl_insert },			/* * */
-  { ISFUNC, rl_insert },			/* + */
-  { ISFUNC, rl_insert },			/* , */
-  { ISFUNC, rl_insert },			/* - */
-  { ISFUNC, rl_insert },			/* . */
-  { ISFUNC, rl_insert },			/* / */
-
-  /* Regular digits. */
-  { ISFUNC, rl_insert },			/* 0 */
-  { ISFUNC, rl_insert },			/* 1 */
-  { ISFUNC, rl_insert },			/* 2 */
-  { ISFUNC, rl_insert },			/* 3 */
-  { ISFUNC, rl_insert },			/* 4 */
-  { ISFUNC, rl_insert },			/* 5 */
-  { ISFUNC, rl_insert },			/* 6 */
-  { ISFUNC, rl_insert },			/* 7 */
-  { ISFUNC, rl_insert },			/* 8 */
-  { ISFUNC, rl_insert },			/* 9 */
-
-  /* A little more punctuation. */
-  { ISFUNC, rl_insert },			/* : */
-  { ISFUNC, rl_insert },			/* ; */
-  { ISFUNC, rl_insert },			/* < */
-  { ISFUNC, rl_insert },			/* = */
-  { ISFUNC, rl_insert },			/* > */
-  { ISFUNC, rl_insert },			/* ? */
-  { ISFUNC, rl_insert },			/* @ */
-
-  /* Uppercase alphabet. */
-  { ISFUNC, rl_insert },			/* A */
-  { ISFUNC, rl_insert },			/* B */
-  { ISFUNC, rl_insert },			/* C */
-  { ISFUNC, rl_insert },			/* D */
-  { ISFUNC, rl_insert },			/* E */
-  { ISFUNC, rl_insert },			/* F */
-  { ISFUNC, rl_insert },			/* G */
-  { ISFUNC, rl_insert },			/* H */
-  { ISFUNC, rl_insert },			/* I */
-  { ISFUNC, rl_insert },			/* J */
-  { ISFUNC, rl_insert },			/* K */
-  { ISFUNC, rl_insert },			/* L */
-  { ISFUNC, rl_insert },			/* M */
-  { ISFUNC, rl_insert },			/* N */
-  { ISFUNC, rl_insert },			/* O */
-  { ISFUNC, rl_insert },			/* P */
-  { ISFUNC, rl_insert },			/* Q */
-  { ISFUNC, rl_insert },			/* R */
-  { ISFUNC, rl_insert },			/* S */
-  { ISFUNC, rl_insert },			/* T */
-  { ISFUNC, rl_insert },			/* U */
-  { ISFUNC, rl_insert },			/* V */
-  { ISFUNC, rl_insert },			/* W */
-  { ISFUNC, rl_insert },			/* X */
-  { ISFUNC, rl_insert },			/* Y */
-  { ISFUNC, rl_insert },			/* Z */
-
-  /* Some more punctuation. */
-  { ISFUNC, rl_insert },			/* [ */
-  { ISFUNC, rl_insert },			/* \ */
-  { ISFUNC, rl_insert },			/* ] */
-  { ISFUNC, rl_insert },			/* ^ */
-  { ISFUNC, rl_insert },			/* _ */
-  { ISFUNC, rl_insert },			/* ` */
-
-  /* Lowercase alphabet. */
-  { ISFUNC, rl_insert },			/* a */
-  { ISFUNC, rl_insert },			/* b */
-  { ISFUNC, rl_insert },			/* c */
-  { ISFUNC, rl_insert },			/* d */
-  { ISFUNC, rl_insert },			/* e */
-  { ISFUNC, rl_insert },			/* f */
-  { ISFUNC, rl_insert },			/* g */
-  { ISFUNC, rl_insert },			/* h */
-  { ISFUNC, rl_insert },			/* i */
-  { ISFUNC, rl_insert },			/* j */
-  { ISFUNC, rl_insert },			/* k */
-  { ISFUNC, rl_insert },			/* l */
-  { ISFUNC, rl_insert },			/* m */
-  { ISFUNC, rl_insert },			/* n */
-  { ISFUNC, rl_insert },			/* o */
-  { ISFUNC, rl_insert },			/* p */
-  { ISFUNC, rl_insert },			/* q */
-  { ISFUNC, rl_insert },			/* r */
-  { ISFUNC, rl_insert },			/* s */
-  { ISFUNC, rl_insert },			/* t */
-  { ISFUNC, rl_insert },			/* u */
-  { ISFUNC, rl_insert },			/* v */
-  { ISFUNC, rl_insert },			/* w */
-  { ISFUNC, rl_insert },			/* x */
-  { ISFUNC, rl_insert },			/* y */
-  { ISFUNC, rl_insert },			/* z */
-
-  /* Final punctuation. */
-  { ISFUNC, rl_insert },			/* { */
-  { ISFUNC, rl_insert },			/* | */
-  { ISFUNC, rl_insert },			/* } */
-  { ISFUNC, rl_insert },			/* ~ */
-  { ISFUNC, rl_rubout },			/* RUBOUT */
-
-#if KEYMAP_SIZE > 128
-  /* Pure 8-bit characters (128 - 159).
-     These might be used in some
-     character sets. */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-
-  /* ISO Latin-1 characters (160 - 255) */
-  { ISFUNC, rl_insert },	/* No-break space */
-  { ISFUNC, rl_insert },	/* Inverted exclamation mark */
-  { ISFUNC, rl_insert },	/* Cent sign */
-  { ISFUNC, rl_insert },	/* Pound sign */
-  { ISFUNC, rl_insert },	/* Currency sign */
-  { ISFUNC, rl_insert },	/* Yen sign */
-  { ISFUNC, rl_insert },	/* Broken bar */
-  { ISFUNC, rl_insert },	/* Section sign */
-  { ISFUNC, rl_insert },	/* Diaeresis */
-  { ISFUNC, rl_insert },	/* Copyright sign */
-  { ISFUNC, rl_insert },	/* Feminine ordinal indicator */
-  { ISFUNC, rl_insert },	/* Left pointing double angle quotation mark */
-  { ISFUNC, rl_insert },	/* Not sign */
-  { ISFUNC, rl_insert },	/* Soft hyphen */
-  { ISFUNC, rl_insert },	/* Registered sign */
-  { ISFUNC, rl_insert },	/* Macron */
-  { ISFUNC, rl_insert },	/* Degree sign */
-  { ISFUNC, rl_insert },	/* Plus-minus sign */
-  { ISFUNC, rl_insert },	/* Superscript two */
-  { ISFUNC, rl_insert },	/* Superscript three */
-  { ISFUNC, rl_insert },	/* Acute accent */
-  { ISFUNC, rl_insert },	/* Micro sign */
-  { ISFUNC, rl_insert },	/* Pilcrow sign */
-  { ISFUNC, rl_insert },	/* Middle dot */
-  { ISFUNC, rl_insert },	/* Cedilla */
-  { ISFUNC, rl_insert },	/* Superscript one */
-  { ISFUNC, rl_insert },	/* Masculine ordinal indicator */
-  { ISFUNC, rl_insert },	/* Right pointing double angle quotation mark */
-  { ISFUNC, rl_insert },	/* Vulgar fraction one quarter */
-  { ISFUNC, rl_insert },	/* Vulgar fraction one half */
-  { ISFUNC, rl_insert },	/* Vulgar fraction three quarters */
-  { ISFUNC, rl_insert },	/* Inverted questionk mark */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with tilde */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin capital letter a with ring above */
-  { ISFUNC, rl_insert },	/* Latin capital letter ae */
-  { ISFUNC, rl_insert },	/* Latin capital letter c with cedilla */
-  { ISFUNC, rl_insert },	/* Latin capital letter e with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter e with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter e with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter e with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin capital letter i with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter i with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter i with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter i with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin capital letter eth (Icelandic) */
-  { ISFUNC, rl_insert },	/* Latin capital letter n with tilde */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with tilde */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with diaeresis */
-  { ISFUNC, rl_insert },	/* Multiplication sign */
-  { ISFUNC, rl_insert },	/* Latin capital letter o with stroke */
-  { ISFUNC, rl_insert },	/* Latin capital letter u with grave */
-  { ISFUNC, rl_insert },	/* Latin capital letter u with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter u with circumflex */
-  { ISFUNC, rl_insert },	/* Latin capital letter u with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin capital letter Y with acute */
-  { ISFUNC, rl_insert },	/* Latin capital letter thorn (Icelandic) */
-  { ISFUNC, rl_insert },	/* Latin small letter sharp s (German) */
-  { ISFUNC, rl_insert },	/* Latin small letter a with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter a with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter a with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter a with tilde */
-  { ISFUNC, rl_insert },	/* Latin small letter a with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin small letter a with ring above */
-  { ISFUNC, rl_insert },	/* Latin small letter ae */
-  { ISFUNC, rl_insert },	/* Latin small letter c with cedilla */
-  { ISFUNC, rl_insert },	/* Latin small letter e with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter e with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter e with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter e with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin small letter i with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter i with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter i with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter i with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin small letter eth (Icelandic) */
-  { ISFUNC, rl_insert },	/* Latin small letter n with tilde */
-  { ISFUNC, rl_insert },	/* Latin small letter o with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter o with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter o with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter o with tilde */
-  { ISFUNC, rl_insert },	/* Latin small letter o with diaeresis */
-  { ISFUNC, rl_insert },	/* Division sign */
-  { ISFUNC, rl_insert },	/* Latin small letter o with stroke */
-  { ISFUNC, rl_insert },	/* Latin small letter u with grave */
-  { ISFUNC, rl_insert },	/* Latin small letter u with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter u with circumflex */
-  { ISFUNC, rl_insert },	/* Latin small letter u with diaeresis */
-  { ISFUNC, rl_insert },	/* Latin small letter y with acute */
-  { ISFUNC, rl_insert },	/* Latin small letter thorn (Icelandic) */
-  { ISFUNC, rl_insert }		/* Latin small letter y with diaeresis */
-#endif /* KEYMAP_SIZE > 128 */
-};
-
-/* Unused for the time being. */
-#if 0
-KEYMAP_ENTRY_ARRAY vi_escape_keymap = {
-  /* The regular control keys come first. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-d */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-e */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-g */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-h */
-  { ISFUNC, rl_tab_insert},			/* Control-i */
-  { ISFUNC, rl_emacs_editing_mode},		/* Control-j */
-  { ISFUNC, rl_kill_line },			/* Control-k */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-l */
-  { ISFUNC, rl_emacs_editing_mode},		/* Control-m */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-n */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-p */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-q */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-r */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-s */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-t */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-u */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-v */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-w */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-x */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-y */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
-
-  { ISFUNC, rl_vi_movement_mode },		/* Control-[ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
-  { ISFUNC, rl_vi_undo },			/* Control-_ */
-
-  /* The start of printing characters. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* SPACE */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* # */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* $ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* % */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* & */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ( */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ) */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* * */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* + */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* , */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* - */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* . */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* / */
-
-  /* Regular digits. */
-  { ISFUNC, rl_vi_arg_digit },			/* 0 */
-  { ISFUNC, rl_vi_arg_digit },			/* 1 */
-  { ISFUNC, rl_vi_arg_digit },			/* 2 */
-  { ISFUNC, rl_vi_arg_digit },			/* 3 */
-  { ISFUNC, rl_vi_arg_digit },			/* 4 */
-  { ISFUNC, rl_vi_arg_digit },			/* 5 */
-  { ISFUNC, rl_vi_arg_digit },			/* 6 */
-  { ISFUNC, rl_vi_arg_digit },			/* 7 */
-  { ISFUNC, rl_vi_arg_digit },			/* 8 */
-  { ISFUNC, rl_vi_arg_digit },			/* 9 */
-
-  /* A little more punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ; */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* = */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ? */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
-
-  /* Uppercase alphabet. */
-  { ISFUNC, rl_do_lowercase_version },		/* A */
-  { ISFUNC, rl_do_lowercase_version },		/* B */
-  { ISFUNC, rl_do_lowercase_version },		/* C */
-  { ISFUNC, rl_do_lowercase_version },		/* D */
-  { ISFUNC, rl_do_lowercase_version },		/* E */
-  { ISFUNC, rl_do_lowercase_version },		/* F */
-  { ISFUNC, rl_do_lowercase_version },		/* G */
-  { ISFUNC, rl_do_lowercase_version },		/* H */
-  { ISFUNC, rl_do_lowercase_version },		/* I */
-  { ISFUNC, rl_do_lowercase_version },		/* J */
-  { ISFUNC, rl_do_lowercase_version },		/* K */
-  { ISFUNC, rl_do_lowercase_version },		/* L */
-  { ISFUNC, rl_do_lowercase_version },		/* M */
-  { ISFUNC, rl_do_lowercase_version },		/* N */
-  { ISFUNC, rl_do_lowercase_version },		/* O */
-  { ISFUNC, rl_do_lowercase_version },		/* P */
-  { ISFUNC, rl_do_lowercase_version },		/* Q */
-  { ISFUNC, rl_do_lowercase_version },		/* R */
-  { ISFUNC, rl_do_lowercase_version },		/* S */
-  { ISFUNC, rl_do_lowercase_version },		/* T */
-  { ISFUNC, rl_do_lowercase_version },		/* U */
-  { ISFUNC, rl_do_lowercase_version },		/* V */
-  { ISFUNC, rl_do_lowercase_version },		/* W */
-  { ISFUNC, rl_do_lowercase_version },		/* X */
-  { ISFUNC, rl_do_lowercase_version },		/* Y */
-  { ISFUNC, rl_do_lowercase_version },		/* Z */
-
-  /* Some more punctuation. */
-  { ISFUNC, rl_arrow_keys },			/* [ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* \ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ^ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* _ */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ` */
-
-  /* Lowercase alphabet. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* a */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* b */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* c */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* d */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* e */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* f */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* h */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* i */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* j */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* k */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* l */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* m */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* n */
-  { ISFUNC, rl_arrow_keys },			/* o */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* p */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* r */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* s */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* t */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* u */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* w */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* x */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* y */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
-
-  /* Final punctuation. */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* | */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
-  { ISFUNC, (rl_command_func_t *)0x0 },		/* ~ */
-  { ISFUNC, rl_backward_kill_word },		/* RUBOUT */
-
-#if KEYMAP_SIZE > 128
-  /* Undefined keys. */
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 },
-  { ISFUNC, (rl_command_func_t *)0x0 }
-#endif /* KEYMAP_SIZE > 128 */
-};
-#endif
diff --git a/readline/vi_mode.c b/readline/vi_mode.c
deleted file mode 100644
--- a/readline/vi_mode.c
+++ /dev/null
@@ -1,1400 +0,0 @@
-/* vi_mode.c -- A vi emulation mode for Bash.
-   Derived from code written by Jeff Sparkes (jsparkes@bnr.ca).  */
-
-/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-/* **************************************************************** */
-/*								    */
-/*			VI Emulation Mode			    */
-/*								    */
-/* **************************************************************** */
-#include "rlconf.h"
-
-#if defined (VI_MODE)
-
-#if defined (HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-
-#include <sys/types.h>
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#if defined (HAVE_UNISTD_H)
-#  include <unistd.h>
-#endif
-
-#include <stdio.h>
-
-/* Some standard library routines. */
-#include "rldefs.h"
-#include "readline.h"
-#include "history.h"
-
-#include "rlprivate.h"
-#include "xmalloc.h"
-
-#ifndef _rl_digit_p
-#define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
-#endif
-
-#ifndef _rl_digit_value
-#define _rl_digit_value(c) ((c) - '0')
-#endif
-
-#ifndef member
-#define member(c, s) ((c) ? (char *)strchr ((s), (c)) != (char *)NULL : 0)
-#endif
-
-#ifndef isident
-#define isident(c) ((_rl_pure_alphabetic (c) || _rl_digit_p (c) || c == '_'))
-#endif
-
-#ifndef exchange
-#define exchange(x, y) do {int temp = x; x = y; y = temp;} while (0)
-#endif
-
-/* Non-zero means enter insertion mode. */
-static int _rl_vi_doing_insert;
-
-/* Command keys which do movement for xxx_to commands. */
-static const char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
-
-/* Keymap used for vi replace characters.  Created dynamically since
-   rarely used. */
-static Keymap vi_replace_map;
-
-/* The number of characters inserted in the last replace operation. */
-static int vi_replace_count;
-
-/* If non-zero, we have text inserted after a c[motion] command that put
-   us implicitly into insert mode.  Some people want this text to be
-   attached to the command so that it is `redoable' with `.'. */
-static int vi_continued_command;
-static char *vi_insert_buffer;
-static int vi_insert_buffer_size;
-
-static int _rl_vi_last_command = 'i';	/* default `.' puts you in insert mode */
-static int _rl_vi_last_repeat = 1;
-static int _rl_vi_last_arg_sign = 1;
-static int _rl_vi_last_motion;
-static int _rl_vi_last_search_char;
-static int _rl_vi_last_replacement;
-
-static int _rl_vi_last_key_before_insert;
-
-static int vi_redoing;
-
-/* Text modification commands.  These are the `redoable' commands. */
-static const char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
-
-/* Arrays for the saved marks. */
-static int vi_mark_chars[27];
-
-static int rl_digit_loop1 __P((void));
-
-void
-_rl_vi_initialize_line ()
-{
-  register int i;
-
-  for (i = 0; i < sizeof (vi_mark_chars) / sizeof (int); i++)
-    vi_mark_chars[i] = -1;
-}
-
-void
-_rl_vi_reset_last ()
-{
-  _rl_vi_last_command = 'i';
-  _rl_vi_last_repeat = 1;
-  _rl_vi_last_arg_sign = 1;
-  _rl_vi_last_motion = 0;
-}
-
-void
-_rl_vi_set_last (key, repeat, sign)
-     int key, repeat, sign;
-{
-  _rl_vi_last_command = key;
-  _rl_vi_last_repeat = repeat;
-  _rl_vi_last_arg_sign = sign;
-}
-
-/* Is the command C a VI mode text modification command? */
-int
-_rl_vi_textmod_command (c)
-     int c;
-{
-  return (member (c, vi_textmod));
-}
-
-static void
-_rl_vi_stuff_insert (count)
-     int count;
-{
-  rl_begin_undo_group ();
-  while (count--)
-    rl_insert_text (vi_insert_buffer);
-  rl_end_undo_group ();
-}
-
-/* Bound to `.'.  Called from command mode, so we know that we have to
-   redo a text modification command.  The default for _rl_vi_last_command
-   puts you back into insert mode. */
-int
-rl_vi_redo (count, c)
-     int count, c;
-{
-  if (!rl_explicit_arg)
-    {
-      rl_numeric_arg = _rl_vi_last_repeat;
-      rl_arg_sign = _rl_vi_last_arg_sign;
-    }
-
-  vi_redoing = 1;
-  /* If we're redoing an insert with `i', stuff in the inserted text
-     and do not go into insertion mode. */
-  if (_rl_vi_last_command == 'i' && vi_insert_buffer && *vi_insert_buffer)
-    {
-      _rl_vi_stuff_insert (count);
-      /* And back up point over the last character inserted. */
-      if (rl_point > 0)
-	rl_point--;
-    }
-  else
-    _rl_dispatch (_rl_vi_last_command, _rl_keymap);
-  vi_redoing = 0;
-
-  return (0);
-}
-
-/* A placeholder for further expansion. */
-int
-rl_vi_undo (count, key)
-     int count, key;
-{
-  return (rl_undo_command (count, key));
-}
-    
-/* Yank the nth arg from the previous line into this line at point. */
-int
-rl_vi_yank_arg (count, key)
-     int count, key;
-{
-  /* Readline thinks that the first word on a line is the 0th, while vi
-     thinks the first word on a line is the 1st.  Compensate. */
-  if (rl_explicit_arg)
-    rl_yank_nth_arg (count - 1, 0);
-  else
-    rl_yank_nth_arg ('$', 0);
-
-  return (0);
-}
-
-/* With an argument, move back that many history lines, else move to the
-   beginning of history. */
-int
-rl_vi_fetch_history (count, c)
-     int count, c;
-{
-  int wanted;
-
-  /* Giving an argument of n means we want the nth command in the history
-     file.  The command number is interpreted the same way that the bash
-     `history' command does it -- that is, giving an argument count of 450
-     to this command would get the command listed as number 450 in the
-     output of `history'. */
-  if (rl_explicit_arg)
-    {
-      wanted = history_base + where_history () - count;
-      if (wanted <= 0)
-        rl_beginning_of_history (0, 0);
-      else
-        rl_get_previous_history (wanted, c);
-    }
-  else
-    rl_beginning_of_history (count, 0);
-  return (0);
-}
-
-/* Search again for the last thing searched for. */
-int
-rl_vi_search_again (count, key)
-     int count, key;
-{
-  switch (key)
-    {
-    case 'n':
-      rl_noninc_reverse_search_again (count, key);
-      break;
-
-    case 'N':
-      rl_noninc_forward_search_again (count, key);
-      break;
-    }
-  return (0);
-}
-
-/* Do a vi style search. */
-int
-rl_vi_search (count, key)
-     int count, key;
-{
-  switch (key)
-    {
-    case '?':
-      rl_noninc_forward_search (count, key);
-      break;
-
-    case '/':
-      rl_noninc_reverse_search (count, key);
-      break;
-
-    default:
-      rl_ding ();
-      break;
-    }
-  return (0);
-}
-
-/* Completion, from vi's point of view. */
-int
-rl_vi_complete (ignore, key)
-     int ignore, key;
-{
-  if ((rl_point < rl_end) && (!whitespace (rl_line_buffer[rl_point])))
-    {
-      if (!whitespace (rl_line_buffer[rl_point + 1]))
-	rl_vi_end_word (1, 'E');
-      rl_point++;
-    }
-
-  if (key == '*')
-    rl_complete_internal ('*');	/* Expansion and replacement. */
-  else if (key == '=')
-    rl_complete_internal ('?');	/* List possible completions. */
-  else if (key == '\\')
-    rl_complete_internal (TAB);	/* Standard Readline completion. */
-  else
-    rl_complete (0, key);
-
-  if (key == '*' || key == '\\')
-    {
-      _rl_vi_set_last (key, 1, rl_arg_sign);
-      rl_vi_insertion_mode (1, key);
-    }
-  return (0);
-}
-
-/* Tilde expansion for vi mode. */
-int
-rl_vi_tilde_expand (ignore, key)
-     int ignore, key;
-{
-  rl_tilde_expand (0, key);
-  _rl_vi_set_last (key, 1, rl_arg_sign);	/* XXX */
-  rl_vi_insertion_mode (1, key);
-  return (0);
-}
-
-/* Previous word in vi mode. */
-int
-rl_vi_prev_word (count, key)
-     int count, key;
-{
-  if (count < 0)
-    return (rl_vi_next_word (-count, key));
-
-  if (rl_point == 0)
-    {
-      rl_ding ();
-      return (0);
-    }
-
-  if (_rl_uppercase_p (key))
-    rl_vi_bWord (count, key);
-  else
-    rl_vi_bword (count, key);
-
-  return (0);
-}
-
-/* Next word in vi mode. */
-int
-rl_vi_next_word (count, key)
-     int count, key;
-{
-  if (count < 0)
-    return (rl_vi_prev_word (-count, key));
-
-  if (rl_point >= (rl_end - 1))
-    {
-      rl_ding ();
-      return (0);
-    }
-
-  if (_rl_uppercase_p (key))
-    rl_vi_fWord (count, key);
-  else
-    rl_vi_fword (count, key);
-  return (0);
-}
-
-/* Move to the end of the ?next? word. */
-int
-rl_vi_end_word (count, key)
-     int count, key;
-{
-  if (count < 0)
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  if (_rl_uppercase_p (key))
-    rl_vi_eWord (count, key);
-  else
-    rl_vi_eword (count, key);
-  return (0);
-}
-
-/* Move forward a word the way that 'W' does. */
-int
-rl_vi_fWord (count, ignore)
-     int count, ignore;
-{
-  while (count-- && rl_point < (rl_end - 1))
-    {
-      /* Skip until whitespace. */
-      while (!whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
-	rl_point++;
-
-      /* Now skip whitespace. */
-      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
-	rl_point++;
-    }
-  return (0);
-}
-
-int
-rl_vi_bWord (count, ignore)
-     int count, ignore;
-{
-  while (count-- && rl_point > 0)
-    {
-      /* If we are at the start of a word, move back to whitespace so
-	 we will go back to the start of the previous word. */
-      if (!whitespace (rl_line_buffer[rl_point]) &&
-	  whitespace (rl_line_buffer[rl_point - 1]))
-	rl_point--;
-
-      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
-	rl_point--;
-
-      if (rl_point > 0)
-	{
-	  while (--rl_point >= 0 && !whitespace (rl_line_buffer[rl_point]));
-	  rl_point++;
-	}
-    }
-  return (0);
-}
-
-int
-rl_vi_eWord (count, ignore)
-     int count, ignore;
-{
-  while (count-- && rl_point < (rl_end - 1))
-    {
-      if (!whitespace (rl_line_buffer[rl_point]))
-	rl_point++;
-
-      /* Move to the next non-whitespace character (to the start of the
-	 next word). */
-      while (++rl_point < rl_end && whitespace (rl_line_buffer[rl_point]));
-
-      if (rl_point && rl_point < rl_end)
-	{
-	  /* Skip whitespace. */
-	  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
-	    rl_point++;
-
-	  /* Skip until whitespace. */
-	  while (rl_point < rl_end && !whitespace (rl_line_buffer[rl_point]))
-	    rl_point++;
-
-	  /* Move back to the last character of the word. */
-	  rl_point--;
-	}
-    }
-  return (0);
-}
-
-int
-rl_vi_fword (count, ignore)
-     int count, ignore;
-{
-  while (count-- && rl_point < (rl_end - 1))
-    {
-      /* Move to white space (really non-identifer). */
-      if (isident (rl_line_buffer[rl_point]))
-	{
-	  while (isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
-	    rl_point++;
-	}
-      else /* if (!whitespace (rl_line_buffer[rl_point])) */
-	{
-	  while (!isident (rl_line_buffer[rl_point]) &&
-		 !whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
-	    rl_point++;
-	}
-
-      /* Move past whitespace. */
-      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
-	rl_point++;
-    }
-  return (0);
-}
-
-int
-rl_vi_bword (count, ignore)
-     int count, ignore;
-{
-  while (count-- && rl_point > 0)
-    {
-      int last_is_ident;
-
-      /* If we are at the start of a word, move back to whitespace
-	 so we will go back to the start of the previous word. */
-      if (!whitespace (rl_line_buffer[rl_point]) &&
-	  whitespace (rl_line_buffer[rl_point - 1]))
-	rl_point--;
-
-      /* If this character and the previous character are `opposite', move
-	 back so we don't get messed up by the rl_point++ down there in
-	 the while loop.  Without this code, words like `l;' screw up the
-	 function. */
-      last_is_ident = isident (rl_line_buffer[rl_point - 1]);
-      if ((isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
-	  (!isident (rl_line_buffer[rl_point]) && last_is_ident))
-	rl_point--;
-
-      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
-	rl_point--;
-
-      if (rl_point > 0)
-	{
-	  if (isident (rl_line_buffer[rl_point]))
-	    while (--rl_point >= 0 && isident (rl_line_buffer[rl_point]));
-	  else
-	    while (--rl_point >= 0 && !isident (rl_line_buffer[rl_point]) &&
-		   !whitespace (rl_line_buffer[rl_point]));
-	  rl_point++;
-	}
-    }
-  return (0);
-}
-
-int
-rl_vi_eword (count, ignore)
-     int count, ignore;
-{
-  while (count-- && rl_point < rl_end - 1)
-    {
-      if (!whitespace (rl_line_buffer[rl_point]))
-	rl_point++;
-
-      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
-	rl_point++;
-
-      if (rl_point < rl_end)
-	{
-	  if (isident (rl_line_buffer[rl_point]))
-	    while (++rl_point < rl_end && isident (rl_line_buffer[rl_point]));
-	  else
-	    while (++rl_point < rl_end && !isident (rl_line_buffer[rl_point])
-		   && !whitespace (rl_line_buffer[rl_point]));
-	}
-      rl_point--;
-    }
-  return (0);
-}
-
-int
-rl_vi_insert_beg (count, key)
-     int count, key;
-{
-  rl_beg_of_line (1, key);
-  rl_vi_insertion_mode (1, key);
-  return (0);
-}
-
-int
-rl_vi_append_mode (count, key)
-     int count, key;
-{
-  if (rl_point < rl_end)
-    rl_point++;
-  rl_vi_insertion_mode (1, key);
-  return (0);
-}
-
-int
-rl_vi_append_eol (count, key)
-     int count, key;
-{
-  rl_end_of_line (1, key);
-  rl_vi_append_mode (1, key);
-  return (0);
-}
-
-/* What to do in the case of C-d. */
-int
-rl_vi_eof_maybe (count, c)
-     int count, c;
-{
-  return (rl_newline (1, '\n'));
-}
-
-/* Insertion mode stuff. */
-
-/* Switching from one mode to the other really just involves
-   switching keymaps. */
-int
-rl_vi_insertion_mode (count, key)
-     int count, key;
-{
-  _rl_keymap = vi_insertion_keymap;
-  _rl_vi_last_key_before_insert = key;
-  return (0);
-}
-
-static void
-_rl_vi_save_insert (up)
-      UNDO_LIST *up;
-{
-  int len, start, end;
-
-  if (up == 0)
-    {
-      if (vi_insert_buffer_size >= 1)
-	vi_insert_buffer[0] = '\0';
-      return;
-    }
-
-  start = up->start;
-  end = up->end;
-  len = end - start + 1;
-  if (len >= vi_insert_buffer_size)
-    {
-      vi_insert_buffer_size += (len + 32) - (len % 32);
-      vi_insert_buffer = xrealloc (vi_insert_buffer, vi_insert_buffer_size);
-    }
-  strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);
-  vi_insert_buffer[len-1] = '\0';
-}
-    
-void
-_rl_vi_done_inserting ()
-{
-  if (_rl_vi_doing_insert)
-    {
-      rl_end_undo_group ();
-      /* Now, the text between rl_undo_list->next->start and
-	 rl_undo_list->next->end is what was inserted while in insert
-	 mode.  It gets copied to VI_INSERT_BUFFER because it depends
-	 on absolute indices into the line which may change (though they
-	 probably will not). */
-      _rl_vi_doing_insert = 0;
-      _rl_vi_save_insert (rl_undo_list->next);
-      vi_continued_command = 1;
-    }
-  else
-    {
-      if (_rl_vi_last_key_before_insert == 'i' && rl_undo_list)
-        _rl_vi_save_insert (rl_undo_list);
-      /* XXX - Other keys probably need to be checked. */
-      else if (_rl_vi_last_key_before_insert == 'C')
-	rl_end_undo_group ();
-      while (_rl_undo_group_level > 0)
-	rl_end_undo_group ();
-      vi_continued_command = 0;
-    }
-}
-
-int
-rl_vi_movement_mode (count, key)
-     int count, key;
-{
-  if (rl_point > 0)
-    rl_backward (1, key);
-
-  _rl_keymap = vi_movement_keymap;
-  _rl_vi_done_inserting ();
-  return (0);
-}
-
-int
-rl_vi_arg_digit (count, c)
-     int count, c;
-{
-  if (c == '0' && rl_numeric_arg == 1 && !rl_explicit_arg)
-    return (rl_beg_of_line (1, c));
-  else
-    return (rl_digit_argument (count, c));
-}
-
-int
-rl_vi_change_case (count, ignore)
-     int count, ignore;
-{
-  char c = 0;
-
-  /* Don't try this on an empty line. */
-  if (rl_point >= rl_end)
-    return (0);
-
-  while (count-- && rl_point < rl_end)
-    {
-      if (_rl_uppercase_p (rl_line_buffer[rl_point]))
-	c = _rl_to_lower (rl_line_buffer[rl_point]);
-      else if (_rl_lowercase_p (rl_line_buffer[rl_point]))
-	c = _rl_to_upper (rl_line_buffer[rl_point]);
-      else
-	{
-	  /* Just skip over characters neither upper nor lower case. */
-	  rl_forward (1, c);
-	  continue;
-	}
-
-      /* Vi is kind of strange here. */
-      if (c)
-	{
-	  rl_begin_undo_group ();
-	  rl_delete (1, c);
-	  rl_insert (1, c);
-	  rl_end_undo_group ();
-	  rl_vi_check ();
-        }
-      else
-	rl_forward (1, c);
-    }
-  return (0);
-}
-
-int
-rl_vi_put (count, key)
-     int count, key;
-{
-  if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))
-    rl_point++;
-
-  rl_yank (1, key);
-  rl_backward (1, key);
-  return (0);
-}
-
-int
-rl_vi_check ()
-{
-  if (rl_point && rl_point == rl_end)
-    rl_point--;
-  return (0);
-}
-
-int
-rl_vi_column (count, key)
-     int count, key;
-{
-  if (count > rl_end)
-    rl_end_of_line (1, key);
-  else
-    rl_point = count - 1;
-  return (0);
-}
-
-int
-rl_vi_domove (key, nextkey)
-     int key, *nextkey;
-{
-  int c, save;
-  int old_end;
-
-  rl_mark = rl_point;
-  RL_SETSTATE(RL_STATE_MOREINPUT);
-  c = rl_read_key ();
-  RL_UNSETSTATE(RL_STATE_MOREINPUT);
-  *nextkey = c;
-
-  if (!member (c, vi_motion))
-    {
-      if (_rl_digit_p (c))
-	{
-	  save = rl_numeric_arg;
-	  rl_numeric_arg = _rl_digit_value (c);
-	  rl_digit_loop1 ();
-	  rl_numeric_arg *= save;
-	  RL_SETSTATE(RL_STATE_MOREINPUT);
-	  c = rl_read_key ();	/* real command */
-	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
-	  *nextkey = c;
-	}
-      else if (key == c && (key == 'd' || key == 'y' || key == 'c'))
-	{
-	  rl_mark = rl_end;
-	  rl_beg_of_line (1, c);
-	  _rl_vi_last_motion = c;
-	  return (0);
-	}
-      else
-	return (-1);
-    }
-
-  _rl_vi_last_motion = c;
-
-  /* Append a blank character temporarily so that the motion routines
-     work right at the end of the line. */
-  old_end = rl_end;
-  rl_line_buffer[rl_end++] = ' ';
-  rl_line_buffer[rl_end] = '\0';
-
-  _rl_dispatch (c, _rl_keymap);
-
-  /* Remove the blank that we added. */
-  rl_end = old_end;
-  rl_line_buffer[rl_end] = '\0';
-  if (rl_point > rl_end)
-    rl_point = rl_end;
-
-  /* No change in position means the command failed. */
-  if (rl_mark == rl_point)
-    return (-1);
-
-  /* rl_vi_f[wW]ord () leaves the cursor on the first character of the next
-     word.  If we are not at the end of the line, and we are on a
-     non-whitespace character, move back one (presumably to whitespace). */
-  if ((_rl_to_upper (c) == 'W') && rl_point < rl_end && rl_point > rl_mark &&
-      !whitespace (rl_line_buffer[rl_point]))
-    rl_point--;
-
-  /* If cw or cW, back up to the end of a word, so the behaviour of ce
-     or cE is the actual result.  Brute-force, no subtlety. */
-  if (key == 'c' && rl_point >= rl_mark && (_rl_to_upper (c) == 'W'))
-    {
-      /* Don't move farther back than where we started. */
-      while (rl_point > rl_mark && whitespace (rl_line_buffer[rl_point]))
-	rl_point--;
-
-      /* Posix.2 says that if cw or cW moves the cursor towards the end of
-	 the line, the character under the cursor should be deleted. */
-      if (rl_point == rl_mark)
-        rl_point++;
-      else
-	{
-	  /* Move past the end of the word so that the kill doesn't
-	     remove the last letter of the previous word.  Only do this
-	     if we are not at the end of the line. */
-	  if (rl_point >= 0 && rl_point < (rl_end - 1) && !whitespace (rl_line_buffer[rl_point]))
-	    rl_point++;
-	}
-    }
-
-  if (rl_mark < rl_point)
-    exchange (rl_point, rl_mark);
-
-  return (0);
-}
-
-/* A simplified loop for vi. Don't dispatch key at end.
-   Don't recognize minus sign?
-   Should this do rl_save_prompt/rl_restore_prompt? */
-static int
-rl_digit_loop1 ()
-{
-  int key, c;
-
-  RL_SETSTATE(RL_STATE_NUMERICARG);
-  while (1)
-    {
-      if (rl_numeric_arg > 1000000)
-	{
-	  rl_explicit_arg = rl_numeric_arg = 0;
-	  rl_ding ();
-	  rl_clear_message ();
-	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
-	  return 1;
-	}
-      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg, 0);
-      RL_SETSTATE(RL_STATE_MOREINPUT);
-      key = c = rl_read_key ();
-      RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-      if (_rl_keymap[c].type == ISFUNC &&
-	  _rl_keymap[c].function == rl_universal_argument)
-	{
-	  rl_numeric_arg *= 4;
-	  continue;
-	}
-
-      c = UNMETA (c);
-      if (_rl_digit_p (c))
-	{
-	  if (rl_explicit_arg)
-	    rl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);
-	  else
-	    rl_numeric_arg = _rl_digit_value (c);
-	  rl_explicit_arg = 1;
-	}
-      else
-	{
-	  rl_clear_message ();
-	  rl_stuff_char (key);
-	  break;
-	}
-    }
-
-  RL_UNSETSTATE(RL_STATE_NUMERICARG);
-  return (0);
-}
-
-int
-rl_vi_delete_to (count, key)
-     int count, key;
-{
-  int c;
-
-  if (_rl_uppercase_p (key))
-    rl_stuff_char ('$');
-  else if (vi_redoing)
-    rl_stuff_char (_rl_vi_last_motion);
-
-  if (rl_vi_domove (key, &c))
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  /* These are the motion commands that do not require adjusting the
-     mark. */
-  if ((strchr (" l|h^0bB", c) == 0) && (rl_mark < rl_end))
-    rl_mark++;
-
-  rl_kill_text (rl_point, rl_mark);
-  return (0);
-}
-
-int
-rl_vi_change_to (count, key)
-     int count, key;
-{
-  int c, start_pos;
-
-  if (_rl_uppercase_p (key))
-    rl_stuff_char ('$');
-  else if (vi_redoing)
-    rl_stuff_char (_rl_vi_last_motion);
-
-  start_pos = rl_point;
-
-  if (rl_vi_domove (key, &c))
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  /* These are the motion commands that do not require adjusting the
-     mark.  c[wW] are handled by special-case code in rl_vi_domove(),
-     and already leave the mark at the correct location. */
-  if ((strchr (" l|hwW^0bB", c) == 0) && (rl_mark < rl_end))
-    rl_mark++;
-
-  /* The cursor never moves with c[wW]. */
-  if ((_rl_to_upper (c) == 'W') && rl_point < start_pos)
-    rl_point = start_pos;
-
-  if (vi_redoing)
-    {
-      if (vi_insert_buffer && *vi_insert_buffer)
-	rl_begin_undo_group ();
-      rl_delete_text (rl_point, rl_mark);
-      if (vi_insert_buffer && *vi_insert_buffer)
-	{
-	  rl_insert_text (vi_insert_buffer);
-	  rl_end_undo_group ();
-	}
-    }
-  else
-    {
-      rl_begin_undo_group ();		/* to make the `u' command work */
-      rl_kill_text (rl_point, rl_mark);
-      /* `C' does not save the text inserted for undoing or redoing. */
-      if (_rl_uppercase_p (key) == 0)
-        _rl_vi_doing_insert = 1;
-      _rl_vi_set_last (key, count, rl_arg_sign);
-      rl_vi_insertion_mode (1, key);
-    }
-
-  return (0);
-}
-
-int
-rl_vi_yank_to (count, key)
-     int count, key;
-{
-  int c, save = rl_point;
-
-  if (_rl_uppercase_p (key))
-    rl_stuff_char ('$');
-
-  if (rl_vi_domove (key, &c))
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  /* These are the motion commands that do not require adjusting the
-     mark. */
-  if ((strchr (" l|h^0%bB", c) == 0) && (rl_mark < rl_end))
-    rl_mark++;
-
-  rl_begin_undo_group ();
-  rl_kill_text (rl_point, rl_mark);
-  rl_end_undo_group ();
-  rl_do_undo ();
-  rl_point = save;
-
-  return (0);
-}
-
-int
-rl_vi_delete (count, key)
-     int count, key;
-{
-  int end;
-
-  if (rl_end == 0)
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  end = rl_point + count;
-
-  if (end >= rl_end)
-    end = rl_end;
-
-  rl_kill_text (rl_point, end);
-  
-  if (rl_point > 0 && rl_point == rl_end)
-    rl_backward (1, key);
-  return (0);
-}
-
-int
-rl_vi_back_to_indent (count, key)
-     int count, key;
-{
-  rl_beg_of_line (1, key);
-  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
-    rl_point++;
-  return (0);
-}
-
-int
-rl_vi_first_print (count, key)
-     int count, key;
-{
-  return (rl_vi_back_to_indent (1, key));
-}
-
-int
-rl_vi_char_search (count, key)
-     int count, key;
-{
-  static char target;
-  static int orig_dir, dir;
-
-  if (key == ';' || key == ',')
-    dir = key == ';' ? orig_dir : -orig_dir;
-  else
-    {
-      if (vi_redoing)
-	target = _rl_vi_last_search_char;
-      else
-	{
-	  RL_SETSTATE(RL_STATE_MOREINPUT);
-	  _rl_vi_last_search_char = target = rl_read_key ();
-	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
-	}
-
-      switch (key)
-        {
-        case 't':
-          orig_dir = dir = FTO;
-          break;
-
-        case 'T':
-          orig_dir = dir = BTO;
-          break;
-
-        case 'f':
-          orig_dir = dir = FFIND;
-          break;
-
-        case 'F':
-          orig_dir = dir = BFIND;
-          break;
-        }
-    }
-
-  return (_rl_char_search_internal (count, dir, target));
-}
-
-/* Match brackets */
-int
-rl_vi_match (ignore, key)
-     int ignore, key;
-{
-  int count = 1, brack, pos;
-
-  pos = rl_point;
-  if ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
-    {
-      while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
-	     rl_point < rl_end - 1)
-	rl_forward (1, key);
-
-      if (brack <= 0)
-	{
-	  rl_point = pos;
-	  rl_ding ();
-	  return -1;
-	}
-    }
-
-  pos = rl_point;
-
-  if (brack < 0)
-    {
-      while (count)
-	{
-	  if (--pos >= 0)
-	    {
-	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
-	      if (b == -brack)
-		count--;
-	      else if (b == brack)
-		count++;
-	    }
-	  else
-	    {
-	      rl_ding ();
-	      return -1;
-	    }
-	}
-    }
-  else
-    {			/* brack > 0 */
-      while (count)
-	{
-	  if (++pos < rl_end)
-	    {
-	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
-	      if (b == -brack)
-		count--;
-	      else if (b == brack)
-		count++;
-	    }
-	  else
-	    {
-	      rl_ding ();
-	      return -1;
-	    }
-	}
-    }
-  rl_point = pos;
-  return (0);
-}
-
-int
-rl_vi_bracktype (c)
-     int c;
-{
-  switch (c)
-    {
-    case '(': return  1;
-    case ')': return -1;
-    case '[': return  2;
-    case ']': return -2;
-    case '{': return  3;
-    case '}': return -3;
-    default:  return  0;
-    }
-}
-
-int
-rl_vi_change_char (count, key)
-     int count, key;
-{
-  int c;
-
-  if (vi_redoing)
-    c = _rl_vi_last_replacement;
-  else
-    {
-      RL_SETSTATE(RL_STATE_MOREINPUT);
-      _rl_vi_last_replacement = c = rl_read_key ();
-      RL_UNSETSTATE(RL_STATE_MOREINPUT);
-    }
-
-  if (c == '\033' || c == CTRL ('C'))
-    return -1;
-
-  while (count-- && rl_point < rl_end)
-    {
-      rl_begin_undo_group ();
-
-      rl_delete (1, c);
-      rl_insert (1, c);
-      if (count == 0)
-	rl_backward (1, c);
-
-      rl_end_undo_group ();
-    }
-  return (0);
-}
-
-int
-rl_vi_subst (count, key)
-     int count, key;
-{
-  rl_begin_undo_group ();
-
-  if (_rl_uppercase_p (key))
-    {
-      rl_beg_of_line (1, key);
-      rl_kill_line (1, key);
-    }
-  else
-    rl_delete_text (rl_point, rl_point+count);
-
-  rl_end_undo_group ();
-
-  _rl_vi_set_last (key, count, rl_arg_sign);
-
-  if (vi_redoing)
-    {
-      int o = _rl_doing_an_undo;
-
-      _rl_doing_an_undo = 1;
-      if (vi_insert_buffer && *vi_insert_buffer)
-	rl_insert_text (vi_insert_buffer);
-      _rl_doing_an_undo = o;
-    }
-  else
-    {
-      rl_begin_undo_group ();
-      _rl_vi_doing_insert = 1;
-      rl_vi_insertion_mode (1, key);
-    }
-
-  return (0);
-}
-
-int
-rl_vi_overstrike (count, key)
-     int count, key;
-{
-  int i;
-
-  if (_rl_vi_doing_insert == 0)
-    {
-      _rl_vi_doing_insert = 1;
-      rl_begin_undo_group ();
-    }
-
-  for (i = 0; i < count; i++)
-    {
-      vi_replace_count++;
-      rl_begin_undo_group ();
-
-      if (rl_point < rl_end)
-	{
-	  rl_delete (1, key);
-	  rl_insert (1, key);
-	}
-      else
-	rl_insert (1, key);
-
-      rl_end_undo_group ();
-    }
-  return (0);
-}
-
-int
-rl_vi_overstrike_delete (count, key)
-     int count, key;
-{
-  int i, s;
-
-  for (i = 0; i < count; i++)
-    {
-      if (vi_replace_count == 0)
-	{
-	  rl_ding ();
-	  break;
-	}
-      s = rl_point;
-
-      if (rl_do_undo ())
-	vi_replace_count--;
-
-      if (rl_point == s)
-	rl_backward (1, key);
-    }
-
-  if (vi_replace_count == 0 && _rl_vi_doing_insert)
-    {
-      rl_end_undo_group ();
-      rl_do_undo ();
-      _rl_vi_doing_insert = 0;
-    }
-  return (0);
-}
-
-int
-rl_vi_replace (count, key)
-     int count, key;
-{
-  int i;
-
-  vi_replace_count = 0;
-
-  if (!vi_replace_map)
-    {
-      vi_replace_map = rl_make_bare_keymap ();
-
-      for (i = ' '; i < KEYMAP_SIZE; i++)
-	vi_replace_map[i].function = rl_vi_overstrike;
-
-      vi_replace_map[RUBOUT].function = rl_vi_overstrike_delete;
-      vi_replace_map[ESC].function = rl_vi_movement_mode;
-      vi_replace_map[RETURN].function = rl_newline;
-      vi_replace_map[NEWLINE].function = rl_newline;
-
-      /* If the normal vi insertion keymap has ^H bound to erase, do the
-         same here.  Probably should remove the assignment to RUBOUT up
-         there, but I don't think it will make a difference in real life. */
-      if (vi_insertion_keymap[CTRL ('H')].type == ISFUNC &&
-	  vi_insertion_keymap[CTRL ('H')].function == rl_rubout)
-	vi_replace_map[CTRL ('H')].function = rl_vi_overstrike_delete;
-
-    }
-  _rl_keymap = vi_replace_map;
-  return (0);
-}
-
-#if 0
-/* Try to complete the word we are standing on or the word that ends with
-   the previous character.  A space matches everything.  Word delimiters are
-   space and ;. */
-int
-rl_vi_possible_completions()
-{
-  int save_pos = rl_point;
-
-  if (rl_line_buffer[rl_point] != ' ' && rl_line_buffer[rl_point] != ';')
-    {
-      while (rl_point < rl_end && rl_line_buffer[rl_point] != ' ' &&
-	     rl_line_buffer[rl_point] != ';')
-	rl_point++;
-    }
-  else if (rl_line_buffer[rl_point - 1] == ';')
-    {
-      rl_ding ();
-      return (0);
-    }
-
-  rl_possible_completions ();
-  rl_point = save_pos;
-
-  return (0);
-}
-#endif
-
-/* Functions to save and restore marks. */
-int
-rl_vi_set_mark (count, key)
-     int count, key;
-{
-  int ch;
-
-  RL_SETSTATE(RL_STATE_MOREINPUT);
-  ch = rl_read_key ();
-  RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-  if (_rl_lowercase_p (ch) == 0)
-    {
-      rl_ding ();
-      return -1;
-    }
-  ch -= 'a';
-  vi_mark_chars[ch] = rl_point;
-  return 0;
-}
-
-int
-rl_vi_goto_mark (count, key)
-     int count, key;
-{
-  int ch;
-
-  RL_SETSTATE(RL_STATE_MOREINPUT);
-  ch = rl_read_key ();
-  RL_UNSETSTATE(RL_STATE_MOREINPUT);
-
-  if (ch == '`')
-    {
-      rl_point = rl_mark;
-      return 0;
-    }
-  else if (_rl_lowercase_p (ch) == 0)
-    {
-      rl_ding ();
-      return -1;
-    }
-
-  ch -= 'a';
-  if (vi_mark_chars[ch] == -1)
-    {
-      rl_ding ();
-      return -1;
-    }
-  rl_point = vi_mark_chars[ch];
-  return 0;
-}
-
-#endif /* VI_MODE */
diff --git a/readline/xmalloc.c b/readline/xmalloc.c
deleted file mode 100644
--- a/readline/xmalloc.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/* xmalloc.c -- safe versions of malloc and realloc */
-
-/* Copyright (C) 1991 Free Software Foundation, Inc.
-
-   This file is part of GNU Readline, a library for reading lines
-   of text with interactive input and history editing.
-
-   Readline is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published by the
-   Free Software Foundation; either version 2, or (at your option) any
-   later version.
-
-   Readline is distributed in the hope that it will be useful, but
-   WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Readline; see the file COPYING.  If not, write to the Free
-   Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-#define READLINE_LIBRARY
-
-#if defined (HAVE_CONFIG_H)
-#include <config.h>
-#endif
-
-#include <stdio.h>
-
-#if defined (HAVE_STDLIB_H)
-#  include <stdlib.h>
-#else
-#  include "ansi_stdlib.h"
-#endif /* HAVE_STDLIB_H */
-
-#include "xmalloc.h"
-
-/* **************************************************************** */
-/*								    */
-/*		   Memory Allocation and Deallocation.		    */
-/*								    */
-/* **************************************************************** */
-
-static void
-memory_error_and_abort (fname)
-     char *fname;
-{
-  fprintf (stderr, "%s: out of virtual memory\n", fname);
-  exit (2);
-}
-
-/* Return a pointer to free()able block of memory large enough
-   to hold BYTES number of bytes.  If the memory cannot be allocated,
-   print an error message and abort. */
-char *
-xmalloc (bytes)
-     int bytes;
-{
-  char *temp;
-
-  temp = (char *)malloc (bytes);
-  if (temp == 0)
-    memory_error_and_abort ("xmalloc");
-  return (temp);
-}
-
-char *
-xrealloc (pointer, bytes)
-     PTR_T pointer;
-     int bytes;
-{
-  char *temp;
-
-  temp = pointer ? (char *)realloc (pointer, bytes) : (char *)malloc (bytes);
-
-  if (temp == 0)
-    memory_error_and_abort ("xrealloc");
-  return (temp);
-}
-
-/* Use this as the function to call when adding unwind protects so we
-   don't need to know what free() returns. */
-void
-xfree (string)
-     PTR_T string;
-{
-  if (string)
-    free (string);
-}
diff --git a/readline/xmalloc.h b/readline/xmalloc.h
deleted file mode 100644
--- a/readline/xmalloc.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* xmalloc.h -- memory allocation that aborts on errors. */
-
-/* Copyright (C) 1999 Free Software Foundation, Inc.
-
-   This file is part of the GNU Readline Library, a library for
-   reading lines of text with interactive input and history editing.
-
-   The GNU Readline Library is free software; you can redistribute it
-   and/or modify it under the terms of the GNU General Public License
-   as published by the Free Software Foundation; either version 2, or
-   (at your option) any later version.
-
-   The GNU Readline Library is distributed in the hope that it will be
-   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   The GNU General Public License is often shipped with GNU software, and
-   is generally kept in a file called COPYING or LICENSE.  If you do not
-   have a copy of the license, write to the Free Software Foundation,
-   59 Temple Place, Suite 330, Boston, MA 02111 USA. */
-
-#if !defined (_XMALLOC_H_)
-#define _XMALLOC_H_
-
-#if defined (READLINE_LIBRARY)
-#  include "rlstdc.h"
-#else
-#  include <readline/rlstdc.h>
-#endif
-
-#ifndef PTR_T
-
-#ifdef __STDC__
-#  define PTR_T	void *
-#else
-#  define PTR_T	char *
-#endif
-
-#endif /* !PTR_T */
-
-extern char *xmalloc __P((int));
-extern char *xrealloc __P((void *, int));
-extern void xfree __P((void *));
-
-#endif /* _XMALLOC_H_ */
