# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1203044270 18000
#      Thu Feb 14 21:57:50 2008 -0500
# Node ID 29980c6b86048e5725cb83d3ca28d169c8276299
# Parent  78f3811155f745e7fc41e9025da3da10dbfd6c4a
don't check f77_exception_encountered

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2008-02-14  John W. Eaton  <jwe@octave.org>
+
+	* examples/fortdemo.cc: Don't check f77_exception_encountered.
+
 2008-02-06  John W. Eaton  <jwe@octave.org>
 
 	* examples/Makefile.in (octave.desktop):
 	Use mv instead of move-if-change.
 
 2008-02-05  John W. Eaton  <jwe@octave.org>
 
 	* dlfcn/Makefile.in: Unconditionally include $(MAKEDEPS).
diff --git a/examples/fortdemo.cc b/examples/fortdemo.cc
--- a/examples/fortdemo.cc
+++ b/examples/fortdemo.cc
@@ -45,19 +45,14 @@ DEFUN_DLD (fortdemo , args , , "Fortran 
         {
           double *av = a.fortran_vec ();
           octave_idx_type na = a.nelem ();
           OCTAVE_LOCAL_BUFFER (char, ctmp, 128);
 
           F77_XFCN (fortsub, FORTSUB, (na, av, ctmp 
                     F77_CHAR_ARG_LEN (128)));
 
-          if (f77_exception_encountered)
-            error ("fortdemo: error in fortran");
-          else
-            {
-              retval(1) = std::string (ctmp);
-              retval(0) = a;
-            }
+	  retval(1) = std::string (ctmp);
+	  retval(0) = a;
         }
     }
   return retval;
 }
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -348,20 +348,16 @@ operator * (const ComplexMatrix& m, cons
 
 	  retval.resize (nr);
 	  Complex *y = retval.fortran_vec ();
 
 	  F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
 				   nr, nc, 1.0, m.data (), ld,
 				   a.data (), 1, 0.0, y, 1
 				   F77_CHAR_ARG_LEN (1)));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in zgemv");
 	}
     }
 
   return retval;
 }
 
 // matrix by column vector -> column vector operations
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1038,48 +1038,39 @@ ComplexMatrix::tinverse (MatrixType &mat
       Complex *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (ztrtri, ZTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
 				 F77_CONST_CHAR_ARG2 (&udiag, 1),
 				 nr, tmp_data, nr, info 
 				 F77_CHAR_ARG_LEN (1)
 				 F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in ztrtri");
-      else
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcond = 0.0;
+      if (info != 0) 
+	info = -1;
+      else if (calc_cond) 
 	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
-	  if (info != 0) 
+	  octave_idx_type ztrcon_info = 0;
+	  char job = '1';
+
+	  OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
+	  OCTAVE_LOCAL_BUFFER (double, rwork, nr);
+
+	  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+				     F77_CONST_CHAR_ARG2 (&uplo, 1),
+				     F77_CONST_CHAR_ARG2 (&udiag, 1),
+				     nr, tmp_data, nr, rcond, 
+				     cwork, rwork, ztrcon_info 
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (ztrcon_info != 0) 
 	    info = -1;
-	  else if (calc_cond) 
-	    {
-	      octave_idx_type ztrcon_info = 0;
-	      char job = '1';
-
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
-	      OCTAVE_LOCAL_BUFFER (double, rwork, nr);
-
-	      F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 F77_CONST_CHAR_ARG2 (&uplo, 1),
-					 F77_CONST_CHAR_ARG2 (&udiag, 1),
-					 nr, tmp_data, nr, rcond, 
-					 cwork, rwork, ztrcon_info 
-					 F77_CHAR_ARG_LEN (1)
-					 F77_CHAR_ARG_LEN (1)
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler) 
-		  ("unrecoverable error in ztrcon");
-
-	      if (ztrcon_info != 0) 
-		info = -1;
-	    }
 	}
 
       if (info == -1 && ! force)
 	retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
@@ -1106,81 +1097,61 @@ ComplexMatrix::finverse (MatrixType &mat
       Array<Complex> z(1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt, 
 				 z.fortran_vec (), lwork, info));
 
-      if (f77_exception_encountered) 
-	{
-	  (*current_liboctave_error_handler)
-	    ("unrecoverable error in zgetri");
-	  return retval;
-	}
-
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (lwork);
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
 	anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcond = 0.0;
+      if (info != 0) 
+	info = -1;
+      else if (calc_cond) 
+	{
+	  // Now calculate the condition number for non-singular matrix.
+	  octave_idx_type zgecon_info = 0;
+	  char job = '1';
+	  Array<double> rz (2 * nc);
+	  double *prz = rz.fortran_vec ();
+	  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nc, tmp_data, nr, anorm, 
+				     rcond, pz, prz, zgecon_info
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (zgecon_info != 0) 
+	    info = -1;
+	}
+
+      if (info == -1 && ! force)
+	retval = *this;  // Restore contents.
       else
 	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
-	  if (info != 0) 
+	  octave_idx_type zgetri_info = 0;
+
+	  F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
+				     pz, lwork, zgetri_info));
+
+	  if (zgetri_info != 0) 
 	    info = -1;
-	  else if (calc_cond) 
-	    {
-	      // Now calculate the condition number for non-singular matrix.
-	      octave_idx_type zgecon_info = 0;
-	      char job = '1';
-	      Array<double> rz (2 * nc);
-	      double *prz = rz.fortran_vec ();
-	      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 nc, tmp_data, nr, anorm, 
-					 rcond, pz, prz, zgecon_info
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler) 
-		  ("unrecoverable error in zgecon");
-
-	      if (zgecon_info != 0) 
-		info = -1;
-	    }
-
-	  if (info == -1 && ! force)
-	    retval = *this;  // Restore contents.
-	  else
-	    {
-	      octave_idx_type zgetri_info = 0;
-
-	      F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
-					 pz, lwork, zgetri_info));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler)
-		  ("unrecoverable error in zgetri");
-
-	      if (zgetri_info != 0) 
-		info = -1;
-	    }
 	}
 
       if (info != 0)
 	mattype.mark_as_rectangular();
     }
   
   return retval;
 }
@@ -1616,83 +1587,74 @@ ComplexMatrix::determinant (octave_idx_t
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
 	anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nr, nc, tmp_data, nr, pipvt, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
-      else
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcond = 0.0;
+      if (info != 0) 
+	{
+	  info = -1;
+	  retval = ComplexDET ();
+	} 
+      else 
 	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  if (calc_cond) 
+	    {
+	      // Now calc the condition number for non-singular matrix.
+	      char job = '1';
+	      Array<Complex> z (2*nr);
+	      Complex *pz = z.fortran_vec ();
+	      Array<double> rz (2*nr);
+	      double *prz = rz.fortran_vec ();
+
+	      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 nc, tmp_data, nr, anorm, 
+					 rcond, pz, prz, info
+					 F77_CHAR_ARG_LEN (1)));
+	    }
+
 	  if (info != 0) 
 	    {
 	      info = -1;
 	      retval = ComplexDET ();
 	    } 
 	  else 
 	    {
-	      if (calc_cond) 
-		{
-		  // Now calc the condition number for non-singular matrix.
-		  char job = '1';
-		  Array<Complex> z (2*nr);
-		  Complex *pz = z.fortran_vec ();
-		  Array<double> rz (2*nr);
-		  double *prz = rz.fortran_vec ();
-		  
-		  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcond, pz, prz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in zgecon");
-		}
-
-	      if (info != 0) 
-		{
-		  info = -1;
-		  retval = ComplexDET ();
-		} 
-	      else 
+	      Complex c = 1.0;
+	      int e = 0;
+
+	      for (octave_idx_type i = 0; i < nc; i++) 
 		{
-		  Complex c = 1.0;
-		  int e = 0;
-
-		  for (octave_idx_type i = 0; i < nc; i++) 
+		  if (ipvt(i) != (i+1))
+		    c = -c;
+
+		  c *= atmp(i,i);
+
+		  if (c == 0.0)
+		    break;
+
+		  while (std::abs(c) < 0.5)
 		    {
-		      if (ipvt(i) != (i+1))
-			c = -c;
-
-		      c *= atmp(i,i);
-
-		      if (c == 0.0)
-			break;
-
-		      while (std::abs(c) < 0.5)
-			{
-			  c *= 2.0;
-			  e--;
-			}
-
-		      while (std::abs(c) >= 2.0)
-			{
-			  c /= 2.0;
-			  e++;
-			}
+		      c *= 2.0;
+		      e--;
 		    }
 
-		  retval = ComplexDET (c, e);
+		  while (std::abs(c) >= 2.0)
+		    {
+		      c /= 2.0;
+		      e++;
+		    }
 		}
+
+	      retval = ComplexDET (c, e);
 	    }
 	}
     }
   
   return retval;
 }
 
 ComplexMatrix
@@ -1746,20 +1708,16 @@ ComplexMatrix::utsolve (MatrixType &matt
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, tmp_data, nr, rcond,
 					     pz, prz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in ztrcon");
-
 		  if (info != 0) 
 		    info = -2;
 
 		  volatile double rcond_plus_one = rcond + 1.0;
 
 		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
 		      info = -2;
@@ -1785,20 +1743,16 @@ ComplexMatrix::utsolve (MatrixType &matt
 		  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in dtrtrs");
 		}
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -1855,20 +1809,16 @@ ComplexMatrix::ltsolve (MatrixType &matt
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, tmp_data, nr, rcond,
 					     pz, prz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in ztrcon");
-
 		  if (info != 0) 
 		    info = -2;
 
 		  volatile double rcond_plus_one = rcond + 1.0;
 
 		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
 		      info = -2;
@@ -1894,20 +1844,16 @@ ComplexMatrix::ltsolve (MatrixType &matt
 		  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in dtrtrs");
 		}
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -1944,88 +1890,74 @@ ComplexMatrix::fsolve (MatrixType &matty
 	  ComplexMatrix atmp = *this;
 	  Complex *tmp_data = atmp.fortran_vec ();
 	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
 	  F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
 				     tmp_data, nr, info
 				     F77_CHAR_ARG_LEN (1)));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zpotrf");
-	  else
+	  // Throw-away extra info LAPACK gives so as to not change output.
+	  rcond = 0.0;
+	  if (info != 0) 
+	    {
+	      info = -2;
+
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Full;
+	    }
+	  else 
 	    {
-	      // Throw-away extra info LAPACK gives so as to not change output.
-	      rcond = 0.0;
-	      if (info != 0) 
+	      if (calc_cond)
 		{
-		  info = -2;
-
+		  Array<Complex> z (2 * nc);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> rz (nc);
+		  double *prz = rz.fortran_vec ();
+
+		  F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, tmp_data, nr, anorm,
+					     rcond, pz, prz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    info = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		    {
+		      info = -2;
+
+		      if (sing_handler)
+			sing_handler (rcond);
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+
+	      if (info == 0)
+		{
+		  retval = b;
+		  Complex *result = retval.fortran_vec ();
+
+		  octave_idx_type b_nc = b.cols ();
+
+		  F77_XFCN (zpotrs, ZPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, b_nc, tmp_data, nr,
+					     result, b.rows(), info
+					     F77_CHAR_ARG_LEN (1)));
+		}
+	      else
+		{
 		  mattype.mark_as_unsymmetric ();
 		  typ = MatrixType::Full;
 		}
-	      else 
-		{
-		  if (calc_cond)
-		    {
-		      Array<Complex> z (2 * nc);
-		      Complex *pz = z.fortran_vec ();
-		      Array<double> rz (nc);
-		      double *prz = rz.fortran_vec ();
-
-		      F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-						 nr, tmp_data, nr, anorm,
-						 rcond, pz, prz, info
-						 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler) 
-			  ("unrecoverable error in zpocon");
-	      
-		      if (info != 0) 
-			info = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-			{
-			  info = -2;
-
-			  if (sing_handler)
-			    sing_handler (rcond);
-			  else
-			    (*current_liboctave_error_handler)
-			      ("matrix singular to machine precision, rcond = %g",
-			       rcond);
-			}
-		    }
-
-		  if (info == 0)
-		    {
-		      retval = b;
-		      Complex *result = retval.fortran_vec ();
-
-		      octave_idx_type b_nc = b.cols ();
-
-		      F77_XFCN (zpotrs, ZPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-						 nr, b_nc, tmp_data, nr,
-						 result, b.rows(), info
-						 F77_CHAR_ARG_LEN (1)));
-		
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler)
-			  ("unrecoverable error in zpotrs");
-		    }
-		  else
-		    {
-		      mattype.mark_as_unsymmetric ();
-		      typ = MatrixType::Full;
-		    }
-		}
 	    }
 	}
 
       if (typ == MatrixType::Full)
 	{
 	  info = 0;
 
 	  Array<octave_idx_type> ipvt (nr);
@@ -2040,89 +1972,75 @@ ComplexMatrix::fsolve (MatrixType &matty
 	  double *prz = rz.fortran_vec ();
 
 	  // Calculate the norm of the matrix, for later use.
 	  if (anorm < 0.)
 	    anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
 	  F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zgetrf");
-	  else
+	  // Throw-away extra info LAPACK gives so as to not change output.
+	  rcond = 0.0;
+	  if (info != 0) 
+	    { 
+	      info = -2;
+
+	      if (sing_handler)
+		sing_handler (rcond);
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	      mattype.mark_as_rectangular ();
+	    } 
+	  else 
 	    {
-	      // Throw-away extra info LAPACK gives so as to not change output.
-	      rcond = 0.0;
-	      if (info != 0) 
-		{ 
-		  info = -2;
-
-		  if (sing_handler)
-		    sing_handler (rcond);
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		  mattype.mark_as_rectangular ();
-		} 
-	      else 
+	      if (calc_cond)
 		{
-		  if (calc_cond)
+		  // Now calculate the condition number for 
+		  // non-singular matrix.
+		  char job = '1';
+		  F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nc, tmp_data, nr, anorm, 
+					     rcond, pz, prz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    info = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      // Now calculate the condition number for 
-		      // non-singular matrix.
-		      char job = '1';
-		      F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-						 nc, tmp_data, nr, anorm, 
-						 rcond, pz, prz, info
-						 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler) 
-			  ("unrecoverable error in zgecon");
-
-		      if (info != 0) 
-			info = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-			{
-			  info = -2;
-
-			  if (sing_handler)
-			    sing_handler (rcond);
-			  else
-			    (*current_liboctave_error_handler)
-			      ("matrix singular to machine precision, rcond = %g",
-			       rcond);
-			}
+		      info = -2;
+
+		      if (sing_handler)
+			sing_handler (rcond);
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-
-		  if (info == 0)
-		    {
-		      retval = b;
-		      Complex *result = retval.fortran_vec ();
-
-		      octave_idx_type b_nc = b.cols ();
-
-		      char job = 'N';
-		      F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-						 nr, b_nc, tmp_data, nr,
-						 pipvt, result, b.rows(), info
-						 F77_CHAR_ARG_LEN (1))); 
-
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler)
-			  ("unrecoverable error in zgetrs");
-		    }
-		  else
-		    mattype.mark_as_rectangular ();		    
 		}
+
+	      if (info == 0)
+		{
+		  retval = b;
+		  Complex *result = retval.fortran_vec ();
+
+		  octave_idx_type b_nc = b.cols ();
+
+		  char job = 'N';
+		  F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, b_nc, tmp_data, nr,
+					     pipvt, result, b.rows(), info
+					     F77_CHAR_ARG_LEN (1))); 
+		}
+	      else
+		mattype.mark_as_rectangular ();		    
 	    }
 	}
     }
   
   return retval;
 }
 
 ComplexMatrix
@@ -2556,47 +2474,35 @@ ComplexMatrix::lssolve (const ComplexMat
 	    addend = n-3*m;
 
 	  const octave_idx_type lworkaround = 4*m + m*m + addend;
 
 	  if (std::real (work(0)) < lworkaround)
 	    work(0) = lworkaround;
 	}
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) 
-	  ("unrecoverable error in zgelsd");
+      lwork = static_cast<octave_idx_type> (std::real (work(0)));
+      work.resize (lwork);
+
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
+				 maxmn, ps, rcond, rank,
+				 work.fortran_vec (), lwork, 
+				 prwork, piwork, info));
+
+      if (rank < minmn)
+	(*current_liboctave_warning_handler) 
+	  ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
+	   m, n, rank, rcond);
+
+      if (s.elem (0) == 0.0)
+	rcond = 0.0;
       else
-	{
-	  lwork = static_cast<octave_idx_type> (std::real (work(0)));
-	  work.resize (lwork);
-
-	  F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				     maxmn, ps, rcond, rank,
-				     work.fortran_vec (), lwork, 
-				     prwork, piwork, info));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zgelsd");
-	  else
-	    {
-	      if (rank < minmn)
-		(*current_liboctave_warning_handler) 
-		  ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-		   m, n, rank, rcond);
-
-	      if (s.elem (0) == 0.0)
-		rcond = 0.0;
-	      else
-		rcond = s.elem (minmn - 1) / s.elem (0);
-
-	      retval.resize (n, nrhs);
-	    }
-	}
+	rcond = s.elem (minmn - 1) / s.elem (0);
+
+      retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ColumnVector& b) const
 {
@@ -2728,48 +2634,39 @@ ComplexMatrix::lssolve (const ComplexCol
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
 				 ps, rcond, rank, work.fortran_vec (),
 				 lwork, prwork, piwork, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) 
-	  ("unrecoverable error in zgelsd");
-      else
+      lwork = static_cast<octave_idx_type> (std::real (work(0)));
+      work.resize (lwork);
+      rwork.resize (static_cast<octave_idx_type> (rwork(0)));
+      iwork.resize (iwork(0));
+
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
+				 maxmn, ps, rcond, rank,
+				 work.fortran_vec (), lwork, 
+				 prwork, piwork, info));
+
+      if (rank < minmn)
 	{
-	  lwork = static_cast<octave_idx_type> (std::real (work(0)));
-	  work.resize (lwork);
-	  rwork.resize (static_cast<octave_idx_type> (rwork(0)));
-	  iwork.resize (iwork(0));
-
-	  F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				     maxmn, ps, rcond, rank,
-				     work.fortran_vec (), lwork, 
-				     prwork, piwork, info));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zgelsd");
-	  else if (rank < minmn)
-	    {
-	      if (rank < minmn)
-		(*current_liboctave_warning_handler) 
-		  ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-		   m, n, rank, rcond);
-
-	      if (s.elem (0) == 0.0)
-		rcond = 0.0;
-	      else
-		rcond = s.elem (minmn - 1) / s.elem (0);
-
-	      retval.resize (n, nrhs);
-	    }
+	  if (rank < minmn)
+	    (*current_liboctave_warning_handler) 
+	      ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
+	       m, n, rank, rcond);
+
+	  if (s.elem (0) == 0.0)
+	    rcond = 0.0;
+	  else
+	    rcond = s.elem (minmn - 1) / s.elem (0);
+
+	  retval.resize (n, nrhs);
 	}
     }
 
   return retval;
 }
 
 // Constants for matrix exponential calculation.
 
@@ -2836,51 +2733,33 @@ ComplexMatrix::expm (void) const
 
   // Permute first
   char job = 'P';
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nc, mp, nc, ilo, ihi,
 			     dpermute.fortran_vec (), info
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
-      return retval;
-    }
-
   // then scale
   job = 'S';
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nc, mp, nc, ilos, ihis,
 			     dscale.fortran_vec (), info
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
-      return retval;
-    }
-
   // Preconditioning step 3: scaling.
 
   ColumnVector work (nc);
   double inf_norm;
 
   F77_XFCN (xzlange, XZLANGE, (F77_CONST_CHAR_ARG2 ("I", 1),
 			       nc, nc, m.fortran_vec (), nc,
 			       work.fortran_vec (), inf_norm
 			       F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler) ("unrecoverable error in zlange");
-      return retval;
-    }
-
   int sqpow = (inf_norm > 0.0
 	       ? static_cast<int> (1.0 + log (inf_norm) / log (2.0)) : 0);
 
   // Check whether we need to square at all.
 
   if (sqpow < 0)
     sqpow = 0;
 
@@ -3046,20 +2925,16 @@ operator * (const ComplexColumnVector& v
       Complex *c = retval.fortran_vec ();
 
       F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
 			       F77_CONST_CHAR_ARG2 ("N", 1),
 			       len, a_len, 1, 1.0, v.data (), len,
 			       a.data (), 1, 0.0, c, len
 			       F77_CHAR_ARG_LEN (1)
 			       F77_CHAR_ARG_LEN (1)));
-
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler)
-	  ("unrecoverable error in zgemm");
     }
 
   return retval;
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 ComplexMatrix&
@@ -3934,24 +3809,19 @@ Sylvester (const ComplexMatrix& a, const
   
   F77_XFCN (ztrsyl, ZTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
 			     F77_CONST_CHAR_ARG2 ("N", 1),
 			     1, a_nr, b_nr, pa, a_nr, pb,
 			     b_nr, px, a_nr, scale, info
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in ztrsyl");
-  else
-    {
-      // FIXME -- check info?
-
-      retval = -ua * cx * ub.hermitian ();
-    }
+  // FIXME -- check info?
+
+  retval = -ua * cx * ub.hermitian ();
 
   return retval;
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& m, const Matrix& a)
 {
   ComplexMatrix tmp (a);
@@ -4011,34 +3881,26 @@ operator * (const ComplexMatrix& m, cons
 	      if (nr == 1)
 		F77_FUNC (xzdotu, XZDOTU) (nc, m.data (), 1, a.data (), 1, *c);
 	      else
 		{
 		  F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
 					   nr, nc, 1.0,  m.data (), ld,
 					   a.data (), 1, 0.0, c, 1
 					   F77_CHAR_ARG_LEN (1)));
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in zgemv");
 		}
 	    }
 	  else
 	    {
 	      F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
 				       F77_CONST_CHAR_ARG2 ("N", 1),
 				       nr, a_nc, nc, 1.0, m.data (),
 				       ld, a.data (), lda, 0.0, c, nr
 				       F77_CHAR_ARG_LEN (1)
 				       F77_CHAR_ARG_LEN (1)));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler)
-		  ("unrecoverable error in zgemm");
 	    }
 	}
     }
 
   return retval;
 }
 
 // FIXME -- it would be nice to share code among the min/max
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -346,20 +346,16 @@ operator * (const ComplexRowVector& v, c
 
 	  retval.resize (a_nc);
 	  Complex *y = retval.fortran_vec ();
 
 	  F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
 				   a_nr, a_nc, 1.0, a.data (),
 				   ld, v.data (), 1, 0.0, y, 1
 				   F77_CHAR_ARG_LEN (1)));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in zgemv");
 	}
     }
 
   return retval;
 }
 
 ComplexRowVector
 operator * (const RowVector& v, const ComplexMatrix& a)
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -3744,20 +3744,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
 	      
 	  octave_idx_type b_nc = b.cols();
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
 
 	  F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
 				   b.rows(), err));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zptsv");
-	  else if (err != 0)
+	  if (err != 0)
 	    {
 	      err = 0;
 	      mattype.mark_as_unsymmetric ();
 	      typ = MatrixType::Tridiagonal;
 	    }
 	  else 
 	    rcond = 1.;
 	}
@@ -3804,20 +3801,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
 	  octave_idx_type b_nc = b.cols();
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
 
 	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
 				   b.rows(), err));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zgtsv");
-	  else if (err != 0)
+	  if (err != 0)
 	    {
 	      rcond = 0.;
 	      err = -2;
 
 	      if (sing_handler)
 		{
 		  sing_handler (rcond);
 		  mattype.mark_as_rectangular ();
@@ -3905,94 +3899,81 @@ SparseComplexMatrix::trisolve (MatrixTyp
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zgttrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  err = -2;
-		  rcond = 0.0;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		} 
-	      else 
-		{
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-		  rcond = 1.0;
-
-		  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+	  if (err != 0) 
+	    {
+	      err = -2;
+	      rcond = 0.0;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	    } 
+	  else 
+	    {
+	      char job = 'N';
+	      volatile octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type b_nc = b.cols ();
+	      retval = SparseComplexMatrix (nr, b_nc, x_nz);
+	      retval.xcidx(0) = 0;
+	      volatile octave_idx_type ii = 0;
+	      rcond = 1.0;
+
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+
+	      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		{
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    work[i] = 0.;
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+		    work[b.ridx(i)] = b.data(i);
+
+		  F77_XFCN (zgttrs, ZGTTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, 1, DL, D, DU, DU2, pipvt, 
+			     work, b.rows (), err
+			     F77_CHAR_ARG_LEN (1)));
+
+		  // Count non-zeros in work vector and adjust 
+		  // space in retval if needed
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    if (work[i] != 0.)
+		      new_nnz++;
+
+		  if (ii + new_nnz > x_nz)
 		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			work[i] = 0.;
-		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-			work[b.ridx(i)] = b.data(i);
-
-		      F77_XFCN (zgttrs, ZGTTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, 1, DL, D, DU, DU2, pipvt, 
-				 work, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in zgttrs");
-			  break;
-			}
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = work[i];
-			  }
-		      retval.xcidx(j+1) = ii;
+		      // Resize the sparse matrix
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+		      retval.change_capacity (sz);
+		      x_nz = sz;
 		    }
 
-		  retval.maybe_compress ();
-		}
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    if (work[i] != 0.)
+		      {
+			retval.xridx(ii) = i;
+			retval.xdata(ii++) = work[i];
+		      }
+		  retval.xcidx(j+1) = ii;
+		}
+
+	      retval.maybe_compress ();
 	    }
 	}
       else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4064,23 +4045,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
 	  rcond = 1.;
 
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
 		  
 	  F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
 				   b_nr, err));
 
-	  if (f77_exception_encountered)
-	    {
-	      (*current_liboctave_error_handler) 
-		("unrecoverable error in zptsv");
-	      err = -1;
-	    }
-	  else if (err != 0)
+	  if (err != 0)
 	    {
 	      err = 0;
 	      mattype.mark_as_unsymmetric ();
 	      typ = MatrixType::Tridiagonal;
 	    }
 	}
 
       if (typ == MatrixType::Tridiagonal)
@@ -4128,23 +4103,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
 	  rcond = 1.;
 
 	  retval = ComplexMatrix (b);
 	  Complex *result = retval.fortran_vec ();
 	      
 	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
 				   b_nr, err));
 
-	  if (f77_exception_encountered)
-	    {
-	      (*current_liboctave_error_handler) 
-		("unrecoverable error in zgtsv");
-	      err = -1;
-	    }
-	  else if (err != 0)
+	  if (err != 0)
 	    {
 	      rcond = 0.;
 	      err = -2;
 		      
 	      if (sing_handler)
 		{
 		  sing_handler (rcond);
 		  mattype.mark_as_rectangular ();
@@ -4230,105 +4199,92 @@ SparseComplexMatrix::trisolve (MatrixTyp
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zgttrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  rcond = 0.0;
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-		} 
-	      else 
-		{	
-		  rcond = 1.;
-		  char job = 'N';
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+	  if (err != 0) 
+	    {
+	      rcond = 0.0;
+	      err = -2;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+	    } 
+	  else 
+	    {	
+	      rcond = 1.;
+	      char job = 'N';
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
+	      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
+
+	      // Take a first guess that the number of non-zero terms
+	      // will be as many as in b
+	      volatile octave_idx_type x_nz = b.nnz ();
+	      volatile octave_idx_type ii = 0;
+	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+	      retval.xcidx(0) = 0;
+	      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		{
+
+		  for (octave_idx_type i = 0; i < b_nr; i++)
+		    Bx[i] = b (i,j);
+
+		  F77_XFCN (zgttrs, ZGTTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, 1, DL, D, DU, DU2, pipvt, 
+			     Bx, b_nr, err
+			     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0)
 		    {
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			Bx[i] = b (i,j);
-
-		      F77_XFCN (zgttrs, ZGTTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, 1, DL, D, DU, DU2, pipvt, 
-				 Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in zgttrs");
-			  break;
-			}
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler)
-			    ("SparseComplexMatrix::solve solve failed");
-
-			  err = -1;
-			  break;
-			}
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  new_nnz++;
-		      
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-			  
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = Bx[i];
-			  }
-
-		      retval.xcidx(j+1) = ii;
+		      (*current_liboctave_error_handler)
+			("SparseComplexMatrix::solve solve failed");
+
+		      err = -1;
+		      break;
 		    }
 
-		  retval.maybe_compress ();
-		}
+		  // Count non-zeros in work vector and adjust 
+		  // space in retval if needed
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    if (Bx[i] != 0.)
+		      new_nnz++;
+
+		  if (ii + new_nnz > x_nz)
+		    {
+		      // Resize the sparse matrix
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+		      retval.change_capacity (sz);
+		      x_nz = sz;
+		    }
+
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    if (Bx[i] != 0.)
+		      {
+			retval.xridx(ii) = i;
+			retval.xdata(ii++) = Bx[i];
+		      }
+
+		  retval.xcidx(j+1) = ii;
+		}
+
+	      retval.maybe_compress ();
 	    }
 	}
       else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4385,95 +4341,81 @@ SparseComplexMatrix::bsolve (MatrixType 
 	  if (calc_cond)
 	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zpbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  rcond = 0.0;
-		  // Matrix is not positive definite!! Fall through to
-		  // unsymmetric banded solver.
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Banded;
-		  err = 0;
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  if (err != 0) 
+	    {
+	      rcond = 0.0;
+	      // Matrix is not positive definite!! Fall through to
+	      // unsymmetric banded solver.
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Banded;
+	      err = 0;
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  Array<Complex> z (2 * nr);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> iz (nr);
+		  double *piz = iz.fortran_vec ();
+
+		  F77_XFCN (zpbcon, ZPBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nr, n_lower, tmp_data, ldm,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      Array<Complex> z (2 * nr);
-		      Complex *pz = z.fortran_vec ();
-		      Array<double> iz (nr);
-		      double *piz = iz.fortran_vec ();
-
-		      F77_XFCN (zpbcon, ZPBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nr, n_lower, tmp_data, ldm,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		      	(*current_liboctave_error_handler) 
-		      	  ("unrecoverable error in zpbcon");
-
-		      if (err != 0) 
-		      	err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.0;
-
-		  if (err == 0)
+		}
+	      else
+		rcond = 1.0;
+
+	      if (err == 0)
+		{
+		  retval = ComplexMatrix (b);
+		  Complex *result = retval.fortran_vec ();
+
+		  octave_idx_type b_nc = b.cols ();
+
+		  F77_XFCN (zpbtrs, ZPBTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, n_lower, b_nc, tmp_data,
+			     ldm, result, b.rows(), err
+			     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0)
 		    {
-		      retval = ComplexMatrix (b);
-		      Complex *result = retval.fortran_vec ();
-
-		      octave_idx_type b_nc = b.cols ();
-
-		      F77_XFCN (zpbtrs, ZPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, b_nc, tmp_data,
-				 ldm, result, b.rows(), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler)
-			  ("unrecoverable error in zpbtrs");
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			}
+		      (*current_liboctave_error_handler) 
+			("SparseMatrix::solve solve failed");
+		      err = -1;
 		    }
 		}
 	    }
 	}
 
       if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
@@ -4512,98 +4454,84 @@ SparseComplexMatrix::bsolve (MatrixType 
 	    }
 
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zgbtrf");
-	  else
-	    {
-	      // Throw-away extra info LAPACK gives so as to not 
-	      // change output.
-	      if (err != 0) 
-		{
-		  rcond = 0.0;
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  // Throw-away extra info LAPACK gives so as to not 
+	  // change output.
+	  if (err != 0) 
+	    {
+	      rcond = 0.0;
+	      err = -2;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  char job = '1';
+		  Array<Complex> z (2 * nr);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> iz (nr);
+		  double *piz = iz.fortran_vec ();
+
+		  F77_XFCN (zgbcon, ZGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		   if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      char job = '1';
-		      Array<Complex> z (2 * nr);
-		      Complex *pz = z.fortran_vec ();
-		      Array<double> iz (nr);
-		      double *piz = iz.fortran_vec ();
-
-		      F77_XFCN (zgbcon, ZGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		        (*current_liboctave_error_handler) 
-		          ("unrecoverable error in zgbcon");
-
-		       if (err != 0) 
-		        err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
-		    {
-		      retval = ComplexMatrix (b);
-		      Complex *result = retval.fortran_vec ();
-
-		      octave_idx_type b_nc = b.cols ();
-
-		      char job = 'N';
-		      F77_XFCN (zgbtrs, ZGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, b_nc, tmp_data,
-				 ldm, pipvt, result, b.rows(), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler)
-			  ("unrecoverable error in zgbtrs");
-		    }
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  retval = ComplexMatrix (b);
+		  Complex *result = retval.fortran_vec ();
+
+		  octave_idx_type b_nc = b.cols ();
+
+		  char job = 'N';
+		  F77_XFCN (zgbtrs, ZGBTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, n_lower, n_upper, b_nc, tmp_data,
+			     ldm, pipvt, result, b.rows(), err
+			     F77_CHAR_ARG_LEN (1)));
 		}
 	    }
 	}
       else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -4662,133 +4590,115 @@ SparseComplexMatrix::bsolve (MatrixType 
 	  if (calc_cond)
 	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zpbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  rcond = 0.0;
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Banded;
-		  err = 0;
-		} 
-	      else 
-		{
-		  if (calc_cond)
-		    {
-		      Array<Complex> z (2 * nr);
-		      Complex *pz = z.fortran_vec ();
-		      Array<double> iz (nr);
-		      double *piz = iz.fortran_vec ();
-
-		      F77_XFCN (zpbcon, ZPBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nr, n_lower, tmp_data, ldm,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		      	(*current_liboctave_error_handler) 
-		      	  ("unrecoverable error in zpbcon");
-
-		      if (err != 0) 
-		      	err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
-		    }
-		  else
-		    rcond = 1.0;
-
-		  if (err == 0)
+	  if (err != 0) 
+	    {
+	      rcond = 0.0;
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Banded;
+	      err = 0;
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  Array<Complex> z (2 * nr);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> iz (nr);
+		  double *piz = iz.fortran_vec ();
+
+		  F77_XFCN (zpbcon, ZPBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nr, n_lower, tmp_data, ldm,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      octave_idx_type b_nr = b.rows ();
-		      octave_idx_type b_nc = b.cols ();
-		      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
-
-		      // Take a first guess that the number of non-zero terms
-		      // will be as many as in b
-		      volatile octave_idx_type x_nz = b.nnz ();
-		      volatile octave_idx_type ii = 0;
-		      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		      retval.xcidx(0) = 0;
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      err = -2;
+
+		      if (sing_handler)
 			{
-			  for (octave_idx_type i = 0; i < b_nr; i++)
-			    Bx[i] = b.elem (i, j);
-
-			  F77_XFCN (zpbtrs, ZPBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, 1, tmp_data,
-				     ldm, Bx, b_nr, err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+	      else
+		rcond = 1.0;
+
+	      if (err == 0)
+		{
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
+		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
+
+		  // Take a first guess that the number of non-zero terms
+		  // will be as many as in b
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
+		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+		  retval.xcidx(0) = 0;
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		    {
+		      for (octave_idx_type i = 0; i < b_nr; i++)
+			Bx[i] = b.elem (i, j);
+
+		      F77_XFCN (zpbtrs, ZPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, 1, tmp_data,
+				 ldm, Bx, b_nr, err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler) 
+			    ("SparseComplexMatrix::solve solve failed");
+			  err = -1;
+			  break;
+			}
+
+		      for (octave_idx_type i = 0; i < b_nr; i++)
+			{
+			  Complex tmp = Bx[i];
+			  if (tmp != 0.0)
 			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dpbtrs");
-			      err = -1;
-			      break;
+			      if (ii == x_nz)
+				{
+				  // Resize the sparse matrix
+				  octave_idx_type sz = x_nz * 
+				    (b_nc - j) / b_nc;
+				  sz = (sz > 10 ? sz : 10) + x_nz;
+				  retval.change_capacity (sz);
+				  x_nz = sz;
+				}
+			      retval.xdata(ii) = tmp;
+			      retval.xridx(ii++) = i;
 			    }
-
-			  if (err != 0)
-			    {
-			      (*current_liboctave_error_handler) 
-				("SparseComplexMatrix::solve solve failed");
-			      err = -1;
-			      break;
-			    }
-
-			  for (octave_idx_type i = 0; i < b_nr; i++)
-			    {
-			      Complex tmp = Bx[i];
-			      if (tmp != 0.0)
-				{
-				  if (ii == x_nz)
-				    {
-				      // Resize the sparse matrix
-				      octave_idx_type sz = x_nz * 
-					(b_nc - j) / b_nc;
-				      sz = (sz > 10 ? sz : 10) + x_nz;
-				      retval.change_capacity (sz);
-				      x_nz = sz;
-				    }
-				  retval.xdata(ii) = tmp;
-				  retval.xridx(ii++) = i;
-				}
-			    }
-			  retval.xcidx(j+1) = ii;
 			}
-
-		      retval.maybe_compress ();
+		      retval.xcidx(j+1) = ii;
 		    }
+
+		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
@@ -4826,137 +4736,120 @@ SparseComplexMatrix::bsolve (MatrixType 
 	    }
 
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zgbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  rcond = 0.0;
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		    sing_handler (rcond);
-		    mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  if (err != 0) 
+	    {
+	      rcond = 0.0;
+	      err = -2;
+
+	      if (sing_handler)
+		{
+		sing_handler (rcond);
+		mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  char job = '1';
+		  Array<Complex> z (2 * nr);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> iz (nr);
+		  double *piz = iz.fortran_vec ();
+
+		  F77_XFCN (zgbcon, ZGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		   if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      char job = '1';
-		      Array<Complex> z (2 * nr);
-		      Complex *pz = z.fortran_vec ();
-		      Array<double> iz (nr);
-		      double *piz = iz.fortran_vec ();
-
-		      F77_XFCN (zgbcon, ZGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		        (*current_liboctave_error_handler) 
-		          ("unrecoverable error in zgbcon");
-
-		       if (err != 0) 
-		        err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  char job = 'N';
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
+		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
+		  retval.xcidx(0) = 0;
+		  volatile octave_idx_type ii = 0;
+
+		  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      char job = 'N';
-		      volatile octave_idx_type x_nz = b.nnz ();
-		      octave_idx_type b_nc = b.cols ();
-		      retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		      retval.xcidx(0) = 0;
-		      volatile octave_idx_type ii = 0;
-
-		      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      for (octave_idx_type i = 0; i < nr; i++)
+			work[i] = 0.;
+		      for (octave_idx_type i = b.cidx(j); 
+			   i < b.cidx(j+1); i++)
+			work[b.ridx(i)] = b.data(i);
+
+		      F77_XFCN (zgbtrs, ZGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, 1, tmp_data,
+				 ldm, pipvt, work, b.rows (), err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      // Count non-zeros in work vector and adjust 
+		      // space in retval if needed
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (work[i] != 0.)
+			  new_nnz++;
+
+		      if (ii + new_nnz > x_nz)
 			{
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    work[i] = 0.;
-			  for (octave_idx_type i = b.cidx(j); 
-			       i < b.cidx(j+1); i++)
-			    work[b.ridx(i)] = b.data(i);
-
-			  F77_XFCN (zgbtrs, ZGBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, n_upper, 1, tmp_data,
-				     ldm, pipvt, work, b.rows (), err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in zgbtrs");
-			      break;
-			    }
-
-			  // Count non-zeros in work vector and adjust 
-			  // space in retval if needed
-			  octave_idx_type new_nnz = 0;
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (work[i] != 0.)
-			      new_nnz++;
-
-			  if (ii + new_nnz > x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (work[i] != 0.)
-			      {
-				retval.xridx(ii) = i;
-				retval.xdata(ii++) = work[i];
-			      }
-			  retval.xcidx(j+1) = ii;
+			  // Resize the sparse matrix
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			  retval.change_capacity (sz);
+			  x_nz = sz;
 			}
 
-		      retval.maybe_compress ();
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (work[i] != 0.)
+			  {
+			    retval.xridx(ii) = i;
+			    retval.xdata(ii++) = work[i];
+			  }
+		      retval.xcidx(j+1) = ii;
 		    }
+
+		  retval.maybe_compress ();
 		}
 	    }
 	}
       else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -5015,98 +4908,81 @@ SparseComplexMatrix::bsolve (MatrixType 
 	  if (calc_cond)
 	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zpbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  // Matrix is not positive definite!! Fall through to
-		  // unsymmetric banded solver.
-		  rcond = 0.0;
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Banded;
-		  err = 0;
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  if (err != 0) 
+	    {
+	      // Matrix is not positive definite!! Fall through to
+	      // unsymmetric banded solver.
+	      rcond = 0.0;
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Banded;
+	      err = 0;
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  Array<Complex> z (2 * nr);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> iz (nr);
+		  double *piz = iz.fortran_vec ();
+
+		  F77_XFCN (zpbcon, ZPBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nr, n_lower, tmp_data, ldm,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      Array<Complex> z (2 * nr);
-		      Complex *pz = z.fortran_vec ();
-		      Array<double> iz (nr);
-		      double *piz = iz.fortran_vec ();
-
-		      F77_XFCN (zpbcon, ZPBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nr, n_lower, tmp_data, ldm,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		      	(*current_liboctave_error_handler) 
-		      	  ("unrecoverable error in zpbcon");
-
-		      if (err != 0) 
-		      	err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.0;
-
-		  if (err == 0)
+		}
+	      else
+		rcond = 1.0;
+
+	      if (err == 0)
+		{
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
+		  retval = ComplexMatrix (b);
+		  Complex *result = retval.fortran_vec ();
+
+		  F77_XFCN (zpbtrs, ZPBTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, n_lower, b_nc, tmp_data,
+			     ldm, result, b_nr, err
+			     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0)
 		    {
-		      octave_idx_type b_nr = b.rows ();
-		      octave_idx_type b_nc = b.cols ();
-		      retval = ComplexMatrix (b);
-		      Complex *result = retval.fortran_vec ();
-
-		      F77_XFCN (zpbtrs, ZPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, b_nc, tmp_data,
-				 ldm, result, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in zpbtrs");
-			  err = -1;
-			}
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseComplexMatrix::solve solve failed");
-			  err = -1;
-			}
+		      (*current_liboctave_error_handler) 
+			("SparseComplexMatrix::solve solve failed");
+		      err = -1;
 		    }
 		}
 	    }
 	}
 
       if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
@@ -5145,97 +5021,81 @@ SparseComplexMatrix::bsolve (MatrixType 
 	    }
 
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zgbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  err = -2;
-		  rcond = 0.0;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  if (err != 0) 
+	    {
+	      err = -2;
+	      rcond = 0.0;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  char job = '1';
+		  Array<Complex> z (2 * nr);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> iz (nr);
+		  double *piz = iz.fortran_vec ();
+
+		  F77_XFCN (zgbcon, ZGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		   if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      char job = '1';
-		      Array<Complex> z (2 * nr);
-		      Complex *pz = z.fortran_vec ();
-		      Array<double> iz (nr);
-		      double *piz = iz.fortran_vec ();
-
-		      F77_XFCN (zgbcon, ZGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		        (*current_liboctave_error_handler) 
-		          ("unrecoverable error in zgbcon");
-
-		       if (err != 0) 
-		        err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
-		    {
-		      char job = 'N';
-		      octave_idx_type b_nc = b.cols ();
-		      retval = ComplexMatrix (b);
-		      Complex *result = retval.fortran_vec ();
-
-		      F77_XFCN (zgbtrs, ZGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, b_nc, tmp_data,
-				 ldm, pipvt, result, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgbtrs");
-			}
-		    }
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  char job = 'N';
+		  octave_idx_type b_nc = b.cols ();
+		  retval = ComplexMatrix (b);
+		  Complex *result = retval.fortran_vec ();
+
+		  F77_XFCN (zgbtrs, ZGBTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, n_lower, n_upper, b_nc, tmp_data,
+			     ldm, pipvt, result, b.rows (), err
+			     F77_CHAR_ARG_LEN (1)));
 		}
 	    }
 	}
       else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -5294,142 +5154,124 @@ SparseComplexMatrix::bsolve (MatrixType 
 	  if (calc_cond)
 	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zpbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  // Matrix is not positive definite!! Fall through to
-		  // unsymmetric banded solver.
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Banded;
-
-		  rcond = 0.0;
-		  err = 0;
-		} 
-	      else 
-		{
-		  if (calc_cond)
-		    {
-		      Array<Complex> z (2 * nr);
-		      Complex *pz = z.fortran_vec ();
-		      Array<double> iz (nr);
-		      double *piz = iz.fortran_vec ();
-
-		      F77_XFCN (zpbcon, ZPBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nr, n_lower, tmp_data, ldm,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		      	(*current_liboctave_error_handler) 
-		      	  ("unrecoverable error in zpbcon");
-
-		      if (err != 0) 
-		      	err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
-		    }
-		  else
-		    rcond = 1.0;
-
-		  if (err == 0)
+	  if (err != 0) 
+	    {
+	      // Matrix is not positive definite!! Fall through to
+	      // unsymmetric banded solver.
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Banded;
+
+	      rcond = 0.0;
+	      err = 0;
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  Array<Complex> z (2 * nr);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> iz (nr);
+		  double *piz = iz.fortran_vec ();
+
+		  F77_XFCN (zpbcon, ZPBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nr, n_lower, tmp_data, ldm,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      octave_idx_type b_nr = b.rows ();
-		      octave_idx_type b_nc = b.cols ();
-		      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
-
-		      // Take a first guess that the number of non-zero terms
-		      // will be as many as in b
-		      volatile octave_idx_type x_nz = b.nnz ();
-		      volatile octave_idx_type ii = 0;
-		      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		      retval.xcidx(0) = 0;
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      err = -2;
+
+		      if (sing_handler)
 			{
-
-			  for (octave_idx_type i = 0; i < b_nr; i++)
-			    Bx[i] = b (i,j);
-
-			  F77_XFCN (zpbtrs, ZPBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, 1, tmp_data,
-				     ldm, Bx, b_nr, err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in zpbtrs");
-			      err = -1;
-			      break;
-			    }
-
-			  if (err != 0)
-			    {
-			      (*current_liboctave_error_handler) 
-				("SparseMatrix::solve solve failed");
-			      err = -1;
-			      break;
-			    }
-
-			  // Count non-zeros in work vector and adjust 
-			  // space in retval if needed
-			  octave_idx_type new_nnz = 0;
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (Bx[i] != 0.)
-			      new_nnz++;
-			  
-			  if (ii + new_nnz > x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-			  
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (Bx[i] != 0.)
-			      {
-				retval.xridx(ii) = i;
-				retval.xdata(ii++) = Bx[i];
-			      }
-
-			  retval.xcidx(j+1) = ii;
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
 			}
-
-		      retval.maybe_compress ();
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
 		}
+	      else
+		rcond = 1.0;
+
+	      if (err == 0)
+		{
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
+		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
+
+		  // Take a first guess that the number of non-zero terms
+		  // will be as many as in b
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
+		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+		  retval.xcidx(0) = 0;
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		    {
+
+		      for (octave_idx_type i = 0; i < b_nr; i++)
+			Bx[i] = b (i,j);
+
+		      F77_XFCN (zpbtrs, ZPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, 1, tmp_data,
+				 ldm, Bx, b_nr, err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler) 
+			    ("SparseMatrix::solve solve failed");
+			  err = -1;
+			  break;
+			}
+
+		      // Count non-zeros in work vector and adjust 
+		      // space in retval if needed
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (Bx[i] != 0.)
+			  new_nnz++;
+
+		      if (ii + new_nnz > x_nz)
+			{
+			  // Resize the sparse matrix
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			  retval.change_capacity (sz);
+			  x_nz = sz;
+			}
+
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (Bx[i] != 0.)
+			  {
+			    retval.xridx(ii) = i;
+			    retval.xdata(ii++) = Bx[i];
+			  }
+
+		      retval.xcidx(j+1) = ii;
+		    }
+
+		  retval.maybe_compress ();
+		}
 	    }
 	}
 
       if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
 	  octave_idx_type n_lower = mattype.nlower ();
@@ -5466,138 +5308,121 @@ SparseComplexMatrix::bsolve (MatrixType 
 	    }
 
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in xgbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  err = -2;
-		  rcond = 0.0;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		}
-	      else 
-		{
-		  if (calc_cond)
+	  if (err != 0) 
+	    {
+	      err = -2;
+	      rcond = 0.0;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	    }
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  char job = '1';
+		  Array<Complex> z (2 * nr);
+		  Complex *pz = z.fortran_vec ();
+		  Array<double> iz (nr);
+		  double *piz = iz.fortran_vec ();
+
+		  F77_XFCN (zgbcon, ZGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		   if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      char job = '1';
-		      Array<Complex> z (2 * nr);
-		      Complex *pz = z.fortran_vec ();
-		      Array<double> iz (nr);
-		      double *piz = iz.fortran_vec ();
-
-		      F77_XFCN (zgbcon, ZGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		        (*current_liboctave_error_handler) 
-		          ("unrecoverable error in zgbcon");
-
-		       if (err != 0) 
-		        err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  char job = 'N';
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
+		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
+		  retval.xcidx(0) = 0;
+		  volatile octave_idx_type ii = 0;
+
+		  OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
+
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      char job = 'N';
-		      volatile octave_idx_type x_nz = b.nnz ();
-		      octave_idx_type b_nc = b.cols ();
-		      retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		      retval.xcidx(0) = 0;
-		      volatile octave_idx_type ii = 0;
-
-		      OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
-
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      for (octave_idx_type i = 0; i < nr; i++)
+			Bx[i] = 0.;
+
+		      for (octave_idx_type i = b.cidx(j); 
+			   i < b.cidx(j+1); i++)
+			Bx[b.ridx(i)] = b.data(i);
+
+		      F77_XFCN (zgbtrs, ZGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, 1, tmp_data,
+				 ldm, pipvt, Bx, b.rows (), err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      // Count non-zeros in work vector and adjust 
+		      // space in retval if needed
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (Bx[i] != 0.)
+			  new_nnz++;
+
+		      if (ii + new_nnz > x_nz)
 			{
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    Bx[i] = 0.;
-
-			  for (octave_idx_type i = b.cidx(j); 
-			       i < b.cidx(j+1); i++)
-			    Bx[b.ridx(i)] = b.data(i);
-
-			  F77_XFCN (zgbtrs, ZGBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, n_upper, 1, tmp_data,
-				     ldm, pipvt, Bx, b.rows (), err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dgbtrs");
-			      break;
-			    }
-
-			  // Count non-zeros in work vector and adjust 
-			  // space in retval if needed
-			  octave_idx_type new_nnz = 0;
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (Bx[i] != 0.)
-			      new_nnz++;
-
-			  if (ii + new_nnz > x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (Bx[i] != 0.)
-			      {
-				retval.xridx(ii) = i;
-				retval.xdata(ii++) = Bx[i]; 
-			      }
-			  retval.xcidx(j+1) = ii;
+			  // Resize the sparse matrix
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			  retval.change_capacity (sz);
+			  x_nz = sz;
 			}
 
-		      retval.maybe_compress ();
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (Bx[i] != 0.)
+			  {
+			    retval.xridx(ii) = i;
+			    retval.xdata(ii++) = Bx[i]; 
+			  }
+		      retval.xcidx(j+1) = ii;
 		    }
+
+		  retval.maybe_compress ();
 		}
 	    }
 	}
       else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,19 @@
+2008-02-14  John W. Eaton  <jwe@octave.org>
+
+	* CColVector.cc, CMatrix.cc, CRowVector.cc, CSparse.cc,
+	CmplxAEPBAL.cc, CmplxCHOL.cc, CmplxHESS.cc, CmplxLU.cc,
+	CmplxQR.cc, CmplxQRP.cc, CmplxSCHUR.cc, CmplxSVD.cc, DASPK.cc,
+	DASRT.cc, DASSL.cc, EIG.cc, LSODE.cc, NLEqn.cc, Quad.cc,
+	dColVector.cc, dMatrix.cc, dRowVector.cc, dSparse.cc,
+	dbleAEPBAL.cc, dbleCHOL.cc, dbleHESS.cc, dbleLU.cc, dbleQR.cc,
+	dbleQRP.cc, dbleSCHUR.cc, dbleSVD.cc:
+	Don't check f77_exception_encountered.
+
 2008-02-12  John W. Eaton  <jwe@octave.org>
 
 	* CMatrix.cc: Declare xilaenv instead of ilaenv.
 	(ComplexMatrix::lssolve): Call xilaenv instead of ilaenv.
 
 2008-02-12  Jason Riedy  <ejr@cs.berkeley.edu>
   
 	* Array.cc (ascending_compare, descending_compare): Remove
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -72,38 +72,30 @@ ComplexAEPBALANCE::init (const ComplexMa
 
   char job = balance_job[0];
 
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
 			     n, p_balanced_mat, n, ilo, ihi,
 			     pscale, info
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
-  else
-    {
-      balancing_mat = ComplexMatrix (n, n, 0.0);
-      for (octave_idx_type i = 0; i < n; i++)
-	balancing_mat.elem (i, i) = 1.0;
+  balancing_mat = ComplexMatrix (n, n, 0.0);
+  for (octave_idx_type i = 0; i < n; i++)
+    balancing_mat.elem (i, i) = 1.0;
 
-      Complex *p_balancing_mat = balancing_mat.fortran_vec ();
+  Complex *p_balancing_mat = balancing_mat.fortran_vec ();
 
-      char side = 'R';
+  char side = 'R';
 
-      F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-				 F77_CONST_CHAR_ARG2 (&side, 1),
-				 n, ilo, ihi, pscale, n,
-				 p_balancing_mat, n, info
-				 F77_CHAR_ARG_LEN (1)
-				 F77_CHAR_ARG_LEN (1)));
-
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in zgebak");
-    }
+  F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     F77_CONST_CHAR_ARG2 (&side, 1),
+			     n, ilo, ihi, pscale, n,
+			     p_balancing_mat, n, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -71,53 +71,44 @@ ComplexCHOL::init (const ComplexMatrix& 
   // Calculate the norm of the matrix, for later use.
   double anorm = 0;
   if (calc_cond) 
     anorm = chol_mat.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
   F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in zpotrf");
+  xrcond = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond) 
+    {
+      octave_idx_type zpocon_info = 0;
+
+      // Now calculate the condition number for non-singular matrix.
+      Array<Complex> z (2*n);
+      Complex *pz = z.fortran_vec ();
+      Array<double> rz (n);
+      double *prz = rz.fortran_vec ();
+      F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
+				 n, anorm, xrcond, pz, prz, zpocon_info
+				 F77_CHAR_ARG_LEN (1)));
+
+      if (zpocon_info != 0) 
+	info = -1;
+    }
   else
     {
-      xrcond = 0.0;
-      if (info != 0)
-	info = -1;
-      else if (calc_cond) 
-	{
-	  octave_idx_type zpocon_info = 0;
-
-	  // Now calculate the condition number for non-singular matrix.
-	  Array<Complex> z (2*n);
-	  Complex *pz = z.fortran_vec ();
-	  Array<double> rz (n);
-	  double *prz = rz.fortran_vec ();
-	  F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-				     n, anorm, xrcond, pz, prz, zpocon_info
-				     F77_CHAR_ARG_LEN (1)));
+      // If someone thinks of a more graceful way of doing this (or
+      // faster for that matter :-)), please let me know!
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in zpocon");
-
-	  if (zpocon_info != 0) 
-	    info = -1;
-	}
-      else
-	{
-	  // If someone thinks of a more graceful way of doing this (or
-	  // faster for that matter :-)), please let me know!
-
-	  if (n > 1)
-	    for (octave_idx_type j = 0; j < a_nc; j++)
-	      for (octave_idx_type i = j+1; i < a_nr; i++)
-		chol_mat.xelem (i, j) = 0.0;
-	}
+      if (n > 1)
+	for (octave_idx_type j = 0; j < a_nc; j++)
+	  for (octave_idx_type i = j+1; i < a_nr; i++)
+	    chol_mat.xelem (i, j) = 0.0;
     }
 
   return info;
 }
 
 static ComplexMatrix
 chol2inv_internal (const ComplexMatrix& r)
 {
@@ -132,30 +123,25 @@ chol2inv_internal (const ComplexMatrix& 
       octave_idx_type info;
 
       ComplexMatrix tmp = r;
 
       F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
 				 tmp.fortran_vec (), n, info
 				 F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in zpotri");
-      else
-	{
-	  // If someone thinks of a more graceful way of doing this (or
-	  // faster for that matter :-)), please let me know!
+      // If someone thinks of a more graceful way of doing this (or
+      // faster for that matter :-)), please let me know!
 
-	  if (n > 1)
-	    for (octave_idx_type j = 0; j < r_nc; j++)
-	      for (octave_idx_type i = j+1; i < r_nr; i++)
-		tmp.xelem (i, j) = std::conj (tmp.xelem (j, i));
+      if (n > 1)
+	for (octave_idx_type j = 0; j < r_nc; j++)
+	  for (octave_idx_type i = j+1; i < r_nr; i++)
+	    tmp.xelem (i, j) = std::conj (tmp.xelem (j, i));
 
-	  retval = tmp;
-	}
+      retval = tmp;
     }
   else
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
   return retval;
 }
 
 // Compute the inverse of a matrix using the Cholesky factorization.
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -83,66 +83,44 @@ ComplexHESS::init (const ComplexMatrix& 
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
 			     n, h, n, ilo, ihi, pscale, info
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in zgebal");
-  else
-    {
-      Array<Complex> tau (n-1);
-      Complex *ptau = tau.fortran_vec ();
+  Array<Complex> tau (n-1);
+  Complex *ptau = tau.fortran_vec ();
 
-      Array<Complex> work (lwork);
-      Complex *pwork = work.fortran_vec ();
+  Array<Complex> work (lwork);
+  Complex *pwork = work.fortran_vec ();
 
-      F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
+  F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in zgehrd");
-      else
-	{
-	  unitary_hess_mat = hess_mat;
-	  Complex *z = unitary_hess_mat.fortran_vec ();
+  unitary_hess_mat = hess_mat;
+  Complex *z = unitary_hess_mat.fortran_vec ();
 
-	  F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
-				     lwork, info));
+  F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
+			     lwork, info));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in zunghr");
-	  else
-	    {
-	      F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 F77_CONST_CHAR_ARG2 (&side, 1),
-					 n, ilo, ihi, pscale, n, z, n, info
-					 F77_CHAR_ARG_LEN (1)
-					 F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     F77_CONST_CHAR_ARG2 (&side, 1),
+			     n, ilo, ihi, pscale, n, z, n, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler)
-		  ("unrecoverable error in zgebak");
-	      else
-		{
-		  // If someone thinks of a more graceful way of
-		  // doing this (or faster for that matter :-)),
-		  // please let me know!
+  // If someone thinks of a more graceful way of
+  // doing this (or faster for that matter :-)),
+  // please let me know!
 
-		  if (n > 2)
-		    for (octave_idx_type j = 0; j < a_nc; j++)
-		      for (octave_idx_type i = j+2; i < a_nr; i++)
-			hess_mat.elem (i, j) = 0;
-		}
-	    }
-	}
-    }
+  if (n > 2)
+    for (octave_idx_type j = 0; j < a_nc; j++)
+      for (octave_idx_type i = j+2; i < a_nr; i++)
+	hess_mat.elem (i, j) = 0;
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -56,19 +56,16 @@ ComplexLU::ComplexLU (const ComplexMatri
 
   a_fact = a;
   Complex *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in zgetrf");
-  else
-    ipvt -= static_cast<octave_idx_type> (1);
+  ipvt -= static_cast<octave_idx_type> (1);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -80,66 +80,55 @@ ComplexQR::init (const ComplexMatrix& a,
     }
   else
     A_fact = a;
 
   Complex *tmp_data = A_fact.fortran_vec ();
 
   F77_XFCN (zgeqrf, ZGEQRF, (m, n, tmp_data, m, ptau, pwork, lwork, info));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in zgeqrf");
+  if (qr_type == QR::raw)
+    {
+      for (octave_idx_type j = 0; j < min_mn; j++)
+	{
+	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
+	  for (octave_idx_type i = limit + 1; i < m; i++)
+	    A_fact.elem (i, j) *= tau.elem (j);
+	}
+
+      r = A_fact;
+
+      if (m > n)
+	r.resize (m, n);
+    }
   else
     {
-      if (qr_type == QR::raw)
-	{
-	  for (octave_idx_type j = 0; j < min_mn; j++)
-	    {
-	      octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
-	      for (octave_idx_type i = limit + 1; i < m; i++)
-		A_fact.elem (i, j) *= tau.elem (j);
-	    }
-
-	  r = A_fact;
+      octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
 
-	  if (m > n)
-	    r.resize (m, n);
-	}
+      if (qr_type == QR::economy && m > n)
+	r.resize (n, n, 0.0);
       else
-	{
-	  octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
-
-	  if (qr_type == QR::economy && m > n)
-	    r.resize (n, n, 0.0);
-	  else
-	    r.resize (m, n, 0.0);
+	r.resize (m, n, 0.0);
 
-	  for (octave_idx_type j = 0; j < n; j++)
-	    {
-	      octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
-	      for (octave_idx_type i = 0; i <= limit; i++)
-		r.elem (i, j) = A_fact.elem (i, j);
-	    }
-
-	  lwork = 32 * n2;
-	  work.resize (lwork);
-	  Complex *pwork2 = work.fortran_vec ();
+      for (octave_idx_type j = 0; j < n; j++)
+	{
+	  octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
+	  for (octave_idx_type i = 0; i <= limit; i++)
+	    r.elem (i, j) = A_fact.elem (i, j);
+	}
 
-	  F77_XFCN (zungqr, ZUNGQR, (m, n2, min_mn, tmp_data, m, ptau,
-				     pwork2, lwork, info));
+      lwork = 32 * n2;
+      work.resize (lwork);
+      Complex *pwork2 = work.fortran_vec ();
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in zungqr");
-	  else
-	    {
-	      q = A_fact;
-	      q.resize (m, n2);
-	    }
-	}
+      F77_XFCN (zungqr, ZUNGQR, (m, n2, min_mn, tmp_data, m, ptau,
+				 pwork2, lwork, info));
+
+      q = A_fact;
+      q.resize (m, n2);
     }
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -89,60 +89,50 @@ ComplexQRP::init (const ComplexMatrix& a
   Array<octave_idx_type> jpvt (n, 0);
   octave_idx_type *pjpvt = jpvt.fortran_vec ();
 
   // Code to enforce a certain permutation could go here...
 
   F77_XFCN (zgeqpf, ZGEQPF, (m, n, tmp_data, m, pjpvt, ptau, pwork,
 			     prwork, info));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in zgeqpf");
+  // Form Permutation matrix (if economy is requested, return the
+  // indices only!)
+
+  if (qr_type == QR::economy)
+    {
+      p.resize (1, n, 0.0);
+      for (octave_idx_type j = 0; j < n; j++)
+	p.elem (0, j) = jpvt.elem (j);
+    }
   else
     {
-      // Form Permutation matrix (if economy is requested, return the
-      // indices only!)
+      p.resize (n, n, 0.0);
+      for (octave_idx_type j = 0; j < n; j++)
+	p.elem (jpvt.elem (j) - 1, j) = 1.0;
+    }
 
-      if (qr_type == QR::economy)
-	{
-	  p.resize (1, n, 0.0);
-	  for (octave_idx_type j = 0; j < n; j++)
-	    p.elem (0, j) = jpvt.elem (j);
-	}
-      else
-	{
-	  p.resize (n, n, 0.0);
-	  for (octave_idx_type j = 0; j < n; j++)
-	    p.elem (jpvt.elem (j) - 1, j) = 1.0;
-	}
+  octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
 
-      octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
+  if (qr_type == QR::economy && m > n)
+    r.resize (n, n, 0.0);
+  else
+    r.resize (m, n, 0.0);
 
-      if (qr_type == QR::economy && m > n)
-	r.resize (n, n, 0.0);
-      else
-	r.resize (m, n, 0.0);
-
-      for (octave_idx_type j = 0; j < n; j++)
-	{
-	  octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
-	  for (octave_idx_type i = 0; i <= limit; i++)
-	    r.elem (i, j) = A_fact.elem (i, j);
-	}
+  for (octave_idx_type j = 0; j < n; j++)
+    {
+      octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
+      for (octave_idx_type i = 0; i <= limit; i++)
+	r.elem (i, j) = A_fact.elem (i, j);
+    }
 
-      F77_XFCN (zungqr, ZUNGQR, (m, n2, min_mn, tmp_data, m, ptau,
-				 pwork, lwork, info));
+  F77_XFCN (zungqr, ZUNGQR, (m, n2, min_mn, tmp_data, m, ptau,
+			     pwork, lwork, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in zungqr");
-      else
-	{
-	  q = A_fact;
-	  q.resize (m, n2);
-	}
-    }
+  q = A_fact;
+  q.resize (m, n2);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -127,19 +127,16 @@ ComplexSCHUR::init (const ComplexMatrix&
 			     selector,
 			     F77_CONST_CHAR_ARG2 (&sense, 1),
 			     n, s, n, sdim, pw, q, n, rconde, rcondv,
 			     pwork, lwork, prwork, pbwork, info
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in zgeesx");
-
   return info;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -144,39 +144,29 @@ ComplexSVD::init (const ComplexMatrix& a
   F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
 			     F77_CONST_CHAR_ARG2 (&jobv, 1),
 			     m, n, tmp_data, m, s_vec, u, m, vt,
 			     nrow_vt, work.fortran_vec (), lwork,
 			     rwork.fortran_vec (), info
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in zgesvd");
-  else
-    {
-      lwork = static_cast<octave_idx_type> (work(0).real ());
-      work.resize (lwork);
+  lwork = static_cast<octave_idx_type> (work(0).real ());
+  work.resize (lwork);
 
-      F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-				 F77_CONST_CHAR_ARG2 (&jobv, 1),
-				 m, n, tmp_data, m, s_vec, u, m, vt,
-				 nrow_vt, work.fortran_vec (), lwork,
-				 rwork.fortran_vec (), info
-				 F77_CHAR_ARG_LEN (1)
-				 F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
+			     F77_CONST_CHAR_ARG2 (&jobv, 1),
+			     m, n, tmp_data, m, s_vec, u, m, vt,
+			     nrow_vt, work.fortran_vec (), lwork,
+			     rwork.fortran_vec (), info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in zgesvd");
-      else
-	{
-	  if (! (jobv == 'N' || jobv == 'O'))
-	    right_sm = right_sm.hermitian ();
-	}
-    }
+  if (! (jobv == 'N' || jobv == 'O'))
+    right_sm = right_sm.hermitian ();
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -457,77 +457,69 @@ DASPK::do_integrate (double tout)
   static double *dummy = 0;
   static octave_idx_type *idummy = 0;
 
   F77_XFCN (ddaspk, DDASPK, (ddaspk_f, nn, t, px, pxdot, tout, pinfo,
 			     prel_tol, pabs_tol, istate, prwork, lrw,
 			     piwork, liw, dummy, idummy, ddaspk_j,
 			     ddaspk_psol));
 
-  if (f77_exception_encountered)
-    {
-      integration_error = true;
-      (*current_liboctave_error_handler) ("unrecoverable error in daspk");
-    }
-  else
+  switch (istate)
     {
-      switch (istate)
-	{
-	case 1: // A step was successfully taken in intermediate-output
-	        // mode. The code has not yet reached TOUT.
-	case 2: // The integration to TSTOP was successfully completed
-	        // (T=TSTOP) by stepping exactly to TSTOP.
-	case 3: // The integration to TOUT was successfully completed
-	        // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
-	        // interpolation.  YPRIME(*) is obtained by interpolation.
-	case 4: // The initial condition calculation, with
-                // INFO(11) > 0, was successful, and INFO(14) = 1.
-                // No integration steps were taken, and the solution
-                // is not considered to have been started.
-	  retval = x;
-	  t = tout;
-	  break;
+    case 1: // A step was successfully taken in intermediate-output
+	    // mode. The code has not yet reached TOUT.
+    case 2: // The integration to TSTOP was successfully completed
+	    // (T=TSTOP) by stepping exactly to TSTOP.
+    case 3: // The integration to TOUT was successfully completed
+	    // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
+	    // interpolation.  YPRIME(*) is obtained by interpolation.
+    case 4: // The initial condition calculation, with
+	    // INFO(11) > 0, was successful, and INFO(14) = 1.
+	    // No integration steps were taken, and the solution
+	    // is not considered to have been started.
+      retval = x;
+      t = tout;
+      break;
 
-	case -1: // A large amount of work has been expended.  (~500 steps).
-	case -2: // The error tolerances are too stringent.
-	case -3: // The local error test cannot be satisfied because you
-	         // specified a zero component in ATOL and the
-		 // corresponding computed solution component is zero.
-		 // Thus, a pure relative error test is impossible for
-		 // this component.
-	case -6: // DDASPK had repeated error test failures on the last
-		 // attempted step.
-	case -7: // The corrector could not converge.
-	case -8: // The matrix of partial derivatives is singular.
-	case -9: // The corrector could not converge.  There were repeated
-		 // error test failures in this step.
-	case -10: // The corrector could not converge because IRES was
-		  // equal to minus one.
-	case -11: // IRES equal to -2 was encountered and control is being
-		  // returned to the calling program.
-	case -12: // DDASPK failed to compute the initial YPRIME.
-	case -13: // Unrecoverable error encountered inside user's
-                  // PSOL routine, and control is being returned to
-                  // the calling program.
-	case -14: // The Krylov linear system solver could not
-                  // achieve convergence.
-	case -33: // The code has encountered trouble from which it cannot
-		  // recover. A message is printed explaining the trouble
-		  // and control is returned to the calling program. For
-		  // example, this occurs when invalid input is detected.
-	  integration_error = true;
-	  break;
+    case -1: // A large amount of work has been expended.  (~500 steps).
+    case -2: // The error tolerances are too stringent.
+    case -3: // The local error test cannot be satisfied because you
+	     // specified a zero component in ATOL and the
+	     // corresponding computed solution component is zero.
+	     // Thus, a pure relative error test is impossible for
+	     // this component.
+    case -6: // DDASPK had repeated error test failures on the last
+	     // attempted step.
+    case -7: // The corrector could not converge.
+    case -8: // The matrix of partial derivatives is singular.
+    case -9: // The corrector could not converge.  There were repeated
+	     // error test failures in this step.
+    case -10: // The corrector could not converge because IRES was
+	      // equal to minus one.
+    case -11: // IRES equal to -2 was encountered and control is being
+	      // returned to the calling program.
+    case -12: // DDASPK failed to compute the initial YPRIME.
+    case -13: // Unrecoverable error encountered inside user's
+	      // PSOL routine, and control is being returned to
+	      // the calling program.
+    case -14: // The Krylov linear system solver could not
+	      // achieve convergence.
+    case -33: // The code has encountered trouble from which it cannot
+	      // recover. A message is printed explaining the trouble
+	      // and control is returned to the calling program. For
+	      // example, this occurs when invalid input is detected.
+      integration_error = true;
+      break;
 
-	default:
-	  integration_error = true;
-	  (*current_liboctave_error_handler)
-	    ("unrecognized value of istate (= %d) returned from ddaspk",
-	     istate);
-	  break;
-	}
+    default:
+      integration_error = true;
+      (*current_liboctave_error_handler)
+	("unrecognized value of istate (= %d) returned from ddaspk",
+	 istate);
+      break;
     }
 
   return retval;
 }
 
 Matrix
 DASPK::do_integrate (const ColumnVector& tout)
 {
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -319,71 +319,63 @@ DASRT::integrate (double tout)
   static double *dummy = 0;
   static octave_idx_type *idummy = 0;
 
   F77_XFCN (ddasrt, DDASRT, (ddasrt_f, nn, t, px, pxdot, tout, pinfo,
 			     prel_tol, pabs_tol, istate, prwork, lrw,
 			     piwork, liw, dummy, idummy, ddasrt_j,
 			     ddasrt_g, ng, pjroot));
 
-  if (f77_exception_encountered)
-    {
-      integration_error = true;
-      (*current_liboctave_error_handler) ("unrecoverable error in dasrt");
-    }
-  else
+  switch (istate)
     {
-      switch (istate)
-	{
-	case 1: // A step was successfully taken in intermediate-output
-	        // mode. The code has not yet reached TOUT.
-	case 2: // The integration to TOUT was successfully completed
-	        // (T=TOUT) by stepping exactly to TOUT.
-	case 3: // The integration to TOUT was successfully completed
-	        // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
-	        // interpolation.  YPRIME(*) is obtained by interpolation.
-	  t = tout;
-	  break;
+    case 1: // A step was successfully taken in intermediate-output
+	    // mode. The code has not yet reached TOUT.
+    case 2: // The integration to TOUT was successfully completed
+	    // (T=TOUT) by stepping exactly to TOUT.
+    case 3: // The integration to TOUT was successfully completed
+	    // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
+	    // interpolation.  YPRIME(*) is obtained by interpolation.
+      t = tout;
+      break;
 
-	case 4: //  The integration was successfully completed
-	        // by finding one or more roots of G at T.
-          break;
+    case 4: //  The integration was successfully completed
+	    // by finding one or more roots of G at T.
+      break;
 
-	case -1: // A large amount of work has been expended.
-	case -2: // The error tolerances are too stringent.
-	case -3: // The local error test cannot be satisfied because you
-	         // specified a zero component in ATOL and the
-		 // corresponding computed solution component is zero.
-		 // Thus, a pure relative error test is impossible for
-		 // this component.
-	case -6: // DDASRT had repeated error test failures on the last
-		 // attempted step.
-	case -7: // The corrector could not converge.
-	case -8: // The matrix of partial derivatives is singular.
-	case -9: // The corrector could not converge.  There were repeated
-		 // error test failures in this step.
-	case -10: // The corrector could not converge because IRES was
-		  // equal to minus one.
-	case -11: // IRES equal to -2 was encountered and control is being
-		  // returned to the calling program.
-	case -12: // DASSL failed to compute the initial YPRIME.
-	case -33: // The code has encountered trouble from which it cannot
-		  // recover. A message is printed explaining the trouble
-		  // and control is returned to the calling program. For
-		  // example, this occurs when invalid input is detected.
-	  integration_error = true;
-	  break;
+    case -1: // A large amount of work has been expended.
+    case -2: // The error tolerances are too stringent.
+    case -3: // The local error test cannot be satisfied because you
+	     // specified a zero component in ATOL and the
+	     // corresponding computed solution component is zero.
+	     // Thus, a pure relative error test is impossible for
+	     // this component.
+    case -6: // DDASRT had repeated error test failures on the last
+	     // attempted step.
+    case -7: // The corrector could not converge.
+    case -8: // The matrix of partial derivatives is singular.
+    case -9: // The corrector could not converge.  There were repeated
+	     // error test failures in this step.
+    case -10: // The corrector could not converge because IRES was
+	      // equal to minus one.
+    case -11: // IRES equal to -2 was encountered and control is being
+	      // returned to the calling program.
+    case -12: // DASSL failed to compute the initial YPRIME.
+    case -33: // The code has encountered trouble from which it cannot
+	      // recover. A message is printed explaining the trouble
+	      // and control is returned to the calling program. For
+	      // example, this occurs when invalid input is detected.
+      integration_error = true;
+      break;
 
-	default:
-	  integration_error = true;
-	  (*current_liboctave_error_handler)
-	    ("unrecognized value of istate (= %d) returned from ddasrt",
-	     istate);
-	  break;
-	}
+    default:
+      integration_error = true;
+      (*current_liboctave_error_handler)
+	("unrecognized value of istate (= %d) returned from ddasrt",
+	 istate);
+      break;
     }
 }
 
 DASRT_result
 DASRT::integrate (const ColumnVector& tout)
 {
   DASRT_result retval;
 
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -282,68 +282,60 @@ DASSL::do_integrate (double tout)
 
   static double *dummy = 0;
   static octave_idx_type *idummy = 0;
 
   F77_XFCN (ddassl, DDASSL, (ddassl_f, nn, t, px, pxdot, tout, pinfo,
 			     prel_tol, pabs_tol, istate, prwork, lrw,
 			     piwork, liw, dummy, idummy, ddassl_j));
 
-  if (f77_exception_encountered)
-    {
-      integration_error = true;
-      (*current_liboctave_error_handler) ("unrecoverable error in dassl");
-    }
-  else
+  switch (istate)
     {
-      switch (istate)
-	{
-	case 1: // A step was successfully taken in intermediate-output
-	        // mode. The code has not yet reached TOUT.
-	case 2: // The integration to TSTOP was successfully completed
-	        // (T=TSTOP) by stepping exactly to TSTOP.
-	case 3: // The integration to TOUT was successfully completed
-	        // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
-	        // interpolation.  YPRIME(*) is obtained by interpolation.
-	  retval = x;
-	  t = tout;
-	  break;
+    case 1: // A step was successfully taken in intermediate-output
+	    // mode. The code has not yet reached TOUT.
+    case 2: // The integration to TSTOP was successfully completed
+	    // (T=TSTOP) by stepping exactly to TSTOP.
+    case 3: // The integration to TOUT was successfully completed
+	    // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
+	    // interpolation.  YPRIME(*) is obtained by interpolation.
+      retval = x;
+      t = tout;
+      break;
 
-	case -1: // A large amount of work has been expended.  (~500 steps).
-	case -2: // The error tolerances are too stringent.
-	case -3: // The local error test cannot be satisfied because you
-	         // specified a zero component in ATOL and the
-		 // corresponding computed solution component is zero.
-		 // Thus, a pure relative error test is impossible for
-		 // this component.
-	case -6: // DDASSL had repeated error test failures on the last
-		 // attempted step.
-	case -7: // The corrector could not converge.
-	case -8: // The matrix of partial derivatives is singular.
-	case -9: // The corrector could not converge.  There were repeated
-		 // error test failures in this step.
-	case -10: // The corrector could not converge because IRES was
-		  // equal to minus one.
-	case -11: // IRES equal to -2 was encountered and control is being
-		  // returned to the calling program.
-	case -12: // DDASSL failed to compute the initial YPRIME.
-	case -33: // The code has encountered trouble from which it cannot
-		  // recover. A message is printed explaining the trouble
-		  // and control is returned to the calling program. For
-		  // example, this occurs when invalid input is detected.
-	  integration_error = true;
-	  break;
+    case -1: // A large amount of work has been expended.  (~500 steps).
+    case -2: // The error tolerances are too stringent.
+    case -3: // The local error test cannot be satisfied because you
+	     // specified a zero component in ATOL and the
+	     // corresponding computed solution component is zero.
+	     // Thus, a pure relative error test is impossible for
+	     // this component.
+    case -6: // DDASSL had repeated error test failures on the last
+	     // attempted step.
+    case -7: // The corrector could not converge.
+    case -8: // The matrix of partial derivatives is singular.
+    case -9: // The corrector could not converge.  There were repeated
+	     // error test failures in this step.
+    case -10: // The corrector could not converge because IRES was
+	      // equal to minus one.
+    case -11: // IRES equal to -2 was encountered and control is being
+	      // returned to the calling program.
+    case -12: // DDASSL failed to compute the initial YPRIME.
+    case -33: // The code has encountered trouble from which it cannot
+	      // recover. A message is printed explaining the trouble
+	      // and control is returned to the calling program. For
+	      // example, this occurs when invalid input is detected.
+      integration_error = true;
+      break;
 
-	default:
-	  integration_error = true;
-	  (*current_liboctave_error_handler)
-	    ("unrecognized value of istate (= %d) returned from ddassl",
-	     istate);
-	  break;
-	}
+    default:
+      integration_error = true;
+      (*current_liboctave_error_handler)
+	("unrecognized value of istate (= %d) returned from ddassl",
+	 istate);
+      break;
     }
 
   return retval;
 }
 
 Matrix
 DASSL::do_integrate (const ColumnVector& tout)
 {
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -111,30 +111,30 @@ EIG::init (const Matrix& a, bool calc_ev
 
   F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
 			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			   n, tmp_data, n, pwr, pwi, dummy,
 			   idummy, pvr, n, &dummy_work, lwork, info
 			   F77_CHAR_ARG_LEN (1)
 			   F77_CHAR_ARG_LEN (1)));
 
-  if (! f77_exception_encountered && info == 0)
+  if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (lwork);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dgeev, DGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
 			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			       n, tmp_data, n, pwr, pwi, dummy,
 			       idummy, pvr, n, pwork, lwork, info
 			       F77_CHAR_ARG_LEN (1)
 			       F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered || info < 0)
+      if (info < 0)
 	{
 	  (*current_liboctave_error_handler) ("unrecoverable error in dgeev");
 	  return info;
 	}
 
       if (info > 0)
 	{
 	  (*current_liboctave_error_handler) ("dgeev failed to converge");
@@ -203,29 +203,29 @@ EIG::symmetric_init (const Matrix& a, bo
   double dummy_work;
 
   F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			   F77_CONST_CHAR_ARG2 ("U", 1),
 			   n, tmp_data, n, pwr, &dummy_work, lwork, info
 			   F77_CHAR_ARG_LEN (1)
 			   F77_CHAR_ARG_LEN (1)));
 
-  if (! f77_exception_encountered && info == 0)
+  if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (lwork);
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dsyev, DSYEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			       F77_CONST_CHAR_ARG2 ("U", 1),
 			       n, tmp_data, n, pwr, pwork, lwork, info
 			       F77_CHAR_ARG_LEN (1)
 			       F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered || info < 0)
+      if (info < 0)
 	{
 	  (*current_liboctave_error_handler) ("unrecoverable error in dsyev");
 	  return info;
 	}
 
       if (info > 0)
 	{
 	  (*current_liboctave_error_handler) ("dsyev failed to converge");
@@ -286,30 +286,30 @@ EIG::init (const ComplexMatrix& a, bool 
 
   F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
 			   F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			   n, tmp_data, n, pw, dummy, idummy,
 			   pv, n, &dummy_work, lwork, prwork, info
 			   F77_CHAR_ARG_LEN (1)
 			   F77_CHAR_ARG_LEN (1)));
 
-  if (! f77_exception_encountered && info == 0)
+  if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (lwork);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
 			       F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			       n, tmp_data, n, pw, dummy, idummy,
 			       pv, n, pwork, lwork, prwork, info
 			       F77_CHAR_ARG_LEN (1)
 			       F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered || info < 0)
+      if (info < 0)
 	{
 	  (*current_liboctave_error_handler) ("unrecoverable error in zgeev");
 	  return info;
 	}
 
       if (info > 0)
 	{
 	  (*current_liboctave_error_handler) ("zgeev failed to converge");
@@ -353,29 +353,29 @@ EIG::hermitian_init (const ComplexMatrix
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			   F77_CONST_CHAR_ARG2 ("U", 1),
 			   n, tmp_data, n, pwr, &dummy_work, lwork,
 			   prwork, info
 			   F77_CHAR_ARG_LEN (1)
 			   F77_CHAR_ARG_LEN (1)));
 
-  if (! f77_exception_encountered && info == 0)
+  if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (lwork);
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
 			       F77_CONST_CHAR_ARG2 ("U", 1),
 			       n, tmp_data, n, pwr, pwork, lwork, prwork, info
 			       F77_CHAR_ARG_LEN (1)
 			       F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered || info < 0)
+      if (info < 0)
 	{
 	  (*current_liboctave_error_handler) ("unrecoverable error in zheev");
 	  return info;
 	}
 
       if (info > 0)
 	{
 	  (*current_liboctave_error_handler) ("zheev failed to converge");
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -270,50 +270,42 @@ LSODE::do_integrate (double tout)
 
       LSODE_options::reset = false;
     }
 
   F77_XFCN (dlsode, DLSODE, (lsode_f, nn, px, t, tout, itol, rel_tol,
 			     pabs_tol, itask, istate, iopt, prwork, lrw,
 			     piwork, liw, lsode_j, method_flag));
 
-  if (f77_exception_encountered)
-    {
-      integration_error = true;
-      (*current_liboctave_error_handler) ("unrecoverable error in lsode");
-    }
-  else
+  switch (istate)
     {
-      switch (istate)
-	{
-	case 1:  // prior to initial integration step.
-	case 2:  // lsode was successful.
-	  retval = x;
-	  t = tout;
-	  break;
-	  
-	case -1:  // excess work done on this call (perhaps wrong mf).
-	case -2:  // excess accuracy requested (tolerances too small).
-	case -3:  // illegal input detected (see printed message).
-	case -4:  // repeated error test failures (check all inputs).
-	case -5:  // repeated convergence failures (perhaps bad jacobian
-	          // supplied or wrong choice of mf or tolerances).
-	case -6:  // error weight became zero during problem. (solution
-	          // component i vanished, and atol or atol(i) = 0.)
-	case -13: // return requested in user-supplied function.
-	  integration_error = true;
-	  break;
+    case 1:  // prior to initial integration step.
+    case 2:  // lsode was successful.
+      retval = x;
+      t = tout;
+      break;
 
-	default:
-	  integration_error = true;
-	  (*current_liboctave_error_handler)
-	    ("unrecognized value of istate (= %d) returned from lsode",
-	     istate);
-	  break;
-	}
+    case -1:  // excess work done on this call (perhaps wrong mf).
+    case -2:  // excess accuracy requested (tolerances too small).
+    case -3:  // illegal input detected (see printed message).
+    case -4:  // repeated error test failures (check all inputs).
+    case -5:  // repeated convergence failures (perhaps bad jacobian
+	      // supplied or wrong choice of mf or tolerances).
+    case -6:  // error weight became zero during problem. (solution
+	      // component i vanished, and atol or atol(i) = 0.)
+    case -13: // return requested in user-supplied function.
+      integration_error = true;
+      break;
+
+    default:
+      integration_error = true;
+      (*current_liboctave_error_handler)
+	("unrecognized value of istate (= %d) returned from lsode",
+	 istate);
+      break;
     }
 
   return retval;
 }
 
 std::string
 LSODE::error_message (void) const
 {
diff --git a/liboctave/NLEqn.cc b/liboctave/NLEqn.cc
--- a/liboctave/NLEqn.cc
+++ b/liboctave/NLEqn.cc
@@ -171,39 +171,33 @@ NLEqn::solve (octave_idx_type& info)
       Array<double> fjac (n*n);
       double *pfjac = fjac.fortran_vec ();
 
       F77_XFCN (hybrj1, HYBRJ1, (hybrj1_fcn, n, px, pfvec, pfjac, n,
 				 tol, info, pwa, lwa));
 
       solution_status = info;
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in hybrj1");
-      else
-	fval = ColumnVector (fvec);
+      fval = ColumnVector (fvec);
     }
   else
     {
       Array<double> fvec (n);
       double *pfvec = fvec.fortran_vec ();
 
       octave_idx_type lwa = (n*(3*n+13))/2;
       Array<double> wa (lwa);
       double *pwa = wa.fortran_vec ();
 
       F77_XFCN (hybrd1, HYBRD1, (hybrd1_fcn, n, px, pfvec, tol, info,
 				 pwa, lwa));
 
       solution_status = info;
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in hybrd1");
-      else
-	fval = ColumnVector (fvec);
+      fval = ColumnVector (fvec);
     }
 
   return retval;
 }
 
 std::string
 NLEqn::error_message (void) const
 {
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -107,19 +107,16 @@ DefQuad::do_integrate (octave_idx_type& 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
   F77_XFCN (dqagp, DQAGP, (user_function, lower_limit, upper_limit,
 			   npts, points, abs_tol, rel_tol, result,
 			   abserr, neval, ier, leniw, lenw, last,
 			   piwork, pwork));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dqagp");
-
   return result;
 }
 
 double
 IndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
 {
   double result = 0.0;
 
@@ -156,19 +153,16 @@ IndefQuad::do_integrate (octave_idx_type
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
   F77_XFCN (dqagi, DQAGI, (user_function, bound, inf, abs_tol, rel_tol,
 			   result, abserr, neval, ier, leniw, lenw,
 			   last, piwork, pwork));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dqagi");
-
   return result;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -216,20 +216,16 @@ operator * (const Matrix& m, const Colum
 
 	  retval.resize (nr);
 	  double *y = retval.fortran_vec ();
 
 	  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
 				   nr, nc, 1.0, m.data (), ld,
 				   a.data (), 1, 0.0, y, 1
 				   F77_CHAR_ARG_LEN (1)));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in dgemv");
 	}
     }
 
   return retval;
 }
 
 // diagonal matrix by column vector -> column vector operations
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -706,48 +706,39 @@ Matrix::tinverse (MatrixType &mattype, o
       double *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (dtrtri, DTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
 				 F77_CONST_CHAR_ARG2 (&udiag, 1),
 				 nr, tmp_data, nr, info 
 				 F77_CHAR_ARG_LEN (1)
 				 F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in dtrtri");
-      else
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcond = 0.0;
+      if (info != 0) 
+	info = -1;
+      else if (calc_cond) 
 	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
-	  if (info != 0) 
+	  octave_idx_type dtrcon_info = 0;
+	  char job = '1';
+
+	  OCTAVE_LOCAL_BUFFER (double, work, 3 * nr);
+	  OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
+
+	  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+				     F77_CONST_CHAR_ARG2 (&uplo, 1),
+				     F77_CONST_CHAR_ARG2 (&udiag, 1),
+				     nr, tmp_data, nr, rcond, 
+				     work, iwork, dtrcon_info 
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (dtrcon_info != 0) 
 	    info = -1;
-	  else if (calc_cond) 
-	    {
-	      octave_idx_type dtrcon_info = 0;
-	      char job = '1';
-
-	      OCTAVE_LOCAL_BUFFER (double, work, 3 * nr);
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
-
-	      F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 F77_CONST_CHAR_ARG2 (&uplo, 1),
-					 F77_CONST_CHAR_ARG2 (&udiag, 1),
-					 nr, tmp_data, nr, rcond, 
-					 work, iwork, dtrcon_info 
-					 F77_CHAR_ARG_LEN (1)
-					 F77_CHAR_ARG_LEN (1)
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler) 
-		  ("unrecoverable error in dtrcon");
-
-	      if (dtrcon_info != 0) 
-		info = -1;
-	    }
 	}
 
       if (info == -1 && ! force)
 	retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
@@ -774,82 +765,62 @@ Matrix::finverse (MatrixType &mattype, o
 
       Array<double> z(1);
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
       F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt, 
 				 z.fortran_vec (), lwork, info));
 
-      if (f77_exception_encountered) 
-	{
-	  (*current_liboctave_error_handler)
-	    ("unrecoverable error in dgetri");
-	  return retval;
-	}
-
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
       z.resize (lwork);
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
 	anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcond = 0.0;
+      if (info != 0) 
+	info = -1;
+      else if (calc_cond) 
+	{
+	  octave_idx_type dgecon_info = 0;
+
+	  // Now calculate the condition number for non-singular matrix.
+	  char job = '1';
+	  Array<octave_idx_type> iz (nc);
+	  octave_idx_type *piz = iz.fortran_vec ();
+	  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+				     nc, tmp_data, nr, anorm, 
+				     rcond, pz, piz, dgecon_info
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (dgecon_info != 0) 
+	    info = -1;
+	}
+
+      if (info == -1 && ! force)
+	retval = *this; // Restore matrix contents.
       else
 	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
-	  if (info != 0) 
+	  octave_idx_type dgetri_info = 0;
+
+	  F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
+				     pz, lwork, dgetri_info));
+
+	  if (dgetri_info != 0) 
 	    info = -1;
-	  else if (calc_cond) 
-	    {
-	      octave_idx_type dgecon_info = 0;
-
-	      // Now calculate the condition number for non-singular matrix.
-	      char job = '1';
-	      Array<octave_idx_type> iz (nc);
-	      octave_idx_type *piz = iz.fortran_vec ();
-	      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 nc, tmp_data, nr, anorm, 
-					 rcond, pz, piz, dgecon_info
-					 F77_CHAR_ARG_LEN (1)));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler) 
-		  ("unrecoverable error in dgecon");
-
-	      if (dgecon_info != 0) 
-		info = -1;
-	    }
-
-	  if (info == -1 && ! force)
-	    retval = *this; // Restore matrix contents.
-	  else
-	    {
-	      octave_idx_type dgetri_info = 0;
-
-	      F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
-					 pz, lwork, dgetri_info));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler)
-		  ("unrecoverable error in dgetri");
-
-	      if (dgetri_info != 0) 
-		info = -1;
-	    }
 	}
 
       if (info != 0)
 	mattype.mark_as_rectangular();
     }
 
   return retval;
 }
@@ -1279,83 +1250,74 @@ Matrix::determinant (octave_idx_type& in
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond) 
 	anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
-      else
+      // Throw-away extra info LAPACK gives so as to not change output.
+      rcond = 0.0;
+      if (info != 0) 
+	{
+	  info = -1;
+	  retval = DET ();
+	} 
+      else 
 	{
-	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  if (calc_cond) 
+	    {
+	      // Now calc the condition number for non-singular matrix.
+	      char job = '1';
+	      Array<double> z (4 * nc);
+	      double *pz = z.fortran_vec ();
+	      Array<octave_idx_type> iz (nc);
+	      octave_idx_type *piz = iz.fortran_vec ();
+
+	      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					 nc, tmp_data, nr, anorm, 
+					 rcond, pz, piz, info
+					 F77_CHAR_ARG_LEN (1)));
+	    }
+
 	  if (info != 0) 
 	    {
 	      info = -1;
 	      retval = DET ();
 	    } 
 	  else 
 	    {
-	      if (calc_cond) 
-		{
-		  // Now calc the condition number for non-singular matrix.
-		  char job = '1';
-		  Array<double> z (4 * nc);
-		  double *pz = z.fortran_vec ();
-		  Array<octave_idx_type> iz (nc);
-		  octave_idx_type *piz = iz.fortran_vec ();
-
-		  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-					     nc, tmp_data, nr, anorm, 
-					     rcond, pz, piz, info
-					     F77_CHAR_ARG_LEN (1)));
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in dgecon");
-		}
-
-	      if (info != 0) 
-		{
-		  info = -1;
-		  retval = DET ();
-		} 
-	      else 
+	      double c = 1.0;
+	      int e = 0;
+
+	      for (octave_idx_type i = 0; i < nc; i++) 
 		{
-		  double c = 1.0;
-		  int e = 0;
-
-		  for (octave_idx_type i = 0; i < nc; i++) 
+		  if (ipvt(i) != (i+1))
+		    c = -c;
+
+		  c *= atmp(i,i);
+
+		  if (c == 0.0)
+		    break;
+
+		  while (fabs (c) < 0.5)
 		    {
-		      if (ipvt(i) != (i+1))
-			c = -c;
-
-		      c *= atmp(i,i);
-
-		      if (c == 0.0)
-			break;
-
-		      while (fabs (c) < 0.5)
-			{
-			  c *= 2.0;
-			  e--;
-			}
-
-		      while (fabs (c) >= 2.0)
-			{
-			  c /= 2.0;
-			  e++;
-			}
+		      c *= 2.0;
+		      e--;
 		    }
 
-		  retval = DET (c, e);
+		  while (fabs (c) >= 2.0)
+		    {
+		      c /= 2.0;
+		      e++;
+		    }
 		}
+
+	      retval = DET (c, e);
 	    }
 	}
     }
 
   return retval;
 }
 
 Matrix
@@ -1408,20 +1370,16 @@ Matrix::utsolve (MatrixType &mattype, co
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, tmp_data, nr, rcond,
 					     pz, piz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in dtrcon");
-
 		  if (info != 0) 
 		    info = -2;
 
 		  volatile double rcond_plus_one = rcond + 1.0;
 
 		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
 		      info = -2;
@@ -1447,20 +1405,16 @@ Matrix::utsolve (MatrixType &mattype, co
 		  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in dtrtrs");
 		}
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -1516,20 +1470,16 @@ Matrix::ltsolve (MatrixType &mattype, co
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, tmp_data, nr, rcond,
 					     pz, piz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in dtrcon");
-
 		  if (info != 0) 
 		    info = -2;
 
 		  volatile double rcond_plus_one = rcond + 1.0;
 
 		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
 		      info = -2;
@@ -1555,20 +1505,16 @@ Matrix::ltsolve (MatrixType &mattype, co
 		  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler) 
-		      ("unrecoverable error in dtrtrs");
 		}
 	    }
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -1603,88 +1549,74 @@ Matrix::fsolve (MatrixType &mattype, con
 	  Matrix atmp = *this;
 	  double *tmp_data = atmp.fortran_vec ();
 	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
 	  F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
 				     tmp_data, nr, info
 				     F77_CHAR_ARG_LEN (1)));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dpotrf");
-	  else
+	  // Throw-away extra info LAPACK gives so as to not change output.
+	  rcond = 0.0;
+	  if (info != 0) 
+	    {
+	      info = -2;
+
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Full;
+	    }
+	  else 
 	    {
-	      // Throw-away extra info LAPACK gives so as to not change output.
-	      rcond = 0.0;
-	      if (info != 0) 
+	      if (calc_cond)
 		{
-		  info = -2;
-
+		  Array<double> z (3 * nc);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nc);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, tmp_data, nr, anorm,
+					     rcond, pz, piz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    info = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		    {
+		      info = -2;
+
+		      if (sing_handler)
+			sing_handler (rcond);
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+
+	      if (info == 0)
+		{
+		  retval = b;
+		  double *result = retval.fortran_vec ();
+
+		  octave_idx_type b_nc = b.cols ();
+
+		  F77_XFCN (dpotrs, DPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, b_nc, tmp_data, nr,
+					     result, b.rows(), info
+					     F77_CHAR_ARG_LEN (1)));
+		}
+	      else
+		{
 		  mattype.mark_as_unsymmetric ();
 		  typ = MatrixType::Full;
-		}
-	      else 
-		{
-		  if (calc_cond)
-		    {
-		      Array<double> z (3 * nc);
-		      double *pz = z.fortran_vec ();
-		      Array<octave_idx_type> iz (nc);
-		      octave_idx_type *piz = iz.fortran_vec ();
-
-		      F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-						 nr, tmp_data, nr, anorm,
-						 rcond, pz, piz, info
-						 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler) 
-			  ("unrecoverable error in dpocon");
-	      
-		      if (info != 0) 
-			info = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-			{
-			  info = -2;
-
-			  if (sing_handler)
-			    sing_handler (rcond);
-			  else
-			    (*current_liboctave_error_handler)
-			      ("matrix singular to machine precision, rcond = %g",
-			       rcond);
-			}
-		    }
-
-		  if (info == 0)
-		    {
-		      retval = b;
-		      double *result = retval.fortran_vec ();
-
-		      octave_idx_type b_nc = b.cols ();
-
-		      F77_XFCN (dpotrs, DPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-						 nr, b_nc, tmp_data, nr,
-						 result, b.rows(), info
-						 F77_CHAR_ARG_LEN (1)));
-		
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler)
-			  ("unrecoverable error in dpotrs");
-		    }
-		  else
-		    {
-		      mattype.mark_as_unsymmetric ();
-		      typ = MatrixType::Full;
-		    }		    
-		}
+		}		    
 	    }
 	}
 
       if (typ == MatrixType::Full)
 	{
 	  info = 0;
 
 	  Array<octave_idx_type> ipvt (nr);
@@ -1697,89 +1629,75 @@ Matrix::fsolve (MatrixType &mattype, con
 
 	  Array<double> z (4 * nc);
 	  double *pz = z.fortran_vec ();
 	  Array<octave_idx_type> iz (nc);
 	  octave_idx_type *piz = iz.fortran_vec ();
 
 	  F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgetrf");
-	  else
+	  // Throw-away extra info LAPACK gives so as to not change output.
+	  rcond = 0.0;
+	  if (info != 0) 
 	    {
-	      // Throw-away extra info LAPACK gives so as to not change output.
-	      rcond = 0.0;
-	      if (info != 0) 
+	      info = -2;
+
+	      if (sing_handler)
+		sing_handler (rcond);
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	      mattype.mark_as_rectangular ();
+	    }
+	  else 
+	    {
+	      if (calc_cond)
 		{
-		  info = -2;
-
-		  if (sing_handler)
-		    sing_handler (rcond);
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		  mattype.mark_as_rectangular ();
-		}
-	      else 
-		{
-		  if (calc_cond)
+		  // Now calculate the condition number for 
+		  // non-singular matrix.
+		  char job = '1';
+		  F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nc, tmp_data, nr, anorm, 
+					     rcond, pz, piz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    info = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      // Now calculate the condition number for 
-		      // non-singular matrix.
-		      char job = '1';
-		      F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-						 nc, tmp_data, nr, anorm, 
-						 rcond, pz, piz, info
-						 F77_CHAR_ARG_LEN (1)));
-	      
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler) 
-			  ("unrecoverable error in dgecon");
-	      
-		      if (info != 0) 
-			info = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-			{
-			  info = -2;
-
-			  if (sing_handler)
-			    sing_handler (rcond);
-			  else
-			    (*current_liboctave_error_handler)
-			      ("matrix singular to machine precision, rcond = %g",
-			       rcond);
-			}
+		      info = -2;
+
+		      if (sing_handler)
+			sing_handler (rcond);
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-
-		  if (info == 0)
-		    {
-		      retval = b;
-		      double *result = retval.fortran_vec ();
-
-		      octave_idx_type b_nc = b.cols ();
-
-		      char job = 'N';
-		      F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-						 nr, b_nc, tmp_data, nr,
-						 pipvt, result, b.rows(), info
-						 F77_CHAR_ARG_LEN (1)));
-		
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler)
-			  ("unrecoverable error in dgetrs");
-		    }
-		  else
-		    mattype.mark_as_rectangular ();
 		}
+
+	      if (info == 0)
+		{
+		  retval = b;
+		  double *result = retval.fortran_vec ();
+
+		  octave_idx_type b_nc = b.cols ();
+
+		  char job = 'N';
+		  F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, b_nc, tmp_data, nr,
+					     pipvt, result, b.rows(), info
+					     F77_CHAR_ARG_LEN (1)));
+		}
+	      else
+		mattype.mark_as_rectangular ();
 	    }
 	}
       else if (typ != MatrixType::Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -2165,45 +2083,33 @@ Matrix::lssolve (const Matrix& b, octave
 	    addend = wlalsd;
 
 	  const octave_idx_type lworkaround = 4*m + m*m + addend;
 
 	  if (work(0) < lworkaround)
 	    work(0) = lworkaround;
 	}
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) 
-	  ("unrecoverable error in dgelsd");
+      lwork = static_cast<octave_idx_type> (work(0));
+      work.resize (lwork);
+
+      F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
+				 maxmn, ps, rcond, rank,
+				 work.fortran_vec (), lwork, 
+				 piwork, info));
+
+      if (rank < minmn)
+	(*current_liboctave_warning_handler) 
+	  ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
+      if (s.elem (0) == 0.0)
+	rcond = 0.0;
       else
-	{
-	  lwork = static_cast<octave_idx_type> (work(0));
-	  work.resize (lwork);
-
-	  F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				     maxmn, ps, rcond, rank,
-				     work.fortran_vec (), lwork, 
-				     piwork, info));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgelsd");
-	  else 
-	    {
-	      if (rank < minmn)
-		(*current_liboctave_warning_handler) 
-		  ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
-	      if (s.elem (0) == 0.0)
-		rcond = 0.0;
-	      else
-		rcond = s.elem (minmn - 1) / s.elem (0);
-
-	      retval.resize (n, nrhs);
-	    }
-	}
+	rcond = s.elem (minmn - 1) / s.elem (0);
+
+      retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::lssolve (const ComplexMatrix& b) const
 {
@@ -2330,45 +2236,36 @@ Matrix::lssolve (const ColumnVector& b, 
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
 				 ps, rcond, rank, work.fortran_vec (),
 				 lwork, piwork, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) 
-	  ("unrecoverable error in dgelsd");
-      else
+      lwork = static_cast<octave_idx_type> (work(0));
+      work.resize (lwork);
+
+      F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
+				 maxmn, ps, rcond, rank,
+				 work.fortran_vec (), lwork, 
+				 piwork, info));
+
+      if (rank < minmn)
 	{
-	  lwork = static_cast<octave_idx_type> (work(0));
-	  work.resize (lwork);
-
-	  F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				     maxmn, ps, rcond, rank,
-				     work.fortran_vec (), lwork, 
-				     piwork, info));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgelsd");
-	  else if (rank < minmn)
-	    {
-	      if (rank < minmn)
-		(*current_liboctave_warning_handler) 
-		  ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
-	      if (s.elem (0) == 0.0)
-		rcond = 0.0;
-	      else
-		rcond = s.elem (minmn - 1) / s.elem (0);
-	    }
-
-	  retval.resize (n, nrhs);
+	  if (rank < minmn)
+	    (*current_liboctave_warning_handler) 
+	      ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
+	  if (s.elem (0) == 0.0)
+	    rcond = 0.0;
+	  else
+	    rcond = s.elem (minmn - 1) / s.elem (0);
 	}
+
+      retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 ComplexColumnVector
 Matrix::lssolve (const ComplexColumnVector& b) const
 {
@@ -2474,38 +2371,26 @@ Matrix::expm (void) const
 
   // then scaling
   job = 'S';
   F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
 			     nc, p_m, nc, ilos, ihis,
 			     dscale.fortran_vec (), info
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler) ("unrecoverable error in dgebal");
-      return retval;
-    }
-
   // Preconditioning step 3: scaling.
   
   ColumnVector work(nc);
   double inf_norm;
   
   F77_XFCN (xdlange, XDLANGE, (F77_CONST_CHAR_ARG2 ("I", 1),
 			       nc, nc, m.fortran_vec (), nc,
 			       work.fortran_vec (), inf_norm
 			       F77_CHAR_ARG_LEN (1)));
   
-  if (f77_exception_encountered)
-    {
-      (*current_liboctave_error_handler) ("unrecoverable error in dlange");
-      return retval;
-    }
-
   octave_idx_type sqpow = static_cast<octave_idx_type> (inf_norm > 0.0
 		     ? (1.0 + log (inf_norm) / log (2.0))
 		     : 0.0);
   
   // Check whether we need to square at all.
   
   if (sqpow < 0)
     sqpow = 0;
@@ -2718,20 +2603,16 @@ operator * (const ColumnVector& v, const
       double *c = retval.fortran_vec ();
 	  
       F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
 			       F77_CONST_CHAR_ARG2 ("N", 1),
 			       len, a_len, 1, 1.0, v.data (), len,
 			       a.data (), 1, 0.0, c, len
 			       F77_CHAR_ARG_LEN (1)
 			       F77_CHAR_ARG_LEN (1)));
-
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler)
-	  ("unrecoverable error in dgemm");
     }
 
   return retval;
 }
 
 // other operations.
 
 Matrix
@@ -3322,24 +3203,19 @@ Sylvester (const Matrix& a, const Matrix
   F77_XFCN (dtrsyl, DTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
 			     F77_CONST_CHAR_ARG2 ("N", 1),
 			     1, a_nr, b_nr, pa, a_nr, pb,
 			     b_nr, px, a_nr, scale, info
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dtrsyl");
-  else
-    {
-      // FIXME -- check info?
+  // FIXME -- check info?
   
-      retval = -ua*cx*ub.transpose ();
-    }
+  retval = -ua*cx*ub.transpose ();
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
 
 /* Simple Dot Product, Matrix-Vector and Matrix-Matrix Unit tests
 %!assert([1 2 3] * [ 4 ; 5 ; 6], 32, 1e-14)
@@ -3388,34 +3264,26 @@ operator * (const Matrix& m, const Matri
 	      if (nr == 1)
 		F77_FUNC (xddot, XDDOT) (nc, m.data (), 1, a.data (), 1, *c);
 	      else
 		{
 		  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
 					   nr, nc, 1.0,  m.data (), ld,
 					   a.data (), 1, 0.0, c, 1
 					   F77_CHAR_ARG_LEN (1)));
-
-		  if (f77_exception_encountered)
-		    (*current_liboctave_error_handler)
-		      ("unrecoverable error in dgemv");
 		}
             }
 	  else
 	    {
 	      F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
 				       F77_CONST_CHAR_ARG2 ("N", 1),
 				       nr, a_nc, nc, 1.0, m.data (),
 				       ld, a.data (), lda, 0.0, c, nr
 				       F77_CHAR_ARG_LEN (1)
 				       F77_CHAR_ARG_LEN (1)));
-
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler)
-		  ("unrecoverable error in dgemm");
 	    }
 	}
     }
 
   return retval;
 }
 
 // FIXME -- it would be nice to share code among the min/max
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -218,20 +218,16 @@ operator * (const RowVector& v, const Ma
 
 	  retval.resize (a_nc);
 	  double *y = retval.fortran_vec ();
 
 	  F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
 				   a_nr, a_nc, 1.0, a.data (),
 				   ld, v.data (), 1, 0.0, y, 1
 				   F77_CHAR_ARG_LEN (1)));
-
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in dgemv");
 	}
     }
 
   return retval;
 }
 
 // other operations
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -3816,20 +3816,17 @@ SparseMatrix::trisolve (MatrixType &matt
 	      
 	  octave_idx_type b_nc = b.cols();
 	  retval = b;
 	  double *result = retval.fortran_vec ();
 
 	  F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result, 
 				   b.rows(), err));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dptsv");
-	  else if (err != 0)
+	  if (err != 0)
 	    {
 	      err = 0;
 	      mattype.mark_as_unsymmetric ();
 	      typ = MatrixType::Tridiagonal;
 	    }
 	  else 
 	    rcond = 1.;
 	}
@@ -3876,20 +3873,17 @@ SparseMatrix::trisolve (MatrixType &matt
 
 	  octave_idx_type b_nc = b.cols();
 	  retval = b;
 	  double *result = retval.fortran_vec ();
 
 	  F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result, 
 				   b.rows(), err));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgtsv");
-	  else if (err != 0)
+	  if (err != 0)
 	    {
 	      rcond = 0.;
 	      err = -2;
 
 	      if (sing_handler)
 		{
 		  sing_handler (rcond);
 		  mattype.mark_as_rectangular ();
@@ -3977,94 +3971,81 @@ SparseMatrix::trisolve (MatrixType &matt
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgttrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  rcond = 0.0;
-		  err = -2;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		} 
-	      else 
-		{
-		  rcond = 1.0;
-		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  octave_idx_type b_nc = b.cols ();
-		  retval = SparseMatrix (nr, b_nc, x_nz);
-		  retval.xcidx(0) = 0;
-		  volatile octave_idx_type ii = 0;
-
-		  OCTAVE_LOCAL_BUFFER (double, work, nr);
-
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+	  if (err != 0) 
+	    {
+	      rcond = 0.0;
+	      err = -2;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	    } 
+	  else 
+	    {
+	      rcond = 1.0;
+	      char job = 'N';
+	      volatile octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type b_nc = b.cols ();
+	      retval = SparseMatrix (nr, b_nc, x_nz);
+	      retval.xcidx(0) = 0;
+	      volatile octave_idx_type ii = 0;
+
+	      OCTAVE_LOCAL_BUFFER (double, work, nr);
+
+	      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		{
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    work[i] = 0.;
+		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+		    work[b.ridx(i)] = b.data(i);
+
+		  F77_XFCN (dgttrs, DGTTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, 1, DL, D, DU, DU2, pipvt, 
+			     work, b.rows (), err
+			     F77_CHAR_ARG_LEN (1)));
+
+		  // Count non-zeros in work vector and adjust 
+		  // space in retval if needed
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    if (work[i] != 0.)
+		      new_nnz++;
+
+		  if (ii + new_nnz > x_nz)
 		    {
-		      for (octave_idx_type i = 0; i < nr; i++)
-			work[i] = 0.;
-		      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-			work[b.ridx(i)] = b.data(i);
-
-		      F77_XFCN (dgttrs, DGTTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, 1, DL, D, DU, DU2, pipvt, 
-				 work, b.rows (), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgttrs");
-			  break;
-			}
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  new_nnz++;
-
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (work[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = work[i];
-			  }
-		      retval.xcidx(j+1) = ii;
+		      // Resize the sparse matrix
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+		      retval.change_capacity (sz);
+		      x_nz = sz;
 		    }
 
-		  retval.maybe_compress ();
-		}
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    if (work[i] != 0.)
+		      {
+			retval.xridx(ii) = i;
+			retval.xdata(ii++) = work[i];
+		      }
+		  retval.xcidx(j+1) = ii;
+		}
+
+	      retval.maybe_compress ();
 	    }
 	}
       else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4136,23 +4117,17 @@ SparseMatrix::trisolve (MatrixType &matt
 	  rcond = 1.;
 
 	  retval = b;
 	  Complex *result = retval.fortran_vec ();
 		  
 	  F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
 				   b_nr, err));
 
-	  if (f77_exception_encountered)
-	    {
-	      (*current_liboctave_error_handler) 
-		("unrecoverable error in zptsv");
-	      err = -1;
-	    }
-	  else if (err != 0)
+	  if (err != 0)
 	    {
 	      err = 0;
 	      mattype.mark_as_unsymmetric ();
 	      typ = MatrixType::Tridiagonal;
 	    }
 	}
 
       if (typ == MatrixType::Tridiagonal)
@@ -4200,23 +4175,17 @@ SparseMatrix::trisolve (MatrixType &matt
 	  rcond = 1.;
 
 	  retval = b;
 	  Complex *result = retval.fortran_vec ();
 	      
 	  F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
 				   b_nr, err));
 
-	  if (f77_exception_encountered)
-	    {
-	      (*current_liboctave_error_handler) 
-		("unrecoverable error in zgtsv");
-	      err = -1;
-	    }
-	  else if (err != 0)
+	  if (err != 0)
 	    {
 	      rcond = 0.;
 	      err = -2;
 		      
 	      if (sing_handler)
 		{
 		  sing_handler (rcond);
 		  mattype.mark_as_rectangular ();
@@ -4301,133 +4270,113 @@ SparseMatrix::trisolve (MatrixType &matt
 		      DL[j] = data(i);
 		    else if (ridx(i) == j - 1)
 		      DU[j-1] = data(i);
 		  }
 	    }
 
 	  F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgttrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  rcond = 0.0;
-		  err = -2;
-
-		  if (sing_handler)
+	  if (err != 0) 
+	    {
+	      rcond = 0.0;
+	      err = -2;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+	    } 
+	  else 
+	    {	
+	      rcond = 1.;
+	      char job = 'N';
+	      octave_idx_type b_nr = b.rows ();
+	      octave_idx_type b_nc = b.cols ();
+	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+	      // Take a first guess that the number of non-zero terms
+	      // will be as many as in b
+	      volatile octave_idx_type x_nz = b.nnz ();
+	      volatile octave_idx_type ii = 0;
+	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+	      retval.xcidx(0) = 0;
+	      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		{
+
+		  for (octave_idx_type i = 0; i < b_nr; i++)
 		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
+		      Complex c = b (i,j);
+		      Bx[i] = std::real (c);
+		      Bz[i] = std::imag (c);
 		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-		} 
-	      else 
-		{	
-		  rcond = 1.;
-		  char job = 'N';
-		  octave_idx_type b_nr = b.rows ();
-		  octave_idx_type b_nc = b.cols ();
-		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-		  // Take a first guess that the number of non-zero terms
-		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
-		  volatile octave_idx_type ii = 0;
-		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		  retval.xcidx(0) = 0;
-		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+
+		  F77_XFCN (dgttrs, DGTTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, 1, DL, D, DU, DU2, pipvt, 
+			     Bx, b_nr, err
+			     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0)
 		    {
-
-		      for (octave_idx_type i = 0; i < b_nr; i++)
-			{
-			  Complex c = b (i,j);
-			  Bx[i] = std::real (c);
-			  Bz[i] = std::imag (c);
-			}
-
-		      F77_XFCN (dgttrs, DGTTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, 1, DL, D, DU, DU2, pipvt, 
-				 Bx, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgttrs");
-			  break;
-			}
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler)
-			    ("SparseMatrix::solve solve failed");
-
-			  err = -1;
-			  break;
-			}
-
-		      F77_XFCN (dgttrs, DGTTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, 1, DL, D, DU, DU2, pipvt, 
-				 Bz, b_nr, err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			{
-			  (*current_liboctave_error_handler)
-			    ("unrecoverable error in dgttrs");
-			  break;
-			}
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler)
-			    ("SparseMatrix::solve solve failed");
-
-			  err = -1;
-			  break;
-			}
-
-		      // Count non-zeros in work vector and adjust 
-		      // space in retval if needed
-		      octave_idx_type new_nnz = 0;
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  new_nnz++;
-		      
-		      if (ii + new_nnz > x_nz)
-			{
-			  // Resize the sparse matrix
-			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			  retval.change_capacity (sz);
-			  x_nz = sz;
-			}
-			  
-		      for (octave_idx_type i = 0; i < nr; i++)
-			if (Bx[i] != 0. || Bz[i] != 0.)
-			  {
-			    retval.xridx(ii) = i;
-			    retval.xdata(ii++) = 
-			      Complex (Bx[i], Bz[i]);
-			  }
-
-		      retval.xcidx(j+1) = ii;
+		      (*current_liboctave_error_handler)
+			("SparseMatrix::solve solve failed");
+
+		      err = -1;
+		      break;
+		    }
+
+		  F77_XFCN (dgttrs, DGTTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, 1, DL, D, DU, DU2, pipvt, 
+			     Bz, b_nr, err
+			     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0)
+		    {
+		      (*current_liboctave_error_handler)
+			("SparseMatrix::solve solve failed");
+
+		      err = -1;
+		      break;
 		    }
 
-		  retval.maybe_compress ();
-		}
+		  // Count non-zeros in work vector and adjust 
+		  // space in retval if needed
+		  octave_idx_type new_nnz = 0;
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    if (Bx[i] != 0. || Bz[i] != 0.)
+		      new_nnz++;
+
+		  if (ii + new_nnz > x_nz)
+		    {
+		      // Resize the sparse matrix
+		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+		      retval.change_capacity (sz);
+		      x_nz = sz;
+		    }
+
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    if (Bx[i] != 0. || Bz[i] != 0.)
+		      {
+			retval.xridx(ii) = i;
+			retval.xdata(ii++) = 
+			  Complex (Bx[i], Bz[i]);
+		      }
+
+		  retval.xcidx(j+1) = ii;
+		}
+
+	      retval.maybe_compress ();
 	    }
 	}
       else if (typ != MatrixType::Tridiagonal_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
@@ -4484,95 +4433,81 @@ SparseMatrix::bsolve (MatrixType &mattyp
 	  if (calc_cond)
 	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dpbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  // Matrix is not positive definite!! Fall through to
-		  // unsymmetric banded solver.
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Banded;
-		  rcond = 0.0;
-		  err = 0;
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  if (err != 0) 
+	    {
+	      // Matrix is not positive definite!! Fall through to
+	      // unsymmetric banded solver.
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Banded;
+	      rcond = 0.0;
+	      err = 0;
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  Array<double> z (3 * nr);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nr);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dpbcon, DGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nr, n_lower, tmp_data, ldm,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      Array<double> z (3 * nr);
-		      double *pz = z.fortran_vec ();
-		      Array<octave_idx_type> iz (nr);
-		      octave_idx_type *piz = iz.fortran_vec ();
-
-		      F77_XFCN (dpbcon, DGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nr, n_lower, tmp_data, ldm,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		      	(*current_liboctave_error_handler) 
-		      	  ("unrecoverable error in dpbcon");
-
-		      if (err != 0) 
-		      	err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  retval = b;
+		  double *result = retval.fortran_vec ();
+
+		  octave_idx_type b_nc = b.cols ();
+
+		  F77_XFCN (dpbtrs, DPBTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, n_lower, b_nc, tmp_data,
+			     ldm, result, b.rows(), err
+			     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0)
 		    {
-		      retval = b;
-		      double *result = retval.fortran_vec ();
-
-		      octave_idx_type b_nc = b.cols ();
-
-		      F77_XFCN (dpbtrs, DPBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, b_nc, tmp_data,
-				 ldm, result, b.rows(), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler)
-			  ("unrecoverable error in dpbtrs");
-
-		      if (err != 0)
-			{
-			  (*current_liboctave_error_handler) 
-			    ("SparseMatrix::solve solve failed");
-			  err = -1;
-			}
+		      (*current_liboctave_error_handler) 
+			("SparseMatrix::solve solve failed");
+		      err = -1;
 		    }
 		}
 	    }
 	}
 
       if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
@@ -4611,99 +4546,85 @@ SparseMatrix::bsolve (MatrixType &mattyp
 	    }
 
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgbtrf");
-	  else
-	    {
-	      // Throw-away extra info LAPACK gives so as to not 
-	      // change output.
-	      if (err != 0) 
-		{
-		  err = -2;
-		  rcond = 0.0;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  // Throw-away extra info LAPACK gives so as to not 
+	  // change output.
+	  if (err != 0) 
+	    {
+	      err = -2;
+	      rcond = 0.0;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  char job = '1';
+		  Array<double> z (3 * nr);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nr);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dgbcon, DGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		   if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      char job = '1';
-		      Array<double> z (3 * nr);
-		      double *pz = z.fortran_vec ();
-		      Array<octave_idx_type> iz (nr);
-		      octave_idx_type *piz = iz.fortran_vec ();
-
-		      F77_XFCN (dgbcon, DGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		        (*current_liboctave_error_handler) 
-		          ("unrecoverable error in dgbcon");
-
-		       if (err != 0) 
-		        err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
-		    {
-		      retval = b;
-		      double *result = retval.fortran_vec ();
-
-		      octave_idx_type b_nc = b.cols ();
-
-		      char job = 'N';
-		      F77_XFCN (dgbtrs, DGBTRS, 
-				(F77_CONST_CHAR_ARG2 (&job, 1),
-				 nr, n_lower, n_upper, b_nc, tmp_data,
-				 ldm, pipvt, result, b.rows(), err
-				 F77_CHAR_ARG_LEN (1)));
-		    
-		      if (f77_exception_encountered)
-			(*current_liboctave_error_handler)
-			  ("unrecoverable error in dgbtrs");
-		    }
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  retval = b;
+		  double *result = retval.fortran_vec ();
+
+		  octave_idx_type b_nc = b.cols ();
+
+		  char job = 'N';
+		  F77_XFCN (dgbtrs, DGBTRS, 
+			    (F77_CONST_CHAR_ARG2 (&job, 1),
+			     nr, n_lower, n_upper, b_nc, tmp_data,
+			     ldm, pipvt, result, b.rows(), err
+			     F77_CHAR_ARG_LEN (1)));
 		}
 	    }
 	}
       else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -4762,133 +4683,115 @@ SparseMatrix::bsolve (MatrixType &mattyp
 	  if (calc_cond)
 	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dpbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Banded;
-		  rcond = 0.0;
-		  err = 0;
-		} 
-	      else 
-		{
-		  if (calc_cond)
-		    {
-		      Array<double> z (3 * nr);
-		      double *pz = z.fortran_vec ();
-		      Array<octave_idx_type> iz (nr);
-		      octave_idx_type *piz = iz.fortran_vec ();
-
-		      F77_XFCN (dpbcon, DGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nr, n_lower, tmp_data, ldm,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		      	(*current_liboctave_error_handler) 
-		      	  ("unrecoverable error in dpbcon");
-
-		      if (err != 0) 
-		      	err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
-		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
+	  if (err != 0) 
+	    {
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Banded;
+	      rcond = 0.0;
+	      err = 0;
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  Array<double> z (3 * nr);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nr);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dpbcon, DGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nr, n_lower, tmp_data, ldm,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      octave_idx_type b_nr = b.rows ();
-		      octave_idx_type b_nc = b.cols ();
-		      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-
-		      // Take a first guess that the number of non-zero terms
-		      // will be as many as in b
-		      volatile octave_idx_type x_nz = b.nnz ();
-		      volatile octave_idx_type ii = 0;
-		      retval = SparseMatrix (b_nr, b_nc, x_nz);
-
-		      retval.xcidx(0) = 0;
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      err = -2;
+
+		      if (sing_handler)
 			{
-			  for (octave_idx_type i = 0; i < b_nr; i++)
-			    Bx[i] = b.elem (i, j);
-
-			  F77_XFCN (dpbtrs, DPBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, 1, tmp_data,
-				     ldm, Bx, b_nr, err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
+		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+
+		  // Take a first guess that the number of non-zero terms
+		  // will be as many as in b
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
+		  retval = SparseMatrix (b_nr, b_nc, x_nz);
+
+		  retval.xcidx(0) = 0;
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		    {
+		      for (octave_idx_type i = 0; i < b_nr; i++)
+			Bx[i] = b.elem (i, j);
+
+		      F77_XFCN (dpbtrs, DPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, 1, tmp_data,
+				 ldm, Bx, b_nr, err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler) 
+			    ("SparseMatrix::solve solve failed");
+			  err = -1;
+			  break;
+			}
+
+		      for (octave_idx_type i = 0; i < b_nr; i++)
+			{
+			  double tmp = Bx[i];
+			  if (tmp != 0.0)
 			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dpbtrs");
-			      err = -1;
-			      break;
+			      if (ii == x_nz)
+				{
+				  // Resize the sparse matrix
+				  octave_idx_type sz = x_nz * 
+				    (b_nc - j) / b_nc;
+				  sz = (sz > 10 ? sz : 10) + x_nz;
+				  retval.change_capacity (sz);
+				  x_nz = sz;
+				}
+			      retval.xdata(ii) = tmp;
+			      retval.xridx(ii++) = i;
 			    }
-
-			  if (err != 0)
-			    {
-			      (*current_liboctave_error_handler) 
-				("SparseMatrix::solve solve failed");
-			      err = -1;
-			      break;
-			    }
-
-			  for (octave_idx_type i = 0; i < b_nr; i++)
-			    {
-			      double tmp = Bx[i];
-			      if (tmp != 0.0)
-				{
-				  if (ii == x_nz)
-				    {
-				      // Resize the sparse matrix
-				      octave_idx_type sz = x_nz * 
-					(b_nc - j) / b_nc;
-				      sz = (sz > 10 ? sz : 10) + x_nz;
-				      retval.change_capacity (sz);
-				      x_nz = sz;
-				    }
-				  retval.xdata(ii) = tmp;
-				  retval.xridx(ii++) = i;
-				}
-			    }
-			  retval.xcidx(j+1) = ii;
 			}
-
-		      retval.maybe_compress ();
+		      retval.xcidx(j+1) = ii;
 		    }
+
+		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
@@ -4926,137 +4829,120 @@ SparseMatrix::bsolve (MatrixType &mattyp
 	    }
 
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  err = -2;
-		  rcond = 0.0;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  if (err != 0) 
+	    {
+	      err = -2;
+	      rcond = 0.0;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  char job = '1';
+		  Array<double> z (3 * nr);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nr);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dgbcon, DGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		   if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      char job = '1';
-		      Array<double> z (3 * nr);
-		      double *pz = z.fortran_vec ();
-		      Array<octave_idx_type> iz (nr);
-		      octave_idx_type *piz = iz.fortran_vec ();
-
-		      F77_XFCN (dgbcon, DGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		        (*current_liboctave_error_handler) 
-		          ("unrecoverable error in dgbcon");
-
-		       if (err != 0) 
-		        err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  char job = 'N';
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
+		  retval = SparseMatrix (nr, b_nc, x_nz);
+		  retval.xcidx(0) = 0;
+		  volatile octave_idx_type ii = 0;
+
+		  OCTAVE_LOCAL_BUFFER (double, work, nr);
+
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      char job = 'N';
-		      volatile octave_idx_type x_nz = b.nnz ();
-		      octave_idx_type b_nc = b.cols ();
-		      retval = SparseMatrix (nr, b_nc, x_nz);
-		      retval.xcidx(0) = 0;
-		      volatile octave_idx_type ii = 0;
-
-		      OCTAVE_LOCAL_BUFFER (double, work, nr);
-
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      for (octave_idx_type i = 0; i < nr; i++)
+			work[i] = 0.;
+		      for (octave_idx_type i = b.cidx(j); 
+			   i < b.cidx(j+1); i++)
+			work[b.ridx(i)] = b.data(i);
+
+		      F77_XFCN (dgbtrs, DGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, 1, tmp_data,
+				 ldm, pipvt, work, b.rows (), err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      // Count non-zeros in work vector and adjust 
+		      // space in retval if needed
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (work[i] != 0.)
+			  new_nnz++;
+
+		      if (ii + new_nnz > x_nz)
 			{
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    work[i] = 0.;
-			  for (octave_idx_type i = b.cidx(j); 
-			       i < b.cidx(j+1); i++)
-			    work[b.ridx(i)] = b.data(i);
-
-			  F77_XFCN (dgbtrs, DGBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, n_upper, 1, tmp_data,
-				     ldm, pipvt, work, b.rows (), err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dgbtrs");
-			      break;
-			    }
-
-			  // Count non-zeros in work vector and adjust 
-			  // space in retval if needed
-			  octave_idx_type new_nnz = 0;
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (work[i] != 0.)
-			      new_nnz++;
-
-			  if (ii + new_nnz > x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (work[i] != 0.)
-			      {
-				retval.xridx(ii) = i;
-				retval.xdata(ii++) = work[i];
-			      }
-			  retval.xcidx(j+1) = ii;
+			  // Resize the sparse matrix
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			  retval.change_capacity (sz);
+			  x_nz = sz;
 			}
 
-		      retval.maybe_compress ();
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (work[i] != 0.)
+			  {
+			    retval.xridx(ii) = i;
+			    retval.xdata(ii++) = work[i];
+			  }
+		      retval.xcidx(j+1) = ii;
 		    }
+
+		  retval.maybe_compress ();
 		}
 	    }
 	}
       else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -5115,138 +5001,112 @@ SparseMatrix::bsolve (MatrixType &mattyp
 	  if (calc_cond)
 	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dpbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  // Matrix is not positive definite!! Fall through to
-		  // unsymmetric banded solver.
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Banded;
-		  rcond = 0.0;
-		  err = 0;
-		} 
-	      else 
-		{
-		  if (calc_cond)
-		    {
-		      Array<double> z (3 * nr);
-		      double *pz = z.fortran_vec ();
-		      Array<octave_idx_type> iz (nr);
-		      octave_idx_type *piz = iz.fortran_vec ();
-
-		      F77_XFCN (dpbcon, DGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nr, n_lower, tmp_data, ldm,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		      	(*current_liboctave_error_handler) 
-		      	  ("unrecoverable error in dpbcon");
-
-		      if (err != 0) 
-		      	err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
-		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
+	  if (err != 0) 
+	    {
+	      // Matrix is not positive definite!! Fall through to
+	      // unsymmetric banded solver.
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Banded;
+	      rcond = 0.0;
+	      err = 0;
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  Array<double> z (3 * nr);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nr);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dpbcon, DGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nr, n_lower, tmp_data, ldm,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      octave_idx_type b_nr = b.rows ();
-		      octave_idx_type b_nc = b.cols ();
-
-		      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-		      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-		      retval.resize (b_nr, b_nc);
-	      
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
+
+		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+		  retval.resize (b_nr, b_nc);
+
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		    {
+		      for (octave_idx_type i = 0; i < b_nr; i++)
 			{
-			  for (octave_idx_type i = 0; i < b_nr; i++)
-			    {
-			      Complex c = b (i,j);
-			      Bx[i] = std::real (c);
-			      Bz[i] = std::imag (c);
-			    }
-			  
-			  F77_XFCN (dpbtrs, DPBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, 1, tmp_data,
-				     ldm, Bx, b_nr, err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dpbtrs");
-			      err = -1;
-			      break;
-			    }
-
-			  if (err != 0)
-			    {
-			      (*current_liboctave_error_handler) 
-				("SparseMatrix::solve solve failed");
-			      err = -1;
-			      break;
-			    }
-
-			  F77_XFCN (dpbtrs, DPBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, 1, tmp_data,
-				     ldm, Bz, b.rows(), err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dpbtrs");
-			      err = -1;
-			      break;
-			    }
-
-			  if (err != 0)
-			    {
-			      (*current_liboctave_error_handler) 
-				("SparseMatrix::solve solve failed");
-			      err = -1;
-			      break;
-			    }
-
-			  for (octave_idx_type i = 0; i < b_nr; i++)
-			    retval (i, j) = Complex (Bx[i], Bz[i]);
+			  Complex c = b (i,j);
+			  Bx[i] = std::real (c);
+			  Bz[i] = std::imag (c);
+			}
+
+		      F77_XFCN (dpbtrs, DPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, 1, tmp_data,
+				 ldm, Bx, b_nr, err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler) 
+			    ("SparseMatrix::solve solve failed");
+			  err = -1;
+			  break;
 			}
+
+		      F77_XFCN (dpbtrs, DPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, 1, tmp_data,
+				 ldm, Bz, b.rows(), err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler) 
+			    ("SparseMatrix::solve solve failed");
+			  err = -1;
+			  break;
+			}
+
+		      for (octave_idx_type i = 0; i < b_nr; i++)
+			retval (i, j) = Complex (Bx[i], Bz[i]);
 		    }
 		}
 	    }
 	}
 
       if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
@@ -5285,126 +5145,102 @@ SparseMatrix::bsolve (MatrixType &mattyp
 	    }
 
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  err = -2;
-		  rcond = 0.0;
-
-		  if (sing_handler)
-		    {
-		    sing_handler (rcond);
-		    mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  if (err != 0) 
+	    {
+	      err = -2;
+	      rcond = 0.0;
+
+	      if (sing_handler)
+		{
+		sing_handler (rcond);
+		mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  char job = '1';
+		  Array<double> z (3 * nr);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nr);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dpbcon, DGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nr, n_lower, tmp_data, ldm,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      char job = '1';
-		      Array<double> z (3 * nr);
-		      double *pz = z.fortran_vec ();
-		      Array<octave_idx_type> iz (nr);
-		      octave_idx_type *piz = iz.fortran_vec ();
-
-		      F77_XFCN (dpbcon, DGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nr, n_lower, tmp_data, ldm,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		      	(*current_liboctave_error_handler) 
-		      	  ("unrecoverable error in dpbcon");
-
-		      if (err != 0) 
-		      	err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-		            sing_handler (rcond);
-			    mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			sing_handler (rcond);
+			mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
 		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  char job = 'N';
+		  octave_idx_type b_nc = b.cols ();
+		  retval.resize (nr,b_nc);
+
+		  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
+		  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
+
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
-		      char job = 'N';
-		      octave_idx_type b_nc = b.cols ();
-		      retval.resize (nr,b_nc);
-
-		      OCTAVE_LOCAL_BUFFER (double, Bz, nr);
-		      OCTAVE_LOCAL_BUFFER (double, Bx, nr);
-
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      for (octave_idx_type i = 0; i < nr; i++)
 			{
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    {
-			      Complex c = b (i, j);
-			      Bx[i] = std::real (c);
-			      Bz[i] = std::imag  (c);
-			    }
-
-			  F77_XFCN (dgbtrs, DGBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, n_upper, 1, tmp_data,
-				     ldm, pipvt, Bx, b.rows (), err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dgbtrs");
-			      break;
-			    }
-
-			  F77_XFCN (dgbtrs, DGBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, n_upper, 1, tmp_data,
-				     ldm, pipvt, Bz, b.rows (), err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dgbtrs");
-			      break;
-			    }
-
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    retval (i, j) = Complex (Bx[i], Bz[i]);
+			  Complex c = b (i, j);
+			  Bx[i] = std::real (c);
+			  Bz[i] = std::imag  (c);
 			}
+
+		      F77_XFCN (dgbtrs, DGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, 1, tmp_data,
+				 ldm, pipvt, Bx, b.rows (), err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      F77_XFCN (dgbtrs, DGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, 1, tmp_data,
+				 ldm, pipvt, Bz, b.rows (), err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      for (octave_idx_type i = 0; i < nr; i++)
+			retval (i, j) = Complex (Bx[i], Bz[i]);
 		    }
 		}
 	    }
 	}
       else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -5464,170 +5300,144 @@ SparseMatrix::bsolve (MatrixType &mattyp
 	  if (calc_cond)
 	    anorm = m_band.abs().sum().row(0).max();
 
 	  char job = 'L';
 	  F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nr, n_lower, tmp_data, ldm, err
 				     F77_CHAR_ARG_LEN (1)));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dpbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  // Matrix is not positive definite!! Fall through to
-		  // unsymmetric banded solver.
-		  mattype.mark_as_unsymmetric ();
-		  typ = MatrixType::Banded;
-
-		  rcond = 0.0;
-		  err = 0;
-		} 
-	      else 
-		{
-		  if (calc_cond)
+	  if (err != 0) 
+	    {
+	      // Matrix is not positive definite!! Fall through to
+	      // unsymmetric banded solver.
+	      mattype.mark_as_unsymmetric ();
+	      typ = MatrixType::Banded;
+
+	      rcond = 0.0;
+	      err = 0;
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  Array<double> z (3 * nr);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nr);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dpbcon, DGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nr, n_lower, tmp_data, ldm,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		  if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      Array<double> z (3 * nr);
-		      double *pz = z.fortran_vec ();
-		      Array<octave_idx_type> iz (nr);
-		      octave_idx_type *piz = iz.fortran_vec ();
-
-		      F77_XFCN (dpbcon, DGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nr, n_lower, tmp_data, ldm,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		      	(*current_liboctave_error_handler) 
-		      	  ("unrecoverable error in dpbcon");
-
-		      if (err != 0) 
-		      	err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
-		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
-		    {
-		      octave_idx_type b_nr = b.rows ();
-		      octave_idx_type b_nc = b.cols ();
-		      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
-		      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
-
-		      // Take a first guess that the number of non-zero terms
-		      // will be as many as in b
-		      volatile octave_idx_type x_nz = b.nnz ();
-		      volatile octave_idx_type ii = 0;
-		      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
-
-		      retval.xcidx(0) = 0;
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      err = -2;
+
+		      if (sing_handler)
 			{
-
-			  for (octave_idx_type i = 0; i < b_nr; i++)
-			    {
-			      Complex c = b (i,j);
-			      Bx[i] = std::real (c);
-			      Bz[i] = std::imag (c);
-			    }
-
-			  F77_XFCN (dpbtrs, DPBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, 1, tmp_data,
-				     ldm, Bx, b_nr, err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dpbtrs");
-			      err = -1;
-			      break;
-			    }
-
-			  if (err != 0)
-			    {
-			      (*current_liboctave_error_handler) 
-				("SparseMatrix::solve solve failed");
-			      err = -1;
-			      break;
-			    }
-
-			  F77_XFCN (dpbtrs, DPBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, 1, tmp_data,
-				     ldm, Bz, b_nr, err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dpbtrs");
-			      err = -1;
-			      break;
-			    }
-
-			  if (err != 0)
-			    {
-			      (*current_liboctave_error_handler)
-				("SparseMatrix::solve solve failed");
-
-			      err = -1;
-			      break;
-			    }
-
-			  // Count non-zeros in work vector and adjust 
-			  // space in retval if needed
-			  octave_idx_type new_nnz = 0;
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (Bx[i] != 0. || Bz[i] != 0.)
-			      new_nnz++;
-			  
-			  if (ii + new_nnz > x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-			  
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (Bx[i] != 0. || Bz[i] != 0.)
-			      {
-				retval.xridx(ii) = i;
-				retval.xdata(ii++) = 
-				  Complex (Bx[i], Bz[i]);
-			      }
-
-			  retval.xcidx(j+1) = ii;
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  octave_idx_type b_nr = b.rows ();
+		  octave_idx_type b_nc = b.cols ();
+		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
+		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
+
+		  // Take a first guess that the number of non-zero terms
+		  // will be as many as in b
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type ii = 0;
+		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
+
+		  retval.xcidx(0) = 0;
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		    {
+
+		      for (octave_idx_type i = 0; i < b_nr; i++)
+			{
+			  Complex c = b (i,j);
+			  Bx[i] = std::real (c);
+			  Bz[i] = std::imag (c);
 			}
 
-		      retval.maybe_compress ();
+		      F77_XFCN (dpbtrs, DPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, 1, tmp_data,
+				 ldm, Bx, b_nr, err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler) 
+			    ("SparseMatrix::solve solve failed");
+			  err = -1;
+			  break;
+			}
+
+		      F77_XFCN (dpbtrs, DPBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, 1, tmp_data,
+				 ldm, Bz, b_nr, err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      if (err != 0)
+			{
+			  (*current_liboctave_error_handler)
+			    ("SparseMatrix::solve solve failed");
+
+			  err = -1;
+			  break;
+			}
+
+		      // Count non-zeros in work vector and adjust 
+		      // space in retval if needed
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (Bx[i] != 0. || Bz[i] != 0.)
+			  new_nnz++;
+
+		      if (ii + new_nnz > x_nz)
+			{
+			  // Resize the sparse matrix
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			  retval.change_capacity (sz);
+			  x_nz = sz;
+			}
+
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (Bx[i] != 0. || Bz[i] != 0.)
+			  {
+			    retval.xridx(ii) = i;
+			    retval.xdata(ii++) = 
+			      Complex (Bx[i], Bz[i]);
+			  }
+
+		      retval.xcidx(j+1) = ii;
 		    }
+
+		  retval.maybe_compress ();
 		}
 	    }
 	}
 
       if (typ == MatrixType::Banded)
 	{
 	  // Create the storage for the banded form of the sparse matrix
 	  octave_idx_type n_upper = mattype.nupper ();
@@ -5665,159 +5475,135 @@ SparseMatrix::bsolve (MatrixType &mattyp
 	    }
 
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
 	  F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dgbtrf");
-	  else
-	    {
-	      if (err != 0) 
-		{
-		  err = -2;
-		  rcond = 0.0;
-
-		  if (sing_handler)
-		    {
-		      sing_handler (rcond);
-		      mattype.mark_as_rectangular ();
-		    }
-		  else
-		    (*current_liboctave_error_handler)
-		      ("matrix singular to machine precision");
-
-		} 
-	      else 
-		{
-		  if (calc_cond)
-		    {
-		      char job = '1';
-		      Array<double> z (3 * nr);
-		      double *pz = z.fortran_vec ();
-		      Array<octave_idx_type> iz (nr);
-		      octave_idx_type *piz = iz.fortran_vec ();
-
-		      F77_XFCN (dgbcon, DGBCON, 
-		      	(F77_CONST_CHAR_ARG2 (&job, 1),
-		      	 nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-		      	 anorm, rcond, pz, piz, err
-		      	 F77_CHAR_ARG_LEN (1)));
-
-		      if (f77_exception_encountered)
-		        (*current_liboctave_error_handler) 
-		          ("unrecoverable error in dgbcon");
-
-		       if (err != 0) 
-		        err = -2;
-
-		      volatile double rcond_plus_one = rcond + 1.0;
-
-		      if (rcond_plus_one == 1.0 || xisnan (rcond))
-		        {
-		          err = -2;
-
-		          if (sing_handler)
-			    {
-			      sing_handler (rcond);
-			      mattype.mark_as_rectangular ();
-			    }
-		          else
-		            (*current_liboctave_error_handler)
-		              ("matrix singular to machine precision, rcond = %g",
-		               rcond);
-		        }
-		    }
-		  else
-		    rcond = 1.;
-
-		  if (err == 0)
+	  if (err != 0) 
+	    {
+	      err = -2;
+	      rcond = 0.0;
+
+	      if (sing_handler)
+		{
+		  sing_handler (rcond);
+		  mattype.mark_as_rectangular ();
+		}
+	      else
+		(*current_liboctave_error_handler)
+		  ("matrix singular to machine precision");
+
+	    } 
+	  else 
+	    {
+	      if (calc_cond)
+		{
+		  char job = '1';
+		  Array<double> z (3 * nr);
+		  double *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nr);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (dgbcon, DGBCON, 
+		    (F77_CONST_CHAR_ARG2 (&job, 1),
+		     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+		     anorm, rcond, pz, piz, err
+		     F77_CHAR_ARG_LEN (1)));
+
+		   if (err != 0) 
+		    err = -2;
+
+		  volatile double rcond_plus_one = rcond + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcond))
 		    {
-		      char job = 'N';
-		      volatile octave_idx_type x_nz = b.nnz ();
-		      octave_idx_type b_nc = b.cols ();
-		      retval = SparseComplexMatrix (nr, b_nc, x_nz);
-		      retval.xcidx(0) = 0;
-		      volatile octave_idx_type ii = 0;
-
-		      OCTAVE_LOCAL_BUFFER (double, Bx, nr);
-		      OCTAVE_LOCAL_BUFFER (double, Bz, nr);
-
-		      for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		      err = -2;
+
+		      if (sing_handler)
+			{
+			  sing_handler (rcond);
+			  mattype.mark_as_rectangular ();
+			}
+		      else
+			(*current_liboctave_error_handler)
+			  ("matrix singular to machine precision, rcond = %g",
+			   rcond);
+		    }
+		}
+	      else
+		rcond = 1.;
+
+	      if (err == 0)
+		{
+		  char job = 'N';
+		  volatile octave_idx_type x_nz = b.nnz ();
+		  octave_idx_type b_nc = b.cols ();
+		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
+		  retval.xcidx(0) = 0;
+		  volatile octave_idx_type ii = 0;
+
+		  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
+		  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
+
+		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
+		    {
+		      for (octave_idx_type i = 0; i < nr; i++)
+			{
+			  Bx[i] = 0.;
+			  Bz[i] = 0.;
+			}
+		      for (octave_idx_type i = b.cidx(j); 
+			   i < b.cidx(j+1); i++)
 			{
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    {
-			      Bx[i] = 0.;
-			      Bz[i] = 0.;
-			    }
-			  for (octave_idx_type i = b.cidx(j); 
-			       i < b.cidx(j+1); i++)
-			    {
-			      Complex c = b.data(i);
-			      Bx[b.ridx(i)] = std::real (c);
-			      Bz[b.ridx(i)] = std::imag (c);
-			    }
-
-			  F77_XFCN (dgbtrs, DGBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, n_upper, 1, tmp_data,
-				     ldm, pipvt, Bx, b.rows (), err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dgbtrs");
-			      break;
-			    }
-
-			  F77_XFCN (dgbtrs, DGBTRS, 
-				    (F77_CONST_CHAR_ARG2 (&job, 1),
-				     nr, n_lower, n_upper, 1, tmp_data,
-				     ldm, pipvt, Bz, b.rows (), err
-				     F77_CHAR_ARG_LEN (1)));
-		    
-			  if (f77_exception_encountered)
-			    {
-			      (*current_liboctave_error_handler)
-				("unrecoverable error in dgbtrs");
-			      break;
-			    }
-
-			  // Count non-zeros in work vector and adjust 
-			  // space in retval if needed
-			  octave_idx_type new_nnz = 0;
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (Bx[i] != 0. || Bz[i] != 0.)
-			      new_nnz++;
-
-			  if (ii + new_nnz > x_nz)
-			    {
-			      // Resize the sparse matrix
-			      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
-			      retval.change_capacity (sz);
-			      x_nz = sz;
-			    }
-
-			  for (octave_idx_type i = 0; i < nr; i++)
-			    if (Bx[i] != 0. || Bz[i] != 0.)
-			      {
-				retval.xridx(ii) = i;
-				retval.xdata(ii++) = 
-				  Complex (Bx[i], Bz[i]);
-			      }
-			  retval.xcidx(j+1) = ii;
+			  Complex c = b.data(i);
+			  Bx[b.ridx(i)] = std::real (c);
+			  Bz[b.ridx(i)] = std::imag (c);
 			}
 
-		      retval.maybe_compress ();
+		      F77_XFCN (dgbtrs, DGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, 1, tmp_data,
+				 ldm, pipvt, Bx, b.rows (), err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      F77_XFCN (dgbtrs, DGBTRS, 
+				(F77_CONST_CHAR_ARG2 (&job, 1),
+				 nr, n_lower, n_upper, 1, tmp_data,
+				 ldm, pipvt, Bz, b.rows (), err
+				 F77_CHAR_ARG_LEN (1)));
+
+		      // Count non-zeros in work vector and adjust 
+		      // space in retval if needed
+		      octave_idx_type new_nnz = 0;
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (Bx[i] != 0. || Bz[i] != 0.)
+			  new_nnz++;
+
+		      if (ii + new_nnz > x_nz)
+			{
+			  // Resize the sparse matrix
+			  octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
+			  retval.change_capacity (sz);
+			  x_nz = sz;
+			}
+
+		      for (octave_idx_type i = 0; i < nr; i++)
+			if (Bx[i] != 0. || Bz[i] != 0.)
+			  {
+			    retval.xridx(ii) = i;
+			    retval.xdata(ii++) = 
+			      Complex (Bx[i], Bz[i]);
+			  }
+		      retval.xcidx(j+1) = ii;
 		    }
+
+		  retval.maybe_compress ();
 		}
 	    }
 	}
       else if (typ != MatrixType::Banded_Hermitian)
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   
   return retval;
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -69,38 +69,30 @@ AEPBALANCE::init (const Matrix& a, const
   double *p_balanced_mat = balanced_mat.fortran_vec ();
 
   char job = balance_job[0];
 
   F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
 			     n, p_balanced_mat, n, ilo, ihi, pscale, info
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dgebal");
-  else
-    {
-      balancing_mat = Matrix (n, n, 0.0);
-      for (octave_idx_type i = 0; i < n; i++)
-	balancing_mat.elem (i ,i) = 1.0;
+  balancing_mat = Matrix (n, n, 0.0);
+  for (octave_idx_type i = 0; i < n; i++)
+    balancing_mat.elem (i ,i) = 1.0;
 
-      double *p_balancing_mat = balancing_mat.fortran_vec ();
+  double *p_balancing_mat = balancing_mat.fortran_vec ();
 
-      char side = 'R';
+  char side = 'R';
 
-      F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-				 F77_CONST_CHAR_ARG2 (&side, 1),
-				 n, ilo, ihi, pscale, n,
-				 p_balancing_mat, n, info
-				 F77_CHAR_ARG_LEN (1)
-				 F77_CHAR_ARG_LEN (1)));
-
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in dgebak");
-    }
+  F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     F77_CONST_CHAR_ARG2 (&side, 1),
+			     n, ilo, ihi, pscale, n,
+			     p_balancing_mat, n, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -71,53 +71,44 @@ CHOL::init (const Matrix& a, bool calc_c
   double anorm = 0;
   if (calc_cond) 
     anorm = chol_mat.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
   F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1),
 			     n, h, n, info
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dpotrf");
+  xrcond = 0.0;
+  if (info != 0)
+    info = -1;
+  else if (calc_cond) 
+    {
+      octave_idx_type dpocon_info = 0;
+
+      // Now calculate the condition number for non-singular matrix.
+      Array<double> z (3*n);
+      double *pz = z.fortran_vec ();
+      Array<octave_idx_type> iz (n);
+      octave_idx_type *piz = iz.fortran_vec ();
+      F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
+				 n, anorm, xrcond, pz, piz, dpocon_info
+				 F77_CHAR_ARG_LEN (1)));
+
+      if (dpocon_info != 0) 
+	info = -1;
+    }
   else
     {
-      xrcond = 0.0;
-      if (info != 0)
-	info = -1;
-      else if (calc_cond) 
-	{
-	  octave_idx_type dpocon_info = 0;
-
-	  // Now calculate the condition number for non-singular matrix.
-	  Array<double> z (3*n);
-	  double *pz = z.fortran_vec ();
-	  Array<octave_idx_type> iz (n);
-	  octave_idx_type *piz = iz.fortran_vec ();
-	  F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-				     n, anorm, xrcond, pz, piz, dpocon_info
-				     F77_CHAR_ARG_LEN (1)));
+      // If someone thinks of a more graceful way of doing this (or
+      // faster for that matter :-)), please let me know!
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dpocon");
-
-	  if (dpocon_info != 0) 
-	    info = -1;
-	}
-      else
-	{
-	  // If someone thinks of a more graceful way of doing this (or
-	  // faster for that matter :-)), please let me know!
-
-	  if (n > 1)
-	    for (octave_idx_type j = 0; j < a_nc; j++)
-	      for (octave_idx_type i = j+1; i < a_nr; i++)
-		chol_mat.xelem (i, j) = 0.0;
-	}
+      if (n > 1)
+	for (octave_idx_type j = 0; j < a_nc; j++)
+	  for (octave_idx_type i = j+1; i < a_nr; i++)
+	    chol_mat.xelem (i, j) = 0.0;
     }
 
   return info;
 }
 
 static Matrix
 chol2inv_internal (const Matrix& r)
 {
@@ -135,31 +126,25 @@ chol2inv_internal (const Matrix& r)
       double *v = tmp.fortran_vec();
 
       if (info == 0)
 	{
 	  F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
 				     v, n, info
 				     F77_CHAR_ARG_LEN (1)));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler) 
-	      ("unrecoverable error in dpotri");
-	  else
-	    {
-	      // If someone thinks of a more graceful way of doing this (or
-	      // faster for that matter :-)), please let me know!
+	  // If someone thinks of a more graceful way of doing this (or
+	  // faster for that matter :-)), please let me know!
 
-	      if (n > 1)
-		for (octave_idx_type j = 0; j < r_nc; j++)
-		  for (octave_idx_type i = j+1; i < r_nr; i++)
-		    tmp.xelem (i, j) = tmp.xelem (j, i);
+	  if (n > 1)
+	    for (octave_idx_type j = 0; j < r_nc; j++)
+	      for (octave_idx_type i = j+1; i < r_nr; i++)
+		tmp.xelem (i, j) = tmp.xelem (j, i);
 
-	      retval = tmp;
-	    }
+	  retval = tmp;
 	}
     }
   else
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
   return retval;
 }
 
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -82,68 +82,46 @@ HESS::init (const Matrix& a)
 
   Array<double> scale (n);
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
 			     n, h, n, ilo, ihi, pscale, info
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dgebal");
-  else
-    {
-      Array<double> tau (n-1);
-      double *ptau = tau.fortran_vec ();
+  Array<double> tau (n-1);
+  double *ptau = tau.fortran_vec ();
 
-      Array<double> work (lwork);
-      double *pwork = work.fortran_vec ();
+  Array<double> work (lwork);
+  double *pwork = work.fortran_vec ();
 
-      F77_XFCN (dgehrd, DGEHRD, (n, ilo, ihi, h, n, ptau, pwork,
-				 lwork, info));
+  F77_XFCN (dgehrd, DGEHRD, (n, ilo, ihi, h, n, ptau, pwork,
+			     lwork, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in dgehrd");
-      else
-	{
-	  unitary_hess_mat = hess_mat;
-	  double *z = unitary_hess_mat.fortran_vec ();
+  unitary_hess_mat = hess_mat;
+  double *z = unitary_hess_mat.fortran_vec ();
 
-	  F77_XFCN (dorghr, DORGHR, (n, ilo, ihi, z, n, ptau, pwork,
-				     lwork, info));
+  F77_XFCN (dorghr, DORGHR, (n, ilo, ihi, z, n, ptau, pwork,
+			     lwork, info));
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in dorghr");
-	  else
-	    {
-	      F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
-					 F77_CONST_CHAR_ARG2 (&side, 1),
-					 n, ilo, ihi, pscale, n, z,
-					 n, info
-					 F77_CHAR_ARG_LEN (1)
-					 F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
+			     F77_CONST_CHAR_ARG2 (&side, 1),
+			     n, ilo, ihi, pscale, n, z,
+			     n, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
-	      if (f77_exception_encountered)
-		(*current_liboctave_error_handler)
-		  ("unrecoverable error in dgebak");
-	      else
-		{
-		  // If someone thinks of a more graceful way of doing
-		  // this (or faster for that matter :-)), please let
-		  // me know!
+  // If someone thinks of a more graceful way of doing
+  // this (or faster for that matter :-)), please let
+  // me know!
 
-		  if (n > 2)
-		    for (octave_idx_type j = 0; j < a_nc; j++)
-		      for (octave_idx_type i = j+2; i < a_nr; i++)
-			hess_mat.elem (i, j) = 0;
-		}
-	    }
-	}
-    }
+  if (n > 2)
+    for (octave_idx_type j = 0; j < a_nc; j++)
+      for (octave_idx_type i = j+2; i < a_nr; i++)
+	hess_mat.elem (i, j) = 0;
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -56,19 +56,16 @@ LU::LU (const Matrix& a)
 
   a_fact = a;
   double *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
   F77_XFCN (dgetrf, DGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dgetrf");
-  else
-    ipvt -= static_cast<octave_idx_type> (1);
+  ipvt -= static_cast<octave_idx_type> (1);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -71,66 +71,55 @@ QR::init (const Matrix& a, QR::type qr_t
   Matrix A_fact = a;
   if (m > n && qr_type != QR::economy)
       A_fact.resize (m, m, 0.0);
 
   double *tmp_data = A_fact.fortran_vec ();
 
   F77_XFCN (dgeqrf, DGEQRF, (m, n, tmp_data, m, ptau, pwork, lwork, info));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dgeqrf");
+  if (qr_type == QR::raw)
+    {
+      for (octave_idx_type j = 0; j < min_mn; j++)
+	{
+	  octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
+	  for (octave_idx_type i = limit + 1; i < m; i++)
+	    A_fact.elem (i, j) *= tau.elem (j);
+	}
+
+      r = A_fact;
+
+      if (m > n)
+	r.resize (m, n);
+    }
   else
     {
-      if (qr_type == QR::raw)
-	{
-	  for (octave_idx_type j = 0; j < min_mn; j++)
-	    {
-	      octave_idx_type limit = j < min_mn - 1 ? j : min_mn - 1;
-	      for (octave_idx_type i = limit + 1; i < m; i++)
-		A_fact.elem (i, j) *= tau.elem (j);
-	    }
-
-	  r = A_fact;
+      octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
 
-	  if (m > n)
-	    r.resize (m, n);
-	}
+      if (qr_type == QR::economy && m > n)
+	r.resize (n, n, 0.0);
       else
-	{
-	  octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
-
-	  if (qr_type == QR::economy && m > n)
-	    r.resize (n, n, 0.0);
-	  else
-	    r.resize (m, n, 0.0);
+	r.resize (m, n, 0.0);
 
-	  for (octave_idx_type j = 0; j < n; j++)
-	    {
-	      octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
-	      for (octave_idx_type i = 0; i <= limit; i++)
-		r.elem (i, j) = tmp_data[m*j+i];
-	    }
-
-	  lwork = 32 * n2;
-	  work.resize (lwork);
-	  double *pwork2 = work.fortran_vec ();
+      for (octave_idx_type j = 0; j < n; j++)
+	{
+	  octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
+	  for (octave_idx_type i = 0; i <= limit; i++)
+	    r.elem (i, j) = tmp_data[m*j+i];
+	}
 
-	  F77_XFCN (dorgqr, DORGQR, (m, n2, min_mn, tmp_data, m, ptau,
-				     pwork2, lwork, info));
+      lwork = 32 * n2;
+      work.resize (lwork);
+      double *pwork2 = work.fortran_vec ();
 
-	  if (f77_exception_encountered)
-	    (*current_liboctave_error_handler)
-	      ("unrecoverable error in dorgqr");
-	  else
-	    {
-	      q = A_fact;
-	      q.resize (m, n2);
-	    }
-	}
+      F77_XFCN (dorgqr, DORGQR, (m, n2, min_mn, tmp_data, m, ptau,
+				 pwork2, lwork, info));
+
+      q = A_fact;
+      q.resize (m, n2);
     }
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -83,60 +83,50 @@ QRP::init (const Matrix& a, QR::type qr_
 
   Array<octave_idx_type> jpvt (n, 0);
   octave_idx_type *pjpvt = jpvt.fortran_vec ();
 
   // Code to enforce a certain permutation could go here...
 
   F77_XFCN (dgeqpf, DGEQPF, (m, n, tmp_data, m, pjpvt, ptau, pwork, info));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dgeqpf");
+  // Form Permutation matrix (if economy is requested, return the
+  // indices only!)
+
+  if (qr_type == QR::economy)
+    {
+      p.resize (1, n, 0.0);
+      for (octave_idx_type j = 0; j < n; j++)
+	p.elem (0, j) = jpvt.elem (j);
+    }
   else
     {
-      // Form Permutation matrix (if economy is requested, return the
-      // indices only!)
+      p.resize (n, n, 0.0);
+      for (octave_idx_type j = 0; j < n; j++)
+	p.elem (jpvt.elem (j) - 1, j) = 1.0;
+    }
 
-      if (qr_type == QR::economy)
-	{
-	  p.resize (1, n, 0.0);
-	  for (octave_idx_type j = 0; j < n; j++)
-	    p.elem (0, j) = jpvt.elem (j);
-	}
-      else
-	{
-	  p.resize (n, n, 0.0);
-	  for (octave_idx_type j = 0; j < n; j++)
-	    p.elem (jpvt.elem (j) - 1, j) = 1.0;
-	}
+  octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
 
-      octave_idx_type n2 = (qr_type == QR::economy) ? min_mn : m;
+  if (qr_type == QR::economy && m > n)
+    r.resize (n, n, 0.0);
+  else
+    r.resize (m, n, 0.0);
 
-      if (qr_type == QR::economy && m > n)
-	r.resize (n, n, 0.0);
-      else
-	r.resize (m, n, 0.0);
-
-      for (octave_idx_type j = 0; j < n; j++)
-	{
-	  octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
-	  for (octave_idx_type i = 0; i <= limit; i++)
-	    r.elem (i, j) = A_fact.elem (i, j);
-	}
+  for (octave_idx_type j = 0; j < n; j++)
+    {
+      octave_idx_type limit = j < min_mn-1 ? j : min_mn-1;
+      for (octave_idx_type i = 0; i <= limit; i++)
+	r.elem (i, j) = A_fact.elem (i, j);
+    }
 
-      F77_XFCN (dorgqr, DORGQR, (m, n2, min_mn, tmp_data, m, ptau,
-				 pwork, lwork, info));
+  F77_XFCN (dorgqr, DORGQR, (m, n2, min_mn, tmp_data, m, ptau,
+			     pwork, lwork, info));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in dorgqr");
-      else
-	{
-	  q = A_fact;
-	  q.resize (m, n2);
-	}
-    }
+  q = A_fact;
+  q.resize (m, n2);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -132,19 +132,16 @@ SCHUR::init (const Matrix& a, const std:
 			     selector,
 			     F77_CONST_CHAR_ARG2 (&sense, 1),
 			     n, s, n, sdim, pwr, pwi, q, n, rconde, rcondv,
 			     pwork, lwork, piwork, liwork, pbwork, info
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dgeesx");
-
   return info;
 }
 
 std::ostream&
 operator << (std::ostream& os, const SCHUR& a)
 {
   os << a.schur_matrix () << "\n";
   os << a.unitary_matrix () << "\n";
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -139,38 +139,28 @@ SVD::init (const Matrix& a, SVD::type sv
 
   F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
 			     F77_CONST_CHAR_ARG2 (&jobv, 1),
 			     m, n, tmp_data, m, s_vec, u, m, vt,
 			     nrow_vt, work.fortran_vec (), lwork, info
 			     F77_CHAR_ARG_LEN (1)
 			     F77_CHAR_ARG_LEN (1)));
 
-  if (f77_exception_encountered)
-    (*current_liboctave_error_handler) ("unrecoverable error in dgesvd");
-  else
-    {
-      lwork = static_cast<octave_idx_type> (work(0));
-      work.resize (lwork);
+  lwork = static_cast<octave_idx_type> (work(0));
+  work.resize (lwork);
 
-      F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
-				 F77_CONST_CHAR_ARG2 (&jobv, 1),
-				 m, n, tmp_data, m, s_vec, u, m, vt,
-				 nrow_vt, work.fortran_vec (), lwork, info
-				 F77_CHAR_ARG_LEN (1)
-				 F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (dgesvd, DGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
+			     F77_CONST_CHAR_ARG2 (&jobv, 1),
+			     m, n, tmp_data, m, s_vec, u, m, vt,
+			     nrow_vt, work.fortran_vec (), lwork, info
+			     F77_CHAR_ARG_LEN (1)
+			     F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered)
-	(*current_liboctave_error_handler) ("unrecoverable error in dgesvd");
-      else
-	{
-	  if (! (jobv == 'N' || jobv == 'O'))
-	    right_sm = right_sm.transpose ();
-	}
-    }
+  if (! (jobv == 'N' || jobv == 'O'))
+    right_sm = right_sm.transpose ();
 
   return info;
 }
 
 std::ostream&
 operator << (std::ostream& os, const SVD& a)
 {
   os << a.left_singular_matrix () << "\n";
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,13 @@
 2008-02-14  John W. Eaton  <jwe@octave.org>
 
+	* DLD-FUNCTIONS/balance.cc, DLD-FUNCTIONS/qz.cc:
+	Don't check f77_exception_encountered.
+
 	* sighandlers.cc (user_abort): If interrupting immediately, set
 	octave_interrupt_state if it is not already set.
 
 	* pt-stmt.cc (tree_statement::eval): Catch execution exceptions.
 
 	* octave.cc (lo_error_handler): New static function.
 	(initialize_error_handlers): Set liboctave_error_handler to
 	lo_error_handler, not error.
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -248,39 +248,27 @@ Generalized eigenvalue problem balancing
 	    cbb = ComplexMatrix (bb);
   
 	  F77_XFCN (zggbal, ZGGBAL,
 		    (F77_CONST_CHAR_ARG2 (&job, 1),
 		     nn, caa.fortran_vec (), nn, cbb.fortran_vec (),
 		     nn, ilo, ihi, lscale.fortran_vec (),
 		     rscale.fortran_vec (), work.fortran_vec (), info
 		     F77_CHAR_ARG_LEN (1)));
-
-	  if (f77_exception_encountered)
-	    {
-	      error ("unrecoverable error in balance GEP");
-	      return retval;
-	    }
 	}
       else
 	{
 	  // real matrices case
 
 	  F77_XFCN (dggbal, DGGBAL,
 		    (F77_CONST_CHAR_ARG2 (&job, 1),
 		     nn, aa.fortran_vec (), nn, bb.fortran_vec (),
 		     nn, ilo, ihi, lscale.fortran_vec (),
 		     rscale.fortran_vec (), work.fortran_vec (), info
 		     F77_CHAR_ARG_LEN  (1)));
-      
-	  if (f77_exception_encountered)
-	    {
-	      error ("unrecoverable error in balance GEP");
-	      return retval;
-	    }
 	}
       
       // Since we just want the balancing matrices, we can use dggbal
       // for both the real and complex cases.
 
       Matrix Pl(nn,nn), Pr(nn,nn);
 
       for (octave_idx_type ii = 0; ii < nn; ii++)
@@ -295,37 +283,25 @@ Generalized eigenvalue problem balancing
       F77_XFCN (dggbak, DGGBAK,
 		(F77_CONST_CHAR_ARG2 (&job, 1),
 		 F77_CONST_CHAR_ARG2 ("L", 1),
 		 nn, ilo, ihi, lscale.data (), rscale.data (),
 		 nn, Pl.fortran_vec (), nn, info
 		 F77_CHAR_ARG_LEN (1)
 		 F77_CHAR_ARG_LEN (1)));
       
-      if (f77_exception_encountered)
-	{
-	  error ("unrecoverable error in balance GEP(L)");
-	  return retval;
-	}
-      
       // then right
       F77_XFCN (dggbak, DGGBAK,
 		(F77_CONST_CHAR_ARG2 (&job, 1),
 		 F77_CONST_CHAR_ARG2 ("R", 1),
 		 nn, ilo, ihi, lscale.data (), rscale.data (),
 		 nn, Pr.fortran_vec (), nn, info
 		 F77_CHAR_ARG_LEN (1)
 		 F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered)
-	{
-	  error ("unrecoverable error in balance GEP(R)");
-	  return retval;
-	}
-
       switch (nargout)
 	{
 	case 0:
 	case 1:
 	  warning ("balance: used GEP, should have two output arguments");
 	  if (complex_case)
 	    retval(0) = caa;
 	  else
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -470,22 +470,16 @@ Order of output arguments was selected f
 #endif
 
       F77_XFCN (dggbal, DGGBAL,
 		(F77_CONST_CHAR_ARG2 (&bal_job, 1),
 		 nn, aa.fortran_vec (), nn, bb.fortran_vec (),
 		 nn, ilo, ihi, lscale.fortran_vec (),
 		 rscale.fortran_vec (), work.fortran_vec (), info
 		 F77_CHAR_ARG_LEN (1)));
-
-      if (f77_exception_encountered)
-	{
-	  error ("unrecoverable error in qz (bal)");
-	  return retval;
-	}
     }
 
   // Since we just want the balancing matrices, we can use dggbal
   // for both the real and complex cases;
   // left first
 
   if (compq == 'V')
     {
@@ -496,22 +490,16 @@ Order of output arguments was selected f
 		 nn, QQ.fortran_vec (), nn, info
 		 F77_CHAR_ARG_LEN (1)
 		 F77_CHAR_ARG_LEN (1)));
 
 #ifdef DEBUG
       if (compq == 'V')
 	std::cout << "qz: balancing done; QQ=" << std::endl << QQ << std::endl;
 #endif
-
-    if (f77_exception_encountered)
-      {
-	error ("unrecoverable error in qz (bal-L)");
-	return retval;
-      }
   }
 
   // then right
   if (compz == 'V')
     {
       F77_XFCN (dggbak, DGGBAK,
 		(F77_CONST_CHAR_ARG2 (&bal_job, 1),
 		 F77_CONST_CHAR_ARG2 ("R", 1),
@@ -519,22 +507,16 @@ Order of output arguments was selected f
 		 nn, ZZ.fortran_vec (), nn, info
 		 F77_CHAR_ARG_LEN (1)
 		 F77_CHAR_ARG_LEN (1)));
 
 #ifdef DEBUG
       if (compz == 'V')
 	std::cout << "qz: balancing done; ZZ=" << std::endl << ZZ << std::endl;
 #endif
-
-      if (f77_exception_encountered)
-	{
-	  error ("unrecoverable error in qz (bal-R)");
-	  return retval;
-	}
     }
 
   static char qz_job;
   qz_job = (nargout < 2 ? 'E' : 'S');	
 
   if (complex_case)
     {
       // complex case
@@ -598,43 +580,31 @@ Order of output arguments was selected f
 		(F77_CONST_CHAR_ARG2 (&compq, 1),
 		 F77_CONST_CHAR_ARG2 (&compz, 1),
 		 nn, ilo, ihi, aa.fortran_vec (),
 		 nn, bb.fortran_vec (), nn, QQ.fortran_vec (), nn,
 		 ZZ.fortran_vec (), nn, info
 		 F77_CHAR_ARG_LEN (1)
 		 F77_CHAR_ARG_LEN (1)));
 
-      if (f77_exception_encountered)
-	{
-	  error ("unrecoverable error in qz (dgghrd)");
-	  return retval;
-	}
-
       // check if just computing generalized eigenvalues or if we're
       // actually computing the decomposition
 
       // reduce to generalized Schur form
       F77_XFCN (dhgeqz, DHGEQZ,
 		(F77_CONST_CHAR_ARG2 (&qz_job, 1),
 		 F77_CONST_CHAR_ARG2 (&compq, 1),
 		 F77_CONST_CHAR_ARG2 (&compz, 1),
 		 nn, ilo, ihi, aa.fortran_vec (), nn, bb.fortran_vec (),
 		 nn, alphar.fortran_vec (), alphai.fortran_vec (),
 		 betar.fortran_vec (), QQ.fortran_vec (), nn,
 		 ZZ.fortran_vec (), nn, work.fortran_vec (), nn, info
 		 F77_CHAR_ARG_LEN (1)
 		 F77_CHAR_ARG_LEN (1)
 		 F77_CHAR_ARG_LEN (1)));
-
-      if (f77_exception_encountered)
-	{
-	  error ("unrecoverable error in qz (dhgeqz)");
-	  return retval;
-	}
     }
 
   // order the QZ decomposition?
   if (ord_job[0] != 'N')
     {
       if (complex_case)
 	{
 	  // probably not needed, but better be safe
@@ -899,22 +869,16 @@ Order of output arguments was selected f
 		    (F77_CONST_CHAR_ARG2 (&side, 1),
 		     F77_CONST_CHAR_ARG2 (&howmny, 1),
 		     select, nn, aa.fortran_vec (), nn, bb.fortran_vec (),
 		     nn, VL.fortran_vec (), nn, VR.fortran_vec (), nn, nn,
 		     m, work.fortran_vec (), info
 		     F77_CHAR_ARG_LEN (1)
 		     F77_CHAR_ARG_LEN (1)));
 
-	  if (f77_exception_encountered)
-	    {
-	      error ("unrecoverable error in qz (dtgevc)");
-	      return retval;
-	    }
-
 	  // now construct the complex form of VV, WW
 	  int jj = 0;
 
 	  while (jj < nn)
 	    {
 	      OCTAVE_QUIT;
 
 	      // see if real or complex eigenvalue
