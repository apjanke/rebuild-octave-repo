# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1470947216 14400
#      Thu Aug 11 16:26:56 2016 -0400
# Node ID edcad35c364f81fe7b8146c5f46e3d24a9e240b6
# Parent  91c5442ea9fd80f42bbf2253b23b2ceecded0025
don't rely on std:: overloads of arg, conj, imag, and real for real args

* lo-mappers.h (arg, conj, imag, real): Provide overloads for real
arguments in octave::math namespace instead of importing them from
std namespace.

* __ichol__.cc, ls-mat4.cc, ls-mat5.cc, __eigs__.cc, ov-complex.cc,
ov-complex.h, ov-cx-mat.cc, ov-cx-sparse.cc, ov-flt-complex.cc,
ov-flt-complex.h, ov-flt-cx-mat.cc, CMatrix.cc, CNDArray.cc,
CSparse.cc, MatrixType.cc, dMatrix.cc, dSparse.cc, fCMatrix.cc,
fCNDArray.cc, fMatrix.cc, chol.cc, eigs-base.cc, lo-mappers.cc,
lo-specfun.cc, sparse-qr.cc: Update for arg, conj, imag, and real
functions in octave::math namespace.  Prefer member function versions
of real and imag for simple variables.  Use std:: namespace versions
directly for known complex values.  Use octave::math namespace
versions otherwise

diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -30,21 +30,21 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "parse.h"
 
 // Secondary functions for complex and real case used in ichol algorithms.
 Complex ichol_mult_complex (Complex a, Complex b)
 {
 #if defined (HAVE_CXX_COMPLEX_SETTERS)
-  b.imag (-std::imag (b));
+  b.imag (-b.imag ());
 #elif defined (HAVE_CXX_COMPLEX_REFERENCE_ACCESSORS)
-  b.imag () = -std::imag (b);
+  b.imag () = -b.imag ();
 #else
-  b = std::conj (b);
+  b = b.conj ();
 #endif
   return a * b;
 }
 
 double ichol_mult_real (double a, double b)
 {
   return a * b;
 }
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -507,23 +507,23 @@ save_mat_binary_data (std::ostream& os, 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
               dtmp[ii++] = j + 1;
           os.write (reinterpret_cast<const char *> (dtmp), n_bytes);
           ds = nc;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp[i] = std::real (m.data (i));
+            dtmp[i] = octave::math::real (m.data (i));
           os.write (reinterpret_cast<const char *> (dtmp), n_bytes);
           ds = 0.;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp[i] = std::imag (m.data (i));
+            dtmp[i] = octave::math::imag (m.data (i));
           os.write (reinterpret_cast<const char *> (dtmp), n_bytes);
           os.write (reinterpret_cast<const char *> (&ds), 8);
         }
       else
         {
           SparseMatrix m = tc.sparse_matrix_value ();
 
           for (octave_idx_type i = 0; i < len; i++)
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -2010,43 +2010,43 @@ int
 save_mat5_array_length (const Complex* val, octave_idx_type nel,
                         bool save_as_floats)
 {
   int ret;
 
   OCTAVE_LOCAL_BUFFER (double, tmp, nel);
 
   for (octave_idx_type i = 1; i < nel; i++)
-    tmp[i] = std::real (val[i]);
+    tmp[i] = octave::math::real (val[i]);
 
   ret = save_mat5_array_length (tmp, nel, save_as_floats);
 
   for (octave_idx_type i = 1; i < nel; i++)
-    tmp[i] = std::imag (val[i]);
+    tmp[i] = octave::math::imag (val[i]);
 
   ret += save_mat5_array_length (tmp, nel, save_as_floats);
 
   return ret;
 }
 
 int
 save_mat5_array_length (const FloatComplex* val, octave_idx_type nel,
                         bool save_as_floats)
 {
   int ret;
 
   OCTAVE_LOCAL_BUFFER (float, tmp, nel);
 
   for (octave_idx_type i = 1; i < nel; i++)
-    tmp[i] = std::real (val[i]);
+    tmp[i] = octave::math::real (val[i]);
 
   ret = save_mat5_array_length (tmp, nel, save_as_floats);
 
   for (octave_idx_type i = 1; i < nel; i++)
-    tmp[i] = std::imag (val[i]);
+    tmp[i] = octave::math::imag (val[i]);
 
   ret += save_mat5_array_length (tmp, nel, save_as_floats);
 
   return ret;
 }
 
 int
 save_mat5_element_length (const octave_value& tc, const std::string& name,
@@ -2453,22 +2453,22 @@ save_mat5_binary_element (std::ostream& 
           octave_idx_type nc = m.cols ();
 
           write_mat5_sparse_index_vector (os, m.ridx (), nnz);
           write_mat5_sparse_index_vector (os, m.cidx (), nc + 1);
 
           NDArray buf (dim_vector (nnz, 1));
 
           for (octave_idx_type i = 0; i < nnz; i++)
-            buf (i) = std::real (m.data (i));
+            buf (i) = octave::math::real (m.data (i));
 
           write_mat5_array (os, buf, save_as_floats);
 
           for (octave_idx_type i = 0; i < nnz; i++)
-            buf (i) = std::imag (m.data (i));
+            buf (i) = octave::math::imag (m.data (i));
 
           write_mat5_array (os, buf, save_as_floats);
         }
       else
         {
           const SparseMatrix m = tc.sparse_matrix_value ();
           octave_idx_type nnz = m.nnz ();
           octave_idx_type nc = m.cols ();
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -290,18 +290,18 @@ Undocumented internal function.
       else
         {
           sigma = args(2+arg_offset).xcomplex_value ("eigs: SIGMA must be a scalar or a string");
 
           have_sigma = true;
         }
     }
 
-  sigmar = std::real (sigma);
-  sigmai = std::imag (sigma);
+  sigmar = sigma.real ();
+  sigmai = sigma.imag ();
 
   if (nargin > (3+arg_offset))
     {
       if (! args(3+arg_offset).is_map ())
         error ("eigs: OPTS argument must be a structure");
 
       octave_scalar_map map = args(3+arg_offset).xscalar_map_value ("eigs: OPTS argument must be a scalar structure");
 
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -100,20 +100,20 @@ octave_complex::numeric_demotion_functio
                                        octave_float_complex::static_type_id ());
 }
 
 octave_base_value *
 octave_complex::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
-  double im = std::imag (scalar);
+  double im = scalar.imag ();
 
   if (im == 0.0)
-    retval = new octave_scalar (std::real (scalar));
+    retval = new octave_scalar (scalar.real ());
 
   return retval;
 }
 
 octave_value
 octave_complex::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
   // FIXME: this doesn't solve the problem of
@@ -131,102 +131,102 @@ octave_complex::do_index_op (const octav
   return tmp.do_index_op (idx, resize_ok);
 }
 
 // Can't make an index_vector from a complex number.  Throw an error.
 idx_vector
 octave_complex::index_vector (bool) const
 {
   std::ostringstream buf;
-  buf << std::real (scalar) << std::showpos << std::imag (scalar) << "i";
+  buf << scalar.real () << std::showpos << scalar.imag () << "i";
   complex_index_exception e (buf.str ());
 
   throw e;
 }
 
 double
 octave_complex::double_value (bool force_conversion) const
 {
   double retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real scalar");
 
-  retval = std::real (scalar);
+  retval = scalar.real ();
 
   return retval;
 }
 
 float
 octave_complex::float_value (bool force_conversion) const
 {
   float retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real scalar");
 
-  retval = std::real (scalar);
+  retval = scalar.real ();
 
   return retval;
 }
 
 Matrix
 octave_complex::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real matrix");
 
-  retval = Matrix (1, 1, std::real (scalar));
+  retval = Matrix (1, 1, scalar.real ());
 
   return retval;
 }
 
 FloatMatrix
 octave_complex::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real matrix");
 
-  retval = FloatMatrix (1, 1, std::real (scalar));
+  retval = FloatMatrix (1, 1, scalar.real ());
 
   return retval;
 }
 
 NDArray
 octave_complex::array_value (bool force_conversion) const
 {
   NDArray retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real matrix");
 
-  retval = NDArray (dim_vector (1, 1), std::real (scalar));
+  retval = NDArray (dim_vector (1, 1), scalar.real ());
 
   return retval;
 }
 
 FloatNDArray
 octave_complex::float_array_value (bool force_conversion) const
 {
   FloatNDArray retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real matrix");
 
-  retval = FloatNDArray (dim_vector (1, 1), std::real (scalar));
+  retval = FloatNDArray (dim_vector (1, 1), scalar.real ());
 
   return retval;
 }
 
 Complex
 octave_complex::complex_value (bool) const
 {
   return scalar;
@@ -458,18 +458,18 @@ octave_complex::load_hdf5 (octave_hdf5_i
 mxArray *
 octave_complex::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, 1, 1, mxCOMPLEX);
 
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
 
-  pr[0] = std::real (scalar);
-  pi[0] = std::imag (scalar);
+  pr[0] = scalar.real ();
+  pi[0] = scalar.imag ();
 
   return retval;
 }
 
 octave_value
 octave_complex::map (unary_mapper_t umap) const
 {
   switch (umap)
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -81,18 +81,18 @@ public:
                             bool resize_ok = false);
 
   // Use this to give a more specific error message.
   idx_vector index_vector (bool /* require_integers */ = false) const;
 
   octave_value any (int = 0) const
   {
     return (scalar != Complex (0, 0)
-            && ! (lo_ieee_isnan (std::real (scalar))
-                  || lo_ieee_isnan (std::imag (scalar))));
+            && ! (lo_ieee_isnan (scalar.real ())
+                  || lo_ieee_isnan (scalar.imag ())));
   }
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_scalar (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -83,18 +83,18 @@ octave_base_value *
 octave_complex_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.numel () == 1)
     {
       Complex c = matrix (0);
 
-      if (std::imag (c) == 0.0)
-        retval = new octave_scalar (std::real (c));
+      if (c.imag () == 0.0)
+        retval = new octave_scalar (c.real ());
       else
         retval = new octave_complex (c);
     }
   else if (matrix.all_elements_are_real ())
     retval = new octave_matrix (::real (matrix));
 
   return retval;
 }
@@ -109,17 +109,17 @@ octave_complex_matrix::double_value (boo
                                "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                              "complex matrix", "real scalar");
 
-  retval = std::real (matrix(0, 0));
+  retval = octave::math::real (matrix(0, 0));
 
   return retval;
 }
 
 float
 octave_complex_matrix::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
@@ -129,17 +129,17 @@ octave_complex_matrix::float_value (bool
                                "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                              "complex matrix", "real scalar");
 
-  retval = std::real (matrix(0, 0));
+  retval = octave::math::real (matrix(0, 0));
 
   return retval;
 }
 
 NDArray
 octave_complex_matrix::array_value (bool force_conversion) const
 {
   NDArray retval;
@@ -250,17 +250,17 @@ octave_complex_matrix::char_array_value 
     warn_implicit_conversion ("Octave:num-to-str",
                                "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
-        retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
+        retval.elem (i) = static_cast<char>(octave::math::real (matrix.elem (i)));
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 octave_complex_matrix::float_complex_array_value (bool) const
 {
@@ -726,18 +726,18 @@ octave_complex_matrix::as_mxArray (void)
   double *pi = static_cast<double *> (retval->get_imag_data ());
 
   mwSize nel = numel ();
 
   const Complex *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     {
-      pr[i] = std::real (p[i]);
-      pi[i] = std::imag (p[i]);
+      pr[i] = octave::math::real (p[i]);
+      pi[i] = octave::math::imag (p[i]);
     }
 
   return retval;
 }
 
 octave_value
 octave_complex_matrix::map (unary_mapper_t umap) const
 {
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -70,18 +70,18 @@ octave_sparse_complex_matrix::try_narrow
       // since they involves a cast to double to avoid issues of overflow
       if (matrix.rows () == 1 && matrix.cols () == 1)
         {
           // Const copy of the matrix, so the right version of () operator used
           const SparseComplexMatrix tmp (matrix);
 
           Complex c = tmp (0, 0);
 
-          if (std::imag (c) == 0.0)
-            retval = new octave_scalar (std::real (c));
+          if (c.imag () == 0.0)
+            retval = new octave_scalar (c.real ());
           else
             retval = new octave_complex (c);
         }
       else if (nr == 0 || nc == 0)
         retval = new octave_matrix (Matrix (nr, nc));
       else if (matrix.all_elements_are_real ())
         if (matrix.cols () > 0 && matrix.rows () > 0
             && (double (matrix.byte_size ()) > double (matrix.rows ())
@@ -115,17 +115,17 @@ octave_sparse_complex_matrix::double_val
   // FIXME: maybe this should be a function, valid_as_scalar()
   if (is_empty ())
     err_invalid_conversion ("complex sparse matrix", "real scalar");
 
   if (numel () > 1)
     warn_implicit_conversion ("Octave:array-to-scalar",
                               "complex sparse matrix", "real scalar");
 
-  retval = std::real (matrix(0, 0));
+  retval = octave::math::real (matrix(0, 0));
 
   return retval;
 }
 
 Matrix
 octave_sparse_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
@@ -183,17 +183,17 @@ octave_sparse_complex_matrix::char_array
     {
       retval = charNDArray (dims (), 0);
       octave_idx_type nc = matrix.cols ();
       octave_idx_type nr = matrix.rows ();
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
           retval(matrix.ridx (i) + nr * j) =
-            static_cast<char>(std::real (matrix.data (i)));
+            static_cast<char>(octave::math::real (matrix.data (i)));
     }
 
   return retval;
 }
 
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
@@ -881,18 +881,18 @@ octave_sparse_complex_matrix::as_mxArray
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
       Complex val = matrix.data (i);
-      pr[i] = std::real (val);
-      pi[i] = std::imag (val);
+      pr[i] = val.real ();
+      pi[i] = val.imag ();
       ir[i] = matrix.ridx (i);
     }
 
   for (mwIndex i = 0; i < columns () + 1; i++)
     jc[i] = matrix.cidx (i);
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -59,20 +59,20 @@ template class octave_base_scalar<FloatC
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex,
                                      "float complex scalar", "single");
 
 octave_base_value *
 octave_float_complex::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
-  float im = std::imag (scalar);
+  float im = scalar.imag ();
 
   if (im == 0.0)
-    retval = new octave_float_scalar (std::real (scalar));
+    retval = new octave_float_scalar (scalar.real ());
 
   return retval;
 }
 
 octave_value
 octave_float_complex::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
   // FIXME: this doesn't solve the problem of
@@ -95,87 +95,87 @@ double
 octave_float_complex::double_value (bool force_conversion) const
 {
   double retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real scalar");
 
-  retval = std::real (scalar);
+  retval = scalar.real ();
 
   return retval;
 }
 
 float
 octave_float_complex::float_value (bool force_conversion) const
 {
   float retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real scalar");
 
-  retval = std::real (scalar);
+  retval = scalar.real ();
 
   return retval;
 }
 
 Matrix
 octave_float_complex::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real matrix");
 
-  retval = Matrix (1, 1, std::real (scalar));
+  retval = Matrix (1, 1, scalar.real ());
 
   return retval;
 }
 
 FloatMatrix
 octave_float_complex::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real matrix");
 
-  retval = FloatMatrix (1, 1, std::real (scalar));
+  retval = FloatMatrix (1, 1, scalar.real ());
 
   return retval;
 }
 
 NDArray
 octave_float_complex::array_value (bool force_conversion) const
 {
   NDArray retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real matrix");
 
-  retval = NDArray (dim_vector (1, 1), std::real (scalar));
+  retval = NDArray (dim_vector (1, 1), scalar.real ());
 
   return retval;
 }
 
 FloatNDArray
 octave_float_complex::float_array_value (bool force_conversion) const
 {
   FloatNDArray retval;
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex scalar", "real matrix");
 
-  retval = FloatNDArray (dim_vector (1, 1), std::real (scalar));
+  retval = FloatNDArray (dim_vector (1, 1), scalar.real ());
 
   return retval;
 }
 
 Complex
 octave_float_complex::complex_value (bool) const
 {
   return scalar;
@@ -408,18 +408,18 @@ octave_float_complex::load_hdf5 (octave_
 mxArray *
 octave_float_complex::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxSINGLE_CLASS, 1, 1, mxCOMPLEX);
 
   float *pr = static_cast<float *> (retval->get_data ());
   float *pi = static_cast<float *> (retval->get_imag_data ());
 
-  pr[0] = std::real (scalar);
-  pi[0] = std::imag (scalar);
+  pr[0] = scalar.real ();
+  pi[0] = scalar.imag ();
 
   return retval;
 }
 
 octave_value
 octave_float_complex::map (unary_mapper_t umap) const
 {
   switch (umap)
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -77,18 +77,18 @@ public:
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   octave_value any (int = 0) const
   {
     return (scalar != FloatComplex (0, 0)
-            && ! (lo_ieee_isnan (std::real (scalar))
-                  || lo_ieee_isnan (std::imag (scalar))));
+            && ! (lo_ieee_isnan (scalar.real ())
+                  || lo_ieee_isnan (scalar.imag ())));
   }
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_scalar (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -71,18 +71,18 @@ octave_base_value *
 octave_float_complex_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.numel () == 1)
     {
       FloatComplex c = matrix (0);
 
-      if (std::imag (c) == 0.0)
-        retval = new octave_float_scalar (std::real (c));
+      if (c.imag () == 0.0)
+        retval = new octave_float_scalar (c.real ());
       else
         retval = new octave_float_complex (c);
     }
   else if (matrix.all_elements_are_real ())
     retval = new octave_float_matrix (::real (matrix));
 
   return retval;
 }
@@ -97,17 +97,17 @@ octave_float_complex_matrix::double_valu
                               "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "complex matrix", "real scalar");
 
-  retval = std::real (matrix(0, 0));
+  retval = octave::math::real (matrix(0, 0));
 
   return retval;
 }
 
 float
 octave_float_complex_matrix::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
@@ -117,17 +117,17 @@ octave_float_complex_matrix::float_value
                               "complex matrix", "real scalar");
 
   if (rows () == 0 || columns () == 0)
     err_invalid_conversion ("complex matrix", "real scalar");
 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             "complex matrix", "real scalar");
 
-  retval = std::real (matrix(0, 0));
+  retval = octave::math::real (matrix(0, 0));
 
   return retval;
 }
 
 Matrix
 octave_float_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
@@ -224,17 +224,17 @@ octave_float_complex_matrix::char_array_
     warn_implicit_conversion ("Octave:num-to-str",
                               "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
-        retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
+        retval.elem (i) = static_cast<char>(octave::math::real (matrix.elem (i)));
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 octave_float_complex_matrix::float_complex_array_value (bool) const
 {
@@ -677,18 +677,18 @@ octave_float_complex_matrix::as_mxArray 
   float *pi = static_cast<float *> (retval->get_imag_data ());
 
   mwSize nel = numel ();
 
   const FloatComplex *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     {
-      pr[i] = std::real (p[i]);
-      pi[i] = std::imag (p[i]);
+      pr[i] = octave::math::real (p[i]);
+      pi[i] = octave::math::imag (p[i]);
     }
 
   return retval;
 }
 
 octave_value
 octave_float_complex_matrix::map (unary_mapper_t umap) const
 {
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1032,17 +1032,17 @@ ComplexMatrix::finverse (MatrixType &mat
   Array<Complex> z (dim_vector (1, 1));
   octave_idx_type lwork = -1;
 
   // Query the optimum work array size.
 
   F77_XFCN (zgetri, ZGETRI, (nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
                              F77_DBLE_CMPLX_ARG (z.fortran_vec ()), lwork, info));
 
-  lwork = static_cast<octave_idx_type> (std::real (z(0)));
+  lwork = static_cast<octave_idx_type> (octave::math::real (z(0)));
   lwork = (lwork <  2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   Complex *pz = z.fortran_vec ();
 
   info = 0;
 
   // Calculate (always, see bug #45577) the norm of the matrix, for later use.
   double anorm =
@@ -2660,28 +2660,28 @@ ComplexMatrix::lssolve (const ComplexMat
           if (nrhs > addend)
             addend = nrhs;
 
           if (n-3*m > addend)
             addend = n-3*m;
 
           const octave_idx_type lworkaround = 4*m + m*m + addend;
 
-          if (std::real (work(0)) < lworkaround)
+          if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
       else if (m >= n)
         {
           octave_idx_type lworkaround = 2*m + m*nrhs;
 
-          if (std::real (work(0)) < lworkaround)
+          if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
-      lwork = static_cast<octave_idx_type> (std::real (work(0)));
+      lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
                                  F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
@@ -2829,17 +2829,17 @@ ComplexMatrix::lssolve (const ComplexCol
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
-      lwork = static_cast<octave_idx_type> (std::real (work(0)));
+      lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
                                  F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
@@ -3089,17 +3089,17 @@ bool
 ComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      if (std::imag (elem (i, j)) != 0.0)
+      if (octave::math::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
   return retval;
 }
@@ -3108,17 +3108,17 @@ bool
 ComplexMatrix::column_is_real_only (octave_idx_type j) const
 {
   bool retval = true;
 
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
-      if (std::imag (elem (i, j)) != 0.0)
+      if (octave::math::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
   return retval;
 }
@@ -3154,30 +3154,30 @@ ComplexMatrix::row_min (Array<octave_idx
           double abs_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! octave::math::isnan (tmp_min))
                 {
-                  abs_min = real_only ? std::real (tmp_min)
+                  abs_min = real_only ? tmp_min.real ()
                                       : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               Complex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+              double abs_tmp = real_only ? tmp.real () : std::abs (tmp);
 
               if (abs_tmp < abs_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
@@ -3229,30 +3229,30 @@ ComplexMatrix::row_max (Array<octave_idx
           double abs_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! octave::math::isnan (tmp_max))
                 {
-                  abs_max = real_only ? std::real (tmp_max)
+                  abs_max = real_only ? tmp_max.real ()
                                       : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               Complex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+              double abs_tmp = real_only ? tmp.real () : std::abs (tmp);
 
               if (abs_tmp > abs_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
@@ -3304,30 +3304,30 @@ ComplexMatrix::column_min (Array<octave_
           double abs_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! octave::math::isnan (tmp_min))
                 {
-                  abs_min = real_only ? std::real (tmp_min)
+                  abs_min = real_only ? tmp_min.real ()
                                       : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               Complex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+              double abs_tmp = real_only ? tmp.real () : std::abs (tmp);
 
               if (abs_tmp < abs_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
@@ -3379,30 +3379,30 @@ ComplexMatrix::column_max (Array<octave_
           double abs_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! octave::math::isnan (tmp_max))
                 {
-                  abs_max = real_only ? std::real (tmp_max)
+                  abs_max = real_only ? tmp_max.real ()
                                       : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               Complex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              double abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+              double abs_tmp = real_only ? tmp.real () : std::abs (tmp);
 
               if (abs_tmp > abs_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
@@ -3619,17 +3619,17 @@ xgemm (const ComplexMatrix& a, const Com
           F77_XFCN (zherk, ZHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    F77_CONST_DBLE_CMPLX_ARG (a.data ()), lda, 0.0, F77_DBLE_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
           for (octave_idx_type j = 0; j < a_nr; j++)
             for (octave_idx_type i = 0; i < j; i++)
-              retval.xelem (j,i) = std::conj (retval.xelem (i,j));
+              retval.xelem (j,i) = octave::math::conj (retval.xelem (i,j));
         }
       else
         {
           F77_XFCN (zsyrk, ZSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    F77_CONST_DBLE_CMPLX_ARG (a.data ()), lda, 0.0, F77_DBLE_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
@@ -3652,17 +3652,17 @@ xgemm (const ComplexMatrix& a, const Com
       Complex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
               F77_FUNC (xzdotu, XZDOTU) (a_nc, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1,
                                          F77_DBLE_CMPLX_ARG (c));
-              if (cja) *c = std::conj (*c);
+              if (cja) *c = octave::math::conj (*c);
             }
           else if (cja)
             F77_FUNC (xzdotc, XZDOTC) (a_nc, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1,
                                        F77_DBLE_CMPLX_ARG (c));
           else
             F77_FUNC (xzdotc, XZDOTC) (a_nc, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1,
                                        F77_DBLE_CMPLX_ARG (c));
         }
@@ -3751,27 +3751,27 @@ min (const ComplexMatrix& a, const Compl
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       bool columns_are_real_only = true;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          if (std::imag (a(i, j)) != 0.0 || std::imag (b(i, j)) != 0.0)
+          if (octave::math::imag (a(i, j)) != 0.0 || octave::math::imag (b(i, j)) != 0.0)
             {
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
-            result(i, j) = octave::math::min (std::real (a(i, j)), std::real (b(i, j)));
+            result(i, j) = octave::math::min (octave::math::real (a(i, j)), octave::math::real (b(i, j)));
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::min (a(i, j), b(i, j));
             }
@@ -3822,30 +3822,30 @@ max (const ComplexMatrix& a, const Compl
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       bool columns_are_real_only = true;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          if (std::imag (a(i, j)) != 0.0 || std::imag (b(i, j)) != 0.0)
+          if (octave::math::imag (a(i, j)) != 0.0 || octave::math::imag (b(i, j)) != 0.0)
             {
               columns_are_real_only = false;
               break;
             }
         }
 
       // FIXME: is it so much faster?
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = octave::math::max (std::real (a(i, j)), std::real (b(i, j)));
+              result(i, j) = octave::math::max (octave::math::real (a(i, j)), octave::math::real (b(i, j)));
             }
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::max (a(i, j), b(i, j));
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -535,18 +535,18 @@ bool
 ComplexNDArray::all_integers (double& max_val, double& min_val) const
 {
   octave_idx_type nel = numel ();
 
   if (nel > 0)
     {
       Complex val = elem (0);
 
-      double r_val = std::real (val);
-      double i_val = std::imag (val);
+      double r_val = val.real ();
+      double i_val = val.imag ();
 
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
         max_val = i_val;
 
       if (i_val < max_val)
@@ -554,18 +554,18 @@ ComplexNDArray::all_integers (double& ma
     }
   else
     return false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = elem (i);
 
-      double r_val = std::real (val);
-      double i_val = std::imag (val);
+      double r_val = val.real ();
+      double i_val = val.imag ();
 
       if (r_val > max_val)
         max_val = r_val;
 
       if (i_val > max_val)
         max_val = i_val;
 
       if (r_val < min_val)
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -3722,36 +3722,36 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = std::real (data (ii++));
+                  D[j] = octave::math::real (data (ii++));
                   DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = std::real (data (ii));
+              D[nc-1] = octave::math::real (data (ii));
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
                 for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
                     if (ridx (i) == j)
-                      D[j] = std::real (data (i));
+                      D[j] = octave::math::real (data (i));
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
@@ -4019,36 +4019,36 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = std::real (data (ii++));
+                  D[j] = octave::math::real (data (ii++));
                   DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = std::real (data (ii));
+              D[nc-1] = octave::math::real (data (ii));
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
                 for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
                     if (ridx (i) == j)
-                      D[j] = std::real (data (i));
+                      D[j] = octave::math::real (data (i));
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
@@ -7233,25 +7233,25 @@ SparseComplexMatrix::all_elements_are_re
 bool
 SparseComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
   octave_idx_type nel = nnz ();
 
   if (nel == 0)
     return false;
 
-  max_val = std::real (data (0));
-  min_val = std::real (data (0));
+  max_val = octave::math::real (data (0));
+  min_val = octave::math::real (data (0));
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
 
-      double r_val = std::real (val);
-      double i_val = std::imag (val);
+      double r_val = val.real ();
+      double i_val = val.imag ();
 
       if (r_val > max_val)
         max_val = r_val;
 
       if (i_val > max_val)
         max_val = i_val;
 
       if (r_val < min_val)
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -172,17 +172,17 @@ matrix_complex_probe (const MArray<std::
            j < ncols && (upper || lower || hermitian); j++)
         {
           for (octave_idx_type i = 0; i < j; i++)
             {
               std::complex<T> aij = a.elem (i,j);
               std::complex<T> aji = a.elem (j,i);
               lower = lower && (aij == zero);
               upper = upper && (aji == zero);
-              hermitian = hermitian && (aij == std::conj (aji)
+              hermitian = hermitian && (aij == octave::math::conj (aji)
                                         && std::norm (aij) < diag[i]*diag[j]);
             }
         }
 
       if (upper)
         typ = MatrixType::Upper;
       else if (lower)
         typ = MatrixType::Lower;
@@ -502,18 +502,19 @@ MatrixType::MatrixType (const MSparse<T>
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
               for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
                 {
                   if (a.ridx (i) == j)
                     {
                       T d = a.data (i);
-                      is_herm = std::real (d) > 0.0 && std::imag (d) == 0.0;
-                      diag(j) = std::real (d);
+                      is_herm = (octave::math::real (d) > 0.0
+                                 && octave::math::imag (d) == 0.0);
+                      diag(j) = octave::math::real (d);
                       break;
                     }
                 }
             }
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
@@ -522,17 +523,17 @@ MatrixType::MatrixType (const MSparse<T>
                 octave_idx_type k = a.ridx (i);
                 is_herm = k == j;
                 if (is_herm)
                   continue;
 
                 T d = a.data (i);
                 if (std::norm (d) < diag(j)*diag(k))
                   {
-                    d = std::conj (d);
+                    d = octave::math::conj (d);
                     for (octave_idx_type l = a.cidx (k); l < a.cidx (k+1); l++)
                       {
                         if (a.ridx (l) == j)
                           {
                             is_herm = a.data (l) == d;
                             break;
                           }
                       }
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -1954,18 +1954,18 @@ stack_complex_matrix (const ComplexMatri
   octave_idx_type m = cm.rows ();
   octave_idx_type n = cm.cols ();
   octave_idx_type nel = m*n;
   Matrix retval (m, 2*n);
   const Complex *cmd = cm.data ();
   double *rd = retval.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      rd[i] = std::real (cmd[i]);
-      rd[nel+i] = std::imag (cmd[i]);
+      rd[i] = octave::math::real (cmd[i]);
+      rd[nel+i] = octave::math::imag (cmd[i]);
     }
   return retval;
 }
 
 static ComplexMatrix
 unstack_complex_matrix (const Matrix& sm)
 {
   octave_idx_type m = sm.rows ();
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -644,17 +644,17 @@ real (const SparseComplexMatrix& a)
   octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data (i) = std::real (a.data (i));
+      r.data (i) = octave::math::real (a.data (i));
       r.ridx (i) = a.ridx (i);
     }
 
   r.maybe_compress (true);
   return r;
 }
 
 SparseMatrix
@@ -665,17 +665,17 @@ imag (const SparseComplexMatrix& a)
   octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data (i) = std::imag (a.data (i));
+      r.data (i) = octave::math::imag (a.data (i));
       r.ridx (i) = a.ridx (i);
     }
 
   r.maybe_compress (true);
   return r;
 }
 
 /*
@@ -4332,18 +4332,18 @@ SparseMatrix::trisolve (MatrixType &matt
 
               retval.xcidx (0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b(i,j);
-                      Bx[i] = std::real (c);
-                      Bz[i] = std::imag (c);
+                      Bx[i] = c.real ();
+                      Bz[i] = c.imag ();
                     }
 
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              Bx, b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
@@ -5082,18 +5082,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
                   retval.resize (b_nr, b_nc);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
                           Complex c = b(i,j);
-                          Bx[i] = std::real (c);
-                          Bz[i] = std::imag (c);
+                          Bx[i] = c.real ();
+                          Bz[i] = c.imag ();
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -5230,18 +5230,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   OCTAVE_LOCAL_BUFFER (double, Bz, nr);
                   OCTAVE_LOCAL_BUFFER (double, Bx, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         {
                           Complex c = b(i, j);
-                          Bx[i] = std::real (c);
-                          Bz[i] = std::imag  (c);
+                          Bx[i] = c.real ();
+                          Bz[i] = c.imag ();
                         }
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -5384,18 +5384,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
                           Complex c = b(i,j);
-                          Bx[i] = std::real (c);
-                          Bz[i] = std::imag (c);
+                          Bx[i] = c.real ();
+                          Bz[i] = c.imag ();
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -5566,18 +5566,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         {
                           Bx[i] = 0.;
                           Bz[i] = 0.;
                         }
                       for (octave_idx_type i = b.cidx (j);
                            i < b.cidx (j+1); i++)
                         {
                           Complex c = b.data (i);
-                          Bx[b.ridx (i)] = std::real (c);
-                          Bz[b.ridx (i)] = std::imag (c);
+                          Bx[b.ridx (i)] = c.real ();
+                          Bz[b.ridx (i)] = c.imag ();
                         }
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -6423,18 +6423,18 @@ SparseMatrix::fsolve (MatrixType &mattyp
               OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b(i,j);
-                      Bx[i] = std::real (c);
-                      Bz[i] = std::imag (c);
+                      Bx[i] = c.real ();
+                      Bz[i] = c.imag ();
                     }
 
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
                                                   Ai, Ax, Xx, Bx, Numeric,
                                                   control, info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
                                                        Ap, Ai, Ax, Xz, Bz,
                                                        Numeric, control, info);
@@ -6685,18 +6685,18 @@ SparseMatrix::fsolve (MatrixType &mattyp
               OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
 
               retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b(i,j);
-                      Bx[i] = std::real (c);
-                      Bz[i] = std::imag (c);
+                      Bx[i] = c.real ();
+                      Bz[i] = c.imag ();
                     }
 
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
                                                   Ai, Ax, Xx, Bx, Numeric,
                                                   control, info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
                                                        Ap, Ai, Ax, Xz, Bz,
                                                        Numeric, control, info);
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1037,17 +1037,17 @@ FloatComplexMatrix::finverse (MatrixType
   Array<FloatComplex> z (dim_vector (1, 1));
   octave_idx_type lwork = -1;
 
   // Query the optimum work array size.
 
   F77_XFCN (cgetri, CGETRI, (nc, F77_CMPLX_ARG (tmp_data), nr, pipvt,
                              F77_CMPLX_ARG (z.fortran_vec ()), lwork, info));
 
-  lwork = static_cast<octave_idx_type> (std::real (z(0)));
+  lwork = static_cast<octave_idx_type> (octave::math::real (z(0)));
   lwork = (lwork <  2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   FloatComplex *pz = z.fortran_vec ();
 
   info = 0;
 
   // Calculate (always, see bug #45577) the norm of the matrix, for later use.
   float anorm =
@@ -2680,28 +2680,28 @@ FloatComplexMatrix::lssolve (const Float
           if (nrhs > addend)
             addend = nrhs;
 
           if (n-3*m > addend)
             addend = n-3*m;
 
           const octave_idx_type lworkaround = 4*m + m*m + addend;
 
-          if (std::real (work(0)) < lworkaround)
+          if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
       else if (m >= n)
         {
           octave_idx_type lworkaround = 2*m + m*nrhs;
 
-          if (std::real (work(0)) < lworkaround)
+          if (octave::math::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
-      lwork = static_cast<octave_idx_type> (std::real (work(0)));
+      lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
                                  F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
@@ -2852,17 +2852,17 @@ FloatComplexMatrix::lssolve (const Float
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval), maxmn,
                                  ps, rcon, rank, F77_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
-      lwork = static_cast<octave_idx_type> (std::real (work(0)));
+      lwork = static_cast<octave_idx_type> (octave::math::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
                                  F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
@@ -3115,17 +3115,17 @@ bool
 FloatComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      if (std::imag (elem (i, j)) != 0.0)
+      if (octave::math::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
   return retval;
 }
@@ -3134,17 +3134,17 @@ bool
 FloatComplexMatrix::column_is_real_only (octave_idx_type j) const
 {
   bool retval = true;
 
   octave_idx_type nr = rows ();
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
-      if (std::imag (elem (i, j)) != 0.0)
+      if (octave::math::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
   return retval;
 }
@@ -3180,30 +3180,30 @@ FloatComplexMatrix::row_min (Array<octav
           float abs_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! octave::math::isnan (tmp_min))
                 {
-                  abs_min = real_only ? std::real (tmp_min)
+                  abs_min = real_only ? tmp_min.real ()
                                       : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               FloatComplex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+              float abs_tmp = real_only ? tmp.real () : std::abs (tmp);
 
               if (abs_tmp < abs_min)
                 {
                   idx_j = j;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
@@ -3255,30 +3255,30 @@ FloatComplexMatrix::row_max (Array<octav
           float abs_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! octave::math::isnan (tmp_max))
                 {
-                  abs_max = real_only ? std::real (tmp_max)
+                  abs_max = real_only ? tmp_max.real ()
                                       : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               FloatComplex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+              float abs_tmp = real_only ? tmp.real () : std::abs (tmp);
 
               if (abs_tmp > abs_max)
                 {
                   idx_j = j;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
@@ -3330,30 +3330,30 @@ FloatComplexMatrix::column_min (Array<oc
           float abs_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! octave::math::isnan (tmp_min))
                 {
-                  abs_min = real_only ? std::real (tmp_min)
+                  abs_min = real_only ? tmp_min.real ()
                                       : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               FloatComplex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+              float abs_tmp = real_only ? tmp.real () : std::abs (tmp);
 
               if (abs_tmp < abs_min)
                 {
                   idx_i = i;
                   tmp_min = tmp;
                   abs_min = abs_tmp;
                 }
             }
@@ -3405,30 +3405,30 @@ FloatComplexMatrix::column_max (Array<oc
           float abs_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! octave::math::isnan (tmp_max))
                 {
-                  abs_max = real_only ? std::real (tmp_max)
+                  abs_max = real_only ? tmp_max.real ()
                                       : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               FloatComplex tmp = elem (i, j);
 
               if (octave::math::isnan (tmp))
                 continue;
 
-              float abs_tmp = real_only ? std::real (tmp) : std::abs (tmp);
+              float abs_tmp = real_only ? tmp.real () : std::abs (tmp);
 
               if (abs_tmp > abs_max)
                 {
                   idx_i = i;
                   tmp_max = tmp;
                   abs_max = abs_tmp;
                 }
             }
@@ -3647,17 +3647,17 @@ xgemm (const FloatComplexMatrix& a, cons
           F77_XFCN (cherk, CHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    F77_CONST_CMPLX_ARG (a.data ()), lda, 0.0, F77_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
           for (octave_idx_type j = 0; j < a_nr; j++)
             for (octave_idx_type i = 0; i < j; i++)
-              retval.xelem (j,i) = std::conj (retval.xelem (i,j));
+              retval.xelem (j,i) = octave::math::conj (retval.xelem (i,j));
         }
       else
         {
           F77_XFCN (csyrk, CSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
                                    F77_CONST_CMPLX_ARG (a.data ()), lda, 0.0, F77_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
@@ -3680,17 +3680,17 @@ xgemm (const FloatComplexMatrix& a, cons
       FloatComplex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
               F77_FUNC (xcdotu, XCDOTU) (a_nc, F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CONST_CMPLX_ARG (b.data ()), 1,
                                          F77_CMPLX_ARG (c));
-              if (cja) *c = std::conj (*c);
+              if (cja) *c = octave::math::conj (*c);
             }
           else if (cja)
             F77_FUNC (xcdotc, XCDOTC) (a_nc, F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CONST_CMPLX_ARG (b.data ()), 1,
                                        F77_CMPLX_ARG (c));
           else
             F77_FUNC (xcdotc, XCDOTC) (a_nc, F77_CONST_CMPLX_ARG (b.data ()), 1, F77_CONST_CMPLX_ARG (a.data ()), 1,
                                        F77_CMPLX_ARG (c));
         }
@@ -3780,27 +3780,27 @@ min (const FloatComplexMatrix& a, const 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       bool columns_are_real_only = true;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          if (std::imag (a(i, j)) != 0.0 || std::imag (b(i, j)) != 0.0)
+          if (octave::math::imag (a(i, j)) != 0.0 || octave::math::imag (b(i, j)) != 0.0)
             {
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
-            result(i, j) = octave::math::min (std::real (a(i, j)), std::real (b(i, j)));
+            result(i, j) = octave::math::min (octave::math::real (a(i, j)), octave::math::real (b(i, j)));
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::min (a(i, j), b(i, j));
             }
@@ -3851,29 +3851,29 @@ max (const FloatComplexMatrix& a, const 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       bool columns_are_real_only = true;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          if (std::imag (a(i, j)) != 0.0 || std::imag (b(i, j)) != 0.0)
+          if (octave::math::imag (a(i, j)) != 0.0 || octave::math::imag (b(i, j)) != 0.0)
             {
               columns_are_real_only = false;
               break;
             }
         }
 
       if (columns_are_real_only)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result(i, j) = octave::math::max (std::real (a(i, j)), std::real (b(i, j)));
+              result(i, j) = octave::math::max (octave::math::real (a(i, j)), octave::math::real (b(i, j)));
             }
         }
       else
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
               result(i, j) = octave::math::max (a(i, j), b(i, j));
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -532,18 +532,18 @@ bool
 FloatComplexNDArray::all_integers (float& max_val, float& min_val) const
 {
   octave_idx_type nel = numel ();
 
   if (nel > 0)
     {
       FloatComplex val = elem (0);
 
-      float r_val = std::real (val);
-      float i_val = std::imag (val);
+      float r_val = val.real ();
+      float i_val = val.imag ();
 
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
         max_val = i_val;
 
       if (i_val < max_val)
@@ -551,18 +551,18 @@ FloatComplexNDArray::all_integers (float
     }
   else
     return false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       FloatComplex val = elem (i);
 
-      float r_val = std::real (val);
-      float i_val = std::imag (val);
+      float r_val = val.real ();
+      float i_val = val.imag ();
 
       if (r_val > max_val)
         max_val = r_val;
 
       if (i_val > max_val)
         max_val = i_val;
 
       if (r_val < min_val)
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -1978,18 +1978,18 @@ stack_complex_matrix (const FloatComplex
   octave_idx_type m = cm.rows ();
   octave_idx_type n = cm.cols ();
   octave_idx_type nel = m*n;
   FloatMatrix retval (m, 2*n);
   const FloatComplex *cmd = cm.data ();
   float *rd = retval.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      rd[i] = std::real (cmd[i]);
-      rd[nel+i] = std::imag (cmd[i]);
+      rd[i] = octave::math::real (cmd[i]);
+      rd[nel+i] = octave::math::imag (cmd[i]);
     }
   return retval;
 }
 
 static FloatComplexMatrix
 unstack_complex_matrix (const FloatMatrix& sm)
 {
   octave_idx_type m = sm.rows ();
diff --git a/liboctave/numeric/chol.cc b/liboctave/numeric/chol.cc
--- a/liboctave/numeric/chol.cc
+++ b/liboctave/numeric/chol.cc
@@ -511,29 +511,29 @@ chol<T>::insert_sym (const VT& u, octave
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
   if (singular (chol_mat))
     info = 2;
-  else if (std::imag (u(j)) != zero)
+  else if (octave::math::imag (u(j)) != zero)
     info = 3;
   else
     {
       T a = chol_mat.hermitian () * chol_mat;
       T a1 (n+1, n+1);
       for (octave_idx_type k = 0; k < n+1; k++)
         for (octave_idx_type l = 0; l < n+1; l++)
           {
             if (l == j)
               a1(k, l) = u(k);
             else if (k == j)
-              a1(k, l) = std::conj (u(l));
+              a1(k, l) = octave::math::conj (u(l));
             else
               a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
           }
       info = init (a1, true, false);
       if (info) info = 1;
     }
 
   return info;
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -1776,17 +1776,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
             }
 
           eig_vec.resize (n, k);
           octave_idx_type i = 0;
           while (i < k)
             {
               octave_idx_type off1 = i * n;
               octave_idx_type off2 = (i+1) * n;
-              if (std::imag (eig_val(i)) == 0)
+              if (octave::math::imag (eig_val(i)) == 0)
                 {
                   for (octave_idx_type j = 0; j < n; j++)
                     eig_vec(j,i) =
                       Complex (z[j+off1],0.);
                   i++;
                 }
               else
                 {
@@ -2122,17 +2122,17 @@ EigsRealNonSymmetricMatrixShift (const M
             }
 
           eig_vec.resize (n, k);
           octave_idx_type i = 0;
           while (i < k)
             {
               octave_idx_type off1 = i * n;
               octave_idx_type off2 = (i+1) * n;
-              if (std::imag (eig_val(i)) == 0)
+              if (octave::math::imag (eig_val(i)) == 0)
                 {
                   for (octave_idx_type j = 0; j < n; j++)
                     eig_vec(j,i) =
                       Complex (z[j+off1],0.);
                   i++;
                 }
               else
                 {
@@ -2405,17 +2405,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
             }
 
           eig_vec.resize (n, k);
           octave_idx_type i = 0;
           while (i < k)
             {
               octave_idx_type off1 = i * n;
               octave_idx_type off2 = (i+1) * n;
-              if (std::imag (eig_val(i)) == 0)
+              if (octave::math::imag (eig_val(i)) == 0)
                 {
                   for (octave_idx_type j = 0; j < n; j++)
                     eig_vec(j,i) =
                       Complex (z[j+off1],0.);
                   i++;
                 }
               else
                 {
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -54,154 +54,154 @@ namespace octave
     is_NA (double x)
     {
       return lo_ieee_is_NA (x);
     }
 
     bool
     is_NA (const Complex& x)
     {
-      return (is_NA (real (x)) || is_NA (imag (x)));
+      return (is_NA (std::real (x)) || is_NA (std::imag (x)));
     }
 
     bool
     is_NA (float x)
     {
       return lo_ieee_is_NA (x);
     }
 
     bool
     is_NA (const FloatComplex& x)
     {
-      return (is_NA (real (x)) || is_NA (imag (x)));
+      return (is_NA (std::real (x)) || is_NA (std::imag (x)));
     }
 
     bool
     is_NaN_or_NA (const Complex& x)
     {
-      return (isnan (real (x)) || isnan (imag (x)));
+      return (isnan (std::real (x)) || isnan (std::imag (x)));
     }
 
     bool
     is_NaN_or_NA (const FloatComplex& x)
     {
-      return (isnan (real (x)) || isnan (imag (x)));
+      return (isnan (std::real (x)) || isnan (std::imag (x)));
     }
 
     Complex
     acos (const Complex& x)
     {
 #if defined (HAVE_COMPLEX_STD_ACOS)
       Complex y = std::acos (x);
 
-      if (imag (x) == 0.0 && real (x) > 1.0)
-        return conj (y);
+      if (std::imag (x) == 0.0 && std::real (x) > 1.0)
+        return std::conj (y);
       else
         return y;
 #else
       static Complex i (0, 1);
 
       Complex tmp;
 
-      if (imag (x) == 0.0)
+      if (std::imag (x) == 0.0)
         {
           // If the imaginary part of X is 0, then avoid generating an
           // imaginary part of -0 for the expression 1-x*x.
           // This effectively chooses the same phase of the branch cut as Matlab.
-          double xr = real (x);
+          double xr = std::real (x);
           tmp = Complex (1.0 - xr*xr);
         }
       else
         tmp = 1.0 - x*x;
 
       return -i * log (x + i * sqrt (tmp));
 #endif
     }
 
     FloatComplex
     acos (const FloatComplex& x)
     {
 #if defined (HAVE_COMPLEX_STD_ACOS)
       FloatComplex y = std::acos (x);
 
-      if (imag (x) == 0.0f && real (x) > 1.0f)
-        return conj (y);
+      if (std::imag (x) == 0.0f && std::real (x) > 1.0f)
+        return std::conj (y);
       else
         return y;
 #else
       static FloatComplex i (0, 1);
 
       FloatComplex tmp;
 
-      if (imag (x) == 0.0f)
+      if (std::imag (x) == 0.0f)
         {
           // If the imaginary part of X is 0, then avoid generating an
           // imaginary part of -0 for the expression 1-x*x.
           // This effectively chooses the same phase of the branch cut as Matlab.
-          float xr = real (x);
+          float xr = std::real (x);
           tmp = FloatComplex (1.0f - xr*xr);
         }
       else
         tmp = 1.0f - x*x;
 
       return -i * log (x + i * sqrt (tmp));
 #endif
     }
 
     Complex
     asin (const Complex& x)
     {
 #if defined (HAVE_COMPLEX_STD_ASIN)
       Complex y = std::asin (x);
 
-      if (imag (x) == 0.0 && real (x) > 1.0)
-        return conj (y);
+      if (std::imag (x) == 0.0 && std::real (x) > 1.0)
+        return std::conj (y);
       else
         return y;
 #else
       static Complex i (0, 1);
 
       Complex tmp;
 
-      if (imag (x) == 0.0)
+      if (std::imag (x) == 0.0)
         {
           // If the imaginary part of X is 0, then avoid generating an
           // imaginary part of -0 for the expression 1-x*x.
           // This effectively chooses the same phase of the branch cut as Matlab.
-          double xr = real (x);
+          double xr = std::real (x);
           tmp = Complex (1.0 - xr*xr);
         }
       else
         tmp = 1.0 - x*x;
 
       return -i * log (i*x + sqrt (tmp));
 #endif
     }
 
     FloatComplex
     asin (const FloatComplex& x)
     {
 #if defined (HAVE_COMPLEX_STD_ASIN)
       FloatComplex y = std::asin (x);
 
-      if (imag (x) == 0.0f && real (x) > 1.0f)
-        return conj (y);
+      if (std::imag (x) == 0.0f && std::real (x) > 1.0f)
+        return std::conj (y);
       else
         return y;
 #else
       static FloatComplex i (0, 1);
 
       FloatComplex tmp;
 
-      if (imag (x) == 0.0f)
+      if (std::imag (x) == 0.0f)
         {
           // If the imaginary part of X is 0, then avoid generating an
           // imaginary part of -0 for the expression 1-x*x.
           // This effectively chooses the same phase of the branch cut as Matlab.
-          float xr = real (x);
+          float xr = std::real (x);
           tmp = FloatComplex (1.0f - xr*xr);
         }
       else
         tmp = 1.0f - x*x;
 
       return -i * log (i*x + sqrt (tmp));
 #endif
     }
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -41,40 +41,89 @@ namespace octave
     extern OCTAVE_API bool is_NA (float x);
 
     extern OCTAVE_API bool is_NA (const Complex& x);
     extern OCTAVE_API bool is_NA (const FloatComplex& x);
 
     extern OCTAVE_API bool is_NaN_or_NA (const Complex& x);
     extern OCTAVE_API bool is_NaN_or_NA (const FloatComplex& x);
 
+    extern OCTAVE_API double copysign (double x, double y);
+    extern OCTAVE_API float copysign (float x, float y);
+
+    extern OCTAVE_API double signbit (double x);
+    extern OCTAVE_API float signbit (float x);
+
+    // Test for negative sign.
+    extern OCTAVE_API bool negative_sign (double x);
+    extern OCTAVE_API bool negative_sign (float x);
+
+    // Test for positive sign.
+    inline bool positive_sign (double x) { return ! negative_sign (x); }
+    inline bool positive_sign (float x) { return ! negative_sign (x); }
+
     extern OCTAVE_API Complex acos (const Complex& x);
     extern OCTAVE_API FloatComplex acos (const FloatComplex& x);
 
     using std::acos;
 
     extern OCTAVE_API Complex asin (const Complex& x);
     extern OCTAVE_API FloatComplex asin (const FloatComplex& x);
 
     using std::asin;
 
     extern OCTAVE_API Complex atan (const Complex& x);
     extern OCTAVE_API FloatComplex atan (const FloatComplex& x);
 
     using std::atan;
 
     // C++ now provides versions of the following funtions for
-    // arguments of type std::complex<T> and T so we no longer need to
-    // provide our own wrappers for real-valued arguments.  Import
-    // them to the octave::math namespace for convenience.
+    // arguments of type std::complex<T> and T.  But some compilers
+    // (I'm looking at you, clang) apparently don't get this right
+    // yet...  So we provide our own wrappers for real-valued arguments.
+
+    inline double arg (double x) { return signbit (x) ? M_PI : 0; }
+    inline float arg (float x) { return signbit (x) ? M_PI : 0; }
+
+    template <typename T>
+    T
+    arg (const std::complex<T>& x)
+    {
+      return std::arg (x);
+    }
+
+    inline double conj (double x) { return x; }
+    inline float conj (float x) { return x; }
 
-    using std::arg;
-    using std::conj;
-    using std::imag;
-    using std::real;
+    template <typename T>
+    std::complex<T>
+    conj (const std::complex<T>& x)
+    {
+      return std::conj (x);
+    }
+
+    inline double imag (double) { return 0; }
+    inline float imag (float) { return 0; }
+
+    template <typename T>
+    T
+    imag (const std::complex<T>& x)
+    {
+      return std::imag (x);
+    }
+
+    inline double real (double x) { return x; }
+    inline float real (float x) { return x; }
+
+    template <typename T>
+    T
+    real (const std::complex<T>& x)
+    {
+      return std::real (x);
+    }
 
     extern OCTAVE_API double log2 (double x);
     extern OCTAVE_API float log2 (float x);
 
     extern OCTAVE_API Complex log2 (const Complex& x);
     extern OCTAVE_API FloatComplex log2 (const FloatComplex& x);
 
     extern OCTAVE_API double log2 (double x, int& exp);
@@ -88,41 +137,27 @@ namespace octave
 
     inline double ceil (double x) { return ::ceil (x); }
     inline float ceil (float x) { return ::ceilf (x); }
 
     template <typename T>
     std::complex<T>
     ceil (const std::complex<T>& x)
     {
-      return std::complex<T> (ceil (real (x)), ceil (imag (x)));
+      return std::complex<T> (ceil (std::real (x)), ceil (std::imag (x)));
     }
 
-    extern OCTAVE_API double copysign (double x, double y);
-    extern OCTAVE_API float copysign (float x, float y);
-
-    extern OCTAVE_API double signbit (double x);
-    extern OCTAVE_API float signbit (float x);
-
-    // Test for negative sign.
-    extern OCTAVE_API bool negative_sign (double x);
-    extern OCTAVE_API bool negative_sign (float x);
-
-    // Test for positive sign.
-    inline bool positive_sign (double x) { return ! negative_sign (x); }
-    inline bool positive_sign (float x) { return ! negative_sign (x); }
-
     extern OCTAVE_API double trunc (double x);
     extern OCTAVE_API float trunc (float x);
 
     template <typename T>
     std::complex<T>
     trunc (const std::complex<T>& x)
     {
-      return std::complex<T> (trunc (real (x)), trunc (imag (x)));
+      return std::complex<T> (trunc (std::real (x)), trunc (std::imag (x)));
     }
 
     inline double fix (double x) { return trunc (x); }
     inline float fix (float x) { return trunc (x); }
 
     template <typename T>
     std::complex<T>
     fix (const std::complex<T>& x)
@@ -132,27 +167,27 @@ namespace octave
 
     extern OCTAVE_API double floor (double x);
     extern OCTAVE_API float floor (float x);
 
     template <typename T>
     std::complex<T>
     floor (const std::complex<T>& x)
     {
-      return std::complex<T> (floor (real (x)), floor (imag (x)));
+      return std::complex<T> (floor (std::real (x)), floor (std::imag (x)));
     }
 
     extern OCTAVE_API double round (double x);
     extern OCTAVE_API float round (float x);
 
     template <typename T>
     std::complex<T>
     round (const std::complex<T>& x)
     {
-      return std::complex<T> (round (real (x)), round (imag (x)));
+      return std::complex<T> (round (std::real (x)), round (std::imag (x)));
     }
 
     inline double
     roundb (double x)
     {
       double t = round (x);
 
       if (fabs (x - t) == 0.5)
@@ -161,62 +196,62 @@ namespace octave
       return t;
     }
 
     inline float
     roundb (float x)
     {
       float t = round (x);
 
-      if (fabsf (x - t) == 0.5)
-        t = 2 * trunc (0.5 * t);
+      if (fabsf (x - t) == 0.5f)
+        t = 2 * trunc (0.5f * t);
 
       return t;
     }
 
     template <typename T>
     std::complex<T>
     roundb (const std::complex<T>& x)
     {
-      return std::complex<T> (roundb (real (x)), roundb (imag (x)));
+      return std::complex<T> (roundb (std::real (x)), roundb (std::imag (x)));
     }
 
     extern OCTAVE_API double frexp (double x, int *expptr);
     extern OCTAVE_API float frexp (float x, int *expptr);
 
     inline bool isnan (bool) { return false; }
     inline bool isnan (char) { return false; }
     extern OCTAVE_API bool isnan (double x);
     extern OCTAVE_API bool isnan (float x);
 
     template <typename T>
     bool
     isnan (const std::complex<T>& x)
     {
-      return (isnan (real (x)) || isnan (imag (x)));
+      return (isnan (std::real (x)) || isnan (std::imag (x)));
     }
 
     extern OCTAVE_API bool finite (double x);
     extern OCTAVE_API bool finite (float x);
 
     template <typename T>
     bool
     finite (const std::complex<T>& x)
     {
-      return (finite (real (x)) && finite (imag (x)));
+      return (finite (std::real (x)) && finite (std::imag (x)));
     }
 
     extern OCTAVE_API bool isinf (double x);
     extern OCTAVE_API bool isinf (float x);
 
     template <typename T>
     bool
     isinf (const std::complex<T>& x)
     {
-      return (isinf (real (x)) || isinf (imag (x)));
+      return (isinf (std::real (x)) || isinf (std::imag (x)));
     }
 
     // Some useful tests, that are commonly repeated.
     // Test for a finite integer.
 
     inline bool isinteger (double x) { return finite (x) && x == round (x); }
     inline bool isinteger (float x) { return finite (x) && x == round (x); }
 
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -362,19 +362,19 @@ namespace octave
     erf (const Complex& x)
     {
       return Faddeeva::erf (x);
     }
 
     FloatComplex
     erf (const FloatComplex& x)
     {
-      Complex xd (real (x), imag (x));
+      Complex xd (x.real (), x.imag ());
       Complex ret = Faddeeva::erf (xd, std::numeric_limits<float>::epsilon ());
-      return FloatComplex (real (ret), imag (ret));
+      return FloatComplex (ret.real (), ret.imag ());
     }
 
     double
     erfc (double x)
     {
 #if defined (HAVE_ERFC)
       return ::erfc (x);
 #else
@@ -401,73 +401,73 @@ namespace octave
     erfc (const Complex& x)
     {
       return Faddeeva::erfc (x);
     }
 
     FloatComplex
     erfc (const FloatComplex& x)
     {
-      Complex xd (real (x), imag (x));
+      Complex xd (x.real (), x.imag ());
       Complex ret = Faddeeva::erfc (xd, std::numeric_limits<float>::epsilon ());
-      return FloatComplex (real (ret), imag (ret));
+      return FloatComplex (ret.real (), ret.imag ());
     }
 
     // Real and complex scaled complementary error function from Faddeeva package
     float erfcx (float x) { return Faddeeva::erfcx(x); }
     double erfcx (double x) { return Faddeeva::erfcx(x); }
 
     Complex
     erfcx (const Complex& x)
     {
       return Faddeeva::erfcx (x);
     }
 
     FloatComplex
     erfcx (const FloatComplex& x)
     {
-      Complex xd (real (x), imag (x));
+      Complex xd (x.real (), x.imag ());
       Complex ret = Faddeeva::erfcx (xd, std::numeric_limits<float>::epsilon ());
-      return FloatComplex (real (ret), imag (ret));
+      return FloatComplex (ret.real (), ret.imag ());
     }
 
     // Real and complex imaginary error function from Faddeeva package
     float erfi (float x) { return Faddeeva::erfi(x); }
     double erfi (double x) { return Faddeeva::erfi(x); }
 
     Complex
     erfi (const Complex& x)
     {
       return Faddeeva::erfi (x);
     }
 
     FloatComplex
     erfi (const FloatComplex& x)
     {
-      Complex xd (real (x), imag (x));
+      Complex xd (x.real (), x.imag ());
       Complex ret = Faddeeva::erfi (xd, std::numeric_limits<float>::epsilon ());
-      return FloatComplex (real (ret), imag (ret));
+      return FloatComplex (ret.real (), ret.imag ());
     }
 
     // Real and complex Dawson function (= scaled erfi) from Faddeeva package
     float dawson (float x) { return Faddeeva::Dawson(x); }
     double dawson (double x) { return Faddeeva::Dawson(x); }
 
     Complex
     dawson (const Complex& x)
     {
       return Faddeeva::Dawson (x);
     }
 
     FloatComplex
     dawson (const FloatComplex& x)
     {
-      Complex xd (real (x), imag (x));
+      Complex xd (x.real (), x.imag ());
       Complex ret = Faddeeva::Dawson (xd, std::numeric_limits<float>::epsilon ());
-      return FloatComplex (real (ret), imag (ret));
+      return FloatComplex (ret.real (), ret.imag ());
     }
 
     double
     gamma (double x)
     {
       double result;
 
       // Special cases for (near) compatibility with Matlab instead of
@@ -1128,18 +1128,18 @@ namespace octave
           else
             {
               F77_FUNC (zbesk, ZBESK) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
 
               if (kode != 2)
                 {
                   Complex expz = exp (-z);
 
-                  double rexpz = real (expz);
-                  double iexpz = imag (expz);
+                  double rexpz = expz.real ();
+                  double iexpz = expz.imag ();
 
                   double tmp = yr*rexpz - yi*iexpz;
 
                   yi = yr*iexpz + yi*rexpz;
                   yr = tmp;
                 }
 
               if (zi == 0.0 && zr >= 0.0)
@@ -1174,18 +1174,18 @@ namespace octave
           double zi = z.imag ();
 
           F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 1, 1, &yr, &yi, nz, ierr);
 
           if (kode != 2)
             {
               Complex expz = exp (Complex (0.0, 1.0) * z);
 
-              double rexpz = real (expz);
-              double iexpz = imag (expz);
+              double rexpz = expz.real ();
+              double iexpz = expz.imag ();
 
               double tmp = yr*rexpz - yi*iexpz;
 
               yi = yr*iexpz + yi*rexpz;
               yr = tmp;
             }
 
           retval = bessel_return_value (Complex (yr, yi), ierr);
@@ -1220,18 +1220,18 @@ namespace octave
           double zi = z.imag ();
 
           F77_FUNC (zbesh, ZBESH) (zr, zi, alpha, 2, 2, 1, &yr, &yi, nz, ierr);
 
           if (kode != 2)
             {
               Complex expz = exp (-Complex (0.0, 1.0) * z);
 
-              double rexpz = real (expz);
-              double iexpz = imag (expz);
+              double rexpz = expz.real ();
+              double iexpz = expz.imag ();
 
               double tmp = yr*rexpz - yi*iexpz;
 
               yi = yr*iexpz + yi*rexpz;
               yr = tmp;
             }
 
           retval = bessel_return_value (Complex (yr, yi), ierr);
@@ -1558,21 +1558,21 @@ namespace octave
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
           F77_FUNC (cbesj, CBESJ) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
-              float expz = exp (std::abs (imag (z)));
+              float expz = exp (std::abs (z.imag ()));
               y *= expz;
             }
 
-          if (imag (z) == 0.0 && real (z) >= 0.0)
+          if (z.imag () == 0.0 && z.real () >= 0.0)
             y = FloatComplex (y.real (), 0.0);
 
           retval = bessel_return_value (y, ierr);
         }
       else if (is_integer_value (alpha))
         {
           // zbesy can overflow as z->0, and cause troubles for generic case below
           alpha = -alpha;
@@ -1613,31 +1613,31 @@ namespace octave
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
           FloatComplex w;
 
           ierr = 0;
 
-          if (real (z) == 0.0 && imag (z) == 0.0)
+          if (z.real () == 0.0 && z.imag () == 0.0)
             {
               y = FloatComplex (-octave::numeric_limits<float>::Inf (), 0.0);
             }
           else
             {
               F77_FUNC (cbesy, CBESY) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, F77_CMPLX_ARG (&w), ierr);
 
               if (kode != 2)
                 {
-                  float expz = exp (std::abs (imag (z)));
+                  float expz = exp (std::abs (z.imag ()));
                   y *= expz;
                 }
 
-              if (imag (z) == 0.0 && real (z) >= 0.0)
+              if (z.imag () == 0.0 && z.real () >= 0.0)
                 y = FloatComplex (y.real (), 0.0);
             }
 
           return bessel_return_value (y, ierr);
         }
       else if (is_integer_value (alpha - 0.5))
         {
           // zbesy can overflow as z->0, and cause troubles for generic case below
@@ -1679,21 +1679,21 @@ namespace octave
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
           F77_FUNC (cbesi, CBESI) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
-              float expz = exp (std::abs (real (z)));
+              float expz = exp (std::abs (z.real ()));
               y *= expz;
             }
 
-          if (imag (z) == 0.0 && real (z) >= 0.0)
+          if (z.imag () == 0.0 && z.real () >= 0.0)
             y = FloatComplex (y.real (), 0.0);
 
           retval = bessel_return_value (y, ierr);
         }
       else
         {
           alpha = -alpha;
 
@@ -1731,38 +1731,38 @@ namespace octave
       if (alpha >= 0.0)
         {
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
           ierr = 0;
 
-          if (real (z) == 0.0 && imag (z) == 0.0)
+          if (z.real () == 0.0 && z.imag () == 0.0)
             {
               y = FloatComplex (octave::numeric_limits<float>::Inf (), 0.0);
             }
           else
             {
               F77_FUNC (cbesk, CBESK) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
               if (kode != 2)
                 {
                   FloatComplex expz = exp (-z);
 
-                  float rexpz = real (expz);
-                  float iexpz = imag (expz);
-
-                  float tmp_r = real (y) * rexpz - imag (y) * iexpz;
-                  float tmp_i = real (y) * iexpz + imag (y) * rexpz;
+                  float rexpz = expz.real ();
+                  float iexpz = expz.imag ();
+
+                  float tmp_r = y.real () * rexpz - y.imag () * iexpz;
+                  float tmp_i = y.real () * iexpz + y.imag () * rexpz;
 
                   y = FloatComplex (tmp_r, tmp_i);
                 }
 
-              if (imag (z) == 0.0 && real (z) >= 0.0)
+              if (z.imag () == 0.0 && z.real () >= 0.0)
                 y = FloatComplex (y.real (), 0.0);
             }
 
           retval = bessel_return_value (y, ierr);
         }
       else
         {
           FloatComplex tmp = cbesk (z, -alpha, kode, ierr);
@@ -1785,21 +1785,21 @@ namespace octave
           octave_idx_type nz;
 
           F77_FUNC (cbesh, CBESH) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               FloatComplex expz = exp (FloatComplex (0.0, 1.0) * z);
 
-              float rexpz = real (expz);
-              float iexpz = imag (expz);
-
-              float tmp_r = real (y) * rexpz - imag (y) * iexpz;
-              float tmp_i = real (y) * iexpz + imag (y) * rexpz;
+              float rexpz = expz.real ();
+              float iexpz = expz.imag ();
+
+              float tmp_r = y.real () * rexpz - y.imag () * iexpz;
+              float tmp_i = y.real () * iexpz + y.imag () * rexpz;
 
               y = FloatComplex (tmp_r, tmp_i);
             }
 
           retval = bessel_return_value (y, ierr);
         }
       else
         {
@@ -1828,21 +1828,21 @@ namespace octave
           octave_idx_type nz;
 
           F77_FUNC (cbesh, CBESH) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               FloatComplex expz = exp (-FloatComplex (0.0, 1.0) * z);
 
-              float rexpz = real (expz);
-              float iexpz = imag (expz);
-
-              float tmp_r = real (y) * rexpz - imag (y) * iexpz;
-              float tmp_i = real (y) * iexpz + imag (y) * rexpz;
+              float rexpz = expz.real ();
+              float iexpz = expz.imag ();
+
+              float tmp_r = y.real () * rexpz - y.imag () * iexpz;
+              float tmp_i = y.real () * iexpz + y.imag () * rexpz;
 
               y = FloatComplex (tmp_r, tmp_i);
             }
 
           retval = bessel_return_value (y, ierr);
         }
       else
         {
@@ -2119,18 +2119,18 @@ namespace octave
       octave_idx_type id = deriv ? 1 : 0;
 
       F77_FUNC (zairy, ZAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
 
       if (! scaled)
         {
           Complex expz = exp (- 2.0 / 3.0 * z * sqrt (z));
 
-          double rexpz = real (expz);
-          double iexpz = imag (expz);
+          double rexpz = expz.real ();
+          double iexpz = expz.imag ();
 
           double tmp = ar*rexpz - ai*iexpz;
 
           ai = ar*iexpz + ai*rexpz;
           ar = tmp;
         }
 
       if (zi == 0.0 && (! scaled || zr >= 0.0))
@@ -2149,20 +2149,20 @@ namespace octave
       double zi = z.imag ();
 
       octave_idx_type id = deriv ? 1 : 0;
 
       F77_FUNC (zbiry, ZBIRY) (zr, zi, id, 2, ar, ai, ierr);
 
       if (! scaled)
         {
-          Complex expz = exp (std::abs (real (2.0 / 3.0 * z * sqrt (z))));
-
-          double rexpz = real (expz);
-          double iexpz = imag (expz);
+          Complex expz = exp (std::abs (std::real (2.0 / 3.0 * z * sqrt (z))));
+
+          double rexpz = expz.real ();
+          double iexpz = expz.imag ();
 
           double tmp = ar*rexpz - ai*iexpz;
 
           ai = ar*iexpz + ai*rexpz;
           ar = tmp;
         }
 
       if (zi == 0.0 && (! scaled || zr >= 0.0))
@@ -2252,18 +2252,18 @@ namespace octave
 
       float ar = a.real ();
       float ai = a.imag ();
 
       if (! scaled)
         {
           FloatComplex expz = exp (- 2.0f / 3.0f * z * sqrt (z));
 
-          float rexpz = real (expz);
-          float iexpz = imag (expz);
+          float rexpz = expz.real ();
+          float iexpz = expz.imag ();
 
           float tmp = ar*rexpz - ai*iexpz;
 
           ai = ar*iexpz + ai*rexpz;
           ar = tmp;
         }
 
       if (z.imag () == 0.0 && (! scaled || z.real () >= 0.0))
@@ -2281,20 +2281,20 @@ namespace octave
 
       F77_FUNC (cbiry, CBIRY) (F77_CONST_CMPLX_ARG (&z), id, 2, F77_CMPLX_ARG (&a), ierr);
 
       float ar = a.real ();
       float ai = a.imag ();
 
       if (! scaled)
         {
-          FloatComplex expz = exp (std::abs (real (2.0f / 3.0f * z * sqrt (z))));
-
-          float rexpz = real (expz);
-          float iexpz = imag (expz);
+          FloatComplex expz = exp (std::abs (std::real (2.0f / 3.0f * z * sqrt (z))));
+
+          float rexpz = expz.real ();
+          float iexpz = expz.imag ();
 
           float tmp = ar*rexpz - ai*iexpz;
 
           ai = ar*iexpz + ai*rexpz;
           ar = tmp;
         }
 
       if (z.imag () == 0.0 && (! scaled || z.real () >= 0.0))
@@ -3716,30 +3716,30 @@ namespace octave
     }
 
     void
     ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn,
             double& err)
     {
       double m1 = 1 - m, ss1, cc1, dd1;
 
-      ellipj (imag (u), m1, ss1, cc1, dd1, err);
-      if (real (u) == 0)
+      ellipj (u.imag (), m1, ss1, cc1, dd1, err);
+      if (u.real () == 0)
         {
           // u is pure imag: Jacoby imag. transf.
           sn = Complex (0, ss1/cc1);
           cn = 1/cc1;         //    cn.imag = 0;
           dn = dd1/cc1;       //    dn.imag = 0;
         }
       else
         {
           // u is generic complex
           double ss, cc, dd, ddd;
 
-          ellipj (real (u), m, ss, cc, dd, err);
+          ellipj (u.real (), m, ss, cc, dd, err);
           ddd = cc1*cc1 + m*ss*ss*ss1*ss1;
           sn = Complex (ss*dd1/ddd, cc*dd*ss1*cc1/ddd);
           cn = Complex (cc*cc1/ddd, -ss*dd*ss1*dd1/ddd);
           dn = Complex (dd*cc1*dd1/ddd, -m*ss*cc*ss1/ddd);
         }
     }
 
     static const double pi = 3.14159265358979323846;
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -765,18 +765,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
 
       for (octave_idx_type j = 0; j < b_nr; j++)
         {
           Complex c = b.xelem (j,i);
-          Xx[j] = std::real (c);
-          Xz[j] = std::imag (c);
+          Xx[j] = c.real ();
+          Xz[j] = c.imag ();
         }
 
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = 0.;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_ipvec) (S->pinv, Xx, buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -861,18 +861,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
 
       for (octave_idx_type j = 0; j < b_nr; j++)
         {
           Complex c = b.xelem (j,i);
-          Xx[j] = std::real (c);
-          Xz[j] = std::imag (c);
+          Xx[j] = c.real ();
+          Xz[j] = c.imag ();
         }
 
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = 0.;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->q, Xx, buf, nr);
       CXSPARSE_DNAME (_utsolve) (N->U, buf);
@@ -1208,18 +1208,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
 
       for (octave_idx_type j = 0; j < b_nr; j++)
         {
           Complex c = b.xelem (j,i);
-          Xx[j] = std::real (c);
-          Xz[j] = std::imag (c);
+          Xx[j] = c.real ();
+          Xz[j] = c.imag ();
         }
 
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = 0.;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_ipvec) (S->pinv, Xx, buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -1327,18 +1327,18 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
 
       for (octave_idx_type j = 0; j < b_nr; j++)
         {
           Complex c = b.xelem (j,i);
-          Xx[j] = std::real (c);
-          Xz[j] = std::imag (c);
+          Xx[j] = c.real ();
+          Xz[j] = c.imag ();
         }
 
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = 0.;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->q, Xx, buf, nr);
       CXSPARSE_DNAME (_utsolve) (N->U, buf);
