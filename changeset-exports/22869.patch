# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1481046045 18000
#      Tue Dec 06 12:40:45 2016 -0500
# Node ID f75d289645ec2569ba3a40240d98bb6c94576735
# Parent  87e3163f6c87494e3f91ddb0a6fcde384519e4d3
make deleted functions public

* octave-gui.h, resource-manager.h, shortcut-manager.h,
base-text-renderer.h, c-file-ptr-stream.h, dynamic-ld.cc,
dynamic-ld.h, event-queue.h, ft-text-renderer.cc, gl-render.cc,
gl-render.h, graphics.cc, graphics.in.h, interpreter.h, mex.cc,
mxarray.in.h, oct-fstrm.h, oct-iostrm.h, oct-prcstrm.h,
oct-procbuf.h, oct-stdstrm.h, oct-stream.cc, oct-stream.h,
oct-strstrm.h, octave-link.h, pager.h, profiler.h, sighandlers.cc,
symtab.h, text-renderer.h, zfstream.h, __init_fltk__.cc,
ov-builtin.h, ov-dld-fcn.h, ov-fcn.h, ov-mex-fcn.h, ov-typeinfo.h,
ov-usr-fcn.h, octave.h, lex.h, parse.h, pt-arg-list.h,
pt-array-list.h, pt-assign.h, pt-binop.h, pt-bp.h, pt-cell.h,
pt-check.h, pt-classdef.h, pt-cmd.h, pt-colon.h, pt-const.h,
pt-decl.h, pt-eval.h, pt-except.h, pt-exp.h, pt-fcn-handle.h,
pt-funcall.h, pt-id.h, pt-idx.h, pt-jump.h, pt-loop.h, pt-mat.h,
pt-misc.h, pt-pr-code.h, pt-select.h, pt-stmt.h, pt-unop.h,
pt-walk.h, pt.h, token.h, Array.cc, idx-vector.h, oct-fftw.h,
sparse-chol.cc, sparse-qr.cc, file-ops.h, mach-info.h, oct-env.h,
action-container.h, cmd-edit.cc, cmd-edit.h, cmd-hist.h,
oct-locbuf.h, oct-mutex.h, oct-shlib.cc, oct-sort.h, pathsearch.h,
singleton-cleanup.h, unwind-prot.h, url-transfer.cc, url-transfer.h:
Declare deleted copy constructors and assignment operators public.

diff --git a/libgui/src/octave-gui.h b/libgui/src/octave-gui.h
--- a/libgui/src/octave-gui.h
+++ b/libgui/src/octave-gui.h
@@ -31,32 +31,32 @@ namespace octave
   {
   public:
 
     gui_application (int argc, char **argv)
       : application (argc, argv), m_argc (argc), m_argv (argv),
         m_gui_running (false)
     { }
 
+    // No copying, at least not yet.
+
+    gui_application (const gui_application&) = delete;
+
+    gui_application& operator = (const gui_application&) = delete;
+
     // Should we start the GUI or fall back to the CLI?
     bool start_gui_p (void) const;
 
     int execute (void);
 
     bool gui_running (void) const { return m_gui_running; }
     void gui_running (bool arg) { m_gui_running = arg; }
 
   private:
 
-    // No copying, at least not yet.
-
-    gui_application (const gui_application&) = delete;
-
-    gui_application& operator = (const gui_application&) = delete;
-
     int m_argc;
     char **m_argv;
     bool m_gui_running;
   };
 }
 
 #endif
 
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -35,16 +35,22 @@ class resource_manager : public QObject
   Q_OBJECT
 
 protected:
 
 public:
 
   resource_manager (void);
 
+  // No copying!
+
+  resource_manager (const resource_manager&) = delete;
+
+  resource_manager& operator = (const resource_manager&) = delete;
+
   ~resource_manager ();
 
   static QSettings *get_settings (void)
   {
     return instance_ok () ? instance->do_get_settings () : 0;
   }
 
   static QIcon icon (const QString& icon_name, bool fallback = true)
@@ -108,22 +114,16 @@ public:
 
   static resource_manager *instance;
 
 public slots:
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
 private:
-
-  // No copying!
-
-  resource_manager (const resource_manager&) = delete;
-
-  resource_manager& operator = (const resource_manager&) = delete;
   
   static bool instance_ok (void);
 
   QString settings_directory;
 
   QString settings_file;
 
   QSettings *settings;
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -58,16 +58,23 @@ public:
   enum
   {
     OSC_IMPORT  = 0,
     OSC_EXPORT  = 1,
     OSC_DEFAULT = 2
   };
 
   shortcut_manager ();
+
+  // No copying!
+
+  shortcut_manager (const shortcut_manager&) = delete;
+
+  shortcut_manager& operator = (const shortcut_manager&) = delete;
+
   ~shortcut_manager ();
 
   static void init_data ()
   {
     if (instance_ok ())
       instance->do_init_data ();
   }
 
@@ -108,22 +115,16 @@ protected:
 protected slots:
 
   void handle_double_clicked (QTreeWidgetItem*, int);
   void shortcut_dialog_finished (int);
   void shortcut_dialog_set_default ();
 
 private:
 
-  // No copying!
-
-  shortcut_manager (const shortcut_manager&) = delete;
-
-  shortcut_manager& operator = (const shortcut_manager&) = delete;
-
   static bool instance_ok (void);
 
   void init (const QString&, const QString&, const QKeySequence&);
   void do_init_data ();
   void do_write_shortcuts (QSettings *settings, bool closing);
   void do_set_shortcut (QAction *action, const QString& key);
   void do_fill_treewidget (QTreeWidget *tree_view);
   bool do_import_export (int action);
diff --git a/libinterp/corefcn/base-text-renderer.h b/libinterp/corefcn/base-text-renderer.h
--- a/libinterp/corefcn/base-text-renderer.h
+++ b/libinterp/corefcn/base-text-renderer.h
@@ -39,16 +39,22 @@ namespace octave
 {
   class
   base_text_renderer : public text_processor
   {
   public:
 
     base_text_renderer (void) : text_processor () { }
 
+    // No copying!
+
+    base_text_renderer (const base_text_renderer&) = delete;
+
+    base_text_renderer& operator = (const base_text_renderer&) = delete;
+
     virtual ~base_text_renderer (void) = default;
 
     virtual Matrix
     get_extent (text_element *elt, double rotation) = 0;
 
     virtual Matrix
     get_extent (const std::string& txt, double rotation,
                 const caseless_str& interpreter) = 0;
@@ -65,21 +71,13 @@ namespace octave
                     const caseless_str& interpreter,
                     bool handle_rotation) = 0;
 
     virtual void
     text_to_strlist (const std::string& txt,
                      std::list<text_renderer::string>& lst,
                      Matrix& box, int halign, int valign, double rotation,
                      const caseless_str& interpreter = "tex") = 0;
-
-  private:
-
-    // No copying!
-
-    base_text_renderer (const base_text_renderer&) = delete;
-
-    base_text_renderer& operator = (const base_text_renderer&) = delete;
   };
 }
 
 #endif
 
diff --git a/libinterp/corefcn/c-file-ptr-stream.h b/libinterp/corefcn/c-file-ptr-stream.h
--- a/libinterp/corefcn/c-file-ptr-stream.h
+++ b/libinterp/corefcn/c-file-ptr-stream.h
@@ -39,16 +39,22 @@ public:
   typedef int (*close_fcn) (FILE *);
 
   FILE* stdiofile (void) { return f; }
 
   c_file_ptr_buf (FILE *f_arg, close_fcn cf_arg = file_close)
     : std::streambuf (), f (f_arg), cf (cf_arg)
   { }
 
+  // No copying!
+
+  c_file_ptr_buf (const c_file_ptr_buf&) = delete;
+
+  c_file_ptr_buf& operator = (const c_file_ptr_buf&) = delete;
+
   ~c_file_ptr_buf (void);
 
   int_type overflow (int_type);
 
   int_type underflow (void) { return underflow_common (false); }
 
   int_type uflow (void) { return underflow_common (true); }
 
@@ -84,57 +90,51 @@ protected:
 
   FILE *f;
 
   close_fcn cf;
 
 private:
 
   int_type underflow_common (bool);
-
-  // No copying!
-
-  c_file_ptr_buf (const c_file_ptr_buf&) = delete;
-
-  c_file_ptr_buf& operator = (const c_file_ptr_buf&) = delete;
 };
 
 // FIXME: the following three classes could probably share some code...
 
 template <typename STREAM_T, typename FILE_T, typename BUF_T>
 class
 c_file_ptr_stream : public STREAM_T
 {
 public:
 
   c_file_ptr_stream (FILE_T f, typename BUF_T::close_fcn cf = BUF_T::file_close)
     : STREAM_T (0), buf (new BUF_T (f, cf)) { STREAM_T::init (buf); }
 
+  // No copying!
+
+  c_file_ptr_stream (const c_file_ptr_stream&) = delete;
+
+  c_file_ptr_stream& operator = (const c_file_ptr_stream&) = delete;
+
   ~c_file_ptr_stream (void) { delete buf; buf = 0; }
 
   BUF_T *rdbuf (void) { return buf; }
 
   void stream_close (void) { if (buf) buf->buf_close (); }
 
   int seek (off_t offset, int origin)
   { return buf ? buf->seek (offset, origin) : -1; }
 
   off_t tell (void) { return buf ? buf->tell () : -1; }
 
   void clear (void) { if (buf) buf->clear (); STREAM_T::clear (); }
 
 private:
 
   BUF_T *buf;
-
-  // No copying!
-
-  c_file_ptr_stream (const c_file_ptr_stream&) = delete;
-
-  c_file_ptr_stream& operator = (const c_file_ptr_stream&) = delete;
 };
 
 typedef c_file_ptr_stream<std::istream, FILE *, c_file_ptr_buf>
   i_c_file_ptr_stream;
 typedef c_file_ptr_stream<std::ostream, FILE *, c_file_ptr_buf>
   o_c_file_ptr_stream;
 typedef c_file_ptr_stream<std::iostream, FILE *, c_file_ptr_buf>
   io_c_file_ptr_stream;
@@ -155,16 +155,22 @@ public:
   typedef int (*close_fcn) (gzFile);
 
   gzFile stdiofile (void) { return f; }
 
   c_zfile_ptr_buf (gzFile f_arg, close_fcn cf_arg = file_close)
     : std::streambuf (), f (f_arg), cf (cf_arg)
   { }
 
+  // No copying!
+
+  c_zfile_ptr_buf (const c_zfile_ptr_buf&) = delete;
+
+  c_zfile_ptr_buf& operator = (const c_zfile_ptr_buf&) = delete;
+
   ~c_zfile_ptr_buf (void);
 
   int_type overflow (int_type);
 
   int_type underflow (void) { return underflow_common (false); }
 
   int_type uflow (void) { return underflow_common (true); }
 
@@ -201,22 +207,16 @@ protected:
 
   gzFile f;
 
   close_fcn cf;
 
 private:
 
   int_type underflow_common (bool);
-
-  // No copying!
-
-  c_zfile_ptr_buf (const c_zfile_ptr_buf&) = delete;
-
-  c_zfile_ptr_buf& operator = (const c_zfile_ptr_buf&) = delete;
 };
 
 typedef c_file_ptr_stream<std::istream, gzFile, c_zfile_ptr_buf>
   i_c_zfile_ptr_stream;
 typedef c_file_ptr_stream<std::ostream, gzFile, c_zfile_ptr_buf>
   o_c_zfile_ptr_stream;
 typedef c_file_ptr_stream<std::iostream, gzFile, c_zfile_ptr_buf>
   io_c_zfile_ptr_stream;
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -63,16 +63,22 @@ public:
   static octave::dynamic_library find_file (const std::string& file_name);
 
   static void display (void);
 
 private:
 
   octave_shlib_list (void) : lib_list () { }
 
+  // No copying!
+
+  octave_shlib_list (const octave_shlib_list&) = delete;
+
+  octave_shlib_list& operator = (const octave_shlib_list&) = delete;
+
   ~octave_shlib_list (void) = default;
 
   void do_append (const octave::dynamic_library& shl);
 
   void do_remove (octave::dynamic_library& shl,
                   octave::dynamic_library::close_hook cl_hook = 0);
 
   octave::dynamic_library do_find_file (const std::string& file_name) const;
@@ -82,22 +88,16 @@ private:
   static octave_shlib_list *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static bool instance_ok (void);
 
   // List of libraries we have loaded.
   std::list<octave::dynamic_library> lib_list;
-
-  // No copying!
-
-  octave_shlib_list (const octave_shlib_list&) = delete;
-
-  octave_shlib_list& operator = (const octave_shlib_list&) = delete;
 };
 
 octave_shlib_list *octave_shlib_list::instance = 0;
 
 void
 octave_shlib_list::do_append (const octave::dynamic_library& shl)
 {
   lib_list.push_back (shl);
diff --git a/libinterp/corefcn/dynamic-ld.h b/libinterp/corefcn/dynamic-ld.h
--- a/libinterp/corefcn/dynamic-ld.h
+++ b/libinterp/corefcn/dynamic-ld.h
@@ -35,16 +35,22 @@ class
 octave_dynamic_loader
 {
 protected:
 
   octave_dynamic_loader (void) { }
 
 public:
 
+  // No copying!
+
+  octave_dynamic_loader (const octave_dynamic_loader&) = delete;
+
+  octave_dynamic_loader& operator = (const octave_dynamic_loader&) = delete;
+
   virtual ~octave_dynamic_loader (void) = default;
 
   static octave_function *
   load_oct (const std::string& fcn_name,
             const std::string& file_name = "",
             bool relative = false);
 
   static octave_function *
@@ -55,22 +61,16 @@ public:
   static bool remove_oct (const std::string& fcn_name,
                           octave::dynamic_library& shl);
 
   static bool remove_mex (const std::string& fcn_name,
                           octave::dynamic_library& shl);
 
 private:
 
-  // No copying!
-
-  octave_dynamic_loader (const octave_dynamic_loader&) = delete;
-
-  octave_dynamic_loader& operator = (const octave_dynamic_loader&) = delete;
-
   static octave_dynamic_loader *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static bool instance_ok (void);
 
   octave_function *
   do_load_oct (const std::string& fcn_name,
diff --git a/libinterp/corefcn/event-queue.h b/libinterp/corefcn/event-queue.h
--- a/libinterp/corefcn/event-queue.h
+++ b/libinterp/corefcn/event-queue.h
@@ -32,16 +32,22 @@ along with Octave; see the file COPYING.
 
 class
 event_queue : public action_container
 {
 public:
 
   event_queue (void) : fifo () { }
 
+  // No copying!
+
+  event_queue (const event_queue&) = delete;
+
+  event_queue& operator = (const event_queue&) = delete;
+
   // Destructor should not raise an exception, so all actions
   // registered should be exception-safe.  If you're not sure, see
   // event_queue_safe.
 
   ~event_queue (void) { run (); }
 
   void add (elem *new_elem)
   {
@@ -69,24 +75,16 @@ public:
       }
   }
 
   size_t size (void) const { return fifo.size (); }
 
 protected:
 
   std::queue<elem *> fifo;
-
-private:
-
-  // No copying!
-
-  event_queue (const event_queue&) = delete;
-
-  event_queue& operator = (const event_queue&) = delete;
 };
 
 // Like event_queue, but this one will guard against the
 // possibility of seeing an exception (or interrupt) in the cleanup actions.
 // Not that we can do much about it, but at least we won't crash.
 
 class
 event_queue_safe : public event_queue
@@ -94,34 +92,32 @@ event_queue_safe : public event_queue
 private:
 
   void warn_unhandled_exception (void) const;
 
 public:
 
   event_queue_safe (void) : event_queue () { }
 
+  // No copying!
+
+  event_queue_safe (const event_queue_safe&) = delete;
+
+  event_queue_safe& operator = (const event_queue_safe&) = delete;
+
   ~event_queue_safe (void)
   {
     while (! empty ())
       {
         try
           {
             run_first ();
           }
         catch (...) // Yes, the black hole.  Remember we're in a dtor.
           {
             warn_unhandled_exception ();
           }
       }
   }
-
-private:
-
-  // No copying!
-
-  event_queue_safe (const event_queue_safe&) = delete;
-
-  event_queue_safe& operator = (const event_queue_safe&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -87,17 +87,61 @@ warn_glyph_render (FT_ULong c)
 // Forward declaration
 static void ft_face_destroyed (void *object);
 
 namespace octave
 {
   class
   ft_manager
   {
+  private:
+
+    ft_manager (void)
+      : library (), freetype_initialized (false), fontconfig_initialized (false)
+    {
+      if (FT_Init_FreeType (&library))
+        error ("unable to initialize FreeType library");
+      else
+        freetype_initialized = true;
+
+#if defined (HAVE_FONTCONFIG)
+      if (! FcInit ())
+        error ("unable to initialize fontconfig library");
+      else
+        fontconfig_initialized = true;
+#endif
+    }
+
   public:
+
+    // No copying!
+
+    ft_manager (const ft_manager&) = delete;
+
+    ft_manager& operator = (const ft_manager&) = delete;
+
+  private:
+
+    ~ft_manager (void)
+    {
+      if (freetype_initialized)
+        FT_Done_FreeType (library);
+
+#if defined (HAVE_FONTCONFIG)
+      // FIXME: Skip the call to FcFini because it can trigger the assertion
+      //
+      //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
+      //
+      // if (fontconfig_initialized)
+      //   FcFini ();
+#endif
+    }
+
+  public:
+
     static bool instance_ok (void)
     {
       bool retval = true;
 
       if (! instance)
         {
           instance = new ft_manager ();
 
@@ -134,55 +178,16 @@ namespace octave
     typedef std::pair<std::string, double> ft_key;
     typedef std::map<ft_key, FT_Face> ft_cache;
 
     // Cache the fonts loaded by FreeType.  This cache only contains
     // weak references to the fonts, strong references are only present
     // in class text_renderer.
     ft_cache cache;
 
-  private:
-
-    // No copying!
-
-    ft_manager (const ft_manager&) = delete;
-
-    ft_manager& operator = (const ft_manager&) = delete;
-
-    ft_manager (void)
-      : library (), freetype_initialized (false), fontconfig_initialized (false)
-    {
-      if (FT_Init_FreeType (&library))
-        error ("unable to initialize FreeType library");
-      else
-        freetype_initialized = true;
-
-#if defined (HAVE_FONTCONFIG)
-      if (! FcInit ())
-        error ("unable to initialize fontconfig library");
-      else
-        fontconfig_initialized = true;
-#endif
-    }
-
-    ~ft_manager (void)
-    {
-      if (freetype_initialized)
-        FT_Done_FreeType (library);
-
-#if defined (HAVE_FONTCONFIG)
-      // FIXME: Skip the call to FcFini because it can trigger the assertion
-      //
-      //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
-      //
-      // if (fontconfig_initialized)
-      //   FcFini ();
-#endif
-    }
-
     FT_Face do_get_font (const std::string& name, const std::string& weight,
                          const std::string& angle, double size)
     {
       FT_Face retval = 0;
 
 #if defined (HAVE_FT_REFERENCE_FACE)
       // Look first into the font cache, then use fontconfig.  If the font
       // is present in the cache, simply add a reference and return it.
@@ -346,16 +351,22 @@ namespace octave
   public:
 
     ft_text_renderer (void)
       : base_text_renderer (), font (), bbox (1, 4, 0.0), halign (0),
         xoffset (0), line_yoffset (0), yoffset (0), mode (MODE_BBOX),
         color (dim_vector (1, 3), 0)
     { }
 
+    // No copying!
+
+    ft_text_renderer (const ft_text_renderer&) = delete;
+
+    ft_text_renderer& operator = (const ft_text_renderer&) = delete;
+
     ~ft_text_renderer (void) = default;
 
     void visit (text_element_string& e);
 
     void visit (text_element_list& e);
 
     void visit (text_element_subscript& e);
 
@@ -398,22 +409,16 @@ namespace octave
                          int halign, int valign, double rotation,
                          const caseless_str& interpreter,
                          bool handle_rotation);
 
   private:
 
     int rotation_to_mode (double rotation) const;
 
-    // No copying!
-
-    ft_text_renderer (const ft_text_renderer&) = delete;
-
-    ft_text_renderer& operator = (const ft_text_renderer&) = delete;
-
     // Class to hold information about fonts and a strong
     // reference to the font objects loaded by FreeType.
 
     class ft_font : public text_renderer::font
     {
     public:
 
       ft_font (void)
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -265,16 +265,22 @@ namespace octave
 #else
     typedef void (CALLBACK *fcn) (void);
 #endif
 
   public:
 
     opengl_tesselator (void) : glu_tess (0), fill () { init (); }
 
+    // No copying!
+
+    opengl_tesselator (const opengl_tesselator&) = delete;
+
+    opengl_tesselator operator = (const opengl_tesselator&) = delete;
+
     virtual ~opengl_tesselator (void)
     { if (glu_tess) gluDeleteTess (glu_tess); }
 
     void begin_polygon (bool filled = true)
     {
       gluTessProperty (glu_tess, GLU_TESS_BOUNDARY_ONLY,
                        (filled ? GL_FALSE : GL_TRUE));
       fill = filled;
@@ -345,22 +351,16 @@ namespace octave
     static void CALLBACK tess_edge_flag (GLboolean flag, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->edge_flag (flag); }
 
     static void CALLBACK tess_error (GLenum err, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->error (err); }
 
   private:
 
-    // No copying!
-
-    opengl_tesselator (const opengl_tesselator&) = delete;
-
-    opengl_tesselator operator = (const opengl_tesselator&) = delete;
-
     GLUtesselator *glu_tess;
     bool fill;
   };
 
   class
   vertex_data
   {
   public:
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -33,16 +33,22 @@ namespace octave
   class
   OCTINTERP_API
   opengl_renderer
   {
   public:
 
     opengl_renderer (void);
 
+    // No copying!
+
+    opengl_renderer (const opengl_renderer&) = delete;
+
+    opengl_renderer& operator = (const opengl_renderer&) = delete;
+
     virtual ~opengl_renderer (void) = default;
 
     virtual void draw (const graphics_object& go, bool toplevel = true);
 
     virtual void draw (const Matrix& hlist, bool toplevel = false)
     {
       int len = hlist.numel ();
 
@@ -134,22 +140,16 @@ namespace octave
                                    const string_vector& ticklabels,
                                    double lim1, double lim2,
                                    double p1, double p2,
                                    int xyz, int ha, int va,
                                    int& wmax, int& hmax);
 
   private:
 
-    // No copying!
-
-    opengl_renderer (const opengl_renderer&) = delete;
-
-    opengl_renderer& operator = (const opengl_renderer&) = delete;
-
     bool is_nan_or_inf (double x, double y, double z) const
     {
       return (octave::math::isnan (x) || octave::math::isnan (y)
               || octave::math::isnan (z)
               || octave::math::isinf (x) || octave::math::isinf (y)
               || octave::math::isinf (z));
     }
 
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9486,39 +9486,41 @@ private:
   octave_value callback;
   octave_value callback_data;
 };
 
 class
 function_event : public base_graphics_event
 {
 public:
+
+  // function_event objects must be created with at least a function.
+
+  function_event (void) = delete;
+
   function_event (graphics_event::event_fcn fcn, void* data = 0)
     : base_graphics_event (), function (fcn), function_data (data)
   { }
 
+  // No copying!
+
+  function_event (const function_event&) = delete;
+
+  function_event & operator = (const function_event&) = delete;
+
   void execute (void)
   {
     function (function_data);
   }
 
 private:
 
   graphics_event::event_fcn function;
 
   void* function_data;
-
-  // function_event objects must be created with at least a function.
-  function_event (void);
-
-  // No copying!
-
-  function_event (const function_event&) = delete;
-
-  function_event & operator = (const function_event&) = delete;
 };
 
 class
 set_event : public base_graphics_event
 {
 public:
   set_event (const graphics_handle& h, const std::string& name,
              const octave_value& value, bool do_notify_toolkit = true)
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -2685,16 +2685,22 @@ protected:
 
 class OCTINTERP_API base_graphics_object
 {
 public:
   friend class graphics_object;
 
   base_graphics_object (void) : count (1), toolkit_flag (false) { }
 
+  // No copying!
+
+  base_graphics_object (const base_graphics_object&) = delete;
+
+  base_graphics_object& operator = (const base_graphics_object&) = delete;
+
   virtual ~base_graphics_object (void) = default;
 
   virtual void mark_modified (void)
   {
     if (! valid_object ())
       error ("base_graphics_object::mark_modified: invalid graphics object");
 
     get_properties ().mark_modified ();
@@ -2920,22 +2926,16 @@ protected:
 
 protected:
   // A reference count.
   octave_refcount<int> count;
 
   // A flag telling whether this object is a valid object
   // in the backend context.
   bool toolkit_flag;
-
-  // No copying!
-
-  base_graphics_object (const base_graphics_object&) = delete;
-
-  base_graphics_object& operator = (const base_graphics_object&) = delete;
 };
 
 class OCTINTERP_API graphics_object
 {
 public:
   graphics_object (void) : rep (new base_graphics_object ()) { }
 
   graphics_object (base_graphics_object *new_rep)
@@ -6358,18 +6358,16 @@ public:
   public:
     auto_lock (bool wait = true)
       : octave_autolock (instance_ok ()
                          ? instance->graphics_lock
                          : octave_mutex (),
                          wait)
     { }
 
-  private:
-
     // No copying!
 
     auto_lock (const auto_lock&) = delete;
 
     auto_lock& operator = (const auto_lock&) = delete;
   };
 
 private:
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -97,35 +97,35 @@ namespace octave
   class application;
 
   class OCTINTERP_API interpreter
   {
   public:
 
     interpreter (application *app_context = 0, bool embedded = false);
 
+    // No copying, at least not yet...
+
+    interpreter (const interpreter&) = delete;
+
+    interpreter& operator = (const interpreter&) = delete;
+
     ~interpreter (void);
 
     int execute (void);
 
     int execute_eval_option_code (const std::string& code);
 
     void execute_command_line_file (const std::string& fname);
 
     bool interactive (void) const { return m_interactive; }
     void interactive (bool arg) { m_interactive = arg; }
 
   private:
 
-    // No copying, at least not yet...
-
-    interpreter (const interpreter&) = delete;
-
-    interpreter& operator = (const interpreter&) = delete;
-
     int main_loop (void);
 
     void clean_up_and_exit (int status, bool safe_to_return = false);
 
     application *m_app_context;
 
     tree_evaluator *m_evaluator;
 
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -154,16 +154,21 @@ static inline void *maybe_mark_foreign (
 class mxArray_octave_value : public mxArray_base
 {
 public:
 
   mxArray_octave_value (const octave_value& ov)
     : mxArray_base (), val (ov), mutate_flag (false),
       id (mxUNKNOWN_CLASS), class_name (0), ndims (-1), dims (0) { }
 
+  // No assignment!  FIXME: should this be implemented?  Note that we
+  // do have a copy constructor.
+
+  mxArray_octave_value& operator = (const mxArray_octave_value&) = delete;
+
   mxArray_base *dup (void) const { return new mxArray_octave_value (*this); }
 
   mxArray *as_mxArray (void) const
   {
     mxArray *retval = val.as_mxArray ();
 
     // RETVAL is assumed to be an mxArray_matlab object.  Should we
     // assert that condition here?
@@ -613,21 +618,16 @@ private:
   // Caching these does not cost much or lead to much duplicated
   // code.  For other things, we just request mutation to a
   // Matlab-style mxArray object.
 
   mutable mxClassID id;
   mutable char *class_name;
   mutable mwSize ndims;
   mutable mwSize *dims;
-
-  // No assignment!  FIXME: should this be implemented?  Note that we
-  // do have a copy constructor.
-
-  mxArray_octave_value& operator = (const mxArray_octave_value&);
 };
 
 // The base class for the Matlab-style representation, used to handle
 // things that are common to all Matlab-style objects.
 
 class mxArray_matlab : public mxArray_base
 {
 protected:
@@ -683,18 +683,33 @@ protected:
   mxArray_matlab (mxClassID id_arg, mwSize m, mwSize n)
     : mxArray_base (), class_name (0), id (id_arg), ndims (2),
       dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
   {
     dims[0] = m;
     dims[1] = n;
   }
 
+  mxArray_matlab (const mxArray_matlab& val)
+    : mxArray_base (val), class_name (mxArray::strsave (val.class_name)),
+      id (val.id), ndims (val.ndims),
+      dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
+  {
+    for (mwIndex i = 0; i < ndims; i++)
+      dims[i] = val.dims[i];
+  }
+
 public:
 
+  // No assignment!
+  // FIXME: should this be implemented?
+  //        Note that we *do* have a copy constructor.
+
+  mxArray_matlab& operator = (const mxArray_matlab&);
+
   ~mxArray_matlab (void)
   {
     mxFree (class_name);
     mxFree (dims);
   }
 
   int is_cell (void) const { return id == mxCELL_CLASS; }
 
@@ -980,25 +995,16 @@ public:
       // FIXME: user-defined objects need their own class ID.
       //        What should they return, size of pointer?
       default: return 0;
       }
   }
 
 protected:
 
-  mxArray_matlab (const mxArray_matlab& val)
-    : mxArray_base (val), class_name (mxArray::strsave (val.class_name)),
-      id (val.id), ndims (val.ndims),
-      dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
-  {
-    for (mwIndex i = 0; i < ndims; i++)
-      dims[i] = val.dims[i];
-  }
-
   dim_vector
   dims_to_dim_vector (void) const
   {
     mwSize nd = get_number_of_dimensions ();
 
     mwSize *d = get_dimensions ();
 
     dim_vector dv;
@@ -1018,22 +1024,16 @@ private:
 
   mwSize ndims;
   mwSize *dims;
 
   OCTAVE_NORETURN void err_invalid_type (void) const
   {
     error ("invalid type for operation");
   }
-
-  // No assignment!
-  // FIXME: should this be implemented?
-  //        Note that we *do* have a copy constructor.
-
-  mxArray_matlab& operator = (const mxArray_matlab&);
 };
 
 // Matlab-style numeric, character, and logical data.
 
 class mxArray_number : public mxArray_matlab
 {
 public:
 
@@ -1127,16 +1127,41 @@ public:
         for (size_t i = 0; i < tmp_len; i++)
           cpr[m*i+j] = static_cast<mxChar> (ptr[i]);
 
         for (size_t i = tmp_len; i < static_cast<size_t>(nc); i++)
           cpr[m*i+j] = static_cast<mxChar> (' ');
       }
   }
 
+protected:
+
+  mxArray_number (const mxArray_number& val)
+    : mxArray_matlab (val),
+      pr (mxArray::malloc (get_number_of_elements () * get_element_size ())),
+      pi (val.pi ? mxArray::malloc (get_number_of_elements ()
+                                    * get_element_size ())
+                 : 0)
+  {
+    size_t nbytes = get_number_of_elements () * get_element_size ();
+
+    if (pr)
+      memcpy (pr, val.pr, nbytes);
+
+    if (pi)
+      memcpy (pi, val.pi, nbytes);
+  }
+
+public:
+
+  // No assignment!  FIXME: should this be implemented?  Note that we
+  // do have a copy constructor.
+
+  mxArray_number& operator = (const mxArray_number&);
+
   mxArray_base *dup (void) const { return new mxArray_number (*this); }
 
   ~mxArray_number (void)
   {
     mxFree (pr);
     mxFree (pi);
   }
 
@@ -1410,41 +1435,20 @@ protected:
     ARRAY_ELT_T *ptr = val.fortran_vec ();
 
     for (mwIndex i = 0; i < nel; i++)
       ptr[i] = ppr[i];
 
     return octave_value (val);
   }
 
-  mxArray_number (const mxArray_number& val)
-    : mxArray_matlab (val),
-      pr (mxArray::malloc (get_number_of_elements () * get_element_size ())),
-      pi (val.pi ? mxArray::malloc (get_number_of_elements ()
-                                    * get_element_size ())
-                 : 0)
-  {
-    size_t nbytes = get_number_of_elements () * get_element_size ();
-
-    if (pr)
-      memcpy (pr, val.pr, nbytes);
-
-    if (pi)
-      memcpy (pi, val.pi, nbytes);
-  }
-
 private:
 
   void *pr;
   void *pi;
-
-  // No assignment!  FIXME: should this be implemented?  Note that we
-  // do have a copy constructor.
-
-  mxArray_number& operator = (const mxArray_number&);
 };
 
 // Matlab-style sparse arrays.
 
 class mxArray_sparse : public mxArray_matlab
 {
 public:
 
@@ -1452,16 +1456,47 @@ public:
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n), nzmax (nzmax_arg),
       pr (mxArray::calloc (nzmax, get_element_size ())),
       pi (flag == mxCOMPLEX ? mxArray::calloc (nzmax, get_element_size ()) : 0),
       ir (static_cast<mwIndex *> (mxArray::calloc (nzmax, sizeof (mwIndex)))),
       jc (static_cast<mwIndex *> (mxArray::calloc (n + 1, sizeof (mwIndex))))
   { }
 
+private:
+
+  mxArray_sparse (const mxArray_sparse& val)
+    : mxArray_matlab (val), nzmax (val.nzmax),
+      pr (mxArray::malloc (nzmax * get_element_size ())),
+      pi (val.pi ? mxArray::malloc (nzmax * get_element_size ()) : 0),
+      ir (static_cast<mwIndex *> (mxArray::malloc (nzmax * sizeof (mwIndex)))),
+      jc (static_cast<mwIndex *> (mxArray::malloc (nzmax * sizeof (mwIndex))))
+  {
+    size_t nbytes = nzmax * get_element_size ();
+
+    if (pr)
+      memcpy (pr, val.pr, nbytes);
+
+    if (pi)
+      memcpy (pi, val.pi, nbytes);
+
+    if (ir)
+      memcpy (ir, val.ir, nzmax * sizeof (mwIndex));
+
+    if (jc)
+      memcpy (jc, val.jc, (val.get_n () + 1) * sizeof (mwIndex));
+  }
+
+public:
+
+  // No assignment!  FIXME: should this be implemented?  Note that we
+  // do have a copy constructor.
+
+  mxArray_sparse& operator = (const mxArray_sparse&);
+
   mxArray_base *dup (void) const { return new mxArray_sparse (*this); }
 
   ~mxArray_sparse (void)
   {
     mxFree (pr);
     mxFree (pi);
     mxFree (ir);
     mxFree (jc);
@@ -1575,43 +1610,16 @@ public:
 private:
 
   mwSize nzmax;
 
   void *pr;
   void *pi;
   mwIndex *ir;
   mwIndex *jc;
-
-  mxArray_sparse (const mxArray_sparse& val)
-    : mxArray_matlab (val), nzmax (val.nzmax),
-      pr (mxArray::malloc (nzmax * get_element_size ())),
-      pi (val.pi ? mxArray::malloc (nzmax * get_element_size ()) : 0),
-      ir (static_cast<mwIndex *> (mxArray::malloc (nzmax * sizeof (mwIndex)))),
-      jc (static_cast<mwIndex *> (mxArray::malloc (nzmax * sizeof (mwIndex))))
-  {
-    size_t nbytes = nzmax * get_element_size ();
-
-    if (pr)
-      memcpy (pr, val.pr, nbytes);
-
-    if (pi)
-      memcpy (pi, val.pi, nbytes);
-
-    if (ir)
-      memcpy (ir, val.ir, nzmax * sizeof (mwIndex));
-
-    if (jc)
-      memcpy (jc, val.jc, (val.get_n () + 1) * sizeof (mwIndex));
-  }
-
-  // No assignment!  FIXME: should this be implemented?  Note that we
-  // do have a copy constructor.
-
-  mxArray_sparse& operator = (const mxArray_sparse&);
 };
 
 // Matlab-style struct arrays.
 
 class mxArray_struct : public mxArray_matlab
 {
 public:
 
@@ -1645,16 +1653,45 @@ public:
                                                      sizeof (char *)))),
       data (static_cast<mxArray **> (mxArray::calloc (nfields *
                                                       get_number_of_elements (),
                                                       sizeof (mxArray *))))
   {
     init (keys);
   }
 
+private:
+
+  mxArray_struct (const mxArray_struct& val)
+    : mxArray_matlab (val), nfields (val.nfields),
+      fields (static_cast<char **> (mxArray::malloc (nfields
+                                                     * sizeof (char *)))),
+      data (static_cast<mxArray **> (mxArray::malloc (nfields *
+                                                      get_number_of_elements ()
+                                                      * sizeof (mxArray *))))
+  {
+    for (int i = 0; i < nfields; i++)
+      fields[i] = mxArray::strsave (val.fields[i]);
+
+    mwSize nel = get_number_of_elements ();
+
+    for (mwIndex i = 0; i < nel * nfields; i++)
+      {
+        mxArray *ptr = val.data[i];
+        data[i] = ptr ? ptr->dup () : 0;
+      }
+  }
+
+public:
+
+  // No assignment!  FIXME: should this be implemented?  Note that we
+  // do have a copy constructor.
+
+  mxArray_struct& operator = (const mxArray_struct& val);
+
   void init (const char **keys)
   {
     for (int i = 0; i < nfields; i++)
       fields[i] = mxArray::strsave (keys[i]);
   }
 
   mxArray_base *dup (void) const { return new mxArray_struct (*this); }
 
@@ -1839,41 +1876,16 @@ public:
 
 private:
 
   int nfields;
 
   char **fields;
 
   mxArray **data;
-
-  mxArray_struct (const mxArray_struct& val)
-    : mxArray_matlab (val), nfields (val.nfields),
-      fields (static_cast<char **> (mxArray::malloc (nfields
-                                                     * sizeof (char *)))),
-      data (static_cast<mxArray **> (mxArray::malloc (nfields *
-                                                      get_number_of_elements ()
-                                                      * sizeof (mxArray *))))
-  {
-    for (int i = 0; i < nfields; i++)
-      fields[i] = mxArray::strsave (val.fields[i]);
-
-    mwSize nel = get_number_of_elements ();
-
-    for (mwIndex i = 0; i < nel * nfields; i++)
-      {
-        mxArray *ptr = val.data[i];
-        data[i] = ptr ? ptr->dup () : 0;
-      }
-  }
-
-  // No assignment!  FIXME: should this be implemented?  Note that we
-  // do have a copy constructor.
-
-  mxArray_struct& operator = (const mxArray_struct& val);
 };
 
 // Matlab-style cell arrays.
 
 class mxArray_cell : public mxArray_matlab
 {
 public:
 
@@ -1887,16 +1899,39 @@ public:
       data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (),
                                      sizeof (mxArray *)))) { }
 
   mxArray_cell (mwSize m, mwSize n)
     : mxArray_matlab (mxCELL_CLASS, m, n),
       data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (),
                                      sizeof (mxArray *)))) { }
 
+private:
+
+  mxArray_cell (const mxArray_cell& val)
+    : mxArray_matlab (val),
+      data (static_cast<mxArray **> (mxArray::malloc (get_number_of_elements ()
+                                                      * sizeof (mxArray *))))
+  {
+    mwSize nel = get_number_of_elements ();
+
+    for (mwIndex i = 0; i < nel; i++)
+      {
+        mxArray *ptr = val.data[i];
+        data[i] = ptr ? ptr->dup () : 0;
+      }
+  }
+
+public:
+
+  // No assignment!  FIXME: should this be implemented?  Note that we
+  // do have a copy constructor.
+
+  mxArray_cell& operator = (const mxArray_cell&);
+
   mxArray_base *dup (void) const { return new mxArray_cell (*this); }
 
   ~mxArray_cell (void)
   {
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel; i++)
       delete data[i];
@@ -1929,35 +1964,16 @@ public:
       p[i] = mxArray::as_octave_value (data[i]);
 
     return c;
   }
 
 private:
 
   mxArray **data;
-
-  mxArray_cell (const mxArray_cell& val)
-    : mxArray_matlab (val),
-      data (static_cast<mxArray **> (mxArray::malloc (get_number_of_elements ()
-                                                      * sizeof (mxArray *))))
-  {
-    mwSize nel = get_number_of_elements ();
-
-    for (mwIndex i = 0; i < nel; i++)
-      {
-        mxArray *ptr = val.data[i];
-        data[i] = ptr ? ptr->dup () : 0;
-      }
-  }
-
-  // No assignment!  FIXME: should this be implemented?  Note that we
-  // do have a copy constructor.
-
-  mxArray_cell& operator = (const mxArray_cell&);
 };
 
 // ------------------------------------------------------------------
 
 mxArray::mxArray (const octave_value& ov)
   : rep (new mxArray_octave_value (ov)), name (0) { }
 
 mxArray::mxArray (mxClassID id, mwSize ndims, const mwSize *dims,
@@ -2060,16 +2076,22 @@ mxArray::maybe_mutate (void) const
 
 class mex
 {
 public:
 
   mex (octave_mex_function *f)
     : curr_mex_fcn (f), memlist (), arraylist (), fname (0) { }
 
+  // No copying!
+
+  mex (const mex&) = delete;
+
+  mex& operator = (const mex&) = delete;
+
   ~mex (void)
   {
     // We can't use mex::free here because it modifies memlist.
     while (! memlist.empty ())
       {
         std::set<void *>::iterator p = memlist.begin ();
         xfree (*p);
         memlist.erase (p);
@@ -2356,22 +2378,16 @@ private:
     if (p != global_memlist.end ())
       global_memlist.erase (p);
 #if defined (DEBUG)
     else
       warning ("%s: value not marked", function_name ());
 #endif
 
   }
-
-  // No copying!
-
-  mex (const mex&) = delete;
-
-  mex& operator = (const mex&) = delete;
 };
 
 // List of memory resources we allocated.
 std::set<void *> mex::global_memlist;
 
 // Current context.
 mex *mex_context = 0;
 
diff --git a/libinterp/corefcn/mxarray.in.h b/libinterp/corefcn/mxarray.in.h
--- a/libinterp/corefcn/mxarray.in.h
+++ b/libinterp/corefcn/mxarray.in.h
@@ -352,16 +352,22 @@ public:
         mxArray_base *new_rep = rep->dup ();
 
         retval = new mxArray (new_rep, name);
       }
 
     return retval;
   }
 
+  // No copying!
+
+  mxArray (const mxArray&) = delete;
+
+  mxArray& operator = (const mxArray&) = delete;
+
   ~mxArray (void);
 
   bool is_octave_value (void) const { return rep->is_octave_value (); }
 
   int is_cell (void) const { return rep->is_cell (); }
 
   int is_char (void) const { return rep->is_char (); }
 
@@ -529,22 +535,16 @@ private:
   mutable mxArray_base *rep;
 
   char *name;
 
   mxArray (mxArray_base *r, const char *n)
     : rep (r), name (mxArray::strsave (n)) { }
 
   void maybe_mutate (void) const;
-
-  // No copying!
-
-  mxArray (const mxArray&) = delete;
-
-  mxArray& operator = (const mxArray&) = delete;
 };
 
 #undef DO_MUTABLE_METHOD
 #undef DO_VOID_MUTABLE_METHOD
 
 #endif
 #endif
 
diff --git a/libinterp/corefcn/oct-fstrm.h b/libinterp/corefcn/oct-fstrm.h
--- a/libinterp/corefcn/oct-fstrm.h
+++ b/libinterp/corefcn/oct-fstrm.h
@@ -35,16 +35,22 @@ octave_fstream : public octave_base_stre
 {
 public:
 
   octave_fstream (const std::string& nm_arg,
                   std::ios::openmode arg_md = std::ios::in | std::ios::out,
                   octave::mach_info::float_format flt_fmt
                     = octave::mach_info::native_float_format ());
 
+  // No copying!
+
+  octave_fstream (const octave_fstream&) = delete;
+
+  octave_fstream& operator = (const octave_fstream&) = delete;
+
   static octave_stream
   create (const std::string& nm_arg,
           std::ios::openmode arg_md = std::ios::in | std::ios::out,
           octave::mach_info::float_format flt_fmt
             = octave::mach_info::native_float_format ());
 
   // Position a stream at OFFSET relative to ORIGIN.
 
@@ -72,18 +78,12 @@ protected:
 
   ~octave_fstream (void) = default;
 
 private:
 
   std::string nm;
 
   std::fstream fs;
-
-  // No copying!
-
-  octave_fstream (const octave_fstream&) = delete;
-
-  octave_fstream& operator = (const octave_fstream&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/corefcn/oct-iostrm.h b/libinterp/corefcn/oct-iostrm.h
--- a/libinterp/corefcn/oct-iostrm.h
+++ b/libinterp/corefcn/oct-iostrm.h
@@ -35,16 +35,28 @@ octave_base_iostream : public octave_bas
 public:
 
   octave_base_iostream (const std::string& n = "",
                         std::ios::openmode m = std::ios::in | std::ios::out,
                         octave::mach_info::float_format ff
                           = octave::mach_info::native_float_format ())
     : octave_base_stream (m, ff), nm (n) { }
 
+  // No copying!
+
+  octave_base_iostream (const octave_base_iostream&) = delete;
+
+  octave_base_iostream& operator = (const octave_base_iostream&) = delete;
+
+protected:
+
+  ~octave_base_iostream (void) = default;
+
+public:
+
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin);
 
   // Return current stream position.
 
   off_t tell (void);
 
@@ -53,31 +65,23 @@ public:
   bool eof (void) const;
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
 
 protected:
 
-  ~octave_base_iostream (void) = default;
-
   void invalid_operation (void) const;
 
 private:
 
   std::string nm;
 
   virtual const char *stream_type (void) const = 0;
-
-  // No copying!
-
-  octave_base_iostream (const octave_base_iostream&) = delete;
-
-  octave_base_iostream& operator = (const octave_base_iostream&) = delete;
 };
 
 class
 octave_istream : public octave_base_iostream
 {
 public:
 
   octave_istream (std::istream *arg = 0, const std::string& n = "")
diff --git a/libinterp/corefcn/oct-prcstrm.h b/libinterp/corefcn/oct-prcstrm.h
--- a/libinterp/corefcn/oct-prcstrm.h
+++ b/libinterp/corefcn/oct-prcstrm.h
@@ -35,56 +35,52 @@ octave_iprocstream : public octave_stdio
 {
 public:
 
   octave_iprocstream (const std::string& n,
                       std::ios::openmode arg_md = std::ios::in,
                       octave::mach_info::float_format flt_fmt
                         = octave::mach_info::native_float_format ());
 
+  // No copying!
+
+  octave_iprocstream (const octave_iprocstream&) = delete;
+
+  octave_iprocstream& operator = (const octave_iprocstream&) = delete;
+
   static octave_stream
   create (const std::string& n, std::ios::openmode arg_md = std::ios::in,
           octave::mach_info::float_format flt_fmt
             = octave::mach_info::native_float_format ());
 
 protected:
 
   ~octave_iprocstream (void);
-
-private:
-
-  // No copying!
-
-  octave_iprocstream (const octave_iprocstream&) = delete;
-
-  octave_iprocstream& operator = (const octave_iprocstream&) = delete;
 };
 
 class
 octave_oprocstream : public octave_stdiostream
 {
 public:
 
   octave_oprocstream (const std::string& n,
                       std::ios::openmode arg_md = std::ios::out,
                       octave::mach_info::float_format flt_fmt
                         = octave::mach_info::native_float_format ());
 
+  // No copying!
+
+  octave_oprocstream (const octave_oprocstream&) = delete;
+
+  octave_oprocstream& operator = (const octave_oprocstream&) = delete;
+
   static octave_stream
   create (const std::string& n, std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format flt_fmt
             = octave::mach_info::native_float_format ());
 
 protected:
 
   ~octave_oprocstream (void);
-
-private:
-
-  // No copying!
-
-  octave_oprocstream (const octave_oprocstream&) = delete;
-
-  octave_oprocstream& operator = (const octave_oprocstream&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/corefcn/oct-procbuf.h b/libinterp/corefcn/oct-procbuf.h
--- a/libinterp/corefcn/oct-procbuf.h
+++ b/libinterp/corefcn/oct-procbuf.h
@@ -40,16 +40,22 @@ public:
   octave_procbuf (void)
     : c_file_ptr_buf (0), wstatus (-1), open_p (false), proc_pid (-1),
       next (0) { }
 
   octave_procbuf (const char *command, int mode)
     : c_file_ptr_buf (0), wstatus (-1), open_p (false), proc_pid (-1),
       next (0) { open (command, mode); }
 
+  // No copying!
+
+  octave_procbuf (const octave_procbuf&) = delete;
+
+  octave_procbuf& operator = (const octave_procbuf&) = delete;
+
   ~octave_procbuf (void) { close (); }
 
   octave_procbuf *open (const char *command, int mode);
 
   octave_procbuf *close (void);
 
   int wait_status (void) const { return wstatus; }
 
@@ -61,22 +67,14 @@ protected:
 
   int wstatus;
 
   bool open_p;
 
   pid_t proc_pid;
 
   octave_procbuf *next;
-
-private:
-
-  // No copying!
-
-  octave_procbuf (const octave_procbuf&) = delete;
-
-  octave_procbuf& operator = (const octave_procbuf&) = delete;
 };
 
 extern void symbols_of_oct_procbuf (void);
 
 #endif
 
diff --git a/libinterp/corefcn/oct-stdstrm.h b/libinterp/corefcn/oct-stdstrm.h
--- a/libinterp/corefcn/oct-stdstrm.h
+++ b/libinterp/corefcn/oct-stdstrm.h
@@ -38,16 +38,22 @@ public:
                        std::ios::openmode m = std::ios::in | std::ios::out,
                        octave::mach_info::float_format ff
                          = octave::mach_info::native_float_format (),
                        typename BUF_T::close_fcn cf = BUF_T::file_close)
     : octave_base_stream (m, ff), nm (n), md (m),
       s (f ? new STREAM_T (f, cf) : 0), fnum (fid)
   { }
 
+  // No copying!
+
+  octave_tstdiostream (const octave_tstdiostream&) = delete;
+
+  octave_tstdiostream& operator = (const octave_tstdiostream&) = delete;
+
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin)
   { return s ? s->seek (offset, origin) : -1; }
 
   // Return current stream position.
 
   off_t tell (void) { return s ? s->tell () : -1; }
@@ -83,24 +89,16 @@ protected:
   std::ios::openmode md;
 
   STREAM_T *s;
 
   // The file number associated with this file.
   int fnum;
 
   ~octave_tstdiostream (void) { delete s; }
-
-private:
-
-  // No copying!
-
-  octave_tstdiostream (const octave_tstdiostream&) = delete;
-
-  octave_tstdiostream& operator = (const octave_tstdiostream&) = delete;
 };
 
 class
 octave_stdiostream
   : public octave_tstdiostream<c_file_ptr_buf, io_c_file_ptr_stream, FILE *>
 {
 public:
 
@@ -117,27 +115,25 @@ public:
           std::ios::openmode m = std::ios::in | std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format (),
           c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::file_close)
   {
     return octave_stream (new octave_stdiostream (n, f, m, ff, cf));
   }
 
-protected:
-
-  ~octave_stdiostream (void) = default;
-
-private:
-
   // No copying!
 
   octave_stdiostream (const octave_stdiostream&) = delete;
 
   octave_stdiostream& operator = (const octave_stdiostream&) = delete;
+
+protected:
+
+  ~octave_stdiostream (void) = default;
 };
 
 #if defined (HAVE_ZLIB)
 
 class
 octave_zstdiostream
   : public octave_tstdiostream<c_zfile_ptr_buf, io_c_zfile_ptr_stream, gzFile>
 {
@@ -157,25 +153,23 @@ public:
           std::ios::openmode m = std::ios::in | std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format (),
           c_zfile_ptr_buf::close_fcn cf = c_zfile_ptr_buf::file_close)
   {
     return octave_stream (new octave_zstdiostream (n, f, fid, m, ff, cf));
   }
 
-protected:
-
-  ~octave_zstdiostream (void) = default;
-
-private:
-
   // No copying!
 
   octave_zstdiostream (const octave_zstdiostream&) = delete;
 
   octave_zstdiostream& operator = (const octave_zstdiostream&) = delete;
+
+protected:
+
+  ~octave_zstdiostream (void) = default;
 };
 
 #endif
 
 #endif
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -237,16 +237,22 @@ public:
 
 class
 scanf_format_list
 {
 public:
 
   scanf_format_list (const std::string& fmt = "");
 
+  // No copying!
+
+  scanf_format_list (const scanf_format_list&) = delete;
+
+  scanf_format_list& operator = (const scanf_format_list&) = delete;
+
   ~scanf_format_list (void);
 
   octave_idx_type num_conversions (void) { return nconv; }
 
   // The length can be different than the number of conversions.
   // For example, "x %d y %d z" has 2 conversions but the length of
   // the list is 3 because of the characters that appear after the
   // last conversion.
@@ -312,21 +318,16 @@ private:
 
   void process_conversion (const std::string& s, size_t& i, size_t n,
                            int& width, bool& discard, char& type,
                            char& modifier);
 
   int finish_conversion (const std::string& s, size_t& i, size_t n,
                          int& width, bool discard, char& type,
                          char modifier);
-  // No copying!
-
-  scanf_format_list (const scanf_format_list&) = delete;
-
-  scanf_format_list& operator = (const scanf_format_list&) = delete;
 };
 
 scanf_format_list::scanf_format_list (const std::string& s)
   : nconv (0), curr_idx (0), fmt_elts (), buf ()
 {
   size_t n = s.length ();
 
   size_t i = 0;
@@ -788,16 +789,22 @@ public:
 
 class
 printf_format_list
 {
 public:
 
   printf_format_list (const std::string& fmt = "");
 
+  // No copying!
+
+  printf_format_list (const printf_format_list&) = delete;
+
+  printf_format_list& operator = (const printf_format_list&) = delete;
+
   ~printf_format_list (void);
 
   octave_idx_type num_conversions (void) { return nconv; }
 
   const printf_format_elt *first (void)
   {
     curr_idx = 0;
     return current ();
@@ -853,22 +860,16 @@ private:
 
   void process_conversion (const std::string& s, size_t& i, size_t n,
                            int& args, std::string& flags, int& fw,
                            int& prec, char& modifier, char& type);
 
   void finish_conversion (const std::string& s, size_t& i, int args,
                           const std::string& flags, int fw, int prec,
                           char modifier, char& type);
-
-  // No copying!
-
-  printf_format_list (const printf_format_list&) = delete;
-
-  printf_format_list& operator = (const printf_format_list&) = delete;
 };
 
 printf_format_list::printf_format_list (const std::string& s)
   : nconv (0), curr_idx (0), fmt_elts (), buf ()
 {
   size_t n = s.length ();
 
   size_t i = 0;
@@ -1219,16 +1220,22 @@ namespace octave
   {
   public:
 
     delimited_stream (std::istream& is, const std::string& delimiters,
                       int longest_lookahead, octave_idx_type bsize = 4096);
 
     delimited_stream (std::istream& is, const delimited_stream& ds);
 
+    // No copying!
+
+    delimited_stream (const delimited_stream&) = delete;
+
+    delimited_stream& operator = (const delimited_stream&) = delete;
+
     ~delimited_stream (void);
 
     // Called when optimized sequence of get is finished.  Ensures that
     // there is a remaining delimiter in buf, or loads more data in.
     void field_done (void)
     {
       if (idx >= last)
         refresh_buf ();
@@ -1333,22 +1340,16 @@ namespace octave
 
     // Position of start of buf in original stream.
     std::streampos buf_in_file;
 
     // Marker to see if a read consumes any characters.
     char *progress_marker;
 
     std::ios_base::iostate flags;
-
-    // No copying!
-
-    delimited_stream (const delimited_stream&) = delete;
-
-    delimited_stream& operator = (const delimited_stream&) = delete;
   };
 
   // Create a delimited stream, reading from is, with delimiters delims,
   // and allowing reading of up to tellg + longest_lookeahead.  When is
   // is at EOF, lookahead may be padded by ASCII nuls.
 
   delimited_stream::delimited_stream (std::istream& is,
                                       const std::string& delimiters,
@@ -1685,16 +1686,21 @@ namespace octave
 
   class
   textscan_format_list
   {
   public:
 
     textscan_format_list (const std::string& fmt = std::string (),
                           const std::string& who = "textscan");
+    // No copying!
+
+    textscan_format_list (const textscan_format_list&) = delete;
+
+    textscan_format_list& operator = (const textscan_format_list&) = delete;
 
     ~textscan_format_list (void);
 
     octave_idx_type num_conversions (void) const { return nconv; }
 
     // The length can be different than the number of conversions.
     // For example, "x %d y %d z" has 2 conversions but the length of
     // the list is 3 because of the characters that appear after the
@@ -1773,21 +1779,16 @@ namespace octave
     void process_conversion (const std::string& s, size_t& i, size_t n);
 
     std::string parse_char_class (const std::string& pattern) const;
 
     int finish_conversion (const std::string& s, size_t& i, size_t n,
                            unsigned int& width, int& prec, int& bitwidth,
                            octave_value& val_type,
                            bool discard, char& type);
-    // No copying!
-
-    textscan_format_list (const textscan_format_list&) = delete;
-
-    textscan_format_list& operator = (const textscan_format_list&) = delete;
   };
 
   // Main class to implement textscan.  Read data and parse it
   // according to a format.
   //
   // The calling sequence is
   //
   //   textscan scanner ();
@@ -1796,16 +1797,22 @@ namespace octave
   class
   OCTINTERP_API
   textscan
   {
   public:
 
     textscan (const std::string& who_arg = "textscan");
 
+    // No copying!
+
+    textscan (const textscan&) = delete;
+
+    textscan& operator = (const textscan&) = delete;
+
     ~textscan (void) = default;
 
     octave_value scan (std::istream& isp, const std::string& fmt,
                        octave_idx_type ntimes,
                        const octave_value_list& options,
                        octave_idx_type& read_count);
 
   private:
@@ -1925,22 +1932,16 @@ namespace octave
       return ((delim_table.empty () && (isspace (ch) || ch == eol1 || ch == eol2))
               || delim_table[ch] != '\0');
     }
 
     bool isspace (unsigned int ch) const { return whitespace_table[ch & 0xff]; }
 
     // True if the only delimiter is whitespace.
     bool whitespace_delim (void) const { return delim_table.empty (); }
-
-    // No copying!
-
-    textscan (const textscan&) = delete;
-
-    textscan& operator = (const textscan&) = delete;
   };
 
   textscan_format_list::textscan_format_list (const std::string& s,
                                               const std::string& who_arg)
     : who (who_arg), set_from_first (false), has_string (false),
       nconv (0), curr_idx (0), fmt_elts (), buf ()
   {
     size_t n = s.length ();
@@ -5292,16 +5293,22 @@ public:
       {
         octave_value val = values(i);
 
         if (val.is_map () || val.is_cell () || val.is_object ())
           err_wrong_type_arg (who, val);
       }
   }
 
+  // No copying!
+
+  printf_value_cache (const printf_value_cache&) = delete;
+
+  printf_value_cache& operator = (const printf_value_cache&) = delete;
+
   ~printf_value_cache (void) = default;
 
   // Get the current value as a double and advance the internal pointer.
   octave_value get_next_value (char type = 0);
 
   // Get the current value as an int and advance the internal pointer.
   int int_value (void);
 
@@ -5318,22 +5325,16 @@ private:
   int n_elts;
   bool have_data;
   octave_value curr_val;
   state curr_state;
 
   // Must create value cache with values!
 
   printf_value_cache (void);
-
-  // No copying!
-
-  printf_value_cache (const printf_value_cache&) = delete;
-
-  printf_value_cache& operator = (const printf_value_cache&) = delete;
 };
 
 octave_value
 printf_value_cache::get_next_value (char type)
 {
   octave_value retval;
 
   if (exhausted ())
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -64,16 +64,22 @@ public:
 
   octave_base_stream (std::ios::openmode arg_md = std::ios::in | std::ios::out,
                       octave::mach_info::float_format ff
                         = octave::mach_info::native_float_format ())
     : count (0), md (arg_md), flt_fmt (ff), fail (false), open_state (true),
       errmsg ()
   { }
 
+  // No copying!
+
+  octave_base_stream (const octave_base_stream&) = delete;
+
+  octave_base_stream& operator = (const octave_base_stream&) = delete;
+
   virtual ~octave_base_stream (void) = default;
 
   // The remaining functions are not specific to input or output only,
   // and must be provided by the derived classes.
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   virtual int seek (off_t offset, int origin) = 0;
@@ -224,22 +230,16 @@ private:
               const std::string& who /* = "printf" */);
 
   int puts (const std::string& s, const std::string& who /* = "puts" */);
 
   // We can always do this in terms of seek(), so the derived class
   // only has to provide that.
 
   void invalid_operation (const std::string& who, const char *rw);
-
-  // No copying!
-
-  octave_base_stream (const octave_base_stream&) = delete;
-
-  octave_base_stream& operator = (const octave_base_stream&) = delete;
 };
 
 class
 OCTINTERP_API
 octave_stream
 {
 public:
 
diff --git a/libinterp/corefcn/oct-strstrm.h b/libinterp/corefcn/oct-strstrm.h
--- a/libinterp/corefcn/oct-strstrm.h
+++ b/libinterp/corefcn/oct-strstrm.h
@@ -35,16 +35,28 @@ octave_base_strstream : public octave_ba
 {
 public:
 
   octave_base_strstream (std::ios::openmode m = std::ios::out,
                          octave::mach_info::float_format ff
                            = octave::mach_info::native_float_format ())
     : octave_base_stream (m, ff) { }
 
+  // No copying!
+
+  octave_base_strstream (const octave_base_strstream&) = delete;
+
+  octave_base_strstream& operator = (const octave_base_strstream&) = delete;
+
+protected:
+
+  ~octave_base_strstream (void) = default;
+
+public:
+
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t, int);
 
   // Return current stream position.
 
   virtual off_t tell (void);
 
@@ -52,28 +64,16 @@ public:
 
   std::string name (void) const { return ""; }
 
   virtual std::streambuf *rdbuf (void) = 0;
 
   virtual bool bad (void) const = 0;
 
   virtual void clear (void) = 0;
-
-protected:
-
-  ~octave_base_strstream (void) = default;
-
-private:
-
-  // No copying!
-
-  octave_base_strstream (const octave_base_strstream&) = delete;
-
-  octave_base_strstream& operator = (const octave_base_strstream&) = delete;
 };
 
 class
 octave_istrstream : public octave_base_strstream
 {
 public:
 
   octave_istrstream (const char *data,
@@ -83,16 +83,29 @@ public:
     : octave_base_strstream (arg_md, ff), is (data) { }
 
   octave_istrstream (const std::string& data,
                      std::ios::openmode arg_md = std::ios::out,
                      octave::mach_info::float_format ff
                        = octave::mach_info::native_float_format ())
     : octave_base_strstream (arg_md, ff), is (data.c_str ()) { }
 
+  // No copying!
+
+  octave_istrstream (const octave_istrstream&) = delete;
+
+  octave_istrstream& operator = (const octave_istrstream&) = delete;
+
+protected:
+
+  ~octave_istrstream (void) = default;
+
+public:
+
+
   static octave_stream
   create (const char *data, std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format ());
 
   static octave_stream
   create (const std::string& data, std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format ff
@@ -109,41 +122,43 @@ public:
   off_t tell (void) { return is.tellg (); }
 
   std::streambuf *rdbuf (void) { return is ? is.rdbuf () : 0; }
 
   bool bad (void) const { return is.bad (); }
 
   void clear (void) { is.clear (); }
 
-protected:
-
-  ~octave_istrstream (void) = default;
-
 private:
 
   std::istringstream is;
-
-  // No copying!
-
-  octave_istrstream (const octave_istrstream&) = delete;
-
-  octave_istrstream& operator = (const octave_istrstream&) = delete;
 };
 
 class
 octave_ostrstream : public octave_base_strstream
 {
 public:
 
   octave_ostrstream (std::ios::openmode arg_md = std::ios::out,
                      octave::mach_info::float_format ff
                        = octave::mach_info::native_float_format ())
     : octave_base_strstream (arg_md, ff), os () { }
 
+  // No copying!
+
+  octave_ostrstream (const octave_ostrstream&) = delete;
+
+  octave_ostrstream& operator = (const octave_ostrstream&) = delete;
+
+protected:
+
+  ~octave_ostrstream (void) = default;
+
+public:
+
   static octave_stream
   create (std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format ());
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return os.eof (); }
@@ -155,25 +170,15 @@ public:
   std::string str (void) { return os.str (); }
 
   std::streambuf *rdbuf (void) { return os ? os.rdbuf () : 0; }
 
   bool bad (void) const { return os.bad (); }
 
   void clear (void) { os.clear (); }
 
-protected:
-
-  ~octave_ostrstream (void) = default;
-
 private:
 
   std::ostringstream os;
-
-  // No copying!
-
-  octave_ostrstream (const octave_ostrstream&) = delete;
-
-  octave_ostrstream& operator = (const octave_ostrstream&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -48,16 +48,22 @@ OCTINTERP_API
 octave_link
 {
 protected:
 
   octave_link (void);
 
 public:
 
+  // No copying!
+
+  octave_link (const octave_link&) = delete;
+
+  octave_link& operator = (const octave_link&) = delete;
+
   virtual ~octave_link (void);
 
   static void generate_events (void)
   {
     if (enabled ())
       instance->do_generate_events ();
   }
 
@@ -349,22 +355,16 @@ public:
       return false;
 
   }
 
 private:
 
   static octave_link *instance;
 
-  // No copying!
-
-  octave_link (const octave_link&) = delete;
-
-  octave_link& operator = (const octave_link&) = delete;
-
   static bool instance_ok (void) { return instance != 0; }
 
 protected:
 
   // Semaphore to lock access to the event queue.
   octave_mutex *event_queue_mutex;
 
   // Event Queue.
diff --git a/libinterp/corefcn/pager.h b/libinterp/corefcn/pager.h
--- a/libinterp/corefcn/pager.h
+++ b/libinterp/corefcn/pager.h
@@ -57,16 +57,22 @@ OCTINTERP_API
 octave_pager_stream : public std::ostream
 {
 protected:
 
   octave_pager_stream (void);
 
 public:
 
+  // No copying!
+
+  octave_pager_stream (const octave_pager_stream&) = delete;
+
+  octave_pager_stream& operator = (const octave_pager_stream&) = delete;
+
   ~octave_pager_stream (void);
 
   static void flush_current_contents_to_diary (void);
 
   static void set_diary_skip (void);
 
   static std::ostream& stream (void);
 
@@ -82,22 +88,16 @@ private:
 
   static octave_pager_stream *instance;
 
   static bool instance_ok (void);
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   octave_pager_buf *pb;
-
-  // No copying!
-
-  octave_pager_stream (const octave_pager_stream&) = delete;
-
-  octave_pager_stream& operator = (const octave_pager_stream&) = delete;
 };
 
 class
 OCTINTERP_API
 octave_diary_buf : public std::stringbuf
 {
 public:
 
@@ -113,16 +113,22 @@ OCTINTERP_API
 octave_diary_stream : public std::ostream
 {
 protected:
 
   octave_diary_stream (void);
 
 public:
 
+  // No copying!
+
+  octave_diary_stream (const octave_diary_stream&) = delete;
+
+  octave_diary_stream& operator = (const octave_diary_stream&) = delete;
+
   ~octave_diary_stream (void);
 
   static std::ostream& stream (void);
 
   static void reset (void);
 
 private:
 
@@ -130,22 +136,16 @@ private:
 
   static octave_diary_stream *instance;
 
   static bool instance_ok (void);
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   octave_diary_buf *db;
-
-  // No copying!
-
-  octave_diary_stream (const octave_diary_stream&) = delete;
-
-  octave_diary_stream& operator = (const octave_diary_stream&) = delete;
 };
 
 #define octave_stdout (octave_pager_stream::stream ())
 
 #define octave_diary (octave_diary_stream::stream ())
 
 extern OCTINTERP_API void flush_octave_stdout (void);
 
diff --git a/libinterp/corefcn/profiler.h b/libinterp/corefcn/profiler.h
--- a/libinterp/corefcn/profiler.h
+++ b/libinterp/corefcn/profiler.h
@@ -66,32 +66,38 @@ public:
           //  the function name is not set for the recurring readline hook function.
           if (fcn == "")
             is_active = false;  // Inactive profiling block
           else
             acc.enter_function (fcn);
         }
     }
 
+    // No copying!
+
+    enter (const enter&) = delete;
+
+    enter& operator = (const enter&) = delete;
+
     ~enter ()
     {
       if (is_active)
         acc.exit_function (fcn);
     }
-
-  private:
-
-    // No copying!
-
-    enter (const enter&) = delete;
-
-    enter& operator = (const enter&) = delete;
   };
 
   profile_data_accumulator (void);
+
+  // No copying!
+
+  profile_data_accumulator (const profile_data_accumulator&) = delete;
+
+  profile_data_accumulator&
+  operator = (const profile_data_accumulator&) = delete;
+  
   virtual ~profile_data_accumulator ();
 
   bool is_active (void) const { return enabled; }
   void set_active (bool);
 
   void reset (void);
 
   octave_value get_flat (void) const;
@@ -125,16 +131,22 @@ private:
   // data we collect.
   class tree_node
   {
   public:
 
     tree_node (tree_node*, octave_idx_type);
     virtual ~tree_node ();
 
+    // No copying!
+
+    tree_node (const tree_node&) = delete;
+
+    tree_node& operator = (const tree_node&) = delete;
+
     void add_time (double dt) { time += dt; }
 
     // Enter a child function.  It is created in the list of children if it
     // wasn't already there.  The now-active child node is returned.
     tree_node* enter (octave_idx_type);
 
     // Exit function.  As a sanity-check, it is verified that the currently
     // active function actually is the one handed in here.  Returned is the
@@ -155,22 +167,16 @@ private:
 
     typedef std::map<octave_idx_type, tree_node*> child_map;
     child_map children;
 
     // This is only time spent *directly* on this level, excluding children!
     double time;
 
     unsigned calls;
-
-    // No copying!
-
-    tree_node (const tree_node&) = delete;
-
-    tree_node& operator = (const tree_node&) = delete;
   };
 
   // Each function we see in the profiler is given a unique index (which
   // simply counts starting from 1).  We thus have to map profiler-names to
   // those indices.  For all other stuff, we identify functions by their index.
 
   typedef std::vector<std::string> function_set;
   typedef std::map<std::string, octave_idx_type> fcn_index_map;
@@ -196,22 +202,16 @@ private:
   // in the profiler or something to choose between cputime, wall-time,
   // user-time, system-time, ...
   double query_time () const;
 
   // Add the time elapsed since last_time to the function we're currently in.
   // This is called from two different positions, thus it is useful to have
   // it as a seperate function.
   void add_current_time (void);
-
-  // No copying!
-
-  profile_data_accumulator (const profile_data_accumulator&) = delete;
-
-  profile_data_accumulator& operator = (const profile_data_accumulator&) = delete;
 };
 
 // The instance used.
 extern OCTINTERP_API profile_data_accumulator profiler;
 
 // Helper macro to profile a block of code.
 
 #define BEGIN_PROFILER_BLOCK(classname)                                 \
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -85,31 +85,29 @@ namespace octave
 
   class
   base_interrupt_manager
   {
   public:
 
     base_interrupt_manager (void) { }
 
+    // No copying!
+
+    base_interrupt_manager (const base_interrupt_manager&) = delete;
+
+    base_interrupt_manager& operator = (const base_interrupt_manager&) = delete;
+
     virtual ~base_interrupt_manager (void) = default;
 
     virtual void do_jump_to_enclosing_context (void) = 0;
 
     virtual void do_user_abort (const char *sig_name, int sig_number) = 0;
 
     virtual void do_raise_sigint (void) = 0;
-
-  private:
-
-    // No copying!
-
-    base_interrupt_manager (const base_interrupt_manager&) = delete;
-
-    base_interrupt_manager& operator = (const base_interrupt_manager&) = delete;
   };
 
 #if defined (OCTAVE_USE_WINDOWS_API)
 
   class
   w32_interrupt_manager : public base_interrupt_manager
   {
   public:
@@ -119,16 +117,22 @@ namespace octave
     {
       thread_id = GetCurrentThreadId ();
 
       DuplicateHandle (GetCurrentProcess (), GetCurrentThread (),
                        GetCurrentProcess (), &thread, 0, FALSE,
                        DUPLICATE_SAME_ACCESS);
     }
 
+    // No copying!
+
+    w32_interrupt_manager (const w32_interrupt_manager&) = delete;
+
+    w32_interrupt_manager& operator = (const w32_interrupt_manager&) = delete;
+
     ~w32_interrupt_manager (void) = default;
 
     static void jump_to_enclosing_context_sync (void)
     {
 #if defined (_MSC_VER)
       _fpreset ();
 #endif
       ::octave_jump_to_enclosing_context ();
@@ -191,61 +195,52 @@ namespace octave
 
   private:
 
     // A handle to the thread that is running the octave interpreter.
     HANDLE thread;
 
     // The ID of the thread that is running the octave interpreter.
     DWORD thread_id;
-
-  private:
-
-    // No copying!
-
-    w32_interrupt_manager (const w32_interrupt_manager&) = delete;
-
-    w32_interrupt_manager& operator = (const w32_interrupt_manager&) = delete;
   };
 
 #endif
 
   class
   posix_interrupt_manager : public base_interrupt_manager
   {
   public:
 
     posix_interrupt_manager (void)
       : base_interrupt_manager ()
     { }
 
+    // No copying!
+
+    posix_interrupt_manager (const posix_interrupt_manager&) = delete;
+
+    posix_interrupt_manager&
+    operator = (const posix_interrupt_manager&) = delete;
+
     ~posix_interrupt_manager (void) = default;
 
     void do_jump_to_enclosing_context (void)
     {
       ::octave_jump_to_enclosing_context ();
     }
 
     void do_user_abort (const char *sig_name, int sig_number)
     {
       octave::user_abort (sig_name, sig_number);
     }
 
     void do_raise_sigint (void)
     {
       octave_raise_wrapper (SIGINT);
     }
-
-  private:
-
-    // No copying!
-
-    posix_interrupt_manager (const posix_interrupt_manager&) = delete;
-
-    posix_interrupt_manager& operator = (const posix_interrupt_manager&) = delete;
   };
 
   class
   interrupt_manager
   {
   public:
 
     ~interrupt_manager (void) = default;
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -64,16 +64,22 @@ public:
 
     // We start with 2 because we allocate 0 for the global symbols
     // and 1 for the top-level workspace.
 
     scope_id_cache (void) : next_available (2), in_use (), free_list () { }
 
   public:
 
+    // No copying!
+
+    scope_id_cache (const scope_id_cache&) = delete;
+
+    scope_id_cache& operator = (const scope_id_cache&) = delete;
+
     ~scope_id_cache (void) = default;
 
     static scope_id alloc (void)
     {
       return instance_ok () ? instance->do_alloc () : -1;
     }
 
     static void free (scope_id scope)
@@ -99,22 +105,16 @@ public:
       if (! instance)
         error ("unable to create scope_id_cache object!");
 
       return retval;
     }
 
   private:
 
-    // No copying!
-
-    scope_id_cache (const scope_id_cache&) = delete;
-
-    scope_id_cache& operator = (const scope_id_cache&) = delete;
-
     static scope_id_cache *instance;
 
     static void cleanup_instance (void) { delete instance; instance = 0; }
 
     // The next available scope not in the free list.
     scope_id next_available;
 
     // The set of scope IDs that are currently allocated.
@@ -209,16 +209,22 @@ public:
       symbol_record_rep (scope_id s, const std::string& nm,
                          const octave_value& v, unsigned int sc)
         : decl_scope (s), curr_fcn (0), name (nm), value_stack (),
           storage_class (sc), finfo (), valid (true), count (1)
       {
         value_stack.push_back (v);
       }
 
+      // No copying!
+
+      symbol_record_rep (const symbol_record_rep& ov) = delete;
+
+      symbol_record_rep& operator = (const symbol_record_rep&) = delete;
+
       void assign (const octave_value& value,
                    context_id context = xdefault_context)
       {
         varref (context) = value;
       }
 
       void assign (octave_value::assign_op op,
                    const std::string& type,
@@ -467,24 +473,16 @@ public:
 
       unsigned int storage_class;
 
       fcn_info *finfo;
 
       bool valid;
 
       octave_refcount<size_t> count;
-
-    private:
-
-      // No copying!
-
-      symbol_record_rep (const symbol_record_rep& ov) = delete;
-
-      symbol_record_rep& operator = (const symbol_record_rep&) = delete;
     };
 
   public:
 
     symbol_record (scope_id s = xcurrent_scope,
                    const std::string& nm = "",
                    const octave_value& v = octave_value (),
                    unsigned int sc = local)
@@ -758,16 +756,22 @@ public:
 
         if (pos != std::string::npos)
           {
             package_name = name.substr (0, pos);
             name = name.substr (pos+1);
           }
       }
 
+      // No copying!
+
+      fcn_info_rep (const fcn_info_rep&) = delete;
+
+      fcn_info_rep& operator = (const fcn_info_rep&) = delete;
+
       octave_value load_private_function (const std::string& dir_name);
 
       octave_value load_class_constructor (void);
 
       octave_value load_class_method (const std::string& dispatch_type);
 
       octave_value find (const octave_value_list& args, bool local_funcs);
 
@@ -944,22 +948,16 @@ public:
 
       octave_refcount<size_t> count;
 
     private:
 
       octave_value xfind (const octave_value_list& args, bool local_funcs);
 
       octave_value x_builtin_find (void);
-
-      // No copying!
-
-      fcn_info_rep (const fcn_info_rep&) = delete;
-
-      fcn_info_rep& operator = (const fcn_info_rep&) = delete;
     };
 
   public:
 
     fcn_info (const std::string& nm = "")
       : rep (new fcn_info_rep (nm)) { }
 
     fcn_info (const fcn_info& fi) : rep (fi.rep)
@@ -2188,22 +2186,16 @@ public:
     assert (inst->curr_fcn == 0 || curr_fcn == 0);
     inst->curr_fcn = curr_fcn;
   }
 
   static void cleanup (void);
 
 private:
 
-  // No copying!
-
-  symbol_table (const symbol_table&) = delete;
-
-  symbol_table& operator = (const symbol_table&) = delete;
-
   typedef std::map<std::string, symbol_record>::const_iterator
     table_const_iterator;
   typedef std::map<std::string, symbol_record>::iterator
     table_iterator;
 
   typedef std::map<std::string, octave_value>::const_iterator
     global_table_const_iterator;
   typedef std::map<std::string, octave_value>::iterator
@@ -2288,16 +2280,22 @@ private:
 
   static const context_id xdefault_context = static_cast<context_id> (-1);
 
   symbol_table (scope_id scope)
     : my_scope (scope), table_name (), table (), nest_children (),
       nest_parent (0), curr_fcn (0), static_workspace (false),
       persistent_table () { }
 
+  // No copying!
+
+  symbol_table (const symbol_table&) = delete;
+
+  symbol_table& operator = (const symbol_table&) = delete;
+
   ~symbol_table (void) = default;
 
   static symbol_table *get_instance (scope_id scope, bool create = true)
   {
     symbol_table *retval = 0;
 
     bool ok = true;
 
diff --git a/libinterp/corefcn/text-renderer.h b/libinterp/corefcn/text-renderer.h
--- a/libinterp/corefcn/text-renderer.h
+++ b/libinterp/corefcn/text-renderer.h
@@ -42,16 +42,22 @@ namespace octave
   class
   OCTINTERP_API
   text_renderer
   {
   public:
 
     text_renderer (void);
 
+    // No copying!
+
+    text_renderer (const text_renderer&) = delete;
+
+    text_renderer& operator = (const text_renderer&) = delete;
+
     ~text_renderer (void);
 
     bool ok (void) const;
 
     Matrix get_extent (text_element *elt, double rotation = 0.0);
 
     Matrix get_extent (const std::string& txt, double rotation = 0.0,
                        const caseless_str& interpreter = "tex");
@@ -198,19 +204,13 @@ namespace octave
     void text_to_strlist (const std::string& txt,
                           std::list<string>& lst, Matrix& box,
                           int halign, int valign, double rotation = 0.0,
                           const caseless_str& interpreter = "tex");
 
   private:
 
     base_text_renderer *rep;
-
-    // No copying!
-
-    text_renderer (const text_renderer&) = delete;
-
-    text_renderer& operator = (const text_renderer&) = delete;
   };
 }
 
 #endif
 
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -50,19 +50,24 @@ along with Octave; see the file COPYING.
  *  the standard file streambuf.
 */
 class gzfilebuf : public std::streambuf
 {
 public:
   //  Default constructor.
   gzfilebuf ();
 
+  // No copying!
+
+  gzfilebuf (const gzfilebuf&) = delete;
+
+  gzfilebuf& operator = (const gzfilebuf&) = delete;
+
   //  Destructor.
-  virtual
-  ~gzfilebuf ();
+  virtual ~gzfilebuf ();
 
   /**
    *  @brief  Set compression level and strategy on the fly.
    *  @param  comp_level  Compression level (see zlib.h for allowed values)
    *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)
    *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.
    *
    *  Unfortunately, these parameters cannot be modified separately, as the
@@ -195,22 +200,16 @@ protected:
 //
 // Some future enhancements
 //
 //  virtual int_type uflow();
 //  virtual int_type pbackfail(int_type c = traits_type::eof());
 
 private:
 
-  // No copying!
-
-  gzfilebuf (const gzfilebuf&) = delete;
-
-  gzfilebuf& operator = (const gzfilebuf&) = delete;
-
   /**
    *  @brief  Allocate internal buffer.
    *
    *  This function is safe to call multiple times.  It will ensure
    *  that a proper internal buffer exists if it is required.  If the
    *  buffer already exists or is external, the buffer pointers will be
    *  reset to their original state.
   */
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -724,29 +724,29 @@ public:
       }
 
     if (type == "uimenu")
       delete_entry (dynamic_cast<uimenu::properties&> (prop));
     else if (type == "figure")
       menubar->clear ();
   }
 
+  // No copying!
+
+  fltk_uimenu (const fltk_uimenu&) = delete;
+
+  fltk_uimenu operator = (const fltk_uimenu&) = delete;
+
   ~fltk_uimenu (void)
   {
     delete menubar;
   }
 
 private:
 
-  // No copying!
-
-  fltk_uimenu (const fltk_uimenu&) = delete;
-
-  fltk_uimenu operator = (const fltk_uimenu&) = delete;
-
   Fl_Menu_Bar* menubar;
 };
 
 #if defined (HAVE_X_WINDOWS)
 static int
 xerror_handler (Display *, XErrorEvent *)
 {
   return 0;
@@ -850,16 +850,22 @@ public:
 
         if (fp.get_currentaxes ().ok ())
           show_canvas ();
         else
           hide_canvas ();
       }
   }
 
+  // No copying!
+
+  plot_window (const plot_window&) = delete;
+
+  plot_window& operator = (const plot_window&) = delete;
+
   ~plot_window (void)
   {
     this->hide ();
     Fl::check ();
   }
 
   double number (void) { return fp.get___myhandle__ ().value (); }
 
@@ -1029,22 +1035,16 @@ public:
   void set_name (void)
   {
     window_label = fp.get_title ();
     label (window_label.c_str ());
   }
 
 private:
 
-  // No copying!
-
-  plot_window (const plot_window&) = delete;
-
-  plot_window& operator = (const plot_window&) = delete;
-
   // window name -- this must exists for the duration of the window's
   // life
   std::string window_label;
 
   // Figure properties.
   figure::properties& fp;
 
   // Status area height.
@@ -1810,36 +1810,46 @@ private:
       }
     //std::cout << "plot_window::handle wasn't interested in event " <<  fl_eventnames[event] << std::endl;
     return Fl_Window::handle (event);
   }
 };
 
 class figure_manager
 {
+private:
+
+  figure_manager (void) = default;
+
 public:
 
+  // No copying!
+
+  figure_manager (const figure_manager&) = delete;
+
+  figure_manager& operator = (const figure_manager&) = delete;
+
+  ~figure_manager (void)
+  {
+    close_all ();
+  }
+
   static bool instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
       instance = new figure_manager ();
 
     if (! instance)
       error ("unable to create figure_manager object!");
 
     return retval;
   }
 
-  ~figure_manager (void)
-  {
-    close_all ();
-  }
-
   static void close_all (void)
   {
     if (instance_ok ())
       instance->do_close_all ();
   }
 
   static void new_window (figure::properties& fp)
   {
@@ -1943,29 +1953,24 @@ public:
       instance->do_toggle_menubar_visibility (str2idx (fig_idx_str),
                                               menubar_is_figure);
   }
 
 private:
 
   static figure_manager *instance;
 
-  figure_manager (void) { }
-
-  // No copying!
-
-  figure_manager (const figure_manager&) = delete;
-
-  figure_manager& operator = (const figure_manager&) = delete;
-
   // Singelton -- hide all of the above.
 
   static int curr_index;
+
   typedef std::map<int, plot_window*> window_map;
+
   typedef window_map::iterator wm_iterator;;
+
   window_map windows;
 
   static std::string fltk_idx_header;
 
   void do_close_all (void)
   {
     wm_iterator win;
     for (win = windows.begin (); win != windows.end (); win++)
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -49,16 +49,22 @@ public:
   octave_builtin (fcn ff, const std::string& nm = "",
                   const std::string& ds = "")
     : octave_function (nm, ds), f (ff), file (), jtype (0) { }
 
   octave_builtin (fcn ff, const std::string& nm, const std::string& fnm,
                   const std::string& ds)
     : octave_function (nm, ds), f (ff), file (fnm), jtype (0) { }
 
+  // No copying!
+
+  octave_builtin (const octave_builtin& ob) = delete;
+
+  octave_builtin& operator = (const octave_builtin& ob) = delete;
+
   ~octave_builtin (void) = default;
 
   std::string src_file_name (void) const { return file; }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   {
     octave_value_list tmp = subsref (type, idx, 1);
@@ -101,19 +107,13 @@ protected:
   // The name of the file where this function was defined.
   std::string file;
 
   // A pointer to the jit type that represents the function.
   jit_type *jtype;
 
 private:
 
-  // No copying!
-
-  octave_builtin (const octave_builtin& ob) = delete;
-
-  octave_builtin& operator = (const octave_builtin& ob) = delete;
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/libinterp/octave-value/ov-dld-fcn.h b/libinterp/octave-value/ov-dld-fcn.h
--- a/libinterp/octave-value/ov-dld-fcn.h
+++ b/libinterp/octave-value/ov-dld-fcn.h
@@ -47,16 +47,22 @@ public:
   octave_dld_function (void)
     : sh_lib (), t_checked (), system_fcn_file ()
   { }
 
   octave_dld_function (octave_builtin::fcn ff, const octave::dynamic_library& shl,
                        const std::string& nm = "",
                        const std::string& ds = "");
 
+  // No copying!
+
+  octave_dld_function (const octave_dld_function& fn) = delete;
+
+  octave_dld_function& operator = (const octave_dld_function& fn) = delete;
+
   ~octave_dld_function (void);
 
   void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   std::string fcn_file_name (void) const;
 
   octave::sys::time time_parsed (void) const;
 
@@ -84,19 +90,13 @@ private:
   // parsed again.
   mutable octave::sys::time t_checked;
 
   // True if this function came from a file that is considered to be a
   // system function.  This affects whether we check the time stamp
   // on the file to see if it has changed.
   bool system_fcn_file;
 
-  // No copying!
-
-  octave_dld_function (const octave_dld_function& fn) = delete;
-
-  octave_dld_function& operator = (const octave_dld_function& fn) = delete;
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -45,16 +45,22 @@ octave_function : public octave_base_val
 {
 public:
 
   octave_function (void)
     : relative (false), locked (false), private_function (false),
       xdispatch_class (), xpackage_name (), my_name (), my_dir_name (),
       doc () { }
 
+  // No copying!
+
+  octave_function (const octave_function& f) = delete;
+
+  octave_function& operator = (const octave_function& f) = delete;
+
   ~octave_function (void) = default;
 
   octave_base_value *clone (void) const;
   octave_base_value *empty_clone (void) const;
 
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
@@ -210,21 +216,12 @@ protected:
   std::string my_name;
 
   // The name of the directory in the path where we found this
   // function.  May be relative.
   std::string my_dir_name;
 
   // The help text for this function.
   std::string doc;
-
-private:
-
-  // No copying!
-
-  octave_function (const octave_function& f) = delete;
-
-  octave_function& operator = (const octave_function& f) = delete;
-
 };
 
 #endif
 
diff --git a/libinterp/octave-value/ov-mex-fcn.h b/libinterp/octave-value/ov-mex-fcn.h
--- a/libinterp/octave-value/ov-mex-fcn.h
+++ b/libinterp/octave-value/ov-mex-fcn.h
@@ -45,16 +45,22 @@ public:
 
   octave_mex_function (void)
     : mex_fcn_ptr (), exit_fcn_ptr (), have_fmex (), sh_lib (),
       t_checked (), system_fcn_file () { }
 
   octave_mex_function (void *fptr, bool fmex, const octave::dynamic_library& shl,
                        const std::string& nm = "");
 
+  // No copying!
+
+  octave_mex_function (const octave_mex_function& fn) = delete;
+
+  octave_mex_function& operator = (const octave_mex_function& fn) = delete;
+
   ~octave_mex_function (void);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   {
     octave_value_list tmp = subsref (type, idx, 1);
     return tmp.length () > 0 ? tmp(0) : octave_value ();
   }
@@ -103,19 +109,13 @@ private:
   // parsed again.
   mutable octave::sys::time t_checked;
 
   // True if this function came from a file that is considered to be a
   // system function.  This affects whether we check the time stamp
   // on the file to see if it has changed.
   bool system_fcn_file;
 
-  // No copying!
-
-  octave_mex_function (const octave_mex_function& fn) = delete;
-
-  octave_mex_function& operator = (const octave_mex_function& fn) = delete;
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/libinterp/octave-value/ov-typeinfo.h b/libinterp/octave-value/ov-typeinfo.h
--- a/libinterp/octave-value/ov-typeinfo.h
+++ b/libinterp/octave-value/ov-typeinfo.h
@@ -201,16 +201,22 @@ protected:
       compound_binary_class_ops (dim_vector (octave_value::num_compound_binary_ops, 1), 0),
       compound_binary_ops (dim_vector (octave_value::num_compound_binary_ops, init_tab_sz, init_tab_sz), 0),
       cat_ops (dim_vector (init_tab_sz, init_tab_sz), 0),
       assign_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz, init_tab_sz), 0),
       assignany_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz), 0),
       pref_assign_conv (dim_vector (init_tab_sz, init_tab_sz), -1),
       widening_ops (dim_vector (init_tab_sz, init_tab_sz), 0)  { }
 
+  // No copying!
+
+  octave_value_typeinfo (const octave_value_typeinfo&) = delete;
+
+  octave_value_typeinfo& operator = (const octave_value_typeinfo&) = delete;
+
   ~octave_value_typeinfo (void) = default;
 
 private:
 
   static const int init_tab_sz;
 
   static octave_value_typeinfo *instance;
 
@@ -313,18 +319,12 @@ private:
   octave_scalar_map do_installed_type_info (void) const;
 
   octave_scalar_map unary_ops_map (void) const;
   octave_scalar_map non_const_unary_ops_map (void) const;
   octave_scalar_map binary_ops_map (void) const;
   octave_scalar_map compound_binary_ops_map (void) const;
   octave_scalar_map assign_ops_map (void) const;
   octave_scalar_map assignany_ops_map (void) const;
-
-  // No copying!
-
-  octave_value_typeinfo (const octave_value_typeinfo&) = delete;
-
-  octave_value_typeinfo& operator = (const octave_value_typeinfo&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -48,41 +48,40 @@ class tree_walker;
 
 #if defined (HAVE_LLVM)
 class jit_function_info;
 #endif
 
 class
 octave_user_code : public octave_function
 {
+protected:
+
+  octave_user_code (const std::string& nm,
+                    const std::string& ds = "")
+    : octave_function (nm, ds) { }
+
 public:
+
   octave_user_code (void)
     : octave_function () { }
 
+  // No copying!
+
+  octave_user_code (const octave_user_code& f) = delete;
+
+  octave_user_code& operator = (const octave_user_code& f) = delete;
+
   ~octave_user_code (void) = default;
 
   bool is_user_code (void) const { return true; }
 
   virtual std::map<std::string, octave_value> subfunctions (void) const;
 
   virtual tree_statement_list *body (void) = 0;
-
-protected:
-
-  octave_user_code (const std::string& nm,
-                    const std::string& ds = "")
-    : octave_function (nm, ds) { }
-
-private:
-
-  // No copying!
-
-  octave_user_code (const octave_user_code& f) = delete;
-
-  octave_user_code& operator = (const octave_user_code& f) = delete;
 };
 
 // Scripts.
 
 class
 octave_user_script : public octave_user_code
 {
 public:
@@ -91,16 +90,22 @@ public:
 
   octave_user_script (const std::string& fnm, const std::string& nm,
                       tree_statement_list *cmds,
                       const std::string& ds = "");
 
   octave_user_script (const std::string& fnm, const std::string& nm,
                       const std::string& ds = "");
 
+  // No copying!
+
+  octave_user_script (const octave_user_script& f) = delete;
+
+  octave_user_script& operator = (const octave_user_script& f) = delete;
+
   ~octave_user_script (void);
 
   octave_function *function_value (bool = false) { return this; }
 
   octave_user_script *user_script_value (bool = false) { return this; }
 
   octave_user_code *user_code_value (bool = false) { return this; }
 
@@ -156,37 +161,37 @@ private:
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
   octave::sys::time t_checked;
 
   // Used to keep track of recursion depth.
   int call_depth;
 
-  // No copying!
-
-  octave_user_script (const octave_user_script& f) = delete;
-
-  octave_user_script& operator = (const octave_user_script& f) = delete;
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 // User-defined functions.
 
 class
 octave_user_function : public octave_user_code
 {
 public:
 
   octave_user_function (symbol_table::scope_id sid = -1,
                         tree_parameter_list *pl = 0,
                         tree_parameter_list *rl = 0,
                         tree_statement_list *cl = 0);
 
+  // No copying!
+
+  octave_user_function (const octave_user_function& fn) = delete;
+
+  octave_user_function& operator = (const octave_user_function& fn) = delete;
+
   ~octave_user_function (void);
 
   symbol_table::context_id active_context () const
   {
     return is_anonymous_function ()
            ? 0 : static_cast<symbol_table::context_id>(call_depth);
   }
 
@@ -510,19 +515,13 @@ private:
   void print_code_function_trailer (void);
 
   void bind_automatic_vars (const string_vector& arg_names, int nargin,
                             int nargout, const octave_value_list& va_args,
                             const std::list<octave_lvalue> *lvalue_list);
 
   void restore_warning_states (void);
 
-  // No copying!
-
-  octave_user_function (const octave_user_function& fn) = delete;
-
-  octave_user_function& operator = (const octave_user_function& fn) = delete;
-
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/libinterp/octave.h b/libinterp/octave.h
--- a/libinterp/octave.h
+++ b/libinterp/octave.h
@@ -183,16 +183,22 @@ namespace octave
   class OCTINTERP_API application
   {
   public:
 
     application (const cmdline_options& opts = cmdline_options ());
 
     application (int argc, char **argv);
 
+    // No copying, at least not yet...
+
+    application (const application&) = delete;
+
+    application& operator = (const application&) = delete;
+
     virtual ~application (void);
 
     void set_program_names (const std::string& pname);
 
     void intern_argv (const string_vector& args);
 
     cmdline_options options (void) const { return m_options; }
 
@@ -232,22 +238,16 @@ namespace octave
 
     // Convenience functions.
 
     static bool forced_interactive (void);
     static bool interactive (void);
 
   private:
 
-    // No copying, at least not yet...
-
-    application (const application&) = delete;
-
-    application& operator = (const application&) = delete;
-
     // The application instance;  There should be only one.
     static application *instance;
 
     void init (void);
 
   protected:
 
     // The name used to invoke Octave.
@@ -286,54 +286,50 @@ namespace octave
     cli_application (const cmdline_options& opts = cmdline_options ())
       : application (opts)
     { }
 
     cli_application (int argc, char **argv)
       : application (argc, argv)
     { }
 
-    ~cli_application (void) = default;
-
-    int execute (void);
-
-  private:
-
     // No copying, at least not yet...
 
     cli_application (const cli_application&) = delete;
 
     cli_application& operator = (const cli_application&) = delete;
+
+    ~cli_application (void) = default;
+
+    int execute (void);
   };
 
   class OCTINTERP_API embedded_application : public application
   {
   public:
 
     embedded_application (const cmdline_options& opts = cmdline_options ())
       : application (opts)
     { }
 
     embedded_application (int argc, char **argv)
       : application (argc, argv)
     { }
 
+    // No copying, at least not yet...
+
+    embedded_application (const embedded_application&) = delete;
+
+    embedded_application& operator = (const embedded_application&) = delete;
+
     ~embedded_application (void) = default;
 
     void create_interpreter (void);
 
     int execute (void);
-
-  private:
-
-    // No copying, at least not yet...
-
-    embedded_application (const embedded_application&) = delete;
-
-    embedded_application& operator = (const embedded_application&) = delete;
   };
 }
 
 #endif
 
 #if defined  (__cplusplus)
 extern "C" {
 #endif
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -190,16 +190,22 @@ namespace octave
       // directly is that we can ensure that memory is cleaned up
       // properly.  It's more tedious to do that with deque since the
       // deque destructor and clear method don't call delete on the
       // elements that it stores.  Another reason is that it makes it
       // easier to change the implementation later if needed.
 
       token_cache (void) : buffer () { }
 
+      // No copying!
+
+      token_cache (const token_cache&) = delete;
+
+      token_cache& operator = (const token_cache&) = delete;
+
       ~token_cache (void) { clear (); }
 
       void push (token *tok)
       {
         buffer.push_front (tok);
       }
 
       void pop (void)
@@ -252,22 +258,16 @@ namespace octave
       {
         while (! empty ())
           pop ();
       }
 
     private:
 
       std::deque<token *> buffer;
-
-      // No copying!
-
-      token_cache (const token_cache&) = delete;
-
-      token_cache& operator = (const token_cache&) = delete;
     };
 
     lexical_feedback (void)
       : end_of_input (false), at_beginning_of_statement (true),
         looking_at_anon_fcn_args (false), looking_at_return_list (false),
         looking_at_parameter_list (false), looking_at_decl_list (false),
         looking_at_initializer_expression (false),
         looking_at_matrix_or_assign_lhs (false),
@@ -287,16 +287,22 @@ namespace octave
         help_text (), string_text (), string_line (0), string_column (0),
         fcn_file_name (), fcn_file_full_name (), looking_at_object_index (),
         parsed_function_name (), pending_local_variables (),
         symtab_context (), nesting_level (), tokens ()
     {
       init ();
     }
 
+    // No copying!
+
+    lexical_feedback (const lexical_feedback&) = delete;
+
+    lexical_feedback& operator = (const lexical_feedback&) = delete;
+
     ~lexical_feedback (void);
 
     void init (void);
 
     void reset (void);
 
     int previous_token_value (void) const;
 
@@ -454,24 +460,16 @@ namespace octave
     symbol_table_context symtab_context;
 
     // is the closest nesting level a square bracket, squiggly brace,
     // a paren, or an anonymous function body?
     bbp_nesting_level nesting_level;
 
     // Tokens generated by the lexer.
     token_cache tokens;
-
-  private:
-
-    // No copying!
-
-    lexical_feedback (const lexical_feedback&) = delete;
-
-    lexical_feedback& operator = (const lexical_feedback&) = delete;
   };
 
   // base_lexer inherits from lexical_feedback because we will
   // eventually have several different constructors and it is easier to
   // intialize if everything is grouped in a parent class rather than
   // listing all the members in the base_lexer class.
 
   class
@@ -550,16 +548,22 @@ namespace octave
 
     base_lexer (interpreter *interp_context = 0)
       : lexical_feedback (), scanner (0), input_buf (), comment_buf (),
         m_interp_context (interp_context)
     {
       init ();
     }
 
+    // No copying!
+
+    base_lexer (const base_lexer&) = delete;
+
+    base_lexer& operator = (const base_lexer&) = delete;
+
     virtual ~base_lexer (void);
 
     void init (void);
 
     virtual bool is_push_lexer (void) const { return false; }
 
     virtual void reset (void);
 
@@ -704,22 +708,16 @@ namespace octave
 
     int show_token (int tok);
 
     void enable_fq_identifier (void);
 
   protected:
 
     std::stack<int> start_state_stack;
-
-    // No copying!
-
-    base_lexer (const base_lexer&) = delete;
-
-    base_lexer& operator = (const base_lexer&) = delete;
   };
 
   class
   lexer : public base_lexer
   {
   public:
 
     lexer (interpreter *interp_context = 0)
@@ -730,16 +728,22 @@ namespace octave
       : base_lexer (interp_context), input_reader (file, this)
     { }
 
     lexer (const std::string& eval_string,
            interpreter *interp_context = 0)
       : base_lexer (interp_context), input_reader (eval_string, this)
     { }
 
+    // No copying!
+
+    lexer (const lexer&) = delete;
+
+    lexer& operator = (const lexer&) = delete;
+
     void reset (void)
     {
       input_reader.reset ();
 
       base_lexer::reset ();
     }
 
     void increment_promptflag (void) { input_reader.increment_promptflag (); }
@@ -768,24 +772,16 @@ namespace octave
     bool input_from_eval_string (void) const
     {
       return input_reader.input_from_eval_string ();
     }
 
     int fill_flex_buffer (char *buf, unsigned int max_size);
 
     octave_input_reader input_reader;
-
-  protected:
-
-    // No copying!
-
-    lexer (const lexer&) = delete;
-
-    lexer& operator = (const lexer&) = delete;
   };
 
   class
   push_lexer : public base_lexer
   {
   public:
 
     push_lexer (interpreter *interp_context = 0)
@@ -809,16 +805,22 @@ namespace octave
 
     push_lexer (const std::string& input, bool eof,
                 interpreter *interp_context = 0)
       : base_lexer (interp_context), pflag (1)
     {
       append_input (input, eof);
     }
 
+    // No copying!
+
+    push_lexer (const push_lexer&) = delete;
+
+    push_lexer& operator = (const push_lexer&) = delete;
+
     bool is_push_lexer (void) const { return true; }
 
     void reset (void)
     {
       promptflag (1);
 
       base_lexer::reset ();
     }
@@ -843,19 +845,13 @@ namespace octave
 
     std::string input_source (void) const { return "push buffer"; }
 
     int fill_flex_buffer (char *buf, unsigned int max_size);
 
   protected:
 
     int pflag;
-
-    // No copying!
-
-    push_lexer (const push_lexer&) = delete;
-
-    push_lexer& operator = (const push_lexer&) = delete;
   };
 }
 
 #endif
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -146,16 +146,22 @@ namespace octave
 
   class
   base_parser
   {
   public:
 
     base_parser (base_lexer& lxr);
 
+    // No copying!
+
+    base_parser (const base_parser&) = delete;
+
+    base_parser& operator = (const base_parser&) = delete;
+
     ~base_parser (void);
 
     void reset (void);
 
     // Error mesages for mismatched end tokens.
     void end_token_error (token *tok, token::end_tok_type expected);
 
     // Check to see that end tokens are properly matched.
@@ -455,24 +461,16 @@ namespace octave
     // Result of parsing input.
     tree_statement_list *stmt_list;
 
     // State of the lexer.
     base_lexer& lexer;
 
     // Internal state of the Bison parser.
     void *parser_state;
-
-  private:
-
-    // No copying!
-
-    base_parser (const base_parser&) = delete;
-
-    base_parser& operator = (const base_parser&) = delete;
   };
 
   class
   parser : public base_parser
   {
   public:
 
     parser (void)
@@ -486,46 +484,42 @@ namespace octave
     parser (const std::string& eval_string)
       : base_parser (*(new octave::lexer (eval_string)))
     { }
 
     parser (octave::lexer& lxr)
       : base_parser (lxr)
     { }
 
-    ~parser (void) = default;
-
-    int run (void);
-
-  private:
-
     // No copying!
 
     parser (const parser&) = delete;
 
     parser& operator = (const parser&) = delete;
+
+    ~parser (void) = default;
+
+    int run (void);
   };
 
   class
   push_parser : public base_parser
   {
   public:
 
     push_parser (void)
       : base_parser (*(new octave::push_lexer ()))
     { }
 
-    ~push_parser (void) = default;
-
-    int run (const std::string& input, bool eof);
-
-  private:
-
     // No copying!
 
     push_parser (const push_parser&) = delete;
 
     push_parser& operator = (const push_parser&) = delete;
+
+    ~push_parser (void) = default;
+
+    int run (const std::string& input, bool eof);
   };
 }
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -51,16 +51,22 @@ public:
     : list_includes_magic_end (false), list_includes_magic_tilde (false),
       simple_assign_lhs (false) { }
 
   tree_argument_list (tree_expression *t)
     : list_includes_magic_end (false), list_includes_magic_tilde (false),
       simple_assign_lhs (false)
   { append (t); }
 
+  // No copying!
+
+  tree_argument_list (const tree_argument_list&) = delete;
+
+  tree_argument_list& operator = (const tree_argument_list&) = delete;
+
   ~tree_argument_list (void);
 
   bool has_magic_end (void) const;
 
   bool has_magic_tilde (void) const
   { return list_includes_magic_tilde; }
 
   tree_expression *remove_front (void)
@@ -96,18 +102,12 @@ public:
 
 private:
 
   bool list_includes_magic_end;
 
   bool list_includes_magic_tilde;
 
   bool simple_assign_lhs;
-
-  // No copying!
-
-  tree_argument_list (const tree_argument_list&) = delete;
-
-  tree_argument_list& operator = (const tree_argument_list&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -43,16 +43,22 @@ public:
 
   tree_array_list (tree_argument_list *row = 0, int l = -1, int c = -1)
     : tree_expression (l, c), octave::base_list<tree_argument_list *> ()
   {
     if (row)
       append (row);
   }
 
+  // No copying!
+
+  tree_array_list (const tree_array_list&) = delete;
+
+  tree_array_list& operator = (const tree_array_list&) = delete;
+
   ~tree_array_list (void);
 
   bool all_elements_are_constant (void) const;
 
   bool has_magic_end (void) const;
 
   // FIXME: should we import the functions from the base class and
   // overload them here, or should we use a different name so we don't
@@ -66,20 +72,12 @@ public:
   void copy_base (const tree_array_list& array_list,
                   symbol_table::scope_id scope,
                   symbol_table::context_id context);
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
-
-private:
-
-  // No copying!
-
-  tree_array_list (const tree_array_list&) = delete;
-
-  tree_array_list& operator = (const tree_array_list&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -50,16 +50,22 @@ public:
                           octave_value::assign_op t = octave_value::op_asn_eq)
     : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs), ans_ass (),
       etype (t) { }
 
   tree_simple_assignment (tree_expression *le, tree_expression *re,
                           bool plhs = false, int l = -1, int c = -1,
                           octave_value::assign_op t = octave_value::op_asn_eq);
 
+  // No copying!
+
+  tree_simple_assignment (const tree_simple_assignment&) = delete;
+
+  tree_simple_assignment& operator = (const tree_simple_assignment&) = delete;
+
   ~tree_simple_assignment (void);
 
   bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
@@ -96,37 +102,37 @@ private:
   // True if we should not delete the lhs.
   bool preserve;
 
   // True if this is an assignment to the automatic variable ans.
   bool ans_ass;
 
   // The type of the expression.
   octave_value::assign_op etype;
-
-  // No copying!
-
-  tree_simple_assignment (const tree_simple_assignment&) = delete;
-
-  tree_simple_assignment& operator = (const tree_simple_assignment&) = delete;
 };
 
 // Multi-valued assignment expressions.
 
 class
 tree_multi_assignment : public tree_expression
 {
 public:
 
   tree_multi_assignment (bool plhs = false, int l = -1, int c = -1)
     : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs) { }
 
   tree_multi_assignment (tree_argument_list *lst, tree_expression *r,
                          bool plhs = false, int l = -1, int c = -1);
 
+  // No copying!
+
+  tree_multi_assignment (const tree_multi_assignment&) = delete;
+
+  tree_multi_assignment& operator = (const tree_multi_assignment&) = delete;
+
   ~tree_multi_assignment (void);
 
   bool has_magic_end (void) const { return (rhs && rhs->has_magic_end ()); }
 
   bool is_assignment_expression (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
 
@@ -153,18 +159,12 @@ private:
   // The left hand side of the assignment.
   tree_argument_list *lhs;
 
   // The right hand side of the assignment.
   tree_expression *rhs;
 
   // True if we should not delete the lhs.
   bool preserve;
-
-  // No copying!
-
-  tree_multi_assignment (const tree_multi_assignment&) = delete;
-
-  tree_multi_assignment& operator = (const tree_multi_assignment&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -54,16 +54,22 @@ public:
   tree_binary_expression (tree_expression *a, tree_expression *b,
                           int l = -1, int c = -1,
                           octave_value::binary_op t
                             = octave_value::unknown_binary_op)
     : tree_expression (l, c), op_lhs (a), op_rhs (b), etype (t),
       eligible_for_braindead_shortcircuit (false),
       braindead_shortcircuit_warning_issued (false) { }
 
+  // No copying!
+
+  tree_binary_expression (const tree_binary_expression&) = delete;
+
+  tree_binary_expression& operator = (const tree_binary_expression&) = delete;
+
   ~tree_binary_expression (void)
   {
     delete op_lhs;
     delete op_rhs;
   }
 
   void mark_braindead_shortcircuit (void)
   {
@@ -119,22 +125,16 @@ private:
   // or WHILE statement.
   bool eligible_for_braindead_shortcircuit;
 
   // TRUE if we have already issued a warning about short circuiting
   // for this operator.
   bool braindead_shortcircuit_warning_issued;
 
   void matlab_style_short_circuit_warning (const char *op);
-
-  // No copying!
-
-  tree_binary_expression (const tree_binary_expression&) = delete;
-
-  tree_binary_expression& operator = (const tree_binary_expression&) = delete;
 };
 
 // Boolean expressions.
 
 class
 tree_boolean_expression : public tree_binary_expression
 {
 public:
@@ -148,16 +148,22 @@ public:
 
   tree_boolean_expression (int l = -1, int c = -1, type t = unknown)
     : tree_binary_expression (l, c), etype (t) { }
 
   tree_boolean_expression (tree_expression *a, tree_expression *b,
                            int l = -1, int c = -1, type t = unknown)
     : tree_binary_expression (a, b, l, c), etype (t) { }
 
+  // No copying!
+
+  tree_boolean_expression (const tree_boolean_expression&) = delete;
+
+  tree_boolean_expression& operator = (const tree_boolean_expression&) = delete;
+
   ~tree_boolean_expression (void) = default;
 
   bool is_boolean_expression (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
@@ -169,18 +175,12 @@ public:
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
 private:
 
   // The type of the expression.
   type etype;
-
-  // No copying!
-
-  tree_boolean_expression (const tree_boolean_expression&) = delete;
-
-  tree_boolean_expression& operator = (const tree_boolean_expression&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-bp.h b/libinterp/parse-tree/pt-bp.h
--- a/libinterp/parse-tree/pt-bp.h
+++ b/libinterp/parse-tree/pt-bp.h
@@ -40,16 +40,22 @@ tree_breakpoint : public tree_walker
 {
 public:
 
   enum action { set = 1, clear = 2, list = 3 };
 
   tree_breakpoint (int l, action a, const std::string& c = pt_bp_empty_string)
     : line (l), act (a), condition (c), found (false), bp_list () { }
 
+  // No copying!
+
+  tree_breakpoint (const tree_breakpoint&) = delete;
+
+  tree_breakpoint& operator = (const tree_breakpoint&) = delete;
+
   ~tree_breakpoint (void) = default;
 
   bool success (void) const { return found; }
 
   void visit_argument_list (tree_argument_list&);
 
   void visit_binary_expression (tree_binary_expression&);
 
@@ -162,22 +168,16 @@ private:
   // Have we already found the line?
   bool found;
 
   // List of breakpoint line numbers.
   octave_value_list bp_list;
 
   // List of breakpoint conditions.
   octave_value_list bp_cond_list;
-
-  // No copying!
-
-  tree_breakpoint (const tree_breakpoint&) = delete;
-
-  tree_breakpoint& operator = (const tree_breakpoint&) = delete;
 };
 
 // TRUE means SIGINT should put us in the debugger at the next
 // available breakpoint.
 extern bool octave_debug_on_interrupt_state;
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-cell.h b/libinterp/parse-tree/pt-cell.h
--- a/libinterp/parse-tree/pt-cell.h
+++ b/libinterp/parse-tree/pt-cell.h
@@ -42,34 +42,32 @@ class
 tree_cell : public tree_array_list
 {
 public:
 
   tree_cell (tree_argument_list *row = 0, int l = -1, int c = -1)
     : tree_array_list (row, l, c)
   { }
 
+  // No copying!
+
+  tree_cell (const tree_cell&) = delete;
+
+  tree_cell& operator = (const tree_cell&) = delete;
+
   ~tree_cell (void) = default;
 
   bool is_cell (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int);
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
-
-private:
-
-  // No copying!
-
-  tree_cell (const tree_cell&) = delete;
-
-  tree_cell& operator = (const tree_cell&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-check.h b/libinterp/parse-tree/pt-check.h
--- a/libinterp/parse-tree/pt-check.h
+++ b/libinterp/parse-tree/pt-check.h
@@ -34,16 +34,22 @@ class tree_decl_command;
 class
 tree_checker : public tree_walker
 {
 public:
 
   tree_checker (void)
     : do_lvalue_check (false), file_name () { }
 
+  // No copying!
+
+  tree_checker (const tree_checker&) = delete;
+
+  tree_checker& operator = (const tree_checker&) = delete;
+
   ~tree_checker (void) = default;
 
   void visit_argument_list (tree_argument_list&);
 
   void visit_binary_expression (tree_binary_expression&);
 
   void visit_break_command (tree_break_command&);
 
@@ -129,18 +135,12 @@ private:
 
   bool do_lvalue_check;
 
   std::string file_name;
 
   void do_decl_command (tree_decl_command&);
 
   OCTAVE_NORETURN void errmsg (const std::string& msg, int line);
-
-  // No copying!
-
-  tree_checker (const tree_checker&) = delete;
-
-  tree_checker& operator = (const tree_checker&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -42,16 +42,22 @@ class tree_classdef_attribute
 public:
 
   tree_classdef_attribute (tree_identifier *i = 0, tree_expression *e = 0)
     : id (i), expr (e), neg (false) { }
 
   tree_classdef_attribute (tree_identifier *i, bool b)
     : id (i), expr (0), neg (b) { }
 
+  // No copying!
+
+  tree_classdef_attribute (const tree_classdef_attribute&) = delete;
+
+  tree_classdef_attribute& operator = (const tree_classdef_attribute&) = delete;
+
   ~tree_classdef_attribute (void)
   {
     delete id;
     delete expr;
   }
 
   tree_identifier *ident (void) { return id; }
 
@@ -61,109 +67,108 @@ public:
 
   void accept (tree_walker&);
 
 private:
 
   tree_identifier *id;
   tree_expression *expr;
   bool neg;
-
-  // No copying!
-
-  tree_classdef_attribute (const tree_classdef_attribute&) = delete;
-
-  tree_classdef_attribute& operator = (const tree_classdef_attribute&) = delete;
 };
 
 class tree_classdef_attribute_list : public octave::base_list<tree_classdef_attribute *>
 {
 public:
 
   tree_classdef_attribute_list (void) { }
 
   tree_classdef_attribute_list (tree_classdef_attribute *a) { append (a); }
 
   tree_classdef_attribute_list (const octave::base_list<tree_classdef_attribute *>& a)
     : octave::base_list<tree_classdef_attribute *> (a) { }
 
-  ~tree_classdef_attribute_list (void);
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_attribute_list (const tree_classdef_attribute_list&) = delete;
 
-  tree_classdef_attribute_list& operator = (const tree_classdef_attribute_list&) = delete;
+  tree_classdef_attribute_list&
+  operator = (const tree_classdef_attribute_list&) = delete;
+
+  ~tree_classdef_attribute_list (void);
+
+  void accept (tree_walker&);
 };
 
 class tree_classdef_superclass
 {
 public:
 
   tree_classdef_superclass (const std::string& cname)
     : cls_name (cname) { }
 
+  // No copying!
+
+  tree_classdef_superclass (const tree_classdef_superclass&) = delete;
+
+  tree_classdef_superclass&
+  operator = (const tree_classdef_superclass&) = delete;
+
   ~tree_classdef_superclass (void) = default;
 
   std::string class_name (void) { return cls_name; }
 
   void accept (tree_walker&);
 
 private:
 
   std::string cls_name;
-
-  // No copying!
-
-  tree_classdef_superclass (const tree_classdef_superclass&) = delete;
-
-  tree_classdef_superclass& operator = (const tree_classdef_superclass&) = delete;
 };
 
 class tree_classdef_superclass_list : public octave::base_list<tree_classdef_superclass *>
 {
 public:
 
   tree_classdef_superclass_list (void) { }
 
   tree_classdef_superclass_list (tree_classdef_superclass *sc) { append (sc); }
 
   tree_classdef_superclass_list (const octave::base_list<tree_classdef_superclass *>& a)
     : octave::base_list<tree_classdef_superclass *> (a) { }
 
-  ~tree_classdef_superclass_list (void);
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_superclass_list (const tree_classdef_superclass_list&) = delete;
 
-  tree_classdef_superclass_list& operator = (const tree_classdef_superclass_list&) = delete;
+  tree_classdef_superclass_list&
+  operator = (const tree_classdef_superclass_list&) = delete;
+
+  ~tree_classdef_superclass_list (void);
+
+  void accept (tree_walker&);
 };
 
 template <typename T>
 class tree_classdef_element : public tree
 {
 public:
 
   tree_classdef_element (tree_classdef_attribute_list *a,
                          octave::base_list<T> *elist,
                          octave_comment_list *lc, octave_comment_list *tc,
                          int l = -1, int c = -1)
     : tree (l, c), attr_list (a), elt_list (elist),
       lead_comm (lc), trail_comm (tc)
   { }
 
+  // No copying!
+
+  tree_classdef_element (const tree_classdef_element&) = delete;
+
+  tree_classdef_element& operator = (const tree_classdef_element&) = delete;
+
   ~tree_classdef_element (void)
   {
     delete attr_list;
     delete elt_list;
     delete lead_comm;
     delete trail_comm;
   }
 
@@ -185,304 +190,289 @@ private:
   // The list of objects contained in this block.
   octave::base_list<T> *elt_list;
 
   // Comment preceding the token marking the beginning of the block.
   octave_comment_list *lead_comm;
 
   // Comment preceding END token.
   octave_comment_list *trail_comm;
-
-  // No copying!
-
-  tree_classdef_element (const tree_classdef_element&) = delete;
-
-  tree_classdef_element& operator = (const tree_classdef_element&) = delete;
 };
 
 class tree_classdef_property
 {
 public:
 
   tree_classdef_property (tree_identifier *i = 0, tree_expression *e = 0)
     : id (i), expr (e) { }
 
+  // No copying!
+
+  tree_classdef_property (const tree_classdef_property&) = delete;
+
+  tree_classdef_property& operator = (const tree_classdef_property&) = delete;
+
   ~tree_classdef_property (void)
   {
     delete id;
     delete expr;
   }
 
   tree_identifier *ident (void) { return id; }
 
   tree_expression *expression (void) { return expr; }
 
   void accept (tree_walker&);
 
 private:
 
   tree_identifier *id;
   tree_expression *expr;
-
-  // No copying!
-
-  tree_classdef_property (const tree_classdef_property&) = delete;
-
-  tree_classdef_property& operator = (const tree_classdef_property&) = delete;
 };
 
 class tree_classdef_property_list : public octave::base_list<tree_classdef_property *>
 {
 public:
 
   tree_classdef_property_list (void) { }
 
   tree_classdef_property_list (tree_classdef_property* p) { append (p); }
 
   tree_classdef_property_list (const octave::base_list<tree_classdef_property *>& a)
     : octave::base_list<tree_classdef_property *> (a) { }
 
-  ~tree_classdef_property_list (void);
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_property_list (const tree_classdef_property_list&) = delete;
 
-  tree_classdef_property_list& operator = (const tree_classdef_property_list&) = delete;
+  tree_classdef_property_list&
+  operator = (const tree_classdef_property_list&) = delete;
+
+  ~tree_classdef_property_list (void);
+
+  void accept (tree_walker&);
 };
 
 class tree_classdef_properties_block
   : public tree_classdef_element<tree_classdef_property *>
 {
 public:
 
   tree_classdef_properties_block (tree_classdef_attribute_list *a,
                                   tree_classdef_property_list *plist,
                                   octave_comment_list *lc,
                                   octave_comment_list *tc,
                                   int l = -1, int c = -1)
     : tree_classdef_element<tree_classdef_property *> (a, plist, lc, tc, l, c) { }
 
-  ~tree_classdef_properties_block (void) = default;
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_properties_block (const tree_classdef_properties_block&) = delete;
 
-  tree_classdef_properties_block& operator = (const tree_classdef_properties_block&) = delete;
+  tree_classdef_properties_block&
+  operator = (const tree_classdef_properties_block&) = delete;
+
+  ~tree_classdef_properties_block (void) = default;
+
+  void accept (tree_walker&);
 };
 
 class tree_classdef_methods_list : public octave::base_list<octave_value>
 {
 public:
 
   tree_classdef_methods_list (void) { }
 
   tree_classdef_methods_list (const octave_value& f) { append (f); }
 
   tree_classdef_methods_list (const octave::base_list<octave_value>& a)
     : octave::base_list<octave_value> (a) { }
 
-  ~tree_classdef_methods_list (void) = default;
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_methods_list (const tree_classdef_methods_list&) = delete;
 
-  tree_classdef_methods_list& operator = (const tree_classdef_methods_list&) = delete;
+  tree_classdef_methods_list&
+  operator = (const tree_classdef_methods_list&) = delete;
+
+  ~tree_classdef_methods_list (void) = default;
+
+  void accept (tree_walker&);
 };
 
 class tree_classdef_methods_block : public tree_classdef_element<octave_value>
 {
 public:
 
   tree_classdef_methods_block (tree_classdef_attribute_list *a,
                                tree_classdef_methods_list *mlist,
                                octave_comment_list *lc,
                                octave_comment_list *tc, int l = -1, int c = -1)
     : tree_classdef_element<octave_value> (a, mlist, lc, tc, l, c) { }
 
-  ~tree_classdef_methods_block (void) = default;
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_methods_block (const tree_classdef_methods_block&) = delete;
 
-  tree_classdef_methods_block& operator = (const tree_classdef_methods_block&) = delete;
+  tree_classdef_methods_block&
+  operator = (const tree_classdef_methods_block&) = delete;
+
+  ~tree_classdef_methods_block (void) = default;
+
+  void accept (tree_walker&);
 };
 
 class tree_classdef_event
 {
 public:
 
   tree_classdef_event (tree_identifier *i = 0) : id (i) { }
 
+  // No copying!
+
+  tree_classdef_event (const tree_classdef_event&) = delete;
+
+  tree_classdef_event& operator = (const tree_classdef_event&) = delete;
+
   ~tree_classdef_event (void)
   {
     delete id;
   }
 
   tree_identifier *ident (void) { return id; }
 
   void accept (tree_walker&);
 
 private:
 
   tree_identifier *id;
-
-  // No copying!
-
-  tree_classdef_event (const tree_classdef_event&) = delete;
-
-  tree_classdef_event& operator = (const tree_classdef_event&) = delete;
 };
 
 class tree_classdef_events_list : public octave::base_list<tree_classdef_event *>
 {
 public:
 
   tree_classdef_events_list (void) { }
 
   tree_classdef_events_list (tree_classdef_event *e) { append (e); }
 
   tree_classdef_events_list (const octave::base_list<tree_classdef_event *>& a)
     : octave::base_list<tree_classdef_event *> (a) { }
 
-  ~tree_classdef_events_list (void);
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_events_list (const tree_classdef_events_list&) = delete;
 
-  tree_classdef_events_list& operator = (const tree_classdef_events_list&) = delete;
+  tree_classdef_events_list&
+  operator = (const tree_classdef_events_list&) = delete;
+
+  ~tree_classdef_events_list (void);
+
+  void accept (tree_walker&);
 };
 
 class tree_classdef_events_block
   : public tree_classdef_element<tree_classdef_event *>
 {
 public:
 
   tree_classdef_events_block (tree_classdef_attribute_list *a,
                               tree_classdef_events_list *elist,
                               octave_comment_list *lc,
                               octave_comment_list *tc, int l = -1, int c = -1)
     : tree_classdef_element<tree_classdef_event *> (a, elist, lc, tc, l, c) { }
 
-  ~tree_classdef_events_block (void) = default;
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_events_block (const tree_classdef_events_block&) = delete;
 
-  tree_classdef_events_block& operator = (const tree_classdef_events_block&) = delete;
+  tree_classdef_events_block&
+  operator = (const tree_classdef_events_block&) = delete;
+
+  ~tree_classdef_events_block (void) = default;
+
+  void accept (tree_walker&);
 };
 
 class tree_classdef_enum
 {
 public:
 
   tree_classdef_enum (void) : id (0), expr (0) { }
 
   tree_classdef_enum (tree_identifier *i, tree_expression *e)
     : id (i), expr (e) { }
 
+  // No copying!
+
+  tree_classdef_enum (const tree_classdef_enum&) = delete;
+
+  tree_classdef_enum& operator = (const tree_classdef_enum&) = delete;
+
   ~tree_classdef_enum (void)
   {
     delete id;
     delete expr;
   }
 
   tree_identifier *ident (void) { return id; }
 
   tree_expression *expression (void) { return expr; }
 
   void accept (tree_walker&);
 
 private:
 
   tree_identifier *id;
   tree_expression *expr;
-
-  // No copying!
-
-  tree_classdef_enum (const tree_classdef_enum&) = delete;
-
-  tree_classdef_enum& operator = (const tree_classdef_enum&) = delete;
 };
 
 class tree_classdef_enum_list : public octave::base_list<tree_classdef_enum *>
 {
 public:
 
   tree_classdef_enum_list (void) { }
 
   tree_classdef_enum_list (tree_classdef_enum *e) { append (e); }
 
   tree_classdef_enum_list (const octave::base_list<tree_classdef_enum *>& a)
     : octave::base_list<tree_classdef_enum *> (a) { }
 
-  ~tree_classdef_enum_list (void);
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_enum_list (const tree_classdef_enum_list&) = delete;
 
   tree_classdef_enum_list& operator = (const tree_classdef_enum_list&) = delete;
+
+  ~tree_classdef_enum_list (void);
+
+  void accept (tree_walker&);
 };
 
 class tree_classdef_enum_block
   : public tree_classdef_element<tree_classdef_enum *>
 {
 public:
 
   tree_classdef_enum_block (tree_classdef_attribute_list *a,
                             tree_classdef_enum_list *elist,
                             octave_comment_list *lc,
                             octave_comment_list *tc, int l = -1, int c = -1)
     : tree_classdef_element<tree_classdef_enum *> (a, elist, lc, tc, l, c) { }
 
-  ~tree_classdef_enum_block (void) = default;
-
-  void accept (tree_walker&);
-
-private:
-
   // No copying!
 
   tree_classdef_enum_block (const tree_classdef_enum_block&) = delete;
 
-  tree_classdef_enum_block& operator = (const tree_classdef_enum_block&) = delete;
+  tree_classdef_enum_block&
+  operator = (const tree_classdef_enum_block&) = delete;
+
+  ~tree_classdef_enum_block (void) = default;
+
+  void accept (tree_walker&);
 };
 
 class tree_classdef_body
 {
 public:
 
   typedef std::list<tree_classdef_properties_block *>::iterator properties_list_iterator;
   typedef std::list<tree_classdef_properties_block *>::const_iterator properties_list_const_iterator;
@@ -518,16 +508,22 @@ public:
   }
 
   tree_classdef_body (tree_classdef_enum_block *enb)
     : properties_lst (), methods_lst (), events_lst (), enum_lst ()
   {
     append (enb);
   }
 
+  // No copying!
+
+  tree_classdef_body (const tree_classdef_body&) = delete;
+
+  tree_classdef_body& operator = (const tree_classdef_body&) = delete;
+
   ~tree_classdef_body (void);
 
   void append (tree_classdef_properties_block *pb)
   {
     properties_lst.push_back (pb);
   }
 
   void append (tree_classdef_methods_block *mb)
@@ -571,22 +567,16 @@ private:
 
   std::list<tree_classdef_properties_block *> properties_lst;
 
   std::list<tree_classdef_methods_block *> methods_lst;
 
   std::list<tree_classdef_events_block *> events_lst;
 
   std::list<tree_classdef_enum_block *> enum_lst;
-
-  // No copying!
-
-  tree_classdef_body (const tree_classdef_body&) = delete;
-
-  tree_classdef_body& operator = (const tree_classdef_body&) = delete;
 };
 
 // Classdef definition.
 
 class tree_classdef : public tree_command
 {
 public:
 
@@ -595,16 +585,22 @@ public:
                  tree_classdef_body *b, octave_comment_list *lc,
                  octave_comment_list *tc,
                  const std::string& pn = "", int l = -1,
                  int c = -1)
     : tree_command (l, c), attr_list (a), id (i),
       supclass_list (sc), element_list (b), lead_comm (lc), trail_comm (tc),
       pack_name (pn) { }
 
+  // No copying!
+
+  tree_classdef (const tree_classdef&) = delete;
+
+  tree_classdef& operator = (const tree_classdef&) = delete;
+
   ~tree_classdef (void)
   {
     delete attr_list;
     delete id;
     delete supclass_list;
     delete element_list;
     delete lead_comm;
     delete trail_comm;
@@ -639,18 +635,12 @@ private:
   tree_classdef_superclass_list *supclass_list;
 
   tree_classdef_body *element_list;
 
   octave_comment_list *lead_comm;
   octave_comment_list *trail_comm;
 
   std::string pack_name;
-
-  // No copying!
-
-  tree_classdef (const tree_classdef&) = delete;
-
-  tree_classdef& operator = (const tree_classdef&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-cmd.h b/libinterp/parse-tree/pt-cmd.h
--- a/libinterp/parse-tree/pt-cmd.h
+++ b/libinterp/parse-tree/pt-cmd.h
@@ -39,41 +39,45 @@ class tree_walker;
 class
 tree_command : public tree
 {
 public:
 
   tree_command (int l = -1, int c = -1)
     : tree (l, c) { }
 
-  virtual ~tree_command (void) = default;
-
-  virtual tree_command *dup (symbol_table::scope_id,
-                             symbol_table::context_id context) const = 0;
-
-private:
-
   // No copying!
 
   tree_command (const tree_command&) = delete;
 
   tree_command& operator = (const tree_command&) = delete;
+
+  virtual ~tree_command (void) = default;
+
+  virtual tree_command *dup (symbol_table::scope_id,
+                             symbol_table::context_id context) const = 0;
 };
 
 // No-op.
 
 class
 tree_no_op_command : public tree_command
 {
 public:
 
   tree_no_op_command (const std::string& cmd = "no_op", bool e = false,
                       int l = -1, int c = -1)
     : tree_command (l, c), eof (e), orig_cmd (cmd) { }
 
+  // No copying!
+
+  tree_no_op_command (const tree_no_op_command&) = delete;
+
+  tree_no_op_command& operator = (const tree_no_op_command&) = delete;
+
   ~tree_no_op_command (void) = default;
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   bool is_end_of_fcn_or_script (void) const
@@ -85,51 +89,45 @@ public:
 
   std::string original_command (void) { return orig_cmd; }
 
 private:
 
   bool eof;
 
   std::string orig_cmd;
-
-  // No copying!
-
-  tree_no_op_command (const tree_no_op_command&) = delete;
-
-  tree_no_op_command& operator = (const tree_no_op_command&) = delete;
 };
 
 // Function definition.
 
 class
 tree_function_def : public tree_command
 {
 public:
 
   tree_function_def (octave_function *f, int l = -1, int c = -1)
     : tree_command (l, c), fcn (f) { }
 
+  // No copying!
+
+  tree_function_def (const tree_function_def&) = delete;
+
+  tree_function_def& operator = (const tree_function_def&) = delete;
+
   ~tree_function_def (void) = default;
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   octave_value function (void) { return fcn; }
 
 private:
 
   octave_value fcn;
 
   tree_function_def (const octave_value& v, int l = -1, int c = -1)
     : tree_command (l, c), fcn (v) { }
-
-  // No copying!
-
-  tree_function_def (const tree_function_def&) = delete;
-
-  tree_function_def& operator = (const tree_function_def&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -51,16 +51,22 @@ public:
     : tree_expression (l, c), op_base (e), op_limit (0),
       op_increment (0), save_base (false) { }
 
   tree_colon_expression (tree_expression *bas, tree_expression *lim,
                          tree_expression *inc, int l = -1, int c = -1)
     : tree_expression (l, c), op_base (bas), op_limit (lim),
       op_increment (inc), save_base (false) { }
 
+  // No copying!
+
+  tree_colon_expression (const tree_colon_expression&) = delete;
+
+  tree_colon_expression& operator = (const tree_colon_expression&) = delete;
+
   ~tree_colon_expression (void)
   {
     if (! save_base)
       delete op_base;
 
     delete op_limit;
     delete op_increment;
   }
@@ -101,18 +107,12 @@ public:
 private:
 
   // The components of the expression.
   tree_expression *op_base;
   tree_expression *op_limit;
   tree_expression *op_increment;
 
   bool save_base;
-
-  // No copying!
-
-  tree_colon_expression (const tree_colon_expression&) = delete;
-
-  tree_colon_expression& operator = (const tree_colon_expression&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-const.h b/libinterp/parse-tree/pt-const.h
--- a/libinterp/parse-tree/pt-const.h
+++ b/libinterp/parse-tree/pt-const.h
@@ -47,16 +47,22 @@ public:
 
   tree_constant (const octave_value& v, int l = -1, int c = -1)
     : tree_expression (l, c), val (v), orig_text () { }
 
   tree_constant (const octave_value& v, const std::string& ot,
                  int l = -1, int c = -1)
     : tree_expression (l, c), val (v), orig_text (ot) { }
 
+  // No copying!
+
+  tree_constant (const tree_constant&) = delete;
+
+  tree_constant& operator = (const tree_constant&) = delete;
+
   ~tree_constant (void) = default;
 
   bool has_magic_end (void) const { return false; }
 
   // Type.  It would be nice to eliminate the need for this.
 
   bool is_constant (void) const { return true; }
 
@@ -88,19 +94,12 @@ public:
 
 private:
 
   // The actual value that this constant refers to.
   octave_value val;
 
   // The original text form of this constant.
   std::string orig_text;
-
-  // No copying!
-
-  tree_constant (const tree_constant&) = delete;
-
-  tree_constant& operator = (const tree_constant&) = delete;
-
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -43,16 +43,22 @@ class tree_walker;
 class
 tree_decl_elt
 {
 public:
 
   tree_decl_elt (tree_identifier *i = 0, tree_expression *e = 0)
     : id (i), expr (e) { }
 
+  // No copying!
+
+  tree_decl_elt (const tree_decl_elt&) = delete;
+
+  tree_decl_elt& operator = (const tree_decl_elt&) = delete;
+
   ~tree_decl_elt (void);
 
   bool eval (void);
 
   bool is_defined (void) { return id ? id->is_defined () : false; }
 
   bool is_variable (void) { return id ? id->is_variable () : false; }
 
@@ -97,150 +103,140 @@ public:
 
 private:
 
   // An identifier to tag with the declared property.
   tree_identifier *id;
 
   // An initializer expression (may be zero);
   tree_expression *expr;
-
-  // No copying!
-
-  tree_decl_elt (const tree_decl_elt&) = delete;
-
-  tree_decl_elt& operator = (const tree_decl_elt&) = delete;
 };
 
 class
 tree_decl_init_list : public octave::base_list<tree_decl_elt *>
 {
 public:
 
   tree_decl_init_list (void) { }
 
   tree_decl_init_list (tree_decl_elt *t) { append (t); }
 
+  // No copying!
+
+  tree_decl_init_list (const tree_decl_init_list&) = delete;
+
+  tree_decl_init_list& operator = (const tree_decl_init_list&) = delete;
+
   ~tree_decl_init_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   tree_decl_init_list *dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
-
-private:
-
-  // No copying!
-
-  tree_decl_init_list (const tree_decl_init_list&) = delete;
-
-  tree_decl_init_list& operator = (const tree_decl_init_list&) = delete;
 };
 
 // Base class for declaration commands -- global, static, etc.
 
 class
 tree_decl_command : public tree_command
 {
 public:
 
   tree_decl_command (const std::string& n, int l = -1, int c = -1)
     : tree_command (l, c), cmd_name (n), init_list (0) { }
 
   tree_decl_command (const std::string& n, tree_decl_init_list *t,
                      int l = -1, int c = -1)
     : tree_command (l, c), cmd_name (n), init_list (t) { }
 
+  // No copying!
+
+  tree_decl_command (const tree_decl_command&) = delete;
+
+  tree_decl_command& operator = (const tree_decl_command&) = delete;
+
   ~tree_decl_command (void);
 
   tree_decl_init_list *initializer_list (void) { return init_list; }
 
   std::string name (void) { return cmd_name; }
 
 protected:
 
   // The name of this command -- global, static, etc.
   std::string cmd_name;
 
   // The list of variables or initializers in this declaration command.
   tree_decl_init_list *init_list;
-
-private:
-
-  // No copying!
-
-  tree_decl_command (const tree_decl_command&) = delete;
-
-  tree_decl_command& operator = (const tree_decl_command&) = delete;
 };
 
 // Global.
 
 class
 tree_global_command : public tree_decl_command
 {
 public:
 
   tree_global_command (int l = -1, int c = -1)
     : tree_decl_command ("global", l, c) { }
 
   tree_global_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("global", t, l, c) { }
 
+  // No copying!
+
+  tree_global_command (const tree_global_command&) = delete;
+
+  tree_global_command& operator = (const tree_global_command&) = delete;
+
   ~tree_global_command (void) = default;
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   static void do_init (tree_decl_elt& elt);
-
-  // No copying!
-
-  tree_global_command (const tree_global_command&) = delete;
-
-  tree_global_command& operator = (const tree_global_command&) = delete;
 };
 
 // Persistent.
 
 class
 tree_persistent_command : public tree_decl_command
 {
 public:
 
   tree_persistent_command (int l = -1, int c = -1)
     : tree_decl_command ("persistent", l, c) { }
 
   tree_persistent_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("persistent", t, l, c) { }
 
+  // No copying!
+
+  tree_persistent_command (const tree_persistent_command&) = delete;
+
+  tree_persistent_command& operator = (const tree_persistent_command&) = delete;
+
   ~tree_persistent_command (void) = default;
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   static void do_init (tree_decl_elt& elt);
-
-  // No copying!
-
-  tree_persistent_command (const tree_persistent_command&) = delete;
-
-  tree_persistent_command& operator = (const tree_persistent_command&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -47,16 +47,22 @@ namespace octave
   public:
 
     typedef void (*decl_elt_init_fcn) (tree_decl_elt&);
 
     tree_evaluator (interpreter *interp_context)
       : m_interp_context (interp_context)
     { }
 
+    // No copying!
+
+    tree_evaluator (const tree_evaluator&) = delete;
+
+    tree_evaluator& operator = (const tree_evaluator&) = delete;
+
     ~tree_evaluator (void) = default;
 
     void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
     void visit_argument_list (tree_argument_list&);
 
     void visit_binary_expression (tree_binary_expression&);
 
@@ -184,22 +190,16 @@ namespace octave
 
     void do_breakpoint (bool is_breakpoint,
                         bool is_end_of_fcn_or_script = false) const;
 
     virtual octave_value
       do_keyboard (const octave_value_list& args = octave_value_list ()) const;
 
     interpreter *m_interp_context;
-
-    // No copying!
-
-    tree_evaluator (const tree_evaluator&) = delete;
-
-    tree_evaluator& operator = (const tree_evaluator&) = delete;
   };
 }
 
 // Maximum nesting level for functions, scripts, or sourced files called
 // recursively.
 extern int Vmax_recursion_depth;
 
 #endif
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -49,16 +49,22 @@ public:
                           tree_identifier *id,
                           octave_comment_list *cl = 0,
                           octave_comment_list *cm = 0,
                           octave_comment_list *ct = 0,
                           int l = -1, int c = -1)
     : tree_command (l, c), try_code (tc), catch_code (cc), expr_id (id),
       lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
+  // No copying!
+
+  tree_try_catch_command (const tree_try_catch_command&) = delete;
+
+  tree_try_catch_command& operator = (const tree_try_catch_command&) = delete;
+
   ~tree_try_catch_command (void);
 
   tree_identifier *identifier (void) { return expr_id; }
 
   tree_statement_list *body (void) { return try_code; }
 
   tree_statement_list *cleanup (void) { return catch_code; }
 
@@ -87,22 +93,16 @@ private:
   // Comment preceding TRY token.
   octave_comment_list *lead_comm;
 
   // Comment preceding CATCH token.
   octave_comment_list *mid_comm;
 
   // Comment preceding END_TRY_CATCH token.
   octave_comment_list *trail_comm;
-
-  // No copying!
-
-  tree_try_catch_command (const tree_try_catch_command&) = delete;
-
-  tree_try_catch_command& operator = (const tree_try_catch_command&) = delete;
 };
 
 // Simple exception handling.
 
 class
 tree_unwind_protect_command : public tree_command
 {
 public:
@@ -115,16 +115,23 @@ public:
                                tree_statement_list *cc,
                                octave_comment_list *cl = 0,
                                octave_comment_list *cm = 0,
                                octave_comment_list *ct = 0,
                                int l = -1, int c = -1)
     : tree_command (l, c), unwind_protect_code (tc), cleanup_code (cc),
       lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
+  // No copying!
+
+  tree_unwind_protect_command (const tree_unwind_protect_command&) = delete;
+
+  tree_unwind_protect_command&
+  operator = (const tree_unwind_protect_command&) = delete;
+
   ~tree_unwind_protect_command (void);
 
   tree_statement_list *body (void) { return unwind_protect_code; }
 
   tree_statement_list *cleanup (void) { return cleanup_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
@@ -149,18 +156,12 @@ private:
   // Comment preceding UNWIND_PROTECT token.
   octave_comment_list *lead_comm;
 
   // Comment preceding UNWIND_PROTECT_CLEANUP token.
   octave_comment_list *mid_comm;
 
   // Comment preceding END_UNWIND_PROTECT token.
   octave_comment_list *trail_comm;
-
-  // No copying!
-
-  tree_unwind_protect_command (const tree_unwind_protect_command&) = delete;
-
-  tree_unwind_protect_command& operator = (const tree_unwind_protect_command&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -40,16 +40,22 @@ class
 tree_expression : public tree
 {
 public:
 
   tree_expression (int l = -1, int c = -1)
     : tree (l, c), num_parens (0), postfix_index_type ('\0'),
       for_cmd_expr (false), print_flag (false) { }
 
+  // No copying!
+
+  tree_expression (const tree_expression&) = delete;
+
+  tree_expression& operator = (const tree_expression&) = delete;
+
   virtual ~tree_expression (void) = default;
 
   virtual bool has_magic_end (void) const = 0;
 
   virtual tree_expression *dup (symbol_table::scope_id,
                                 symbol_table::context_id context) const = 0;
 
   virtual bool is_constant (void) const { return false; }
@@ -151,20 +157,12 @@ protected:
   char postfix_index_type;
 
   // TRUE if this expression is the EXPR in for loop:
   // FOR i = EXPR ... END
   bool for_cmd_expr;
 
   // Print result of rvalue for this expression?
   bool print_flag;
-
-private:
-
-  // No copying!
-
-  tree_expression (const tree_expression&) = delete;
-
-  tree_expression& operator = (const tree_expression&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -48,16 +48,22 @@ tree_fcn_handle : public tree_expression
 public:
 
   tree_fcn_handle (int l = -1, int c = -1)
     : tree_expression (l, c), nm () { }
 
   tree_fcn_handle (const std::string& n, int l = -1, int c = -1)
     : tree_expression (l, c), nm (n) { }
 
+  // No copying!
+
+  tree_fcn_handle (const tree_fcn_handle&) = delete;
+
+  tree_fcn_handle& operator = (const tree_fcn_handle&) = delete;
+
   ~tree_fcn_handle (void) = default;
 
   bool has_magic_end (void) const { return false; }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false,
               bool pr_orig_txt = true);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
@@ -75,22 +81,16 @@ public:
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
   // The name of this function handle.
   std::string nm;
-
-  // No copying!
-
-  tree_fcn_handle (const tree_fcn_handle&) = delete;
-
-  tree_fcn_handle& operator = (const tree_fcn_handle&) = delete;
 };
 
 class
 tree_anon_fcn_handle : public tree_expression
 {
 public:
 
   tree_anon_fcn_handle (int l = -1, int c = -1)
@@ -98,16 +98,22 @@ public:
 
   tree_anon_fcn_handle (tree_parameter_list *pl, tree_parameter_list *rl,
                         tree_statement_list *cl, symbol_table::scope_id sid,
                         int l = -1, int c = -1)
     : tree_expression (l, c),
       fcn (new octave_user_function (sid, pl, rl, cl)),
       file_name () { }
 
+  // No copying!
+
+  tree_anon_fcn_handle (const tree_anon_fcn_handle&) = delete;
+
+  tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&) = delete;
+
   ~tree_anon_fcn_handle (void) { delete fcn; }
 
   bool has_magic_end (void) const { return false; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
@@ -142,18 +148,12 @@ public:
 
 private:
 
   // The function.
   octave_user_function *fcn;
 
   // Filename where the handle was defined.
   std::string file_name;
-
-  // No copying!
-
-  tree_anon_fcn_handle (const tree_anon_fcn_handle&) = delete;
-
-  tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-funcall.h b/libinterp/parse-tree/pt-funcall.h
--- a/libinterp/parse-tree/pt-funcall.h
+++ b/libinterp/parse-tree/pt-funcall.h
@@ -43,16 +43,22 @@ public:
   tree_funcall (const octave_value& f, const octave_value_list& a,
                 int l = -1, int c = -1)
     : tree_expression (l, c), fcn (f), args (a)
   {
     if (! fcn.is_function ())
       error ("tree_funcall: invalid function");
   }
 
+  // No copying!
+
+  tree_funcall (const tree_funcall&) = delete;
+
+  tree_funcall& operator = (const tree_funcall&) = delete;
+
   ~tree_funcall (void) = default;
 
   bool has_magic_end (void) const { return false; }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false,
               bool pr_orig_txt = true);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
@@ -84,18 +90,12 @@ public:
 private:
 
   // Function to call.  Error if not a valid function at time of
   // construction.
   octave_value fcn;
 
   // Argument list.
   octave_value_list args;
-
-  // No copying!
-
-  tree_funcall (const tree_funcall&) = delete;
-
-  tree_funcall& operator = (const tree_funcall&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -51,16 +51,22 @@ public:
   tree_identifier (int l = -1, int c = -1)
     : tree_expression (l, c) { }
 
   tree_identifier (const symbol_table::symbol_record& s,
                    int l = -1, int c = -1,
                    symbol_table::scope_id sc = symbol_table::current_scope ())
     : tree_expression (l, c), sym (s, sc) { }
 
+  // No copying!
+
+  tree_identifier (const tree_identifier&) = delete;
+
+  tree_identifier& operator = (const tree_identifier&) = delete;
+
   ~tree_identifier (void) = default;
 
   bool has_magic_end (void) const { return (name () == "end"); }
 
   bool is_identifier (void) const { return true; }
 
   // The name doesn't change with scope, so use sym instead of
   // accessing it through sym so that this function may remain const.
@@ -132,22 +138,16 @@ public:
   symbol_table::symbol_reference symbol (void) const
   {
     return sym;
   }
 private:
 
   // The symbol record that this identifier references.
   symbol_table::symbol_reference sym;
-
-  // No copying!
-
-  tree_identifier (const tree_identifier&) = delete;
-
-  tree_identifier& operator = (const tree_identifier&) = delete;
 };
 
 class tree_black_hole : public tree_identifier
 {
 public:
 
   tree_black_hole (int l = -1, int c = -1)
     : tree_identifier (l, c) { }
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -52,16 +52,22 @@ public:
                          int l = -1, int c = -1, char t = '(');
 
   tree_index_expression (tree_expression *e, const std::string& n,
                          int l = -1, int c = -1);
 
   tree_index_expression (tree_expression *e, tree_expression* df,
                          int l = -1, int c = -1);
 
+  // No copying!
+
+  tree_index_expression (const tree_index_expression&) = delete;
+
+  tree_index_expression& operator = (const tree_index_expression&) = delete;
+
   ~tree_index_expression (void);
 
   bool has_magic_end (void) const;
 
   void append (tree_argument_list *lst = 0, char t = '(');
 
   void append (const std::string& n);
 
@@ -118,18 +124,12 @@ private:
   tree_index_expression (int l, int c);
 
   octave_map make_arg_struct (void) const;
 
   std::string
   get_struct_index
     (std::list<string_vector>::const_iterator p_arg_nm,
      std::list<tree_expression *>::const_iterator p_dyn_field) const;
-
-  // No copying!
-
-  tree_index_expression (const tree_index_expression&) = delete;
-
-  tree_index_expression& operator = (const tree_index_expression&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-jump.h b/libinterp/parse-tree/pt-jump.h
--- a/libinterp/parse-tree/pt-jump.h
+++ b/libinterp/parse-tree/pt-jump.h
@@ -35,84 +35,78 @@ class tree_walker;
 class
 tree_break_command : public tree_command
 {
 public:
 
   tree_break_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
+  // No copying!
+
+  tree_break_command (const tree_break_command&) = delete;
+
+  tree_break_command& operator = (const tree_break_command&) = delete;
+
   ~tree_break_command (void) = default;
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   static int breaking;
-
-private:
-
-  // No copying!
-
-  tree_break_command (const tree_break_command&) = delete;
-
-  tree_break_command& operator = (const tree_break_command&) = delete;
 };
 
 // Continue.
 
 class
 tree_continue_command : public tree_command
 {
 public:
 
   tree_continue_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
+  // No copying!
+
+  tree_continue_command (const tree_continue_command&) = delete;
+
+  tree_continue_command& operator = (const tree_continue_command&) = delete;
+
   ~tree_continue_command (void) = default;
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   static int continuing;
-
-private:
-
-  // No copying!
-
-  tree_continue_command (const tree_continue_command&) = delete;
-
-  tree_continue_command& operator = (const tree_continue_command&) = delete;
 };
 
 // Return.
 
 class
 tree_return_command : public tree_command
 {
 public:
 
   tree_return_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
+  // No copying!
+
+  tree_return_command (const tree_return_command&) = delete;
+
+  tree_return_command& operator = (const tree_return_command&) = delete;
+
   ~tree_return_command (void) = default;
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   static int returning;
-
-private:
-
-  // No copying!
-
-  tree_return_command (const tree_return_command&) = delete;
-
-  tree_return_command& operator = (const tree_return_command&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -72,16 +72,22 @@ public:
                       int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
       trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
   { }
 
+  // No copying!
+
+  tree_while_command (const tree_while_command&) = delete;
+
+  tree_while_command& operator = (const tree_while_command&) = delete;
+
   ~tree_while_command (void);
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
@@ -120,22 +126,16 @@ protected:
   octave_comment_list *trail_comm;
 
 private:
 
 #if defined (HAVE_LLVM)
   // compiled version of the loop
   jit_info *compiled;
 #endif
-
-  // No copying!
-
-  tree_while_command (const tree_while_command&) = delete;
-
-  tree_while_command& operator = (const tree_while_command&) = delete;
 };
 
 // Do-Until.
 
 class
 tree_do_until_command : public tree_while_command
 {
 public:
@@ -150,30 +150,28 @@ public:
     : tree_while_command (e, lc, tc, l, c) { }
 
   tree_do_until_command (tree_expression *e, tree_statement_list *lst,
                          octave_comment_list *lc = 0,
                          octave_comment_list *tc = 0,
                          int l = -1, int c = -1)
     : tree_while_command (e, lst, lc, tc, l, c) { }
 
+  // No copying!
+
+  tree_do_until_command (const tree_do_until_command&) = delete;
+
+  tree_do_until_command& operator = (const tree_do_until_command&) = delete;
+
   ~tree_do_until_command (void) = default;
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
-
-private:
-
-  // No copying!
-
-  tree_do_until_command (const tree_do_until_command&) = delete;
-
-  tree_do_until_command& operator = (const tree_do_until_command&) = delete;
 };
 
 // For.
 
 class
 tree_simple_for_command : public tree_command
 {
 public:
@@ -196,16 +194,22 @@ public:
     : tree_command (l, c), parallel (parallel_arg), lhs (le),
       expr (re), maxproc (maxproc_arg), list (lst),
       lead_comm (lc), trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
   { }
 
+  // No copying!
+
+  tree_simple_for_command (const tree_simple_for_command&) = delete;
+
+  tree_simple_for_command& operator = (const tree_simple_for_command&) = delete;
+
   ~tree_simple_for_command (void);
 
   bool in_parallel (void) { return parallel; }
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *control_expr (void) { return expr; }
 
@@ -256,22 +260,16 @@ private:
   // Comment preceding FOR token.
   octave_comment_list *lead_comm;
 
   // Comment preceding ENDFOR token.
   octave_comment_list *trail_comm;
 
   // compiled version of the loop
   jit_info *compiled;
-
-  // No copying!
-
-  tree_simple_for_command (const tree_simple_for_command&) = delete;
-
-  tree_simple_for_command& operator = (const tree_simple_for_command&) = delete;
 };
 
 class
 tree_complex_for_command : public tree_command
 {
 public:
 
   tree_complex_for_command (int l = -1, int c = -1)
@@ -281,16 +279,22 @@ public:
   tree_complex_for_command (tree_argument_list *le, tree_expression *re,
                             tree_statement_list *lst,
                             octave_comment_list *lc = 0,
                             octave_comment_list *tc = 0,
                             int l = -1, int c = -1)
     : tree_command (l, c), lhs (le), expr (re), list (lst),
       lead_comm (lc), trail_comm (tc) { }
 
+  // No copying!
+
+  tree_complex_for_command (const tree_complex_for_command&) = delete;
+
+  tree_complex_for_command& operator = (const tree_complex_for_command&) = delete;
+
   ~tree_complex_for_command (void);
 
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
@@ -314,18 +318,12 @@ private:
   // List of commands to execute.
   tree_statement_list *list;
 
   // Comment preceding FOR token.
   octave_comment_list *lead_comm;
 
   // Comment preceding ENDFOR token.
   octave_comment_list *trail_comm;
-
-  // No copying!
-
-  tree_complex_for_command (const tree_complex_for_command&) = delete;
-
-  tree_complex_for_command& operator = (const tree_complex_for_command&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-mat.h b/libinterp/parse-tree/pt-mat.h
--- a/libinterp/parse-tree/pt-mat.h
+++ b/libinterp/parse-tree/pt-mat.h
@@ -45,38 +45,36 @@ class
 tree_matrix : public tree_array_list
 {
 public:
 
   tree_matrix (tree_argument_list *row = 0, int l = -1, int c = -1)
     : tree_array_list (row, l, c)
   { }
 
+  // No copying!
+
+  tree_matrix (const tree_matrix&) = delete;
+
+  tree_matrix& operator = (const tree_matrix&) = delete;
+
   ~tree_matrix (void) = default;
 
   bool is_matrix (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
-
-private:
-
-  // No copying!
-
-  tree_matrix (const tree_matrix&) = delete;
-
-  tree_matrix& operator = (const tree_matrix&) = delete;
 };
 
 // The character to fill with when creating string arrays.
 extern char Vstring_fill_char;
 
 extern std::string
 get_concat_class (const std::string& c1, const std::string& c2);
 
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -59,16 +59,22 @@ public:
     : marked_for_varargs (0) { }
 
   tree_parameter_list (tree_decl_elt *t)
     : marked_for_varargs (0) { append (t); }
 
   tree_parameter_list (tree_identifier *id)
     : marked_for_varargs (0) { append (new tree_decl_elt (id)); }
 
+  // No copying!
+
+  tree_parameter_list (const tree_parameter_list&) = delete;
+
+  tree_parameter_list& operator = (const tree_parameter_list&) = delete;
+
   ~tree_parameter_list (void);
 
   void mark_as_formal_parameters (void);
 
   bool validate (in_or_out type);
 
   bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
@@ -95,64 +101,54 @@ public:
 
 private:
 
   int marked_for_varargs;
 
   void mark_varargs (void) { marked_for_varargs = 1; }
 
   void mark_varargs_only (void) { marked_for_varargs = -1; }
-
-  // No copying!
-
-  tree_parameter_list (const tree_parameter_list&) = delete;
-
-  tree_parameter_list& operator = (const tree_parameter_list&) = delete;
 };
 
 // Return lists.  Used to hold the right hand sides of multiple
 // assignment expressions.
 
 class
 tree_return_list : public octave::base_list<tree_index_expression *>
 {
 public:
 
   tree_return_list (void) { }
 
   tree_return_list (tree_index_expression *t) { append (t); }
 
+  // No copying!
+
+  tree_return_list (const tree_return_list&) = delete;
+
+  tree_return_list& operator = (const tree_return_list&) = delete;
+
   ~tree_return_list (void);
 
   tree_return_list *dup (symbol_table::scope_id scope,
                          symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
-
-private:
-
-  // No copying!
-
-  tree_return_list (const tree_return_list&) = delete;
-
-  tree_return_list& operator = (const tree_return_list&) = delete;
 };
 
 class
 tree_va_return_list : public octave::base_list<octave_value>
 {
 public:
 
   tree_va_return_list (void) { }
 
-  ~tree_va_return_list (void) = default;
-
-private:
-
   // No copying!
 
   tree_va_return_list (const tree_va_return_list&) = delete;
 
   tree_va_return_list& operator = (const tree_va_return_list&) = delete;
+
+  ~tree_va_return_list (void) = default;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-pr-code.h b/libinterp/parse-tree/pt-pr-code.h
--- a/libinterp/parse-tree/pt-pr-code.h
+++ b/libinterp/parse-tree/pt-pr-code.h
@@ -48,16 +48,22 @@ public:
       print_original_text (pr_orig_txt),
       curr_print_indent_level (0), beginning_of_line (true),
       suppress_newlines (0)
   {
     // For "none".
     nesting.push ('n');
   }
 
+  // No copying!
+
+  tree_print_code (const tree_print_code&) = delete;
+
+  tree_print_code& operator = (const tree_print_code&) = delete;
+
   ~tree_print_code (void) = default;
 
   void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
   void visit_argument_list (tree_argument_list&);
 
   void visit_binary_expression (tree_binary_expression&);
 
@@ -184,18 +190,12 @@ private:
 
   void print_comment_elt (const octave_comment_elt& comment_elt);
 
   void print_indented_comment (octave_comment_list *comment_list);
 
   // Must create with an output stream!
 
   tree_print_code (void);
-
-  // No copying!
-
-  tree_print_code (const tree_print_code&) = delete;
-
-  tree_print_code& operator = (const tree_print_code&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -49,16 +49,22 @@ public:
                   int l = -1, int c = -1)
     : tree (l, c), expr (0), list (sl), lead_comm (lc) { }
 
   tree_if_clause (tree_expression *e, tree_statement_list *sl,
                   octave_comment_list *lc = 0,
                   int l = -1, int c = -1)
     : tree (l, c), expr (e), list (sl), lead_comm (lc) { }
 
+  // No copying!
+
+  tree_if_clause (const tree_if_clause&) = delete;
+
+  tree_if_clause& operator = (const tree_if_clause&) = delete;
+
   ~tree_if_clause (void);
 
   bool is_else_clause (void) { return ! expr; }
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *commands (void) { return list; }
 
@@ -74,69 +80,67 @@ private:
   // The condition to test.
   tree_expression *expr;
 
   // The list of statements to evaluate if expr is true.
   tree_statement_list *list;
 
   // Comment preceding ELSE or ELSEIF token.
   octave_comment_list *lead_comm;
-
-  // No copying!
-
-  tree_if_clause (const tree_if_clause&) = delete;
-
-  tree_if_clause& operator = (const tree_if_clause&) = delete;
 };
 
 class
 tree_if_command_list : public octave::base_list<tree_if_clause *>
 {
 public:
 
   tree_if_command_list (void) { }
 
   tree_if_command_list (tree_if_clause *t) { append (t); }
 
+  // No copying!
+
+  tree_if_command_list (const tree_if_command_list&) = delete;
+
+  tree_if_command_list& operator = (const tree_if_command_list&) = delete;
+
   ~tree_if_command_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   tree_if_command_list *dup (symbol_table::scope_id scope,
                              symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
-
-private:
-
-  // No copying!
-
-  tree_if_command_list (const tree_if_command_list&) = delete;
-
-  tree_if_command_list& operator = (const tree_if_command_list&) = delete;
 };
 
 class
 tree_if_command : public tree_command
 {
 public:
 
   tree_if_command (int l = -1, int c = -1)
     : tree_command (l, c), list (0), lead_comm (0), trail_comm (0) { }
 
   tree_if_command (tree_if_command_list *lst, octave_comment_list *lc,
                    octave_comment_list *tc, int l = -1, int c = -1)
     : tree_command (l, c), list (lst), lead_comm (lc), trail_comm (tc) { }
 
+  // No copying!
+
+  tree_if_command (const tree_if_command&) = delete;
+
+  tree_if_command& operator = (const tree_if_command&) = delete;
+
   ~tree_if_command (void);
 
   tree_if_command_list *cmd_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
@@ -150,22 +154,16 @@ private:
   // List of if commands (if, elseif, elseif, ... else, endif)
   tree_if_command_list *list;
 
   // Comment preceding IF token.
   octave_comment_list *lead_comm;
 
   // Comment preceding ENDIF token.
   octave_comment_list *trail_comm;
-
-  // No copying!
-
-  tree_if_command (const tree_if_command&) = delete;
-
-  tree_if_command& operator = (const tree_if_command&) = delete;
 };
 
 // Switch.
 
 class
 tree_switch_case : public tree
 {
 public:
@@ -177,16 +175,22 @@ public:
                     int l = -1, int c = -1)
     : tree (l, c), label (0), list (sl), lead_comm (lc) { }
 
   tree_switch_case (tree_expression *e, tree_statement_list *sl,
                     octave_comment_list *lc = 0,
                     int l = -1, int c = -1)
     : tree (l, c), label (e), list (sl), lead_comm (lc) { }
 
+  // No copying!
+
+  tree_switch_case (const tree_switch_case&) = delete;
+
+  tree_switch_case& operator = (const tree_switch_case&) = delete;
+
   ~tree_switch_case (void);
 
   bool is_default_case (void) { return ! label; }
 
   bool label_matches (const octave_value& val);
 
   tree_expression *case_label (void) { return label; }
 
@@ -204,55 +208,47 @@ private:
   // The case label.
   tree_expression *label;
 
   // The list of statements to evaluate if the label matches.
   tree_statement_list *list;
 
   // Comment preceding CASE or OTHERWISE token.
   octave_comment_list *lead_comm;
-
-  // No copying!
-
-  tree_switch_case (const tree_switch_case&) = delete;
-
-  tree_switch_case& operator = (const tree_switch_case&) = delete;
 };
 
 class
 tree_switch_case_list : public octave::base_list<tree_switch_case *>
 {
 public:
 
   tree_switch_case_list (void) { }
 
   tree_switch_case_list (tree_switch_case *t) { append (t); }
 
+  // No copying!
+
+  tree_switch_case_list (const tree_switch_case_list&) = delete;
+
+  tree_switch_case_list& operator = (const tree_switch_case_list&) = delete;
+
   ~tree_switch_case_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
         erase (p);
       }
   }
 
   tree_switch_case_list *dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
-
-private:
-
-  // No copying!
-
-  tree_switch_case_list (const tree_switch_case_list&) = delete;
-
-  tree_switch_case_list& operator = (const tree_switch_case_list&) = delete;
 };
 
 class
 tree_switch_command : public tree_command
 {
 public:
 
   tree_switch_command (int l = -1, int c = -1)
@@ -260,16 +256,22 @@ public:
       trail_comm (0) { }
 
   tree_switch_command (tree_expression *e, tree_switch_case_list *lst,
                        octave_comment_list *lc, octave_comment_list *tc,
                        int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
       trail_comm (tc) { }
 
+  // No copying!
+
+  tree_switch_command (const tree_switch_command&) = delete;
+
+  tree_switch_command& operator = (const tree_switch_command&) = delete;
+
   ~tree_switch_command (void);
 
   tree_expression *switch_value (void) { return expr; }
 
   tree_switch_case_list *case_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
@@ -288,18 +290,12 @@ private:
   // List of cases (case 1, case 2, ..., default)
   tree_switch_case_list *list;
 
   // Comment preceding SWITCH token.
   octave_comment_list *lead_comm;
 
   // Comment preceding ENDSWITCH token.
   octave_comment_list *trail_comm;
-
-  // No copying!
-
-  tree_switch_command (const tree_switch_command&) = delete;
-
-  tree_switch_command& operator = (const tree_switch_command&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -52,16 +52,22 @@ public:
     : cmd (0), expr (0), comm (0) { }
 
   tree_statement (tree_command *c, octave_comment_list *cl)
     : cmd (c), expr (0), comm (cl) { }
 
   tree_statement (tree_expression *e, octave_comment_list *cl)
     : cmd (0), expr (e), comm (cl) { }
 
+  // No copying!
+
+  tree_statement (const tree_statement&) = delete;
+
+  tree_statement& operator = (const tree_statement&) = delete;
+
   ~tree_statement (void);
 
   void set_print_flag (bool print_flag);
 
   bool print_result (void);
 
   bool is_command (void) const { return cmd != 0; }
 
@@ -113,22 +119,16 @@ private:
   // Command to execute.
   tree_command *cmd;
 
   // Expression to evaluate.
   tree_expression *expr;
 
   // Comment associated with this statement.
   octave_comment_list *comm;
-
-  // No copying!
-
-  tree_statement (const tree_statement&) = delete;
-
-  tree_statement& operator = (const tree_statement&) = delete;
 };
 
 // A list of statements to evaluate.
 
 class
 tree_statement_list : public octave::base_list<tree_statement *>
 {
 public:
@@ -136,16 +136,22 @@ public:
   tree_statement_list (void)
     : function_body (false), anon_function_body (false),
       script_body (false) { }
 
   tree_statement_list (tree_statement *s)
     : function_body (false), anon_function_body (false),
       script_body (false) { append (s); }
 
+  // No copying!
+
+  tree_statement_list (const tree_statement_list&) = delete;
+
+  tree_statement_list& operator = (const tree_statement_list&) = delete;
+
   ~tree_statement_list (void)
   {
     while (! empty ())
       {
         iterator p = begin ();
         delete *p;
         erase (p);
       }
@@ -187,18 +193,12 @@ private:
   // Does this list of statements make up the body of a function?
   bool function_body;
 
   // Does this list of statements make up the body of a function?
   bool anon_function_body;
 
   // Does this list of statements make up the body of a script?
   bool script_body;
-
-  // No copying!
-
-  tree_statement_list (const tree_statement_list&) = delete;
-
-  tree_statement_list& operator = (const tree_statement_list&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-unop.h b/libinterp/parse-tree/pt-unop.h
--- a/libinterp/parse-tree/pt-unop.h
+++ b/libinterp/parse-tree/pt-unop.h
@@ -48,16 +48,22 @@ public:
                            = octave_value::unknown_unary_op)
     : tree_expression (l, c), op (0), etype (t)  { }
 
   tree_unary_expression (tree_expression *e, int l = -1, int c = -1,
                          octave_value::unary_op t
                            = octave_value::unknown_unary_op)
     : tree_expression (l, c), op (e), etype (t) { }
 
+  // No copying!
+
+  tree_unary_expression (const tree_unary_expression&) = delete;
+
+  tree_unary_expression& operator = (const tree_unary_expression&) = delete;
+
   ~tree_unary_expression (void) { delete op; }
 
   bool is_unary_expression (void) const { return true; }
 
   bool has_magic_end (void) const { return (op && op->has_magic_end ()); }
 
   tree_expression *operand (void) { return op; }
 
@@ -67,24 +73,16 @@ public:
 
 protected:
 
   // The operand for the expression.
   tree_expression *op;
 
   // The type of the expression.
   octave_value::unary_op etype;
-
-private:
-
-  // No copying!
-
-  tree_unary_expression (const tree_unary_expression&) = delete;
-
-  tree_unary_expression& operator = (const tree_unary_expression&) = delete;
 };
 
 // Prefix expressions.
 
 class
 tree_prefix_expression : public tree_unary_expression
 {
 public:
@@ -92,38 +90,36 @@ public:
   tree_prefix_expression (int l = -1, int c = -1)
     : tree_unary_expression (l, c, octave_value::unknown_unary_op) { }
 
   tree_prefix_expression (tree_expression *e, int l = -1, int c = -1,
                           octave_value::unary_op t
                             = octave_value::unknown_unary_op)
     : tree_unary_expression (e, l, c, t) { }
 
+  // No copying!
+
+  tree_prefix_expression (const tree_prefix_expression&) = delete;
+
+  tree_prefix_expression& operator = (const tree_prefix_expression&) = delete;
+
   ~tree_prefix_expression (void) = default;
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   std::string profiler_name (void) const { return "prefix " + oper (); }
-
-private:
-
-  // No copying!
-
-  tree_prefix_expression (const tree_prefix_expression&) = delete;
-
-  tree_prefix_expression& operator = (const tree_prefix_expression&) = delete;
 };
 
 // Postfix expressions.
 
 class
 tree_postfix_expression : public tree_unary_expression
 {
 public:
@@ -131,34 +127,32 @@ public:
   tree_postfix_expression (int l = -1, int c = -1)
     : tree_unary_expression (l, c, octave_value::unknown_unary_op) { }
 
   tree_postfix_expression (tree_expression *e, int l = -1, int c = -1,
                            octave_value::unary_op t
                              = octave_value::unknown_unary_op)
     : tree_unary_expression (e, l, c, t) { }
 
+  // No copying!
+
+  tree_postfix_expression (const tree_postfix_expression&) = delete;
+
+  tree_postfix_expression& operator = (const tree_postfix_expression&) = delete;
+
   ~tree_postfix_expression (void) = default;
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   std::string profiler_name (void) const { return "postfix " + oper (); }
-
-private:
-
-  // No copying!
-
-  tree_postfix_expression (const tree_postfix_expression&) = delete;
-
-  tree_postfix_expression& operator = (const tree_postfix_expression&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt-walk.h b/libinterp/parse-tree/pt-walk.h
--- a/libinterp/parse-tree/pt-walk.h
+++ b/libinterp/parse-tree/pt-walk.h
@@ -84,18 +84,30 @@ class tree_classdef_enum;
 class tree_classdef_enum_list;
 class tree_classdef_enum_block;
 class tree_classdef_body;
 class tree_classdef;
 
 class
 tree_walker
 {
+protected:
+
+  tree_walker (void) { }
+
+  virtual ~tree_walker (void) = default;
+
 public:
 
+  // No copying!
+
+  tree_walker (const tree_walker&) = delete;
+
+  tree_walker& operator = (const tree_walker&) = delete;
+
   virtual void
   visit_anon_fcn_handle (tree_anon_fcn_handle&) = 0;
 
   virtual void
   visit_argument_list (tree_argument_list&) = 0;
 
   virtual void
   visit_binary_expression (tree_binary_expression&) = 0;
@@ -262,26 +274,12 @@ public:
   virtual void
   visit_classdef_enum_block (tree_classdef_enum_block&) { } // = 0;
 
   virtual void
   visit_classdef_body (tree_classdef_body&) { } // = 0;
 
   virtual void
   visit_classdef (tree_classdef&) { } // = 0;
-
-protected:
-
-  tree_walker (void) { }
-
-  virtual ~tree_walker (void) = default;
-
-private:
-
-  // No copying!
-
-  tree_walker (const tree_walker&) = delete;
-
-  tree_walker& operator = (const tree_walker&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/pt.h b/libinterp/parse-tree/pt.h
--- a/libinterp/parse-tree/pt.h
+++ b/libinterp/parse-tree/pt.h
@@ -39,16 +39,22 @@ bool meets_condition (std::string *);
 class
 tree
 {
 public:
 
   tree (int l = -1, int c = -1)
     : line_num (l), column_num (c), bp (NULL) { }
 
+  // No copying!
+
+  tree (const tree&) = delete;
+
+  tree& operator = (const tree&) = delete;
+
   virtual ~tree (void) = default;
 
   virtual int line (void) const { return line_num; }
 
   virtual int column (void) const { return column_num; }
 
   void line (int l) { line_num = l; }
 
@@ -88,18 +94,12 @@ private:
 
   // The input line and column where we found the text that was
   // eventually converted to this tree node.
   int line_num;
   int column_num;
 
   // Breakpoint flag: NULL if no breakpoint, or the condition if there is one
   std::string *bp;
-
-  // No copying!
-
-  tree (const tree&) = delete;
-
-  tree& operator = (const tree&) = delete;
 };
 
 #endif
 
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -69,16 +69,22 @@ public:
   token (int tv, const std::string& s, int l = -1, int c = -1);
   token (int tv, double d, const std::string& s = "",
          int l = -1, int c = -1);
   token (int tv, end_tok_type t, int l = -1, int c = -1);
   token (int tv, symbol_table::symbol_record *s, int l = -1, int c = -1);
   token (int tv, const std::string& mth, const std::string& cls,
          int l = -1, int c = -1);
 
+  // No copying!
+
+  token (const token& tok) = delete;
+
+  token& operator = (const token& tok) = delete;
+
   ~token (void);
 
   void mark_may_be_command (void) { maybe_cmd = true; }
   bool may_be_command (void) const { return maybe_cmd; }
 
   void mark_trailing_space (void) { tspc = true; }
   bool space_follows_token (void) const { return tspc; }
 
@@ -107,22 +113,16 @@ public:
 
   std::string superclass_method_name (void);
   std::string superclass_class_name (void);
 
   std::string text_rep (void);
 
 private:
 
-  // No copying!
-
-  token (const token& tok) = delete;
-
-  token& operator = (const token& tok) = delete;
-
   bool maybe_cmd;
   bool tspc;
   int line_num;
   int column_num;
   int tok_val;
   token_type type_tag;
   union
   {
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -352,16 +352,22 @@ public:
           }
       }
 
     // Determine whether we can use block transposes.
     use_blk = top >= 1 && stride[1] == 1 && stride[0] == dim[1];
 
   }
 
+  // No copying!
+
+  rec_permute_helper (const rec_permute_helper&) = delete;
+
+  rec_permute_helper& operator = (const rec_permute_helper&) = delete;
+
   ~rec_permute_helper (void) { delete [] dim; }
 
   // Helper method for fast blocked transpose.
   template <typename T>
   static T *
   blk_trans (const T *src, T *dest, octave_idx_type nr, octave_idx_type nc)
   {
     static const octave_idx_type m = 8;
@@ -429,22 +435,16 @@ private:
         octave_idx_type len = dim[lev];
         for (octave_idx_type i = 0, j = 0; i < len; i++, j+= step)
           dest = do_permute (src + i * step, dest, lev-1);
       }
 
     return dest;
   }
 
-  // No copying!
-
-  rec_permute_helper (const rec_permute_helper&) = delete;
-
-  rec_permute_helper& operator = (const rec_permute_helper&) = delete;
-
 public:
 
   template <typename T>
   void permute (const T *src, T *dest) const { do_permute (src, dest, top); }
 };
 
 template <typename T>
 Array<T>
@@ -557,16 +557,22 @@ public:
             top++;
             idx[top] = ia(i);
             dim[top] = dv(i);
             cdim[top] = cdim[top-1] * dim[top-1];
           }
       }
   }
 
+  // No copying!
+
+  rec_index_helper (const rec_index_helper&) = delete;
+
+  rec_index_helper& operator = (const rec_index_helper&) = delete;
+
   ~rec_index_helper (void) { delete [] idx; delete [] dim; }
 
 private:
 
   // Recursive N-D indexing
   template <typename T>
   T *do_index (const T *src, T *dest, int lev) const
   {
@@ -610,22 +616,16 @@ private:
       {
         octave_idx_type nn = idx[lev].length (dim[lev]);
         octave_idx_type d = cdim[lev];
         for (octave_idx_type i = 0; i < nn; i++)
           do_fill (val, dest + d*idx[lev].xelem (i), lev-1);
       }
   }
 
-  // No copying!
-
-  rec_index_helper (const rec_index_helper&) = delete;
-
-  rec_index_helper& operator = (const rec_index_helper&) = delete;
-
 public:
 
   template <typename T>
   void index (const T *src, T *dest) const { do_index (src, dest, top); }
 
   template <typename T>
   void assign (const T *src, T *dest) const { do_assign (src, dest, top); }
 
@@ -670,16 +670,22 @@ public:
       {
         cext[j] = std::min (ndv(i+j), odv(i+j));
         sext[j] = sld *= odv(i+j);
         dext[j] = dld *= ndv(i+j);
       }
     cext[0] *= ld;
   }
 
+  // No copying!
+
+  rec_resize_helper (const rec_resize_helper&) = delete;
+
+  rec_resize_helper& operator = (const rec_resize_helper&) = delete;
+
   ~rec_resize_helper (void) { delete [] cext; }
 
 private:
 
   // recursive resizing
   template <typename T>
   void do_resize_fill (const T* src, T *dest, const T& rfv, int lev) const
   {
@@ -695,22 +701,16 @@ private:
         dd = dext[lev-1];
         for (k = 0; k < cext[lev]; k++)
           do_resize_fill (src + k * sd, dest + k * dd, rfv, lev - 1);
 
         std::fill_n (dest + k * dd, dext[lev] - k * dd, rfv);
       }
   }
 
-  // No copying!
-
-  rec_resize_helper (const rec_resize_helper&) = delete;
-
-  rec_resize_helper& operator = (const rec_resize_helper&) = delete;
-
 public:
 
   template <typename T>
   void resize_fill (const T* src, T *dest, const T& rfv) const
   { do_resize_fill (src, dest, rfv, n-1); }
 };
 
 template <typename T>
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -69,16 +69,22 @@ public:
 
 private:
 
   class OCTAVE_API idx_base_rep
   {
   public:
     idx_base_rep (void) : count (1), err (false) { }
 
+    // No copying!
+
+    idx_base_rep (const idx_base_rep&) = delete;
+
+    idx_base_rep& operator = (const idx_base_rep&) = delete;
+
     virtual ~idx_base_rep (void) = default;
 
     // Non-range-checking element query.
     virtual octave_idx_type xelem (octave_idx_type i) const = 0;
 
     // Range-checking element query.
     virtual octave_idx_type checkelem (octave_idx_type i) const = 0;
 
@@ -105,34 +111,32 @@ private:
     // i/o
     virtual std::ostream& print (std::ostream& os) const = 0;
 
     virtual Array<octave_idx_type> as_array (void);
 
     octave_refcount<int> count;
 
     bool err;
-
-  private:
-
-    // No copying!
-
-    idx_base_rep (const idx_base_rep&) = delete;
-
-    idx_base_rep& operator = (const idx_base_rep&) = delete;
   };
 
   // The magic colon index.
   class OCTAVE_API idx_colon_rep : public idx_base_rep
   {
   public:
     idx_colon_rep (void) { }
 
     idx_colon_rep (char c);
 
+    // No copying!
+
+    idx_colon_rep (const idx_colon_rep& idx) = delete;
+
+    idx_colon_rep& operator = (const idx_colon_rep& idx) = delete;
+
     octave_idx_type xelem (octave_idx_type i) const { return i; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type n) const { return n; }
 
     octave_idx_type extent (octave_idx_type n) const { return n; }
 
@@ -141,39 +145,37 @@ private:
     idx_base_rep *sort_uniq_clone (bool = false)
     { count++; return this; }
 
     OCTAVE_NORETURN idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type) const { return true; }
 
     std::ostream& print (std::ostream& os) const;
-
-  private:
-
-    // No copying!
-
-    idx_colon_rep (const idx_colon_rep& idx) = delete;
-
-    idx_colon_rep& operator = (const idx_colon_rep& idx) = delete;
   };
 
   // To distinguish the "direct" constructors that blindly trust the data.
   enum direct { DIRECT };
 
   // The integer range index.
   class OCTAVE_API idx_range_rep : public idx_base_rep
   {
   public:
+    idx_range_rep (void)
+      : start(0), len(0), step(1) { }
+
     idx_range_rep (octave_idx_type _start, octave_idx_type _len,
                    octave_idx_type _step, direct)
       : idx_base_rep (), start(_start), len(_len), step(_step) { }
 
-    idx_range_rep (void)
-      : start(0), len(0), step(1) { }
+    // No copying!
+
+    idx_range_rep (const idx_range_rep& idx) = delete;
+
+    idx_range_rep& operator = (const idx_range_rep& idx) = delete;
 
     // Zero-based constructor.
     idx_range_rep (octave_idx_type _start, octave_idx_type _limit,
                    octave_idx_type _step);
 
     idx_range_rep (const Range&);
 
     octave_idx_type xelem (octave_idx_type i) const
@@ -208,35 +210,34 @@ private:
     std::ostream& print (std::ostream& os) const;
 
     Range unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
 
-    // No copying!
-
-    idx_range_rep (const idx_range_rep& idx) = delete;
-
-    idx_range_rep& operator = (const idx_range_rep& idx) = delete;
-
     octave_idx_type start, len, step;
-
   };
 
   // The integer scalar index.
   class OCTAVE_API idx_scalar_rep : public idx_base_rep
   {
   public:
+    idx_scalar_rep (void)
+      : data (0) { }
+
     idx_scalar_rep (octave_idx_type i, direct)
       : data (i) { }
 
-    idx_scalar_rep (void)
-      : data (0) { }
+    // No copying!
+
+    idx_scalar_rep (const idx_scalar_rep& idx) = delete;
+
+    idx_scalar_rep& operator = (const idx_scalar_rep& idx) = delete;
 
     // Zero-based constructor.
     idx_scalar_rep (octave_idx_type i);
 
     template <typename T>
     idx_scalar_rep (T x);
 
     octave_idx_type xelem (octave_idx_type) const { return data; }
@@ -265,54 +266,53 @@ private:
     std::ostream& print (std::ostream& os) const;
 
     double unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
 
-    // No copying!
-
-    idx_scalar_rep (const idx_scalar_rep& idx) = delete;
-
-    idx_scalar_rep& operator = (const idx_scalar_rep& idx) = delete;
-
     octave_idx_type data;
-
   };
 
   // The integer vector index.
   class OCTAVE_API idx_vector_rep : public idx_base_rep
   {
   public:
+    idx_vector_rep (void)
+      : data (0), len (0), ext (0), aowner (0), orig_dims ()
+    { }
+
     // Direct constructor.
     idx_vector_rep (octave_idx_type *_data, octave_idx_type _len,
                     octave_idx_type _ext, const dim_vector& od, direct)
       : data (_data), len (_len), ext (_ext), aowner (0), orig_dims (od) { }
 
-    idx_vector_rep (void)
-      : data (0), len (0), ext (0), aowner (0), orig_dims ()
-    { }
-
     // Zero-based constructor.
     idx_vector_rep (const Array<octave_idx_type>& inda);
 
     idx_vector_rep (const Array<octave_idx_type>& inda,
                     octave_idx_type _ext, direct);
 
     template <typename T>
     idx_vector_rep (const Array<T>&);
 
     idx_vector_rep (bool);
 
     idx_vector_rep (const Array<bool>&, octave_idx_type = -1);
 
     idx_vector_rep (const Sparse<bool>&);
 
+    // No copying!
+
+    idx_vector_rep (const idx_vector_rep& idx) = delete;
+
+    idx_vector_rep& operator = (const idx_vector_rep& idx) = delete;
+
     ~idx_vector_rep (void);
 
     octave_idx_type xelem (octave_idx_type i) const { return data[i]; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const { return len; }
 
@@ -332,22 +332,16 @@ private:
     std::ostream& print (std::ostream& os) const;
 
     Array<double> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
 
-    // No copying!
-
-    idx_vector_rep (const idx_vector_rep& idx) = delete;
-
-    idx_vector_rep& operator = (const idx_vector_rep& idx) = delete;
-
     const octave_idx_type *data;
     octave_idx_type len;
     octave_idx_type ext;
 
     // This is a trick to allow user-given zero-based arrays to be used
     // as indices without copying.  If the following pointer is nonzero,
     // we do not own the data, but rather have an Array<octave_idx_type>
     // object that provides us the data.  Note that we need a pointer
@@ -358,31 +352,37 @@ private:
 
     dim_vector orig_dims;
   };
 
   // The logical mask index.
   class OCTAVE_API idx_mask_rep : public idx_base_rep
   {
   public:
+    idx_mask_rep (void)
+      : data (0), len (0), ext (0), lsti (-1), lste (-1), aowner (0),
+        orig_dims ()
+    { }
+
     // Direct constructor.
     idx_mask_rep (bool *_data, octave_idx_type _len,
                   octave_idx_type _ext, const dim_vector& od, direct)
       : data (_data), len (_len), ext (_ext), lsti (-1), lste (-1),
         aowner (0), orig_dims (od) { }
 
-    idx_mask_rep (void)
-      : data (0), len (0), ext (0), lsti (-1), lste (-1), aowner (0),
-        orig_dims ()
-    { }
-
     idx_mask_rep (bool);
 
     idx_mask_rep (const Array<bool>&, octave_idx_type = -1);
 
+    // No copying!
+
+    idx_mask_rep (const idx_mask_rep& idx) = delete;
+
+    idx_mask_rep& operator = (const idx_mask_rep& idx) = delete;
+
     ~idx_mask_rep (void);
 
     octave_idx_type xelem (octave_idx_type i) const;
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const { return len; }
 
@@ -406,22 +406,16 @@ private:
     std::ostream& print (std::ostream& os) const;
 
     Array<bool> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
 
   private:
 
-    // No copying!
-
-    idx_mask_rep (const idx_mask_rep& idx) = delete;
-
-    idx_mask_rep& operator = (const idx_mask_rep& idx) = delete;
-
     const bool *data;
     octave_idx_type len;
     octave_idx_type ext;
 
     // FIXME: I'm not sure if this is a good design.  Maybe it would be
     // better to employ some sort of generalized iteration scheme.
     mutable octave_idx_type lsti;
     mutable octave_idx_type lste;
diff --git a/liboctave/numeric/oct-fftw.h b/liboctave/numeric/oct-fftw.h
--- a/liboctave/numeric/oct-fftw.h
+++ b/liboctave/numeric/oct-fftw.h
@@ -35,16 +35,22 @@ OCTAVE_API
 octave_fftw_planner
 {
 protected:
 
   octave_fftw_planner (void);
 
 public:
 
+  // No copying!
+
+  octave_fftw_planner (const octave_fftw_planner&) = delete;
+
+  octave_fftw_planner& operator = (const octave_fftw_planner&) = delete;
+
   ~octave_fftw_planner (void);
 
   enum FftwMethod
   {
     UNKNOWN = -1,
     ESTIMATE,
     MEASURE,
     PATIENT,
@@ -95,22 +101,16 @@ public:
 
   static int threads (void)
   {
     return instance_ok () ? instance->nthreads : 0;
   }
 
 private:
 
-  // No copying!
-
-  octave_fftw_planner (const octave_fftw_planner&) = delete;
-
-  octave_fftw_planner& operator = (const octave_fftw_planner&) = delete;
-
   static octave_fftw_planner *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   void *
   do_create_plan (int dir, const int rank, const dim_vector dims,
                   octave_idx_type howmany, octave_idx_type stride,
                   octave_idx_type dist, const Complex *in,
@@ -180,16 +180,23 @@ OCTAVE_API
 octave_float_fftw_planner
 {
 protected:
 
   octave_float_fftw_planner (void);
 
 public:
 
+  // No copying!
+
+  octave_float_fftw_planner (const octave_float_fftw_planner&) = delete;
+
+  octave_float_fftw_planner&
+  operator = (const octave_float_fftw_planner&) = delete;
+
   ~octave_float_fftw_planner (void);
 
   enum FftwMethod
   {
     UNKNOWN = -1,
     ESTIMATE,
     MEASURE,
     PATIENT,
@@ -240,22 +247,16 @@ public:
 
   static int threads (void)
   {
     return instance_ok () ? instance->nthreads : 0;
   }
 
 private:
 
-  // No copying!
-
-  octave_float_fftw_planner (const octave_float_fftw_planner&) = delete;
-
-  octave_float_fftw_planner& operator = (const octave_float_fftw_planner&) = delete;
-
   static octave_float_fftw_planner *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   void *
   do_create_plan (int dir, const int rank, const dim_vector dims,
                   octave_idx_type howmany, octave_idx_type stride,
                   octave_idx_type dist, const FloatComplex *in,
@@ -321,16 +322,24 @@ private:
 };
 
 class
 OCTAVE_API
 octave_fftw
 {
 public:
 
+  octave_fftw (void) = delete;
+
+  // No copying.
+
+  octave_fftw (const octave_fftw&) = delete;
+
+  octave_fftw& operator = (const octave_fftw&) = delete;
+
   static int fft (const double *in, Complex *out, size_t npts,
                   size_t nsamples = 1, octave_idx_type stride = 1,
                   octave_idx_type dist = -1);
   static int fft (const Complex *in, Complex *out, size_t npts,
                   size_t nsamples = 1, octave_idx_type stride = 1,
                   octave_idx_type dist = -1);
   static int ifft (const Complex *in, Complex *out, size_t npts,
                    size_t nsamples = 1, octave_idx_type stride = 1,
@@ -352,20 +361,15 @@ public:
                    size_t nsamples = 1, octave_idx_type stride = 1,
                    octave_idx_type dist = -1);
 
   static int fftNd (const float*, FloatComplex*, const int, const dim_vector &);
   static int fftNd (const FloatComplex*, FloatComplex*, const int,
                     const dim_vector &);
   static int ifftNd (const FloatComplex*, FloatComplex*, const int,
                      const dim_vector &);
-
-private:
-  octave_fftw (void);
-  octave_fftw (const octave_fftw&);
-  octave_fftw& operator = (const octave_fftw&);
 };
 
 extern OCTAVE_API std::string octave_fftw_version (void);
 extern OCTAVE_API std::string octave_fftwf_version (void);
 
 #endif
 
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -64,16 +64,22 @@ namespace octave
         : count (1), is_pd (false), minor_p (0), perms (), cond (0)
 #if defined (HAVE_CHOLMOD)
         , Lsparse (0), Common ()
 #endif
       {
         info = init (a, natural, force);
       }
 
+      // No copying!
+
+      sparse_chol_rep (const sparse_chol_rep&) = delete;
+
+      sparse_chol_rep& operator = (const sparse_chol_rep&) = delete;
+
       ~sparse_chol_rep (void)
       {
 #if defined (HAVE_CHOLMOD)
         if (Lsparse)
           CHOLMOD_NAME (free_sparse) (&Lsparse, &Common);
 
         CHOLMOD_NAME(finish) (&Common);
 #endif
@@ -120,22 +126,16 @@ namespace octave
       cholmod_sparse *Lsparse;
 
       cholmod_common Common;
 
       void drop_zeros (const cholmod_sparse *S);
 #endif
 
       octave_idx_type init (const chol_type& a, bool natural, bool force);
-
-      // No copying!
-
-      sparse_chol_rep (const sparse_chol_rep&) = delete;
-
-      sparse_chol_rep& operator = (const sparse_chol_rep&) = delete;
     };
 
 #if defined (HAVE_CHOLMOD)
 
     // Can't use CHOLMOD_NAME(drop)(0.0, S, cm) because it doesn't treat
     // complex matrices.
 
     template <typename chol_type>
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -70,16 +70,22 @@ namespace octave
 
     template <typename SPARSE_T>
     class sparse_qr<SPARSE_T>::sparse_qr_rep
     {
     public:
 
       sparse_qr_rep (const SPARSE_T& a, int order);
 
+      // No copying!
+
+      sparse_qr_rep (const sparse_qr_rep&) = delete;
+
+      sparse_qr_rep& operator = (const sparse_qr_rep&) = delete;
+
       ~sparse_qr_rep (void);
 
       bool ok (void) const
       {
 #if defined (HAVE_CXSPARSE)
         return (N && S);
 #else
         return false;
@@ -110,24 +116,16 @@ namespace octave
 
       template <typename RHS_T, typename RET_T>
       RET_T
       tall_solve (const RHS_T& b, octave_idx_type& info) const;
 
       template <typename RHS_T, typename RET_T>
       RET_T
       wide_solve (const RHS_T& b, octave_idx_type& info) const;
-
-    private:
-
-      // No copying!
-
-      sparse_qr_rep (const sparse_qr_rep&) = delete;
-
-      sparse_qr_rep& operator = (const sparse_qr_rep&) = delete;
     };
 
     template <typename SPARSE_T>
     ColumnVector
     sparse_qr<SPARSE_T>::sparse_qr_rep::Pinv (void) const
     {
 #if defined (HAVE_CXSPARSE)
 
diff --git a/liboctave/system/file-ops.h b/liboctave/system/file-ops.h
--- a/liboctave/system/file-ops.h
+++ b/liboctave/system/file-ops.h
@@ -52,16 +52,22 @@ namespace octave
           m_dir_sep_char (dir_sep_char_arg),
           m_dir_sep_str (dir_sep_str_arg),
           m_dir_sep_chars (dir_sep_chars_arg) { }
 
     public:
 
       typedef std::string (*tilde_expansion_hook) (const std::string&);
 
+      // No copying!
+
+      file_ops (const file_ops&) = delete;
+
+      file_ops& operator = (const file_ops&) = delete;
+
       static tilde_expansion_hook tilde_expansion_preexpansion_hook;
 
       static tilde_expansion_hook tilde_expansion_failure_hook;
 
       static string_vector tilde_additional_prefixes;
 
       static string_vector tilde_additional_suffixes;
 
@@ -126,22 +132,16 @@ namespace octave
       static std::string native_separator_path (const std::string& path);
 
     private:
 
       static file_ops *instance;
 
       static void cleanup_instance (void) { delete instance; instance = 0; }
 
-      // No copying!
-
-      file_ops (const file_ops&) = delete;
-
-      file_ops& operator = (const file_ops&) = delete;
-
       static bool instance_ok (void);
 
       char m_dev_sep_char;
 
       char m_dir_sep_char;
       std::string m_dir_sep_str;
       std::string m_dir_sep_chars;
     };
diff --git a/liboctave/system/mach-info.h b/liboctave/system/mach-info.h
--- a/liboctave/system/mach-info.h
+++ b/liboctave/system/mach-info.h
@@ -34,16 +34,22 @@ namespace octave
   mach_info
   {
   protected:
 
     mach_info (void);
 
   public:
 
+    // No copying!
+
+    mach_info (const mach_info&) = delete;
+
+    mach_info& operator = (const mach_info&) = delete;
+
     enum float_format
     {
       flt_fmt_unknown,
       flt_fmt_ieee_little_endian,
       flt_fmt_ieee_big_endian,
     };
 
     static bool instance_ok (void);
@@ -64,22 +70,16 @@ namespace octave
 
     static void cleanup_instance (void) { delete instance; instance = 0; }
 
     // The floating point format for the current machine.
     mutable float_format native_float_fmt;
 
     // TRUE if the byte order on this system is big endian.
     mutable bool big_chief;
-
-    // No copying!
-
-    mach_info (const mach_info&) = delete;
-
-    mach_info& operator = (const mach_info&) = delete;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::mach_info' instead")
 typedef octave::mach_info oct_mach_info;
 
diff --git a/liboctave/system/oct-env.h b/liboctave/system/oct-env.h
--- a/liboctave/system/oct-env.h
+++ b/liboctave/system/oct-env.h
@@ -36,16 +36,22 @@ namespace octave
     env
     {
     protected:
 
       env (void);
 
     public:
 
+      // No copying!
+
+      env (const env&) = delete;
+
+      env& operator = (const env&) = delete;
+
       static std::string polite_directory_format (const std::string& name);
 
       static bool absolute_pathname (const std::string& s);
 
       static bool rooted_relative_pathname (const std::string& s);
 
       static std::string base_pathname (const std::string& s);
 
@@ -111,22 +117,16 @@ namespace octave
       void do_set_program_name (const std::string& s) const;
 
       void pathname_backup (std::string& path, int n) const;
 
       void error (int) const;
 
       void error (const std::string&) const;
 
-      // No copying!
-
-      env (const env&) = delete;
-
-      env& operator = (const env&) = delete;
-
       // The real thing.
       static env *instance;
 
       static void cleanup_instance (void) { delete instance; instance = 0; }
 
       // TRUE means follow symbolic links that point to directories just
       // as if they are real directories.
       bool follow_symbolic_links;
diff --git a/liboctave/util/action-container.h b/liboctave/util/action-container.h
--- a/liboctave/util/action-container.h
+++ b/liboctave/util/action-container.h
@@ -37,206 +37,228 @@ action_container
 {
 public:
 
   // A generic unwind_protect element.  Knows how to run itself and
   // discard itself.  Also, contains a pointer to the next element.
   class elem
   {
   public:
-    elem (void) { }
-
-    virtual void run (void) { }
-
-    virtual ~elem (void) = default;
 
     friend class action_container;
 
-  private:
+    elem (void) { }
 
     // No copying!
 
     elem (const elem&) = delete;
 
     elem& operator = (const elem&) = delete;
+
+    virtual ~elem (void) = default;
+
+    virtual void run (void) { }
   };
 
   // An element that merely runs a void (*)(void) function.
 
   class fcn_elem : public elem
   {
   public:
+
     fcn_elem (void (*fptr) (void))
       : e_fptr (fptr) { }
 
     void run (void) { e_fptr (); }
 
   private:
+
     void (*e_fptr) (void);
   };
 
   // An element that stores a variable of type T along with a void (*) (T)
   // function pointer, and calls the function with the parameter.
 
   template <typename T>
   class fcn_arg_elem : public elem
   {
   public:
+
     fcn_arg_elem (void (*fcn) (T), T arg)
       : e_fcn (fcn), e_arg (arg) { }
 
-    void run (void) { e_fcn (e_arg); }
-
-  private:
-
     // No copying!
 
     fcn_arg_elem (const fcn_arg_elem&) = delete;
 
     fcn_arg_elem& operator = (const fcn_arg_elem&) = delete;
 
+    void run (void) { e_fcn (e_arg); }
+
+  private:
+
     void (*e_fcn) (T);
+
     T e_arg;
   };
 
   // An element that stores a variable of type T along with a
   // void (*) (const T&) function pointer, and calls the function with
   // the parameter.
 
   template <typename T>
   class fcn_crefarg_elem : public elem
   {
   public:
+
     fcn_crefarg_elem (void (*fcn) (const T&), const T& arg)
       : e_fcn (fcn), e_arg (arg) { }
 
     void run (void) { e_fcn (e_arg); }
 
   private:
+
     void (*e_fcn) (const T&);
+
     T e_arg;
   };
 
   // An element for calling a member function.
 
   template <typename T>
   class method_elem : public elem
   {
   public:
+
     method_elem (T *obj, void (T::*method) (void))
       : e_obj (obj), e_method (method) { }
 
+    // No copying!
+
+    method_elem (const method_elem&) = delete;
+
+    method_elem operator = (const method_elem&) = delete;
+
     void run (void) { (e_obj->*e_method) (); }
 
   private:
 
     T *e_obj;
+
     void (T::*e_method) (void);
-
-    // No copying!
-
-    method_elem (const method_elem&) = delete;
-
-    method_elem operator = (const method_elem&) = delete;
   };
 
   // An element for calling a member function with a single argument
 
   template <typename T, typename A>
   class method_arg_elem : public elem
   {
   public:
+
     method_arg_elem (T *obj, void (T::*method) (A), A arg)
       : e_obj (obj), e_method (method), e_arg (arg) { }
 
+    // No copying!
+
+    method_arg_elem (const method_arg_elem&) = delete;
+
+    method_arg_elem operator = (const method_arg_elem&) = delete;
+
     void run (void) { (e_obj->*e_method) (e_arg); }
 
   private:
 
     T *e_obj;
-    void (T::*e_method) (A);
-    A e_arg;
 
-    // No copying!
+    void (T::*e_method) (A);
 
-    method_arg_elem (const method_arg_elem&) = delete;
-
-    method_arg_elem operator = (const method_arg_elem&) = delete;
+    A e_arg;
   };
 
   // An element for calling a member function with a single argument
 
   template <typename T, typename A>
   class method_crefarg_elem : public elem
   {
   public:
+
     method_crefarg_elem (T *obj, void (T::*method) (const A&), const A& arg)
       : e_obj (obj), e_method (method), e_arg (arg) { }
 
+    // No copying!
+
+    method_crefarg_elem (const method_crefarg_elem&) = delete;
+
+    method_crefarg_elem operator = (const method_crefarg_elem&) = delete;
+
     void run (void) { (e_obj->*e_method) (e_arg); }
 
   private:
 
     T *e_obj;
-    void (T::*e_method) (const A&);
-    A e_arg;
 
-    // No copying!
+    void (T::*e_method) (const A&);
 
-    method_crefarg_elem (const method_crefarg_elem&) = delete;
-
-    method_crefarg_elem operator = (const method_crefarg_elem&) = delete;
+    A e_arg;
   };
 
   // An element that stores arbitrary variable, and restores it.
 
   template <typename T>
   class restore_var_elem : public elem
   {
   public:
+
     restore_var_elem (T& ref, const T& val)
       : e_ptr (&ref), e_val (val) { }
 
-    void run (void) { *e_ptr = e_val; }
-
-  private:
-
     // No copying!
 
     restore_var_elem (const restore_var_elem&) = delete;
 
     restore_var_elem& operator = (const restore_var_elem&) = delete;
 
+    void run (void) { *e_ptr = e_val; }
+
+  private:
+
     T *e_ptr, e_val;
   };
 
   // Deletes a class allocated using new.
 
   template <typename T>
   class delete_ptr_elem : public elem
   {
   public:
+
     delete_ptr_elem (T *ptr)
       : e_ptr (ptr) { }
 
+    // No copying!
+
+    delete_ptr_elem (const delete_ptr_elem&) = delete;
+
+    delete_ptr_elem operator = (const delete_ptr_elem&) = delete;
+
     void run (void) { delete e_ptr; }
 
   private:
 
     T *e_ptr;
-
-    // No copying!
-
-    delete_ptr_elem (const delete_ptr_elem&) = delete;
-
-    delete_ptr_elem operator = (const delete_ptr_elem&) = delete;
   };
 
   action_container (void) { }
 
+  // No copying!
+
+  action_container (const action_container&) = delete;
+
+  action_container& operator = (const action_container&) = delete;
+
   virtual ~action_container (void) = default;
 
   virtual void add (elem *new_elem) = 0;
 
   // Call to void func (void).
   void add_fcn (void (*fcn) (void))
   {
     add (new fcn_elem (fcn));
@@ -325,20 +347,12 @@ public:
       discard_first ();
   }
 
   void discard (void) { discard (size ()); }
 
   virtual size_t size (void) const = 0;
 
   bool empty (void) const { return size () == 0; }
-
-private:
-
-  // No copying!
-
-  action_container (const action_container&) = delete;
-
-  action_container& operator = (const action_container&) = delete;
 };
 
 #endif
 
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -918,16 +918,22 @@ namespace octave
   class
   default_command_editor : public command_editor
   {
   public:
 
     default_command_editor (void)
       : command_editor (), input_stream (stdin), output_stream (stdout) { }
 
+    // No copying!
+
+    default_command_editor (const default_command_editor&) = delete;
+
+    default_command_editor& operator = (const default_command_editor&) = delete;
+
     ~default_command_editor (void) = default;
 
     std::string do_readline (const std::string& prompt, bool& eof);
 
     void do_set_input_stream (FILE *f);
 
     FILE *do_get_input_stream (void);
 
@@ -953,22 +959,16 @@ namespace octave
 
     void do_accept_line (void);
 
   private:
 
     FILE *input_stream;
 
     FILE *output_stream;
-
-    // No copying!
-
-    default_command_editor (const default_command_editor&) = delete;
-
-    default_command_editor& operator = (const default_command_editor&) = delete;
   };
 
   std::string
   default_command_editor::do_readline (const std::string& prompt, bool& eof)
   {
     std::fputs (prompt.c_str (), output_stream);
     std::fflush (output_stream);
 
diff --git a/liboctave/util/cmd-edit.h b/liboctave/util/cmd-edit.h
--- a/liboctave/util/cmd-edit.h
+++ b/liboctave/util/cmd-edit.h
@@ -58,16 +58,22 @@ namespace octave
     typedef std::string (*quoting_fcn) (const std::string&, int, char);
 
     typedef std::string (*dequoting_fcn) (const std::string&, int);
 
     typedef int (*char_is_quoted_fcn) (const std::string&, int);
 
     typedef void (*user_accept_line_fcn) (const std::string&);
 
+    // No copying!
+
+    command_editor (const command_editor&) = delete;
+
+    command_editor& operator = (const command_editor&) = delete;
+
     virtual ~command_editor (void) = default;
 
     static void set_name (const std::string& n);
 
     static std::string readline (const std::string& prompt);
 
     static std::string readline (const std::string& prompt, bool& eof);
 
@@ -188,22 +194,16 @@ namespace octave
     static void force_default_editor (void);
 
     static void set_initial_input (const std::string& text);
 
     static int insert_initial_input (void);
 
   private:
 
-    // No copying!
-
-    command_editor (const command_editor&) = delete;
-
-    command_editor& operator = (const command_editor&) = delete;
-
     static bool instance_ok (void);
 
     static void make_command_editor (void);
 
     static int startup_handler (void);
 
     static int pre_input_handler (void);
 
diff --git a/liboctave/util/cmd-hist.h b/liboctave/util/cmd-hist.h
--- a/liboctave/util/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -38,16 +38,22 @@ namespace octave
   protected:
 
     command_history (void)
       : initialized (false), ignoring_additions (false), history_control (0),
         lines_in_file (0), lines_this_session (0), xfile (), xsize (-1) { }
 
   public:
 
+    // No copying!
+
+    command_history (const command_history&) = delete;
+
+    command_history& operator = (const command_history&) = delete;
+
     virtual ~command_history (void) = default;
 
     static void initialize (bool, const std::string&, int, const std::string&);
 
     static bool is_initialized (void);
 
     static void set_file (const std::string&);
 
@@ -114,22 +120,16 @@ namespace octave
     static std::string get_entry (int);
 
     static void replace_entry (int, const std::string&);
 
     static void clean_up_and_save (const std::string& = "", int = -1);
 
   private:
 
-    // No copying!
-
-    command_history (const command_history&) = delete;
-
-    command_history& operator = (const command_history&) = delete;
-
     static bool instance_ok (void);
 
     static void make_command_history (void);
 
     // The real thing.
     static command_history *instance;
 
     static void cleanup_instance (void) { delete instance; instance = 0; }
diff --git a/liboctave/util/oct-locbuf.h b/liboctave/util/oct-locbuf.h
--- a/liboctave/util/oct-locbuf.h
+++ b/liboctave/util/oct-locbuf.h
@@ -38,28 +38,29 @@ class octave_local_buffer
 public:
   octave_local_buffer (size_t size)
     : data (0)
   {
     if (size)
       data = new T [size];
   }
 
+  // No copying!
+
+  octave_local_buffer (const octave_local_buffer&) = delete;
+
+  octave_local_buffer& operator = (const octave_local_buffer&) = delete;
+
   ~octave_local_buffer (void) { delete [] data; }
 
   operator T *() const { return data; }
 
 private:
+
   T *data;
-
-  // No copying!
-
-  octave_local_buffer (const octave_local_buffer&) = delete;
-
-  octave_local_buffer& operator = (const octave_local_buffer&) = delete;
 };
 
 // For buffers of POD types, we'll be smarter.  There is one thing
 // that differentiates a local buffer from a dynamic array - the local
 // buffers, if not manipulated improperly, have a FIFO semantics,
 // meaning that if buffer B is allocated after buffer A, B *must* be
 // deallocated before A.  This is *guaranteed* if you use local buffer
 // exclusively through the OCTAVE_LOCAL_BUFFER macro, because the C++
@@ -71,16 +72,22 @@ private:
 // deallocating the chunk.
 
 class octave_chunk_buffer
 {
 public:
 
   OCTAVE_API octave_chunk_buffer (size_t size);
 
+  // No copying!
+
+  octave_chunk_buffer (const octave_chunk_buffer&) = delete;
+
+  octave_chunk_buffer& operator = (const octave_chunk_buffer&) = delete;
+
   OCTAVE_API virtual ~octave_chunk_buffer (void);
 
   char *data (void) const { return dat; }
 
   static OCTAVE_API void clear (void);
 
 private:
 
@@ -100,22 +107,16 @@ private:
   // The number of active allocations.
   static size_t active;
 
   // Pointer to the current chunk.
   char *cnk;
 
   // Pointer to the beginning of the most recent allocation.
   char *dat;
-
-  // No copying!
-
-  octave_chunk_buffer (const octave_chunk_buffer&) = delete;
-
-  octave_chunk_buffer& operator = (const octave_chunk_buffer&) = delete;
 };
 
 // This specializes octave_local_buffer to use the chunked buffer
 // mechanism for POD types.
 #define SPECIALIZE_POD_BUFFER(TYPE)                             \
   template <>                                                   \
   class octave_local_buffer<TYPE> : private octave_chunk_buffer \
   {                                                             \
diff --git a/liboctave/util/oct-mutex.h b/liboctave/util/oct-mutex.h
--- a/liboctave/util/oct-mutex.h
+++ b/liboctave/util/oct-mutex.h
@@ -112,36 +112,36 @@ public:
       {
         mutex.lock ();
         lock_result = true;
       }
     else
       lock_result = mutex.try_lock ();
   }
 
+  // No copying.
+
+  octave_autolock (const octave_autolock&) = delete;
+
+  octave_autolock& operator = (const octave_autolock&) = delete;
+
   ~octave_autolock (void)
   {
     if (lock_result)
       mutex.unlock ();
   }
 
   bool ok (void) const { return lock_result; }
 
   operator bool (void) const { return ok (); }
 
 private:
 
-  // No copying.
-
-  octave_autolock (const octave_autolock&) = delete;
+  octave_mutex mutex;
 
-  octave_autolock& operator = (const octave_autolock&) = delete;
-
-private:
-  octave_mutex mutex;
   bool lock_result;
 };
 
 class
 OCTAVE_API
 octave_thread
 {
 public:
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -159,35 +159,35 @@ namespace octave
 
   class
   octave_dlopen_shlib : public dynamic_library::dynlib_rep
   {
   public:
 
     octave_dlopen_shlib (const std::string& f);
 
+    // No copying!
+
+    octave_dlopen_shlib (const octave_dlopen_shlib&) = delete;
+
+    octave_dlopen_shlib& operator = (const octave_dlopen_shlib&) = delete;
+
     ~octave_dlopen_shlib (void);
 
     void *search (const std::string& name,
                   dynamic_library::name_mangler mangler = 0);
 
     // FIXME: this is possibly redundant because failure to open a library will
     // normally throw an exception, avoiding the construction of an invalid
     // library.  Leave it here for possible future use.
 
     bool is_open (void) const { return (library != 0); }
 
   private:
 
-    // No copying!
-
-    octave_dlopen_shlib (const octave_dlopen_shlib&) = delete;
-
-    octave_dlopen_shlib& operator = (const octave_dlopen_shlib&) = delete;
-
     void *library;
   };
 
   octave_dlopen_shlib::octave_dlopen_shlib (const std::string& f)
     : dynamic_library::dynlib_rep (f), library (0)
   {
     int flags = 0;
 
@@ -250,31 +250,31 @@ namespace octave
 
   class
   octave_shl_load_shlib : public dynamic_library::dynlib_rep
   {
   public:
 
     octave_shl_load_shlib (const std::string& f);
 
+    // No copying!
+
+    octave_shl_load_shlib (const octave_shl_load_shlib&) = delete;
+
+    octave_shl_load_shlib& operator = (const octave_shl_load_shlib&) = delete;
+
     ~octave_shl_load_shlib (void);
 
     void *search (const std::string& name,
                   dynamic_library::name_mangler mangler = 0);
 
     bool is_open (void) const { return (library != 0); }
 
   private:
 
-    // No copying!
-
-    octave_shl_load_shlib (const octave_shl_load_shlib&) = delete;
-
-    octave_shl_load_shlib& operator = (const octave_shl_load_shlib&) = delete;
-
     shl_t library;
   };
 
   octave_shl_load_shlib::octave_shl_load_shlib (const std::string& f)
     : dynamic_library::dynlib_rep (f), library (0)
   {
     file = f;
 
@@ -318,31 +318,31 @@ namespace octave
 
   class
   octave_w32_shlib: public dynamic_library::dynlib_rep
   {
   public:
 
     octave_w32_shlib (const std::string& f);
 
+    // No copying!
+
+    octave_w32_shlib (const octave_w32_shlib&) = delete;
+
+    octave_w32_shlib& operator = (const octave_w32_shlib&) = delete;
+
     ~octave_w32_shlib (void);
 
     void *search (const std::string& name,
                   dynamic_library::name_mangler mangler = 0);
 
     bool is_open (void) const { return (handle != 0); }
 
   private:
 
-    // No copying!
-
-    octave_w32_shlib (const octave_w32_shlib&) = delete;
-
-    octave_w32_shlib& operator = (const octave_w32_shlib&) = delete;
-
     HINSTANCE handle;
   };
 
   static void
   set_dll_directory (const std::string& dir = "")
   {
     SetDllDirectory (dir.empty () ? 0 : dir.c_str ());
   }
@@ -417,35 +417,35 @@ namespace octave
 
   class
   octave_dyld_shlib : public dynamic_library::dynlib_rep
   {
   public:
 
     octave_dyld_shlib (void);
 
+    // No copying!
+
+    octave_dyld_shlib (const octave_dyld_shlib&) = delete;
+
+    octave_dyld_shlib& operator = (const octave_dyld_shlib&) = delete;
+
     ~octave_dyld_shlib (void);
 
     void open (const std::string& f);
 
     void *search (const std::string& name,
                   dynamic_library::name_mangler mangler = 0);
 
     void close (dynamic_library::close_hook cl_hook = 0);
 
     bool is_open (void) const {return (handle != 0); }
 
   private:
 
-    // No copying!
-
-    octave_dyld_shlib (const octave_dyld_shlib&) = delete;
-
-    octave_dyld_shlib& operator = (const octave_dyld_shlib&) = delete;
-
     NSObjectFileImage img;
     NSModule handle;
   };
 
   octave_dyld_shlib::octave_dyld_shlib (const std::string& f)
     : dynamic_library::dynlib_rep (f), handle (0)
   {
     int returnCode = NSCreateObjectFileImageFromFile (file.c_str (), &img);
diff --git a/liboctave/util/oct-sort.h b/liboctave/util/oct-sort.h
--- a/liboctave/util/oct-sort.h
+++ b/liboctave/util/oct-sort.h
@@ -112,16 +112,22 @@ public:
 
   typedef bool (*compare_fcn_type) (typename ref_param<T>::type,
                                     typename ref_param<T>::type);
 
   octave_sort (void);
 
   octave_sort (compare_fcn_type);
 
+  // No copying!
+
+  octave_sort (const octave_sort&) = delete;
+
+  octave_sort& operator = (const octave_sort&) = delete;
+
   ~octave_sort (void);
 
   void set_compare (compare_fcn_type comp) { compare = comp; }
 
   void set_compare (sortmode mode);
 
   // Sort an array in-place.
   void sort (T *data, octave_idx_type nel);
@@ -183,16 +189,22 @@ private:
   };
 
   struct MergeState
   {
     MergeState (void)
       : min_gallop (), a (0), ia (0), alloced (0), n (0)
     { reset (); }
 
+    // No copying!
+
+    MergeState (const MergeState&) = delete;
+
+    MergeState& operator = (const MergeState&) = delete;
+
     ~MergeState (void)
     { delete [] a; delete [] ia; }
 
     void reset (void)
     { min_gallop = MIN_GALLOP; n = 0; }
 
     void getmem (octave_idx_type need);
 
@@ -215,22 +227,16 @@ private:
     // true (so long as the indices are in bounds) that
     //
     //   pending[i].base + pending[i].len == pending[i+1].base
     //
     // so we could cut the storage for this, but it's a minor amount,
     // and keeping all the info explicit simplifies the code.
     octave_idx_type n;
     struct s_slice pending[MAX_MERGE_PENDING];
-
-    // No copying!
-
-    MergeState (const MergeState&) = delete;
-
-    MergeState& operator = (const MergeState&) = delete;
   };
 
   compare_fcn_type compare;
 
   MergeState *ms;
 
   template <typename Comp>
   void binarysort (T *data, octave_idx_type nel,
@@ -323,22 +329,16 @@ private:
   void lookup_sorted (const T *data, octave_idx_type nel,
                       const T* values, octave_idx_type nvalues,
                       octave_idx_type *idx, bool rev, Comp comp);
 
   template <typename Comp>
   void nth_element (T *data, octave_idx_type nel,
                     octave_idx_type lo, octave_idx_type up,
                     Comp comp);
-
-  // No copying!
-
-  octave_sort (const octave_sort&) = delete;
-
-  octave_sort& operator = (const octave_sort&) = delete;
 };
 
 template <typename T>
 class
 vec_index
 {
 public:
   T vec;
diff --git a/liboctave/util/pathsearch.h b/liboctave/util/pathsearch.h
--- a/liboctave/util/pathsearch.h
+++ b/liboctave/util/pathsearch.h
@@ -139,16 +139,22 @@ namespace octave
     // we can ensure proper initialization.
 
     class OCTAVE_API static_members
     {
     public:
 
       static_members (void);
 
+      // No copying!
+
+      static_members (const static_members&) = delete;
+
+      static_members& operator = (const static_members&) = delete;
+
       static char path_sep_char (void)
       {
         return instance_ok () ? instance->xpath_sep_char : 0;
       }
 
       static void path_sep_char (char c)
       {
         if (instance_ok ())
@@ -166,22 +172,16 @@ namespace octave
     private:
 
       static static_members *instance;
 
       static void cleanup_instance (void) { delete instance; instance = 0; }
 
       static bool instance_ok (void);
 
-      // No copying!
-
-      static_members (const static_members&) = delete;
-
-      static_members& operator = (const static_members&) = delete;
-
       char xpath_sep_char;
 
       std::string xpath_sep_str;
     };
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
diff --git a/liboctave/util/singleton-cleanup.h b/liboctave/util/singleton-cleanup.h
--- a/liboctave/util/singleton-cleanup.h
+++ b/liboctave/util/singleton-cleanup.h
@@ -34,16 +34,22 @@ singleton_cleanup_list
 protected:
 
   singleton_cleanup_list (void) : fcn_list () { }
 
 public:
 
   typedef void (*fptr) (void);
 
+  // No copying!
+
+  singleton_cleanup_list (const singleton_cleanup_list&) = delete;
+
+  singleton_cleanup_list& operator = (const singleton_cleanup_list&) = delete;
+
   ~singleton_cleanup_list (void);
 
   static void add (fptr f)
   {
     if (instance_ok ())
       instance->do_add (f);
   }
 
@@ -58,18 +64,12 @@ private:
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   std::set<fptr> fcn_list;
 
   void do_add (fptr f)
   {
     fcn_list.insert (f);
   }
-
-  // No copying!
-
-  singleton_cleanup_list (const singleton_cleanup_list&) = delete;
-
-  singleton_cleanup_list& operator = (const singleton_cleanup_list&) = delete;
 };
 
 #endif
 
diff --git a/liboctave/util/unwind-prot.h b/liboctave/util/unwind-prot.h
--- a/liboctave/util/unwind-prot.h
+++ b/liboctave/util/unwind-prot.h
@@ -38,16 +38,22 @@ namespace octave
   class
   OCTAVE_API
   unwind_protect : public action_container
   {
   public:
 
     unwind_protect (void) : lifo () { }
 
+    // No copying!
+
+    unwind_protect (const unwind_protect&) = delete;
+
+    unwind_protect& operator = (const unwind_protect&) = delete;
+
     // Destructor should not raise an exception, so all actions
     // registered should be exception-safe.  If you're not sure, see
     // unwind_protect_safe.
 
     ~unwind_protect (void) { run (); }
 
     virtual void add (elem *new_elem)
     {
@@ -95,24 +101,16 @@ namespace octave
     OCTAVE_DEPRECATED ("use 'discard' instead")
     void discard_top (int num) { discard (num); }
 
     size_t size (void) const { return lifo.size (); }
 
   protected:
 
     std::stack<elem *> lifo;
-
-  private:
-
-    // No copying!
-
-    unwind_protect (const unwind_protect&) = delete;
-
-    unwind_protect& operator = (const unwind_protect&) = delete;
   };
 
   // Like unwind_protect, but this one will guard against the possibility
   // of seeing an exception (or interrupt) in the cleanup actions.
   // Not that we can do much about it, but at least we won't crash.
 
   class
   OCTAVE_API
@@ -121,38 +119,36 @@ namespace octave
   private:
 
     void warn_unhandled_exception (void) const;
 
   public:
 
     unwind_protect_safe (void) : unwind_protect () { }
 
+    // No copying!
+
+    unwind_protect_safe (const unwind_protect_safe&) = delete;
+
+    unwind_protect_safe& operator = (const unwind_protect_safe&) = delete;
+
     ~unwind_protect_safe (void)
     {
       while (! empty ())
         {
           try
             {
               run_first ();
             }
           catch (...) // Yes, the black hole.  Remember we're in a destructor.
             {
               warn_unhandled_exception ();
             }
         }
     }
-
-  private:
-
-    // No copying!
-
-    unwind_protect_safe (const unwind_protect_safe&) = delete;
-
-    unwind_protect_safe& operator = (const unwind_protect_safe&) = delete;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::unwind_protect' instead")
 typedef octave::unwind_protect unwind_protect;
 
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -327,16 +327,22 @@ namespace octave
 
       // Restore the default HTTP request method to GET after setting
       // NOBODY to true (in the init method) and back to false (above).
       // This is needed for backward compatibility with versions of
       // libcurl < 7.18.2.
       SETOPT (CURLOPT_HTTPGET, 1);
     }
 
+    // No copying!
+
+    curl_transfer (const curl_transfer&) = delete;
+
+    curl_transfer& operator = (const curl_transfer&) = delete;
+
     ~curl_transfer (void)
     {
       if (curl)
         curl_easy_cleanup (curl);
     }
 
     void perform (void)
     {
@@ -663,22 +669,16 @@ namespace octave
     // To be compatible with any version of cURL, the caller must keep a
     // copy of all string parameters associated with a CURL handle until
     // the handle is released.  The curl_handle::curl_handle_rep class
     // contains the pointer to the CURL handle and so is the best
     // candidate for storing the strings as well. (bug #36717)
     std::string url;
     std::string userpwd;
 
-    // No copying!
-
-    curl_transfer (const curl_transfer&) = delete;
-
-    curl_transfer& operator = (const curl_transfer&) = delete;
-
     void init (const std::string& user, const std::string& passwd,
                std::istream& is, std::ostream& os)
     {
       // No data transfer by default
       SETOPT (CURLOPT_NOBODY, 1);
 
       // Set the username and password
       userpwd = user;
diff --git a/liboctave/util/url-transfer.h b/liboctave/util/url-transfer.h
--- a/liboctave/util/url-transfer.h
+++ b/liboctave/util/url-transfer.h
@@ -65,16 +65,22 @@ namespace octave
         ascii_mode (false), ok (true), errmsg (), curr_istream (&std::cin),
         curr_ostream (&os) { }
 
     base_url_transfer (const std::string& url, std::ostream& os)
       : count (1), host_or_url (url), valid (false), ftp (false),
         ascii_mode (false), ok (true), errmsg (),
         curr_istream (&std::cin), curr_ostream (&os) { }
 
+    // No copying!
+
+    base_url_transfer (const base_url_transfer&) = delete;
+
+    base_url_transfer& operator = (const base_url_transfer&) = delete;
+
     virtual ~base_url_transfer (void) = default;
 
     bool is_valid (void) const { return valid; }
 
     bool good (void) const { return valid && ok; }
 
     virtual void perform (void) { }
 
@@ -148,24 +154,16 @@ namespace octave
     std::string host_or_url;
     bool valid;
     bool ftp;
     bool ascii_mode;
     bool ok;
     std::string errmsg;
     std::istream *curr_istream;
     std::ostream *curr_ostream;
-
-  private:
-
-    // No copying!
-
-    base_url_transfer (const base_url_transfer&) = delete;
-
-    base_url_transfer& operator = (const base_url_transfer&) = delete;
   };
 
   class
   OCTAVE_API
   url_transfer
   {
   public:
 
@@ -176,36 +174,36 @@ namespace octave
 
     url_transfer (const std::string& url, std::ostream& os);
 
     url_transfer (const url_transfer& h) : rep (h.rep)
     {
       rep->count++;
     }
 
-    ~url_transfer (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
-
     url_transfer& operator = (const url_transfer& h)
     {
       if (this != &h)
         {
           if (--rep->count == 0)
             delete rep;
 
           rep = h.rep;
           rep->count++;
         }
 
       return *this;
     }
 
+    ~url_transfer (void)
+    {
+      if (--rep->count == 0)
+        delete rep;
+    }
+
     bool is_valid (void) const { return rep->is_valid (); }
 
     bool good (void) const { return rep->good (); }
 
     std::string lasterror (void) const { return rep->lasterror (); }
 
     std::ostream& set_ostream (std::ostream& os)
     {
