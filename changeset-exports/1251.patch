# HG changeset patch
# User jwe
# Date 797615912 0
#      Tue Apr 11 15:58:32 1995 +0000
# Node ID 97eac19837dca713b4ca0435f926a1a70883504b
# Parent  5cca5ae2029986cce4d81167fdf9cb9f887eca0e
[project @ 1995-04-11 15:58:32 by jwe]

diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -33,20 +33,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (zgemv) (const char*, const int*, const int*,
-		       const Complex*, const Complex*, const int*,
-		       const Complex*, const int*, const Complex*,
-		       Complex*, const int*, long);
+  int F77_FCN (zgemv) (const char*, const int&, const int&,
+		       const Complex&, const Complex*, const int&,
+		       const Complex*, const int&, const Complex&,
+		       Complex*, const int&, long);
 }
 
 /*
  * Complex Column Vector class
  */
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
    : MArray<Complex> (a.length ())
@@ -441,26 +441,22 @@ operator * (const ComplexMatrix& m, cons
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexColumnVector ();
     }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
-  char trans = 'N';
   int ld = nr;
-  Complex alpha (1.0);
-  Complex beta (0.0);
-  int i_one = 1;
 
   Complex *y = new Complex [nr];
 
-  F77_FCN (zgemv) (&trans, &nr, &nc, &alpha, m.data (), &ld, a.data (),
-		   &i_one, &beta, y, &i_one, 1L); 
+  F77_FCN (zgemv) ("N", nr, nc, 1.0, m.data (), ld, a.data (), 1, 0.0,
+		   y, 1, 1L);
 
   return ComplexColumnVector (y, nr);
 }
 
 // column vector by column vector -> column vector operations
 
 ComplexColumnVector
 operator + (const ComplexColumnVector& v, const ColumnVector& a)
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -37,46 +37,46 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (zgemm) (const char*, const char*, const int*,
-		       const int*, const int*, const Complex*,
-		       const Complex*, const int*, const Complex*,
-		       const int*, const Complex*, Complex*, const int*,
+  int F77_FCN (zgemm) (const char*, const char*, const int&,
+		       const int&, const int&, const Complex&,
+		       const Complex*, const int&, const Complex*,
+		       const int&, const Complex&, Complex*, const int&,
 		       long, long);
 
-  int F77_FCN (zgeco) (Complex*, const int*, const int*, int*,
-		       double*, Complex*);
-
-  int F77_FCN (zgedi) (Complex*, const int*, const int*, int*,
-		       Complex*, Complex*, const int*);
-
-  int F77_FCN (zgesl) (Complex*, const int*, const int*, int*,
-		       Complex*, const int*);
-
-  int F77_FCN (zgelss) (const int*, const int*, const int*, Complex*,
-			const int*, Complex*, const int*, double*,
-			const double*, int*, Complex*, const int*,
-			double*, int*);
+  int F77_FCN (zgeco) (Complex*, const int&, const int&, int*,
+		       double&, Complex*);
+
+  int F77_FCN (zgedi) (Complex*, const int&, const int&, int*,
+		       Complex*, Complex*, const int&);
+
+  int F77_FCN (zgesl) (Complex*, const int&, const int&, int*,
+		       Complex*, const int&);
+
+  int F77_FCN (zgelss) (const int&, const int&, const int&, Complex*,
+			const int&, Complex*, const int&, double*,
+			double&, int&, Complex*, const int&,
+			double*, int&);
 
 // Note that the original complex fft routines were not written for
 // double complex arguments.  They have been modified by adding an
 // implicit double precision (a-h,o-z) statement at the beginning of
 // each subroutine.
 
-  int F77_FCN (cffti) (const int*, Complex*);
-
-  int F77_FCN (cfftf) (const int*, Complex*, Complex*);
-
-  int F77_FCN (cfftb) (const int*, Complex*, Complex*);
+  int F77_FCN (cffti) (const int&, Complex*);
+
+  int F77_FCN (cfftf) (const int&, Complex*, Complex*);
+
+  int F77_FCN (cfftb) (const int&, Complex*, Complex*);
 }
 
 /*
  * Complex Matrix class
  */
 
 ComplexMatrix::ComplexMatrix (const Matrix& a)
   : MArray2<Complex> (a.rows (), a.cols ())
@@ -783,30 +783,29 @@ ComplexMatrix::inverse (int& info, doubl
     }
 
   info = 0;
 
   int *ipvt = new int [nr];
   Complex *z = new Complex [nr];
   Complex *tmp_data = dup (data (), len);
 
-  F77_FCN (zgeco) (tmp_data, &nr, &nc, ipvt, &rcond, z);
+  F77_FCN (zgeco) (tmp_data, nr, nc, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -1;
       copy (tmp_data, data (), len);  // Restore contents.
     }
   else
     {
-      int job = 1;
-      Complex dummy;
-
-      F77_FCN (zgedi) (tmp_data, &nr, &nc, ipvt, &dummy, z, &job);
+      Complex *dummy;
+
+      F77_FCN (zgedi) (tmp_data, nr, nc, ipvt, dummy, z, 1);
     }
 
   delete [] ipvt;
   delete [] z;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
 
@@ -863,20 +862,20 @@ ComplexMatrix::fourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftf) (&npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftf) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
@@ -894,20 +893,20 @@ ComplexMatrix::ifourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftb) (&npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftb) (npts, &tmp_data[npts*j], wsave);
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
@@ -928,37 +927,37 @@ ComplexMatrix::fourier2d (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftf) (&npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftf) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
   wsave = new Complex [nn];
   Complex *row = new Complex[npts];
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	row[i] = tmp_data[i*nr + j];
 
-      F77_FCN (cfftf) (&npts, row, wsave);
+      F77_FCN (cfftf) (npts, row, wsave);
 
       for (i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = row[i];
     }
 
   delete [] wsave;
   delete [] row;
 
@@ -981,40 +980,40 @@ ComplexMatrix::ifourier2d (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftb) (&npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftb) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
   wsave = new Complex [nn];
   Complex *row = new Complex[npts];
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	row[i] = tmp_data[i*nr + j];
 
-      F77_FCN (cfftb) (&npts, row, wsave);
+      F77_FCN (cfftb) (npts, row, wsave);
 
       for (i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = row[i] / (double) npts;
     }
 
   delete [] wsave;
   delete [] row;
 
@@ -1054,29 +1053,28 @@ ComplexMatrix::determinant (int& info, d
   else
     {
       info = 0;
       int *ipvt = new int [nr];
 
       Complex *z = new Complex [nr];
       Complex *tmp_data = dup (data (), length ());
 
-      F77_FCN (zgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
+      F77_FCN (zgeco) (tmp_data, nr, nr, ipvt, rcond, z);
 
       volatile double rcond_plus_one = rcond + 1.0;
       if (rcond_plus_one == 1.0)
 	{
 	  info = -1;
 	  retval = ComplexDET ();
 	}
       else
 	{
-	  int job = 10;
 	  Complex d[2];
-	  F77_FCN (zgedi) (tmp_data, &nr, &nr, ipvt, d, z, &job);
+	  F77_FCN (zgedi) (tmp_data, nr, nr, ipvt, d, z, 10);
 	  retval = ComplexDET (d);
 	}
 
       delete [] tmp_data;
       delete [] ipvt;
       delete [] z;
     }
 
@@ -1136,31 +1134,29 @@ ComplexMatrix::solve (const ComplexMatri
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   Complex *z = new Complex [nr];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (zgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
+  F77_FCN (zgeco) (tmp_data, nr, nr, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -2;
     }
   else
     {
-      int job = 0;
-
       Complex *result = dup (b.data (), b.length ());
 
       for (int j = 0; j < b_nc; j++)
-	F77_FCN (zgesl) (tmp_data, &nr, &nr, ipvt, &result[nr*j], &job);
+	F77_FCN (zgesl) (tmp_data, nr, nr, ipvt, &result[nr*j], 0);
 
       retval = ComplexMatrix (result, b_nr, b_nc);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
@@ -1199,30 +1195,28 @@ ComplexMatrix::solve (const ComplexColum
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   Complex *z = new Complex [nr];
   Complex *tmp_data = dup (data (), length ());
 
-  F77_FCN (zgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
+  F77_FCN (zgeco) (tmp_data, nr, nr, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -2;
     }
   else
     {
-      int job = 0;
-
       Complex *result = dup (b.data (), b_len);
 
-      F77_FCN (zgesl) (tmp_data, &nr, &nr, ipvt, result, &job);
+      F77_FCN (zgesl) (tmp_data, nr, nr, ipvt, result, 0);
 
       retval = ComplexColumnVector (result, b_len);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
@@ -1281,18 +1275,18 @@ ComplexMatrix::lssolve (const ComplexMat
     lwork = 2*n + (nrhs > m ? nrhs : m);
 
   Complex *work = new Complex [lwork];
 
   int lrwork = (5 * (m < n ? m : n)) - 4;
   lrwork = lrwork > 1 ? lrwork : 1;
   double *rwork = new double [lrwork];
 
-  F77_FCN (zgelss) (&m, &n, &nrhs, tmp_data, &m, presult, &nrr, s,
-		    &rcond, &rank, work, &lwork, rwork, &info);
+  F77_FCN (zgelss) (m, n, nrhs, tmp_data, m, presult, nrr, s,
+		    rcond, rank, work, lwork, rwork, info);
 
   ComplexMatrix retval (n, nrhs);
   for (j = 0; j < nrhs; j++)
     for (i = 0; i < n; i++)
       retval.elem (i, j) = result.elem (i, j);
 
   delete [] tmp_data;
   delete [] s;
@@ -1354,18 +1348,18 @@ ComplexMatrix::lssolve (const ComplexCol
     lwork = 2*n + (nrhs > m ? nrhs : m);
 
   Complex *work = new Complex [lwork];
 
   int lrwork = (5 * (m < n ? m : n)) - 4;
   lrwork = lrwork > 1 ? lrwork : 1;
   double *rwork = new double [lrwork];
 
-  F77_FCN (zgelss) (&m, &n, &nrhs, tmp_data, &m, presult, &nrr, s,
-		    &rcond, &rank, work, &lwork, rwork, &info);
+  F77_FCN (zgelss) (m, n, nrhs, tmp_data, m, presult, nrr, s,
+		    rcond, rank, work, lwork, rwork, info);
 
   ComplexColumnVector retval (n);
   for (i = 0; i < n; i++)
     retval.elem (i) = result.elem (i);
 
   delete [] tmp_data;
   delete [] s;
   delete [] work;
@@ -1400,27 +1394,20 @@ operator * (const ComplexColumnVector& v
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return ComplexMatrix ();
     }
 
   if (len == 0)
     return ComplexMatrix (len, len, 0.0);
 
-  char transa = 'N';
-  char transb = 'N';
-  Complex alpha (1.0);
-  Complex beta (0.0);
-  int anr = 1;
-
   Complex *c = new Complex [len * a_len];
 
-  F77_FCN (zgemm) (&transa, &transb, &len, &a_len, &anr, &alpha,
-		   v.data (), &len, a.data (), &anr, &beta, c, &len,
-		   1L, 1L);
+  F77_FCN (zgemm) ("N", "N", len, a_len, 1, 1.0, v.data (), len,
+		   a.data (), 1, 0.0, c, len, 1L, 1L);
 
   return ComplexMatrix (c, len, a_len);
 }
 
 // diagonal matrix by scalar -> matrix operations
 
 ComplexMatrix
 operator + (const DiagMatrix& a, const Complex& s)
@@ -2448,29 +2435,23 @@ operator * (const ComplexMatrix& m, cons
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ComplexMatrix ();
     }
 
   if (nr == 0 || nc == 0 || a_nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
-  char trans  = 'N';
-  char transa = 'N';
-
   int ld  = nr;
   int lda = a.rows ();
 
-  Complex alpha (1.0);
-  Complex beta (0.0);
-
   Complex *c = new Complex [nr*a_nc];
 
-  F77_FCN (zgemm) (&trans, &transa, &nr, &a_nc, &nc, &alpha, m.data (),
-		   &ld, a.data (), &lda, &beta, c, &nr, 1L, 1L);
+  F77_FCN (zgemm) ("N", "N", nr, a_nc, nc, 1.0, m.data (),
+		   ld, a.data (), lda, 0.0, c, nr, 1L, 1L);
 
   return ComplexMatrix (c, nr, a_nc);
 }
 
 ComplexMatrix
 product (const ComplexMatrix& m, const Matrix& a)
 {
   int nr = m.rows ();
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -33,20 +33,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (zgemv) (const char*, const int*, const int*,
-		       const Complex*, const Complex*, const int*,
-		       const Complex*, const int*, const Complex*,
-		       Complex*, const int*, long);
+  int F77_FCN (zgemv) (const char*, const int&, const int&,
+		       const Complex&, const Complex*, const int&,
+		       const Complex*, const int&, const Complex&,
+		       Complex*, const int&, long);
 }
 
 /*
  * Complex Row Vector class
  */
 
 ComplexRowVector::ComplexRowVector (const RowVector& a)
   : MArray<Complex> (a.length ())
@@ -433,26 +433,22 @@ operator * (const ComplexRowVector& v, c
   if (len == 0 || a.cols () == 0)
     return ComplexRowVector (0);
 
 // Transpose A to form A'*x == (x'*A)'
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
-  char trans = 'T';
   int ld = a_nr;
-  Complex alpha (1.0);
-  Complex beta (0.0);
-  int i_one = 1;
 
   Complex *y = new Complex [len];
 
-  F77_FCN (zgemv) (&trans, &a_nc, &a_nr, &alpha, a.data (), &ld,
-		   v.data (), &i_one, &beta, y, &i_one, 1L); 
+  F77_FCN (zgemv) ("T", a_nc, a_nr, 1.0, a.data (), ld, v.data (), 1,
+		   0.0, y, 1, 1L); 
 
   return ComplexRowVector (y, len);
 }
 
 ComplexRowVector
 operator * (const RowVector& v, const ComplexMatrix& a)
 {
   ComplexRowVector tmp (v);
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -26,22 +26,22 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "CmplxAEPBAL.h"
 #include "dMatrix.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgebal) (const char*, const int*, Complex*, const int*,
-                        int*, int*, double*, int*, long, long);
+  int F77_FCN (zgebal) (const char*, const int&, Complex*, const int&,
+                        int&, int&, double*, int&, long, long);
  
-  int F77_FCN (zgebak) (const char*, const char*, const int*, const int*,
-			const int*, double*, const int*, Complex*, 
-			const int*, int*, long, long);
+  int F77_FCN (zgebak) (const char*, const char*, const int&, const int&,
+			const int&, double*, const int&, Complex*, 
+			const int&, int&, long, long);
 }
 
 int
 ComplexAEPBALANCE::init (const ComplexMatrix& a, const char *balance_job)
 {
 
   int n = a.cols ();
 
@@ -51,27 +51,27 @@ ComplexAEPBALANCE::init (const ComplexMa
   int ilo;
   int ihi;
   double *scale = new double [n];
 
 // Copy matrix into local structure.
 
   balanced_mat = a;
 
-  F77_FCN (zgebal) (balance_job, &n, balanced_mat.fortran_vec (),
-		    &n, &ilo, &ihi, scale, &info, 1L, 1L);
+  F77_FCN (zgebal) (balance_job, n, balanced_mat.fortran_vec (),
+		    n, ilo, ihi, scale, info, 1L, 1L);
 
 // Initialize balancing matrix to identity.
 
   balancing_mat = Matrix (n, n, 0.0);
   for (int i = 0; i < n; i++)
     balancing_mat (i, i) = 1.0;
 
-  F77_FCN (zgebak) (balance_job, "R", &n, &ilo, &ihi, scale, &n, 
-		    balancing_mat.fortran_vec (), &n, &info, 1L, 1L);
+  F77_FCN (zgebak) (balance_job, "R", n, ilo, ihi, scale, n, 
+		    balancing_mat.fortran_vec (), n, info, 1L, 1L);
 
   delete [] scale;
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -27,40 +27,38 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxCHOL.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zpotrf) (const char*, const int*, Complex*, const int*,
-			int*, long);
+  int F77_FCN (zpotrf) (const char*, const int&, Complex*, const int&,
+			int&, long);
 }
 
 int
 ComplexCHOL::init (const ComplexMatrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
    if (a_nr != a_nc)
      {
        (*current_liboctave_error_handler)
 	 ("ComplexCHOL requires square matrix");
        return -1;
      }
 
-   char uplo = 'U';
-
    int n = a_nc;
    int info;
 
    Complex *h = dup (a.data (), a.length ());
 
-   F77_FCN (zpotrf) (&uplo, &n, h, &n, &info, 1L);
+   F77_FCN (zpotrf) ("U", n, h, n, info, 1L);
 
    chol_mat = ComplexMatrix (h, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for
 // that matter :-)), please let me know!
 
   if (n > 1)
     for (int j = 0; j < a_nc; j++)
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -27,72 +27,69 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxHESS.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgebal) (const char*, const int*, Complex*, const int*,
-                        int*, int*, double*, int*, long, long);
+  int F77_FCN (zgebal) (const char*, const int&, Complex*, const int&,
+                        int&, int&, double*, int&, long, long);
  
-  int F77_FCN (zgebak) (const char*, const char*, const int*, const int*,
-			const int*, double*, const int*, Complex*, 
-			const int*, int*, long, long);
+  int F77_FCN (zgehrd) (const int&, const int&, const int&, Complex*,
+                        const int&, Complex*, Complex*, const int&,
+                        int&, long, long);
+ 
+  int F77_FCN (zunghr) (const int&, const int&, const int&, Complex*,
+                        const int&, Complex*, Complex*, const int&,
+                        int&, long, long);
 
-  int F77_FCN (zgehrd) (const int*, const int*, const int*, Complex*,
-                        const int*, Complex*, Complex*, const int*,
-                        int*, long, long);
- 
-  int F77_FCN (zunghr) (const int*, const int*, const int*, Complex*,
-                        const int*, Complex*, Complex*, const int*,
-                        int*, long, long);
+  int F77_FCN (zgebak) (const char*, const char*, const int&, const int&,
+			const int&, double*, const int&, Complex*,
+			const int&, int&, long, long);
 }
 
 int
 ComplexHESS::init (const ComplexMatrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
    if (a_nr != a_nc)
      {
        (*current_liboctave_error_handler)
 	 ("ComplexHESS requires square matrix");
        return -1;
      }
 
-   char job = 'N';
-   char side = 'R';
+   char *job = "N";
+   char *side = "R";
 
    int n = a_nc;
    int lwork = 32 * n;
    int info;
    int ilo;
    int ihi;
 
    Complex *h = dup (a.data (), a.length ());
 
    double *scale = new double [n];
    Complex *tau = new Complex [n-1];
    Complex *work = new Complex [lwork];
    Complex *z = new Complex [n*n];
 
-   F77_FCN (zgebal) (&job, &n, h, &n, &ilo, &ihi, scale, &info, 1L, 1L);
+   F77_FCN (zgebal) (job, n, h, n, ilo, ihi, scale, info, 1L, 1L);
 
-   F77_FCN (zgehrd) (&n, &ilo, &ihi, h, &n, tau, work, &lwork, &info, 1L,
-		     1L);
+   F77_FCN (zgehrd) (n, ilo, ihi, h, n, tau, work, lwork, info, 1L, 1L);
 
    copy (z, h, n*n);
 
-   F77_FCN (zunghr) (&n, &ilo, &ihi, z, &n, tau, work, &lwork, &info, 1L,
-		     1L);
+   F77_FCN (zunghr) (n, ilo, ihi, z, n, tau, work, lwork, info, 1L, 1L);
 
-   F77_FCN (zgebak) (&job, &side, &n, &ilo, &ihi, scale, &n, z, &n, &info,
-		     1L, 1L); 
+   F77_FCN (zgebak) (job, side, n, ilo, ihi, scale, n, z, n, info, 1L, 1L); 
 
    hess_mat = ComplexMatrix (h, n, n);
    unitary_hess_mat = ComplexMatrix (z, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for
 // that matter :-)), please let me know!
 
    if (n > 2)
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -27,18 +27,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxLU.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgesv) (const int*, const int*, Complex*, const int*,
-		       int*, Complex*, const int*, int*);
+  int F77_FCN (zgesv) (const int&, const int&, Complex*, const int&,
+		       int*, Complex*, const int&, int&);
 }
 
 ComplexLU::ComplexLU (const ComplexMatrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr == 0 || a_nc == 0 || a_nr != a_nc)
     {
@@ -47,20 +47,19 @@ ComplexLU::ComplexLU (const ComplexMatri
     }
 
   int n = a_nr;
 
   int *ipvt = new int [n];
   int *pvt = new int [n];
   Complex *tmp_data = dup (a.data (), a.length ());
   int info = 0;
-  int zero = 0;
-  Complex b;
+  Complex *b;
 
-  F77_FCN (zgesv) (&n, &zero, tmp_data, &n, ipvt, &b, &n, &info);
+  F77_FCN (zgesv) (n, 0, tmp_data, n, ipvt, b, n, info);
 
   ComplexMatrix A_fact (tmp_data, n, n);
 
   int i;
 
   for (i = 0; i < n; i++)
     {
       ipvt[i] -= 1;
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -27,21 +27,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxQR.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgeqrf) (const int*, const int*, Complex*, const int*,
-			Complex*, Complex*, const int*, int*);
+  int F77_FCN (zgeqrf) (const int&, const int&, Complex*, const int&,
+			Complex*, Complex*, const int&, int&);
 
-  int F77_FCN (zungqr) (const int*, const int*, const int*, Complex*,
-			const int*, Complex*, Complex*, const int*, int*);
+  int F77_FCN (zungqr) (const int&, const int&, const int&, Complex*,
+			const int&, Complex*, Complex*, const int&, int&);
 }
 
 ComplexQR::ComplexQR (const ComplexMatrix& a, QR::type qr_type)
 {
   int m = a.rows ();
   int n = a.cols ();
 
   if (m == 0 || n == 0)
@@ -61,17 +61,17 @@ ComplexQR::ComplexQR (const ComplexMatri
   if (m > n)
     {
       tmp_data = new Complex [m*m];
       copy (tmp_data, a.data (), a.length ());
     }
   else
     tmp_data = dup (a.data (), a.length ());
 
-  F77_FCN (zgeqrf) (&m, &n, tmp_data, &m, tau, work, &lwork, &info);
+  F77_FCN (zgeqrf) (m, n, tmp_data, m, tau, work, lwork, info);
 
   delete [] work;
 
   if (qr_type == QR::raw)
     {
       for (int j = 0; j < min_mn; j++)
 	{
 	  int limit = j < min_mn - 1 ? j : min_mn - 1;
@@ -98,18 +98,17 @@ ComplexQR::ComplexQR (const ComplexMatri
 	  int limit = j < min_mn-1 ? j : min_mn-1;
 	  for (int i = 0; i <= limit; i++)
 	    r.elem (i, j) = tmp_data[m*j+i];
 	}
 
       lwork = 32*m;
       work = new Complex[lwork];
 
-      F77_FCN (zungqr) (&m, &m, &min_mn, tmp_data, &m, tau, work,
-			&lwork, &info);
+      F77_FCN (zungqr) (m, m, min_mn, tmp_data, m, tau, work, lwork, info);
 
       q = ComplexMatrix (tmp_data, m, m);
       q.resize (m, n2);
 
       delete [] tau;
       delete [] work;
     }
 }
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -29,21 +29,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxQRP.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgeqpf) (const int*, const int*, Complex*, const int*,
-			int*, Complex*, Complex*, double*, int*);
+  int F77_FCN (zgeqpf) (const int&, const int&, Complex*, const int&,
+			int*, Complex*, Complex*, double*, int&);
 
-  int F77_FCN (zungqr) (const int*, const int*, const int*, Complex*,
-			const int*, Complex*, Complex*, const int*, int*);
+  int F77_FCN (zungqr) (const int&, const int&, const int&, Complex*,
+			const int&, Complex*, Complex*, const int&, int&);
 }
 
 // It would be best to share some of this code with ComplexQR class...
 
 ComplexQRP::ComplexQRP (const ComplexMatrix& a, QR::type qr_type)
 {
   assert (qr_type != QR::raw);
 
@@ -78,17 +78,17 @@ ComplexQRP::ComplexQRP (const ComplexMat
   int *jpvt = new int[n];
 
 // Clear Pivot vector (code to enforce a certain permutation would go
 // here...)
 
   for (int i = 0; i < n; i++)
     jpvt[i] = 0;      
 
-  F77_FCN (zgeqpf) (&m, &n, tmp_data, &m, jpvt, tau, work, rwork, &info);
+  F77_FCN (zgeqpf) (m, n, tmp_data, m, jpvt, tau, work, rwork, info);
 
 // Form Permutation matrix (if economy is requested, return the
 // indices only!)
 
   if (qr_type == QR::economy && m > n)
     {
       p.resize (1, n, 0.0);
       for (int j = 0; j < n; j++)
@@ -121,18 +121,17 @@ ComplexQRP::ComplexQRP (const ComplexMat
       int limit = j < min_mn-1 ? j : min_mn-1;
       for (int i = 0; i <= limit; i++)
 	r.elem (i, j) = tmp_data[m*j+i];
     }
 
   lwork = 32*m;
   work = new Complex[lwork];
 
-  F77_FCN (zungqr) (&m, &m, &min_mn, tmp_data, &m, tau, work,
-		    &lwork, &info);
+  F77_FCN (zungqr) (m, m, min_mn, tmp_data, m, tau, work, lwork, info);
 
   q = ComplexMatrix (tmp_data, m, m);
   q.resize (m, n2);
 
   delete [] tau;
   delete [] work;
 }
 
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -27,55 +27,55 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "CmplxSCHUR.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgeesx) (const char*, const char*, int (*)(Complex*),
-			const char*, const int*, Complex*, const int*,
-			int*, Complex*, Complex*, const int*, double*,
-			double*, Complex*, const int*, double*, int*,
-			int*, long, long);
+  int F77_FCN (zgeesx) (const char*, const char*, int (*)(const Complex&),
+			const char*, const int&, Complex*, const int&,
+			int&, Complex*, Complex*, const int&, double&,
+			double&, Complex*, const int&, double*, int*,
+			int&, long, long);
 }
 
 static int
-complex_select_ana (Complex *a)
+complex_select_ana (const Complex& a)
 {
-  return a->real () < 0.0;
+  return a.real () < 0.0;
 }
 
 static int
-complex_select_dig (Complex *a)
+complex_select_dig (const Complex& a)
 {
-  return (abs (*a) < 1.0);
+  return (abs (a) < 1.0);
 }
 
 int
 ComplexSCHUR::init (const ComplexMatrix& a, const char *ord)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
 	("ComplexSCHUR requires square matrix");
       return -1;
     }
 
-  char jobvs = 'V';
-  char sort;
+  char *jobvs = "V";
+  char *sort;
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
-     sort = 'S';
+     sort = "S";
    else
-     sort = 'N';
+     sort = "N";
 
-  char sense = 'N';
+  char *sense = "N";
 
   int n = a_nc;
   int lwork = 8 * n;
   int info;
   int sdim;
   double rconde;
   double rcondv;
 
@@ -90,31 +90,31 @@ ComplexSCHUR::init (const ComplexMatrix&
   Complex *s = dup (a.data (), a.length ());
 
   Complex *work = new Complex [lwork];
   Complex *q = new Complex [n*n];
   Complex *w = new Complex [n];
 
   if (*ord == 'A' || *ord == 'a')
     {
-      F77_FCN (zgeesx) (&jobvs, &sort, complex_select_ana, &sense,
-			&n, s, &n, &sdim, w, q, &n, &rconde, &rcondv,
-			work, &lwork, rwork, bwork, &info, 1L, 1L);
+      F77_FCN (zgeesx) (jobvs, sort, complex_select_ana, sense,
+			n, s, n, sdim, w, q, n, rconde, rcondv,
+			work, lwork, rwork, bwork, info, 1L, 1L);
     }
   else if (*ord == 'D' || *ord == 'd')
     {
-      F77_FCN (zgeesx) (&jobvs, &sort, complex_select_dig, &sense,
-			&n, s, &n, &sdim, w, q, &n, &rconde, &rcondv,
-			work, &lwork, rwork, bwork, &info, 1L, 1L);
+      F77_FCN (zgeesx) (jobvs, sort, complex_select_dig, sense,
+			n, s, n, sdim, w, q, n, rconde, rcondv,
+			work, lwork, rwork, bwork, info, 1L, 1L);
     }
   else
     {
-      F77_FCN (zgeesx) (&jobvs, &sort, (void *) 0, &sense, &n, s,
-			&n, &sdim, w, q, &n, &rconde, &rcondv, work,
-			&lwork, rwork, bwork, &info, 1L, 1L);
+      F77_FCN (zgeesx) (jobvs, sort, (void *) 0, sense, n, s,
+			n, sdim, w, q, n, rconde, rcondv, work,
+			lwork, rwork, bwork, info, 1L, 1L);
     }
 
   schur_mat = ComplexMatrix (s, n, n);
   unitary_mat = ComplexMatrix (q, n, n);
 
   delete [] w;
   delete [] work;
   delete [] rwork;
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -26,61 +26,61 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "CmplxSVD.h"
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (zgesvd) (const char*, const char*, const int*,
-			const int*, Complex*, const int*, double*,
-			Complex*, const int*, Complex*, const int*,
-			Complex*, const int*, double*, int*, long, long);
+  int F77_FCN (zgesvd) (const char*, const char*, const int&,
+			const int&, Complex*, const int&, double*,
+			Complex*, const int&, Complex*, const int&,
+			Complex*, const int&, double*, int&, long, long);
 }
 
 int
 ComplexSVD::init (const ComplexMatrix& a, SVD::type svd_type)
 {
   int info;
 
   int m = a.rows ();
   int n = a.cols ();
 
   Complex *tmp_data = dup (a.data (), a.length ());
 
   int min_mn = m < n ? m : n;
   int max_mn = m > n ? m : n;
 
-  char jobu = 'A';
-  char jobv = 'A';
+  char *jobu = "A";
+  char *jobv = "A";
 
   int ncol_u = m;
   int nrow_vt = n;
   int nrow_s = m;
   int ncol_s = n;
 
   if (svd_type == SVD::economy)
     {
-      jobu = jobv = 'S';
+      jobu = jobv = "S";
       ncol_u = nrow_vt = nrow_s = ncol_s = min_mn;
     }
 
   Complex *u = new Complex[m * ncol_u];
   double *s_vec  = new double[min_mn];
   Complex *vt = new Complex[nrow_vt * n];
 
   int lwork = 2*min_mn + max_mn;
   Complex *work = new Complex[lwork];
 
   int lrwork = 5*max_mn;
   double *rwork = new double[lrwork];
 
-  F77_FCN (zgesvd) (&jobu, &jobv, &m, &n, tmp_data, &m, s_vec, u, &m,
-		    vt, &nrow_vt, work, &lwork, rwork, &info, 1L, 1L);
+  F77_FCN (zgesvd) (jobu, jobv, m, n, tmp_data, m, s_vec, u, m,
+		    vt, nrow_vt, work, lwork, rwork, info, 1L, 1L);
 
   left_sm = ComplexMatrix (u, m, ncol_u);
   sigma = DiagMatrix (s_vec, nrow_s, ncol_s);
   ComplexMatrix vt_m (vt, nrow_vt, n);
   right_sm = vt_m.hermitian ();
 
   delete [] tmp_data;
   delete [] work;
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -28,20 +28,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #include <iostream.h>
 
 #include "CollocWt.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FCN (jcobi) (int*, int*, int*, int*, double*, double*,
+  int F77_FCN (jcobi) (int&, int&, int&, int&, double&, double&,
 		       double*, double*, double*, double*); 
 
-  int F77_FCN (dfopr) (int*, int*, int*, int*, int*, int*,
+  int F77_FCN (dfopr) (int&, int&, int&, int&, int&, int&,
 		       double*, double*, double*, double*, double*);
 }
 
 // Error handling.
 
 void
 CollocWt::error (const char* msg)
 {
@@ -270,51 +270,51 @@ CollocWt::init (void)
   q.resize (nt);
   A.resize (nt, nt);
   B.resize (nt, nt);
 
   double *pr = r.fortran_vec ();
 
 // Compute roots.
 
-  F77_FCN (jcobi) (&nt, &n, &inc_left, &inc_right, &Alpha, &Beta,
+  F77_FCN (jcobi) (nt, n, inc_left, inc_right, Alpha, Beta,
 		   dif1, dif2, dif3, pr);
 
   int id;
   int i, j;
 
 // First derivative weights.
 
   id = 1;
   for (i = 1; i <= nt; i++)
     {
-      F77_FCN (dfopr) (&nt, &n, &inc_left, &inc_right, &i, &id, dif1,
+      F77_FCN (dfopr) (nt, n, inc_left, inc_right, i, id, dif1,
 		       dif2, dif3, pr, vect); 
 
       for (j = 0; j < nt; j++)
 	A (i-1, j) = vect[j];
     }
 
 // Second derivative weights.
 
   id = 2;
   for (i = 1; i <= nt; i++)
     {
-      F77_FCN (dfopr) (&nt, &n, &inc_left, &inc_right, &i, &id, dif1,
+      F77_FCN (dfopr) (nt, n, inc_left, inc_right, i, id, dif1,
 		       dif2, dif3, pr, vect); 
 
       for (j = 0; j < nt; j++)
 	B (i-1, j) = vect[j];
     }
 
 // Gaussian quadrature weights.
 
   id = 3;
   double *pq = q.fortran_vec ();
-  F77_FCN (dfopr) (&nt, &n, &inc_left, &inc_right, &i, &id, dif1,
+  F77_FCN (dfopr) (nt, n, inc_left, inc_right, i, id, dif1,
 		   dif2, dif3, pr, pq);
 
   delete [] dif1;
   delete [] dif2;
   delete [] dif3;
   delete [] vect;
 
   initialized = 1;
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -26,24 +26,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "DAE.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FCN (ddassl) (int (*)(double*, double*, double*, double*,
-				int*, double*, int*),
-			const int*, double*, double*, double*,
-			double*, const int*, const double*,
-			const double*, int*, double*, const int*, 
-			int*, const int*, const double*, const int*,
-			int (*)(double*, double*, double*, double*,
-				double*, double*, int*));
+  int F77_FCN (ddassl) (int (*)(const double&, double*, double*,
+				double*, int&, double*, int*),
+			const int&, double&, double*, double*,
+			double&, const int*, const double&,
+			const double&, int&, double*, const int&, 
+			int*, const int&, const double*, const int*,
+			int (*)(const double&, double*, double*,
+				double*, const double&, double*, int*));
 }
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
 static int nn;
 
 DAE::DAE (void)
 {
@@ -185,63 +185,63 @@ DAE::initialize (const Vector& state, co
   integration_error = 0;
   restart = 1;
   xdot = deriv;
   x = state;
   t = time;
 }
 
 int
-ddassl_f (double *time, double *state, double *deriv, double *delta,
-	  int *ires, double *rpar, int *ipar)
+ddassl_f (const double& time, double *state, double *deriv,
+	  double *delta, int& ires, double *rpar, int *ipar)
 {
   Vector tmp_deriv (nn);
   Vector tmp_state (nn);
   Vector tmp_delta (nn);
 
   for (int i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv [i];
       tmp_state.elem (i) = state [i];
     }
 
-  tmp_delta = user_fun (tmp_state, tmp_deriv, *time);
+  tmp_delta = user_fun (tmp_state, tmp_deriv, time);
 
   if (tmp_delta.length () == 0)
-    *ires = -2;
+    ires = -2;
   else
     {
       for (i = 0; i < nn; i++)
 	delta [i] = tmp_delta.elem (i);
     }
 
   return 0;
 }
 
 int
-ddassl_j (double *time, double *state, double *deriv, double *pd,
-	  double *cj, double *rpar, int *ipar)
+ddassl_j (const double& time, double *state, double *deriv, double *pd,
+	  const double& cj, double *rpar, int *ipar)
 {
   Vector tmp_state (nn);
   Vector tmp_deriv (nn);
 
 // XXX FIXME XXX
 
   Matrix tmp_dfdxdot (nn, nn);
   Matrix tmp_dfdx (nn, nn);
 
   DAEFunc::DAEJac tmp_jac;
   tmp_jac.dfdxdot = &tmp_dfdxdot;
   tmp_jac.dfdx    = &tmp_dfdx;
 
-  tmp_jac = user_jac (tmp_state, tmp_deriv, *time);
+  tmp_jac = user_jac (tmp_state, tmp_deriv, time);
 
   // Fix up the matrix of partial derivatives for dassl.
 
-  tmp_dfdx = tmp_dfdx + (tmp_dfdxdot * (*cj));
+  tmp_dfdx = tmp_dfdx +  cj * tmp_dfdxdot;
 
   for (int j = 0; j < nn; j++)
     for (int i = 0; i < nn; i++)
       pd [nn * j + i] = tmp_dfdx.elem (i, j);
 
   return 0;
 }
 
@@ -284,30 +284,30 @@ DAE::integrate (double tout)
   if (maximum_step_size () >= 0.0)
     {
       rwork[2] = maximum_step_size ();
       info[6] = 1;
     }
   else
     info[6] = 0;
 
-  double dummy;
-  int idummy;
+  double *dummy;
+  int *idummy;
 
   if (restart)
     {
       restart = 0;
       info[0] = 0;
     }
 
 // again:
 
-  F77_FCN (ddassl) (ddassl_f, &n, &t, px, pxdot, &tout, info,
-		    &rel_tol, &abs_tol, &idid, rwork, &lrw, iwork,
-		    &liw, &dummy, &idummy, ddassl_j);
+  F77_FCN (ddassl) (ddassl_f, n, t, px, pxdot, tout, info,
+		    rel_tol, abs_tol, idid, rwork, lrw, iwork,
+		    liw, dummy, idummy, ddassl_j);
 
   switch (idid)
     {
     case 1: // A step was successfully taken in the
 	    // intermediate-output mode. The code has not yet reached
 	    // TOUT.
       break;
     case 2: // The integration to TSTOP was successfully completed
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -27,57 +27,54 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "EIG.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgeev) (const char*, const char*, const int*, double*,
-		       const int*, double*, double*, double*,
-		       const int*, double*, const int*, double*,
-		       const int*, int*, long, long);
+  int F77_FCN (dgeev) (const char*, const char*, const int&, double*,
+		       const int&, double*, double*, double*,
+		       const int&, double*, const int&, double*,
+		       const int&, int&, long, long);
 
-  int F77_FCN (zgeev) (const char*, const char*, const int*, Complex*,
-		       const int*, Complex*, Complex*, const int*,
-		       Complex*, const int*, Complex*, const int*,
-		       double*, int*, long, long);
+  int F77_FCN (zgeev) (const char*, const char*, const int&, Complex*,
+		       const int&, Complex*, Complex*, const int&,
+		       Complex*, const int&, Complex*, const int&,
+		       double*, int&, long, long);
 }
 
 int
 EIG::init (const Matrix& a)
 {
   int a_nr = a.rows ();
   if (a_nr != a.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
   int n = a_nr;
 
   int info;
 
-  char jobvl = 'N';
-  char jobvr = 'V';
-
   double *tmp_data = dup (a.data (), a.length ());
   double *wr = new double[n];
   double *wi = new double[n];
   Matrix vr (n, n);
   double *pvr = vr.fortran_vec ();
   int lwork = 8*n;
   double *work = new double[lwork];
 
-  double dummy;
+  double *dummy;
   int idummy = 1;
 
-  F77_FCN (dgeev) (&jobvl, &jobvr, &n, tmp_data, &n, wr, wi, &dummy,
-		   &idummy, pvr, &n, work, &lwork, &info, 1L, 1L);
+  F77_FCN (dgeev) ("N", "V", n, tmp_data, n, wr, wi, dummy,
+		   idummy, pvr, n, work, lwork, info, 1L, 1L);
 
   lambda.resize (n);
   v.resize (n, n);
 
   for (int j = 0; j < n; j++)
     {
       if (wi[j] == 0.0)
 	{
@@ -123,37 +120,33 @@ EIG::init (const ComplexMatrix& a)
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
   int n = a_nr;
 
   int info;
 
-  char jobvl = 'N';
-  char jobvr = 'V';
-
   lambda.resize (n);
   v.resize (n, n);
 
   Complex *pw = lambda.fortran_vec ();
   Complex *pvr = v.fortran_vec ();
 
   Complex *tmp_data = dup (a.data (), a.length ());
 
   int lwork = 8*n;
   Complex *work = new Complex[lwork];
   double *rwork = new double[4*n];
 
-  Complex dummy;
+  Complex *dummy;
   int idummy = 1;
 
-  F77_FCN (zgeev) (&jobvl, &jobvr, &n, tmp_data, &n, pw, &dummy,
-		   &idummy, pvr, &n, work, &lwork, rwork, &info, 1L,
-		   1L);
+  F77_FCN (zgeev) ("N", "V", n, tmp_data, n, pw, dummy, idummy, pvr,
+		   n, work, lwork, rwork, info, 1L, 1L);
 
   delete [] tmp_data;
   delete [] work;
   delete [] rwork;
 
   return info;
 }
 
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -30,22 +30,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include <iostream.h>
 
 #include "ODE.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
-  int F77_FCN (lsode) (int (*)(int*, double*, double*, double*, int*),
-		       int *, double *, double *, double *,
-		       int *, double *, double *, int *, int *, int *,
-		       double *, int *, int *, int *,
-		       int (*)(int*, double*, double*, int*, int*,
-			       double*, int*), int *);
+  int F77_FCN (lsode) (int (*)(const int&, const double&, double*,
+			       double*, int&),
+		       int&, double*, double&, double&, int&,
+		       double&, double&, int&, int&, int&,
+		       double*, int&, int*, int&,
+		       int (*)(const int&, const double&, double*,
+			       const int&, const int&, double*,
+			       const int&), int&);
 }
 
 static ODEFunc::ODERHSFunc user_fun;
 static ODEFunc::ODEJacFunc user_jac;
 static ColumnVector *tmp_x;
 
 ODE::ODE (void)
 {
@@ -143,56 +145,55 @@ ODE::ODE (const ColumnVector& state, dou
 
 ODE::~ODE (void)
 {
   delete [] rwork;
   delete [] iwork;
 }
 
 int
-lsode_f (int *neq, double *time, double *state, double *deriv, int *ierr)
+lsode_f (const int& neq, const double& time, double *state,
+	 double *deriv, int& ierr) 
 {
-  int nn = *neq;
-  ColumnVector tmp_deriv (nn);
+  ColumnVector tmp_deriv (neq);
 
   /*
    * NOTE: this won't work if LSODE passes copies of the state vector.
    *       In that case we have to create a temporary vector object
    *       and copy.
    */
-  tmp_deriv = (*user_fun) (*tmp_x, *time);
+  tmp_deriv = (*user_fun) (*tmp_x, time);
 
   if (tmp_deriv.length () == 0)
-    *ierr = -1;
+    ierr = -1;
   else
     {
-      for (int i = 0; i < nn; i++)
+      for (int i = 0; i < neq; i++)
 	deriv [i] = tmp_deriv.elem (i);
     }
 
   return 0;
 }
 
 int
-lsode_j (int *neq, double *time, double *state, int *ml, int *mu,
-         double *pd, int *nrowpd)
+lsode_j (const int& neq, const double& time, double *state,
+	 const int& ml, const int& mu, double *pd, const int& nrowpd)
 {
-  int nn = *neq;
-  Matrix tmp_jac (nn, nn);
+  Matrix tmp_jac (neq, neq);
 
   /*
    * NOTE: this won't work if LSODE passes copies of the state vector.
    *       In that case we have to create a temporary vector object
    *       and copy.
    */
-  tmp_jac = (*user_jac) (*tmp_x, *time);
+  tmp_jac = (*user_jac) (*tmp_x, time);
 
-  for (int j = 0; j < nn; j++)
-    for (int i = 0; i < nn; i++)
-      pd [*nrowpd * j + i] = tmp_jac (i, j);
+  for (int j = 0; j < neq; j++)
+    for (int i = 0; i < neq; i++)
+      pd [nrowpd * j + i] = tmp_jac (i, j);
 
   return 0;
 }
 
 ColumnVector
 ODE::integrate (double tout)
 {
   if (jac)
@@ -237,20 +238,19 @@ ODE::integrate (double tout)
   if (restart)
     {
       restart = 0;
       istate = 1;
     }
 
  again:
 
-  (void) F77_FCN (lsode) (lsode_f, &n, xp, &t, &tout, &itol,
-			  &rel_tol, &abs_tol, &itask, &istate, &iopt,
-			  rwork, &lrw, iwork, &liw, lsode_j,
-			  &method_flag);
+  (void) F77_FCN (lsode) (lsode_f, n, xp, t, tout, itol, rel_tol,
+			  abs_tol, itask, istate, iopt, rwork, lrw,
+			  iwork, liw, lsode_j, method_flag);
 
   switch (istate)
     {
     case -13: // Return requested in user-supplied function.
     case -6: // error weight became zero during problem. (solution
 	     // component i vanished, and atol or atol(i) = 0.)
     case -5: // repeated convergence failures (perhaps bad jacobian
 	     // supplied or wrong choice of mf or tolerances).
diff --git a/liboctave/NLEqn.cc b/liboctave/NLEqn.cc
--- a/liboctave/NLEqn.cc
+++ b/liboctave/NLEqn.cc
@@ -31,22 +31,22 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "NLEqn.h"
 #include "dMatrix.h"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 extern "C"
 {
   int F77_FCN (hybrd1) (int (*)(int*, double*, double*, int*),
-			const int*, double*, double*, const double*,
-			int*, double*, const int*);
+			const int&, double*, double*, const double&,
+			int&, double*, const int&);
 
   int F77_FCN (hybrj1) (int (*)(int*, double*, double*, double*, int*, int*),
-			const int*, double*, double*, double*, const int*,
-			const double*, int*, double*, const int*);
+			const int&, double*, double*, double*, const int&,
+			const double&, int&, double*, const int&);
 }
 
 static nonlinear_fcn user_fun;
 static jacobian_fcn user_jac;
 
 // error handling
 
 void
@@ -200,18 +200,16 @@ hybrj1_fcn (int *n, double *x, double *f
     }
 
   return 0;
 }
 
 Vector
 NLEqn::solve (int& info)
 {
-  int tmp_info = 0;
-
   if (n == 0)
     {
       error ("equation set not initialized");
       return Vector ();
     }
 
   double tol = tolerance ();
 
@@ -224,36 +222,34 @@ NLEqn::solve (int& info)
   user_jac = jac;
 
   if (jac)
     {
       int lwa = (n*(n+13))/2;
       double *wa = new double [lwa];
       double *fjac = new double [n*n];
 
-      F77_FCN (hybrj1) (hybrj1_fcn, &n, px, fvec, fjac, &n, &tol,
-			&tmp_info, wa, &lwa);
+      F77_FCN (hybrj1) (hybrj1_fcn, n, px, fvec, fjac, n, tol, info,
+			wa, lwa);
 
       delete [] wa;
       delete [] fjac;
     }
   else
     {
       int lwa = (n*(3*n+13))/2;
       double *wa = new double [lwa];
 
-      F77_FCN (hybrd1) (hybrd1_fcn, &n, px, fvec, &tol, &tmp_info, wa, &lwa);
+      F77_FCN (hybrd1) (hybrd1_fcn, n, px, fvec, tol, info, wa, lwa);
 
       delete [] wa;
     }
 
   Vector retval;
 
-  info = tmp_info;
-
   if (info >= 0)
     {
       retval.resize (n);
 
       for (i = 0; i < n; i++)
 	retval.elem (i) = px[i];
     }
 
diff --git a/liboctave/NPSOL.cc b/liboctave/NPSOL.cc
--- a/liboctave/NPSOL.cc
+++ b/liboctave/NPSOL.cc
@@ -35,124 +35,124 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dMatrix.h"
 
 #include "NPSOL.h"
 #include "f77-uscore.h"
 #include "sun-utils.h"
 
 extern "C"
 {
-  int F77_FCN (npoptn) (char *, long);
+  int F77_FCN (npoptn) (const char*, long);
 
-  int F77_FCN (npsol) (int *, int *, int *, int *, int *, int *,
-		       double *, double *, double *,
-		       int (*)(int*, int*, int*, int*, int*, double*,
-			       double*, double*, int*),
-		       int (*)(int*, int*, double*, double*, double*, int*),
-		       int *, int *, int *, double *,
-		       double *, double *, double *, double *,
-		       double *, double *, int *, int *, double *,
-		       int *);
+  int F77_FCN (npsol) (int&, int&, int&, int&, int&, int&, double*,
+		       double*, double*,
+		       int (*)(int&, const int&, const int&, const
+			       int&, int*, double*, double*, double*,
+			       int*),
+		       int (*)(int&, const int&, double*, double*,
+			       double*, int*),
+		       int&, int&, int*, double*, double*, double*,
+		       double&, double*, double*, double*, int*, int&,
+		       double*, int&);
 }
 
 // XXX FIXME XXX -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the objective
 // function, and the user wants us to quit.
 int npsol_objective_error = 0;
 
 static objective_fcn user_phi;
 static gradient_fcn user_grad;
 static nonlinear_fcn user_g;
 static jacobian_fcn user_jac;
 
 int
-npsol_objfun (int *mode, int *n, double *xx, double *objf,
-	      double *objgrd, int *nstate)
+npsol_objfun (int& mode, const int& n, double *xx, double *objf,
+	      double *objgrd, int* nstate)
 {
-  int nn = *n;
-  Vector tmp_x (nn);
+  Vector tmp_x (n);
 
   npsol_objective_error = 0;
 
-  for (int i = 0; i < nn; i++)
+  for (int i = 0; i < n; i++)
     tmp_x.elem (i) = xx[i];
 
-  if (*mode == 0 || *mode == 2)
+  if (mode == 0 || mode == 2)
     {
       double value = (*user_phi) (tmp_x);
 
       if (npsol_objective_error)
 	{
-	  *mode = -1;
+	  mode = -1;
 	  return 0;
 	}
 
 #if defined (sun) && defined (__GNUC__)
       assign_double (objf, value);
 #else
       *objf = value;
 #endif
     }
 
-  if ((*mode == 1 || *mode == 2) && user_grad)
+  if ((mode == 1 || mode == 2) && user_grad)
     {
-      Vector tmp_grad (nn);
+      Vector tmp_grad (n);
 
       tmp_grad = (*user_grad) (tmp_x);
 
       if (tmp_grad.length () == 0)
-	*mode = -1;
+	mode = -1;
       else
 	{
-	  for (i = 0; i < nn; i++)
+	  for (i = 0; i < n; i++)
 	    objgrd[i] = tmp_grad.elem (i);
 	}
     }
 
   return 0;
 }
 
 int
-npsol_confun (int *mode, int *ncnln, int *n, int *nrowj, int *needc,
-	      double *xx, double *cons, double *cjac, int *nstate)
+npsol_confun (int& mode, const int& ncnln, const int& n,
+	      const int& nrowj, int* needc, double *xx,
+	      double *cons, double *cjac, int* nstate) 
 {
-  int nn = *n, nncnln = *ncnln;
-  Vector tmp_x (nn);
-  Vector tmp_c (nncnln);
+  Vector tmp_x (n);
+  Vector tmp_c (ncnln);
 
-  for (int i = 0; i < nn; i++)
+  for (int i = 0; i < n; i++)
     tmp_x.elem (i) = xx[i];
 
   tmp_c = (*user_g) (tmp_x);
 
   if (tmp_c.length () == 0)
     {
-      *mode = -1;
+      mode = -1;
       return 0;
     }
   else
     {
-      for (i = 0; i < nncnln; i++)
+      for (i = 0; i < ncnln; i++)
 	cons[i] = tmp_c.elem (i);
     }
 
   if (user_jac)
     {
-      Matrix tmp_jac (nncnln, nn);
+      Matrix tmp_jac (ncnln, n);
 
       tmp_jac = (*user_jac) (tmp_x);
 
       if (tmp_jac.rows () == 0 || tmp_jac.columns () == 0)
-	*mode = -1;
+	mode = -1;
       else
 	{
-	  int ld = *nrowj;
-	  for (int j = 0; j < nn; j++)
-	    for (i = 0; i < nncnln; i++)
+	  int ld = nrowj;
+	  for (int j = 0; j < n; j++)
+	    for (i = 0; i < ncnln; i++)
 	      cjac[i+j*ld] = tmp_jac (i, j);
 	}
     }
 
   return 0;
 }
 
 Vector
@@ -295,20 +295,20 @@ NPSOL::minimize (double& objf, int& info
     F77_FCN (npoptn) ("Derivative Level 2", 18L);
   else if (user_jac && user_grad)
     F77_FCN (npoptn) ("Derivative Level 3", 18L);
 
   int attempt = 0;
   while (attempt++ < 5)
     {
 
-      F77_FCN (npsol) (&n, &nclin, &ncnln, &nrowa, &nrowj, &nrowr, pclin,
-		       clow, cup, npsol_confun, npsol_objfun, &inform,
-		       &iter, istate, c, cjac, pclambda, &objf, objgrd, r,
-		       px, iw, &leniw, w, &lenw);
+      F77_FCN (npsol) (n, nclin, ncnln, nrowa, nrowj, nrowr, pclin,
+		       clow, cup, npsol_confun, npsol_objfun, inform,
+		       iter, istate, c, cjac, pclambda, objf, objgrd, r,
+		       px, iw, leniw, w, lenw);
 
       if (inform == 6 || inform == 1)
 	continue;
       else
 	break;
     }
 
 // Clean up.
diff --git a/liboctave/QLD.cc b/liboctave/QLD.cc
--- a/liboctave/QLD.cc
+++ b/liboctave/QLD.cc
@@ -31,20 +31,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dMatrix.h"
 #include "dColVector.h"
 #include "dRowVector.h"
 #include "QLD.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (qld) (int*, int*, int*, int*, int*, double*, double*,
+  int F77_FCN (qld) (int&, int&, int&, int&, int&, double*, double*,
 		     double*, double*, double*, double*, double*,
-		     double*, int*, int*, int*, double*, int*, int*,
-		     int*);
+		     double*, int&, int&, int&, double*, int&, int*,
+		     int&);
 }
 
 Vector
 QLD::minimize (double& objf, int& inform)
 {
   int n = x.capacity ();
 
   Matrix A1 = lc.eq_constraint_matrix ();
@@ -102,22 +102,22 @@ QLD::minimize (double& objf, int& inform
       xub.resize (n, 1.0e30);
     }
   double *pxl = xlb.fortran_vec ();
   double *pxu = xub.fortran_vec ();
 
   int mmax = m > 0 ? m : 1;
 
   iprint = 1;
-  F77_FCN (qld) (&m, &me, &mmax, &n, &n, ph, pc, pa, pb, pxl, pxu, px,
-		 u, &iout, &inform, &iprint, war, &lwar, iwar, &liwar);
+  F77_FCN (qld) (m, me, mmax, n, n, ph, pc, pa, pb, pxl, pxu, px,
+		 u, iout, inform, iprint, war, lwar, iwar, liwar);
 
-  delete war;
-  delete iwar;
-  delete u;
+  delete [] war;
+  delete [] iwar;
+  delete [] u;
 
   objf = (x.transpose () * H * x) / 2.0;
   if (c.capacity () > 0)
     objf += c.transpose () * x;
 
   return x;
 }
 
diff --git a/liboctave/QPSOL.cc b/liboctave/QPSOL.cc
--- a/liboctave/QPSOL.cc
+++ b/liboctave/QPSOL.cc
@@ -30,53 +30,43 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #ifndef QPSOL_MISSING
 
 #include "QPSOL.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (qpsol) (int*, int*, int*, int*, int*, int*, int*, int*,
-		       double*, double*, double*, double*, double*,
+  int F77_FCN (qpsol) (int&, int&, int&, int&, int&, int&, int&, int&,
+		       double&, double*, double*, double*, double*,
 		       double*, double*,
-		       int (*)(int*, int*, int*, int*, double*,
-			       double*, double*),
-		       int*, int*, int*, int*, double*, int*, int*,
-		       double*, double*, int*, int*, double*, int*);
+		       int (*)(const int&, const int&, const int&,
+			       const int&, double*, double*, double*),
+		       int&, int&, int&, int*, double*, int&, int&,
+		       double&, double*, int*, int&, double*, int&);
 
-  int F77_FCN (dgemv) (const char*, const int*, const int*,
-		       const double*, const double*, const int*,
-		       const double*, const int*, const double*,
-		       double*, const int*, long);
+  int F77_FCN (dgemv) (const char*, const int&, const int&,
+		       const double&, const double*, const int&,
+		       const double*, const int&, const double&,
+		       double*, const int&, long);
 }
 
 int
-qphess (int *pn, int *pnrowh, int *ncolh, int *pcol, double *hess,
-	double *x, double *hx)
+qphess (const int& n, const int& nrowh, const int& ncolh,
+	const int& jthcol, double *hess, double *x, double *hx)
 {
-  int n = *pn;
-  int nrowh = *pnrowh;
-  int jthcol = *pcol;
-
   if (jthcol > 0)
     {
       int hp = (jthcol - 1) * nrowh;
       for (int i = 0; i < n; i++)
 	hx[i] = hess[hp+i];
     }
   else
     {
-      char trans = 'N';
-      double alpha = 1.0;
-      double beta  = 0.0;
-      int i_one = 1;
-
-      F77_FCN (dgemv) (&trans, pn, pn, &alpha, hess, pn, x, &i_one,
-		       &beta, hx, &i_one, 1L);
+      F77_FCN (dgemv) ("N", n, n, 1.0, hess, n, x, 1, 0.0, hx, 1, 1L);
     }
 
   return 0;
 }
 
 Vector
 QPSOL::minimize (double& objf, int& inform, Vector& lambda)
 {
@@ -154,20 +144,20 @@ QPSOL::minimize (double& objf, int& info
   if (lp == 0 || nclin >= n)
     lenw = 2*n*(n + 2) + nclin + 2*ncon;
   else
     lenw = 2*ncon*(1 + ncon) + 4*n + nclin;
 
   int *iw = new int [leniw];
   double *w = new double [lenw];
 
-  F77_FCN (qpsol) (&itmax, &msglvl, &n, &nclin, &nctotl, &ncon, &n,
-		   &n, &bigbnd, pa, pbl, pbu, pc, featol, ph, qphess,
-		   &cold, &lp, &orthog, istate, px, &inform, &iter,
-		   &objf, pclambda, iw, &leniw, w, &lenw);
+  F77_FCN (qpsol) (itmax, msglvl, n, nclin, nctotl, ncon, n,
+		   n, bigbnd, pa, pbl, pbu, pc, featol, ph, qphess,
+		   cold, lp, orthog, istate, px, inform, iter,
+		   objf, pclambda, iw, leniw, w, lenw);
 
   delete [] pbl;
   delete [] pbu;
   delete [] featol;
   delete [] istate;
   delete [] iw;
   delete [] w;
 
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -37,26 +37,26 @@ static integrand_fcn user_fcn;
 // XXX FIXME XXX -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 int quad_integration_error = 0;
 
 extern "C"
 {
-  int F77_FCN (dqagp) (const double (*)(double*, int*), const double*,
-		       const double*, const int*, const double*,
-		       const double*, const double*, double*, double*,
-		       int*, int*, const int*, const int*, int*, int*,
-		       double*);
+  int F77_FCN (dqagp) (const double (*)(double*, int&),
+		       const double&, const double&, const int&,
+		       const double*, const double&, const double&,
+		       double&, double&, int&, int&, const int&,
+		       const int&, int&, int*, double*);
 
-  int F77_FCN (dqagi) (const double (*)(double*, int*), const double*,
-		       const int*, const double*, const double*,
-		       double*, double*, int*, int*, const int*,
-		       const int*, int*, int*, double*);
+  int F77_FCN (dqagi) (const double (*)(double*, int&), const double&,
+		       const int&, const double&, const double&,
+		       double&, double&, int&, int&, const int&,
+		       const int&, int&, int*, double*); 
 }
 
 Quad::Quad (integrand_fcn fcn)
 {
   f = fcn;
 }
 
 Quad::Quad (integrand_fcn fcn, double abs, double rel)
@@ -83,30 +83,30 @@ Quad::integrate (int& ier)
 double
 Quad::integrate (int& ier, int& neval)
 {
   double abserr;
   return integrate (ier, neval, abserr);
 }
 
 static double
-user_function (double *x, int *ierr)
+user_function (double *x, int& ierr)
 {
 #if defined (sun) && defined (__GNUC__)
   double xx = access_double (x);
 #else
   double xx = *x;
 #endif
 
   quad_integration_error = 0;
 
   double retval = (*user_fcn) (xx);
 
   if (quad_integration_error)
-    *ierr = -1;
+    ierr = -1;
 
   return retval;
 }
 
 DefQuad::DefQuad (integrand_fcn fcn) : Quad (fcn)
 {
   lower_limit = 0.0;
   upper_limit = 1.0;
@@ -170,19 +170,19 @@ DefQuad::integrate (int& ier, int& neval
   int *iwork = new int [leniw];
   double *work = new double [lenw];
   user_fcn = f;
   int last;
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
-  F77_FCN (dqagp) (user_function, &lower_limit, &upper_limit, &npts,
-		   points, &abs_tol, &rel_tol, &result, &abserr,
-		   &neval, &ier, &leniw, &lenw, &last, iwork, work);
+  F77_FCN (dqagp) (user_function, lower_limit, upper_limit, npts,
+		   points, abs_tol, rel_tol, result, abserr,
+		   neval, ier, leniw, lenw, last, iwork, work);
 
   delete [] iwork;
   delete [] work;
 
   return result;
 }
 
 IndefQuad::IndefQuad (integrand_fcn fcn) : Quad (fcn)
@@ -238,19 +238,19 @@ IndefQuad::integrate (int& ier, int& nev
     default:
       assert (0);
       break;
     }
 
   double abs_tol = absolute_tolerance ();
   double rel_tol = relative_tolerance ();
 
-  F77_FCN (dqagi) (user_function, &bound, &inf, &abs_tol, &rel_tol,
-		   &result, &abserr, &neval, &ier, &leniw, &lenw,
-		   &last, iwork, work);
+  F77_FCN (dqagi) (user_function, bound, inf, abs_tol, rel_tol,
+		   result, abserr, neval, ier, leniw, lenw,
+		   last, iwork, work);
 
   delete [] iwork;
   delete [] work;
 
   return result;
 }
 
 Quad_options::Quad_options (void)
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -33,20 +33,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (dgemv) (const char*, const int*, const int*,
-		       const double*, const double*, const int*,
-		       const double*, const int*, const double*,
-		       double*, const int*, long);
+  int F77_FCN (dgemv) (const char*, const int&, const int&,
+		       const double&, const double*, const int&,
+		       const double*, const int&, const double&,
+		       double*, const int&, long);
 }
 
 /*
  * Column Vector class.
  */
 
 int
 ColumnVector::operator == (const ColumnVector& a) const
@@ -216,26 +216,22 @@ operator * (const Matrix& m, const Colum
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return ColumnVector ();
     }
 
   if (nr == 0 || nc == 0)
     return ColumnVector (0);
 
-  char trans = 'N';
   int ld = nr;
-  double alpha = 1.0;
-  double beta  = 0.0;
-  int i_one = 1;
 
   double *y = new double [nr];
 
-  F77_FCN (dgemv) (&trans, &nr, &nc, &alpha, m.data (), &ld, a.data (),
-		   &i_one, &beta, y, &i_one, 1L); 
+  F77_FCN (dgemv) ("N", nr, nc, 1.0, m.data (), ld, a.data (), 1, 0.0,
+		   y, 1, 1L);
 
   return ColumnVector (y, nr);
 }
 
 // diagonal matrix by column vector -> column vector operations
 
 ColumnVector
 operator * (const DiagMatrix& m, const ColumnVector& a)
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -38,46 +38,45 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (dgemm) (const char*, const char*, const int*,
-		       const int*, const int*, const double*,
-		       const double*, const int*, const double*,
-		       const int*, const double*, double*, const int*,
+  int F77_FCN (dgemm) (const char*, const char*, const int&,
+		       const int&, const int&, const double&,
+		       const double*, const int&, const double*,
+		       const int&, const double&, double*, const int&,
 		       long, long);
 
-  int F77_FCN (dgeco) (double*, const int*, const int*, int*, double*,
+  int F77_FCN (dgeco) (double*, const int&, const int&, int*, double&,
 		       double*);
 
-  int F77_FCN (dgesl) (const double*, const int*, const int*,
-		       const int*, double*, const int*); 
+  int F77_FCN (dgesl) (const double*, const int&, const int&,
+		       const int*, double*, const int&); 
 
-  int F77_FCN (dgedi) (double*, const int*, const int*, const int*,
-		       double*, double*, const int*);
+  int F77_FCN (dgedi) (double*, const int&, const int&, const int*,
+		       double*, double*, const int&);
 
-  int F77_FCN (dgelss) (const int*, const int*, const int*, double*,
-			const int*, double*, const int*, double*,
-			const double*, int*, double*, const int*,
-			int*);
+  int F77_FCN (dgelss) (const int&, const int&, const int&, double*,
+			const int&, double*, const int&, double*,
+			double&, int&, double*, const int&, int&);
 
 // Note that the original complex fft routines were not written for
 // double complex arguments.  They have been modified by adding an
 // implicit double precision (a-h,o-z) statement at the beginning of
 // each subroutine.
 
-  int F77_FCN (cffti) (const int*, Complex*);
+  int F77_FCN (cffti) (const int&, Complex*);
 
-  int F77_FCN (cfftf) (const int*, Complex*, Complex*);
+  int F77_FCN (cfftf) (const int&, Complex*, Complex*);
 
-  int F77_FCN (cfftb) (const int*, Complex*, Complex*);
+  int F77_FCN (cfftb) (const int&, Complex*, Complex*);
 }
 
 /*
  * Matrix class.
  */
 
 Matrix::Matrix (const DiagMatrix& a)
   : MArray2<double> (a.rows (), a.cols (), 0.0)
@@ -510,30 +509,29 @@ Matrix::inverse (int& info, double& rcon
     }
 
   info = 0;
 
   int *ipvt = new int [nr];
   double *z = new double [nr];
   double *tmp_data = dup (data (), len);
 
-  F77_FCN (dgeco) (tmp_data, &nr, &nc, ipvt, &rcond, z);
+  F77_FCN (dgeco) (tmp_data, nr, nc, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -1;
       copy (tmp_data, data (), len);  // Restore matrix contents.
     }
   else
     {
-      int job = 1;
-      double dummy;
+      double *dummy;
 
-      F77_FCN (dgedi) (tmp_data, &nr, &nc, ipvt, &dummy, z, &job);
+      F77_FCN (dgedi) (tmp_data, nr, nc, ipvt, dummy, z, 1);
     }
 
   delete [] ipvt;
   delete [] z;
 
   return Matrix (tmp_data, nr, nc);
 }
 
@@ -590,20 +588,20 @@ Matrix::fourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = make_complex (data (), length ());
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftf) (&npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftf) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
 
 ComplexMatrix
 Matrix::ifourier (void) const
@@ -621,20 +619,20 @@ Matrix::ifourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = make_complex (data (), length ());
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftb) (&npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftb) (npts, &tmp_data[npts*j], wsave);
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
 
   delete [] wsave;
 
   return ComplexMatrix (tmp_data, nr, nc);
 }
@@ -655,37 +653,37 @@ Matrix::fourier2d (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = make_complex (data (), length ());
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftf) (&npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftf) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
   wsave = new Complex [nn];
   Complex *row = new Complex[npts];
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	row[i] = tmp_data[i*nr + j];
 
-      F77_FCN (cfftf) (&npts, row, wsave);
+      F77_FCN (cfftf) (npts, row, wsave);
 
       for (i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = row[i];
     }
 
   delete [] wsave;
   delete [] row;
 
@@ -708,40 +706,40 @@ Matrix::ifourier2d (void) const
       npts = nr;
       nsamples = nc;
     }
 
   int nn = 4*npts+15;
   Complex *wsave = new Complex [nn];
   Complex *tmp_data = make_complex (data (), length ());
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (int j = 0; j < nsamples; j++)
-    F77_FCN (cfftb) (&npts, &tmp_data[npts*j], wsave);
+    F77_FCN (cfftb) (npts, &tmp_data[npts*j], wsave);
 
   delete [] wsave;
 
   for (j = 0; j < npts*nsamples; j++)
     tmp_data[j] = tmp_data[j] / (double) npts;
 
   npts = nc;
   nsamples = nr;
   nn = 4*npts+15;
   wsave = new Complex [nn];
   Complex *row = new Complex[npts];
 
-  F77_FCN (cffti) (&npts, wsave);
+  F77_FCN (cffti) (npts, wsave);
 
   for (j = 0; j < nsamples; j++)
     {
       for (int i = 0; i < npts; i++)
 	row[i] = tmp_data[i*nr + j];
 
-      F77_FCN (cfftb) (&npts, row, wsave);
+      F77_FCN (cfftb) (npts, row, wsave);
 
       for (i = 0; i < npts; i++)
 	tmp_data[i*nr + j] = row[i] / (double) npts;
     }
 
   delete [] wsave;
   delete [] row;
 
@@ -781,29 +779,28 @@ Matrix::determinant (int& info, double& 
   else
     {
       info = 0;
       int *ipvt = new int [nr];
 
       double *z = new double [nr];
       double *tmp_data = dup (data (), length ());
 
-      F77_FCN (dgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
+      F77_FCN (dgeco) (tmp_data, nr, nr, ipvt, rcond, z);
 
       volatile double rcond_plus_one = rcond + 1.0;
       if (rcond_plus_one == 1.0)
 	{
 	  info = -1;
 	  retval = DET ();
 	}
       else
 	{
-	  int job = 10;
 	  double d[2];
-	  F77_FCN (dgedi) (tmp_data, &nr, &nr, ipvt, d, z, &job);
+	  F77_FCN (dgedi) (tmp_data, nr, nr, ipvt, d, z, 10);
 	  retval = DET (d);
 	}
 
       delete [] tmp_data;
       delete [] ipvt;
       delete [] z;
     }
 
@@ -840,32 +837,30 @@ Matrix::solve (const Matrix& b, int& inf
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   double *z = new double [nr];
   double *tmp_data = dup (data (), length ());
 
-  F77_FCN (dgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
+  F77_FCN (dgeco) (tmp_data, nr, nr, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -2;
     }
   else
     {
-      int job = 0;
-
       double *result = dup (b.data (), b.length ());
 
       int b_nc = b.cols ();
       for (int j = 0; j < b_nc; j++)
-	F77_FCN (dgesl) (tmp_data, &nr, &nr, ipvt, &result[nr*j], &job);
+	F77_FCN (dgesl) (tmp_data, nr, nr, ipvt, &result[nr*j], 0);
 
       retval = Matrix (result, b.rows (), b_nc);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
@@ -922,32 +917,30 @@ Matrix::solve (const ColumnVector& b, in
     }
 
   info = 0;
   int *ipvt = new int [nr];
 
   double *z = new double [nr];
   double *tmp_data = dup (data (), length ());
 
-  F77_FCN (dgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
+  F77_FCN (dgeco) (tmp_data, nr, nr, ipvt, rcond, z);
 
   volatile double rcond_plus_one = rcond + 1.0;
   if (rcond_plus_one == 1.0)
     {
       info = -2;
     }
   else
     {
-      int job = 0;
-
       int b_len = b.length ();
 
       double *result = dup (b.data (), b_len);
 
-      F77_FCN (dgesl) (tmp_data, &nr, &nr, ipvt, result, &job);
+      F77_FCN (dgesl) (tmp_data, nr, nr, ipvt, result, 0);
 
       retval = ColumnVector (result, b_len);
     }
 
   delete [] tmp_data;
   delete [] ipvt;
   delete [] z;
 
@@ -1023,18 +1016,18 @@ Matrix::lssolve (const Matrix& b, int& i
   int lwork;
   if (m < n)
     lwork = 3*m + (2*m > nrhs ? (2*m > n ? 2*m : n) : (nrhs > n ? nrhs : n));
   else
     lwork = 3*n + (2*n > nrhs ? (2*n > m ? 2*n : m) : (nrhs > m ? nrhs : m));
 
   double *work = new double [lwork];
 
-  F77_FCN (dgelss) (&m, &n, &nrhs, tmp_data, &m, presult, &nrr, s,
-		    &rcond, &rank, work, &lwork, &info);
+  F77_FCN (dgelss) (m, n, nrhs, tmp_data, m, presult, nrr, s, rcond,
+		    rank, work, lwork, info);
 
   Matrix retval (n, nrhs);
   for (j = 0; j < nrhs; j++)
     for (i = 0; i < n; i++)
       retval.elem (i, j) = result.elem (i, j);
 
   delete [] tmp_data;
   delete [] s;
@@ -1110,18 +1103,18 @@ Matrix::lssolve (const ColumnVector& b, 
   int lwork;
   if (m < n)
     lwork = 3*m + (2*m > nrhs ? (2*m > n ? 2*m : n) : (nrhs > n ? nrhs : n));
   else
     lwork = 3*n + (2*n > nrhs ? (2*n > m ? 2*n : m) : (nrhs > m ? nrhs : m));
 
   double *work = new double [lwork];
 
-  F77_FCN (dgelss) (&m, &n, &nrhs, tmp_data, &m, presult, &nrr, s,
-		    &rcond, &rank, work, &lwork, &info);
+  F77_FCN (dgelss) (m, n, nrhs, tmp_data, m, presult, nrr, s, rcond,
+		    rank, work, lwork, info);
 
   ColumnVector retval (n);
   for (i = 0; i < n; i++)
     retval.elem (i) = result.elem (i);
 
   delete [] tmp_data;
   delete [] s;
   delete [] work;
@@ -1255,27 +1248,20 @@ operator * (const ColumnVector& v, const
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return Matrix ();
     }
 
   if (len == 0)
     return Matrix (len, len, 0.0);
 
-  char transa = 'N';
-  char transb = 'N';
-  double alpha = 1.0;
-  double beta  = 0.0;
-  int anr = 1;
-
   double *c = new double [len * a_len];
 
-  F77_FCN (dgemm) (&transa, &transb, &len, &a_len, &anr, &alpha,
-		   v.data (), &len, a.data (), &anr, &beta, c, &len,
-		   1L, 1L); 
+  F77_FCN (dgemm) ("N", "N", len, a_len, 1, 1.0, v.data (),
+		   len, a.data (), 1, 0.0, c, len, 1L, 1L);
 
   return Matrix (c, len, a_len);
 }
 
 // diagonal matrix by scalar -> matrix operations
 
 Matrix
 operator + (const DiagMatrix& a, double s)
@@ -1514,29 +1500,23 @@ operator * (const Matrix& m, const Matri
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
       return Matrix ();
     }
 
   if (nr == 0 || nc == 0 || a_nc == 0)
     return Matrix (nr, a_nc, 0.0);
 
-  char trans  = 'N';
-  char transa = 'N';
-
   int ld  = nr;
   int lda = a_nr;
 
-  double alpha = 1.0;
-  double beta  = 0.0;
-
   double *c = new double [nr*a_nc];
 
-  F77_FCN (dgemm) (&trans, &transa, &nr, &a_nc, &nc, &alpha, m.data (),
-		   &ld, a.data (), &lda, &beta, c, &nr, 1L, 1L);
+  F77_FCN (dgemm) ("N", "N", nr, a_nc, nc, 1.0, m.data (),
+		   ld, a.data (), lda, 0.0, c, nr, 1L, 1L);
 
   return Matrix (c, nr, a_nc);
 }
 
 // other operations.
 
 Matrix
 map (d_d_Mapper f, const Matrix& a)
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -33,23 +33,23 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (dgemv) (const char*, const int*, const int*,
-		       const double*, const double*, const int*,
-		       const double*, const int*, const double*,
-		       double*, const int*, long);
+  int F77_FCN (dgemv) (const char*, const int&, const int&,
+		       const double&, const double*, const int&,
+		       const double*, const int&, const double&,
+		       double*, const int&, long);
 
-  double F77_FCN (ddot) (const int*, const double*, const int*,
-			 const double*, const int*);
+  double F77_FCN (ddot) (const int&, const double*, const int&,
+			 const double*, const int&);
 }
 
 /*
  * Row Vector class.
  */
 
 int
 RowVector::operator == (const RowVector& a) const
@@ -221,26 +221,22 @@ operator * (const RowVector& v, const Ma
   if (len == 0 || a.cols () == 0)
     return RowVector (0);
 
 // Transpose A to form A'*x == (x'*A)'
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
-  char trans = 'T';
   int ld = a_nr;
-  double alpha = 1.0;
-  double beta  = 0.0;
-  int i_one = 1;
 
   double *y = new double [len];
 
-  F77_FCN (dgemv) (&trans, &a_nc, &a_nr, &alpha, a.data (), &ld,
-		   v.data (), &i_one, &beta, y, &i_one, 1L); 
+  F77_FCN (dgemv) ("T", a_nc, a_nr, 1.0, a.data (), ld, v.data (),
+		   1, 0.0, y, 1, 1L);
 
   return RowVector (y, len);
 }
 
 // other operations
 
 RowVector
 map (d_d_Mapper f, const RowVector& a)
@@ -358,18 +354,17 @@ operator * (const RowVector& v, const Co
   int len = v.length ();
   if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector multiplication attempted");
       return 0.0;
     }
 
-  int i_one = 1;
-  return F77_FCN (ddot) (&len, v.data (), &i_one, a.data (), &i_one);
+  return F77_FCN (ddot) (len, v.data (), 1, a.data (), 1);
 }
 
 Complex
 operator * (const RowVector& v, const ComplexColumnVector& a)
 {
   ComplexRowVector tmp (v);
   return tmp * a;
 }
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -25,23 +25,23 @@ Software Foundation, 675 Mass Ave, Cambr
 #include <config.h>
 #endif
 
 #include "dbleAEPBAL.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgebal) (const char*, const int*, double*,
-                        const int*, int*, int*, double*,
-                        int*, long, long);
+  int F77_FCN (dgebal) (const char*, const int&, double*,
+                        const int&, int&, int&, double*,
+                        int&, long, long);
 
-  int F77_FCN (dgebak) (const char*, const char*, const int*, const int*,
-			const int*, double*, const int*, double*, const int*,
-			int*, long, long);
+  int F77_FCN (dgebak) (const char*, const char*, const int&, const int&,
+			const int&, double*, const int&, double*, const int&,
+			int&, long, long);
 }
 
 int
 AEPBALANCE::init (const Matrix& a, const char *balance_job)
 {
   int a_nc = a.cols ();
   if (a.rows () != a_nc)
     {
@@ -57,27 +57,27 @@ AEPBALANCE::init (const Matrix& a, const
   int ilo;
   int ihi;
   double *scale = new double [n];
 
 // Copy matrix into local structure.
 
   balanced_mat = a;
 
-  F77_FCN (dgebal) (balance_job, &n, balanced_mat.fortran_vec (), 
-		    &n, &ilo, &ihi, scale, &info, 1L, 1L);
+  F77_FCN (dgebal) (balance_job, n, balanced_mat.fortran_vec (), 
+		    n, ilo, ihi, scale, info, 1L, 1L);
 
 // Initialize balancing matrix to identity.
 
   balancing_mat = Matrix (n, n, 0.0);
   for (int i = 0; i < n; i++)
     balancing_mat.elem (i ,i) = 1.0;
 
-  F77_FCN (dgebak) (balance_job, "R", &n, &ilo, &ihi, scale, &n, 
-		    balancing_mat.fortran_vec (), &n, &info, 1L, 1L);
+  F77_FCN (dgebak) (balance_job, "R", n, ilo, ihi, scale, n, 
+		    balancing_mat.fortran_vec (), n, info, 1L, 1L);
 
   delete [] scale;
 
   return info;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -27,39 +27,37 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleCHOL.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dpotrf) (const char*, const int*, double*, const int*,
-			int*, long);
+  int F77_FCN (dpotrf) (const char*, const int&, double*, const int&,
+			int&, long);
 }
 
 int
 CHOL::init (const Matrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("CHOL requires square matrix");
       return -1;
     }
 
-  char uplo = 'U';
-
   int n = a_nc;
   int info;
 
   double *h = dup (a.data (), a.length ());
 
-  F77_FCN (dpotrf) (&uplo, &n, h, &n, &info, 1L);
+  F77_FCN (dpotrf) ("U", n, h, n, info, 1L);
 
   chol_mat = Matrix (h, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for
 // that matter :-)), please let me know!
 
   if (n > 1)
     for (int j = 0; j < a_nc; j++)
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -27,31 +27,31 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include <math.h>
 
 #include "dbleGEPBAL.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgebak) (const char*, const char*, const int*, const int*,
-			const int*, double*, const int*, double*, const int*,
-			int*, long, long);
+  int F77_FCN (dgebak) (const char*, const char*, const int&, const int&,
+			const int&, double*, const int&, double*, const int&,
+			int&, long, long);
 
-  int F77_FCN (reduce) (const int*, const int*, double*,
-	   	        const int*, double*,
-			int*, int*, double*, double*);
+  int F77_FCN (reduce) (const int&, const int&, double*,
+	   	        const int&, double*,
+			int&, int&, double*, double*);
 
-  int F77_FCN (scaleg) (const int*, const int*, double*,
-	   	        const int*, double*,
-			const int*, const int*, double*, double*, double*);
+  int F77_FCN (scaleg) (const int&, const int&, double*,
+	   	        const int&, double*,
+			const int&, const int&, double*, double*, double*);
 
-  int F77_FCN (gradeq) (const int*, const int*, double*,
-	   	        const int*, double*,
-			int*, int*, double*, double*);
+  int F77_FCN (gradeq) (const int&, const int&, double*,
+	   	        const int&, double*,
+			int&, int&, double*, double*);
 }
 
 int
 GEPBALANCE::init (const Matrix& a, const Matrix& b, const char *balance_job)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   int b_nr = b.rows ();
@@ -100,35 +100,35 @@ GEPBALANCE::init (const Matrix& a, const
     left_balancing_mat (i, i) = 1.0;
 
   right_balancing_mat = left_balancing_mat;
 
 // Check for permutation option.
 
   if (*balance_job == 'P' || *balance_job == 'B')
     {
-      F77_FCN (reduce) (&n, &n, balanced_a_mat.fortran_vec (),
-			&n, balanced_b_mat.fortran_vec (), &ilo, &ihi,
+      F77_FCN (reduce) (n, n, balanced_a_mat.fortran_vec (),
+			n, balanced_b_mat.fortran_vec (), ilo, ihi,
 			cscale, wk.fortran_vec ());
     }
   else
     {
 
 // Set up for scaling later.
 
       ilo = 1;
       ihi = n;
     }
 
 // Check for scaling option.
 
   if ((*balance_job == 'S' || *balance_job == 'B') && ilo != ihi)
     {
-      F77_FCN (scaleg) (&n, &n, balanced_a_mat.fortran_vec (), 
-			&n, balanced_b_mat.fortran_vec (), &ilo, &ihi,
+      F77_FCN (scaleg) (n, n, balanced_a_mat.fortran_vec (), 
+			n, balanced_b_mat.fortran_vec (), ilo, ihi,
 			cscale, cperm, wk.fortran_vec ());
     }
   else
     {
 
 // Set scaling data to 0's.
 
       for (int tmp = ilo-1; tmp < ihi; tmp++)
@@ -143,34 +143,34 @@ GEPBALANCE::init (const Matrix& a, const
   for (int tmp = ilo-1; tmp < ihi; tmp++)
     {
       cscale[tmp] = pow (2.0, cscale[tmp]);
       wk.elem (tmp, 0) = pow (2.0, -wk.elem (tmp, 0));
     }
 
 // Column permutations/scaling.
 
-  F77_FCN (dgebak) (balance_job, "R", &n, &ilo, &ihi, cscale, &n, 
-		    right_balancing_mat.fortran_vec (), &n, &info, 1L,
-		    1L);
+  F77_FCN (dgebak) (balance_job, "R", n, ilo, ihi, cscale, n, 
+		    right_balancing_mat.fortran_vec (), n, info,
+		    1L, 1L);
     
 // Row permutations/scaling.
 
-  F77_FCN (dgebak) (balance_job, "L", &n, &ilo, &ihi, &wk.elem (0, 0), &n, 
-		    left_balancing_mat.fortran_vec (), &n, &info, 1L, 1L);
+  F77_FCN (dgebak) (balance_job, "L", n, ilo, ihi, wk.fortran_vec (), n,
+		    left_balancing_mat.fortran_vec (), n, info, 1L, 1L);
 
 // XXX FIXME XXX --- these four lines need to be added and debugged.
 // GEPBALANCE::init will work without them, though, so here they are.
 
 #if 0
   if ((*balance_job == 'P' || *balance_job == 'B') && ilo != ihi)
     {
-      F77_FCN (gradeq) (&n, &n, balanced_a_mat.fortran_vec (),
-			&n, balanced_b_mat.fortran_vec (), &ilo, &ihi,
-			cperm, &wk.elem (0, 1));
+      F77_FCN (gradeq) (n, n, balanced_a_mat.fortran_vec (),
+			n, balanced_b_mat.fortran_vec (), ilo, ihi,
+			cperm, wk.fortran_vec ());
     }
 #endif
 
 // Transpose for aa = cc*a*dd convention...
   left_balancing_mat = left_balancing_mat.transpose ();
 
   delete [] cscale;
   delete [] cperm;
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -27,73 +27,69 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleHESS.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgebal) (const char*, const int*, double*,
-                        const int*, int*, int*, double*,
-                        int*, long, long);
+  int F77_FCN (dgebal) (const char*, const int&, double*,
+                        const int&, int&, int&, double*,
+                        int&, long, long);
 
-  int F77_FCN (dgebak) (const char*, const char*, const int*, const int*,
-			const int*, double*, const int*, double*, const int*,
-			int*, long, long);
+  int F77_FCN (dgehrd) (const int&, const int&, const int&,
+                        double*, const int&, double*, double*,
+                        const int&, int&, long, long);
 
-  int F77_FCN (dgehrd) (const int*, const int*, const int*,
-                        double*, const int*, double*, double*,
-                        const int*, int*, long, long);
+  int F77_FCN (dorghr) (const int&, const int&, const int&,
+                        double*, const int&, double*, double*,
+                        const int&, int&, long, long);
 
-  int F77_FCN (dorghr) (const int*, const int*, const int*,
-                        double*, const int*, double*, double*,
-                        const int*, int*, long, long);
+  int F77_FCN (dgebak) (const char*, const char*, const int&, const int&,
+			const int&, double*, const int&, double*, const int&,
+			int&, long, long);
 }
 
 int
 HESS::init (const Matrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("HESS requires square matrix");
       return -1;
     }
 
-  char jobbal = 'N';
-  char side = 'R';
+  char *jobbal = "N";
+  char *side = "R";
 
   int n = a_nc;
   int lwork = 32 * n;
   int info;
   int ilo;
   int ihi;
 
   double *h = dup (a.data (), a.length ());
 
   double *tau = new double [n+1];
   double *scale = new double [n];
   double *z = new double [n*n];
   double *work = new double [lwork];
 
-  F77_FCN (dgebal) (&jobbal, &n, h, &n, &ilo, &ihi, scale, &info,
-		    1L, 1L);
+  F77_FCN (dgebal) (jobbal, n, h, n, ilo, ihi, scale, info, 1L, 1L);
 
-  F77_FCN (dgehrd) (&n, &ilo, &ihi, h, &n, tau, work, &lwork, &info,
-		    1L, 1L);
+  F77_FCN (dgehrd) (n, ilo, ihi, h, n, tau, work, lwork, info, 1L, 1L);
 
   copy (z, h, n*n);
 
-  F77_FCN (dorghr) (&n, &ilo, &ihi, z, &n, tau, work, &lwork, &info,
-		    1L, 1L);
+  F77_FCN (dorghr) (n, ilo, ihi, z, n, tau, work, lwork, info, 1L, 1L);
 
-  F77_FCN (dgebak) (&jobbal, &side, &n, &ilo, &ihi, scale, &n, z, &n, 
-		    &info, 1L, 1L);
+  F77_FCN (dgebak) (jobbal, side, n, ilo, ihi, scale, n, z, n, info, 1L, 1L);
 
 // We need to clear out all of the area below the sub-diagonal which was used
 // to store the unitary matrix.
 
   hess_mat = Matrix (h, n, n);
   unitary_hess_mat = Matrix (z, n, n);
 
 // If someone thinks of a more graceful way of doing this (or faster for 
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -27,18 +27,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleLU.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgesv) (const int*, const int*, double*, const int*,
-		       int*, double*, const int*, int*);
+  int F77_FCN (dgesv) (const int&, const int&, double*, const int&,
+		       int*, double&, const int&, int&);
 }
 
 LU::LU (const Matrix& a)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr == 0 || a_nc == 0 || a_nr != a_nc)
     {
@@ -47,20 +47,19 @@ LU::LU (const Matrix& a)
     }
 
   int n = a_nr;
 
   int *ipvt = new int [n];
   int *pvt = new int [n];
   double *tmp_data = dup (a.data (), a.length ());
   int info = 0;
-  int zero = 0;
   double b;
 
-  F77_FCN (dgesv) (&n, &zero, tmp_data, &n, ipvt, &b, &n, &info);
+  F77_FCN (dgesv) (n, 0, tmp_data, n, ipvt, b, n, info);
 
   Matrix A_fact (tmp_data, n, n);
 
   int i;
 
   for (i = 0; i < n; i++)
     {
       ipvt[i] -= 1;
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -27,24 +27,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleQR.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgeqrf) (const int*, const int*, double*, const int*,
-			double*, double*, const int*, int*);
+  int F77_FCN (dgeqrf) (const int&, const int&, double*, const int&,
+			double*, double*, const int&, int&);
 
-  int F77_FCN (dorgqr) (const int*, const int*, const int*, double*,
-			const int*, double*, double*, const int*, int*);
-
-  int F77_FCN (dgeqpf) (const int*, const int*, double*, const int*,
-			int*, double*, double*, int*);
+  int F77_FCN (dorgqr) (const int&, const int&, const int&, double*,
+			const int&, double*, double*, const int&, int&);
 }
 
 QR::QR (const Matrix& a, QR::type qr_type)
 {
   int m = a.rows ();
   int n = a.cols ();
 
   if (m == 0 || n == 0)
@@ -63,17 +60,17 @@ QR::QR (const Matrix& a, QR::type qr_typ
   if (m > n)
     {
       tmp_data = new double [m*m];
       copy (tmp_data, a.data (), a.length ());
     }
   else
     tmp_data = dup (a.data (), a.length ());
 
-  F77_FCN (dgeqrf) (&m, &n, tmp_data, &m, tau, work, &lwork, &info);
+  F77_FCN (dgeqrf) (m, n, tmp_data, m, tau, work, lwork, info);
 
   delete [] work;
 
   if (qr_type == QR::raw)
     {
       for (int j = 0; j < min_mn; j++)
 	{
 	  int limit = j < min_mn - 1 ? j : min_mn - 1;
@@ -100,18 +97,17 @@ QR::QR (const Matrix& a, QR::type qr_typ
 	  int limit = j < min_mn-1 ? j : min_mn-1;
 	  for (int i = 0; i <= limit; i++)
 	    r.elem (i, j) = tmp_data[m*j+i];
 	}
 
       lwork = 32*m;
       work = new double[lwork];
 
-      F77_FCN (dorgqr) (&m, &m, &min_mn, tmp_data, &m, tau, work,
-			&lwork, &info);
+      F77_FCN (dorgqr) (m, m, min_mn, tmp_data, m, tau, work, lwork, info);
 
       q = Matrix (tmp_data, m, m);
       q.resize (m, n2);
 
       delete [] tau;
       delete [] work;
     }
 }
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -29,21 +29,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "dbleQRP.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgeqpf) (const int*, const int*, double*, const int*,
-			int*, double*, double*, int*);
+  int F77_FCN (dgeqpf) (const int&, const int&, double*, const int&,
+			int*, double*, double*, int&);
 
-  int F77_FCN (dorgqr) (const int*, const int*, const int*, double*,
-			const int*, double*, double*, const int*, int*);
+  int F77_FCN (dorgqr) (const int&, const int&, const int&, double*,
+			const int&, double*, double*, const int&, int&);
 }
 
 // It would be best to share some of this code with QR class...
 
 QRP::QRP (const Matrix& a, QR::type qr_type)
 {
   assert (qr_type != QR::raw);
 
@@ -74,17 +74,17 @@ QRP::QRP (const Matrix& a, QR::type qr_t
   int *jpvt = new int[n];
 
 // Clear Pivot vector (code to enforce a certain permutation would go
 // here...)
 
   for (int i = 0; i < n; i++)
     jpvt[i] = 0;
 
-  F77_FCN (dgeqpf) (&m, &n, tmp_data, &m, jpvt, tau, work, &info);
+  F77_FCN (dgeqpf) (m, n, tmp_data, m, jpvt, tau, work, info);
 
 // Form Permutation matrix (if economy is requested, return the
 // indices only!)
 
   if (qr_type == QR::economy && m > n)
     {
       p.resize (1, n, 0.0);
       for (int j = 0; j < n; j++)
@@ -117,18 +117,17 @@ QRP::QRP (const Matrix& a, QR::type qr_t
       int limit = j < min_mn-1 ? j : min_mn-1;
       for (int i = 0; i <= limit; i++)
 	r.elem (i, j) = tmp_data[m*j+i];
     }
 
   lwork = 32*m;
   work = new double[lwork];
 
-  F77_FCN (dorgqr) (&m, &m, &min_mn, tmp_data, &m, tau, work,
-		    &lwork, &info);
+  F77_FCN (dorgqr) (m, m, min_mn, tmp_data, m, tau, work, lwork, info);
 
   q = Matrix (tmp_data, m, m);
   q.resize (m, n2);
 
   delete [] tau;
   delete [] work;
 }
 
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -28,55 +28,55 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "dbleSCHUR.h"
 #include "mx-inlines.cc"
 #include "lo-error.h"
 #include "f77-uscore.h"
 
 extern "C"
 {
   int F77_FCN (dgeesx) (const char*, const char*,
-			int (*)(double*, double*), const char*,
-			const int*, double*, const int*, int*, double*,
-			double*, double*, const int*, double*, double*, 
-			double*, const int*, int*, const int*, int*,
-			int*, long, long);
+			int (*)(const double&, const double&),
+			const char*, const int&, double*, const int&,
+			int&, double*, double*, double*, const int&,
+			double&, double&, double*, const int&, int*,
+			const int&, int*, int&, long, long);
 }
 
 static int
-select_ana (double *a, double *b)
+select_ana (const double& a, const double& b)
 {
-   return (*a < 0.0);
+   return (a < 0.0);
 }
 
 static int
-select_dig (double *a, double *b)
+select_dig (const double& a, const double& b)
 {
-  return (hypot (*a, *b) < 1.0);
+  return (hypot (a, b) < 1.0);
 }
 
 int
 SCHUR::init (const Matrix& a, const char *ord)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("SCHUR requires square matrix");
       return -1;
     }
 
-  char jobvs = 'V';
-  char sort;
+  char *jobvs = "V";
+  char *sort;
 
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
-    sort = 'S';
+    sort = "S";
   else
-    sort = 'N';
+    sort = "N";
 
-  char sense = 'N';
+  char *sense = "N";
 
   int n = a_nc;
   int lwork = 8 * n;
   int liwork = 1;
   int info;
   int sdim;
   double rconde;
   double rcondv;
@@ -95,32 +95,32 @@ SCHUR::init (const Matrix& a, const char
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
     {
       iwork = new int [liwork];
       bwork = new int [n];
     }
 
   if (*ord == 'A' || *ord == 'a')
     {
-      F77_FCN (dgeesx) (&jobvs, &sort, select_ana, &sense, &n, s, &n,
-			&sdim, wr, wi, q, &n, &rconde, &rcondv, work,
-			&lwork, iwork, &liwork, bwork, &info, 1L, 1L);
+      F77_FCN (dgeesx) (jobvs, sort, select_ana, sense, n, s, n,
+			sdim, wr, wi, q, n, rconde, rcondv, work,
+			lwork, iwork, liwork, bwork, info, 1L, 1L);
     }
   else if (*ord == 'D' || *ord == 'd')
     {
-      F77_FCN (dgeesx) (&jobvs, &sort, select_dig, &sense, &n, s, &n,
-			&sdim, wr, wi, q, &n, &rconde, &rcondv, work,
-			&lwork, iwork, &liwork, bwork, &info, 1L, 1L);
+      F77_FCN (dgeesx) (jobvs, sort, select_dig, sense, n, s, n,
+			sdim, wr, wi, q, n, rconde, rcondv, work,
+			lwork, iwork, liwork, bwork, info, 1L, 1L);
       
     }
   else
     {
-      F77_FCN (dgeesx) (&jobvs, &sort, (void *) 0, &sense, &n, s,
-			&n, &sdim, wr, wi, q, &n, &rconde, &rcondv,
-			work, &lwork, iwork, &liwork, bwork, &info,
+      F77_FCN (dgeesx) (jobvs, sort, (void *) 0, sense, n, s,
+			n, sdim, wr, wi, q, n, rconde, rcondv,
+			work, lwork, iwork, liwork, bwork, info,
 			1L, 1L);
     }
 
   schur_mat = Matrix (s, n, n);
   unitary_mat = Matrix (q, n, n);
 
   delete [] wr;
   delete [] wi;
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -26,60 +26,60 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include "dbleSVD.h"
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 
 extern "C"
 {
-  int F77_FCN (dgesvd) (const char*, const char*, const int*,
-			const int*, double*, const int*, double*,
-			double*, const int*, double*, const int*,
-			double*, const int*, int*, long, long);
+  int F77_FCN (dgesvd) (const char*, const char*, const int&,
+			const int&, double*, const int&, double*,
+			double*, const int&, double*, const int&,
+			double*, const int&, int&, long, long);
 }
 
 int
 SVD::init (const Matrix& a, SVD::type svd_type)
 {
   int info;
 
   int m = a.rows ();
   int n = a.cols ();
 
   double *tmp_data = dup (a.data (), a.length ());
 
   int min_mn = m < n ? m : n;
   int max_mn = m > n ? m : n;
 
-  char jobu = 'A';
-  char jobv = 'A';
+  char *jobu = "A";
+  char *jobv = "A";
 
   int ncol_u = m;
   int nrow_vt = n;
   int nrow_s = m;
   int ncol_s = n;
 
   if (svd_type == SVD::economy)
     {
-      jobu = jobv = 'S';
+      jobu = jobv ="S";
       ncol_u = nrow_vt = nrow_s = ncol_s = min_mn;
     }
 
   double *u = new double[m * ncol_u];
   double *s_vec  = new double[min_mn];
   double *vt = new double[nrow_vt * n];
 
   int tmp1 = 3*min_mn + max_mn;
   int tmp2 = 5*min_mn - 4;
   int lwork = tmp1 > tmp2 ? tmp1 : tmp2;
   double *work = new double[lwork];
 
-  F77_FCN (dgesvd) (&jobu, &jobv, &m, &n, tmp_data, &m, s_vec, u, &m,
-		    vt, &nrow_vt, work, &lwork, &info, 1L, 1L);
+  F77_FCN (dgesvd) (jobu, jobv, m, n, tmp_data, m, s_vec, u, m,
+		    vt, nrow_vt, work, lwork, info, 1L, 1L);
 
   left_sm = Matrix (u, m, ncol_u);
   sigma = DiagMatrix (s_vec, nrow_s, ncol_s);
   Matrix vt_m (vt, nrow_vt, n);
   right_sm = vt_m.transpose ();
 
   delete [] tmp_data;
   delete [] work;
