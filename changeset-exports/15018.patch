# HG changeset patch
# User Rik <rik@octave.org>
# Date 1343315602 25200
#      Thu Jul 26 08:13:22 2012 -0700
# Node ID 3d8ace26c5b49a8e0fc0e603b44894c0a5bad1a1
# Parent  dd4ad69e4ab9ef46d2ecdfc991493a5f38af952c
maint: Use Octave coding conventions for cuddled parentheses in liboctave/.

* Array-util.cc, Array.cc, Array.h, CMatrix.cc, CNDArray.cc, CSparse.cc,
CmplxQR.cc, CollocWt.cc, DASPK.cc, DASRT.cc, DASSL.cc, EIG.cc, LSODE.cc,
MSparse.cc, MatrixType.cc, Sparse-op-defs.h, Sparse-perm-op-defs.h, Sparse.cc,
Sparse.h, SparseCmplxCHOL.cc, SparseCmplxLU.cc, SparseCmplxQR.cc, SparseQR.cc,
SparsedbleCHOL.cc, SparsedbleLU.cc, boolSparse.cc, cmd-hist.cc, dDiagMatrix.cc,
dMatrix.cc, dNDArray.cc, dSparse.cc, data-conv.cc, dbleQR.cc, dbleSVD.cc,
dim-vector.cc, eigs-base.cc, f2c-main.c, fCMatrix.cc, fCNDArray.cc,
fCmplxQR.cc, fEIG.cc, fMatrix.cc, fNDArray.cc, floatQR.cc, floatSVD.cc,
idx-vector.cc, kpse.cc, lo-specfun.cc, mx-inlines.cc, mx-op-defs.h,
oct-alloc.cc, oct-binmap.h, oct-fftw.cc, oct-group.h, oct-inttypes.cc,
oct-inttypes.h, oct-locbuf.cc, oct-md5.cc, oct-rand.cc, oct-sort.cc,
oct-syscalls.cc, randgamma.c, randmtzig.c, randpoisson.c, sparse-base-chol.cc,
sparse-base-lu.cc, sparse-dmsolve.cc, str-vec.cc, str-vec.h, tempnam.c,
tempname.c: Use Octave coding conventions for cuddled parentheses in liboctave/.

diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -440,17 +440,17 @@ zero_dims_inquire (const Array<idx_vecto
       all_colons = all_colons && colon[i];
     }
 
   // If the number of nonscalar indices matches the dimensionality of
   // RHS, we try an exact match, inquiring even singleton dimensions.
   if (all_colons)
     {
       rdv = rhdv;
-      rdv.resize(ial, 1);
+      rdv.resize (ial, 1);
     }
   else if (nonsc == rhdvl)
     {
       for (int i = 0, j = 0; i < ial; i++)
         {
           if (scalar[i]) continue;
           if (colon[i])
             rdv(i) = rhdv(j);
@@ -461,17 +461,17 @@ zero_dims_inquire (const Array<idx_vecto
     {
       dim_vector rhdv0 = rhdv;
       rhdv0.chop_all_singletons ();
       int rhdv0l = rhdv0.length ();
       for (int i = 0, j = 0; i < ial; i++)
         {
           if (scalar[i]) continue;
           if (colon[i])
-            rdv(i) =  (j < rhdv0l) ? rhdv0(j++) : 1;
+            rdv(i) = (j < rhdv0l) ? rhdv0(j++) : 1;
         }
     }
 
   delete [] scalar;
   delete [] colon;
 
   return rdv;
 }
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -718,27 +718,27 @@ Array<T>::index (const idx_vector& i) co
         gripe_index_out_of_range (1, 1, i.extent (n), n); // throws
 
       // FIXME -- this is the only place where orig_dimensions are used.
       dim_vector rd = i.orig_dimensions ();
       octave_idx_type il = i.length (n);
 
       // FIXME -- this is for Matlab compatibility.  Matlab 2007 given
       //
-      //   b = ones(3,1)
+      //   b = ones (3,1)
       //
       // yields the following:
       //
-      //   b(zeros(0,0)) gives []
-      //   b(zeros(1,0)) gives zeros(0,1)
-      //   b(zeros(0,1)) gives zeros(0,1)
-      //   b(zeros(0,m)) gives zeros(0,m)
-      //   b(zeros(m,0)) gives zeros(m,0)
-      //   b(1:2) gives ones(2,1)
-      //   b(ones(2)) gives ones(2) etc.
+      //   b(zeros (0,0)) gives []
+      //   b(zeros (1,0)) gives zeros (0,1)
+      //   b(zeros (0,1)) gives zeros (0,1)
+      //   b(zeros (0,m)) gives zeros (0,m)
+      //   b(zeros (m,0)) gives zeros (m,0)
+      //   b(1:2) gives ones (2,1)
+      //   b(ones (2)) gives ones (2) etc.
       //
       // As you can see, the behaviour is weird, but the tests end up pretty
       // simple.  Nah, I don't want to suggest that this is ad hoc :)
 
       if (ndims () == 2 && n != 1 && rd.is_vector ())
         {
           if (columns () == 1)
             rd = dim_vector (il, 1);
@@ -2218,23 +2218,23 @@ Array<T>::find (octave_idx_type n, bool 
                 break;
             }
           if (k < n)
             retval.resize2 (k, 1);
         }
     }
 
   // Fixup return dimensions, for Matlab compatibility.
-  // find(zeros(0,0)) -> zeros(0,0)
-  // find(zeros(1,0)) -> zeros(1,0)
-  // find(zeros(0,1)) -> zeros(0,1)
-  // find(zeros(0,X)) -> zeros(0,1)
-  // find(zeros(1,1)) -> zeros(0,0) !!!! WHY?
-  // find(zeros(0,1,0)) -> zeros(0,0)
-  // find(zeros(0,1,0,1)) -> zeros(0,0) etc
+  // find (zeros (0,0)) -> zeros (0,0)
+  // find (zeros (1,0)) -> zeros (1,0)
+  // find (zeros (0,1)) -> zeros (0,1)
+  // find (zeros (0,X)) -> zeros (0,1)
+  // find (zeros (1,1)) -> zeros (0,0) !!!! WHY?
+  // find (zeros (0,1,0)) -> zeros (0,0)
+  // find (zeros (0,1,0,1)) -> zeros (0,0) etc
 
   if ((numel () == 1 && retval.is_empty ())
       || (rows () == 0 && dims ().numel (1) == 0))
     retval.dimensions = dim_vector ();
   else if (rows () == 1 && ndims () == 2)
     retval.dimensions = dim_vector (1, retval.length ());
 
   return retval;
@@ -2736,29 +2736,29 @@ operator << (std::ostream& os, const Arr
               cols = a_dims(1);
 
               for (octave_idx_type j = 0; j < rows; j++)
                 {
                   ra_idx(0) = j;
                   for (octave_idx_type k = 0; k < cols; k++)
                     {
                       ra_idx(1) = k;
-                      os << " " << a.elem(ra_idx);
+                      os << " " << a.elem (ra_idx);
                     }
                   os << "\n";
                 }
               break;
 
             default:
               rows = a_dims(0);
 
               for (octave_idx_type k = 0; k < rows; k++)
                 {
                   ra_idx(0) = k;
-                  os << " " << a.elem(ra_idx);
+                  os << " " << a.elem (ra_idx);
                 }
               break;
             }
 
           os << "\n";
         }
       else
         {
@@ -2776,17 +2776,17 @@ operator << (std::ostream& os, const Arr
 
               for (octave_idx_type j = 0; j < rows; j++)
                 {
                   ra_idx(0) = j;
 
                   for (octave_idx_type k = 0; k < cols; k++)
                     {
                       ra_idx(1) = k;
-                      os << " " << a.elem(ra_idx);
+                      os << " " << a.elem (ra_idx);
                     }
 
                   os << "\n";
                 }
 
               os << "\n";
 
               if (i != m - 1)
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -327,18 +327,18 @@ public:
   octave_idx_type compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k) const;
   octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx) const;
 
   octave_idx_type compute_index_unchecked (const Array<octave_idx_type>& ra_idx) const
     { return dimensions.compute_index (ra_idx.data (), ra_idx.length ()); }
 
   // No checking, even for multiple references, ever.
 
-  T& xelem (octave_idx_type n) { return slice_data [n]; }
-  crefT xelem (octave_idx_type n) const { return slice_data [n]; }
+  T& xelem (octave_idx_type n) { return slice_data[n]; }
+  crefT xelem (octave_idx_type n) const { return slice_data[n]; }
 
   T& xelem (octave_idx_type i, octave_idx_type j) { return xelem (dim1 ()*j+i); }
   crefT xelem (octave_idx_type i, octave_idx_type j) const { return xelem (dim1 ()*j+i); }
 
   T& xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
     { return xelem (i, dim2 ()*k+j); }
   crefT xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
     { return xelem (i, dim2 ()*k+j); }
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1074,27 +1074,27 @@ ComplexMatrix::finverse (MatrixType &mat
       Array<Complex> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
                                  z.fortran_vec (), lwork, info));
 
-      lwork = static_cast<octave_idx_type> (std::real(z(0)));
+      lwork = static_cast<octave_idx_type> (std::real (z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (dim_vector (lwork, 1));
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
-        anorm  = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1158,17 +1158,17 @@ ComplexMatrix::inverse (MatrixType &matt
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (!mattype.is_hermitian ())
-        ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = ComplexMatrix (rows (), columns (), Complex (octave_Inf, 0.));
     }
 
   return ret;
 }
 
@@ -1827,17 +1827,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-              if(anorm < 0.)
+              if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
@@ -2095,17 +2095,17 @@ ComplexMatrix::fsolve (MatrixType &matty
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -2179,17 +2179,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2405,17 +2405,17 @@ ComplexMatrix::solve (MatrixType &typ, c
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   ComplexMatrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
-  return tmp.column(static_cast<octave_idx_type> (0));
+  return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -235,17 +235,17 @@ ComplexNDArray::fourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
@@ -282,17 +282,17 @@ ComplexNDArray::ifourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<double> (npts);
         }
     }
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -167,37 +167,37 @@ SparseComplexMatrix::SparseComplexMatrix
       if (a(i, i) != 0.0)
         {
           data (j) = a(i, i);
           ridx (j) = i;
           j++;
         }
     }
   for (octave_idx_type i = l; i <= a.cols (); i++)
-    cidx(i) = j;
+    cidx (i) = j;
 }
 bool
 SparseComplexMatrix::operator == (const SparseComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz = nnz ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    if (cidx(i) != a.cidx(i))
+    if (cidx (i) != a.cidx (i))
         return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
-    if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
+    if (data (i) != a.data (i) || ridx (i) != a.ridx (i))
       return false;
 
   return true;
 }
 
 bool
 SparseComplexMatrix::operator != (const SparseComplexMatrix& a) const
 {
@@ -209,29 +209,29 @@ SparseComplexMatrix::is_hermitian (void)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == nc && nr > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              octave_idx_type ri = ridx(i);
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              octave_idx_type ri = ridx (i);
 
               if (ri != j)
                 {
                   bool found = false;
 
-                  for (octave_idx_type k = cidx(ri); k < cidx(ri+1); k++)
+                  for (octave_idx_type k = cidx (ri); k < cidx (ri+1); k++)
                     {
-                      if (ridx(k) == j)
+                      if (ridx (k) == j)
                         {
-                          if (data(i) == conj(data(k)))
+                          if (data (i) == conj (data (k)))
                             found = true;
                           break;
                         }
                     }
 
                   if (! found)
                     return false;
                 }
@@ -272,31 +272,31 @@ SparseComplexMatrix::max (Array<octave_i
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp_max;
           double abs_max = octave_NaN;
           octave_idx_type idx_j = 0;
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              if (ridx(i) != idx_j)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
 
           if (idx_j != nr)
             {
               tmp_max = 0.;
               abs_max = 0.;
             }
 
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               Complex tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
 
               double abs_tmp = std::abs (tmp);
 
@@ -327,55 +327,55 @@ SparseComplexMatrix::max (Array<octave_i
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, 1), 0);
 
-      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-        idx_arg.elem(ridx(i)) = -1;
+      for (octave_idx_type i = cidx (0); i < cidx (1); i++)
+        idx_arg.elem (ridx (i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            if (idx_arg.elem(i) != -1)
+            if (idx_arg.elem (i) != -1)
               continue;
             bool found = false;
-            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-              if (ridx(k) == i)
+            for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
+              if (ridx (k) == i)
                 {
                   found = true;
                   break;
                 }
 
             if (!found)
-              idx_arg.elem(i) = j;
+              idx_arg.elem (i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               Complex tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
-              else if (ix == -1 || std::abs(tmp) > std::abs(elem (ir, ix)))
+              else if (ix == -1 || std::abs (tmp) > std::abs (elem (ir, ix)))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+        if (idx_arg.elem (j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
           nel++;
 
       result = SparseComplexMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -427,31 +427,31 @@ SparseComplexMatrix::min (Array<octave_i
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp_min;
           double abs_min = octave_NaN;
           octave_idx_type idx_j = 0;
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              if (ridx(i) != idx_j)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
 
           if (idx_j != nr)
             {
               tmp_min = 0.;
               abs_min = 0.;
             }
 
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               Complex tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
 
               double abs_tmp = std::abs (tmp);
 
@@ -482,55 +482,55 @@ SparseComplexMatrix::min (Array<octave_i
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, 1), 0);
 
-      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-        idx_arg.elem(ridx(i)) = -1;
+      for (octave_idx_type i = cidx (0); i < cidx (1); i++)
+        idx_arg.elem (ridx (i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            if (idx_arg.elem(i) != -1)
+            if (idx_arg.elem (i) != -1)
               continue;
             bool found = false;
-            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-              if (ridx(k) == i)
+            for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
+              if (ridx (k) == i)
                 {
                   found = true;
                   break;
                 }
 
             if (!found)
-              idx_arg.elem(i) = j;
+              idx_arg.elem (i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               Complex tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
-              else if (ix == -1 || std::abs(tmp) < std::abs(elem (ir, ix)))
+              else if (ix == -1 || std::abs (tmp) < std::abs (elem (ir, ix)))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+        if (idx_arg.elem (j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
           nel++;
 
       result = SparseComplexMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -658,17 +658,17 @@ SparseComplexMatrix::hermitian (void) co
     {
       const octave_idx_type tmp = retval.xcidx (i);
       retval.xcidx (i) = nz;
       nz += tmp;
     }
   // retval.xcidx[1:nr] holds row entry *start* offsets for rows 0:(nr-1)
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+    for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
       {
         octave_idx_type q = retval.xcidx (ridx (k) + 1)++;
         retval.xridx (q) = j;
         retval.xdata (q) = conj (data (k));
       }
   assert (nnz () == retval.xcidx (nr));
   // retval.xcidx[1:nr] holds row entry *end* offsets for rows 0:(nr-1)
   // and retval.xcidx[0:(nr-1)] holds their row entry *start* offsets
@@ -750,17 +750,17 @@ SparseComplexMatrix::dinverse (MatrixTyp
           // Force make_unique to be called
           Complex *v = retval.data ();
 
           if (calccond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
-                  double tmp = std::abs(v[i]);
+                  double tmp = std::abs (v[i]);
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
 
@@ -800,18 +800,18 @@ SparseComplexMatrix::tinverse (MatrixTyp
           double ainvnorm = 0.;
 
           if (calccond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Upper || typ == MatrixType::Lower)
             {
               octave_idx_type nz = nnz ();
@@ -826,102 +826,102 @@ SparseComplexMatrix::tinverse (MatrixTyp
                   octave_idx_type cx_colstart = cx;
 
                   if (cx == nz2)
                     {
                       nz2 *= 2;
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx(i) = cx;
-                  retval.xridx(cx) = i;
-                  retval.xdata(cx) = 1.0;
+                  retval.xcidx (i) = cx;
+                  retval.xridx (cx) = i;
+                  retval.xdata (cx) = 1.0;
                   cx++;
 
                   // iterate accross columns of input matrix
                   for (octave_idx_type j = i+1; j < nr; j++)
                     {
                       Complex v = 0.;
                       // iterate to calculate sum
-                      octave_idx_type colXp = retval.xcidx(i);
-                      octave_idx_type colUp = cidx(j);
+                      octave_idx_type colXp = retval.xcidx (i);
+                      octave_idx_type colUp = cidx (j);
                       octave_idx_type rpX, rpU;
 
-                      if (cidx(j) == cidx(j+1))
+                      if (cidx (j) == cidx (j+1))
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       do
                         {
                           octave_quit ();
-                          rpX = retval.xridx(colXp);
-                          rpU = ridx(colUp);
+                          rpX = retval.xridx (colXp);
+                          rpU = ridx (colUp);
 
                           if (rpX < rpU)
                             colXp++;
                           else if (rpX > rpU)
                             colUp++;
                           else
                             {
-                              v -= retval.xdata(colXp) * data(colUp);
+                              v -= retval.xdata (colXp) * data (colUp);
                               colXp++;
                               colUp++;
                             }
                         } while ((rpX<j) && (rpU<j) &&
                                  (colXp<cx) && (colUp<nz));
 
 
                       // get A(m,m)
                       if (typ == MatrixType::Upper)
-                        colUp = cidx(j+1) - 1;
+                        colUp = cidx (j+1) - 1;
                       else
-                        colUp = cidx(j);
-                      Complex pivot = data(colUp);
-                      if (pivot == 0. || ridx(colUp) != j)
+                        colUp = cidx (j);
+                      Complex pivot = data (colUp);
+                      if (pivot == 0. || ridx (colUp) != j)
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       if (v != 0.)
                         {
                           if (cx == nz2)
                             {
                               nz2 *= 2;
                               retval.change_capacity (nz2);
                             }
 
-                          retval.xridx(cx) = j;
-                          retval.xdata(cx) = v / pivot;
+                          retval.xridx (cx) = j;
+                          retval.xdata (cx) = v / pivot;
                           cx++;
                         }
                     }
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Upper)
-                    colUp = cidx(i+1) - 1;
+                    colUp = cidx (i+1) - 1;
                   else
-                    colUp = cidx(i);
-                  Complex pivot = data(colUp);
-                  if (pivot == 0. || ridx(colUp) != i)
+                    colUp = cidx (i);
+                  Complex pivot = data (colUp);
+                  if (pivot == 0. || ridx (colUp) != i)
                     {
                       (*current_liboctave_error_handler) ("division by zero");
                       goto inverse_singular;
                     }
 
                   if (pivot != 1.0)
                     for (octave_idx_type j = cx_colstart; j < cx; j++)
-                      retval.xdata(j) /= pivot;
-                }
-              retval.xcidx(nr) = cx;
+                      retval.xdata (j) /= pivot;
+                }
+              retval.xcidx (nr) = cx;
               retval.maybe_compress ();
             }
           else
             {
               octave_idx_type nz = nnz ();
               octave_idx_type cx = 0;
               octave_idx_type nz2 = nz;
               retval = SparseComplexMatrix (nr, nc, nz2);
@@ -955,47 +955,47 @@ SparseComplexMatrix::tinverse (MatrixTyp
                   work[iidx] = 1.0;
 
                   // iterate accross columns of input matrix
                   for (octave_idx_type j = iidx+1; j < nr; j++)
                     {
                       Complex v = 0.;
                       octave_idx_type jidx = perm[j];
                       // iterate to calculate sum
-                      for (octave_idx_type k = cidx(jidx);
-                           k < cidx(jidx+1); k++)
+                      for (octave_idx_type k = cidx (jidx);
+                           k < cidx (jidx+1); k++)
                         {
                           octave_quit ();
-                          v -= work[ridx(k)] * data(k);
+                          v -= work[ridx (k)] * data (k);
                         }
 
                       // get A(m,m)
                       Complex pivot;
                       if (typ == MatrixType::Permuted_Upper)
-                        pivot = data(cidx(jidx+1) - 1);
+                        pivot = data (cidx (jidx+1) - 1);
                       else
-                        pivot = data(cidx(jidx));
+                        pivot = data (cidx (jidx));
                       if (pivot == 0.)
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       work[j] = v / pivot;
                     }
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Permuted_Upper)
-                    colUp = cidx(perm[iidx]+1) - 1;
+                    colUp = cidx (perm[iidx]+1) - 1;
                   else
-                    colUp = cidx(perm[iidx]);
-
-                  Complex pivot = data(colUp);
+                    colUp = cidx (perm[iidx]);
+
+                  Complex pivot = data (colUp);
                   if (pivot == 0.)
                     {
                       (*current_liboctave_error_handler)
                         ("division by zero");
                       goto inverse_singular;
                     }
 
                   octave_idx_type new_cx = cx;
@@ -1008,38 +1008,38 @@ SparseComplexMatrix::tinverse (MatrixTyp
                       }
 
                   if (cx < new_cx)
                     {
                       nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx(i) = cx;
+                  retval.xcidx (i) = cx;
                   for (octave_idx_type j = iidx; j < nr; j++)
                     if (work[j] != 0.)
                       {
-                        retval.xridx(cx) = j;
-                        retval.xdata(cx++) = work[j];
+                        retval.xridx (cx) = j;
+                        retval.xdata (cx++) = work[j];
                       }
                 }
 
-              retval.xcidx(nr) = cx;
+              retval.xcidx (nr) = cx;
               retval.maybe_compress ();
             }
 
           if (calccond)
             {
               // Calculate the 1-norm of inverse matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = retval.cidx(j);
-                       i < retval.cidx(j+1); i++)
-                    atmp += std::abs(retval.data(i));
+                  for (octave_idx_type i = retval.cidx (j);
+                       i < retval.cidx (j+1); i++)
+                    atmp += std::abs (retval.data (i));
                   if (atmp > ainvnorm)
                     ainvnorm = atmp;
                 }
 
               rcond = 1. / ainvnorm / anorm;
             }
         }
       else
@@ -1078,17 +1078,17 @@ SparseComplexMatrix::inverse (MatrixType
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexCHOL fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
               SparseComplexMatrix InvL = fact.L ().transpose ().
-                tinverse(tmp_typ, info, rcond2, true, false);
+                tinverse (tmp_typ, info, rcond2, true, false);
               ret = Q * InvL.hermitian () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
@@ -1101,19 +1101,19 @@ SparseComplexMatrix::inverse (MatrixType
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexLU fact (*this, Qinit, Matrix (), false, false);
           rcond = fact.rcond ();
           double rcond2;
           SparseComplexMatrix InvL = fact.L ().transpose ().
-            tinverse(tmp_typ, info, rcond2, true, false);
+            tinverse (tmp_typ, info, rcond2, true, false);
           SparseComplexMatrix InvU = fact.U ().
-            tinverse(tmp_typ, info, rcond2, true, false).transpose ();
+            tinverse (tmp_typ, info, rcond2, true, false).transpose ();
           ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
 ComplexDET
@@ -1274,33 +1274,33 @@ SparseComplexMatrix::dsolve (MatrixType 
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols (), Complex(0.,0.));
+          retval.resize (nc, b.cols (), Complex (0.,0.));
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                  retval(k,j) = b(ridx(i),j) / data (i);
+                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                  retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = std::abs(data(i));
+                  double tmp = std::abs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1339,59 +1339,59 @@ SparseComplexMatrix::dsolve (MatrixType 
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
-                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                   {
-                    if (b.ridx(i) >= nm)
+                    if (b.ridx (i) >= nm)
                       break;
-                    retval.xridx (ii) = b.ridx(i);
-                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                    retval.xridx (ii) = b.ridx (i);
+                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
                   }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
-                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-                        if (ridx(i) == b.ridx(k))
+                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                        if (ridx (i) == b.ridx (k))
                           {
                             found = true;
                             break;
                           }
                       if (found)
                         {
                           retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data(k) / data (i);
+                          retval.xdata (ii++) = b.data (k) / data (i);
                         }
                     }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = std::abs(data(i));
+                  double tmp = std::abs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1426,33 +1426,33 @@ SparseComplexMatrix::dsolve (MatrixType 
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols (), Complex(0.,0.));
+          retval.resize (nc, b.cols (), Complex (0.,0.));
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                  retval(k,j) = b(ridx(i),j) / data (i);
+                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                  retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
-                  double tmp = std::abs(data(i));
+                  double tmp = std::abs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1491,59 +1491,59 @@ SparseComplexMatrix::dsolve (MatrixType 
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
-                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                   {
-                    if (b.ridx(i) >= nm)
+                    if (b.ridx (i) >= nm)
                       break;
-                    retval.xridx (ii) = b.ridx(i);
-                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                    retval.xridx (ii) = b.ridx (i);
+                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
                   }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
-                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-                        if (ridx(i) == b.ridx(k))
+                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                        if (ridx (i) == b.ridx (k))
                           {
                             found = true;
                             break;
                           }
                       if (found)
                         {
                           retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data(k) / data (i);
+                          retval.xdata (ii++) = b.data (k) / data (i);
                         }
                     }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = std::abs(data(i));
+                  double tmp = std::abs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1589,18 +1589,18 @@ SparseComplexMatrix::utsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Upper)
             {
               retval.resize (nc, b_nc);
@@ -1615,30 +1615,30 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(perm[i], j) = work[i];
                 }
 
@@ -1653,30 +1653,30 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -1691,29 +1691,29 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -1726,30 +1726,30 @@ SparseComplexMatrix::utsolve (MatrixType
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              Complex tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -1824,66 +1824,66 @@ SparseComplexMatrix::utsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               octave_idx_type *perm = mattype.triangular_perm ();
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 rperm[perm[i]] = i;
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -1896,20 +1896,20 @@ SparseComplexMatrix::utsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[rperm[i]] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[rperm[i]];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[rperm[i]];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -1920,66 +1920,66 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -1992,20 +1992,20 @@ SparseComplexMatrix::utsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2014,30 +2014,30 @@ SparseComplexMatrix::utsolve (MatrixType
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              Complex tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2112,18 +2112,18 @@ SparseComplexMatrix::utsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Upper)
             {
               retval.resize (nc, b_nc);
@@ -2138,30 +2138,30 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(perm[i], j) = work[i];
                 }
 
@@ -2176,30 +2176,30 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2214,29 +2214,29 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -2249,30 +2249,30 @@ SparseComplexMatrix::utsolve (MatrixType
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              Complex tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2347,66 +2347,66 @@ SparseComplexMatrix::utsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               octave_idx_type *perm = mattype.triangular_perm ();
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 rperm[perm[i]] = i;
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2419,20 +2419,20 @@ SparseComplexMatrix::utsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[rperm[i]] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[rperm[i]];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[rperm[i]];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2443,66 +2443,66 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nr-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2515,20 +2515,20 @@ SparseComplexMatrix::utsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2537,30 +2537,30 @@ SparseComplexMatrix::utsolve (MatrixType
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              Complex tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2636,18 +2636,18 @@ SparseComplexMatrix::ltsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Lower)
             {
               retval.resize (nc, b_nc);
@@ -2663,38 +2663,38 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(mini);
+                          Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(i, j) = work[i];
                 }
 
@@ -2710,42 +2710,42 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              Complex tmp = work[k] / data(mini);
+                              Complex tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2759,29 +2759,29 @@ SparseComplexMatrix::ltsolve (MatrixType
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k));
+                          Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
               if (calc_cond)
@@ -2794,30 +2794,30 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k));
+                              Complex tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2892,71 +2892,71 @@ SparseComplexMatrix::ltsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
               octave_idx_type *perm = mattype.triangular_perm ();
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[perm[b.ridx(i)]] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[perm[b.ridx (i)]] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(mini);
+                          Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2969,20 +2969,20 @@ SparseComplexMatrix::ltsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2994,78 +2994,78 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              Complex tmp = work[k] / data(mini);
+                              Complex tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k));
+                          Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3078,20 +3078,20 @@ SparseComplexMatrix::ltsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3101,30 +3101,30 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k));
+                              Complex tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3200,18 +3200,18 @@ SparseComplexMatrix::ltsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Lower)
             {
               retval.resize (nc, b_nc);
@@ -3227,38 +3227,38 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(mini);
+                          Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(i, j) = work[i];
                 }
 
@@ -3274,42 +3274,42 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              Complex tmp = work[k] / data(mini);
+                              Complex tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3325,29 +3325,29 @@ SparseComplexMatrix::ltsolve (MatrixType
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k));
+                          Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -3361,30 +3361,30 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k));
+                              Complex tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3459,71 +3459,71 @@ SparseComplexMatrix::ltsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
               octave_idx_type *perm = mattype.triangular_perm ();
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[perm[b.ridx(i)]] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[perm[b.ridx (i)]] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(mini);
+                          Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3536,20 +3536,20 @@ SparseComplexMatrix::ltsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3561,78 +3561,78 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              Complex tmp = work[k] / data(mini);
+                              Complex tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k));
+                          Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3645,20 +3645,20 @@ SparseComplexMatrix::ltsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3668,30 +3668,30 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k));
+                              Complex tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3766,38 +3766,38 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = std::real(data(ii++));
-                  DL[j] = data(ii);
+                  D[j] = std::real (data (ii++));
+                  DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = std::real(data(ii));
+              D[nc-1] = std::real (data (ii));
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = std::real(data(i));
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = std::real (data (i));
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
@@ -3820,41 +3820,41 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
@@ -3923,41 +3923,41 @@ SparseComplexMatrix::trisolve (MatrixTyp
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
           if (err != 0)
             {
               err = -2;
@@ -3974,28 +3974,28 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
             }
           else
             {
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseComplexMatrix (nr, b_nc, x_nz);
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               volatile octave_idx_type ii = 0;
               rcond = 1.0;
 
               OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              work, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   // Count non-zeros in work vector and adjust
@@ -4011,20 +4011,20 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4064,38 +4064,38 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = std::real(data(ii++));
-                  DL[j] = data(ii);
+                  D[j] = std::real (data (ii++));
+                  DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = std::real(data(ii));
+              D[nc-1] = std::real (data (ii));
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = std::real (data(i));
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = std::real (data (i));
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
@@ -4119,41 +4119,41 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
@@ -4223,41 +4223,41 @@ SparseComplexMatrix::trisolve (MatrixTyp
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
@@ -4281,17 +4281,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b (i,j);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
@@ -4321,21 +4321,21 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (Bx[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = Bx[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = Bx[i];
                       }
 
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4378,27 +4378,27 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4485,28 +4485,28 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4627,27 +4627,27 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4701,17 +4701,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
                   // Take a first guess that the number of non-zero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b.elem (i, j);
 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
@@ -4735,21 +4735,21 @@ SparseComplexMatrix::bsolve (MatrixType 
                                 {
                                   // Resize the sparse matrix
                                   octave_idx_type sz = x_nz *
                                     (b_nc - j) / b_nc;
                                   sz = (sz > 10 ? sz : 10) + x_nz;
                                   retval.change_capacity (sz);
                                   x_nz = sz;
                                 }
-                              retval.xdata(ii) = tmp;
-                              retval.xridx(ii++) = i;
+                              retval.xdata (ii) = tmp;
+                              retval.xridx (ii++) = i;
                             }
                         }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
@@ -4767,28 +4767,28 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4850,28 +4850,28 @@ SparseComplexMatrix::bsolve (MatrixType 
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
-                      for (octave_idx_type i = b.cidx(j);
-                           i < b.cidx(j+1); i++)
-                        work[b.ridx(i)] = b.data(i);
+                      for (octave_idx_type i = b.cidx (j);
+                           i < b.cidx (j+1); i++)
+                        work[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, work, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       // Count non-zeros in work vector and adjust
@@ -4887,20 +4887,20 @@ SparseComplexMatrix::bsolve (MatrixType 
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) = work[i];
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) = work[i];
                           }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
@@ -4945,27 +4945,27 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5052,28 +5052,28 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5191,27 +5191,27 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5268,17 +5268,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
                   // Take a first guess that the number of non-zero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b (i,j);
 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
@@ -5307,21 +5307,21 @@ SparseComplexMatrix::bsolve (MatrixType 
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) = Bx[i];
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) = Bx[i];
                           }
 
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
@@ -5339,28 +5339,28 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5422,29 +5422,29 @@ SparseComplexMatrix::bsolve (MatrixType 
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         Bx[i] = 0.;
 
-                      for (octave_idx_type i = b.cidx(j);
-                           i < b.cidx(j+1); i++)
-                        Bx[b.ridx(i)] = b.data(i);
+                      for (octave_idx_type i = b.cidx (j);
+                           i < b.cidx (j+1); i++)
+                        Bx[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       // Count non-zeros in work vector and adjust
@@ -5460,20 +5460,20 @@ SparseComplexMatrix::bsolve (MatrixType 
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) = Bx[i];
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) = Bx[i];
                           }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
@@ -5731,17 +5731,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval.resize (b.rows (), b.cols ());
               for (octave_idx_type j = 0; j < b.cols (); j++)
                 {
                   octave_idx_type jr = j * b.rows ();
                   for (octave_idx_type i = 0; i < b.rows (); i++)
-                    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
+                    retval.xelem (i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -5985,22 +5985,22 @@ SparseComplexMatrix::fsolve (MatrixType 
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
                 (static_cast<octave_idx_type>(X->nrow),
                  static_cast<octave_idx_type>(X->ncol),
                  static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
-                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+                retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
-                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-                  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
+                  retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6045,17 +6045,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
 #ifdef UMFPACK_SEPARATE_SPLIT
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
@@ -6100,21 +6100,21 @@ SparseComplexMatrix::fsolve (MatrixType 
                           if (ii == x_nz)
                             {
                               // Resize the sparse matrix
                               octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
                               sz = (sz > 10 ? sz : 10) + x_nz;
                               retval.change_capacity (sz);
                               x_nz = sz;
                             }
-                          retval.xdata(ii) = tmp;
-                          retval.xridx(ii++) = i;
+                          retval.xdata (ii) = tmp;
+                          retval.xridx (ii++) = i;
                         }
                     }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
@@ -6265,17 +6265,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval.resize (b.rows (), b.cols ());
               for (octave_idx_type j = 0; j < b.cols (); j++)
                 {
                   octave_idx_type jr = j * b.rows ();
                   for (octave_idx_type i = 0; i < b.rows (); i++)
-                    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
+                    retval.xelem (i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6498,22 +6498,22 @@ SparseComplexMatrix::fsolve (MatrixType 
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
                 (static_cast<octave_idx_type>(X->nrow),
                  static_cast<octave_idx_type>(X->ncol),
                  static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
-                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+                retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
-                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-                  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
+                  retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6551,17 +6551,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b (i,j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
                                              Ai,
                                              reinterpret_cast<const double *> (Ax),
@@ -6591,21 +6591,21 @@ SparseComplexMatrix::fsolve (MatrixType 
                           if (ii == x_nz)
                             {
                               // Resize the sparse matrix
                               octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
                               sz = (sz > 10 ? sz : 10) + x_nz;
                               retval.change_capacity (sz);
                               x_nz = sz;
                             }
-                          retval.xdata(ii) = tmp;
-                          retval.xridx(ii++) = i;
+                          retval.xdata (ii) = tmp;
+                          retval.xridx (ii++) = i;
                         }
                     }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               rcond = Info (UMFPACK_RCOND);
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (status == UMFPACK_WARNING_singular_matrix ||
@@ -6689,17 +6689,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
         Matrix> (*this, b, err);
 #endif
@@ -6757,17 +6757,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
         SparseMatrix> (*this, b, err);
 #endif
@@ -6825,17 +6825,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
         ComplexMatrix> (*this, b, err);
 #endif
@@ -6894,17 +6894,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
         SparseComplexMatrix> (*this, b, err);
 #endif
@@ -7172,22 +7172,22 @@ SparseComplexMatrix::operator ! (void) c
 
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
         {
-          if (jj < cidx(i+1) && ridx(jj) == j)
+          if (jj < cidx (i+1) && ridx (jj) == j)
             jj++;
           else
             {
-              r.data(ii) = true;
-              r.ridx(ii++) = j;
+              r.data (ii) = true;
+              r.ridx (ii++) = j;
             }
         }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
@@ -7262,18 +7262,18 @@ SparseComplexMatrix::all_elements_are_re
 bool
 SparseComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
   octave_idx_type nel = nnz ();
 
   if (nel == 0)
     return false;
 
-  max_val = std::real(data (0));
-  min_val = std::real(data (0));
+  max_val = std::real (data (0));
+  min_val = std::real (data (0));
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
         Complex val = data (i);
 
         double r_val = std::real (val);
         double i_val = std::imag (val);
 
@@ -7348,36 +7348,36 @@ SparseComplexMatrix::cumsum (int dim) co
 SparseComplexMatrix
 SparseComplexMatrix::prod (int dim) const
 {
   if ((rows () == 1 && dim == -1) || dim == 1)
     return transpose (). prod (0). transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=,
-                           (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
+                           (cidx (j+1) - cidx (j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, +=, 0.0, 0.0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::sumsq (int dim) const
 {
 #define ROW_EXPR \
   Complex d = data (i); \
-  tmp [ridx(i)] += d * conj (d)
+  tmp[ridx (i)] += d * conj (d)
 
 #define COL_EXPR \
   Complex d = data (i); \
-  tmp [j] += d * conj (d)
+  tmp[j] += d * conj (d)
 
   SPARSE_BASE_REDUCTION_OP (SparseComplexMatrix, Complex, ROW_EXPR,
                             COL_EXPR, 0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
@@ -7411,20 +7411,20 @@ operator << (std::ostream& os, const Spa
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)
      {
        octave_quit ();
-       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
          {
-           os << a.ridx(i) + 1 << " "  << j + 1 << " ";
-           octave_write_complex (os, a.data(i));
+           os << a.ridx (i) + 1 << " "  << j + 1 << " ";
+           octave_write_complex (os, a.data (i));
            os << "\n";
          }
      }
 
   return os;
 }
 
 std::istream&
@@ -7635,25 +7635,25 @@ min (const Complex& c, const SparseCompl
 {
   SparseComplexMatrix result;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseComplexMatrix);
 
-  if (abs(c) == 0.)
+  if (abs (c) == 0.)
     return SparseComplexMatrix (nr, nc);
   else
     {
       result = SparseComplexMatrix (m);
 
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-          result.data(i) = xmin(c, m.data(i));
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+          result.data (i) = xmin (c, m.data (i));
     }
 
   return result;
 }
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& m, const Complex& c)
 {
@@ -7681,69 +7681,69 @@ min (const SparseComplexMatrix& a, const
       else
         {
           r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
-              octave_idx_type  ja = a.cidx(i);
-              octave_idx_type  ja_max = a.cidx(i+1);
+              octave_idx_type  ja = a.cidx (i);
+              octave_idx_type  ja_max = a.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = b.cidx(i);
-              octave_idx_type  jb_max = b.cidx(i+1);
+              octave_idx_type  jb = b.cidx (i);
+              octave_idx_type  jb_max = b.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                     {
-                      Complex tmp = xmin (a.data(ja), 0.);
+                      Complex tmp = xmin (a.data (ja), 0.);
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = a.ridx(ja);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                           (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                     {
-                      Complex tmp = xmin (0., b.data(jb));
+                      Complex tmp = xmin (0., b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = b.ridx(jb);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = b.ridx (jb);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      Complex tmp = xmin (a.data(ja), b.data(jb));
+                      Complex tmp = xmin (a.data (ja), b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
@@ -7756,22 +7756,22 @@ max (const Complex& c, const SparseCompl
   SparseComplexMatrix result;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseComplexMatrix);
 
   // Count the number of non-zero elements
-  if (xmax(c, 0.) != 0.)
+  if (xmax (c, 0.) != 0.)
     {
       result = SparseComplexMatrix (nr, nc, c);
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-          result.xdata(m.ridx(i) + j * nr) = xmax (c, m.data(i));
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+          result.xdata (m.ridx (i) + j * nr) = xmax (c, m.data (i));
     }
   else
     result = SparseComplexMatrix (m);
 
   return result;
 }
 
 SparseComplexMatrix
@@ -7805,69 +7805,69 @@ max (const SparseComplexMatrix& a, const
       else
         {
           r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
-              octave_idx_type  ja = a.cidx(i);
-              octave_idx_type  ja_max = a.cidx(i+1);
+              octave_idx_type  ja = a.cidx (i);
+              octave_idx_type  ja_max = a.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = b.cidx(i);
-              octave_idx_type  jb_max = b.cidx(i+1);
+              octave_idx_type  jb = b.cidx (i);
+              octave_idx_type  jb_max = b.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                     {
-                      Complex tmp = xmax (a.data(ja), 0.);
+                      Complex tmp = xmax (a.data (ja), 0.);
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = a.ridx(ja);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                           (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                     {
-                      Complex tmp = xmax (0., b.data(jb));
+                      Complex tmp = xmax (0., b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = b.ridx(jb);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = b.ridx (jb);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      Complex tmp = xmax (a.data(ja), b.data(jb));
+                      Complex tmp = xmax (a.data (ja), b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -464,33 +464,33 @@ ComplexQR::update (const ComplexColumnVe
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init(q*r + ComplexMatrix (u) * ComplexMatrix (v).hermitian (), get_type ());
+      init (q*r + ComplexMatrix (u) * ComplexMatrix (v).hermitian (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 ComplexQR::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
-      init(q*r + u * v.hermitian (), get_type ());
+      init (q*r + u * v.hermitian (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 static
 ComplexMatrix insert_col (const ComplexMatrix& a, octave_idx_type i,
                           const ComplexColumnVector& x)
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -207,17 +207,17 @@ jcobi (octave_idx_type n, octave_idx_typ
               double xp1 = (dif1[j] - x) * xn1 - dif2[j] * xd1 - xn;
 
               xd  = xn;
               xd1 = xn1;
               xn  = xp;
               xn1 = xp1;
             }
 
-          double zc  = 1.0;
+          double zc = 1.0;
           double z = xn / xn1;
 
           if (i != 0)
             {
               for (octave_idx_type j = 1; j <= i; j++)
                 zc = zc - z / (x - root[j-1]);
             }
 
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -78,30 +78,30 @@ ddaspk_f (const double& time, const doub
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.length () == 0)
         ires = -2;
       else
         {
           for (octave_idx_type i = 0; i < nn; i++)
-            delta [i] = tmp_delta.elem (i);
+            delta[i] = tmp_delta.elem (i);
         }
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
@@ -132,18 +132,18 @@ ddaspk_j (const double& time, const doub
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
       pd [nn * j + i] = tmp_pd.elem (i, j);
 
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -108,18 +108,18 @@ ddasrt_j (const double& time, const doub
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = (*user_jsub) (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
       pd [nn * j + i] = tmp_pd.elem (i, j);
 
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -71,30 +71,30 @@ ddassl_f (const double& time, const doub
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.length () == 0)
         ires = -2;
       else
         {
           for (octave_idx_type i = 0; i < nn; i++)
-            delta [i] = tmp_delta.elem (i);
+            delta[i] = tmp_delta.elem (i);
         }
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
@@ -106,18 +106,18 @@ ddassl_j (const double& time, const doub
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
       pd [nn * j + i] = tmp_pd.elem (i, j);
 
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -225,18 +225,18 @@ EIG::init (const Matrix& a, bool calc_ev
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = Complex (wr.elem(j), wi.elem(j));
-              lambda.elem(j+1) = Complex (wr.elem(j+1), wi.elem(j+1));
+              lambda.elem (j) = Complex (wr.elem (j), wi.elem (j));
+              lambda.elem (j+1) = Complex (wr.elem (j+1), wi.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   double real_part = vr.elem (i, j);
                   double imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = Complex (real_part, imag_part);
                   v.elem (i, j+1) = Complex (real_part, -imag_part);
                 }
@@ -576,20 +576,20 @@ EIG::init (const Matrix& a, const Matrix
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = Complex (ar.elem(j) / beta.elem (j),
-                                        ai.elem(j) / beta.elem (j));
-              lambda.elem(j+1) = Complex (ar.elem(j+1) / beta.elem (j+1),
-                                          ai.elem(j+1) / beta.elem (j+1));
+              lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j),
+                                         ai.elem (j) / beta.elem (j));
+              lambda.elem (j+1) = Complex (ar.elem (j+1) / beta.elem (j+1),
+                                           ai.elem (j+1) / beta.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   double real_part = vr.elem (i, j);
                   double imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = Complex (real_part, imag_part);
                   v.elem (i, j+1) = Complex (real_part, -imag_part);
                 }
@@ -775,17 +775,17 @@ EIG::init (const ComplexMatrix& a, const
         {
           (*current_liboctave_error_handler) ("zggev failed to converge");
           return info;
         }
 
       lambda.resize (n);
 
       for (octave_idx_type j = 0; j < n; j++)
-        lambda.elem (j) = alpha.elem (j) / beta.elem(j);
+        lambda.elem (j) = alpha.elem (j) / beta.elem (j);
 
       v = vtmp;
     }
   else
     (*current_liboctave_error_handler) ("zggev workspace query failed");
 
   return info;
 }
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -74,17 +74,17 @@ lsode_f (const octave_idx_type& neq, con
 
   tmp_deriv = (*user_fun) (*tmp_x, time);
 
   if (tmp_deriv.length () == 0)
     ierr = -1;
   else
     {
       for (octave_idx_type i = 0; i < neq; i++)
-        deriv [i] = tmp_deriv.elem (i);
+        deriv[i] = tmp_deriv.elem (i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -55,60 +55,60 @@ plus_or_minus (MSparse<T>& a, const MSpa
       gripe_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
     else
       {
         r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
         octave_idx_type jx = 0;
         for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
-            octave_idx_type  ja = a.cidx(i);
-            octave_idx_type  ja_max = a.cidx(i+1);
+            octave_idx_type  ja = a.cidx (i);
+            octave_idx_type  ja_max = a.cidx (i+1);
             bool ja_lt_max= ja < ja_max;
 
-            octave_idx_type  jb = b.cidx(i);
-            octave_idx_type  jb_max = b.cidx(i+1);
+            octave_idx_type  jb = b.cidx (i);
+            octave_idx_type  jb_max = b.cidx (i+1);
             bool jb_lt_max = jb < jb_max;
 
             while (ja_lt_max || jb_lt_max )
               {
                 octave_quit ();
                 if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                   {
-                    r.ridx(jx) = a.ridx(ja);
-                    r.data(jx) = op (a.data(ja), 0.);
+                    r.ridx (jx) = a.ridx (ja);
+                    r.data (jx) = op (a.data (ja), 0.);
                     jx++;
                     ja++;
                     ja_lt_max= ja < ja_max;
                   }
                 else if (( !ja_lt_max ) ||
-                     (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                     (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                   {
-                    r.ridx(jx) = b.ridx(jb);
-                    r.data(jx) = op (0., b.data(jb));
+                    r.ridx (jx) = b.ridx (jb);
+                    r.data (jx) = op (0., b.data (jb));
                     jx++;
                     jb++;
                     jb_lt_max= jb < jb_max;
                   }
                 else
                   {
-                     if (op (a.data(ja), b.data(jb)) != 0.)
+                     if (op (a.data (ja), b.data (jb)) != 0.)
                        {
-                          r.data(jx) = op (a.data(ja), b.data(jb));
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = op (a.data (ja), b.data (jb));
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                        }
                      ja++;
                      ja_lt_max= ja < ja_max;
                      jb++;
                      jb_lt_max= jb < jb_max;
                   }
               }
-            r.cidx(i+1) = jx;
+            r.cidx (i+1) = jx;
           }
 
         a = r.maybe_compress ();
       }
 
     return a;
 }
 
@@ -134,17 +134,17 @@ MArray<T>
 plus_or_minus (const MSparse<T>& a, const T& s, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   MArray<T> r (dim_vector (nr, nc), op (0.0, s));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+    for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
       r.elem (a.ridx (i), j) = op (a.data (i), s);
   return r;
 }
 
 template <typename T>
 MArray<T>
 operator + (const MSparse<T>& a, const T& s)
 {
@@ -166,21 +166,21 @@ times_or_divide (const MSparse<T>& a, co
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
 
   MSparse<T> r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data(i) = op (a.data(i), s);
-      r.ridx(i) = a.ridx(i);
+      r.data (i) = op (a.data (i), s);
+      r.ridx (i) = a.ridx (i);
     }
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    r.cidx(i) = a.cidx(i);
+    r.cidx (i) = a.cidx (i);
   r.maybe_compress (true);
   return r;
 }
 
 template <typename T>
 MSparse<T>
 operator * (const MSparse<T>& a, const T& s)
 {
@@ -202,17 +202,17 @@ MArray<T>
 plus_or_minus (const T& s, const MSparse<T>& a, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   MArray<T> r (dim_vector (nr, nc), op (s, 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+    for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
       r.elem (a.ridx (i), j) = op (s, a.data (i));
   return r;
 }
 
 template <typename T>
 MArray<T>
 operator + (const T& s, const MSparse<T>& a)
 {
@@ -233,21 +233,21 @@ times_or_divides (const T& s, const MSpa
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
 
   MSparse<T> r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data(i) = op (s, a.data(i));
-      r.ridx(i) = a.ridx(i);
+      r.data (i) = op (s, a.data (i));
+      r.ridx (i) = a.ridx (i);
     }
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    r.cidx(i) = a.cidx(i);
+    r.cidx (i) = a.cidx (i);
   r.maybe_compress (true);
   return r;
 }
 
 template <class T>
 MSparse<T>
 operator * (const T& s, const MSparse<T>& a)
 {
@@ -274,113 +274,113 @@ plus_or_minus (const MSparse<T>& a, cons
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr == 1 && a_nc == 1)
     {
-      if (a.elem(0,0) == 0.)
+      if (a.elem (0,0) == 0.)
         if (negate)
           r = -MSparse<T> (b);
         else
           r = MSparse<T> (b);
       else
         {
-          r = MSparse<T> (b_nr, b_nc, op (a.data(0), 0.));
+          r = MSparse<T> (b_nr, b_nc, op (a.data (0), 0.));
 
           for (octave_idx_type j = 0 ; j < b_nc ; j++)
             {
               octave_quit ();
               octave_idx_type idxj = j * b_nr;
-              for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++)
+              for (octave_idx_type i = b.cidx (j) ; i < b.cidx (j+1) ; i++)
                 {
                   octave_quit ();
-                  r.data(idxj + b.ridx(i)) = op (a.data(0), b.data(i));
+                  r.data (idxj + b.ridx (i)) = op (a.data (0), b.data (i));
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
-      if (b.elem(0,0) == 0.)
+      if (b.elem (0,0) == 0.)
         r = MSparse<T> (a);
       else
         {
-          r = MSparse<T> (a_nr, a_nc, op (0.0, b.data(0)));
+          r = MSparse<T> (a_nr, a_nc, op (0.0, b.data (0)));
 
           for (octave_idx_type j = 0 ; j < a_nc ; j++)
             {
               octave_quit ();
               octave_idx_type idxj = j * a_nr;
-              for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++)
+              for (octave_idx_type i = a.cidx (j) ; i < a.cidx (j+1) ; i++)
                 {
                   octave_quit ();
-                  r.data(idxj + a.ridx(i)) = op (a.data(i), b.data(0));
+                  r.data (idxj + a.ridx (i)) = op (a.data (i), b.data (0));
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
     gripe_nonconformant (op_name, a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx(i);
-          octave_idx_type  ja_max = a.cidx(i+1);
+          octave_idx_type  ja = a.cidx (i);
+          octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
-          octave_idx_type  jb = b.cidx(i);
-          octave_idx_type  jb_max = b.cidx(i+1);
+          octave_idx_type  jb = b.cidx (i);
+          octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max )
             {
               octave_quit ();
               if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
-                  r.ridx(jx) = a.ridx(ja);
-                  r.data(jx) = op (a.data(ja), 0.);
+                  r.ridx (jx) = a.ridx (ja);
+                  r.data (jx) = op (a.data (ja), 0.);
                   jx++;
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
               else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                 {
-                  r.ridx(jx) = b.ridx(jb);
-                  r.data(jx) = op (0.,  b.data(jb));
+                  r.ridx (jx) = b.ridx (jb);
+                  r.data (jx) = op (0.,  b.data (jb));
                   jx++;
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  if (op (a.data(ja), b.data(jb)) != 0.)
+                  if (op (a.data (ja), b.data (jb)) != 0.)
                     {
-                      r.data(jx) = op (a.data(ja), b.data(jb));
-                      r.ridx(jx) = a.ridx(ja);
+                      r.data (jx) = op (a.data (ja), b.data (jb));
+                      r.ridx (jx) = a.ridx (ja);
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
             }
-          r.cidx(i+1) = jx;
+          r.cidx (i+1) = jx;
         }
 
       r.maybe_compress ();
     }
 
   return r;
 }
 
@@ -407,92 +407,92 @@ product (const MSparse<T>& a, const MSpa
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr == 1 && a_nc == 1)
     {
-      if (a.elem(0,0) == 0.)
+      if (a.elem (0,0) == 0.)
         r = MSparse<T> (b_nr, b_nc);
       else
         {
           r = MSparse<T> (b);
           octave_idx_type b_nnz = b.nnz ();
 
           for (octave_idx_type i = 0 ; i < b_nnz ; i++)
             {
               octave_quit ();
-              r.data (i) = a.data(0) * r.data(i);
+              r.data (i) = a.data (0) * r.data (i);
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
-      if (b.elem(0,0) == 0.)
+      if (b.elem (0,0) == 0.)
         r = MSparse<T> (a_nr, a_nc);
       else
         {
           r = MSparse<T> (a);
           octave_idx_type a_nnz = a.nnz ();
 
           for (octave_idx_type i = 0 ; i < a_nnz ; i++)
             {
               octave_quit ();
-              r.data (i) = r.data(i) * b.data(0);
+              r.data (i) = r.data (i) * b.data (0);
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
     gripe_nonconformant ("product", a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () > b.nnz () ? a.nnz () : b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx(i);
-          octave_idx_type  ja_max = a.cidx(i+1);
+          octave_idx_type  ja = a.cidx (i);
+          octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
-          octave_idx_type  jb = b.cidx(i);
-          octave_idx_type  jb_max = b.cidx(i+1);
+          octave_idx_type  jb = b.cidx (i);
+          octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max )
             {
               octave_quit ();
               if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   ja++; ja_lt_max= ja < ja_max;
                 }
               else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                 {
                   jb++; jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  if ((a.data(ja) * b.data(jb)) != 0.)
+                  if ((a.data (ja) * b.data (jb)) != 0.)
                     {
-                      r.data(jx) = a.data(ja) * b.data(jb);
-                      r.ridx(jx) = a.ridx(ja);
+                      r.data (jx) = a.data (ja) * b.data (jb);
+                      r.ridx (jx) = a.ridx (ja);
                       jx++;
                     }
                   ja++; ja_lt_max= ja < ja_max;
                   jb++; jb_lt_max= jb < jb_max;
                 }
             }
-          r.cidx(i+1) = jx;
+          r.cidx (i+1) = jx;
         }
 
       r.maybe_compress ();
     }
 
   return r;
 }
 
@@ -513,97 +513,97 @@ quotient (const MSparse<T>& a, const MSp
     {
       T val = a.elem (0,0);
       T fill = val / T ();
       if (fill == T ())
         {
           octave_idx_type b_nnz = b.nnz ();
           r = MSparse<T> (b);
           for (octave_idx_type i = 0 ; i < b_nnz ; i++)
-            r.data (i) = val / r.data(i);
+            r.data (i) = val / r.data (i);
           r.maybe_compress ();
         }
       else
         {
           r = MSparse<T> (b_nr, b_nc, fill);
           for (octave_idx_type j = 0 ; j < b_nc ; j++)
             {
               octave_quit ();
               octave_idx_type idxj = j * b_nr;
-              for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++)
+              for (octave_idx_type i = b.cidx (j) ; i < b.cidx (j+1) ; i++)
                 {
                   octave_quit ();
-                  r.data(idxj + b.ridx(i)) = val / b.data(i);
+                  r.data (idxj + b.ridx (i)) = val / b.data (i);
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
       T val = b.elem (0,0);
       T fill = T () / val;
       if (fill == T ())
         {
           octave_idx_type a_nnz = a.nnz ();
           r = MSparse<T> (a);
           for (octave_idx_type i = 0 ; i < a_nnz ; i++)
-            r.data (i) = r.data(i) / val;
+            r.data (i) = r.data (i) / val;
           r.maybe_compress ();
         }
       else
         {
           r = MSparse<T> (a_nr, a_nc, fill);
           for (octave_idx_type j = 0 ; j < a_nc ; j++)
             {
               octave_quit ();
               octave_idx_type idxj = j * a_nr;
-              for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++)
+              for (octave_idx_type i = a.cidx (j) ; i < a.cidx (j+1) ; i++)
                 {
                   octave_quit ();
-                  r.data(idxj + a.ridx(i)) = a.data(i) / val;
+                  r.data (idxj + a.ridx (i)) = a.data (i) / val;
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
     gripe_nonconformant ("quotient", a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T>( a_nr, a_nc, (Zero / Zero));
 
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx(i);
-          octave_idx_type  ja_max = a.cidx(i+1);
+          octave_idx_type  ja = a.cidx (i);
+          octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
-          octave_idx_type  jb = b.cidx(i);
-          octave_idx_type  jb_max = b.cidx(i+1);
+          octave_idx_type  jb = b.cidx (i);
+          octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max )
             {
               octave_quit ();
               if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
-                  r.elem (a.ridx(ja),i) = a.data(ja) / Zero;
+                  r.elem (a.ridx (ja),i) = a.data (ja) / Zero;
                   ja++; ja_lt_max= ja < ja_max;
                 }
               else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                 {
-                  r.elem (b.ridx(jb),i) = Zero / b.data(jb);
+                  r.elem (b.ridx (jb),i) = Zero / b.data (jb);
                   jb++; jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  r.elem (a.ridx(ja),i) = a.data(ja) / b.data(jb);
+                  r.elem (a.ridx (ja),i) = a.data (ja) / b.data (jb);
                   ja++; ja_lt_max= ja < ja_max;
                   jb++; jb_lt_max= jb < jb_max;
                 }
             }
         }
 
       r.maybe_compress (true);
     }
@@ -624,11 +624,11 @@ operator + (const MSparse<T>& a)
 
 template <class T>
 MSparse<T>
 operator - (const MSparse<T>& a)
 {
   MSparse<T> retval (a);
   octave_idx_type nz = a.nnz ();
   for (octave_idx_type i = 0; i < nz; i++)
-    retval.data(i) = - retval.data(i);
+    retval.data (i) = - retval.data (i);
   return retval;
 }
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -46,17 +46,17 @@ MatrixType::MatrixType (void)
 
 MatrixType::MatrixType (const MatrixType &a)
   : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden),
     upper_band (a.upper_band), lower_band (a.lower_band),
     dense (a.dense), full (a.full), nperm (a.nperm), perm (0)
 {
   if (nperm != 0)
     {
-      perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type[nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = a.perm[i];
     }
 }
 
 template<class T>
 MatrixType::matrix_type
 matrix_real_probe (const MArray<T>& a)
@@ -226,46 +226,46 @@ MatrixType::MatrixType (const SparseMatr
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
       for (i = 0; i < nm; i++)
         {
-          if (a.cidx(i+1) != a.cidx(i) + 1)
+          if (a.cidx (i+1) != a.cidx (i) + 1)
             {
               tmp_typ = MatrixType::Full;
               break;
             }
-          if (a.ridx(i) != i)
+          if (a.ridx (i) != i)
             {
               tmp_typ = MatrixType::Permuted_Diagonal;
               break;
             }
         }
 
       if (tmp_typ == MatrixType::Permuted_Diagonal)
         {
           std::vector<bool> found (nrows);
 
           for (octave_idx_type j = 0; j < i; j++)
-            found [j] = true;
+            found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
-            found [j] = false;
+            found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
-              if ((a.cidx(j+1) > a.cidx(j) + 1)  ||
-                  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
+              if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
+                  ((a.cidx (j+1) == a.cidx (j) + 1) && found [a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
-              found [a.ridx(j)] = true;
+              found [a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
@@ -273,34 +273,34 @@ MatrixType::MatrixType (const SparseMatr
       upper_band = 0;
       lower_band = 0;
       for (octave_idx_type j = 0; j < ncols; j++)
         {
           bool zero_on_diagonal = false;
           if (j < nrows)
             {
               zero_on_diagonal = true;
-              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-                if (a.ridx(i) == j)
+              for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+                if (a.ridx (i) == j)
                   {
                     zero_on_diagonal = false;
                     break;
                   }
             }
 
           if (zero_on_diagonal)
             {
               singular = true;
               break;
             }
 
-          if (a.cidx(j+1) != a.cidx(j))
+          if (a.cidx (j+1) != a.cidx (j))
             {
-              octave_idx_type ru = a.ridx(a.cidx(j));
-              octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+              octave_idx_type ru = a.ridx (a.cidx (j));
+              octave_idx_type rl = a.ridx (a.cidx (j+1)-1);
 
               if (j - ru > upper_band)
                 upper_band = j - ru;
 
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
@@ -343,67 +343,67 @@ MatrixType::MatrixType (const SparseMatr
           // Search for a permuted triangular matrix, and test if
           // permutation is singular
 
           // FIXME
           // Perhaps this should be based on a dmperm algorithm
           bool found = false;
 
           nperm = ncols;
-          perm = new octave_idx_type [ncols];
+          perm = new octave_idx_type[ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
-            perm [i] = -1;
+            perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 {
-                  if ((a.cidx(j+1) - a.cidx(j)) > 0 &&
-                      (a.ridx(a.cidx(j+1)-1) == i))
+                  if ((a.cidx (j+1) - a.cidx (j)) > 0 &&
+                      (a.ridx (a.cidx (j+1)-1) == i))
                     {
-                      perm [i] = j;
+                      perm[i] = j;
                       found = true;
                       break;
                     }
                 }
 
               if (!found)
                 break;
             }
 
           if (found)
             {
               typ = MatrixType::Permuted_Upper;
               if (ncols > nrows)
                 {
                   octave_idx_type k = nrows;
                   for (octave_idx_type i = 0; i < ncols; i++)
-                    if (perm [i] == -1)
+                    if (perm[i] == -1)
                       perm[i] = k++;
                 }
             }
-          else if (a.cidx(nm) == a.cidx(ncols))
+          else if (a.cidx (nm) == a.cidx (ncols))
             {
               nperm = nrows;
               delete [] perm;
-              perm = new octave_idx_type [nrows];
+              perm = new octave_idx_type[nrows];
               OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
-                  perm [i] = -1;
-                  tmp [i] = -1;
+                  perm[i] = -1;
+                  tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
-                for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-                    perm [a.ridx(i)] = j;
+                for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+                    perm [a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -473,46 +473,46 @@ MatrixType::MatrixType (const SparseMatr
           bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
-              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+              for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
                 {
-                  if (a.ridx(i) == j)
+                  if (a.ridx (i) == j)
                     {
-                      double d = a.data(i);
+                      double d = a.data (i);
                       is_herm = d > 0.;
                       diag(j) = d;
                       break;
                     }
                 }
             }
 
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
-            for (octave_idx_type i = a.cidx(j); is_herm && i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); is_herm && i < a.cidx (j+1); i++)
               {
-                octave_idx_type k = a.ridx(i);
+                octave_idx_type k = a.ridx (i);
                 is_herm = k == j;
                 if (is_herm)
                   continue;
-                double d = a.data(i);
+                double d = a.data (i);
                 if (d*d < diag(j)*diag(k))
                   {
-                    for (octave_idx_type l = a.cidx(k); l < a.cidx(k+1); l++)
+                    for (octave_idx_type l = a.cidx (k); l < a.cidx (k+1); l++)
                       {
-                        if (a.ridx(l) == j)
+                        if (a.ridx (l) == j)
                           {
-                            is_herm = a.data(l) == d;
+                            is_herm = a.data (l) == d;
                             break;
                           }
                       }
                   }
               }
 
           if (is_herm)
             {
@@ -547,46 +547,46 @@ MatrixType::MatrixType (const SparseComp
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
       for (i = 0; i < nm; i++)
         {
-          if (a.cidx(i+1) != a.cidx(i) + 1)
+          if (a.cidx (i+1) != a.cidx (i) + 1)
             {
               tmp_typ = MatrixType::Full;
               break;
             }
-          if (a.ridx(i) != i)
+          if (a.ridx (i) != i)
             {
               tmp_typ = MatrixType::Permuted_Diagonal;
               break;
             }
         }
 
       if (tmp_typ == MatrixType::Permuted_Diagonal)
         {
           std::vector<bool> found (nrows);
 
           for (octave_idx_type j = 0; j < i; j++)
-            found [j] = true;
+            found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
-            found [j] = false;
+            found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
-              if ((a.cidx(j+1) > a.cidx(j) + 1)  ||
-                  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
+              if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
+                  ((a.cidx (j+1) == a.cidx (j) + 1) && found [a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
-              found [a.ridx(j)] = true;
+              found [a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
@@ -594,34 +594,34 @@ MatrixType::MatrixType (const SparseComp
       upper_band = 0;
       lower_band = 0;
       for (octave_idx_type j = 0; j < ncols; j++)
         {
           bool zero_on_diagonal = false;
           if (j < nrows)
             {
               zero_on_diagonal = true;
-              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-                if (a.ridx(i) == j)
+              for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+                if (a.ridx (i) == j)
                   {
                     zero_on_diagonal = false;
                     break;
                   }
             }
 
           if (zero_on_diagonal)
             {
               singular = true;
               break;
             }
 
-          if (a.cidx(j+1) != a.cidx(j))
+          if (a.cidx (j+1) != a.cidx (j))
             {
-              octave_idx_type ru = a.ridx(a.cidx(j));
-              octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+              octave_idx_type ru = a.ridx (a.cidx (j));
+              octave_idx_type rl = a.ridx (a.cidx (j+1)-1);
 
               if (j - ru > upper_band)
                 upper_band = j - ru;
 
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
@@ -664,67 +664,67 @@ MatrixType::MatrixType (const SparseComp
           // Search for a permuted triangular matrix, and test if
           // permutation is singular
 
           // FIXME
           // Perhaps this should be based on a dmperm algorithm
           bool found = false;
 
           nperm = ncols;
-          perm = new octave_idx_type [ncols];
+          perm = new octave_idx_type[ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
-            perm [i] = -1;
+            perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 {
-                  if ((a.cidx(j+1) - a.cidx(j)) > 0 &&
-                      (a.ridx(a.cidx(j+1)-1) == i))
+                  if ((a.cidx (j+1) - a.cidx (j)) > 0 &&
+                      (a.ridx (a.cidx (j+1)-1) == i))
                     {
-                      perm [i] = j;
+                      perm[i] = j;
                       found = true;
                       break;
                     }
                 }
 
               if (!found)
                 break;
             }
 
           if (found)
             {
               typ = MatrixType::Permuted_Upper;
               if (ncols > nrows)
                 {
                   octave_idx_type k = nrows;
                   for (octave_idx_type i = 0; i < ncols; i++)
-                    if (perm [i] == -1)
+                    if (perm[i] == -1)
                       perm[i] = k++;
                 }
             }
-          else if (a.cidx(nm) == a.cidx(ncols))
+          else if (a.cidx (nm) == a.cidx (ncols))
             {
               nperm = nrows;
               delete [] perm;
-              perm = new octave_idx_type [nrows];
+              perm = new octave_idx_type[nrows];
               OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
-                  perm [i] = -1;
-                  tmp [i] = -1;
+                  perm[i] = -1;
+                  tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
-                for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-                    perm [a.ridx(i)] = j;
+                for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+                    perm [a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -794,46 +794,46 @@ MatrixType::MatrixType (const SparseComp
           bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
-              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+              for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
                 {
-                  if (a.ridx(i) == j)
+                  if (a.ridx (i) == j)
                     {
-                      Complex d = a.data(i);
+                      Complex d = a.data (i);
                       is_herm = d.real () > 0. && d.imag () == 0.;
                       diag(j) = d.real ();
                       break;
                     }
                 }
             }
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
-            for (octave_idx_type i = a.cidx(j); is_herm && i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); is_herm && i < a.cidx (j+1); i++)
               {
-                octave_idx_type k = a.ridx(i);
+                octave_idx_type k = a.ridx (i);
                 is_herm = k == j;
                 if (is_herm)
                   continue;
-                Complex d = a.data(i);
+                Complex d = a.data (i);
                 if (std::norm (d) < diag(j)*diag(k))
                   {
                     d = std::conj (d);
-                    for (octave_idx_type l = a.cidx(k); l < a.cidx(k+1); l++)
+                    for (octave_idx_type l = a.cidx (k); l < a.cidx (k+1); l++)
                       {
-                        if (a.ridx(l) == j)
+                        if (a.ridx (l) == j)
                           {
-                            is_herm = a.data(l) == d;
+                            is_herm = a.data (l) == d;
                             break;
                           }
                       }
                   }
               }
 
 
           if (is_herm)
@@ -871,17 +871,17 @@ MatrixType::MatrixType (const matrix_typ
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if ((t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower) &&
       np > 0 && p != 0)
     {
       typ = t;
       nperm = np;
-      perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type[nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = p[i];
     }
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type ku,
@@ -984,17 +984,17 @@ MatrixType::type (const SparseMatrix &a)
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type[nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1017,17 +1017,17 @@ MatrixType::type (const SparseComplexMat
   upper_band = tmp_typ.upper_band;
   lower_band = tmp_typ.lower_band;
   dense = tmp_typ.dense;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type[nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1044,17 +1044,17 @@ MatrixType::type (const Matrix &a)
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type[nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1071,17 +1071,17 @@ MatrixType::type (const ComplexMatrix &a
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type[nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1098,17 +1098,17 @@ MatrixType::type (const FloatMatrix &a)
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type[nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 int
@@ -1125,17 +1125,17 @@ MatrixType::type (const FloatComplexMatr
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
-      perm = new octave_idx_type [nperm];
+      perm = new octave_idx_type[nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
 
   return typ;
 }
 
 void
@@ -1220,17 +1220,17 @@ MatrixType::mark_as_unsymmetric (void)
            typ == MatrixType::Unknown)
     typ = MatrixType::Full;
 }
 
 void
 MatrixType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *p)
 {
   nperm = np;
-  perm = new octave_idx_type [nperm];
+  perm = new octave_idx_type[nperm];
   for (octave_idx_type i = 0; i < nperm; i++)
     perm[i] = p[i];
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     typ = MatrixType::Permuted_Diagonal;
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     typ = MatrixType::Permuted_Upper;
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -69,21 +69,21 @@ along with Octave; see the file COPYING.
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
-        r.xdata(i) = m.data(i) OP s; \
-        r.xridx(i) = m.ridx(i); \
+        r.xdata (i) = m.data (i) OP s; \
+        r.xridx (i) = m.ridx (i); \
       } \
     for (octave_idx_type i = 0; i < nc + 1; i++) \
-      r.xcidx(i) = m.cidx(i); \
+      r.xcidx (i) = m.cidx (i); \
     \
     r.maybe_compress (true); \
     return r; \
   }
 
 #define SPARSE_SMS_BIN_OPS(R1, R2, M, S) \
   SPARSE_SMS_BIN_OP_1 (R1, operator +, +, M, S) \
   SPARSE_SMS_BIN_OP_1 (R1, operator -, -, M, S) \
@@ -109,29 +109,29 @@ along with Octave; see the file COPYING.
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r; \
     \
     if (MC (MZ) OP SC (s)) \
       { \
         r = SparseBoolMatrix (nr, nc, true); \
         for (octave_idx_type j = 0; j < nc; j++) \
-          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+          for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
             if (! (MC (m.data (i)) OP SC (s))) \
               r.data (m.ridx (i) + j * nr) = false; \
         r.maybe_compress (true); \
       } \
     else \
       { \
         r = SparseBoolMatrix (nr, nc, m.nnz ()); \
         r.cidx (0) = static_cast<octave_idx_type> (0); \
         octave_idx_type nel = 0; \
         for (octave_idx_type j = 0; j < nc; j++) \
           { \
-            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
               if (MC (m.data (i)) OP SC (s)) \
                 { \
                   r.ridx (nel) = m.ridx (i); \
                   r.data (nel++) = true; \
                 } \
             r.cidx (j + 1) = nel; \
           } \
         r.maybe_compress (false); \
@@ -164,30 +164,30 @@ along with Octave; see the file COPYING.
     SparseBoolMatrix r; \
     \
     if (nr > 0 && nc > 0) \
       { \
         if (LHS_ZERO OP (s != RHS_ZERO)) \
           { \
             r = SparseBoolMatrix (nr, nc, true); \
             for (octave_idx_type j = 0; j < nc; j++) \
-              for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-                if (! ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO))) \
+              for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
+                if (! ((m.data (i) != LHS_ZERO) OP (s != RHS_ZERO))) \
                   r.data (m.ridx (i) + j * nr) = false; \
             r.maybe_compress (true); \
           } \
         else \
           { \
             r = SparseBoolMatrix (nr, nc, m.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < nc; j++) \
               { \
-                for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-                  if ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO)) \
+                for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
+                  if ((m.data (i) != LHS_ZERO) OP (s != RHS_ZERO)) \
                     { \
                       r.ridx (nel) = m.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
@@ -238,21 +238,21 @@ along with Octave; see the file COPYING.
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
-        r.xdata(i) = s OP m.data(i); \
-        r.xridx(i) = m.ridx(i); \
+        r.xdata (i) = s OP m.data (i); \
+        r.xridx (i) = m.ridx (i); \
       } \
     for (octave_idx_type i = 0; i < nc + 1; i++) \
-      r.xcidx(i) = m.cidx(i); \
+      r.xcidx (i) = m.cidx (i); \
  \
     r.maybe_compress(true); \
     return r; \
   }
 
 #define SPARSE_SSM_BIN_OPS(R1, R2, S, M) \
   SPARSE_SSM_BIN_OP_1 (R1, operator +, +, S, M) \
   SPARSE_SSM_BIN_OP_1 (R1, operator -, -, S, M) \
@@ -278,29 +278,29 @@ along with Octave; see the file COPYING.
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r; \
     \
     if (SC (s) OP SC (MZ)) \
       { \
         r = SparseBoolMatrix (nr, nc, true); \
         for (octave_idx_type j = 0; j < nc; j++) \
-          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+          for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
             if (! (SC (s) OP MC (m.data (i)))) \
               r.data (m.ridx (i) + j * nr) = false; \
         r.maybe_compress (true); \
       } \
     else \
       { \
         r = SparseBoolMatrix (nr, nc, m.nnz ()); \
         r.cidx (0) = static_cast<octave_idx_type> (0); \
         octave_idx_type nel = 0; \
         for (octave_idx_type j = 0; j < nc; j++) \
           { \
-            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
               if (SC (s) OP MC (m.data (i))) \
                 { \
                   r.ridx (nel) = m.ridx (i); \
                   r.data (nel++) = true; \
                 } \
             r.cidx (j + 1) = nel; \
           } \
         r.maybe_compress (false); \
@@ -333,30 +333,30 @@ along with Octave; see the file COPYING.
     SparseBoolMatrix r; \
     \
     if (nr > 0 && nc > 0) \
       { \
         if ((s != LHS_ZERO) OP RHS_ZERO) \
           { \
             r = SparseBoolMatrix (nr, nc, true); \
             for (octave_idx_type j = 0; j < nc; j++) \
-              for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-                if (! ((s != LHS_ZERO) OP (m.data(i) != RHS_ZERO))) \
+              for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
+                if (! ((s != LHS_ZERO) OP (m.data (i) != RHS_ZERO))) \
                   r.data (m.ridx (i) + j * nr) = false; \
             r.maybe_compress (true); \
           } \
         else \
           { \
             r = SparseBoolMatrix (nr, nc, m.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < nc; j++) \
               { \
-                for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-                  if ((s != LHS_ZERO) OP (m.data(i) != RHS_ZERO)) \
+                for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
+                  if ((s != LHS_ZERO) OP (m.data (i) != RHS_ZERO)) \
                     { \
                       r.ridx (nel) = m.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
@@ -393,110 +393,110 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
-        if (m1.elem(0,0) == 0.) \
+        if (m1.elem (0,0) == 0.) \
           r = OP R (m2); \
         else \
           { \
-            r = R (m2_nr, m2_nc, m1.data(0) OP 0.); \
+            r = R (m2_nr, m2_nc, m1.data (0) OP 0.); \
             \
             for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m2_nr; \
-                for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
+                for (octave_idx_type i = m2.cidx (j) ; i < m2.cidx (j+1) ; i++) \
                   { \
                     octave_quit (); \
-                    r.data(idxj + m2.ridx(i)) = m1.data(0) OP m2.data(i); \
+                    r.data (idxj + m2.ridx (i)) = m1.data (0) OP m2.data (i); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
-        if (m2.elem(0,0) == 0.) \
+        if (m2.elem (0,0) == 0.) \
           r = R (m1); \
         else \
           { \
-            r = R (m1_nr, m1_nc, 0. OP m2.data(0)); \
+            r = R (m1_nr, m1_nc, 0. OP m2.data (0)); \
             \
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
-                for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
+                for (octave_idx_type i = m1.cidx (j) ; i < m1.cidx (j+1) ; i++) \
                   { \
                     octave_quit (); \
-                    r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.data(0); \
+                    r.data (idxj + m1.ridx (i)) = m1.data (i) OP m2.data (0); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            octave_idx_type  ja = m1.cidx(i); \
-            octave_idx_type  ja_max = m1.cidx(i+1); \
+            octave_idx_type  ja = m1.cidx (i); \
+            octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            octave_idx_type  jb = m2.cidx(i); \
-            octave_idx_type  jb_max = m2.cidx(i+1); \
+            octave_idx_type  jb = m2.cidx (i); \
+            octave_idx_type  jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
-                      (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
+                      (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
-                    r.ridx(jx) = m1.ridx(ja); \
-                    r.data(jx) = m1.data(ja) OP 0.; \
+                    r.ridx (jx) = m1.ridx (ja); \
+                    r.data (jx) = m1.data (ja) OP 0.; \
                     jx++; \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
-                     (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
+                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)) ) ) \
                   { \
-                    r.ridx(jx) = m2.ridx(jb); \
-                    r.data(jx) = 0. OP m2.data(jb); \
+                    r.ridx (jx) = m2.ridx (jb); \
+                    r.data (jx) = 0. OP m2.data (jb); \
                     jx++; \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-                     if ((m1.data(ja) OP m2.data(jb)) != 0.) \
+                     if ((m1.data (ja) OP m2.data (jb)) != 0.) \
                        { \
-                          r.data(jx) = m1.data(ja) OP m2.data(jb); \
-                          r.ridx(jx) = m1.ridx(ja); \
+                          r.data (jx) = m1.data (ja) OP m2.data (jb); \
+                          r.ridx (jx) = m1.ridx (ja); \
                           jx++; \
                        } \
                      ja++; \
                      ja_lt_max= ja < ja_max; \
                      jb++; \
                      jb_lt_max= jb < jb_max; \
                   } \
               } \
-            r.cidx(i+1) = jx; \
+            r.cidx (i+1) = jx; \
           } \
         \
         r.maybe_compress (); \
       } \
  \
     return r; \
   }
 
@@ -509,92 +509,92 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
-        if (m1.elem(0,0) == 0.) \
+        if (m1.elem (0,0) == 0.) \
           r = R (m2_nr, m2_nc); \
         else \
           { \
             r = R (m2); \
             octave_idx_type m2_nnz = m2.nnz (); \
             \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
               { \
                 octave_quit (); \
-                r.data (i) = m1.data(0) OP r.data(i); \
+                r.data (i) = m1.data (0) OP r.data (i); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
-        if (m2.elem(0,0) == 0.) \
+        if (m2.elem (0,0) == 0.) \
           r = R (m1_nr, m1_nc); \
         else \
           { \
             r = R (m1); \
             octave_idx_type m1_nnz = m1.nnz (); \
             \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
               { \
                 octave_quit (); \
-                r.data (i) = r.data(i) OP m2.data(0); \
+                r.data (i) = r.data (i) OP m2.data (0); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            octave_idx_type  ja = m1.cidx(i); \
-            octave_idx_type  ja_max = m1.cidx(i+1); \
+            octave_idx_type  ja = m1.cidx (i); \
+            octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            octave_idx_type  jb = m2.cidx(i); \
-            octave_idx_type  jb_max = m2.cidx(i+1); \
+            octave_idx_type  jb = m2.cidx (i); \
+            octave_idx_type  jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
-                      (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
+                      (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
                      ja++; ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
-                     (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
+                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)) ) ) \
                   { \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-                     if ((m1.data(ja) OP m2.data(jb)) != 0.) \
+                     if ((m1.data (ja) OP m2.data (jb)) != 0.) \
                        { \
-                          r.data(jx) = m1.data(ja) OP m2.data(jb); \
-                          r.ridx(jx) = m1.ridx(ja); \
+                          r.data (jx) = m1.data (ja) OP m2.data (jb); \
+                          r.ridx (jx) = m1.ridx (ja); \
                           jx++; \
                        } \
                      ja++; ja_lt_max= ja < ja_max; \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
               } \
-            r.cidx(i+1) = jx; \
+            r.cidx (i+1) = jx; \
           } \
         \
         r.maybe_compress (); \
       } \
  \
     return r; \
   }
 
@@ -612,101 +612,101 @@ along with Octave; see the file COPYING.
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
         if ((m1.elem (0,0) OP Complex ()) == Complex ()) \
           { \
             octave_idx_type m2_nnz = m2.nnz (); \
             r = R (m2); \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
-              r.data (i) = m1.elem(0,0) OP r.data(i); \
+              r.data (i) = m1.elem (0,0) OP r.data (i); \
             r.maybe_compress (); \
           } \
         else \
           { \
-            r = R (m2_nr, m2_nc, m1.elem(0,0) OP Complex ()); \
+            r = R (m2_nr, m2_nc, m1.elem (0,0) OP Complex ()); \
             for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m2_nr; \
-                for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
+                for (octave_idx_type i = m2.cidx (j) ; i < m2.cidx (j+1) ; i++) \
                   { \
                     octave_quit (); \
-                    r.data(idxj + m2.ridx(i)) = m1.elem(0,0) OP m2.data(i); \
+                    r.data (idxj + m2.ridx (i)) = m1.elem (0,0) OP m2.data (i); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if ((Complex () OP m1.elem (0,0)) == Complex ()) \
           { \
             octave_idx_type m1_nnz = m1.nnz (); \
             r = R (m1); \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
-              r.data (i) = r.data(i) OP m2.elem(0,0); \
+              r.data (i) = r.data (i) OP m2.elem (0,0); \
             r.maybe_compress (); \
           } \
         else \
           { \
-            r = R (m1_nr, m1_nc, Complex () OP m2.elem(0,0)); \
+            r = R (m1_nr, m1_nc, Complex () OP m2.elem (0,0)); \
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
-                for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
+                for (octave_idx_type i = m1.cidx (j) ; i < m1.cidx (j+1) ; i++) \
                   { \
                     octave_quit (); \
-                    r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.elem(0,0); \
+                    r.data (idxj + m1.ridx (i)) = m1.data (i) OP m2.elem (0,0); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
  \
         /* FIXME Kludge... Always double/Complex, so Complex () */ \
         r = R (m1_nr, m1_nc, (Complex () OP Complex ())); \
         \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            octave_idx_type  ja = m1.cidx(i); \
-            octave_idx_type  ja_max = m1.cidx(i+1); \
+            octave_idx_type  ja = m1.cidx (i); \
+            octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            octave_idx_type  jb = m2.cidx(i); \
-            octave_idx_type  jb_max = m2.cidx(i+1); \
+            octave_idx_type  jb = m2.cidx (i); \
+            octave_idx_type  jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
-                      (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
+                      (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
                     /* keep those kludges coming */ \
-                    r.elem(m1.ridx(ja),i) = m1.data(ja) OP Complex (); \
+                    r.elem (m1.ridx (ja),i) = m1.data (ja) OP Complex (); \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
-                     (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
+                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)) ) ) \
                   { \
                     /* keep those kludges coming */ \
-                    r.elem(m2.ridx(jb),i) = Complex () OP m2.data(jb);  \
+                    r.elem (m2.ridx (jb),i) = Complex () OP m2.data (jb);  \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-                    r.elem(m1.ridx(ja),i) = m1.data(ja) OP m2.data(jb); \
+                    r.elem (m1.ridx (ja),i) = m1.data (ja) OP m2.data (jb); \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
               } \
           } \
         r.maybe_compress (true); \
@@ -750,63 +750,63 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
-    if (C1 (m1.elem(0,0)) OP C2 (Z2)) \
+    if (C1 (m1.elem (0,0)) OP C2 (Z2)) \
           { \
             r = SparseBoolMatrix (m2_nr, m2_nc, true); \
             for (octave_idx_type j = 0; j < m2_nc; j++) \
-              for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-                if (! (C1 (m1.elem (0,0)) OP C2 (m2.data(i)))) \
+              for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
+                if (! (C1 (m1.elem (0,0)) OP C2 (m2.data (i)))) \
                   r.data (m2.ridx (i) + j * m2_nr) = false; \
             r.maybe_compress (true); \
           } \
         else \
           { \
             r = SparseBoolMatrix (m2_nr, m2_nc, m2.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m2_nc; j++) \
               { \
-                for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-                  if (C1 (m1.elem (0,0)) OP C2 (m2.data(i))) \
+                for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
+                  if (C1 (m1.elem (0,0)) OP C2 (m2.data (i))) \
                     { \
                       r.ridx (nel) = m2.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (C1 (Z1) OP C2 (m2.elem (0,0))) \
           { \
             r = SparseBoolMatrix (m1_nr, m1_nc, true); \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
-              for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-                if (! (C1 (m1.data (i)) OP C2 (m2.elem(0,0)))) \
+              for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
+                if (! (C1 (m1.data (i)) OP C2 (m2.elem (0,0)))) \
                   r.data (m1.ridx (i) + j * m1_nr) = false; \
             r.maybe_compress (true); \
           } \
         else \
           { \
             r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
-                for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-                  if (C1 (m1.data (i)) OP C2 (m2.elem(0,0))) \
+                for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
+                  if (C1 (m1.data (i)) OP C2 (m2.elem (0,0))) \
                     { \
                       r.ridx (nel) = m1.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
@@ -821,23 +821,23 @@ along with Octave; see the file COPYING.
                 for (octave_idx_type j = 0; j < m1_nc; j++) \
                   { \
                      octave_idx_type i1 = m1.cidx (j); \
                      octave_idx_type e1 = m1.cidx (j+1); \
                      octave_idx_type i2 = m2.cidx (j); \
                      octave_idx_type e2 = m2.cidx (j+1); \
                      while (i1 < e1 || i2 < e2) \
                        { \
-                         if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
+                         if (i1 == e1 || (i2 < e2 && m1.ridx (i1) > m2.ridx (i2))) \
                            { \
                              if (! (C1 (Z1) OP C2 (m2.data (i2)))) \
                                r.data (m2.ridx (i2) + j * m1_nr) = false; \
                              i2++; \
                            } \
-                         else if (i2 == e2 || m1.ridx(i1) < m2.ridx(i2)) \
+                         else if (i2 == e2 || m1.ridx (i1) < m2.ridx (i2)) \
                            { \
                              if (! (C1 (m1.data (i1)) OP C2 (Z2))) \
                                r.data (m1.ridx (i1) + j * m1_nr) = false; \
                              i1++; \
                            } \
                          else \
                            { \
                              if (! (C1 (m1.data (i1)) OP C2 (m2.data (i2)))) \
@@ -857,26 +857,26 @@ along with Octave; see the file COPYING.
                 for (octave_idx_type j = 0; j < m1_nc; j++) \
                   { \
                      octave_idx_type i1 = m1.cidx (j); \
                      octave_idx_type e1 = m1.cidx (j+1); \
                      octave_idx_type i2 = m2.cidx (j); \
                      octave_idx_type e2 = m2.cidx (j+1); \
                      while (i1 < e1 || i2 < e2) \
                        { \
-                         if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
+                         if (i1 == e1 || (i2 < e2 && m1.ridx (i1) > m2.ridx (i2))) \
                            { \
                              if (C1 (Z1) OP C2 (m2.data (i2))) \
                                { \
                                  r.ridx (nel) = m2.ridx (i2); \
                                  r.data (nel++) = true; \
                                } \
                              i2++; \
                            } \
-                         else if (i2 == e2 || m1.ridx(i1) < m2.ridx(i2)) \
+                         else if (i2 == e2 || m1.ridx (i1) < m2.ridx (i2)) \
                            { \
                              if (C1 (m1.data (i1)) OP C2 (Z2)) \
                                { \
                                  r.ridx (nel) = m1.ridx (i1); \
                                  r.data (nel++) = true; \
                                } \
                              i1++; \
                            } \
@@ -936,66 +936,66 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
         if (m2_nr > 0 && m2_nc > 0) \
           { \
-            if ((m1.elem(0,0) != LHS_ZERO) OP RHS_ZERO) \
+            if ((m1.elem (0,0) != LHS_ZERO) OP RHS_ZERO) \
               { \
                 r = SparseBoolMatrix (m2_nr, m2_nc, true); \
                 for (octave_idx_type j = 0; j < m2_nc; j++) \
-                  for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-                    if (! ((m1.elem(0,0) != LHS_ZERO) OP (m2.data(i) != RHS_ZERO))) \
+                  for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
+                    if (! ((m1.elem (0,0) != LHS_ZERO) OP (m2.data (i) != RHS_ZERO))) \
                       r.data (m2.ridx (i) + j * m2_nr) = false; \
                 r.maybe_compress (true); \
               } \
             else \
               { \
                 r = SparseBoolMatrix (m2_nr, m2_nc, m2.nnz ()); \
                 r.cidx (0) = static_cast<octave_idx_type> (0); \
                 octave_idx_type nel = 0; \
                 for (octave_idx_type j = 0; j < m2_nc; j++) \
                   { \
-                    for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-                      if ((m1.elem(0,0) != LHS_ZERO) OP (m2.data(i) != RHS_ZERO)) \
+                    for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
+                      if ((m1.elem (0,0) != LHS_ZERO) OP (m2.data (i) != RHS_ZERO)) \
                         { \
                           r.ridx (nel) = m2.ridx (i); \
                           r.data (nel++) = true; \
                         } \
                     r.cidx (j + 1) = nel; \
                   } \
                 r.maybe_compress (false); \
               } \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (m1_nr > 0 && m1_nc > 0) \
           { \
-            if (LHS_ZERO OP (m2.elem(0,0) != RHS_ZERO)) \
+            if (LHS_ZERO OP (m2.elem (0,0) != RHS_ZERO)) \
               { \
                 r = SparseBoolMatrix (m1_nr, m1_nc, true); \
                 for (octave_idx_type j = 0; j < m1_nc; j++) \
-                  for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-                    if (! ((m1.data(i) != LHS_ZERO) OP (m2.elem(0,0) != RHS_ZERO))) \
+                  for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
+                    if (! ((m1.data (i) != LHS_ZERO) OP (m2.elem (0,0) != RHS_ZERO))) \
                       r.data (m1.ridx (i) + j * m1_nr) = false; \
                 r.maybe_compress (true); \
               } \
             else \
               { \
                 r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz ()); \
                 r.cidx (0) = static_cast<octave_idx_type> (0); \
                 octave_idx_type nel = 0; \
                 for (octave_idx_type j = 0; j < m1_nc; j++) \
                   { \
-                    for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-                      if ((m1.data(i) != LHS_ZERO) OP (m2.elem(0,0) != RHS_ZERO)) \
+                    for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
+                      if ((m1.data (i) != LHS_ZERO) OP (m2.elem (0,0) != RHS_ZERO)) \
                         { \
                           r.ridx (nel) = m1.ridx (i); \
                           r.data (nel++) = true; \
                         } \
                     r.cidx (j + 1) = nel; \
                   } \
                 r.maybe_compress (false); \
               } \
@@ -1011,37 +1011,37 @@ along with Octave; see the file COPYING.
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 octave_idx_type i1 = m1.cidx (j); \
                 octave_idx_type e1 = m1.cidx (j+1); \
                 octave_idx_type i2 = m2.cidx (j); \
                 octave_idx_type e2 = m2.cidx (j+1); \
                 while (i1 < e1 || i2 < e2) \
                   { \
-                    if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
+                    if (i1 == e1 || (i2 < e2 && m1.ridx (i1) > m2.ridx (i2))) \
                       { \
                         if (LHS_ZERO OP m2.data (i2) != RHS_ZERO) \
                           { \
                             r.ridx (nel) = m2.ridx (i2); \
                             r.data (nel++) = true; \
                           } \
                         i2++; \
                       } \
-                    else if (i2 == e2 || m1.ridx(i1) < m2.ridx(i2)) \
+                    else if (i2 == e2 || m1.ridx (i1) < m2.ridx (i2)) \
                       { \
                         if (m1.data (i1) != LHS_ZERO OP RHS_ZERO) \
                           { \
                             r.ridx (nel) = m1.ridx (i1); \
                             r.data (nel++) = true; \
                           } \
                         i1++; \
                       } \
                     else \
                       { \
-                        if (m1.data (i1) != LHS_ZERO OP m2.data(i2) != RHS_ZERO) \
+                        if (m1.data (i1) != LHS_ZERO OP m2.data (i2) != RHS_ZERO) \
                           { \
                             r.ridx (nel) = m1.ridx (i1); \
                             r.data (nel++) = true; \
                           } \
                         i1++; \
                         i2++; \
                       } \
                   } \
@@ -1086,17 +1086,17 @@ along with Octave; see the file COPYING.
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m2_nr == 1 && m2_nc == 1) \
-      r = R (m1 OP m2.elem(0,0)); \
+      r = R (m1 OP m2.elem (0,0)); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (F (m1, m2.matrix_value ())); \
       } \
     return r; \
   }
@@ -1109,41 +1109,41 @@ along with Octave; see the file COPYING.
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m2_nr == 1 && m2_nc == 1) \
-      r = R (m1 OP m2.elem(0,0)); \
+      r = R (m1 OP m2.elem (0,0)); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         if (do_mx_check (m1, mx_inline_all_finite<M1::element_type>)) \
           { \
             /* Sparsity pattern is preserved. */ \
             octave_idx_type m2_nz = m2.nnz (); \
             r = R (m2_nr, m2_nc, m2_nz); \
             for (octave_idx_type j = 0, k = 0; j < m2_nc; j++) \
               { \
                 octave_quit (); \
-                for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
+                for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
                   { \
-                    octave_idx_type mri = m2.ridx(i); \
-                    R::element_type x = m1(mri, j) OP m2.data(i); \
+                    octave_idx_type mri = m2.ridx (i); \
+                    R::element_type x = m1(mri, j) OP m2.data (i); \
                     if (x != 0.0) \
                       { \
-                        r.xdata(k) = x; \
-                        r.xridx(k) = m2.ridx(i); \
+                        r.xdata (k) = x; \
+                        r.xridx (k) = m2.ridx (i); \
                         k++; \
                       } \
                   } \
-                r.xcidx(j+1) = k; \
+                r.xcidx (j+1) = k; \
               } \
             r.maybe_compress (false); \
             return r; \
           } \
         else \
           r = R (F (m1, m2.matrix_value ())); \
       } \
  \
@@ -1177,44 +1177,44 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m2_nr == 1 && m2_nc == 1) \
-      r = SparseBoolMatrix (F (m1, m2.elem(0,0))); \
+      r = SparseBoolMatrix (F (m1, m2.elem (0,0))); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
             /* Count num of non-zero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
-                if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
+                if (C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j))) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
             octave_idx_type ii = 0; \
             r.cidx (0) = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 for (octave_idx_type i = 0; i < m1_nr; i++) \
                   { \
-                    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
+                    bool el = C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j)); \
                     if (el) \
                       { \
-                        r.data(ii) = el; \
-                        r.ridx(ii++) = i; \
+                        r.data (ii) = el; \
+                        r.ridx (ii++) = i; \
                       } \
                   } \
-                r.cidx(j+1) = ii; \
+                r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
@@ -1245,46 +1245,46 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m2_nr == 1 && m2_nc == 1) \
-      r = SparseBoolMatrix  (F (m1, m2.elem(0,0))); \
+      r = SparseBoolMatrix (F (m1, m2.elem (0,0))); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
             /* Count num of non-zero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
-                if ((m1.elem(i, j) != LHS_ZERO) \
-                    OP (m2.elem(i, j) != RHS_ZERO)) \
+                if ((m1.elem (i, j) != LHS_ZERO) \
+                    OP (m2.elem (i, j) != RHS_ZERO)) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
             octave_idx_type ii = 0; \
             r.cidx (0) = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 for (octave_idx_type i = 0; i < m1_nr; i++) \
                   { \
-                    bool el = (m1.elem(i, j) != LHS_ZERO) \
-                      OP (m2.elem(i, j) != RHS_ZERO);     \
+                    bool el = (m1.elem (i, j) != LHS_ZERO) \
+                      OP (m2.elem (i, j) != RHS_ZERO);     \
                     if (el) \
                       { \
-                        r.data(ii) = el; \
-                        r.ridx(ii++) = i; \
+                        r.data (ii) = el; \
+                        r.ridx (ii++) = i; \
                       } \
                   } \
-                r.cidx(j+1) = ii; \
+                r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
@@ -1319,17 +1319,17 @@ along with Octave; see the file COPYING.
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
-      r = R (m1.elem(0,0) OP m2); \
+      r = R (m1.elem (0,0) OP m2); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1.matrix_value () OP m2); \
       } \
     return r; \
   }
@@ -1350,41 +1350,41 @@ along with Octave; see the file COPYING.
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
-      r = R (m1.elem(0,0) OP m2); \
+      r = R (m1.elem (0,0) OP m2); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         if (SPARSE_SMM_BIN_OP_2_CHECK_ ## F(M2::element_type)) \
           { \
             /* Sparsity pattern is preserved. */ \
             octave_idx_type m1_nz = m1.nnz (); \
             r = R (m1_nr, m1_nc, m1_nz); \
             for (octave_idx_type j = 0, k = 0; j < m1_nc; j++) \
               { \
                 octave_quit (); \
-                for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
+                for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
                   { \
-                    octave_idx_type mri = m1.ridx(i); \
-                    R::element_type x = m1.data(i) OP m2(mri, j); \
+                    octave_idx_type mri = m1.ridx (i); \
+                    R::element_type x = m1.data (i) OP m2 (mri, j); \
                     if (x != 0.0) \
                       { \
-                        r.xdata(k) = x; \
-                        r.xridx(k) = m1.ridx(i); \
+                        r.xdata (k) = x; \
+                        r.xridx (k) = m1.ridx (i); \
                         k++; \
                       } \
                   } \
-                r.xcidx(j+1) = k; \
+                r.xcidx (j+1) = k; \
               } \
             r.maybe_compress (false); \
             return r; \
           } \
         else \
           r = R (F (m1.matrix_value (), m2)); \
       } \
  \
@@ -1417,44 +1417,44 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
-      r = SparseBoolMatrix (F (m1.elem(0,0), m2)); \
+      r = SparseBoolMatrix (F (m1.elem (0,0), m2)); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
             /* Count num of non-zero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
-                if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
+                if (C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j))) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
             octave_idx_type ii = 0; \
             r.cidx (0) = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 for (octave_idx_type i = 0; i < m1_nr; i++) \
                   { \
-                    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
+                    bool el = C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j)); \
                     if (el) \
                       { \
-                        r.data(ii) = el; \
-                        r.ridx(ii++) = i; \
+                        r.data (ii) = el; \
+                        r.ridx (ii++) = i; \
                       } \
                   } \
-                r.cidx(j+1) = ii; \
+                r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
@@ -1485,46 +1485,46 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
-      r = SparseBoolMatrix (F (m1.elem(0,0), m2)); \
+      r = SparseBoolMatrix (F (m1.elem (0,0), m2)); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
             /* Count num of non-zero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
-                if ((m1.elem(i, j) != LHS_ZERO) \
-                    OP (m2.elem(i, j) != RHS_ZERO)) \
+                if ((m1.elem (i, j) != LHS_ZERO) \
+                    OP (m2.elem (i, j) != RHS_ZERO)) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
             octave_idx_type ii = 0; \
             r.cidx (0) = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 for (octave_idx_type i = 0; i < m1_nr; i++) \
                   { \
-                    bool el = (m1.elem(i, j) != LHS_ZERO) \
-                      OP (m2.elem(i, j) != RHS_ZERO);     \
+                    bool el = (m1.elem (i, j) != LHS_ZERO) \
+                      OP (m2.elem (i, j) != RHS_ZERO);     \
                     if (el) \
                       { \
-                        r.data(ii) = el; \
-                        r.ridx(ii++) = i; \
+                        r.data (ii) = el; \
+                        r.ridx (ii++) = i; \
                       } \
                   } \
-                r.cidx(j+1) = ii; \
+                r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
@@ -1560,56 +1560,56 @@ along with Octave; see the file COPYING.
       else \
         { \
           octave_idx_type nel = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (); \
               for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)   \
                 { \
-                  t += data(j); \
+                  t += data (j); \
                   if (t != ELT_TYPE ()) \
                     { \
-                      if (j == cidx(i+1) - 1) \
-                        nel += nr - ridx(j);  \
+                      if (j == cidx (i+1) - 1) \
+                        nel += nr - ridx (j);  \
                       else \
-                        nel += ridx(j+1) - ridx(j); \
+                        nel += ridx (j+1) - ridx (j); \
                     } \
                 } \
             } \
           retval = RET_TYPE (nr, nc, nel); \
-          retval.cidx(0) = 0; \
+          retval.cidx (0) = 0; \
           octave_idx_type ii = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (); \
               for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)   \
                 { \
-                  t += data(j); \
+                  t += data (j); \
                   if (t != ELT_TYPE ()) \
                     { \
-                      if (j == cidx(i+1) - 1) \
+                      if (j == cidx (i+1) - 1) \
                         { \
-                          for (octave_idx_type k = ridx(j); k < nr; k++) \
+                          for (octave_idx_type k = ridx (j); k < nr; k++) \
                             { \
                                retval.data (ii) = t; \
                                retval.ridx (ii++) = k; \
                             } \
                         } \
                       else \
                         { \
-                          for (octave_idx_type k = ridx(j); k < ridx(j+1); k++) \
+                          for (octave_idx_type k = ridx (j); k < ridx (j+1); k++) \
                             { \
                                retval.data (ii) = t; \
                                retval.ridx (ii++) = k; \
                             } \
                         } \
                     } \
                 } \
-              retval.cidx(i+1) = ii; \
+              retval.cidx (i+1) = ii; \
             } \
         } \
     } \
   else \
     retval = RET_TYPE (nr,nc); \
  \
   return retval
 
@@ -1629,44 +1629,44 @@ along with Octave; see the file COPYING.
       else \
         { \
           octave_idx_type nel = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             { \
               octave_idx_type jj = 0; \
               for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
                 { \
-                  if (jj == ridx(j)) \
+                  if (jj == ridx (j)) \
                     { \
                       nel++; \
                       jj++; \
                     } \
                   else \
                     break; \
                 } \
             } \
           retval = RET_TYPE (nr, nc, nel); \
-          retval.cidx(0) = 0; \
+          retval.cidx (0) = 0; \
           octave_idx_type ii = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (1.); \
               octave_idx_type jj = 0; \
               for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
                 { \
-                  if (jj == ridx(j)) \
+                  if (jj == ridx (j)) \
                     { \
-                      t *= data(j); \
-                      retval.data(ii) = t; \
-                      retval.ridx(ii++) = jj++; \
+                      t *= data (j); \
+                      retval.data (ii) = t; \
+                      retval.ridx (ii++) = jj++; \
                     } \
                   else \
                     break; \
                 } \
-              retval.cidx(i+1) = ii; \
+              retval.cidx (i+1) = ii; \
             } \
         } \
     } \
   else \
     retval = RET_TYPE (nr,nc); \
  \
   return retval
 
@@ -1685,77 +1685,77 @@ along with Octave; see the file COPYING.
           /* Define j here to allow fancy definition for prod method */ \
           octave_idx_type j = 0; \
           OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nr); \
           \
           for (octave_idx_type i = 0; i < nr; i++) \
             tmp[i] = INIT_VAL; \
           for (j = 0; j < nc; j++) \
             { \
-              for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
+              for (octave_idx_type i = cidx (j); i < cidx (j + 1); i++) \
                 { \
                   ROW_EXPR; \
                 } \
             } \
           octave_idx_type nel = 0; \
           for (octave_idx_type i = 0; i < nr; i++) \
             if (tmp[i] != EL_TYPE ())  \
               nel++ ; \
           retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nel); \
-          retval.cidx(0) = 0; \
-          retval.cidx(1) = nel; \
+          retval.cidx (0) = 0; \
+          retval.cidx (1) = nel; \
           nel = 0; \
           for (octave_idx_type i = 0; i < nr; i++) \
             if (tmp[i] != EL_TYPE ())  \
               { \
-                retval.data(nel) = tmp[i]; \
-                retval.ridx(nel++) = i; \
+                retval.data (nel) = tmp[i]; \
+                retval.ridx (nel++) = i; \
               } \
         } \
       else \
         { \
           OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nc); \
           \
           for (octave_idx_type j = 0; j < nc; j++) \
             { \
               tmp[j] = INIT_VAL; \
-              for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
+              for (octave_idx_type i = cidx (j); i < cidx (j + 1); i++) \
                 { \
                   COL_EXPR; \
                 } \
             } \
           octave_idx_type nel = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             if (tmp[i] != EL_TYPE ())  \
               nel++ ; \
           retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, nel); \
-          retval.cidx(0) = 0; \
+          retval.cidx (0) = 0; \
           nel = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             if (tmp[i] != EL_TYPE ())  \
               { \
-                retval.data(nel) = tmp[i]; \
-                retval.ridx(nel++) = 0; \
-                retval.cidx(i+1) = retval.cidx(i) + 1; \
+                retval.data (nel) = tmp[i]; \
+                retval.ridx (nel++) = 0; \
+                retval.cidx (i+1) = retval.cidx (i) + 1; \
               } \
             else \
-              retval.cidx(i+1) = retval.cidx(i); \
+              retval.cidx (i+1) = retval.cidx (i); \
         } \
     } \
   else if (nc == 0 && (nr == 0 || (nr == 1 && dim == -1))) \
     { \
       if (MT_RESULT) \
         { \
           retval = RET_TYPE (static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (1)); \
-          retval.cidx(0) = 0; \
-          retval.cidx(1) = 1; \
-          retval.ridx(0) = 0; \
-          retval.data(0) = MT_RESULT; \
+          retval.cidx (0) = 0; \
+          retval.cidx (1) = 1; \
+          retval.ridx (0) = 0; \
+          retval.data (0) = MT_RESULT; \
         } \
       else \
           retval = RET_TYPE (static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (0)); \
     } \
   else if (nr == 0 && (dim == 0 || dim == -1)) \
     { \
@@ -1774,52 +1774,52 @@ along with Octave; see the file COPYING.
         retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, \
                            static_cast<octave_idx_type> (0)); \
     } \
   else if (nc == 0 && dim == 1) \
     { \
       if (MT_RESULT) \
         { \
           retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nr); \
-          retval.cidx(0) = 0; \
-          retval.cidx(1) = nr; \
+          retval.cidx (0) = 0; \
+          retval.cidx (1) = nr; \
           for (octave_idx_type i = 0; i < nr; i++) \
             { \
-              retval.ridx(i) = i; \
-              retval.data(i) = MT_RESULT; \
+              retval.ridx (i) = i; \
+              retval.data (i) = MT_RESULT; \
             } \
         } \
       else \
         retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), \
                            static_cast<octave_idx_type> (0)); \
     } \
   else \
     retval.resize (nr > 0, nc > 0); \
  \
   return retval
 
 #define SPARSE_REDUCTION_OP_ROW_EXPR(OP) \
-  tmp[ridx(i)] OP data (i)
+  tmp[ridx (i)] OP data (i)
 
 #define SPARSE_REDUCTION_OP_COL_EXPR(OP) \
   tmp[j] OP data (i)
 
 #define SPARSE_REDUCTION_OP(RET_TYPE, EL_TYPE, OP, INIT_VAL, MT_RESULT) \
   SPARSE_BASE_REDUCTION_OP (RET_TYPE, EL_TYPE, \
                         SPARSE_REDUCTION_OP_ROW_EXPR (OP), \
                         SPARSE_REDUCTION_OP_COL_EXPR (OP), \
                         INIT_VAL, MT_RESULT)
 
 
 // Don't break from this loop if the test succeeds because
 // we are looping over the rows and not the columns in the inner
 // loop.
 #define SPARSE_ANY_ALL_OP_ROW_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
-    tmp[ridx(i)] = TEST_TRUE_VAL; \
+    tmp[ridx (i)] = TEST_TRUE_VAL; \
 
 #define SPARSE_ANY_ALL_OP_COL_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
     { \
       tmp[j] = TEST_TRUE_VAL; \
       break; \
     }
 
@@ -1829,102 +1829,102 @@ along with Octave; see the file COPYING.
                         SPARSE_ANY_ALL_OP_COL_CODE (TEST_OP, TEST_TRUE_VAL), \
                         INIT_VAL, MT_RESULT)
 
 #define SPARSE_ALL_OP(DIM) \
   if ((rows () == 1 && dim == -1) || dim == 1) \
     return transpose (). all (0). transpose (); \
   else \
     { \
-      SPARSE_ANY_ALL_OP (DIM, (cidx(j+1) - cidx(j) < nr ? false : true), \
+      SPARSE_ANY_ALL_OP (DIM, (cidx (j+1) - cidx (j) < nr ? false : true), \
                          true, ==, false); \
     }
 
 #define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, false, !=, true)
 
 #define SPARSE_SPARSE_MUL( RET_TYPE, RET_EL_TYPE, EL_TYPE ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
    { \
-     RET_EL_TYPE s = m.elem(0,0); \
+     RET_EL_TYPE s = m.elem (0,0); \
      octave_idx_type nz = a.nnz (); \
      RET_TYPE r (a_nr, a_nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
-         r.data(i) = s * a.data(i); \
-         r.ridx(i) = a.ridx(i); \
+         r.data (i) = s * a.data (i); \
+         r.ridx (i) = a.ridx (i); \
        } \
      for (octave_idx_type i = 0; i < a_nc + 1; i++) \
        { \
          octave_quit (); \
-         r.cidx(i) = a.cidx(i); \
+         r.cidx (i) = a.cidx (i); \
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (a_nr == 1 && a_nc == 1) \
    { \
-     RET_EL_TYPE s = a.elem(0,0); \
+     RET_EL_TYPE s = a.elem (0,0); \
      octave_idx_type nz = m.nnz (); \
      RET_TYPE r (nr, nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
-         r.data(i) = m.data(i) * s; \
-         r.ridx(i) = m.ridx(i); \
+         r.data (i) = m.data (i) * s; \
+         r.ridx (i) = m.ridx (i); \
        } \
      for (octave_idx_type i = 0; i < nc + 1; i++) \
        { \
          octave_quit (); \
-         r.cidx(i) = m.cidx(i); \
+         r.cidx (i) = m.cidx (i); \
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (nc != a_nr) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr); \
       RET_TYPE retval (nr, a_nc, static_cast<octave_idx_type> (0)); \
       for (octave_idx_type i = 0; i < nr; i++) \
         w[i] = 0; \
-      retval.xcidx(0) = 0; \
+      retval.xcidx (0) = 0; \
       \
       octave_idx_type nel = 0; \
       \
       for (octave_idx_type i = 0; i < a_nc; i++) \
         { \
-          for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+          for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
             { \
-              octave_idx_type  col = a.ridx(j); \
-              for (octave_idx_type k = m.cidx(col) ; k < m.cidx(col+1); k++) \
+              octave_idx_type  col = a.ridx (j); \
+              for (octave_idx_type k = m.cidx (col) ; k < m.cidx (col+1); k++) \
                 { \
-                  if (w[m.ridx(k)] < i + 1) \
+                  if (w[m.ridx (k)] < i + 1) \
                     { \
-                      w[m.ridx(k)] = i + 1; \
+                      w[m.ridx (k)] = i + 1; \
                       nel++; \
                     } \
                   octave_quit (); \
                 } \
             } \
-          retval.xcidx(i+1) = nel; \
+          retval.xcidx (i+1) = nel; \
         } \
       \
       if (nel == 0) \
         return RET_TYPE (nr, a_nc); \
       else \
         {  \
           for (octave_idx_type i = 0; i < nr; i++) \
             w[i] = 0; \
@@ -1946,67 +1946,67 @@ along with Octave; see the file COPYING.
           octave_idx_type n_per_col = (a_nc > 43000 ? 43000 : \
                                         (a_nc * a_nc) / 43000); \
           octave_idx_type ii = 0; \
           octave_idx_type *ri = retval.xridx (); \
           octave_sort<octave_idx_type> sort; \
           \
           for (octave_idx_type i = 0; i < a_nc ; i++) \
             { \
-              if (retval.xcidx(i+1) - retval.xcidx(i) > n_per_col) \
+              if (retval.xcidx (i+1) - retval.xcidx (i) > n_per_col) \
                 { \
-                  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+                  for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
                     { \
-                      octave_idx_type col = a.ridx(j); \
-                      EL_TYPE tmpval = a.data(j); \
-                      for (octave_idx_type k = m.cidx(col) ; \
-                           k < m.cidx(col+1); k++) \
+                      octave_idx_type col = a.ridx (j); \
+                      EL_TYPE tmpval = a.data (j); \
+                      for (octave_idx_type k = m.cidx (col) ; \
+                           k < m.cidx (col+1); k++) \
                         { \
                           octave_quit (); \
-                          octave_idx_type row = m.ridx(k); \
+                          octave_idx_type row = m.ridx (k); \
                           if (w[row] < i + 1) \
                             { \
                               w[row] = i + 1; \
-                              Xcol[row] = tmpval * m.data(k); \
+                              Xcol[row] = tmpval * m.data (k); \
                             } \
                           else \
-                            Xcol[row] += tmpval * m.data(k); \
+                            Xcol[row] += tmpval * m.data (k); \
                         } \
                     } \
                   for (octave_idx_type k = 0; k < nr; k++) \
                     if (w[k] == i + 1) \
                       { \
-                        retval.xdata(ii) = Xcol[k]; \
-                        retval.xridx(ii++) = k; \
+                        retval.xdata (ii) = Xcol[k]; \
+                        retval.xridx (ii++) = k; \
                       } \
                 } \
               else \
                 { \
-                  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+                  for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
                     { \
-                      octave_idx_type col = a.ridx(j); \
-                      EL_TYPE tmpval = a.data(j); \
-                      for (octave_idx_type k = m.cidx(col) ; \
-                          k < m.cidx(col+1); k++) \
+                      octave_idx_type col = a.ridx (j); \
+                      EL_TYPE tmpval = a.data (j); \
+                      for (octave_idx_type k = m.cidx (col) ; \
+                          k < m.cidx (col+1); k++) \
                         { \
                           octave_quit (); \
-                          octave_idx_type row = m.ridx(k); \
+                          octave_idx_type row = m.ridx (k); \
                           if (w[row] < i + 1) \
                             { \
                               w[row] = i + 1; \
-                              retval.xridx(ii++) = row;\
-                              Xcol[row] = tmpval * m.data(k); \
+                              retval.xridx (ii++) = row;\
+                              Xcol[row] = tmpval * m.data (k); \
                             } \
                           else \
-                            Xcol[row] += tmpval * m.data(k); \
+                            Xcol[row] += tmpval * m.data (k); \
                         } \
                     } \
-                  sort.sort (ri + retval.xcidx(i), ii - retval.xcidx(i)); \
-                  for (octave_idx_type k = retval.xcidx(i); k < ii; k++) \
-                    retval.xdata(k) = Xcol[retval.xridx(k)]; \
+                  sort.sort (ri + retval.xcidx (i), ii - retval.xcidx (i)); \
+                  for (octave_idx_type k = retval.xcidx (i); k < ii; k++) \
+                    retval.xdata (k) = Xcol[retval.xridx (k)]; \
                 }  \
             } \
           retval.maybe_compress (true);\
           return retval; \
         } \
     }
 
 #define SPARSE_FULL_MUL( RET_TYPE, EL_TYPE, ZERO ) \
@@ -2031,34 +2031,34 @@ along with Octave; see the file COPYING.
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           for (octave_idx_type j = 0; j < a_nr; j++) \
             { \
               octave_quit (); \
               \
-              EL_TYPE tmpval = a.elem(j,i); \
-              for (octave_idx_type k = m.cidx(j) ; k < m.cidx(j+1); k++) \
-                retval.elem (m.ridx(k),i) += tmpval * m.data(k); \
+              EL_TYPE tmpval = a.elem (j,i); \
+              for (octave_idx_type k = m.cidx (j) ; k < m.cidx (j+1); k++) \
+                retval.elem (m.ridx (k),i) += tmpval * m.data (k); \
             } \
         } \
       return retval; \
     }
 
 #define SPARSE_FULL_TRANS_MUL( RET_TYPE, EL_TYPE, ZERO, CONJ_OP ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
     { \
-      RET_TYPE retval = CONJ_OP (m.elem(0,0)) * a; \
+      RET_TYPE retval = CONJ_OP (m.elem (0,0)) * a; \
       return retval; \
     } \
   else if (nr != a_nr) \
     { \
       gripe_nonconformant ("operator *", nc, nr, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
@@ -2067,18 +2067,18 @@ along with Octave; see the file COPYING.
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           for (octave_idx_type j = 0; j < nc; j++) \
             { \
               octave_quit (); \
               \
               EL_TYPE acc = ZERO; \
-              for (octave_idx_type k = m.cidx(j) ; k < m.cidx(j+1); k++) \
-                acc += a.elem (m.ridx(k),i) * CONJ_OP (m.data(k)); \
+              for (octave_idx_type k = m.cidx (j) ; k < m.cidx (j+1); k++) \
+                acc += a.elem (m.ridx (k),i) * CONJ_OP (m.data (k)); \
               retval.xelem (j,i) = acc; \
             } \
         } \
       return retval; \
     }
 
 #define FULL_SPARSE_MUL( RET_TYPE, EL_TYPE, ZERO ) \
   octave_idx_type nr = m.rows (); \
@@ -2099,56 +2099,56 @@ along with Octave; see the file COPYING.
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           octave_quit (); \
-          for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+          for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
             { \
-              octave_idx_type col = a.ridx(j); \
-              EL_TYPE tmpval = a.data(j); \
+              octave_idx_type col = a.ridx (j); \
+              EL_TYPE tmpval = a.data (j); \
               \
               for (octave_idx_type k = 0 ; k < nr; k++) \
-                retval.xelem (k,i) += tmpval * m.elem(k,col); \
+                retval.xelem (k,i) += tmpval * m.elem (k,col); \
             } \
         } \
       return retval; \
     }
 
 #define FULL_SPARSE_MUL_TRANS( RET_TYPE, EL_TYPE, ZERO, CONJ_OP ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (a_nr == 1 && a_nc == 1) \
     { \
-      RET_TYPE retval = m * CONJ_OP (a.elem(0,0)); \
+      RET_TYPE retval = m * CONJ_OP (a.elem (0,0)); \
       return retval; \
     } \
   else if (nc != a_nc) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nc, a_nr); \
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nr, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           octave_quit (); \
-          for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+          for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
             { \
-              octave_idx_type col = a.ridx(j); \
-              EL_TYPE tmpval = CONJ_OP (a.data(j)); \
+              octave_idx_type col = a.ridx (j); \
+              EL_TYPE tmpval = CONJ_OP (a.data (j)); \
               for (octave_idx_type k = 0 ; k < nr; k++) \
-                retval.xelem (k,col) += tmpval * m.elem(k,i); \
+                retval.xelem (k,col) += tmpval * m.elem (k,i); \
             } \
         } \
       return retval; \
     }
 
 #endif
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -38,25 +38,25 @@ SM octinternal_do_mul_colpm_sm (const oc
 
   for (octave_idx_type j = 0; j <= nc; ++j)
     r.xcidx (j) = a.cidx (j);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_quit ();
 
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, r.xcidx(j+1) - r.xcidx(j));
-      for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, r.xcidx (j+1) - r.xcidx (j));
+      for (octave_idx_type i = r.xcidx (j), ii = 0; i < r.xcidx (j+1); i++)
         {
           sidx[ii++]=i;
           r.xridx (i) = pcol[a.ridx (i)];
         }
-      sort.sort (r.xridx () + r.xcidx(j), sidx, r.xcidx(j+1) - r.xcidx(j));
-      for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
-        r.xdata(i) = a.data (sidx[ii++]);
+      sort.sort (r.xridx () + r.xcidx (j), sidx, r.xcidx (j+1) - r.xcidx (j));
+      for (octave_idx_type i = r.xcidx (j), ii = 0; i < r.xcidx (j+1); i++)
+        r.xdata (i) = a.data (sidx[ii++]);
     }
 
   return r;
 }
 
 template <typename SM>
 SM octinternal_do_mul_pm_sm (const PermMatrix& p, const SM& a)
 {
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -61,22 +61,22 @@ Sparse<T>::Sparse (const PermMatrix& a)
   for (octave_idx_type i = 0; i <= n; i++)
     cidx (i) = i;
 
   const Array<octave_idx_type> pv = a.pvec ();
 
   if (a.is_row_perm ())
     {
       for (octave_idx_type i = 0; i < n; i++)
-        ridx (pv (i)) = i;
+        ridx (pv(i)) = i;
     }
   else
     {
       for (octave_idx_type i = 0; i < n; i++)
-        ridx (i) = pv (i);
+        ridx (i) = pv(i);
     }
 
   for (octave_idx_type i = 0; i < n; i++)
     data (i) = 1.0;
 }
 
 template <class T>
 T&
@@ -171,23 +171,23 @@ Sparse<T>::SparseRep::change_length (oct
   // We shall skip reallocation if we have less than 1/frac extra elements to
   // discard.
   static const int frac = 5;
   if (nz > nzmx || nz < nzmx - nzmx/frac)
     {
       // Reallocate.
       octave_idx_type min_nzmx = std::min (nz, nzmx);
 
-      octave_idx_type * new_ridx = new octave_idx_type [nz];
+      octave_idx_type * new_ridx = new octave_idx_type[nz];
       copy_or_memcpy (min_nzmx, r, new_ridx);
 
       delete [] r;
       r = new_ridx;
 
-      T * new_data = new T [nz];
+      T * new_data = new T[nz];
       copy_or_memcpy (min_nzmx, d, new_data);
 
       delete [] d;
       d = new_data;
 
       nzmx = nz;
     }
 }
@@ -218,17 +218,17 @@ Sparse<T>::Sparse (octave_idx_type nr, o
             }
           xcidx (j+1) = ii;
         }
     }
   else
     {
       rep = new typename Sparse<T>::SparseRep (nr, nc, 0);
       for (octave_idx_type j = 0; j < nc+1; j++)
-        xcidx(j) = 0;
+        xcidx (j) = 0;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
   if (dv.length () != 2)
@@ -259,31 +259,31 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
       octave_idx_type new_nr = dv (0);
       octave_idx_type new_nc = dv (1);
       octave_idx_type old_nr = old_dims (0);
       octave_idx_type old_nc = old_dims (1);
 
       rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
 
       octave_idx_type kk = 0;
-      xcidx(0) = 0;
+      xcidx (0) = 0;
       for (octave_idx_type i = 0; i < old_nc; i++)
-        for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++)
+        for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++)
           {
-            octave_idx_type tmp = i * old_nr + a.ridx(j);
+            octave_idx_type tmp = i * old_nr + a.ridx (j);
             octave_idx_type ii = tmp % new_nr;
             octave_idx_type jj = (tmp - ii) / new_nr;
             for (octave_idx_type k = kk; k < jj; k++)
-              xcidx(k+1) = j;
+              xcidx (k+1) = j;
             kk = jj;
-            xdata(j) = a.data(j);
-            xridx(j) = ii;
+            xdata (j) = a.data (j);
+            xridx (j) = ii;
           }
       for (octave_idx_type k = kk; k < new_nc; k++)
-        xcidx(k+1) = new_nzmx;
+        xcidx (k+1) = new_nzmx;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array<T>& a, const idx_vector& r,
                    const idx_vector& c, octave_idx_type nr,
                    octave_idx_type nc, bool sum_terms,
                    octave_idx_type nzm)
@@ -318,21 +318,21 @@ Sparse<T>::Sparse (const Array<T>& a, co
   if ((rl != 1 && rl != n) || (cl != 1 && cl != n))
     (*current_liboctave_error_handler) ("sparse: dimension mismatch");
 
   if (rl <= 1 && cl <= 1)
     {
       if (n == 1 && a(0) != T ())
         {
           change_capacity (nzm > 1 ? nzm : 1);
-          xcidx(0) = 0;
-          xridx(0) = r(0);
-          xdata(0) = a(0);
+          xcidx (0) = 0;
+          xridx (0) = r(0);
+          xdata (0) = a(0);
           for (octave_idx_type j = 0; j < nc; j++)
-            xcidx(j+1) = j >= c(0);
+            xcidx (j+1) = j >= c(0);
         }
     }
   else if (a_scalar)
     {
       // This is completely specialized, because the sorts can be simplified.
       T a0 = a(0);
       if (a0 == T ())
         {
@@ -414,33 +414,33 @@ Sparse<T>::Sparse (const Array<T>& a, co
           OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, n);
           for (octave_idx_type i = 0; i < n; i++)
             if (rl == 1)
               sidx[ci[cd[i]+1]++] = rd[0];
             else
               sidx[ci[cd[i]+1]++] = rd[i];
 
           // Subsorts. We don't need a stable sort, all values are equal.
-          xcidx(0) = 0;
+          xcidx (0) = 0;
           for (octave_idx_type j = 0; j < nc; j++)
             {
               std::sort (sidx + ci[j], sidx + ci[j+1]);
               octave_idx_type l = -1, nzj = 0;
               // Count.
               for (octave_idx_type i = ci[j]; i < ci[j+1]; i++)
                 {
                   octave_idx_type k = sidx[i];
                   if (k != l)
                     {
                       l = k;
                       nzj++;
                     }
                 }
               // Set column pointer.
-              xcidx(j+1) = xcidx(j) + nzj;
+              xcidx (j+1) = xcidx (j) + nzj;
             }
 
           change_capacity (nzm > xcidx (nc) ? nzm : xcidx (nc));
           octave_idx_type *rri = ridx ();
           T *rrd = data ();
 
           // Fill-in data.
           for (octave_idx_type j = 0, jj = -1; j < nc; j++)
@@ -490,18 +490,18 @@ Sparse<T>::Sparse (const Array<T>& a, co
 
       const octave_idx_type *rd = rs.raw (), *rdi = rsi.data ();
       // Count unique indices.
       octave_idx_type new_nz = 1;
       for (octave_idx_type i = 1; i < n; i++)
         new_nz += rd[i-1] != rd[i];
       // Allocate result.
       change_capacity (nzm > new_nz ? nzm : new_nz);
-      xcidx(0) = 0;
-      xcidx(1) = new_nz;
+      xcidx (0) = 0;
+      xcidx (1) = new_nz;
       octave_idx_type *rri = ridx ();
       T *rrd = data ();
 
       octave_quit ();
 
       octave_idx_type k = 0;
       rri[k] = rd[0];
       rrd[k] = a(rdi[0]);
@@ -561,33 +561,33 @@ Sparse<T>::Sparse (const Array<T>& a, co
           if (rl == 1)
             p.first = rd[0];
           else
             p.first = rd[i];
           p.second = i;
         }
 
       // Subsorts. We don't need a stable sort, the second index stabilizes it.
-      xcidx(0) = 0;
+      xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           std::sort (spairs + ci[j], spairs + ci[j+1]);
           octave_idx_type l = -1, nzj = 0;
           // Count.
           for (octave_idx_type i = ci[j]; i < ci[j+1]; i++)
             {
               octave_idx_type k = spairs[i].first;
               if (k != l)
                 {
                   l = k;
                   nzj++;
                 }
             }
           // Set column pointer.
-          xcidx(j+1) = xcidx(j) + nzj;
+          xcidx (j+1) = xcidx (j) + nzj;
         }
 
       change_capacity (nzm > xcidx (nc) ? nzm : xcidx (nc));
       octave_idx_type *rri = ridx ();
       T *rrd = data ();
 
       // Fill-in data.
       for (octave_idx_type j = 0, jj = -1; j < nc; j++)
@@ -647,26 +647,26 @@ Sparse<T>::Sparse (const Array<T>& a)
       // First count the number of non-zero terms
       for (octave_idx_type i = 0; i < len; i++)
         if (a(i) != T ())
           new_nzmx++;
 
       rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
 
       octave_idx_type ii = 0;
-      xcidx(0) = 0;
+      xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             if (a.elem (i,j) != T ())
               {
-                xdata(ii) = a.elem (i,j);
-                xridx(ii++) = i;
+                xdata (ii) = a.elem (i,j);
+                xridx (ii++) = i;
               }
-          xcidx(j+1) = ii;
+          xcidx (j+1) = ii;
         }
     }
 }
 
 template <class T>
 Sparse<T>::~Sparse (void)
 {
   if (--rep->count == 0)
@@ -828,31 +828,31 @@ Sparse<T>::reshape (const dim_vector& ne
           octave_idx_type new_nnz = nnz ();
           octave_idx_type new_nr = dims2 (0);
           octave_idx_type new_nc = dims2 (1);
           octave_idx_type old_nr = rows ();
           octave_idx_type old_nc = cols ();
           retval = Sparse<T> (new_nr, new_nc, new_nnz);
 
           octave_idx_type kk = 0;
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           for (octave_idx_type i = 0; i < old_nc; i++)
-            for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
+            for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)
               {
-                octave_idx_type tmp = i * old_nr + ridx(j);
+                octave_idx_type tmp = i * old_nr + ridx (j);
                 octave_idx_type ii = tmp % new_nr;
                 octave_idx_type jj = (tmp - ii) / new_nr;
                 for (octave_idx_type k = kk; k < jj; k++)
-                  retval.xcidx(k+1) = j;
+                  retval.xcidx (k+1) = j;
                 kk = jj;
-                retval.xdata(j) = data(j);
-                retval.xridx(j) = ii;
+                retval.xdata (j) = data (j);
+                retval.xridx (j) = ii;
               }
           for (octave_idx_type k = kk; k < new_nc; k++)
-            retval.xcidx(k+1) = new_nnz;
+            retval.xcidx (k+1) = new_nnz;
         }
       else
         {
           std::string dimensions_str = dimensions.str ();
           std::string new_dims_str = new_dims.str ();
 
           (*current_liboctave_error_handler)
             ("reshape: can't reshape %s array to %s array",
@@ -944,24 +944,24 @@ Sparse<T>::resize (octave_idx_type r, oc
   // Sparse rep. It is not good for anything in there.
   make_unique ();
 
   if (r < rows ())
     {
       octave_idx_type i = 0, k = 0;
       for (octave_idx_type j = 1; j <= rep->ncols; j++)
         {
-          octave_idx_type u = xcidx(j);
+          octave_idx_type u = xcidx (j);
           for (i = i; i < u; i++)
-            if (xridx(i) < r)
+            if (xridx (i) < r)
               {
-                xdata(k) = xdata(i);
-                xridx(k++) = xridx(i);
+                xdata (k) = xdata (i);
+                xridx (k++) = xridx (i);
               }
-          xcidx(j) = k;
+          xcidx (j) = k;
         }
     }
 
   rep->nrows = dimensions(0) = r;
 
   if (c != rep->ncols)
     {
       octave_idx_type *new_cidx = new octave_idx_type [c+1];
@@ -989,79 +989,79 @@ Sparse<T>::insert (const Sparse<T>& a, o
 
   if (r < 0 || r + a_rows > rows () || c < 0 || c + a_cols > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   // First count the number of elements in the final array
-  octave_idx_type nel = cidx(c) + a.nnz ();
+  octave_idx_type nel = cidx (c) + a.nnz ();
 
   if (c + a_cols < nc)
-    nel += cidx(nc) - cidx(c + a_cols);
+    nel += cidx (nc) - cidx (c + a_cols);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
-    for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
-      if (ridx(j) < r || ridx(j) >= r + a_rows)
+    for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)
+      if (ridx (j) < r || ridx (j) >= r + a_rows)
         nel++;
 
   Sparse<T> tmp (*this);
   --rep->count;
   rep = new typename Sparse<T>::SparseRep (nr, nc, nel);
 
-  for (octave_idx_type i = 0; i < tmp.cidx(c); i++)
+  for (octave_idx_type i = 0; i < tmp.cidx (c); i++)
     {
-      data(i) = tmp.data(i);
-      ridx(i) = tmp.ridx(i);
+      data (i) = tmp.data (i);
+      ridx (i) = tmp.ridx (i);
     }
   for (octave_idx_type i = 0; i < c + 1; i++)
-    cidx(i) = tmp.cidx(i);
+    cidx (i) = tmp.cidx (i);
 
-  octave_idx_type ii = cidx(c);
+  octave_idx_type ii = cidx (c);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
     {
       octave_quit ();
 
-      for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
-        if (tmp.ridx(j) < r)
+      for (octave_idx_type j = tmp.cidx (i); j < tmp.cidx (i+1); j++)
+        if (tmp.ridx (j) < r)
           {
-            data(ii) = tmp.data(j);
-            ridx(ii++) = tmp.ridx(j);
+            data (ii) = tmp.data (j);
+            ridx (ii++) = tmp.ridx (j);
           }
 
       octave_quit ();
 
-      for (octave_idx_type j = a.cidx(i-c); j < a.cidx(i-c+1); j++)
+      for (octave_idx_type j = a.cidx (i-c); j < a.cidx (i-c+1); j++)
         {
-          data(ii) = a.data(j);
-          ridx(ii++) = r + a.ridx(j);
+          data (ii) = a.data (j);
+          ridx (ii++) = r + a.ridx (j);
         }
 
       octave_quit ();
 
-      for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
-        if (tmp.ridx(j) >= r + a_rows)
+      for (octave_idx_type j = tmp.cidx (i); j < tmp.cidx (i+1); j++)
+        if (tmp.ridx (j) >= r + a_rows)
           {
-            data(ii) = tmp.data(j);
-            ridx(ii++) = tmp.ridx(j);
+            data (ii) = tmp.data (j);
+            ridx (ii++) = tmp.ridx (j);
           }
 
-      cidx(i+1) = ii;
+      cidx (i+1) = ii;
     }
 
   for (octave_idx_type i = c + a_cols; i < nc; i++)
     {
-      for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
+      for (octave_idx_type j = tmp.cidx (i); j < tmp.cidx (i+1); j++)
         {
-          data(ii) = tmp.data(j);
-          ridx(ii++) = tmp.ridx(j);
+          data (ii) = tmp.data (j);
+          ridx (ii++) = tmp.ridx (j);
         }
-      cidx(i+1) = ii;
+      cidx (i+1) = ii;
     }
 
   return *this;
 }
 
 template <class T>
 Sparse<T>&
 Sparse<T>::insert (const Sparse<T>& a, const Array<octave_idx_type>& ra_idx)
@@ -1095,17 +1095,17 @@ Sparse<T>::transpose (void) const
     {
       const octave_idx_type tmp = retval.xcidx (i);
       retval.xcidx (i) = nz;
       nz += tmp;
     }
   // retval.xcidx[1:nr] holds row entry *start* offsets for rows 0:(nr-1)
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+    for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
       {
         octave_idx_type q = retval.xcidx (ridx (k) + 1)++;
         retval.xridx (q) = j;
         retval.xdata (q) = data (k);
       }
   assert (nnz () == retval.xcidx (nr));
   // retval.xcidx[1:nr] holds row entry *end* offsets for rows 0:(nr-1)
   // and retval.xcidx[0:(nr-1)] holds their row entry *start* offsets
@@ -1165,50 +1165,50 @@ Sparse<T>::delete_elements (const idx_ve
           octave_idx_type ui = lblookup (tmp.ridx (), nz, ub);
           // Copy data and adjust indices.
           octave_idx_type nz_new = nz - (ui - li);
           *this = Sparse<T> (nr - (ub - lb), 1, nz_new);
           copy_or_memcpy (li, tmp.data (), data ());
           copy_or_memcpy (li, tmp.ridx (), xridx ());
           copy_or_memcpy (nz - ui, tmp.data () + ui, xdata () + li);
           mx_inline_sub (nz - ui, xridx () + li, tmp.ridx () + ui, ub - lb);
-          xcidx(1) = nz_new;
+          xcidx (1) = nz_new;
         }
       else
         {
           OCTAVE_LOCAL_BUFFER (octave_idx_type, ridx_new, nz);
           OCTAVE_LOCAL_BUFFER (T, data_new, nz);
           idx_vector sidx = idx.sorted (true);
           const octave_idx_type *sj = sidx.raw ();
           octave_idx_type sl = sidx.length (nel), nz_new = 0, j = 0;
           for (octave_idx_type i = 0; i < nz; i++)
             {
-              octave_idx_type r = tmp.ridx(i);
+              octave_idx_type r = tmp.ridx (i);
               for (;j < sl && sj[j] < r; j++) ;
               if (j == sl || sj[j] > r)
                 {
-                  data_new[nz_new] = tmp.data(i);
+                  data_new[nz_new] = tmp.data (i);
                   ridx_new[nz_new++] = r - j;
                 }
             }
 
           *this = Sparse<T> (nr - sl, 1, nz_new);
           copy_or_memcpy (nz_new, ridx_new, ridx ());
           copy_or_memcpy (nz_new, data_new, xdata ());
-          xcidx(1) = nz_new;
+          xcidx (1) = nz_new;
         }
     }
   else if (nr == 1)
     {
       // Sparse row vector.
       octave_idx_type lb, ub;
       if (idx.is_cont_range (nc, lb, ub))
         {
           const Sparse<T> tmp = *this;
-          octave_idx_type lbi = tmp.cidx(lb), ubi = tmp.cidx(ub), new_nz = nz - (ubi - lbi);
+          octave_idx_type lbi = tmp.cidx (lb), ubi = tmp.cidx (ub), new_nz = nz - (ubi - lbi);
           *this = Sparse<T> (1, nc - (ub - lb), new_nz);
           copy_or_memcpy (lbi, tmp.data (), data ());
           copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
           fill_or_memset (new_nz, static_cast<octave_idx_type> (0), ridx ());
           copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
           mx_inline_sub (nc - ub, xcidx () + 1, tmp.cidx () + ub + 1, ubi - lbi);
         }
       else
@@ -1248,17 +1248,17 @@ Sparse<T>::delete_elements (const idx_ve
           else if (nz == 0)
             {
               // No elements to preserve; adjust dimensions.
               *this = Sparse<T> (nr, nc - (ub - lb));
             }
           else
             {
               const Sparse<T> tmp = *this;
-              octave_idx_type lbi = tmp.cidx(lb), ubi = tmp.cidx(ub),
+              octave_idx_type lbi = tmp.cidx (lb), ubi = tmp.cidx (ub),
                 new_nz = nz - (ubi - lbi);
 
               *this = Sparse<T> (nr, nc - (ub - lb), new_nz);
               copy_or_memcpy (lbi, tmp.data (), data ());
               copy_or_memcpy (lbi, tmp.ridx (), ridx ());
               copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
               copy_or_memcpy (nz - ubi, tmp.ridx () + ubi, xridx () + lbi);
               copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
@@ -1291,30 +1291,30 @@ Sparse<T>::delete_elements (const idx_ve
             {
               // This is more memory-efficient than the approach below.
               const Sparse<T> tmpl = index (idx_vector (0, lb), idx_j);
               const Sparse<T> tmpu = index (idx_vector (ub, nr), idx_j);
               *this = Sparse<T> (nr - (ub - lb), nc,
                                  tmpl.nnz () + tmpu.nnz ());
               for (octave_idx_type j = 0, k = 0; j < nc; j++)
                 {
-                  for (octave_idx_type i = tmpl.cidx(j); i < tmpl.cidx(j+1);
+                  for (octave_idx_type i = tmpl.cidx (j); i < tmpl.cidx (j+1);
                        i++)
                     {
-                      xdata(k) = tmpl.data(i);
-                      xridx(k++) = tmpl.ridx(i);
+                      xdata (k) = tmpl.data (i);
+                      xridx (k++) = tmpl.ridx (i);
                     }
-                  for (octave_idx_type i = tmpu.cidx(j); i < tmpu.cidx(j+1);
+                  for (octave_idx_type i = tmpu.cidx (j); i < tmpu.cidx (j+1);
                        i++)
                     {
-                      xdata(k) = tmpu.data(i);
-                      xridx(k++) = tmpu.ridx(i) + lb;
+                      xdata (k) = tmpu.data (i);
+                      xridx (k++) = tmpu.ridx (i) + lb;
                     }
 
-                  xcidx(j+1) = k;
+                  xcidx (j+1) = k;
                 }
             }
         }
       else
         {
           // This is done by transposing, deleting columns, then transposing
           // again.
           Sparse<T> tmp = transpose ();
@@ -1368,25 +1368,25 @@ Sparse<T>::index (const idx_vector& idx,
         retval = *this;
       else
         {
           // Fast magic colon processing.
           retval = Sparse<T> (nel, 1, nz);
 
           for (octave_idx_type i = 0; i < nc; i++)
             {
-              for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
+              for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)
                 {
-                  retval.xdata(j) = data(j);
-                  retval.xridx(j) = ridx(j) + i * nr;
+                  retval.xdata (j) = data (j);
+                  retval.xridx (j) = ridx (j) + i * nr;
                 }
             }
 
-          retval.xcidx(0) = 0;
-          retval.xcidx(1) = nz;
+          retval.xcidx (0) = 0;
+          retval.xcidx (1) = nz;
         }
     }
   else if (idx.extent (nel) > nel)
     {
       // resize_ok is completely handled here.
       if (resize_ok)
         {
           octave_idx_type ext = idx.extent (nel);
@@ -1399,44 +1399,44 @@ Sparse<T>::index (const idx_vector& idx,
     }
   else if (nr == 1 && nc == 1)
     {
       // You have to be pretty sick to get to this bit of code,
       // since you have a scalar stored as a sparse matrix, and
       // then want to make a dense matrix with sparse
       // representation. Ok, we'll do it, but you deserve what
       // you get!!
-      retval = Sparse<T> (idx_dims(0), idx_dims(1), nz ? data(0) : T ());
+      retval = Sparse<T> (idx_dims(0), idx_dims(1), nz ? data (0) : T ());
     }
   else if (nc == 1)
     {
       // Sparse column vector.
       octave_idx_type lb, ub;
 
       if (idx.is_scalar ())
         {
           // Scalar index - just a binary lookup.
           octave_idx_type i = lblookup (ridx (), nz, idx(0));
-          if (i < nz && ridx(i) == idx(0))
-            retval = Sparse (1, 1, data(i));
+          if (i < nz && ridx (i) == idx(0))
+            retval = Sparse (1, 1, data (i));
           else
             retval = Sparse (1, 1);
         }
       else if (idx.is_cont_range (nel, lb, ub))
         {
           // Special-case a contiguous range.
           // Look-up indices first.
           octave_idx_type li = lblookup (ridx (), nz, lb);
           octave_idx_type ui = lblookup (ridx (), nz, ub);
           // Copy data and adjust indices.
           octave_idx_type nz_new = ui - li;
           retval = Sparse<T> (ub - lb, 1, nz_new);
           copy_or_memcpy (nz_new, data () + li, retval.data ());
           mx_inline_sub (nz_new, retval.xridx (), ridx () + li, lb);
-          retval.xcidx(1) = nz_new;
+          retval.xcidx (1) = nz_new;
         }
       else if (idx.is_permutation (nel) && idx.is_vector ())
         {
           if (idx.is_range () && idx.increment () == -1)
             {
               retval = Sparse<T> (nr, 1, nz);
 
               for (octave_idx_type j = 0; j < nz; j++)
@@ -1472,49 +1472,49 @@ Sparse<T>::index (const idx_vector& idx,
           // Count matches.
           retval = Sparse<T> (idxa.rows (), idxa.cols ());
           for (octave_idx_type j = 0; j < new_nc; j++)
             {
               octave_idx_type nzj = 0;
               for (octave_idx_type i = 0; i < new_nr; i++)
                 {
                   octave_idx_type l = lidx(i, j);
-                  if (l < nz && ridx(l) == idxa(i, j))
+                  if (l < nz && ridx (l) == idxa(i, j))
                     nzj++;
                   else
                     lidx(i, j) = nz;
                 }
-              retval.xcidx(j+1) = retval.xcidx(j) + nzj;
+              retval.xcidx (j+1) = retval.xcidx (j) + nzj;
             }
 
-          retval.change_capacity (retval.xcidx(new_nc));
+          retval.change_capacity (retval.xcidx (new_nc));
 
           // Copy data and set row indices.
           octave_idx_type k = 0;
           for (octave_idx_type j = 0; j < new_nc; j++)
             for (octave_idx_type i = 0; i < new_nr; i++)
               {
                 octave_idx_type l = lidx(i, j);
                 if (l < nz)
                   {
-                    retval.data(k) = data(l);
-                    retval.xridx(k++) = i;
+                    retval.data (k) = data (l);
+                    retval.xridx (k++) = i;
                   }
               }
         }
     }
   else if (nr == 1)
     {
       octave_idx_type lb, ub;
       if (idx.is_scalar ())
-        retval = Sparse<T> (1, 1, elem(0, idx(0)));
+        retval = Sparse<T> (1, 1, elem (0, idx(0)));
       else if (idx.is_cont_range (nel, lb, ub))
         {
           // Special-case a contiguous range.
-          octave_idx_type lbi = cidx(lb), ubi = cidx(ub), new_nz = ubi - lbi;
+          octave_idx_type lbi = cidx (lb), ubi = cidx (ub), new_nz = ubi - lbi;
           retval = Sparse<T> (1, ub - lb, new_nz);
           copy_or_memcpy (new_nz, data () + lbi, retval.data ());
           fill_or_memset (new_nz, static_cast<octave_idx_type> (0), retval.ridx ());
           mx_inline_sub (ub - lb + 1, retval.cidx (), cidx () + lb, lbi);
         }
       else
         {
           // Sparse row vectors occupy O(nr) storage anyway, so let's just
@@ -1578,39 +1578,39 @@ Sparse<T>::index (const idx_vector& idx_
     {
       // Great, we're just manipulating columns. This is going to be quite
       // efficient, because the columns can stay compressed as they are.
       if (idx_j.is_colon ())
         retval = *this; // Shallow copy.
       else if (idx_j.is_cont_range (nc, lb, ub))
         {
           // Special-case a contiguous range.
-          octave_idx_type lbi = cidx(lb), ubi = cidx(ub), new_nz = ubi - lbi;
+          octave_idx_type lbi = cidx (lb), ubi = cidx (ub), new_nz = ubi - lbi;
           retval = Sparse<T> (nr, ub - lb, new_nz);
           copy_or_memcpy (new_nz, data () + lbi, retval.data ());
           copy_or_memcpy (new_nz, ridx () + lbi, retval.ridx ());
           mx_inline_sub (ub - lb + 1, retval.cidx (), cidx () + lb, lbi);
         }
       else
         {
           // Count new nonzero elements.
           retval = Sparse<T> (nr, m);
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_idx_type jj = idx_j(j);
-              retval.xcidx(j+1) = retval.xcidx(j) + (cidx(jj+1) - cidx(jj));
+              retval.xcidx (j+1) = retval.xcidx (j) + (cidx (jj+1) - cidx (jj));
             }
 
           retval.change_capacity (retval.xcidx (m));
 
           // Copy data & indices.
           for (octave_idx_type j = 0; j < m; j++)
             {
-              octave_idx_type ljj = cidx(idx_j(j));
-              octave_idx_type lj = retval.xcidx(j), nzj = retval.xcidx(j+1) - lj;
+              octave_idx_type ljj = cidx (idx_j(j));
+              octave_idx_type lj = retval.xcidx (j), nzj = retval.xcidx (j+1) - lj;
               copy_or_memcpy (nzj, data () + ljj, retval.data () + lj);
               copy_or_memcpy (nzj, ridx () + ljj, retval.ridx () + lj);
             }
         }
     }
   else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
     {
       // It's actually vector indexing. The 1D index is specialized for that.
@@ -1623,127 +1623,127 @@ Sparse<T>::index (const idx_vector& idx_
   else if (idx_i.is_scalar ())
     {
       octave_idx_type ii = idx_i(0);
       retval = Sparse<T> (1, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ij, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
           octave_quit ();
-          octave_idx_type jj = idx_j(j), lj = cidx(jj), nzj = cidx(jj+1) - cidx(jj);
+          octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
           // Scalar index - just a binary lookup.
           octave_idx_type i = lblookup (ridx () + lj, nzj, ii);
-          if (i < nzj && ridx(i+lj) == ii)
+          if (i < nzj && ridx (i+lj) == ii)
             {
               ij[j] = i + lj;
-              retval.xcidx(j+1) = retval.xcidx(j) + 1;
+              retval.xcidx (j+1) = retval.xcidx (j) + 1;
             }
           else
-            retval.xcidx(j+1) = retval.xcidx(j);
+            retval.xcidx (j+1) = retval.xcidx (j);
         }
 
-      retval.change_capacity (retval.xcidx(m));
+      retval.change_capacity (retval.xcidx (m));
 
       // Copy data, adjust row indices.
       for (octave_idx_type j = 0; j < m; j++)
         {
-          octave_idx_type i = retval.xcidx(j);
-          if (retval.xcidx(j+1) > i)
+          octave_idx_type i = retval.xcidx (j);
+          if (retval.xcidx (j+1) > i)
             {
-              retval.xridx(i) = 0;
-              retval.xdata(i) = data(ij[j]);
+              retval.xridx (i) = 0;
+              retval.xdata (i) = data (ij[j]);
             }
         }
     }
   else if (idx_i.is_cont_range (nr, lb, ub))
     {
       retval = Sparse<T> (n, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, li, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ui, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
           octave_quit ();
-          octave_idx_type jj = idx_j(j), lj = cidx(jj), nzj = cidx(jj+1) - cidx(jj);
+          octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
           octave_idx_type lij, uij;
           // Lookup indices.
           li[j] = lij = lblookup (ridx () + lj, nzj, lb) + lj;
           ui[j] = uij = lblookup (ridx () + lj, nzj, ub) + lj;
-          retval.xcidx(j+1) = retval.xcidx(j) + ui[j] - li[j];
+          retval.xcidx (j+1) = retval.xcidx (j) + ui[j] - li[j];
         }
 
-      retval.change_capacity (retval.xcidx(m));
+      retval.change_capacity (retval.xcidx (m));
 
       // Copy data, adjust row indices.
       for (octave_idx_type j = 0, k = 0; j < m; j++)
         {
           octave_quit ();
           for (octave_idx_type i = li[j]; i < ui[j]; i++)
             {
-              retval.xdata(k) = data(i);
-              retval.xridx(k++) = ridx(i) - lb;
+              retval.xdata (k) = data (i);
+              retval.xridx (k++) = ridx (i) - lb;
             }
         }
     }
   else if (idx_i.is_permutation (nr))
     {
       // The columns preserve their length, we just need to renumber and sort them.
       // Count new nonzero elements.
       retval = Sparse<T> (nr, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
           octave_idx_type jj = idx_j(j);
-          retval.xcidx(j+1) = retval.xcidx(j) + (cidx(jj+1) - cidx(jj));
+          retval.xcidx (j+1) = retval.xcidx (j) + (cidx (jj+1) - cidx (jj));
         }
 
       retval.change_capacity (retval.xcidx (m));
 
       octave_quit ();
 
       if (idx_i.is_range () && idx_i.increment () == -1)
         {
           // It's nr:-1:1. Just flip all columns.
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_quit ();
-              octave_idx_type jj = idx_j(j), lj = cidx(jj), nzj = cidx(jj+1) - cidx(jj);
-              octave_idx_type li = retval.xcidx(j), uj = lj + nzj - 1;
+              octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
+              octave_idx_type li = retval.xcidx (j), uj = lj + nzj - 1;
               for (octave_idx_type i = 0; i < nzj; i++)
                 {
-                  retval.xdata(li + i) = data(uj - i); // Copy in reverse order.
-                  retval.xridx(li + i) = nr - 1 - ridx(uj - i); // Ditto with transform.
+                  retval.xdata (li + i) = data (uj - i); // Copy in reverse order.
+                  retval.xridx (li + i) = nr - 1 - ridx (uj - i); // Ditto with transform.
                 }
             }
         }
       else
         {
           // Get inverse permutation.
           idx_vector idx_iinv = idx_i.inverse_permutation (nr);
           const octave_idx_type *iinv = idx_iinv.raw ();
 
           // Scatter buffer.
           OCTAVE_LOCAL_BUFFER (T, scb, nr);
           octave_idx_type *rri = retval.ridx ();
 
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_quit ();
-              octave_idx_type jj = idx_j(j), lj = cidx(jj), nzj = cidx(jj+1) - cidx(jj);
-              octave_idx_type li = retval.xcidx(j);
+              octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
+              octave_idx_type li = retval.xcidx (j);
               // Scatter the column, transform indices.
               for (octave_idx_type i = 0; i < nzj; i++)
-                scb[rri[li + i] = iinv[ridx(lj + i)]] = data(lj + i);
+                scb[rri[li + i] = iinv[ridx (lj + i)]] = data (lj + i);
 
               octave_quit ();
 
               // Sort them.
               std::sort (rri + li, rri + li + nzj);
 
               // Gather.
               for (octave_idx_type i = 0; i < nzj; i++)
-                retval.xdata(li + i) = scb[rri[li + i]];
+                retval.xdata (li + i) = scb[rri[li + i]];
             }
         }
 
     }
   else if (idx_j.is_colon ())
     {
       // This requires  uncompressing columns, which is generally costly,
       // so we rely on the efficient transpose to handle this.
@@ -1841,17 +1841,17 @@ Sparse<T>::assign (const idx_vector& idx
                   copy_or_memcpy (rnz, rhs.data (), data () + li);
                   mx_inline_add (rnz, ridx () + li, rhs.ridx (), lb);
 
                   // ...tail
                   copy_or_memcpy (nz - ui, tmp.data () + ui, data () + li + rnz);
                   copy_or_memcpy (nz - ui, tmp.ridx () + ui, ridx () + li + rnz);
                 }
 
-              cidx(1) = new_nz;
+              cidx (1) = new_nz;
             }
           else if (idx.is_range () && idx.increment () == -1)
             {
               // It's s(u:-1:l) = r. Reverse the assignment.
               assign (idx.sorted (), rhs.index (idx_vector (rhl - 1, 0, -1)));
             }
           else if (idx.is_permutation (n))
             {
@@ -1861,17 +1861,17 @@ Sparse<T>::assign (const idx_vector& idx
             {
               // Elements are being zeroed.
               octave_idx_type *ri = ridx ();
               for (octave_idx_type i = 0; i < rhl; i++)
                 {
                   octave_idx_type iidx = idx(i);
                   octave_idx_type li = lblookup (ri, nz, iidx);
                   if (li != nz && ri[li] == iidx)
-                    xdata(li) = T ();
+                    xdata (li) = T ();
                 }
 
               maybe_compress (true);
             }
           else
             {
               const Sparse<T> tmp = *this;
               octave_idx_type new_nz = nz + rhl;
@@ -1980,17 +1980,17 @@ Sparse<T>::assign (const idx_vector& idx
           octave_idx_type lb, ub;
           // Great, we're just manipulating columns. This is going to be quite
           // efficient, because the columns can stay compressed as they are.
           if (idx_j.is_colon ())
             *this = rhs; // Shallow copy.
           else if (idx_j.is_cont_range (nc, lb, ub))
             {
               // Special-case a contiguous range.
-              octave_idx_type li = cidx(lb), ui = cidx(ub);
+              octave_idx_type li = cidx (lb), ui = cidx (ub);
               octave_idx_type rnz = rhs.nnz (), new_nz = nz - (ui - li) + rnz;
 
               if (new_nz >= nz && new_nz <= capacity ())
                 {
                   // Adding/overwriting elements, enough capacity allocated.
 
                   if (new_nz > nz)
                     {
@@ -2046,46 +2046,46 @@ Sparse<T>::assign (const idx_vector& idx
           else
             {
               const Sparse<T> tmp = *this;
               *this = Sparse<T> (nr, nc);
               OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, jsav, nc, -1);
 
               // Assemble column lengths.
               for (octave_idx_type i = 0; i < nc; i++)
-                xcidx(i+1) = tmp.cidx(i+1) - tmp.cidx(i);
+                xcidx (i+1) = tmp.cidx (i+1) - tmp.cidx (i);
 
               for (octave_idx_type i = 0; i < m; i++)
                 {
                   octave_idx_type j =idx_j(i);
                   jsav[j] = i;
-                  xcidx(j+1) = rhs.cidx(i+1) - rhs.cidx(i);
+                  xcidx (j+1) = rhs.cidx (i+1) - rhs.cidx (i);
                 }
 
               // Make cumulative.
               for (octave_idx_type i = 0; i < nc; i++)
-                xcidx(i+1) += xcidx(i);
+                xcidx (i+1) += xcidx (i);
 
               change_capacity (nnz ());
 
               // Merge columns.
               for (octave_idx_type i = 0; i < nc; i++)
                 {
-                  octave_idx_type l = xcidx(i), u = xcidx(i+1), j = jsav[i];
+                  octave_idx_type l = xcidx (i), u = xcidx (i+1), j = jsav[i];
                   if (j >= 0)
                     {
                       // from rhs
-                      octave_idx_type k = rhs.cidx(j);
+                      octave_idx_type k = rhs.cidx (j);
                       copy_or_memcpy (u - l, rhs.data () + k, xdata () + l);
                       copy_or_memcpy (u - l, rhs.ridx () + k, xridx () + l);
                     }
                   else
                     {
                       // original
-                      octave_idx_type k = tmp.cidx(i);
+                      octave_idx_type k = tmp.cidx (i);
                       copy_or_memcpy (u - l, tmp.data () + k, xdata () + l);
                       copy_or_memcpy (u - l, tmp.ridx () + k, xridx () + l);
                     }
                 }
 
             }
         }
       else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
@@ -2178,36 +2178,36 @@ Sparse<T>::sort (octave_idx_type dim, so
     abort ();
 
   T *v = m.data ();
   octave_idx_type *mcidx = m.cidx ();
   octave_idx_type *mridx = m.ridx ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      octave_idx_type ns = mcidx [j + 1] - mcidx [j];
+      octave_idx_type ns = mcidx[j + 1] - mcidx[j];
       lsort.sort (v, ns);
 
       octave_idx_type i;
       if (mode == ASCENDING)
         {
           for (i = 0; i < ns; i++)
-            if (sparse_ascending_compare<T> (static_cast<T> (0), v [i]))
+            if (sparse_ascending_compare<T> (static_cast<T> (0), v[i]))
               break;
         }
       else
         {
           for (i = 0; i < ns; i++)
-            if (sparse_descending_compare<T> (static_cast<T> (0), v [i]))
+            if (sparse_descending_compare<T> (static_cast<T> (0), v[i]))
               break;
         }
       for (octave_idx_type k = 0; k < i; k++)
-        mridx [k] = k;
+        mridx[k] = k;
       for (octave_idx_type k = i; k < ns; k++)
-        mridx [k] = k - ns + nr;
+        mridx[k] = k - ns + nr;
 
       v += ns;
       mridx += ns;
     }
 
   if (dim > 0)
       m = m.transpose ();
 
@@ -2250,17 +2250,17 @@ Sparse<T>::sort (Array<octave_idx_type> 
   octave_idx_type *mcidx = m.cidx ();
   octave_idx_type *mridx = m.ridx ();
 
   sidx = Array<octave_idx_type> (dim_vector (nr, nc));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, vi, nr);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      octave_idx_type ns = mcidx [j + 1] - mcidx [j];
+      octave_idx_type ns = mcidx[j + 1] - mcidx[j];
       octave_idx_type offset = j * nr;
 
       if (ns == 0)
         {
           for (octave_idx_type k = 0; k < nr; k++)
             sidx (offset + k) = k;
         }
       else
@@ -2291,24 +2291,24 @@ Sparse<T>::sort (Array<octave_idx_type> 
               if (ii < ns && mridx[ii] == k)
                 ii++;
               else
                 sidx (offset + jj++) = k;
             }
 
           for (octave_idx_type k = 0; k < i; k++)
             {
-              sidx (k + offset) = vi [k];
-              mridx [k] = k;
+              sidx (k + offset) = vi[k];
+              mridx[k] = k;
             }
 
           for (octave_idx_type k = i; k < ns; k++)
             {
-              sidx (k - ns + nr + offset) = vi [k];
-              mridx [k] = k - ns + nr;
+              sidx (k - ns + nr + offset) = vi[k];
+              mridx[k] = k - ns + nr;
             }
 
           v += ns;
           mridx += ns;
         }
     }
 
   if (dim > 0)
@@ -2432,39 +2432,39 @@ Sparse<T>::diag (octave_idx_type k) cons
 
           if (nnz () > 0)
             {
               for (octave_idx_type i = 0; i < coff+1; i++)
                 d.xcidx (i) = 0;
 
               for (octave_idx_type j = 0; j < nnc; j++)
                 {
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     {
                       d.xdata (i) = data (i);
                       d.xridx (i) = j + roff;
                     }
-                  d.xcidx (j + coff + 1) = cidx(j+1);
+                  d.xcidx (j + coff + 1) = cidx (j+1);
                 }
 
               for (octave_idx_type i = nnc + coff + 1; i < n + 1; i++)
                 d.xcidx (i) = nz;
             }
         }
       else
         {
           octave_idx_type n = nnr + std::abs (k);
           octave_idx_type nz = nnz ();
 
           d = Sparse<T> (n, n, nz);
 
           if (nnz () > 0)
             {
               octave_idx_type ii = 0;
-              octave_idx_type ir = ridx(0);
+              octave_idx_type ir = ridx (0);
 
               for (octave_idx_type i = 0; i < coff+1; i++)
                 d.xcidx (i) = 0;
 
               for (octave_idx_type i = 0; i < nnr; i++)
                 {
                   if (ir == i)
                     {
@@ -2540,27 +2540,27 @@ Sparse<T>::cat (int dim, octave_idx_type
             octave_idx_type rcum = 0;
             for (octave_idx_type i = 0; i < n; i++)
               {
                 const Sparse<T>& spi = sparse_list[i];
                 // Skipping empty matrices. See the comment in Array.cc.
                 if (spi.is_empty ())
                   continue;
 
-                octave_idx_type kl = spi.cidx(j), ku = spi.cidx(j+1);
+                octave_idx_type kl = spi.cidx (j), ku = spi.cidx (j+1);
                 for (octave_idx_type k = kl; k < ku; k++, l++)
                   {
-                    retval.xridx(l) = spi.ridx(k) + rcum;
-                    retval.xdata(l) = spi.data(k);
+                    retval.xridx (l) = spi.ridx (k) + rcum;
+                    retval.xdata (l) = spi.data (k);
                   }
 
                 rcum += spi.rows ();
               }
 
-            retval.xcidx(j+1) = l;
+            retval.xcidx (j+1) = l;
           }
 
         break;
       }
     case 1:
       {
         octave_idx_type l = 0;
         for (octave_idx_type i = 0; i < n; i++)
@@ -2590,25 +2590,25 @@ Array<T>
 Sparse<T>::array_value () const
 {
   NoAlias< Array<T> > retval (dims (), T ());
   if (rows () == 1)
     {
       octave_idx_type i = 0;
       for (octave_idx_type j = 0, nc = cols (); j < nc; j++)
         {
-          if (cidx(j+1) > i)
+          if (cidx (j+1) > i)
             retval(j) = data (i++);
         }
     }
   else
     {
       for (octave_idx_type j = 0, nc = cols (); j < nc; j++)
-        for (octave_idx_type i = cidx(j), iu = cidx(j+1); i < iu; i++)
-          retval(ridx(i), j) = data (i);
+        for (octave_idx_type i = cidx (j), iu = cidx (j+1); i < iu; i++)
+          retval(ridx (i), j) = data (i);
     }
 
   return retval;
 }
 
 /*
  * Tests
  *
@@ -2638,22 +2638,22 @@ Sparse<T>::array_value () const
 %!      error ("invalid dim, '%d'", dim);
 %!  endswitch
 %!endfunction
 
 %!function test_sparse_slice (size, dim, slice)
 %!  x = ones (size);
 %!  s = set_slice (sparse (x), dim, slice);
 %!  f = set_slice (x, dim, slice);
-%!  assert (nnz(s), nnz(f));
-%!  assert (full(s), f);
-%!  s = set_slice2 (sparse(x), dim, slice);
+%!  assert (nnz (s), nnz (f));
+%!  assert (full (s), f);
+%!  s = set_slice2 (sparse (x), dim, slice);
 %!  f = set_slice2 (x, dim, slice);
-%!  assert (nnz(s), nnz(f));
-%!  assert (full(s), f);
+%!  assert (nnz (s), nnz (f));
+%!  assert (full (s), f);
 %!endfunction
 
 #### 1d indexing
 
 ## size = [2 0]
 %!test test_sparse_slice ([2 0], 11, []);
 %!assert (set_slice (sparse (ones ([2 0])), 11, 1), sparse ([2 0]'))  # sparse different from full
 %!assert (set_slice (sparse (ones ([2 0])), 11, 2), sparse ([0 2]'))  # sparse different from full
@@ -2775,17 +2775,17 @@ bug #35570:
 ## Test removing columns (bug #36656)
 
 %!test
 %! s = sparse (magic (5));
 %! s(:,2:4) = [];
 %! assert (s, sparse (magic (5)(:, [1,5])));
 
 %!test
-%! s = sparse([], [], [], 1, 1);
+%! s = sparse ([], [], [], 1, 1);
 %! s(1,:) = [];
 %! assert (s, sparse ([], [], [], 0, 1));
 
 */
 
 template <class T>
 void
 Sparse<T>::print_info (std::ostream& os, const std::string& prefix) const
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -67,32 +67,32 @@ protected:
     octave_idx_type *r;
     octave_idx_type *c;
     octave_idx_type nzmx;
     octave_idx_type nrows;
     octave_idx_type ncols;
     octave_refcount<int> count;
 
     SparseRep (void)
-      : d (0), r (0), c (new octave_idx_type [1]), nzmx (0), nrows (0),
+      : d (0), r (0), c (new octave_idx_type[1]), nzmx (0), nrows (0),
       ncols (0), count (1)
       {
         c[0] = 0;
       }
 
     SparseRep (octave_idx_type n)
       : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
       ncols (n), count (1)
       {
         for (octave_idx_type i = 0; i < n + 1; i++)
           c[i] = 0;
       }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz = 0)
-      : d (new T [nz]), r (new octave_idx_type [nz]),
+      : d (new T[nz]), r (new octave_idx_type[nz]),
       c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr),
       ncols (nc), count (1)
       {
         c[nc] = nz;
         for (octave_idx_type i = 0; i < nc; i++)
           c[i] = 0;
       }
 
@@ -106,17 +106,17 @@ protected:
         copy_or_memcpy (nz, a.r, r);
         copy_or_memcpy (ncols + 1, a.c, c);
       }
 
     ~SparseRep (void) { delete [] d; delete [] r; delete [] c; }
 
     octave_idx_type length (void) const { return nzmx; }
 
-    octave_idx_type nnz (void) const { return c [ncols]; }
+    octave_idx_type nnz (void) const { return c[ncols]; }
 
     T& elem (octave_idx_type _r, octave_idx_type _c);
 
     T celem (octave_idx_type _r, octave_idx_type _c) const;
 
     T& data (octave_idx_type i) { return d[i]; }
 
     T cdata (octave_idx_type i) const { return d[i]; }
@@ -263,17 +263,17 @@ public:
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
   octave_idx_type get_row_index (octave_idx_type k) { return ridx (k); }
   octave_idx_type get_col_index (octave_idx_type k)
   {
     octave_idx_type ret = 0;
-    while (cidx(ret+1) < k)
+    while (cidx (ret+1) < k)
       ret++;
     return ret;
   }
 
   size_t byte_size (void) const
   {
     return (static_cast<size_t>(cols () + 1) * sizeof (octave_idx_type)
             + static_cast<size_t> (capacity ())
@@ -594,38 +594,38 @@ public:
     if (f_zero != 0.)
       {
         octave_idx_type nr = rows ();
         octave_idx_type nc = cols ();
 
         result = Sparse<U> (nr, nc, f_zero);
 
         for (octave_idx_type j = 0; j < nc; j++)
-          for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_quit ();
               /* Use data instead of elem for better performance.  */
-              result.data (ridx (i) + j * nr) = fcn (data(i));
+              result.data (ridx (i) + j * nr) = fcn (data (i));
             }
 
         result.maybe_compress (true);
       }
     else
       {
         octave_idx_type nz = nnz ();
         octave_idx_type nr = rows ();
         octave_idx_type nc = cols ();
 
         result = Sparse<U> (nr, nc, nz);
         octave_idx_type ii = 0;
         result.cidx (ii) = 0;
 
         for (octave_idx_type j = 0; j < nc; j++)
           {
-            for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 U val = fcn (data (i));
                 if (val != 0.0)
                   {
                     result.data (ii) = val;
                     result.ridx (ii++) = ridx (i);
                   }
                 octave_quit ();
@@ -704,17 +704,17 @@ read_sparse_matrix (std::istream& is, Sp
               (*current_liboctave_error_handler)
                 ("invalid sparse matrix: column indices must appear in ascending order");
               is.setstate (std::ios::failbit);
               goto done;
             }
           else if (jtmp > jold)
             {
               for (octave_idx_type j = jold; j < jtmp; j++)
-                a.cidx(j+1) = ii;
+                a.cidx (j+1) = ii;
             }
           else if (itmp < iold)
             {
               (*current_liboctave_error_handler)
                 ("invalid sparse matrix: row indices must appear in ascending order in each column");
               is.setstate (std::ios::failbit);
               goto done;
             }
@@ -729,17 +729,17 @@ read_sparse_matrix (std::istream& is, Sp
               a.data (ii) = tmp;
               a.ridx (ii++) = itmp;
             }
           else
             goto done;
         }
 
       for (octave_idx_type j = jold; j < nc; j++)
-        a.cidx(j+1) = ii;
+        a.cidx (j+1) = ii;
     }
 
  done:
 
   return is;
 }
 
 #endif
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/SparseCmplxCHOL.cc
--- a/liboctave/SparseCmplxCHOL.cc
+++ b/liboctave/SparseCmplxCHOL.cc
@@ -46,22 +46,22 @@ chol2inv (const SparseComplexMatrix& r)
       MatrixType mattype (r);
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseComplexMatrix rinv;
 
       if (typ == MatrixType::Upper)
         {
-          rinv = r.inverse(mattype, info, rcond, true, false);
+          rinv = r.inverse (mattype, info, rcond, true, false);
           retval = rinv.transpose () * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
-          rinv = r.transpose ().inverse(mattype, info, rcond, true, false);
+          rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
           retval = rinv.transpose () * rinv;
         }
       else
         (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -321,17 +321,17 @@ SparseComplexLU::SparseComplexLU (const 
       int status;
 
       // Null loop so that qinit is imediately deallocated when not
       // needed
       do {
         OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
         for (octave_idx_type i = 0; i < nc; i++)
-          qinit [i] = static_cast<octave_idx_type> (Qinit (i));
+          qinit[i] = static_cast<octave_idx_type> (Qinit (i));
 
         status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
                                        reinterpret_cast<const double *> (Ax),
                                        0, qinit, &Symbolic, control,
                                        info);
       } while (0);
 
       if (status < 0)
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -64,17 +64,17 @@ SparseComplexQR::SparseComplexQR_rep::Sp
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<cs_complex_t *>(reinterpret_cast<const cs_complex_t *>
                                       (a.data ()));
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
 #else
   S = CXSPARSE_ZNAME (_sqr) (&A, order - 1, 1);
 #endif
   N = CXSPARSE_ZNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (!N)
     (*current_liboctave_error_handler)
@@ -125,37 +125,37 @@ SparseComplexQR::SparseComplexQR_rep::V 
 }
 
 ColumnVector
 SparseComplexQR::SparseComplexQR_rep::Pinv (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined(CS_VER) && (CS_VER >= 2)
-    ret.xelem(i) = S->pinv[i];
+#if defined (CS_VER) && (CS_VER >= 2)
+    ret.xelem (i) = S->pinv[i];
 #else
-    ret.xelem(i) = S->Pinv[i];
+    ret.xelem (i) = S->Pinv[i];
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 ColumnVector
 SparseComplexQR::SparseComplexQR_rep::P (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined(CS_VER) && (CS_VER >= 2)
-    ret.xelem(S->pinv[i]) = i;
+#if defined (CS_VER) && (CS_VER >= 2)
+    ret.xelem (S->pinv[i]) = i;
 #else
-    ret.xelem(S->Pinv[i]) = i;
+    ret.xelem (S->Pinv[i]) = i;
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 SparseComplexMatrix
@@ -207,17 +207,17 @@ SparseComplexQR::SparseComplexQR_rep::C 
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (S->pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf), b_nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (b_nr, S->Pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type i = 0; i < nm; i++)
@@ -257,17 +257,17 @@ SparseComplexQR::SparseComplexQR_rep::Q 
         bvec[i] = OCTAVE_C99_ZERO;
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
         {
           octave_quit ();
           bvec[j] = OCTAVE_C99_ONE;
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (S->pinv, bvec, reinterpret_cast<cs_complex_t *>(buf), nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nr, S->Pinv, bvec, reinterpret_cast<cs_complex_t *>(buf));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type i = 0; i < nm; i++)
@@ -285,17 +285,17 @@ SparseComplexQR::SparseComplexQR_rep::Q 
     }
   return ret.hermitian ();
 #else
   return ComplexMatrix ();
 #endif
 }
 
 ComplexMatrix
-qrsolve(const SparseComplexMatrix&a, const Matrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const Matrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
@@ -305,125 +305,125 @@ qrsolve(const SparseComplexMatrix&a, con
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
         (x.fortran_vec ());
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
           CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
         (x.fortran_vec ());
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N ()->B [i];
+        B[i] = q.N ()->B[i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
                 (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
           CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 SparseComplexMatrix
-qrsolve(const SparseComplexMatrix&a, const SparseMatrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const SparseMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
@@ -435,47 +435,47 @@ qrsolve(const SparseComplexMatrix&a, con
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -487,78 +487,78 @@ qrsolve(const SparseComplexMatrix&a, con
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
 
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N ()->B [i];
+        B[i] = q.N ()->B[i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
                 (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -570,34 +570,34 @@ qrsolve(const SparseComplexMatrix&a, con
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
 ComplexMatrix
-qrsolve(const SparseComplexMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   const cs_complex_t *bvec =
@@ -609,116 +609,116 @@ qrsolve(const SparseComplexMatrix&a, con
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
         (x.fortran_vec ());
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
           CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
         (x.fortran_vec ());
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N ()->B [i];
+        B[i] = q.N ()->B[i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
 #endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
                 (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
           CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 SparseComplexMatrix
-qrsolve(const SparseComplexMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
@@ -730,47 +730,47 @@ qrsolve(const SparseComplexMatrix&a, con
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -782,77 +782,77 @@ qrsolve(const SparseComplexMatrix&a, con
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N ()->B [i];
+        B[i] = q.N ()->B[i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
                 (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -864,21 +864,21 @@ qrsolve(const SparseComplexMatrix&a, con
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -43,17 +43,17 @@ SparseQR::SparseQR_rep::SparseQR_rep (co
   nrows = A.m;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<double *>(a.data ());
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_DNAME (_sqr) (order, &A, 1);
 #else
   S = CXSPARSE_DNAME (_sqr) (&A, order - 1, 1);
 #endif
 
   N = CXSPARSE_DNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (!N)
@@ -105,37 +105,37 @@ SparseQR::SparseQR_rep::V (void) const
 }
 
 ColumnVector
 SparseQR::SparseQR_rep::Pinv (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined(CS_VER) && (CS_VER >= 2)
-    ret.xelem(i) = S->pinv[i];
+#if defined (CS_VER) && (CS_VER >= 2)
+    ret.xelem (i) = S->pinv[i];
 #else
-    ret.xelem(i) = S->Pinv[i];
+    ret.xelem (i) = S->Pinv[i];
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 ColumnVector
 SparseQR::SparseQR_rep::P (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined(CS_VER) && (CS_VER >= 2)
-    ret.xelem(S->pinv[i]) = i;
+#if defined (CS_VER) && (CS_VER >= 2)
+    ret.xelem (S->pinv[i]) = i;
 #else
-    ret.xelem(S->Pinv[i]) = i;
+    ret.xelem (S->Pinv[i]) = i;
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 SparseMatrix
@@ -190,17 +190,17 @@ SparseQR::SparseQR_rep::C (const Matrix 
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type i = nr; i < S->m2; i++)
             buf[i] = 0.;
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (S->pinv, bvec + idx, buf, b_nr);
 #else
           CXSPARSE_DNAME (_ipvec) (b_nr, S->Pinv, bvec + idx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
@@ -240,17 +240,17 @@ SparseQR::SparseQR_rep::Q (void) const
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
         {
           octave_quit ();
           bvec[j] = 1.0;
           for (octave_idx_type i = nr; i < S->m2; i++)
             buf[i] = 0.;
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (S->pinv, bvec, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, S->Pinv, bvec, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
@@ -266,17 +266,17 @@ SparseQR::SparseQR_rep::Q (void) const
     }
   return ret.transpose ();
 #else
   return Matrix ();
 #endif
 }
 
 Matrix
-qrsolve(const SparseMatrix&a, const Matrix &b, octave_idx_type& info)
+qrsolve (const SparseMatrix&a, const Matrix &b, octave_idx_type& info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   const double *bvec = b.fortran_vec ();
@@ -287,100 +287,100 @@ qrsolve(const SparseMatrix&a, const Matr
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = Matrix (nc, b_nc, 0.0);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return Matrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       double *vec = x.fortran_vec ();
       OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
         return Matrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       double *vec = x.fortran_vec ();
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
   return Matrix ();
 #endif
 }
 
 SparseMatrix
-qrsolve(const SparseMatrix&a, const SparseMatrix &b, octave_idx_type &info)
+qrsolve (const SparseMatrix&a, const SparseMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   SparseMatrix x;
@@ -392,45 +392,45 @@ qrsolve(const SparseMatrix&a, const Spar
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return SparseMatrix ();
       x = SparseMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
@@ -440,61 +440,61 @@ qrsolve(const SparseMatrix&a, const Spar
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
         return SparseMatrix ();
       x = SparseMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
@@ -504,34 +504,34 @@ qrsolve(const SparseMatrix&a, const Spar
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseMatrix ();
 #endif
 }
 
 ComplexMatrix
-qrsolve(const SparseMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
@@ -541,88 +541,88 @@ qrsolve(const SparseMatrix&a, const Comp
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       Complex *vec = x.fortran_vec ();
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       Complex *vec = x.fortran_vec ();
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
@@ -630,56 +630,56 @@ qrsolve(const SparseMatrix&a, const Comp
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
@@ -688,17 +688,17 @@ qrsolve(const SparseMatrix&a, const Comp
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 SparseComplexMatrix
-qrsolve(const SparseMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   SparseComplexMatrix x;
@@ -710,17 +710,17 @@ qrsolve(const SparseMatrix&a, const Spar
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
@@ -728,56 +728,56 @@ qrsolve(const SparseMatrix&a, const Spar
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
@@ -787,32 +787,32 @@ qrsolve(const SparseMatrix&a, const Spar
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
@@ -821,56 +821,56 @@ qrsolve(const SparseMatrix&a, const Spar
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
@@ -880,37 +880,37 @@ qrsolve(const SparseMatrix&a, const Spar
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
 Matrix
-qrsolve(const SparseMatrix &a, const MArray<double> &b,
-        octave_idx_type &info)
+qrsolve (const SparseMatrix &a, const MArray<double> &b,
+         octave_idx_type &info)
 {
   return qrsolve (a, Matrix (b), info);
 }
 
 ComplexMatrix
-qrsolve(const SparseMatrix &a, const MArray<Complex> &b,
-        octave_idx_type &info)
+qrsolve (const SparseMatrix &a, const MArray<Complex> &b,
+         octave_idx_type &info)
 {
   return qrsolve (a, ComplexMatrix (b), info);
 }
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/SparsedbleCHOL.cc
--- a/liboctave/SparsedbleCHOL.cc
+++ b/liboctave/SparsedbleCHOL.cc
@@ -46,22 +46,22 @@ chol2inv (const SparseMatrix& r)
       MatrixType mattype (r);
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseMatrix rinv;
 
       if (typ == MatrixType::Upper)
         {
-          rinv = r.inverse(mattype, info, rcond, true, false);
+          rinv = r.inverse (mattype, info, rcond, true, false);
           retval = rinv.transpose () * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
-          rinv = r.transpose ().inverse(mattype, info, rcond, true, false);
+          rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
           retval = rinv.transpose () * rinv;
         }
       else
         (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -306,17 +306,17 @@ SparseLU::SparseLU (const SparseMatrix& 
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not needed
       do {
         OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
         for (octave_idx_type i = 0; i < nc; i++)
-          qinit [i] = static_cast<octave_idx_type> (Qinit (i));
+          qinit[i] = static_cast<octave_idx_type> (Qinit (i));
 
         status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax,
                                        qinit, &Symbolic, control, info);
       } while (0);
 
       if (status < 0)
         {
           (*current_liboctave_error_handler)
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -50,21 +50,21 @@ SparseBoolMatrix::operator == (const Spa
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    if (cidx(i) != a.cidx(i))
+    if (cidx (i) != a.cidx (i))
         return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
-    if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
+    if (data (i) != a.data (i) || ridx (i) != a.ridx (i))
       return false;
 
   return true;
 }
 
 bool
 SparseBoolMatrix::operator != (const SparseBoolMatrix& a) const
 {
@@ -108,22 +108,22 @@ SparseBoolMatrix::operator ! (void) cons
 
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
         {
-          if (jj < cidx(i+1) && ridx(jj) == j)
+          if (jj < cidx (i+1) && ridx (jj) == j)
             jj++;
           else
             {
-              r.data(ii) = true;
-              r.ridx(ii++) = j;
+              r.data (ii) = true;
+              r.ridx (ii++) = j;
             }
         }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
@@ -145,33 +145,33 @@ SparseBoolMatrix::any (int dim) const
   octave_idx_type nr = rows (), nc = cols (), nz = nnz ();
   if (dim == -1)
     dim = (nr == 1 && nc != 1) ? 1 : 0;
 
   if (dim == 0)
     {
       // Result is a row vector.
       retval = Sparse<bool> (1, nc);
-      retval.xcidx(0) = 0;
+      retval.xcidx (0) = 0;
       for (octave_idx_type i = 0; i < nc; i++)
-        retval.xcidx(i+1) = retval.xcidx(i) + (cidx(i+1) > cidx(i));
-      octave_idx_type new_nz = retval.xcidx(nc);
+        retval.xcidx (i+1) = retval.xcidx (i) + (cidx (i+1) > cidx (i));
+      octave_idx_type new_nz = retval.xcidx (nc);
       retval.change_capacity (new_nz);
       fill_or_memset (new_nz, static_cast<octave_idx_type> (0), retval.ridx ());
       fill_or_memset (new_nz, true, retval.data ());
     }
   else if (dim == 1)
     {
       // Result is a column vector.
       if (nz > nr/4)
         {
           // We can use O(nr) memory.
           Array<bool> tmp (dim_vector (nr, 1), false);
           for (octave_idx_type i = 0; i < nz; i++)
-            tmp.xelem(ridx(i)) = true;
+            tmp.xelem (ridx (i)) = true;
           retval = tmp;
         }
       else
         {
           Array<octave_idx_type> tmp (dim_vector (nz, 1));
           copy_or_memcpy (nz, ridx (), tmp.fortran_vec ());
           retval = Sparse<bool> (Array<bool> (dim_vector (1, 1), true),
                                  idx_vector (tmp),
@@ -190,37 +190,37 @@ SparseBoolMatrix::sum (int dim) const
   octave_idx_type nr = rows (), nc = cols (), nz = nnz ();
   if (dim == -1)
     dim = (nr == 1 && nc != 1) ? 1 : 0;
 
   if (dim == 0)
     {
       // Result is a row vector.
       retval = Sparse<double> (1, nc);
-      for(octave_idx_type i = 0; i < nc; i++)
-        retval.xcidx(i+1) = retval.xcidx(i) + (cidx(i+1) > cidx(i));
-      octave_idx_type new_nz = retval.xcidx(nc);
+      for (octave_idx_type i = 0; i < nc; i++)
+        retval.xcidx (i+1) = retval.xcidx (i) + (cidx (i+1) > cidx (i));
+      octave_idx_type new_nz = retval.xcidx (nc);
       retval.change_capacity (new_nz);
       fill_or_memset (new_nz, static_cast<octave_idx_type> (0), retval.ridx ());
-      for(octave_idx_type i = 0, k = 0; i < nc; i++)
+      for (octave_idx_type i = 0, k = 0; i < nc; i++)
         {
-          octave_idx_type c = cidx(i+1) - cidx(i);
+          octave_idx_type c = cidx (i+1) - cidx (i);
           if (c > 0)
-            retval.xdata(k++) = c;
+            retval.xdata (k++) = c;
         }
     }
   else if (dim == 1)
     {
       // Result is a column vector.
       if (nz > nr)
         {
           // We can use O(nr) memory.
           Array<double> tmp (dim_vector (nr, 1), 0);
           for (octave_idx_type i = 0; i < nz; i++)
-            tmp.xelem(ridx(i)) += 1.0;
+            tmp.xelem (ridx (i)) += 1.0;
           retval = tmp;
         }
       else
         {
           Array<octave_idx_type> tmp (dim_vector (nz, 1));
           copy_or_memcpy (nz, ridx (), tmp.fortran_vec ());
           retval = Sparse<double> (Array<double> (dim_vector (1, 1), 1.0),
                                    idx_vector (tmp),
@@ -241,34 +241,34 @@ SparseBoolMatrix::diag (octave_idx_type 
 boolMatrix
 SparseBoolMatrix::matrix_value (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   boolMatrix retval (nr, nc, false);
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-      retval.elem (ridx(i), j) = data (i);
+    for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+      retval.elem (ridx (i), j) = data (i);
 
   return retval;
 }
 
 std::ostream&
 operator << (std::ostream& os, const SparseBoolMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)
      {
        octave_quit ();
-       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-         os << a.ridx(i) + 1 << " "  << j + 1 << " " << a.data(i) << "\n";
+       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+         os << a.ridx (i) + 1 << " "  << j + 1 << " " << a.data (i) << "\n";
      }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseBoolMatrix& a)
 {
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -530,17 +530,17 @@ command_history::file (void)
   return (instance_ok ())
     ? instance->do_file () : std::string ();
 }
 
 void
 command_history::process_histcontrol (const std::string& control_arg)
 {
   if (instance_ok ())
-    instance->do_process_histcontrol(control_arg);
+    instance->do_process_histcontrol (control_arg);
 }
 
 std::string
 command_history::histcontrol (void)
 {
   return (instance_ok ())
     ? instance->do_histcontrol () : std::string ();
 }
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -357,17 +357,17 @@ DiagMatrix::determinant (void) const
     }
 
   return det;
 }
 
 double
 DiagMatrix::rcond (void) const
 {
-  ColumnVector av  = diag (0).map<double> (fabs);
+  ColumnVector av = diag (0).map<double> (fabs);
   double amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0 : amn / amx;
 }
 
 std::ostream&
 operator << (std::ostream& os, const DiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -758,17 +758,17 @@ Matrix::finverse (MatrixType &mattype, o
       z.resize (dim_vector (lwork, 1));
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond)
-        anorm = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -833,17 +833,17 @@ Matrix::inverse (MatrixType &mattype, oc
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (!mattype.is_hermitian ())
-        ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = Matrix (rows (), columns (), octave_Inf);
     }
 
   return ret;
 }
 
@@ -1493,17 +1493,17 @@ Matrix::rcond (MatrixType &mattype) cons
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-              if(anorm < 0.)
+              if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
@@ -1757,17 +1757,17 @@ Matrix::fsolve (MatrixType &mattype, con
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1833,18 +1833,18 @@ Matrix::fsolve (MatrixType &mattype, con
         {
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
-          if(anorm < 0.)
-            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          if (anorm < 0.)
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           Array<double> z (dim_vector (4 * nc, 1));
           double *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2057,17 +2057,17 @@ Matrix::solve (MatrixType &typ, const Co
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
                double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   Matrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
-  return tmp.column(static_cast<octave_idx_type> (0));
+  return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
@@ -2089,17 +2089,17 @@ Matrix::solve (MatrixType &typ, const Co
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                octave_idx_type& info, double& rcon,
                solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve(typ, b, info, rcon, sing_handler, transt);
+  return tmp.solve (typ, b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -276,17 +276,17 @@ NDArray::fourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
@@ -323,17 +323,17 @@ NDArray::ifourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<double> (npts);
         }
     }
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -172,38 +172,38 @@ SparseMatrix::SparseMatrix (const DiagMa
       if (a(i, i) != 0.0)
         {
           data (j) = a(i, i);
           ridx (j) = i;
           j++;
         }
     }
   for (octave_idx_type i = l; i <= a.cols (); i++)
-    cidx(i) = j;
+    cidx (i) = j;
 }
 
 bool
 SparseMatrix::operator == (const SparseMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz = nnz ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    if (cidx(i) != a.cidx(i))
+    if (cidx (i) != a.cidx (i))
         return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
-    if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
+    if (data (i) != a.data (i) || ridx (i) != a.ridx (i))
       return false;
 
   return true;
 }
 
 bool
 SparseMatrix::operator != (const SparseMatrix& a) const
 {
@@ -215,29 +215,29 @@ SparseMatrix::is_symmetric (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == nc && nr > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              octave_idx_type ri = ridx(i);
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              octave_idx_type ri = ridx (i);
 
               if (ri != j)
                 {
                   bool found = false;
 
-                  for (octave_idx_type k = cidx(ri); k < cidx(ri+1); k++)
+                  for (octave_idx_type k = cidx (ri); k < cidx (ri+1); k++)
                     {
-                      if (ridx(k) == j)
+                      if (ridx (k) == j)
                         {
-                          if (data(i) == data(k))
+                          if (data (i) == data (k))
                             found = true;
                           break;
                         }
                     }
 
                   if (! found)
                     return false;
                 }
@@ -289,28 +289,28 @@ SparseMatrix::max (Array<octave_idx_type
   if (dim == 0)
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           double tmp_max = octave_NaN;
           octave_idx_type idx_j = 0;
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              if (ridx(i) != idx_j)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
 
           if (idx_j != nr)
             tmp_max = 0.;
 
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               double tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
               else if (xisnan (tmp_max) || tmp > tmp_max)
                 {
                   idx_j = ridx (i);
@@ -339,55 +339,55 @@ SparseMatrix::max (Array<octave_idx_type
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
       idx_arg.resize (dim_vector  (nr, 1), 0);
 
-      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-        idx_arg.elem(ridx(i)) = -1;
+      for (octave_idx_type i = cidx (0); i < cidx (1); i++)
+        idx_arg.elem (ridx (i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            if (idx_arg.elem(i) != -1)
+            if (idx_arg.elem (i) != -1)
               continue;
             bool found = false;
-            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-              if (ridx(k) == i)
+            for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
+              if (ridx (k) == i)
                 {
                   found = true;
                   break;
                 }
 
             if (!found)
-              idx_arg.elem(i) = j;
+              idx_arg.elem (i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               double tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
               else if (ix == -1 || tmp > elem (ir, ix))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+        if (idx_arg.elem (j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
           nel++;
 
       result = SparseMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -438,28 +438,28 @@ SparseMatrix::min (Array<octave_idx_type
   if (dim == 0)
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           double tmp_min = octave_NaN;
           octave_idx_type idx_j = 0;
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              if (ridx(i) != idx_j)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
 
           if (idx_j != nr)
             tmp_min = 0.;
 
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               double tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
               else if (xisnan (tmp_min) || tmp < tmp_min)
                 {
                   idx_j = ridx (i);
@@ -488,55 +488,55 @@ SparseMatrix::min (Array<octave_idx_type
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, 1), 0);
 
-      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-        idx_arg.elem(ridx(i)) = -1;
+      for (octave_idx_type i = cidx (0); i < cidx (1); i++)
+        idx_arg.elem (ridx (i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            if (idx_arg.elem(i) != -1)
+            if (idx_arg.elem (i) != -1)
               continue;
             bool found = false;
-            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-              if (ridx(k) == i)
+            for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
+              if (ridx (k) == i)
                 {
                   found = true;
                   break;
                 }
 
             if (!found)
-              idx_arg.elem(i) = j;
+              idx_arg.elem (i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               double tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
               else if (ix == -1 || tmp < elem (ir, ix))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+        if (idx_arg.elem (j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
           nel++;
 
       result = SparseMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -615,42 +615,42 @@ SparseMatrix
 real (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
-    r.cidx(i) = a.cidx(i);
+    r.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data(i) = std::real (a.data(i));
-      r.ridx(i) = a.ridx(i);
+      r.data (i) = std::real (a.data (i));
+      r.ridx (i) = a.ridx (i);
     }
 
   return r;
 }
 
 SparseMatrix
 imag (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
-    r.cidx(i) = a.cidx(i);
+    r.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data(i) = std::imag (a.data(i));
-      r.ridx(i) = a.ridx(i);
+      r.data (i) = std::imag (a.data (i));
+      r.ridx (i) = a.ridx (i);
     }
 
   return r;
 }
 
 SparseMatrix
 atan2 (const double& x, const SparseMatrix& y)
 {
@@ -662,38 +662,38 @@ atan2 (const double& x, const SparseMatr
   else
     {
       // Its going to be basically full, so this is probably the
       // best way to handle it.
       Matrix tmp (nr, nc, atan2 (x, 0.));
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
-          tmp.elem (y.ridx(i), j) = atan2 (x, y.data(i));
+          tmp.elem (y.ridx (i), j) = atan2 (x, y.data (i));
 
       return SparseMatrix (tmp);
     }
 }
 
 SparseMatrix
 atan2 (const SparseMatrix& x, const double& y)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
   octave_idx_type nz = x.nnz ();
 
   SparseMatrix retval (nr, nc, nz);
 
   octave_idx_type ii = 0;
-  retval.xcidx(0) = 0;
+  retval.xcidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
-      for (octave_idx_type j = x.cidx(i); j < x.cidx(i+1); j++)
+      for (octave_idx_type j = x.cidx (i); j < x.cidx (i+1); j++)
         {
-          double tmp = atan2 (x.data(j), y);
+          double tmp = atan2 (x.data (j), y);
           if (tmp != 0.)
             {
               retval.xdata (ii) = tmp;
               retval.xridx (ii++) = x.ridx (j);
             }
         }
       retval.xcidx (i+1) = ii;
     }
@@ -732,58 +732,58 @@ atan2 (const SparseMatrix& x, const Spar
       else
         {
           r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < x_nc ; i++)
             {
-              octave_idx_type  ja = x.cidx(i);
-              octave_idx_type  ja_max = x.cidx(i+1);
+              octave_idx_type  ja = x.cidx (i);
+              octave_idx_type  ja_max = x.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = y.cidx(i);
-              octave_idx_type  jb_max = y.cidx(i+1);
+              octave_idx_type  jb = y.cidx (i);
+              octave_idx_type  jb_max = y.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (x.ridx(ja) < y.ridx(jb))))
+                      (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
                     {
-                      r.ridx(jx) = x.ridx(ja);
-                      r.data(jx) = atan2 (x.data(ja), 0.);
+                      r.ridx (jx) = x.ridx (ja);
+                      r.data (jx) = atan2 (x.data (ja), 0.);
                       jx++;
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (y.ridx(jb) < x.ridx(ja)) ) )
+                           (jb_lt_max && (y.ridx (jb) < x.ridx (ja)) ) )
                     {
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      double tmp = atan2 (x.data(ja), y.data(jb));
+                      double tmp = atan2 (x.data (ja), y.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = x.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = x.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
@@ -844,17 +844,17 @@ SparseMatrix::dinverse (MatrixType &matt
           // Force make_unique to be called
           double *v = retval.data ();
 
           if (calccond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
-                  double tmp = fabs(v[i]);
+                  double tmp = fabs (v[i]);
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
 
@@ -894,18 +894,18 @@ SparseMatrix::tinverse (MatrixType &matt
           double ainvnorm = 0.;
 
           if (calccond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Upper || typ == MatrixType::Lower)
             {
               octave_idx_type nz = nnz ();
@@ -920,101 +920,101 @@ SparseMatrix::tinverse (MatrixType &matt
                   octave_idx_type cx_colstart = cx;
 
                   if (cx == nz2)
                     {
                       nz2 *= 2;
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx(i) = cx;
-                  retval.xridx(cx) = i;
-                  retval.xdata(cx) = 1.0;
+                  retval.xcidx (i) = cx;
+                  retval.xridx (cx) = i;
+                  retval.xdata (cx) = 1.0;
                   cx++;
 
                   // iterate accross columns of input matrix
                   for (octave_idx_type j = i+1; j < nr; j++)
                     {
                       double v = 0.;
                       // iterate to calculate sum
-                      octave_idx_type colXp = retval.xcidx(i);
-                      octave_idx_type colUp = cidx(j);
+                      octave_idx_type colXp = retval.xcidx (i);
+                      octave_idx_type colUp = cidx (j);
                       octave_idx_type rpX, rpU;
 
-                      if (cidx(j) == cidx(j+1))
+                      if (cidx (j) == cidx (j+1))
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       do
                         {
                           octave_quit ();
-                          rpX = retval.xridx(colXp);
-                          rpU = ridx(colUp);
+                          rpX = retval.xridx (colXp);
+                          rpU = ridx (colUp);
 
                           if (rpX < rpU)
                             colXp++;
                           else if (rpX > rpU)
                             colUp++;
                           else
                             {
-                              v -= retval.xdata(colXp) * data(colUp);
+                              v -= retval.xdata (colXp) * data (colUp);
                               colXp++;
                               colUp++;
                             }
                         } while ((rpX<j) && (rpU<j) &&
                                  (colXp<cx) && (colUp<nz));
 
                       // get A(m,m)
                       if (typ == MatrixType::Upper)
-                        colUp = cidx(j+1) - 1;
+                        colUp = cidx (j+1) - 1;
                       else
-                        colUp = cidx(j);
-                      double pivot = data(colUp);
-                      if (pivot == 0. || ridx(colUp) != j)
+                        colUp = cidx (j);
+                      double pivot = data (colUp);
+                      if (pivot == 0. || ridx (colUp) != j)
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       if (v != 0.)
                         {
                           if (cx == nz2)
                             {
                               nz2 *= 2;
                               retval.change_capacity (nz2);
                             }
 
-                          retval.xridx(cx) = j;
-                          retval.xdata(cx) = v / pivot;
+                          retval.xridx (cx) = j;
+                          retval.xdata (cx) = v / pivot;
                           cx++;
                         }
                     }
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Upper)
-                    colUp = cidx(i+1) - 1;
+                    colUp = cidx (i+1) - 1;
                   else
-                    colUp = cidx(i);
-                  double pivot = data(colUp);
-                  if (pivot == 0. || ridx(colUp) != i)
+                    colUp = cidx (i);
+                  double pivot = data (colUp);
+                  if (pivot == 0. || ridx (colUp) != i)
                     {
                       (*current_liboctave_error_handler) ("division by zero");
                       goto inverse_singular;
                     }
 
                   if (pivot != 1.0)
                     for (octave_idx_type j = cx_colstart; j < cx; j++)
-                      retval.xdata(j) /= pivot;
-                }
-              retval.xcidx(nr) = cx;
+                      retval.xdata (j) /= pivot;
+                }
+              retval.xcidx (nr) = cx;
               retval.maybe_compress ();
             }
           else
             {
               octave_idx_type nz = nnz ();
               octave_idx_type cx = 0;
               octave_idx_type nz2 = nz;
               retval = SparseMatrix (nr, nc, nz2);
@@ -1048,47 +1048,47 @@ SparseMatrix::tinverse (MatrixType &matt
                   work[iidx] = 1.0;
 
                   // iterate accross columns of input matrix
                   for (octave_idx_type j = iidx+1; j < nr; j++)
                     {
                       double v = 0.;
                       octave_idx_type jidx = perm[j];
                       // iterate to calculate sum
-                      for (octave_idx_type k = cidx(jidx);
-                           k < cidx(jidx+1); k++)
+                      for (octave_idx_type k = cidx (jidx);
+                           k < cidx (jidx+1); k++)
                         {
                           octave_quit ();
-                          v -= work[ridx(k)] * data(k);
+                          v -= work[ridx (k)] * data (k);
                         }
 
                       // get A(m,m)
                       double pivot;
                       if (typ == MatrixType::Permuted_Upper)
-                        pivot = data(cidx(jidx+1) - 1);
+                        pivot = data (cidx (jidx+1) - 1);
                       else
-                        pivot = data(cidx(jidx));
+                        pivot = data (cidx (jidx));
                       if (pivot == 0.)
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       work[j] = v / pivot;
                     }
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Permuted_Upper)
-                    colUp = cidx(perm[iidx]+1) - 1;
+                    colUp = cidx (perm[iidx]+1) - 1;
                   else
-                    colUp = cidx(perm[iidx]);
-
-                  double pivot = data(colUp);
+                    colUp = cidx (perm[iidx]);
+
+                  double pivot = data (colUp);
                   if (pivot == 0.)
                     {
                       (*current_liboctave_error_handler)
                         ("division by zero");
                       goto inverse_singular;
                     }
 
                   octave_idx_type new_cx = cx;
@@ -1101,38 +1101,38 @@ SparseMatrix::tinverse (MatrixType &matt
                       }
 
                   if (cx < new_cx)
                     {
                       nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx(i) = cx;
+                  retval.xcidx (i) = cx;
                   for (octave_idx_type j = iidx; j < nr; j++)
                     if (work[j] != 0.)
                       {
-                        retval.xridx(cx) = j;
-                        retval.xdata(cx++) = work[j];
+                        retval.xridx (cx) = j;
+                        retval.xdata (cx++) = work[j];
                       }
                 }
 
-              retval.xcidx(nr) = cx;
+              retval.xcidx (nr) = cx;
               retval.maybe_compress ();
             }
 
           if (calccond)
             {
               // Calculate the 1-norm of inverse matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = retval.cidx(j);
-                       i < retval.cidx(j+1); i++)
-                    atmp += fabs(retval.data(i));
+                  for (octave_idx_type i = retval.cidx (j);
+                       i < retval.cidx (j+1); i++)
+                    atmp += fabs (retval.data (i));
                   if (atmp > ainvnorm)
                     ainvnorm = atmp;
                 }
 
               rcond = 1. / ainvnorm / anorm;
             }
         }
       else
@@ -1170,17 +1170,17 @@ SparseMatrix::inverse (MatrixType &matty
         {
           MatrixType tmp_typ (MatrixType::Upper);
           SparseCHOL fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
-              SparseMatrix InvL = fact.L ().transpose ().tinverse(tmp_typ,
+              SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
                                            info, rcond2, true, false);
               ret = Q * InvL.transpose () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
@@ -1193,19 +1193,19 @@ SparseMatrix::inverse (MatrixType &matty
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseLU fact (*this, Qinit, Matrix (), false, false);
           rcond = fact.rcond ();
           double rcond2;
-          SparseMatrix InvL = fact.L ().transpose ().tinverse(tmp_typ,
+          SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
                                            info, rcond2, true, false);
-          SparseMatrix InvU = fact.U ().tinverse(tmp_typ, info, rcond2,
+          SparseMatrix InvU = fact.U ().tinverse (tmp_typ, info, rcond2,
                                            true, false).transpose ();
           ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
@@ -1369,25 +1369,25 @@ SparseMatrix::dsolve (MatrixType &mattyp
           retval.resize (nc, b.cols (), 0.);
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                  retval(k,j) = b(ridx(i),j) / data (i);
+                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                  retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = fabs(data(i));
+                  double tmp = fabs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1425,59 +1425,59 @@ SparseMatrix::dsolve (MatrixType &mattyp
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseMatrix (nc, b_nc, b_nz);
 
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b_nc; j++)
               {
-                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                   {
-                    if (b.ridx(i) >= nm)
+                    if (b.ridx (i) >= nm)
                       break;
-                    retval.xridx (ii) = b.ridx(i);
-                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                    retval.xridx (ii) = b.ridx (i);
+                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
                   }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
           else
             for (octave_idx_type j = 0; j < b_nc; j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
-                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-                        if (ridx(i) == b.ridx(k))
+                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                        if (ridx (i) == b.ridx (k))
                           {
                             found = true;
                             break;
                           }
                       if (found)
                         {
                           retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data(k) / data (i);
+                          retval.xdata (ii++) = b.data (k) / data (i);
                         }
                     }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = fabs(data(i));
+                  double tmp = fabs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1519,25 +1519,25 @@ SparseMatrix::dsolve (MatrixType &mattyp
           retval.resize (nc, b.cols (), 0);
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                  retval(k,j) = b(ridx(i),j) / data (i);
+                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                  retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = fabs(data(i));
+                  double tmp = fabs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1575,59 +1575,59 @@ SparseMatrix::dsolve (MatrixType &mattyp
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
-                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                   {
-                    if (b.ridx(i) >= nm)
+                    if (b.ridx (i) >= nm)
                       break;
-                    retval.xridx (ii) = b.ridx(i);
-                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                    retval.xridx (ii) = b.ridx (i);
+                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
                   }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
-                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-                        if (ridx(i) == b.ridx(k))
+                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                        if (ridx (i) == b.ridx (k))
                           {
                             found = true;
                             break;
                           }
                       if (found)
                         {
                           retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data(k) / data (i);
+                          retval.xdata (ii++) = b.data (k) / data (i);
                         }
                     }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = fabs(data(i));
+                  double tmp = fabs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1673,18 +1673,18 @@ SparseMatrix::utsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Upper)
             {
               retval.resize (nc, b_nc);
@@ -1699,30 +1699,30 @@ SparseMatrix::utsolve (MatrixType &matty
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(kidx+1)-1);
+                          double tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (perm[i], j) = work[i];
                 }
 
@@ -1737,30 +1737,30 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              double tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -1775,29 +1775,29 @@ SparseMatrix::utsolve (MatrixType &matty
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(k+1)-1);
+                          double tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -1810,29 +1810,29 @@ SparseMatrix::utsolve (MatrixType &matty
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k+1)-1);
+                              double tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -1907,66 +1907,66 @@ SparseMatrix::utsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               octave_idx_type *perm = mattype.triangular_perm ();
               OCTAVE_LOCAL_BUFFER (double, work, nm);
 
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 rperm[perm[i]] = i;
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(kidx+1)-1);
+                          double tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -1979,20 +1979,20 @@ SparseMatrix::utsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[rperm[i]] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[rperm[i]];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[rperm[i]];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2003,66 +2003,66 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              double tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (double, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(k+1)-1);
+                          double tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2075,20 +2075,20 @@ SparseMatrix::utsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2097,30 +2097,30 @@ SparseMatrix::utsolve (MatrixType &matty
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k+1)-1);
+                              double tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2195,18 +2195,18 @@ SparseMatrix::utsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Upper)
             {
               retval.resize (nc, b_nc);
@@ -2221,30 +2221,30 @@ SparseMatrix::utsolve (MatrixType &matty
                     cwork[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (perm[i], j) = cwork[i];
                 }
 
@@ -2260,30 +2260,30 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              double tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2298,29 +2298,29 @@ SparseMatrix::utsolve (MatrixType &matty
                     cwork[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     cwork[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(k+1)-1);
+                          Complex tmp = cwork[k] / data (cidx (k+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp  * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp  * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = cwork[i];
                 }
 
@@ -2334,30 +2334,30 @@ SparseMatrix::utsolve (MatrixType &matty
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k+1)-1);
+                              double tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2432,66 +2432,66 @@ SparseMatrix::utsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               octave_idx_type *perm = mattype.triangular_perm ();
               OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 rperm[perm[i]] = i;
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    cwork[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    cwork[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2504,20 +2504,20 @@ SparseMatrix::utsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[rperm[i]] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = cwork[rperm[i]];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = cwork[rperm[i]];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
@@ -2529,66 +2529,66 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              double tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    cwork[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    cwork[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(k+1)-1);
+                          Complex tmp = cwork[k] / data (cidx (k+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2601,20 +2601,20 @@ SparseMatrix::utsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = cwork[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = cwork[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
@@ -2624,30 +2624,30 @@ SparseMatrix::utsolve (MatrixType &matty
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k+1)-1);
+                              double tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2723,18 +2723,18 @@ SparseMatrix::ltsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Lower)
             {
               retval.resize (nc, b_nc);
@@ -2751,38 +2751,38 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data(mini) == 0)
+                          if (minr != k || data (mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(mini);
+                          double tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(i, j) = work[i];
                 }
 
@@ -2798,42 +2798,42 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              double tmp = work[k] / data(mini);
+                              double tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2847,30 +2847,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(k));
+                          double tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1;
-                               i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1;
+                               i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -2884,30 +2884,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k));
+                              double tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2982,71 +2982,71 @@ SparseMatrix::ltsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               OCTAVE_LOCAL_BUFFER (double, work, nm);
               octave_idx_type *perm = mattype.triangular_perm ();
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[perm[b.ridx(i)]] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[perm[b.ridx (i)]] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data(mini) == 0)
+                          if (minr != k || data (mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(mini);
+                          double tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3059,20 +3059,20 @@ SparseMatrix::ltsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3084,78 +3084,78 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              double tmp = work[k] / data(mini);
+                              double tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nr; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (double, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(k));
+                          double tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3168,20 +3168,20 @@ SparseMatrix::ltsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3191,30 +3191,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k));
+                              double tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3290,18 +3290,18 @@ SparseMatrix::ltsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Lower)
             {
               retval.resize (nc, b_nc);
@@ -3317,38 +3317,38 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data(mini) == 0)
+                          if (minr != k || data (mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(mini);
+                          Complex tmp = cwork[k] / data (mini);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(i, j) = cwork[i];
                 }
 
@@ -3365,42 +3365,42 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              double tmp = work[k] / data(mini);
+                              double tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3415,29 +3415,29 @@ SparseMatrix::ltsolve (MatrixType &matty
                     cwork[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     cwork[i] = 0.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(k));
+                          Complex tmp = cwork[k] / data (cidx (k));
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = cwork[i];
                 }
 
@@ -3452,30 +3452,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k));
+                              double tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3550,71 +3550,71 @@ SparseMatrix::ltsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
               octave_idx_type *perm = mattype.triangular_perm ();
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    cwork[perm[b.ridx(i)]] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    cwork[perm[b.ridx (i)]] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data(mini) == 0)
+                          if (minr != k || data (mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(mini);
+                          Complex tmp = cwork[k] / data (mini);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3627,20 +3627,20 @@ SparseMatrix::ltsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = cwork[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = cwork[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
@@ -3653,78 +3653,78 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              double tmp = work[k] / data(mini);
+                              double tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    cwork[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    cwork[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(k));
+                          Complex tmp = cwork[k] / data (cidx (k));
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3737,20 +3737,20 @@ SparseMatrix::ltsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = cwork[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = cwork[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
@@ -3761,30 +3761,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k));
+                              double tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3859,38 +3859,38 @@ SparseMatrix::trisolve (MatrixType &matt
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = data(ii);
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result,
@@ -3913,41 +3913,41 @@ SparseMatrix::trisolve (MatrixType &matt
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result,
@@ -4016,41 +4016,41 @@ SparseMatrix::trisolve (MatrixType &matt
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
@@ -4068,27 +4068,27 @@ SparseMatrix::trisolve (MatrixType &matt
             }
           else
             {
               rcond = 1.0;
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseMatrix (nr, b_nc, x_nz);
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               volatile octave_idx_type ii = 0;
 
               OCTAVE_LOCAL_BUFFER (double, work, nr);
 
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              work, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   // Count non-zeros in work vector and adjust
@@ -4104,20 +4104,20 @@ SparseMatrix::trisolve (MatrixType &matt
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4157,38 +4157,38 @@ SparseMatrix::trisolve (MatrixType &matt
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = data(ii);
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
@@ -4212,41 +4212,41 @@ SparseMatrix::trisolve (MatrixType &matt
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
@@ -4315,41 +4315,41 @@ SparseMatrix::trisolve (MatrixType &matt
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
@@ -4374,17 +4374,17 @@ SparseMatrix::trisolve (MatrixType &matt
               OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b (i,j);
                       Bx[i] = std::real (c);
                       Bz[i] = std::imag (c);
@@ -4433,22 +4433,22 @@ SparseMatrix::trisolve (MatrixType &matt
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (Bx[i] != 0. || Bz[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) =
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) =
                           Complex (Bx[i], Bz[i]);
                       }
 
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4491,27 +4491,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4598,28 +4598,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4741,27 +4741,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4815,17 +4815,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 
                   // Take a first guess that the number of non-zero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseMatrix (b_nr, b_nc, x_nz);
 
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b.elem (i, j);
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
@@ -4849,21 +4849,21 @@ SparseMatrix::bsolve (MatrixType &mattyp
                                 {
                                   // Resize the sparse matrix
                                   octave_idx_type sz = x_nz *
                                     (b_nc - j) / b_nc;
                                   sz = (sz > 10 ? sz : 10) + x_nz;
                                   retval.change_capacity (sz);
                                   x_nz = sz;
                                 }
-                              retval.xdata(ii) = tmp;
-                              retval.xridx(ii++) = i;
+                              retval.xdata (ii) = tmp;
+                              retval.xridx (ii++) = i;
                             }
                         }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
@@ -4881,28 +4881,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4964,28 +4964,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseMatrix (nr, b_nc, x_nz);
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (double, work, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
-                      for (octave_idx_type i = b.cidx(j);
-                           i < b.cidx(j+1); i++)
-                        work[b.ridx(i)] = b.data(i);
+                      for (octave_idx_type i = b.cidx (j);
+                           i < b.cidx (j+1); i++)
+                        work[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, work, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       // Count non-zeros in work vector and adjust
@@ -5001,20 +5001,20 @@ SparseMatrix::bsolve (MatrixType &mattyp
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) = work[i];
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) = work[i];
                           }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
@@ -5059,27 +5059,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5197,28 +5197,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5358,27 +5358,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5436,17 +5436,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
                   // Take a first guess that the number of non-zero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
                           Complex c = b (i,j);
                           Bx[i] = std::real (c);
                           Bz[i] = std::imag (c);
@@ -5494,22 +5494,22 @@ SparseMatrix::bsolve (MatrixType &mattyp
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) =
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) =
                               Complex (Bx[i], Bz[i]);
                           }
 
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
@@ -5527,28 +5527,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5610,35 +5610,35 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (double, Bx, nr);
                   OCTAVE_LOCAL_BUFFER (double, Bz, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         {
                           Bx[i] = 0.;
                           Bz[i] = 0.;
                         }
-                      for (octave_idx_type i = b.cidx(j);
-                           i < b.cidx(j+1); i++)
+                      for (octave_idx_type i = b.cidx (j);
+                           i < b.cidx (j+1); i++)
                         {
-                          Complex c = b.data(i);
-                          Bx[b.ridx(i)] = std::real (c);
-                          Bz[b.ridx(i)] = std::imag (c);
+                          Complex c = b.data (i);
+                          Bx[b.ridx (i)] = std::real (c);
+                          Bz[b.ridx (i)] = std::imag (c);
                         }
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -5661,21 +5661,21 @@ SparseMatrix::bsolve (MatrixType &mattyp
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) =
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) =
                               Complex (Bx[i], Bz[i]);
                           }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
@@ -5930,17 +5930,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval.resize (b.rows (), b.cols ());
               for (octave_idx_type j = 0; j < b.cols (); j++)
                 {
                   octave_idx_type jr = j * b.rows ();
                   for (octave_idx_type i = 0; i < b.rows (); i++)
-                    retval.xelem(i,j) = static_cast<double *>(X->x)[jr + i];
+                    retval.xelem (i,j) = static_cast<double *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6155,22 +6155,22 @@ SparseMatrix::fsolve (MatrixType &mattyp
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseMatrix (static_cast<octave_idx_type>(X->nrow),
                                      static_cast<octave_idx_type>(X->ncol),
                                      static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
-                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+                retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
-                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-                  retval.xdata(j) = static_cast<double *>(X->x)[j];
+                  retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata (j) = static_cast<double *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6207,17 +6207,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseMatrix (b_nr, b_nc, x_nz);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
                                              Ai, Ax, Xx, Bx, Numeric, control,
@@ -6242,21 +6242,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                           if (ii == x_nz)
                             {
                               // Resize the sparse matrix
                               octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
                               sz = (sz > 10 ? sz : 10) + x_nz;
                               retval.change_capacity (sz);
                               x_nz = sz;
                             }
-                          retval.xdata(ii) = tmp;
-                          retval.xridx(ii++) = i;
+                          retval.xdata (ii) = tmp;
+                          retval.xridx (ii++) = i;
                         }
                     }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
@@ -6407,17 +6407,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval.resize (b.rows (), b.cols ());
               for (octave_idx_type j = 0; j < b.cols (); j++)
                 {
                   octave_idx_type jr = j * b.rows ();
                   for (octave_idx_type i = 0; i < b.rows (); i++)
-                    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
+                    retval.xelem (i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6652,22 +6652,22 @@ SparseMatrix::fsolve (MatrixType &mattyp
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
                 (static_cast<octave_idx_type>(X->nrow),
                  static_cast<octave_idx_type>(X->ncol),
                  static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
-                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+                retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
-                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-                  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
+                  retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6707,17 +6707,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b (i,j);
                       Bx[i] = std::real (c);
                       Bz[i] = std::imag (c);
                     }
@@ -6749,21 +6749,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                           if (ii == x_nz)
                             {
                               // Resize the sparse matrix
                               octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
                               sz = (sz > 10 ? sz : 10) + x_nz;
                               retval.change_capacity (sz);
                               x_nz = sz;
                             }
-                          retval.xdata(ii) = tmp;
-                          retval.xridx(ii++) = i;
+                          retval.xdata (ii) = tmp;
+                          retval.xridx (ii++) = i;
                         }
                     }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
@@ -6965,17 +6965,17 @@ SparseMatrix::solve (MatrixType &mattype
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseMatrix,
         ComplexMatrix> (*this, b, err);
 #endif
@@ -7033,17 +7033,17 @@ SparseMatrix::solve (MatrixType &mattype
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseMatrix,
         SparseComplexMatrix> (*this, b, err);
 #endif
@@ -7446,22 +7446,22 @@ SparseMatrix::operator ! (void) const
 
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
         {
-          if (jj < cidx(i+1) && ridx(jj) == j)
+          if (jj < cidx (i+1) && ridx (jj) == j)
             jj++;
           else
             {
-              r.data(ii) = true;
-              r.ridx(ii++) = j;
+              r.data (ii) = true;
+              r.ridx (ii++) = j;
             }
         }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
@@ -7495,32 +7495,32 @@ SparseMatrix::cumsum (int dim) const
 SparseMatrix
 SparseMatrix::prod (int dim) const
 {
   if ((rows () == 1 && dim == -1) || dim == 1)
     return transpose (). prod (0). transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseMatrix, double, *=,
-                           (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
+                           (cidx (j+1) - cidx (j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseMatrix
 SparseMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseMatrix, double, +=, 0.0, 0.0);
 }
 
 SparseMatrix
 SparseMatrix::sumsq (int dim) const
 {
 #define ROW_EXPR \
   double d = data (i); \
-  tmp[ridx(i)] += d * d
+  tmp[ridx (i)] += d * d
 
 #define COL_EXPR \
   double d = data (i); \
   tmp[j] += d * d
 
   SPARSE_BASE_REDUCTION_OP (SparseMatrix, double, ROW_EXPR, COL_EXPR,
                             0.0, 0.0);
 
@@ -7531,17 +7531,17 @@ SparseMatrix::sumsq (int dim) const
 SparseMatrix
 SparseMatrix::abs (void) const
 {
   octave_idx_type nz = nnz ();
 
   SparseMatrix retval (*this);
 
   for (octave_idx_type i = 0; i < nz; i++)
-    retval.data(i) = fabs(retval.data(i));
+    retval.data (i) = fabs (retval.data (i));
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::diag (octave_idx_type k) const
 {
   return MSparse<double>::diag (k);
@@ -7558,20 +7558,20 @@ operator << (std::ostream& os, const Spa
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)
      {
        octave_quit ();
-       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
          {
-           os << a.ridx(i) + 1 << " "  << j + 1 << " ";
-           octave_write_double (os, a.data(i));
+           os << a.ridx (i) + 1 << " "  << j + 1 << " ";
+           octave_write_double (os, a.data (i));
            os << "\n";
          }
      }
 
   return os;
 }
 
 std::istream&
@@ -7707,52 +7707,52 @@ min (double d, const SparseMatrix& m)
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
   // Count the number of non-zero elements
   if (d < 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           {
             double tmp = xmin (d, m.data (i));
             if (tmp != 0.)
               {
-                octave_idx_type idx = m.ridx(i) + j * nr;
-                result.xdata(idx) = tmp;
-                result.xridx(idx) = m.ridx(i);
+                octave_idx_type idx = m.ridx (i) + j * nr;
+                result.xdata (idx) = tmp;
+                result.xridx (idx) = m.ridx (i);
               }
           }
     }
   else
     {
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           if (xmin (d, m.data (i)) != 0.)
             nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
       octave_idx_type ii = 0;
-      result.xcidx(0) = 0;
+      result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
             {
               double tmp = xmin (d, m.data (i));
 
               if (tmp != 0.)
                 {
-                  result.xdata(ii) = tmp;
-                  result.xridx(ii++) = m.ridx(i);
-                }
-            }
-          result.xcidx(j+1) = ii;
+                  result.xdata (ii) = tmp;
+                  result.xridx (ii++) = m.ridx (i);
+                }
+            }
+          result.xcidx (j+1) = ii;
         }
     }
 
   return result;
 }
 
 SparseMatrix
 min (const SparseMatrix& m, double d)
@@ -7778,69 +7778,69 @@ min (const SparseMatrix& a, const Sparse
       else
         {
           r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
-              octave_idx_type  ja = a.cidx(i);
-              octave_idx_type  ja_max = a.cidx(i+1);
+              octave_idx_type  ja = a.cidx (i);
+              octave_idx_type  ja_max = a.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = b.cidx(i);
-              octave_idx_type  jb_max = b.cidx(i+1);
+              octave_idx_type  jb = b.cidx (i);
+              octave_idx_type  jb_max = b.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                     {
-                      double tmp = xmin (a.data(ja), 0.);
+                      double tmp = xmin (a.data (ja), 0.);
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = a.ridx(ja);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                           (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                     {
-                      double tmp = xmin (0., b.data(jb));
+                      double tmp = xmin (0., b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = b.ridx(jb);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = b.ridx (jb);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      double tmp = xmin (a.data(ja), b.data(jb));
+                      double tmp = xmin (a.data (ja), b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
@@ -7857,52 +7857,52 @@ max (double d, const SparseMatrix& m)
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
   // Count the number of non-zero elements
   if (d > 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           {
             double tmp = xmax (d, m.data (i));
 
             if (tmp != 0.)
               {
-                octave_idx_type idx = m.ridx(i) + j * nr;
-                result.xdata(idx) = tmp;
-                result.xridx(idx) = m.ridx(i);
+                octave_idx_type idx = m.ridx (i) + j * nr;
+                result.xdata (idx) = tmp;
+                result.xridx (idx) = m.ridx (i);
               }
           }
     }
   else
     {
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           if (xmax (d, m.data (i)) != 0.)
             nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
       octave_idx_type ii = 0;
-      result.xcidx(0) = 0;
+      result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
             {
               double tmp = xmax (d, m.data (i));
               if (tmp != 0.)
                 {
-                  result.xdata(ii) = tmp;
-                  result.xridx(ii++) = m.ridx(i);
-                }
-            }
-          result.xcidx(j+1) = ii;
+                  result.xdata (ii) = tmp;
+                  result.xridx (ii++) = m.ridx (i);
+                }
+            }
+          result.xcidx (j+1) = ii;
         }
     }
 
   return result;
 }
 
 SparseMatrix
 max (const SparseMatrix& m, double d)
@@ -7928,69 +7928,69 @@ max (const SparseMatrix& a, const Sparse
       else
         {
           r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
-              octave_idx_type  ja = a.cidx(i);
-              octave_idx_type  ja_max = a.cidx(i+1);
+              octave_idx_type  ja = a.cidx (i);
+              octave_idx_type  ja_max = a.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = b.cidx(i);
-              octave_idx_type  jb_max = b.cidx(i+1);
+              octave_idx_type  jb = b.cidx (i);
+              octave_idx_type  jb_max = b.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                     {
-                      double tmp = xmax (a.data(ja), 0.);
+                      double tmp = xmax (a.data (ja), 0.);
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = a.ridx(ja);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                           (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                     {
-                      double tmp = xmax (0., b.data(jb));
+                      double tmp = xmax (0., b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = b.ridx(jb);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = b.ridx (jb);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      double tmp = xmax (a.data(ja), b.data(jb));
+                      double tmp = xmax (a.data (ja), b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -491,17 +491,17 @@ oct_data_conv::data_type_as_string (oct_
             swap_bytes< size > (ptr, len); \
           for (octave_idx_type i = 0; i < len; i++) \
             data[i] = ptr[i]; \
         } \
     } \
   while (0)
 
 // Have to use copy here to avoid writing over data accessed via
-// Matrix::data().
+// Matrix::data ().
 
 #define LS_DO_WRITE(TYPE, data, size, len, stream) \
   do \
     { \
       if (len > 0) \
         { \
           char tmp_type = type; \
           stream.write (&tmp_type, 1); \
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -461,33 +461,33 @@ QR::update (const ColumnVector& u, const
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init(q*r + Matrix (u) * Matrix (v).transpose (), get_type ());
+      init (q*r + Matrix (u) * Matrix (v).transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 QR::update (const Matrix& u, const Matrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
-      init(q*r + u * v.transpose (), get_type ());
+      init (q*r + u * v.transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 static
 Matrix insert_col (const Matrix& a, octave_idx_type i,
                         const ColumnVector& x)
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -130,17 +130,17 @@ SVD::init (const Matrix& a, SVD::type sv
   type_computed = svd_type;
 
   if (! (jobu == 'N' || jobu == 'O'))
     left_sm.resize (m, ncol_u);
 
   double *u = left_sm.fortran_vec ();
 
   sigma.resize (nrow_s, ncol_s);
-  double *s_vec  = sigma.fortran_vec ();
+  double *s_vec = sigma.fortran_vec ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   double *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
diff --git a/liboctave/dim-vector.cc b/liboctave/dim-vector.cc
--- a/liboctave/dim-vector.cc
+++ b/liboctave/dim-vector.cc
@@ -152,26 +152,26 @@ dim_vector::squeeze (void) const
               // was not a singleton dimension.
 
               new_dims.resize (2);
 
               new_dims(1) = 1;
             }
         }
       else
-        new_dims.resize(k);
+        new_dims.resize (k);
     }
 
   return new_dims;
 }
 
-// This is the rule for cat(). cat(dim, A, B) works if one
+// This is the rule for cat(). cat (dim, A, B) works if one
 // of the following holds, in this order:
 //
-// 1. size(A, k) == size(B, k) for all k != dim.
+// 1. size (A, k) == size (B, k) for all k != dim.
 // In this case, size (C, dim) = size (A, dim) + size (B, dim) and
 // other sizes remain intact.
 //
 // 2. A is 0x0, in which case B is the result
 // 3. B is 0x0, in which case A is the result
 
 bool
 dim_vector::concat (const dim_vector& dvb, int dim)
@@ -225,17 +225,17 @@ dim_vector::concat (const dim_vector& dv
   return match;
 }
 
 // Rules for horzcat/vertcat are yet looser.
 // two arrays A, B can be concatenated
 // horizontally (dim = 2) or vertically (dim = 1) if one of the
 // following holds, in this order:
 //
-// 1. cat(dim, A, B) works
+// 1. cat (dim, A, B) works
 //
 // 2. A, B are 2D and one of them is an empty vector, in which
 // case the result is the other one except if both of them
 // are empty vectors, in which case the result is 0x0.
 
 bool
 dim_vector::hvcat (const dim_vector& dvb, int dim)
 {
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -236,18 +236,18 @@ ltsolve (const SM& L, const ColumnVector
   const double* qv = Q.fortran_vec ();
 
   if (!err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
         {
           for (octave_idx_type i = 0; i < n; i++)
-            retval.elem(static_cast<octave_idx_type>(qv[i]), j)  =
-              tmp.elem(i,j);
+            retval.elem (static_cast<octave_idx_type>(qv[i]), j) =
+              tmp.elem (i,j);
         }
     }
 
   return retval;
 }
 
 template <class SM, class M>
 static M
@@ -259,32 +259,32 @@ utsolve (const SM& U, const ColumnVector
   double rcond;
   MatrixType utyp (MatrixType::Upper);
 
   M retval (n, b_nc);
   const double* qv = Q.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = 0; i < n; i++)
-        retval.elem(i,j) = m.elem(static_cast<octave_idx_type>(qv[i]), j);
+        retval.elem (i,j) = m.elem (static_cast<octave_idx_type>(qv[i]), j);
     }
   return U.solve (utyp, retval, err, rcond, 0);
 }
 
 static bool
 vector_product (const SparseMatrix& m, const double* x, double* y)
 {
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     y[j] = 0.;
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      y[m.ridx(i)] += m.data(i) * x[j];
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      y[m.ridx (i)] += m.data (i) * x[j];
 
   return true;
 }
 
 static bool
 vector_product (const Matrix& m, const double *x, double *y)
 {
   octave_idx_type nr = m.rows ();
@@ -310,18 +310,18 @@ vector_product (const SparseComplexMatri
                         Complex* y)
 {
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     y[j] = 0.;
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      y[m.ridx(i)] += m.data(i) * x[j];
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      y[m.ridx (i)] += m.data (i) * x[j];
 
   return true;
 }
 
 static bool
 vector_product (const ComplexMatrix& m, const Complex *x, Complex *y)
 {
   octave_idx_type nr = m.rows ();
@@ -349,18 +349,18 @@ make_cholb (Matrix& b, Matrix& bt, Colum
   CHOL fact (b, info);
   octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
-      b =  bt.transpose ();
-      permB = ColumnVector(n);
+      b = bt.transpose ();
+      permB = ColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseMatrix& b, SparseMatrix& bt, ColumnVector& permB)
@@ -386,18 +386,18 @@ make_cholb (ComplexMatrix& b, ComplexMat
   ComplexCHOL fact (b, info);
   octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
-      b =  bt.hermitian ();
-      permB = ColumnVector(n);
+      b = bt.hermitian ();
+      permB = ColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseComplexMatrix& b, SparseComplexMatrix& bt,
@@ -433,44 +433,44 @@ LuAminusSigmaB (const SparseMatrix &m, c
     {
       if (cholB)
         {
           if (permB.length ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
-                  tmp.xcidx(i) = i;
-                  tmp.xridx(i) =
+                  tmp.xcidx (i) = i;
+                  tmp.xridx (i) =
                     static_cast<octave_idx_type>(permB(i));
-                  tmp.xdata(i) = 1;
+                  tmp.xdata (i) = 1;
                 }
-              tmp.xcidx(n) = n;
+              tmp.xcidx (n) = n;
 
               AminusSigmaB = AminusSigmaB - sigma * tmp *
                 b.transpose () * b * tmp.transpose ();
             }
           else
             AminusSigmaB = AminusSigmaB - sigma *
               b.transpose () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseMatrix sigmat (n, n, n);
 
-          // Create sigma * speye(n,n)
+          // Create sigma * speye (n,n)
           sigmat.xcidx (0) = 0;
           for (octave_idx_type i = 0; i < n; i++)
             {
-              sigmat.xdata(i) = sigma;
-              sigmat.xridx(i) = i;
-              sigmat.xcidx(i+1) = i + 1;
+              sigmat.xdata (i) = sigma;
+              sigmat.xridx (i) = i;
+              sigmat.xcidx (i+1) = i + 1;
             }
 
           AminusSigmaB = AminusSigmaB - sigmat;
         }
 
   SparseLU fact (AminusSigmaB);
 
   L = fact.L ();
@@ -485,19 +485,19 @@ LuAminusSigmaB (const SparseMatrix &m, c
     }
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
-      if (U.xcidx(j+1) > U.xcidx(j) &&
-          U.xridx (U.xcidx(j+1)-1) == j)
-        d = std::abs (U.xdata (U.xcidx(j+1)-1));
+      if (U.xcidx (j+1) > U.xcidx (j) &&
+          U.xridx (U.xcidx (j+1)-1) == j)
+        d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
 
@@ -536,18 +536,18 @@ LuAminusSigmaB (const Matrix &m, const M
           double *p = AminusSigmaB.fortran_vec ();
 
           if (permB.length ())
             {
               for (octave_idx_type j = 0;
                    j < b.cols (); j++)
                 for (octave_idx_type i = 0;
                      i < b.rows (); i++)
-                  *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
-                                      static_cast<octave_idx_type>(pB[j]));
+                  *p++ -= tmp.xelem (static_cast<octave_idx_type>(pB[i]),
+                                     static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
@@ -565,17 +565,17 @@ LuAminusSigmaB (const Matrix &m, const M
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
-      double d = std::abs (U.xelem(j,j));
+      double d = std::abs (U.xelem (j,j));
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
 
   double rcond = (minU / maxU);
@@ -608,43 +608,43 @@ LuAminusSigmaB (const SparseComplexMatri
     {
       if (cholB)
         {
           if (permB.length ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
-                  tmp.xcidx(i) = i;
-                  tmp.xridx(i) =
+                  tmp.xcidx (i) = i;
+                  tmp.xridx (i) =
                     static_cast<octave_idx_type>(permB(i));
-                  tmp.xdata(i) = 1;
+                  tmp.xdata (i) = 1;
                 }
-              tmp.xcidx(n) = n;
+              tmp.xcidx (n) = n;
 
               AminusSigmaB = AminusSigmaB - tmp * b.hermitian () * b *
                 tmp.transpose () * sigma;
             }
           else
             AminusSigmaB = AminusSigmaB - sigma * b.hermitian () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseComplexMatrix sigmat (n, n, n);
 
-      // Create sigma * speye(n,n)
+      // Create sigma * speye (n,n)
       sigmat.xcidx (0) = 0;
       for (octave_idx_type i = 0; i < n; i++)
         {
-          sigmat.xdata(i) = sigma;
-          sigmat.xridx(i) = i;
-          sigmat.xcidx(i+1) = i + 1;
+          sigmat.xdata (i) = sigma;
+          sigmat.xridx (i) = i;
+          sigmat.xcidx (i+1) = i + 1;
         }
 
       AminusSigmaB = AminusSigmaB - sigmat;
     }
 
   SparseComplexLU fact (AminusSigmaB);
 
   L = fact.L ();
@@ -659,19 +659,19 @@ LuAminusSigmaB (const SparseComplexMatri
     }
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
-      if (U.xcidx(j+1) > U.xcidx(j) &&
-          U.xridx (U.xcidx(j+1)-1) == j)
-        d = std::abs (U.xdata (U.xcidx(j+1)-1));
+      if (U.xcidx (j+1) > U.xcidx (j) &&
+          U.xridx (U.xcidx (j+1)-1) == j)
+        d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
 
@@ -710,18 +710,18 @@ LuAminusSigmaB (const ComplexMatrix &m, 
           Complex *p = AminusSigmaB.fortran_vec ();
 
           if (permB.length ())
             {
               for (octave_idx_type j = 0;
                    j < b.cols (); j++)
                 for (octave_idx_type i = 0;
                      i < b.rows (); i++)
-                  *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
-                                      static_cast<octave_idx_type>(pB[j]));
+                  *p++ -= tmp.xelem (static_cast<octave_idx_type>(pB[i]),
+                                     static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
@@ -739,17 +739,17 @@ LuAminusSigmaB (const ComplexMatrix &m, 
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
-      double d = std::abs (U.xelem(j,j));
+      double d = std::abs (U.xelem (j,j));
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
 
   double rcond = (minU / maxU);
@@ -795,19 +795,19 @@ EigsRealSymmetricMatrix (const M& m, con
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -822,17 +822,17 @@ EigsRealSymmetricMatrix (const M& m, con
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k < 1 || k > n - 2)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
-         "      Use 'eig(full(A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -886,24 +886,24 @@ EigsRealSymmetricMatrix (const M& m, con
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
           if (permB.length () == 0)
             {
-              permB = ColumnVector(n);
+              permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
-          if (! make_cholb(b, bt, permB))
+          if (! make_cholb (b, bt, permB))
             {
               (*current_liboctave_error_handler)
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
@@ -946,17 +946,17 @@ EigsRealSymmetricMatrix (const M& m, con
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -974,17 +974,17 @@ EigsRealSymmetricMatrix (const M& m, con
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
-              mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
+              mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
           else if (!vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
@@ -1068,17 +1068,17 @@ EigsRealSymmetricMatrix (const M& m, con
                         z[off1 + j] = z[off2 + j];
 
                       for (octave_idx_type j = 0; j < n; j++)
                         z[off2 + j] = dtmp[j];
                     }
                 }
 
               if (note3)
-                eig_vec = ltsolve(b, permB, eig_vec);
+                eig_vec = ltsolve (b, permB, eig_vec);
             }
         }
       else
         {
           (*current_liboctave_error_handler)
             ("eigs: error %d in dseupd", info2);
           return -1;
         }
@@ -1119,33 +1119,33 @@ EigsRealSymmetricMatrixShift (const M& m
   //if (! std::abs (sigma))
   //  return EigsRealSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                _b, permB, resid, os, tol, rvec, cholB,
   //                                disp, maxit);
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
@@ -1213,17 +1213,17 @@ EigsRealSymmetricMatrixShift (const M& m
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
-  if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
+  if (! LuAminusSigmaB (m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
@@ -1239,17 +1239,17 @@ EigsRealSymmetricMatrixShift (const M& m
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1428,19 +1428,19 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -1455,17 +1455,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -1540,17 +1540,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1709,19 +1709,19 @@ EigsRealNonSymmetricMatrix (const M& m, 
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -1736,17 +1736,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig(full(A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -1800,24 +1800,24 @@ EigsRealNonSymmetricMatrix (const M& m, 
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
           if (permB.length () == 0)
             {
-              permB = ColumnVector(n);
+              permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
-          if (! make_cholb(b, bt, permB))
+          if (! make_cholb (b, bt, permB))
             {
               (*current_liboctave_error_handler)
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
@@ -1888,17 +1888,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
-              mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
+              mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
           else if (!vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
@@ -1977,17 +1977,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
               Complex dtmp = d[i];
               d[i] = d[k - i - 1];
               d[k - i - 1] = dtmp;
             }
-          eig_val.resize(k);
+          eig_val.resize (k);
 
           if (rvec)
             {
               OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
               for (octave_idx_type i = 0; i < k2; i++)
                 {
                   octave_idx_type off1 = i * n;
@@ -2007,39 +2007,39 @@ EigsRealNonSymmetricMatrix (const M& m, 
                 }
 
               eig_vec.resize (n, k);
               octave_idx_type i = 0;
               while (i < k)
                 {
                   octave_idx_type off1 = i * n;
                   octave_idx_type off2 = (i+1) * n;
-                  if (std::imag(eig_val(i)) == 0)
+                  if (std::imag (eig_val(i)) == 0)
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         eig_vec(j,i) =
-                          Complex(z[j+off1],0.);
+                          Complex (z[j+off1],0.);
                       i++;
                     }
                   else
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         {
                           eig_vec(j,i) =
-                            Complex(z[j+off1],z[j+off2]);
+                            Complex (z[j+off1],z[j+off2]);
                           if (i < k - 1)
                             eig_vec(j,i+1) =
-                              Complex(z[j+off1],-z[j+off2]);
+                              Complex (z[j+off1],-z[j+off2]);
                         }
                       i+=2;
                     }
                 }
 
               if (note3)
-                eig_vec = ltsolve(M (b), permB, eig_vec);
+                eig_vec = ltsolve (M(b), permB, eig_vec);
             }
         }
       else
         {
           (*current_liboctave_error_handler)
             ("eigs: error %d in dneupd", info2);
           return -1;
         }
@@ -2082,19 +2082,19 @@ EigsRealNonSymmetricMatrixShift (const M
   //if (! std::abs (sigmar))
   //  return EigsRealNonSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                   _b, permB, resid, os, tol, rvec, cholB,
   //                                   disp, maxit);
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -2109,17 +2109,17 @@ EigsRealNonSymmetricMatrixShift (const M
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -2176,17 +2176,17 @@ EigsRealNonSymmetricMatrixShift (const M
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
-  if (! LuAminusSigmaB(m, b, cholB, permB, sigmar, L, U, P, Q))
+  if (! LuAminusSigmaB (m, b, cholB, permB, sigmar, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
@@ -2202,17 +2202,17 @@ EigsRealNonSymmetricMatrixShift (const M
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2363,17 +2363,17 @@ EigsRealNonSymmetricMatrixShift (const M
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
               Complex dtmp = d[i];
               d[i] = d[k - i - 1];
               d[k - i - 1] = dtmp;
             }
-          eig_val.resize(k);
+          eig_val.resize (k);
 
           if (rvec)
             {
               OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
               for (octave_idx_type i = 0; i < k2; i++)
                 {
                   octave_idx_type off1 = i * n;
@@ -2393,32 +2393,32 @@ EigsRealNonSymmetricMatrixShift (const M
                 }
 
               eig_vec.resize (n, k);
               octave_idx_type i = 0;
               while (i < k)
                 {
                   octave_idx_type off1 = i * n;
                   octave_idx_type off2 = (i+1) * n;
-                  if (std::imag(eig_val(i)) == 0)
+                  if (std::imag (eig_val(i)) == 0)
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         eig_vec(j,i) =
-                          Complex(z[j+off1],0.);
+                          Complex (z[j+off1],0.);
                       i++;
                     }
                   else
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         {
                           eig_vec(j,i) =
-                            Complex(z[j+off1],z[j+off2]);
+                            Complex (z[j+off1],z[j+off2]);
                           if (i < k - 1)
                             eig_vec(j,i+1) =
-                              Complex(z[j+off1],-z[j+off2]);
+                              Complex (z[j+off1],-z[j+off2]);
                         }
                       i+=2;
                     }
                 }
             }
         }
       else
         {
@@ -2445,19 +2445,19 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   char bmat = 'I';
   double sigmai = 0.;
   octave_idx_type mode = 1;
   int err = 0;
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -2472,17 +2472,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -2675,17 +2675,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
               Complex dtmp = d[i];
               d[i] = d[k - i - 1];
               d[k - i - 1] = dtmp;
             }
-          eig_val.resize(k);
+          eig_val.resize (k);
 
           if (rvec)
             {
               OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
               for (octave_idx_type i = 0; i < k2; i++)
                 {
                   octave_idx_type off1 = i * n;
@@ -2705,32 +2705,32 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
                 }
 
               eig_vec.resize (n, k);
               octave_idx_type i = 0;
               while (i < k)
                 {
                   octave_idx_type off1 = i * n;
                   octave_idx_type off2 = (i+1) * n;
-                  if (std::imag(eig_val(i)) == 0)
+                  if (std::imag (eig_val(i)) == 0)
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         eig_vec(j,i) =
-                          Complex(z[j+off1],0.);
+                          Complex (z[j+off1],0.);
                       i++;
                     }
                   else
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         {
                           eig_vec(j,i) =
-                            Complex(z[j+off1],z[j+off2]);
+                            Complex (z[j+off1],z[j+off2]);
                           if (i < k - 1)
                             eig_vec(j,i+1) =
-                              Complex(z[j+off1],-z[j+off2]);
+                              Complex (z[j+off1],-z[j+off2]);
                         }
                       i+=2;
                     }
                 }
             }
         }
       else
         {
@@ -2773,23 +2773,23 @@ EigsComplexNonSymmetricMatrix (const M& 
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      Array<double> rr (octave_rand::vector(n));
-      Array<double> ri (octave_rand::vector(n));
+      octave_rand::distribution ("uniform");
+      Array<double> rr (octave_rand::vector (n));
+      Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
-        cresid(i) = Complex(rr(i),ri(i));
-      octave_rand::distribution(rand_dist);
+        cresid(i) = Complex (rr(i),ri(i));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -2804,17 +2804,17 @@ EigsComplexNonSymmetricMatrix (const M& 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig(full(A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -2868,24 +2868,24 @@ EigsComplexNonSymmetricMatrix (const M& 
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.hermitian ();
           if (permB.length () == 0)
             {
-              permB = ColumnVector(n);
+              permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
-          if (! make_cholb(b, bt, permB))
+          if (! make_cholb (b, bt, permB))
             {
               (*current_liboctave_error_handler)
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
@@ -2929,17 +2929,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2956,17 +2956,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               ComplexMatrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
-              mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
+              mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
 
             }
           else if (!vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
@@ -3021,17 +3021,17 @@ EigsComplexNonSymmetricMatrix (const M& 
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = ctmp;
         }
-      eig_val.resize(k);
+      eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
           for (octave_idx_type i = 0; i < k2; i++)
             {
               octave_idx_type off1 = i * n;
@@ -3046,17 +3046,17 @@ EigsComplexNonSymmetricMatrix (const M& 
               for (octave_idx_type j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
               for (octave_idx_type j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
 
           if (note3)
-            eig_vec = ltsolve(b, permB, eig_vec);
+            eig_vec = ltsolve (b, permB, eig_vec);
         }
     }
   else
     {
       (*current_liboctave_error_handler)
         ("eigs: error %d in zneupd", info2);
       return -1;
     }
@@ -3098,23 +3098,23 @@ EigsComplexNonSymmetricMatrixShift (cons
   //if (! std::abs (sigma))
   //  return EigsComplexNonSymmetricMatrix (m, "SM", k, p, info, eig_vec,
   //                                      eig_val, _b, permB, cresid, os, tol,
   //                                      rvec, cholB, disp, maxit);
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      Array<double> rr (octave_rand::vector(n));
-      Array<double> ri (octave_rand::vector(n));
+      octave_rand::distribution ("uniform");
+      Array<double> rr (octave_rand::vector (n));
+      Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
-        cresid(i) = Complex(rr(i),ri(i));
-      octave_rand::distribution(rand_dist);
+        cresid(i) = Complex (rr(i),ri(i));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -3129,17 +3129,17 @@ EigsComplexNonSymmetricMatrixShift (cons
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -3196,17 +3196,17 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
-  if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
+  if (! LuAminusSigmaB (m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (3 * p + 5);
 
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
@@ -3361,17 +3361,17 @@ EigsComplexNonSymmetricMatrixShift (cons
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = ctmp;
         }
-      eig_val.resize(k);
+      eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
           for (octave_idx_type i = 0; i < k2; i++)
             {
               octave_idx_type off1 = i * n;
@@ -3407,31 +3407,31 @@ EigsComplexNonSymmetricFunc (EigsComplex
                              octave_idx_type k, octave_idx_type p,
                              octave_idx_type &info, ComplexMatrix &eig_vec,
                              ComplexColumnVector &eig_val,
                              ComplexColumnVector &cresid, std::ostream& os,
                              double tol, bool rvec, bool /* cholB */,
                              int disp, int maxit)
 {
   std::string typ (_typ);
-  bool have_sigma = (std::abs(sigma) ? true : false);
+  bool have_sigma = (std::abs (sigma) ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      Array<double> rr (octave_rand::vector(n));
-      Array<double> ri (octave_rand::vector(n));
+      octave_rand::distribution ("uniform");
+      Array<double> rr (octave_rand::vector (n));
+      Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
-        cresid(i) = Complex(rr(i),ri(i));
-      octave_rand::distribution(rand_dist);
+        cresid(i) = Complex (rr(i),ri(i));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -3446,17 +3446,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -3625,17 +3625,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = ctmp;
         }
-      eig_val.resize(k);
+      eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
           for (octave_idx_type i = 0; i < k2; i++)
             {
               octave_idx_type off1 = i * n;
diff --git a/liboctave/f2c-main.c b/liboctave/f2c-main.c
--- a/liboctave/f2c-main.c
+++ b/liboctave/f2c-main.c
@@ -26,10 +26,10 @@ along with Octave; see the file COPYING.
 /* Dummy Fortran main declaration, needed in order to link to some
    Fortran libraries.  See the AC_F77_DUMMY_MAIN macro documentation.
    This function should never be called. */
 
 #ifdef F77_DUMMY_MAIN
 #  ifdef __cplusplus
 extern "C"
 #  endif
-int F77_DUMMY_MAIN () { assert(0); return 1; }
+int F77_DUMMY_MAIN () { assert (0); return 1; }
 #endif
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1076,27 +1076,27 @@ FloatComplexMatrix::finverse (MatrixType
       Array<FloatComplex> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
                                  z.fortran_vec (), lwork, info));
 
-      lwork = static_cast<octave_idx_type> (std::real(z(0)));
+      lwork = static_cast<octave_idx_type> (std::real (z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (dim_vector (lwork, 1));
       FloatComplex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm;
       if (calc_cond)
-        anorm  = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1160,17 +1160,17 @@ FloatComplexMatrix::inverse (MatrixType 
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (!mattype.is_hermitian ())
-        ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = FloatComplexMatrix (rows (), columns (), FloatComplex (octave_Float_Inf, 0.));
     }
 
   return ret;
 }
 
@@ -1823,17 +1823,17 @@ FloatComplexMatrix::rcond (MatrixType &m
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-              if(anorm < 0.)
+              if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
@@ -2091,17 +2091,17 @@ FloatComplexMatrix::fsolve (MatrixType &
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -2175,17 +2175,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2401,17 +2401,17 @@ FloatComplexMatrix::solve (MatrixType &t
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
                       octave_idx_type& info, float& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   FloatComplexMatrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
-  return tmp.column(static_cast<octave_idx_type> (0));
+  return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -232,17 +232,17 @@ FloatComplexNDArray::fourier (int dim) c
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
@@ -279,17 +279,17 @@ FloatComplexNDArray::ifourier (int dim) 
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<float> (npts);
         }
     }
diff --git a/liboctave/fCmplxQR.cc b/liboctave/fCmplxQR.cc
--- a/liboctave/fCmplxQR.cc
+++ b/liboctave/fCmplxQR.cc
@@ -466,33 +466,33 @@ FloatComplexQR::update (const FloatCompl
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init(q*r + FloatComplexMatrix (u) * FloatComplexMatrix (v).hermitian (), get_type ());
+      init (q*r + FloatComplexMatrix (u) * FloatComplexMatrix (v).hermitian (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 FloatComplexQR::update (const FloatComplexMatrix& u, const FloatComplexMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
-      init(q*r + u * v.hermitian (), get_type ());
+      init (q*r + u * v.hermitian (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 static
 FloatComplexMatrix insert_col (const FloatComplexMatrix& a, octave_idx_type i,
                                const FloatComplexColumnVector& x)
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -221,18 +221,18 @@ FloatEIG::init (const FloatMatrix& a, bo
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = FloatComplex (wr.elem(j), wi.elem(j));
-              lambda.elem(j+1) = FloatComplex (wr.elem(j+1), wi.elem(j+1));
+              lambda.elem (j) = FloatComplex (wr.elem (j), wi.elem (j));
+              lambda.elem (j+1) = FloatComplex (wr.elem (j+1), wi.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   float real_part = vr.elem (i, j);
                   float imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = FloatComplex (real_part, imag_part);
                   v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
                 }
@@ -571,20 +571,20 @@ FloatEIG::init (const FloatMatrix& a, co
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = FloatComplex (ar.elem(j) / beta.elem (j),
-                                             ai.elem(j) / beta.elem (j));
-              lambda.elem(j+1) = FloatComplex (ar.elem(j+1) / beta.elem (j+1),
-                                               ai.elem(j+1) / beta.elem (j+1));
+              lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j),
+                                              ai.elem (j) / beta.elem (j));
+              lambda.elem (j+1) = FloatComplex (ar.elem (j+1) / beta.elem (j+1),
+                                                ai.elem (j+1) / beta.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   float real_part = vr.elem (i, j);
                   float imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = FloatComplex (real_part, imag_part);
                   v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
                 }
@@ -770,17 +770,17 @@ FloatEIG::init (const FloatComplexMatrix
         {
           (*current_liboctave_error_handler) ("cggev failed to converge");
           return info;
         }
 
       lambda.resize (n);
 
       for (octave_idx_type j = 0; j < n; j++)
-        lambda.elem (j) = alpha.elem (j) / beta.elem(j);
+        lambda.elem (j) = alpha.elem (j) / beta.elem (j);
 
       v = vtmp;
     }
   else
     (*current_liboctave_error_handler) ("cggev workspace query failed");
 
   return info;
 }
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -758,17 +758,17 @@ FloatMatrix::finverse (MatrixType &matty
       z.resize (dim_vector (lwork, 1));
       float *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond)
-        anorm = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -833,17 +833,17 @@ FloatMatrix::inverse (MatrixType &mattyp
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (!mattype.is_hermitian ())
-        ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = FloatMatrix (rows (), columns (), octave_Float_Inf);
     }
 
   return ret;
 }
 
@@ -1457,17 +1457,17 @@ FloatMatrix::rcond (MatrixType &mattype)
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
               anorm = atmp.abs ().sum ().
-                row(static_cast<octave_idx_type>(0)).max ();
+                row (static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1493,17 +1493,17 @@ FloatMatrix::rcond (MatrixType &mattype)
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-              if(anorm < 0.)
+              if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
@@ -1757,17 +1757,17 @@ FloatMatrix::fsolve (MatrixType &mattype
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1833,18 +1833,18 @@ FloatMatrix::fsolve (MatrixType &mattype
         {
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
-          if(anorm < 0.)
-            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          if (anorm < 0.)
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           Array<float> z (dim_vector (4 * nc, 1));
           float *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2057,17 +2057,17 @@ FloatMatrix::solve (MatrixType &typ, con
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
                float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatMatrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
-  return tmp.column(static_cast<octave_idx_type> (0));
+  return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
@@ -2089,17 +2089,17 @@ FloatMatrix::solve (MatrixType &typ, con
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
                octave_idx_type& info, float& rcon,
                solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve(typ, b, info, rcon, sing_handler, transt);
+  return tmp.solve (typ, b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -236,17 +236,17 @@ FloatNDArray::fourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
@@ -283,17 +283,17 @@ FloatNDArray::ifourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<float> (npts);
         }
     }
diff --git a/liboctave/floatQR.cc b/liboctave/floatQR.cc
--- a/liboctave/floatQR.cc
+++ b/liboctave/floatQR.cc
@@ -459,33 +459,33 @@ FloatQR::update (const FloatColumnVector
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init(q*r + FloatMatrix (u) * FloatMatrix (v).transpose (), get_type ());
+      init (q*r + FloatMatrix (u) * FloatMatrix (v).transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 FloatQR::update (const FloatMatrix& u, const FloatMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
-      init(q*r + u * v.transpose (), get_type ());
+      init (q*r + u * v.transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 static
 FloatMatrix insert_col (const FloatMatrix& a, octave_idx_type i,
                         const FloatColumnVector& x)
diff --git a/liboctave/floatSVD.cc b/liboctave/floatSVD.cc
--- a/liboctave/floatSVD.cc
+++ b/liboctave/floatSVD.cc
@@ -130,17 +130,17 @@ FloatSVD::init (const FloatMatrix& a, SV
   type_computed = svd_type;
 
   if (! (jobu == 'N' || jobu == 'O'))
     left_sm.resize (m, ncol_u);
 
   float *u = left_sm.fortran_vec ();
 
   sigma.resize (nrow_s, ncol_s);
-  float *s_vec  = sigma.fortran_vec ();
+  float *s_vec = sigma.fortran_vec ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   float *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -103,17 +103,17 @@ idx_vector::idx_colon_rep::print (std::o
   return os << ":";
 }
 
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_range_rep);
 
 idx_vector::idx_range_rep::idx_range_rep (octave_idx_type _start,
                                           octave_idx_type _limit,
                                           octave_idx_type _step)
-  : start(_start), len (_step ? std::max((_limit - _start) / _step, static_cast<octave_idx_type> (0)) : -1), step (_step)
+  : start(_start), len (_step ? std::max ((_limit - _start) / _step, static_cast<octave_idx_type> (0)) : -1), step (_step)
 {
   if (len < 0)
     {
       gripe_invalid_range ();
       err = true;
     }
   else if (start < 0 || (step < 0 && start + (len-1)*step < 0))
     {
@@ -380,17 +380,17 @@ idx_vector::idx_vector_rep::idx_vector_r
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (bool b)
   : data (0), len (b ? 1 : 0), ext (0), aowner (0), orig_dims (len, len)
 {
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type [1];
+      octave_idx_type *d = new octave_idx_type[1];
       d[0] = 0;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<bool>& bnda,
                                             octave_idx_type nnz)
@@ -402,17 +402,17 @@ idx_vector::idx_vector_rep::idx_vector_r
   const dim_vector dv = bnda.dims ();
 
   if (! dv.all_zero ())
     orig_dims = ((dv.length () == 2 && dv(0) == 1)
                  ? dim_vector (1, len) : dim_vector (len, 1));
 
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type [len];
+      octave_idx_type *d = new octave_idx_type[len];
 
       octave_idx_type ntot = bnda.length ();
 
       octave_idx_type k = 0;
       for (octave_idx_type i = 0; i < ntot; i++)
         if (bnda.xelem (i))
           d[k++] = i;
 
@@ -430,17 +430,17 @@ idx_vector::idx_vector_rep::idx_vector_r
 
   dim_vector dv = bnda.dims ();
 
   orig_dims = ((dv.length () == 2 && dv(0) == 1)
                ? dim_vector (1, len) : orig_dims = dim_vector (len, 1));
 
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type [len];
+      octave_idx_type *d = new octave_idx_type[len];
 
       octave_idx_type nnz = bnda.nnz ();
 
       octave_idx_type k = 0;
       // FIXME: I hope this is OK, i.e. the element iterated this way are correctly ordered.
       for (octave_idx_type i = 0; i < nnz; i++)
         {
           if (bnda.data (i))
@@ -561,17 +561,17 @@ idx_vector::idx_vector_rep::sort_idx (Ar
   if (ext > len*xlog2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
       idx.clear (orig_dims);
       octave_idx_type *idx_data = idx.fortran_vec ();
       for (octave_idx_type i = 0; i < len; i++)
         idx_data[i] = i;
 
-      octave_idx_type *new_data = new octave_idx_type [len];
+      octave_idx_type *new_data = new octave_idx_type[len];
       new_rep->data = new_data;
       std::copy (data, data + len, new_data);
 
       octave_sort<octave_idx_type> lsort;
       lsort.set_compare (ASCENDING);
       lsort.sort (new_data, idx_data, len);
     }
   else
@@ -580,17 +580,17 @@ idx_vector::idx_vector_rep::sort_idx (Ar
       OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, cnt, ext, 0);
 
       for (octave_idx_type i = 0; i < len; i++)
         cnt[data[i]]++;
 
       idx.clear (orig_dims);
       octave_idx_type *idx_data = idx.fortran_vec ();
 
-      octave_idx_type *new_data = new octave_idx_type [len];
+      octave_idx_type *new_data = new octave_idx_type[len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, k = 0; i < ext; i++)
         {
           octave_idx_type j = cnt[i];
           cnt[i] = k;
           k += j;
         }
@@ -649,17 +649,17 @@ idx_vector::idx_vector_rep::as_array (vo
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_mask_rep);
 
 idx_vector::idx_mask_rep::idx_mask_rep (bool b)
   : data (0), len (b ? 1 : 0), ext (0), lsti (-1), lste (-1),
     aowner (0), orig_dims (len, len)
 {
   if (len != 0)
     {
-      bool *d = new bool [1];
+      bool *d = new bool[1];
       d[0] = true;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_mask_rep::idx_mask_rep (const Array<bool>& bnda,
                                         octave_idx_type nnz)
@@ -1140,17 +1140,17 @@ idx_vector::complement (octave_idx_type 
 
 bool
 idx_vector::is_permutation (octave_idx_type n) const
 {
   bool retval = false;
 
   if (is_colon_equiv (n))
     retval = true;
-  else if (length (n) == n && extent(n) == n)
+  else if (length(n) == n && extent(n) == n)
     {
       OCTAVE_LOCAL_BUFFER_INIT (bool, left, n, true);
 
       retval = true;
 
       for (octave_idx_type i = 0, len = length (); i < len; i++)
         {
           octave_idx_type k = xelem (i);
@@ -1185,17 +1185,17 @@ idx_vector::inverse_permutation (octave_
         break;
       }
     case class_vector:
       {
         idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
         const octave_idx_type *ri = r->get_data ();
         Array<octave_idx_type> idx (orig_dimensions ());
         for (octave_idx_type i = 0; i < n; i++)
-          idx.xelem(ri[i]) = i;
+          idx.xelem (ri[i]) = i;
         retval = new idx_vector_rep (idx, r->extent (0), DIRECT);
         break;
       }
     default:
       retval = *this;
       break;
     }
 
@@ -1205,17 +1205,17 @@ idx_vector::inverse_permutation (octave_
 idx_vector
 idx_vector::unmask (void) const
 {
   if (idx_class () == class_mask)
     {
       idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
       const bool *data = r->get_data ();
       octave_idx_type ext = r->extent (0), len = r->length (0);
-      octave_idx_type *idata = new octave_idx_type [len];
+      octave_idx_type *idata = new octave_idx_type[len];
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         if (data[i])
           idata[j++] = i;
 
       ext = len > 0 ? idata[len - 1] + 1 : 0;
 
       return new idx_vector_rep (idata, len, ext, r->orig_dimensions (),
@@ -1325,12 +1325,12 @@ INSTANTIATE_SCALAR_VECTOR_REP_CONST (oct
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_int64)
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_uint8)
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_uint16)
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_uint32)
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_uint64)
 
 /*
 
-%!error id=Octave:index-out-of-bounds 1(find([1,1] != 0))
-%!assert ((1:3)(find([1,0,1] != 0)), [1,3])
+%!error id=Octave:index-out-of-bounds 1(find ([1,1] != 0))
+%!assert ((1:3)(find ([1,0,1] != 0)), [1,3])
 
 */
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -30,30 +30,30 @@ 02110-1301, USA.  */
 #include <string>
 
 /* System defines are for non-Unix systems only.  (Testing for all Unix
    variations should be done in configure.)  Presently the defines used
    are: DOS OS2 WIN32.  I do not use any of these systems
    myself; if you do, I'd be grateful for any changes. --kb@mail.tug.org */
 
 /* If we have either DOS or OS2, we are DOSISH.  */
-#if defined (DOS) || defined (OS2) || defined (WIN32) || defined(__MSDOS__)
+#if defined (DOS) || defined (OS2) || defined (WIN32) || defined (__MSDOS__)
 #define DOSISH
 #endif
 
 #if defined (DOSISH)
 #define MONOCASE_FILENAMES      /* case-insensitive filename comparisons */
 #endif
 
 extern "C" {
-#if defined(__MINGW32__)
+#if defined (__MINGW32__)
 #include <windows.h>
 #include <fcntl.h>
 #include <dirent.h>
-#elif defined(WIN32)
+#elif defined (WIN32)
 #ifndef _MSC_VER
 #define __STDC__ 1
 #include "win32lib.h"
 #endif
 #endif /* not WIN32 */
 
 #ifdef __DJGPP__
 #include <fcntl.h>      /* for long filenames' stuff */
@@ -71,17 +71,17 @@ extern "C" {
    compiling standalone, we get our c-auto.h.  Otherwise, the package
    containing us must provide this (unless it can somehow generate ours
    from c-auto.in).  We use <...> instead of "..." so that the current
    cpp directory (i.e., kpathsea/) won't be searched. */
 
 /* If you want to find subdirectories in a directory with non-Unix
    semantics (specifically, if a directory with no subdirectories does
    not have exactly two links), define this.  */
-#if defined(__DJGPP__) || ! defined (DOSISH)
+#if defined (__DJGPP__) || ! defined (DOSISH)
 /* Surprise!  DJGPP returns st_nlink exactly like on Unix.  */
 #define ST_NLINK_TRICK
 #endif /* either not DOSISH or __DJGPP__ */
 
 #ifdef OS2
 #define access ln_access
 #define fopen ln_fopen
 #define rename ln_rename
@@ -94,17 +94,17 @@ extern "C" {
 /* What separates filename components?  */
 #ifndef DIR_SEP
 #ifdef DOSISH
 /* Either \'s or 's work.  Wayne Sullivan's web2pc prefers /, so we'll
    go with that.  */
 #define DIR_SEP '/'
 #define DIR_SEP_STRING "/"
 #define IS_DEVICE_SEP(ch) ((ch) == ':')
-#define NAME_BEGINS_WITH_DEVICE(name) ((name.length()>0) && IS_DEVICE_SEP((name)[1]))
+#define NAME_BEGINS_WITH_DEVICE(name) ((name.length ()>0) && IS_DEVICE_SEP((name)[1]))
 /* On DOS, it's good to allow both \ and / between directories.  */
 #define IS_DIR_SEP(ch) ((ch) == '/' || (ch) == '\\')
 #else
 #define DIR_SEP '/'
 #define DIR_SEP_STRING "/"
 #endif /* not DOSISH */
 #endif /* not DIR_SEP */
 
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -449,17 +449,17 @@ expm1 (double x)
   else
     retval = exp (x) - 1;
 
   return retval;
 }
 #endif
 
 Complex
-expm1(const Complex& x)
+expm1 (const Complex& x)
 {
   Complex retval;
 
   if (std:: abs (x) < 1)
     {
       double im = x.imag ();
       double u = expm1 (x.real ());
       double v = sin (im/2);
@@ -504,17 +504,17 @@ expm1f (float x)
   else
     retval = exp (x) - 1;
 
   return retval;
 }
 #endif
 
 FloatComplex
-expm1(const FloatComplex& x)
+expm1 (const FloatComplex& x)
 {
   FloatComplex retval;
 
   if (std:: abs (x) < 1)
     {
       float im = x.imag ();
       float u = expm1 (x.real ());
       float v = sin (im/2);
@@ -560,17 +560,17 @@ log1p (const Complex& x)
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       double u = 2*r + r*r + i*i;
       retval = Complex (log1p (u / (1+sqrt (u+1))),
                         atan2 (1 + r, i));
     }
   else
-    retval = std::log (Complex(1) + x);
+    retval = std::log (Complex (1) + x);
 
   return retval;
 }
 
 #if !defined (HAVE_CBRT)
 double cbrt (double x)
 {
   static const double one_third = 0.3333333333333333333;
@@ -619,17 +619,17 @@ log1p (const FloatComplex& x)
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       float u = 2*r + r*r + i*i;
       retval = FloatComplex (log1p (u / (1+sqrt (u+1))),
                         atan2 (1 + r, i));
     }
   else
-    retval = std::log (FloatComplex(1) + x);
+    retval = std::log (FloatComplex (1) + x);
 
   return retval;
 }
 
 #if !defined (HAVE_CBRTF)
 float cbrtf (float x)
 {
   static const float one_third = 0.3333333333333333333f;
@@ -868,17 +868,17 @@ zbesi (const Complex& z, double alpha, i
       if (ierr == 0 || ierr == 3)
         {
           Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
             * zbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
-              tmp2 *= exp(-z - std::abs(z.real ()));
+              tmp2 *= exp (-z - std::abs (z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = Complex (octave_NaN, octave_NaN);
@@ -1478,17 +1478,17 @@ cbesi (const FloatComplex& z, float alph
       if (ierr == 0 || ierr == 3)
         {
           FloatComplex tmp2 = static_cast<float> (2.0 / M_PI) * sinf (static_cast<float> (M_PI) * alpha)
             * cbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
-              tmp2 *= exp(-z - std::abs(z.real ()));
+              tmp2 *= exp (-z - std::abs (z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
@@ -1888,17 +1888,17 @@ airy (const Complex& z, bool deriv, bool
   double zi = z.imag ();
 
   octave_idx_type id = deriv ? 1 : 0;
 
   F77_FUNC (zairy, ZAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
 
   if (! scaled)
     {
-      Complex expz = exp (- 2.0 / 3.0 * z * sqrt(z));
+      Complex expz = exp (- 2.0 / 3.0 * z * sqrt (z));
 
       double rexpz = real (expz);
       double iexpz = imag (expz);
 
       double tmp = ar*rexpz - ai*iexpz;
 
       ai = ar*iexpz + ai*rexpz;
       ar = tmp;
@@ -2018,17 +2018,17 @@ airy (const FloatComplex& z, bool deriv,
   float zi = z.imag ();
 
   octave_idx_type id = deriv ? 1 : 0;
 
   F77_FUNC (cairy, CAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
 
   if (! scaled)
     {
-      FloatComplex expz = exp (- static_cast<float> (2.0 / 3.0) * z * sqrt(z));
+      FloatComplex expz = exp (- static_cast<float> (2.0 / 3.0) * z * sqrt (z));
 
       float rexpz = real (expz);
       float iexpz = imag (expz);
 
       float tmp = ar*rexpz - ai*iexpz;
 
       ai = ar*iexpz + ai*rexpz;
       ar = tmp;
@@ -3125,17 +3125,17 @@ erfcx_impl (T x)
         }
       else
         result = sqrpi / y;
 
       // Fix up negative argument.
       if (x < 0)
         {
           double y2 = ceil (x / 16.0) * 16.0, del = (x-y2)*(x+y2);
-          result = 2*(std::exp(y2*y2) * std::exp(del)) - result;
+          result = 2*(std::exp (y2*y2) * std::exp (del)) - result;
         }
     }
 
   return result;
 }
 
 double erfcx (double x)
 {
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -478,22 +478,22 @@ inline bool xis_false (const Complex& x)
 inline bool xis_true (const FloatComplex& x) { return ! xisnan (x) && x != 0.0f; }
 inline bool xis_false (const FloatComplex& x) { return x == 0.0f; }
 
 #define OP_RED_SUM(ac, el) ac += el
 #define OP_RED_PROD(ac, el) ac *= el
 #define OP_RED_SUMSQ(ac, el) ac += el*el
 #define OP_RED_SUMSQC(ac, el) ac += cabsq (el)
 
-inline void op_dble_sum(double& ac, float el)
+inline void op_dble_sum (double& ac, float el)
 { ac += el; }
-inline void op_dble_sum(Complex& ac, const FloatComplex& el)
+inline void op_dble_sum (Complex& ac, const FloatComplex& el)
 { ac += el; } // FIXME: guaranteed?
 template <class T>
-inline void op_dble_sum(double& ac, const octave_int<T>& el)
+inline void op_dble_sum (double& ac, const octave_int<T>& el)
 { ac += el.double_value (); }
 
 // The following two implement a simple short-circuiting.
 #define OP_RED_ANYC(ac, el) if (xis_true (el)) { ac = true; break; } else continue
 #define OP_RED_ALLC(ac, el) if (xis_false (el)) { ac = false; break; } else continue
 
 #define OP_RED_FCN(F, TSRC, TRES, OP, ZERO) \
 template <class T> \
@@ -1172,17 +1172,17 @@ get_extent_triplet (const dim_vector& di
 template <class R, class T>
 inline Array<R>
 do_mx_red_op (const Array<T>& src, int dim,
               void (*mx_red_op) (const T *, R *, octave_idx_type,
                                  octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
-  // M*b inconsistency: sum([]) = 0 etc.
+  // M*b inconsistency: sum ([]) = 0 etc.
   if (dims.length () == 2 && dims(0) == 0 && dims(1) == 0)
     dims (1) = 1;
 
   get_extent_triplet (dims, dim, l, n, u);
 
   // Reduction operation reduces the array size.
   if (dim < dims.length ()) dims(dim) = 1;
   dims.chop_trailing_singletons ();
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -408,17 +408,17 @@ OP (const M& m, const DM& dm) \
  \
       if (m_nr > 0 && m_nc > 0) \
         { \
           r = R (m); \
  \
           octave_idx_type len = dm.length (); \
  \
           for (octave_idx_type i = 0; i < len; i++) \
-            r.elem(i, i) OPEQ dm.elem(i, i); \
+            r.elem (i, i) OPEQ dm.elem (i, i); \
         } \
     } \
  \
   return r; \
 }
 
 #define MDM_MULTIPLY_OP(R, M, DM, R_ZERO) \
 R \
@@ -478,17 +478,17 @@ OP (const DM& dm, const M& m) \
     { \
       if (m_nr > 0 && m_nc > 0) \
         { \
           r = R (PREOP m); \
  \
           octave_idx_type len = dm.length (); \
  \
           for (octave_idx_type i = 0; i < len; i++) \
-            r.elem(i, i) OPEQ dm.elem(i, i); \
+            r.elem (i, i) OPEQ dm.elem (i, i); \
         } \
       else \
         r.resize (m_nr, m_nc); \
     } \
  \
   return r; \
 }
 
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <new>
 
 #include "oct-alloc.h"
 
 void *
 octave_allocator::alloc (size_t size)
 {
   if (size != item_size)
-    return ::new char [size];
+    return ::new char[size];
 
   if (! head)
     {
       if (! grow ())
         return 0;
     }
 
   link *tmp = head;
diff --git a/liboctave/oct-binmap.h b/liboctave/oct-binmap.h
--- a/liboctave/oct-binmap.h
+++ b/liboctave/oct-binmap.h
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 
 #include "Array.h"
 #include "Sparse.h"
 #include "Array-util.h"
 
 #include "bsxfun.h"
 
 // This source file implements a general binary maping function for
-// arrays. The syntax is binmap<type> (a, b, f, [name]). type denotes
+// arrays. The syntax is binmap<type> (a, b, f,[name]). type denotes
 // the expected return type of the operation. a, b, should be one of
 // the 6 combinations:
 //
 // Array-Array
 // Array-scalar
 // scalar-Array
 // Sparse-Sparse
 // Sparse-scalar
@@ -218,17 +218,17 @@ template <class U, class T, class R, cla
 Sparse<U>
 binmap (const T& x, const Sparse<R>& ys, F fcn)
 {
   octave_idx_type nz = ys.nnz ();
   Sparse<U> retval (ys.rows (), ys.cols (), nz);
   for (octave_idx_type i = 0; i < nz; i++)
     {
       octave_quit ();
-      retval.xdata(i) = fcn (x, ys.data(i));
+      retval.xdata (i) = fcn (x, ys.data (i));
     }
 
   octave_quit ();
   retval.maybe_compress ();
   return retval;
 }
 
 // Sparse-scalar
@@ -236,17 +236,17 @@ template <class U, class T, class R, cla
 Sparse<U>
 binmap (const Sparse<T>& xs, const R& y, F fcn)
 {
   octave_idx_type nz = xs.nnz ();
   Sparse<U> retval (xs.rows (), xs.cols (), nz);
   for (octave_idx_type i = 0; i < nz; i++)
     {
       octave_quit ();
-      retval.xdata(i) = fcn (xs.data(i), y);
+      retval.xdata (i) = fcn (xs.data (i), y);
     }
 
   octave_quit ();
   retval.maybe_compress ();
   return retval;
 }
 
 // Sparse-Sparse (treats singletons as scalars)
@@ -271,59 +271,59 @@ binmap (const Sparse<T>& xs, const Spars
       octave_idx_type nr = xs.rows (), nc = xs.cols ();
       Sparse<T> retval (nr, nc);
 
       octave_idx_type nz = 0;
       // Count nonzeros.
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
-          octave_idx_type ix = xs.cidx(j), iy = ys.cidx(j);
-          octave_idx_type ux = xs.cidx(j+1), uy = ys.cidx(j+1);
+          octave_idx_type ix = xs.cidx (j), iy = ys.cidx (j);
+          octave_idx_type ux = xs.cidx (j+1), uy = ys.cidx (j+1);
           while (ix != ux || iy != uy)
             {
-              octave_idx_type rx = xs.ridx(ix), ry = ys.ridx(ix);
+              octave_idx_type rx = xs.ridx (ix), ry = ys.ridx (ix);
               ix += rx <= ry;
               iy += ry <= rx;
               nz++;
             }
 
-          retval.xcidx(j+1) = nz;
+          retval.xcidx (j+1) = nz;
         }
 
       // Allocate space.
-      retval.change_capacity (retval.xcidx(nc));
+      retval.change_capacity (retval.xcidx (nc));
 
       // Fill.
       nz = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
-          octave_idx_type ix = xs.cidx(j), iy = ys.cidx(j);
-          octave_idx_type ux = xs.cidx(j+1), uy = ys.cidx(j+1);
+          octave_idx_type ix = xs.cidx (j), iy = ys.cidx (j);
+          octave_idx_type ux = xs.cidx (j+1), uy = ys.cidx (j+1);
           while (ix != ux || iy != uy)
             {
-              octave_idx_type rx = xs.ridx(ix), ry = ys.ridx(ix);
+              octave_idx_type rx = xs.ridx (ix), ry = ys.ridx (ix);
               if (rx == ry)
                 {
-                  retval.xridx(nz) = rx;
-                  retval.xdata(nz) = fcn (xs.data(ix), ys.data(iy));
+                  retval.xridx (nz) = rx;
+                  retval.xdata (nz) = fcn (xs.data (ix), ys.data (iy));
                   ix++;
                   iy++;
                 }
               else if (rx < ry)
                 {
-                  retval.xridx(nz) = rx;
-                  retval.xdata(nz) = fcn (xs.data(ix), yzero);
+                  retval.xridx (nz) = rx;
+                  retval.xdata (nz) = fcn (xs.data (ix), yzero);
                   ix++;
                 }
               else if (ry < rx)
                 {
-                  retval.xridx(nz) = ry;
-                  retval.xdata(nz) = fcn (xzero, ys.data(iy));
+                  retval.xridx (nz) = ry;
+                  retval.xdata (nz) = fcn (xzero, ys.data (iy));
                   iy++;
                 }
 
               nz++;
             }
         }
 
       retval.maybe_compress ();
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -718,17 +718,17 @@ convert_packcomplex_1d (T *out, size_t n
                         octave_idx_type stride, octave_idx_type dist)
 {
   octave_quit ();
 
   // Fill in the missing data.
 
   for (size_t i = 0; i < nr; i++)
     for (size_t j = nc/2+1; j < nc; j++)
-      out[j*stride + i*dist] = conj(out[(nc - j)*stride + i*dist]);
+      out[j*stride + i*dist] = conj (out[(nc - j)*stride + i*dist]);
 
   octave_quit ();
 }
 
 template <class T>
 static inline void
 convert_packcomplex_Nd (T *out, const dim_vector &dv)
 {
@@ -753,20 +753,20 @@ convert_packcomplex_Nd (T *out, const di
   octave_quit ();
 
   // Fill in the missing data for the rank = 2 case directly for speed.
 
   for (size_t i = 0; i < np; i++)
     {
       for (size_t j = 1; j < nr; j++)
         for (size_t k = nc/2+1; k < nc; k++)
-          out[k + (j + i*nr)*nc] = conj(out[nc - k + ((i+1)*nr - j)*nc]);
+          out[k + (j + i*nr)*nc] = conj (out[nc - k + ((i+1)*nr - j)*nc]);
 
       for (size_t j = nc/2+1; j < nc; j++)
-        out[j + i*nr*nc] = conj(out[(i*nr+1)*nc - j]);
+        out[j + i*nr*nc] = conj (out[(i*nr+1)*nc - j]);
     }
 
   octave_quit ();
 
   // Now do the permutations needed for rank > 2 cases.
 
   size_t jstart = dv(0) * dv(1);
   size_t kstep = dv(0);
@@ -777,17 +777,17 @@ convert_packcomplex_Nd (T *out, const di
       size_t jmax = jstart * dv(inner);
       for (size_t i = 0; i < nel; i+=jmax)
         for (size_t j = jstart, jj = jmax-jstart; j < jj;
              j+=jstart, jj-=jstart)
           for (size_t k = 0; k < jstart; k+= kstep)
             for (size_t l = nc/2+1; l < nc; l++)
               {
                 T tmp = out[i+ j + k + l];
-                out[i + j + k + l] =  out[i + jj + k + l];
+                out[i + j + k + l] = out[i + jj + k + l];
                 out[i + jj + k + l] = tmp;
               }
       jstart = jmax;
     }
 
   octave_quit ();
 }
 
diff --git a/liboctave/oct-group.h b/liboctave/oct-group.h
--- a/liboctave/oct-group.h
+++ b/liboctave/oct-group.h
@@ -43,17 +43,17 @@ public:
     : gr_name (gr.gr_name), gr_passwd (gr.gr_passwd),
       gr_gid (gr.gr_gid), gr_mem (gr.gr_mem), valid (gr.valid)
   { }
 
   octave_group& operator = (const octave_group& gr)
   {
     if (this != &gr)
       {
-        gr_name  = gr.gr_name;
+        gr_name = gr.gr_name;
         gr_passwd = gr.gr_passwd;
         gr_gid = gr.gr_gid;
         gr_mem = gr.gr_mem;
         valid = gr.valid;
       }
 
     return *this;
   }
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -267,33 +267,33 @@ overflow:
 
 #define DOUBLE_INT_BINOP_DECL(OP,SUFFIX) \
   template <> \
   OCTAVE_API octave_ ## SUFFIX \
   operator OP (const double& x, const octave_ ## SUFFIX & y)
 
 INT_DOUBLE_BINOP_DECL (+, uint64)
 {
-  return (y < 0) ? x - octave_uint64(-y) : x + octave_uint64(y);
+  return (y < 0) ? x - octave_uint64 (-y) : x + octave_uint64 (y);
 }
 
 DOUBLE_INT_BINOP_DECL (+, uint64)
 { return y + x; }
 
 INT_DOUBLE_BINOP_DECL (+, int64)
 {
   if (fabs (y) < static_cast<double> (octave_int64::max ()))
     return x + octave_int64 (y);
   else
     {
       // If the number is within the int64 range (the most common case,
       // probably), the above will work as expected. If not, it's more
       // complicated - as long as y is within _twice_ the signed range, the
       // result may still be an integer. An instance of such an operation is
-      // 3*2**62 + (1+intmin('int64')) that should yield int64(2**62) + 1.  So
+      // 3*2**62 + (1+intmin ('int64')) that should yield int64 (2**62) + 1.  So
       // what we do is to try to convert y/2 and add it twice. Note that if y/2
       // overflows, the result must overflow as well, and that y/2 cannot be a
       // fractional number.
       octave_int64 y2 (y / 2);
       return (x + y2) + y2;
     }
 }
 
@@ -305,22 +305,22 @@ DOUBLE_INT_BINOP_DECL (+, int64)
 INT_DOUBLE_BINOP_DECL (-, uint64)
 {
   return x + (-y);
 }
 
 DOUBLE_INT_BINOP_DECL (-, uint64)
 {
   if (x <= static_cast<double> (octave_uint64::max ()))
-    return octave_uint64(x) - y;
+    return octave_uint64 (x) - y;
   else
     {
       // Again a trick to get the corner cases right. Things like
-      // 3**2**63 - intmax('uint64') should produce the correct result, i.e.
-      // int64(2**63) + 1.
+      // 3**2**63 - intmax ('uint64') should produce the correct result, i.e.
+      // int64 (2**63) + 1.
       const double p2_64 = std::pow (2.0, 64);
       if (y.bool_value ())
         {
           const uint64_t p2_64my = (~y.value ()) + 1; // Equals 2**64 - y
           return octave_uint64 (x - p2_64) + octave_uint64 (p2_64my);
         }
       else
         return octave_uint64 (p2_64);
@@ -335,17 +335,17 @@ INT_DOUBLE_BINOP_DECL (-, int64)
 DOUBLE_INT_BINOP_DECL (-, int64)
 {
   static const bool twosc = (std::numeric_limits<int64_t>::min ()
                              < -std::numeric_limits<int64_t>::max ());
   // In case of symmetric integers (not two's complement), this will probably
   // be eliminated at compile time.
   if (twosc && y.value () == std::numeric_limits<int64_t>::min ())
     {
-      return octave_int64 (x + std::pow(2.0, 63));
+      return octave_int64 (x + std::pow (2.0, 63));
     }
   else
     return x + (-y);
 }
 
 // NOTE:
 // Emulated mixed multiplications are tricky due to possible precision loss.
 // Here, after sorting out common cases for speed, we follow the strategy
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -820,17 +820,17 @@ public:
 
 #undef OCTAVE_INT_BIN_OP
 
   static octave_int<T> min (void) { return std::numeric_limits<T>::min (); }
   static octave_int<T> max (void) { return std::numeric_limits<T>::max (); }
 
   static int nbits (void) { return std::numeric_limits<T>::digits; }
 
-  static int byte_size (void) { return sizeof(T); }
+  static int byte_size (void) { return sizeof (T); }
 
   static const char *type_name ();
 
   // The following are provided for convenience.
   static const octave_int zero, one;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
diff --git a/liboctave/oct-locbuf.cc b/liboctave/oct-locbuf.cc
--- a/liboctave/oct-locbuf.cc
+++ b/liboctave/oct-locbuf.cc
@@ -69,21 +69,21 @@ octave_chunk_buffer::octave_chunk_buffer
     {
       // Big buffers (> 1/8 chunk) will be allocated as stand-alone and
       // won't disrupt the chain.
 
       if (size > chunk_size >> 3)
         {
           // Use new [] to get std::bad_alloc if out of memory.
 
-          dat = new char [size];
+          dat = new char[size];
           return;
         }
 
-      dat = new char [chunk_size];
+      dat = new char[chunk_size];
       chunk = top = dat;
       left = chunk_size;
     }
 
   // Now allocate memory from the chunk and update state.
 
   cnk = chunk;
   dat = top;
diff --git a/liboctave/oct-md5.cc b/liboctave/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/oct-md5.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-error.h"
 #include "oct-md5.h"
 #include "md5.h"
 
 static std::string
 oct_md5_result_to_str (const unsigned char *buf)
 {
-  char tmp [33];
+  char tmp[33];
 
   sprintf (tmp,
            "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
            buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],
            buf[8],  buf[9], buf[10], buf[11], buf[12], buf[13], buf[14],
            buf[15]);
 
   return std::string (tmp, 32);
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -355,28 +355,28 @@ octave_rand::do_scalar (double a)
           F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, retval);
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, retval);
           break;
 
         case poisson_dist:
-          if (a < 0.0 || xisnan(a) || xisinf(a))
+          if (a < 0.0 || xisnan (a) || xisinf (a))
             retval = octave_NaN;
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, retval);
               F77_FUNC (dignpoi, DIGNPOI) (a, retval);
             }
           break;
 
         case gamma_dist:
-          if (a <= 0.0 || xisnan(a) || xisinf(a))
+          if (a <= 0.0 || xisnan (a) || xisinf (a))
             retval = octave_NaN;
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
@@ -438,28 +438,28 @@ octave_rand::do_float_scalar (float a)
           F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, dretval);
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, dretval);
           break;
 
         case poisson_dist:
-          if (da < 0.0 || xisnan(da) || xisinf(da))
+          if (da < 0.0 || xisnan (da) || xisinf (da))
             dretval = octave_NaN;
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, dretval);
               F77_FUNC (dignpoi, DIGNPOI) (da, dretval);
             }
           break;
 
         case gamma_dist:
-          if (da <= 0.0 || xisnan(da) || xisinf(da))
+          if (da <= 0.0 || xisnan (da) || xisinf (da))
             retval = octave_NaN;
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, da, dretval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
@@ -625,17 +625,17 @@ octave_rand::get_internal_state (void)
 {
   ColumnVector s (MT_N + 1);
 
   OCTAVE_LOCAL_BUFFER (uint32_t, tmp, MT_N + 1);
 
   oct_get_state (tmp);
 
   for (octave_idx_type i = 0; i <= MT_N; i++)
-    s.elem (i) = static_cast<double> (tmp [i]);
+    s.elem (i) = static_cast<double> (tmp[i]);
 
   return s;
 }
 
 void
 octave_rand::save_state (void)
 {
   rand_states[current_distribution] = get_internal_state ();;
@@ -667,17 +667,17 @@ void
 octave_rand::set_internal_state (const ColumnVector& s)
 {
   octave_idx_type len = s.length ();
   octave_idx_type n = len < MT_N + 1 ? len : MT_N + 1;
 
   OCTAVE_LOCAL_BUFFER (uint32_t, tmp, MT_N + 1);
 
   for (octave_idx_type i = 0; i < n; i++)
-    tmp[i] = static_cast<uint32_t> (s.elem(i));
+    tmp[i] = static_cast<uint32_t> (s.elem (i));
 
   if (len == MT_N + 1 && tmp[MT_N] <= MT_N && tmp[MT_N] > 0)
     oct_set_state (tmp);
   else
     oct_init_by_array (tmp, len);
 }
 
 void
@@ -743,17 +743,17 @@ octave_rand::fill (octave_idx_type len, 
         }
       else
         oct_fill_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
-          if (a < 0.0 || xisnan(a) || xisinf(a))
+          if (a < 0.0 || xisnan (a) || xisinf (a))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
@@ -764,17 +764,17 @@ octave_rand::fill (octave_idx_type len, 
         }
       else
         oct_fill_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
-          if (a <= 0.0 || xisnan(a) || xisinf(a))
+          if (a <= 0.0 || xisnan (a) || xisinf (a))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, a, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
@@ -833,17 +833,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_float_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
           double da = a;
-          if (da < 0.0 || xisnan(da) || xisinf(da))
+          if (da < 0.0 || xisnan (da) || xisinf (da))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, tmp);
@@ -855,17 +855,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_float_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
           double da = a;
-          if (da <= 0.0 || xisnan(da) || xisinf(da))
+          if (da <= 0.0 || xisnan (da) || xisinf (da))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, da, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -1179,17 +1179,17 @@ octave_sort<T>::merge_at (octave_idx_typ
   /* Where does a end in b?  Elements in b after that can be
    * ignored (already in place).
    */
   nb = gallop_left (pa[na-1], pb, nb, nb-1, comp);
   if (nb <= 0)
     return nb;
 
   /* Merge what remains of the runs, using a temp array with
-   * min(na, nb) elements.
+   * min (na, nb) elements.
    */
   if (na <= nb)
     return merge_lo (pa, na, pb, nb, comp);
   else
     return merge_hi (pa, na, pb, nb, comp);
 }
 
 template <class T>
@@ -1233,17 +1233,17 @@ octave_sort<T>::merge_at (octave_idx_typ
   /* Where does a end in b?  Elements in b after that can be
    * ignored (already in place).
    */
   nb = gallop_left (pa[na-1], pb, nb, nb-1, comp);
   if (nb <= 0)
     return nb;
 
   /* Merge what remains of the runs, using a temp array with
-   * min(na, nb) elements.
+   * min (na, nb) elements.
    */
   if (na <= nb)
     return merge_lo (pa, ipa, na, pb, ipb, nb, comp);
   else
     return merge_hi (pa, ipa, na, pb, ipb, nb, comp);
 }
 
 /* Examine the stack of runs waiting to be merged, merging adjacent runs
@@ -1408,17 +1408,17 @@ octave_sort<T>::sort (T *data, octave_id
           octave_idx_type n;
 
           /* Identify next run. */
           n = count_run (data + lo, nremaining, descending, comp);
           if (n < 0)
             goto fail;
           if (descending)
             std::reverse (data + lo, data + lo + n);
-          /* If short, extend to min(minrun, nremaining). */
+          /* If short, extend to min (minrun, nremaining). */
           if (n < minrun)
             {
               const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
               binarysort (data + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
@@ -1470,17 +1470,17 @@ octave_sort<T>::sort (T *data, octave_id
           n = count_run (data + lo, nremaining, descending, comp);
           if (n < 0)
             goto fail;
           if (descending)
             {
               std::reverse (data + lo, data + lo + n);
               std::reverse (idx + lo, idx + lo + n);
             }
-          /* If short, extend to min(minrun, nremaining). */
+          /* If short, extend to min (minrun, nremaining). */
           if (n < minrun)
             {
               const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
               binarysort (data + lo, idx + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
@@ -1605,19 +1605,19 @@ octave_sort<T>::sort_rows (const T *data
   // This is a breadth-first traversal.
   typedef sortrows_run_t run_t;
   std::stack<run_t> runs;
 
   runs.push (run_t (0, 0, rows));
 
   while (! runs.empty ())
     {
-      octave_idx_type col  = runs.top ().col;
-      octave_idx_type ofs  = runs.top ().ofs;
-      octave_idx_type nel  = runs.top ().nel;
+      octave_idx_type col = runs.top ().col;
+      octave_idx_type ofs = runs.top ().ofs;
+      octave_idx_type nel = runs.top ().nel;
       runs.pop ();
       assert (nel > 1);
 
       T *lbuf = buf + ofs;
       const T *ldata = data + rows*col;
       octave_idx_type *lidx = idx + ofs;
 
       // Gather.
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -353,32 +353,32 @@ octave_syscalls::popen2 (const std::stri
                   else
                     child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
                 }
               else
                 child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
 
               (*current_liboctave_error_handler)(child_msg.c_str ());
 
-              exit(0);
+              exit (0);
             }
           else
             {
               // Parent process
               gnulib::close (child_stdin[0]);
               gnulib::close (child_stdout[1]);
 
 #if defined (F_SETFL) && defined (O_NONBLOCK)
               if (! sync_mode && octave_fcntl (child_stdout[0], F_SETFL, O_NONBLOCK, msg) < 0)
                 msg = "popen2: error setting file mode -- " + msg;
               else
 #endif
                 {
-                  fildes[0] = child_stdin [1];
-                  fildes[1] = child_stdout [0];
+                  fildes[0] = child_stdin[1];
+                  fildes[1] = child_stdout[0];
                   return pid;
                 }
             }
           gnulib::close (child_stdout[0]);
           gnulib::close (child_stdout[1]);
         }
       else
         msg = "popen2: pipe creation failed -- " + msg;
diff --git a/liboctave/randgamma.c b/liboctave/randgamma.c
--- a/liboctave/randgamma.c
+++ b/liboctave/randgamma.c
@@ -20,18 +20,18 @@ along with Octave; see the file COPYING.
 
 */
 
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
 /*
 
-double randg(a)
-void fill_randg(a,n,x)
+double randg (a)
+void fill_randg (a,n,x)
 
 Generate a series of standard gamma distributions.
 
 See: Marsaglia G and Tsang W (2000), "A simple method for generating
 gamma variables", ACM Transactions on Mathematical Software 26(3) 363-372
 
 Needs the following defines:
 * NAN: value to return for Not-A-Number
@@ -94,19 +94,19 @@ Dirichlet(a1,...,ak) for ai > 0
 #define RUNI oct_randu()
 #define RNOR oct_randn()
 #define REXP oct_rande()
 
 void
 oct_fill_randg (double a, octave_idx_type n, double *r)
 {
   octave_idx_type i;
-  /* If a < 1, start by generating gamma(1+a) */
+  /* If a < 1, start by generating gamma (1+a) */
   const double d =  (a < 1. ? 1.+a : a) - 1./3.;
-  const double c = 1./sqrt(9.*d);
+  const double c = 1./sqrt (9.*d);
 
   /* Handle invalid cases */
   if (a <= 0 || INFINITE(a))
     {
       for (i=0; i < n; i++)
         r[i] = NAN;
       return;
     }
@@ -117,33 +117,33 @@ oct_fill_randg (double a, octave_idx_typ
     restart:
       x = RNOR;
       v = (1+c*x);
       v *= v*v;
       if (v <= 0)
         goto restart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
-      if (u >= 1.-0.0331*xsq*xsq && log(u) >= 0.5*xsq + d*(1-v+log(v)))
+      if (u >= 1.-0.0331*xsq*xsq && log (u) >= 0.5*xsq + d*(1-v+log (v)))
         goto restart;
       r[i] = d*v;
     }
   if (a < 1)
     { /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
       for (i = 0; i < n; i++)
-        r[i] *= exp(-REXP/a);
+        r[i] *= exp (-REXP/a);
     }
 }
 
 double
 oct_randg (double a)
 {
   double ret;
-  oct_fill_randg(a,1,&ret);
+  oct_fill_randg (a,1,&ret);
   return ret;
 }
 
 #undef NAN
 #undef RUNI
 #undef RNOR
 #undef REXP
 #define NAN octave_Float_NaN
@@ -152,17 +152,17 @@ oct_randg (double a)
 #define REXP oct_float_rande()
 
 void
 oct_fill_float_randg (float a, octave_idx_type n, float *r)
 {
   octave_idx_type i;
   /* If a < 1, start by generating gamma(1+a) */
   const float d =  (a < 1. ? 1.+a : a) - 1./3.;
-  const float c = 1./sqrt(9.*d);
+  const float c = 1./sqrt (9.*d);
 
   /* Handle invalid cases */
   if (a <= 0 || INFINITE(a))
     {
       for (i=0; i < n; i++)
         r[i] = NAN;
       return;
     }
@@ -173,27 +173,27 @@ oct_fill_float_randg (float a, octave_id
     frestart:
       x = RNOR;
       v = (1+c*x);
       v *= v*v;
       if (v <= 0)
         goto frestart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
-      if (u >= 1.-0.0331*xsq*xsq && log(u) >= 0.5*xsq + d*(1-v+log(v)))
+      if (u >= 1.-0.0331*xsq*xsq && log (u) >= 0.5*xsq + d*(1-v+log (v)))
         goto frestart;
       r[i] = d*v;
     }
   if (a < 1)
     { /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
       for (i = 0; i < n; i++)
-        r[i] *= exp(-REXP/a);
+        r[i] *= exp (-REXP/a);
     }
 }
 
 float
 oct_float_randg (float a)
 {
   float ret;
-  oct_fill_float_randg(a,1,&ret);
+  oct_fill_float_randg (a,1,&ret);
   return ret;
 }
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -112,68 +112,68 @@ along with Octave; see the file COPYING.
 
    === Usage instructions ===
    Before using any of the generators, initialize the state with one of
    oct_init_by_int, oct_init_by_array or oct_init_by_entropy.
 
    All generators share the same state vector.
 
    === Mersenne Twister ===
-   void oct_init_by_int(uint32_t s)           32-bit initial state
-   void oct_init_by_array(uint32_t k[],int m) m*32-bit initial state
-   void oct_init_by_entropy(void)             random initial state
-   void oct_get_state(uint32_t save[MT_N+1])  saves state in array
-   void oct_set_state(uint32_t save[MT_N+1])  restores state from array
-   static uint32_t randmt(void)               returns 32-bit unsigned int
+   void oct_init_by_int (uint32_t s)           32-bit initial state
+   void oct_init_by_array (uint32_t k[],int m) m*32-bit initial state
+   void oct_init_by_entropy (void)             random initial state
+   void oct_get_state (uint32_t save[MT_N+1])  saves state in array
+   void oct_set_state (uint32_t save[MT_N+1])  restores state from array
+   static uint32_t randmt (void)               returns 32-bit unsigned int
 
    === inline generators ===
-   static uint32_t randi32(void)   returns 32-bit unsigned int
-   static uint64_t randi53(void)   returns 53-bit unsigned int
-   static uint64_t randi54(void)   returns 54-bit unsigned int
-   static float randu32(void)     returns 32-bit uniform in (0,1)
-   static double randu53(void)     returns 53-bit uniform in (0,1)
+   static uint32_t randi32 (void)   returns 32-bit unsigned int
+   static uint64_t randi53 (void)   returns 53-bit unsigned int
+   static uint64_t randi54 (void)   returns 54-bit unsigned int
+   static float randu32 (void)      returns 32-bit uniform in (0,1)
+   static double randu53 (void)     returns 53-bit uniform in (0,1)
 
-   double oct_randu(void)       returns M-bit uniform in (0,1)
-   double oct_randn(void)       returns M-bit standard normal
-   double oct_rande(void)       returns N-bit standard exponential
+   double oct_randu (void)       returns M-bit uniform in (0,1)
+   double oct_randn (void)       returns M-bit standard normal
+   double oct_rande (void)       returns N-bit standard exponential
 
-   float oct_float_randu(void)       returns M-bit uniform in (0,1)
-   float oct_float_randn(void)       returns M-bit standard normal
-   float oct_float_rande(void)       returns N-bit standard exponential
+   float oct_float_randu (void)       returns M-bit uniform in (0,1)
+   float oct_float_randn (void)       returns M-bit standard normal
+   float oct_float_rande (void)       returns N-bit standard exponential
 
    === Array generators ===
-   void oct_fill_randi32(octave_idx_type, uint32_t [])
-   void oct_fill_randi64(octave_idx_type, uint64_t [])
+   void oct_fill_randi32 (octave_idx_type, uint32_t [])
+   void oct_fill_randi64 (octave_idx_type, uint64_t [])
 
-   void oct_fill_randu(octave_idx_type, double [])
-   void oct_fill_randn(octave_idx_type, double [])
-   void oct_fill_rande(octave_idx_type, double [])
+   void oct_fill_randu (octave_idx_type, double [])
+   void oct_fill_randn (octave_idx_type, double [])
+   void oct_fill_rande (octave_idx_type, double [])
 
-   void oct_fill_float_randu(octave_idx_type, float [])
-   void oct_fill_float_randn(octave_idx_type, float [])
-   void oct_fill_float_rande(octave_idx_type, float [])
+   void oct_fill_float_randu (octave_idx_type, float [])
+   void oct_fill_float_randn (octave_idx_type, float [])
+   void oct_fill_float_rande (octave_idx_type, float [])
 */
 
 #if defined (HAVE_CONFIG_H)
 #include <config.h>
 #endif
 
 #include <stdio.h>
 #include <time.h>
 
 #ifdef HAVE_GETTIMEOFDAY
 #include <sys/time.h>
 #endif
 
 #include "lo-math.h"
 #include "randmtzig.h"
 
-/* FIXME may want to suppress X86 if sizeof(long)>4 */
-#if !defined(USE_X86_32)
-# if defined(i386) || defined(HAVE_X86_32)
+/* FIXME may want to suppress X86 if sizeof(long) > 4 */
+#if !defined (USE_X86_32)
+# if defined (i386) || defined (HAVE_X86_32)
 #  define USE_X86_32 1
 # else
 #  define USE_X86_32 0
 # endif
 #endif
 
 /* ===== Mersenne Twister 32-bit generator ===== */
 
@@ -255,44 +255,44 @@ oct_init_by_array (uint32_t *init_key, i
 
 void
 oct_init_by_entropy (void)
 {
     uint32_t entropy[MT_N];
     int n = 0;
 
     /* Look for entropy in /dev/urandom */
-    FILE* urandom =fopen("/dev/urandom", "rb");
+    FILE* urandom =fopen ("/dev/urandom", "rb");
     if (urandom)
       {
         while (n < MT_N)
           {
             unsigned char word[4];
-            if (fread(word, 4, 1, urandom) != 1)
+            if (fread (word, 4, 1, urandom) != 1)
               break;
             entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+(word[3]<<24);
           }
-        fclose(urandom);
+        fclose (urandom);
       }
 
     /* If there isn't enough entropy, gather some from various sources */
     if (n < MT_N)
-      entropy[n++] = time(NULL); /* Current time in seconds */
+      entropy[n++] = time (NULL); /* Current time in seconds */
     if (n < MT_N)
       entropy[n++] = clock ();    /* CPU time used (usec) */
 #ifdef HAVE_GETTIMEOFDAY
     if (n < MT_N)
       {
         struct timeval tv;
-        if (gettimeofday(&tv, NULL) != -1)
+        if (gettimeofday (&tv, NULL) != -1)
           entropy[n++] = tv.tv_usec;   /* Fractional part of current time */
       }
 #endif
     /* Send all the entropy into the initial state vector */
-    oct_init_by_array(entropy,n);
+    oct_init_by_array (entropy,n);
 }
 
 void
 oct_set_state (uint32_t *save)
 {
   int i;
   for (i = 0; i < MT_N; i++)
     state[i] = save[i];
@@ -501,17 +501,17 @@ create_ziggurat_tables (void)
   wi[0] = NOR_SECTION_AREA / fi[255] / NMANTISSA;
   fi[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
        */
-      x = sqrt(-2. * log(NOR_SECTION_AREA / x1 + fi[i+1]));
+      x = sqrt (-2. * log (NOR_SECTION_AREA / x1 + fi[i+1]));
       ki[i+1] = (ZIGINT)(x / x1 * NMANTISSA);
       wi[i] = x / NMANTISSA;
       fi[i] = exp (-0.5 * x * x);
       x1 = x;
     }
 
   ki[1] = 0;
 
@@ -529,17 +529,17 @@ create_ziggurat_tables (void)
   we[0] = EXP_SECTION_AREA / fe[255] / EMANTISSA;
   fe[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-x) -> x = -ln(y)
        */
-      x = - log(EXP_SECTION_AREA / x1 + fe[i+1]);
+      x = - log (EXP_SECTION_AREA / x1 + fe[i+1]);
       ke[i+1] = (ZIGINT)(x / x1 * EMANTISSA);
       we[i] = x / EMANTISSA;
       fe[i] = exp (-x);
       x1 = x;
     }
   ke[1] = 0;
 
   initt = 0;
@@ -615,17 +615,17 @@ oct_randn (void)
           do
             {
               xx = - ZIGGURAT_NOR_INV_R * log (RANDU);
               yy = - log (RANDU);
             }
           while ( yy+yy <= xx*xx);
           return (rabs&0x100 ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
         }
-      else if ((fi[idx-1] - fi[idx]) * RANDU + fi[idx] < exp(-0.5*x*x))
+      else if ((fi[idx-1] - fi[idx]) * RANDU + fi[idx] < exp (-0.5*x*x))
         return x;
     }
 }
 
 double
 oct_rande (void)
 {
   if (initt)
@@ -640,19 +640,19 @@ oct_rande (void)
         return x;               // 98.9% of the time we return here 1st try
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
            *
            * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
            */
-          return ZIGGURAT_EXP_R - log(RANDU);
+          return ZIGGURAT_EXP_R - log (RANDU);
         }
-      else if ((fe[idx-1] - fe[idx]) * RANDU + fe[idx] < exp(-x))
+      else if ((fe[idx-1] - fe[idx]) * RANDU + fe[idx] < exp (-x))
         return x;
     }
 }
 
 #undef ZIGINT
 #undef EMANTISSA
 #undef ERANDI
 #undef NMANTISSA
@@ -692,17 +692,17 @@ create_ziggurat_float_tables (void)
   fwi[0] = NOR_SECTION_AREA / ffi[255] / NMANTISSA;
   ffi[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
        */
-      x = sqrt(-2. * log(NOR_SECTION_AREA / x1 + ffi[i+1]));
+      x = sqrt (-2. * log (NOR_SECTION_AREA / x1 + ffi[i+1]));
       fki[i+1] = (ZIGINT)(x / x1 * NMANTISSA);
       fwi[i] = x / NMANTISSA;
       ffi[i] = exp (-0.5 * x * x);
       x1 = x;
     }
 
   fki[1] = 0;
 
@@ -720,17 +720,17 @@ create_ziggurat_float_tables (void)
   fwe[0] = EXP_SECTION_AREA / ffe[255] / EMANTISSA;
   ffe[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-x) -> x = -ln(y)
        */
-      x = - log(EXP_SECTION_AREA / x1 + ffe[i+1]);
+      x = - log (EXP_SECTION_AREA / x1 + ffe[i+1]);
       fke[i+1] = (ZIGINT)(x / x1 * EMANTISSA);
       fwe[i] = x / EMANTISSA;
       ffe[i] = exp (-x);
       x1 = x;
     }
   fke[1] = 0;
 
   inittf = 0;
@@ -782,17 +782,17 @@ oct_float_randn (void)
           do
             {
               xx = - ZIGGURAT_NOR_INV_R * log (RANDU);
               yy = - log (RANDU);
             }
           while ( yy+yy <= xx*xx);
           return (rabs&0x100 ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
         }
-      else if ((ffi[idx-1] - ffi[idx]) * RANDU + ffi[idx] < exp(-0.5*x*x))
+      else if ((ffi[idx-1] - ffi[idx]) * RANDU + ffi[idx] < exp (-0.5*x*x))
         return x;
     }
 }
 
 float
 oct_float_rande (void)
 {
   if (inittf)
@@ -807,19 +807,19 @@ oct_float_rande (void)
         return x;               // 98.9% of the time we return here 1st try
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
            *
            * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
            */
-          return ZIGGURAT_EXP_R - log(RANDU);
+          return ZIGGURAT_EXP_R - log (RANDU);
         }
-      else if ((ffe[idx-1] - ffe[idx]) * RANDU + ffe[idx] < exp(-x))
+      else if ((ffe[idx-1] - ffe[idx]) * RANDU + ffe[idx] < exp (-x))
         return x;
     }
 }
 
 /* Array generators */
 void
 oct_fill_randu (octave_idx_type n, double *p)
 {
diff --git a/liboctave/randpoisson.c b/liboctave/randpoisson.c
--- a/liboctave/randpoisson.c
+++ b/liboctave/randpoisson.c
@@ -100,17 +100,17 @@ flogfak (double k)
   };
 
   double  r, rr;
 
   if (k >= 30.0)
     {
       r  = 1.0 / k;
       rr = r * r;
-      return ((k + 0.5)*log(k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
+      return ((k + 0.5)*log (k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
     }
   else
     return (logfak[(int)k]);
 }
 
 
 /******************************************************************
  *                                                                *
@@ -141,66 +141,66 @@ flogfak (double k)
  * Implemented by H. Zechner, January 1994                        *
  * Revised by F. Niederl, July 1994                               *
  *                                                                *
  ******************************************************************/
 
 static double
 f (double k, double l_nu, double c_pm)
 {
-  return exp(k * l_nu - flogfak(k) - c_pm);
+  return exp (k * l_nu - flogfak (k) - c_pm);
 }
 
 static double
 pprsc (double my)
 {
   static double        my_last = -1.0;
   static double        m,  k2, k4, k1, k5;
   static double        dl, dr, r1, r2, r4, r5, ll, lr, l_my, c_pm,
     f1, f2, f4, f5, p1, p2, p3, p4, p5, p6;
   double               Dk, X, Y;
   double               Ds, U, V, W;
 
   if (my != my_last)
     {                               /* set-up           */
       my_last = my;
       /* approximate deviation of reflection points k2, k4 from my - 1/2 */
-      Ds = sqrt(my + 0.25);
+      Ds = sqrt (my + 0.25);
 
       /* mode m, reflection points k2 and k4, and points k1 and k5,      */
       /* which delimit the centre region of h(x)                         */
-      m  = floor(my);
-      k2 = ceil(my - 0.5 - Ds);
-      k4 = floor(my - 0.5 + Ds);
+      m  = floor (my);
+      k2 = ceil (my - 0.5 - Ds);
+      k4 = floor (my - 0.5 + Ds);
       k1 = k2 + k2 - m + 1L;
       k5 = k4 + k4 - m;
 
       /* range width of the critical left and right centre region        */
       dl = (k2 - k1);
       dr = (k5 - k4);
 
       /* recurrence constants r(k)=p(k)/p(k-1) at k = k1, k2, k4+1, k5+1 */
       r1 = my / k1;
       r2 = my / k2;
       r4 = my / (k4 + 1.0);
       r5 = my / (k5 + 1.0);
 
       /* reciprocal values of the scale parameters of exp. tail envelope */
-      ll =  log(r1);                                 /* expon. tail left */
-      lr = -log(r5);                                 /* expon. tail right*/
+      ll =  log (r1);                                /* expon. tail left */
+      lr = -log (r5);                                /* expon. tail right*/
 
       /* Poisson constants, necessary for computing function values f(k) */
-      l_my = log(my);
-      c_pm = m * l_my - flogfak(m);
+      l_my = log (my);
+      c_pm = m * l_my - flogfak (m);
 
       /* function values f(k) = p(k)/p(m) at k = k2, k4, k1, k5          */
-      f2 = f(k2, l_my, c_pm);
-      f4 = f(k4, l_my, c_pm);
-      f1 = f(k1, l_my, c_pm);
-      f5 = f(k5, l_my, c_pm);
+      f2 = f (k2, l_my, c_pm);
+      f4 = f (k4, l_my, c_pm);
+      f1 = f (k1, l_my, c_pm);
+      f5 = f (k5, l_my, c_pm);
 
       /* area of the two centre and the two exponential tail regions     */
       /* area of the two immediate acceptance regions between k2, k4     */
       p1 = f2 * (dl + 1.0);                            /* immed. left    */
       p2 = f2 * dl         + p1;                       /* centre left    */
       p3 = f4 * (dr + 1.0) + p2;                       /* immed. right   */
       p4 = f4 * dr         + p3;                       /* centre right   */
       p5 = f1 / ll         + p4;                       /* exp. tail left */
@@ -211,122 +211,122 @@ pprsc (double my)
     {
       /* generate uniform number U -- U(0, p6)                           */
       /* case distinction corresponding to U                             */
       if ((U = RUNI * p6) < p2)
         {                                            /* centre left      */
 
           /* immediate acceptance region
              R2 = [k2, m) *[0, f2),  X = k2, ... m -1 */
-          if ((V = U - p1) < 0.0)  return(k2 + floor(U/f2));
+          if ((V = U - p1) < 0.0)  return (k2 + floor (U/f2));
           /* immediate acceptance region
              R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1 */
-          if ((W = V / dl) < f1 )  return(k1 + floor(V/f1));
+          if ((W = V / dl) < f1 )  return (k1 + floor (V/f1));
 
           /* computation of candidate X < k2, and its counterpart Y > k2 */
           /* either squeeze-acceptance of X or acceptance-rejection of Y */
-          Dk = floor(dl * RUNI) + 1.0;
+          Dk = floor (dl * RUNI) + 1.0;
           if (W <= f2 - Dk * (f2 - f2/r2))
             {                                        /* quick accept of  */
-              return(k2 - Dk);                       /* X = k2 - Dk      */
+              return (k2 - Dk);                      /* X = k2 - Dk      */
             }
           if ((V = f2 + f2 - W) < 1.0)
             {                                        /* quick reject of Y*/
               Y = k2 + Dk;
               if (V <= f2 + Dk * (1.0 - f2)/(dl + 1.0))
                 {                                    /* quick accept of  */
-                  return(Y);                         /* Y = k2 + Dk      */
+                  return (Y);                        /* Y = k2 + Dk      */
                 }
-              if (V <= f(Y, l_my, c_pm))  return(Y); /* final accept of Y*/
+              if (V <= f (Y, l_my, c_pm))  return (Y); /* final accept of Y*/
             }
           X = k2 - Dk;
         }
       else if (U < p4)
         {                                            /* centre right     */
           /*  immediate acceptance region
               R3 = [m, k4+1)*[0, f4), X = m, ... k4    */
-          if ((V = U - p3) < 0.0)  return(k4 - floor((U - p2)/f4));
+          if ((V = U - p3) < 0.0)  return (k4 - floor ((U - p2)/f4));
           /* immediate acceptance region
              R4 = [k4+1, k5+1)*[0, f5)                */
-          if ((W = V / dr) < f5 )  return(k5 - floor(V/f5));
+          if ((W = V / dr) < f5 )  return (k5 - floor (V/f5));
 
           /* computation of candidate X > k4, and its counterpart Y < k4 */
           /* either squeeze-acceptance of X or acceptance-rejection of Y */
-          Dk = floor(dr * RUNI) + 1.0;
+          Dk = floor (dr * RUNI) + 1.0;
           if (W <= f4 - Dk * (f4 - f4*r4))
             {                                        /* quick accept of  */
-              return(k4 + Dk);                       /* X = k4 + Dk      */
+              return (k4 + Dk);                      /* X = k4 + Dk      */
             }
           if ((V = f4 + f4 - W) < 1.0)
             {                                        /* quick reject of Y*/
               Y = k4 - Dk;
               if (V <= f4 + Dk * (1.0 - f4)/ dr)
                 {                                    /* quick accept of  */
-                  return(Y);                         /* Y = k4 - Dk      */
+                  return (Y);                        /* Y = k4 - Dk      */
                 }
-              if (V <= f(Y, l_my, c_pm))  return(Y); /* final accept of Y*/
+              if (V <= f (Y, l_my, c_pm))  return (Y); /* final accept of Y*/
             }
           X = k4 + Dk;
         }
       else
         {
           W = RUNI;
           if (U < p5)
             {                                        /* expon. tail left */
-              Dk = floor(1.0 - log(W)/ll);
+              Dk = floor (1.0 - log (W)/ll);
               if ((X = k1 - Dk) < 0L)  continue;     /* 0 <= X <= k1 - 1 */
               W *= (U - p4) * ll;                    /* W -- U(0, h(x))  */
               if (W <= f1 - Dk * (f1 - f1/r1))
-                return(X);                           /* quick accept of X*/
+                return (X);                          /* quick accept of X*/
             }
           else
             {                                        /* expon. tail right*/
-              Dk = floor(1.0 - log(W)/lr);
+              Dk = floor (1.0 - log (W)/lr);
               X  = k5 + Dk;                          /* X >= k5 + 1      */
               W *= (U - p5) * lr;                    /* W -- U(0, h(x))  */
               if (W <= f5 - Dk * (f5 - f5*r5))
-                return(X);                           /* quick accept of X*/
+                return (X);                          /* quick accept of X*/
             }
         }
 
       /* acceptance-rejection test of candidate X from the original area */
       /* test, whether  W <= f(k),    with  W = U*h(x)  and  U -- U(0, 1)*/
       /* log f(X) = (X - m)*log(my) - log X! + log m!                    */
-      if (log(W) <= X * l_my - flogfak(X) - c_pm)  return(X);
+      if (log (W) <= X * l_my - flogfak (X) - c_pm)  return (X);
     }
 }
 /* ---- pprsc.c end ------ */
 
 
 /* The remainder of the file is by Paul Kienzle */
 
 /* Given uniform u, find x such that CDF(L,x)==u.  Return x. */
 static void
-poisson_cdf_lookup(double lambda, double *p, size_t n)
+poisson_cdf_lookup (double lambda, double *p, size_t n)
 {
   /* Table size is predicated on the maximum value of lambda
    * we want to store in the table, and the maximum value of
    * returned by the uniform random number generator on [0,1).
    * With lambda==10 and u_max = 1 - 1/(2^32+1), we
    * have poisson_pdf(lambda,36) < 1-u_max.  If instead our
    * generator uses more bits of mantissa or returns a value
    * in the range [0,1], then for lambda==10 we need a table
    * size of 46 instead.  For long doubles, the table size
    * will need to be longer still.  */
 #define TABLESIZE 46
   double t[TABLESIZE];
 
   /* Precompute the table for the u up to and including 0.458.
    * We will almost certainly need it. */
-  int intlambda = (int)floor(lambda);
+  int intlambda = (int)floor (lambda);
   double P;
   int tableidx;
   size_t i = n;
 
-  t[0] = P = exp(-lambda);
+  t[0] = P = exp (-lambda);
   for (tableidx = 1; tableidx <= intlambda; tableidx++) {
     P = P*lambda/(double)tableidx;
     t[tableidx] = t[tableidx-1] + P;
   }
 
   while (i-- > 0) {
     double u = RUNI;
 
@@ -364,28 +364,28 @@ poisson_cdf_lookup(double lambda, double
      * This should be true even if RUNI is returning values in
      * the range [0,1] rather than [0,1).
      */
     p[i] = (double)(tableidx-1);
   }
 }
 
 static void
-poisson_cdf_lookup_float(double lambda, float *p, size_t n)
+poisson_cdf_lookup_float (double lambda, float *p, size_t n)
 {
   double t[TABLESIZE];
 
   /* Precompute the table for the u up to and including 0.458.
    * We will almost certainly need it. */
-  int intlambda = (int)floor(lambda);
+  int intlambda = (int)floor (lambda);
   double P;
   int tableidx;
   size_t i = n;
 
-  t[0] = P = exp(-lambda);
+  t[0] = P = exp (-lambda);
   for (tableidx = 1; tableidx <= intlambda; tableidx++) {
     P = P*lambda/(double)tableidx;
     t[tableidx] = t[tableidx-1] + P;
   }
 
   while (i-- > 0) {
     double u = RUNI;
     int k = (u > 0.458 ? intlambda : 0);
@@ -407,55 +407,55 @@ poisson_cdf_lookup_float(double lambda, 
     p[i] = (float)(tableidx-1);
   }
 }
 
 /* From Press, et al., Numerical Recipes */
 static void
 poisson_rejection (double lambda, double *p, size_t n)
 {
-  double sq = sqrt(2.0*lambda);
-  double alxm = log(lambda);
+  double sq = sqrt (2.0*lambda);
+  double alxm = log (lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
 
   for (i = 0; i < n; i++)
     {
       double y, em, t;
       do {
         do {
           y = tan(M_PI*RUNI);
           em = sq * y + lambda;
         } while (em < 0.0);
-        em = floor(em);
-        t = 0.9*(1.0+y*y)*exp(em*alxm-flogfak(em)-g);
+        em = floor (em);
+        t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
       } while (RUNI > t);
       p[i] = em;
     }
 }
 
 /* From Press, et al., Numerical Recipes */
 static void
 poisson_rejection_float (double lambda, float *p, size_t n)
 {
-  double sq = sqrt(2.0*lambda);
-  double alxm = log(lambda);
+  double sq = sqrt (2.0*lambda);
+  double alxm = log (lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
 
   for (i = 0; i < n; i++)
     {
       double y, em, t;
       do {
         do {
-          y = tan(M_PI*RUNI);
+          y = tan (M_PI*RUNI);
           em = sq * y + lambda;
         } while (em < 0.0);
-        em = floor(em);
-        t = 0.9*(1.0+y*y)*exp(em*alxm-flogfak(em)-g);
+        em = floor (em);
+        t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
       } while (RUNI > t);
       p[i] = em;
     }
 }
 
 /* The cutoff of L <= 1e8 in the following two functions before using
  * the normal approximation is based on:
  *   > L=1e8; x=floor(linspace(0,2*L,1000));
@@ -472,62 +472,62 @@ oct_fill_randp (double L, octave_idx_typ
   octave_idx_type i;
   if (L < 0.0 || INFINITE(L))
     {
       for (i=0; i<n; i++)
         p[i] = NAN;
     }
   else if (L <= 10.0)
     {
-      poisson_cdf_lookup(L, p, n);
+      poisson_cdf_lookup (L, p, n);
     }
   else if (L <= 1e8)
     {
       for (i=0; i<n; i++)
-        p[i] = pprsc(L);
+        p[i] = pprsc (L);
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      const double sqrtL = sqrt(L);
+      const double sqrtL = sqrt (L);
       for (i = 0; i < n; i++)
         {
-          p[i] = floor(RNOR*sqrtL + L + 0.5);
+          p[i] = floor (RNOR*sqrtL + L + 0.5);
           if (p[i] < 0.0)
             p[i] = 0.0; /* will probably never happen */
         }
     }
 }
 
 /* Generate one poisson variate */
 double
 oct_randp (double L)
 {
   double ret;
   if (L < 0.0) ret = NAN;
   else if (L <= 12.0) {
     /* From Press, et al. Numerical recipes */
-    double g = exp(-L);
+    double g = exp (-L);
     int em = -1;
     double t = 1.0;
     do {
       ++em;
       t *= RUNI;
     } while (t > g);
     ret = em;
   } else if (L <= 1e8) {
     /* numerical recipes */
-    poisson_rejection(L, &ret, 1);
+    poisson_rejection (L, &ret, 1);
   } else if (INFINITE(L)) {
     /* FIXME R uses NaN, but the normal approx. suggests that as
      * limit should be inf. Which is correct? */
     ret = NAN;
   } else {
     /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-    ret = floor(RNOR*sqrt(L) + L + 0.5);
+    ret = floor (RNOR*sqrt (L) + L + 0.5);
     if (ret < 0.0) ret = 0.0; /* will probably never happen */
   }
   return ret;
 }
 
 /* Generate a set of poisson numbers with the same distribution */
 void
 oct_fill_float_randp (float FL, octave_idx_type n, float *p)
@@ -536,59 +536,59 @@ oct_fill_float_randp (float FL, octave_i
   octave_idx_type i;
   if (L < 0.0 || INFINITE(L))
     {
       for (i=0; i<n; i++)
         p[i] = NAN;
     }
   else if (L <= 10.0)
     {
-      poisson_cdf_lookup_float(L, p, n);
+      poisson_cdf_lookup_float (L, p, n);
     }
   else if (L <= 1e8)
     {
       for (i=0; i<n; i++)
-        p[i] = pprsc(L);
+        p[i] = pprsc (L);
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      const double sqrtL = sqrt(L);
+      const double sqrtL = sqrt (L);
       for (i = 0; i < n; i++)
         {
-          p[i] = floor(RNOR*sqrtL + L + 0.5);
+          p[i] = floor (RNOR*sqrtL + L + 0.5);
           if (p[i] < 0.0)
             p[i] = 0.0; /* will probably never happen */
         }
     }
 }
 
 /* Generate one poisson variate */
 float
 oct_float_randp (float FL)
 {
   double L = FL;
   float ret;
   if (L < 0.0) ret = NAN;
   else if (L <= 12.0) {
     /* From Press, et al. Numerical recipes */
-    double g = exp(-L);
+    double g = exp (-L);
     int em = -1;
     double t = 1.0;
     do {
       ++em;
       t *= RUNI;
     } while (t > g);
     ret = em;
   } else if (L <= 1e8) {
     /* numerical recipes */
-    poisson_rejection_float(L, &ret, 1);
+    poisson_rejection_float (L, &ret, 1);
   } else if (INFINITE(L)) {
     /* FIXME R uses NaN, but the normal approx. suggests that as
      * limit should be inf. Which is correct? */
     ret = NAN;
   } else {
     /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-    ret = floor(RNOR*sqrt(L) + L + 0.5);
+    ret = floor (RNOR*sqrt (L) + L + 0.5);
     if (ret < 0.0) ret = 0.0; /* will probably never happen */
   }
   return ret;
 }
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -51,34 +51,34 @@ sparse_base_chol<chol_type, chol_elt, p_
   Sp = static_cast<octave_idx_type *>(S->p);
   Si = static_cast<octave_idx_type *>(S->i);
   Sx = static_cast<chol_elt *>(S->x);
   pdest = 0;
   ncol = S->ncol;
 
   for (k = 0; k < ncol; k++)
     {
-      p = Sp [k];
+      p = Sp[k];
       pend = Sp [k+1];
-      Sp [k] = pdest;
+      Sp[k] = pdest;
       for (; p < pend; p++)
         {
-          sik = Sx [p];
+          sik = Sx[p];
           if (CHOLMOD_IS_NONZERO (sik))
             {
               if (p != pdest)
                 {
-                  Si [pdest] = Si [p];
-                  Sx [pdest] = sik;
+                  Si[pdest] = Si[p];
+                  Sx[pdest] = sik;
                 }
               pdest++;
             }
         }
     }
-  Sp [ncol] = pdest;
+  Sp[ncol] = pdest;
 }
 #endif
 
 template <class chol_type, class chol_elt, class p_type>
 octave_idx_type
 sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::init
   (const chol_type& a, bool natural)
 {
@@ -152,17 +152,17 @@ sparse_base_chol<chol_type, chol_elt, p_
     ac->x = &dummy;
   else
     ac->x = a.data ();
 
   // use natural ordering if no q output parameter
   if (natural)
     {
       cm->nmethods = 1 ;
-      cm->method [0].ordering = CHOLMOD_NATURAL ;
+      cm->method[0].ordering = CHOLMOD_NATURAL ;
       cm->postorder = false ;
     }
 
   cholmod_factor *Lfactor;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   Lfactor = CHOLMOD_NAME(analyze) (ac, cm);
   CHOLMOD_NAME(factorize) (ac, Lfactor, cm);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -224,21 +224,21 @@ chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::L (void) const
 {
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L ();
   octave_idx_type nc = m->ncol;
   octave_idx_type nnz = m->nzmax;
   chol_type ret (m->nrow, nc, nnz);
   for (octave_idx_type j = 0; j < nc+1; j++)
-    ret.xcidx(j) = static_cast<octave_idx_type *>(m->p)[j];
+    ret.xcidx (j) = static_cast<octave_idx_type *>(m->p)[j];
   for (octave_idx_type i = 0; i < nnz; i++)
     {
-      ret.xridx(i) = static_cast<octave_idx_type *>(m->i)[i];
-      ret.xdata(i) = static_cast<chol_elt *>(m->x)[i];
+      ret.xridx (i) = static_cast<octave_idx_type *>(m->i)[i];
+      ret.xdata (i) = static_cast<chol_elt *>(m->x)[i];
     }
   return ret;
 #else
   return chol_type ();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
@@ -247,21 +247,21 @@ sparse_base_chol<chol_type, chol_elt, p_
 sparse_base_chol_rep::Q (void) const
 {
 #ifdef HAVE_CHOLMOD
   octave_idx_type n = Lsparse->nrow;
   p_type p (n, n, n);
 
   for (octave_idx_type i = 0; i < n; i++)
     {
-      p.xcidx(i) = i;
-      p.xridx(i) = static_cast<octave_idx_type>(perms(i));
-      p.xdata(i) = 1;
+      p.xcidx (i) = i;
+      p.xridx (i) = static_cast<octave_idx_type>(perms (i));
+      p.xdata (i) = 1;
     }
-  p.xcidx(n) = n;
+  p.xcidx (n) = n;
 
   return p;
 #else
   return p_type ();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
@@ -272,17 +272,17 @@ sparse_base_chol<chol_type, chol_elt, p_
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L ();
   octave_idx_type n = m->ncol;
   ColumnVector perms = rep->perm ();
   chol_type ret;
   double rcond2;
   octave_idx_type info;
   MatrixType mattype (MatrixType::Upper);
-  chol_type linv = L ().hermitian ().inverse(mattype, info, rcond2, 1, 0);
+  chol_type linv = L ().hermitian ().inverse (mattype, info, rcond2, 1, 0);
 
   if (perms.length () == n)
     {
       p_type Qc = Q ();
       retval = Qc * linv * linv.hermitian () * Qc.transpose ();
     }
   else
     retval = linv * linv.hermitian ();
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/sparse-base-lu.cc
--- a/liboctave/sparse-base-lu.cc
+++ b/liboctave/sparse-base-lu.cc
@@ -32,36 +32,36 @@ lu_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Y (void) const
 {
   octave_idx_type nr = Lfact.rows ();
   octave_idx_type nc = Ufact.rows ();
   octave_idx_type rcmin = (nr > nc ? nr : nc);
 
   lu_type Yout (nr, nc, Lfact.nnz () + Ufact.nnz ());
   octave_idx_type ii = 0;
-  Yout.xcidx(0) = 0;
+  Yout.xcidx (0) = 0;
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx(j + 1); i++)
+      for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx (j + 1); i++)
         {
-          Yout.xridx (ii) = Ufact.ridx(i);
-          Yout.xdata (ii++) = Ufact.data(i);
+          Yout.xridx (ii) = Ufact.ridx (i);
+          Yout.xdata (ii++) = Ufact.data (i);
         }
       if (j < rcmin)
         {
           // Note the +1 skips the 1.0 on the diagonal
           for (octave_idx_type i = Lfact.cidx (j) + 1;
-               i < Lfact.cidx(j +1); i++)
+               i < Lfact.cidx (j +1); i++)
             {
-              Yout.xridx (ii) = Lfact.ridx(i);
-              Yout.xdata (ii++) = Lfact.data(i);
+              Yout.xridx (ii) = Lfact.ridx (i);
+              Yout.xdata (ii++) = Lfact.data (i);
             }
         }
-      Yout.xcidx(j + 1) = ii;
+      Yout.xcidx (j + 1) = ii;
     }
 
   return Yout;
 }
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 p_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pr (void) const
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -49,49 +49,49 @@ dmsolve_extract (const MSparse<T> &A, co
   // in the row are in no particular order), even though octave in
   // general can't. For those functions that can using it is a big
   // win here in terms of speed.
   if (lazy)
     {
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
-          octave_idx_type qq = (Q ? Q [j] : j);
+          octave_idx_type qq = (Q ? Q[j] : j);
           B.xcidx (j - cst) = nz;
-          for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
+          for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
               octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
               if (r >= rst && r < rend)
                 {
                   B.xdata (nz) = A.data (p);
-                  B.xridx (nz++) =  r - rst ;
+                  B.xridx (nz++) = r - rst ;
                 }
             }
         }
       B.xcidx (cend - cst) = nz ;
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, X, rend - rst);
       octave_sort<octave_idx_type> sort;
       octave_idx_type *ri = B.xridx ();
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
-          octave_idx_type qq = (Q ? Q [j] : j);
+          octave_idx_type qq = (Q ? Q[j] : j);
           B.xcidx (j - cst) = nz;
-          for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
+          for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
               octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
               if (r >= rst && r < rend)
                 {
                   X [r-rst] = A.data (p);
-                  B.xridx (nz++) =  r - rst ;
+                  B.xridx (nz++) = r - rst ;
                 }
             }
           sort.sort (ri + B.xcidx (j - cst), nz - B.xcidx (j - cst));
           for (octave_idx_type p = B.cidx (j - cst); p < nz; p++)
             B.xdata (p) = X [B.xridx (p)];
         }
       B.xcidx (cend - cst) = nz ;
     }
@@ -192,78 +192,78 @@ dmsolve_insert (MSparse<T> &a, const MSp
 {
   octave_idx_type b_rows = b.rows ();
   octave_idx_type b_cols = b.cols ();
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Qinv, nr);
   for (octave_idx_type i = 0; i < nr; i++)
-    Qinv [Q [i]] = i;
+    Qinv[Q[i]] = i;
 
   // First count the number of elements in the final array
-  octave_idx_type nel = a.xcidx(c) + b.nnz ();
+  octave_idx_type nel = a.xcidx (c) + b.nnz ();
 
   if (c + b_cols < nc)
-    nel += a.xcidx(nc) - a.xcidx(c + b_cols);
+    nel += a.xcidx (nc) - a.xcidx (c + b_cols);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
-    for (octave_idx_type j = a.xcidx(i); j < a.xcidx(i+1); j++)
-      if (Qinv [a.xridx(j)] < r || Qinv [a.xridx(j)] >= r + b_rows)
+    for (octave_idx_type j = a.xcidx (i); j < a.xcidx (i+1); j++)
+      if (Qinv [a.xridx (j)] < r || Qinv [a.xridx (j)] >= r + b_rows)
         nel++;
 
   OCTAVE_LOCAL_BUFFER (T, X, nr);
   octave_sort<octave_idx_type> sort;
   MSparse<T> tmp (a);
   a = MSparse<T> (nr, nc, nel);
   octave_idx_type *ri = a.xridx ();
 
-  for (octave_idx_type i = 0; i < tmp.cidx(c); i++)
+  for (octave_idx_type i = 0; i < tmp.cidx (c); i++)
     {
-      a.xdata(i) = tmp.xdata(i);
-      a.xridx(i) = tmp.xridx(i);
+      a.xdata (i) = tmp.xdata (i);
+      a.xridx (i) = tmp.xridx (i);
     }
   for (octave_idx_type i = 0; i < c + 1; i++)
-    a.xcidx(i) = tmp.xcidx(i);
+    a.xcidx (i) = tmp.xcidx (i);
 
-  octave_idx_type ii = a.xcidx(c);
+  octave_idx_type ii = a.xcidx (c);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     {
       octave_quit ();
 
-      for (octave_idx_type j = tmp.xcidx(i); j < tmp.xcidx(i+1); j++)
-        if (Qinv [tmp.xridx(j)] < r ||  Qinv [tmp.xridx(j)] >= r + b_rows)
+      for (octave_idx_type j = tmp.xcidx (i); j < tmp.xcidx (i+1); j++)
+        if (Qinv [tmp.xridx (j)] < r ||  Qinv [tmp.xridx (j)] >= r + b_rows)
           {
-            X [tmp.xridx(j)] = tmp.xdata(j);
-            a.xridx(ii++) = tmp.xridx(j);
+            X [tmp.xridx (j)] = tmp.xdata (j);
+            a.xridx (ii++) = tmp.xridx (j);
           }
 
       octave_quit ();
 
-      for (octave_idx_type j = b.cidx(i-c); j < b.cidx(i-c+1); j++)
+      for (octave_idx_type j = b.cidx (i-c); j < b.cidx (i-c+1); j++)
         {
-          X [Q [r + b.ridx(j)]] = b.data(j);
-          a.xridx(ii++) = Q [r + b.ridx(j)];
+          X [Q [r + b.ridx (j)]] = b.data (j);
+          a.xridx (ii++) = Q [r + b.ridx (j)];
         }
 
       sort.sort (ri + a.xcidx (i), ii - a.xcidx (i));
       for (octave_idx_type p = a.xcidx (i); p < ii; p++)
         a.xdata (p) = X [a.xridx (p)];
-      a.xcidx(i+1) = ii;
+      a.xcidx (i+1) = ii;
     }
 
   for (octave_idx_type i = c + b_cols; i < nc; i++)
     {
-      for (octave_idx_type j = tmp.xcidx(i); j < tmp.cidx(i+1); j++)
+      for (octave_idx_type j = tmp.xcidx (i); j < tmp.cidx (i+1); j++)
         {
-          a.xdata(ii) = tmp.xdata(j);
-          a.xridx(ii++) = tmp.xridx(j);
+          a.xdata (ii) = tmp.xdata (j);
+          a.xridx (ii++) = tmp.xridx (j);
         }
-      a.xcidx(i+1) = ii;
+      a.xcidx (i+1) = ii;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MSparse<double> &a, const SparseMatrix &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
@@ -282,17 +282,17 @@ dmsolve_permute (MArray<RT> &a, const MA
   a.resize (dim_vector (b_nr, b_nc));
   RT *Btx = a.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       octave_idx_type off = j * b_nr;
       for (octave_idx_type i = 0; i < b_nr; i++)
         {
           octave_quit ();
-          Btx [p [i] + off] = Bx [ i + off];
+          Btx[p[i] + off] = Bx[ i + off];
         }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_permute (MArray<double> &a, const MArray<double>& b,
                  const octave_idx_type *p);
@@ -313,33 +313,33 @@ dmsolve_permute (MSparse<RT> &a, const M
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nz = b.nnz ();
   octave_idx_type nz = 0;
   a = MSparse<RT> (b_nr, b_nc, b_nz);
   octave_sort<octave_idx_type> sort;
   octave_idx_type *ri = a.xridx ();
   OCTAVE_LOCAL_BUFFER (RT, X, b_nr);
-  a.xcidx(0) = 0;
+  a.xcidx (0) = 0;
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
-      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+      for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
         {
           octave_quit ();
-          octave_idx_type r = p [b.ridx (i)];
-          X [r] = b.data (i);
-          a.xridx(nz++) = p [b.ridx (i)];
+          octave_idx_type r = p[b.ridx (i)];
+          X[r] = b.data (i);
+          a.xridx (nz++) = p[b.ridx (i)];
         }
       sort.sort (ri + a.xcidx (j), nz - a.xcidx (j));
       for (octave_idx_type i = a.cidx (j); i < nz; i++)
         {
           octave_quit ();
           a.xdata (i) = X [a.xridx (i)];
         }
-      a.xcidx(j+1) = nz;
+      a.xcidx (j+1) = nz;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_permute (MSparse<double> &a, const MSparse<double>& b,
                  const octave_idx_type *p);
 
@@ -384,93 +384,93 @@ dmsolve (const ST &a, const T &b, octave
       csm.x = 0;
       csm.nz = -1;
       csm.nzmax = a.nnz ();
       // Cast away const on A, with full knowledge that CSparse won't touch it.
       // Prevents the methods below making a copy of the data.
       csm.p = const_cast<octave_idx_type *>(a.cidx ());
       csm.i = const_cast<octave_idx_type *>(a.ridx ());
 
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
       CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm, 0);
       octave_idx_type *p = dm->p;
       octave_idx_type *q = dm->q;
 #else
       CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm);
       octave_idx_type *p = dm->P;
       octave_idx_type *q = dm->Q;
 #endif
       OCTAVE_LOCAL_BUFFER (octave_idx_type, pinv, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        pinv [p [i]] = i;
+        pinv[p[i]] = i;
       RT btmp;
       dmsolve_permute (btmp, b, pinv);
       info = 0;
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
-      if (dm->rr [2] < nr && dm->cc [3] < nc)
+      if (dm->rr[2] < nr && dm->cc[3] < nc)
         {
-          ST m = dmsolve_extract (a, pinv, q, dm->rr [2], nr, dm->cc [3], nc,
+          ST m = dmsolve_extract (a, pinv, q, dm->rr[2], nr, dm->cc[3], nc,
                                   nnz_remaining, true);
           nnz_remaining -= m.nnz ();
           RT mtmp =
             qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
                                          b_nc), info);
-          dmsolve_insert (retval, mtmp, q, dm->cc [3], 0);
-          if (dm->rr [2] > 0 && !info)
+          dmsolve_insert (retval, mtmp, q, dm->cc[3], 0);
+          if (dm->rr[2] > 0 && !info)
             {
-              m = dmsolve_extract (a, pinv, q, 0, dm->rr [2],
-                                   dm->cc [3], nc, nnz_remaining, true);
+              m = dmsolve_extract (a, pinv, q, 0, dm->rr[2],
+                                   dm->cc[3], nc, nnz_remaining, true);
               nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[2], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Structurally non-singular blocks
       // FIXME Should use fine Dulmange-Mendelsohn decomposition here.
-      if (dm->rr [1] < dm->rr [2] && dm->cc [2] < dm->cc [3] && !info)
+      if (dm->rr[1] < dm->rr[2] && dm->cc[2] < dm->cc[3] && !info)
         {
-          ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2],
-                                  dm->cc [2], dm->cc [3], nnz_remaining, false);
+          ST m = dmsolve_extract (a, pinv, q, dm->rr[1], dm->rr[2],
+                                  dm->cc[2], dm->cc[3], nnz_remaining, false);
           nnz_remaining -= m.nnz ();
-          RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr [1], dm->rr [2],
+          RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr[1], dm->rr[2],
                                       0, b_nc);
           double rcond = 0.0;
           MatrixType mtyp (MatrixType::Full);
           RT mtmp = m.solve (mtyp, btmp2, info, rcond,
                              solve_singularity_warning, false);
           if (info != 0)
             {
               info = 0;
               mtmp = qrsolve (m, btmp2, info);
             }
 
-          dmsolve_insert (retval, mtmp, q, dm->cc [2], 0);
-          if (dm->rr [1] > 0 && !info)
+          dmsolve_insert (retval, mtmp, q, dm->cc[2], 0);
+          if (dm->rr[1] > 0 && !info)
             {
-              m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], dm->cc [2],
-                                   dm->cc [3], nnz_remaining, true);
+              m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], dm->cc[2],
+                                   dm->cc[3], nnz_remaining, true);
               nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[1], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Trailing under-determined block
-      if (dm->rr [1] > 0 && dm->cc [2] > 0 && !info)
+      if (dm->rr[1] > 0 && dm->cc[2] > 0 && !info)
         {
-          ST m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], 0,
-                                  dm->cc [2], nnz_remaining, true);
+          ST m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], 0,
+                                  dm->cc[2], nnz_remaining, true);
           RT mtmp =
-            qrsolve (m, dmsolve_extract(btmp, 0, 0, 0, dm->rr [1] , 0,
-                                        b_nc), info);
+            qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1] , 0,
+                                         b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
   return retval;
 #else
   return RT ();
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -49,32 +49,32 @@ string_vector::string_vector (const std:
 
   resize (n);
 
   octave_idx_type i = 0;
 
   for (std::list<std::string>::const_iterator p = lst.begin ();
        p != lst.end ();
        p++)
-    elem(i++) = *p;
+    elem (i++) = *p;
 }
 
 string_vector::string_vector (const std::set<std::string>& lst)
   : Array<std::string> ()
 {
   size_t n = lst.size ();
 
   resize (n);
 
   octave_idx_type i = 0;
 
   for (std::set<std::string>::const_iterator p = lst.begin ();
        p != lst.end ();
        p++)
-    elem(i++) = *p;
+    elem (i++) = *p;
 }
 
 // Create a string vector from a NULL terminated list of C strings.
 
 string_vector::string_vector (const char * const *s)
   : Array<std::string> ()
 {
   octave_idx_type n = 0;
@@ -120,85 +120,85 @@ string_vector::uniq (void)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       octave_idx_type k = 0;
 
       for (octave_idx_type i = 1; i < len; i++)
-        if (elem(i) != elem(k))
+        if (elem (i) != elem (k))
           if (++k != i)
-            elem(k) = elem(i);
+            elem (k) = elem (i);
 
       if (len != ++k)
         resize (k);
     }
 
   return *this;
 }
 
 string_vector&
 string_vector::append (const std::string& s)
 {
   octave_idx_type len = length ();
 
   resize (len + 1);
 
-  elem(len) = s;
+  elem (len) = s;
 
   return *this;
 }
 
 string_vector&
 string_vector::append (const string_vector& sv)
 {
   octave_idx_type len = length ();
   octave_idx_type sv_len = sv.length ();
   octave_idx_type new_len = len + sv_len;
 
   resize (new_len);
 
   for (octave_idx_type i = 0; i < sv_len; i++)
-    elem(len + i) = sv[i];
+    elem (len + i) = sv[i];
 
   return *this;
 }
 
 std::string
 string_vector::join (const std::string& sep) const
 {
   std::string retval;
 
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       octave_idx_type i;
 
       for (i = 0; i < len - 1; i++)
-        retval += elem(i) + sep;
+        retval += elem (i) + sep;
 
-      retval += elem(i);
+      retval += elem (i);
     }
 
   return retval;
 }
 
 char **
 string_vector::c_str_vec (void) const
 {
   octave_idx_type len = length ();
 
   char **retval = new char * [len + 1];
 
-  retval [len] = 0;
+  retval[len] = 0;
 
   for (octave_idx_type i = 0; i < len; i++)
-    retval[i] = strsave (elem(i).c_str ());
+    retval[i] = strsave (elem (i).c_str ());
 
   return retval;
 }
 
 void
 string_vector::delete_c_str_vec (const char * const *v)
 {
   const char * const *p = v;
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -74,17 +74,17 @@ public:
 
   octave_idx_type max_length (void) const
   {
     octave_idx_type n = length ();
     octave_idx_type longest = 0;
 
     for (octave_idx_type i = 0; i < n; i++)
       {
-        octave_idx_type tmp = elem(i).length ();
+        octave_idx_type tmp = elem (i).length ();
 
         if (tmp > longest)
           longest = tmp;
       }
 
     return longest;
   }
 
diff --git a/liboctave/tempnam.c b/liboctave/tempnam.c
--- a/liboctave/tempnam.c
+++ b/liboctave/tempnam.c
@@ -38,22 +38,22 @@ extern char *__stdio_gen_tempname (const
    If not and if DIR is not NULL, that value is checked.  If that fails,
    P_tmpdir is tried and finally "/tmp".  The storage for the filename
    is allocated by `malloc'.  */
 char *
 tempnam (const char *dir, const char *pfx)
 {
   size_t len;
   register char *s;
-  register char *t = __stdio_gen_tempname(dir, pfx, 1, &len, (FILE **) NULL);
+  register char *t = __stdio_gen_tempname (dir, pfx, 1, &len, (FILE **) NULL);
 
   if (t == NULL)
     return NULL;
 
-  s = (char *) malloc(len);
+  s = (char *) malloc (len);
   if (s == NULL)
     return NULL;
 
-  (void) memcpy(s, t, len);
+  (void) memcpy (s, t, len);
   return s;
 }
 
 #endif
diff --git a/liboctave/tempname.c b/liboctave/tempname.c
--- a/liboctave/tempname.c
+++ b/liboctave/tempname.c
@@ -107,24 +107,24 @@ char *
   size_t *idx;
   static char buf[FILENAME_MAX];
   static pid_t oldpid = (pid_t) 0;
   pid_t pid = getpid ();
   register size_t len, plen, dlen;
 
   if (dir_search)
     {
-      register const char *d = getenv("TMPDIR");
-      if (d != NULL && !diraccess(d))
+      register const char *d = getenv ("TMPDIR");
+      if (d != NULL && !diraccess (d))
         d = NULL;
-      if (d == NULL && dir != NULL && diraccess(dir))
+      if (d == NULL && dir != NULL && diraccess (dir))
         d = dir;
-      if (d == NULL && diraccess(tmpdir))
+      if (d == NULL && diraccess (tmpdir))
         d = tmpdir;
-      if (d == NULL && diraccess("/tmp"))
+      if (d == NULL && diraccess ("/tmp"))
         d = "/tmp";
       if (d == NULL)
         {
           errno = ENOENT;
           return NULL;
         }
       dir = d;
     }
@@ -134,24 +134,24 @@ char *
   dlen = strlen (dir);
 
   /* Remove trailing slashes from the directory name.  */
   while (dlen > 1 && dir[dlen - 1] == '/')
     --dlen;
 
   if (pfx != NULL && *pfx != '\0')
     {
-      plen = strlen(pfx);
+      plen = strlen (pfx);
       if (plen > 5)
         plen = 5;
     }
   else
     plen = 0;
 
-  if (dir != tmpdir && !strcmp(dir, tmpdir))
+  if (dir != tmpdir && !strcmp (dir, tmpdir))
     dir = tmpdir;
   idx = &indices[(plen == 0 && dir == tmpdir) ? 1 : 0];
 
   if (pid != oldpid)
     {
       oldpid = pid;
       indices[0] = indices[1] = 0;
     }
