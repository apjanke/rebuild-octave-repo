# HG changeset patch
# User jwe
# Date 947831664 0
#      Fri Jan 14 06:34:24 2000 +0000
# Node ID 2e06c3941943e9615b3decc7f1ac1a6897744095
# Parent  3c609681b2bf8808e176a4e712fac86276a0185c
[project @ 2000-01-14 06:33:18 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,25 @@
+2000-01-14  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* control/system/__abcddims__.m: Rename from
+	control/system/abcddims.m, change all callers.
+	* control/base/__bodquist__.m: Likewise.
+	* control/base/__freqresp__.m: Likewise.
+	* control/util/__outlist__.m: Likewise.
+	* control/base/__stepimp__.m: Likewise.
+	* control/system/__syschnamesl__.m: Likewise.
+	* control/system/__syscont_disc__.m: Likewise.
+	* control/system/__sysdefioname__.m: Likewise.
+	* control/system/__sysdefstname__.m: Likewise.
+	* control/system/__sysgroupn__.m: Likewise.
+	* control/system/__tf2sysl__.m: Likewise.
+	* control/util/__zgpbal__.m: Likewise.
+	* control/system/__zp2ssg2__.m: Likewise.
+
 2000-01-13  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* control/base/Makefile.in: Ditto.
 	* control/hinf/Makefile.in: New file.
 	* control/marsyas/Makefile.in: Ditto.
 	* control/obsolete/Makefile.in: Ditto.
 	* control/system/Makefile.in: Ditto.
 	* control/util/Makefile.in: Ditto.
diff --git a/scripts/control/base/__bodquist__.m b/scripts/control/base/__bodquist__.m
--- a/scripts/control/base/__bodquist__.m
+++ b/scripts/control/base/__bodquist__.m
@@ -12,62 +12,62 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{f}, @var{w}] =} bodquist (@var{sys}, @var{w}, @var{out_idx}, @var{in_idx})
+## @deftypefn {Function File} {[@var{f}, @var{w}] =} __bodquist__ (@var{sys}, @var{w}, @var{out_idx}, @var{in_idx})
 ## used internally by bode, nyquist; compute system frequency response.
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## input system structure
 ## @item w
 ## range of frequencies; empty if user wants default
 ## @item out_idx
 ## list of outputs; empty if user wants all
 ## @item in_idx
 ## list of inputs; empty if user wants all
 ## @item rname
-## name of routine that called bodquist ("bode" or "nyquist")
+## name of routine that called __bodquist__ ("bode" or "nyquist")
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item w
 ## list of frequencies
 ## @item f
 ## frequency response of sys; @math{f(ii) = f(omega(ii))}
 ## @end table
-## @strong{Note} bodquist could easily be incorporated into a Nichols
+## @strong{Note} __bodquist__ could easily be incorporated into a Nichols
 ## plot function; this is in a "to do" list.
 ##
 ## Both bode and nyquist share the same introduction, so the common parts are
-## in bodquist.  It contains the part that finds the number of arguments,
+## in __bodquist__.  It contains the part that finds the number of arguments,
 ## determines whether or not the system is SISO, and computes the frequency
 ## response.  Only the way the response is plotted is different between the
 ## two functions.
 ## @end deftypefn
 
-function [f, w] = bodquist (sys, w, outputs, inputs, rname)
+function [f, w] = __bodquist__ (sys, w, outputs, inputs, rname)
 
   ## check number of input arguments given
   if (nargin != 5)
-    usage("[f,w] = bodquist(sys,w,outputs,inputs,rname)");
+    usage ("[f, w] = __bodquist__ (sys, w, outputs, inputs, rname)");
   endif
 
   ## check each argument to see if it's in the correct form
   if (!is_struct(sys))
     error("sys must be a system data structure");
   endif
 
-  ## let freqresp determine w if it's not already given
+  ## let __freqresp__ determine w if it's not already given
   USEW = freqchkw(w);
 
   ## get initial dimensions (revised below if sysprune is called)
   [nn,nz,mm,pp ] = sysdimensions(sys);
 
   ## check for an output vector and to see whether it`s correct
   if (!isempty(outputs))
     if (isempty(inputs))
@@ -81,17 +81,17 @@ function [f, w] = bodquist (sys, w, outp
   ## for speed in computation, convert local copy of
   ## SISO state space systems to zero-pole  form
   if( is_siso(sys) & strcmp( sysgettype(sys), "ss") )
     [zer,pol,k,tsam,inname,outname] = sys2zp(sys);
     sys = zp2sys(zer,pol,k,tsam,inname,outname);
   endif
 
   ## get system frequency response
-  [f,w] = freqresp(sys,USEW,w);
+  [f, w] = __freqresp__ (sys, USEW, w);
 
   phase = arg(f)*180.0/pi;
 
   if(!USEW)
     ## smooth plots
     pcnt = 5;           # max number of refinement steps
     dphase = 5;         # desired max change in phase
     dmag = 0.2;         # desired max change in magnitude
@@ -127,21 +127,22 @@ function [f, w] = bodquist (sys, w, outp
         endfor
         wnew = vec(wseg)'; # make a row vector
         wnew = wnew(find(wnew != 0));
         wnew = sort(wnew);
         wnew = create_set(wnew);
         if(isempty(wnew))   # all small crossovers
           pcnt = 0;
         else
-          [fnew,wnew] = freqresp(sys,1,wnew);    # get new freq resp points
-          w = [w,wnew];                 # combine with old freq resp
-          f = [f,fnew];
-          [w,idx] = sort(w);            # sort into order
-          f = f(idx);
+	  ## get new freq resp points, combine with old, and sort.
+          [fnew, wnew] = __freqresp__ (sys, 1, wnew);
+          w = [w, wnew];
+          f = [f, fnew];
+          [w, idx] = sort (w);
+          f = f (idx);
           phase = arg(f)*180.0/pi;
         endif
       endif
     endwhile
   endif
 
   ## ensure unique frequency values
   [w,idx] = sort(w);
diff --git a/scripts/control/base/__freqresp__.m b/scripts/control/base/__freqresp__.m
--- a/scripts/control/base/__freqresp__.m
+++ b/scripts/control/base/__freqresp__.m
@@ -12,17 +12,17 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{out} =} freqresp (@var{sys}, @var{USEW}@{,@var{w}@});
+## @deftypefn {Function File} {@var{out} =} __freqresp__ (@var{sys}, @var{USEW}@{,@var{w}@});
 ## Frequency response function - used internally by @code{bode}, @code{nyquist}.
 ## minimal argument checking; "do not attempt to do this at home"
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item sys
 ## system data structure
 ## @item USEW
@@ -37,31 +37,31 @@
 ## @item w
 ## vector of corresponding frequencies
 ## @end table
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 11, 1994
 
-function [ff, w] = freqresp (sys, USEW, w);
+function [ff, w] = __freqresp__ (sys, USEW, w);
 
   ## SYS_INTERNAL accesses members of system data structure
 
   save_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   ## Check Args
-  if( (nargin < 2) || (nargin > 4) )
-    usage ("[ff,w] = freqresp(sys,USEW{,w})");
-  elseif( USEW & (nargin < 3) )
-    error("USEW=1 but w was not passed.");
-  elseif( USEW & isempty(w))
-    warning("USEW=1 but w is empty; setting USEW=0");
-    USEW=0;
+  if ((nargin < 2) || (nargin > 4))
+    usage ("[ff, w] = __freqresp__ (sys, USEW, w)");
+  elseif (USEW & (nargin < 3) )
+    error ("USEW = 1 but w was not passed.");
+  elseif (USEW & isempty(w))
+    warning("USEW = 1 but w is empty; setting USEW=0");
+    USEW = 0;
   endif
 
   DIGITAL = is_digital(sys);
 
   ## compute default w if needed
   if(!USEW)
     if(is_siso(sys))
       sys = sysupdate(sys,"zp");
diff --git a/scripts/control/base/__stepimp__.m b/scripts/control/base/__stepimp__.m
--- a/scripts/control/base/__stepimp__.m
+++ b/scripts/control/base/__stepimp__.m
@@ -12,38 +12,38 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{y}, @var{t}] = } stepimp (@var{sitype}, @var{sys} [, @var{inp}, @var{tstop}, @var{n}])
+## @deftypefn {Function File} {[@var{y}, @var{t}] = } __stepimp__ (@var{sitype}, @var{sys} [, @var{inp}, @var{tstop}, @var{n}])
 ## Impulse or step response for a linear system.
 ## The system can be discrete or multivariable (or both).
 ## This m-file contains the "common code" of step and impulse.
 ##
 ## Produces a plot or the response data for system sys.
 ##
 ## Limited argument checking; "do not attempt to do this at home".
 ## Used internally in @code{impulse}, @code{step}. Use @code{step}
 ## or @code{impulse} instead.
 ## @end deftypefn
 ## @seealso{step and impulse}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 
-function [y, t] = stepimp (sitype, sys, inp, tstop, n)
+function [y, t] = __stepimp__ (sitype, sys, inp, tstop, n)
 
   if (sitype == 1)         IMPULSE = 0;
   elseif (sitype == 2)     IMPULSE = 1;
-  else                     error("stepimp: invalid sitype argument.")
+  else                     error("__stepimp__: invalid sitype argument.")
   endif
   sys = sysupdate(sys,"ss");
 
   USE_DEF = 0;   # default tstop and n if we have to give up
   N_MIN = 50;    # minimum number of points
   N_MAX = 2000;  # maximum number of points
   T_DEF = 10.0;  # default simulation time
 
@@ -54,17 +54,17 @@ function [y, t] = stepimp (sitype, sys, 
   if (nargin < 3)                      inp = 1;
   elseif (inp < 1 | inp > NIN)         error("Argument inp out of range")
   endif
 
   DIGITAL = is_digital(sys);
   if (DIGITAL)
     NSTATES = ndstates;
     if (TSAMPLE < eps)
-      error("stepimp: sampling time of discrete system too small.")
+      error("__stepimp__: sampling time of discrete system too small.")
     endif
   else        NSTATES = ncstates;       endif
   if (NSTATES < 1)
     error("step: pure gain block (n_states < 1), step response is trivial");
   endif
   if (nargin < 5)
     ## we have to compute the time when the system reaches steady state
     ## and the step size
@@ -105,17 +105,17 @@ function [y, t] = stepimp (sitype, sys, 
     endif
   endif
 
   if (DIGITAL)
     ## ---- sampled system
     if (nargin == 5)
       n = round(n);
       if (n < 2)
-        error("stepimp: n must not be less than 2.")
+        error("__stepimp__: n must not be less than 2.")
       endif
     else
       if (nargin == 4)
         ## n is unknown
       elseif (nargin >= 1)
         ## tstop and n are unknown
         if (USE_DEF)
           tstop = (N_MIN - 1) * TSAMPLE;
diff --git a/scripts/control/base/bode.m b/scripts/control/base/bode.m
--- a/scripts/control/base/bode.m
+++ b/scripts/control/base/bode.m
@@ -36,17 +36,17 @@
 ## @itemize @bullet
 ## @item @var{T}=@code{sysgettsam(@var{sys})} (the system sampling time) and
 ## @item @math{G(z)} is the system transfer function.
 ## @end itemize
 ##
 ## @strong{ Default} the default frequency range is selected as follows: (These
 ## steps are NOT performed if @var{w} is specified)
 ## @enumerate
-## @item via routine bodquist, isolate all poles and zeros away from
+## @item via routine __bodquist__, isolate all poles and zeros away from
 ## @var{w}=0 (@var{jw}=0 or @math{@code{exp}(jwT)}=1) and select the frequency
 ## range based on the breakpoint locations of the frequencies.
 ## @item if @var{sys} is discrete time, the frequency range is limited
 ##               to @math{jwT} in
 ## @ifinfo
 ## [0,2 pi /T]
 ## @end ifinfo
 ## @iftex
@@ -121,17 +121,17 @@ function [mag_r, phase_r, w_r] = bode (s
   if (strcmp (plot_style, "dB"))
     do_db_plot = 1;
   elseif (strcmp (plot_style, "mag"))
     do_db_plot = 0;
   else
     error ("bode: invalid value of plot_style specified");
   endif
 
-  [f, w] = bodquist(sys,w,outputs,inputs,"bode");
+  [f, w] = __bodquist__ (sys, w, outputs, inputs, "bode");
 
   [stname,inname,outname] = sysgetsignals(sys);
   systsam = sysgettsam(sys);
 
   ## Get the magnitude and phase of f.
   mag = abs(f);
   phase = arg(f)*180.0/pi;
 
@@ -157,19 +157,19 @@ function [mag_r, phase_r, w_r] = bode (s
     if(is_siso(sys))
       if (gnuplot_has_multiplot)
         subplot(2,1,1);
       endif
       title(["|[Y/U]",tistr,"|, u=", nth(inname,1),", y=",nth(outname,1)]);
     else
       title([ "||Y(", tistr, ")/U(", tistr, ")||"]);
       disp("MIMO plot from")
-      disp(outlist(inname,"     "));
+      disp(__outlist__(inname,"     "));
       disp("to")
-      disp(outlist(outname,"    "));
+      disp(__outlist__(outname,"    "));
     endif
     wv = [min(w), max(w)];
     if(do_db_plot && max(mag) > 0)
       ylabel("Gain in dB");
       md = 20*log10(mag);
       axvec = axis2dlim([vec(w),vec(md)]);
       axvec(1:2) = wv;
       axis(axvec);
diff --git a/scripts/control/base/bode_bounds.m b/scripts/control/base/bode_bounds.m
--- a/scripts/control/base/bode_bounds.m
+++ b/scripts/control/base/bode_bounds.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{wmin}, @var{wmax}] =} bode_bounds (@var{zer}, @var{pol}, @var{dflg}@{, @var{tsam} @})
 ## Get default range of frequencies based on cutoff frequencies of system
 ## poles and zeros.
 ## Frequency range is the interval [10^wmin,10^wmax]
 ##
-## Used internally in freqresp (@code{bode}, @code{nyquist})
+## Used internally in __freqresp__ (@code{bode}, @code{nyquist})
 ## @end deftypefn
 
 function [wmin, wmax] = bode_bounds (zer, pol, DIGITAL, tsam)
 
   ## make sure zer,pol are row vectors
   if(!isempty(pol)) pol = reshape(pol,1,length(pol)); endif
   if(!isempty(zer)) zer = reshape(zer,1,length(zer)); endif
 
diff --git a/scripts/control/base/bodquist.m b/scripts/control/base/bodquist.m
deleted file mode 100644
--- a/scripts/control/base/bodquist.m
+++ /dev/null
@@ -1,156 +0,0 @@
-## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{f}, @var{w}] =} bodquist (@var{sys}, @var{w}, @var{out_idx}, @var{in_idx})
-## used internally by bode, nyquist; compute system frequency response.
-##
-## @strong{Inputs}
-## @table @var
-## @item sys
-## input system structure
-## @item w
-## range of frequencies; empty if user wants default
-## @item out_idx
-## list of outputs; empty if user wants all
-## @item in_idx
-## list of inputs; empty if user wants all
-## @item rname
-## name of routine that called bodquist ("bode" or "nyquist")
-## @end table
-## @strong{Outputs}
-## @table @var
-## @item w
-## list of frequencies
-## @item f
-## frequency response of sys; @math{f(ii) = f(omega(ii))}
-## @end table
-## @strong{Note} bodquist could easily be incorporated into a Nichols
-## plot function; this is in a "to do" list.
-##
-## Both bode and nyquist share the same introduction, so the common parts are
-## in bodquist.  It contains the part that finds the number of arguments,
-## determines whether or not the system is SISO, and computes the frequency
-## response.  Only the way the response is plotted is different between the
-## two functions.
-## @end deftypefn
-
-function [f, w] = bodquist (sys, w, outputs, inputs, rname)
-
-  ## check number of input arguments given
-  if (nargin != 5)
-    usage("[f,w] = bodquist(sys,w,outputs,inputs,rname)");
-  endif
-
-  ## check each argument to see if it's in the correct form
-  if (!is_struct(sys))
-    error("sys must be a system data structure");
-  endif
-
-  ## let freqresp determine w if it's not already given
-  USEW = freqchkw(w);
-
-  ## get initial dimensions (revised below if sysprune is called)
-  [nn,nz,mm,pp ] = sysdimensions(sys);
-
-  ## check for an output vector and to see whether it`s correct
-  if (!isempty(outputs))
-    if (isempty(inputs))
-      inputs = 1:mm;                    # use all inputs
-      warning([rname,": outputs specified but not inputs"]);
-    endif
-    sys = sysprune(sys,outputs,inputs);
-    [nn,nz,mm,pp ] = sysdimensions(sys);
-  endif
-
-  ## for speed in computation, convert local copy of
-  ## SISO state space systems to zero-pole  form
-  if( is_siso(sys) & strcmp( sysgettype(sys), "ss") )
-    [zer,pol,k,tsam,inname,outname] = sys2zp(sys);
-    sys = zp2sys(zer,pol,k,tsam,inname,outname);
-  endif
-
-  ## get system frequency response
-  [f,w] = freqresp(sys,USEW,w);
-
-  phase = arg(f)*180.0/pi;
-
-  if(!USEW)
-    ## smooth plots
-    pcnt = 5;           # max number of refinement steps
-    dphase = 5;         # desired max change in phase
-    dmag = 0.2;         # desired max change in magnitude
-    while(pcnt)
-      pd = abs(diff(phase));                    # phase variation
-      pdbig = vec(find(pd > dphase));
-
-      lp = length(f);  lp1 = lp-1;              # relative variation
-      fd = abs(diff(f));
-      fm = max(abs([f(1:lp1); f(2:lp)]));
-      fdbig = vec(find(fd > fm/10));
-
-      bigpts = union(fdbig, pdbig);
-
-      if(isempty(bigpts) )
-        pcnt = 0;
-      else
-        pcnt = pcnt - 1;
-        wnew = [];
-        crossover_points = find ( phase(1:lp1).*phase(2:lp) < 0);
-        pd(crossover_points) = abs(359.99+dphase - pd(crossover_points));
-        np_pts = max(3,ceil(pd/dphase)+2);              # phase points
-        nm_pts = max(3,ceil(log(fd./fm)/log(dmag))+2);  # magnitude points
-        npts = min(5,max(np_pts, nm_pts));
-
-        w1 = log10(w(1:lp1));
-        w2 = log10(w(2:lp));
-        for ii=bigpts
-          if(npts(ii))
-            wtmp = logspace(w1(ii),w2(ii),npts(ii));
-            wseg(ii,1:(npts(ii)-2)) = wtmp(2:(npts(ii)-1));
-          endif
-        endfor
-        wnew = vec(wseg)'; # make a row vector
-        wnew = wnew(find(wnew != 0));
-        wnew = sort(wnew);
-        wnew = create_set(wnew);
-        if(isempty(wnew))   # all small crossovers
-          pcnt = 0;
-        else
-          [fnew,wnew] = freqresp(sys,1,wnew);    # get new freq resp points
-          w = [w,wnew];                 # combine with old freq resp
-          f = [f,fnew];
-          [w,idx] = sort(w);            # sort into order
-          f = f(idx);
-          phase = arg(f)*180.0/pi;
-        endif
-      endif
-    endwhile
-  endif
-
-  ## ensure unique frequency values
-  [w,idx] = sort(w);
-  f = f(idx);
-
-  w_diff = diff(w);
-  w_dup = find(w_diff == 0);
-  w_idx = complement(w_dup,1:length(w));
-  w = w(w_idx);
-  f = f(w_idx);
-
-endfunction
diff --git a/scripts/control/base/frdemo.m b/scripts/control/base/frdemo.m
--- a/scripts/control/base/frdemo.m
+++ b/scripts/control/base/frdemo.m
@@ -132,17 +132,17 @@ function frdemo ()
           cmd = "sys2 = syssetsignals(sys2,\"out\",\"y_sys2\");";
           disp(cmd);  eval(cmd);
           cmd = "sys2 = syssetsignals(sys2,\"in\",\"u_sys2\");";
           disp(cmd);  eval(cmd);
           cmd = "nn = sysdimensions(sys2);";
           disp(cmd);  eval(cmd);
           cmd = "[nn,nz] = sysdimensions(sys2);";
           disp(cmd);  eval(cmd);
-          cmd = "sys2 = syssetsignals(sys2,\"st\",sysdefioname(nn+nz,\"x_sys2\"));";
+          cmd = "sys2 = syssetsignals(sys2,\"st\",__sysdefioname__(nn+nz,\"x_sys2\"));";
           disp(cmd);  eval(cmd);
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
           disp(cmd); eval(cmd);
           disp("The resulting state-space system (after changing signal names");
           disp("in sys2) is");
           cmd = "sysout(sys_mimo)";
           eval(cmd);
           disp("\nNotice that there are now 2 inputs and 2 outputs, and that it did");
@@ -263,17 +263,17 @@ function frdemo ()
           disp("\nExample #4, We will now examine a MIMO state-space system.  Systems");
           disp("two and three will be grouped.");
           cmd = "[nn,nz] = sysdimensions(sys2);";
           disp(cmd); eval(cmd);
           cmd = "sys2 = syssetsignals(sys2,\"out\",\"y_sys2\");";
           disp(cmd); eval(cmd);
           cmd = "sys2 = syssetsignals(sys2,\"in\",\"u_sys2\");";
           disp(cmd); eval(cmd);
-          cmd = "sys2 = syssetsignals(sys2,\"st\",sysdefioname(nn+nz,\"x_sys2\"));";
+          cmd = "sys2 = syssetsignals(sys2,\"st\",__sysdefioname__(nn+nz,\"x_sys2\"));";
           disp(cmd); eval(cmd);
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
           disp(cmd); eval(cmd);
           cmd = "sysout(sys_mimo);";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's bode plots, execute the following command:\n")
           cmd = "bode(sys_mimo);";
@@ -414,17 +414,17 @@ function frdemo ()
           disp("an equal number of inputs and outputs.  Otherwise, nyquist returns");
           disp("an error.  To examine a MIMO system, systems 2 and 3 will be grouped");
           cmd = "[nn,nz] = sysdimensions(sys2);";
           disp(cmd); eval(cmd);
           cmd = "sys2 = syssetsignals(sys2,\"out\",\"y_sys2\");";
           disp(cmd); eval(cmd);
           cmd = "sys2 = syssetsignals(sys2,\"in\",\"u_sys2\");";
           disp(cmd); eval(cmd);
-          cmd = "sys2 = syssetsignals(sys2,\"st\",sysdefioname(nn+nz,\"x_sys2\"));";
+          cmd = "sys2 = syssetsignals(sys2,\"st\",__sysdefioname__(nn+nz,\"x_sys2\"));";
           disp(cmd); eval(cmd);
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
           disp(cmd); eval(cmd);
           cmd = "sysout(sys_mimo);";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's nyquist plot, execute the following command:\n")
           cmd = "nyquist(sys_mimo);";
diff --git a/scripts/control/base/freqchkw.m b/scripts/control/base/freqchkw.m
--- a/scripts/control/base/freqchkw.m
+++ b/scripts/control/base/freqchkw.m
@@ -13,17 +13,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{retval} =} freqchkw (@var{w})
-## Used by @code{freqresp} to check that input frequency vector @var{w}
+## Used by @code{__freqresp__} to check that input frequency vector @var{w}
 ## is valid.
 ## Returns boolean value.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996
 
 function USEW = freqchkw (w)
diff --git a/scripts/control/base/freqresp.m b/scripts/control/base/freqresp.m
deleted file mode 100644
--- a/scripts/control/base/freqresp.m
+++ /dev/null
@@ -1,133 +0,0 @@
-## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{out} =} freqresp (@var{sys}, @var{USEW}@{,@var{w}@});
-## Frequency response function - used internally by @code{bode}, @code{nyquist}.
-## minimal argument checking; "do not attempt to do this at home"
-##
-## @strong{Inputs}
-## @table @var
-## @item sys
-## system data structure
-## @item USEW
-## returned by @code{freqchkw}
-## @item optional
-## must be present if @var{USEW} is true (nonzero)
-## @end table
-## @strong{Outputs}
-## @table @var
-## @item @var{out}
-## vector of finite @math{G(j*w)} entries (or @math{||G(j*w)||} for MIMO)
-## @item w
-## vector of corresponding frequencies
-## @end table
-## @end deftypefn
-
-## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
-## Created: July 11, 1994
-
-function [ff, w] = freqresp (sys, USEW, w);
-
-  ## SYS_INTERNAL accesses members of system data structure
-
-  save_val = empty_list_elements_ok;
-  empty_list_elements_ok = 1;
-
-  ## Check Args
-  if( (nargin < 2) || (nargin > 4) )
-    usage ("[ff,w] = freqresp(sys,USEW{,w})");
-  elseif( USEW & (nargin < 3) )
-    error("USEW=1 but w was not passed.");
-  elseif( USEW & isempty(w))
-    warning("USEW=1 but w is empty; setting USEW=0");
-    USEW=0;
-  endif
-
-  DIGITAL = is_digital(sys);
-
-  ## compute default w if needed
-  if(!USEW)
-    if(is_siso(sys))
-      sys = sysupdate(sys,"zp");
-      [zer,pol] = sys2zp(sys);
-    else
-      zer = tzero(sys);
-      pol = eig(sys2ss(sys));
-    endif
-
-    ## get default frequency range
-    [wmin,wmax] = bode_bounds(zer,pol,DIGITAL,sysgettsam(sys));
-    w = logspace(wmin,wmax,50);
-  else
-    w = reshape(w,1,length(w));         # make sure it's a row vector
-  endif
-
-  ## now get complex values of s or z
-  if(DIGITAL)
-    jw = exp(i*w*sysgettsam(sys));
-  else
-    jw = i*w;
-  endif
-
-  [nn,nz,mm,pp] = sysdimensions(sys);
-
-  ## now compute the frequency response - divide by zero yields a warning
-  if (strcmp(sysgettype(sys),"zp"))
-    ## zero-pole form (preferred)
-    [zer,pol,sysk] = sys2zp(sys);
-    ff = ones(size(jw));
-    l1 = min(length(zer)*(1-isempty(zer)),length(pol)*(1-isempty(pol)));
-    for ii=1:l1
-      ff = ff .* (jw - zer(ii)) ./ (jw - pol(ii));
-    endfor
-
-    ## require proper  transfer function, so now just get poles.
-    for ii=(l1+1):length(pol)
-      ff = ff ./ (jw - pol(ii));
-    endfor
-    ff = ff*sysk;
-
-  elseif (strcmp(sysgettype(sys),"tf"))
-    ## transfer function form
-    [num,den] = sys2tf(sys);
-    ff = polyval(num,jw)./polyval(den,jw);
-  elseif (mm==pp)
-    ## The system is square; do state-space form bode plot
-    [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
-    n = sysn + sysnz;
-    for ii=1:length(jw);
-      ff(ii) = det(sysc*((jw(ii).*eye(n)-sysa)\sysb)+sysd);
-    endfor;
-  else
-    ## Must be state space... bode
-    [sysa,sysb,sysc,sysd,tsam,sysn,sysnz] = sys2ss(sys);
-    n = sysn + sysnz;
-    for ii=1:length(jw);
-      ff(ii) = norm(sysc*((jw(ii)*eye(n)-sysa)\sysb)+sysd);
-    endfor
-
-  endif
-
-  w = reshape(w,1,length(w));
-  ff = reshape(ff,1,length(ff));
-
-  ## restore global variable
-  empty_list_elements_ok = save_val;
-endfunction
-
diff --git a/scripts/control/base/impulse.m b/scripts/control/base/impulse.m
--- a/scripts/control/base/impulse.m
+++ b/scripts/control/base/impulse.m
@@ -36,54 +36,54 @@
 ## the number of data values.
 ##
 ## Both parameters @var{tstop} and @var{n} can be omitted and will be
 ## computed from the eigenvalues of the A-Matrix.
 ## @end table
 ## @strong{Outputs}
 ## @var{y}, @var{t}: impulse response
 ## @end deftypefn
-## @seealso{step and stepimp}
+## @seealso{step and __stepimp__}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 ## modified by
 
 function [y, t] = impulse (sys, inp, tstop, n)
 
-  if((nargin < 1) || (nargin > 4))
-    usage("[y, u] = impulse(sys[, inp, tstop, n])");
+  if ((nargin < 1) || (nargin > 4))
+    usage ("[y, u] = impulse (sys, inp, tstop, n)");
   endif
 
-  if(nargout > 2)
-    usage("[y, u] = impulse(sys[, inp, tstop, n])");
+  if (nargout > 2)
+    usage ("[y, u] = impulse (sys, inp, tstop, n)");
   endif
 
-  if(!is_struct(sys))
-    error("impulse: sys must be a system data structure.");
+  if (! is_struct (sys))
+    error ("impulse: sys must be a system data structure.");
   endif
 
   if (nargout == 0)
     switch (nargin)
       case (1)
-        stepimp(2, sys);
+        __stepimp__ (2, sys);
       case (2)
-        stepimp(2, sys, inp);
+        __stepimp__ (2, sys, inp);
       case (3)
-        stepimp(2, sys, inp, tstop);
+        __stepimp__ (2, sys, inp, tstop);
       case (4)
-        stepimp(2, sys, inp, tstop, n);
+        __stepimp__ (2, sys, inp, tstop, n);
     endswitch
   else
     switch (nargin)
       case (1)
-        [y, t] = stepimp(2, sys);
+        [y, t] = __stepimp__ (2, sys);
       case (2)
-        [y, t] = stepimp(2, sys, inp);
+        [y, t] = __stepimp__ (2, sys, inp);
       case (3)
-        [y, t] = stepimp(2, sys, inp, tstop);
+        [y, t] = __stepimp__ (2, sys, inp, tstop);
       case (4)
-        [y, t] = stepimp(2, sys, inp, tstop, n);
+        [y, t] = __stepimp__ (2, sys, inp, tstop, n);
     endswitch
   endif
 
 endfunction
diff --git a/scripts/control/base/nichols.m b/scripts/control/base/nichols.m
--- a/scripts/control/base/nichols.m
+++ b/scripts/control/base/nichols.m
@@ -24,17 +24,17 @@
 ##   sys: system data structure (must be either purely continuous or discrete;
 ##       see is_digital)
 ##   w: frequency values for evaluation.
 ##      if sys is continuous, then nichols evaluates G(jw)
 ##      if sys is discrete, then nichols evaluates G(exp(jwT)), where T=sys.tsam
 ##         (the system sampling time)
 ##      default: the default frequency range is selected as follows: (These
 ##        steps are NOT performed if w is specified)
-##          (1) via routine bodquist, isolate all poles and zeros away from
+##          (1) via routine __bodquist__, isolate all poles and zeros away from
 ##              w=0 (jw=0 or exp(jwT)=1) and select the frequency
 ##             range based on the breakpoint locations of the frequencies.
 ##          (2) if sys is discrete time, the frequency range is limited
 ##              to jwT in [0,2p*pi]
 ##          (3) A "smoothing" routine is used to ensure that the plot phase does
 ##              not change excessively from point to point and that singular
 ##              points (e.g., crossovers from +/- 180) are accurately shown.
 ##   outputs, inputs: the indices of the output(s) and input(s) to be used in
@@ -61,17 +61,17 @@ function [mag, phase, w] = nichols (sys,
   endif
   if(nargin < 3)
     outputs = [];
   endif
   if(nargin < 4)
     inputs = [];
   endif
 
-  [f, w] = bodquist(sys,w,outputs,inputs,"nichols");
+  [f, w] = __bodquist__ (sys, w, outputs, inputs, "nichols");
 
   [stname,inname,outname] = sysgetsignals(sys);
   systsam = sysgettsam(sys);
 
   ## Get the magnitude and phase of f.
   mag = abs(f);
   phase = arg(f)*180.0/pi;
 
@@ -93,18 +93,18 @@ function [mag, phase, w] = nichols (sys,
       tistr = "(jw)";
     endif
     xlabel("Phase (deg)");
     if(is_siso(sys))
       title(["Nichols plot of |[Y/U]",tistr,"|, u=", ...
         sysgetsignals(sys,"in",1,1), ", y=",sysgetsignals(sys,"out",1,1)]);
     else
       title([ "||Y(", tistr, ")/U(", tistr, ")||"]);
-      printf("MIMO plot from\n%s\nto\n%s\n",outlist(inname,"    "), ...
-        outlist(outname,"       "));
+      printf("MIMO plot from\n%s\nto\n%s\n",__outlist__(inname,"    "), ...
+        __outlist__(outname,"       "));
     endif
     if(max(mag) > 0)
       ylabel("Gain in dB");
       md = 20*log10(mag);
     else
       ylabel("Gain |Y/U|")
       md = mag;
     endif
diff --git a/scripts/control/base/nyquist.m b/scripts/control/base/nyquist.m
--- a/scripts/control/base/nyquist.m
+++ b/scripts/control/base/nyquist.m
@@ -33,17 +33,17 @@
 ## if sys is continuous, then bode evaluates @math{G(jw)}
 ## if sys is discrete, then bode evaluates @math{G(exp(jwT))}, where
 ## @math{@var{T}=sysgettsam(@var{sys})} (the system sampling time)
 ## @item default
 ## the default frequency range is selected as follows: (These
 ## steps are NOT performed if @var{w} is specified)
 ## @end table
 ## @enumerate
-## @item via routine bodquist, isolate all poles and zeros away from
+## @item via routine __bodquist__, isolate all poles and zeros away from
 ## @var{w}=0 (@var{jw}=0 or @math{exp(@var{jwT})=1}) and select the frequency
 ## range based on the breakpoint locations of the frequencies.
 ## @item if @var{sys} is discrete time, the frequency range is limited
 ## to @var{jwT} in
 ## @ifinfo
 ## [0,2p*pi]
 ## @end ifinfo
 ## @iftex
@@ -88,17 +88,17 @@
 ## Created: July 13, 1994
 ## A. S. Hodel July 1995 (adaptive frequency spacing,
 ##     remove acura parameter, etc.)
 ## Revised by John Ingram July 1996 for system format
 
 function [realp, imagp, w] = nyquist (sys, w, outputs, inputs, atol)
 
   ## Both bode and nyquist share the same introduction, so the common
-  ## parts are in a file called bodquist.m.  It contains the part that
+  ## parts are in a file called __bodquist__.m.  It contains the part that
   ## finds the number of arguments, determines whether or not the system
   ## is SISO, andd computes the frequency response.  Only the way the
   ## response is plotted is different between the two functions.
 
   ## check number of input arguments given
   if (nargin < 1 | nargin > 5)
     usage("[realp,imagp,w] = nyquist(sys[,w,outputs,inputs,atol])");
   endif
@@ -112,19 +112,19 @@ function [realp, imagp, w] = nyquist (sy
     inputs = [];
   endif
   if(nargin < 5)
     atol = 0;
   elseif(!(is_sample(atol) | atol == 0))
     error("atol must be a nonnegative scalar.")
   endif
 
-  ## signal to bodquist who's calling
+  ## signal to __bodquist__ who's calling
 
-  [f,w] = bodquist(sys,w,outputs,inputs,"nyquist");
+  [f, w] = __bodquist__ (sys, w, outputs, inputs, "nyquist");
 
   ## Get the real and imaginary part of f.
   realp = real(f);
   imagp = imag(f);
 
   ## No output arguments, then display plot, otherwise return data.
   if (nargout == 0)
     dnplot = 0;
diff --git a/scripts/control/base/step.m b/scripts/control/base/step.m
--- a/scripts/control/base/step.m
+++ b/scripts/control/base/step.m
@@ -38,53 +38,53 @@
 ## Both parameters @var{tstop} and @var{n} can be omitted and will be
 ## computed from the eigenvalues of the A-Matrix.
 ## @end table
 ## @strong{Outputs}
 ## @var{y}, @var{t}: impulse response
 ##
 ## When invoked with the output paramter y the plot is not displayed.
 ## @end deftypefn
-## @seealso{impulse and stepimp}
+## @seealso{impulse and __stepimp__}
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 30, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = step (sys, inp, tstop, n)
 
-  if((nargin < 1) || (nargin > 4))
-    usage("[y, u] = step(sys[, inp, tstop, n])");
+  if ((nargin < 1) || (nargin > 4))
+    usage ("[y, u] = step(sys, inp, tstop, n)");
   endif
 
-  if(nargout > 2)
-    usage("[y, u] = step(sys[, inp, tstop, n])");
+  if (nargout > 2)
+    usage ("[y, u] = step (sys, inp, tstop, n)");
   endif
 
-  if(!is_struct(sys))
-    error("step: sys must be a system data structure.");
+  if (! is_struct (sys))
+    error ("step: sys must be a system data structure.");
   endif
 
   if (nargout == 0)
     switch (nargin)
       case (1)
-        stepimp(1, sys);
+        __stepimp__ (1, sys);
       case (2)
-        stepimp(1, sys, inp);
+        __stepimp__ (1, sys, inp);
       case (3)
-        stepimp(1, sys, inp, tstop);
+        __stepimp__ (1, sys, inp, tstop);
       case (4)
-        stepimp(1, sys, inp, tstop, n);
+        __stepimp__ (1, sys, inp, tstop, n);
     endswitch
   else
     switch (nargin)
       case (1)
-        [y, t] = stepimp(1, sys);
+        [y, t] = __stepimp__ (1, sys);
       case (2)
-        [y, t] = stepimp(1, sys, inp);
+        [y, t] = __stepimp__ (1, sys, inp);
       case (3)
-        [y, t] = stepimp(1, sys, inp, tstop);
+        [y, t] = __stepimp__ (1, sys, inp, tstop);
       case (4)
-        [y, t] = stepimp(1, sys, inp, tstop, n);
+        [y, t] = __stepimp__ (1, sys, inp, tstop, n);
     endswitch
   endif
 
 endfunction
diff --git a/scripts/control/base/stepimp.m b/scripts/control/base/stepimp.m
deleted file mode 100644
--- a/scripts/control/base/stepimp.m
+++ /dev/null
@@ -1,279 +0,0 @@
-## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{y}, @var{t}] = } stepimp (@var{sitype}, @var{sys} [, @var{inp}, @var{tstop}, @var{n}])
-## Impulse or step response for a linear system.
-## The system can be discrete or multivariable (or both).
-## This m-file contains the "common code" of step and impulse.
-##
-## Produces a plot or the response data for system sys.
-##
-## Limited argument checking; "do not attempt to do this at home".
-## Used internally in @code{impulse}, @code{step}. Use @code{step}
-## or @code{impulse} instead.
-## @end deftypefn
-## @seealso{step and impulse}
-
-## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
-## Created: October 2, 1997
-## based on lsim.m of Scottedward Hodel
-
-function [y, t] = stepimp (sitype, sys, inp, tstop, n)
-
-  if (sitype == 1)         IMPULSE = 0;
-  elseif (sitype == 2)     IMPULSE = 1;
-  else                     error("stepimp: invalid sitype argument.")
-  endif
-  sys = sysupdate(sys,"ss");
-
-  USE_DEF = 0;   # default tstop and n if we have to give up
-  N_MIN = 50;    # minimum number of points
-  N_MAX = 2000;  # maximum number of points
-  T_DEF = 10.0;  # default simulation time
-
-  ## collect useful information about the system
-  [ncstates,ndstates,NIN,NOUT] = sysdimensions(sys);
-  TSAMPLE = sysgettsam(sys);
-
-  if (nargin < 3)                      inp = 1;
-  elseif (inp < 1 | inp > NIN)         error("Argument inp out of range")
-  endif
-
-  DIGITAL = is_digital(sys);
-  if (DIGITAL)
-    NSTATES = ndstates;
-    if (TSAMPLE < eps)
-      error("stepimp: sampling time of discrete system too small.")
-    endif
-  else        NSTATES = ncstates;       endif
-  if (NSTATES < 1)
-    error("step: pure gain block (n_states < 1), step response is trivial");
-  endif
-  if (nargin < 5)
-    ## we have to compute the time when the system reaches steady state
-    ## and the step size
-    ev = eig(sys2ss(sys));
-    if (DIGITAL)
-      ## perform bilinear transformation on poles in z
-      for i = 1:NSTATES
-        pole = ev(i);
-        if (abs(pole + 1) < 1.0e-10)
-          ev(i) = 0;
-        else
-          ev(i) = 2 / TSAMPLE * (pole - 1) / (pole + 1);
-        endif
-      endfor
-    endif
-    ## remove poles near zero from eigenvalue array ev
-    nk = NSTATES;
-    for i = 1:NSTATES
-      if (abs(ev(i)) < 1.0e-10)
-        ev(i) = 0;
-        nk = nk - 1;
-      endif
-    endfor
-    if (nk == 0)
-      USE_DEF = 1;
-      ## printf("##STEPIMP-DEBUG: using defaults.\n");
-    else
-      ev = ev(find(ev));
-      x = max(abs(ev));
-      t_step = 0.2 * pi / x;
-      x = min(abs(real(ev)));
-      t_sim = 5.0 / x;
-      ## round up
-      yy = 10^(ceil(log10(t_sim)) - 1);
-      t_sim = yy * ceil(t_sim / yy);
-      ## printf("##STEPIMP-DEBUG: nk=%d   t_step=%f  t_sim=%f\n",
-      ##   nk, t_step, t_sim);
-    endif
-  endif
-
-  if (DIGITAL)
-    ## ---- sampled system
-    if (nargin == 5)
-      n = round(n);
-      if (n < 2)
-        error("stepimp: n must not be less than 2.")
-      endif
-    else
-      if (nargin == 4)
-        ## n is unknown
-      elseif (nargin >= 1)
-        ## tstop and n are unknown
-        if (USE_DEF)
-          tstop = (N_MIN - 1) * TSAMPLE;
-        else
-          tstop = t_sim;
-        endif
-      endif
-      n = floor(tstop / TSAMPLE) + 1;
-      if (n < 2)  n = 2;  endif
-      if (n > N_MAX)
-        n = N_MAX;
-        printf("Hint: number of samples limited to %d by default.\n", \
-               N_MAX);
-        printf("  ==> increase \"n\" parameter for longer simulations.\n");
-      endif
-    endif
-    tstop = (n - 1) * TSAMPLE;
-    t_step = TSAMPLE;
-  else
-    ## ---- continuous system
-    if (nargin == 5)
-      n = round(n);
-      if (n < 2)
-        error("step: n must not be less than 2.")
-      endif
-      t_step = tstop / (n - 1);
-    else
-      if (nargin == 4)
-        ## only n in unknown
-        if (USE_DEF)
-          n = N_MIN;
-          t_step = tstop / (n - 1);
-        else
-          n = floor(tstop / t_step) + 1;
-        endif
-      else
-        ## tstop and n are unknown
-        if (USE_DEF)
-          tstop = T_DEF;
-          n = N_MIN;
-          t_step = tstop / (n - 1);
-        else
-          tstop = t_sim;
-          n = floor(tstop / t_step) + 1;
-        endif
-      endif
-      if (n < N_MIN)
-        n = N_MIN;
-        t_step = tstop / (n - 1);
-      endif
-      if (n > N_MAX)
-        tstop = (n - 1) * t_step;
-        t_step = tstop / (N_MAX - 1);
-        n = N_MAX;
-      endif
-    endif
-    tstop = (n - 1) * t_step;
-    [jnk,B] = sys2ss(sys);
-    B = B(:,inp);
-    sys = c2d(sys, t_step);
-  endif
-  ## printf("##STEPIMP-DEBUG: t_step=%f n=%d  tstop=%f\n", t_step, n, tstop);
-
-  F = sys.a;
-  G = sys.b(:,inp);
-  C = sys.c;
-  D = sys.d(:,inp);
-  y = zeros(NOUT, n);
-  t = linspace(0, tstop, n);
-
-  if (IMPULSE)
-    if (!DIGITAL && (D'*D > 0))
-      error("impulse: D matrix is nonzero, impulse response infinite.")
-    endif
-    if (DIGITAL)
-      y(:,1) = D / t_step;
-      x = G / t_step;
-    else
-      x = B;
-      y(:,1) = C * x;
-      x = F * x;
-    endif
-    for i = 2:n
-      y(:,i) = C * x;
-      x = F * x;
-    endfor
-  else
-    x = zeros(NSTATES, 1);
-    for i = 1:n
-      y(:,i) = C * x + D;
-      x = F * x + G;
-    endfor
-  endif
-
-  if(nargout == 0)
-    ## Plot the information
-    oneplot();
-    gset nogrid
-    gset nologscale
-    gset autoscale
-    gset nokey
-    clearplot();
-    if (gnuplot_has_multiplot)
-      if (IMPULSE)
-        gm = zeros(NOUT, 1);
-        tt = "impulse";
-      else
-        ssys = ss2sys(F, G, C, D, t_step);
-        gm = dcgain(ssys);
-        tt = "step";
-      endif
-      ncols = floor(sqrt(NOUT));
-      nrows = ceil(NOUT / ncols);
-      for i = 1:NOUT
-        subplot(nrows, ncols, i);
-        title(sprintf("%s: | %s -> %s", tt,sysgetsignals(sys,"in",inp,1), ...
-          sysgetsignals(sys,"out",i,1)));
-        if (DIGITAL)
-          [ts, ys] = stairs(t, y(i,:));
-          ts = ts(1:2*n-2)';  ys = ys(1:2*n-2)';
-          if (length(gm) > 0)
-            yy = [ys; gm(i)*ones(size(ts))];
-          else
-            yy = ys;
-          endif
-          grid("on");
-          xlabel("time [s]");
-          ylabel("y(t)");
-          plot(ts, yy);
-        else
-          if (length(gm) > 0)
-            yy = [y(i,:); gm(i)*ones(size(t))];
-          else
-            yy = y(i,:);
-          endif
-          grid("on");
-          xlabel("time [s]");
-          ylabel("y(t)");
-          plot(t, yy);
-        endif
-      endfor
-      ## leave gnuplot in multiplot mode is bad style
-      oneplot();
-    else
-      ## plot everything in one diagram
-      title([tt, " response | ", sysgetsignals(sys,"in",inp,1), ...
-        " -> all outputs"]);
-      if (DIGITAL)
-        stairs(t, y(i,:));
-      else
-        grid("on");
-        xlabel("time [s]");
-        ylabel("y(t)");
-        plot(t, y(i,:));
-      endif
-    endif
-    y=[];
-    t=[];
-  endif
-  ## printf("##STEPIMP-DEBUG: gratulations, successfull completion.\n");
-endfunction
diff --git a/scripts/control/base/tzero.m b/scripts/control/base/tzero.m
--- a/scripts/control/base/tzero.m
+++ b/scripts/control/base/tzero.m
@@ -73,17 +73,17 @@ function [zer, gain] = tzero (A, B, C, D
     zer = [];
     gain = D;
     return;
   endif
 
   ## First, balance the system via the zero computation generalized eigenvalue
   ## problem balancing method (Hodel and Tiller, Linear Alg. Appl., 1992)
 
-  Asys = zgpbal(Asys); [A,B,C,D] = sys2ss(Asys);   # balance coefficients
+  Asys = __zgpbal__ (Asys); [A,B,C,D] = sys2ss(Asys);   # balance coefficients
   meps = 2*eps*norm ([A, B; C, D], "fro");
   Asys = zgreduce(Asys,meps);  [A, B, C, D] = sys2ss(Asys); # ENVD algorithm
   if(!isempty(A))
     ## repeat with dual system
     Asys = ss2sys(A', C', B', D');   Asys = zgreduce(Asys,meps);
 
     ## transform back
     [A,B,C,D] = sys2ss(Asys);    Asys = ss2sys(A', C', B', D');
diff --git a/scripts/control/system/__abcddims__.m b/scripts/control/system/__abcddims__.m
--- a/scripts/control/system/__abcddims__.m
+++ b/scripts/control/system/__abcddims__.m
@@ -12,27 +12,27 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{y}, @var{my}, @var{ny}] =} abcddims (@var{x})
+## @deftypefn {Function File} {[@var{y}, @var{my}, @var{ny}] =} __abcddims__ (@var{x})
 ##
 ## Used internally in @code{abcddim}.  If @var{x} is a zero-size matrix,
 ## both dimensions are set to 0 in @var{y}.
 ## @var{my} and @var{ny} are the row and column dimensions of the result.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: February 1997
 
-function [y, my, ny] = abcddims (x)
+function [y, my, ny] = __abcddims__ (x)
 
   y = x;
   if(isempty(y))
     y = [];
   endif
   [my,ny] = size(y);
 
 endfunction
diff --git a/scripts/control/system/__syschnamesl__.m b/scripts/control/system/__syschnamesl__.m
--- a/scripts/control/system/__syschnamesl__.m
+++ b/scripts/control/system/__syschnamesl__.m
@@ -12,27 +12,27 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{old_names} =} syschnamesl (@var{olist}, @var{old_names}, @var{inames}, @var{listname})
+## @deftypefn {Function File} {@var{old_names} =} __syschnamesl__ (@var{olist}, @var{old_names}, @var{inames}, @var{listname})
 ## used internally in syschnames
 ## item olist: index list
 ## old_names: original list names
 ## inames: new names
 ## listname: name of index list
 ##
 ## combines the two string lists old_names and inames
 ## @end deftypefn
 
-function old_names = syschnamesl (olist, old_names, inames, listname)
+function old_names = __syschnamesl__ (olist, old_names, inames, listname)
 
   probstr = [];
   if( max(olist) > rows(old_names) )
     probstr = ["index list value(s) exceed(s) number of signals (", ...
       num2str(rows(old_names)),")"];
 
   elseif( length(olist) > rows(inames) )
     probstr = ["index list dimension exceeds number of replacement names (", ...
@@ -74,43 +74,43 @@ function old_names = syschnamesl (olist,
 
         old_names(olist(ii),1:len_my) = mystr;
       endfor
     endif
   endif
   if(!isempty(probstr))
     ## the following lines are NOT debugging code!
     disp("Problem in syschnames: old names are")
-    outlist(old_names," ")
+    __outlist__(old_names," ")
     disp("new names are")
-    outlist(inames,"    ")
+    __outlist__(inames,"    ")
     disp("list indices are")
     disp(olist)
     error(sprintf("syschnames: \"%s\" dim=(%d x %d)--\n\t%s\n", ...
         listname, rows(olist), columns(olist),probstr));
   endif
 
   ## change zeros  to blanks
   if( find(old_names == 0) )
-    ## disp("syschnamesl: old_names contains zeros ")
+    ## disp("__syschnamesl__: old_names contains zeros ")
     ## old_names
-    ## disp("/syschnamesl");
+    ## disp("/__syschnamesl__");
 
     [ii,jj] = find(old_names == 0);
     for idx=1:length(ii)
       old_names(ii(idx),jj(idx)) = " ";
     endfor
 
-    ## disp("syschnamesl: old_names fixed zeros ")
+    ## disp("__syschnamesl__: old_names fixed zeros ")
     ## old_names
-    ## disp("/syschnamesl");
+    ## disp("/__syschnamesl__");
   endif
 
   ## just in case it's not a string anymore
   if( !isstr(old_names) )
     old_names = setstr(old_names);
   endif
 
-  ## disp("syschnamesl: exit, old_names=")
+  ## disp("__syschnamesl__: exit, old_names=")
   ## old_names
-  ## disp("/syschnamesl: exiting")
+  ## disp("/__syschnamesl__: exiting")
 
 endfunction
diff --git a/scripts/control/system/__syscont_disc__.m b/scripts/control/system/__syscont_disc__.m
--- a/scripts/control/system/__syscont_disc__.m
+++ b/scripts/control/system/__syscont_disc__.m
@@ -12,17 +12,17 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{n_tot}, @var{st_c}, @var{st_d}, @var{y_c}, @var{y_d}] =} syscont_disc(@var{sys})
+## @deftypefn {Function File} {[@var{n_tot}, @var{st_c}, @var{st_d}, @var{y_c}, @var{y_d}] =} __syscont_disc__ (@var{sys})
 ## Used internally in syscont and sysdisc.
 ##
 ## @strong{Inputs}
 ## @var{ sys} is a system data structure.
 ##
 ## @strong{Outputs}
 ## @table @var
 ## @item n_tot
@@ -36,17 +36,17 @@
 ## @item y_d
 ## vector of discrete output indices
 ## @end table
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: February 1997
 
-function [n_tot, st_c, st_d, y_c, y_d] = syscont_disc (sys)
+function [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys)
 
   ## get ranges for discrete/continuous states and outputs
   [nn,nz,mm,pp,yd] = sysdimensions(sys);
   n_tot = nn + nz;
   st_c = 1:(nn);
   st_d = nn + (1:nz);
   y_c = find(yd == 0);          # y_c, y_d will be empty if there are none.
   y_d = find(yd == 1);
diff --git a/scripts/control/system/__sysdefioname__.m b/scripts/control/system/__sysdefioname__.m
--- a/scripts/control/system/__sysdefioname__.m
+++ b/scripts/control/system/__sysdefioname__.m
@@ -12,39 +12,39 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{ioname} =} sysdefioname (@var{n},@var{str} @{,@var{m}@})
+## @deftypefn {Function File} {@var{ioname} =} __sysdefioname__ (@var{n},@var{str} @{,@var{m}@})
 ## return default input or output names given @var{n}, @var{str}, @var{m}.
 ## @var{n} is the final value, @var{str} is the string prefix, and @var{m}
 ## is start value
 ##
 ## used internally, minimal argument checking
 ##
-## @strong{Example} @code{ioname = sysdefioname(5,"u",3)}
+## @strong{Example} @code{ioname = __sysdefioname__(5,"u",3)}
 ## returns the list:
 ## @example
 ## ioname =
 ## (
 ##   [1] = u_3
 ##   [2] = u_4
 ##   [3] = u_5
 ## )
 ## @end example
 ## @end deftypefn
 
-function ioname = sysdefioname (n, str, m)
+function ioname = __sysdefioname__ (n, str, m)
 
   if (nargin < 2 | nargin > 3)
-    usage("ioname = sysdefioname(n,str[,m])");
+    usage ("ioname = __sysdefioname__ (n, str, m)");
   endif
 
   if (nargin == 2)           m = min(1,n);            endif
 
   ioname = list();
   jj = 1;
   if(n > 0 & m > 0 & m <= n)
     for ii = m:n
diff --git a/scripts/control/system/__sysdefstname__.m b/scripts/control/system/__sysdefstname__.m
--- a/scripts/control/system/__sysdefstname__.m
+++ b/scripts/control/system/__sysdefstname__.m
@@ -12,23 +12,23 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{stname} =} sysdefstname (@var{n}, @var{nz})
+## @deftypefn {Function File} {@var{stname} =} __sysdefstname__ (@var{n}, @var{nz})
 ## return default state names given @var{n}, @var{nz}
 ##
 ## used internally, minimal argument checking
 ## @end deftypefn
 
-function stname = sysdefstname (n, nz)
+function stname = __sysdefstname__ (n, nz)
 
   stname = list();
   if(n > 0)
     for ii = 1:n
       stname(ii) = sprintf("x_%d",ii);
     endfor
   endif
 
diff --git a/scripts/control/system/__sysgroupn__.m b/scripts/control/system/__sysgroupn__.m
--- a/scripts/control/system/__sysgroupn__.m
+++ b/scripts/control/system/__sysgroupn__.m
@@ -12,30 +12,30 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{names} =} sysgroupn (@var{names})
-## names = sysgroupn(names)
+## @deftypefn {Function File} {@var{names} =} __sysgroupn__ (@var{names})
+## names = __sysgroupn__(names)
 ## Locate and mark duplicate names
 ## inputs:
 ## names: list of signal names
 ## kind: kind of signal name (used for diagnostic message purposes only)
 ## outputs:
 ## returns names with unique suffixes added; diagnostic warning
 ## message is printed to inform the user of the new signal name
 ##
 ## used internally in sysgroup and elsewhere.
 ## @end deftypefn
 
-function names = sysgroupn (names, kind)
+function names = __sysgroupn__ (names, kind)
 
   ## check for duplicate names
   l = length(names);
   ii = 1;
   while(ii <= l-1)
     st1 = nth(names,ii);
     jj = ii+1;
     while ( jj <= l)
diff --git a/scripts/control/system/__tf2sysl__.m b/scripts/control/system/__tf2sysl__.m
--- a/scripts/control/system/__tf2sysl__.m
+++ b/scripts/control/system/__tf2sysl__.m
@@ -12,22 +12,22 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{vec} =} tf2sysl (@var{vec})
+## @deftypefn {Function File} {@var{vec} =} __tf2sysl__ (@var{vec})
 ## used internally in @ref{tf2sys}.
 ## strip leading zero coefficients to get the true polynomial length
 ## @end deftypefn
 
-function vec = tf2sysl (vec)
+function vec = __tf2sysl__ (vec)
 
   while( (length(vec) > 1) & (vec(1) == 0) )
     vec = vec(2:length(vec));
   endwhile
 
   if(vec(1) == 0)
     warning("tf2sys: polynomial has no nonzero coefficients!")
   endif
diff --git a/scripts/control/system/__zp2ssg2__.m b/scripts/control/system/__zp2ssg2__.m
--- a/scripts/control/system/__zp2ssg2__.m
+++ b/scripts/control/system/__zp2ssg2__.m
@@ -12,26 +12,26 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{poly}, @var{rvals}] =} zp2ssg2 (@var{rvals})
+## @deftypefn {Function File} {[@var{poly}, @var{rvals}] =} __zp2ssg2__ (@var{rvals})
 ## Used internally in @code{zp2ss}
 ## Extract 2 values from @var{rvals} (if possible) and construct
 ## a polynomial with those roots.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1996
 
-function [poly, rvals] = zp2ssg2 (rvals)
+function [poly, rvals] = __zp2ssg2__ (rvals)
 
   ## locate imaginary roots (if any)
   cidx = find(imag(rvals));
 
   if(!isempty(cidx))
     ## select first complex root, omit from cidx
     r1i = cidx(1);      r1 = rvals(r1i);     cidx = complement(r1i,cidx);
 
diff --git a/scripts/control/system/abcddim.m b/scripts/control/system/abcddim.m
--- a/scripts/control/system/abcddim.m
+++ b/scripts/control/system/abcddim.m
@@ -68,20 +68,20 @@
 function [n, m, p] = abcddim (a, b, c, d)
 
   if (nargin != 4)
     error ("abcddim: four arguments required");
   endif
 
   n = m = p = -1;
 
-  [a,an,am] = abcddims(a);
-  [b,bn,bm] = abcddims(b);
-  [c,cn,cm] = abcddims(c);
-  [d,dn,dm] = abcddims(d);
+  [a, an, am] = __abcddims__ (a);
+  [b, bn, bm] = __abcddims__ (b);
+  [c, cn, cm] = __abcddims__ (c);
+  [d, dn, dm] = __abcddims__ (d);
 
   if ( (!is_square(a)) & (!isempty(a)) )
     warning (["abcddim: a is not square (",num2str(an),"x",num2str(am),")"]);
     return
   endif
 
   if( (bm == 0) & (dm == 0) )
     warning("abcddim: no inputs");
@@ -98,17 +98,17 @@ function [n, m, p] = abcddim (a, b, c, d
         " and c(",num2str(cn),"x",num2str(cm),") are not compatible"]);
     return
   endif
 
   have_connections = (bn*cn != 0);
 
   if( (dn == 0) & have_connections)
     warning("abcddim: empty d matrix passed; setting compatibly with b, c");
-    [d,dn,dm] = abcddims(zeros(cn,bm));
+    [d, dn, dm] = __abcddims__ (zeros (cn, bm));
   endif
 
   if(an > 0)
     [dn, dm] = size(d);
     if ( (cn != dn) & have_connections )
       warning (["abcddim: c(",num2str(cn),"x",num2str(cm), ...
         " and d(",num2str(dn),"x",num2str(dm),") are not compatible"]);
       return
diff --git a/scripts/control/system/abcddims.m b/scripts/control/system/abcddims.m
deleted file mode 100644
--- a/scripts/control/system/abcddims.m
+++ /dev/null
@@ -1,38 +0,0 @@
-## Copyright (C) 1997 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{y}, @var{my}, @var{ny}] =} abcddims (@var{x})
-##
-## Used internally in @code{abcddim}.  If @var{x} is a zero-size matrix,
-## both dimensions are set to 0 in @var{y}.
-## @var{my} and @var{ny} are the row and column dimensions of the result.
-## @end deftypefn
-
-## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
-## Created: February 1997
-
-function [y, my, ny] = abcddims (x)
-
-  y = x;
-  if(isempty(y))
-    y = [];
-  endif
-  [my,ny] = size(y);
-
-endfunction
diff --git a/scripts/control/system/fir2sys.m b/scripts/control/system/fir2sys.m
--- a/scripts/control/system/fir2sys.m
+++ b/scripts/control/system/fir2sys.m
@@ -87,19 +87,19 @@ function sys = fir2sys (num, tsam, innam
   if (nargin <= 1)
     tsam = 1;           # default
   elseif (isempty(tsam))
     tsam = 1;
   endif
 
   ## Set name of input
   if (nargin < 3)
-    inname = sysdefioname (1, "u");
+    inname = __sysdefioname__ (1, "u");
   endif
 
   ## Set name of output
   if (nargin < 4)
-    outname = sysdefioname (1, "y");
+    outname = __sysdefioname__ (1, "y");
   endif
 
   sys = tf2sys (num, den, tsam, inname, outname);
 
 endfunction
diff --git a/scripts/control/system/parallel.m b/scripts/control/system/parallel.m
--- a/scripts/control/system/parallel.m
+++ b/scripts/control/system/parallel.m
@@ -49,18 +49,18 @@ function sysp = parallel (Asys, Bsys)
   if(mA != mB)
     error(["Asys has ",num2str(mA)," inputs, Bsys has ",num2str(mB)," inputs"]);
   endif
 
   ## save signal names
   Ain = sysgetsignals(Asys,"in");
 
   ## change signal names to avoid warning messages from sysgroup
-  Asys = syssetsignals(Asys,"in",sysdefioname(length(Ain),"Ain_u"));
-  Bsys = syssetsignals(Bsys,"in",sysdefioname(length(Ain),"Bin_u"));
+  Asys = syssetsignals(Asys,"in",__sysdefioname__(length(Ain),"Ain_u"));
+  Bsys = syssetsignals(Bsys,"in",__sysdefioname__(length(Ain),"Bin_u"));
 
   sysp = sysgroup(Asys,Bsys);
   sysD = ss2sys([],[],[],[eye(mA);eye(mA)]);
 
   sysp = sysmult(sysp,sysD);
   sysp = syssetsignals(sysp,"in",Ain);
 
 endfunction
diff --git a/scripts/control/system/ss2sys.m b/scripts/control/system/ss2sys.m
--- a/scripts/control/system/ss2sys.m
+++ b/scripts/control/system/ss2sys.m
@@ -251,19 +251,19 @@ function retsys = ss2sys (a, b, c, d, ts
   retsys.n = n;
   retsys.nz = nz;
   retsys.tsam = tsam;
   retsys.yd = zeros(1,p);     # default value entered below
 
   ## Set the system vector:  active = 2(ss), updated = [0 0 1];
   retsys.sys = [2, 0, 0, 1];
 
-  retsys.stname = sysdefstname(n,nz);
-  retsys.inname = sysdefioname(m,"u");
-  retsys.outname = sysdefioname(p,"y");
+  retsys.stname = __sysdefstname__ (n, nz);
+  retsys.inname = __sysdefioname__ (m, "u");
+  retsys.outname = __sysdefioname__ (p, "y");
 
   ## check for state names
   if(nargin >= 8)
     if(!isempty(stname)) retsys = syssetsignals(retsys,"st",stname); endif
   endif
 
   ## check for input names
   if(nargin >= 9)
diff --git a/scripts/control/system/sysadd.m b/scripts/control/system/sysadd.m
--- a/scripts/control/system/sysadd.m
+++ b/scripts/control/system/sysadd.m
@@ -89,20 +89,20 @@ function sys = sysadd (...)
       endif
     endif
 
     ## make sure in ss form
     Gsys = sysupdate(Gsys,"ss");
     Hsys = sysupdate(Hsys,"ss");
 
     ## change signal names to avoid warning messages from sysgroup
-    Gsys = syssetsignals(Gsys,"in",sysdefioname(length(Gin),"Gin_u"));
-    Gsys = syssetsignals(Gsys,"out",sysdefioname(length(Gout),"Gout_u"));
-    Hsys = syssetsignals(Hsys,"in",sysdefioname(length(Hin),"Hin_u"));
-    Hsys = syssetsignals(Hsys,"out",sysdefioname(length(Hout),"Hout_u"));
+    Gsys = syssetsignals(Gsys,"in",__sysdefioname__(length(Gin),"Gin_u"));
+    Gsys = syssetsignals(Gsys,"out",__sysdefioname__(length(Gout),"Gout_u"));
+    Hsys = syssetsignals(Hsys,"in",__sysdefioname__(length(Hin),"Hin_u"));
+    Hsys = syssetsignals(Hsys,"out",__sysdefioname__(length(Hout),"Hout_u"));
 
     sys = sysgroup(Gsys,Hsys);
 
     eyin = eye(mg);
     eyout = eye(pg);
 
     sys = sysscale(sys,[eyout, eyout],[eyin;eyin],Gout,Gin);
 
diff --git a/scripts/control/system/sysappend.m b/scripts/control/system/sysappend.m
--- a/scripts/control/system/sysappend.m
+++ b/scripts/control/system/sysappend.m
@@ -108,17 +108,17 @@ function retsys = sysappend (sys, b, c, 
     if(nargin >= 6)   # new names were passed
       if(!isstr(inname))
         error("inname must be a string");
       elseif(rows(inname) != (Bm - Am))
         error(sprintf("%d new inputs requested; inname(%dx%d)", ...
           (Bm-Am),rows(inname),columns(inname)));
       endif
     else
-      inname = sysdefioname(Bm,"u",(Am+1));
+      inname = __sysdefioname__(Bm,"u",(Am+1));
     endif
     if(Am)   Ain = append(Ain,inname);
     else     Ain = inname;              endif
 
     ## default b matrix
     if(isempty(b))     b  = zeros(Ann+Anz,(Bm-Am));
     elseif(rows(b) != Ann+Anz | columns(b) != (Bm-Am))
         error(sprintf("b(%dx%d); should be (%dx%d)", rows(b), columns(b), ...
@@ -137,17 +137,17 @@ function retsys = sysappend (sys, b, c, 
     if(nargin >= 5)  # new names were passed
       if(!isstr(outname))
         error("outname must be a string");
       elseif(rows(outname) != (Bp - Ap))
         error(sprintf("%d new outputs requested; outname(%dx%d)", ...
           (Bp-Ap),rows(outname),columns(outname)));
       endif
     else
-      outname = sysdefioname(Bp,"y",(Ap+1));
+      outname = __sysdefioname__(Bp,"y",(Ap+1));
     endif
     if(Ap)   Aout = append(Aout,outname);
     else     Aout = outname;                endif
 
     ## construct new yd entries
     if(nargin == 7)
       if(!is_vector(yd))
         error(sprintf("yd(%dx%d) must be a vector",rows(yd),columns(yd)))
diff --git a/scripts/control/system/syschnamesl.m b/scripts/control/system/syschnamesl.m
deleted file mode 100644
--- a/scripts/control/system/syschnamesl.m
+++ /dev/null
@@ -1,116 +0,0 @@
-## Copyright (C) 1996 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{old_names} =} syschnamesl (@var{olist}, @var{old_names}, @var{inames}, @var{listname})
-## used internally in syschnames
-## item olist: index list
-## old_names: original list names
-## inames: new names
-## listname: name of index list
-##
-## combines the two string lists old_names and inames
-## @end deftypefn
-
-function old_names = syschnamesl (olist, old_names, inames, listname)
-
-  probstr = [];
-  if( max(olist) > rows(old_names) )
-    probstr = ["index list value(s) exceed(s) number of signals (", ...
-      num2str(rows(old_names)),")"];
-
-  elseif( length(olist) > rows(inames) )
-    probstr = ["index list dimension exceeds number of replacement names (", ...
-      num2str(rows(inames)),")"];
-
-  elseif(isempty(olist))
-    probstr = [];    # do nothing, no changes
-
-  elseif(min(size(olist)) != 1 )
-    probstr = "index list must be either a vector or an empty matrix";
-
-  elseif(max(olist) > rows(old_names))
-    probstr = ["max(",listname,")=",num2str(max(olist))," > ", ...
-        num2str(rows(old_names)),", too big"];
-
-  elseif(min(olist) < 1)
-    probstr = ["min(",listname,")=",num2str(min(olist))," < 1, too small"];
-
-  else
-    if( length(olist)  == 1)
-        len_in = columns(inames);
-        len_out = columns(old_names);
-
-      if (len_in < len_out)
-        inames(1,(len_in+1):(len_out)) = zeros(1,(len_out - len_in));
-      endif
-
-      old_names(olist,1:length(inames)) = inames;
-    elseif(length(olist) > 1)
-      for ii=1:length(olist)
-        mystr = inames(ii,:);
-        len_my = columns(mystr);
-        len_out = columns(old_names);
-
-        if (len_my < len_out)
-          mystr(1,(len_my+1):(len_out)) = " "*ones(1,(len_out - len_my));
-          len_my = len_out;
-        endif
-
-        old_names(olist(ii),1:len_my) = mystr;
-      endfor
-    endif
-  endif
-  if(!isempty(probstr))
-    ## the following lines are NOT debugging code!
-    disp("Problem in syschnames: old names are")
-    outlist(old_names," ")
-    disp("new names are")
-    outlist(inames,"    ")
-    disp("list indices are")
-    disp(olist)
-    error(sprintf("syschnames: \"%s\" dim=(%d x %d)--\n\t%s\n", ...
-        listname, rows(olist), columns(olist),probstr));
-  endif
-
-  ## change zeros  to blanks
-  if( find(old_names == 0) )
-    ## disp("syschnamesl: old_names contains zeros ")
-    ## old_names
-    ## disp("/syschnamesl");
-
-    [ii,jj] = find(old_names == 0);
-    for idx=1:length(ii)
-      old_names(ii(idx),jj(idx)) = " ";
-    endfor
-
-    ## disp("syschnamesl: old_names fixed zeros ")
-    ## old_names
-    ## disp("/syschnamesl");
-  endif
-
-  ## just in case it's not a string anymore
-  if( !isstr(old_names) )
-    old_names = setstr(old_names);
-  endif
-
-  ## disp("syschnamesl: exit, old_names=")
-  ## old_names
-  ## disp("/syschnamesl: exiting")
-
-endfunction
diff --git a/scripts/control/system/syscont.m b/scripts/control/system/syscont.m
--- a/scripts/control/system/syscont.m
+++ b/scripts/control/system/syscont.m
@@ -45,18 +45,18 @@ function [csys, Acd, Ccd] = syscont (sys
   empty_list_elements_ok = 1;
 
   if (nargin != 1)
     usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   endif
 
-  sys = sysupdate(sys,"ss");
-  [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys);        # get ranges
+  sys = sysupdate (sys, "ss");
+  [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Acc = Acd = Bcc = Ccc = Ccd = Dcc = [];
 
   if(isempty(st_c) & isempty(y_c))
     error("syscont: expecting continous states and/or continous outputs");
   elseif (isempty(st_c))
     warning("syscont: no continuous states");
diff --git a/scripts/control/system/syscont_disc.m b/scripts/control/system/syscont_disc.m
deleted file mode 100644
--- a/scripts/control/system/syscont_disc.m
+++ /dev/null
@@ -1,54 +0,0 @@
-## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{n_tot}, @var{st_c}, @var{st_d}, @var{y_c}, @var{y_d}] =} syscont_disc(@var{sys})
-## Used internally in syscont and sysdisc.
-##
-## @strong{Inputs}
-## @var{ sys} is a system data structure.
-##
-## @strong{Outputs}
-## @table @var
-## @item n_tot
-## total number of states
-## @item st_c
-## vector of continuous state indices (empty if none)
-## @item st_d
-## vector of discrete state indices (empty if none)
-## @item y_c
-## vector of continuous output indices
-## @item y_d
-## vector of discrete output indices
-## @end table
-## @end deftypefn
-
-## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
-## Created: February 1997
-
-function [n_tot, st_c, st_d, y_c, y_d] = syscont_disc (sys)
-
-  ## get ranges for discrete/continuous states and outputs
-  [nn,nz,mm,pp,yd] = sysdimensions(sys);
-  n_tot = nn + nz;
-  st_c = 1:(nn);
-  st_d = nn + (1:nz);
-  y_c = find(yd == 0);          # y_c, y_d will be empty if there are none.
-  y_d = find(yd == 1);
-
-endfunction
diff --git a/scripts/control/system/sysdefioname.m b/scripts/control/system/sysdefioname.m
deleted file mode 100644
--- a/scripts/control/system/sysdefioname.m
+++ /dev/null
@@ -1,57 +0,0 @@
-## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{ioname} =} sysdefioname (@var{n},@var{str} @{,@var{m}@})
-## return default input or output names given @var{n}, @var{str}, @var{m}.
-## @var{n} is the final value, @var{str} is the string prefix, and @var{m}
-## is start value
-##
-## used internally, minimal argument checking
-##
-## @strong{Example} @code{ioname = sysdefioname(5,"u",3)}
-## returns the list:
-## @example
-## ioname =
-## (
-##   [1] = u_3
-##   [2] = u_4
-##   [3] = u_5
-## )
-## @end example
-## @end deftypefn
-
-function ioname = sysdefioname (n, str, m)
-
-  if (nargin < 2 | nargin > 3)
-    usage("ioname = sysdefioname(n,str[,m])");
-  endif
-
-  if (nargin == 2)           m = min(1,n);            endif
-
-  ioname = list();
-  jj = 1;
-  if(n > 0 & m > 0 & m <= n)
-    for ii = m:n
-      ioname(ii+1-m) = sprintf("%s_%d",str,ii);
-    endfor
-  elseif(m > n)
-    error("str=%s; start value m=%d > final value n=%d",str,m,n);
-  endif
-
-endfunction
diff --git a/scripts/control/system/sysdefstname.m b/scripts/control/system/sysdefstname.m
deleted file mode 100644
--- a/scripts/control/system/sysdefstname.m
+++ /dev/null
@@ -1,42 +0,0 @@
-## Copyright (C) 1996 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{stname} =} sysdefstname (@var{n}, @var{nz})
-## return default state names given @var{n}, @var{nz}
-##
-## used internally, minimal argument checking
-## @end deftypefn
-
-function stname = sysdefstname (n, nz)
-
-  stname = list();
-  if(n > 0)
-    for ii = 1:n
-      stname(ii) = sprintf("x_%d",ii);
-    endfor
-  endif
-
-  ## Set default names for discrete states
-  if(nz > 0)
-    for ii = (n+1):(n+nz)
-      stname(ii) = sprintf("xd_%d",ii);
-    endfor
-  endif
-
-endfunction
diff --git a/scripts/control/system/sysdisc.m b/scripts/control/system/sysdisc.m
--- a/scripts/control/system/sysdisc.m
+++ b/scripts/control/system/sysdisc.m
@@ -40,18 +40,18 @@ function [dsys, Adc, Cdc] = sysdisc (sys
   empty_list_elements_ok = 1;
 
   if (nargin != 1)
     usage("[dsys,Adc,Cdc] = sysdisc(sys)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   endif
 
-  sys = sysupdate(sys,"ss");
-  [n_tot,st_c,st_d,y_c,y_d] = syscont_disc(sys);        # get ranges
+  sys = sysupdate (sys, "ss");
+  [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Add = Adc = Bdd = Cdd = Cdc = Ddd = [];
 
   if(isempty(st_d) & isempty(y_d))
     error("sysdisc: expecting discrete states and/or continous outputs");
   elseif (isempty(st_d))
     warning("sysdisc: no discrete states");
diff --git a/scripts/control/system/sysgroup.m b/scripts/control/system/sysgroup.m
--- a/scripts/control/system/sysgroup.m
+++ b/scripts/control/system/sysgroup.m
@@ -121,19 +121,19 @@ function sys = sysgroup (...)
     endif
     [tmp,pv] = sort(dstates);
     A = A(pv,pv);
     B = B(pv,:);
     C = C(:,pv);
     stname = stname(pv);
 
     ## check for duplicate signal names
-    inname = sysgroupn(inname,"input");
-    stname = sysgroupn(stname,"state");
-    outname = sysgroupn(outname,"output");
+    inname = __sysgroupn__ (inname, "input");
+    stname = __sysgroupn__ (stname, "state");
+    outname = __sysgroupn__ (outname, "output");
 
     ## mark discrete outputs
     outlist = find([Ayd, Byd]);
 
     ## build new system
     sys = ss2sys(A,B,C,D,tsam,An+Bn,Anz+Bnz,stname,inname,outname);
 
   else
diff --git a/scripts/control/system/sysgroupn.m b/scripts/control/system/sysgroupn.m
deleted file mode 100644
--- a/scripts/control/system/sysgroupn.m
+++ /dev/null
@@ -1,57 +0,0 @@
-## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{names} =} sysgroupn (@var{names})
-## names = sysgroupn(names)
-## Locate and mark duplicate names
-## inputs:
-## names: list of signal names
-## kind: kind of signal name (used for diagnostic message purposes only)
-## outputs:
-## returns names with unique suffixes added; diagnostic warning
-## message is printed to inform the user of the new signal name
-##
-## used internally in sysgroup and elsewhere.
-## @end deftypefn
-
-function names = sysgroupn (names, kind)
-
-  ## check for duplicate names
-  l = length(names);
-  ii = 1;
-  while(ii <= l-1)
-    st1 = nth(names,ii);
-    jj = ii+1;
-    while ( jj <= l)
-      st2 = nth(names,jj);
-      if(strcmp(st1,st2))
-        suffix = ["_",num2str(jj)];
-        warning("sysgroup: %s name(%d) = %s name(%d) = %s", ...
-          kind,ii,kind,jj,st1);
-        strval = sprintf("%s%s",st2,suffix);
-        names(jj) = strval;
-        warning("sysgroup:     changed %s name %d to %s",kind,jj,strval);
-        ## restart the check (just to be sure there's no further duplications)
-        ii = 0; jj = l;
-      endif
-      jj = jj+1;
-    endwhile
-    ii = ii+1;
-  endwhile
-endfunction
diff --git a/scripts/control/system/sysmult.m b/scripts/control/system/sysmult.m
--- a/scripts/control/system/sysmult.m
+++ b/scripts/control/system/sysmult.m
@@ -86,18 +86,18 @@ function sys = sysmult (...)
         bc = Ab(1:An)* Bc(alist,1:(Bn));
         if( norm(bc,1) )
           warning("sysmult: Bsys states -> Bsys discrete outputs -> continuous states of Asys");
         endif
       endif
     endif
 
     ## change signal names to avoid spurious warnings from sysgroup
-    Asys = syssetsignals(Asys,"in",sysdefioname(Am,"A_sysmult_tmp_name"));
-    Bsys = syssetsignals(Bsys,"out",sysdefioname(Bp,"B_sysmult_tmp_name"));
+    Asys = syssetsignals(Asys,"in",__sysdefioname__(Am,"A_sysmult_tmp_name"));
+    Bsys = syssetsignals(Bsys,"out",__sysdefioname__(Bp,"B_sysmult_tmp_name"));
 
     sys = sysgroup(Asys,Bsys);
 
     ## connect outputs of B to inputs of A
     sys = sysconnect(sys,Ap+(1:Bp),1:Am);
 
     ## now keep only  outputs of A and inputs of B
     sys = sysprune(sys,1:Ap,Am+(1:Bm));
diff --git a/scripts/control/system/sysout.m b/scripts/control/system/sysout.m
--- a/scripts/control/system/sysout.m
+++ b/scripts/control/system/sysout.m
@@ -67,23 +67,23 @@ function retsys = sysout (sys, opt)
       error("opt must be one of [], \"ss\", \"tf\", \"zp\", or \"all\"");
     endif
   endif
 
   ## now check output for each form:
   [nn,nz,mm,pp] = sysdimensions(sys);
   if( mm > 0)
     disp("Input(s)")
-    disp(outlist(sysgetsignals(sys,"in"),"      "));
+    disp(__outlist__(sysgetsignals(sys,"in"),"      "));
   else
     disp("Input(s): none");
   endif
   if (pp > 0)
     disp("Output(s):")
-    disp(outlist(sysgetsignals(sys,"out"), ...
+    disp(__outlist__(sysgetsignals(sys,"out"), ...
           "     ",sysgetsignals(sys,"yd")) );
   else
     disp("Output(s): none");
   endif
   if(sysgettsam(sys) > 0)
     disp(["Sampling interval: ",num2str(sysgettsam(sys))]);
     str = "z";
   else
@@ -111,17 +111,17 @@ function retsys = sysout (sys, opt)
     disp([num2str(nn)," continuous states, ", num2str(nz)," discrete states"]);
     if( nn+nz > 0)
       disp("State(s):")
       xi = (nn+1):(nn+nz);
       xd = zeros(1,nn+nz);
       if(!isempty(xi))
         xd(xi) = 1;
       endif
-      disp(outlist(sysgetsignals(sys,"st"),"    ",xd));
+      disp(__outlist__(sysgetsignals(sys,"st"),"    ",xd));
     else
       disp("State(s): none");
     endif
 
     ## display matrix values?
     dmat = (max( [ (nn+nz), mm, pp ] ) <= 32);
 
     printf("A matrix: %d x %d\n",sysdimensions(sys,"st"),
diff --git a/scripts/control/system/sysscale.m b/scripts/control/system/sysscale.m
--- a/scripts/control/system/sysscale.m
+++ b/scripts/control/system/sysscale.m
@@ -111,28 +111,28 @@ function sys = sysscale (sys, outscale, 
   sysd = outscale*sysd*inscale;
 
   if( !is_square(outscale) )
     ## strip extra output names (if any)
     sysoutname = sysoutname(1:min(rows(outscale),columns(outscale)));
     if( nargin < 4)
       warning("sysscale: outscale not square, outname not specified");
       warning("sysscale:  using default output names");
-      outname = sysdefioname(rows(sysc),"y");
+      outname = __sysdefioname__(rows(sysc),"y");
     endif
   else
     outname = sysoutname;
   endif
   if( !is_square(inscale) )
     ## strip extra output names (if any)
     sysinname = sysinname(1:min(rows(inscale),columns(inscale)));
     if(nargin < 5)
       warning("sysscale: inscale not square, inname not specified");
       warning("sysscale:  using default input names");
-      inname = sysdefioname(columns(sysb),"u");
+      inname = __sysdefioname__(columns(sysb),"u");
     endif
   else
     inname = sysgetsignals(sys,"in");
   endif
 
   sys = ss2sys(sysa,sysb,sysc,sysd,systsam,nn,nz,sysstname, ...
         inname,outname,find(sysyd==1));
 
diff --git a/scripts/control/system/syssub.m b/scripts/control/system/syssub.m
--- a/scripts/control/system/syssub.m
+++ b/scripts/control/system/syssub.m
@@ -88,20 +88,20 @@ function sys = syssub (...)
       endif
     endif
 
     ## make sure in ss form
     Gsys = sysupdate(Gsys,"ss");
     Hsys = sysupdate(Hsys,"ss");
 
     ## change signal names to avoid warning messages from sysgroup
-    Gsys = syssetsignals(Gsys,"in",sysdefioname(length(Gin),"Gin_u"));
-    Gsys = syssetsignals(Gsys,"out",sysdefioname(length(Gout),"Gout_u"));
-    Hsys = syssetsignals(Hsys,"in",sysdefioname(length(Hin),"Hin_u"));
-    Hsys = syssetsignals(Hsys,"out",sysdefioname(length(Hout),"Hout_u"));
+    Gsys = syssetsignals(Gsys,"in",__sysdefioname__(length(Gin),"Gin_u"));
+    Gsys = syssetsignals(Gsys,"out",__sysdefioname__(length(Gout),"Gout_u"));
+    Hsys = syssetsignals(Hsys,"in",__sysdefioname__(length(Hin),"Hin_u"));
+    Hsys = syssetsignals(Hsys,"out",__sysdefioname__(length(Hout),"Hout_u"));
 
     sys = sysgroup(Gsys,Hsys);
 
     eyin = eye(mg);
     eyout = eye(pg);
 
     sys = sysscale (sys, [eyout, -eyout], [eyin; eyin], Gout, Gin);
 
diff --git a/scripts/control/system/sysupdate.m b/scripts/control/system/sysupdate.m
--- a/scripts/control/system/sysupdate.m
+++ b/scripts/control/system/sysupdate.m
@@ -111,13 +111,13 @@ function sys = sysupdate (sys, opt)
       sys.sys(4) = 1;
     ## original system is zero-pole
     elseif(sys.sys(1) == 1)
       [sys.a,sys.b,sys.c,sys.d] = zp2ss(sys.zer,sys.pol,sys.k);
       sys.sys(4) = 1;
     endif
 
     ## create new state names
-    sys.stname = sysdefstname(sys.n, sys.nz);
+    sys.stname = __sysdefstname__ (sys.n, sys.nz);
   endif
 
 
 endfunction
diff --git a/scripts/control/system/tf2sys.m b/scripts/control/system/tf2sys.m
--- a/scripts/control/system/tf2sys.m
+++ b/scripts/control/system/tf2sys.m
@@ -69,18 +69,18 @@ function outsys = tf2sys (num, den, tsam
   if( ! ( (is_vector(num) || is_scalar(num)) && ...
         (is_vector(den) || is_scalar(den))) )
     error(["num (",num2str(rows(num)),"x",num2str(columns(num)), ...
       ") and den (",num2str(rows(den)),"x",num2str(columns(den)), ...
       ") must be vectors"])
   endif
 
   ## strip leading zero coefficients
-  num = tf2sysl(num);
-  den = tf2sysl(den);
+  num = __tf2sysl__ (num);
+  den = __tf2sysl__ (den);
 
   if (length(num) >  length(den))
     error("# of poles (%d) < # of zeros (%d)",length(den)-1, length(num)-1);
   endif
 
   ## check sampling interval (if any)
   if(nargin <= 2)           tsam = 0;           # default
   elseif (isempty(tsam))    tsam = 0;           endif
@@ -100,19 +100,19 @@ function outsys = tf2sys (num, den, tsam
   outsys.nz = 0;
   outsys.yd = 0;        # assume discrete-time
   ## check discrete time
   if(tsam > 0)
     [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
     outsys.yd = 1;
   endif
 
-  outsys.inname  = sysdefioname(1,"u");
-  outsys.outname = sysdefioname(1,"y");
-  outsys.stname  = sysdefstname(outsys.n,outsys.nz);
+  outsys.inname  = __sysdefioname__ (1, "u");
+  outsys.outname = __sysdefioname__ (1, "y");
+  outsys.stname  = __sysdefstname__ (outsys.n, outsys.nz);
 
   ## Set name of input
   if (nargin > 3)
     ## make sure its a list of a single string
     if(!isempty(inname))
       if(!is_list(inname))  inname = list(inname);  endif
       if( !is_signal_list(inname) )
         error("inname must be a string or list of strings");
diff --git a/scripts/control/system/tf2sysl.m b/scripts/control/system/tf2sysl.m
deleted file mode 100644
--- a/scripts/control/system/tf2sysl.m
+++ /dev/null
@@ -1,35 +0,0 @@
-## Copyright (C) 1996 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{vec} =} tf2sysl (@var{vec})
-## used internally in @ref{tf2sys}.
-## strip leading zero coefficients to get the true polynomial length
-## @end deftypefn
-
-function vec = tf2sysl (vec)
-
-  while( (length(vec) > 1) & (vec(1) == 0) )
-    vec = vec(2:length(vec));
-  endwhile
-
-  if(vec(1) == 0)
-    warning("tf2sys: polynomial has no nonzero coefficients!")
-  endif
-
-endfunction
diff --git a/scripts/control/system/zp2ss.m b/scripts/control/system/zp2ss.m
--- a/scripts/control/system/zp2ss.m
+++ b/scripts/control/system/zp2ss.m
@@ -117,36 +117,36 @@ function [a, b, c, d] = zp2ss (zer, pol,
         num = [1, -zer(1)];
         zer = zer(2:length(zer));
       endif
       den = [1, -pol(1)];
       pol = pol(2:length(pol));
     case(2)
       ## got a complex pole or zero, need two roots (if available)
       if(length(zer) > 1)
-        [num,zer] = zp2ssg2(zer);       # get two zeros
+        [num, zer] = __zp2ssg2__ (zer);       # get two zeros
       elseif(length(zer) == 1)
         num = [1, -zer];                # use last zero (better be real!)
         zer = [];
       endif
-      [den,pol] = zp2ssg2(pol);         # get two poles
+      [den, pol] = __zp2ssg2__ (pol);         # get two poles
     otherwise
       error(["pcnt = ",num2str(pcnt)])
     endswitch
 
     ## pack tf into system form and put in series with earlier realization
     zpsys1 = tf2sys(num,den,0,"u","yy");
 
     ## change names to avoid warning messages from sysgroup
-    zpsys  = syssetsignals(zpsys,"in","u1",1);
-    zpsys1 = sysupdate(zpsys1,"ss");
-    nn     = sysdimensions(zpsys);        # working with continuous system
-    zpsys  = syssetsignals(zpsys,"st", sysdefioname(nn,"x"));
-    nn1    = sysdimensions(zpsys1);
-    zpsys1 = syssetsignals(zpsys1,"st",sysdefioname(nn1,"xx"));
+    zpsys  = syssetsignals (zpsys, "in", "u1", 1);
+    zpsys1 = sysupdate (zpsys1, "ss");
+    nn     = sysdimensions (zpsys);        # working with continuous system
+    zpsys  = syssetsignals (zpsys, "st", __sysdefioname__ (nn, "x"));
+    nn1    = sysdimensions (zpsys1);
+    zpsys1 = syssetsignals (zpsys1, "st", __sysdefioname__ (nn1, "xx"));
 
     zpsys = sysmult(zpsys,zpsys1);
 
   endwhile
 
   [a,b,c,d] = sys2ss(zpsys);
 
   empty_list_elements_ok = sav_val;
diff --git a/scripts/control/system/zp2ssg2.m b/scripts/control/system/zp2ssg2.m
deleted file mode 100644
--- a/scripts/control/system/zp2ssg2.m
+++ /dev/null
@@ -1,68 +0,0 @@
-## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{poly}, @var{rvals}] =} zp2ssg2 (@var{rvals})
-## Used internally in @code{zp2ss}
-## Extract 2 values from @var{rvals} (if possible) and construct
-## a polynomial with those roots.
-## @end deftypefn
-
-## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
-## Created: August 1996
-
-function [poly, rvals] = zp2ssg2 (rvals)
-
-  ## locate imaginary roots (if any)
-  cidx = find(imag(rvals));
-
-  if(!isempty(cidx))
-    ## select first complex root, omit from cidx
-    r1i = cidx(1);      r1 = rvals(r1i);     cidx = complement(r1i,cidx);
-
-    ## locate conjugate root (must be in cidx list, just in case there's
-    ## roundoff)
-    err = abs(rvals(cidx) - r1');
-    minerr = min(err);
-    c2i = find(err == minerr);
-    r2i = cidx(c2i);
-    r2 = rvals(r2i);
-    cidx = complement(r2i,cidx);
-
-    ## don't check for divide by zero, since 0 is not complex.
-    if(abs(r2 - r1')/abs(r1) > 1e-12)
-      error(sprintf("r1=(%f,%f); r2=(%f,%f), not conjugates.", ...
-        real(r1),imag(r1),real(r2),imag(r2)));
-    endif
-
-    ## complex conjugate pair
-    poly = [1, -2*real(r1), real(r1)^2+imag(r1)^2];
-  else
-    ## select two roots (they're all real)
-    r1 = rvals(1);
-    r2 = rvals(2);
-    poly = [1, -(r1+r2), (r1*r2)];
-    r1i = 1;  r2i = 2;
-  endif
-
-  ## remove roots used
-  idx = complement([r1i, r2i],1:length(rvals));
-  rvals = rvals(idx);
-
-endfunction
-
diff --git a/scripts/control/system/zp2sys.m b/scripts/control/system/zp2sys.m
--- a/scripts/control/system/zp2sys.m
+++ b/scripts/control/system/zp2sys.m
@@ -112,19 +112,19 @@ function outsys = zp2sys (zer, pol, k, t
     elseif (tsam > 0)
       [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
       outsys.yd = 1;            # discrete-time output
     endif
 
     outsys.tsam = tsam;
   endif
 
-  outsys.inname = sysdefioname(1,"u");
-  outsys.outname = sysdefioname(1,"y");
-  outsys.stname = sysdefstname(outsys.n,outsys.nz);
+  outsys.inname = __sysdefioname__ (1, "u");
+  outsys.outname = __sysdefioname__ (1, "y");
+  outsys.stname = __sysdefstname__ (outsys.n, outsys.nz);
 
   ## Set name of input
   if (nargin > 4)
     ## make sure its a string
     if(!isempty(inname))
       if(!is_list(inname))  inname = list(inname); endif
       if(!is_signal_list(inname))
         error("inname must be a single signal name");
diff --git a/scripts/control/system/zp2tf.m b/scripts/control/system/zp2tf.m
--- a/scripts/control/system/zp2tf.m
+++ b/scripts/control/system/zp2tf.m
@@ -50,26 +50,26 @@ function [num, den] = zp2tf (zer, pol, k
   elseif(length(zer) > length(pol))
     error(sprintf("zer(%dx%d) longer than pol(%dx%d)",rz,cz,rp,cp));
   endif
 
   ## initialize converted polynomials
 
   num = k;  den = 1;
 
-  ## call zp2ssg2 if there are complex conjugate pairs left, otherwise
+  ## call __zp2ssg2__ if there are complex conjugate pairs left, otherwise
   ## construct real zeros one by one.  Repeat for poles.
 
   while(!isempty(zer))
-    if( max(abs(imag(zer))) )     [poly,zer] = zp2ssg2(zer);
+    if( max(abs(imag(zer))) )     [poly, zer] = __zp2ssg2__ (zer);
     else                          poly = [1, -zer(1)];
                                   zer = zer(2:length(zer));      endif
     num = conv(num,poly);
   endwhile
 
   while(!isempty(pol))
-    if( max(abs(imag(pol))) )     [poly,pol] = zp2ssg2(pol);
+    if( max(abs(imag(pol))) )     [poly, pol] = __zp2ssg2__ (pol);
     else                          poly = [1, -pol(1)];
                                   pol = pol(2:length(pol));      endif
     den = conv(den,poly);
   endwhile
 
 endfunction
diff --git a/scripts/control/util/__outlist__.m b/scripts/control/util/__outlist__.m
--- a/scripts/control/util/__outlist__.m
+++ b/scripts/control/util/__outlist__.m
@@ -12,17 +12,17 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} outlist (@var{lmat}@{, @var{tabchar}, @var{yd}, @var{ilist} @})
+## @deftypefn {Function File} {} __outlist__ (@var{lmat}@{, @var{tabchar}, @var{yd}, @var{ilist} @})
 ## Prints an enumerated list of strings.
 ## internal use only; minimal argument checking performed
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item        lmat
 ## list of strings
 ## @item        tabchar
@@ -39,17 +39,17 @@
 ##
 ## @strong{Outputs}
 ## prints the list to the screen, numbering each string in order.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: December 1995
 
-function str_val = outlist (name_list, tabchar, yd, ilist)
+function str_val = __outlist__ (name_list, tabchar, yd, ilist)
 
   ## save for restore later
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if( nargin < 1 | nargin > 4 )
     usage("str_val = outlist(x[,tabchar,yd,ilist])");
   endif
diff --git a/scripts/control/util/__zgpbal__.m b/scripts/control/util/__zgpbal__.m
--- a/scripts/control/util/__zgpbal__.m
+++ b/scripts/control/util/__zgpbal__.m
@@ -12,60 +12,60 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{retsys} =} zgpbal (@var{Asys})
+## @deftypefn {Function File} {@var{retsys} =} __zgpbal__ (@var{Asys})
 ##
 ## used internally in @code{tzero}; minimal argument checking performed
 ##
 ## implementation of zero computation generalized eigenvalue problem
 ## balancing method (Hodel and Tiller, Allerton Conference, 1991)
 ## Based on Ward's balancing algorithm (SIAM J. Sci Stat. Comput., 1981)
 ##
-## zgpbal computes a state/input/output weighting that attempts to
+## __zgpbal__ computes a state/input/output weighting that attempts to
 ## reduced the range of the magnitudes of the nonzero elements of [a,b,c,d]
 ## The weighting uses scalar multiplication by powers of 2, so no roundoff
 ## will occur.
 ##
-## zgpbal should be followed by zgpred
+## __zgpbal__ should be followed by zgpred
 ## @end deftypefn
 
 ## References:
 ## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
 ## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
-function retsys = zgpbal (Asys)
+function retsys = __zgpbal__ (Asys)
 
   if( (nargin != 1) | (!is_struct(Asys)))
-    usage("retsys = zgpbal(Asys)");
+    usage("retsys = __zgpbal__ (Asys)");
   endif
 
   Asys = sysupdate(Asys,"ss");
   [a,b,c,d] = sys2ss(Asys);
 
   [nn,mm,pp] = abcddim(a,b,c,d);
 
   np1 = nn+1;
   nmp = nn+mm+pp;
 
   ## set up log vector zz, incidence matrix ff
   zz = zginit(a,b,c,d);
 
-  ## disp("zgpbal: zginit returns")
+  ## disp("__zgpbal__: zginit returns")
   ## zz
-  ## disp("/zgpbal")
+  ## disp("/__zgpbal__")
 
   if (norm(zz))
     ## generalized conjugate gradient approach
     xx = zgscal(a,b,c,d,zz,nn,mm,pp);
 
     for i=1:nmp
       xx(i) = floor(xx(i)+0.5);
       xx(i) = 2.0^xx(i);
diff --git a/scripts/control/util/outlist.m b/scripts/control/util/outlist.m
deleted file mode 100644
--- a/scripts/control/util/outlist.m
+++ /dev/null
@@ -1,80 +0,0 @@
-## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} outlist (@var{lmat}@{, @var{tabchar}, @var{yd}, @var{ilist} @})
-## Prints an enumerated list of strings.
-## internal use only; minimal argument checking performed
-##
-## @strong{Inputs}
-## @table @var
-## @item        lmat
-## list of strings
-## @item        tabchar
-## tab character (default: none)
-## @item   yd
-## indices of strings to append with the string "(discrete)"
-## (used by @var{sysout}; minimal checking of this argument)
-## @math{yd = [] } indicates all outputs are continuous
-## @item ilist
-## index numbers to print with names.
-##
-## default: @code{1:rows(lmat)}
-## @end table
-##
-## @strong{Outputs}
-## prints the list to the screen, numbering each string in order.
-## @end deftypefn
-
-## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
-## Created: December 1995
-
-function str_val = outlist (name_list, tabchar, yd, ilist)
-
-  ## save for restore later
-  save_empty = empty_list_elements_ok;
-  empty_list_elements_ok = 1;
-
-  if( nargin < 1 | nargin > 4 )
-    usage("str_val = outlist(x[,tabchar,yd,ilist])");
-  endif
-
-  m = length(name_list);
-  if(nargin < 4)           ilist = 1:m;          endif
-  if(nargin ==1)
-    empty_list_elements_ok = 1;
-    tabchar = "";
-  endif
-
-  if(nargin < 3)             yd = zeros(1,m);
-  elseif(isempty(yd))        yd = zeros(1,m);          endif
-
-  str_val = "";
-  dstr = list(""," (discrete)");
-  if((m >= 1) && (is_list(name_list)))
-    for ii=1:m
-      str_val = sprintf("%s%s%d: %s%s\n",str_val,tabchar, ilist(ii), ...
-          nth(name_list,ii),nth(dstr,yd(ii)+1));
-    endfor
-  else
-    str_val = sprintf("%sNone",tabchar);
-  endif
-
-  empty_list_elements_ok = save_empty;
-
-endfunction
diff --git a/scripts/control/util/zgpbal.m b/scripts/control/util/zgpbal.m
deleted file mode 100644
--- a/scripts/control/util/zgpbal.m
+++ /dev/null
@@ -1,109 +0,0 @@
-## Copyright (C) 1996 Auburn University.  All rights reserved.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by the
-## Free Software Foundation; either version 2, or (at your option) any
-## later version.
-##
-## Octave is distributed in the hope that it will be useful, but WITHOUT
-## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-## for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{retsys} =} zgpbal (@var{Asys})
-##
-## used internally in @code{tzero}; minimal argument checking performed
-##
-## implementation of zero computation generalized eigenvalue problem
-## balancing method (Hodel and Tiller, Allerton Conference, 1991)
-## Based on Ward's balancing algorithm (SIAM J. Sci Stat. Comput., 1981)
-##
-## zgpbal computes a state/input/output weighting that attempts to
-## reduced the range of the magnitudes of the nonzero elements of [a,b,c,d]
-## The weighting uses scalar multiplication by powers of 2, so no roundoff
-## will occur.
-##
-## zgpbal should be followed by zgpred
-## @end deftypefn
-
-## References:
-## ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
-## Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
-
-## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
-## Created: July 24, 1992
-## Conversion to Octave by R. Bruce Tenison July 3, 1994
-
-function retsys = zgpbal (Asys)
-
-  if( (nargin != 1) | (!is_struct(Asys)))
-    usage("retsys = zgpbal(Asys)");
-  endif
-
-  Asys = sysupdate(Asys,"ss");
-  [a,b,c,d] = sys2ss(Asys);
-
-  [nn,mm,pp] = abcddim(a,b,c,d);
-
-  np1 = nn+1;
-  nmp = nn+mm+pp;
-
-  ## set up log vector zz, incidence matrix ff
-  zz = zginit(a,b,c,d);
-
-  ## disp("zgpbal: zginit returns")
-  ## zz
-  ## disp("/zgpbal")
-
-  if (norm(zz))
-    ## generalized conjugate gradient approach
-    xx = zgscal(a,b,c,d,zz,nn,mm,pp);
-
-    for i=1:nmp
-      xx(i) = floor(xx(i)+0.5);
-      xx(i) = 2.0^xx(i);
-    endfor
-
-    ## now scale a
-    ## block 1: a = sigma a inv(sigma)
-    for i=1:nn
-      a(i,1:nn) = a(i,1:nn)*xx(i);
-      a(1:nn,i) = a(1:nn,i)/xx(i);
-    endfor
-    ## block 2: b= sigma a phi
-    for j=1:mm
-      j1 = j+nn;
-      b(1:nn,j) = b(1:nn,j)*xx(j1);
-    endfor
-    for i=1:nn
-      b(i,1:mm) = b(i,1:mm)*xx(i);
-    endfor
-    for i=1:pp
-      i1 = i+nn+mm;
-      ## block 3: c = psi C inv(sigma)
-      c(i,1:nn) = c(i,1:nn)*xx(i1);
-    endfor
-    for j=1:nn
-      c(1:pp,j) = c(1:pp,j)/xx(j);
-    endfor
-    ## block 4: d = psi D phi
-    for j=1:mm
-      j1 = j+nn;
-      d(1:pp,j) = d(1:pp,j)*xx(j1);
-    endfor
-    for i=1:pp
-      i1 = i + nn + mm;
-      d(i,1:mm) = d(i,1:mm)*xx(i1);
-    endfor
-  endif
-
-  retsys = ss2sys(a,b,c,d);
-endfunction
-
diff --git a/scripts/control/util/zgsgiv.m b/scripts/control/util/zgsgiv.m
--- a/scripts/control/util/zgsgiv.m
+++ b/scripts/control/util/zgsgiv.m
@@ -14,17 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[a, b] =} zgsgiv (@var{c}, @var{s}, @var{a}, @var{b})
 ## apply givens rotation c,s to row vectors @var{a},@var{b}
-## No longer used in zero-balancing (zgpbal); kept for backward compatibility.
+## No longer used in zero-balancing (__zgpbal__); kept for backward
+## compatibility.
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 29, 1992
 ## Convertion to Octave by R. Bruce Tenison July 3, 1994
 
 function [a, b] = zgsgiv (c, s, a, b)
 
