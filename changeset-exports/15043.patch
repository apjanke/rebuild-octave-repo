# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1343491594 14400
#      Sat Jul 28 12:06:34 2012 -0400
# Branch gui
# Node ID fabc0e37ead1d69c4dc9b3991ea8e6148d789f7a
# Parent  7c14e3e6fc6b61a3cfecfea41b15c9e2820569a9
# Parent  4328e28414aa7e4db247867280aad6700fbd3d24
maint: periodic merge of default to gui

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -74,20 +74,23 @@ Summary of important user-visible change
     It now accepts string inputs in the following numerical formats: 12, 21,
     22, 26, 29, 31.  This is undocumented, but verifiable, Matlab behavior.
     In addition, the default for formats which do not specify a date is
     January 1st of the current year.  The previous default was the current day,
     month, and year.  This may produce changes in existing scripts.
 
  ** Other new functions added in 3.8.0:
 
-      betaincinv  lines         tetramesh
-      colorcube   rgbplot
-      erfcinv     shrinkfaces
-      findfigs    splinefit
+      betaincinv   erfcinv      splinefit
+      cmpermute    findfigs     tetramesh
+      cmunique     fminsearch   rgbplot     
+      colorcube    lines        shrinkfaces 
+
+ ** The default name of the Octave crash dump file is now called
+    octave-workspace instead of octave-core.
       
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.4 and have been
     removed from Octave 3.8.
                                            
       autocor    dispatch              is_global    strerror
       autocov    fstat                 krylovb      values  
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -176,16 +176,20 @@ FT2_LIBS = @FT2_LIBS@
 HDF5_CPPFLAGS = @HDF5_CPPFLAGS@
 HDF5_LDFLAGS = @HDF5_LDFLAGS@
 HDF5_LIBS = @HDF5_LIBS@
 
 Z_CPPFLAGS = @Z_CPPFLAGS@
 Z_LDFLAGS = @Z_LDFLAGS@
 Z_LIBS = @Z_LIBS@
 
+LLVM_CPPFLAGS = @LLVM_CPPFLAGS@
+LLVM_LDFLAGS = @LLVM_LDFLAGS@
+LLVM_LIBS = @LLVM_LIBS@
+
 GRAPHICS_LIBS = @GRAPHICS_LIBS@
 
 QHULL_CPPFLAGS = @QHULL_CPPFLAGS@
 QHULL_LDFLAGS = @QHULL_LDFLAGS@
 QHULL_LIBS = @QHULL_LIBS@
 
 REGEX_LIBS = @REGEX_LIBS@
 
@@ -247,17 +251,17 @@ TERM_LIBS = @TERM_LIBS@
 
 ARPACK_CPPFLAGS = @ARPACK_CPPFLAGS@
 ARPACK_LDFLAGS = @ARPACK_LDFLAGS@
 ARPACK_LIBS = @ARPACK_LIBS@
 
 DL_LIBS = @DL_LIBS@
 LIBS = @LIBS@
 
-ALL_CPPFLAGS = $(CPPFLAGS) $(HDF5_CPPFLAGS) $(Z_CPPFLAGS)
+ALL_CPPFLAGS = $(CPPFLAGS) $(HDF5_CPPFLAGS) $(Z_CPPFLAGS) $(LLVM_CPPFLAGS)
 
 SPARSE_XCPPFLAGS = \
   $(CHOLMOD_CPPFLAGS) $(UMFPACK_CPPFLAGS) \
   $(AMD_CPPFLAGS) $(CAMD_CPPFLAGS) $(COLAMD_CPPFLAGS) \
   $(CCOLAMD_CPPFLAGS) $(CXSPARSE_CPPFLAGS)
 
 SPARSE_XLDFLAGS = \
   $(CHOLMOD_LDFLAGS) $(UMFPACK_LDFLAGS) \
@@ -539,16 +543,19 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_CONF_LIBFLAGS%|\"${LIBFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_LIBOCTAVE%|\"${LIBOCTAVE}\"|" \
   -e "s|%OCTAVE_CONF_LIBOCTINTERP%|\"${LIBOCTINTERP}\"|" \
   -e "s|%OCTAVE_CONF_LIBS%|\"${LIBS}\"|" \
   -e "s|%OCTAVE_CONF_LN_S%|\"${LN_S}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_CPPFLAGS%|\"${MAGICK_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_LDFLAGS%|\"${MAGICK_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_MAGICK_LIBS%|\"${MAGICK_LIBS}\"|" \
+  -e "s|%OCTAVE_CONF_LLVM_CPPFLAGS%|\"${LLVM_CPPFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_LLVM_LDFLAGS%|\"${LLVM_LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_LLVM_LIBS%|\"${LLVM_LIBS}\"|" \
   -e 's|%OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%|\"@MKOCTFILE_DL_LDFLAGS@\"|' \
   -e "s|%OCTAVE_CONF_OCTAVE_LINK_DEPS%|\"${OCTAVE_LINK_DEPS}\"|" \
   -e "s|%OCTAVE_CONF_OCTAVE_LINK_OPTS%|\"${OCTAVE_LINK_OPTS}\"|" \
   -e "s|%OCTAVE_CONF_OCTINCLUDEDIR%|\"${octincludedir}\"|" \
   -e "s|%OCTAVE_CONF_OCTLIBDIR%|\"${octlibdir}\"|" \
   -e "s|%OCTAVE_CONF_OCT_LINK_DEPS%|\"${OCT_LINK_DEPS}\"|" \
   -e "s|%OCTAVE_CONF_OCT_LINK_OPTS%|\"${OCT_LINK_OPTS}\"|" \
   -e "s|%OCTAVE_CONF_OPENGL_LIBS%|\"${OPENGL_LIBS}\"|" \
diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -508,17 +508,17 @@ sub emit_opt_handler_fcns
 #include <config.h>
 #endif
 
 #include <iomanip>
 #include <iostream>
 
 #include "$header"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "pr-output.h"
 
 #include "oct-obj.h"
 #include "utils.h"
 #include "pager.h"
 
 static $CLASS_NAME $STATIC_OBJECT_NAME;
 
@@ -904,21 +904,21 @@ show_$CLASS_NAME (const std::string& key
     }
 
   return retval;\n}\n\n|;
 }
 
 sub emit_options_function
 {
   print <<"_END_EMIT_OPTIONS_FUNCTION_HDR_";
-DEFUN_DLD ($OPT_FCN_NAME, args, ,
+DEFUN ($OPT_FCN_NAME, args, ,
   "-*- texinfo -*-\\n\\
-\@deftypefn  {Loadable Function} {} $OPT_FCN_NAME ()\\n\\
-\@deftypefnx {Loadable Function} {val =} $OPT_FCN_NAME (\@var{opt})\\n\\
-\@deftypefnx {Loadable Function} {} $OPT_FCN_NAME (\@var{opt}, \@var{val})\\n\\
+\@deftypefn  {Built-in Function} {} $OPT_FCN_NAME ()\\n\\
+\@deftypefnx {Built-in Function} {val =} $OPT_FCN_NAME (\@var{opt})\\n\\
+\@deftypefnx {Built-in Function} {} $OPT_FCN_NAME (\@var{opt}, \@var{val})\\n\\
 $DOC_STRING\\n\\
 \\n\\
 Options include\\n\\
 \\n\\
 \@table \@code\\n\\
 _END_EMIT_OPTIONS_FUNCTION_HDR_
 # FIXME: Add extra newline above
 
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -710,16 +710,106 @@ else
 fi
 
 ### Check for ZLIB library.
 
 OCTAVE_CHECK_LIBRARY(z, ZLIB,
   [ZLIB library not found.  Octave will not be able to save or load compressed data files or HDF5 files.],
   [zlib.h], [gzclearerr])
 
+### Check for the llvm library
+dnl
+dnl
+dnl llvm is odd and has its own pkg-config like script. We should probably check
+dnl for existance and 
+dnl
+save_CPPFLAGS="$CPPFLAGS"
+save_CXXFLAGS="$CXXFLAGS"
+save_LIBS="$LIBS"
+save_LDFLAGS="$LDFLAGS"
+
+warn_llvm="LLVM library fails tests. JIT compilation will be disabled."
+
+AC_ARG_VAR(LLVM_CONFIG, [path to llvm-config utility])
+
+AC_ARG_ENABLE([jit-debug],
+  AS_HELP_STRING([--enable-jit-debug], [Enable debug printing of jit IRs]))
+
+AS_IF([test "x$enable_jit_debug" = "xyes"], [
+  AC_DEFINE(OCTAVE_JIT_DEBUG, 1, [Define for jit debug printing])
+])
+
+LLVM_CXXFLAGS=
+LLVM_CPPFLAGS=
+LLVM_LDFLAGS=
+LLVM_LIBS=
+
+if test "x$ac_cv_env_LLVM_CONFIG_set" = "xset"; then
+  # We use -isystem if avaiable because we do not want to see warnings in llvm
+  LLVM_INCLUDE_FLAG=-I
+  OCTAVE_CC_FLAG(-isystem ., [
+    LLVM_INCLUDE_FLAG=-isystem
+    AC_MSG_NOTICE([using -isystem for llvm headers])])
+
+  LLVM_LDFLAGS="-L`$LLVM_CONFIG --libdir`"
+  LLVM_LIBS=`$LLVM_CONFIG --libs`
+  dnl Use -isystem so we don't get warnings from llvm headers
+  LLVM_CPPFLAGS="$LLVM_INCLUDE_FLAG `$LLVM_CONFIG --includedir`"
+  LLVM_CXXFLAGS=
+
+  dnl
+  dnl We define some extra flags that llvm requires in order to include headers.
+  dnl Idealy we should get these from llvm-config, but llvm-config isn't very
+  dnl helpful.
+  dnl
+  CPPFLAGS="-D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS $LLVM_CPPFLAGS $CPPFLAGS"
+  CXXFLAGS="$LLVM_CXXFLAGS $CXXFLAGS"
+  LIBS="$LLVM_LIBS $LIBS"
+  LDFLAGS="$LLVM_LDFLAGS $LDFLAGS"
+
+  AC_LANG_PUSH(C++)
+    AC_CHECK_HEADER([llvm/LLVMContext.h], [
+      AC_MSG_CHECKING([for llvm::getGlobalContext in llvm/LLVMContext.h])
+        AC_COMPILE_IFELSE(
+          [AC_LANG_PROGRAM([[#include <llvm/LLVMContext.h>]],
+                           [[llvm::LLVMContext& ctx = llvm::getGlobalContext ();]])],
+          [
+           AC_MSG_RESULT([yes])
+           warn_llvm=
+           XTRA_CXXFLAGS="$XTRA_CXXFLAGS $LLVM_CXXFLAGS $LLVM_CPPFLAGS"
+          ],
+          [AC_MSG_RESULT([no])
+      ])
+    ])
+  AC_LANG_POP(C++)
+  
+else
+  warn_llvm="LLVM_CONFIG not set. JIT compilation will be disabled."
+fi
+
+if test -z "$warn_llvm"; then
+  AC_DEFINE(HAVE_LLVM, 1, [Define if LLVM is available])
+else
+  LLVM_CXXFLAGS=
+  LLVM_CPPFLAGS=
+  LLVM_LDFLAGS=
+  LLVM_LIBS=
+  OCTAVE_CONFIGURE_WARNING([warn_llvm])
+fi
+
+AC_SUBST(LLVM_CXXFLAGS)
+AC_SUBST(LLVM_CPPFLAGS)
+AC_SUBST(LLVM_LDFLAGS)
+AC_SUBST(LLVM_LIBS)
+
+CPPFLAGS="$save_CPPFLAGS"
+CXXFLAGS="$save_CXXFLAGS"
+LIBS="$save_LIBS"
+LDFLAGS="$save_LDFLAGS"
+
 ### Check for HDF5 library.
 
 save_CPPFLAGS="$CPPFLAGS"
 CPPFLAGS="$Z_CPPFLAGS $CPPFLAGS"
 save_LIBS="$LIBS"
 LIBS="$Z_LDFLAGS $Z_LIBS $LIBS"
 OCTAVE_CHECK_LIBRARY(hdf5, HDF5,
   [HDF5 library not found.  Octave will not be able to save or load HDF5 data files.],
@@ -2743,27 +2833,30 @@ Octave is now configured for $canonical_
   DL libraries:                $DL_LIBS
   FFTW3 CPPFLAGS:              $FFTW3_CPPFLAGS
   FFTW3 LDFLAGS:               $FFTW3_LDFLAGS
   FFTW3 libraries:             $FFTW3_LIBS
   FFTW3F CPPFLAGS:             $FFTW3F_CPPFLAGS
   FFTW3F LDFLAGS:              $FFTW3F_LDFLAGS
   FFTW3F libraries:            $FFTW3F_LIBS
   fontconfig CFLAGS:           $FONTCONFIG_CFLAGS
-  fontconfig LIBS:             $FONTCONFIG_LIBS
-  FT2_CFLAGS:                  $FT2_CFLAGS
-  FT2_LIBS:                    $FT2_LIBS
+  fontconfig libraries:        $FONTCONFIG_LIBS
+  FreeType2 CFLAGS:            $FT2_CFLAGS
+  FreeType2 libraries:         $FT2_LIBS
   GLPK CPPFLAGS:               $GLPK_CPPFLAGS
   GLPK LDFLAGS:                $GLPK_LDFLAGS
   GLPK libraries:              $GLPK_LIBS
   graphics CFLAGS:             $GRAPHICS_CFLAGS
-  graphics LIBS:               $GRAPHICS_LIBS
+  graphics libraries:          $GRAPHICS_LIBS
   Magick++ CPPFLAGS:           $MAGICK_CPPFLAGS
   Magick++ LDFLAGS:            $MAGICK_LDFLAGS
   Magick++ libraries:          $MAGICK_LIBS
+  LLVM CPPFLAGS:               $LLVM_CPPFLAGS
+  LLVM LDFLAGS:                $LLVM_LDFLAGS
+  LLVM libraries:              $LLVM_LIBS
   HDF5 CPPFLAGS:               $HDF5_CPPFLAGS
   HDF5 LDFLAGS:                $HDF5_LDFLAGS
   HDF5 libraries:              $HDF5_LIBS
   LAPACK libraries:            $LAPACK_LIBS
   OPENGL libraries:            $OPENGL_LIBS
   PTHREAD flags:               $PTHREAD_CFLAGS
   PTHREAD libraries:           $PTHREAD_LIBS
   QHULL CPPFLAGS:              $QHULL_CPPFLAGS
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -304,16 +304,20 @@ cos (pi/2)
 
 @node Mathematical Constants
 @section Mathematical Constants
 
 @DOCSTRING(e)
 
 @DOCSTRING(pi)
 
+@c Provide a Seealso link location for these objects in the documentation
+@anchor{doc-i}
+@anchor{doc-j}
+@anchor{doc-J}
 @DOCSTRING(I)
 
 @DOCSTRING(Inf)
 
 @DOCSTRING(NaN)
 
 @DOCSTRING(eps)
 
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -130,17 +130,21 @@ Octave successfully built.  Now choose f
    make install    - to install (PREFIX=...)
 @end group
 @end example
 
 @node Basics of Generating a Changeset
 @section Basics of Generating a Changeset
 
 The preferable form of contribution is creating a Mercurial changeset
-and sending it via e-mail to the octave-maintainers mailing list.
+and submit it to the @uref{http://savannah.gnu.org/bugs/?group=octave, bug} or
+@uref{http://savannah.gnu.org/patch/?func=additem&group=octave, patch}
+trackers@footnote{Please use the patch tracker only for patches which add new
+features.  If you have a patch to submit that fixes a bug, you should use the
+bug tracker instead.}.
 Mercurial is the source code management system currently used to develop
 Octave.  Other forms of contributions (e.g., simple diff patches) are
 also acceptable, but they slow down the review process.  If you want to
 make more contributions, you should really get familiar with Mercurial.
 A good place to start is
 @url{http://www.selenic.com/mercurial/wiki/index.cgi/Tutorial}.  There
 you will also find help how to install Mercurial.
 
@@ -154,53 +158,52 @@ hg clone http://www.octave.org/hg/octave
 cd octave
 # change some sources@dots{}
 hg commit -m "make Octave the coolest software ever"
                              # commit the changeset into your
                              # local repository
 hg export -o ../cool.diff tip
                              # export the changeset to a diff
                              # file
-# send ../cool.diff via email
+# attach ../cool.diff to your bug report
 @end group
 @end example
 
 You may want to get familiar with Mercurial queues to manage your
 changesets.  Here is a slightly more complex example using Mercurial
 queues, where work on two unrelated changesets is done in parallel and
-one of the changesets is updated after discussion on the maintainers
-mailing list:
+one of the changesets is updated after discussion on the bug tracker:
 
 @example
 hg qnew nasty_bug            # create a new patch
 # change sources@dots{}
 hg qref                      # save the changes into the patch
 # change even more@dots{}
 hg qref -m "solution to nasty bug!"
                              # save again with commit message
 hg export -o ../nasty.diff tip
                              # export the patch
-# send ../nasty.diff via email
+# attach ../nasty.diff to your bug report
 hg qpop                      # undo the application of the patch
                              # and remove the changes from the
                              # source tree
 hg qnew doc_improvements     # create an unrelated patch
 # change doc sources@dots{}
 hg qref -m "could not find myfav.m in the doc"
                              # save the changes into the patch
 hg export -o ../doc.diff tip
                              # export the second patch
-# send ../doc.diff tip via email
+# attach ../doc.diff to your bug report
 hg qpop
-# discussion in the maintainers mailing list @dots{}
+# discussion in the bug tracker @dots{}
 hg qpush nasty_bug           # apply the patch again
 # change sources yet again @dots{}
 hg qref
 hg export -o ../nasty2.diff tip
-# send ../nasty2.diff via email
+# attach ../nasty2.diff to your bug report
 @end example
 
 @node General Guidelines
 @section General Guidelines
 
 All Octave's sources are distributed under the General Public License
 (GPL).  Currently, Octave uses GPL version 3.  For details about this
 license, see @url{http://www.gnu.org/licenses/gpl.html}.  Therefore,
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -445,16 +445,17 @@ ipermute
 ishandle
 ishghandle
 isolines
 isosurface
 isovalue
 isreal
 issparse
 isvector
+iter
 ith
 iy
 Jacobian
 Jacobians
 ji
 jpeg
 JPEG
 jpg
@@ -606,16 +607,17 @@ NaNs
 nargin
 nbincdf
 nbininv
 nbinpdf
 nbinrnd
 nd
 ndgrid
 ne
+Nelder
 neq
 Neudecker
 Neumann
 NeXT
 nfev
 nfft
 Ng
 ni
diff --git a/doc/interpreter/image.txi b/doc/interpreter/image.txi
--- a/doc/interpreter/image.txi
+++ b/doc/interpreter/image.txi
@@ -55,17 +55,17 @@ formats is supported.  The @code{imwrite
 for writing images to the disk.
 
 In summary, most image processing code will follow the structure of this code
 
 @example
 @group
 I = imread ("my_input_image.img");
 J = process_my_image (I);
-imwrite ("my_output_image.img", J);
+imwrite (J, "my_output_image.img");
 @end group
 @end example
 
 @DOCSTRING(imread)
 
 @DOCSTRING(imwrite)
 
 @DOCSTRING(IMAGE_PATH)
@@ -88,25 +88,25 @@ shows the image given in the first input
 
 @DOCSTRING(image)
 
 @DOCSTRING(imagesc)
 
 @node Representing Images
 @section Representing Images
 
-In general Octave supports four different kinds of images, gray-scale
-images, RGB images, binary images, and indexed images.  A gray-scale
+In general Octave supports four different kinds of images, grayscale
+images, RGB images, binary images, and indexed images.  A grayscale
 image is represented with an M-by-N matrix in which each
 element corresponds to the intensity of a pixel.  An RGB image is
 represented with an M-by-N-by-3 array where each
 3-vector corresponds to the red, green, and blue intensities of each
 pixel.
 
-The actual meaning of the value of a pixel in a gray-scale or RGB
+The actual meaning of the value of a pixel in a grayscale or RGB
 image depends on the class of the matrix.  If the matrix is of class
 @code{double} pixel intensities are between 0 and 1, if it is of class
 @code{uint8} intensities are between 0 and 255, and if it is of class
 @code{uint16} intensities are between 0 and 65535.
 
 A binary image is an M-by-N matrix of class @code{logical}.
 A pixel in a binary image is black if it is @code{false} and white
 if it is @code{true}.
@@ -182,16 +182,22 @@ The following three functions modify the
 replace it.   
 
 @DOCSTRING(brighten)
 
 @DOCSTRING(spinmap)
 
 @DOCSTRING(whitebg)
 
+The following functions can be used to manipulate colormaps.
+
+@DOCSTRING(cmunique)
+
+@DOCSTRING(cmpermute)
+
 @node Plotting on top of Images
 @section Plotting on top of Images
 
 If gnuplot is being used to display images it is possible to plot on
 top of images.  Since an image is a matrix it is indexed by row and
 column values.  The plotting system is, however, based on the 
 traditional @math{(x, y)} system.  To minimize the difference between
 the two systems Octave places the origin of the coordinate system in
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -234,17 +234,17 @@ Formatted data from can be read from, or
 * Saving Data on Unexpected Exits::
 @end menu
 
 @node Saving Data on Unexpected Exits
 @subsubsection Saving Data on Unexpected Exits
 
 If Octave for some reason exits unexpectedly it will by default save the
 variables available in the workspace to a file in the current directory.
-By default this file is named @samp{octave-core} and can be loaded
+By default this file is named @samp{octave-workspace} and can be loaded
 into memory with the @code{load} command.  While the default behavior
 most often is reasonable it can be changed through the following
 functions.
 
 @DOCSTRING(crash_dumps_octave_core)
 
 @DOCSTRING(sighup_dumps_octave_core)
 
diff --git a/doc/interpreter/nonlin.txi b/doc/interpreter/nonlin.txi
--- a/doc/interpreter/nonlin.txi
+++ b/doc/interpreter/nonlin.txi
@@ -167,22 +167,28 @@ which gives the same solution as before.
 @section Minimizers
 @cindex local minimum
 @cindex finding minimums
 
 Often it is useful to find the minimum value of a function rather than just
 the zeroes where it crosses the x-axis.  @code{fminbnd} is designed for the
 simpler, but very common, case of a univariate function where the interval
 to search is bounded.  For unbounded minimization of a function with
-potentially many variables use @code{fminunc}.  @xref{Optimization}, for
+potentially many variables use @code{fminunc} or @code{fminsearch}.  The two
+functions use different internal algorithms and some knowledge of the objective
+function is required.  For functions which can be differentiated, @code{fminunc}
+is appropriate.  For functions with discontinuities, or for which a gradient
+search would fail, use @code{fminsearch}.  @xref{Optimization}, for
 minimization with the presence of constraint functions.  Note that searches
 can be made for maxima by simply inverting the objective function
 @tex
 ($F_{max} = -F_{min}$).
 @end tex
 @ifnottex
 (@code{Fto_max = -Fto_min}).
 @end ifnottex
 
 @DOCSTRING(fminbnd)
 
 @DOCSTRING(fminunc)
 
+@DOCSTRING(fminsearch)
+
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -421,17 +421,17 @@ get_ra_idx (octave_idx_type idx, const d
   return retval;
 }
 
 dim_vector
 zero_dims_inquire (const Array<idx_vector>& ia, const dim_vector& rhdv)
 {
   int ial = ia.length (), rhdvl = rhdv.length ();
   dim_vector rdv = dim_vector::alloc (ial);
-  bool *scalar = new bool[ial], *colon = new bool[ial];
+  bool *scalar = new bool [ial], *colon = new bool [ial];
   // Mark scalars and colons, count non-scalar indices.
   int nonsc = 0;
   bool all_colons = true;
   for (int i = 0; i < ial; i++)
     {
       // FIXME -- should we check for length() instead?
       scalar[i] = ia(i).is_scalar ();
       colon[i] = ia(i).is_colon ();
@@ -440,17 +440,17 @@ zero_dims_inquire (const Array<idx_vecto
       all_colons = all_colons && colon[i];
     }
 
   // If the number of nonscalar indices matches the dimensionality of
   // RHS, we try an exact match, inquiring even singleton dimensions.
   if (all_colons)
     {
       rdv = rhdv;
-      rdv.resize(ial, 1);
+      rdv.resize (ial, 1);
     }
   else if (nonsc == rhdvl)
     {
       for (int i = 0, j = 0; i < ial; i++)
         {
           if (scalar[i]) continue;
           if (colon[i])
             rdv(i) = rhdv(j);
@@ -461,17 +461,17 @@ zero_dims_inquire (const Array<idx_vecto
     {
       dim_vector rhdv0 = rhdv;
       rhdv0.chop_all_singletons ();
       int rhdv0l = rhdv0.length ();
       for (int i = 0, j = 0; i < ial; i++)
         {
           if (scalar[i]) continue;
           if (colon[i])
-            rdv(i) =  (j < rhdv0l) ? rhdv0(j++) : 1;
+            rdv(i) = (j < rhdv0l) ? rhdv0(j++) : 1;
         }
     }
 
   delete [] scalar;
   delete [] colon;
 
   return rdv;
 }
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -644,17 +644,17 @@ public:
     : cext (0), sext (0), dext (0), n (0)
     {
       int l = ndv.length ();
       assert (odv.length () == l);
       octave_idx_type ld = 1;
       int i = 0;
       for (; i < l-1 && ndv(i) == odv(i); i++) ld *= ndv(i);
       n = l - i;
-      cext = new octave_idx_type[3*n];
+      cext = new octave_idx_type [3*n];
       // Trick to avoid three allocations
       sext = cext + n;
       dext = sext + n;
 
       octave_idx_type sld = ld, dld = ld;
       for (int j = 0; j < n; j++)
         {
           cext[j] = std::min (ndv(i+j), odv(i+j));
@@ -718,27 +718,27 @@ Array<T>::index (const idx_vector& i) co
         gripe_index_out_of_range (1, 1, i.extent (n), n); // throws
 
       // FIXME -- this is the only place where orig_dimensions are used.
       dim_vector rd = i.orig_dimensions ();
       octave_idx_type il = i.length (n);
 
       // FIXME -- this is for Matlab compatibility.  Matlab 2007 given
       //
-      //   b = ones(3,1)
+      //   b = ones (3,1)
       //
       // yields the following:
       //
-      //   b(zeros(0,0)) gives []
-      //   b(zeros(1,0)) gives zeros(0,1)
-      //   b(zeros(0,1)) gives zeros(0,1)
-      //   b(zeros(0,m)) gives zeros(0,m)
-      //   b(zeros(m,0)) gives zeros(m,0)
-      //   b(1:2) gives ones(2,1)
-      //   b(ones(2)) gives ones(2) etc.
+      //   b(zeros (0,0)) gives []
+      //   b(zeros (1,0)) gives zeros (0,1)
+      //   b(zeros (0,1)) gives zeros (0,1)
+      //   b(zeros (0,m)) gives zeros (0,m)
+      //   b(zeros (m,0)) gives zeros (m,0)
+      //   b(1:2) gives ones (2,1)
+      //   b(ones (2)) gives ones (2) etc.
       //
       // As you can see, the behaviour is weird, but the tests end up pretty
       // simple.  Nah, I don't want to suggest that this is ad hoc :)
 
       if (ndims () == 2 && n != 1 && rd.is_vector ())
         {
           if (columns () == 1)
             rd = dim_vector (il, 1);
@@ -2218,23 +2218,23 @@ Array<T>::find (octave_idx_type n, bool 
                 break;
             }
           if (k < n)
             retval.resize2 (k, 1);
         }
     }
 
   // Fixup return dimensions, for Matlab compatibility.
-  // find(zeros(0,0)) -> zeros(0,0)
-  // find(zeros(1,0)) -> zeros(1,0)
-  // find(zeros(0,1)) -> zeros(0,1)
-  // find(zeros(0,X)) -> zeros(0,1)
-  // find(zeros(1,1)) -> zeros(0,0) !!!! WHY?
-  // find(zeros(0,1,0)) -> zeros(0,0)
-  // find(zeros(0,1,0,1)) -> zeros(0,0) etc
+  // find (zeros (0,0)) -> zeros (0,0)
+  // find (zeros (1,0)) -> zeros (1,0)
+  // find (zeros (0,1)) -> zeros (0,1)
+  // find (zeros (0,X)) -> zeros (0,1)
+  // find (zeros (1,1)) -> zeros (0,0) !!!! WHY?
+  // find (zeros (0,1,0)) -> zeros (0,0)
+  // find (zeros (0,1,0,1)) -> zeros (0,0) etc
 
   if ((numel () == 1 && retval.is_empty ())
       || (rows () == 0 && dims ().numel (1) == 0))
     retval.dimensions = dim_vector ();
   else if (rows () == 1 && ndims () == 2)
     retval.dimensions = dim_vector (1, retval.length ());
 
   return retval;
@@ -2736,29 +2736,29 @@ operator << (std::ostream& os, const Arr
               cols = a_dims(1);
 
               for (octave_idx_type j = 0; j < rows; j++)
                 {
                   ra_idx(0) = j;
                   for (octave_idx_type k = 0; k < cols; k++)
                     {
                       ra_idx(1) = k;
-                      os << " " << a.elem(ra_idx);
+                      os << " " << a.elem (ra_idx);
                     }
                   os << "\n";
                 }
               break;
 
             default:
               rows = a_dims(0);
 
               for (octave_idx_type k = 0; k < rows; k++)
                 {
                   ra_idx(0) = k;
-                  os << " " << a.elem(ra_idx);
+                  os << " " << a.elem (ra_idx);
                 }
               break;
             }
 
           os << "\n";
         }
       else
         {
@@ -2776,17 +2776,17 @@ operator << (std::ostream& os, const Arr
 
               for (octave_idx_type j = 0; j < rows; j++)
                 {
                   ra_idx(0) = j;
 
                   for (octave_idx_type k = 0; k < cols; k++)
                     {
                       ra_idx(1) = k;
-                      os << " " << a.elem(ra_idx);
+                      os << " " << a.elem (ra_idx);
                     }
 
                   os << "\n";
                 }
 
               os << "\n";
 
               if (i != m - 1)
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -159,16 +159,24 @@ private:
       // NR was originally allocated with new, but that does not seem
       // to be necessary since it will never be deleted.  So just use
       // a static object instead.
 
       static typename Array<T>::ArrayRep nr;
       return &nr;
     }
 
+protected:
+
+  // For jit support
+  Array (T *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
+    : dimensions (adims),
+      rep (reinterpret_cast<typename Array<T>::ArrayRep *> (arep)),
+      slice_data (sdata), slice_len (slen) {}
+
 public:
 
   // Empty ctor (0x0).
 
   Array (void)
     : dimensions (), rep (nil_rep ()), slice_data (rep->data),
       slice_len (rep->len)
     {
@@ -319,18 +327,18 @@ public:
   octave_idx_type compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k) const;
   octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx) const;
 
   octave_idx_type compute_index_unchecked (const Array<octave_idx_type>& ra_idx) const
     { return dimensions.compute_index (ra_idx.data (), ra_idx.length ()); }
 
   // No checking, even for multiple references, ever.
 
-  T& xelem (octave_idx_type n) { return slice_data [n]; }
-  crefT xelem (octave_idx_type n) const { return slice_data [n]; }
+  T& xelem (octave_idx_type n) { return slice_data[n]; }
+  crefT xelem (octave_idx_type n) const { return slice_data[n]; }
 
   T& xelem (octave_idx_type i, octave_idx_type j) { return xelem (dim1 ()*j+i); }
   crefT xelem (octave_idx_type i, octave_idx_type j) const { return xelem (dim1 ()*j+i); }
 
   T& xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
     { return xelem (i, dim2 ()*k+j); }
   crefT xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
     { return xelem (i, dim2 ()*k+j); }
@@ -688,16 +696,26 @@ public:
 
   template <class U> friend class Array;
 
   // Returns true if this->dims () == dv, and if so, replaces this->dimensions
   // by a shallow copy of dv. This is useful for maintaining several arrays with
   // supposedly equal dimensions (e.g. structs in the interpreter).
   bool optimize_dimensions (const dim_vector& dv);
 
+  // WARNING: Only call these functions from jit
+
+  int *jit_ref_count (void) { return rep->count.get (); }
+
+  T *jit_slice_data (void) const { return slice_data; }
+
+  octave_idx_type *jit_dimensions (void) const { return dimensions.to_jit (); }
+
+  void *jit_array_rep (void) const { return rep; }
+
 private:
 
   void resize2 (octave_idx_type nr, octave_idx_type nc, const T& rfv);
   void resize2 (octave_idx_type nr, octave_idx_type nc)                
   {
     resize2 (nr, nc, resize_fill_value ());
   }
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1074,27 +1074,27 @@ ComplexMatrix::finverse (MatrixType &mat
       Array<Complex> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
                                  z.fortran_vec (), lwork, info));
 
-      lwork = static_cast<octave_idx_type> (std::real(z(0)));
+      lwork = static_cast<octave_idx_type> (std::real (z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (dim_vector (lwork, 1));
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
-        anorm  = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1158,17 +1158,17 @@ ComplexMatrix::inverse (MatrixType &matt
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (!mattype.is_hermitian ())
-        ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = ComplexMatrix (rows (), columns (), Complex (octave_Inf, 0.));
     }
 
   return ret;
 }
 
@@ -1827,17 +1827,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-              if(anorm < 0.)
+              if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
@@ -2095,17 +2095,17 @@ ComplexMatrix::fsolve (MatrixType &matty
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -2179,17 +2179,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2405,17 +2405,17 @@ ComplexMatrix::solve (MatrixType &typ, c
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   ComplexMatrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
-  return tmp.column(static_cast<octave_idx_type> (0));
+  return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -235,17 +235,17 @@ ComplexNDArray::fourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
@@ -282,17 +282,17 @@ ComplexNDArray::ifourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<double> (npts);
         }
     }
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -167,37 +167,37 @@ SparseComplexMatrix::SparseComplexMatrix
       if (a(i, i) != 0.0)
         {
           data (j) = a(i, i);
           ridx (j) = i;
           j++;
         }
     }
   for (octave_idx_type i = l; i <= a.cols (); i++)
-    cidx(i) = j;
+    cidx (i) = j;
 }
 bool
 SparseComplexMatrix::operator == (const SparseComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz = nnz ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    if (cidx(i) != a.cidx(i))
+    if (cidx (i) != a.cidx (i))
         return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
-    if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
+    if (data (i) != a.data (i) || ridx (i) != a.ridx (i))
       return false;
 
   return true;
 }
 
 bool
 SparseComplexMatrix::operator != (const SparseComplexMatrix& a) const
 {
@@ -209,29 +209,29 @@ SparseComplexMatrix::is_hermitian (void)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == nc && nr > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              octave_idx_type ri = ridx(i);
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              octave_idx_type ri = ridx (i);
 
               if (ri != j)
                 {
                   bool found = false;
 
-                  for (octave_idx_type k = cidx(ri); k < cidx(ri+1); k++)
+                  for (octave_idx_type k = cidx (ri); k < cidx (ri+1); k++)
                     {
-                      if (ridx(k) == j)
+                      if (ridx (k) == j)
                         {
-                          if (data(i) == conj(data(k)))
+                          if (data (i) == conj (data (k)))
                             found = true;
                           break;
                         }
                     }
 
                   if (! found)
                     return false;
                 }
@@ -272,31 +272,31 @@ SparseComplexMatrix::max (Array<octave_i
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp_max;
           double abs_max = octave_NaN;
           octave_idx_type idx_j = 0;
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              if (ridx(i) != idx_j)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
 
           if (idx_j != nr)
             {
               tmp_max = 0.;
               abs_max = 0.;
             }
 
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               Complex tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
 
               double abs_tmp = std::abs (tmp);
 
@@ -327,55 +327,55 @@ SparseComplexMatrix::max (Array<octave_i
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, 1), 0);
 
-      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-        idx_arg.elem(ridx(i)) = -1;
+      for (octave_idx_type i = cidx (0); i < cidx (1); i++)
+        idx_arg.elem (ridx (i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            if (idx_arg.elem(i) != -1)
+            if (idx_arg.elem (i) != -1)
               continue;
             bool found = false;
-            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-              if (ridx(k) == i)
+            for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
+              if (ridx (k) == i)
                 {
                   found = true;
                   break;
                 }
 
             if (!found)
-              idx_arg.elem(i) = j;
+              idx_arg.elem (i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               Complex tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
-              else if (ix == -1 || std::abs(tmp) > std::abs(elem (ir, ix)))
+              else if (ix == -1 || std::abs (tmp) > std::abs (elem (ir, ix)))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+        if (idx_arg.elem (j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
           nel++;
 
       result = SparseComplexMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -427,31 +427,31 @@ SparseComplexMatrix::min (Array<octave_i
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp_min;
           double abs_min = octave_NaN;
           octave_idx_type idx_j = 0;
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              if (ridx(i) != idx_j)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
 
           if (idx_j != nr)
             {
               tmp_min = 0.;
               abs_min = 0.;
             }
 
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               Complex tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
 
               double abs_tmp = std::abs (tmp);
 
@@ -482,55 +482,55 @@ SparseComplexMatrix::min (Array<octave_i
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, 1), 0);
 
-      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-        idx_arg.elem(ridx(i)) = -1;
+      for (octave_idx_type i = cidx (0); i < cidx (1); i++)
+        idx_arg.elem (ridx (i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            if (idx_arg.elem(i) != -1)
+            if (idx_arg.elem (i) != -1)
               continue;
             bool found = false;
-            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-              if (ridx(k) == i)
+            for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
+              if (ridx (k) == i)
                 {
                   found = true;
                   break;
                 }
 
             if (!found)
-              idx_arg.elem(i) = j;
+              idx_arg.elem (i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               Complex tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
-              else if (ix == -1 || std::abs(tmp) < std::abs(elem (ir, ix)))
+              else if (ix == -1 || std::abs (tmp) < std::abs (elem (ir, ix)))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+        if (idx_arg.elem (j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
           nel++;
 
       result = SparseComplexMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -658,17 +658,17 @@ SparseComplexMatrix::hermitian (void) co
     {
       const octave_idx_type tmp = retval.xcidx (i);
       retval.xcidx (i) = nz;
       nz += tmp;
     }
   // retval.xcidx[1:nr] holds row entry *start* offsets for rows 0:(nr-1)
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+    for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
       {
         octave_idx_type q = retval.xcidx (ridx (k) + 1)++;
         retval.xridx (q) = j;
         retval.xdata (q) = conj (data (k));
       }
   assert (nnz () == retval.xcidx (nr));
   // retval.xcidx[1:nr] holds row entry *end* offsets for rows 0:(nr-1)
   // and retval.xcidx[0:(nr-1)] holds their row entry *start* offsets
@@ -750,17 +750,17 @@ SparseComplexMatrix::dinverse (MatrixTyp
           // Force make_unique to be called
           Complex *v = retval.data ();
 
           if (calccond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
-                  double tmp = std::abs(v[i]);
+                  double tmp = std::abs (v[i]);
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
 
@@ -800,18 +800,18 @@ SparseComplexMatrix::tinverse (MatrixTyp
           double ainvnorm = 0.;
 
           if (calccond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Upper || typ == MatrixType::Lower)
             {
               octave_idx_type nz = nnz ();
@@ -826,102 +826,102 @@ SparseComplexMatrix::tinverse (MatrixTyp
                   octave_idx_type cx_colstart = cx;
 
                   if (cx == nz2)
                     {
                       nz2 *= 2;
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx(i) = cx;
-                  retval.xridx(cx) = i;
-                  retval.xdata(cx) = 1.0;
+                  retval.xcidx (i) = cx;
+                  retval.xridx (cx) = i;
+                  retval.xdata (cx) = 1.0;
                   cx++;
 
                   // iterate accross columns of input matrix
                   for (octave_idx_type j = i+1; j < nr; j++)
                     {
                       Complex v = 0.;
                       // iterate to calculate sum
-                      octave_idx_type colXp = retval.xcidx(i);
-                      octave_idx_type colUp = cidx(j);
+                      octave_idx_type colXp = retval.xcidx (i);
+                      octave_idx_type colUp = cidx (j);
                       octave_idx_type rpX, rpU;
 
-                      if (cidx(j) == cidx(j+1))
+                      if (cidx (j) == cidx (j+1))
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       do
                         {
                           octave_quit ();
-                          rpX = retval.xridx(colXp);
-                          rpU = ridx(colUp);
+                          rpX = retval.xridx (colXp);
+                          rpU = ridx (colUp);
 
                           if (rpX < rpU)
                             colXp++;
                           else if (rpX > rpU)
                             colUp++;
                           else
                             {
-                              v -= retval.xdata(colXp) * data(colUp);
+                              v -= retval.xdata (colXp) * data (colUp);
                               colXp++;
                               colUp++;
                             }
                         } while ((rpX<j) && (rpU<j) &&
                                  (colXp<cx) && (colUp<nz));
 
 
                       // get A(m,m)
                       if (typ == MatrixType::Upper)
-                        colUp = cidx(j+1) - 1;
+                        colUp = cidx (j+1) - 1;
                       else
-                        colUp = cidx(j);
-                      Complex pivot = data(colUp);
-                      if (pivot == 0. || ridx(colUp) != j)
+                        colUp = cidx (j);
+                      Complex pivot = data (colUp);
+                      if (pivot == 0. || ridx (colUp) != j)
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       if (v != 0.)
                         {
                           if (cx == nz2)
                             {
                               nz2 *= 2;
                               retval.change_capacity (nz2);
                             }
 
-                          retval.xridx(cx) = j;
-                          retval.xdata(cx) = v / pivot;
+                          retval.xridx (cx) = j;
+                          retval.xdata (cx) = v / pivot;
                           cx++;
                         }
                     }
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Upper)
-                    colUp = cidx(i+1) - 1;
+                    colUp = cidx (i+1) - 1;
                   else
-                    colUp = cidx(i);
-                  Complex pivot = data(colUp);
-                  if (pivot == 0. || ridx(colUp) != i)
+                    colUp = cidx (i);
+                  Complex pivot = data (colUp);
+                  if (pivot == 0. || ridx (colUp) != i)
                     {
                       (*current_liboctave_error_handler) ("division by zero");
                       goto inverse_singular;
                     }
 
                   if (pivot != 1.0)
                     for (octave_idx_type j = cx_colstart; j < cx; j++)
-                      retval.xdata(j) /= pivot;
-                }
-              retval.xcidx(nr) = cx;
+                      retval.xdata (j) /= pivot;
+                }
+              retval.xcidx (nr) = cx;
               retval.maybe_compress ();
             }
           else
             {
               octave_idx_type nz = nnz ();
               octave_idx_type cx = 0;
               octave_idx_type nz2 = nz;
               retval = SparseComplexMatrix (nr, nc, nz2);
@@ -955,47 +955,47 @@ SparseComplexMatrix::tinverse (MatrixTyp
                   work[iidx] = 1.0;
 
                   // iterate accross columns of input matrix
                   for (octave_idx_type j = iidx+1; j < nr; j++)
                     {
                       Complex v = 0.;
                       octave_idx_type jidx = perm[j];
                       // iterate to calculate sum
-                      for (octave_idx_type k = cidx(jidx);
-                           k < cidx(jidx+1); k++)
+                      for (octave_idx_type k = cidx (jidx);
+                           k < cidx (jidx+1); k++)
                         {
                           octave_quit ();
-                          v -= work[ridx(k)] * data(k);
+                          v -= work[ridx (k)] * data (k);
                         }
 
                       // get A(m,m)
                       Complex pivot;
                       if (typ == MatrixType::Permuted_Upper)
-                        pivot = data(cidx(jidx+1) - 1);
+                        pivot = data (cidx (jidx+1) - 1);
                       else
-                        pivot = data(cidx(jidx));
+                        pivot = data (cidx (jidx));
                       if (pivot == 0.)
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       work[j] = v / pivot;
                     }
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Permuted_Upper)
-                    colUp = cidx(perm[iidx]+1) - 1;
+                    colUp = cidx (perm[iidx]+1) - 1;
                   else
-                    colUp = cidx(perm[iidx]);
-
-                  Complex pivot = data(colUp);
+                    colUp = cidx (perm[iidx]);
+
+                  Complex pivot = data (colUp);
                   if (pivot == 0.)
                     {
                       (*current_liboctave_error_handler)
                         ("division by zero");
                       goto inverse_singular;
                     }
 
                   octave_idx_type new_cx = cx;
@@ -1008,38 +1008,38 @@ SparseComplexMatrix::tinverse (MatrixTyp
                       }
 
                   if (cx < new_cx)
                     {
                       nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx(i) = cx;
+                  retval.xcidx (i) = cx;
                   for (octave_idx_type j = iidx; j < nr; j++)
                     if (work[j] != 0.)
                       {
-                        retval.xridx(cx) = j;
-                        retval.xdata(cx++) = work[j];
+                        retval.xridx (cx) = j;
+                        retval.xdata (cx++) = work[j];
                       }
                 }
 
-              retval.xcidx(nr) = cx;
+              retval.xcidx (nr) = cx;
               retval.maybe_compress ();
             }
 
           if (calccond)
             {
               // Calculate the 1-norm of inverse matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = retval.cidx(j);
-                       i < retval.cidx(j+1); i++)
-                    atmp += std::abs(retval.data(i));
+                  for (octave_idx_type i = retval.cidx (j);
+                       i < retval.cidx (j+1); i++)
+                    atmp += std::abs (retval.data (i));
                   if (atmp > ainvnorm)
                     ainvnorm = atmp;
                 }
 
               rcond = 1. / ainvnorm / anorm;
             }
         }
       else
@@ -1078,17 +1078,17 @@ SparseComplexMatrix::inverse (MatrixType
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexCHOL fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
               SparseComplexMatrix InvL = fact.L ().transpose ().
-                tinverse(tmp_typ, info, rcond2, true, false);
+                tinverse (tmp_typ, info, rcond2, true, false);
               ret = Q * InvL.hermitian () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
@@ -1101,19 +1101,19 @@ SparseComplexMatrix::inverse (MatrixType
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexLU fact (*this, Qinit, Matrix (), false, false);
           rcond = fact.rcond ();
           double rcond2;
           SparseComplexMatrix InvL = fact.L ().transpose ().
-            tinverse(tmp_typ, info, rcond2, true, false);
+            tinverse (tmp_typ, info, rcond2, true, false);
           SparseComplexMatrix InvU = fact.U ().
-            tinverse(tmp_typ, info, rcond2, true, false).transpose ();
+            tinverse (tmp_typ, info, rcond2, true, false).transpose ();
           ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
 ComplexDET
@@ -1274,33 +1274,33 @@ SparseComplexMatrix::dsolve (MatrixType 
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols (), Complex(0.,0.));
+          retval.resize (nc, b.cols (), Complex (0.,0.));
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                  retval(k,j) = b(ridx(i),j) / data (i);
+                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                  retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = std::abs(data(i));
+                  double tmp = std::abs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1339,59 +1339,59 @@ SparseComplexMatrix::dsolve (MatrixType 
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
-                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                   {
-                    if (b.ridx(i) >= nm)
+                    if (b.ridx (i) >= nm)
                       break;
-                    retval.xridx (ii) = b.ridx(i);
-                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                    retval.xridx (ii) = b.ridx (i);
+                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
                   }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
-                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-                        if (ridx(i) == b.ridx(k))
+                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                        if (ridx (i) == b.ridx (k))
                           {
                             found = true;
                             break;
                           }
                       if (found)
                         {
                           retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data(k) / data (i);
+                          retval.xdata (ii++) = b.data (k) / data (i);
                         }
                     }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = std::abs(data(i));
+                  double tmp = std::abs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1426,33 +1426,33 @@ SparseComplexMatrix::dsolve (MatrixType 
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols (), Complex(0.,0.));
+          retval.resize (nc, b.cols (), Complex (0.,0.));
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                  retval(k,j) = b(ridx(i),j) / data (i);
+                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                  retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
-                  double tmp = std::abs(data(i));
+                  double tmp = std::abs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1491,59 +1491,59 @@ SparseComplexMatrix::dsolve (MatrixType 
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
-                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                   {
-                    if (b.ridx(i) >= nm)
+                    if (b.ridx (i) >= nm)
                       break;
-                    retval.xridx (ii) = b.ridx(i);
-                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                    retval.xridx (ii) = b.ridx (i);
+                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
                   }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
-                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-                        if (ridx(i) == b.ridx(k))
+                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                        if (ridx (i) == b.ridx (k))
                           {
                             found = true;
                             break;
                           }
                       if (found)
                         {
                           retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data(k) / data (i);
+                          retval.xdata (ii++) = b.data (k) / data (i);
                         }
                     }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = std::abs(data(i));
+                  double tmp = std::abs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1589,18 +1589,18 @@ SparseComplexMatrix::utsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Upper)
             {
               retval.resize (nc, b_nc);
@@ -1615,30 +1615,30 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(perm[i], j) = work[i];
                 }
 
@@ -1653,30 +1653,30 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -1691,29 +1691,29 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -1726,30 +1726,30 @@ SparseComplexMatrix::utsolve (MatrixType
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              Complex tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -1824,66 +1824,66 @@ SparseComplexMatrix::utsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               octave_idx_type *perm = mattype.triangular_perm ();
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 rperm[perm[i]] = i;
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -1896,20 +1896,20 @@ SparseComplexMatrix::utsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[rperm[i]] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[rperm[i]];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[rperm[i]];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -1920,66 +1920,66 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -1992,20 +1992,20 @@ SparseComplexMatrix::utsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2014,30 +2014,30 @@ SparseComplexMatrix::utsolve (MatrixType
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              Complex tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2112,18 +2112,18 @@ SparseComplexMatrix::utsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Upper)
             {
               retval.resize (nc, b_nc);
@@ -2138,30 +2138,30 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(perm[i], j) = work[i];
                 }
 
@@ -2176,30 +2176,30 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2214,29 +2214,29 @@ SparseComplexMatrix::utsolve (MatrixType
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -2249,30 +2249,30 @@ SparseComplexMatrix::utsolve (MatrixType
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              Complex tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2347,66 +2347,66 @@ SparseComplexMatrix::utsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               octave_idx_type *perm = mattype.triangular_perm ();
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 rperm[perm[i]] = i;
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2419,20 +2419,20 @@ SparseComplexMatrix::utsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[rperm[i]] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[rperm[i]];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[rperm[i]];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2443,66 +2443,66 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(iidx+1)-1);
+                              Complex tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nr-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k+1)-1);
+                          Complex tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2515,20 +2515,20 @@ SparseComplexMatrix::utsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2537,30 +2537,30 @@ SparseComplexMatrix::utsolve (MatrixType
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k+1)-1);
+                              Complex tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2636,18 +2636,18 @@ SparseComplexMatrix::ltsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Lower)
             {
               retval.resize (nc, b_nc);
@@ -2663,38 +2663,38 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(mini);
+                          Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(i, j) = work[i];
                 }
 
@@ -2710,42 +2710,42 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              Complex tmp = work[k] / data(mini);
+                              Complex tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2759,29 +2759,29 @@ SparseComplexMatrix::ltsolve (MatrixType
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k));
+                          Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
               if (calc_cond)
@@ -2794,30 +2794,30 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k));
+                              Complex tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2892,71 +2892,71 @@ SparseComplexMatrix::ltsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
               octave_idx_type *perm = mattype.triangular_perm ();
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[perm[b.ridx(i)]] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[perm[b.ridx (i)]] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(mini);
+                          Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2969,20 +2969,20 @@ SparseComplexMatrix::ltsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2994,78 +2994,78 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              Complex tmp = work[k] / data(mini);
+                              Complex tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k));
+                          Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3078,20 +3078,20 @@ SparseComplexMatrix::ltsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3101,30 +3101,30 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k));
+                              Complex tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3200,18 +3200,18 @@ SparseComplexMatrix::ltsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Lower)
             {
               retval.resize (nc, b_nc);
@@ -3227,38 +3227,38 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(mini);
+                          Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(i, j) = work[i];
                 }
 
@@ -3274,42 +3274,42 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              Complex tmp = work[k] / data(mini);
+                              Complex tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3325,29 +3325,29 @@ SparseComplexMatrix::ltsolve (MatrixType
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k));
+                          Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -3361,30 +3361,30 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k));
+                              Complex tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3459,71 +3459,71 @@ SparseComplexMatrix::ltsolve (MatrixType
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
               octave_idx_type *perm = mattype.triangular_perm ();
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[perm[b.ridx(i)]] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[perm[b.ridx (i)]] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(mini);
+                          Complex tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3536,20 +3536,20 @@ SparseComplexMatrix::ltsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3561,78 +3561,78 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              Complex tmp = work[k] / data(mini);
+                              Complex tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = work[k] / data(cidx(k));
+                          Complex tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3645,20 +3645,20 @@ SparseComplexMatrix::ltsolve (MatrixType
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3668,30 +3668,30 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              Complex tmp = work[k] / data(cidx(k));
+                              Complex tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += std::abs(work[i]);
+                          atmp += std::abs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3766,38 +3766,38 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = std::real(data(ii++));
-                  DL[j] = data(ii);
+                  D[j] = std::real (data (ii++));
+                  DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = std::real(data(ii));
+              D[nc-1] = std::real (data (ii));
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = std::real(data(i));
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = std::real (data (i));
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
@@ -3820,41 +3820,41 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
@@ -3923,41 +3923,41 @@ SparseComplexMatrix::trisolve (MatrixTyp
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
           if (err != 0)
             {
               err = -2;
@@ -3974,28 +3974,28 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
             }
           else
             {
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseComplexMatrix (nr, b_nc, x_nz);
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               volatile octave_idx_type ii = 0;
               rcond = 1.0;
 
               OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              work, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   // Count non-zeros in work vector and adjust
@@ -4011,20 +4011,20 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4064,38 +4064,38 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = std::real(data(ii++));
-                  DL[j] = data(ii);
+                  D[j] = std::real (data (ii++));
+                  DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = std::real(data(ii));
+              D[nc-1] = std::real (data (ii));
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = std::real (data(i));
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = std::real (data (i));
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
@@ -4119,41 +4119,41 @@ SparseComplexMatrix::trisolve (MatrixTyp
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
@@ -4223,41 +4223,41 @@ SparseComplexMatrix::trisolve (MatrixTyp
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
@@ -4281,17 +4281,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b (i,j);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
@@ -4321,21 +4321,21 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (Bx[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = Bx[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = Bx[i];
                       }
 
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4378,27 +4378,27 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4485,28 +4485,28 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4627,27 +4627,27 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4701,17 +4701,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
                   // Take a first guess that the number of non-zero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b.elem (i, j);
 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
@@ -4735,21 +4735,21 @@ SparseComplexMatrix::bsolve (MatrixType 
                                 {
                                   // Resize the sparse matrix
                                   octave_idx_type sz = x_nz *
                                     (b_nc - j) / b_nc;
                                   sz = (sz > 10 ? sz : 10) + x_nz;
                                   retval.change_capacity (sz);
                                   x_nz = sz;
                                 }
-                              retval.xdata(ii) = tmp;
-                              retval.xridx(ii++) = i;
+                              retval.xdata (ii) = tmp;
+                              retval.xridx (ii++) = i;
                             }
                         }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
@@ -4767,28 +4767,28 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4850,28 +4850,28 @@ SparseComplexMatrix::bsolve (MatrixType 
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
-                      for (octave_idx_type i = b.cidx(j);
-                           i < b.cidx(j+1); i++)
-                        work[b.ridx(i)] = b.data(i);
+                      for (octave_idx_type i = b.cidx (j);
+                           i < b.cidx (j+1); i++)
+                        work[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, work, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       // Count non-zeros in work vector and adjust
@@ -4887,20 +4887,20 @@ SparseComplexMatrix::bsolve (MatrixType 
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) = work[i];
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) = work[i];
                           }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
@@ -4945,27 +4945,27 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5052,28 +5052,28 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5191,27 +5191,27 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5268,17 +5268,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
                   // Take a first guess that the number of non-zero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b (i,j);
 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
@@ -5307,21 +5307,21 @@ SparseComplexMatrix::bsolve (MatrixType 
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) = Bx[i];
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) = Bx[i];
                           }
 
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
@@ -5339,28 +5339,28 @@ SparseComplexMatrix::bsolve (MatrixType 
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += std::abs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5422,29 +5422,29 @@ SparseComplexMatrix::bsolve (MatrixType 
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         Bx[i] = 0.;
 
-                      for (octave_idx_type i = b.cidx(j);
-                           i < b.cidx(j+1); i++)
-                        Bx[b.ridx(i)] = b.data(i);
+                      for (octave_idx_type i = b.cidx (j);
+                           i < b.cidx (j+1); i++)
+                        Bx[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       // Count non-zeros in work vector and adjust
@@ -5460,20 +5460,20 @@ SparseComplexMatrix::bsolve (MatrixType 
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) = Bx[i];
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) = Bx[i];
                           }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
@@ -5731,17 +5731,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval.resize (b.rows (), b.cols ());
               for (octave_idx_type j = 0; j < b.cols (); j++)
                 {
                   octave_idx_type jr = j * b.rows ();
                   for (octave_idx_type i = 0; i < b.rows (); i++)
-                    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
+                    retval.xelem (i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -5985,22 +5985,22 @@ SparseComplexMatrix::fsolve (MatrixType 
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
                 (static_cast<octave_idx_type>(X->nrow),
                  static_cast<octave_idx_type>(X->ncol),
                  static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
-                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+                retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
-                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-                  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
+                  retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6045,17 +6045,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
 #ifdef UMFPACK_SEPARATE_SPLIT
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
@@ -6100,21 +6100,21 @@ SparseComplexMatrix::fsolve (MatrixType 
                           if (ii == x_nz)
                             {
                               // Resize the sparse matrix
                               octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
                               sz = (sz > 10 ? sz : 10) + x_nz;
                               retval.change_capacity (sz);
                               x_nz = sz;
                             }
-                          retval.xdata(ii) = tmp;
-                          retval.xridx(ii++) = i;
+                          retval.xdata (ii) = tmp;
+                          retval.xridx (ii++) = i;
                         }
                     }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
@@ -6265,17 +6265,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval.resize (b.rows (), b.cols ());
               for (octave_idx_type j = 0; j < b.cols (); j++)
                 {
                   octave_idx_type jr = j * b.rows ();
                   for (octave_idx_type i = 0; i < b.rows (); i++)
-                    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
+                    retval.xelem (i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6498,22 +6498,22 @@ SparseComplexMatrix::fsolve (MatrixType 
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
                 (static_cast<octave_idx_type>(X->nrow),
                  static_cast<octave_idx_type>(X->ncol),
                  static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
-                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+                retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
-                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-                  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
+                  retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6551,17 +6551,17 @@ SparseComplexMatrix::fsolve (MatrixType 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b (i,j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
                                              Ai,
                                              reinterpret_cast<const double *> (Ax),
@@ -6591,21 +6591,21 @@ SparseComplexMatrix::fsolve (MatrixType 
                           if (ii == x_nz)
                             {
                               // Resize the sparse matrix
                               octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
                               sz = (sz > 10 ? sz : 10) + x_nz;
                               retval.change_capacity (sz);
                               x_nz = sz;
                             }
-                          retval.xdata(ii) = tmp;
-                          retval.xridx(ii++) = i;
+                          retval.xdata (ii) = tmp;
+                          retval.xridx (ii++) = i;
                         }
                     }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               rcond = Info (UMFPACK_RCOND);
               volatile double rcond_plus_one = rcond + 1.0;
 
               if (status == UMFPACK_WARNING_singular_matrix ||
@@ -6689,17 +6689,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
         Matrix> (*this, b, err);
 #endif
@@ -6757,17 +6757,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
         SparseMatrix> (*this, b, err);
 #endif
@@ -6825,17 +6825,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
         ComplexMatrix> (*this, b, err);
 #endif
@@ -6894,17 +6894,17 @@ SparseComplexMatrix::solve (MatrixType &
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
         SparseComplexMatrix> (*this, b, err);
 #endif
@@ -7172,22 +7172,22 @@ SparseComplexMatrix::operator ! (void) c
 
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
         {
-          if (jj < cidx(i+1) && ridx(jj) == j)
+          if (jj < cidx (i+1) && ridx (jj) == j)
             jj++;
           else
             {
-              r.data(ii) = true;
-              r.ridx(ii++) = j;
+              r.data (ii) = true;
+              r.ridx (ii++) = j;
             }
         }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
@@ -7262,18 +7262,18 @@ SparseComplexMatrix::all_elements_are_re
 bool
 SparseComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
   octave_idx_type nel = nnz ();
 
   if (nel == 0)
     return false;
 
-  max_val = std::real(data (0));
-  min_val = std::real(data (0));
+  max_val = std::real (data (0));
+  min_val = std::real (data (0));
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
         Complex val = data (i);
 
         double r_val = std::real (val);
         double i_val = std::imag (val);
 
@@ -7348,36 +7348,36 @@ SparseComplexMatrix::cumsum (int dim) co
 SparseComplexMatrix
 SparseComplexMatrix::prod (int dim) const
 {
   if ((rows () == 1 && dim == -1) || dim == 1)
     return transpose (). prod (0). transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=,
-                           (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
+                           (cidx (j+1) - cidx (j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, +=, 0.0, 0.0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::sumsq (int dim) const
 {
 #define ROW_EXPR \
   Complex d = data (i); \
-  tmp [ridx(i)] += d * conj (d)
+  tmp[ridx (i)] += d * conj (d)
 
 #define COL_EXPR \
   Complex d = data (i); \
-  tmp [j] += d * conj (d)
+  tmp[j] += d * conj (d)
 
   SPARSE_BASE_REDUCTION_OP (SparseComplexMatrix, Complex, ROW_EXPR,
                             COL_EXPR, 0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
@@ -7411,20 +7411,20 @@ operator << (std::ostream& os, const Spa
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)
      {
        octave_quit ();
-       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
          {
-           os << a.ridx(i) + 1 << " "  << j + 1 << " ";
-           octave_write_complex (os, a.data(i));
+           os << a.ridx (i) + 1 << " "  << j + 1 << " ";
+           octave_write_complex (os, a.data (i));
            os << "\n";
          }
      }
 
   return os;
 }
 
 std::istream&
@@ -7635,25 +7635,25 @@ min (const Complex& c, const SparseCompl
 {
   SparseComplexMatrix result;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseComplexMatrix);
 
-  if (abs(c) == 0.)
+  if (abs (c) == 0.)
     return SparseComplexMatrix (nr, nc);
   else
     {
       result = SparseComplexMatrix (m);
 
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-          result.data(i) = xmin(c, m.data(i));
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+          result.data (i) = xmin (c, m.data (i));
     }
 
   return result;
 }
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& m, const Complex& c)
 {
@@ -7681,69 +7681,69 @@ min (const SparseComplexMatrix& a, const
       else
         {
           r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
-              octave_idx_type  ja = a.cidx(i);
-              octave_idx_type  ja_max = a.cidx(i+1);
+              octave_idx_type  ja = a.cidx (i);
+              octave_idx_type  ja_max = a.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = b.cidx(i);
-              octave_idx_type  jb_max = b.cidx(i+1);
+              octave_idx_type  jb = b.cidx (i);
+              octave_idx_type  jb_max = b.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                     {
-                      Complex tmp = xmin (a.data(ja), 0.);
+                      Complex tmp = xmin (a.data (ja), 0.);
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = a.ridx(ja);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                           (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                     {
-                      Complex tmp = xmin (0., b.data(jb));
+                      Complex tmp = xmin (0., b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = b.ridx(jb);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = b.ridx (jb);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      Complex tmp = xmin (a.data(ja), b.data(jb));
+                      Complex tmp = xmin (a.data (ja), b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
@@ -7756,22 +7756,22 @@ max (const Complex& c, const SparseCompl
   SparseComplexMatrix result;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   EMPTY_RETURN_CHECK (SparseComplexMatrix);
 
   // Count the number of non-zero elements
-  if (xmax(c, 0.) != 0.)
+  if (xmax (c, 0.) != 0.)
     {
       result = SparseComplexMatrix (nr, nc, c);
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-          result.xdata(m.ridx(i) + j * nr) = xmax (c, m.data(i));
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+          result.xdata (m.ridx (i) + j * nr) = xmax (c, m.data (i));
     }
   else
     result = SparseComplexMatrix (m);
 
   return result;
 }
 
 SparseComplexMatrix
@@ -7805,69 +7805,69 @@ max (const SparseComplexMatrix& a, const
       else
         {
           r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
-              octave_idx_type  ja = a.cidx(i);
-              octave_idx_type  ja_max = a.cidx(i+1);
+              octave_idx_type  ja = a.cidx (i);
+              octave_idx_type  ja_max = a.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = b.cidx(i);
-              octave_idx_type  jb_max = b.cidx(i+1);
+              octave_idx_type  jb = b.cidx (i);
+              octave_idx_type  jb_max = b.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                     {
-                      Complex tmp = xmax (a.data(ja), 0.);
+                      Complex tmp = xmax (a.data (ja), 0.);
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = a.ridx(ja);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                           (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                     {
-                      Complex tmp = xmax (0., b.data(jb));
+                      Complex tmp = xmax (0., b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = b.ridx(jb);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = b.ridx (jb);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      Complex tmp = xmax (a.data(ja), b.data(jb));
+                      Complex tmp = xmax (a.data (ja), b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -464,33 +464,33 @@ ComplexQR::update (const ComplexColumnVe
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init(q*r + ComplexMatrix (u) * ComplexMatrix (v).hermitian (), get_type ());
+      init (q*r + ComplexMatrix (u) * ComplexMatrix (v).hermitian (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 ComplexQR::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
-      init(q*r + u * v.hermitian (), get_type ());
+      init (q*r + u * v.hermitian (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 static
 ComplexMatrix insert_col (const ComplexMatrix& a, octave_idx_type i,
                           const ComplexColumnVector& x)
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -207,17 +207,17 @@ jcobi (octave_idx_type n, octave_idx_typ
               double xp1 = (dif1[j] - x) * xn1 - dif2[j] * xd1 - xn;
 
               xd  = xn;
               xd1 = xn1;
               xn  = xp;
               xn1 = xp1;
             }
 
-          double zc  = 1.0;
+          double zc = 1.0;
           double z = xn / xn1;
 
           if (i != 0)
             {
               for (octave_idx_type j = 1; j <= i; j++)
                 zc = zc - z / (x - root[j-1]);
             }
 
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -78,30 +78,30 @@ ddaspk_f (const double& time, const doub
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.length () == 0)
         ires = -2;
       else
         {
           for (octave_idx_type i = 0; i < nn; i++)
-            delta [i] = tmp_delta.elem (i);
+            delta[i] = tmp_delta.elem (i);
         }
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
@@ -132,25 +132,25 @@ ddaspk_j (const double& time, const doub
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
-      pd [nn * j + i] = tmp_pd.elem (i, j);
+      pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 DASPK::do_integrate (double tout)
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -108,25 +108,25 @@ ddasrt_j (const double& time, const doub
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = (*user_jsub) (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
-      pd [nn * j + i] = tmp_pd.elem (i, j);
+      pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
 ddasrt_g (const octave_idx_type& neq, const double& t, const double *state,
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -71,30 +71,30 @@ ddassl_f (const double& time, const doub
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.length () == 0)
         ires = -2;
       else
         {
           for (octave_idx_type i = 0; i < nn; i++)
-            delta [i] = tmp_delta.elem (i);
+            delta[i] = tmp_delta.elem (i);
         }
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
@@ -106,25 +106,25 @@ ddassl_j (const double& time, const doub
 
   // FIXME -- would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
-      tmp_deriv.elem (i) = deriv [i];
-      tmp_state.elem (i) = state [i];
+      tmp_deriv.elem (i) = deriv[i];
+      tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
   for (octave_idx_type j = 0; j < nn; j++)
     for (octave_idx_type i = 0; i < nn; i++)
-      pd [nn * j + i] = tmp_pd.elem (i, j);
+      pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 DASSL::do_integrate (double tout)
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -225,18 +225,18 @@ EIG::init (const Matrix& a, bool calc_ev
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = Complex (wr.elem(j), wi.elem(j));
-              lambda.elem(j+1) = Complex (wr.elem(j+1), wi.elem(j+1));
+              lambda.elem (j) = Complex (wr.elem (j), wi.elem (j));
+              lambda.elem (j+1) = Complex (wr.elem (j+1), wi.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   double real_part = vr.elem (i, j);
                   double imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = Complex (real_part, imag_part);
                   v.elem (i, j+1) = Complex (real_part, -imag_part);
                 }
@@ -576,20 +576,20 @@ EIG::init (const Matrix& a, const Matrix
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = Complex (ar.elem(j) / beta.elem (j),
-                                        ai.elem(j) / beta.elem (j));
-              lambda.elem(j+1) = Complex (ar.elem(j+1) / beta.elem (j+1),
-                                          ai.elem(j+1) / beta.elem (j+1));
+              lambda.elem (j) = Complex (ar.elem (j) / beta.elem (j),
+                                         ai.elem (j) / beta.elem (j));
+              lambda.elem (j+1) = Complex (ar.elem (j+1) / beta.elem (j+1),
+                                           ai.elem (j+1) / beta.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   double real_part = vr.elem (i, j);
                   double imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = Complex (real_part, imag_part);
                   v.elem (i, j+1) = Complex (real_part, -imag_part);
                 }
@@ -775,17 +775,17 @@ EIG::init (const ComplexMatrix& a, const
         {
           (*current_liboctave_error_handler) ("zggev failed to converge");
           return info;
         }
 
       lambda.resize (n);
 
       for (octave_idx_type j = 0; j < n; j++)
-        lambda.elem (j) = alpha.elem (j) / beta.elem(j);
+        lambda.elem (j) = alpha.elem (j) / beta.elem (j);
 
       v = vtmp;
     }
   else
     (*current_liboctave_error_handler) ("zggev workspace query failed");
 
   return info;
 }
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -74,17 +74,17 @@ lsode_f (const octave_idx_type& neq, con
 
   tmp_deriv = (*user_fun) (*tmp_x, time);
 
   if (tmp_deriv.length () == 0)
     ierr = -1;
   else
     {
       for (octave_idx_type i = 0; i < neq; i++)
-        deriv [i] = tmp_deriv.elem (i);
+        deriv[i] = tmp_deriv.elem (i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
@@ -98,17 +98,17 @@ lsode_j (const octave_idx_type& neq, con
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_jac = (*user_jac) (*tmp_x, time);
 
   for (octave_idx_type j = 0; j < neq; j++)
     for (octave_idx_type i = 0; i < neq; i++)
-      pd [nrowpd * j + i] = tmp_jac (i, j);
+      pd[nrowpd * j + i] = tmp_jac (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 LSODE::do_integrate (double tout)
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -34,16 +34,22 @@ along with Octave; see the file COPYING.
 #include "MArray-decl.h"
 
 MARRAY_OPS_FORWARD_DECLS (MArray, )
 
 template <class T>
 class
 MArray : public Array<T>
 {
+protected:
+
+  // For jit support
+  MArray (T *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
+    : Array<T> (sdata, slen, adims, arep) { }
+
 public:
 
   MArray (void) : Array<T> () {}
 
   explicit MArray (octave_idx_type n) GCC_ATTR_DEPRECATED
     : Array<T> (dim_vector (n, 1)) { }
 
   MArray (octave_idx_type n, const T& val) GCC_ATTR_DEPRECATED
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -55,60 +55,60 @@ plus_or_minus (MSparse<T>& a, const MSpa
       gripe_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
     else
       {
         r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
         octave_idx_type jx = 0;
         for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
-            octave_idx_type  ja = a.cidx(i);
-            octave_idx_type  ja_max = a.cidx(i+1);
+            octave_idx_type  ja = a.cidx (i);
+            octave_idx_type  ja_max = a.cidx (i+1);
             bool ja_lt_max= ja < ja_max;
 
-            octave_idx_type  jb = b.cidx(i);
-            octave_idx_type  jb_max = b.cidx(i+1);
+            octave_idx_type  jb = b.cidx (i);
+            octave_idx_type  jb_max = b.cidx (i+1);
             bool jb_lt_max = jb < jb_max;
 
             while (ja_lt_max || jb_lt_max )
               {
                 octave_quit ();
                 if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                   {
-                    r.ridx(jx) = a.ridx(ja);
-                    r.data(jx) = op (a.data(ja), 0.);
+                    r.ridx (jx) = a.ridx (ja);
+                    r.data (jx) = op (a.data (ja), 0.);
                     jx++;
                     ja++;
                     ja_lt_max= ja < ja_max;
                   }
                 else if (( !ja_lt_max ) ||
-                     (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                     (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                   {
-                    r.ridx(jx) = b.ridx(jb);
-                    r.data(jx) = op (0., b.data(jb));
+                    r.ridx (jx) = b.ridx (jb);
+                    r.data (jx) = op (0., b.data (jb));
                     jx++;
                     jb++;
                     jb_lt_max= jb < jb_max;
                   }
                 else
                   {
-                     if (op (a.data(ja), b.data(jb)) != 0.)
+                     if (op (a.data (ja), b.data (jb)) != 0.)
                        {
-                          r.data(jx) = op (a.data(ja), b.data(jb));
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = op (a.data (ja), b.data (jb));
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                        }
                      ja++;
                      ja_lt_max= ja < ja_max;
                      jb++;
                      jb_lt_max= jb < jb_max;
                   }
               }
-            r.cidx(i+1) = jx;
+            r.cidx (i+1) = jx;
           }
 
         a = r.maybe_compress ();
       }
 
     return a;
 }
 
@@ -134,17 +134,17 @@ MArray<T>
 plus_or_minus (const MSparse<T>& a, const T& s, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   MArray<T> r (dim_vector (nr, nc), op (0.0, s));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+    for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
       r.elem (a.ridx (i), j) = op (a.data (i), s);
   return r;
 }
 
 template <typename T>
 MArray<T>
 operator + (const MSparse<T>& a, const T& s)
 {
@@ -166,21 +166,21 @@ times_or_divide (const MSparse<T>& a, co
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
 
   MSparse<T> r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data(i) = op (a.data(i), s);
-      r.ridx(i) = a.ridx(i);
+      r.data (i) = op (a.data (i), s);
+      r.ridx (i) = a.ridx (i);
     }
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    r.cidx(i) = a.cidx(i);
+    r.cidx (i) = a.cidx (i);
   r.maybe_compress (true);
   return r;
 }
 
 template <typename T>
 MSparse<T>
 operator * (const MSparse<T>& a, const T& s)
 {
@@ -202,17 +202,17 @@ MArray<T>
 plus_or_minus (const T& s, const MSparse<T>& a, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   MArray<T> r (dim_vector (nr, nc), op (s, 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+    for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
       r.elem (a.ridx (i), j) = op (s, a.data (i));
   return r;
 }
 
 template <typename T>
 MArray<T>
 operator + (const T& s, const MSparse<T>& a)
 {
@@ -233,21 +233,21 @@ times_or_divides (const T& s, const MSpa
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
 
   MSparse<T> r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data(i) = op (s, a.data(i));
-      r.ridx(i) = a.ridx(i);
+      r.data (i) = op (s, a.data (i));
+      r.ridx (i) = a.ridx (i);
     }
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    r.cidx(i) = a.cidx(i);
+    r.cidx (i) = a.cidx (i);
   r.maybe_compress (true);
   return r;
 }
 
 template <class T>
 MSparse<T>
 operator * (const T& s, const MSparse<T>& a)
 {
@@ -274,113 +274,113 @@ plus_or_minus (const MSparse<T>& a, cons
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr == 1 && a_nc == 1)
     {
-      if (a.elem(0,0) == 0.)
+      if (a.elem (0,0) == 0.)
         if (negate)
           r = -MSparse<T> (b);
         else
           r = MSparse<T> (b);
       else
         {
-          r = MSparse<T> (b_nr, b_nc, op (a.data(0), 0.));
+          r = MSparse<T> (b_nr, b_nc, op (a.data (0), 0.));
 
           for (octave_idx_type j = 0 ; j < b_nc ; j++)
             {
               octave_quit ();
               octave_idx_type idxj = j * b_nr;
-              for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++)
+              for (octave_idx_type i = b.cidx (j) ; i < b.cidx (j+1) ; i++)
                 {
                   octave_quit ();
-                  r.data(idxj + b.ridx(i)) = op (a.data(0), b.data(i));
+                  r.data (idxj + b.ridx (i)) = op (a.data (0), b.data (i));
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
-      if (b.elem(0,0) == 0.)
+      if (b.elem (0,0) == 0.)
         r = MSparse<T> (a);
       else
         {
-          r = MSparse<T> (a_nr, a_nc, op (0.0, b.data(0)));
+          r = MSparse<T> (a_nr, a_nc, op (0.0, b.data (0)));
 
           for (octave_idx_type j = 0 ; j < a_nc ; j++)
             {
               octave_quit ();
               octave_idx_type idxj = j * a_nr;
-              for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++)
+              for (octave_idx_type i = a.cidx (j) ; i < a.cidx (j+1) ; i++)
                 {
                   octave_quit ();
-                  r.data(idxj + a.ridx(i)) = op (a.data(i), b.data(0));
+                  r.data (idxj + a.ridx (i)) = op (a.data (i), b.data (0));
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
     gripe_nonconformant (op_name, a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx(i);
-          octave_idx_type  ja_max = a.cidx(i+1);
+          octave_idx_type  ja = a.cidx (i);
+          octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
-          octave_idx_type  jb = b.cidx(i);
-          octave_idx_type  jb_max = b.cidx(i+1);
+          octave_idx_type  jb = b.cidx (i);
+          octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max )
             {
               octave_quit ();
               if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
-                  r.ridx(jx) = a.ridx(ja);
-                  r.data(jx) = op (a.data(ja), 0.);
+                  r.ridx (jx) = a.ridx (ja);
+                  r.data (jx) = op (a.data (ja), 0.);
                   jx++;
                   ja++;
                   ja_lt_max= ja < ja_max;
                 }
               else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                 {
-                  r.ridx(jx) = b.ridx(jb);
-                  r.data(jx) = op (0.,  b.data(jb));
+                  r.ridx (jx) = b.ridx (jb);
+                  r.data (jx) = op (0.,  b.data (jb));
                   jx++;
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  if (op (a.data(ja), b.data(jb)) != 0.)
+                  if (op (a.data (ja), b.data (jb)) != 0.)
                     {
-                      r.data(jx) = op (a.data(ja), b.data(jb));
-                      r.ridx(jx) = a.ridx(ja);
+                      r.data (jx) = op (a.data (ja), b.data (jb));
+                      r.ridx (jx) = a.ridx (ja);
                       jx++;
                     }
                   ja++;
                   ja_lt_max= ja < ja_max;
                   jb++;
                   jb_lt_max= jb < jb_max;
                 }
             }
-          r.cidx(i+1) = jx;
+          r.cidx (i+1) = jx;
         }
 
       r.maybe_compress ();
     }
 
   return r;
 }
 
@@ -407,92 +407,92 @@ product (const MSparse<T>& a, const MSpa
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr == 1 && a_nc == 1)
     {
-      if (a.elem(0,0) == 0.)
+      if (a.elem (0,0) == 0.)
         r = MSparse<T> (b_nr, b_nc);
       else
         {
           r = MSparse<T> (b);
           octave_idx_type b_nnz = b.nnz ();
 
           for (octave_idx_type i = 0 ; i < b_nnz ; i++)
             {
               octave_quit ();
-              r.data (i) = a.data(0) * r.data(i);
+              r.data (i) = a.data (0) * r.data (i);
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
-      if (b.elem(0,0) == 0.)
+      if (b.elem (0,0) == 0.)
         r = MSparse<T> (a_nr, a_nc);
       else
         {
           r = MSparse<T> (a);
           octave_idx_type a_nnz = a.nnz ();
 
           for (octave_idx_type i = 0 ; i < a_nnz ; i++)
             {
               octave_quit ();
-              r.data (i) = r.data(i) * b.data(0);
+              r.data (i) = r.data (i) * b.data (0);
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
     gripe_nonconformant ("product", a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T> (a_nr, a_nc, (a.nnz () > b.nnz () ? a.nnz () : b.nnz ()));
 
       octave_idx_type jx = 0;
       r.cidx (0) = 0;
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx(i);
-          octave_idx_type  ja_max = a.cidx(i+1);
+          octave_idx_type  ja = a.cidx (i);
+          octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
-          octave_idx_type  jb = b.cidx(i);
-          octave_idx_type  jb_max = b.cidx(i+1);
+          octave_idx_type  jb = b.cidx (i);
+          octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max )
             {
               octave_quit ();
               if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
                   ja++; ja_lt_max= ja < ja_max;
                 }
               else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                 {
                   jb++; jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  if ((a.data(ja) * b.data(jb)) != 0.)
+                  if ((a.data (ja) * b.data (jb)) != 0.)
                     {
-                      r.data(jx) = a.data(ja) * b.data(jb);
-                      r.ridx(jx) = a.ridx(ja);
+                      r.data (jx) = a.data (ja) * b.data (jb);
+                      r.ridx (jx) = a.ridx (ja);
                       jx++;
                     }
                   ja++; ja_lt_max= ja < ja_max;
                   jb++; jb_lt_max= jb < jb_max;
                 }
             }
-          r.cidx(i+1) = jx;
+          r.cidx (i+1) = jx;
         }
 
       r.maybe_compress ();
     }
 
   return r;
 }
 
@@ -513,97 +513,97 @@ quotient (const MSparse<T>& a, const MSp
     {
       T val = a.elem (0,0);
       T fill = val / T ();
       if (fill == T ())
         {
           octave_idx_type b_nnz = b.nnz ();
           r = MSparse<T> (b);
           for (octave_idx_type i = 0 ; i < b_nnz ; i++)
-            r.data (i) = val / r.data(i);
+            r.data (i) = val / r.data (i);
           r.maybe_compress ();
         }
       else
         {
           r = MSparse<T> (b_nr, b_nc, fill);
           for (octave_idx_type j = 0 ; j < b_nc ; j++)
             {
               octave_quit ();
               octave_idx_type idxj = j * b_nr;
-              for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++)
+              for (octave_idx_type i = b.cidx (j) ; i < b.cidx (j+1) ; i++)
                 {
                   octave_quit ();
-                  r.data(idxj + b.ridx(i)) = val / b.data(i);
+                  r.data (idxj + b.ridx (i)) = val / b.data (i);
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
       T val = b.elem (0,0);
       T fill = T () / val;
       if (fill == T ())
         {
           octave_idx_type a_nnz = a.nnz ();
           r = MSparse<T> (a);
           for (octave_idx_type i = 0 ; i < a_nnz ; i++)
-            r.data (i) = r.data(i) / val;
+            r.data (i) = r.data (i) / val;
           r.maybe_compress ();
         }
       else
         {
           r = MSparse<T> (a_nr, a_nc, fill);
           for (octave_idx_type j = 0 ; j < a_nc ; j++)
             {
               octave_quit ();
               octave_idx_type idxj = j * a_nr;
-              for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++)
+              for (octave_idx_type i = a.cidx (j) ; i < a.cidx (j+1) ; i++)
                 {
                   octave_quit ();
-                  r.data(idxj + a.ridx(i)) = a.data(i) / val;
+                  r.data (idxj + a.ridx (i)) = a.data (i) / val;
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (a_nr != b_nr || a_nc != b_nc)
     gripe_nonconformant ("quotient", a_nr, a_nc, b_nr, b_nc);
   else
     {
       r = MSparse<T>( a_nr, a_nc, (Zero / Zero));
 
       for (octave_idx_type i = 0 ; i < a_nc ; i++)
         {
-          octave_idx_type  ja = a.cidx(i);
-          octave_idx_type  ja_max = a.cidx(i+1);
+          octave_idx_type  ja = a.cidx (i);
+          octave_idx_type  ja_max = a.cidx (i+1);
           bool ja_lt_max= ja < ja_max;
 
-          octave_idx_type  jb = b.cidx(i);
-          octave_idx_type  jb_max = b.cidx(i+1);
+          octave_idx_type  jb = b.cidx (i);
+          octave_idx_type  jb_max = b.cidx (i+1);
           bool jb_lt_max = jb < jb_max;
 
           while (ja_lt_max || jb_lt_max )
             {
               octave_quit ();
               if ((! jb_lt_max) ||
-                  (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                 {
-                  r.elem (a.ridx(ja),i) = a.data(ja) / Zero;
+                  r.elem (a.ridx (ja),i) = a.data (ja) / Zero;
                   ja++; ja_lt_max= ja < ja_max;
                 }
               else if (( !ja_lt_max ) ||
-                       (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                 {
-                  r.elem (b.ridx(jb),i) = Zero / b.data(jb);
+                  r.elem (b.ridx (jb),i) = Zero / b.data (jb);
                   jb++; jb_lt_max= jb < jb_max;
                 }
               else
                 {
-                  r.elem (a.ridx(ja),i) = a.data(ja) / b.data(jb);
+                  r.elem (a.ridx (ja),i) = a.data (ja) / b.data (jb);
                   ja++; ja_lt_max= ja < ja_max;
                   jb++; jb_lt_max= jb < jb_max;
                 }
             }
         }
 
       r.maybe_compress (true);
     }
@@ -624,11 +624,11 @@ operator + (const MSparse<T>& a)
 
 template <class T>
 MSparse<T>
 operator - (const MSparse<T>& a)
 {
   MSparse<T> retval (a);
   octave_idx_type nz = a.nnz ();
   for (octave_idx_type i = 0; i < nz; i++)
-    retval.data(i) = - retval.data(i);
+    retval.data (i) = - retval.data (i);
   return retval;
 }
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -69,17 +69,17 @@ matrix_real_probe (const MArray<T>& a)
 
   if (ncols == nrows)
     {
       bool upper = true;
       bool lower = true;
       bool hermitian = true;
 
       // do the checks for lower/upper/hermitian all in one pass.
-      OCTAVE_LOCAL_BUFFER(T, diag, ncols);
+      OCTAVE_LOCAL_BUFFER (T, diag, ncols);
 
       for (octave_idx_type j = 0;
            j < ncols && upper; j++)
         {
           T d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
           hermitian = hermitian && (d > zero);
@@ -127,17 +127,17 @@ matrix_complex_probe (const MArray<std::
 
   if (ncols == nrows)
     {
       bool upper = true;
       bool lower = true;
       bool hermitian = true;
 
       // do the checks for lower/upper/hermitian all in one pass.
-      OCTAVE_LOCAL_BUFFER(T, diag, ncols);
+      OCTAVE_LOCAL_BUFFER (T, diag, ncols);
 
       for (octave_idx_type j = 0;
            j < ncols && upper; j++)
         {
           std::complex<T> d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
           hermitian = hermitian && (d.real () > zero && d.imag () == zero);
@@ -226,46 +226,46 @@ MatrixType::MatrixType (const SparseMatr
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
       for (i = 0; i < nm; i++)
         {
-          if (a.cidx(i+1) != a.cidx(i) + 1)
+          if (a.cidx (i+1) != a.cidx (i) + 1)
             {
               tmp_typ = MatrixType::Full;
               break;
             }
-          if (a.ridx(i) != i)
+          if (a.ridx (i) != i)
             {
               tmp_typ = MatrixType::Permuted_Diagonal;
               break;
             }
         }
 
       if (tmp_typ == MatrixType::Permuted_Diagonal)
         {
           std::vector<bool> found (nrows);
 
           for (octave_idx_type j = 0; j < i; j++)
-            found [j] = true;
+            found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
-            found [j] = false;
+            found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
-              if ((a.cidx(j+1) > a.cidx(j) + 1)  ||
-                  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
+              if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
+                  ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
-              found [a.ridx(j)] = true;
+              found[a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
@@ -273,34 +273,34 @@ MatrixType::MatrixType (const SparseMatr
       upper_band = 0;
       lower_band = 0;
       for (octave_idx_type j = 0; j < ncols; j++)
         {
           bool zero_on_diagonal = false;
           if (j < nrows)
             {
               zero_on_diagonal = true;
-              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-                if (a.ridx(i) == j)
+              for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+                if (a.ridx (i) == j)
                   {
                     zero_on_diagonal = false;
                     break;
                   }
             }
 
           if (zero_on_diagonal)
             {
               singular = true;
               break;
             }
 
-          if (a.cidx(j+1) != a.cidx(j))
+          if (a.cidx (j+1) != a.cidx (j))
             {
-              octave_idx_type ru = a.ridx(a.cidx(j));
-              octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+              octave_idx_type ru = a.ridx (a.cidx (j));
+              octave_idx_type rl = a.ridx (a.cidx (j+1)-1);
 
               if (j - ru > upper_band)
                 upper_band = j - ru;
 
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
@@ -346,64 +346,64 @@ MatrixType::MatrixType (const SparseMatr
           // FIXME
           // Perhaps this should be based on a dmperm algorithm
           bool found = false;
 
           nperm = ncols;
           perm = new octave_idx_type [ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
-            perm [i] = -1;
+            perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 {
-                  if ((a.cidx(j+1) - a.cidx(j)) > 0 &&
-                      (a.ridx(a.cidx(j+1)-1) == i))
+                  if ((a.cidx (j+1) - a.cidx (j)) > 0 &&
+                      (a.ridx (a.cidx (j+1)-1) == i))
                     {
-                      perm [i] = j;
+                      perm[i] = j;
                       found = true;
                       break;
                     }
                 }
 
               if (!found)
                 break;
             }
 
           if (found)
             {
               typ = MatrixType::Permuted_Upper;
               if (ncols > nrows)
                 {
                   octave_idx_type k = nrows;
                   for (octave_idx_type i = 0; i < ncols; i++)
-                    if (perm [i] == -1)
+                    if (perm[i] == -1)
                       perm[i] = k++;
                 }
             }
-          else if (a.cidx(nm) == a.cidx(ncols))
+          else if (a.cidx (nm) == a.cidx (ncols))
             {
               nperm = nrows;
               delete [] perm;
               perm = new octave_idx_type [nrows];
               OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
-                  perm [i] = -1;
-                  tmp [i] = -1;
+                  perm[i] = -1;
+                  tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
-                for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-                    perm [a.ridx(i)] = j;
+                for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+                    perm[a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -473,46 +473,46 @@ MatrixType::MatrixType (const SparseMatr
           bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
-              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+              for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
                 {
-                  if (a.ridx(i) == j)
+                  if (a.ridx (i) == j)
                     {
-                      double d = a.data(i);
+                      double d = a.data (i);
                       is_herm = d > 0.;
                       diag(j) = d;
                       break;
                     }
                 }
             }
 
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
-            for (octave_idx_type i = a.cidx(j); is_herm && i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); is_herm && i < a.cidx (j+1); i++)
               {
-                octave_idx_type k = a.ridx(i);
+                octave_idx_type k = a.ridx (i);
                 is_herm = k == j;
                 if (is_herm)
                   continue;
-                double d = a.data(i);
+                double d = a.data (i);
                 if (d*d < diag(j)*diag(k))
                   {
-                    for (octave_idx_type l = a.cidx(k); l < a.cidx(k+1); l++)
+                    for (octave_idx_type l = a.cidx (k); l < a.cidx (k+1); l++)
                       {
-                        if (a.ridx(l) == j)
+                        if (a.ridx (l) == j)
                           {
-                            is_herm = a.data(l) == d;
+                            is_herm = a.data (l) == d;
                             break;
                           }
                       }
                   }
               }
 
           if (is_herm)
             {
@@ -547,46 +547,46 @@ MatrixType::MatrixType (const SparseComp
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
       for (i = 0; i < nm; i++)
         {
-          if (a.cidx(i+1) != a.cidx(i) + 1)
+          if (a.cidx (i+1) != a.cidx (i) + 1)
             {
               tmp_typ = MatrixType::Full;
               break;
             }
-          if (a.ridx(i) != i)
+          if (a.ridx (i) != i)
             {
               tmp_typ = MatrixType::Permuted_Diagonal;
               break;
             }
         }
 
       if (tmp_typ == MatrixType::Permuted_Diagonal)
         {
           std::vector<bool> found (nrows);
 
           for (octave_idx_type j = 0; j < i; j++)
-            found [j] = true;
+            found[j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
-            found [j] = false;
+            found[j] = false;
 
           for (octave_idx_type j = i; j < nm; j++)
             {
-              if ((a.cidx(j+1) > a.cidx(j) + 1)  ||
-                  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
+              if ((a.cidx (j+1) > a.cidx (j) + 1)  ||
+                  ((a.cidx (j+1) == a.cidx (j) + 1) && found[a.ridx (j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
-              found [a.ridx(j)] = true;
+              found[a.ridx (j)] = true;
             }
         }
       typ = tmp_typ;
     }
 
   if (typ == MatrixType::Full)
     {
       // Search for banded, upper and lower triangular matrices
@@ -594,34 +594,34 @@ MatrixType::MatrixType (const SparseComp
       upper_band = 0;
       lower_band = 0;
       for (octave_idx_type j = 0; j < ncols; j++)
         {
           bool zero_on_diagonal = false;
           if (j < nrows)
             {
               zero_on_diagonal = true;
-              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-                if (a.ridx(i) == j)
+              for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+                if (a.ridx (i) == j)
                   {
                     zero_on_diagonal = false;
                     break;
                   }
             }
 
           if (zero_on_diagonal)
             {
               singular = true;
               break;
             }
 
-          if (a.cidx(j+1) != a.cidx(j))
+          if (a.cidx (j+1) != a.cidx (j))
             {
-              octave_idx_type ru = a.ridx(a.cidx(j));
-              octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+              octave_idx_type ru = a.ridx (a.cidx (j));
+              octave_idx_type rl = a.ridx (a.cidx (j+1)-1);
 
               if (j - ru > upper_band)
                 upper_band = j - ru;
 
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
@@ -667,64 +667,64 @@ MatrixType::MatrixType (const SparseComp
           // FIXME
           // Perhaps this should be based on a dmperm algorithm
           bool found = false;
 
           nperm = ncols;
           perm = new octave_idx_type [ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
-            perm [i] = -1;
+            perm[i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 {
-                  if ((a.cidx(j+1) - a.cidx(j)) > 0 &&
-                      (a.ridx(a.cidx(j+1)-1) == i))
+                  if ((a.cidx (j+1) - a.cidx (j)) > 0 &&
+                      (a.ridx (a.cidx (j+1)-1) == i))
                     {
-                      perm [i] = j;
+                      perm[i] = j;
                       found = true;
                       break;
                     }
                 }
 
               if (!found)
                 break;
             }
 
           if (found)
             {
               typ = MatrixType::Permuted_Upper;
               if (ncols > nrows)
                 {
                   octave_idx_type k = nrows;
                   for (octave_idx_type i = 0; i < ncols; i++)
-                    if (perm [i] == -1)
+                    if (perm[i] == -1)
                       perm[i] = k++;
                 }
             }
-          else if (a.cidx(nm) == a.cidx(ncols))
+          else if (a.cidx (nm) == a.cidx (ncols))
             {
               nperm = nrows;
               delete [] perm;
               perm = new octave_idx_type [nrows];
               OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nrows);
 
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
-                  perm [i] = -1;
-                  tmp [i] = -1;
+                  perm[i] = -1;
+                  tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
-                for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-                    perm [a.ridx(i)] = j;
+                for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+                    perm[a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -794,46 +794,46 @@ MatrixType::MatrixType (const SparseComp
           bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
-              for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+              for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
                 {
-                  if (a.ridx(i) == j)
+                  if (a.ridx (i) == j)
                     {
-                      Complex d = a.data(i);
+                      Complex d = a.data (i);
                       is_herm = d.real () > 0. && d.imag () == 0.;
                       diag(j) = d.real ();
                       break;
                     }
                 }
             }
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
-            for (octave_idx_type i = a.cidx(j); is_herm && i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); is_herm && i < a.cidx (j+1); i++)
               {
-                octave_idx_type k = a.ridx(i);
+                octave_idx_type k = a.ridx (i);
                 is_herm = k == j;
                 if (is_herm)
                   continue;
-                Complex d = a.data(i);
+                Complex d = a.data (i);
                 if (std::norm (d) < diag(j)*diag(k))
                   {
                     d = std::conj (d);
-                    for (octave_idx_type l = a.cidx(k); l < a.cidx(k+1); l++)
+                    for (octave_idx_type l = a.cidx (k); l < a.cidx (k+1); l++)
                       {
-                        if (a.ridx(l) == j)
+                        if (a.ridx (l) == j)
                           {
-                            is_herm = a.data(l) == d;
+                            is_herm = a.data (l) == d;
                             break;
                           }
                       }
                   }
               }
 
 
           if (is_herm)
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -69,21 +69,21 @@ along with Octave; see the file COPYING.
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
-        r.xdata(i) = m.data(i) OP s; \
-        r.xridx(i) = m.ridx(i); \
+        r.xdata (i) = m.data (i) OP s; \
+        r.xridx (i) = m.ridx (i); \
       } \
     for (octave_idx_type i = 0; i < nc + 1; i++) \
-      r.xcidx(i) = m.cidx(i); \
+      r.xcidx (i) = m.cidx (i); \
     \
     r.maybe_compress (true); \
     return r; \
   }
 
 #define SPARSE_SMS_BIN_OPS(R1, R2, M, S) \
   SPARSE_SMS_BIN_OP_1 (R1, operator +, +, M, S) \
   SPARSE_SMS_BIN_OP_1 (R1, operator -, -, M, S) \
@@ -109,29 +109,29 @@ along with Octave; see the file COPYING.
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r; \
     \
     if (MC (MZ) OP SC (s)) \
       { \
         r = SparseBoolMatrix (nr, nc, true); \
         for (octave_idx_type j = 0; j < nc; j++) \
-          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+          for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
             if (! (MC (m.data (i)) OP SC (s))) \
               r.data (m.ridx (i) + j * nr) = false; \
         r.maybe_compress (true); \
       } \
     else \
       { \
         r = SparseBoolMatrix (nr, nc, m.nnz ()); \
         r.cidx (0) = static_cast<octave_idx_type> (0); \
         octave_idx_type nel = 0; \
         for (octave_idx_type j = 0; j < nc; j++) \
           { \
-            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
               if (MC (m.data (i)) OP SC (s)) \
                 { \
                   r.ridx (nel) = m.ridx (i); \
                   r.data (nel++) = true; \
                 } \
             r.cidx (j + 1) = nel; \
           } \
         r.maybe_compress (false); \
@@ -164,30 +164,30 @@ along with Octave; see the file COPYING.
     SparseBoolMatrix r; \
     \
     if (nr > 0 && nc > 0) \
       { \
         if (LHS_ZERO OP (s != RHS_ZERO)) \
           { \
             r = SparseBoolMatrix (nr, nc, true); \
             for (octave_idx_type j = 0; j < nc; j++) \
-              for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-                if (! ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO))) \
+              for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
+                if (! ((m.data (i) != LHS_ZERO) OP (s != RHS_ZERO))) \
                   r.data (m.ridx (i) + j * nr) = false; \
             r.maybe_compress (true); \
           } \
         else \
           { \
             r = SparseBoolMatrix (nr, nc, m.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < nc; j++) \
               { \
-                for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-                  if ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO)) \
+                for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
+                  if ((m.data (i) != LHS_ZERO) OP (s != RHS_ZERO)) \
                     { \
                       r.ridx (nel) = m.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
@@ -238,21 +238,21 @@ along with Octave; see the file COPYING.
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     octave_idx_type nz = m.nnz (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
-        r.xdata(i) = s OP m.data(i); \
-        r.xridx(i) = m.ridx(i); \
+        r.xdata (i) = s OP m.data (i); \
+        r.xridx (i) = m.ridx (i); \
       } \
     for (octave_idx_type i = 0; i < nc + 1; i++) \
-      r.xcidx(i) = m.cidx(i); \
+      r.xcidx (i) = m.cidx (i); \
  \
     r.maybe_compress(true); \
     return r; \
   }
 
 #define SPARSE_SSM_BIN_OPS(R1, R2, S, M) \
   SPARSE_SSM_BIN_OP_1 (R1, operator +, +, S, M) \
   SPARSE_SSM_BIN_OP_1 (R1, operator -, -, S, M) \
@@ -278,29 +278,29 @@ along with Octave; see the file COPYING.
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
     SparseBoolMatrix r; \
     \
     if (SC (s) OP SC (MZ)) \
       { \
         r = SparseBoolMatrix (nr, nc, true); \
         for (octave_idx_type j = 0; j < nc; j++) \
-          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+          for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
             if (! (SC (s) OP MC (m.data (i)))) \
               r.data (m.ridx (i) + j * nr) = false; \
         r.maybe_compress (true); \
       } \
     else \
       { \
         r = SparseBoolMatrix (nr, nc, m.nnz ()); \
         r.cidx (0) = static_cast<octave_idx_type> (0); \
         octave_idx_type nel = 0; \
         for (octave_idx_type j = 0; j < nc; j++) \
           { \
-            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
+            for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
               if (SC (s) OP MC (m.data (i))) \
                 { \
                   r.ridx (nel) = m.ridx (i); \
                   r.data (nel++) = true; \
                 } \
             r.cidx (j + 1) = nel; \
           } \
         r.maybe_compress (false); \
@@ -333,30 +333,30 @@ along with Octave; see the file COPYING.
     SparseBoolMatrix r; \
     \
     if (nr > 0 && nc > 0) \
       { \
         if ((s != LHS_ZERO) OP RHS_ZERO) \
           { \
             r = SparseBoolMatrix (nr, nc, true); \
             for (octave_idx_type j = 0; j < nc; j++) \
-              for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-                if (! ((s != LHS_ZERO) OP (m.data(i) != RHS_ZERO))) \
+              for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
+                if (! ((s != LHS_ZERO) OP (m.data (i) != RHS_ZERO))) \
                   r.data (m.ridx (i) + j * nr) = false; \
             r.maybe_compress (true); \
           } \
         else \
           { \
             r = SparseBoolMatrix (nr, nc, m.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < nc; j++) \
               { \
-                for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++) \
-                  if ((s != LHS_ZERO) OP (m.data(i) != RHS_ZERO)) \
+                for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++) \
+                  if ((s != LHS_ZERO) OP (m.data (i) != RHS_ZERO)) \
                     { \
                       r.ridx (nel) = m.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
@@ -393,110 +393,110 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
-        if (m1.elem(0,0) == 0.) \
+        if (m1.elem (0,0) == 0.) \
           r = OP R (m2); \
         else \
           { \
-            r = R (m2_nr, m2_nc, m1.data(0) OP 0.); \
+            r = R (m2_nr, m2_nc, m1.data (0) OP 0.); \
             \
             for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m2_nr; \
-                for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
+                for (octave_idx_type i = m2.cidx (j) ; i < m2.cidx (j+1) ; i++) \
                   { \
                     octave_quit (); \
-                    r.data(idxj + m2.ridx(i)) = m1.data(0) OP m2.data(i); \
+                    r.data (idxj + m2.ridx (i)) = m1.data (0) OP m2.data (i); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
-        if (m2.elem(0,0) == 0.) \
+        if (m2.elem (0,0) == 0.) \
           r = R (m1); \
         else \
           { \
-            r = R (m1_nr, m1_nc, 0. OP m2.data(0)); \
+            r = R (m1_nr, m1_nc, 0. OP m2.data (0)); \
             \
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
-                for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
+                for (octave_idx_type i = m1.cidx (j) ; i < m1.cidx (j+1) ; i++) \
                   { \
                     octave_quit (); \
-                    r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.data(0); \
+                    r.data (idxj + m1.ridx (i)) = m1.data (i) OP m2.data (0); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            octave_idx_type  ja = m1.cidx(i); \
-            octave_idx_type  ja_max = m1.cidx(i+1); \
+            octave_idx_type  ja = m1.cidx (i); \
+            octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            octave_idx_type  jb = m2.cidx(i); \
-            octave_idx_type  jb_max = m2.cidx(i+1); \
+            octave_idx_type  jb = m2.cidx (i); \
+            octave_idx_type  jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
-                      (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
+                      (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
-                    r.ridx(jx) = m1.ridx(ja); \
-                    r.data(jx) = m1.data(ja) OP 0.; \
+                    r.ridx (jx) = m1.ridx (ja); \
+                    r.data (jx) = m1.data (ja) OP 0.; \
                     jx++; \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
-                     (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
+                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)) ) ) \
                   { \
-                    r.ridx(jx) = m2.ridx(jb); \
-                    r.data(jx) = 0. OP m2.data(jb); \
+                    r.ridx (jx) = m2.ridx (jb); \
+                    r.data (jx) = 0. OP m2.data (jb); \
                     jx++; \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-                     if ((m1.data(ja) OP m2.data(jb)) != 0.) \
+                     if ((m1.data (ja) OP m2.data (jb)) != 0.) \
                        { \
-                          r.data(jx) = m1.data(ja) OP m2.data(jb); \
-                          r.ridx(jx) = m1.ridx(ja); \
+                          r.data (jx) = m1.data (ja) OP m2.data (jb); \
+                          r.ridx (jx) = m1.ridx (ja); \
                           jx++; \
                        } \
                      ja++; \
                      ja_lt_max= ja < ja_max; \
                      jb++; \
                      jb_lt_max= jb < jb_max; \
                   } \
               } \
-            r.cidx(i+1) = jx; \
+            r.cidx (i+1) = jx; \
           } \
         \
         r.maybe_compress (); \
       } \
  \
     return r; \
   }
 
@@ -509,92 +509,92 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
-        if (m1.elem(0,0) == 0.) \
+        if (m1.elem (0,0) == 0.) \
           r = R (m2_nr, m2_nc); \
         else \
           { \
             r = R (m2); \
             octave_idx_type m2_nnz = m2.nnz (); \
             \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
               { \
                 octave_quit (); \
-                r.data (i) = m1.data(0) OP r.data(i); \
+                r.data (i) = m1.data (0) OP r.data (i); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
-        if (m2.elem(0,0) == 0.) \
+        if (m2.elem (0,0) == 0.) \
           r = R (m1_nr, m1_nc); \
         else \
           { \
             r = R (m1); \
             octave_idx_type m1_nnz = m1.nnz (); \
             \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
               { \
                 octave_quit (); \
-                r.data (i) = r.data(i) OP m2.data(0); \
+                r.data (i) = r.data (i) OP m2.data (0); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            octave_idx_type  ja = m1.cidx(i); \
-            octave_idx_type  ja_max = m1.cidx(i+1); \
+            octave_idx_type  ja = m1.cidx (i); \
+            octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            octave_idx_type  jb = m2.cidx(i); \
-            octave_idx_type  jb_max = m2.cidx(i+1); \
+            octave_idx_type  jb = m2.cidx (i); \
+            octave_idx_type  jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
-                      (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
+                      (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
                      ja++; ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
-                     (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
+                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)) ) ) \
                   { \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-                     if ((m1.data(ja) OP m2.data(jb)) != 0.) \
+                     if ((m1.data (ja) OP m2.data (jb)) != 0.) \
                        { \
-                          r.data(jx) = m1.data(ja) OP m2.data(jb); \
-                          r.ridx(jx) = m1.ridx(ja); \
+                          r.data (jx) = m1.data (ja) OP m2.data (jb); \
+                          r.ridx (jx) = m1.ridx (ja); \
                           jx++; \
                        } \
                      ja++; ja_lt_max= ja < ja_max; \
                      jb++; jb_lt_max= jb < jb_max; \
                   } \
               } \
-            r.cidx(i+1) = jx; \
+            r.cidx (i+1) = jx; \
           } \
         \
         r.maybe_compress (); \
       } \
  \
     return r; \
   }
 
@@ -612,101 +612,101 @@ along with Octave; see the file COPYING.
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
         if ((m1.elem (0,0) OP Complex ()) == Complex ()) \
           { \
             octave_idx_type m2_nnz = m2.nnz (); \
             r = R (m2); \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
-              r.data (i) = m1.elem(0,0) OP r.data(i); \
+              r.data (i) = m1.elem (0,0) OP r.data (i); \
             r.maybe_compress (); \
           } \
         else \
           { \
-            r = R (m2_nr, m2_nc, m1.elem(0,0) OP Complex ()); \
+            r = R (m2_nr, m2_nc, m1.elem (0,0) OP Complex ()); \
             for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m2_nr; \
-                for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
+                for (octave_idx_type i = m2.cidx (j) ; i < m2.cidx (j+1) ; i++) \
                   { \
                     octave_quit (); \
-                    r.data(idxj + m2.ridx(i)) = m1.elem(0,0) OP m2.data(i); \
+                    r.data (idxj + m2.ridx (i)) = m1.elem (0,0) OP m2.data (i); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if ((Complex () OP m1.elem (0,0)) == Complex ()) \
           { \
             octave_idx_type m1_nnz = m1.nnz (); \
             r = R (m1); \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
-              r.data (i) = r.data(i) OP m2.elem(0,0); \
+              r.data (i) = r.data (i) OP m2.elem (0,0); \
             r.maybe_compress (); \
           } \
         else \
           { \
-            r = R (m1_nr, m1_nc, Complex () OP m2.elem(0,0)); \
+            r = R (m1_nr, m1_nc, Complex () OP m2.elem (0,0)); \
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
-                for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
+                for (octave_idx_type i = m1.cidx (j) ; i < m1.cidx (j+1) ; i++) \
                   { \
                     octave_quit (); \
-                    r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.elem(0,0); \
+                    r.data (idxj + m1.ridx (i)) = m1.data (i) OP m2.elem (0,0); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
  \
         /* FIXME Kludge... Always double/Complex, so Complex () */ \
         r = R (m1_nr, m1_nc, (Complex () OP Complex ())); \
         \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
-            octave_idx_type  ja = m1.cidx(i); \
-            octave_idx_type  ja_max = m1.cidx(i+1); \
+            octave_idx_type  ja = m1.cidx (i); \
+            octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
-            octave_idx_type  jb = m2.cidx(i); \
-            octave_idx_type  jb_max = m2.cidx(i+1); \
+            octave_idx_type  jb = m2.cidx (i); \
+            octave_idx_type  jb_max = m2.cidx (i+1); \
             bool jb_lt_max = jb < jb_max; \
             \
             while (ja_lt_max || jb_lt_max ) \
               { \
                 octave_quit (); \
                 if ((! jb_lt_max) || \
-                      (ja_lt_max && (m1.ridx(ja) < m2.ridx(jb)))) \
+                      (ja_lt_max && (m1.ridx (ja) < m2.ridx (jb)))) \
                   { \
                     /* keep those kludges coming */ \
-                    r.elem(m1.ridx(ja),i) = m1.data(ja) OP Complex (); \
+                    r.elem (m1.ridx (ja),i) = m1.data (ja) OP Complex (); \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                   } \
                 else if (( !ja_lt_max ) || \
-                     (jb_lt_max && (m2.ridx(jb) < m1.ridx(ja)) ) ) \
+                     (jb_lt_max && (m2.ridx (jb) < m1.ridx (ja)) ) ) \
                   { \
                     /* keep those kludges coming */ \
-                    r.elem(m2.ridx(jb),i) = Complex () OP m2.data(jb);  \
+                    r.elem (m2.ridx (jb),i) = Complex () OP m2.data (jb);  \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
                 else \
                   { \
-                    r.elem(m1.ridx(ja),i) = m1.data(ja) OP m2.data(jb); \
+                    r.elem (m1.ridx (ja),i) = m1.data (ja) OP m2.data (jb); \
                     ja++; \
                     ja_lt_max= ja < ja_max; \
                     jb++; \
                     jb_lt_max= jb < jb_max; \
                   } \
               } \
           } \
         r.maybe_compress (true); \
@@ -750,63 +750,63 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
-    if (C1 (m1.elem(0,0)) OP C2 (Z2)) \
+    if (C1 (m1.elem (0,0)) OP C2 (Z2)) \
           { \
             r = SparseBoolMatrix (m2_nr, m2_nc, true); \
             for (octave_idx_type j = 0; j < m2_nc; j++) \
-              for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-                if (! (C1 (m1.elem (0,0)) OP C2 (m2.data(i)))) \
+              for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
+                if (! (C1 (m1.elem (0,0)) OP C2 (m2.data (i)))) \
                   r.data (m2.ridx (i) + j * m2_nr) = false; \
             r.maybe_compress (true); \
           } \
         else \
           { \
             r = SparseBoolMatrix (m2_nr, m2_nc, m2.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m2_nc; j++) \
               { \
-                for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-                  if (C1 (m1.elem (0,0)) OP C2 (m2.data(i))) \
+                for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
+                  if (C1 (m1.elem (0,0)) OP C2 (m2.data (i))) \
                     { \
                       r.ridx (nel) = m2.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (C1 (Z1) OP C2 (m2.elem (0,0))) \
           { \
             r = SparseBoolMatrix (m1_nr, m1_nc, true); \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
-              for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-                if (! (C1 (m1.data (i)) OP C2 (m2.elem(0,0)))) \
+              for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
+                if (! (C1 (m1.data (i)) OP C2 (m2.elem (0,0)))) \
                   r.data (m1.ridx (i) + j * m1_nr) = false; \
             r.maybe_compress (true); \
           } \
         else \
           { \
             r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz ()); \
             r.cidx (0) = static_cast<octave_idx_type> (0); \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
-                for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-                  if (C1 (m1.data (i)) OP C2 (m2.elem(0,0))) \
+                for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
+                  if (C1 (m1.data (i)) OP C2 (m2.elem (0,0))) \
                     { \
                       r.ridx (nel) = m1.ridx (i); \
                       r.data (nel++) = true; \
                     } \
                 r.cidx (j + 1) = nel; \
               } \
             r.maybe_compress (false); \
           } \
@@ -821,23 +821,23 @@ along with Octave; see the file COPYING.
                 for (octave_idx_type j = 0; j < m1_nc; j++) \
                   { \
                      octave_idx_type i1 = m1.cidx (j); \
                      octave_idx_type e1 = m1.cidx (j+1); \
                      octave_idx_type i2 = m2.cidx (j); \
                      octave_idx_type e2 = m2.cidx (j+1); \
                      while (i1 < e1 || i2 < e2) \
                        { \
-                         if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
+                         if (i1 == e1 || (i2 < e2 && m1.ridx (i1) > m2.ridx (i2))) \
                            { \
                              if (! (C1 (Z1) OP C2 (m2.data (i2)))) \
                                r.data (m2.ridx (i2) + j * m1_nr) = false; \
                              i2++; \
                            } \
-                         else if (i2 == e2 || m1.ridx(i1) < m2.ridx(i2)) \
+                         else if (i2 == e2 || m1.ridx (i1) < m2.ridx (i2)) \
                            { \
                              if (! (C1 (m1.data (i1)) OP C2 (Z2))) \
                                r.data (m1.ridx (i1) + j * m1_nr) = false; \
                              i1++; \
                            } \
                          else \
                            { \
                              if (! (C1 (m1.data (i1)) OP C2 (m2.data (i2)))) \
@@ -857,26 +857,26 @@ along with Octave; see the file COPYING.
                 for (octave_idx_type j = 0; j < m1_nc; j++) \
                   { \
                      octave_idx_type i1 = m1.cidx (j); \
                      octave_idx_type e1 = m1.cidx (j+1); \
                      octave_idx_type i2 = m2.cidx (j); \
                      octave_idx_type e2 = m2.cidx (j+1); \
                      while (i1 < e1 || i2 < e2) \
                        { \
-                         if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
+                         if (i1 == e1 || (i2 < e2 && m1.ridx (i1) > m2.ridx (i2))) \
                            { \
                              if (C1 (Z1) OP C2 (m2.data (i2))) \
                                { \
                                  r.ridx (nel) = m2.ridx (i2); \
                                  r.data (nel++) = true; \
                                } \
                              i2++; \
                            } \
-                         else if (i2 == e2 || m1.ridx(i1) < m2.ridx(i2)) \
+                         else if (i2 == e2 || m1.ridx (i1) < m2.ridx (i2)) \
                            { \
                              if (C1 (m1.data (i1)) OP C2 (Z2)) \
                                { \
                                  r.ridx (nel) = m1.ridx (i1); \
                                  r.data (nel++) = true; \
                                } \
                              i1++; \
                            } \
@@ -936,66 +936,66 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
         if (m2_nr > 0 && m2_nc > 0) \
           { \
-            if ((m1.elem(0,0) != LHS_ZERO) OP RHS_ZERO) \
+            if ((m1.elem (0,0) != LHS_ZERO) OP RHS_ZERO) \
               { \
                 r = SparseBoolMatrix (m2_nr, m2_nc, true); \
                 for (octave_idx_type j = 0; j < m2_nc; j++) \
-                  for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-                    if (! ((m1.elem(0,0) != LHS_ZERO) OP (m2.data(i) != RHS_ZERO))) \
+                  for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
+                    if (! ((m1.elem (0,0) != LHS_ZERO) OP (m2.data (i) != RHS_ZERO))) \
                       r.data (m2.ridx (i) + j * m2_nr) = false; \
                 r.maybe_compress (true); \
               } \
             else \
               { \
                 r = SparseBoolMatrix (m2_nr, m2_nc, m2.nnz ()); \
                 r.cidx (0) = static_cast<octave_idx_type> (0); \
                 octave_idx_type nel = 0; \
                 for (octave_idx_type j = 0; j < m2_nc; j++) \
                   { \
-                    for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
-                      if ((m1.elem(0,0) != LHS_ZERO) OP (m2.data(i) != RHS_ZERO)) \
+                    for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
+                      if ((m1.elem (0,0) != LHS_ZERO) OP (m2.data (i) != RHS_ZERO)) \
                         { \
                           r.ridx (nel) = m2.ridx (i); \
                           r.data (nel++) = true; \
                         } \
                     r.cidx (j + 1) = nel; \
                   } \
                 r.maybe_compress (false); \
               } \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (m1_nr > 0 && m1_nc > 0) \
           { \
-            if (LHS_ZERO OP (m2.elem(0,0) != RHS_ZERO)) \
+            if (LHS_ZERO OP (m2.elem (0,0) != RHS_ZERO)) \
               { \
                 r = SparseBoolMatrix (m1_nr, m1_nc, true); \
                 for (octave_idx_type j = 0; j < m1_nc; j++) \
-                  for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-                    if (! ((m1.data(i) != LHS_ZERO) OP (m2.elem(0,0) != RHS_ZERO))) \
+                  for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
+                    if (! ((m1.data (i) != LHS_ZERO) OP (m2.elem (0,0) != RHS_ZERO))) \
                       r.data (m1.ridx (i) + j * m1_nr) = false; \
                 r.maybe_compress (true); \
               } \
             else \
               { \
                 r = SparseBoolMatrix (m1_nr, m1_nc, m1.nnz ()); \
                 r.cidx (0) = static_cast<octave_idx_type> (0); \
                 octave_idx_type nel = 0; \
                 for (octave_idx_type j = 0; j < m1_nc; j++) \
                   { \
-                    for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
-                      if ((m1.data(i) != LHS_ZERO) OP (m2.elem(0,0) != RHS_ZERO)) \
+                    for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
+                      if ((m1.data (i) != LHS_ZERO) OP (m2.elem (0,0) != RHS_ZERO)) \
                         { \
                           r.ridx (nel) = m1.ridx (i); \
                           r.data (nel++) = true; \
                         } \
                     r.cidx (j + 1) = nel; \
                   } \
                 r.maybe_compress (false); \
               } \
@@ -1011,37 +1011,37 @@ along with Octave; see the file COPYING.
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 octave_idx_type i1 = m1.cidx (j); \
                 octave_idx_type e1 = m1.cidx (j+1); \
                 octave_idx_type i2 = m2.cidx (j); \
                 octave_idx_type e2 = m2.cidx (j+1); \
                 while (i1 < e1 || i2 < e2) \
                   { \
-                    if (i1 == e1 || (i2 < e2 && m1.ridx(i1) > m2.ridx(i2))) \
+                    if (i1 == e1 || (i2 < e2 && m1.ridx (i1) > m2.ridx (i2))) \
                       { \
                         if (LHS_ZERO OP m2.data (i2) != RHS_ZERO) \
                           { \
                             r.ridx (nel) = m2.ridx (i2); \
                             r.data (nel++) = true; \
                           } \
                         i2++; \
                       } \
-                    else if (i2 == e2 || m1.ridx(i1) < m2.ridx(i2)) \
+                    else if (i2 == e2 || m1.ridx (i1) < m2.ridx (i2)) \
                       { \
                         if (m1.data (i1) != LHS_ZERO OP RHS_ZERO) \
                           { \
                             r.ridx (nel) = m1.ridx (i1); \
                             r.data (nel++) = true; \
                           } \
                         i1++; \
                       } \
                     else \
                       { \
-                        if (m1.data (i1) != LHS_ZERO OP m2.data(i2) != RHS_ZERO) \
+                        if (m1.data (i1) != LHS_ZERO OP m2.data (i2) != RHS_ZERO) \
                           { \
                             r.ridx (nel) = m1.ridx (i1); \
                             r.data (nel++) = true; \
                           } \
                         i1++; \
                         i2++; \
                       } \
                   } \
@@ -1086,17 +1086,17 @@ along with Octave; see the file COPYING.
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m2_nr == 1 && m2_nc == 1) \
-      r = R (m1 OP m2.elem(0,0)); \
+      r = R (m1 OP m2.elem (0,0)); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (F (m1, m2.matrix_value ())); \
       } \
     return r; \
   }
@@ -1109,41 +1109,41 @@ along with Octave; see the file COPYING.
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m2_nr == 1 && m2_nc == 1) \
-      r = R (m1 OP m2.elem(0,0)); \
+      r = R (m1 OP m2.elem (0,0)); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         if (do_mx_check (m1, mx_inline_all_finite<M1::element_type>)) \
           { \
             /* Sparsity pattern is preserved. */ \
             octave_idx_type m2_nz = m2.nnz (); \
             r = R (m2_nr, m2_nc, m2_nz); \
             for (octave_idx_type j = 0, k = 0; j < m2_nc; j++) \
               { \
                 octave_quit (); \
-                for (octave_idx_type i = m2.cidx(j); i < m2.cidx(j+1); i++) \
+                for (octave_idx_type i = m2.cidx (j); i < m2.cidx (j+1); i++) \
                   { \
-                    octave_idx_type mri = m2.ridx(i); \
-                    R::element_type x = m1(mri, j) OP m2.data(i); \
+                    octave_idx_type mri = m2.ridx (i); \
+                    R::element_type x = m1(mri, j) OP m2.data (i); \
                     if (x != 0.0) \
                       { \
-                        r.xdata(k) = x; \
-                        r.xridx(k) = m2.ridx(i); \
+                        r.xdata (k) = x; \
+                        r.xridx (k) = m2.ridx (i); \
                         k++; \
                       } \
                   } \
-                r.xcidx(j+1) = k; \
+                r.xcidx (j+1) = k; \
               } \
             r.maybe_compress (false); \
             return r; \
           } \
         else \
           r = R (F (m1, m2.matrix_value ())); \
       } \
  \
@@ -1177,44 +1177,44 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m2_nr == 1 && m2_nc == 1) \
-      r = SparseBoolMatrix (F (m1, m2.elem(0,0))); \
+      r = SparseBoolMatrix (F (m1, m2.elem (0,0))); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
             /* Count num of non-zero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
-                if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
+                if (C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j))) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
             octave_idx_type ii = 0; \
             r.cidx (0) = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 for (octave_idx_type i = 0; i < m1_nr; i++) \
                   { \
-                    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
+                    bool el = C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j)); \
                     if (el) \
                       { \
-                        r.data(ii) = el; \
-                        r.ridx(ii++) = i; \
+                        r.data (ii) = el; \
+                        r.ridx (ii++) = i; \
                       } \
                   } \
-                r.cidx(j+1) = ii; \
+                r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
@@ -1245,46 +1245,46 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m2_nr == 1 && m2_nc == 1) \
-      r = SparseBoolMatrix  (F (m1, m2.elem(0,0))); \
+      r = SparseBoolMatrix (F (m1, m2.elem (0,0))); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
             /* Count num of non-zero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
-                if ((m1.elem(i, j) != LHS_ZERO) \
-                    OP (m2.elem(i, j) != RHS_ZERO)) \
+                if ((m1.elem (i, j) != LHS_ZERO) \
+                    OP (m2.elem (i, j) != RHS_ZERO)) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
             octave_idx_type ii = 0; \
             r.cidx (0) = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 for (octave_idx_type i = 0; i < m1_nr; i++) \
                   { \
-                    bool el = (m1.elem(i, j) != LHS_ZERO) \
-                      OP (m2.elem(i, j) != RHS_ZERO);     \
+                    bool el = (m1.elem (i, j) != LHS_ZERO) \
+                      OP (m2.elem (i, j) != RHS_ZERO);     \
                     if (el) \
                       { \
-                        r.data(ii) = el; \
-                        r.ridx(ii++) = i; \
+                        r.data (ii) = el; \
+                        r.ridx (ii++) = i; \
                       } \
                   } \
-                r.cidx(j+1) = ii; \
+                r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
@@ -1319,17 +1319,17 @@ along with Octave; see the file COPYING.
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
-      r = R (m1.elem(0,0) OP m2); \
+      r = R (m1.elem (0,0) OP m2); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1.matrix_value () OP m2); \
       } \
     return r; \
   }
@@ -1350,41 +1350,41 @@ along with Octave; see the file COPYING.
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
-      r = R (m1.elem(0,0) OP m2); \
+      r = R (m1.elem (0,0) OP m2); \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         if (SPARSE_SMM_BIN_OP_2_CHECK_ ## F(M2::element_type)) \
           { \
             /* Sparsity pattern is preserved. */ \
             octave_idx_type m1_nz = m1.nnz (); \
             r = R (m1_nr, m1_nc, m1_nz); \
             for (octave_idx_type j = 0, k = 0; j < m1_nc; j++) \
               { \
                 octave_quit (); \
-                for (octave_idx_type i = m1.cidx(j); i < m1.cidx(j+1); i++) \
+                for (octave_idx_type i = m1.cidx (j); i < m1.cidx (j+1); i++) \
                   { \
-                    octave_idx_type mri = m1.ridx(i); \
-                    R::element_type x = m1.data(i) OP m2(mri, j); \
+                    octave_idx_type mri = m1.ridx (i); \
+                    R::element_type x = m1.data (i) OP m2 (mri, j); \
                     if (x != 0.0) \
                       { \
-                        r.xdata(k) = x; \
-                        r.xridx(k) = m1.ridx(i); \
+                        r.xdata (k) = x; \
+                        r.xridx (k) = m1.ridx (i); \
                         k++; \
                       } \
                   } \
-                r.xcidx(j+1) = k; \
+                r.xcidx (j+1) = k; \
               } \
             r.maybe_compress (false); \
             return r; \
           } \
         else \
           r = R (F (m1.matrix_value (), m2)); \
       } \
  \
@@ -1417,44 +1417,44 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
-      r = SparseBoolMatrix (F (m1.elem(0,0), m2)); \
+      r = SparseBoolMatrix (F (m1.elem (0,0), m2)); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
             /* Count num of non-zero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
-                if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
+                if (C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j))) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
             octave_idx_type ii = 0; \
             r.cidx (0) = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 for (octave_idx_type i = 0; i < m1_nr; i++) \
                   { \
-                    bool el = C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j)); \
+                    bool el = C1 (m1.elem (i, j)) OP C2 (m2.elem (i, j)); \
                     if (el) \
                       { \
-                        r.data(ii) = el; \
-                        r.ridx(ii++) = i; \
+                        r.data (ii) = el; \
+                        r.ridx (ii++) = i; \
                       } \
                   } \
-                r.cidx(j+1) = ii; \
+                r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
@@ -1485,46 +1485,46 @@ along with Octave; see the file COPYING.
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
     if (m1_nr == 1 && m1_nc == 1) \
-      r = SparseBoolMatrix (F (m1.elem(0,0), m2)); \
+      r = SparseBoolMatrix (F (m1.elem (0,0), m2)); \
     else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
         if (m1_nr != 0 || m1_nc != 0) \
           { \
             /* Count num of non-zero elements */ \
             octave_idx_type nel = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               for (octave_idx_type i = 0; i < m1_nr; i++) \
-                if ((m1.elem(i, j) != LHS_ZERO) \
-                    OP (m2.elem(i, j) != RHS_ZERO)) \
+                if ((m1.elem (i, j) != LHS_ZERO) \
+                    OP (m2.elem (i, j) != RHS_ZERO)) \
                   nel++; \
             \
             r = SparseBoolMatrix (m1_nr, m1_nc, nel); \
             \
             octave_idx_type ii = 0; \
             r.cidx (0) = 0; \
             for (octave_idx_type j = 0; j < m1_nc; j++) \
               { \
                 for (octave_idx_type i = 0; i < m1_nr; i++) \
                   { \
-                    bool el = (m1.elem(i, j) != LHS_ZERO) \
-                      OP (m2.elem(i, j) != RHS_ZERO);     \
+                    bool el = (m1.elem (i, j) != LHS_ZERO) \
+                      OP (m2.elem (i, j) != RHS_ZERO);     \
                     if (el) \
                       { \
-                        r.data(ii) = el; \
-                        r.ridx(ii++) = i; \
+                        r.data (ii) = el; \
+                        r.ridx (ii++) = i; \
                       } \
                   } \
-                r.cidx(j+1) = ii; \
+                r.cidx (j+1) = ii; \
               } \
           } \
       }       \
     else \
       { \
         if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
           gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
@@ -1560,56 +1560,56 @@ along with Octave; see the file COPYING.
       else \
         { \
           octave_idx_type nel = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (); \
               for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)   \
                 { \
-                  t += data(j); \
+                  t += data (j); \
                   if (t != ELT_TYPE ()) \
                     { \
-                      if (j == cidx(i+1) - 1) \
-                        nel += nr - ridx(j);  \
+                      if (j == cidx (i+1) - 1) \
+                        nel += nr - ridx (j);  \
                       else \
-                        nel += ridx(j+1) - ridx(j); \
+                        nel += ridx (j+1) - ridx (j); \
                     } \
                 } \
             } \
           retval = RET_TYPE (nr, nc, nel); \
-          retval.cidx(0) = 0; \
+          retval.cidx (0) = 0; \
           octave_idx_type ii = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (); \
               for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)   \
                 { \
-                  t += data(j); \
+                  t += data (j); \
                   if (t != ELT_TYPE ()) \
                     { \
-                      if (j == cidx(i+1) - 1) \
+                      if (j == cidx (i+1) - 1) \
                         { \
-                          for (octave_idx_type k = ridx(j); k < nr; k++) \
+                          for (octave_idx_type k = ridx (j); k < nr; k++) \
                             { \
                                retval.data (ii) = t; \
                                retval.ridx (ii++) = k; \
                             } \
                         } \
                       else \
                         { \
-                          for (octave_idx_type k = ridx(j); k < ridx(j+1); k++) \
+                          for (octave_idx_type k = ridx (j); k < ridx (j+1); k++) \
                             { \
                                retval.data (ii) = t; \
                                retval.ridx (ii++) = k; \
                             } \
                         } \
                     } \
                 } \
-              retval.cidx(i+1) = ii; \
+              retval.cidx (i+1) = ii; \
             } \
         } \
     } \
   else \
     retval = RET_TYPE (nr,nc); \
  \
   return retval
 
@@ -1629,44 +1629,44 @@ along with Octave; see the file COPYING.
       else \
         { \
           octave_idx_type nel = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             { \
               octave_idx_type jj = 0; \
               for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
                 { \
-                  if (jj == ridx(j)) \
+                  if (jj == ridx (j)) \
                     { \
                       nel++; \
                       jj++; \
                     } \
                   else \
                     break; \
                 } \
             } \
           retval = RET_TYPE (nr, nc, nel); \
-          retval.cidx(0) = 0; \
+          retval.cidx (0) = 0; \
           octave_idx_type ii = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             { \
               ELT_TYPE t = ELT_TYPE (1.); \
               octave_idx_type jj = 0; \
               for (octave_idx_type j = cidx (i); j < cidx (i+1); j++) \
                 { \
-                  if (jj == ridx(j)) \
+                  if (jj == ridx (j)) \
                     { \
-                      t *= data(j); \
-                      retval.data(ii) = t; \
-                      retval.ridx(ii++) = jj++; \
+                      t *= data (j); \
+                      retval.data (ii) = t; \
+                      retval.ridx (ii++) = jj++; \
                     } \
                   else \
                     break; \
                 } \
-              retval.cidx(i+1) = ii; \
+              retval.cidx (i+1) = ii; \
             } \
         } \
     } \
   else \
     retval = RET_TYPE (nr,nc); \
  \
   return retval
 
@@ -1685,77 +1685,77 @@ along with Octave; see the file COPYING.
           /* Define j here to allow fancy definition for prod method */ \
           octave_idx_type j = 0; \
           OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nr); \
           \
           for (octave_idx_type i = 0; i < nr; i++) \
             tmp[i] = INIT_VAL; \
           for (j = 0; j < nc; j++) \
             { \
-              for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
+              for (octave_idx_type i = cidx (j); i < cidx (j + 1); i++) \
                 { \
                   ROW_EXPR; \
                 } \
             } \
           octave_idx_type nel = 0; \
           for (octave_idx_type i = 0; i < nr; i++) \
             if (tmp[i] != EL_TYPE ())  \
               nel++ ; \
           retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nel); \
-          retval.cidx(0) = 0; \
-          retval.cidx(1) = nel; \
+          retval.cidx (0) = 0; \
+          retval.cidx (1) = nel; \
           nel = 0; \
           for (octave_idx_type i = 0; i < nr; i++) \
             if (tmp[i] != EL_TYPE ())  \
               { \
-                retval.data(nel) = tmp[i]; \
-                retval.ridx(nel++) = i; \
+                retval.data (nel) = tmp[i]; \
+                retval.ridx (nel++) = i; \
               } \
         } \
       else \
         { \
           OCTAVE_LOCAL_BUFFER (EL_TYPE, tmp, nc); \
           \
           for (octave_idx_type j = 0; j < nc; j++) \
             { \
               tmp[j] = INIT_VAL; \
-              for (octave_idx_type i = cidx(j); i < cidx(j + 1); i++) \
+              for (octave_idx_type i = cidx (j); i < cidx (j + 1); i++) \
                 { \
                   COL_EXPR; \
                 } \
             } \
           octave_idx_type nel = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             if (tmp[i] != EL_TYPE ())  \
               nel++ ; \
           retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, nel); \
-          retval.cidx(0) = 0; \
+          retval.cidx (0) = 0; \
           nel = 0; \
           for (octave_idx_type i = 0; i < nc; i++) \
             if (tmp[i] != EL_TYPE ())  \
               { \
-                retval.data(nel) = tmp[i]; \
-                retval.ridx(nel++) = 0; \
-                retval.cidx(i+1) = retval.cidx(i) + 1; \
+                retval.data (nel) = tmp[i]; \
+                retval.ridx (nel++) = 0; \
+                retval.cidx (i+1) = retval.cidx (i) + 1; \
               } \
             else \
-              retval.cidx(i+1) = retval.cidx(i); \
+              retval.cidx (i+1) = retval.cidx (i); \
         } \
     } \
   else if (nc == 0 && (nr == 0 || (nr == 1 && dim == -1))) \
     { \
       if (MT_RESULT) \
         { \
           retval = RET_TYPE (static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (1)); \
-          retval.cidx(0) = 0; \
-          retval.cidx(1) = 1; \
-          retval.ridx(0) = 0; \
-          retval.data(0) = MT_RESULT; \
+          retval.cidx (0) = 0; \
+          retval.cidx (1) = 1; \
+          retval.ridx (0) = 0; \
+          retval.data (0) = MT_RESULT; \
         } \
       else \
           retval = RET_TYPE (static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (1), \
                              static_cast<octave_idx_type> (0)); \
     } \
   else if (nr == 0 && (dim == 0 || dim == -1)) \
     { \
@@ -1774,52 +1774,52 @@ along with Octave; see the file COPYING.
         retval = RET_TYPE (static_cast<octave_idx_type> (1), nc, \
                            static_cast<octave_idx_type> (0)); \
     } \
   else if (nc == 0 && dim == 1) \
     { \
       if (MT_RESULT) \
         { \
           retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), nr); \
-          retval.cidx(0) = 0; \
-          retval.cidx(1) = nr; \
+          retval.cidx (0) = 0; \
+          retval.cidx (1) = nr; \
           for (octave_idx_type i = 0; i < nr; i++) \
             { \
-              retval.ridx(i) = i; \
-              retval.data(i) = MT_RESULT; \
+              retval.ridx (i) = i; \
+              retval.data (i) = MT_RESULT; \
             } \
         } \
       else \
         retval = RET_TYPE (nr, static_cast<octave_idx_type> (1), \
                            static_cast<octave_idx_type> (0)); \
     } \
   else \
     retval.resize (nr > 0, nc > 0); \
  \
   return retval
 
 #define SPARSE_REDUCTION_OP_ROW_EXPR(OP) \
-  tmp[ridx(i)] OP data (i)
+  tmp[ridx (i)] OP data (i)
 
 #define SPARSE_REDUCTION_OP_COL_EXPR(OP) \
   tmp[j] OP data (i)
 
 #define SPARSE_REDUCTION_OP(RET_TYPE, EL_TYPE, OP, INIT_VAL, MT_RESULT) \
   SPARSE_BASE_REDUCTION_OP (RET_TYPE, EL_TYPE, \
                         SPARSE_REDUCTION_OP_ROW_EXPR (OP), \
                         SPARSE_REDUCTION_OP_COL_EXPR (OP), \
                         INIT_VAL, MT_RESULT)
 
 
 // Don't break from this loop if the test succeeds because
 // we are looping over the rows and not the columns in the inner
 // loop.
 #define SPARSE_ANY_ALL_OP_ROW_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
-    tmp[ridx(i)] = TEST_TRUE_VAL; \
+    tmp[ridx (i)] = TEST_TRUE_VAL; \
 
 #define SPARSE_ANY_ALL_OP_COL_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
     { \
       tmp[j] = TEST_TRUE_VAL; \
       break; \
     }
 
@@ -1829,102 +1829,102 @@ along with Octave; see the file COPYING.
                         SPARSE_ANY_ALL_OP_COL_CODE (TEST_OP, TEST_TRUE_VAL), \
                         INIT_VAL, MT_RESULT)
 
 #define SPARSE_ALL_OP(DIM) \
   if ((rows () == 1 && dim == -1) || dim == 1) \
     return transpose (). all (0). transpose (); \
   else \
     { \
-      SPARSE_ANY_ALL_OP (DIM, (cidx(j+1) - cidx(j) < nr ? false : true), \
+      SPARSE_ANY_ALL_OP (DIM, (cidx (j+1) - cidx (j) < nr ? false : true), \
                          true, ==, false); \
     }
 
 #define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, false, !=, true)
 
 #define SPARSE_SPARSE_MUL( RET_TYPE, RET_EL_TYPE, EL_TYPE ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
    { \
-     RET_EL_TYPE s = m.elem(0,0); \
+     RET_EL_TYPE s = m.elem (0,0); \
      octave_idx_type nz = a.nnz (); \
      RET_TYPE r (a_nr, a_nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
-         r.data(i) = s * a.data(i); \
-         r.ridx(i) = a.ridx(i); \
+         r.data (i) = s * a.data (i); \
+         r.ridx (i) = a.ridx (i); \
        } \
      for (octave_idx_type i = 0; i < a_nc + 1; i++) \
        { \
          octave_quit (); \
-         r.cidx(i) = a.cidx(i); \
+         r.cidx (i) = a.cidx (i); \
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (a_nr == 1 && a_nc == 1) \
    { \
-     RET_EL_TYPE s = a.elem(0,0); \
+     RET_EL_TYPE s = a.elem (0,0); \
      octave_idx_type nz = m.nnz (); \
      RET_TYPE r (nr, nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
-         r.data(i) = m.data(i) * s; \
-         r.ridx(i) = m.ridx(i); \
+         r.data (i) = m.data (i) * s; \
+         r.ridx (i) = m.ridx (i); \
        } \
      for (octave_idx_type i = 0; i < nc + 1; i++) \
        { \
          octave_quit (); \
-         r.cidx(i) = m.cidx(i); \
+         r.cidx (i) = m.cidx (i); \
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (nc != a_nr) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr); \
       RET_TYPE retval (nr, a_nc, static_cast<octave_idx_type> (0)); \
       for (octave_idx_type i = 0; i < nr; i++) \
         w[i] = 0; \
-      retval.xcidx(0) = 0; \
+      retval.xcidx (0) = 0; \
       \
       octave_idx_type nel = 0; \
       \
       for (octave_idx_type i = 0; i < a_nc; i++) \
         { \
-          for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+          for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
             { \
-              octave_idx_type  col = a.ridx(j); \
-              for (octave_idx_type k = m.cidx(col) ; k < m.cidx(col+1); k++) \
+              octave_idx_type  col = a.ridx (j); \
+              for (octave_idx_type k = m.cidx (col) ; k < m.cidx (col+1); k++) \
                 { \
-                  if (w[m.ridx(k)] < i + 1) \
+                  if (w[m.ridx (k)] < i + 1) \
                     { \
-                      w[m.ridx(k)] = i + 1; \
+                      w[m.ridx (k)] = i + 1; \
                       nel++; \
                     } \
                   octave_quit (); \
                 } \
             } \
-          retval.xcidx(i+1) = nel; \
+          retval.xcidx (i+1) = nel; \
         } \
       \
       if (nel == 0) \
         return RET_TYPE (nr, a_nc); \
       else \
         {  \
           for (octave_idx_type i = 0; i < nr; i++) \
             w[i] = 0; \
@@ -1946,67 +1946,67 @@ along with Octave; see the file COPYING.
           octave_idx_type n_per_col = (a_nc > 43000 ? 43000 : \
                                         (a_nc * a_nc) / 43000); \
           octave_idx_type ii = 0; \
           octave_idx_type *ri = retval.xridx (); \
           octave_sort<octave_idx_type> sort; \
           \
           for (octave_idx_type i = 0; i < a_nc ; i++) \
             { \
-              if (retval.xcidx(i+1) - retval.xcidx(i) > n_per_col) \
+              if (retval.xcidx (i+1) - retval.xcidx (i) > n_per_col) \
                 { \
-                  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+                  for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
                     { \
-                      octave_idx_type col = a.ridx(j); \
-                      EL_TYPE tmpval = a.data(j); \
-                      for (octave_idx_type k = m.cidx(col) ; \
-                           k < m.cidx(col+1); k++) \
+                      octave_idx_type col = a.ridx (j); \
+                      EL_TYPE tmpval = a.data (j); \
+                      for (octave_idx_type k = m.cidx (col) ; \
+                           k < m.cidx (col+1); k++) \
                         { \
                           octave_quit (); \
-                          octave_idx_type row = m.ridx(k); \
+                          octave_idx_type row = m.ridx (k); \
                           if (w[row] < i + 1) \
                             { \
                               w[row] = i + 1; \
-                              Xcol[row] = tmpval * m.data(k); \
+                              Xcol[row] = tmpval * m.data (k); \
                             } \
                           else \
-                            Xcol[row] += tmpval * m.data(k); \
+                            Xcol[row] += tmpval * m.data (k); \
                         } \
                     } \
                   for (octave_idx_type k = 0; k < nr; k++) \
                     if (w[k] == i + 1) \
                       { \
-                        retval.xdata(ii) = Xcol[k]; \
-                        retval.xridx(ii++) = k; \
+                        retval.xdata (ii) = Xcol[k]; \
+                        retval.xridx (ii++) = k; \
                       } \
                 } \
               else \
                 { \
-                  for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+                  for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
                     { \
-                      octave_idx_type col = a.ridx(j); \
-                      EL_TYPE tmpval = a.data(j); \
-                      for (octave_idx_type k = m.cidx(col) ; \
-                          k < m.cidx(col+1); k++) \
+                      octave_idx_type col = a.ridx (j); \
+                      EL_TYPE tmpval = a.data (j); \
+                      for (octave_idx_type k = m.cidx (col) ; \
+                          k < m.cidx (col+1); k++) \
                         { \
                           octave_quit (); \
-                          octave_idx_type row = m.ridx(k); \
+                          octave_idx_type row = m.ridx (k); \
                           if (w[row] < i + 1) \
                             { \
                               w[row] = i + 1; \
-                              retval.xridx(ii++) = row;\
-                              Xcol[row] = tmpval * m.data(k); \
+                              retval.xridx (ii++) = row;\
+                              Xcol[row] = tmpval * m.data (k); \
                             } \
                           else \
-                            Xcol[row] += tmpval * m.data(k); \
+                            Xcol[row] += tmpval * m.data (k); \
                         } \
                     } \
-                  sort.sort (ri + retval.xcidx(i), ii - retval.xcidx(i)); \
-                  for (octave_idx_type k = retval.xcidx(i); k < ii; k++) \
-                    retval.xdata(k) = Xcol[retval.xridx(k)]; \
+                  sort.sort (ri + retval.xcidx (i), ii - retval.xcidx (i)); \
+                  for (octave_idx_type k = retval.xcidx (i); k < ii; k++) \
+                    retval.xdata (k) = Xcol[retval.xridx (k)]; \
                 }  \
             } \
           retval.maybe_compress (true);\
           return retval; \
         } \
     }
 
 #define SPARSE_FULL_MUL( RET_TYPE, EL_TYPE, ZERO ) \
@@ -2031,34 +2031,34 @@ along with Octave; see the file COPYING.
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           for (octave_idx_type j = 0; j < a_nr; j++) \
             { \
               octave_quit (); \
               \
-              EL_TYPE tmpval = a.elem(j,i); \
-              for (octave_idx_type k = m.cidx(j) ; k < m.cidx(j+1); k++) \
-                retval.elem (m.ridx(k),i) += tmpval * m.data(k); \
+              EL_TYPE tmpval = a.elem (j,i); \
+              for (octave_idx_type k = m.cidx (j) ; k < m.cidx (j+1); k++) \
+                retval.elem (m.ridx (k),i) += tmpval * m.data (k); \
             } \
         } \
       return retval; \
     }
 
 #define SPARSE_FULL_TRANS_MUL( RET_TYPE, EL_TYPE, ZERO, CONJ_OP ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
     { \
-      RET_TYPE retval = CONJ_OP (m.elem(0,0)) * a; \
+      RET_TYPE retval = CONJ_OP (m.elem (0,0)) * a; \
       return retval; \
     } \
   else if (nr != a_nr) \
     { \
       gripe_nonconformant ("operator *", nc, nr, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
@@ -2067,18 +2067,18 @@ along with Octave; see the file COPYING.
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           for (octave_idx_type j = 0; j < nc; j++) \
             { \
               octave_quit (); \
               \
               EL_TYPE acc = ZERO; \
-              for (octave_idx_type k = m.cidx(j) ; k < m.cidx(j+1); k++) \
-                acc += a.elem (m.ridx(k),i) * CONJ_OP (m.data(k)); \
+              for (octave_idx_type k = m.cidx (j) ; k < m.cidx (j+1); k++) \
+                acc += a.elem (m.ridx (k),i) * CONJ_OP (m.data (k)); \
               retval.xelem (j,i) = acc; \
             } \
         } \
       return retval; \
     }
 
 #define FULL_SPARSE_MUL( RET_TYPE, EL_TYPE, ZERO ) \
   octave_idx_type nr = m.rows (); \
@@ -2099,56 +2099,56 @@ along with Octave; see the file COPYING.
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           octave_quit (); \
-          for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+          for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
             { \
-              octave_idx_type col = a.ridx(j); \
-              EL_TYPE tmpval = a.data(j); \
+              octave_idx_type col = a.ridx (j); \
+              EL_TYPE tmpval = a.data (j); \
               \
               for (octave_idx_type k = 0 ; k < nr; k++) \
-                retval.xelem (k,i) += tmpval * m.elem(k,col); \
+                retval.xelem (k,i) += tmpval * m.elem (k,col); \
             } \
         } \
       return retval; \
     }
 
 #define FULL_SPARSE_MUL_TRANS( RET_TYPE, EL_TYPE, ZERO, CONJ_OP ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (a_nr == 1 && a_nc == 1) \
     { \
-      RET_TYPE retval = m * CONJ_OP (a.elem(0,0)); \
+      RET_TYPE retval = m * CONJ_OP (a.elem (0,0)); \
       return retval; \
     } \
   else if (nc != a_nc) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nc, a_nr); \
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nr, ZERO); \
       \
       for (octave_idx_type i = 0; i < a_nc ; i++) \
         { \
           octave_quit (); \
-          for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
+          for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++) \
             { \
-              octave_idx_type col = a.ridx(j); \
-              EL_TYPE tmpval = CONJ_OP (a.data(j)); \
+              octave_idx_type col = a.ridx (j); \
+              EL_TYPE tmpval = CONJ_OP (a.data (j)); \
               for (octave_idx_type k = 0 ; k < nr; k++) \
-                retval.xelem (k,col) += tmpval * m.elem(k,i); \
+                retval.xelem (k,col) += tmpval * m.elem (k,i); \
             } \
         } \
       return retval; \
     }
 
 #endif
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -38,25 +38,25 @@ SM octinternal_do_mul_colpm_sm (const oc
 
   for (octave_idx_type j = 0; j <= nc; ++j)
     r.xcidx (j) = a.cidx (j);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_quit ();
 
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, r.xcidx(j+1) - r.xcidx(j));
-      for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, r.xcidx (j+1) - r.xcidx (j));
+      for (octave_idx_type i = r.xcidx (j), ii = 0; i < r.xcidx (j+1); i++)
         {
           sidx[ii++]=i;
           r.xridx (i) = pcol[a.ridx (i)];
         }
-      sort.sort (r.xridx () + r.xcidx(j), sidx, r.xcidx(j+1) - r.xcidx(j));
-      for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
-        r.xdata(i) = a.data (sidx[ii++]);
+      sort.sort (r.xridx () + r.xcidx (j), sidx, r.xcidx (j+1) - r.xcidx (j));
+      for (octave_idx_type i = r.xcidx (j), ii = 0; i < r.xcidx (j+1); i++)
+        r.xdata (i) = a.data (sidx[ii++]);
     }
 
   return r;
 }
 
 template <typename SM>
 SM octinternal_do_mul_pm_sm (const PermMatrix& p, const SM& a)
 {
@@ -66,17 +66,17 @@ SM octinternal_do_mul_pm_sm (const PermM
       gripe_nonconformant ("operator *", p.rows (), p.cols (), a.rows (), a.cols ());
       return SM ();
     }
 
   if (p.is_row_perm ())
     {
       // Form the column permutation and then call the colpm_sm routine.
       const octave_idx_type *prow = p.pvec ().data ();
-      OCTAVE_LOCAL_BUFFER(octave_idx_type, pcol, nr);
+      OCTAVE_LOCAL_BUFFER (octave_idx_type, pcol, nr);
       for (octave_idx_type i = 0; i < nr; ++i)
         pcol[prow[i]] = i;
       return octinternal_do_mul_colpm_sm (pcol, a);
     }
   else
     return octinternal_do_mul_colpm_sm (p.pvec ().data (), a);
 }
 
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -61,22 +61,22 @@ Sparse<T>::Sparse (const PermMatrix& a)
   for (octave_idx_type i = 0; i <= n; i++)
     cidx (i) = i;
 
   const Array<octave_idx_type> pv = a.pvec ();
 
   if (a.is_row_perm ())
     {
       for (octave_idx_type i = 0; i < n; i++)
-        ridx (pv (i)) = i;
+        ridx (pv(i)) = i;
     }
   else
     {
       for (octave_idx_type i = 0; i < n; i++)
-        ridx (i) = pv (i);
+        ridx (i) = pv(i);
     }
 
   for (octave_idx_type i = 0; i < n; i++)
     data (i) = 1.0;
 }
 
 template <class T>
 T&
@@ -218,17 +218,17 @@ Sparse<T>::Sparse (octave_idx_type nr, o
             }
           xcidx (j+1) = ii;
         }
     }
   else
     {
       rep = new typename Sparse<T>::SparseRep (nr, nc, 0);
       for (octave_idx_type j = 0; j < nc+1; j++)
-        xcidx(j) = 0;
+        xcidx (j) = 0;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
   if (dv.length () != 2)
@@ -259,31 +259,31 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
       octave_idx_type new_nr = dv (0);
       octave_idx_type new_nc = dv (1);
       octave_idx_type old_nr = old_dims (0);
       octave_idx_type old_nc = old_dims (1);
 
       rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
 
       octave_idx_type kk = 0;
-      xcidx(0) = 0;
+      xcidx (0) = 0;
       for (octave_idx_type i = 0; i < old_nc; i++)
-        for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++)
+        for (octave_idx_type j = a.cidx (i); j < a.cidx (i+1); j++)
           {
-            octave_idx_type tmp = i * old_nr + a.ridx(j);
+            octave_idx_type tmp = i * old_nr + a.ridx (j);
             octave_idx_type ii = tmp % new_nr;
             octave_idx_type jj = (tmp - ii) / new_nr;
             for (octave_idx_type k = kk; k < jj; k++)
-              xcidx(k+1) = j;
+              xcidx (k+1) = j;
             kk = jj;
-            xdata(j) = a.data(j);
-            xridx(j) = ii;
+            xdata (j) = a.data (j);
+            xridx (j) = ii;
           }
       for (octave_idx_type k = kk; k < new_nc; k++)
-        xcidx(k+1) = new_nzmx;
+        xcidx (k+1) = new_nzmx;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array<T>& a, const idx_vector& r,
                    const idx_vector& c, octave_idx_type nr,
                    octave_idx_type nc, bool sum_terms,
                    octave_idx_type nzm)
@@ -318,21 +318,21 @@ Sparse<T>::Sparse (const Array<T>& a, co
   if ((rl != 1 && rl != n) || (cl != 1 && cl != n))
     (*current_liboctave_error_handler) ("sparse: dimension mismatch");
 
   if (rl <= 1 && cl <= 1)
     {
       if (n == 1 && a(0) != T ())
         {
           change_capacity (nzm > 1 ? nzm : 1);
-          xcidx(0) = 0;
-          xridx(0) = r(0);
-          xdata(0) = a(0);
+          xcidx (0) = 0;
+          xridx (0) = r(0);
+          xdata (0) = a(0);
           for (octave_idx_type j = 0; j < nc; j++)
-            xcidx(j+1) = j >= c(0);
+            xcidx (j+1) = j >= c(0);
         }
     }
   else if (a_scalar)
     {
       // This is completely specialized, because the sorts can be simplified.
       T a0 = a(0);
       if (a0 == T ())
         {
@@ -414,33 +414,33 @@ Sparse<T>::Sparse (const Array<T>& a, co
           OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, n);
           for (octave_idx_type i = 0; i < n; i++)
             if (rl == 1)
               sidx[ci[cd[i]+1]++] = rd[0];
             else
               sidx[ci[cd[i]+1]++] = rd[i];
 
           // Subsorts. We don't need a stable sort, all values are equal.
-          xcidx(0) = 0;
+          xcidx (0) = 0;
           for (octave_idx_type j = 0; j < nc; j++)
             {
               std::sort (sidx + ci[j], sidx + ci[j+1]);
               octave_idx_type l = -1, nzj = 0;
               // Count.
               for (octave_idx_type i = ci[j]; i < ci[j+1]; i++)
                 {
                   octave_idx_type k = sidx[i];
                   if (k != l)
                     {
                       l = k;
                       nzj++;
                     }
                 }
               // Set column pointer.
-              xcidx(j+1) = xcidx(j) + nzj;
+              xcidx (j+1) = xcidx (j) + nzj;
             }
 
           change_capacity (nzm > xcidx (nc) ? nzm : xcidx (nc));
           octave_idx_type *rri = ridx ();
           T *rrd = data ();
 
           // Fill-in data.
           for (octave_idx_type j = 0, jj = -1; j < nc; j++)
@@ -490,18 +490,18 @@ Sparse<T>::Sparse (const Array<T>& a, co
 
       const octave_idx_type *rd = rs.raw (), *rdi = rsi.data ();
       // Count unique indices.
       octave_idx_type new_nz = 1;
       for (octave_idx_type i = 1; i < n; i++)
         new_nz += rd[i-1] != rd[i];
       // Allocate result.
       change_capacity (nzm > new_nz ? nzm : new_nz);
-      xcidx(0) = 0;
-      xcidx(1) = new_nz;
+      xcidx (0) = 0;
+      xcidx (1) = new_nz;
       octave_idx_type *rri = ridx ();
       T *rrd = data ();
 
       octave_quit ();
 
       octave_idx_type k = 0;
       rri[k] = rd[0];
       rrd[k] = a(rdi[0]);
@@ -561,33 +561,33 @@ Sparse<T>::Sparse (const Array<T>& a, co
           if (rl == 1)
             p.first = rd[0];
           else
             p.first = rd[i];
           p.second = i;
         }
 
       // Subsorts. We don't need a stable sort, the second index stabilizes it.
-      xcidx(0) = 0;
+      xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           std::sort (spairs + ci[j], spairs + ci[j+1]);
           octave_idx_type l = -1, nzj = 0;
           // Count.
           for (octave_idx_type i = ci[j]; i < ci[j+1]; i++)
             {
               octave_idx_type k = spairs[i].first;
               if (k != l)
                 {
                   l = k;
                   nzj++;
                 }
             }
           // Set column pointer.
-          xcidx(j+1) = xcidx(j) + nzj;
+          xcidx (j+1) = xcidx (j) + nzj;
         }
 
       change_capacity (nzm > xcidx (nc) ? nzm : xcidx (nc));
       octave_idx_type *rri = ridx ();
       T *rrd = data ();
 
       // Fill-in data.
       for (octave_idx_type j = 0, jj = -1; j < nc; j++)
@@ -647,26 +647,26 @@ Sparse<T>::Sparse (const Array<T>& a)
       // First count the number of non-zero terms
       for (octave_idx_type i = 0; i < len; i++)
         if (a(i) != T ())
           new_nzmx++;
 
       rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
 
       octave_idx_type ii = 0;
-      xcidx(0) = 0;
+      xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             if (a.elem (i,j) != T ())
               {
-                xdata(ii) = a.elem (i,j);
-                xridx(ii++) = i;
+                xdata (ii) = a.elem (i,j);
+                xridx (ii++) = i;
               }
-          xcidx(j+1) = ii;
+          xcidx (j+1) = ii;
         }
     }
 }
 
 template <class T>
 Sparse<T>::~Sparse (void)
 {
   if (--rep->count == 0)
@@ -828,31 +828,31 @@ Sparse<T>::reshape (const dim_vector& ne
           octave_idx_type new_nnz = nnz ();
           octave_idx_type new_nr = dims2 (0);
           octave_idx_type new_nc = dims2 (1);
           octave_idx_type old_nr = rows ();
           octave_idx_type old_nc = cols ();
           retval = Sparse<T> (new_nr, new_nc, new_nnz);
 
           octave_idx_type kk = 0;
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           for (octave_idx_type i = 0; i < old_nc; i++)
-            for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
+            for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)
               {
-                octave_idx_type tmp = i * old_nr + ridx(j);
+                octave_idx_type tmp = i * old_nr + ridx (j);
                 octave_idx_type ii = tmp % new_nr;
                 octave_idx_type jj = (tmp - ii) / new_nr;
                 for (octave_idx_type k = kk; k < jj; k++)
-                  retval.xcidx(k+1) = j;
+                  retval.xcidx (k+1) = j;
                 kk = jj;
-                retval.xdata(j) = data(j);
-                retval.xridx(j) = ii;
+                retval.xdata (j) = data (j);
+                retval.xridx (j) = ii;
               }
           for (octave_idx_type k = kk; k < new_nc; k++)
-            retval.xcidx(k+1) = new_nnz;
+            retval.xcidx (k+1) = new_nnz;
         }
       else
         {
           std::string dimensions_str = dimensions.str ();
           std::string new_dims_str = new_dims.str ();
 
           (*current_liboctave_error_handler)
             ("reshape: can't reshape %s array to %s array",
@@ -944,24 +944,24 @@ Sparse<T>::resize (octave_idx_type r, oc
   // Sparse rep. It is not good for anything in there.
   make_unique ();
 
   if (r < rows ())
     {
       octave_idx_type i = 0, k = 0;
       for (octave_idx_type j = 1; j <= rep->ncols; j++)
         {
-          octave_idx_type u = xcidx(j);
+          octave_idx_type u = xcidx (j);
           for (i = i; i < u; i++)
-            if (xridx(i) < r)
+            if (xridx (i) < r)
               {
-                xdata(k) = xdata(i);
-                xridx(k++) = xridx(i);
+                xdata (k) = xdata (i);
+                xridx (k++) = xridx (i);
               }
-          xcidx(j) = k;
+          xcidx (j) = k;
         }
     }
 
   rep->nrows = dimensions(0) = r;
 
   if (c != rep->ncols)
     {
       octave_idx_type *new_cidx = new octave_idx_type [c+1];
@@ -989,79 +989,79 @@ Sparse<T>::insert (const Sparse<T>& a, o
 
   if (r < 0 || r + a_rows > rows () || c < 0 || c + a_cols > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   // First count the number of elements in the final array
-  octave_idx_type nel = cidx(c) + a.nnz ();
+  octave_idx_type nel = cidx (c) + a.nnz ();
 
   if (c + a_cols < nc)
-    nel += cidx(nc) - cidx(c + a_cols);
+    nel += cidx (nc) - cidx (c + a_cols);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
-    for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
-      if (ridx(j) < r || ridx(j) >= r + a_rows)
+    for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)
+      if (ridx (j) < r || ridx (j) >= r + a_rows)
         nel++;
 
   Sparse<T> tmp (*this);
   --rep->count;
   rep = new typename Sparse<T>::SparseRep (nr, nc, nel);
 
-  for (octave_idx_type i = 0; i < tmp.cidx(c); i++)
+  for (octave_idx_type i = 0; i < tmp.cidx (c); i++)
     {
-      data(i) = tmp.data(i);
-      ridx(i) = tmp.ridx(i);
+      data (i) = tmp.data (i);
+      ridx (i) = tmp.ridx (i);
     }
   for (octave_idx_type i = 0; i < c + 1; i++)
-    cidx(i) = tmp.cidx(i);
+    cidx (i) = tmp.cidx (i);
 
-  octave_idx_type ii = cidx(c);
+  octave_idx_type ii = cidx (c);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
     {
       octave_quit ();
 
-      for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
-        if (tmp.ridx(j) < r)
+      for (octave_idx_type j = tmp.cidx (i); j < tmp.cidx (i+1); j++)
+        if (tmp.ridx (j) < r)
           {
-            data(ii) = tmp.data(j);
-            ridx(ii++) = tmp.ridx(j);
+            data (ii) = tmp.data (j);
+            ridx (ii++) = tmp.ridx (j);
           }
 
       octave_quit ();
 
-      for (octave_idx_type j = a.cidx(i-c); j < a.cidx(i-c+1); j++)
+      for (octave_idx_type j = a.cidx (i-c); j < a.cidx (i-c+1); j++)
         {
-          data(ii) = a.data(j);
-          ridx(ii++) = r + a.ridx(j);
+          data (ii) = a.data (j);
+          ridx (ii++) = r + a.ridx (j);
         }
 
       octave_quit ();
 
-      for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
-        if (tmp.ridx(j) >= r + a_rows)
+      for (octave_idx_type j = tmp.cidx (i); j < tmp.cidx (i+1); j++)
+        if (tmp.ridx (j) >= r + a_rows)
           {
-            data(ii) = tmp.data(j);
-            ridx(ii++) = tmp.ridx(j);
+            data (ii) = tmp.data (j);
+            ridx (ii++) = tmp.ridx (j);
           }
 
-      cidx(i+1) = ii;
+      cidx (i+1) = ii;
     }
 
   for (octave_idx_type i = c + a_cols; i < nc; i++)
     {
-      for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
+      for (octave_idx_type j = tmp.cidx (i); j < tmp.cidx (i+1); j++)
         {
-          data(ii) = tmp.data(j);
-          ridx(ii++) = tmp.ridx(j);
+          data (ii) = tmp.data (j);
+          ridx (ii++) = tmp.ridx (j);
         }
-      cidx(i+1) = ii;
+      cidx (i+1) = ii;
     }
 
   return *this;
 }
 
 template <class T>
 Sparse<T>&
 Sparse<T>::insert (const Sparse<T>& a, const Array<octave_idx_type>& ra_idx)
@@ -1095,17 +1095,17 @@ Sparse<T>::transpose (void) const
     {
       const octave_idx_type tmp = retval.xcidx (i);
       retval.xcidx (i) = nz;
       nz += tmp;
     }
   // retval.xcidx[1:nr] holds row entry *start* offsets for rows 0:(nr-1)
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
+    for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
       {
         octave_idx_type q = retval.xcidx (ridx (k) + 1)++;
         retval.xridx (q) = j;
         retval.xdata (q) = data (k);
       }
   assert (nnz () == retval.xcidx (nr));
   // retval.xcidx[1:nr] holds row entry *end* offsets for rows 0:(nr-1)
   // and retval.xcidx[0:(nr-1)] holds their row entry *start* offsets
@@ -1165,50 +1165,50 @@ Sparse<T>::delete_elements (const idx_ve
           octave_idx_type ui = lblookup (tmp.ridx (), nz, ub);
           // Copy data and adjust indices.
           octave_idx_type nz_new = nz - (ui - li);
           *this = Sparse<T> (nr - (ub - lb), 1, nz_new);
           copy_or_memcpy (li, tmp.data (), data ());
           copy_or_memcpy (li, tmp.ridx (), xridx ());
           copy_or_memcpy (nz - ui, tmp.data () + ui, xdata () + li);
           mx_inline_sub (nz - ui, xridx () + li, tmp.ridx () + ui, ub - lb);
-          xcidx(1) = nz_new;
+          xcidx (1) = nz_new;
         }
       else
         {
           OCTAVE_LOCAL_BUFFER (octave_idx_type, ridx_new, nz);
           OCTAVE_LOCAL_BUFFER (T, data_new, nz);
           idx_vector sidx = idx.sorted (true);
           const octave_idx_type *sj = sidx.raw ();
           octave_idx_type sl = sidx.length (nel), nz_new = 0, j = 0;
           for (octave_idx_type i = 0; i < nz; i++)
             {
-              octave_idx_type r = tmp.ridx(i);
+              octave_idx_type r = tmp.ridx (i);
               for (;j < sl && sj[j] < r; j++) ;
               if (j == sl || sj[j] > r)
                 {
-                  data_new[nz_new] = tmp.data(i);
+                  data_new[nz_new] = tmp.data (i);
                   ridx_new[nz_new++] = r - j;
                 }
             }
 
           *this = Sparse<T> (nr - sl, 1, nz_new);
           copy_or_memcpy (nz_new, ridx_new, ridx ());
           copy_or_memcpy (nz_new, data_new, xdata ());
-          xcidx(1) = nz_new;
+          xcidx (1) = nz_new;
         }
     }
   else if (nr == 1)
     {
       // Sparse row vector.
       octave_idx_type lb, ub;
       if (idx.is_cont_range (nc, lb, ub))
         {
           const Sparse<T> tmp = *this;
-          octave_idx_type lbi = tmp.cidx(lb), ubi = tmp.cidx(ub), new_nz = nz - (ubi - lbi);
+          octave_idx_type lbi = tmp.cidx (lb), ubi = tmp.cidx (ub), new_nz = nz - (ubi - lbi);
           *this = Sparse<T> (1, nc - (ub - lb), new_nz);
           copy_or_memcpy (lbi, tmp.data (), data ());
           copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
           fill_or_memset (new_nz, static_cast<octave_idx_type> (0), ridx ());
           copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
           mx_inline_sub (nc - ub, xcidx () + 1, tmp.cidx () + ub + 1, ubi - lbi);
         }
       else
@@ -1248,17 +1248,17 @@ Sparse<T>::delete_elements (const idx_ve
           else if (nz == 0)
             {
               // No elements to preserve; adjust dimensions.
               *this = Sparse<T> (nr, nc - (ub - lb));
             }
           else
             {
               const Sparse<T> tmp = *this;
-              octave_idx_type lbi = tmp.cidx(lb), ubi = tmp.cidx(ub),
+              octave_idx_type lbi = tmp.cidx (lb), ubi = tmp.cidx (ub),
                 new_nz = nz - (ubi - lbi);
 
               *this = Sparse<T> (nr, nc - (ub - lb), new_nz);
               copy_or_memcpy (lbi, tmp.data (), data ());
               copy_or_memcpy (lbi, tmp.ridx (), ridx ());
               copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
               copy_or_memcpy (nz - ubi, tmp.ridx () + ubi, xridx () + lbi);
               copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
@@ -1291,30 +1291,30 @@ Sparse<T>::delete_elements (const idx_ve
             {
               // This is more memory-efficient than the approach below.
               const Sparse<T> tmpl = index (idx_vector (0, lb), idx_j);
               const Sparse<T> tmpu = index (idx_vector (ub, nr), idx_j);
               *this = Sparse<T> (nr - (ub - lb), nc,
                                  tmpl.nnz () + tmpu.nnz ());
               for (octave_idx_type j = 0, k = 0; j < nc; j++)
                 {
-                  for (octave_idx_type i = tmpl.cidx(j); i < tmpl.cidx(j+1);
+                  for (octave_idx_type i = tmpl.cidx (j); i < tmpl.cidx (j+1);
                        i++)
                     {
-                      xdata(k) = tmpl.data(i);
-                      xridx(k++) = tmpl.ridx(i);
+                      xdata (k) = tmpl.data (i);
+                      xridx (k++) = tmpl.ridx (i);
                     }
-                  for (octave_idx_type i = tmpu.cidx(j); i < tmpu.cidx(j+1);
+                  for (octave_idx_type i = tmpu.cidx (j); i < tmpu.cidx (j+1);
                        i++)
                     {
-                      xdata(k) = tmpu.data(i);
-                      xridx(k++) = tmpu.ridx(i) + lb;
+                      xdata (k) = tmpu.data (i);
+                      xridx (k++) = tmpu.ridx (i) + lb;
                     }
 
-                  xcidx(j+1) = k;
+                  xcidx (j+1) = k;
                 }
             }
         }
       else
         {
           // This is done by transposing, deleting columns, then transposing
           // again.
           Sparse<T> tmp = transpose ();
@@ -1368,25 +1368,25 @@ Sparse<T>::index (const idx_vector& idx,
         retval = *this;
       else
         {
           // Fast magic colon processing.
           retval = Sparse<T> (nel, 1, nz);
 
           for (octave_idx_type i = 0; i < nc; i++)
             {
-              for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
+              for (octave_idx_type j = cidx (i); j < cidx (i+1); j++)
                 {
-                  retval.xdata(j) = data(j);
-                  retval.xridx(j) = ridx(j) + i * nr;
+                  retval.xdata (j) = data (j);
+                  retval.xridx (j) = ridx (j) + i * nr;
                 }
             }
 
-          retval.xcidx(0) = 0;
-          retval.xcidx(1) = nz;
+          retval.xcidx (0) = 0;
+          retval.xcidx (1) = nz;
         }
     }
   else if (idx.extent (nel) > nel)
     {
       // resize_ok is completely handled here.
       if (resize_ok)
         {
           octave_idx_type ext = idx.extent (nel);
@@ -1399,44 +1399,44 @@ Sparse<T>::index (const idx_vector& idx,
     }
   else if (nr == 1 && nc == 1)
     {
       // You have to be pretty sick to get to this bit of code,
       // since you have a scalar stored as a sparse matrix, and
       // then want to make a dense matrix with sparse
       // representation. Ok, we'll do it, but you deserve what
       // you get!!
-      retval = Sparse<T> (idx_dims(0), idx_dims(1), nz ? data(0) : T ());
+      retval = Sparse<T> (idx_dims(0), idx_dims(1), nz ? data (0) : T ());
     }
   else if (nc == 1)
     {
       // Sparse column vector.
       octave_idx_type lb, ub;
 
       if (idx.is_scalar ())
         {
           // Scalar index - just a binary lookup.
           octave_idx_type i = lblookup (ridx (), nz, idx(0));
-          if (i < nz && ridx(i) == idx(0))
-            retval = Sparse (1, 1, data(i));
+          if (i < nz && ridx (i) == idx(0))
+            retval = Sparse (1, 1, data (i));
           else
             retval = Sparse (1, 1);
         }
       else if (idx.is_cont_range (nel, lb, ub))
         {
           // Special-case a contiguous range.
           // Look-up indices first.
           octave_idx_type li = lblookup (ridx (), nz, lb);
           octave_idx_type ui = lblookup (ridx (), nz, ub);
           // Copy data and adjust indices.
           octave_idx_type nz_new = ui - li;
           retval = Sparse<T> (ub - lb, 1, nz_new);
           copy_or_memcpy (nz_new, data () + li, retval.data ());
           mx_inline_sub (nz_new, retval.xridx (), ridx () + li, lb);
-          retval.xcidx(1) = nz_new;
+          retval.xcidx (1) = nz_new;
         }
       else if (idx.is_permutation (nel) && idx.is_vector ())
         {
           if (idx.is_range () && idx.increment () == -1)
             {
               retval = Sparse<T> (nr, 1, nz);
 
               for (octave_idx_type j = 0; j < nz; j++)
@@ -1472,49 +1472,49 @@ Sparse<T>::index (const idx_vector& idx,
           // Count matches.
           retval = Sparse<T> (idxa.rows (), idxa.cols ());
           for (octave_idx_type j = 0; j < new_nc; j++)
             {
               octave_idx_type nzj = 0;
               for (octave_idx_type i = 0; i < new_nr; i++)
                 {
                   octave_idx_type l = lidx(i, j);
-                  if (l < nz && ridx(l) == idxa(i, j))
+                  if (l < nz && ridx (l) == idxa(i, j))
                     nzj++;
                   else
                     lidx(i, j) = nz;
                 }
-              retval.xcidx(j+1) = retval.xcidx(j) + nzj;
+              retval.xcidx (j+1) = retval.xcidx (j) + nzj;
             }
 
-          retval.change_capacity (retval.xcidx(new_nc));
+          retval.change_capacity (retval.xcidx (new_nc));
 
           // Copy data and set row indices.
           octave_idx_type k = 0;
           for (octave_idx_type j = 0; j < new_nc; j++)
             for (octave_idx_type i = 0; i < new_nr; i++)
               {
                 octave_idx_type l = lidx(i, j);
                 if (l < nz)
                   {
-                    retval.data(k) = data(l);
-                    retval.xridx(k++) = i;
+                    retval.data (k) = data (l);
+                    retval.xridx (k++) = i;
                   }
               }
         }
     }
   else if (nr == 1)
     {
       octave_idx_type lb, ub;
       if (idx.is_scalar ())
-        retval = Sparse<T> (1, 1, elem(0, idx(0)));
+        retval = Sparse<T> (1, 1, elem (0, idx(0)));
       else if (idx.is_cont_range (nel, lb, ub))
         {
           // Special-case a contiguous range.
-          octave_idx_type lbi = cidx(lb), ubi = cidx(ub), new_nz = ubi - lbi;
+          octave_idx_type lbi = cidx (lb), ubi = cidx (ub), new_nz = ubi - lbi;
           retval = Sparse<T> (1, ub - lb, new_nz);
           copy_or_memcpy (new_nz, data () + lbi, retval.data ());
           fill_or_memset (new_nz, static_cast<octave_idx_type> (0), retval.ridx ());
           mx_inline_sub (ub - lb + 1, retval.cidx (), cidx () + lb, lbi);
         }
       else
         {
           // Sparse row vectors occupy O(nr) storage anyway, so let's just
@@ -1578,39 +1578,39 @@ Sparse<T>::index (const idx_vector& idx_
     {
       // Great, we're just manipulating columns. This is going to be quite
       // efficient, because the columns can stay compressed as they are.
       if (idx_j.is_colon ())
         retval = *this; // Shallow copy.
       else if (idx_j.is_cont_range (nc, lb, ub))
         {
           // Special-case a contiguous range.
-          octave_idx_type lbi = cidx(lb), ubi = cidx(ub), new_nz = ubi - lbi;
+          octave_idx_type lbi = cidx (lb), ubi = cidx (ub), new_nz = ubi - lbi;
           retval = Sparse<T> (nr, ub - lb, new_nz);
           copy_or_memcpy (new_nz, data () + lbi, retval.data ());
           copy_or_memcpy (new_nz, ridx () + lbi, retval.ridx ());
           mx_inline_sub (ub - lb + 1, retval.cidx (), cidx () + lb, lbi);
         }
       else
         {
           // Count new nonzero elements.
           retval = Sparse<T> (nr, m);
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_idx_type jj = idx_j(j);
-              retval.xcidx(j+1) = retval.xcidx(j) + (cidx(jj+1) - cidx(jj));
+              retval.xcidx (j+1) = retval.xcidx (j) + (cidx (jj+1) - cidx (jj));
             }
 
           retval.change_capacity (retval.xcidx (m));
 
           // Copy data & indices.
           for (octave_idx_type j = 0; j < m; j++)
             {
-              octave_idx_type ljj = cidx(idx_j(j));
-              octave_idx_type lj = retval.xcidx(j), nzj = retval.xcidx(j+1) - lj;
+              octave_idx_type ljj = cidx (idx_j(j));
+              octave_idx_type lj = retval.xcidx (j), nzj = retval.xcidx (j+1) - lj;
               copy_or_memcpy (nzj, data () + ljj, retval.data () + lj);
               copy_or_memcpy (nzj, ridx () + ljj, retval.ridx () + lj);
             }
         }
     }
   else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
     {
       // It's actually vector indexing. The 1D index is specialized for that.
@@ -1623,127 +1623,127 @@ Sparse<T>::index (const idx_vector& idx_
   else if (idx_i.is_scalar ())
     {
       octave_idx_type ii = idx_i(0);
       retval = Sparse<T> (1, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ij, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
           octave_quit ();
-          octave_idx_type jj = idx_j(j), lj = cidx(jj), nzj = cidx(jj+1) - cidx(jj);
+          octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
           // Scalar index - just a binary lookup.
           octave_idx_type i = lblookup (ridx () + lj, nzj, ii);
-          if (i < nzj && ridx(i+lj) == ii)
+          if (i < nzj && ridx (i+lj) == ii)
             {
               ij[j] = i + lj;
-              retval.xcidx(j+1) = retval.xcidx(j) + 1;
+              retval.xcidx (j+1) = retval.xcidx (j) + 1;
             }
           else
-            retval.xcidx(j+1) = retval.xcidx(j);
+            retval.xcidx (j+1) = retval.xcidx (j);
         }
 
-      retval.change_capacity (retval.xcidx(m));
+      retval.change_capacity (retval.xcidx (m));
 
       // Copy data, adjust row indices.
       for (octave_idx_type j = 0; j < m; j++)
         {
-          octave_idx_type i = retval.xcidx(j);
-          if (retval.xcidx(j+1) > i)
+          octave_idx_type i = retval.xcidx (j);
+          if (retval.xcidx (j+1) > i)
             {
-              retval.xridx(i) = 0;
-              retval.xdata(i) = data(ij[j]);
+              retval.xridx (i) = 0;
+              retval.xdata (i) = data (ij[j]);
             }
         }
     }
   else if (idx_i.is_cont_range (nr, lb, ub))
     {
       retval = Sparse<T> (n, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, li, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ui, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
           octave_quit ();
-          octave_idx_type jj = idx_j(j), lj = cidx(jj), nzj = cidx(jj+1) - cidx(jj);
+          octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
           octave_idx_type lij, uij;
           // Lookup indices.
           li[j] = lij = lblookup (ridx () + lj, nzj, lb) + lj;
           ui[j] = uij = lblookup (ridx () + lj, nzj, ub) + lj;
-          retval.xcidx(j+1) = retval.xcidx(j) + ui[j] - li[j];
+          retval.xcidx (j+1) = retval.xcidx (j) + ui[j] - li[j];
         }
 
-      retval.change_capacity (retval.xcidx(m));
+      retval.change_capacity (retval.xcidx (m));
 
       // Copy data, adjust row indices.
       for (octave_idx_type j = 0, k = 0; j < m; j++)
         {
           octave_quit ();
           for (octave_idx_type i = li[j]; i < ui[j]; i++)
             {
-              retval.xdata(k) = data(i);
-              retval.xridx(k++) = ridx(i) - lb;
+              retval.xdata (k) = data (i);
+              retval.xridx (k++) = ridx (i) - lb;
             }
         }
     }
   else if (idx_i.is_permutation (nr))
     {
       // The columns preserve their length, we just need to renumber and sort them.
       // Count new nonzero elements.
       retval = Sparse<T> (nr, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
           octave_idx_type jj = idx_j(j);
-          retval.xcidx(j+1) = retval.xcidx(j) + (cidx(jj+1) - cidx(jj));
+          retval.xcidx (j+1) = retval.xcidx (j) + (cidx (jj+1) - cidx (jj));
         }
 
       retval.change_capacity (retval.xcidx (m));
 
       octave_quit ();
 
       if (idx_i.is_range () && idx_i.increment () == -1)
         {
           // It's nr:-1:1. Just flip all columns.
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_quit ();
-              octave_idx_type jj = idx_j(j), lj = cidx(jj), nzj = cidx(jj+1) - cidx(jj);
-              octave_idx_type li = retval.xcidx(j), uj = lj + nzj - 1;
+              octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
+              octave_idx_type li = retval.xcidx (j), uj = lj + nzj - 1;
               for (octave_idx_type i = 0; i < nzj; i++)
                 {
-                  retval.xdata(li + i) = data(uj - i); // Copy in reverse order.
-                  retval.xridx(li + i) = nr - 1 - ridx(uj - i); // Ditto with transform.
+                  retval.xdata (li + i) = data (uj - i); // Copy in reverse order.
+                  retval.xridx (li + i) = nr - 1 - ridx (uj - i); // Ditto with transform.
                 }
             }
         }
       else
         {
           // Get inverse permutation.
           idx_vector idx_iinv = idx_i.inverse_permutation (nr);
           const octave_idx_type *iinv = idx_iinv.raw ();
 
           // Scatter buffer.
           OCTAVE_LOCAL_BUFFER (T, scb, nr);
           octave_idx_type *rri = retval.ridx ();
 
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_quit ();
-              octave_idx_type jj = idx_j(j), lj = cidx(jj), nzj = cidx(jj+1) - cidx(jj);
-              octave_idx_type li = retval.xcidx(j);
+              octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
+              octave_idx_type li = retval.xcidx (j);
               // Scatter the column, transform indices.
               for (octave_idx_type i = 0; i < nzj; i++)
-                scb[rri[li + i] = iinv[ridx(lj + i)]] = data(lj + i);
+                scb[rri[li + i] = iinv[ridx (lj + i)]] = data (lj + i);
 
               octave_quit ();
 
               // Sort them.
               std::sort (rri + li, rri + li + nzj);
 
               // Gather.
               for (octave_idx_type i = 0; i < nzj; i++)
-                retval.xdata(li + i) = scb[rri[li + i]];
+                retval.xdata (li + i) = scb[rri[li + i]];
             }
         }
 
     }
   else if (idx_j.is_colon ())
     {
       // This requires  uncompressing columns, which is generally costly,
       // so we rely on the efficient transpose to handle this.
@@ -1841,17 +1841,17 @@ Sparse<T>::assign (const idx_vector& idx
                   copy_or_memcpy (rnz, rhs.data (), data () + li);
                   mx_inline_add (rnz, ridx () + li, rhs.ridx (), lb);
 
                   // ...tail
                   copy_or_memcpy (nz - ui, tmp.data () + ui, data () + li + rnz);
                   copy_or_memcpy (nz - ui, tmp.ridx () + ui, ridx () + li + rnz);
                 }
 
-              cidx(1) = new_nz;
+              cidx (1) = new_nz;
             }
           else if (idx.is_range () && idx.increment () == -1)
             {
               // It's s(u:-1:l) = r. Reverse the assignment.
               assign (idx.sorted (), rhs.index (idx_vector (rhl - 1, 0, -1)));
             }
           else if (idx.is_permutation (n))
             {
@@ -1861,17 +1861,17 @@ Sparse<T>::assign (const idx_vector& idx
             {
               // Elements are being zeroed.
               octave_idx_type *ri = ridx ();
               for (octave_idx_type i = 0; i < rhl; i++)
                 {
                   octave_idx_type iidx = idx(i);
                   octave_idx_type li = lblookup (ri, nz, iidx);
                   if (li != nz && ri[li] == iidx)
-                    xdata(li) = T ();
+                    xdata (li) = T ();
                 }
 
               maybe_compress (true);
             }
           else
             {
               const Sparse<T> tmp = *this;
               octave_idx_type new_nz = nz + rhl;
@@ -1980,17 +1980,17 @@ Sparse<T>::assign (const idx_vector& idx
           octave_idx_type lb, ub;
           // Great, we're just manipulating columns. This is going to be quite
           // efficient, because the columns can stay compressed as they are.
           if (idx_j.is_colon ())
             *this = rhs; // Shallow copy.
           else if (idx_j.is_cont_range (nc, lb, ub))
             {
               // Special-case a contiguous range.
-              octave_idx_type li = cidx(lb), ui = cidx(ub);
+              octave_idx_type li = cidx (lb), ui = cidx (ub);
               octave_idx_type rnz = rhs.nnz (), new_nz = nz - (ui - li) + rnz;
 
               if (new_nz >= nz && new_nz <= capacity ())
                 {
                   // Adding/overwriting elements, enough capacity allocated.
 
                   if (new_nz > nz)
                     {
@@ -2046,46 +2046,46 @@ Sparse<T>::assign (const idx_vector& idx
           else
             {
               const Sparse<T> tmp = *this;
               *this = Sparse<T> (nr, nc);
               OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, jsav, nc, -1);
 
               // Assemble column lengths.
               for (octave_idx_type i = 0; i < nc; i++)
-                xcidx(i+1) = tmp.cidx(i+1) - tmp.cidx(i);
+                xcidx (i+1) = tmp.cidx (i+1) - tmp.cidx (i);
 
               for (octave_idx_type i = 0; i < m; i++)
                 {
                   octave_idx_type j =idx_j(i);
                   jsav[j] = i;
-                  xcidx(j+1) = rhs.cidx(i+1) - rhs.cidx(i);
+                  xcidx (j+1) = rhs.cidx (i+1) - rhs.cidx (i);
                 }
 
               // Make cumulative.
               for (octave_idx_type i = 0; i < nc; i++)
-                xcidx(i+1) += xcidx(i);
+                xcidx (i+1) += xcidx (i);
 
               change_capacity (nnz ());
 
               // Merge columns.
               for (octave_idx_type i = 0; i < nc; i++)
                 {
-                  octave_idx_type l = xcidx(i), u = xcidx(i+1), j = jsav[i];
+                  octave_idx_type l = xcidx (i), u = xcidx (i+1), j = jsav[i];
                   if (j >= 0)
                     {
                       // from rhs
-                      octave_idx_type k = rhs.cidx(j);
+                      octave_idx_type k = rhs.cidx (j);
                       copy_or_memcpy (u - l, rhs.data () + k, xdata () + l);
                       copy_or_memcpy (u - l, rhs.ridx () + k, xridx () + l);
                     }
                   else
                     {
                       // original
-                      octave_idx_type k = tmp.cidx(i);
+                      octave_idx_type k = tmp.cidx (i);
                       copy_or_memcpy (u - l, tmp.data () + k, xdata () + l);
                       copy_or_memcpy (u - l, tmp.ridx () + k, xridx () + l);
                     }
                 }
 
             }
         }
       else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
@@ -2178,36 +2178,36 @@ Sparse<T>::sort (octave_idx_type dim, so
     abort ();
 
   T *v = m.data ();
   octave_idx_type *mcidx = m.cidx ();
   octave_idx_type *mridx = m.ridx ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      octave_idx_type ns = mcidx [j + 1] - mcidx [j];
+      octave_idx_type ns = mcidx[j + 1] - mcidx[j];
       lsort.sort (v, ns);
 
       octave_idx_type i;
       if (mode == ASCENDING)
         {
           for (i = 0; i < ns; i++)
-            if (sparse_ascending_compare<T> (static_cast<T> (0), v [i]))
+            if (sparse_ascending_compare<T> (static_cast<T> (0), v[i]))
               break;
         }
       else
         {
           for (i = 0; i < ns; i++)
-            if (sparse_descending_compare<T> (static_cast<T> (0), v [i]))
+            if (sparse_descending_compare<T> (static_cast<T> (0), v[i]))
               break;
         }
       for (octave_idx_type k = 0; k < i; k++)
-        mridx [k] = k;
+        mridx[k] = k;
       for (octave_idx_type k = i; k < ns; k++)
-        mridx [k] = k - ns + nr;
+        mridx[k] = k - ns + nr;
 
       v += ns;
       mridx += ns;
     }
 
   if (dim > 0)
       m = m.transpose ();
 
@@ -2250,17 +2250,17 @@ Sparse<T>::sort (Array<octave_idx_type> 
   octave_idx_type *mcidx = m.cidx ();
   octave_idx_type *mridx = m.ridx ();
 
   sidx = Array<octave_idx_type> (dim_vector (nr, nc));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, vi, nr);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      octave_idx_type ns = mcidx [j + 1] - mcidx [j];
+      octave_idx_type ns = mcidx[j + 1] - mcidx[j];
       octave_idx_type offset = j * nr;
 
       if (ns == 0)
         {
           for (octave_idx_type k = 0; k < nr; k++)
             sidx (offset + k) = k;
         }
       else
@@ -2291,24 +2291,24 @@ Sparse<T>::sort (Array<octave_idx_type> 
               if (ii < ns && mridx[ii] == k)
                 ii++;
               else
                 sidx (offset + jj++) = k;
             }
 
           for (octave_idx_type k = 0; k < i; k++)
             {
-              sidx (k + offset) = vi [k];
-              mridx [k] = k;
+              sidx (k + offset) = vi[k];
+              mridx[k] = k;
             }
 
           for (octave_idx_type k = i; k < ns; k++)
             {
-              sidx (k - ns + nr + offset) = vi [k];
-              mridx [k] = k - ns + nr;
+              sidx (k - ns + nr + offset) = vi[k];
+              mridx[k] = k - ns + nr;
             }
 
           v += ns;
           mridx += ns;
         }
     }
 
   if (dim > 0)
@@ -2432,39 +2432,39 @@ Sparse<T>::diag (octave_idx_type k) cons
 
           if (nnz () > 0)
             {
               for (octave_idx_type i = 0; i < coff+1; i++)
                 d.xcidx (i) = 0;
 
               for (octave_idx_type j = 0; j < nnc; j++)
                 {
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     {
                       d.xdata (i) = data (i);
                       d.xridx (i) = j + roff;
                     }
-                  d.xcidx (j + coff + 1) = cidx(j+1);
+                  d.xcidx (j + coff + 1) = cidx (j+1);
                 }
 
               for (octave_idx_type i = nnc + coff + 1; i < n + 1; i++)
                 d.xcidx (i) = nz;
             }
         }
       else
         {
           octave_idx_type n = nnr + std::abs (k);
           octave_idx_type nz = nnz ();
 
           d = Sparse<T> (n, n, nz);
 
           if (nnz () > 0)
             {
               octave_idx_type ii = 0;
-              octave_idx_type ir = ridx(0);
+              octave_idx_type ir = ridx (0);
 
               for (octave_idx_type i = 0; i < coff+1; i++)
                 d.xcidx (i) = 0;
 
               for (octave_idx_type i = 0; i < nnr; i++)
                 {
                   if (ir == i)
                     {
@@ -2540,27 +2540,27 @@ Sparse<T>::cat (int dim, octave_idx_type
             octave_idx_type rcum = 0;
             for (octave_idx_type i = 0; i < n; i++)
               {
                 const Sparse<T>& spi = sparse_list[i];
                 // Skipping empty matrices. See the comment in Array.cc.
                 if (spi.is_empty ())
                   continue;
 
-                octave_idx_type kl = spi.cidx(j), ku = spi.cidx(j+1);
+                octave_idx_type kl = spi.cidx (j), ku = spi.cidx (j+1);
                 for (octave_idx_type k = kl; k < ku; k++, l++)
                   {
-                    retval.xridx(l) = spi.ridx(k) + rcum;
-                    retval.xdata(l) = spi.data(k);
+                    retval.xridx (l) = spi.ridx (k) + rcum;
+                    retval.xdata (l) = spi.data (k);
                   }
 
                 rcum += spi.rows ();
               }
 
-            retval.xcidx(j+1) = l;
+            retval.xcidx (j+1) = l;
           }
 
         break;
       }
     case 1:
       {
         octave_idx_type l = 0;
         for (octave_idx_type i = 0; i < n; i++)
@@ -2590,25 +2590,25 @@ Array<T>
 Sparse<T>::array_value () const
 {
   NoAlias< Array<T> > retval (dims (), T ());
   if (rows () == 1)
     {
       octave_idx_type i = 0;
       for (octave_idx_type j = 0, nc = cols (); j < nc; j++)
         {
-          if (cidx(j+1) > i)
+          if (cidx (j+1) > i)
             retval(j) = data (i++);
         }
     }
   else
     {
       for (octave_idx_type j = 0, nc = cols (); j < nc; j++)
-        for (octave_idx_type i = cidx(j), iu = cidx(j+1); i < iu; i++)
-          retval(ridx(i), j) = data (i);
+        for (octave_idx_type i = cidx (j), iu = cidx (j+1); i < iu; i++)
+          retval(ridx (i), j) = data (i);
     }
 
   return retval;
 }
 
 /*
  * Tests
  *
@@ -2638,22 +2638,22 @@ Sparse<T>::array_value () const
 %!      error ("invalid dim, '%d'", dim);
 %!  endswitch
 %!endfunction
 
 %!function test_sparse_slice (size, dim, slice)
 %!  x = ones (size);
 %!  s = set_slice (sparse (x), dim, slice);
 %!  f = set_slice (x, dim, slice);
-%!  assert (nnz(s), nnz(f));
-%!  assert (full(s), f);
-%!  s = set_slice2 (sparse(x), dim, slice);
+%!  assert (nnz (s), nnz (f));
+%!  assert (full (s), f);
+%!  s = set_slice2 (sparse (x), dim, slice);
 %!  f = set_slice2 (x, dim, slice);
-%!  assert (nnz(s), nnz(f));
-%!  assert (full(s), f);
+%!  assert (nnz (s), nnz (f));
+%!  assert (full (s), f);
 %!endfunction
 
 #### 1d indexing
 
 ## size = [2 0]
 %!test test_sparse_slice ([2 0], 11, []);
 %!assert (set_slice (sparse (ones ([2 0])), 11, 1), sparse ([2 0]'))  # sparse different from full
 %!assert (set_slice (sparse (ones ([2 0])), 11, 2), sparse ([0 2]'))  # sparse different from full
@@ -2775,17 +2775,17 @@ bug #35570:
 ## Test removing columns (bug #36656)
 
 %!test
 %! s = sparse (magic (5));
 %! s(:,2:4) = [];
 %! assert (s, sparse (magic (5)(:, [1,5])));
 
 %!test
-%! s = sparse([], [], [], 1, 1);
+%! s = sparse ([], [], [], 1, 1);
 %! s(1,:) = [];
 %! assert (s, sparse ([], [], [], 0, 1));
 
 */
 
 template <class T>
 void
 Sparse<T>::print_info (std::ostream& os, const std::string& prefix) const
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -106,17 +106,17 @@ protected:
         copy_or_memcpy (nz, a.r, r);
         copy_or_memcpy (ncols + 1, a.c, c);
       }
 
     ~SparseRep (void) { delete [] d; delete [] r; delete [] c; }
 
     octave_idx_type length (void) const { return nzmx; }
 
-    octave_idx_type nnz (void) const { return c [ncols]; }
+    octave_idx_type nnz (void) const { return c[ncols]; }
 
     T& elem (octave_idx_type _r, octave_idx_type _c);
 
     T celem (octave_idx_type _r, octave_idx_type _c) const;
 
     T& data (octave_idx_type i) { return d[i]; }
 
     T cdata (octave_idx_type i) const { return d[i]; }
@@ -263,17 +263,17 @@ public:
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
   octave_idx_type get_row_index (octave_idx_type k) { return ridx (k); }
   octave_idx_type get_col_index (octave_idx_type k)
   {
     octave_idx_type ret = 0;
-    while (cidx(ret+1) < k)
+    while (cidx (ret+1) < k)
       ret++;
     return ret;
   }
 
   size_t byte_size (void) const
   {
     return (static_cast<size_t>(cols () + 1) * sizeof (octave_idx_type)
             + static_cast<size_t> (capacity ())
@@ -594,38 +594,38 @@ public:
     if (f_zero != 0.)
       {
         octave_idx_type nr = rows ();
         octave_idx_type nc = cols ();
 
         result = Sparse<U> (nr, nc, f_zero);
 
         for (octave_idx_type j = 0; j < nc; j++)
-          for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_quit ();
               /* Use data instead of elem for better performance.  */
-              result.data (ridx (i) + j * nr) = fcn (data(i));
+              result.data (ridx (i) + j * nr) = fcn (data (i));
             }
 
         result.maybe_compress (true);
       }
     else
       {
         octave_idx_type nz = nnz ();
         octave_idx_type nr = rows ();
         octave_idx_type nc = cols ();
 
         result = Sparse<U> (nr, nc, nz);
         octave_idx_type ii = 0;
         result.cidx (ii) = 0;
 
         for (octave_idx_type j = 0; j < nc; j++)
           {
-            for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 U val = fcn (data (i));
                 if (val != 0.0)
                   {
                     result.data (ii) = val;
                     result.ridx (ii++) = ridx (i);
                   }
                 octave_quit ();
@@ -704,17 +704,17 @@ read_sparse_matrix (std::istream& is, Sp
               (*current_liboctave_error_handler)
                 ("invalid sparse matrix: column indices must appear in ascending order");
               is.setstate (std::ios::failbit);
               goto done;
             }
           else if (jtmp > jold)
             {
               for (octave_idx_type j = jold; j < jtmp; j++)
-                a.cidx(j+1) = ii;
+                a.cidx (j+1) = ii;
             }
           else if (itmp < iold)
             {
               (*current_liboctave_error_handler)
                 ("invalid sparse matrix: row indices must appear in ascending order in each column");
               is.setstate (std::ios::failbit);
               goto done;
             }
@@ -729,17 +729,17 @@ read_sparse_matrix (std::istream& is, Sp
               a.data (ii) = tmp;
               a.ridx (ii++) = itmp;
             }
           else
             goto done;
         }
 
       for (octave_idx_type j = jold; j < nc; j++)
-        a.cidx(j+1) = ii;
+        a.cidx (j+1) = ii;
     }
 
  done:
 
   return is;
 }
 
 #endif
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/SparseCmplxCHOL.cc
--- a/liboctave/SparseCmplxCHOL.cc
+++ b/liboctave/SparseCmplxCHOL.cc
@@ -46,22 +46,22 @@ chol2inv (const SparseComplexMatrix& r)
       MatrixType mattype (r);
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseComplexMatrix rinv;
 
       if (typ == MatrixType::Upper)
         {
-          rinv = r.inverse(mattype, info, rcond, true, false);
+          rinv = r.inverse (mattype, info, rcond, true, false);
           retval = rinv.transpose () * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
-          rinv = r.transpose ().inverse(mattype, info, rcond, true, false);
+          rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
           retval = rinv.transpose () * rinv;
         }
       else
         (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -321,17 +321,17 @@ SparseComplexLU::SparseComplexLU (const 
       int status;
 
       // Null loop so that qinit is imediately deallocated when not
       // needed
       do {
         OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
         for (octave_idx_type i = 0; i < nc; i++)
-          qinit [i] = static_cast<octave_idx_type> (Qinit (i));
+          qinit[i] = static_cast<octave_idx_type> (Qinit (i));
 
         status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
                                        reinterpret_cast<const double *> (Ax),
                                        0, qinit, &Symbolic, control,
                                        info);
       } while (0);
 
       if (status < 0)
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -64,17 +64,17 @@ SparseComplexQR::SparseComplexQR_rep::Sp
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<cs_complex_t *>(reinterpret_cast<const cs_complex_t *>
                                       (a.data ()));
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
 #else
   S = CXSPARSE_ZNAME (_sqr) (&A, order - 1, 1);
 #endif
   N = CXSPARSE_ZNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (!N)
     (*current_liboctave_error_handler)
@@ -125,37 +125,37 @@ SparseComplexQR::SparseComplexQR_rep::V 
 }
 
 ColumnVector
 SparseComplexQR::SparseComplexQR_rep::Pinv (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined(CS_VER) && (CS_VER >= 2)
-    ret.xelem(i) = S->pinv[i];
+#if defined (CS_VER) && (CS_VER >= 2)
+    ret.xelem (i) = S->pinv[i];
 #else
-    ret.xelem(i) = S->Pinv[i];
+    ret.xelem (i) = S->Pinv[i];
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 ColumnVector
 SparseComplexQR::SparseComplexQR_rep::P (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined(CS_VER) && (CS_VER >= 2)
-    ret.xelem(S->pinv[i]) = i;
+#if defined (CS_VER) && (CS_VER >= 2)
+    ret.xelem (S->pinv[i]) = i;
 #else
-    ret.xelem(S->Pinv[i]) = i;
+    ret.xelem (S->Pinv[i]) = i;
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 SparseComplexMatrix
@@ -207,17 +207,17 @@ SparseComplexQR::SparseComplexQR_rep::C 
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (S->pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf), b_nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (b_nr, S->Pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type i = 0; i < nm; i++)
@@ -257,17 +257,17 @@ SparseComplexQR::SparseComplexQR_rep::Q 
         bvec[i] = OCTAVE_C99_ZERO;
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
         {
           octave_quit ();
           bvec[j] = OCTAVE_C99_ONE;
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (S->pinv, bvec, reinterpret_cast<cs_complex_t *>(buf), nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nr, S->Pinv, bvec, reinterpret_cast<cs_complex_t *>(buf));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type i = 0; i < nm; i++)
@@ -285,17 +285,17 @@ SparseComplexQR::SparseComplexQR_rep::Q 
     }
   return ret.hermitian ();
 #else
   return ComplexMatrix ();
 #endif
 }
 
 ComplexMatrix
-qrsolve(const SparseComplexMatrix&a, const Matrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const Matrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
@@ -305,125 +305,125 @@ qrsolve(const SparseComplexMatrix&a, con
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
         (x.fortran_vec ());
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
           CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
         (x.fortran_vec ());
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N ()->B [i];
+        B[i] = q.N ()->B[i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
                 (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
           CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 SparseComplexMatrix
-qrsolve(const SparseComplexMatrix&a, const SparseMatrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const SparseMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
@@ -435,47 +435,47 @@ qrsolve(const SparseComplexMatrix&a, con
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -487,78 +487,78 @@ qrsolve(const SparseComplexMatrix&a, con
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
 
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N ()->B [i];
+        B[i] = q.N ()->B[i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
                 (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -570,34 +570,34 @@ qrsolve(const SparseComplexMatrix&a, con
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
 ComplexMatrix
-qrsolve(const SparseComplexMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   const cs_complex_t *bvec =
@@ -609,116 +609,116 @@ qrsolve(const SparseComplexMatrix&a, con
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
         (x.fortran_vec ());
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
           CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
         (x.fortran_vec ());
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N ()->B [i];
+        B[i] = q.N ()->B[i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
 #endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
                 (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
           CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 SparseComplexMatrix
-qrsolve(const SparseComplexMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
@@ -730,47 +730,47 @@ qrsolve(const SparseComplexMatrix&a, con
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
             (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_ipvec)
             (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -782,77 +782,77 @@ qrsolve(const SparseComplexMatrix&a, con
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N ()->B [i];
+        B[i] = q.N ()->B[i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B)[i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
+#if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
                 (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
             (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_pvec)
             (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -864,21 +864,21 @@ qrsolve(const SparseComplexMatrix&a, con
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -43,17 +43,17 @@ SparseQR::SparseQR_rep::SparseQR_rep (co
   nrows = A.m;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<double *>(a.data ());
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_DNAME (_sqr) (order, &A, 1);
 #else
   S = CXSPARSE_DNAME (_sqr) (&A, order - 1, 1);
 #endif
 
   N = CXSPARSE_DNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   if (!N)
@@ -105,37 +105,37 @@ SparseQR::SparseQR_rep::V (void) const
 }
 
 ColumnVector
 SparseQR::SparseQR_rep::Pinv (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined(CS_VER) && (CS_VER >= 2)
-    ret.xelem(i) = S->pinv[i];
+#if defined (CS_VER) && (CS_VER >= 2)
+    ret.xelem (i) = S->pinv[i];
 #else
-    ret.xelem(i) = S->Pinv[i];
+    ret.xelem (i) = S->Pinv[i];
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 ColumnVector
 SparseQR::SparseQR_rep::P (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
-#if defined(CS_VER) && (CS_VER >= 2)
-    ret.xelem(S->pinv[i]) = i;
+#if defined (CS_VER) && (CS_VER >= 2)
+    ret.xelem (S->pinv[i]) = i;
 #else
-    ret.xelem(S->Pinv[i]) = i;
+    ret.xelem (S->Pinv[i]) = i;
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
 SparseMatrix
@@ -190,17 +190,17 @@ SparseQR::SparseQR_rep::C (const Matrix 
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type i = nr; i < S->m2; i++)
             buf[i] = 0.;
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (S->pinv, bvec + idx, buf, b_nr);
 #else
           CXSPARSE_DNAME (_ipvec) (b_nr, S->Pinv, bvec + idx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
@@ -240,17 +240,17 @@ SparseQR::SparseQR_rep::Q (void) const
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
         {
           octave_quit ();
           bvec[j] = 1.0;
           for (octave_idx_type i = nr; i < S->m2; i++)
             buf[i] = 0.;
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (S->pinv, bvec, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, S->Pinv, bvec, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
@@ -266,17 +266,17 @@ SparseQR::SparseQR_rep::Q (void) const
     }
   return ret.transpose ();
 #else
   return Matrix ();
 #endif
 }
 
 Matrix
-qrsolve(const SparseMatrix&a, const Matrix &b, octave_idx_type& info)
+qrsolve (const SparseMatrix&a, const Matrix &b, octave_idx_type& info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   const double *bvec = b.fortran_vec ();
@@ -287,100 +287,100 @@ qrsolve(const SparseMatrix&a, const Matr
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = Matrix (nc, b_nc, 0.0);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return Matrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       double *vec = x.fortran_vec ();
       OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
         return Matrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       double *vec = x.fortran_vec ();
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
   return Matrix ();
 #endif
 }
 
 SparseMatrix
-qrsolve(const SparseMatrix&a, const SparseMatrix &b, octave_idx_type &info)
+qrsolve (const SparseMatrix&a, const SparseMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   SparseMatrix x;
@@ -392,45 +392,45 @@ qrsolve(const SparseMatrix&a, const Spar
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return SparseMatrix ();
       x = SparseMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
@@ -440,61 +440,61 @@ qrsolve(const SparseMatrix&a, const Spar
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
         return SparseMatrix ();
       x = SparseMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
-            Xx[j] = b.xelem(j,i);
+            Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
@@ -504,34 +504,34 @@ qrsolve(const SparseMatrix&a, const Spar
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseMatrix ();
 #endif
 }
 
 ComplexMatrix
-qrsolve(const SparseMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
@@ -541,88 +541,88 @@ qrsolve(const SparseMatrix&a, const Comp
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       Complex *vec = x.fortran_vec ();
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
         return ComplexMatrix ();
-      x.resize(nc, b_nc);
+      x.resize (nc, b_nc);
       Complex *vec = x.fortran_vec ();
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
@@ -630,56 +630,56 @@ qrsolve(const SparseMatrix&a, const Comp
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
@@ -688,17 +688,17 @@ qrsolve(const SparseMatrix&a, const Comp
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 SparseComplexMatrix
-qrsolve(const SparseMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   SparseComplexMatrix x;
@@ -710,17 +710,17 @@ qrsolve(const SparseMatrix&a, const Spar
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
@@ -728,56 +728,56 @@ qrsolve(const SparseMatrix&a, const Spar
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
 #else
           CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
 #else
           CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
@@ -787,32 +787,32 @@ qrsolve(const SparseMatrix&a, const Spar
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
   else
     {
       SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
         return SparseComplexMatrix ();
       x = SparseComplexMatrix (nc, b_nc, b.nnz ());
-      x.xcidx(0) = 0;
+      x.xcidx (0) = 0;
       x_nz = b.nnz ();
       ii = 0;
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
@@ -821,56 +821,56 @@ qrsolve(const SparseMatrix&a, const Spar
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
 #else
           CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
 #endif
           CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
 #else
           CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
@@ -880,37 +880,37 @@ qrsolve(const SparseMatrix&a, const Spar
                   if (ii == x_nz)
                     {
                       // Resize the sparse matrix
                       octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                       sz = (sz > 10 ? sz : 10) + x_nz;
                       x.change_capacity (sz);
                       x_nz = sz;
                     }
-                  x.xdata(ii) = tmp;
-                  x.xridx(ii++) = j;
+                  x.xdata (ii) = tmp;
+                  x.xridx (ii++) = j;
                 }
             }
-          x.xcidx(i+1) = ii;
+          x.xcidx (i+1) = ii;
         }
       info = 0;
     }
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
 Matrix
-qrsolve(const SparseMatrix &a, const MArray<double> &b,
-        octave_idx_type &info)
+qrsolve (const SparseMatrix &a, const MArray<double> &b,
+         octave_idx_type &info)
 {
   return qrsolve (a, Matrix (b), info);
 }
 
 ComplexMatrix
-qrsolve(const SparseMatrix &a, const MArray<Complex> &b,
-        octave_idx_type &info)
+qrsolve (const SparseMatrix &a, const MArray<Complex> &b,
+         octave_idx_type &info)
 {
   return qrsolve (a, ComplexMatrix (b), info);
 }
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/SparsedbleCHOL.cc
--- a/liboctave/SparsedbleCHOL.cc
+++ b/liboctave/SparsedbleCHOL.cc
@@ -46,22 +46,22 @@ chol2inv (const SparseMatrix& r)
       MatrixType mattype (r);
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseMatrix rinv;
 
       if (typ == MatrixType::Upper)
         {
-          rinv = r.inverse(mattype, info, rcond, true, false);
+          rinv = r.inverse (mattype, info, rcond, true, false);
           retval = rinv.transpose () * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
-          rinv = r.transpose ().inverse(mattype, info, rcond, true, false);
+          rinv = r.transpose ().inverse (mattype, info, rcond, true, false);
           retval = rinv.transpose () * rinv;
         }
       else
         (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -306,17 +306,17 @@ SparseLU::SparseLU (const SparseMatrix& 
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not needed
       do {
         OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
         for (octave_idx_type i = 0; i < nc; i++)
-          qinit [i] = static_cast<octave_idx_type> (Qinit (i));
+          qinit[i] = static_cast<octave_idx_type> (Qinit (i));
 
         status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax,
                                        qinit, &Symbolic, control, info);
       } while (0);
 
       if (status < 0)
         {
           (*current_liboctave_error_handler)
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -50,21 +50,21 @@ SparseBoolMatrix::operator == (const Spa
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    if (cidx(i) != a.cidx(i))
+    if (cidx (i) != a.cidx (i))
         return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
-    if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
+    if (data (i) != a.data (i) || ridx (i) != a.ridx (i))
       return false;
 
   return true;
 }
 
 bool
 SparseBoolMatrix::operator != (const SparseBoolMatrix& a) const
 {
@@ -108,22 +108,22 @@ SparseBoolMatrix::operator ! (void) cons
 
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
         {
-          if (jj < cidx(i+1) && ridx(jj) == j)
+          if (jj < cidx (i+1) && ridx (jj) == j)
             jj++;
           else
             {
-              r.data(ii) = true;
-              r.ridx(ii++) = j;
+              r.data (ii) = true;
+              r.ridx (ii++) = j;
             }
         }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
@@ -145,33 +145,33 @@ SparseBoolMatrix::any (int dim) const
   octave_idx_type nr = rows (), nc = cols (), nz = nnz ();
   if (dim == -1)
     dim = (nr == 1 && nc != 1) ? 1 : 0;
 
   if (dim == 0)
     {
       // Result is a row vector.
       retval = Sparse<bool> (1, nc);
-      retval.xcidx(0) = 0;
+      retval.xcidx (0) = 0;
       for (octave_idx_type i = 0; i < nc; i++)
-        retval.xcidx(i+1) = retval.xcidx(i) + (cidx(i+1) > cidx(i));
-      octave_idx_type new_nz = retval.xcidx(nc);
+        retval.xcidx (i+1) = retval.xcidx (i) + (cidx (i+1) > cidx (i));
+      octave_idx_type new_nz = retval.xcidx (nc);
       retval.change_capacity (new_nz);
       fill_or_memset (new_nz, static_cast<octave_idx_type> (0), retval.ridx ());
       fill_or_memset (new_nz, true, retval.data ());
     }
   else if (dim == 1)
     {
       // Result is a column vector.
       if (nz > nr/4)
         {
           // We can use O(nr) memory.
           Array<bool> tmp (dim_vector (nr, 1), false);
           for (octave_idx_type i = 0; i < nz; i++)
-            tmp.xelem(ridx(i)) = true;
+            tmp.xelem (ridx (i)) = true;
           retval = tmp;
         }
       else
         {
           Array<octave_idx_type> tmp (dim_vector (nz, 1));
           copy_or_memcpy (nz, ridx (), tmp.fortran_vec ());
           retval = Sparse<bool> (Array<bool> (dim_vector (1, 1), true),
                                  idx_vector (tmp),
@@ -190,37 +190,37 @@ SparseBoolMatrix::sum (int dim) const
   octave_idx_type nr = rows (), nc = cols (), nz = nnz ();
   if (dim == -1)
     dim = (nr == 1 && nc != 1) ? 1 : 0;
 
   if (dim == 0)
     {
       // Result is a row vector.
       retval = Sparse<double> (1, nc);
-      for(octave_idx_type i = 0; i < nc; i++)
-        retval.xcidx(i+1) = retval.xcidx(i) + (cidx(i+1) > cidx(i));
-      octave_idx_type new_nz = retval.xcidx(nc);
+      for (octave_idx_type i = 0; i < nc; i++)
+        retval.xcidx (i+1) = retval.xcidx (i) + (cidx (i+1) > cidx (i));
+      octave_idx_type new_nz = retval.xcidx (nc);
       retval.change_capacity (new_nz);
       fill_or_memset (new_nz, static_cast<octave_idx_type> (0), retval.ridx ());
-      for(octave_idx_type i = 0, k = 0; i < nc; i++)
+      for (octave_idx_type i = 0, k = 0; i < nc; i++)
         {
-          octave_idx_type c = cidx(i+1) - cidx(i);
+          octave_idx_type c = cidx (i+1) - cidx (i);
           if (c > 0)
-            retval.xdata(k++) = c;
+            retval.xdata (k++) = c;
         }
     }
   else if (dim == 1)
     {
       // Result is a column vector.
       if (nz > nr)
         {
           // We can use O(nr) memory.
           Array<double> tmp (dim_vector (nr, 1), 0);
           for (octave_idx_type i = 0; i < nz; i++)
-            tmp.xelem(ridx(i)) += 1.0;
+            tmp.xelem (ridx (i)) += 1.0;
           retval = tmp;
         }
       else
         {
           Array<octave_idx_type> tmp (dim_vector (nz, 1));
           copy_or_memcpy (nz, ridx (), tmp.fortran_vec ());
           retval = Sparse<double> (Array<double> (dim_vector (1, 1), 1.0),
                                    idx_vector (tmp),
@@ -241,34 +241,34 @@ SparseBoolMatrix::diag (octave_idx_type 
 boolMatrix
 SparseBoolMatrix::matrix_value (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   boolMatrix retval (nr, nc, false);
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-      retval.elem (ridx(i), j) = data (i);
+    for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+      retval.elem (ridx (i), j) = data (i);
 
   return retval;
 }
 
 std::ostream&
 operator << (std::ostream& os, const SparseBoolMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)
      {
        octave_quit ();
-       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-         os << a.ridx(i) + 1 << " "  << j + 1 << " " << a.data(i) << "\n";
+       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+         os << a.ridx (i) + 1 << " "  << j + 1 << " " << a.data (i) << "\n";
      }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseBoolMatrix& a)
 {
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -530,17 +530,17 @@ command_history::file (void)
   return (instance_ok ())
     ? instance->do_file () : std::string ();
 }
 
 void
 command_history::process_histcontrol (const std::string& control_arg)
 {
   if (instance_ok ())
-    instance->do_process_histcontrol(control_arg);
+    instance->do_process_histcontrol (control_arg);
 }
 
 std::string
 command_history::histcontrol (void)
 {
   return (instance_ok ())
     ? instance->do_histcontrol () : std::string ();
 }
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -357,17 +357,17 @@ DiagMatrix::determinant (void) const
     }
 
   return det;
 }
 
 double
 DiagMatrix::rcond (void) const
 {
-  ColumnVector av  = diag (0).map<double> (fabs);
+  ColumnVector av = diag (0).map<double> (fabs);
   double amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0 : amn / amx;
 }
 
 std::ostream&
 operator << (std::ostream& os, const DiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -758,17 +758,17 @@ Matrix::finverse (MatrixType &mattype, o
       z.resize (dim_vector (lwork, 1));
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond)
-        anorm = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -833,17 +833,17 @@ Matrix::inverse (MatrixType &mattype, oc
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (!mattype.is_hermitian ())
-        ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = Matrix (rows (), columns (), octave_Inf);
     }
 
   return ret;
 }
 
@@ -1493,17 +1493,17 @@ Matrix::rcond (MatrixType &mattype) cons
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-              if(anorm < 0.)
+              if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
@@ -1757,17 +1757,17 @@ Matrix::fsolve (MatrixType &mattype, con
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1833,18 +1833,18 @@ Matrix::fsolve (MatrixType &mattype, con
         {
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
-          if(anorm < 0.)
-            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          if (anorm < 0.)
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           Array<double> z (dim_vector (4 * nc, 1));
           double *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2057,17 +2057,17 @@ Matrix::solve (MatrixType &typ, const Co
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
                double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   Matrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
-  return tmp.column(static_cast<octave_idx_type> (0));
+  return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
@@ -2089,17 +2089,17 @@ Matrix::solve (MatrixType &typ, const Co
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                octave_idx_type& info, double& rcon,
                solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve(typ, b, info, rcon, sing_handler, transt);
+  return tmp.solve (typ, b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -276,17 +276,17 @@ NDArray::fourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
@@ -323,17 +323,17 @@ NDArray::ifourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<double> (npts);
         }
     }
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -59,16 +59,20 @@ public:
   template <class U>
   NDArray (const Array<U>& a) : MArray<double> (a) { }
 
   template <class U>
   explicit NDArray (const intNDArray<U>& a) : MArray<double> (a) { }
 
   NDArray (const charNDArray&);
 
+  // For jit support only
+  NDArray (double *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
+    : MArray<double> (sdata, slen, adims, arep) { }
+
   NDArray& operator = (const NDArray& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
   // unary operations
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -172,38 +172,38 @@ SparseMatrix::SparseMatrix (const DiagMa
       if (a(i, i) != 0.0)
         {
           data (j) = a(i, i);
           ridx (j) = i;
           j++;
         }
     }
   for (octave_idx_type i = l; i <= a.cols (); i++)
-    cidx(i) = j;
+    cidx (i) = j;
 }
 
 bool
 SparseMatrix::operator == (const SparseMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz = nnz ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
-    if (cidx(i) != a.cidx(i))
+    if (cidx (i) != a.cidx (i))
         return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
-    if (data(i) != a.data(i) || ridx(i) != a.ridx(i))
+    if (data (i) != a.data (i) || ridx (i) != a.ridx (i))
       return false;
 
   return true;
 }
 
 bool
 SparseMatrix::operator != (const SparseMatrix& a) const
 {
@@ -215,29 +215,29 @@ SparseMatrix::is_symmetric (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == nc && nr > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              octave_idx_type ri = ridx(i);
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              octave_idx_type ri = ridx (i);
 
               if (ri != j)
                 {
                   bool found = false;
 
-                  for (octave_idx_type k = cidx(ri); k < cidx(ri+1); k++)
+                  for (octave_idx_type k = cidx (ri); k < cidx (ri+1); k++)
                     {
-                      if (ridx(k) == j)
+                      if (ridx (k) == j)
                         {
-                          if (data(i) == data(k))
+                          if (data (i) == data (k))
                             found = true;
                           break;
                         }
                     }
 
                   if (! found)
                     return false;
                 }
@@ -289,28 +289,28 @@ SparseMatrix::max (Array<octave_idx_type
   if (dim == 0)
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           double tmp_max = octave_NaN;
           octave_idx_type idx_j = 0;
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              if (ridx(i) != idx_j)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
 
           if (idx_j != nr)
             tmp_max = 0.;
 
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               double tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
               else if (xisnan (tmp_max) || tmp > tmp_max)
                 {
                   idx_j = ridx (i);
@@ -339,55 +339,55 @@ SparseMatrix::max (Array<octave_idx_type
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
       idx_arg.resize (dim_vector  (nr, 1), 0);
 
-      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-        idx_arg.elem(ridx(i)) = -1;
+      for (octave_idx_type i = cidx (0); i < cidx (1); i++)
+        idx_arg.elem (ridx (i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            if (idx_arg.elem(i) != -1)
+            if (idx_arg.elem (i) != -1)
               continue;
             bool found = false;
-            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-              if (ridx(k) == i)
+            for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
+              if (ridx (k) == i)
                 {
                   found = true;
                   break;
                 }
 
             if (!found)
-              idx_arg.elem(i) = j;
+              idx_arg.elem (i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               double tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
               else if (ix == -1 || tmp > elem (ir, ix))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+        if (idx_arg.elem (j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
           nel++;
 
       result = SparseMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -438,28 +438,28 @@ SparseMatrix::min (Array<octave_idx_type
   if (dim == 0)
     {
       idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           double tmp_min = octave_NaN;
           octave_idx_type idx_j = 0;
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-            {
-              if (ridx(i) != idx_j)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+            {
+              if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
 
           if (idx_j != nr)
             tmp_min = 0.;
 
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               double tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
               else if (xisnan (tmp_min) || tmp < tmp_min)
                 {
                   idx_j = ridx (i);
@@ -488,55 +488,55 @@ SparseMatrix::min (Array<octave_idx_type
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, 1), 0);
 
-      for (octave_idx_type i = cidx(0); i < cidx(1); i++)
-        idx_arg.elem(ridx(i)) = -1;
+      for (octave_idx_type i = cidx (0); i < cidx (1); i++)
+        idx_arg.elem (ridx (i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            if (idx_arg.elem(i) != -1)
+            if (idx_arg.elem (i) != -1)
               continue;
             bool found = false;
-            for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
-              if (ridx(k) == i)
+            for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
+              if (ridx (k) == i)
                 {
                   found = true;
                   break;
                 }
 
             if (!found)
-              idx_arg.elem(i) = j;
+              idx_arg.elem (i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+          for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_idx_type ir = ridx (i);
               octave_idx_type ix = idx_arg.elem (ir);
               double tmp = data (i);
 
               if (xisnan (tmp))
                 continue;
               else if (ix == -1 || tmp < elem (ir, ix))
                 idx_arg.elem (ir) = j;
             }
         }
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nr; j++)
-        if (idx_arg.elem(j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
+        if (idx_arg.elem (j) == -1 || elem (j, idx_arg.elem (j)) != 0.)
           nel++;
 
       result = SparseMatrix (nr, 1, nel);
 
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
@@ -615,42 +615,42 @@ SparseMatrix
 real (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
-    r.cidx(i) = a.cidx(i);
+    r.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data(i) = std::real (a.data(i));
-      r.ridx(i) = a.ridx(i);
+      r.data (i) = std::real (a.data (i));
+      r.ridx (i) = a.ridx (i);
     }
 
   return r;
 }
 
 SparseMatrix
 imag (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
-    r.cidx(i) = a.cidx(i);
+    r.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
-      r.data(i) = std::imag (a.data(i));
-      r.ridx(i) = a.ridx(i);
+      r.data (i) = std::imag (a.data (i));
+      r.ridx (i) = a.ridx (i);
     }
 
   return r;
 }
 
 SparseMatrix
 atan2 (const double& x, const SparseMatrix& y)
 {
@@ -662,38 +662,38 @@ atan2 (const double& x, const SparseMatr
   else
     {
       // Its going to be basically full, so this is probably the
       // best way to handle it.
       Matrix tmp (nr, nc, atan2 (x, 0.));
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
-          tmp.elem (y.ridx(i), j) = atan2 (x, y.data(i));
+          tmp.elem (y.ridx (i), j) = atan2 (x, y.data (i));
 
       return SparseMatrix (tmp);
     }
 }
 
 SparseMatrix
 atan2 (const SparseMatrix& x, const double& y)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
   octave_idx_type nz = x.nnz ();
 
   SparseMatrix retval (nr, nc, nz);
 
   octave_idx_type ii = 0;
-  retval.xcidx(0) = 0;
+  retval.xcidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
-      for (octave_idx_type j = x.cidx(i); j < x.cidx(i+1); j++)
+      for (octave_idx_type j = x.cidx (i); j < x.cidx (i+1); j++)
         {
-          double tmp = atan2 (x.data(j), y);
+          double tmp = atan2 (x.data (j), y);
           if (tmp != 0.)
             {
               retval.xdata (ii) = tmp;
               retval.xridx (ii++) = x.ridx (j);
             }
         }
       retval.xcidx (i+1) = ii;
     }
@@ -732,58 +732,58 @@ atan2 (const SparseMatrix& x, const Spar
       else
         {
           r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < x_nc ; i++)
             {
-              octave_idx_type  ja = x.cidx(i);
-              octave_idx_type  ja_max = x.cidx(i+1);
+              octave_idx_type  ja = x.cidx (i);
+              octave_idx_type  ja_max = x.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = y.cidx(i);
-              octave_idx_type  jb_max = y.cidx(i+1);
+              octave_idx_type  jb = y.cidx (i);
+              octave_idx_type  jb_max = y.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (x.ridx(ja) < y.ridx(jb))))
+                      (ja_lt_max && (x.ridx (ja) < y.ridx (jb))))
                     {
-                      r.ridx(jx) = x.ridx(ja);
-                      r.data(jx) = atan2 (x.data(ja), 0.);
+                      r.ridx (jx) = x.ridx (ja);
+                      r.data (jx) = atan2 (x.data (ja), 0.);
                       jx++;
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (y.ridx(jb) < x.ridx(ja)) ) )
+                           (jb_lt_max && (y.ridx (jb) < x.ridx (ja)) ) )
                     {
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      double tmp = atan2 (x.data(ja), y.data(jb));
+                      double tmp = atan2 (x.data (ja), y.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = x.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = x.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
@@ -844,17 +844,17 @@ SparseMatrix::dinverse (MatrixType &matt
           // Force make_unique to be called
           double *v = retval.data ();
 
           if (calccond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
-                  double tmp = fabs(v[i]);
+                  double tmp = fabs (v[i]);
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
 
@@ -894,18 +894,18 @@ SparseMatrix::tinverse (MatrixType &matt
           double ainvnorm = 0.;
 
           if (calccond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Upper || typ == MatrixType::Lower)
             {
               octave_idx_type nz = nnz ();
@@ -920,101 +920,101 @@ SparseMatrix::tinverse (MatrixType &matt
                   octave_idx_type cx_colstart = cx;
 
                   if (cx == nz2)
                     {
                       nz2 *= 2;
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx(i) = cx;
-                  retval.xridx(cx) = i;
-                  retval.xdata(cx) = 1.0;
+                  retval.xcidx (i) = cx;
+                  retval.xridx (cx) = i;
+                  retval.xdata (cx) = 1.0;
                   cx++;
 
                   // iterate accross columns of input matrix
                   for (octave_idx_type j = i+1; j < nr; j++)
                     {
                       double v = 0.;
                       // iterate to calculate sum
-                      octave_idx_type colXp = retval.xcidx(i);
-                      octave_idx_type colUp = cidx(j);
+                      octave_idx_type colXp = retval.xcidx (i);
+                      octave_idx_type colUp = cidx (j);
                       octave_idx_type rpX, rpU;
 
-                      if (cidx(j) == cidx(j+1))
+                      if (cidx (j) == cidx (j+1))
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       do
                         {
                           octave_quit ();
-                          rpX = retval.xridx(colXp);
-                          rpU = ridx(colUp);
+                          rpX = retval.xridx (colXp);
+                          rpU = ridx (colUp);
 
                           if (rpX < rpU)
                             colXp++;
                           else if (rpX > rpU)
                             colUp++;
                           else
                             {
-                              v -= retval.xdata(colXp) * data(colUp);
+                              v -= retval.xdata (colXp) * data (colUp);
                               colXp++;
                               colUp++;
                             }
                         } while ((rpX<j) && (rpU<j) &&
                                  (colXp<cx) && (colUp<nz));
 
                       // get A(m,m)
                       if (typ == MatrixType::Upper)
-                        colUp = cidx(j+1) - 1;
+                        colUp = cidx (j+1) - 1;
                       else
-                        colUp = cidx(j);
-                      double pivot = data(colUp);
-                      if (pivot == 0. || ridx(colUp) != j)
+                        colUp = cidx (j);
+                      double pivot = data (colUp);
+                      if (pivot == 0. || ridx (colUp) != j)
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       if (v != 0.)
                         {
                           if (cx == nz2)
                             {
                               nz2 *= 2;
                               retval.change_capacity (nz2);
                             }
 
-                          retval.xridx(cx) = j;
-                          retval.xdata(cx) = v / pivot;
+                          retval.xridx (cx) = j;
+                          retval.xdata (cx) = v / pivot;
                           cx++;
                         }
                     }
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Upper)
-                    colUp = cidx(i+1) - 1;
+                    colUp = cidx (i+1) - 1;
                   else
-                    colUp = cidx(i);
-                  double pivot = data(colUp);
-                  if (pivot == 0. || ridx(colUp) != i)
+                    colUp = cidx (i);
+                  double pivot = data (colUp);
+                  if (pivot == 0. || ridx (colUp) != i)
                     {
                       (*current_liboctave_error_handler) ("division by zero");
                       goto inverse_singular;
                     }
 
                   if (pivot != 1.0)
                     for (octave_idx_type j = cx_colstart; j < cx; j++)
-                      retval.xdata(j) /= pivot;
-                }
-              retval.xcidx(nr) = cx;
+                      retval.xdata (j) /= pivot;
+                }
+              retval.xcidx (nr) = cx;
               retval.maybe_compress ();
             }
           else
             {
               octave_idx_type nz = nnz ();
               octave_idx_type cx = 0;
               octave_idx_type nz2 = nz;
               retval = SparseMatrix (nr, nc, nz2);
@@ -1048,47 +1048,47 @@ SparseMatrix::tinverse (MatrixType &matt
                   work[iidx] = 1.0;
 
                   // iterate accross columns of input matrix
                   for (octave_idx_type j = iidx+1; j < nr; j++)
                     {
                       double v = 0.;
                       octave_idx_type jidx = perm[j];
                       // iterate to calculate sum
-                      for (octave_idx_type k = cidx(jidx);
-                           k < cidx(jidx+1); k++)
+                      for (octave_idx_type k = cidx (jidx);
+                           k < cidx (jidx+1); k++)
                         {
                           octave_quit ();
-                          v -= work[ridx(k)] * data(k);
+                          v -= work[ridx (k)] * data (k);
                         }
 
                       // get A(m,m)
                       double pivot;
                       if (typ == MatrixType::Permuted_Upper)
-                        pivot = data(cidx(jidx+1) - 1);
+                        pivot = data (cidx (jidx+1) - 1);
                       else
-                        pivot = data(cidx(jidx));
+                        pivot = data (cidx (jidx));
                       if (pivot == 0.)
                         {
                           (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       work[j] = v / pivot;
                     }
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Permuted_Upper)
-                    colUp = cidx(perm[iidx]+1) - 1;
+                    colUp = cidx (perm[iidx]+1) - 1;
                   else
-                    colUp = cidx(perm[iidx]);
-
-                  double pivot = data(colUp);
+                    colUp = cidx (perm[iidx]);
+
+                  double pivot = data (colUp);
                   if (pivot == 0.)
                     {
                       (*current_liboctave_error_handler)
                         ("division by zero");
                       goto inverse_singular;
                     }
 
                   octave_idx_type new_cx = cx;
@@ -1101,38 +1101,38 @@ SparseMatrix::tinverse (MatrixType &matt
                       }
 
                   if (cx < new_cx)
                     {
                       nz2 = (2*nz2 < new_cx ? new_cx : 2*nz2);
                       retval.change_capacity (nz2);
                     }
 
-                  retval.xcidx(i) = cx;
+                  retval.xcidx (i) = cx;
                   for (octave_idx_type j = iidx; j < nr; j++)
                     if (work[j] != 0.)
                       {
-                        retval.xridx(cx) = j;
-                        retval.xdata(cx++) = work[j];
+                        retval.xridx (cx) = j;
+                        retval.xdata (cx++) = work[j];
                       }
                 }
 
-              retval.xcidx(nr) = cx;
+              retval.xcidx (nr) = cx;
               retval.maybe_compress ();
             }
 
           if (calccond)
             {
               // Calculate the 1-norm of inverse matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = retval.cidx(j);
-                       i < retval.cidx(j+1); i++)
-                    atmp += fabs(retval.data(i));
+                  for (octave_idx_type i = retval.cidx (j);
+                       i < retval.cidx (j+1); i++)
+                    atmp += fabs (retval.data (i));
                   if (atmp > ainvnorm)
                     ainvnorm = atmp;
                 }
 
               rcond = 1. / ainvnorm / anorm;
             }
         }
       else
@@ -1170,17 +1170,17 @@ SparseMatrix::inverse (MatrixType &matty
         {
           MatrixType tmp_typ (MatrixType::Upper);
           SparseCHOL fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
-              SparseMatrix InvL = fact.L ().transpose ().tinverse(tmp_typ,
+              SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
                                            info, rcond2, true, false);
               ret = Q * InvL.transpose () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
@@ -1193,19 +1193,19 @@ SparseMatrix::inverse (MatrixType &matty
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseLU fact (*this, Qinit, Matrix (), false, false);
           rcond = fact.rcond ();
           double rcond2;
-          SparseMatrix InvL = fact.L ().transpose ().tinverse(tmp_typ,
+          SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
                                            info, rcond2, true, false);
-          SparseMatrix InvU = fact.U ().tinverse(tmp_typ, info, rcond2,
+          SparseMatrix InvU = fact.U ().tinverse (tmp_typ, info, rcond2,
                                            true, false).transpose ();
           ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
@@ -1369,25 +1369,25 @@ SparseMatrix::dsolve (MatrixType &mattyp
           retval.resize (nc, b.cols (), 0.);
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                  retval(k,j) = b(ridx(i),j) / data (i);
+                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                  retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = fabs(data(i));
+                  double tmp = fabs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1425,59 +1425,59 @@ SparseMatrix::dsolve (MatrixType &mattyp
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseMatrix (nc, b_nc, b_nz);
 
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b_nc; j++)
               {
-                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                   {
-                    if (b.ridx(i) >= nm)
+                    if (b.ridx (i) >= nm)
                       break;
-                    retval.xridx (ii) = b.ridx(i);
-                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                    retval.xridx (ii) = b.ridx (i);
+                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
                   }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
           else
             for (octave_idx_type j = 0; j < b_nc; j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
-                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-                        if (ridx(i) == b.ridx(k))
+                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                        if (ridx (i) == b.ridx (k))
                           {
                             found = true;
                             break;
                           }
                       if (found)
                         {
                           retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data(k) / data (i);
+                          retval.xdata (ii++) = b.data (k) / data (i);
                         }
                     }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = fabs(data(i));
+                  double tmp = fabs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1519,25 +1519,25 @@ SparseMatrix::dsolve (MatrixType &mattyp
           retval.resize (nc, b.cols (), 0);
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
-                for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                  retval(k,j) = b(ridx(i),j) / data (i);
+                for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                  retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = fabs(data(i));
+                  double tmp = fabs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1575,59 +1575,59 @@ SparseMatrix::dsolve (MatrixType &mattyp
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
-                for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+                for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                   {
-                    if (b.ridx(i) >= nm)
+                    if (b.ridx (i) >= nm)
                       break;
-                    retval.xridx (ii) = b.ridx(i);
-                    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
+                    retval.xridx (ii) = b.ridx (i);
+                    retval.xdata (ii++) = b.data (i) / data (b.ridx (i));
                   }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
-                  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+                  for (octave_idx_type i = cidx (l); i < cidx (l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
-                      for (k = b.cidx(j); k < b.cidx(j+1); k++)
-                        if (ridx(i) == b.ridx(k))
+                      for (k = b.cidx (j); k < b.cidx (j+1); k++)
+                        if (ridx (i) == b.ridx (k))
                           {
                             found = true;
                             break;
                           }
                       if (found)
                         {
                           retval.xridx (ii) = l;
-                          retval.xdata (ii++) = b.data(k) / data (i);
+                          retval.xdata (ii++) = b.data (k) / data (i);
                         }
                     }
-                retval.xcidx(j+1) = ii;
+                retval.xcidx (j+1) = ii;
               }
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
-                  double tmp = fabs(data(i));
+                  double tmp = fabs (data (i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
               rcond = dmin / dmax;
             }
           else
@@ -1673,18 +1673,18 @@ SparseMatrix::utsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Upper)
             {
               retval.resize (nc, b_nc);
@@ -1699,30 +1699,30 @@ SparseMatrix::utsolve (MatrixType &matty
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(kidx+1)-1);
+                          double tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (perm[i], j) = work[i];
                 }
 
@@ -1737,30 +1737,30 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              double tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -1775,29 +1775,29 @@ SparseMatrix::utsolve (MatrixType &matty
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(k+1)-1);
+                          double tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -1810,29 +1810,29 @@ SparseMatrix::utsolve (MatrixType &matty
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k+1)-1);
+                              double tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -1907,66 +1907,66 @@ SparseMatrix::utsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               octave_idx_type *perm = mattype.triangular_perm ();
               OCTAVE_LOCAL_BUFFER (double, work, nm);
 
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 rperm[perm[i]] = i;
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(kidx+1)-1);
+                          double tmp = work[k] / data (cidx (kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -1979,20 +1979,20 @@ SparseMatrix::utsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[rperm[i]] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[rperm[i]];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[rperm[i]];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2003,66 +2003,66 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              double tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (double, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(k+1)-1);
+                          double tmp = work[k] / data (cidx (k+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2075,20 +2075,20 @@ SparseMatrix::utsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -2097,30 +2097,30 @@ SparseMatrix::utsolve (MatrixType &matty
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k+1)-1);
+                              double tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2195,18 +2195,18 @@ SparseMatrix::utsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Upper)
             {
               retval.resize (nc, b_nc);
@@ -2221,30 +2221,30 @@ SparseMatrix::utsolve (MatrixType &matty
                     cwork[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (perm[i], j) = cwork[i];
                 }
 
@@ -2260,30 +2260,30 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              double tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2298,29 +2298,29 @@ SparseMatrix::utsolve (MatrixType &matty
                     cwork[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     cwork[i] = 0.;
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(k+1)-1);
+                          Complex tmp = cwork[k] / data (cidx (k+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp  * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp  * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = cwork[i];
                 }
 
@@ -2334,30 +2334,30 @@ SparseMatrix::utsolve (MatrixType &matty
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k+1)-1);
+                              double tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2432,66 +2432,66 @@ SparseMatrix::utsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Upper)
             {
               octave_idx_type *perm = mattype.triangular_perm ();
               OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 rperm[perm[i]] = i;
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    cwork[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    cwork[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       octave_idx_type kidx = perm[k];
 
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(kidx+1)-1) != k ||
-                              data(cidx(kidx+1)-1) == 0.)
+                          if (ridx (cidx (kidx+1)-1) != k ||
+                              data (cidx (kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
+                          Complex tmp = cwork[k] / data (cidx (kidx+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx);
-                               i < cidx(kidx+1)-1; i++)
+                          for (octave_idx_type i = cidx (kidx);
+                               i < cidx (kidx+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2504,20 +2504,20 @@ SparseMatrix::utsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[rperm[i]] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = cwork[rperm[i]];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = cwork[rperm[i]];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
@@ -2529,66 +2529,66 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(iidx+1)-1);
+                              double tmp = work[k] / data (cidx (iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx);
-                                   i < cidx(iidx+1)-1; i++)
+                              for (octave_idx_type i = cidx (iidx);
+                                   i < cidx (iidx+1)-1; i++)
                                 {
-                                  octave_idx_type idx2 = ridx(i);
-                                  work[idx2] = work[idx2] - tmp * data(i);
+                                  octave_idx_type idx2 = ridx (i);
+                                  work[idx2] = work[idx2] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    cwork[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    cwork[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = nc-1; k >= 0; k--)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(k+1)-1) != k ||
-                              data(cidx(k+1)-1) == 0.)
+                          if (ridx (cidx (k+1)-1) != k ||
+                              data (cidx (k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(k+1)-1);
+                          Complex tmp = cwork[k] / data (cidx (k+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1)-1; i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -2601,20 +2601,20 @@ SparseMatrix::utsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = cwork[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = cwork[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
@@ -2624,30 +2624,30 @@ SparseMatrix::utsolve (MatrixType &matty
                   for (octave_idx_type j = 0; j < nr; j++)
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k+1)-1);
+                              double tmp = work[k] / data (cidx (k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1)-1; i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1)-1; i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = 0; i < j+1; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2723,18 +2723,18 @@ SparseMatrix::ltsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Lower)
             {
               retval.resize (nc, b_nc);
@@ -2751,38 +2751,38 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data(mini) == 0)
+                          if (minr != k || data (mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(mini);
+                          double tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(i, j) = work[i];
                 }
 
@@ -2798,42 +2798,42 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              double tmp = work[k] / data(mini);
+                              double tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2847,30 +2847,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     work[i] = 0.;
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(k));
+                          double tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1;
-                               i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1;
+                               i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = work[i];
                 }
 
@@ -2884,30 +2884,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k));
+                              double tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -2982,71 +2982,71 @@ SparseMatrix::ltsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               OCTAVE_LOCAL_BUFFER (double, work, nm);
               octave_idx_type *perm = mattype.triangular_perm ();
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[perm[b.ridx(i)]] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[perm[b.ridx (i)]] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data(mini) == 0)
+                          if (minr != k || data (mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(mini);
+                          double tmp = work[k] / data (mini);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3059,20 +3059,20 @@ SparseMatrix::ltsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3084,78 +3084,78 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              double tmp = work[k] / data(mini);
+                              double tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nr; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (double, work, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (work[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          double tmp = work[k] / data(cidx(k));
+                          double tmp = work[k] / data (cidx (k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              work[iidx] = work[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              work[iidx] = work[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3168,20 +3168,20 @@ SparseMatrix::ltsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
@@ -3191,30 +3191,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k));
+                              double tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3290,18 +3290,18 @@ SparseMatrix::ltsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           if (typ == MatrixType::Permuted_Lower)
             {
               retval.resize (nc, b_nc);
@@ -3317,38 +3317,38 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data(mini) == 0)
+                          if (minr != k || data (mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(mini);
+                          Complex tmp = cwork[k] / data (mini);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval(i, j) = cwork[i];
                 }
 
@@ -3365,42 +3365,42 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              double tmp = work[k] / data(mini);
+                              double tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3415,29 +3415,29 @@ SparseMatrix::ltsolve (MatrixType &matty
                     cwork[i] = b(i,j);
                   for (octave_idx_type i = nr; i < nc; i++)
                     cwork[i] = 0.;
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(k));
+                          Complex tmp = cwork[k] / data (cidx (k));
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     retval.xelem (i, j) = cwork[i];
                 }
 
@@ -3452,30 +3452,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k));
+                              double tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3550,71 +3550,71 @@ SparseMatrix::ltsolve (MatrixType &matty
           rcond = 1.;
 
           if (calc_cond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
               for (octave_idx_type j = 0; j < nc; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
-          retval.xcidx(0) = 0;
+          retval.xcidx (0) = 0;
           octave_idx_type ii = 0;
           octave_idx_type x_nz = b_nz;
 
           if (typ == MatrixType::Permuted_Lower)
             {
               OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
               octave_idx_type *perm = mattype.triangular_perm ();
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    cwork[perm[b.ridx(i)]] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    cwork[perm[b.ridx (i)]] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
                           octave_idx_type minr = nr;
                           octave_idx_type mini = 0;
 
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
-                            if (perm[ridx(i)] < minr)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
+                            if (perm[ridx (i)] < minr)
                               {
-                                minr = perm[ridx(i)];
+                                minr = perm[ridx (i)];
                                 mini = i;
                               }
 
-                          if (minr != k || data(mini) == 0)
+                          if (minr != k || data (mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(mini);
+                          Complex tmp = cwork[k] / data (mini);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
-                              octave_idx_type iidx = perm[ridx(i)];
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = perm[ridx (i)];
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3627,20 +3627,20 @@ SparseMatrix::ltsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = cwork[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = cwork[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
@@ -3653,78 +3653,78 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
-                                if (perm[ridx(i)] < minr)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
+                                if (perm[ridx (i)] < minr)
                                   {
-                                    minr = perm[ridx(i)];
+                                    minr = perm[ridx (i)];
                                     mini = i;
                                   }
 
-                              double tmp = work[k] / data(mini);
+                              double tmp = work[k] / data (mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k);
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k);
+                                   i < cidx (k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
-                                  octave_idx_type iidx = perm[ridx(i)];
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = perm[ridx (i)];
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
 
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nm; i++)
                     cwork[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    cwork[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    cwork[b.ridx (i)] = b.data (i);
 
                   for (octave_idx_type k = 0; k < nc; k++)
                     {
                       if (cwork[k] != 0.)
                         {
-                          if (ridx(cidx(k)) != k ||
-                              data(cidx(k)) == 0.)
+                          if (ridx (cidx (k)) != k ||
+                              data (cidx (k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
                             }
 
-                          Complex tmp = cwork[k] / data(cidx(k));
+                          Complex tmp = cwork[k] / data (cidx (k));
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+                          for (octave_idx_type i = cidx (k)+1; i < cidx (k+1); i++)
                             {
-                              octave_idx_type iidx = ridx(i);
-                              cwork[iidx] = cwork[iidx] - tmp * data(i);
+                              octave_idx_type iidx = ridx (i);
+                              cwork[iidx] = cwork[iidx] - tmp * data (i);
                             }
                         }
                     }
 
                   // Count non-zeros in work vector and adjust space in
                   // retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nc; i++)
@@ -3737,20 +3737,20 @@ SparseMatrix::ltsolve (MatrixType &matty
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
                     if (cwork[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = cwork[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = cwork[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
@@ -3761,30 +3761,30 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
-                              double tmp = work[k] / data(cidx(k));
+                              double tmp = work[k] / data (cidx (k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1;
-                                   i < cidx(k+1); i++)
+                              for (octave_idx_type i = cidx (k)+1;
+                                   i < cidx (k+1); i++)
                                 {
-                                  octave_idx_type iidx = ridx(i);
-                                  work[iidx] = work[iidx] - tmp * data(i);
+                                  octave_idx_type iidx = ridx (i);
+                                  work[iidx] = work[iidx] - tmp * data (i);
                                 }
                             }
                         }
                       double atmp = 0;
                       for (octave_idx_type i = j; i < nc; i++)
                         {
-                          atmp += fabs(work[i]);
+                          atmp += fabs (work[i]);
                           work[i] = 0.;
                         }
                       if (atmp > ainvnorm)
                         ainvnorm = atmp;
                     }
                   rcond = 1. / ainvnorm / anorm;
                 }
             }
@@ -3859,38 +3859,38 @@ SparseMatrix::trisolve (MatrixType &matt
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = data(ii);
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result,
@@ -3913,41 +3913,41 @@ SparseMatrix::trisolve (MatrixType &matt
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result,
@@ -4016,41 +4016,41 @@ SparseMatrix::trisolve (MatrixType &matt
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
@@ -4068,27 +4068,27 @@ SparseMatrix::trisolve (MatrixType &matt
             }
           else
             {
               rcond = 1.0;
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseMatrix (nr, b_nc, x_nz);
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               volatile octave_idx_type ii = 0;
 
               OCTAVE_LOCAL_BUFFER (double, work, nr);
 
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
-                  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-                    work[b.ridx(i)] = b.data(i);
+                  for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
+                    work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, 1, DL, D, DU, DU2, pipvt,
                              work, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   // Count non-zeros in work vector and adjust
@@ -4104,20 +4104,20 @@ SparseMatrix::trisolve (MatrixType &matt
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) = work[i];
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) = work[i];
                       }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4157,38 +4157,38 @@ SparseMatrix::trisolve (MatrixType &matt
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii);
                   ii += 2;
                 }
-              D[nc-1] = data(ii);
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
@@ -4212,41 +4212,41 @@ SparseMatrix::trisolve (MatrixType &matt
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
@@ -4315,41 +4315,41 @@ SparseMatrix::trisolve (MatrixType &matt
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
-                  D[j] = data(ii++);
-                  DL[j] = data(ii++);
-                  DU[j] = data(ii++);
-                }
-              D[nc-1] = data(ii);
+                  D[j] = data (ii++);
+                  DL[j] = data (ii++);
+                  DU[j] = data (ii++);
+                }
+              D[nc-1] = data (ii);
             }
           else
             {
               D[0] = 0.;
               for (octave_idx_type i = 0; i < nr - 1; i++)
                 {
                   D[i+1] = 0.;
                   DL[i] = 0.;
                   DU[i] = 0.;
                 }
 
               for (octave_idx_type j = 0; j < nc; j++)
-                for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+                for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                   {
-                    if (ridx(i) == j)
-                      D[j] = data(i);
-                    else if (ridx(i) == j + 1)
-                      DL[j] = data(i);
-                    else if (ridx(i) == j - 1)
-                      DU[j-1] = data(i);
+                    if (ridx (i) == j)
+                      D[j] = data (i);
+                    else if (ridx (i) == j + 1)
+                      DL[j] = data (i);
+                    else if (ridx (i) == j - 1)
+                      DU[j-1] = data (i);
                   }
             }
 
           F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
@@ -4374,17 +4374,17 @@ SparseMatrix::trisolve (MatrixType &matt
               OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b (i,j);
                       Bx[i] = std::real (c);
                       Bz[i] = std::imag (c);
@@ -4433,22 +4433,22 @@ SparseMatrix::trisolve (MatrixType &matt
                       octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (Bx[i] != 0. || Bz[i] != 0.)
                       {
-                        retval.xridx(ii) = i;
-                        retval.xdata(ii++) =
+                        retval.xridx (ii) = i;
+                        retval.xdata (ii++) =
                           Complex (Bx[i], Bz[i]);
                       }
 
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
             }
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
@@ -4491,27 +4491,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4598,28 +4598,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4741,27 +4741,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4815,17 +4815,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 
                   // Take a first guess that the number of non-zero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseMatrix (b_nr, b_nc, x_nz);
 
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b.elem (i, j);
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
@@ -4849,21 +4849,21 @@ SparseMatrix::bsolve (MatrixType &mattyp
                                 {
                                   // Resize the sparse matrix
                                   octave_idx_type sz = x_nz *
                                     (b_nc - j) / b_nc;
                                   sz = (sz > 10 ? sz : 10) + x_nz;
                                   retval.change_capacity (sz);
                                   x_nz = sz;
                                 }
-                              retval.xdata(ii) = tmp;
-                              retval.xridx(ii++) = i;
+                              retval.xdata (ii) = tmp;
+                              retval.xridx (ii++) = i;
                             }
                         }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
@@ -4881,28 +4881,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -4964,28 +4964,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseMatrix (nr, b_nc, x_nz);
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (double, work, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
-                      for (octave_idx_type i = b.cidx(j);
-                           i < b.cidx(j+1); i++)
-                        work[b.ridx(i)] = b.data(i);
+                      for (octave_idx_type i = b.cidx (j);
+                           i < b.cidx (j+1); i++)
+                        work[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, work, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       // Count non-zeros in work vector and adjust
@@ -5001,20 +5001,20 @@ SparseMatrix::bsolve (MatrixType &mattyp
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) = work[i];
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) = work[i];
                           }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
@@ -5059,27 +5059,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5197,28 +5197,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5358,27 +5358,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
-                  m_band(ri - j, j) = data(i);
+                  m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs ().sum ().row(0).max ();
+            anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5436,17 +5436,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
                   // Take a first guess that the number of non-zero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
                           Complex c = b (i,j);
                           Bx[i] = std::real (c);
                           Bz[i] = std::imag (c);
@@ -5494,22 +5494,22 @@ SparseMatrix::bsolve (MatrixType &mattyp
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) =
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) =
                               Complex (Bx[i], Bz[i]);
                           }
 
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
@@ -5527,28 +5527,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-              m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
+            for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+              m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             {
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-                    atmp += fabs(data(i));
+                  for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
+                    atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
@@ -5610,35 +5610,35 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
-                  retval.xcidx(0) = 0;
+                  retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (double, Bx, nr);
                   OCTAVE_LOCAL_BUFFER (double, Bz, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         {
                           Bx[i] = 0.;
                           Bz[i] = 0.;
                         }
-                      for (octave_idx_type i = b.cidx(j);
-                           i < b.cidx(j+1); i++)
+                      for (octave_idx_type i = b.cidx (j);
+                           i < b.cidx (j+1); i++)
                         {
-                          Complex c = b.data(i);
-                          Bx[b.ridx(i)] = std::real (c);
-                          Bz[b.ridx(i)] = std::imag (c);
+                          Complex c = b.data (i);
+                          Bx[b.ridx (i)] = std::real (c);
+                          Bz[b.ridx (i)] = std::imag (c);
                         }
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
@@ -5661,21 +5661,21 @@ SparseMatrix::bsolve (MatrixType &mattyp
                           octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           {
-                            retval.xridx(ii) = i;
-                            retval.xdata(ii++) =
+                            retval.xridx (ii) = i;
+                            retval.xdata (ii++) =
                               Complex (Bx[i], Bz[i]);
                           }
-                      retval.xcidx(j+1) = ii;
+                      retval.xcidx (j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
@@ -5930,17 +5930,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval.resize (b.rows (), b.cols ());
               for (octave_idx_type j = 0; j < b.cols (); j++)
                 {
                   octave_idx_type jr = j * b.rows ();
                   for (octave_idx_type i = 0; i < b.rows (); i++)
-                    retval.xelem(i,j) = static_cast<double *>(X->x)[jr + i];
+                    retval.xelem (i,j) = static_cast<double *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6155,22 +6155,22 @@ SparseMatrix::fsolve (MatrixType &mattyp
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseMatrix (static_cast<octave_idx_type>(X->nrow),
                                      static_cast<octave_idx_type>(X->ncol),
                                      static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
-                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+                retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
-                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-                  retval.xdata(j) = static_cast<double *>(X->x)[j];
+                  retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata (j) = static_cast<double *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6207,17 +6207,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseMatrix (b_nr, b_nc, x_nz);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
                                              Ai, Ax, Xx, Bx, Numeric, control,
@@ -6242,21 +6242,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                           if (ii == x_nz)
                             {
                               // Resize the sparse matrix
                               octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
                               sz = (sz > 10 ? sz : 10) + x_nz;
                               retval.change_capacity (sz);
                               x_nz = sz;
                             }
-                          retval.xdata(ii) = tmp;
-                          retval.xridx(ii++) = i;
+                          retval.xdata (ii) = tmp;
+                          retval.xridx (ii++) = i;
                         }
                     }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
@@ -6407,17 +6407,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval.resize (b.rows (), b.cols ());
               for (octave_idx_type j = 0; j < b.cols (); j++)
                 {
                   octave_idx_type jr = j * b.rows ();
                   for (octave_idx_type i = 0; i < b.rows (); i++)
-                    retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
+                    retval.xelem (i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6652,22 +6652,22 @@ SparseMatrix::fsolve (MatrixType &mattyp
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
                 (static_cast<octave_idx_type>(X->nrow),
                  static_cast<octave_idx_type>(X->ncol),
                  static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
-                retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
+                retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
-                  retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
-                  retval.xdata(j) = static_cast<Complex *>(X->x)[j];
+                  retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
+                  retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
               CHOLMOD_NAME(print_common) (tmp, cm);
@@ -6707,17 +6707,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
 
-              retval.xcidx(0) = 0;
+              retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b (i,j);
                       Bx[i] = std::real (c);
                       Bz[i] = std::imag (c);
                     }
@@ -6749,21 +6749,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                           if (ii == x_nz)
                             {
                               // Resize the sparse matrix
                               octave_idx_type sz = x_nz * (b_nc - j) / b_nc;
                               sz = (sz > 10 ? sz : 10) + x_nz;
                               retval.change_capacity (sz);
                               x_nz = sz;
                             }
-                          retval.xdata(ii) = tmp;
-                          retval.xridx(ii++) = i;
+                          retval.xdata (ii) = tmp;
+                          retval.xridx (ii++) = i;
                         }
                     }
-                  retval.xcidx(j+1) = ii;
+                  retval.xcidx (j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
@@ -6965,17 +6965,17 @@ SparseMatrix::solve (MatrixType &mattype
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<ComplexMatrix, SparseMatrix,
         ComplexMatrix> (*this, b, err);
 #endif
@@ -7033,17 +7033,17 @@ SparseMatrix::solve (MatrixType &mattype
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
-  if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
+  if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseMatrix,
         SparseComplexMatrix> (*this, b, err);
 #endif
@@ -7446,22 +7446,22 @@ SparseMatrix::operator ! (void) const
 
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
         {
-          if (jj < cidx(i+1) && ridx(jj) == j)
+          if (jj < cidx (i+1) && ridx (jj) == j)
             jj++;
           else
             {
-              r.data(ii) = true;
-              r.ridx(ii++) = j;
+              r.data (ii) = true;
+              r.ridx (ii++) = j;
             }
         }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
@@ -7495,32 +7495,32 @@ SparseMatrix::cumsum (int dim) const
 SparseMatrix
 SparseMatrix::prod (int dim) const
 {
   if ((rows () == 1 && dim == -1) || dim == 1)
     return transpose (). prod (0). transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseMatrix, double, *=,
-                           (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
+                           (cidx (j+1) - cidx (j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseMatrix
 SparseMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseMatrix, double, +=, 0.0, 0.0);
 }
 
 SparseMatrix
 SparseMatrix::sumsq (int dim) const
 {
 #define ROW_EXPR \
   double d = data (i); \
-  tmp[ridx(i)] += d * d
+  tmp[ridx (i)] += d * d
 
 #define COL_EXPR \
   double d = data (i); \
   tmp[j] += d * d
 
   SPARSE_BASE_REDUCTION_OP (SparseMatrix, double, ROW_EXPR, COL_EXPR,
                             0.0, 0.0);
 
@@ -7531,17 +7531,17 @@ SparseMatrix::sumsq (int dim) const
 SparseMatrix
 SparseMatrix::abs (void) const
 {
   octave_idx_type nz = nnz ();
 
   SparseMatrix retval (*this);
 
   for (octave_idx_type i = 0; i < nz; i++)
-    retval.data(i) = fabs(retval.data(i));
+    retval.data (i) = fabs (retval.data (i));
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::diag (octave_idx_type k) const
 {
   return MSparse<double>::diag (k);
@@ -7558,20 +7558,20 @@ operator << (std::ostream& os, const Spa
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)
      {
        octave_quit ();
-       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
          {
-           os << a.ridx(i) + 1 << " "  << j + 1 << " ";
-           octave_write_double (os, a.data(i));
+           os << a.ridx (i) + 1 << " "  << j + 1 << " ";
+           octave_write_double (os, a.data (i));
            os << "\n";
          }
      }
 
   return os;
 }
 
 std::istream&
@@ -7707,52 +7707,52 @@ min (double d, const SparseMatrix& m)
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
   // Count the number of non-zero elements
   if (d < 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           {
             double tmp = xmin (d, m.data (i));
             if (tmp != 0.)
               {
-                octave_idx_type idx = m.ridx(i) + j * nr;
-                result.xdata(idx) = tmp;
-                result.xridx(idx) = m.ridx(i);
+                octave_idx_type idx = m.ridx (i) + j * nr;
+                result.xdata (idx) = tmp;
+                result.xridx (idx) = m.ridx (i);
               }
           }
     }
   else
     {
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           if (xmin (d, m.data (i)) != 0.)
             nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
       octave_idx_type ii = 0;
-      result.xcidx(0) = 0;
+      result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
             {
               double tmp = xmin (d, m.data (i));
 
               if (tmp != 0.)
                 {
-                  result.xdata(ii) = tmp;
-                  result.xridx(ii++) = m.ridx(i);
-                }
-            }
-          result.xcidx(j+1) = ii;
+                  result.xdata (ii) = tmp;
+                  result.xridx (ii++) = m.ridx (i);
+                }
+            }
+          result.xcidx (j+1) = ii;
         }
     }
 
   return result;
 }
 
 SparseMatrix
 min (const SparseMatrix& m, double d)
@@ -7778,69 +7778,69 @@ min (const SparseMatrix& a, const Sparse
       else
         {
           r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
-              octave_idx_type  ja = a.cidx(i);
-              octave_idx_type  ja_max = a.cidx(i+1);
+              octave_idx_type  ja = a.cidx (i);
+              octave_idx_type  ja_max = a.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = b.cidx(i);
-              octave_idx_type  jb_max = b.cidx(i+1);
+              octave_idx_type  jb = b.cidx (i);
+              octave_idx_type  jb_max = b.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                     {
-                      double tmp = xmin (a.data(ja), 0.);
+                      double tmp = xmin (a.data (ja), 0.);
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = a.ridx(ja);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                           (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                     {
-                      double tmp = xmin (0., b.data(jb));
+                      double tmp = xmin (0., b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = b.ridx(jb);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = b.ridx (jb);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      double tmp = xmin (a.data(ja), b.data(jb));
+                      double tmp = xmin (a.data (ja), b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
@@ -7857,52 +7857,52 @@ max (double d, const SparseMatrix& m)
 
   EMPTY_RETURN_CHECK (SparseMatrix);
 
   // Count the number of non-zero elements
   if (d > 0.)
     {
       result = SparseMatrix (nr, nc, d);
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           {
             double tmp = xmax (d, m.data (i));
 
             if (tmp != 0.)
               {
-                octave_idx_type idx = m.ridx(i) + j * nr;
-                result.xdata(idx) = tmp;
-                result.xridx(idx) = m.ridx(i);
+                octave_idx_type idx = m.ridx (i) + j * nr;
+                result.xdata (idx) = tmp;
+                result.xridx (idx) = m.ridx (i);
               }
           }
     }
   else
     {
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+        for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
           if (xmax (d, m.data (i)) != 0.)
             nel++;
 
       result = SparseMatrix (nr, nc, nel);
 
       octave_idx_type ii = 0;
-      result.xcidx(0) = 0;
+      result.xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+          for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
             {
               double tmp = xmax (d, m.data (i));
               if (tmp != 0.)
                 {
-                  result.xdata(ii) = tmp;
-                  result.xridx(ii++) = m.ridx(i);
-                }
-            }
-          result.xcidx(j+1) = ii;
+                  result.xdata (ii) = tmp;
+                  result.xridx (ii++) = m.ridx (i);
+                }
+            }
+          result.xcidx (j+1) = ii;
         }
     }
 
   return result;
 }
 
 SparseMatrix
 max (const SparseMatrix& m, double d)
@@ -7928,69 +7928,69 @@ max (const SparseMatrix& a, const Sparse
       else
         {
           r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
-              octave_idx_type  ja = a.cidx(i);
-              octave_idx_type  ja_max = a.cidx(i+1);
+              octave_idx_type  ja = a.cidx (i);
+              octave_idx_type  ja_max = a.cidx (i+1);
               bool ja_lt_max= ja < ja_max;
 
-              octave_idx_type  jb = b.cidx(i);
-              octave_idx_type  jb_max = b.cidx(i+1);
+              octave_idx_type  jb = b.cidx (i);
+              octave_idx_type  jb_max = b.cidx (i+1);
               bool jb_lt_max = jb < jb_max;
 
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
+                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
                     {
-                      double tmp = xmax (a.data(ja), 0.);
+                      double tmp = xmax (a.data (ja), 0.);
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = a.ridx(ja);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                     }
                   else if (( !ja_lt_max ) ||
-                           (jb_lt_max && (b.ridx(jb) < a.ridx(ja)) ) )
+                           (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
                     {
-                      double tmp = xmax (0., b.data(jb));
+                      double tmp = xmax (0., b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.ridx(jx) = b.ridx(jb);
-                          r.data(jx) = tmp;
+                          r.ridx (jx) = b.ridx (jb);
+                          r.data (jx) = tmp;
                           jx++;
                         }
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                   else
                     {
-                      double tmp = xmax (a.data(ja), b.data(jb));
+                      double tmp = xmax (a.data (ja), b.data (jb));
                       if (tmp != 0.)
                         {
-                          r.data(jx) = tmp;
-                          r.ridx(jx) = a.ridx(ja);
+                          r.data (jx) = tmp;
+                          r.ridx (jx) = a.ridx (ja);
                           jx++;
                         }
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
-              r.cidx(i+1) = jx;
+              r.cidx (i+1) = jx;
             }
 
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -491,17 +491,17 @@ oct_data_conv::data_type_as_string (oct_
             swap_bytes< size > (ptr, len); \
           for (octave_idx_type i = 0; i < len; i++) \
             data[i] = ptr[i]; \
         } \
     } \
   while (0)
 
 // Have to use copy here to avoid writing over data accessed via
-// Matrix::data().
+// Matrix::data ().
 
 #define LS_DO_WRITE(TYPE, data, size, len, stream) \
   do \
     { \
       if (len > 0) \
         { \
           char tmp_type = type; \
           stream.write (&tmp_type, 1); \
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -461,33 +461,33 @@ QR::update (const ColumnVector& u, const
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init(q*r + Matrix (u) * Matrix (v).transpose (), get_type ());
+      init (q*r + Matrix (u) * Matrix (v).transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 QR::update (const Matrix& u, const Matrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
-      init(q*r + u * v.transpose (), get_type ());
+      init (q*r + u * v.transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 static
 Matrix insert_col (const Matrix& a, octave_idx_type i,
                         const ColumnVector& x)
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -130,17 +130,17 @@ SVD::init (const Matrix& a, SVD::type sv
   type_computed = svd_type;
 
   if (! (jobu == 'N' || jobu == 'O'))
     left_sm.resize (m, ncol_u);
 
   double *u = left_sm.fortran_vec ();
 
   sigma.resize (nrow_s, ncol_s);
-  double *s_vec  = sigma.fortran_vec ();
+  double *s_vec = sigma.fortran_vec ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   double *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
diff --git a/liboctave/dim-vector.cc b/liboctave/dim-vector.cc
--- a/liboctave/dim-vector.cc
+++ b/liboctave/dim-vector.cc
@@ -152,26 +152,26 @@ dim_vector::squeeze (void) const
               // was not a singleton dimension.
 
               new_dims.resize (2);
 
               new_dims(1) = 1;
             }
         }
       else
-        new_dims.resize(k);
+        new_dims.resize (k);
     }
 
   return new_dims;
 }
 
-// This is the rule for cat(). cat(dim, A, B) works if one
+// This is the rule for cat(). cat (dim, A, B) works if one
 // of the following holds, in this order:
 //
-// 1. size(A, k) == size(B, k) for all k != dim.
+// 1. size (A, k) == size (B, k) for all k != dim.
 // In this case, size (C, dim) = size (A, dim) + size (B, dim) and
 // other sizes remain intact.
 //
 // 2. A is 0x0, in which case B is the result
 // 3. B is 0x0, in which case A is the result
 
 bool
 dim_vector::concat (const dim_vector& dvb, int dim)
@@ -225,17 +225,17 @@ dim_vector::concat (const dim_vector& dv
   return match;
 }
 
 // Rules for horzcat/vertcat are yet looser.
 // two arrays A, B can be concatenated
 // horizontally (dim = 2) or vertically (dim = 1) if one of the
 // following holds, in this order:
 //
-// 1. cat(dim, A, B) works
+// 1. cat (dim, A, B) works
 //
 // 2. A, B are 2D and one of them is an empty vector, in which
 // case the result is the other one except if both of them
 // are empty vectors, in which case the result is 0x0.
 
 bool
 dim_vector::hvcat (const dim_vector& dvb, int dim)
 {
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -61,31 +61,31 @@ private:
   octave_idx_type& ndims (void) const { return rep[-1]; }
 
   octave_idx_type& count (void) const { return rep[-2]; }
 
   // Construct a new rep with count = 1 and ndims given.
 
   static octave_idx_type *newrep (int ndims)
   {
-    octave_idx_type *r = new octave_idx_type[ndims + 2];
+    octave_idx_type *r = new octave_idx_type [ndims + 2];
 
     *r++ = 1;
     *r++ = ndims;
 
     return r;
   }
 
   // Clone this->rep.
 
   octave_idx_type *clonerep (void)
   {
     int l = ndims ();
 
-    octave_idx_type *r = new octave_idx_type[l + 2];
+    octave_idx_type *r = new octave_idx_type [l + 2];
 
     *r++ = 1;
     *r++ = l;
 
     for (int i = 0; i < l; i++)
       r[i] = rep[i];
 
     return r;
@@ -95,17 +95,17 @@ private:
 
   octave_idx_type *resizerep (int n, octave_idx_type fill_value)
   {
     int l = ndims ();
 
     if (n < 2)
       n = 2;
 
-    octave_idx_type *r = new octave_idx_type[n + 2];
+    octave_idx_type *r = new octave_idx_type [n + 2];
 
     *r++ = 1;
     *r++ = n;
 
     if (l > n)
       l = n;
 
     int j;
@@ -207,37 +207,44 @@ public:
           l--;
         while (l > 2 && rep[l-1] == 1);
         ndims () = l;
       }
   }
 
   void chop_all_singletons (void);
 
+  // WARNING: Only call by jit
+  octave_idx_type *to_jit (void) const
+  {
+    return rep;
+  }
+
 private:
 
   static octave_idx_type *nil_rep (void)
     {
       static dim_vector zv (0, 0);
       return zv.rep;
     }
 
-  explicit dim_vector (octave_idx_type *r)
-    : rep (r) { }
-
 public:
 
   static octave_idx_type dim_max (void);
 
   explicit dim_vector (void) : rep (nil_rep ())
   { OCTREFCOUNT_ATOMIC_INCREMENT (&(count())); }
 
   dim_vector (const dim_vector& dv) : rep (dv.rep)
   { OCTREFCOUNT_ATOMIC_INCREMENT (&(count())); }
 
+  // FIXME: Should be private, but required by array constructor for jit
+  explicit dim_vector (octave_idx_type *r)
+    : rep (r) { }
+
   static dim_vector alloc (int n)
   {
     return dim_vector (newrep (n < 2 ? 2 : n));
   }
 
   dim_vector& operator = (const dim_vector& dv)
   {
     if (&dv != this)
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -236,18 +236,18 @@ ltsolve (const SM& L, const ColumnVector
   const double* qv = Q.fortran_vec ();
 
   if (!err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
         {
           for (octave_idx_type i = 0; i < n; i++)
-            retval.elem(static_cast<octave_idx_type>(qv[i]), j)  =
-              tmp.elem(i,j);
+            retval.elem (static_cast<octave_idx_type>(qv[i]), j) =
+              tmp.elem (i,j);
         }
     }
 
   return retval;
 }
 
 template <class SM, class M>
 static M
@@ -259,32 +259,32 @@ utsolve (const SM& U, const ColumnVector
   double rcond;
   MatrixType utyp (MatrixType::Upper);
 
   M retval (n, b_nc);
   const double* qv = Q.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = 0; i < n; i++)
-        retval.elem(i,j) = m.elem(static_cast<octave_idx_type>(qv[i]), j);
+        retval.elem (i,j) = m.elem (static_cast<octave_idx_type>(qv[i]), j);
     }
   return U.solve (utyp, retval, err, rcond, 0);
 }
 
 static bool
 vector_product (const SparseMatrix& m, const double* x, double* y)
 {
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     y[j] = 0.;
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      y[m.ridx(i)] += m.data(i) * x[j];
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      y[m.ridx (i)] += m.data (i) * x[j];
 
   return true;
 }
 
 static bool
 vector_product (const Matrix& m, const double *x, double *y)
 {
   octave_idx_type nr = m.rows ();
@@ -310,18 +310,18 @@ vector_product (const SparseComplexMatri
                         Complex* y)
 {
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     y[j] = 0.;
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      y[m.ridx(i)] += m.data(i) * x[j];
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      y[m.ridx (i)] += m.data (i) * x[j];
 
   return true;
 }
 
 static bool
 vector_product (const ComplexMatrix& m, const Complex *x, Complex *y)
 {
   octave_idx_type nr = m.rows ();
@@ -349,18 +349,18 @@ make_cholb (Matrix& b, Matrix& bt, Colum
   CHOL fact (b, info);
   octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
-      b =  bt.transpose ();
-      permB = ColumnVector(n);
+      b = bt.transpose ();
+      permB = ColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseMatrix& b, SparseMatrix& bt, ColumnVector& permB)
@@ -386,18 +386,18 @@ make_cholb (ComplexMatrix& b, ComplexMat
   ComplexCHOL fact (b, info);
   octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
-      b =  bt.hermitian ();
-      permB = ColumnVector(n);
+      b = bt.hermitian ();
+      permB = ColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseComplexMatrix& b, SparseComplexMatrix& bt,
@@ -433,44 +433,44 @@ LuAminusSigmaB (const SparseMatrix &m, c
     {
       if (cholB)
         {
           if (permB.length ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
-                  tmp.xcidx(i) = i;
-                  tmp.xridx(i) =
+                  tmp.xcidx (i) = i;
+                  tmp.xridx (i) =
                     static_cast<octave_idx_type>(permB(i));
-                  tmp.xdata(i) = 1;
+                  tmp.xdata (i) = 1;
                 }
-              tmp.xcidx(n) = n;
+              tmp.xcidx (n) = n;
 
               AminusSigmaB = AminusSigmaB - sigma * tmp *
                 b.transpose () * b * tmp.transpose ();
             }
           else
             AminusSigmaB = AminusSigmaB - sigma *
               b.transpose () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseMatrix sigmat (n, n, n);
 
-          // Create sigma * speye(n,n)
+          // Create sigma * speye (n,n)
           sigmat.xcidx (0) = 0;
           for (octave_idx_type i = 0; i < n; i++)
             {
-              sigmat.xdata(i) = sigma;
-              sigmat.xridx(i) = i;
-              sigmat.xcidx(i+1) = i + 1;
+              sigmat.xdata (i) = sigma;
+              sigmat.xridx (i) = i;
+              sigmat.xcidx (i+1) = i + 1;
             }
 
           AminusSigmaB = AminusSigmaB - sigmat;
         }
 
   SparseLU fact (AminusSigmaB);
 
   L = fact.L ();
@@ -485,19 +485,19 @@ LuAminusSigmaB (const SparseMatrix &m, c
     }
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
-      if (U.xcidx(j+1) > U.xcidx(j) &&
-          U.xridx (U.xcidx(j+1)-1) == j)
-        d = std::abs (U.xdata (U.xcidx(j+1)-1));
+      if (U.xcidx (j+1) > U.xcidx (j) &&
+          U.xridx (U.xcidx (j+1)-1) == j)
+        d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
 
@@ -536,18 +536,18 @@ LuAminusSigmaB (const Matrix &m, const M
           double *p = AminusSigmaB.fortran_vec ();
 
           if (permB.length ())
             {
               for (octave_idx_type j = 0;
                    j < b.cols (); j++)
                 for (octave_idx_type i = 0;
                      i < b.rows (); i++)
-                  *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
-                                      static_cast<octave_idx_type>(pB[j]));
+                  *p++ -= tmp.xelem (static_cast<octave_idx_type>(pB[i]),
+                                     static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
@@ -565,17 +565,17 @@ LuAminusSigmaB (const Matrix &m, const M
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
-      double d = std::abs (U.xelem(j,j));
+      double d = std::abs (U.xelem (j,j));
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
 
   double rcond = (minU / maxU);
@@ -608,43 +608,43 @@ LuAminusSigmaB (const SparseComplexMatri
     {
       if (cholB)
         {
           if (permB.length ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
-                  tmp.xcidx(i) = i;
-                  tmp.xridx(i) =
+                  tmp.xcidx (i) = i;
+                  tmp.xridx (i) =
                     static_cast<octave_idx_type>(permB(i));
-                  tmp.xdata(i) = 1;
+                  tmp.xdata (i) = 1;
                 }
-              tmp.xcidx(n) = n;
+              tmp.xcidx (n) = n;
 
               AminusSigmaB = AminusSigmaB - tmp * b.hermitian () * b *
                 tmp.transpose () * sigma;
             }
           else
             AminusSigmaB = AminusSigmaB - sigma * b.hermitian () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseComplexMatrix sigmat (n, n, n);
 
-      // Create sigma * speye(n,n)
+      // Create sigma * speye (n,n)
       sigmat.xcidx (0) = 0;
       for (octave_idx_type i = 0; i < n; i++)
         {
-          sigmat.xdata(i) = sigma;
-          sigmat.xridx(i) = i;
-          sigmat.xcidx(i+1) = i + 1;
+          sigmat.xdata (i) = sigma;
+          sigmat.xridx (i) = i;
+          sigmat.xcidx (i+1) = i + 1;
         }
 
       AminusSigmaB = AminusSigmaB - sigmat;
     }
 
   SparseComplexLU fact (AminusSigmaB);
 
   L = fact.L ();
@@ -659,19 +659,19 @@ LuAminusSigmaB (const SparseComplexMatri
     }
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
-      if (U.xcidx(j+1) > U.xcidx(j) &&
-          U.xridx (U.xcidx(j+1)-1) == j)
-        d = std::abs (U.xdata (U.xcidx(j+1)-1));
+      if (U.xcidx (j+1) > U.xcidx (j) &&
+          U.xridx (U.xcidx (j+1)-1) == j)
+        d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
 
@@ -710,18 +710,18 @@ LuAminusSigmaB (const ComplexMatrix &m, 
           Complex *p = AminusSigmaB.fortran_vec ();
 
           if (permB.length ())
             {
               for (octave_idx_type j = 0;
                    j < b.cols (); j++)
                 for (octave_idx_type i = 0;
                      i < b.rows (); i++)
-                  *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
-                                      static_cast<octave_idx_type>(pB[j]));
+                  *p++ -= tmp.xelem (static_cast<octave_idx_type>(pB[i]),
+                                     static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
@@ -739,17 +739,17 @@ LuAminusSigmaB (const ComplexMatrix &m, 
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
-      double d = std::abs (U.xelem(j,j));
+      double d = std::abs (U.xelem (j,j));
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
     }
 
   double rcond = (minU / maxU);
@@ -795,19 +795,19 @@ EigsRealSymmetricMatrix (const M& m, con
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -822,17 +822,17 @@ EigsRealSymmetricMatrix (const M& m, con
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k < 1 || k > n - 2)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
-         "      Use 'eig(full(A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -886,24 +886,24 @@ EigsRealSymmetricMatrix (const M& m, con
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
           if (permB.length () == 0)
             {
-              permB = ColumnVector(n);
+              permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
-          if (! make_cholb(b, bt, permB))
+          if (! make_cholb (b, bt, permB))
             {
               (*current_liboctave_error_handler)
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
@@ -946,17 +946,17 @@ EigsRealSymmetricMatrix (const M& m, con
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -974,17 +974,17 @@ EigsRealSymmetricMatrix (const M& m, con
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
-              mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
+              mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
           else if (!vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
@@ -1068,17 +1068,17 @@ EigsRealSymmetricMatrix (const M& m, con
                         z[off1 + j] = z[off2 + j];
 
                       for (octave_idx_type j = 0; j < n; j++)
                         z[off2 + j] = dtmp[j];
                     }
                 }
 
               if (note3)
-                eig_vec = ltsolve(b, permB, eig_vec);
+                eig_vec = ltsolve (b, permB, eig_vec);
             }
         }
       else
         {
           (*current_liboctave_error_handler)
             ("eigs: error %d in dseupd", info2);
           return -1;
         }
@@ -1119,33 +1119,33 @@ EigsRealSymmetricMatrixShift (const M& m
   //if (! std::abs (sigma))
   //  return EigsRealSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                _b, permB, resid, os, tol, rvec, cholB,
   //                                disp, maxit);
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
@@ -1213,17 +1213,17 @@ EigsRealSymmetricMatrixShift (const M& m
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
-  if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
+  if (! LuAminusSigmaB (m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
@@ -1239,17 +1239,17 @@ EigsRealSymmetricMatrixShift (const M& m
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1428,19 +1428,19 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -1455,17 +1455,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -1540,17 +1540,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -1709,19 +1709,19 @@ EigsRealNonSymmetricMatrix (const M& m, 
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -1736,17 +1736,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig(full(A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -1800,24 +1800,24 @@ EigsRealNonSymmetricMatrix (const M& m, 
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.transpose ();
           if (permB.length () == 0)
             {
-              permB = ColumnVector(n);
+              permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
-          if (! make_cholb(b, bt, permB))
+          if (! make_cholb (b, bt, permB))
             {
               (*current_liboctave_error_handler)
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
@@ -1888,17 +1888,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
 
-              mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
+              mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
           else if (!vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
@@ -1964,30 +1964,30 @@ EigsRealNonSymmetricMatrix (const M& m, 
       if (info2 == 0)
         {
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
-                d [i-jj] = Complex (dr[i], di[i]);
+                d[i-jj] = Complex (dr[i], di[i]);
             }
           if (jj == 0 && !rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
               Complex dtmp = d[i];
               d[i] = d[k - i - 1];
               d[k - i - 1] = dtmp;
             }
-          eig_val.resize(k);
+          eig_val.resize (k);
 
           if (rvec)
             {
               OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
               for (octave_idx_type i = 0; i < k2; i++)
                 {
                   octave_idx_type off1 = i * n;
@@ -2007,39 +2007,39 @@ EigsRealNonSymmetricMatrix (const M& m, 
                 }
 
               eig_vec.resize (n, k);
               octave_idx_type i = 0;
               while (i < k)
                 {
                   octave_idx_type off1 = i * n;
                   octave_idx_type off2 = (i+1) * n;
-                  if (std::imag(eig_val(i)) == 0)
+                  if (std::imag (eig_val(i)) == 0)
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         eig_vec(j,i) =
-                          Complex(z[j+off1],0.);
+                          Complex (z[j+off1],0.);
                       i++;
                     }
                   else
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         {
                           eig_vec(j,i) =
-                            Complex(z[j+off1],z[j+off2]);
+                            Complex (z[j+off1],z[j+off2]);
                           if (i < k - 1)
                             eig_vec(j,i+1) =
-                              Complex(z[j+off1],-z[j+off2]);
+                              Complex (z[j+off1],-z[j+off2]);
                         }
                       i+=2;
                     }
                 }
 
               if (note3)
-                eig_vec = ltsolve(M (b), permB, eig_vec);
+                eig_vec = ltsolve (M(b), permB, eig_vec);
             }
         }
       else
         {
           (*current_liboctave_error_handler)
             ("eigs: error %d in dneupd", info2);
           return -1;
         }
@@ -2082,19 +2082,19 @@ EigsRealNonSymmetricMatrixShift (const M
   //if (! std::abs (sigmar))
   //  return EigsRealNonSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                   _b, permB, resid, os, tol, rvec, cholB,
   //                                   disp, maxit);
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -2109,17 +2109,17 @@ EigsRealNonSymmetricMatrixShift (const M
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -2176,17 +2176,17 @@ EigsRealNonSymmetricMatrixShift (const M
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
-  if (! LuAminusSigmaB(m, b, cholB, permB, sigmar, L, U, P, Q))
+  if (! LuAminusSigmaB (m, b, cholB, permB, sigmar, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
@@ -2202,17 +2202,17 @@ EigsRealNonSymmetricMatrixShift (const M
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2350,30 +2350,30 @@ EigsRealNonSymmetricMatrixShift (const M
       if (info2 == 0)
         {
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
-                d [i-jj] = Complex (dr[i], di[i]);
+                d[i-jj] = Complex (dr[i], di[i]);
             }
           if (jj == 0 && !rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
               Complex dtmp = d[i];
               d[i] = d[k - i - 1];
               d[k - i - 1] = dtmp;
             }
-          eig_val.resize(k);
+          eig_val.resize (k);
 
           if (rvec)
             {
               OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
               for (octave_idx_type i = 0; i < k2; i++)
                 {
                   octave_idx_type off1 = i * n;
@@ -2393,32 +2393,32 @@ EigsRealNonSymmetricMatrixShift (const M
                 }
 
               eig_vec.resize (n, k);
               octave_idx_type i = 0;
               while (i < k)
                 {
                   octave_idx_type off1 = i * n;
                   octave_idx_type off2 = (i+1) * n;
-                  if (std::imag(eig_val(i)) == 0)
+                  if (std::imag (eig_val(i)) == 0)
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         eig_vec(j,i) =
-                          Complex(z[j+off1],0.);
+                          Complex (z[j+off1],0.);
                       i++;
                     }
                   else
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         {
                           eig_vec(j,i) =
-                            Complex(z[j+off1],z[j+off2]);
+                            Complex (z[j+off1],z[j+off2]);
                           if (i < k - 1)
                             eig_vec(j,i+1) =
-                              Complex(z[j+off1],-z[j+off2]);
+                              Complex (z[j+off1],-z[j+off2]);
                         }
                       i+=2;
                     }
                 }
             }
         }
       else
         {
@@ -2445,19 +2445,19 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   char bmat = 'I';
   double sigmai = 0.;
   octave_idx_type mode = 1;
   int err = 0;
 
   if (resid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      resid = ColumnVector (octave_rand::vector(n));
-      octave_rand::distribution(rand_dist);
+      octave_rand::distribution ("uniform");
+      resid = ColumnVector (octave_rand::vector (n));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -2472,17 +2472,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -2662,30 +2662,30 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       if (info2 == 0)
         {
           octave_idx_type jj = 0;
           for (octave_idx_type i = 0; i < k+1; i++)
             {
               if (dr[i] == 0.0 && di[i] == 0.0 && jj == 0)
                 jj++;
               else
-                d [i-jj] = Complex (dr[i], di[i]);
+                d[i-jj] = Complex (dr[i], di[i]);
             }
           if (jj == 0 && !rvec)
             for (octave_idx_type i = 0; i < k; i++)
               d[i] = d[i+1];
 
           octave_idx_type k2 = k / 2;
           for (octave_idx_type i = 0; i < k2; i++)
             {
               Complex dtmp = d[i];
               d[i] = d[k - i - 1];
               d[k - i - 1] = dtmp;
             }
-          eig_val.resize(k);
+          eig_val.resize (k);
 
           if (rvec)
             {
               OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
               for (octave_idx_type i = 0; i < k2; i++)
                 {
                   octave_idx_type off1 = i * n;
@@ -2705,32 +2705,32 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
                 }
 
               eig_vec.resize (n, k);
               octave_idx_type i = 0;
               while (i < k)
                 {
                   octave_idx_type off1 = i * n;
                   octave_idx_type off2 = (i+1) * n;
-                  if (std::imag(eig_val(i)) == 0)
+                  if (std::imag (eig_val(i)) == 0)
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         eig_vec(j,i) =
-                          Complex(z[j+off1],0.);
+                          Complex (z[j+off1],0.);
                       i++;
                     }
                   else
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         {
                           eig_vec(j,i) =
-                            Complex(z[j+off1],z[j+off2]);
+                            Complex (z[j+off1],z[j+off2]);
                           if (i < k - 1)
                             eig_vec(j,i+1) =
-                              Complex(z[j+off1],-z[j+off2]);
+                              Complex (z[j+off1],-z[j+off2]);
                         }
                       i+=2;
                     }
                 }
             }
         }
       else
         {
@@ -2773,23 +2773,23 @@ EigsComplexNonSymmetricMatrix (const M& 
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      Array<double> rr (octave_rand::vector(n));
-      Array<double> ri (octave_rand::vector(n));
+      octave_rand::distribution ("uniform");
+      Array<double> rr (octave_rand::vector (n));
+      Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
-        cresid(i) = Complex(rr(i),ri(i));
-      octave_rand::distribution(rand_dist);
+        cresid(i) = Complex (rr(i),ri(i));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -2804,17 +2804,17 @@ EigsComplexNonSymmetricMatrix (const M& 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-         "      Use 'eig(full(A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -2868,24 +2868,24 @@ EigsComplexNonSymmetricMatrix (const M& 
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
           b = b.hermitian ();
           if (permB.length () == 0)
             {
-              permB = ColumnVector(n);
+              permB = ColumnVector (n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
-          if (! make_cholb(b, bt, permB))
+          if (! make_cholb (b, bt, permB))
             {
               (*current_liboctave_error_handler)
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
@@ -2929,17 +2929,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
           return -1;
         }
 
-      if (disp > 0 && !xisnan(workl[iptr(5)-1]))
+      if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
@@ -2956,17 +2956,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               ComplexMatrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
-              mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
+              mtmp = utsolve (bt, permB, m * ltsolve (b, permB, mtmp));
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
 
             }
           else if (!vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
@@ -3021,17 +3021,17 @@ EigsComplexNonSymmetricMatrix (const M& 
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = ctmp;
         }
-      eig_val.resize(k);
+      eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
           for (octave_idx_type i = 0; i < k2; i++)
             {
               octave_idx_type off1 = i * n;
@@ -3046,17 +3046,17 @@ EigsComplexNonSymmetricMatrix (const M& 
               for (octave_idx_type j = 0; j < n; j++)
                 z[off1 + j] = z[off2 + j];
 
               for (octave_idx_type j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
 
           if (note3)
-            eig_vec = ltsolve(b, permB, eig_vec);
+            eig_vec = ltsolve (b, permB, eig_vec);
         }
     }
   else
     {
       (*current_liboctave_error_handler)
         ("eigs: error %d in zneupd", info2);
       return -1;
     }
@@ -3098,23 +3098,23 @@ EigsComplexNonSymmetricMatrixShift (cons
   //if (! std::abs (sigma))
   //  return EigsComplexNonSymmetricMatrix (m, "SM", k, p, info, eig_vec,
   //                                      eig_val, _b, permB, cresid, os, tol,
   //                                      rvec, cholB, disp, maxit);
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      Array<double> rr (octave_rand::vector(n));
-      Array<double> ri (octave_rand::vector(n));
+      octave_rand::distribution ("uniform");
+      Array<double> rr (octave_rand::vector (n));
+      Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
-        cresid(i) = Complex(rr(i),ri(i));
-      octave_rand::distribution(rand_dist);
+        cresid(i) = Complex (rr(i),ri(i));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -3129,17 +3129,17 @@ EigsComplexNonSymmetricMatrixShift (cons
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -3196,17 +3196,17 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
-  if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
+  if (! LuAminusSigmaB (m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (3 * p + 5);
 
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
@@ -3361,17 +3361,17 @@ EigsComplexNonSymmetricMatrixShift (cons
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = ctmp;
         }
-      eig_val.resize(k);
+      eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
           for (octave_idx_type i = 0; i < k2; i++)
             {
               octave_idx_type off1 = i * n;
@@ -3407,31 +3407,31 @@ EigsComplexNonSymmetricFunc (EigsComplex
                              octave_idx_type k, octave_idx_type p,
                              octave_idx_type &info, ComplexMatrix &eig_vec,
                              ComplexColumnVector &eig_val,
                              ComplexColumnVector &cresid, std::ostream& os,
                              double tol, bool rvec, bool /* cholB */,
                              int disp, int maxit)
 {
   std::string typ (_typ);
-  bool have_sigma = (std::abs(sigma) ? true : false);
+  bool have_sigma = (std::abs (sigma) ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
   if (cresid.is_empty ())
     {
       std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution("uniform");
-      Array<double> rr (octave_rand::vector(n));
-      Array<double> ri (octave_rand::vector(n));
+      octave_rand::distribution ("uniform");
+      Array<double> rr (octave_rand::vector (n));
+      Array<double> ri (octave_rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
-        cresid(i) = Complex(rr(i),ri(i));
-      octave_rand::distribution(rand_dist);
+        cresid(i) = Complex (rr(i),ri(i));
+      octave_rand::distribution (rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
@@ -3446,17 +3446,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig(full(A))' instead");
+             "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -3625,17 +3625,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
         {
           Complex ctmp = d[i];
           d[i] = d[k - i - 1];
           d[k - i - 1] = ctmp;
         }
-      eig_val.resize(k);
+      eig_val.resize (k);
 
       if (rvec)
         {
           OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
           for (octave_idx_type i = 0; i < k2; i++)
             {
               octave_idx_type off1 = i * n;
diff --git a/liboctave/f2c-main.c b/liboctave/f2c-main.c
--- a/liboctave/f2c-main.c
+++ b/liboctave/f2c-main.c
@@ -26,10 +26,10 @@ along with Octave; see the file COPYING.
 /* Dummy Fortran main declaration, needed in order to link to some
    Fortran libraries.  See the AC_F77_DUMMY_MAIN macro documentation.
    This function should never be called. */
 
 #ifdef F77_DUMMY_MAIN
 #  ifdef __cplusplus
 extern "C"
 #  endif
-int F77_DUMMY_MAIN () { assert(0); return 1; }
+int F77_DUMMY_MAIN () { assert (0); return 1; }
 #endif
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1076,27 +1076,27 @@ FloatComplexMatrix::finverse (MatrixType
       Array<FloatComplex> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
       F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
                                  z.fortran_vec (), lwork, info));
 
-      lwork = static_cast<octave_idx_type> (std::real(z(0)));
+      lwork = static_cast<octave_idx_type> (std::real (z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (dim_vector (lwork, 1));
       FloatComplex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm;
       if (calc_cond)
-        anorm  = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1160,17 +1160,17 @@ FloatComplexMatrix::inverse (MatrixType 
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (!mattype.is_hermitian ())
-        ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = FloatComplexMatrix (rows (), columns (), FloatComplex (octave_Float_Inf, 0.));
     }
 
   return ret;
 }
 
@@ -1823,17 +1823,17 @@ FloatComplexMatrix::rcond (MatrixType &m
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-              if(anorm < 0.)
+              if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
@@ -2091,17 +2091,17 @@ FloatComplexMatrix::fsolve (MatrixType &
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -2175,17 +2175,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2401,17 +2401,17 @@ FloatComplexMatrix::solve (MatrixType &t
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
                       octave_idx_type& info, float& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   FloatComplexMatrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
-  return tmp.column(static_cast<octave_idx_type> (0));
+  return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -232,17 +232,17 @@ FloatComplexNDArray::fourier (int dim) c
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
@@ -279,17 +279,17 @@ FloatComplexNDArray::ifourier (int dim) 
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<float> (npts);
         }
     }
diff --git a/liboctave/fCmplxQR.cc b/liboctave/fCmplxQR.cc
--- a/liboctave/fCmplxQR.cc
+++ b/liboctave/fCmplxQR.cc
@@ -466,33 +466,33 @@ FloatComplexQR::update (const FloatCompl
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init(q*r + FloatComplexMatrix (u) * FloatComplexMatrix (v).hermitian (), get_type ());
+      init (q*r + FloatComplexMatrix (u) * FloatComplexMatrix (v).hermitian (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 FloatComplexQR::update (const FloatComplexMatrix& u, const FloatComplexMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
-      init(q*r + u * v.hermitian (), get_type ());
+      init (q*r + u * v.hermitian (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 static
 FloatComplexMatrix insert_col (const FloatComplexMatrix& a, octave_idx_type i,
                                const FloatComplexColumnVector& x)
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -221,18 +221,18 @@ FloatEIG::init (const FloatMatrix& a, bo
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = FloatComplex (wr.elem(j), wi.elem(j));
-              lambda.elem(j+1) = FloatComplex (wr.elem(j+1), wi.elem(j+1));
+              lambda.elem (j) = FloatComplex (wr.elem (j), wi.elem (j));
+              lambda.elem (j+1) = FloatComplex (wr.elem (j+1), wi.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   float real_part = vr.elem (i, j);
                   float imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = FloatComplex (real_part, imag_part);
                   v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
                 }
@@ -571,20 +571,20 @@ FloatEIG::init (const FloatMatrix& a, co
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = FloatComplex (ar.elem(j) / beta.elem (j),
-                                             ai.elem(j) / beta.elem (j));
-              lambda.elem(j+1) = FloatComplex (ar.elem(j+1) / beta.elem (j+1),
-                                               ai.elem(j+1) / beta.elem (j+1));
+              lambda.elem (j) = FloatComplex (ar.elem (j) / beta.elem (j),
+                                              ai.elem (j) / beta.elem (j));
+              lambda.elem (j+1) = FloatComplex (ar.elem (j+1) / beta.elem (j+1),
+                                                ai.elem (j+1) / beta.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   float real_part = vr.elem (i, j);
                   float imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = FloatComplex (real_part, imag_part);
                   v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
                 }
@@ -770,17 +770,17 @@ FloatEIG::init (const FloatComplexMatrix
         {
           (*current_liboctave_error_handler) ("cggev failed to converge");
           return info;
         }
 
       lambda.resize (n);
 
       for (octave_idx_type j = 0; j < n; j++)
-        lambda.elem (j) = alpha.elem (j) / beta.elem(j);
+        lambda.elem (j) = alpha.elem (j) / beta.elem (j);
 
       v = vtmp;
     }
   else
     (*current_liboctave_error_handler) ("cggev workspace query failed");
 
   return info;
 }
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -758,17 +758,17 @@ FloatMatrix::finverse (MatrixType &matty
       z.resize (dim_vector (lwork, 1));
       float *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond)
-        anorm = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -833,17 +833,17 @@ FloatMatrix::inverse (MatrixType &mattyp
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (!mattype.is_hermitian ())
-        ret = finverse(mattype, info, rcon, force, calc_cond);
+        ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = FloatMatrix (rows (), columns (), octave_Float_Inf);
     }
 
   return ret;
 }
 
@@ -1457,17 +1457,17 @@ FloatMatrix::rcond (MatrixType &mattype)
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
               anorm = atmp.abs ().sum ().
-                row(static_cast<octave_idx_type>(0)).max ();
+                row (static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1493,17 +1493,17 @@ FloatMatrix::rcond (MatrixType &mattype)
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-              if(anorm < 0.)
+              if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
                   row(static_cast<octave_idx_type>(0)).max ();
 
               Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
@@ -1757,17 +1757,17 @@ FloatMatrix::fsolve (MatrixType &mattype
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1833,18 +1833,18 @@ FloatMatrix::fsolve (MatrixType &mattype
         {
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
-          if(anorm < 0.)
-            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
+          if (anorm < 0.)
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
           Array<float> z (dim_vector (4 * nc, 1));
           float *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2057,17 +2057,17 @@ FloatMatrix::solve (MatrixType &typ, con
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
                float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatMatrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
-  return tmp.column(static_cast<octave_idx_type> (0));
+  return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
@@ -2089,17 +2089,17 @@ FloatMatrix::solve (MatrixType &typ, con
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
                octave_idx_type& info, float& rcon,
                solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve(typ, b, info, rcon, sing_handler, transt);
+  return tmp.solve (typ, b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -236,17 +236,17 @@ FloatNDArray::fourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
@@ -283,17 +283,17 @@ FloatNDArray::ifourier (int dim) const
 
   for (octave_idx_type k = 0; k < nloop; k++)
     {
       for (octave_idx_type j = 0; j < howmany; j++)
         {
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem((i + k*npts)*stride + j*dist);
+            tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<float> (npts);
         }
     }
diff --git a/liboctave/floatQR.cc b/liboctave/floatQR.cc
--- a/liboctave/floatQR.cc
+++ b/liboctave/floatQR.cc
@@ -459,33 +459,33 @@ FloatQR::update (const FloatColumnVector
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init(q*r + FloatMatrix (u) * FloatMatrix (v).transpose (), get_type ());
+      init (q*r + FloatMatrix (u) * FloatMatrix (v).transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 FloatQR::update (const FloatMatrix& u, const FloatMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
-      init(q*r + u * v.transpose (), get_type ());
+      init (q*r + u * v.transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 static
 FloatMatrix insert_col (const FloatMatrix& a, octave_idx_type i,
                         const FloatColumnVector& x)
diff --git a/liboctave/floatSVD.cc b/liboctave/floatSVD.cc
--- a/liboctave/floatSVD.cc
+++ b/liboctave/floatSVD.cc
@@ -130,17 +130,17 @@ FloatSVD::init (const FloatMatrix& a, SV
   type_computed = svd_type;
 
   if (! (jobu == 'N' || jobu == 'O'))
     left_sm.resize (m, ncol_u);
 
   float *u = left_sm.fortran_vec ();
 
   sigma.resize (nrow_s, ncol_s);
-  float *s_vec  = sigma.fortran_vec ();
+  float *s_vec = sigma.fortran_vec ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm.resize (nrow_vt, n);
 
   float *vt = right_sm.fortran_vec ();
 
   // Ask DGESVD what the dimension of WORK should be.
 
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -103,17 +103,17 @@ idx_vector::idx_colon_rep::print (std::o
   return os << ":";
 }
 
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_range_rep);
 
 idx_vector::idx_range_rep::idx_range_rep (octave_idx_type _start,
                                           octave_idx_type _limit,
                                           octave_idx_type _step)
-  : start(_start), len (_step ? std::max((_limit - _start) / _step, static_cast<octave_idx_type> (0)) : -1), step (_step)
+  : start(_start), len (_step ? std::max ((_limit - _start) / _step, static_cast<octave_idx_type> (0)) : -1), step (_step)
 {
   if (len < 0)
     {
       gripe_invalid_range ();
       err = true;
     }
   else if (start < 0 || (step < 0 && start + (len-1)*step < 0))
     {
@@ -320,17 +320,17 @@ idx_vector::idx_scalar_rep::as_array (vo
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_vector_rep);
 
 template <class T>
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<T>& nda)
   : data (0), len (nda.numel ()), ext (0), aowner (0), orig_dims (nda.dims ())
 {
   if (len != 0)
     {
-      octave_idx_type *d = new octave_idx_type[len];
+      octave_idx_type *d = new octave_idx_type [len];
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
       data = d;
 
       if (err)
       {
         delete [] data;
         gripe_invalid_index ();
@@ -484,17 +484,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
 
   // This is wrapped in auto_ptr so that we don't leak on out-of-memory.
   std::auto_ptr<idx_vector_rep> new_rep (
     new idx_vector_rep (0, len, ext, orig_dims, DIRECT));
 
   if (ext > len*xlog2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       std::copy (data, data + len, new_data);
       octave_sort<octave_idx_type> lsort;
       lsort.set_compare (ASCENDING);
       lsort.sort (new_data, len);
 
       if (uniq)
@@ -519,31 +519,31 @@ idx_vector::idx_vector_rep::sort_uniq_cl
         new_len += has[i];
 
       new_rep->len = new_len;
       if (new_rep->orig_dims.length () == 2 && new_rep->orig_dims(0) == 1)
         new_rep->orig_dims = dim_vector (1, new_len);
       else
         new_rep->orig_dims = dim_vector (new_len, 1);
 
-      octave_idx_type *new_data = new octave_idx_type[new_len];
+      octave_idx_type *new_data = new octave_idx_type [new_len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         if (has[i])
           new_data[j++] = i;
     }
   else
     {
       // Use two-pass bucket sort.
       OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, cnt, ext, 0);
       for (octave_idx_type i = 0; i < len; i++)
         cnt[data[i]]++;
 
-      octave_idx_type *new_data = new octave_idx_type[len];
+      octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
         {
           for (octave_idx_type k = 0; k < cnt[i]; k++)
             new_data[j++] = i;
         }
     }
@@ -1140,17 +1140,17 @@ idx_vector::complement (octave_idx_type 
 
 bool
 idx_vector::is_permutation (octave_idx_type n) const
 {
   bool retval = false;
 
   if (is_colon_equiv (n))
     retval = true;
-  else if (length (n) == n && extent(n) == n)
+  else if (length(n) == n && extent(n) == n)
     {
       OCTAVE_LOCAL_BUFFER_INIT (bool, left, n, true);
 
       retval = true;
 
       for (octave_idx_type i = 0, len = length (); i < len; i++)
         {
           octave_idx_type k = xelem (i);
@@ -1185,17 +1185,17 @@ idx_vector::inverse_permutation (octave_
         break;
       }
     case class_vector:
       {
         idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
         const octave_idx_type *ri = r->get_data ();
         Array<octave_idx_type> idx (orig_dimensions ());
         for (octave_idx_type i = 0; i < n; i++)
-          idx.xelem(ri[i]) = i;
+          idx.xelem (ri[i]) = i;
         retval = new idx_vector_rep (idx, r->extent (0), DIRECT);
         break;
       }
     default:
       retval = *this;
       break;
     }
 
@@ -1325,12 +1325,12 @@ INSTANTIATE_SCALAR_VECTOR_REP_CONST (oct
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_int64)
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_uint8)
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_uint16)
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_uint32)
 INSTANTIATE_SCALAR_VECTOR_REP_CONST (octave_uint64)
 
 /*
 
-%!error id=Octave:index-out-of-bounds 1(find([1,1] != 0))
-%!assert ((1:3)(find([1,0,1] != 0)), [1,3])
+%!error id=Octave:index-out-of-bounds 1(find ([1,1] != 0))
+%!assert ((1:3)(find ([1,0,1] != 0)), [1,3])
 
 */
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -30,30 +30,30 @@ 02110-1301, USA.  */
 #include <string>
 
 /* System defines are for non-Unix systems only.  (Testing for all Unix
    variations should be done in configure.)  Presently the defines used
    are: DOS OS2 WIN32.  I do not use any of these systems
    myself; if you do, I'd be grateful for any changes. --kb@mail.tug.org */
 
 /* If we have either DOS or OS2, we are DOSISH.  */
-#if defined (DOS) || defined (OS2) || defined (WIN32) || defined(__MSDOS__)
+#if defined (DOS) || defined (OS2) || defined (WIN32) || defined (__MSDOS__)
 #define DOSISH
 #endif
 
 #if defined (DOSISH)
 #define MONOCASE_FILENAMES      /* case-insensitive filename comparisons */
 #endif
 
 extern "C" {
-#if defined(__MINGW32__)
+#if defined (__MINGW32__)
 #include <windows.h>
 #include <fcntl.h>
 #include <dirent.h>
-#elif defined(WIN32)
+#elif defined (WIN32)
 #ifndef _MSC_VER
 #define __STDC__ 1
 #include "win32lib.h"
 #endif
 #endif /* not WIN32 */
 
 #ifdef __DJGPP__
 #include <fcntl.h>      /* for long filenames' stuff */
@@ -71,17 +71,17 @@ extern "C" {
    compiling standalone, we get our c-auto.h.  Otherwise, the package
    containing us must provide this (unless it can somehow generate ours
    from c-auto.in).  We use <...> instead of "..." so that the current
    cpp directory (i.e., kpathsea/) won't be searched. */
 
 /* If you want to find subdirectories in a directory with non-Unix
    semantics (specifically, if a directory with no subdirectories does
    not have exactly two links), define this.  */
-#if defined(__DJGPP__) || ! defined (DOSISH)
+#if defined (__DJGPP__) || ! defined (DOSISH)
 /* Surprise!  DJGPP returns st_nlink exactly like on Unix.  */
 #define ST_NLINK_TRICK
 #endif /* either not DOSISH or __DJGPP__ */
 
 #ifdef OS2
 #define access ln_access
 #define fopen ln_fopen
 #define rename ln_rename
@@ -94,17 +94,17 @@ extern "C" {
 /* What separates filename components?  */
 #ifndef DIR_SEP
 #ifdef DOSISH
 /* Either \'s or 's work.  Wayne Sullivan's web2pc prefers /, so we'll
    go with that.  */
 #define DIR_SEP '/'
 #define DIR_SEP_STRING "/"
 #define IS_DEVICE_SEP(ch) ((ch) == ':')
-#define NAME_BEGINS_WITH_DEVICE(name) ((name.length()>0) && IS_DEVICE_SEP((name)[1]))
+#define NAME_BEGINS_WITH_DEVICE(name) ((name.length ()>0) && IS_DEVICE_SEP((name)[1]))
 /* On DOS, it's good to allow both \ and / between directories.  */
 #define IS_DIR_SEP(ch) ((ch) == '/' || (ch) == '\\')
 #else
 #define DIR_SEP '/'
 #define DIR_SEP_STRING "/"
 #endif /* not DOSISH */
 #endif /* not DIR_SEP */
 
diff --git a/liboctave/lo-macros.h b/liboctave/lo-macros.h
--- a/liboctave/lo-macros.h
+++ b/liboctave/lo-macros.h
@@ -87,9 +87,13 @@ OCT_ITERATE_PARAM_MACRO8(MACRO, PARAM) M
 
 #define OCT_MAKE_DECL_LIST_HELPER(NUM, PREFIX) \
   OCT_IF_PARAM(NUM,OCT_MAKE_LIST_HELPER1,) OCT_CONCAT2(PREFIX, NUM)
 
 // expands to TYPE PREFIX0, TYPE PREFIX1, ..., TYPE PREFIX ## (NUM-1)
 #define OCT_MAKE_DECL_LIST(TYPE, PREFIX, NUM) \
   OCT_ITERATE_PARAM_MACRO(OCT_MAKE_DECL_LIST_HELPER, TYPE PREFIX, NUM)
 
+// expands to PREFIX0, PREFIX1, ..., PREFIX ## (NUM-1)
+#define OCT_MAKE_ARG_LIST(PREFIX, NUM)          \
+  OCT_ITERATE_PARAM_MACRO(OCT_MAKE_DECL_LIST_HELPER, PREFIX, NUM)
+
 #endif
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -449,17 +449,17 @@ expm1 (double x)
   else
     retval = exp (x) - 1;
 
   return retval;
 }
 #endif
 
 Complex
-expm1(const Complex& x)
+expm1 (const Complex& x)
 {
   Complex retval;
 
   if (std:: abs (x) < 1)
     {
       double im = x.imag ();
       double u = expm1 (x.real ());
       double v = sin (im/2);
@@ -504,17 +504,17 @@ expm1f (float x)
   else
     retval = exp (x) - 1;
 
   return retval;
 }
 #endif
 
 FloatComplex
-expm1(const FloatComplex& x)
+expm1 (const FloatComplex& x)
 {
   FloatComplex retval;
 
   if (std:: abs (x) < 1)
     {
       float im = x.imag ();
       float u = expm1 (x.real ());
       float v = sin (im/2);
@@ -560,17 +560,17 @@ log1p (const Complex& x)
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       double u = 2*r + r*r + i*i;
       retval = Complex (log1p (u / (1+sqrt (u+1))),
                         atan2 (1 + r, i));
     }
   else
-    retval = std::log (Complex(1) + x);
+    retval = std::log (Complex (1) + x);
 
   return retval;
 }
 
 #if !defined (HAVE_CBRT)
 double cbrt (double x)
 {
   static const double one_third = 0.3333333333333333333;
@@ -619,17 +619,17 @@ log1p (const FloatComplex& x)
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       float u = 2*r + r*r + i*i;
       retval = FloatComplex (log1p (u / (1+sqrt (u+1))),
                         atan2 (1 + r, i));
     }
   else
-    retval = std::log (FloatComplex(1) + x);
+    retval = std::log (FloatComplex (1) + x);
 
   return retval;
 }
 
 #if !defined (HAVE_CBRTF)
 float cbrtf (float x)
 {
   static const float one_third = 0.3333333333333333333f;
@@ -868,17 +868,17 @@ zbesi (const Complex& z, double alpha, i
       if (ierr == 0 || ierr == 3)
         {
           Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
             * zbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
-              tmp2 *= exp(-z - std::abs(z.real ()));
+              tmp2 *= exp (-z - std::abs (z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = Complex (octave_NaN, octave_NaN);
@@ -1478,17 +1478,17 @@ cbesi (const FloatComplex& z, float alph
       if (ierr == 0 || ierr == 3)
         {
           FloatComplex tmp2 = static_cast<float> (2.0 / M_PI) * sinf (static_cast<float> (M_PI) * alpha)
             * cbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
-              tmp2 *= exp(-z - std::abs(z.real ()));
+              tmp2 *= exp (-z - std::abs (z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
@@ -1888,17 +1888,17 @@ airy (const Complex& z, bool deriv, bool
   double zi = z.imag ();
 
   octave_idx_type id = deriv ? 1 : 0;
 
   F77_FUNC (zairy, ZAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
 
   if (! scaled)
     {
-      Complex expz = exp (- 2.0 / 3.0 * z * sqrt(z));
+      Complex expz = exp (- 2.0 / 3.0 * z * sqrt (z));
 
       double rexpz = real (expz);
       double iexpz = imag (expz);
 
       double tmp = ar*rexpz - ai*iexpz;
 
       ai = ar*iexpz + ai*rexpz;
       ar = tmp;
@@ -2018,17 +2018,17 @@ airy (const FloatComplex& z, bool deriv,
   float zi = z.imag ();
 
   octave_idx_type id = deriv ? 1 : 0;
 
   F77_FUNC (cairy, CAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
 
   if (! scaled)
     {
-      FloatComplex expz = exp (- static_cast<float> (2.0 / 3.0) * z * sqrt(z));
+      FloatComplex expz = exp (- static_cast<float> (2.0 / 3.0) * z * sqrt (z));
 
       float rexpz = real (expz);
       float iexpz = imag (expz);
 
       float tmp = ar*rexpz - ai*iexpz;
 
       ai = ar*iexpz + ai*rexpz;
       ar = tmp;
@@ -3125,17 +3125,17 @@ erfcx_impl (T x)
         }
       else
         result = sqrpi / y;
 
       // Fix up negative argument.
       if (x < 0)
         {
           double y2 = ceil (x / 16.0) * 16.0, del = (x-y2)*(x+y2);
-          result = 2*(std::exp(y2*y2) * std::exp(del)) - result;
+          result = 2*(std::exp (y2*y2) * std::exp (del)) - result;
         }
     }
 
   return result;
 }
 
 double erfcx (double x)
 {
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -478,22 +478,22 @@ inline bool xis_false (const Complex& x)
 inline bool xis_true (const FloatComplex& x) { return ! xisnan (x) && x != 0.0f; }
 inline bool xis_false (const FloatComplex& x) { return x == 0.0f; }
 
 #define OP_RED_SUM(ac, el) ac += el
 #define OP_RED_PROD(ac, el) ac *= el
 #define OP_RED_SUMSQ(ac, el) ac += el*el
 #define OP_RED_SUMSQC(ac, el) ac += cabsq (el)
 
-inline void op_dble_sum(double& ac, float el)
+inline void op_dble_sum (double& ac, float el)
 { ac += el; }
-inline void op_dble_sum(Complex& ac, const FloatComplex& el)
+inline void op_dble_sum (Complex& ac, const FloatComplex& el)
 { ac += el; } // FIXME: guaranteed?
 template <class T>
-inline void op_dble_sum(double& ac, const octave_int<T>& el)
+inline void op_dble_sum (double& ac, const octave_int<T>& el)
 { ac += el.double_value (); }
 
 // The following two implement a simple short-circuiting.
 #define OP_RED_ANYC(ac, el) if (xis_true (el)) { ac = true; break; } else continue
 #define OP_RED_ALLC(ac, el) if (xis_false (el)) { ac = false; break; } else continue
 
 #define OP_RED_FCN(F, TSRC, TRES, OP, ZERO) \
 template <class T> \
@@ -1172,17 +1172,17 @@ get_extent_triplet (const dim_vector& di
 template <class R, class T>
 inline Array<R>
 do_mx_red_op (const Array<T>& src, int dim,
               void (*mx_red_op) (const T *, R *, octave_idx_type,
                                  octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
-  // M*b inconsistency: sum([]) = 0 etc.
+  // M*b inconsistency: sum ([]) = 0 etc.
   if (dims.length () == 2 && dims(0) == 0 && dims(1) == 0)
     dims (1) = 1;
 
   get_extent_triplet (dims, dim, l, n, u);
 
   // Reduction operation reduces the array size.
   if (dim < dims.length ()) dims(dim) = 1;
   dims.chop_trailing_singletons ();
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -408,17 +408,17 @@ OP (const M& m, const DM& dm) \
  \
       if (m_nr > 0 && m_nc > 0) \
         { \
           r = R (m); \
  \
           octave_idx_type len = dm.length (); \
  \
           for (octave_idx_type i = 0; i < len; i++) \
-            r.elem(i, i) OPEQ dm.elem(i, i); \
+            r.elem (i, i) OPEQ dm.elem (i, i); \
         } \
     } \
  \
   return r; \
 }
 
 #define MDM_MULTIPLY_OP(R, M, DM, R_ZERO) \
 R \
@@ -478,17 +478,17 @@ OP (const DM& dm, const M& m) \
     { \
       if (m_nr > 0 && m_nc > 0) \
         { \
           r = R (PREOP m); \
  \
           octave_idx_type len = dm.length (); \
  \
           for (octave_idx_type i = 0; i < len; i++) \
-            r.elem(i, i) OPEQ dm.elem(i, i); \
+            r.elem (i, i) OPEQ dm.elem (i, i); \
         } \
       else \
         r.resize (m_nr, m_nc); \
     } \
  \
   return r; \
 }
 
diff --git a/liboctave/oct-binmap.h b/liboctave/oct-binmap.h
--- a/liboctave/oct-binmap.h
+++ b/liboctave/oct-binmap.h
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 
 #include "Array.h"
 #include "Sparse.h"
 #include "Array-util.h"
 
 #include "bsxfun.h"
 
 // This source file implements a general binary maping function for
-// arrays. The syntax is binmap<type> (a, b, f, [name]). type denotes
+// arrays. The syntax is binmap<type> (a, b, f,[name]). type denotes
 // the expected return type of the operation. a, b, should be one of
 // the 6 combinations:
 //
 // Array-Array
 // Array-scalar
 // scalar-Array
 // Sparse-Sparse
 // Sparse-scalar
@@ -218,17 +218,17 @@ template <class U, class T, class R, cla
 Sparse<U>
 binmap (const T& x, const Sparse<R>& ys, F fcn)
 {
   octave_idx_type nz = ys.nnz ();
   Sparse<U> retval (ys.rows (), ys.cols (), nz);
   for (octave_idx_type i = 0; i < nz; i++)
     {
       octave_quit ();
-      retval.xdata(i) = fcn (x, ys.data(i));
+      retval.xdata (i) = fcn (x, ys.data (i));
     }
 
   octave_quit ();
   retval.maybe_compress ();
   return retval;
 }
 
 // Sparse-scalar
@@ -236,17 +236,17 @@ template <class U, class T, class R, cla
 Sparse<U>
 binmap (const Sparse<T>& xs, const R& y, F fcn)
 {
   octave_idx_type nz = xs.nnz ();
   Sparse<U> retval (xs.rows (), xs.cols (), nz);
   for (octave_idx_type i = 0; i < nz; i++)
     {
       octave_quit ();
-      retval.xdata(i) = fcn (xs.data(i), y);
+      retval.xdata (i) = fcn (xs.data (i), y);
     }
 
   octave_quit ();
   retval.maybe_compress ();
   return retval;
 }
 
 // Sparse-Sparse (treats singletons as scalars)
@@ -271,59 +271,59 @@ binmap (const Sparse<T>& xs, const Spars
       octave_idx_type nr = xs.rows (), nc = xs.cols ();
       Sparse<T> retval (nr, nc);
 
       octave_idx_type nz = 0;
       // Count nonzeros.
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
-          octave_idx_type ix = xs.cidx(j), iy = ys.cidx(j);
-          octave_idx_type ux = xs.cidx(j+1), uy = ys.cidx(j+1);
+          octave_idx_type ix = xs.cidx (j), iy = ys.cidx (j);
+          octave_idx_type ux = xs.cidx (j+1), uy = ys.cidx (j+1);
           while (ix != ux || iy != uy)
             {
-              octave_idx_type rx = xs.ridx(ix), ry = ys.ridx(ix);
+              octave_idx_type rx = xs.ridx (ix), ry = ys.ridx (ix);
               ix += rx <= ry;
               iy += ry <= rx;
               nz++;
             }
 
-          retval.xcidx(j+1) = nz;
+          retval.xcidx (j+1) = nz;
         }
 
       // Allocate space.
-      retval.change_capacity (retval.xcidx(nc));
+      retval.change_capacity (retval.xcidx (nc));
 
       // Fill.
       nz = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
-          octave_idx_type ix = xs.cidx(j), iy = ys.cidx(j);
-          octave_idx_type ux = xs.cidx(j+1), uy = ys.cidx(j+1);
+          octave_idx_type ix = xs.cidx (j), iy = ys.cidx (j);
+          octave_idx_type ux = xs.cidx (j+1), uy = ys.cidx (j+1);
           while (ix != ux || iy != uy)
             {
-              octave_idx_type rx = xs.ridx(ix), ry = ys.ridx(ix);
+              octave_idx_type rx = xs.ridx (ix), ry = ys.ridx (ix);
               if (rx == ry)
                 {
-                  retval.xridx(nz) = rx;
-                  retval.xdata(nz) = fcn (xs.data(ix), ys.data(iy));
+                  retval.xridx (nz) = rx;
+                  retval.xdata (nz) = fcn (xs.data (ix), ys.data (iy));
                   ix++;
                   iy++;
                 }
               else if (rx < ry)
                 {
-                  retval.xridx(nz) = rx;
-                  retval.xdata(nz) = fcn (xs.data(ix), yzero);
+                  retval.xridx (nz) = rx;
+                  retval.xdata (nz) = fcn (xs.data (ix), yzero);
                   ix++;
                 }
               else if (ry < rx)
                 {
-                  retval.xridx(nz) = ry;
-                  retval.xdata(nz) = fcn (xzero, ys.data(iy));
+                  retval.xridx (nz) = ry;
+                  retval.xdata (nz) = fcn (xzero, ys.data (iy));
                   iy++;
                 }
 
               nz++;
             }
         }
 
       retval.maybe_compress ();
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -718,17 +718,17 @@ convert_packcomplex_1d (T *out, size_t n
                         octave_idx_type stride, octave_idx_type dist)
 {
   octave_quit ();
 
   // Fill in the missing data.
 
   for (size_t i = 0; i < nr; i++)
     for (size_t j = nc/2+1; j < nc; j++)
-      out[j*stride + i*dist] = conj(out[(nc - j)*stride + i*dist]);
+      out[j*stride + i*dist] = conj (out[(nc - j)*stride + i*dist]);
 
   octave_quit ();
 }
 
 template <class T>
 static inline void
 convert_packcomplex_Nd (T *out, const dim_vector &dv)
 {
@@ -753,20 +753,20 @@ convert_packcomplex_Nd (T *out, const di
   octave_quit ();
 
   // Fill in the missing data for the rank = 2 case directly for speed.
 
   for (size_t i = 0; i < np; i++)
     {
       for (size_t j = 1; j < nr; j++)
         for (size_t k = nc/2+1; k < nc; k++)
-          out[k + (j + i*nr)*nc] = conj(out[nc - k + ((i+1)*nr - j)*nc]);
+          out[k + (j + i*nr)*nc] = conj (out[nc - k + ((i+1)*nr - j)*nc]);
 
       for (size_t j = nc/2+1; j < nc; j++)
-        out[j + i*nr*nc] = conj(out[(i*nr+1)*nc - j]);
+        out[j + i*nr*nc] = conj (out[(i*nr+1)*nc - j]);
     }
 
   octave_quit ();
 
   // Now do the permutations needed for rank > 2 cases.
 
   size_t jstart = dv(0) * dv(1);
   size_t kstep = dv(0);
@@ -777,17 +777,17 @@ convert_packcomplex_Nd (T *out, const di
       size_t jmax = jstart * dv(inner);
       for (size_t i = 0; i < nel; i+=jmax)
         for (size_t j = jstart, jj = jmax-jstart; j < jj;
              j+=jstart, jj-=jstart)
           for (size_t k = 0; k < jstart; k+= kstep)
             for (size_t l = nc/2+1; l < nc; l++)
               {
                 T tmp = out[i+ j + k + l];
-                out[i + j + k + l] =  out[i + jj + k + l];
+                out[i + j + k + l] = out[i + jj + k + l];
                 out[i + jj + k + l] = tmp;
               }
       jstart = jmax;
     }
 
   octave_quit ();
 }
 
diff --git a/liboctave/oct-group.h b/liboctave/oct-group.h
--- a/liboctave/oct-group.h
+++ b/liboctave/oct-group.h
@@ -43,17 +43,17 @@ public:
     : gr_name (gr.gr_name), gr_passwd (gr.gr_passwd),
       gr_gid (gr.gr_gid), gr_mem (gr.gr_mem), valid (gr.valid)
   { }
 
   octave_group& operator = (const octave_group& gr)
   {
     if (this != &gr)
       {
-        gr_name  = gr.gr_name;
+        gr_name = gr.gr_name;
         gr_passwd = gr.gr_passwd;
         gr_gid = gr.gr_gid;
         gr_mem = gr.gr_mem;
         valid = gr.valid;
       }
 
     return *this;
   }
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -267,33 +267,33 @@ overflow:
 
 #define DOUBLE_INT_BINOP_DECL(OP,SUFFIX) \
   template <> \
   OCTAVE_API octave_ ## SUFFIX \
   operator OP (const double& x, const octave_ ## SUFFIX & y)
 
 INT_DOUBLE_BINOP_DECL (+, uint64)
 {
-  return (y < 0) ? x - octave_uint64(-y) : x + octave_uint64(y);
+  return (y < 0) ? x - octave_uint64 (-y) : x + octave_uint64 (y);
 }
 
 DOUBLE_INT_BINOP_DECL (+, uint64)
 { return y + x; }
 
 INT_DOUBLE_BINOP_DECL (+, int64)
 {
   if (fabs (y) < static_cast<double> (octave_int64::max ()))
     return x + octave_int64 (y);
   else
     {
       // If the number is within the int64 range (the most common case,
       // probably), the above will work as expected. If not, it's more
       // complicated - as long as y is within _twice_ the signed range, the
       // result may still be an integer. An instance of such an operation is
-      // 3*2**62 + (1+intmin('int64')) that should yield int64(2**62) + 1.  So
+      // 3*2**62 + (1+intmin ('int64')) that should yield int64 (2**62) + 1.  So
       // what we do is to try to convert y/2 and add it twice. Note that if y/2
       // overflows, the result must overflow as well, and that y/2 cannot be a
       // fractional number.
       octave_int64 y2 (y / 2);
       return (x + y2) + y2;
     }
 }
 
@@ -305,22 +305,22 @@ DOUBLE_INT_BINOP_DECL (+, int64)
 INT_DOUBLE_BINOP_DECL (-, uint64)
 {
   return x + (-y);
 }
 
 DOUBLE_INT_BINOP_DECL (-, uint64)
 {
   if (x <= static_cast<double> (octave_uint64::max ()))
-    return octave_uint64(x) - y;
+    return octave_uint64 (x) - y;
   else
     {
       // Again a trick to get the corner cases right. Things like
-      // 3**2**63 - intmax('uint64') should produce the correct result, i.e.
-      // int64(2**63) + 1.
+      // 3**2**63 - intmax ('uint64') should produce the correct result, i.e.
+      // int64 (2**63) + 1.
       const double p2_64 = std::pow (2.0, 64);
       if (y.bool_value ())
         {
           const uint64_t p2_64my = (~y.value ()) + 1; // Equals 2**64 - y
           return octave_uint64 (x - p2_64) + octave_uint64 (p2_64my);
         }
       else
         return octave_uint64 (p2_64);
@@ -335,17 +335,17 @@ INT_DOUBLE_BINOP_DECL (-, int64)
 DOUBLE_INT_BINOP_DECL (-, int64)
 {
   static const bool twosc = (std::numeric_limits<int64_t>::min ()
                              < -std::numeric_limits<int64_t>::max ());
   // In case of symmetric integers (not two's complement), this will probably
   // be eliminated at compile time.
   if (twosc && y.value () == std::numeric_limits<int64_t>::min ())
     {
-      return octave_int64 (x + std::pow(2.0, 63));
+      return octave_int64 (x + std::pow (2.0, 63));
     }
   else
     return x + (-y);
 }
 
 // NOTE:
 // Emulated mixed multiplications are tricky due to possible precision loss.
 // Here, after sorting out common cases for speed, we follow the strategy
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -820,17 +820,17 @@ public:
 
 #undef OCTAVE_INT_BIN_OP
 
   static octave_int<T> min (void) { return std::numeric_limits<T>::min (); }
   static octave_int<T> max (void) { return std::numeric_limits<T>::max (); }
 
   static int nbits (void) { return std::numeric_limits<T>::digits; }
 
-  static int byte_size (void) { return sizeof(T); }
+  static int byte_size (void) { return sizeof (T); }
 
   static const char *type_name ();
 
   // The following are provided for convenience.
   static const octave_int zero, one;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
diff --git a/liboctave/oct-locbuf.h b/liboctave/oct-locbuf.h
--- a/liboctave/oct-locbuf.h
+++ b/liboctave/oct-locbuf.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 template <class T>
 class octave_local_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : data (0)
     {
       if (size)
-        data = new T[size];
+        data = new T [size];
     }
   ~octave_local_buffer (void) { delete [] data; }
   operator T *() const { return data; }
 
 private:
   T *data;
 
   // No copying!
@@ -199,15 +199,15 @@ public:
   T *buf = _buffer_ ## buf
 
 #endif
 
 // Note: we use weird variables in the for loop to avoid warnings
 // about shadowed parameters.
 
 #define OCTAVE_LOCAL_BUFFER_INIT(T, buf, size, value) \
-  OCTAVE_LOCAL_BUFFER(T, buf, size); \
+  OCTAVE_LOCAL_BUFFER (T, buf, size); \
   for (size_t _buf_iter = 0, _buf_size = size; \
         _buf_iter < _buf_size; _buf_iter++) \
     buf[_buf_iter] = value
 
 #endif
 
diff --git a/liboctave/oct-md5.cc b/liboctave/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/oct-md5.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-error.h"
 #include "oct-md5.h"
 #include "md5.h"
 
 static std::string
 oct_md5_result_to_str (const unsigned char *buf)
 {
-  char tmp [33];
+  char tmp[33];
 
   sprintf (tmp,
            "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
            buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],
            buf[8],  buf[9], buf[10], buf[11], buf[12], buf[13], buf[14],
            buf[15]);
 
   return std::string (tmp, 32);
diff --git a/liboctave/oct-mem.h b/liboctave/oct-mem.h
--- a/liboctave/oct-mem.h
+++ b/liboctave/oct-mem.h
@@ -123,26 +123,26 @@ DEFINE_POD_FILL (octave_int<T>)
 // Uninitialized allocation. Will not initialize memory for complex and octave_int.
 // Memory allocated by octave_new should be freed by octave_delete.
 template <class T>
 inline T *no_ctor_new (size_t n)
 {
   // Some systems let us allocate > 2GB memory even though size_t, which is either
   // buggy or completely cuckoo, so let's check here to stay safe.
   safe_size_comp (n, sizeof (T));
-  return new T[n];
+  return new T [n];
 }
 template <class T>
 inline void no_ctor_delete (T *ptr)
 { delete [] ptr; }
 
 #define DEFINE_POD_NEW_DELETE(T) \
 template <> \
 inline T *no_ctor_new<T > (size_t n) \
-{ return reinterpret_cast<T *> (new char[safe_size_comp (n, sizeof (T))]); } \
+{ return reinterpret_cast<T *> (new char [safe_size_comp (n, sizeof (T))]); } \
 template <> \
 inline void no_ctor_delete<T > (T *ptr) \
 { delete [] reinterpret_cast<char *> (ptr); }
 
 DEFINE_POD_NEW_DELETE (Complex)
 DEFINE_POD_NEW_DELETE (FloatComplex)
 
 DEFINE_POD_NEW_DELETE (octave_int8)
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -355,28 +355,28 @@ octave_rand::do_scalar (double a)
           F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, retval);
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, retval);
           break;
 
         case poisson_dist:
-          if (a < 0.0 || xisnan(a) || xisinf(a))
+          if (a < 0.0 || xisnan (a) || xisinf (a))
             retval = octave_NaN;
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, retval);
               F77_FUNC (dignpoi, DIGNPOI) (a, retval);
             }
           break;
 
         case gamma_dist:
-          if (a <= 0.0 || xisnan(a) || xisinf(a))
+          if (a <= 0.0 || xisnan (a) || xisinf (a))
             retval = octave_NaN;
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
@@ -438,28 +438,28 @@ octave_rand::do_float_scalar (float a)
           F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, dretval);
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, dretval);
           break;
 
         case poisson_dist:
-          if (da < 0.0 || xisnan(da) || xisinf(da))
+          if (da < 0.0 || xisnan (da) || xisinf (da))
             dretval = octave_NaN;
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, dretval);
               F77_FUNC (dignpoi, DIGNPOI) (da, dretval);
             }
           break;
 
         case gamma_dist:
-          if (da <= 0.0 || xisnan(da) || xisinf(da))
+          if (da <= 0.0 || xisnan (da) || xisinf (da))
             retval = octave_NaN;
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, da, dretval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
@@ -625,17 +625,17 @@ octave_rand::get_internal_state (void)
 {
   ColumnVector s (MT_N + 1);
 
   OCTAVE_LOCAL_BUFFER (uint32_t, tmp, MT_N + 1);
 
   oct_get_state (tmp);
 
   for (octave_idx_type i = 0; i <= MT_N; i++)
-    s.elem (i) = static_cast<double> (tmp [i]);
+    s.elem (i) = static_cast<double> (tmp[i]);
 
   return s;
 }
 
 void
 octave_rand::save_state (void)
 {
   rand_states[current_distribution] = get_internal_state ();;
@@ -667,17 +667,17 @@ void
 octave_rand::set_internal_state (const ColumnVector& s)
 {
   octave_idx_type len = s.length ();
   octave_idx_type n = len < MT_N + 1 ? len : MT_N + 1;
 
   OCTAVE_LOCAL_BUFFER (uint32_t, tmp, MT_N + 1);
 
   for (octave_idx_type i = 0; i < n; i++)
-    tmp[i] = static_cast<uint32_t> (s.elem(i));
+    tmp[i] = static_cast<uint32_t> (s.elem (i));
 
   if (len == MT_N + 1 && tmp[MT_N] <= MT_N && tmp[MT_N] > 0)
     oct_set_state (tmp);
   else
     oct_init_by_array (tmp, len);
 }
 
 void
@@ -743,17 +743,17 @@ octave_rand::fill (octave_idx_type len, 
         }
       else
         oct_fill_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
-          if (a < 0.0 || xisnan(a) || xisinf(a))
+          if (a < 0.0 || xisnan (a) || xisinf (a))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
@@ -764,17 +764,17 @@ octave_rand::fill (octave_idx_type len, 
         }
       else
         oct_fill_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
-          if (a <= 0.0 || xisnan(a) || xisinf(a))
+          if (a <= 0.0 || xisnan (a) || xisinf (a))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, a, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
@@ -833,17 +833,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_float_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
           double da = a;
-          if (da < 0.0 || xisnan(da) || xisinf(da))
+          if (da < 0.0 || xisnan (da) || xisinf (da))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, tmp);
@@ -855,17 +855,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_float_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
           double da = a;
-          if (da <= 0.0 || xisnan(da) || xisinf(da))
+          if (da <= 0.0 || xisnan (da) || xisinf (da))
 #define RAND_FUNC(x) x = octave_NaN;
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, da, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
diff --git a/liboctave/oct-refcount.h b/liboctave/oct-refcount.h
--- a/liboctave/oct-refcount.h
+++ b/liboctave/oct-refcount.h
@@ -77,13 +77,18 @@ public:
       return OCTREFCOUNT_ATOMIC_DECREMENT_POST (&count);
     }
 
   operator count_type (void) const
     {
       return static_cast<count_type const volatile&> (count);
     }
 
+  count_type *get (void)
+    {
+      return &count;
+    }
+
 private:
   count_type count;
 };
 
 #endif
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -537,17 +537,17 @@ octave_sort<T>::MergeState::getmem (octa
     return;
 
   need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
    * we don't care what's in the block.
    */
   delete [] a;
   delete [] ia; // Must do this or fool possible next getmemi.
-  a = new T[need];
+  a = new T [need];
   alloced = need;
 
 }
 
 template <class T>
 void
 octave_sort<T>::MergeState::getmemi (octave_idx_type need)
 {
@@ -556,18 +556,18 @@ octave_sort<T>::MergeState::getmemi (oct
 
   need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
    * we don't care what's in the block.
    */
   delete [] a;
   delete [] ia;
 
-  a = new T[need];
-  ia = new octave_idx_type[need];
+  a = new T [need];
+  ia = new octave_idx_type [need];
   alloced = need;
 }
 
 /* Merge the na elements starting at pa with the nb elements starting at pb
  * in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
  * Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
  * merge, and should have na <= nb.  See listsort.txt for more info.
  * Return 0 if successful, -1 if error.
@@ -1179,17 +1179,17 @@ octave_sort<T>::merge_at (octave_idx_typ
   /* Where does a end in b?  Elements in b after that can be
    * ignored (already in place).
    */
   nb = gallop_left (pa[na-1], pb, nb, nb-1, comp);
   if (nb <= 0)
     return nb;
 
   /* Merge what remains of the runs, using a temp array with
-   * min(na, nb) elements.
+   * min (na, nb) elements.
    */
   if (na <= nb)
     return merge_lo (pa, na, pb, nb, comp);
   else
     return merge_hi (pa, na, pb, nb, comp);
 }
 
 template <class T>
@@ -1233,17 +1233,17 @@ octave_sort<T>::merge_at (octave_idx_typ
   /* Where does a end in b?  Elements in b after that can be
    * ignored (already in place).
    */
   nb = gallop_left (pa[na-1], pb, nb, nb-1, comp);
   if (nb <= 0)
     return nb;
 
   /* Merge what remains of the runs, using a temp array with
-   * min(na, nb) elements.
+   * min (na, nb) elements.
    */
   if (na <= nb)
     return merge_lo (pa, ipa, na, pb, ipb, nb, comp);
   else
     return merge_hi (pa, ipa, na, pb, ipb, nb, comp);
 }
 
 /* Examine the stack of runs waiting to be merged, merging adjacent runs
@@ -1408,17 +1408,17 @@ octave_sort<T>::sort (T *data, octave_id
           octave_idx_type n;
 
           /* Identify next run. */
           n = count_run (data + lo, nremaining, descending, comp);
           if (n < 0)
             goto fail;
           if (descending)
             std::reverse (data + lo, data + lo + n);
-          /* If short, extend to min(minrun, nremaining). */
+          /* If short, extend to min (minrun, nremaining). */
           if (n < minrun)
             {
               const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
               binarysort (data + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
@@ -1470,17 +1470,17 @@ octave_sort<T>::sort (T *data, octave_id
           n = count_run (data + lo, nremaining, descending, comp);
           if (n < 0)
             goto fail;
           if (descending)
             {
               std::reverse (data + lo, data + lo + n);
               std::reverse (idx + lo, idx + lo + n);
             }
-          /* If short, extend to min(minrun, nremaining). */
+          /* If short, extend to min (minrun, nremaining). */
           if (n < minrun)
             {
               const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
               binarysort (data + lo, idx + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
@@ -1605,19 +1605,19 @@ octave_sort<T>::sort_rows (const T *data
   // This is a breadth-first traversal.
   typedef sortrows_run_t run_t;
   std::stack<run_t> runs;
 
   runs.push (run_t (0, 0, rows));
 
   while (! runs.empty ())
     {
-      octave_idx_type col  = runs.top ().col;
-      octave_idx_type ofs  = runs.top ().ofs;
-      octave_idx_type nel  = runs.top ().nel;
+      octave_idx_type col = runs.top ().col;
+      octave_idx_type ofs = runs.top ().ofs;
+      octave_idx_type nel = runs.top ().nel;
       runs.pop ();
       assert (nel > 1);
 
       T *lbuf = buf + ofs;
       const T *ldata = data + rows*col;
       octave_idx_type *lidx = idx + ofs;
 
       // Gather.
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -353,32 +353,32 @@ octave_syscalls::popen2 (const std::stri
                   else
                     child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
                 }
               else
                 child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
 
               (*current_liboctave_error_handler)(child_msg.c_str ());
 
-              exit(0);
+              exit (0);
             }
           else
             {
               // Parent process
               gnulib::close (child_stdin[0]);
               gnulib::close (child_stdout[1]);
 
 #if defined (F_SETFL) && defined (O_NONBLOCK)
               if (! sync_mode && octave_fcntl (child_stdout[0], F_SETFL, O_NONBLOCK, msg) < 0)
                 msg = "popen2: error setting file mode -- " + msg;
               else
 #endif
                 {
-                  fildes[0] = child_stdin [1];
-                  fildes[1] = child_stdout [0];
+                  fildes[0] = child_stdin[1];
+                  fildes[1] = child_stdout[0];
                   return pid;
                 }
             }
           gnulib::close (child_stdout[0]);
           gnulib::close (child_stdout[1]);
         }
       else
         msg = "popen2: pipe creation failed -- " + msg;
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -170,17 +170,17 @@ octave_base_tm::strftime (const std::str
 
       char *buf = 0;
       size_t bufsize = STRFTIME_BUF_INITIAL_SIZE;
       size_t chars_written = 0;
 
       while (chars_written == 0)
         {
           delete [] buf;
-          buf = new char[bufsize];
+          buf = new char [bufsize];
           buf[0] = '\0';
 
           chars_written = nstrftime (buf, bufsize, fmt_str, &t, 0, 0);
 
           bufsize *= 2;
         }
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
diff --git a/liboctave/randgamma.c b/liboctave/randgamma.c
--- a/liboctave/randgamma.c
+++ b/liboctave/randgamma.c
@@ -20,18 +20,18 @@ along with Octave; see the file COPYING.
 
 */
 
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
 /*
 
-double randg(a)
-void fill_randg(a,n,x)
+double randg (a)
+void fill_randg (a,n,x)
 
 Generate a series of standard gamma distributions.
 
 See: Marsaglia G and Tsang W (2000), "A simple method for generating
 gamma variables", ACM Transactions on Mathematical Software 26(3) 363-372
 
 Needs the following defines:
 * NAN: value to return for Not-A-Number
@@ -94,19 +94,19 @@ Dirichlet(a1,...,ak) for ai > 0
 #define RUNI oct_randu()
 #define RNOR oct_randn()
 #define REXP oct_rande()
 
 void
 oct_fill_randg (double a, octave_idx_type n, double *r)
 {
   octave_idx_type i;
-  /* If a < 1, start by generating gamma(1+a) */
+  /* If a < 1, start by generating gamma (1+a) */
   const double d =  (a < 1. ? 1.+a : a) - 1./3.;
-  const double c = 1./sqrt(9.*d);
+  const double c = 1./sqrt (9.*d);
 
   /* Handle invalid cases */
   if (a <= 0 || INFINITE(a))
     {
       for (i=0; i < n; i++)
         r[i] = NAN;
       return;
     }
@@ -117,33 +117,33 @@ oct_fill_randg (double a, octave_idx_typ
     restart:
       x = RNOR;
       v = (1+c*x);
       v *= v*v;
       if (v <= 0)
         goto restart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
-      if (u >= 1.-0.0331*xsq*xsq && log(u) >= 0.5*xsq + d*(1-v+log(v)))
+      if (u >= 1.-0.0331*xsq*xsq && log (u) >= 0.5*xsq + d*(1-v+log (v)))
         goto restart;
       r[i] = d*v;
     }
   if (a < 1)
     { /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
       for (i = 0; i < n; i++)
-        r[i] *= exp(-REXP/a);
+        r[i] *= exp (-REXP/a);
     }
 }
 
 double
 oct_randg (double a)
 {
   double ret;
-  oct_fill_randg(a,1,&ret);
+  oct_fill_randg (a,1,&ret);
   return ret;
 }
 
 #undef NAN
 #undef RUNI
 #undef RNOR
 #undef REXP
 #define NAN octave_Float_NaN
@@ -152,17 +152,17 @@ oct_randg (double a)
 #define REXP oct_float_rande()
 
 void
 oct_fill_float_randg (float a, octave_idx_type n, float *r)
 {
   octave_idx_type i;
   /* If a < 1, start by generating gamma(1+a) */
   const float d =  (a < 1. ? 1.+a : a) - 1./3.;
-  const float c = 1./sqrt(9.*d);
+  const float c = 1./sqrt (9.*d);
 
   /* Handle invalid cases */
   if (a <= 0 || INFINITE(a))
     {
       for (i=0; i < n; i++)
         r[i] = NAN;
       return;
     }
@@ -173,27 +173,27 @@ oct_fill_float_randg (float a, octave_id
     frestart:
       x = RNOR;
       v = (1+c*x);
       v *= v*v;
       if (v <= 0)
         goto frestart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
-      if (u >= 1.-0.0331*xsq*xsq && log(u) >= 0.5*xsq + d*(1-v+log(v)))
+      if (u >= 1.-0.0331*xsq*xsq && log (u) >= 0.5*xsq + d*(1-v+log (v)))
         goto frestart;
       r[i] = d*v;
     }
   if (a < 1)
     { /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
       for (i = 0; i < n; i++)
-        r[i] *= exp(-REXP/a);
+        r[i] *= exp (-REXP/a);
     }
 }
 
 float
 oct_float_randg (float a)
 {
   float ret;
-  oct_fill_float_randg(a,1,&ret);
+  oct_fill_float_randg (a,1,&ret);
   return ret;
 }
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -112,68 +112,68 @@ along with Octave; see the file COPYING.
 
    === Usage instructions ===
    Before using any of the generators, initialize the state with one of
    oct_init_by_int, oct_init_by_array or oct_init_by_entropy.
 
    All generators share the same state vector.
 
    === Mersenne Twister ===
-   void oct_init_by_int(uint32_t s)           32-bit initial state
-   void oct_init_by_array(uint32_t k[],int m) m*32-bit initial state
-   void oct_init_by_entropy(void)             random initial state
-   void oct_get_state(uint32_t save[MT_N+1])  saves state in array
-   void oct_set_state(uint32_t save[MT_N+1])  restores state from array
-   static uint32_t randmt(void)               returns 32-bit unsigned int
+   void oct_init_by_int (uint32_t s)           32-bit initial state
+   void oct_init_by_array (uint32_t k[],int m) m*32-bit initial state
+   void oct_init_by_entropy (void)             random initial state
+   void oct_get_state (uint32_t save[MT_N+1])  saves state in array
+   void oct_set_state (uint32_t save[MT_N+1])  restores state from array
+   static uint32_t randmt (void)               returns 32-bit unsigned int
 
    === inline generators ===
-   static uint32_t randi32(void)   returns 32-bit unsigned int
-   static uint64_t randi53(void)   returns 53-bit unsigned int
-   static uint64_t randi54(void)   returns 54-bit unsigned int
-   static float randu32(void)     returns 32-bit uniform in (0,1)
-   static double randu53(void)     returns 53-bit uniform in (0,1)
+   static uint32_t randi32 (void)   returns 32-bit unsigned int
+   static uint64_t randi53 (void)   returns 53-bit unsigned int
+   static uint64_t randi54 (void)   returns 54-bit unsigned int
+   static float randu32 (void)      returns 32-bit uniform in (0,1)
+   static double randu53 (void)     returns 53-bit uniform in (0,1)
 
-   double oct_randu(void)       returns M-bit uniform in (0,1)
-   double oct_randn(void)       returns M-bit standard normal
-   double oct_rande(void)       returns N-bit standard exponential
+   double oct_randu (void)       returns M-bit uniform in (0,1)
+   double oct_randn (void)       returns M-bit standard normal
+   double oct_rande (void)       returns N-bit standard exponential
 
-   float oct_float_randu(void)       returns M-bit uniform in (0,1)
-   float oct_float_randn(void)       returns M-bit standard normal
-   float oct_float_rande(void)       returns N-bit standard exponential
+   float oct_float_randu (void)       returns M-bit uniform in (0,1)
+   float oct_float_randn (void)       returns M-bit standard normal
+   float oct_float_rande (void)       returns N-bit standard exponential
 
    === Array generators ===
-   void oct_fill_randi32(octave_idx_type, uint32_t [])
-   void oct_fill_randi64(octave_idx_type, uint64_t [])
+   void oct_fill_randi32 (octave_idx_type, uint32_t [])
+   void oct_fill_randi64 (octave_idx_type, uint64_t [])
 
-   void oct_fill_randu(octave_idx_type, double [])
-   void oct_fill_randn(octave_idx_type, double [])
-   void oct_fill_rande(octave_idx_type, double [])
+   void oct_fill_randu (octave_idx_type, double [])
+   void oct_fill_randn (octave_idx_type, double [])
+   void oct_fill_rande (octave_idx_type, double [])
 
-   void oct_fill_float_randu(octave_idx_type, float [])
-   void oct_fill_float_randn(octave_idx_type, float [])
-   void oct_fill_float_rande(octave_idx_type, float [])
+   void oct_fill_float_randu (octave_idx_type, float [])
+   void oct_fill_float_randn (octave_idx_type, float [])
+   void oct_fill_float_rande (octave_idx_type, float [])
 */
 
 #if defined (HAVE_CONFIG_H)
 #include <config.h>
 #endif
 
 #include <stdio.h>
 #include <time.h>
 
 #ifdef HAVE_GETTIMEOFDAY
 #include <sys/time.h>
 #endif
 
 #include "lo-math.h"
 #include "randmtzig.h"
 
-/* FIXME may want to suppress X86 if sizeof(long)>4 */
-#if !defined(USE_X86_32)
-# if defined(i386) || defined(HAVE_X86_32)
+/* FIXME may want to suppress X86 if sizeof(long) > 4 */
+#if !defined (USE_X86_32)
+# if defined (i386) || defined (HAVE_X86_32)
 #  define USE_X86_32 1
 # else
 #  define USE_X86_32 0
 # endif
 #endif
 
 /* ===== Mersenne Twister 32-bit generator ===== */
 
@@ -255,44 +255,44 @@ oct_init_by_array (uint32_t *init_key, i
 
 void
 oct_init_by_entropy (void)
 {
     uint32_t entropy[MT_N];
     int n = 0;
 
     /* Look for entropy in /dev/urandom */
-    FILE* urandom =fopen("/dev/urandom", "rb");
+    FILE* urandom =fopen ("/dev/urandom", "rb");
     if (urandom)
       {
         while (n < MT_N)
           {
             unsigned char word[4];
-            if (fread(word, 4, 1, urandom) != 1)
+            if (fread (word, 4, 1, urandom) != 1)
               break;
             entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+(word[3]<<24);
           }
-        fclose(urandom);
+        fclose (urandom);
       }
 
     /* If there isn't enough entropy, gather some from various sources */
     if (n < MT_N)
-      entropy[n++] = time(NULL); /* Current time in seconds */
+      entropy[n++] = time (NULL); /* Current time in seconds */
     if (n < MT_N)
       entropy[n++] = clock ();    /* CPU time used (usec) */
 #ifdef HAVE_GETTIMEOFDAY
     if (n < MT_N)
       {
         struct timeval tv;
-        if (gettimeofday(&tv, NULL) != -1)
+        if (gettimeofday (&tv, NULL) != -1)
           entropy[n++] = tv.tv_usec;   /* Fractional part of current time */
       }
 #endif
     /* Send all the entropy into the initial state vector */
-    oct_init_by_array(entropy,n);
+    oct_init_by_array (entropy,n);
 }
 
 void
 oct_set_state (uint32_t *save)
 {
   int i;
   for (i = 0; i < MT_N; i++)
     state[i] = save[i];
@@ -501,17 +501,17 @@ create_ziggurat_tables (void)
   wi[0] = NOR_SECTION_AREA / fi[255] / NMANTISSA;
   fi[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
        */
-      x = sqrt(-2. * log(NOR_SECTION_AREA / x1 + fi[i+1]));
+      x = sqrt (-2. * log (NOR_SECTION_AREA / x1 + fi[i+1]));
       ki[i+1] = (ZIGINT)(x / x1 * NMANTISSA);
       wi[i] = x / NMANTISSA;
       fi[i] = exp (-0.5 * x * x);
       x1 = x;
     }
 
   ki[1] = 0;
 
@@ -529,17 +529,17 @@ create_ziggurat_tables (void)
   we[0] = EXP_SECTION_AREA / fe[255] / EMANTISSA;
   fe[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-x) -> x = -ln(y)
        */
-      x = - log(EXP_SECTION_AREA / x1 + fe[i+1]);
+      x = - log (EXP_SECTION_AREA / x1 + fe[i+1]);
       ke[i+1] = (ZIGINT)(x / x1 * EMANTISSA);
       we[i] = x / EMANTISSA;
       fe[i] = exp (-x);
       x1 = x;
     }
   ke[1] = 0;
 
   initt = 0;
@@ -615,17 +615,17 @@ oct_randn (void)
           do
             {
               xx = - ZIGGURAT_NOR_INV_R * log (RANDU);
               yy = - log (RANDU);
             }
           while ( yy+yy <= xx*xx);
           return (rabs&0x100 ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
         }
-      else if ((fi[idx-1] - fi[idx]) * RANDU + fi[idx] < exp(-0.5*x*x))
+      else if ((fi[idx-1] - fi[idx]) * RANDU + fi[idx] < exp (-0.5*x*x))
         return x;
     }
 }
 
 double
 oct_rande (void)
 {
   if (initt)
@@ -640,19 +640,19 @@ oct_rande (void)
         return x;               // 98.9% of the time we return here 1st try
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
            *
            * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
            */
-          return ZIGGURAT_EXP_R - log(RANDU);
+          return ZIGGURAT_EXP_R - log (RANDU);
         }
-      else if ((fe[idx-1] - fe[idx]) * RANDU + fe[idx] < exp(-x))
+      else if ((fe[idx-1] - fe[idx]) * RANDU + fe[idx] < exp (-x))
         return x;
     }
 }
 
 #undef ZIGINT
 #undef EMANTISSA
 #undef ERANDI
 #undef NMANTISSA
@@ -692,17 +692,17 @@ create_ziggurat_float_tables (void)
   fwi[0] = NOR_SECTION_AREA / ffi[255] / NMANTISSA;
   ffi[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
        */
-      x = sqrt(-2. * log(NOR_SECTION_AREA / x1 + ffi[i+1]));
+      x = sqrt (-2. * log (NOR_SECTION_AREA / x1 + ffi[i+1]));
       fki[i+1] = (ZIGINT)(x / x1 * NMANTISSA);
       fwi[i] = x / NMANTISSA;
       ffi[i] = exp (-0.5 * x * x);
       x1 = x;
     }
 
   fki[1] = 0;
 
@@ -720,17 +720,17 @@ create_ziggurat_float_tables (void)
   fwe[0] = EXP_SECTION_AREA / ffe[255] / EMANTISSA;
   ffe[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
        * need inverse operator of y = exp(-x) -> x = -ln(y)
        */
-      x = - log(EXP_SECTION_AREA / x1 + ffe[i+1]);
+      x = - log (EXP_SECTION_AREA / x1 + ffe[i+1]);
       fke[i+1] = (ZIGINT)(x / x1 * EMANTISSA);
       fwe[i] = x / EMANTISSA;
       ffe[i] = exp (-x);
       x1 = x;
     }
   fke[1] = 0;
 
   inittf = 0;
@@ -782,17 +782,17 @@ oct_float_randn (void)
           do
             {
               xx = - ZIGGURAT_NOR_INV_R * log (RANDU);
               yy = - log (RANDU);
             }
           while ( yy+yy <= xx*xx);
           return (rabs&0x100 ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
         }
-      else if ((ffi[idx-1] - ffi[idx]) * RANDU + ffi[idx] < exp(-0.5*x*x))
+      else if ((ffi[idx-1] - ffi[idx]) * RANDU + ffi[idx] < exp (-0.5*x*x))
         return x;
     }
 }
 
 float
 oct_float_rande (void)
 {
   if (inittf)
@@ -807,19 +807,19 @@ oct_float_rande (void)
         return x;               // 98.9% of the time we return here 1st try
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
            *
            * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
            */
-          return ZIGGURAT_EXP_R - log(RANDU);
+          return ZIGGURAT_EXP_R - log (RANDU);
         }
-      else if ((ffe[idx-1] - ffe[idx]) * RANDU + ffe[idx] < exp(-x))
+      else if ((ffe[idx-1] - ffe[idx]) * RANDU + ffe[idx] < exp (-x))
         return x;
     }
 }
 
 /* Array generators */
 void
 oct_fill_randu (octave_idx_type n, double *p)
 {
diff --git a/liboctave/randpoisson.c b/liboctave/randpoisson.c
--- a/liboctave/randpoisson.c
+++ b/liboctave/randpoisson.c
@@ -100,17 +100,17 @@ flogfak (double k)
   };
 
   double  r, rr;
 
   if (k >= 30.0)
     {
       r  = 1.0 / k;
       rr = r * r;
-      return ((k + 0.5)*log(k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
+      return ((k + 0.5)*log (k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
     }
   else
     return (logfak[(int)k]);
 }
 
 
 /******************************************************************
  *                                                                *
@@ -141,66 +141,66 @@ flogfak (double k)
  * Implemented by H. Zechner, January 1994                        *
  * Revised by F. Niederl, July 1994                               *
  *                                                                *
  ******************************************************************/
 
 static double
 f (double k, double l_nu, double c_pm)
 {
-  return exp(k * l_nu - flogfak(k) - c_pm);
+  return exp (k * l_nu - flogfak (k) - c_pm);
 }
 
 static double
 pprsc (double my)
 {
   static double        my_last = -1.0;
   static double        m,  k2, k4, k1, k5;
   static double        dl, dr, r1, r2, r4, r5, ll, lr, l_my, c_pm,
     f1, f2, f4, f5, p1, p2, p3, p4, p5, p6;
   double               Dk, X, Y;
   double               Ds, U, V, W;
 
   if (my != my_last)
     {                               /* set-up           */
       my_last = my;
       /* approximate deviation of reflection points k2, k4 from my - 1/2 */
-      Ds = sqrt(my + 0.25);
+      Ds = sqrt (my + 0.25);
 
       /* mode m, reflection points k2 and k4, and points k1 and k5,      */
       /* which delimit the centre region of h(x)                         */
-      m  = floor(my);
-      k2 = ceil(my - 0.5 - Ds);
-      k4 = floor(my - 0.5 + Ds);
+      m  = floor (my);
+      k2 = ceil (my - 0.5 - Ds);
+      k4 = floor (my - 0.5 + Ds);
       k1 = k2 + k2 - m + 1L;
       k5 = k4 + k4 - m;
 
       /* range width of the critical left and right centre region        */
       dl = (k2 - k1);
       dr = (k5 - k4);
 
       /* recurrence constants r(k)=p(k)/p(k-1) at k = k1, k2, k4+1, k5+1 */
       r1 = my / k1;
       r2 = my / k2;
       r4 = my / (k4 + 1.0);
       r5 = my / (k5 + 1.0);
 
       /* reciprocal values of the scale parameters of exp. tail envelope */
-      ll =  log(r1);                                 /* expon. tail left */
-      lr = -log(r5);                                 /* expon. tail right*/
+      ll =  log (r1);                                /* expon. tail left */
+      lr = -log (r5);                                /* expon. tail right*/
 
       /* Poisson constants, necessary for computing function values f(k) */
-      l_my = log(my);
-      c_pm = m * l_my - flogfak(m);
+      l_my = log (my);
+      c_pm = m * l_my - flogfak (m);
 
       /* function values f(k) = p(k)/p(m) at k = k2, k4, k1, k5          */
-      f2 = f(k2, l_my, c_pm);
-      f4 = f(k4, l_my, c_pm);
-      f1 = f(k1, l_my, c_pm);
-      f5 = f(k5, l_my, c_pm);
+      f2 = f (k2, l_my, c_pm);
+      f4 = f (k4, l_my, c_pm);
+      f1 = f (k1, l_my, c_pm);
+      f5 = f (k5, l_my, c_pm);
 
       /* area of the two centre and the two exponential tail regions     */
       /* area of the two immediate acceptance regions between k2, k4     */
       p1 = f2 * (dl + 1.0);                            /* immed. left    */
       p2 = f2 * dl         + p1;                       /* centre left    */
       p3 = f4 * (dr + 1.0) + p2;                       /* immed. right   */
       p4 = f4 * dr         + p3;                       /* centre right   */
       p5 = f1 / ll         + p4;                       /* exp. tail left */
@@ -211,122 +211,122 @@ pprsc (double my)
     {
       /* generate uniform number U -- U(0, p6)                           */
       /* case distinction corresponding to U                             */
       if ((U = RUNI * p6) < p2)
         {                                            /* centre left      */
 
           /* immediate acceptance region
              R2 = [k2, m) *[0, f2),  X = k2, ... m -1 */
-          if ((V = U - p1) < 0.0)  return(k2 + floor(U/f2));
+          if ((V = U - p1) < 0.0)  return (k2 + floor (U/f2));
           /* immediate acceptance region
              R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1 */
-          if ((W = V / dl) < f1 )  return(k1 + floor(V/f1));
+          if ((W = V / dl) < f1 )  return (k1 + floor (V/f1));
 
           /* computation of candidate X < k2, and its counterpart Y > k2 */
           /* either squeeze-acceptance of X or acceptance-rejection of Y */
-          Dk = floor(dl * RUNI) + 1.0;
+          Dk = floor (dl * RUNI) + 1.0;
           if (W <= f2 - Dk * (f2 - f2/r2))
             {                                        /* quick accept of  */
-              return(k2 - Dk);                       /* X = k2 - Dk      */
+              return (k2 - Dk);                      /* X = k2 - Dk      */
             }
           if ((V = f2 + f2 - W) < 1.0)
             {                                        /* quick reject of Y*/
               Y = k2 + Dk;
               if (V <= f2 + Dk * (1.0 - f2)/(dl + 1.0))
                 {                                    /* quick accept of  */
-                  return(Y);                         /* Y = k2 + Dk      */
+                  return (Y);                        /* Y = k2 + Dk      */
                 }
-              if (V <= f(Y, l_my, c_pm))  return(Y); /* final accept of Y*/
+              if (V <= f (Y, l_my, c_pm))  return (Y); /* final accept of Y*/
             }
           X = k2 - Dk;
         }
       else if (U < p4)
         {                                            /* centre right     */
           /*  immediate acceptance region
               R3 = [m, k4+1)*[0, f4), X = m, ... k4    */
-          if ((V = U - p3) < 0.0)  return(k4 - floor((U - p2)/f4));
+          if ((V = U - p3) < 0.0)  return (k4 - floor ((U - p2)/f4));
           /* immediate acceptance region
              R4 = [k4+1, k5+1)*[0, f5)                */
-          if ((W = V / dr) < f5 )  return(k5 - floor(V/f5));
+          if ((W = V / dr) < f5 )  return (k5 - floor (V/f5));
 
           /* computation of candidate X > k4, and its counterpart Y < k4 */
           /* either squeeze-acceptance of X or acceptance-rejection of Y */
-          Dk = floor(dr * RUNI) + 1.0;
+          Dk = floor (dr * RUNI) + 1.0;
           if (W <= f4 - Dk * (f4 - f4*r4))
             {                                        /* quick accept of  */
-              return(k4 + Dk);                       /* X = k4 + Dk      */
+              return (k4 + Dk);                      /* X = k4 + Dk      */
             }
           if ((V = f4 + f4 - W) < 1.0)
             {                                        /* quick reject of Y*/
               Y = k4 - Dk;
               if (V <= f4 + Dk * (1.0 - f4)/ dr)
                 {                                    /* quick accept of  */
-                  return(Y);                         /* Y = k4 - Dk      */
+                  return (Y);                        /* Y = k4 - Dk      */
                 }
-              if (V <= f(Y, l_my, c_pm))  return(Y); /* final accept of Y*/
+              if (V <= f (Y, l_my, c_pm))  return (Y); /* final accept of Y*/
             }
           X = k4 + Dk;
         }
       else
         {
           W = RUNI;
           if (U < p5)
             {                                        /* expon. tail left */
-              Dk = floor(1.0 - log(W)/ll);
+              Dk = floor (1.0 - log (W)/ll);
               if ((X = k1 - Dk) < 0L)  continue;     /* 0 <= X <= k1 - 1 */
               W *= (U - p4) * ll;                    /* W -- U(0, h(x))  */
               if (W <= f1 - Dk * (f1 - f1/r1))
-                return(X);                           /* quick accept of X*/
+                return (X);                          /* quick accept of X*/
             }
           else
             {                                        /* expon. tail right*/
-              Dk = floor(1.0 - log(W)/lr);
+              Dk = floor (1.0 - log (W)/lr);
               X  = k5 + Dk;                          /* X >= k5 + 1      */
               W *= (U - p5) * lr;                    /* W -- U(0, h(x))  */
               if (W <= f5 - Dk * (f5 - f5*r5))
-                return(X);                           /* quick accept of X*/
+                return (X);                          /* quick accept of X*/
             }
         }
 
       /* acceptance-rejection test of candidate X from the original area */
       /* test, whether  W <= f(k),    with  W = U*h(x)  and  U -- U(0, 1)*/
       /* log f(X) = (X - m)*log(my) - log X! + log m!                    */
-      if (log(W) <= X * l_my - flogfak(X) - c_pm)  return(X);
+      if (log (W) <= X * l_my - flogfak (X) - c_pm)  return (X);
     }
 }
 /* ---- pprsc.c end ------ */
 
 
 /* The remainder of the file is by Paul Kienzle */
 
 /* Given uniform u, find x such that CDF(L,x)==u.  Return x. */
 static void
-poisson_cdf_lookup(double lambda, double *p, size_t n)
+poisson_cdf_lookup (double lambda, double *p, size_t n)
 {
   /* Table size is predicated on the maximum value of lambda
    * we want to store in the table, and the maximum value of
    * returned by the uniform random number generator on [0,1).
    * With lambda==10 and u_max = 1 - 1/(2^32+1), we
    * have poisson_pdf(lambda,36) < 1-u_max.  If instead our
    * generator uses more bits of mantissa or returns a value
    * in the range [0,1], then for lambda==10 we need a table
    * size of 46 instead.  For long doubles, the table size
    * will need to be longer still.  */
 #define TABLESIZE 46
   double t[TABLESIZE];
 
   /* Precompute the table for the u up to and including 0.458.
    * We will almost certainly need it. */
-  int intlambda = (int)floor(lambda);
+  int intlambda = (int)floor (lambda);
   double P;
   int tableidx;
   size_t i = n;
 
-  t[0] = P = exp(-lambda);
+  t[0] = P = exp (-lambda);
   for (tableidx = 1; tableidx <= intlambda; tableidx++) {
     P = P*lambda/(double)tableidx;
     t[tableidx] = t[tableidx-1] + P;
   }
 
   while (i-- > 0) {
     double u = RUNI;
 
@@ -364,28 +364,28 @@ poisson_cdf_lookup(double lambda, double
      * This should be true even if RUNI is returning values in
      * the range [0,1] rather than [0,1).
      */
     p[i] = (double)(tableidx-1);
   }
 }
 
 static void
-poisson_cdf_lookup_float(double lambda, float *p, size_t n)
+poisson_cdf_lookup_float (double lambda, float *p, size_t n)
 {
   double t[TABLESIZE];
 
   /* Precompute the table for the u up to and including 0.458.
    * We will almost certainly need it. */
-  int intlambda = (int)floor(lambda);
+  int intlambda = (int)floor (lambda);
   double P;
   int tableidx;
   size_t i = n;
 
-  t[0] = P = exp(-lambda);
+  t[0] = P = exp (-lambda);
   for (tableidx = 1; tableidx <= intlambda; tableidx++) {
     P = P*lambda/(double)tableidx;
     t[tableidx] = t[tableidx-1] + P;
   }
 
   while (i-- > 0) {
     double u = RUNI;
     int k = (u > 0.458 ? intlambda : 0);
@@ -407,55 +407,55 @@ poisson_cdf_lookup_float(double lambda, 
     p[i] = (float)(tableidx-1);
   }
 }
 
 /* From Press, et al., Numerical Recipes */
 static void
 poisson_rejection (double lambda, double *p, size_t n)
 {
-  double sq = sqrt(2.0*lambda);
-  double alxm = log(lambda);
+  double sq = sqrt (2.0*lambda);
+  double alxm = log (lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
 
   for (i = 0; i < n; i++)
     {
       double y, em, t;
       do {
         do {
           y = tan(M_PI*RUNI);
           em = sq * y + lambda;
         } while (em < 0.0);
-        em = floor(em);
-        t = 0.9*(1.0+y*y)*exp(em*alxm-flogfak(em)-g);
+        em = floor (em);
+        t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
       } while (RUNI > t);
       p[i] = em;
     }
 }
 
 /* From Press, et al., Numerical Recipes */
 static void
 poisson_rejection_float (double lambda, float *p, size_t n)
 {
-  double sq = sqrt(2.0*lambda);
-  double alxm = log(lambda);
+  double sq = sqrt (2.0*lambda);
+  double alxm = log (lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
 
   for (i = 0; i < n; i++)
     {
       double y, em, t;
       do {
         do {
-          y = tan(M_PI*RUNI);
+          y = tan (M_PI*RUNI);
           em = sq * y + lambda;
         } while (em < 0.0);
-        em = floor(em);
-        t = 0.9*(1.0+y*y)*exp(em*alxm-flogfak(em)-g);
+        em = floor (em);
+        t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
       } while (RUNI > t);
       p[i] = em;
     }
 }
 
 /* The cutoff of L <= 1e8 in the following two functions before using
  * the normal approximation is based on:
  *   > L=1e8; x=floor(linspace(0,2*L,1000));
@@ -472,62 +472,62 @@ oct_fill_randp (double L, octave_idx_typ
   octave_idx_type i;
   if (L < 0.0 || INFINITE(L))
     {
       for (i=0; i<n; i++)
         p[i] = NAN;
     }
   else if (L <= 10.0)
     {
-      poisson_cdf_lookup(L, p, n);
+      poisson_cdf_lookup (L, p, n);
     }
   else if (L <= 1e8)
     {
       for (i=0; i<n; i++)
-        p[i] = pprsc(L);
+        p[i] = pprsc (L);
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      const double sqrtL = sqrt(L);
+      const double sqrtL = sqrt (L);
       for (i = 0; i < n; i++)
         {
-          p[i] = floor(RNOR*sqrtL + L + 0.5);
+          p[i] = floor (RNOR*sqrtL + L + 0.5);
           if (p[i] < 0.0)
             p[i] = 0.0; /* will probably never happen */
         }
     }
 }
 
 /* Generate one poisson variate */
 double
 oct_randp (double L)
 {
   double ret;
   if (L < 0.0) ret = NAN;
   else if (L <= 12.0) {
     /* From Press, et al. Numerical recipes */
-    double g = exp(-L);
+    double g = exp (-L);
     int em = -1;
     double t = 1.0;
     do {
       ++em;
       t *= RUNI;
     } while (t > g);
     ret = em;
   } else if (L <= 1e8) {
     /* numerical recipes */
-    poisson_rejection(L, &ret, 1);
+    poisson_rejection (L, &ret, 1);
   } else if (INFINITE(L)) {
     /* FIXME R uses NaN, but the normal approx. suggests that as
      * limit should be inf. Which is correct? */
     ret = NAN;
   } else {
     /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-    ret = floor(RNOR*sqrt(L) + L + 0.5);
+    ret = floor (RNOR*sqrt (L) + L + 0.5);
     if (ret < 0.0) ret = 0.0; /* will probably never happen */
   }
   return ret;
 }
 
 /* Generate a set of poisson numbers with the same distribution */
 void
 oct_fill_float_randp (float FL, octave_idx_type n, float *p)
@@ -536,59 +536,59 @@ oct_fill_float_randp (float FL, octave_i
   octave_idx_type i;
   if (L < 0.0 || INFINITE(L))
     {
       for (i=0; i<n; i++)
         p[i] = NAN;
     }
   else if (L <= 10.0)
     {
-      poisson_cdf_lookup_float(L, p, n);
+      poisson_cdf_lookup_float (L, p, n);
     }
   else if (L <= 1e8)
     {
       for (i=0; i<n; i++)
-        p[i] = pprsc(L);
+        p[i] = pprsc (L);
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      const double sqrtL = sqrt(L);
+      const double sqrtL = sqrt (L);
       for (i = 0; i < n; i++)
         {
-          p[i] = floor(RNOR*sqrtL + L + 0.5);
+          p[i] = floor (RNOR*sqrtL + L + 0.5);
           if (p[i] < 0.0)
             p[i] = 0.0; /* will probably never happen */
         }
     }
 }
 
 /* Generate one poisson variate */
 float
 oct_float_randp (float FL)
 {
   double L = FL;
   float ret;
   if (L < 0.0) ret = NAN;
   else if (L <= 12.0) {
     /* From Press, et al. Numerical recipes */
-    double g = exp(-L);
+    double g = exp (-L);
     int em = -1;
     double t = 1.0;
     do {
       ++em;
       t *= RUNI;
     } while (t > g);
     ret = em;
   } else if (L <= 1e8) {
     /* numerical recipes */
-    poisson_rejection_float(L, &ret, 1);
+    poisson_rejection_float (L, &ret, 1);
   } else if (INFINITE(L)) {
     /* FIXME R uses NaN, but the normal approx. suggests that as
      * limit should be inf. Which is correct? */
     ret = NAN;
   } else {
     /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-    ret = floor(RNOR*sqrt(L) + L + 0.5);
+    ret = floor (RNOR*sqrt (L) + L + 0.5);
     if (ret < 0.0) ret = 0.0; /* will probably never happen */
   }
   return ret;
 }
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -51,34 +51,34 @@ sparse_base_chol<chol_type, chol_elt, p_
   Sp = static_cast<octave_idx_type *>(S->p);
   Si = static_cast<octave_idx_type *>(S->i);
   Sx = static_cast<chol_elt *>(S->x);
   pdest = 0;
   ncol = S->ncol;
 
   for (k = 0; k < ncol; k++)
     {
-      p = Sp [k];
-      pend = Sp [k+1];
-      Sp [k] = pdest;
+      p = Sp[k];
+      pend = Sp[k+1];
+      Sp[k] = pdest;
       for (; p < pend; p++)
         {
-          sik = Sx [p];
+          sik = Sx[p];
           if (CHOLMOD_IS_NONZERO (sik))
             {
               if (p != pdest)
                 {
-                  Si [pdest] = Si [p];
-                  Sx [pdest] = sik;
+                  Si[pdest] = Si[p];
+                  Sx[pdest] = sik;
                 }
               pdest++;
             }
         }
     }
-  Sp [ncol] = pdest;
+  Sp[ncol] = pdest;
 }
 #endif
 
 template <class chol_type, class chol_elt, class p_type>
 octave_idx_type
 sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::init
   (const chol_type& a, bool natural)
 {
@@ -152,17 +152,17 @@ sparse_base_chol<chol_type, chol_elt, p_
     ac->x = &dummy;
   else
     ac->x = a.data ();
 
   // use natural ordering if no q output parameter
   if (natural)
     {
       cm->nmethods = 1 ;
-      cm->method [0].ordering = CHOLMOD_NATURAL ;
+      cm->method[0].ordering = CHOLMOD_NATURAL ;
       cm->postorder = false ;
     }
 
   cholmod_factor *Lfactor;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   Lfactor = CHOLMOD_NAME(analyze) (ac, cm);
   CHOLMOD_NAME(factorize) (ac, Lfactor, cm);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -224,21 +224,21 @@ chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::L (void) const
 {
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L ();
   octave_idx_type nc = m->ncol;
   octave_idx_type nnz = m->nzmax;
   chol_type ret (m->nrow, nc, nnz);
   for (octave_idx_type j = 0; j < nc+1; j++)
-    ret.xcidx(j) = static_cast<octave_idx_type *>(m->p)[j];
+    ret.xcidx (j) = static_cast<octave_idx_type *>(m->p)[j];
   for (octave_idx_type i = 0; i < nnz; i++)
     {
-      ret.xridx(i) = static_cast<octave_idx_type *>(m->i)[i];
-      ret.xdata(i) = static_cast<chol_elt *>(m->x)[i];
+      ret.xridx (i) = static_cast<octave_idx_type *>(m->i)[i];
+      ret.xdata (i) = static_cast<chol_elt *>(m->x)[i];
     }
   return ret;
 #else
   return chol_type ();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
@@ -247,21 +247,21 @@ sparse_base_chol<chol_type, chol_elt, p_
 sparse_base_chol_rep::Q (void) const
 {
 #ifdef HAVE_CHOLMOD
   octave_idx_type n = Lsparse->nrow;
   p_type p (n, n, n);
 
   for (octave_idx_type i = 0; i < n; i++)
     {
-      p.xcidx(i) = i;
-      p.xridx(i) = static_cast<octave_idx_type>(perms(i));
-      p.xdata(i) = 1;
+      p.xcidx (i) = i;
+      p.xridx (i) = static_cast<octave_idx_type>(perms (i));
+      p.xdata (i) = 1;
     }
-  p.xcidx(n) = n;
+  p.xcidx (n) = n;
 
   return p;
 #else
   return p_type ();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
@@ -272,17 +272,17 @@ sparse_base_chol<chol_type, chol_elt, p_
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L ();
   octave_idx_type n = m->ncol;
   ColumnVector perms = rep->perm ();
   chol_type ret;
   double rcond2;
   octave_idx_type info;
   MatrixType mattype (MatrixType::Upper);
-  chol_type linv = L ().hermitian ().inverse(mattype, info, rcond2, 1, 0);
+  chol_type linv = L ().hermitian ().inverse (mattype, info, rcond2, 1, 0);
 
   if (perms.length () == n)
     {
       p_type Qc = Q ();
       retval = Qc * linv * linv.hermitian () * Qc.transpose ();
     }
   else
     retval = linv * linv.hermitian ();
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/sparse-base-lu.cc
--- a/liboctave/sparse-base-lu.cc
+++ b/liboctave/sparse-base-lu.cc
@@ -32,36 +32,36 @@ lu_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Y (void) const
 {
   octave_idx_type nr = Lfact.rows ();
   octave_idx_type nc = Ufact.rows ();
   octave_idx_type rcmin = (nr > nc ? nr : nc);
 
   lu_type Yout (nr, nc, Lfact.nnz () + Ufact.nnz ());
   octave_idx_type ii = 0;
-  Yout.xcidx(0) = 0;
+  Yout.xcidx (0) = 0;
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx(j + 1); i++)
+      for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx (j + 1); i++)
         {
-          Yout.xridx (ii) = Ufact.ridx(i);
-          Yout.xdata (ii++) = Ufact.data(i);
+          Yout.xridx (ii) = Ufact.ridx (i);
+          Yout.xdata (ii++) = Ufact.data (i);
         }
       if (j < rcmin)
         {
           // Note the +1 skips the 1.0 on the diagonal
           for (octave_idx_type i = Lfact.cidx (j) + 1;
-               i < Lfact.cidx(j +1); i++)
+               i < Lfact.cidx (j +1); i++)
             {
-              Yout.xridx (ii) = Lfact.ridx(i);
-              Yout.xdata (ii++) = Lfact.data(i);
+              Yout.xridx (ii) = Lfact.ridx (i);
+              Yout.xdata (ii++) = Lfact.data (i);
             }
         }
-      Yout.xcidx(j + 1) = ii;
+      Yout.xcidx (j + 1) = ii;
     }
 
   return Yout;
 }
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 p_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pr (void) const
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -28,75 +28,84 @@ along with Octave; see the file COPYING.
 
 #include "MArray.h"
 #include "MSparse.h"
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
 #include "MatrixType.h"
 #include "oct-sort.h"
 #include "oct-locbuf.h"
+#include "oct-inttypes.h"
 
 template <class T>
 static MSparse<T>
 dmsolve_extract (const MSparse<T> &A, const octave_idx_type *Pinv,
                 const octave_idx_type *Q, octave_idx_type rst,
                 octave_idx_type rend, octave_idx_type cst,
                 octave_idx_type cend, octave_idx_type maxnz = -1,
                 bool lazy = false)
 {
-  octave_idx_type nz = (rend - rst) * (cend - cst);
+  octave_idx_type nr = rend - rst, nc = cend - cst;
   maxnz = (maxnz < 0 ? A.nnz () : maxnz);
-  MSparse<T> B (rend - rst, cend - cst, (nz < maxnz ? nz : maxnz));
+  octave_idx_type nz;
+
+  // Cast to uint64 to handle overflow in this multiplication
+  if (octave_uint64 (nr)*octave_uint64 (nc) < octave_uint64 (maxnz))
+    nz = nr*nc;
+  else
+    nz = maxnz;
+
+  MSparse<T> B (nr, nc, (nz < maxnz ? nz : maxnz));
   // Some sparse functions can support lazy indexing (where elements
   // in the row are in no particular order), even though octave in
   // general can't. For those functions that can using it is a big
   // win here in terms of speed.
   if (lazy)
     {
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
-          octave_idx_type qq = (Q ? Q [j] : j);
+          octave_idx_type qq = (Q ? Q[j] : j);
           B.xcidx (j - cst) = nz;
-          for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
+          for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
-              octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
+              octave_idx_type r = (Pinv ? Pinv[A.ridx (p)] : A.ridx (p));
               if (r >= rst && r < rend)
                 {
                   B.xdata (nz) = A.data (p);
-                  B.xridx (nz++) =  r - rst ;
+                  B.xridx (nz++) = r - rst ;
                 }
             }
         }
       B.xcidx (cend - cst) = nz ;
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, X, rend - rst);
       octave_sort<octave_idx_type> sort;
       octave_idx_type *ri = B.xridx ();
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
-          octave_idx_type qq = (Q ? Q [j] : j);
+          octave_idx_type qq = (Q ? Q[j] : j);
           B.xcidx (j - cst) = nz;
-          for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
+          for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
-              octave_idx_type r = (Pinv ? Pinv [A.ridx (p)] : A.ridx (p));
+              octave_idx_type r = (Pinv ? Pinv[A.ridx (p)] : A.ridx (p));
               if (r >= rst && r < rend)
                 {
-                  X [r-rst] = A.data (p);
-                  B.xridx (nz++) =  r - rst ;
+                  X[r-rst] = A.data (p);
+                  B.xridx (nz++) = r - rst ;
                 }
             }
           sort.sort (ri + B.xcidx (j - cst), nz - B.xcidx (j - cst));
           for (octave_idx_type p = B.cidx (j - cst); p < nz; p++)
-            B.xdata (p) = X [B.xridx (p)];
+            B.xdata (p) = X[B.xridx (p)];
         }
       B.xcidx (cend - cst) = nz ;
     }
 
   return B;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
@@ -165,17 +174,17 @@ dmsolve_insert (MArray<T> &a, const MArr
   octave_idx_type nc = b.cols ();
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type aoff = (c + j) * anr;
       octave_idx_type boff = j * nr;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          ax [Q [r + i] + aoff] = bx [i + boff];
+          ax[Q[r + i] + aoff] = bx[i + boff];
         }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MArray<double> &a, const MArray<double> &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
@@ -192,78 +201,78 @@ dmsolve_insert (MSparse<T> &a, const MSp
 {
   octave_idx_type b_rows = b.rows ();
   octave_idx_type b_cols = b.cols ();
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Qinv, nr);
   for (octave_idx_type i = 0; i < nr; i++)
-    Qinv [Q [i]] = i;
+    Qinv[Q[i]] = i;
 
   // First count the number of elements in the final array
-  octave_idx_type nel = a.xcidx(c) + b.nnz ();
+  octave_idx_type nel = a.xcidx (c) + b.nnz ();
 
   if (c + b_cols < nc)
-    nel += a.xcidx(nc) - a.xcidx(c + b_cols);
+    nel += a.xcidx (nc) - a.xcidx (c + b_cols);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
-    for (octave_idx_type j = a.xcidx(i); j < a.xcidx(i+1); j++)
-      if (Qinv [a.xridx(j)] < r || Qinv [a.xridx(j)] >= r + b_rows)
+    for (octave_idx_type j = a.xcidx (i); j < a.xcidx (i+1); j++)
+      if (Qinv[a.xridx (j)] < r || Qinv[a.xridx (j)] >= r + b_rows)
         nel++;
 
   OCTAVE_LOCAL_BUFFER (T, X, nr);
   octave_sort<octave_idx_type> sort;
   MSparse<T> tmp (a);
   a = MSparse<T> (nr, nc, nel);
   octave_idx_type *ri = a.xridx ();
 
-  for (octave_idx_type i = 0; i < tmp.cidx(c); i++)
+  for (octave_idx_type i = 0; i < tmp.cidx (c); i++)
     {
-      a.xdata(i) = tmp.xdata(i);
-      a.xridx(i) = tmp.xridx(i);
+      a.xdata (i) = tmp.xdata (i);
+      a.xridx (i) = tmp.xridx (i);
     }
   for (octave_idx_type i = 0; i < c + 1; i++)
-    a.xcidx(i) = tmp.xcidx(i);
+    a.xcidx (i) = tmp.xcidx (i);
 
-  octave_idx_type ii = a.xcidx(c);
+  octave_idx_type ii = a.xcidx (c);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     {
       octave_quit ();
 
-      for (octave_idx_type j = tmp.xcidx(i); j < tmp.xcidx(i+1); j++)
-        if (Qinv [tmp.xridx(j)] < r ||  Qinv [tmp.xridx(j)] >= r + b_rows)
+      for (octave_idx_type j = tmp.xcidx (i); j < tmp.xcidx (i+1); j++)
+        if (Qinv[tmp.xridx (j)] < r ||  Qinv[tmp.xridx (j)] >= r + b_rows)
           {
-            X [tmp.xridx(j)] = tmp.xdata(j);
-            a.xridx(ii++) = tmp.xridx(j);
+            X[tmp.xridx (j)] = tmp.xdata (j);
+            a.xridx (ii++) = tmp.xridx (j);
           }
 
       octave_quit ();
 
-      for (octave_idx_type j = b.cidx(i-c); j < b.cidx(i-c+1); j++)
+      for (octave_idx_type j = b.cidx (i-c); j < b.cidx (i-c+1); j++)
         {
-          X [Q [r + b.ridx(j)]] = b.data(j);
-          a.xridx(ii++) = Q [r + b.ridx(j)];
+          X[Q[r + b.ridx (j)]] = b.data (j);
+          a.xridx (ii++) = Q[r + b.ridx (j)];
         }
 
       sort.sort (ri + a.xcidx (i), ii - a.xcidx (i));
       for (octave_idx_type p = a.xcidx (i); p < ii; p++)
-        a.xdata (p) = X [a.xridx (p)];
-      a.xcidx(i+1) = ii;
+        a.xdata (p) = X[a.xridx (p)];
+      a.xcidx (i+1) = ii;
     }
 
   for (octave_idx_type i = c + b_cols; i < nc; i++)
     {
-      for (octave_idx_type j = tmp.xcidx(i); j < tmp.cidx(i+1); j++)
+      for (octave_idx_type j = tmp.xcidx (i); j < tmp.cidx (i+1); j++)
         {
-          a.xdata(ii) = tmp.xdata(j);
-          a.xridx(ii++) = tmp.xridx(j);
+          a.xdata (ii) = tmp.xdata (j);
+          a.xridx (ii++) = tmp.xridx (j);
         }
-      a.xcidx(i+1) = ii;
+      a.xcidx (i+1) = ii;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MSparse<double> &a, const SparseMatrix &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
@@ -282,17 +291,17 @@ dmsolve_permute (MArray<RT> &a, const MA
   a.resize (dim_vector (b_nr, b_nc));
   RT *Btx = a.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       octave_idx_type off = j * b_nr;
       for (octave_idx_type i = 0; i < b_nr; i++)
         {
           octave_quit ();
-          Btx [p [i] + off] = Bx [ i + off];
+          Btx[p[i] + off] = Bx[ i + off];
         }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_permute (MArray<double> &a, const MArray<double>& b,
                  const octave_idx_type *p);
@@ -313,33 +322,33 @@ dmsolve_permute (MSparse<RT> &a, const M
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nz = b.nnz ();
   octave_idx_type nz = 0;
   a = MSparse<RT> (b_nr, b_nc, b_nz);
   octave_sort<octave_idx_type> sort;
   octave_idx_type *ri = a.xridx ();
   OCTAVE_LOCAL_BUFFER (RT, X, b_nr);
-  a.xcidx(0) = 0;
+  a.xcidx (0) = 0;
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
-      for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+      for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
         {
           octave_quit ();
-          octave_idx_type r = p [b.ridx (i)];
-          X [r] = b.data (i);
-          a.xridx(nz++) = p [b.ridx (i)];
+          octave_idx_type r = p[b.ridx (i)];
+          X[r] = b.data (i);
+          a.xridx (nz++) = p[b.ridx (i)];
         }
       sort.sort (ri + a.xcidx (j), nz - a.xcidx (j));
       for (octave_idx_type i = a.cidx (j); i < nz; i++)
         {
           octave_quit ();
-          a.xdata (i) = X [a.xridx (i)];
+          a.xdata (i) = X[a.xridx (i)];
         }
-      a.xcidx(j+1) = nz;
+      a.xcidx (j+1) = nz;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_permute (MSparse<double> &a, const MSparse<double>& b,
                  const octave_idx_type *p);
 
@@ -384,93 +393,93 @@ dmsolve (const ST &a, const T &b, octave
       csm.x = 0;
       csm.nz = -1;
       csm.nzmax = a.nnz ();
       // Cast away const on A, with full knowledge that CSparse won't touch it.
       // Prevents the methods below making a copy of the data.
       csm.p = const_cast<octave_idx_type *>(a.cidx ());
       csm.i = const_cast<octave_idx_type *>(a.ridx ());
 
-#if defined(CS_VER) && (CS_VER >= 2)
+#if defined (CS_VER) && (CS_VER >= 2)
       CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm, 0);
       octave_idx_type *p = dm->p;
       octave_idx_type *q = dm->q;
 #else
       CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm);
       octave_idx_type *p = dm->P;
       octave_idx_type *q = dm->Q;
 #endif
       OCTAVE_LOCAL_BUFFER (octave_idx_type, pinv, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        pinv [p [i]] = i;
+        pinv[p[i]] = i;
       RT btmp;
       dmsolve_permute (btmp, b, pinv);
       info = 0;
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
-      if (dm->rr [2] < nr && dm->cc [3] < nc)
+      if (dm->rr[2] < nr && dm->cc[3] < nc)
         {
-          ST m = dmsolve_extract (a, pinv, q, dm->rr [2], nr, dm->cc [3], nc,
+          ST m = dmsolve_extract (a, pinv, q, dm->rr[2], nr, dm->cc[3], nc,
                                   nnz_remaining, true);
           nnz_remaining -= m.nnz ();
           RT mtmp =
             qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
                                          b_nc), info);
-          dmsolve_insert (retval, mtmp, q, dm->cc [3], 0);
-          if (dm->rr [2] > 0 && !info)
+          dmsolve_insert (retval, mtmp, q, dm->cc[3], 0);
+          if (dm->rr[2] > 0 && !info)
             {
-              m = dmsolve_extract (a, pinv, q, 0, dm->rr [2],
-                                   dm->cc [3], nc, nnz_remaining, true);
+              m = dmsolve_extract (a, pinv, q, 0, dm->rr[2],
+                                   dm->cc[3], nc, nnz_remaining, true);
               nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[2], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Structurally non-singular blocks
       // FIXME Should use fine Dulmange-Mendelsohn decomposition here.
-      if (dm->rr [1] < dm->rr [2] && dm->cc [2] < dm->cc [3] && !info)
+      if (dm->rr[1] < dm->rr[2] && dm->cc[2] < dm->cc[3] && !info)
         {
-          ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2],
-                                  dm->cc [2], dm->cc [3], nnz_remaining, false);
+          ST m = dmsolve_extract (a, pinv, q, dm->rr[1], dm->rr[2],
+                                  dm->cc[2], dm->cc[3], nnz_remaining, false);
           nnz_remaining -= m.nnz ();
-          RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr [1], dm->rr [2],
+          RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr[1], dm->rr[2],
                                       0, b_nc);
           double rcond = 0.0;
           MatrixType mtyp (MatrixType::Full);
           RT mtmp = m.solve (mtyp, btmp2, info, rcond,
                              solve_singularity_warning, false);
           if (info != 0)
             {
               info = 0;
               mtmp = qrsolve (m, btmp2, info);
             }
 
-          dmsolve_insert (retval, mtmp, q, dm->cc [2], 0);
-          if (dm->rr [1] > 0 && !info)
+          dmsolve_insert (retval, mtmp, q, dm->cc[2], 0);
+          if (dm->rr[1] > 0 && !info)
             {
-              m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], dm->cc [2],
-                                   dm->cc [3], nnz_remaining, true);
+              m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], dm->cc[2],
+                                   dm->cc[3], nnz_remaining, true);
               nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[1], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Trailing under-determined block
-      if (dm->rr [1] > 0 && dm->cc [2] > 0 && !info)
+      if (dm->rr[1] > 0 && dm->cc[2] > 0 && !info)
         {
-          ST m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], 0,
-                                  dm->cc [2], nnz_remaining, true);
+          ST m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], 0,
+                                  dm->cc[2], nnz_remaining, true);
           RT mtmp =
-            qrsolve (m, dmsolve_extract(btmp, 0, 0, 0, dm->rr [1] , 0,
-                                        b_nc), info);
+            qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1] , 0,
+                                         b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
   return retval;
 #else
   return RT ();
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -49,32 +49,32 @@ string_vector::string_vector (const std:
 
   resize (n);
 
   octave_idx_type i = 0;
 
   for (std::list<std::string>::const_iterator p = lst.begin ();
        p != lst.end ();
        p++)
-    elem(i++) = *p;
+    elem (i++) = *p;
 }
 
 string_vector::string_vector (const std::set<std::string>& lst)
   : Array<std::string> ()
 {
   size_t n = lst.size ();
 
   resize (n);
 
   octave_idx_type i = 0;
 
   for (std::set<std::string>::const_iterator p = lst.begin ();
        p != lst.end ();
        p++)
-    elem(i++) = *p;
+    elem (i++) = *p;
 }
 
 // Create a string vector from a NULL terminated list of C strings.
 
 string_vector::string_vector (const char * const *s)
   : Array<std::string> ()
 {
   octave_idx_type n = 0;
@@ -120,85 +120,85 @@ string_vector::uniq (void)
 {
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       octave_idx_type k = 0;
 
       for (octave_idx_type i = 1; i < len; i++)
-        if (elem(i) != elem(k))
+        if (elem (i) != elem (k))
           if (++k != i)
-            elem(k) = elem(i);
+            elem (k) = elem (i);
 
       if (len != ++k)
         resize (k);
     }
 
   return *this;
 }
 
 string_vector&
 string_vector::append (const std::string& s)
 {
   octave_idx_type len = length ();
 
   resize (len + 1);
 
-  elem(len) = s;
+  elem (len) = s;
 
   return *this;
 }
 
 string_vector&
 string_vector::append (const string_vector& sv)
 {
   octave_idx_type len = length ();
   octave_idx_type sv_len = sv.length ();
   octave_idx_type new_len = len + sv_len;
 
   resize (new_len);
 
   for (octave_idx_type i = 0; i < sv_len; i++)
-    elem(len + i) = sv[i];
+    elem (len + i) = sv[i];
 
   return *this;
 }
 
 std::string
 string_vector::join (const std::string& sep) const
 {
   std::string retval;
 
   octave_idx_type len = length ();
 
   if (len > 0)
     {
       octave_idx_type i;
 
       for (i = 0; i < len - 1; i++)
-        retval += elem(i) + sep;
+        retval += elem (i) + sep;
 
-      retval += elem(i);
+      retval += elem (i);
     }
 
   return retval;
 }
 
 char **
 string_vector::c_str_vec (void) const
 {
   octave_idx_type len = length ();
 
   char **retval = new char * [len + 1];
 
-  retval [len] = 0;
+  retval[len] = 0;
 
   for (octave_idx_type i = 0; i < len; i++)
-    retval[i] = strsave (elem(i).c_str ());
+    retval[i] = strsave (elem (i).c_str ());
 
   return retval;
 }
 
 void
 string_vector::delete_c_str_vec (const char * const *v)
 {
   const char * const *p = v;
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -74,17 +74,17 @@ public:
 
   octave_idx_type max_length (void) const
   {
     octave_idx_type n = length ();
     octave_idx_type longest = 0;
 
     for (octave_idx_type i = 0; i < n; i++)
       {
-        octave_idx_type tmp = elem(i).length ();
+        octave_idx_type tmp = elem (i).length ();
 
         if (tmp > longest)
           longest = tmp;
       }
 
     return longest;
   }
 
diff --git a/liboctave/tempnam.c b/liboctave/tempnam.c
--- a/liboctave/tempnam.c
+++ b/liboctave/tempnam.c
@@ -38,22 +38,22 @@ extern char *__stdio_gen_tempname (const
    If not and if DIR is not NULL, that value is checked.  If that fails,
    P_tmpdir is tried and finally "/tmp".  The storage for the filename
    is allocated by `malloc'.  */
 char *
 tempnam (const char *dir, const char *pfx)
 {
   size_t len;
   register char *s;
-  register char *t = __stdio_gen_tempname(dir, pfx, 1, &len, (FILE **) NULL);
+  register char *t = __stdio_gen_tempname (dir, pfx, 1, &len, (FILE **) NULL);
 
   if (t == NULL)
     return NULL;
 
-  s = (char *) malloc(len);
+  s = (char *) malloc (len);
   if (s == NULL)
     return NULL;
 
-  (void) memcpy(s, t, len);
+  (void) memcpy (s, t, len);
   return s;
 }
 
 #endif
diff --git a/liboctave/tempname.c b/liboctave/tempname.c
--- a/liboctave/tempname.c
+++ b/liboctave/tempname.c
@@ -107,24 +107,24 @@ char *
   size_t *idx;
   static char buf[FILENAME_MAX];
   static pid_t oldpid = (pid_t) 0;
   pid_t pid = getpid ();
   register size_t len, plen, dlen;
 
   if (dir_search)
     {
-      register const char *d = getenv("TMPDIR");
-      if (d != NULL && !diraccess(d))
+      register const char *d = getenv ("TMPDIR");
+      if (d != NULL && !diraccess (d))
         d = NULL;
-      if (d == NULL && dir != NULL && diraccess(dir))
+      if (d == NULL && dir != NULL && diraccess (dir))
         d = dir;
-      if (d == NULL && diraccess(tmpdir))
+      if (d == NULL && diraccess (tmpdir))
         d = tmpdir;
-      if (d == NULL && diraccess("/tmp"))
+      if (d == NULL && diraccess ("/tmp"))
         d = "/tmp";
       if (d == NULL)
         {
           errno = ENOENT;
           return NULL;
         }
       dir = d;
     }
@@ -134,24 +134,24 @@ char *
   dlen = strlen (dir);
 
   /* Remove trailing slashes from the directory name.  */
   while (dlen > 1 && dir[dlen - 1] == '/')
     --dlen;
 
   if (pfx != NULL && *pfx != '\0')
     {
-      plen = strlen(pfx);
+      plen = strlen (pfx);
       if (plen > 5)
         plen = 5;
     }
   else
     plen = 0;
 
-  if (dir != tmpdir && !strcmp(dir, tmpdir))
+  if (dir != tmpdir && !strcmp (dir, tmpdir))
     dir = tmpdir;
   idx = &indices[(plen == 0 && dir == tmpdir) ? 1 : 0];
 
   if (pid != oldpid)
     {
       oldpid = pid;
       indices[0] = indices[1] = 0;
     }
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -281,17 +281,17 @@ EOB
 dnl
 dnl Check to see if C compiler handles FLAG command line option.  If
 dnl two arguments are specified, execute the second arg as shell
 dnl commands.  Otherwise, add FLAG to CFLAGS if the compiler accepts
 dnl the flag.
 dnl
 dnl OCTAVE_CC_FLAG
 AC_DEFUN([OCTAVE_CC_FLAG], [
-  ac_safe=`echo "$1" | sed 'y%./+-:=%__p___%'`
+  ac_safe=`echo "$1" | sed 'y% ./+-:=%___p___%'`
   AC_MSG_CHECKING([whether ${CC-cc} accepts $1])
   AC_CACHE_VAL(octave_cv_cc_flag_$ac_safe, [
     AC_LANG_PUSH(C)
     XCFLAGS="$CFLAGS"
     CFLAGS="$CFLAGS $1"
     AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
       eval "octave_cv_cc_flag_$ac_safe=yes",
       eval "octave_cv_cc_flag_$ac_safe=no")
@@ -623,25 +623,22 @@ AC_DEFUN([OCTAVE_PROG_GNUPLOT], [
 gp_names="gnuplot"
 gp_default="gnuplot"
 if test "$cross_compiling" = yes; then
   GNUPLOT="$gp_default"
   AC_MSG_RESULT([assuming $GNUPLOT exists on $canonical_host_type host])
 else
   AC_CHECK_PROGS(GNUPLOT, [$gp_names])
   if test -z "$GNUPLOT"; then
-    warn_gnuplot=yes
-
     GNUPLOT="$gp_default"
-    warn_gnuplot = "
+    warn_gnuplot="
 
 gnuplot not found. It isn't necessary to have gnuplot installed, but
 without native graphics or gnuplot you won't be able to use any of
 Octave's plotting commands.
-
 "
     OCTAVE_CONFIGURE_WARNING([warn_gnuplot])
   fi
 fi
 AC_SUBST(GNUPLOT)
 ])
 dnl
 dnl Is gperf installed?
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -14,24 +14,28 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} help @var{name}
 ## @deftypefnx {Command} {} help @code{--list}
+## @deftypefnx {Command} {} help @code{.}
 ## Display the help text for @var{name}.   For example, the command
 ## @kbd{help help} prints a short message describing the @code{help}
 ## command.
 ##
 ## Given the single argument @code{--list}, list all operators,
 ## keywords, built-in functions, and loadable functions available
 ## in the current session of Octave.
 ##
+## Given the single argument @code{.}, list all operators available
+## in the current session of Octave.
+##
 ## If invoked without any arguments, @code{help} display instructions
 ## on how to access help from the command line.
 ##
 ## The help command can give you information about operators, but not the
 ## comma and semicolons that are used as command separators.  To get help
 ## for those, you must type @kbd{help comma} or @kbd{help semicolon}.
 ## @seealso{doc, lookfor, which}
 ## @end deftypefn
@@ -63,16 +67,26 @@ function retval = help (name)
       if (nargout == 0)
         printf ("%s", tmp);
       else
         retval = tmp;
       endif
       return;
     endif
 
+    if (strcmp (name, "."))
+      tmp = do_list_operators ();
+      if (nargout == 0)
+        printf ("%s", tmp);
+      else
+        retval = tmp;
+      endif
+      return;
+    endif
+
     ## Get help text
     [text, format] = get_help_text (name);
 
     ## Take action depending on help text format
     switch (lower (format))
       case "plain text"
         status = 0;
       case "texinfo"
@@ -101,20 +115,25 @@ function retval = help (name)
     endif
 
   else
     error ("help: invalid input\n");
   endif
 
 endfunction
 
+function retval = do_list_operators ()
+  
+  retval = sprintf ("*** operators:\n\n%s\n\n",
+                       list_in_columns (__operators__ ()));
+endfunction
+
 function retval = do_list_functions ()
 
-  operators = sprintf ("*** operators:\n\n%s\n\n",
-                       list_in_columns (__operators__ ()));
+  operators = do_list_operators ();
 
   keywords = sprintf ("*** keywords:\n\n%s\n\n",
                       list_in_columns (__keywords__ ()));
 
   builtins = sprintf ("*** builtins:\n\n%s\n\n",
                       list_in_columns (__builtins__ ()));
 
   dirs = strsplit (path, pathsep);
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -113,14 +113,14 @@ endfunction
 
 
 %!test
 %! var = 1;
 %! typestr = type ("var");
 %! typestr = typestr{1}(1:17);
 %! assert (typestr, "var is a variable");
 
-%!assert (type ("dot"){1}, "dot is a dynamically-linked function")
+%!assert (type ("amd"){1}, "amd is a dynamically-linked function")
 %!assert (type ("cat"){1}, "cat is a built-in function")
 %!assert (type ("+"){1}, "+ is an operator")
 %!assert (type ("end"){1}, "end is a keyword")
 %!error (type ('NO_NAME'))
  
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -33,17 +33,17 @@ function txt = unimplemented (fcn)
     txt = ["importdata is not implemented.  Similar functionality is ",...
     "available through @code{load}, @code{dlmread}, @code{csvread}, ",...
     "or @code{textscan}."];  
 
   case "quad2d"
     txt = ["quad2d is not implemented.  Consider using dblquad."];
 
   case "gsvd"
-    txt = ["gsvd is not currently part of core Octave.  See the ",
+    txt = ["gsvd is not currently part of core Octave.  See the ",...
     "linear-algebra package at @url{http://octave.sf.net/linear-algebra/}."];
 
   case "linprog"
     txt = ["Octave does not currently provide linprog.  ",...
     "Linear programming problems may be solved using @code{glpk}.  ",...
     "Try @code{help glpk} for more info."];
 
   case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", "ode45", "odeget", "odeset"}
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -54,13 +54,13 @@ function varargout = which (varargin)
 
 endfunction
 
 
 %!test
 %! str = which ("ls");
 %! assert (str(end-17:end), strcat ("miscellaneous", filesep (), "ls.m"));
 %!test
-%! str = which ("dot");
-%! assert (str(end-6:end), "dot.oct");
+%! str = which ("amd");
+%! assert (str(end-6:end), "amd.oct");
 
 %!assert (which ("_NO_SUCH_NAME_"), "")
 
diff --git a/scripts/image/cmpermute.m b/scripts/image/cmpermute.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/cmpermute.m
@@ -0,0 +1,144 @@
+## Copyright (C) 2004 Josep Mones i Teixidor
+## Copyright (C) 2012 Rik Wehbring 
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {[@var{Y}, @var{newmap}] =} cmpermute (@var{X}, @var{map})
+## @deftypefnx {Function File} {[@var{Y}, @var{newmap}] =} cmpermute (@var{X}, @var{map}, @var{index})
+## Reorder colors in a colormap.
+##
+## When called with only two arguments, @code{cmpermute} randomly rearranges
+## the colormap @var{map} and returns a new colormap @var{newmap}.  It also
+## returns the indexed image @var{Y} which is the equivalent of the original
+## input image @var{X} when displayed using @var{newmap}.  The input image
+## @var{X} must be an indexed image of class uint8 or double.
+##
+## When called with an optional third argument the order of colors in the
+## new colormap is defined by @var{index}.
+##
+## @strong{Caution:} @code{index} should not have repeated elements or the
+## function will fail.
+##
+## @end deftypefn
+
+## Author:  Josep Mones i Teixidor <jmones@puntbarra.com>
+
+function [Y, newmap] = cmpermute (X, map, index)
+
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+  endif
+
+  ## FIXME: Matlab only accepts 2 types.  Expand to uint16 & single??
+  if (! (isa (X, "uint8") || isa (X, "double")))
+    error ("cmpermute: X must be of class uint8 or double");
+  endif
+
+  if (! isreal (X) || issparse (X)
+      || (isfloat (X) && (any (X(:) < 1 || any (X(:) != fix (X(:)))))))
+    error ("cmpermute: X must be an indexed image");
+  endif
+
+  if (! isnumeric (map) || iscomplex (map)
+      || ndims (map) != 2 || columns (map) != 3
+      || any (map(:) < 0) || any (map(:) > 1))
+    error ("cmpermute: MAP must be a valid colormap");
+  endif
+
+  if (nargin < 3)
+    index = randperm (rows (map));
+  elseif (! isvector (index) || length (index) != rows (map))
+    error ("cmpermute: invalid parameter INDEX");
+  endif
+
+  ## new colormap
+  newmap = map(index,:);
+
+  ## build reverse index
+  rindex = zeros (size (index));
+  rindex(index) = 1:length (index);
+ 
+  ## adapt indices
+  if (isa (X, "uint8"))
+    rindex = uint8 (rindex-1);
+    ## 0-based indices
+    Y = rindex(double (X) + 1);
+  else
+    Y = rindex(X);
+  endif
+
+endfunction
+
+
+%!demo
+%! [Y, newmap] = cmpermute ([1:4], hot (4), 4:-1:1)
+%! ## colormap will be arranged in reverse order (so will image)
+
+%!shared X, map
+%! X = uint8 (magic (16));
+%! [X, map] = cmunique (X);
+
+%!test # random permutation, 0-based index
+%! [Y, newmap] = cmpermute (X, map);
+%! ## test we didn't lose colors
+%! assert (sort (map), sortrows (newmap)); 
+%! ## test if images are equal
+%! assert (map(double (X)+1), newmap(double (Y)+1));
+
+%!test # reverse map, 0-based index
+%! [Y, newmap] = cmpermute (X, map, rows (map):-1:1);
+%! ## we expect a reversed colormap
+%! assert (flipud (newmap), map);
+%! ## we expect reversed indices in image
+%! assert (X, max (Y(:)) - Y);
+
+%!shared X,map
+%! X = uint16 (magic (20));
+%! [X, map] = cmunique (X);
+
+%!test # random permutation, 1-based index
+%! [Y, newmap] = cmpermute (X, map);
+%! ## test we didn't lose colors
+%! assert (sort (map), sortrows (newmap)); 
+%! ## test if images are equal
+%! assert (map(X), newmap(Y));
+
+%!test # reverse map, 1-based index
+%! [Y, newmap] = cmpermute (X, map, rows (map):-1:1);
+%! ## we expect a reversed colormap
+%! assert (newmap (rows (newmap):-1:1,:), map);
+%! ## we expect reversed indices in image
+%! assert (X, max (Y(:)) + 1 - Y);
+
+## Test input validation
+%!error cmpermute ()
+%!error cmpermute (1,2,3,4)
+%!error <X must be of class uint8> cmpermute (uint16 (magic (16)), jet (256))
+%!error <X must be an indexed image> cmpermute (1+i, jet (256))
+%!error <X must be an indexed image> cmpermute (sparse (1), jet (256))
+%!error <X must be an indexed image> cmpermute (0, jet (256))
+%!error <X must be an indexed image> cmpermute (1.5, jet (256))
+%!error <MAP must be a valid colormap> cmpermute (1, "a")
+%!error <MAP must be a valid colormap> cmpermute (1, i)
+%!error <MAP must be a valid colormap> cmpermute (1, ones (3,3,3))
+%!error <MAP must be a valid colormap> cmpermute (1, ones (3,2))
+%!error <MAP must be a valid colormap> cmpermute (1, [-1 1 1])
+%!error <MAP must be a valid colormap> cmpermute (1, [2 1 1])
+%!error <invalid parameter INDEX> cmpermute (1, [0 1 0;1 0 1], ones (3))
+%!error <invalid parameter INDEX> cmpermute (1, [0 1 0;1 0 1], 1:3)
+
diff --git a/scripts/image/cmunique.m b/scripts/image/cmunique.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/cmunique.m
@@ -0,0 +1,204 @@
+## Copyright (C) 2004 Josep Mones i Teixidor
+## Copyright (C) 2012 Rik Wehbring 
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {[@var{Y}, @var{newmap}] =} cmunique (@var{X}, @var{map})
+## @deftypefnx {Function File} {[@var{Y}, @var{newmap}] =} cmunique (@var{RGB})
+## @deftypefnx {Function File} {[@var{Y}, @var{newmap}] =} cmunique (@var{I})
+## Convert an input image @var{X} to an ouput indexed image @var{Y} which uses
+## the smallest colormap possible @var{newmap}.
+##
+## When the input is an indexed image (@var{X} with colormap @var{map}) the 
+## output is a colormap @var{newmap} from which any repeated rows have been
+## eliminated.  The output image, @var{Y}, is the original input image with
+## the indices adjusted to match the new, possibly smaller, colormap.
+##
+## When the input is an RGB image (an @nospell{MxNx3} array), the output
+## colormap will contain one entry for every unique color in the original image.
+## In the worst case the new map could have as many rows as the number of
+## pixels in the original image.
+##
+## When the input is a grayscale image @var{I}, the output colormap will
+## contain one entry for every unique intensity value in the original image.
+## In the worst case the new map could have as many rows as the number of
+## pixels in the original image.
+##
+## Implementation Details:
+##
+## @var{newmap} is always an Mx3 matrix, even if the input image is
+## an intensity grayscale image @var{I} (all three RGB planes are
+## assigned the same value).
+##
+## The output image is of class uint8 if the size of the new colormap is
+## less than or equal to 256.  Otherwise, the output image is of class double.
+##
+## @seealso{rgb2ind, gray2ind}
+## @end deftypefn
+
+
+## Author:  Josep Mones i Teixidor <jmones@puntbarra.com>
+
+function [Y, newmap] = cmunique (X, map)
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
+
+  cls = class (X);
+  ## FIXME: Documentation accepts only 3 classes.  Could easily add 'single'.
+  if (! any (isa (X, {"uint8", "uint16", "double"})))
+    error ("cmunique: X is of invalid data type '%s'", cls);
+  endif
+
+  if (nargin == 2)
+    ## (X, map) case
+    if (! isnumeric (map) || iscomplex (map)
+        || ndims (map) != 2 || columns (map) != 3
+        || any (map(:) < 0) || any (map(:) > 1))
+      error ("cmunique: MAP must be a valid colormap");
+    endif
+    [newmap,i,j] = unique (map, "rows");  # calculate unique colormap
+    if (isa (X, "double"))
+      Y = j(X);               # find new indices
+    else
+      Y = j(double (X) + 1);  # find new indices
+    endif
+  else
+    switch (size (X,3))
+      case (1)
+        ## I case
+        [newmap,i,j] = unique (X);               # calculate unique colormap
+        newmap = repmat (newmap,1,3);            # get a RGB colormap
+        Y = reshape (j, rows (X), columns (X));  # Y is j reshaped
+      case (3)
+        ## RGB case
+        ## build a map with all values
+        map = [X(:,:,1)(:), X(:,:,2)(:), X(:,:,3)(:)];
+        [newmap,i,j] = unique (map, "rows");     # calculate unique colormap
+        Y = reshape (j, rows (X), columns (X));  # Y is j reshaped
+      otherwise
+        error ("cmunique: X is not a valid image");
+    endswitch
+    
+    ## if image was uint8 or uint16 we have to convert newmap to [0,1] range
+    if (! isa (X, "double"))
+      newmap = double (newmap) / double (intmax (class (X)));
+    endif
+  endif
+
+  if (rows (newmap) <= 256)
+    ## convert Y to uint8 (0-based indices then)
+    Y = uint8 (Y-1);
+  endif
+
+endfunction
+
+
+%!demo
+%! [Y, newmap] = cmunique ([1:4;5:8], [hot(4);hot(4)])
+%! ## Both rows are equal since map maps colors to the same value
+%! ## cmunique will give the same indices to both
+
+## Check that output is uint8 in short colormaps
+%!test
+%! [Y, newmap] = cmunique ([1:4;5:8], [hot(4);hot(4)]);
+%! assert (Y, uint8 ([0:3;0:3]));
+%! assert (newmap, hot (4));
+
+## Check that output is double in bigger
+%!test
+%! [Y, newmap] = cmunique ([1:300;301:600], [hot(300);hot(300)]);
+%! assert (Y, [1:300;1:300]);
+%! assert (newmap, hot (300));
+
+## Check boundary case 256
+%!test
+%! [Y, newmap] = cmunique ([1:256;257:512], [hot(256);hot(256)]);
+%! assert (Y, uint8 ([0:255;0:255]));
+%! assert (newmap, hot (256));
+
+## Check boundary case 257
+%!test
+%! [Y, newmap] = cmunique ([1:257;258:514], [hot(257);hot(257)]);
+%! assert (Y, [1:257;1:257]);
+%! assert (newmap, hot (257));
+
+## Random RGB image
+%!test
+%! RGB = rand (10,10,3);
+%! [Y, newmap] = cmunique (RGB);
+%! assert (RGB(:,:,1), newmap(:,1)(Y+1));
+%! assert (RGB(:,:,2), newmap(:,2)(Y+1));
+%! assert (RGB(:,:,3), newmap(:,3)(Y+1));
+
+## Random uint8 RGB image
+%!test
+%! RGB = uint8 (rand (10,10,3)*255);
+%! RGBd = double (RGB) / 255;
+%! [Y, newmap] = cmunique (RGB);
+%! assert (RGBd(:,:,1), newmap(:,1)(Y+1));
+%! assert (RGBd(:,:,2), newmap(:,2)(Y+1));
+%! assert (RGBd(:,:,3), newmap(:,3)(Y+1));
+
+## Random uint16 RGB image
+%!test
+%! RGB = uint16 (rand (10,10,3)*65535);
+%! RGBd = double (RGB) / 65535;
+%! [Y, newmap] = cmunique (RGB);
+%! assert (RGBd(:,:,1), newmap(:,1)(Y+1));
+%! assert (RGBd(:,:,2), newmap(:,2)(Y+1));
+%! assert (RGBd(:,:,3), newmap(:,3)(Y+1));
+
+## Random I image
+%!test
+%! I = rand (10,10);
+%! [Y, newmap] = cmunique (I);
+%! assert (I, newmap(:,1)(Y+1));
+%! assert (I, newmap(:,2)(Y+1));
+%! assert (I, newmap(:,3)(Y+1));
+
+## Random uint8 I image
+%!test
+%! I = uint8 (rand (10,10)*256);
+%! Id = double (I) / 255;
+%! [Y, newmap] = cmunique (I);
+%! assert (Id, newmap(:,1)(Y+1));
+%! assert (Id, newmap(:,2)(Y+1));
+%! assert (Id, newmap(:,3)(Y+1));
+
+## Random uint16 I image
+%!test
+%! I = uint16 (rand (10,10)*65535);
+%! Id = double (I) / 65535;
+%! [Y,newmap] = cmunique (I);
+%! assert (Id,newmap (:,1)(Y+1));
+%! assert (Id,newmap (:,2)(Y+1));
+%! assert (Id,newmap (:,3)(Y+1));
+
+## Test input validation
+%!error cmpermute ()
+%!error cmpermute (1,2,3)
+%!error <X is of invalid data type> cmunique (single (magic (16)))
+%!error <MAP must be a valid colormap> cmunique (1, "a")
+%!error <MAP must be a valid colormap> cmunique (1, i)
+%!error <MAP must be a valid colormap> cmunique (1, ones (3,3,3))
+%!error <MAP must be a valid colormap> cmunique (1, ones (3,2))
+%!error <MAP must be a valid colormap> cmunique (1, [-1 1 1])
+%!error <MAP must be a valid colormap> cmunique (1, [2 1 1])
+
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} imshow (@var{im})
 ## @deftypefnx {Function File} {} imshow (@var{im}, @var{limits})
 ## @deftypefnx {Function File} {} imshow (@var{im}, @var{map})
 ## @deftypefnx {Function File} {} imshow (@var{rgb}, @dots{})
 ## @deftypefnx {Function File} {} imshow (@var{filename})
 ## @deftypefnx {Function File} {} imshow (@dots{}, @var{string_param1}, @var{value1}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} imshow (@dots{})
 ## Display the image @var{im}, where @var{im} can be a 2-dimensional
-## (gray-scale image) or a 3-dimensional (RGB image) matrix.
+## (grayscale image) or a 3-dimensional (RGB image) matrix.
 ##
 ## If @var{limits} is a 2-element vector @code{[@var{low}, @var{high}]},
 ## the image is shown using a display range between @var{low} and
 ## @var{high}.  If an empty matrix is passed for @var{limits}, the
 ## display range is computed as the range between the minimal and the
 ## maximal value in the image.
 ##
 ## If @var{map} is a valid color map, the image will be shown as an indexed
diff --git a/scripts/image/module.mk b/scripts/image/module.mk
--- a/scripts/image/module.mk
+++ b/scripts/image/module.mk
@@ -1,14 +1,16 @@
 FCN_FILE_DIRS += image
 
 image_FCN_FILES = \
   image/autumn.m \
   image/bone.m \
   image/brighten.m \
+  image/cmpermute.m \
+  image/cmunique.m \
   image/colorcube.m \
   image/colormap.m \
   image/contrast.m \
   image/cool.m \
   image/copper.m \
   image/flag.m \
   image/gmap40.m \
   image/gray.m \
diff --git a/scripts/miscellaneous/fileattrib.m b/scripts/miscellaneous/fileattrib.m
--- a/scripts/miscellaneous/fileattrib.m
+++ b/scripts/miscellaneous/fileattrib.m
@@ -52,16 +52,17 @@
 ## @var{file}.
 ##
 ## @item UserExecute
 ## @itemx GroupExecute
 ## @itemx OtherExecute
 ## True if the user (group; other users) has execute permission for
 ## @var{file}.
 ## @end table
+##
 ## If an attribute does not apply (i.e., archive on a Unix system) then
 ## the field is set to NaN.
 ##
 ## With no input arguments, return information about the current
 ## directory.
 ##
 ## If @var{file} contains globbing characters, return information about
 ## all the matching files.
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -46,20 +46,20 @@ endfunction
 %! unwind_protect
 %!   filename = tmpnam;
 %!   dummy    = 1;
 %!   save (filename, "dummy");
 %!   dirname  = tmpnam;
 %!   mkdir (dirname);
 %!   entry = gzip (filename, dirname);
 %!   [path, basename, extension] = fileparts (filename);
-%!   if ! strcmp (entry, [dirname, filesep, basename, extension, ".gz"])
+%!   if (! strcmp (entry, [dirname, filesep, basename, extension, ".gz"]))
 %!     error ("gzipped file does not match expected name!");
 %!   endif
-%!   if ! exist (entry, "file")
+%!   if (! exist (entry, "file"))
 %!     error ("gzipped file cannot be found!");
 %!   endif
 %!   gunzip (entry);
 %!   if (system (sprintf ("diff %s %s%c%s%s", filename, dirname, filesep,
 %!                                            basename, extension)))
 %!     error ("unzipped file not equal to original file!");
 %!   end
 %! unwind_protect_cleanup
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -15,40 +15,45 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fminbnd (@var{fun}, @var{a}, @var{b}, @var{options})
-## Find a minimum point of a univariate function.  @var{fun} should be a
-## function
-## handle or name.  @var{a}, @var{b} specify a starting interval.  @var{options}
-## is a
-## structure specifying additional options.  Currently, @code{fminbnd}
-## recognizes these options: @code{"FunValCheck"}, @code{"OutputFcn"},
-## @code{"TolX"}, @code{"MaxIter"}, @code{"MaxFunEvals"}.
-## For description of these options, see @ref{doc-optimset,,optimset}.
+## Find a minimum point of a univariate function.
+## 
+## @var{fun} should be a function handle or name.  @var{a}, @var{b} specify a
+## starting interval.  @var{options} is a structure specifying additional
+## options.  Currently, @code{fminbnd} recognizes these options:
+## "FunValCheck", "OutputFcn", "TolX", "MaxIter", "MaxFunEvals".  For a
+## description of these options, see @ref{doc-optimset,,optimset}.
 ##
 ## On exit, the function returns @var{x}, the approximate minimum point
 ## and @var{fval}, the function value thereof.
 ## @var{info} is an exit flag that can have these values:
 ##
 ## @itemize
 ## @item 1
 ## The algorithm converged to a solution.
 ##
 ## @item 0
 ## Maximum number of iterations or function evaluations has been exhausted.
 ##
 ## @item -1
 ## The algorithm has been terminated from user output function.
 ## @end itemize
-## @seealso{optimset, fzero, fminunc}
+##
+## Notes: The search for a minimum is restricted to be in the interval
+## bound by @var{a} and @var{b}.  If you only have an initial point
+## to begin searching from you will need to use an unconstrained
+## minimization algorithm such as @code{fminunc} or @code{fminsearch}.
+## @code{fminbnd} internally uses a Golden Section search strategy.
+## @seealso{fzero, fminunc, fminsearch, optimset}
 ## @end deftypefn
 
 ## This is patterned after opt/fmin.f from Netlib, which in turn is taken from
 ## Richard Brent: Algorithms For Minimization Without Derivatives, Prentice-Hall (1973)
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fminbnd");
 
diff --git a/scripts/optimization/fminsearch.m b/scripts/optimization/fminsearch.m
new file mode 100644
--- /dev/null
+++ b/scripts/optimization/fminsearch.m
@@ -0,0 +1,352 @@
+## Copyright (C) 2003,2012 Andy Adler
+## Copyright (C) 2002 N.J.Higham
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{x} =} fminsearch (@var{fun}, @var{x0})
+## @deftypefnx {Function File} {@var{x} =} fminsearch (@var{fun}, @var{x0}, @var{options})
+## @deftypefnx {Function File} {[@var{x}, @var{fval}] =} fminsearch (@dots{})
+##
+## Find a value of @var{x} which minimizes the function @var{fun}.
+## The search begins at the point @var{x0} and iterates using the
+## Nelder & Mead Simplex algorithm (a derivative-free method).  This algorithm
+## is better-suited to functions which have discontinuities or for which
+## a gradient-based search such as @code{fminunc} fails.
+##
+## Options for the search are provided in the parameter @var{options} using 
+## the function @code{optimset}.  Currently, @code{fminsearch} accepts the
+## options: "TolX", "MaxFunEvals", "MaxIter", "Display".  For a description of
+## these options, see @code{optimset}.
+##
+## On exit, the function returns @var{x}, the minimum point,
+## and @var{fval}, the function value thereof.
+##
+## Example usages:
+##
+## @example
+## @group
+## fminsearch (@@(x) (x(1)-5).^2+(x(2)-8).^4, [0;0])
+##
+## fminsearch (inline ("(x(1)-5).^2+(x(2)-8).^4", "x"), [0;0])
+## @end group
+## @end example
+## @seealso{fminbnd, fminunc, optimset}
+## @end deftypefn
+
+## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+## PKG_ADD: [~] = __all_opts__ ("fminsearch");
+
+## FIXME: Add support for "exitflag" output variable
+## FIXME: Add support for "output" output variable
+## FIXME: For Display option, add 'final' and 'notify' options.  Not too hard.
+## FIXME: Add support for OutputFcn.  See fminunc for a template
+## FIXME: Add support for exiting based on TolFun.  See fminunc for an idea.
+
+function [x, fval] = fminsearch (fun, x0, options = struct ())
+
+  ## Get default options if requested.
+  if (nargin == 1 && ischar (fun) && strcmp (fun, "defaults"))
+    x = optimset ("Display", "notify", "FunValCheck", "off",
+                  "MaxFunEvals", 400, "MaxIter", 400,
+                  "OutputFcn", [],
+                  "TolFun", 1e-7, "TolX", 1e-4);
+    return;
+  endif
+
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+  endif
+
+  x = nmsmax (fun, x0, options);
+
+  if (isargout (2))
+    fval = feval (fun, x);
+  endif
+
+endfunction
+
+##NMSMAX  Nelder-Mead simplex method for direct search optimization.
+##        [x, fmax, nf] = NMSMAX(FUN, x0, STOPIT, SAVIT) attempts to
+##        maximize the function FUN, using the starting vector x0.
+##        The Nelder-Mead direct search method is used.
+##        Output arguments:
+##               x    = vector yielding largest function value found,
+##               fmax = function value at x,
+##               nf   = number of function evaluations.
+##        The iteration is terminated when either
+##               - the relative size of the simplex is <= STOPIT(1)
+##                 (default 1e-3),
+##               - STOPIT(2) function evaluations have been performed
+##                 (default inf, i.e., no limit), or
+##               - a function value equals or exceeds STOPIT(3)
+##                 (default inf, i.e., no test on function values).
+##        The form of the initial simplex is determined by STOPIT(4):
+##           STOPIT(4) = 0: regular simplex (sides of equal length, the default)
+##           STOPIT(4) = 1: right-angled simplex.
+##        Progress of the iteration is not shown if STOPIT(5) = 0 (default 1).
+##           STOPIT(6) indicates the direction (ie. minimization or
+##                   maximization.) Default is 1, maximization.
+##                   set STOPIT(6)=-1 for minimization
+##        If a non-empty fourth parameter string SAVIT is present, then
+##        `SAVE SAVIT x fmax nf' is executed after each inner iteration.
+##        NB: x0 can be a matrix.  In the output argument, in SAVIT saves,
+##            and in function calls, x has the same shape as x0.
+##        NMSMAX(fun, x0, STOPIT, SAVIT, P1, P2,...) allows additional
+##        arguments to be passed to fun, via feval(fun,x,P1,P2,...).
+## References:
+## N. J. Higham, Optimization by direct search in matrix computations,
+##    SIAM J. Matrix Anal. Appl, 14(2): 317-333, 1993.
+## C. T. Kelley, Iterative Methods for Optimization, Society for Industrial
+##    and Applied Mathematics, Philadelphia, PA, 1999.
+
+## From Matrix Toolbox
+## Copyright (C) 2002 N.J.Higham
+## www.maths.man.ac.uk/~higham/mctoolbox
+##
+## Modifications for Octave by A.Adler 2003
+
+function [stopit, savit, dirn, trace, tol, maxiter] = parse_options (options, x );
+
+  ## Tolerance for cgce test based on relative size of simplex.
+  stopit(1) = tol = optimget (options, "TolX", 1e-4);
+
+  ## Max no. of f-evaluations.
+  stopit(2) = optimget (options, "MaxFunEvals", length (x) * 200);
+
+  ## Max no. of iterations
+  maxiter = optimget (options, "MaxIter", length (x) * 200);
+
+  ## Default target for f-values.
+  stopit(3) = Inf;  # FIXME: expose this parameter to the outside
+
+  ## Default initial simplex.
+  stopit(4) = 0;    # FIXME: expose this parameter to the outside
+
+  ## Default: show progress.
+  display = optimget (options, "Display", "notify");
+  if (strcmp (display, "iter"))
+    stopit(5) = 1;
+  else
+    stopit(5) = 0;
+  endif
+  trace = stopit(5);
+
+  ## Use function to minimize, not maximize
+  stopit(6) = dirn = -1;
+
+  ## File name for snapshots.
+  savit = [];  # FIXME: expose this parameter to the outside
+
+endfunction
+
+function [x, fmax, nf] = nmsmax (fun, x, options, savit, varargin)
+
+  [stopit, savit, dirn, trace, tol, maxiter] = parse_options (options, x);
+
+  if (strcmpi (optimget (options, "FunValCheck", "off"), "on"))
+    ## Replace fcn with a guarded version.
+    fun = @(x) guarded_eval (fun, x);
+  endif
+
+  x0 = x(:);  # Work with column vector internally.
+  n = length (x0);
+
+  V = [zeros(n,1) eye(n)];
+  f = zeros (n+1,1);
+  V(:,1) = x0;
+  f(1) = dirn * feval (fun,x,varargin{:});
+  fmax_old = f(1);
+
+  if (trace)
+    fprintf ("f(x0) = %9.4e\n", f(1));
+  endif
+
+  k = 0; m = 0;
+
+  ## Set up initial simplex.
+  scale = max (norm (x0,Inf), 1);
+  if (stopit(4) == 0)
+    ## Regular simplex - all edges have same length.
+    ## Generated from construction given in reference [18, pp. 80-81] of [1].
+    alpha = scale / (n*sqrt (2)) * [sqrt(n+1)-1+n, sqrt(n+1)-1];
+    V(:,2:n+1) = (x0 + alpha(2)*ones (n,1)) * ones (1,n);
+    for j = 2:n+1
+      V(j-1,j) = x0(j-1) + alpha(1);
+      x(:) = V(:,j);
+      f(j) = dirn * feval (fun,x,varargin{:});
+    endfor
+  else
+    ## Right-angled simplex based on co-ordinate axes.
+    alpha = scale * ones(n+1,1);
+    for j=2:n+1
+      V(:,j) = x0 + alpha(j)*V(:,j);
+      x(:) = V(:,j);
+      f(j) = dirn * feval (fun,x,varargin{:});
+    endfor
+  endif
+  nf = n+1;
+  how = "initial  ";
+
+  [~,j] = sort (f);
+  j = j(n+1:-1:1);
+  f = f(j);
+  V = V(:,j);
+
+  alpha = 1;  beta = 1/2;  gamma = 2;
+
+  while (1)   # Outer (and only) loop.
+    k++;
+
+    if (k > maxiter)
+      msg = "Exceeded maximum iterations...quitting\n";
+      break;
+    endif
+
+    fmax = f(1);
+    if (fmax > fmax_old)
+      if (! isempty (savit))
+        x(:) = V(:,1);
+        eval (["save " savit " x fmax nf"]);
+      endif
+    endif
+    if (trace)
+      fprintf ("Iter. %2.0f,", k);
+      fprintf (["  how = " how "  "]);
+      fprintf ("nf = %3.0f,  f = %9.4e  (%2.1f%%)\n", nf, fmax, ...
+               100*(fmax-fmax_old)/(abs(fmax_old)+eps));
+    endif
+    fmax_old = fmax;
+
+    ## Three stopping tests from MDSMAX.M
+
+    ## Stopping Test 1 - f reached target value?
+    if (fmax >= stopit(3))
+      msg = "Exceeded target...quitting\n";
+      break;
+    endif
+
+    ## Stopping Test 2 - too many f-evals?
+    if (nf >= stopit(2))
+      msg = "Max no. of function evaluations exceeded...quitting\n";
+      break;
+    endif
+
+    ## Stopping Test 3 - converged?   This is test (4.3) in [1].
+    v1 = V(:,1);
+    size_simplex = norm (V(:,2:n+1)-v1(:,ones (1,n)),1) / max (1, norm (v1,1));
+    if (size_simplex <= tol)
+      msg = sprintf ("Simplex size %9.4e <= %9.4e...quitting\n", ...
+                      size_simplex, tol);
+      break;
+    endif
+
+    ##  One step of the Nelder-Mead simplex algorithm
+    ##  NJH: Altered function calls and changed CNT to NF.
+    ##       Changed each `fr < f(1)' type test to `>' for maximization
+    ##       and re-ordered function values after sort.
+
+    vbar = (sum (V(:,1:n)')/n)';  # Mean value
+    vr = (1 + alpha)*vbar - alpha*V(:,n+1);
+    x(:) = vr;
+    fr = dirn * feval (fun,x,varargin{:});
+    nf = nf + 1;
+    vk = vr;  fk = fr; how = "reflect, ";
+    if (fr > f(n))
+      if (fr > f(1))
+        ve = gamma*vr + (1-gamma)*vbar;
+        x(:) = ve;
+        fe = dirn * feval (fun,x,varargin{:});
+        nf = nf + 1;
+        if (fe > f(1))
+          vk = ve;
+          fk = fe;
+          how = "expand,  ";
+        endif
+      endif
+    else
+      vt = V(:,n+1);
+      ft = f(n+1);
+      if (fr > ft)
+        vt = vr;
+        ft = fr;
+      endif
+      vc = beta*vt + (1-beta)*vbar;
+      x(:) = vc;
+      fc = dirn * feval (fun,x,varargin{:});
+      nf = nf + 1;
+      if (fc > f(n))
+        vk = vc; fk = fc;
+        how = "contract,";
+      else
+        for j = 2:n
+          V(:,j) = (V(:,1) + V(:,j))/2;
+          x(:) = V(:,j);
+          f(j) = dirn * feval (fun,x,varargin{:});
+        endfor
+        nf = nf + n-1;
+        vk = (V(:,1) + V(:,n+1))/2;
+        x(:) = vk;
+        fk = dirn * feval (fun,x,varargin{:});
+        nf = nf + 1;
+        how = "shrink,  ";
+      endif
+    endif
+    V(:,n+1) = vk;
+    f(n+1) = fk;
+    [~,j] = sort(f);
+    j = j(n+1:-1:1);
+    f = f(j);
+    V = V(:,j);
+
+  endwhile   # End of outer (and only) loop.
+
+  ## Finished.
+  if (trace)
+    fprintf (msg);
+  endif
+  x(:) = V(:,1);
+
+endfunction
+
+## A helper function that evaluates a function and checks for bad results.
+function y = guarded_eval (fun, x)
+
+  y = fun (x);
+
+  if (! (isreal (f)))
+    error ("fminsearch:notreal", "fminsearch: non-real value encountered");
+  elseif (any (isnan (f(:))))
+    error ("fminsearch:isnan", "fminsearch: NaN value encountered");
+  elseif (any (isinf (f(:))))
+    error ("fminsearch:isinf", "fminsearch: Inf value encountered");
+  endif
+
+endfunction
+
+
+%!demo
+%! fcn = @(x) (x(1)-5).^2 + (x(2)-8).^4
+%! x0 = [0;0];
+%! [xmin, fval] = fminsearch (fcn, x0)
+
+%!assert (fminsearch (@sin, 3, optimset ("MaxIter", 3)), 4.8750, 1e-4)
+%!assert (fminsearch (@sin, 3, optimset ("MaxIter", 30)), 4.7124, 1e-4)
+%!shared c
+%! c = 1.5;
+%!assert (fminsearch (@(x) x(1).^2+c*x(2).^2,[1;1]), [0;0], 1e-4)
+
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -19,16 +19,17 @@
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fminunc (@var{fcn}, @var{x0})
 ## @deftypefnx {Function File} {} fminunc (@var{fcn}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{fvec}, @var{info}, @var{output}, @var{grad}, @var{hess}] =} fminunc (@var{fcn}, @dots{})
 ## Solve an unconstrained optimization problem defined by the function
 ## @var{fcn}.
+##
 ## @var{fcn} should accepts a vector (array) defining the unknown variables,
 ## and return the objective function value, optionally with gradient.
 ## In other words, this function attempts to determine a vector @var{x} such
 ## that @code{@var{fcn} (@var{x})} is a local minimum.
 ## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
 ## in all calls to @var{fcn}, but otherwise is treated as a column vector.
 ## @var{options} is a structure specifying additional options.
 ## Currently, @code{fminunc} recognizes these options:
@@ -67,19 +68,22 @@
 ## @item -3
 ## The trust region radius became excessively small.
 ## @end table
 ##
 ## Optionally, fminunc can also yield a structure with convergence statistics
 ## (@var{output}), the output gradient (@var{grad}) and approximate Hessian
 ## (@var{hess}).
 ##
-## Note: If you only have a single nonlinear equation of one variable, using
-## @code{fminbnd} is usually a much better idea.
-## @seealso{fminbnd, optimset}
+## Notes: If you only have a single nonlinear equation of one variable then
+## using @code{fminbnd} is usually a much better idea.  The algorithm used is a
+## gradient search which depends on the objective function being differentiable.
+## If the function has discontinuities it may be better to use a derivative-free
+## algorithm such as @code{fminsearch}.
+## @seealso{fminbnd, fminsearch, optimset}
 ## @end deftypefn
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fminunc");
 
 function [x, fval, info, output, grad, hess] = fminunc (fcn, x0, options = struct ())
 
   ## Get default options if requested.
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -364,40 +364,43 @@
 ## Problem has no feasible solution.
 ##
 ## @item 184 (@w{@code{LPX_UNBND}})
 ## Problem has no unbounded solution.
 ##
 ## @item 185 (@w{@code{LPX_UNDEF}})
 ## Solution status is undefined.
 ## @end table
+##
 ## Interior Point Method:
 ##
 ## @table @asis
 ## @item 150 (@w{@code{LPX_T_UNDEF}})
 ## The interior point method is undefined.
 ##
 ## @item 151 (@w{@code{LPX_T_OPT}})
 ## The interior point method is optimal.
 ## @end table
+##
 ## Mixed Integer Method:
 ##
 ## @table @asis
 ## @item 170 (@w{@code{LPX_I_UNDEF}})
 ## The status is undefined.
 ##
 ## @item 171 (@w{@code{LPX_I_OPT}})
 ## The solution is integer optimal.
 ##
 ## @item 172 (@w{@code{LPX_I_FEAS}})
 ## Solution integer feasible but its optimality has not been proven
 ##
 ## @item 173 (@w{@code{LPX_I_NOFEAS}})
 ## No integer feasible solution.
 ## @end table
+##
 ## @noindent
 ## If an error occurs, @var{status} will contain one of the following
 ## codes:
 ##
 ## @table @asis
 ## @item 204 (@w{@code{LPX_E_FAULT}})
 ## Unable to start the search.
 ##
diff --git a/scripts/optimization/module.mk b/scripts/optimization/module.mk
--- a/scripts/optimization/module.mk
+++ b/scripts/optimization/module.mk
@@ -1,16 +1,17 @@
 FCN_FILE_DIRS += optimization
 
 optimization_PRIVATE_FCN_FILES = \
   optimization/private/__fdjac__.m
 
 optimization_FCN_FILES = \
   optimization/__all_opts__.m \
   optimization/fminbnd.m \
+  optimization/fminsearch.m \
   optimization/fminunc.m \
   optimization/fsolve.m \
   optimization/fzero.m \
   optimization/glpk.m \
   optimization/lsqnonneg.m \
   optimization/optimget.m \
   optimization/optimset.m \
   optimization/pqpnonneg.m \
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -21,26 +21,44 @@
 ## @deftypefn  {Function File} {} optimset ()
 ## @deftypefnx {Function File} {} optimset (@var{par}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {} optimset (@var{old}, @var{par}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {} optimset (@var{old}, @var{new})
 ## Create options struct for optimization functions.
 ##
 ## Valid parameters are:
 ##
-## @itemize @bullet
+## @table @asis
 ## @item AutoScaling
 ##
 ## @item ComplexEqn
 ##
+## @item Display
+## Request verbose display of results from optimizations.  Values are:
+##
+## @table @asis
+## @item "off" [default]
+## No display.
+##
+## @item "iter"
+## Display intermediate results for every loop iteration.
+##
+## @item "final"
+## Display the result of the final loop iteration.
+##
+## @item "notify"
+## Display the result of the final loop iteration if the function has
+## failed to converge.
+## @end table
+##
 ## @item FinDiffType
 ##
 ## @item FunValCheck
 ## When enabled, display an error if the objective function returns an invalid
-## value (a complex value, NaN, or Inf).  Must be set to "on" or "off"
+## value (a complex number, NaN, or Inf).  Must be set to "on" or "off"
 ## [default].  Note: the functions @code{fzero} and @code{fminbnd} correctly
 ## handle Inf values and only complex values or NaN will cause an error in this
 ## case. 
 ##
 ## @item GradObj
 ## When set to "on", the function to be minimized must return a second argument
 ## which is the gradient, or first derivative, of the function at the point
 ## @var{x}.  If set to "off" [default], the gradient is computed via finite
@@ -72,17 +90,17 @@
 ## @item TolX
 ## Termination criterion for the function input.  If the difference in @var{x},
 ## the current search point, between one algorithm iteration and the next is
 ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
 ##
 ## @item TypicalX
 ##
 ## @item Updating
-## @end itemize
+## @end table
 ## @end deftypefn
 
 function retval = optimset (varargin)
 
   nargs = nargin ();
 
   ## Add more as needed.
   opts = __all_opts__ ();
diff --git a/scripts/pkg/module.mk b/scripts/pkg/module.mk
--- a/scripts/pkg/module.mk
+++ b/scripts/pkg/module.mk
@@ -1,12 +1,11 @@
 FCN_FILE_DIRS += pkg
 
 pkg_PRIVATE_FCN_FILES = \
-  pkg/private/absolute_pathname.m \
   pkg/private/build.m \
   pkg/private/configure_make.m \
   pkg/private/copy_files.m \
   pkg/private/create_pkgadddel.m \
   pkg/private/describe.m \
   pkg/private/dirempty.m \
   pkg/private/extract_pkg.m \
   pkg/private/finish_installation.m \
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -416,77 +416,76 @@ function [local_packages, global_package
       if (length (files) == 0 && nargout == 0)
         printf ("Installation prefix:             %s\n", prefix);
         printf ("Architecture dependent prefix:   %s\n", archprefix);
       elseif (length (files) == 0 && nargout >= 1)
         local_packages = prefix;
         global_packages = archprefix;
       elseif (length (files) >= 1 && nargout <= 2 && ischar (files{1}))
         prefix = files{1};
-        try
-          prefix = absolute_pathname (prefix);
-        catch
+        if (! exist (prefix, "dir"))
           [status, msg, msgid] = mkdir (prefix);
           if (status == 0)
             error("cannot create prefix %s: %s", prefix, msg);
           endif
           warning ("creating the directory %s\n", prefix);
-          prefix = absolute_pathname (prefix);
-        end_try_catch
-        prefix = absolute_pathname (prefix);
-        local_packages = prefix;
+        endif
+        local_packages = prefix = canonicalize_filename (prefix);
         user_prefix = true;
         if (length (files) >= 2 && ischar (files{2}))
           archprefix = files{2};
-          try
-            archprefix = absolute_pathname (archprefix);
-          catch
+          if (! exist (archprefix, "dir"))
             [status, msg, msgid] = mkdir (archprefix);
             if (status == 0)
               error("cannot create archprefix %s: %s", archprefix, msg);
             endif
             warning ("creating the directory %s\n", archprefix);
-            archprefix = absolute_pathname (archprefix);
-          end_try_catch
-          global_packages = archprefix;
+            global_packages = archprefix = canonicalize_file_name (archprefix);
+          endif
         endif
       else
         error ("you must specify a prefix directory, or request an output argument");
       endif
-
+      
     case "local_list"
       if (length (files) == 0 && nargout == 0)
         disp (local_list);
       elseif (length (files) == 0 && nargout == 1)
         local_packages = local_list;
       elseif (length (files) == 1 && nargout == 0 && ischar (files{1}))
-        try
-          local_list = absolute_pathname (files{1});
-        catch
-          ## Force file to be created
-          fclose (fopen (files{1}, "wt"));
-          local_list = absolute_pathname (files{1});
-        end_try_catch
+        local_list = files{1};
+        if (! exist (local_list, "file"))          
+          try
+            ## Force file to be created
+            fclose (fopen (local_list, "wt"));
+          catch
+            error ("cannot create file %s", local_list);
+          end_try_catch
+        endif
+        local_list = canonicalize_file_name (local_list);
       else
         error ("you must specify a local_list file, or request an output argument");
       endif
 
     case "global_list"
       if (length (files) == 0 && nargout == 0)
         disp(global_list);
       elseif (length (files) == 0 && nargout == 1)
         local_packages = global_list;
       elseif (length (files) == 1 && nargout == 0 && ischar (files{1}))
-        try
-          global_list = absolute_pathname (files{1});
-        catch
-          ## Force file to be created
-          fclose (fopen (files{1}, "wt"));
-          global_list = absolute_pathname (files{1});
-        end_try_catch
+        global_list = files{1};
+        if (! exist (global_list, "file"))  
+          try
+            ## Force file to be created
+            fclose (fopen (files{1}, "wt"));
+          catch
+            error ("cannot create file %s", global_list);
+          end_try_catch
+        endif
+        global_list = canonicalize_file_name (global_list);
       else
         error ("you must specify a global_list file, or request an output argument");
       endif
 
     case "rebuild"
       if (global_install)
         global_packages = rebuild (prefix, archprefix, global_list, files,
                                    auto, verbose);
diff --git a/scripts/pkg/private/absolute_pathname.m b/scripts/pkg/private/absolute_pathname.m
deleted file mode 100644
--- a/scripts/pkg/private/absolute_pathname.m
+++ /dev/null
@@ -1,33 +0,0 @@
-## Copyright (C) 2005-2012 S√∏ren Hauberg
-## Copyright (C) 2010 VZLU Prague, a.s.
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{pth} =} absolute_pathname (@var{pth})
-## Undocumented internal function.
-## @end deftypefn
-
-function pth = absolute_pathname (pth)
-  [status, msg, msgid] = fileattrib (pth);
-  if (status != 1)
-    error ("could not find the file or path %s", pth);
-  else
-    pth = msg.Name;
-  endif
-endfunction
-
diff --git a/scripts/pkg/private/build.m b/scripts/pkg/private/build.m
--- a/scripts/pkg/private/build.m
+++ b/scripts/pkg/private/build.m
@@ -29,17 +29,20 @@ function build (files, handle_deps, auto
   builddir = files{1};
   if (! exist (builddir, "dir"))
     warning ("creating build directory %s", builddir);
     [status, msg] = mkdir (builddir);
     if (status != 1)
       error ("could not create installation directory: %s", msg);
     endif
   endif
-  builddir = absolute_pathname (builddir);
+  [builddir, status] = canonicalize_file_name (builddir);
+  if (! status)
+    error ("cannot find directory %s", builddir);
+  endif
   installdir = fullfile (builddir, "install");
   if (! exist (installdir, "dir"))
     [status, msg] = mkdir (installdir);
     if (status != 1)
       error ("could not create installation directory: %s", msg);
     endif
   endif
   files(1) = [];
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -104,16 +104,17 @@
 ##
 ## @item "label[xyz]"
 ## Turn tic labels on for all axes, or turn them on for the
 ## specified axes and off for the remainder.
 ##
 ## @item "nolabel"
 ## Turn tic labels off for all axes.
 ## @end table
+##
 ## Note, if there are no tic marks for an axis, there can be no labels.
 ##
 ## @noindent
 ## The following options affect the direction of increasing values on
 ## the axes.
 ##
 ## @table @asis
 ## @item "ij"
diff --git a/scripts/plot/copyobj.m b/scripts/plot/copyobj.m
--- a/scripts/plot/copyobj.m
+++ b/scripts/plot/copyobj.m
@@ -10,61 +10,99 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn   {Function File} {@var{hnew} =} copyobj (@var{horig})
-## @deftypefnx  {Function File} {@var{hnew} =} copyobj (@var{horig}, @var{hparent})
-## Constructs a copy of the object associated with handle @var{horig}
-## and returns a handle, @var{hnew}, to the new object.
-## If a parent handle @var{hparent} (root, figure, axes or hggroup) is specified,
-## the copied object will be created as a child to @var{hparent}.
+## @deftypefn  {Function File} {@var{hnew} =} copyobj (@var{horig})
+## @deftypefnx {Function File} {@var{hnew} =} copyobj (@var{horig}, @var{hparent})
+## Construct a copy of the object associated with handle @var{horig}
+## and return a handle @var{hnew} to the new object.
+## If a parent handle @var{hparent} (root, figure, axes, or hggroup) is
+## specified, the copied object will be created as a child to @var{hparent}.
 ## @seealso{findobj, get, set, struct2hdl, hdl2struct}
 ## @end deftypefn
 
 ## Author: pdiribarne <pdiribarne@new-host.home>
 ## Created: 2012-04-01
 
-function hout = copyobj (hin, hpar = 0)
+function hnew = copyobj (horig, hparent = 0)
 
   partypes = {"root", "figure", "axes", "hggroup"};
   othertypes = {"line", "patch", "surface", "image", "text"};
   alltypes = [partypes othertypes];
 
-  if (! ishandle (hin) || nargin > 2)
+  if (! ishandle (horig) || nargin > 2)
     print_usage ();
-  elseif (! ishandle (hpar))
-    hpar = figure (floor (hpar));
-  elseif (! any (strcmpi (get (hpar).type, partypes)))
+  elseif (! ishandle (hparent))
+    hparent = figure (fix (hparent));
+  elseif (! any (strcmpi (get (hparent).type, partypes)))
     print_usage ();
   endif
 
   ## compatibility of input handles
-  kididx = find (strcmp (alltypes, get (hin).type));
-  paridx = find (strcmp (alltypes, get (hpar).type));
+  kididx = find (strcmp (alltypes, get (horig).type));
+  paridx = find (strcmp (alltypes, get (hparent).type));
 
   if (kididx <= paridx)
     error ("copyobj: %s object can't be children to %s.",
-           alltypes{kididx}, alltypes{paridx})
-  elseif nargin == 1
-    str = hdl2struct (hin);
-    hout = struct2hdl (str);
+           alltypes{kididx}, alltypes{paridx});
+  elseif (nargin == 1)
+    str = hdl2struct (horig);
+    hnew = struct2hdl (str);
   else
-    str = hdl2struct (hin);
-    hout = struct2hdl (str, hpar);
+    str = hdl2struct (horig);
+    hnew = struct2hdl (str, hparent);
   endif
+
 endfunction
 
+
+%!demo
+%! hdl = figure (1234);
+%! clf;
+%! hold on;
+%! x = 1:10;
+%! y = x.^2;
+%! dy = 2 * (.2 * x);
+%! y2 = (x - 3).^2;
+%! hg = errorbar (x, y, dy,'#~');
+%! set (hg, 'marker', '^', 'markerfacecolor', rand (1,3));
+%! plot (x, y2, 'ok-');
+%! legend ('errorbar', 'line');
+%! hnew = copyobj (hdl);
+
+%!demo
+%! ## FIXME: This demo fails occasionally for an obscure reason.
+%! ## It appears that there is something wrong with Octave code for patches.
+%! hdl = figure (1234);
+%! clf;
+%! subplot (2,2,1);
+%! hold on;
+%! contourf (rand (10, 10));
+%! colorbar;
+%! subplot (2,2,2);
+%! quiver (rand (10, 10), rand (10, 10));
+%! subplot (2,2,3);
+%! colormap (jet (64));
+%! hold on;
+%! sombrero;
+%! colorbar ('peer', gca, 'NorthOutside');
+%! subplot (2,2,4);
+%! imagesc (rand (30, 30));
+%! text (15, 15, 'Rotated text', ...
+%!      'HorizontAlalignment', 'Center', 'Rotation', 30);
+%! hnew = copyobj (hdl);
+
 %!test
 %! h1 = figure ();
-%! set (h1, "visible", "off")
+%! set (h1, "visible", "off");
 %! x = 0:0.1:2*pi;
 %! y1 = sin (x);
 %! y2 = exp (x - 1);
 %! ax = plotyy (x,y1, x-1,y2, @plot, @semilogy);
 %! xlabel ("X");
 %! ylabel (ax(1), "Axis 1");
 %! ylabel (ax(2), "Axis 2");
 %! axes (ax(1));
@@ -74,54 +112,19 @@ endfunction
 %! text (4.5, 80, "Right Axis", ...
 %!       "color", [0 0.5 0], "horizontalalignment", "center");
 %! s1 = hdl2struct (h1);
 %! h2 = struct2hdl (s1);
 %! s2 = hdl2struct (h2);
 %! png1 = strcat (tmpnam (), ".png");
 %! png2 = strcat (tmpnam (), ".png");
 %! unwind_protect
-%!   print (h1, png1)
+%!   print (h1, png1);
 %!   [img1, map1, alpha1] = imread (png1);
-%!   print (h2, png2)
+%!   print (h2, png2);
 %!   [img2, map2, alpha2] = imread (png2);
 %! unwind_protect_cleanup
 %!   unlink (png1);
 %!   unlink (png2);
 %! end_unwind_protect
-%! assert (img1, img2)
-%! assert (map1, map2)
-%! assert (alpha1, alpha2)
-
-%!demo
-%! hdl = figure (1234);
-%! clf ()
-%! hold on
-%! x = 1:10;
-%! y = x.^2;
-%! dy = 2 * (.2 * x);
-%! y2 = (x - 3).^2;
-%! hg = errorbar (x, y, dy,'#~');
-%! set (hg, 'marker', '^', 'markerfacecolor', rand(1,3))
-%! plot (x, y2, 'ok-')
-%! legend ('errorbar', 'line')
-%! hout = copyobj (1234);
-
-%!demo
-%! hdl = figure (1234);
-%! clf ()
-%! subplot (2, 2, 1);
-%! hold on
-%! [C, H] = contourf (rand(10, 10));
-%! colorbar
-%! subplot (2, 2, 2);
-%! hold on
-%! quiver (rand(10, 10), rand(10, 10))
-%! subplot (2, 2, 3);
-%! colormap (jet (64))
-%! sombrero;
-%! colorbar('peer', gca, 'NorthOutside')
-%! subplot (2, 2, 4);
-%! imagesc (rand (30, 30));
-%! text (15, 15, 'Rotated text', ...
-%!      'HorizontAlalignment', 'Center', 'Rotation', 30);
-%! hout = copyobj (1234);
-
+%! assert (img1, img2);
+%! assert (map1, map2);
+%! assert (alpha1, alpha2);
diff --git a/scripts/plot/findfigs.m b/scripts/plot/findfigs.m
--- a/scripts/plot/findfigs.m
+++ b/scripts/plot/findfigs.m
@@ -42,17 +42,17 @@ function findfigs ()
 
   ## give the monitor a margin so that the figure must not just
   ## marginally be on the monitor.
   margin = 30;
   screensize(1:2) += margin;
   screensize(3:4) -= margin;
 
   for i = 1:numel (figh)
-    if strcmp (get (figh(i), "visible"), "on")
+    if (strcmp (get (figh(i), "visible"), "on"))
 
       units = get (figh(i), "units");
       unwind_protect
         if (!strcmp (units, "pixels"))
           set (figh(i), "units", "pixels");
         endif
         pos = get (figh(i), "position");
         ## Test if (in order):
diff --git a/scripts/plot/gco.m b/scripts/plot/gco.m
--- a/scripts/plot/gco.m
+++ b/scripts/plot/gco.m
@@ -15,28 +15,28 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} gco ()
 ## @deftypefnx {Function File} {@var{h} =} gco (@var{fig})
 ## Return a handle to the current object of the current figure, or a handle
-## to the current object of the figure with handle @var{fig}. The current
-## object of a figure is the object that was last clicked on. It is stored
+## to the current object of the figure with handle @var{fig}.  The current
+## object of a figure is the object that was last clicked on.  It is stored
 ## in the CurrentObject property of the target figure.
 ##
 ## If the last mouse click didn't occur on any child object of the figure,
 ## the current object is the figure itself.
 ##
-## If no mouse click occured in the target figure, this function returns and
+## If no mouse click occured in the target figure, this function returns an
 ## empty matrix.
 ##
 ## Note that the value returned by this function is not necessarily the same
-## as the one returned by gcbo during callback execution. An executing
+## as the one returned by gcbo during callback execution.  An executing
 ## callback can be interrupted by another callback and the current object
 ## can be modified.
 ##
 ##@seealso{gcbo, gcf}
 ##@end deftypefn
 
 function h = gco ()
 
diff --git a/scripts/plot/hdl2struct.m b/scripts/plot/hdl2struct.m
--- a/scripts/plot/hdl2struct.m
+++ b/scripts/plot/hdl2struct.m
@@ -10,104 +10,105 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{s} =} hdl2struct (@var{h})
-## Returns a structure, @var{s}, whose fields describe the properties
+## @deftypefn {Function File} {@var{s} =} hdl2struct (@var{h})
+## Return a structure, @var{s}, whose fields describe the properties
 ## of the object, and its children, associated with the handle, @var{h}.
 ## The fields of the structure, @var{s}, are "type", "handle", "properties",
 ## "children" and "special".
 ## @seealso{findobj, get, set, struct2hdl}
 ## @end deftypefn
 
 ## Author: pdiribarne <pdiribarne@new-host.home>
 ## Created: 2012-03-04
 
-function hgS = hdl2struct (h)
+function s = hdl2struct (h)
+
   if (nargin != 1 || !ishandle (h))
     print_usage ();
   endif
 
   hiddenh = get (0, "showhiddenhandles");
-  if strcmp (hiddenh, "on")
+  if (strcmp (hiddenh, "on"))
     set (0, "showhiddenhandles", "off");
   endif
 
   ## main object
   main = get (h);
-  hgS.handle = h;
-  hgS.type =  main.type;
-  hgS.properties  = getprops (h);
-  hgS.children = [];
-  hgS.special = [];
+  s.handle = h;
+  s.type =  main.type;
+  s.properties  = getprops (h);
+  s.children = [];
+  s.special = [];
 
   ## sweep all children but legends, colorbars, uimenu and hggroup children
   ## in reverse order
   kids = main.children;
   lg = findobj (h, "-depth", 1, "tag", "legend");
   cb = findobj (h, "-depth", 1, "tag", "colorbar");
   ui = findobj (h, "-depth", 1, "type", "uimenu");
   nkids = length (kids);
   ii = 0;
-  while nkids
-    if (! any (kids (nkids) == lg) && !any (kids (nkids) == cb)
-          && ! any (kids (nkids) == ui) && !strcmpi (main.type, "hggroup"))
+  while (nkids)
+    if (! any (kids (nkids) == lg) && ! any (kids (nkids) == cb)
+          && ! any (kids (nkids) == ui) && ! strcmp (main.type, "hggroup"))
       ii++;
-      hgS.children(ii) = hdl2struct(kids(nkids));
+      s.children(ii) = hdl2struct (kids(nkids));
     endif
     nkids--;
   endwhile
 
   ## add non "children" children objects (title, xlabel, ...) and
   ## hggroup children and tag theim in "special"
   special = [];
-  if (strcmpi (main.type, "hggroup"))
+  if (strcmp (main.type, "hggroup"))
     special = main.children;
   endif
   special = [special getspecial(h)];
   nsp = length (special);
-  while nsp
+  while (nsp)
     ii++;
-    hgS.children(ii) = hdl2struct (special(nsp));
-    hgS.special(nsp) = ii;
+    s.children(ii) = hdl2struct (special(nsp));
+    s.special(nsp) = ii;
     nsp--;
   endwhile
 
   ## look for legends and colorbars among "main"'s brothers and add them
   ## to the children list
-  if (strcmpi (main.type, "axes"))
+  if (strcmp (main.type, "axes"))
     par = main.parent;
     lg = findobj (par, "-depth", 1, "tag", "legend");
-    if !isempty (lg)
+    if (! isempty (lg))
       idx = arrayfun (@(x) get(x).userdata.handle(end) == h, lg);
-      lg = lg(find(idx));
+      lg = lg(find (idx));
     endif
     nlg = length (lg);
-    if nlg == 1
+    if (nlg == 1)
       ii++;
-      hgS.children(ii) = hdl2struct (lg);
+      s.children(ii) = hdl2struct (lg);
     elseif (nlg > 1)
       error ("hdl2struct: more than one legend found")
     endif
 
     cb = findobj (par, "-depth", 1, "tag", "colorbar");
     if (! isempty (cb))
       idx = arrayfun (@(x) get(x).axes == h, cb);
-      cb = cb(find(idx));
+      cb = cb(find (idx));
     endif
 
     ncb = length (cb);
     if (ncb == 1)
       ii++;
-      hgS.children(ii) = hdl2struct(cb);
+      s.children(ii) = hdl2struct (cb);
     elseif (nlg > 1)
       error ("hdl2struct: more than one colorbar found")
     endif
   endif
 
   set (0, "showhiddenhandles", hiddenh);
 
 endfunction
@@ -144,23 +145,26 @@ function prpstr = getprops (h)
             "currentpoint", "extent"};
 
   nflds = length (fields);
   ii = 0;
   while nflds
     prop = fields{nflds};
     val = obj.(fields{nflds});
     ii++;
-    if !any (strcmp (prop, forbid))
+    if (! any (strcmp (prop, forbid)))
       prpstr.(prop) = val;
     endif
     nflds--;
   endwhile
 
   ## hidden properties
   hidden = {"autopos_tag", "looseinset"};
   for ii = 1:numel (hidden)
     if (isprop (h, hidden{ii}))
       prpstr.(hidden{ii}) = get (h, hidden{ii});
     endif
   endfor
+
 endfunction
 
+
+## FIXME: need validation tests
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -200,10 +200,25 @@ function retval = plot (varargin)
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
-%% FIXME: Need demo or test for function
+%!demo
+%! x = 1:5;  y = 1:5;
+%! plot (x,y,'g');
+%! title ('plot of green line at 45 degrees');
 
+%!demo
+%! x = 1:5;  y = 1:5;
+%! plot (x,y,'g*');
+%! title ('plot of green stars along a line at 45 degrees');
+
+%!demo
+%! x1 = 1:5;  y1 = 1:5;
+%! x2 = 5:9; y2 = 5:-1:1;
+%! plot (x1,y1,'bo-', x2,y2,'rs-');
+%! axis ('tight');
+%! title ('plot of blue circles ascending and red squares descending with connecting lines drawn'); 
+
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -99,17 +99,17 @@ function h = slice (varargin)
   elseif (nargs == 7)
     v = varargin{4};
     if (ndims (v) != 3)
       error ("slice: expect 3-dimensional array of values");
     endif
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
-    if (isvector (x) && isvector (y) && isvector (z)]))
+    if (isvector (x) && isvector (y) && isvector (z))
       [x, y, z] = meshgrid (x, y, z);
     elseif (ndims (x) == 3 && size_equal (x, y, z))
       ## Do nothing.
     else
       error ("slice: X, Y, Z size mismatch");
     endif
     sx = varargin{5};
     sy = varargin{6};
diff --git a/scripts/plot/struct2hdl.m b/scripts/plot/struct2hdl.m
--- a/scripts/plot/struct2hdl.m
+++ b/scripts/plot/struct2hdl.m
@@ -13,603 +13,605 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{h} =} struct2hdl (@var{s})
 ## @deftypefnx {Function File} {@var{h} =} struct2hdl (@var{s}, @var{p})
 ## @deftypefnx {Function File} {@var{h} =} struct2hdl (@var{s}, @var{p}, @var{hilev})
-## Constructs an object from the structure @var{s}. The structure must
-## contain the fields "handle", "type", "children", "properties", and
+## Construct a handle object @var{h} from the structure @var{s}.  The structure
+## must contain the fields "handle", "type", "children", "properties", and
 ## "special".  If the handle of an existing figure or axes is specified,
-## @var{p}, the new object will be created as a child to that object.
-## If no object handle is provided, then a new figure and the necessary
+## @var{p}, the new object will be created as a child of that object.
+## If no object handle is provided then a new figure and the necessary
 ## children will be constructed using the default object values from
 ## the root figure.
 ##
-## A third boolean argument @var{hilev} can be passed to specify wether
-## the function should try to preserve listeners/calbacks e.g for
-## legends or hggroups. Default is false.
-## @seealso{findobj, get, hdl2struct, set}
+## A third boolean argument @var{hilev} can be passed to specify whether
+## the function should try to preserve listeners/callbacks, e.g., for
+## legends or hggroups.  The default is false.
+## @seealso{hdl2struct, findobj, get, set}
 ## @end deftypefn
 
 ## Author: pdiribarne <pdiribarne@new-host.home>
 ## Created: 2012-03-04
 
-function [ h, matchout ] = struct2hdl (hgS, matchin=[], hilev = false)
+function [h, pout] = struct2hdl (s, p=[], hilev = false)
 
-  fields = { "handle", "type", "children", "properties", "special"};
+  fields = {"handle", "type", "children", "properties", "special"};
   partypes = {"root", "figure", "axes", "hggroup"};
   othertypes = {"line", "patch", "surface", "image", "text"};
   alltypes = [partypes othertypes];
 
-  if (nargin > 3 || ! isstruct (hgS))
+  if (nargin > 3 || ! isstruct (s))
     print_usage ();
-  elseif (! all (isfield (hgS, fields)))
+  elseif (! all (isfield (s, fields)))
     print_usage ();
-  elseif (isscalar (matchin))
-    if (! ishandle (matchin))
-      error ("struct2hdl: argument #2 is not a handle to graphic object")
+  elseif (isscalar (p))
+    if (! ishandle (p))
+      error ("struct2hdl: P is not a handle to a graphic object");
     endif
-    if (any (strcmp (get (matchin).type, partypes)))
-      paridx = find (strcmp (get (matchin).type, alltypes));
-      kididx = find (strcmp (hgS.type, alltypes));
+    if (any (strcmp (get (p).type, partypes)))
+      paridx = find (strcmp (get (p).type, alltypes));
+      kididx = find (strcmp (s.type, alltypes));
       if (kididx <= paridx)
-        error ("struct2hdl: incompatible input handles")
+        error ("struct2hdl: incompatible input handles");
       endif
     else
-      error ("struct2hdl: %s object can't be parent object", get (matchin).type)
+      error ("struct2hdl: %s object can't be parent object", get (p).type);
     endif
-    hpar = matchin;
-    matchin = [NaN; hpar];
+    hpar = p;
+    p = [NaN; hpar];
     ## create appropriate parent if needed
-    if (any (strcmp (hgS.type, othertypes)))
+    if (any (strcmp (s.type, othertypes)))
       for ii = (paridx+1) : (numel (partypes)-1)
         eval (["hpar = " partypes{ii} "(\"parent\", hpar);"]);
-        matchin = [matchin [NaN; hpar]];
+        p = [p [NaN; hpar]];
       endfor
-    elseif (any (strcmp (hgS.type, {"hggroup", "axes"})))
+    elseif (any (strcmp (s.type, {"hggroup", "axes"})))
       for ii = (paridx+1) : (kididx-1)
         eval (["hpar = " partypes{ii} "(\"parent\", hpar);"]);
-        matchin = [matchin [NaN; hpar]];
+        p = [p [NaN; hpar]];
       endfor
     else
       par = NaN;
     endif
-  elseif (isempty (matchin))
-    if (any (strcmp (hgS.type, othertypes)))
+  elseif (isempty (p))
+    if (any (strcmp (s.type, othertypes)))
       par = axes ();
-    elseif (any (strcmp (hgS.type, {"hggroup", "axes"})))
+    elseif (any (strcmp (s.type, {"hggroup", "axes"})))
       par = figure ();
     else
       par = NaN;
     endif
-    matchin = [NaN; par];
+    p = [NaN; par];
   endif
-  ## read parent (last column) in matchin and remove it if duplicate
-  par = matchin (2,end);
-  tst = find (matchin (2,:) == par);
+  ## read parent (last column) in p and remove it if duplicate
+  par = p(2,end);
+  tst = find (p(2,:) == par);
   if (numel (tst) > 1)
-    matchin = matchin (1:2, 1:(tst(end)-1));
+    p = p(1:2, 1:(tst(end)-1));
   endif
 
   ## create object
-  if (strcmpi (hgS.type, "root"))
+  if (strcmp (s.type, "root"))
     h = 0;
-    hgS.properties = rmfield (hgS.properties, ...
+    s.properties = rmfield (s.properties, ...
                               {"callbackobject", "commandwindowsize", ...
                                "screendepth", "screenpixelsperinch", ...
                                "screensize"});
-  elseif (strcmpi (hgS.type, "figure"))
+  elseif (strcmp (s.type, "figure"))
     h = figure ();
-  elseif (strcmpi (hgS.type, "axes"))
+  elseif (strcmp (s.type, "axes"))
     ## legends and colorbars are "transformed" in normal axes
     ## if hilev is not requested
     if (! hilev)
-      if (strcmp (hgS.properties.tag, "legend"))
-        hgS.properties.tag = "";
-        hgS.properties.userdata = [];
+      if (strcmp (s.properties.tag, "legend"))
+        s.properties.tag = "";
+        s.properties.userdata = [];
         par = gcf;
-      elseif (strcmp (hgS.properties.tag, "colorbar"))
-        hgS.properties.tag = "";
-        hgS.properties.userdata = [];
+      elseif (strcmp (s.properties.tag, "colorbar"))
+        s.properties.tag = "";
+        s.properties.userdata = [];
         par = gcf;
       endif
     endif
 
-    [h, hgS] = createaxes (hgS, matchin, par);
-  elseif (strcmpi (hgS.type, "line"))
-    h = createline (hgS, par);
-  elseif (strcmpi (hgS.type, "patch"))
-    [h, hgS] = createpatch (hgS, par);
-  elseif (strcmpi (hgS.type, "text"))
-    h = createtext (hgS, par);
-  elseif (strcmpi (hgS.type, "image"))
-    h = createimage (hgS, par);
-  elseif (strcmpi (hgS.type, "surface"))
-    h = createsurface (hgS, par);
-  elseif (strcmpi (hgS.type, "hggroup"))
-    [h, hgS, matchin] = createhg (hgS, matchin, par, hilev);
+    [h, s] = createaxes (s, p, par);
+  elseif (strcmp (s.type, "line"))
+    h = createline (s, par);
+  elseif (strcmp (s.type, "patch"))
+    [h, s] = createpatch (s, par);
+  elseif (strcmp (s.type, "text"))
+    h = createtext (s, par);
+  elseif (strcmp (s.type, "image"))
+    h = createimage (s, par);
+  elseif (strcmp (s.type, "surface"))
+    h = createsurface (s, par);
+  elseif (strcmp (s.type, "hggroup"))
+    [h, s, p] = createhg (s, p, par, hilev);
   endif
 
   ## children
-  matchin = [matchin [hgS.handle; h]]; # [original; new]
-  kids = hgS.children;
+  p = [p [s.handle; h]];  # [original; new]
+  kids = s.children;
   nkids = length (kids);
   ii = 0;
-  while nkids
+  while (nkids)
     ii++;
-    if (! any (ii == hgS.special))
-      [h2, matchin] = struct2hdl (hgS.children(ii),
-                                  [matchin [hgS.handle; h]], hilev);
+    if (! any (ii == s.special))
+      [h2, p] = struct2hdl (s.children(ii), [p [s.handle; h]], hilev);
     endif
     nkids--;
   endwhile
 
   ## paste properties
-  setprops (hgS, h, matchin, hilev);
+  setprops (s, h, p, hilev);
 
-  matchout = matchin;
+  pout = p;
 
 endfunction
 
-function [h, hgSout] = createaxes (hgS, matchin, par);
+function [h, sout] = createaxes (s, p, par)
   ## regular axes
-  if (strcmpi (hgS.properties.tag, ""))
-    propval = {"position", hgS.properties.position};
+  if (strcmp (s.properties.tag, ""))
+    propval = {"position", s.properties.position};
     hid = {"autopos_tag", "looseinset"};
     for ii = 1:numel (hid)
       prop = hid{ii};
-      if (isfield (hgS.properties, prop))
-        val = hgS.properties.(prop);
+      if (isfield (s.properties, prop))
+        val = s.properties.(prop);
         propval = [propval, prop, val];
       endif
     endfor
     h = axes (propval{:}, "parent", par);
 
-    if isfield (hgS.properties, "__plotyy_axes__")
-      plty = hgS.properties.__plotyy_axes__;
-      addproperty ("__plotyy_axes__", h, "any")
-      tmp = [matchin [hgS.handle; h]];
-      tst = arrayfun (@(x) any (plty == x), tmp (1:2:end));
-      if sum (tst) == numel (plty)
+    if (isfield (s.properties, "__plotyy_axes__"))
+      plty = s.properties.__plotyy_axes__;
+      addproperty ("__plotyy_axes__", h, "any");
+      tmp = [p [s.handle; h]];
+      tst = arrayfun (@(x) any (plty == x), tmp(1:2:end));
+      if (sum (tst) == numel (plty))
         for ii = 1:numel (plty)
-          plty(ii) = tmp (find (tmp == plty(ii)) + 1);
+          plty(ii) = tmp(find (tmp == plty(ii)) + 1);
         endfor
         for ii = 1:numel (plty)
           set (plty(ii), "__plotyy_axes__", plty);
         endfor
       endif
-      hgS.properties = rmfield (hgS.properties, "__plotyy_axes__");
+      s.properties = rmfield (s.properties, "__plotyy_axes__");
     endif
 
     ## delete non-default and already set properties
-    fields = fieldnames (hgS.properties);
+    fields = fieldnames (s.properties);
     tst = cellfun (@(x) isprop (h, x), fields);
-    hgS.properties = rmfield (hgS.properties,  fields(find (tst == 0)));
+    s.properties = rmfield (s.properties, fields(find (tst == 0)));
 
-  elseif (strcmpi (hgS.properties.tag, "legend"))
+  elseif (strcmp (s.properties.tag, "legend"))
     ## legends
-    oldax = hgS.properties.userdata.handle;
-    idx = find (matchin == oldax);
-    newax = matchin(idx+1);
+    oldax = s.properties.userdata.handle;
+    idx = find (p == oldax);
+    newax = p(idx+1);
     strings = {};
-    kids = hgS.children;
-    kids(hgS.special) = [];
+    kids = s.children;
+    kids(s.special) = [];
     oldh = unique (arrayfun (@(x) x.properties.userdata(end), kids));
     for ii = 1:length (oldh)
-      idx = find (matchin(1:2:end) == oldh(ii)) * 2;
+      idx = find (p(1:2:end) == oldh(ii)) * 2;
       if (! isempty (idx))
-        newh(ii) = matchin (idx);
+        newh(ii) = p(idx);
         if (! strcmp (get (newh(ii), "type"), "hggroup"))
           str = get (newh(ii), "displayname");
           strings = [strings str];
         else
           str = get (get (newh(ii), "children")(1), "displayname");
           strings = [strings str];
         endif
       else
-        error ("struct2hdl: didn't find a legend item")
+        error ("struct2hdl: didn't find a legend item");
       endif
     endfor
-    location = hgS.properties.location;
-    orientation = hgS.properties.orientation;
-    textpos = hgS.properties.textposition;
-    box = hgS.properties.box;
+    location = s.properties.location;
+    orientation = s.properties.orientation;
+    textpos = s.properties.textposition;
+    box = s.properties.box;
 
     h = legend (newax, newh, strings, "location", location, ...
                 "orientation", orientation);
     set (h, "textposition", textpos); # bug makes "textposition"
-                                # redefine the legend
+                                      # redefine the legend
     h = legend (newax, newh, strings, "location", location, ...
                 "orientation", orientation);
     ## box
     if (strcmp (box, "on"))
-      legend boxon
+      legend ("boxon");
     endif
 
     ## visibility
     tst = arrayfun (@(x) strcmp (x.properties.visible, "on"), kids);
-    if !any (tst)
+    if (! any (tst))
       legend ("hide");
     endif
 
     ## remove all properties such as "textposition" that redefines
     ## the entire legend. Also remove chidren
-    hgS.properties = rmfield (hgS.properties, ...
-                                {"userdata", "xlabel",...
-                                 "ylabel", "zlabel", "location", ...
-                                 "title", "string","orientation", ...
-                                 "visible", "textposition"});
+    s.properties = rmfield (s.properties, ...
+                              {"userdata", "xlabel",...
+                               "ylabel", "zlabel", "location", ...
+                               "title", "string","orientation", ...
+                               "visible", "textposition"});
 
-    hgS.children = [];
+    s.children = [];
 
-  elseif (strcmpi (hgS.properties.tag, "colorbar"))
+  elseif (strcmp (s.properties.tag, "colorbar"))
     ## colorbar
-    oldax = hgS.properties.axes;
-    if (! isempty (idx = find (oldax == matchin)))
-      ax = matchin(idx+1);
-      location = hgS.properties.location;
+    oldax = s.properties.axes;
+    if (! isempty (idx = find (oldax == p)))
+      ax = p(idx+1);
+      location = s.properties.location;
       h = colorbar ("peer", ax, location);
-      hgS.properties = rmfield (hgS.properties, ...
-                              {"userdata", "xlabel" ...
-                               "ylabel", "zlabel", ...
-                               "title", "axes"});
-      hgS.children= [];
+      s.properties = rmfield (s.properties, ...
+                                {"userdata", "xlabel" ...
+                                 "ylabel", "zlabel", ...
+                                 "title", "axes"});
+      s.children= [];
     else
-      error ("hdl2struct: didn't find an object")
+      error ("hdl2struct: didn't find an object");
     endif
   endif
-  hgSout = hgS;
+  sout = s;
 endfunction
 
-function [h] = createline (hgS, par);
+function h = createline (s, par)
   h = line ("parent", par);
-  addmissingprops (h, hgS.properties);
+  addmissingprops (h, s.properties);
 endfunction
 
-function [h, hgSout] = createpatch (hgS, par);
-  prp.faces = hgS.properties.faces;
-  prp.vertices = hgS.properties.vertices;
-  prp.facevertexcdata = hgS.properties.facevertexcdata;
+function [h, sout] = createpatch (s, par)
+  prp.faces = s.properties.faces;
+  prp.vertices = s.properties.vertices;
+  prp.facevertexcdata = s.properties.facevertexcdata;
   h = patch (prp);
   set (h, "parent", par);
-  hgS.properties = rmfield (hgS.properties,
+  s.properties = rmfield (s.properties,
                             {"faces", "vertices", "facevertexcdata"});
-  addmissingprops (h, hgS.properties);
-  hgSout = hgS;
+  addmissingprops (h, s.properties);
+  sout = s;
 endfunction
 
-function [h] = createtext (hgS, par);
+function h = createtext (s, par)
   h = text ("parent", par);
-  addmissingprops (h, hgS.properties)
+  addmissingprops (h, s.properties);
 endfunction
 
-function [h] = createimage (hgS, par);
+function h = createimage (s, par)
   h = image ("parent", par);
-  addmissingprops (h, hgS.properties)
+  addmissingprops (h, s.properties);
 endfunction
 
-function [h] = createsurface (hgS, par);
+function h = createsurface (s, par)
   h = surface ("parent", par);
-  addmissingprops (h, hgS.properties)
+  addmissingprops (h, s.properties);
 endfunction
 
-function [h, hgSout, matchout] = createhg (hgS, matchin, par, hilev)
+function [h, sout, pout] = createhg (s, p, par, hilev)
   ## Here we infer from properties the type of hggroup we should build
   ## an call corresponding high level functions
   ## We manually set "hold on" to avoid next hggroup be deleted
   ## the proper value of axes "nextplot" will finally be recovered
 
   hold on;
   if (hilev)
-    [h, hgS, matchin] = createhg_hilev (hgS, matchin, par);
-    if (numel (hgS.children) != numel (get (h).children))
-      warning (["struct2hdl: couldn't infer the hggroup type. ", ...
+    [h, s, p] = createhg_hilev (s, p, par);
+    if (numel (s.children) != numel (get (h).children))
+      warning (["struct2hdl: could not infer the hggroup type. ", ...
                 "Will build objects but listener/callback functions ", ...
                 "will be lost"]);
-      if isfield (h, "bargroup")
+      if (isfield (h, "bargroup"))
         delete (get (h).bargroup);
       else
         delete (h);
       endif
       h = hggroup ("parent", par);
-      addmissingprops (h, hgS.properties);
-      hgS.special = [];
+      addmissingprops (h, s.properties);
+      s.special = [];
     else
-      oldkids = hgS.children;
+      oldkids = s.children;
       newkids = get (h).children;
       nkids = numel (oldkids);
       ii = 1;
-      while nkids
-        matchin = [matchin [oldkids(ii++).handle; newkids(nkids--)]];
+      while (nkids)
+        p = [p [oldkids(ii++).handle; newkids(nkids--)]];
       endwhile
     endif
   else
     h = hggroup ("parent", par);
-    addmissingprops (h, hgS.properties);
-    hgS.special = [];
+    addmissingprops (h, s.properties);
+    s.special = [];
   endif
-  hgSout = hgS;
-  matchout = matchin;
+  sout = s;
+  pout = p;
 endfunction
 
-function [h, hgSout, matchout] = createhg_hilev (hgS, matchin, par)
-  fields = hgS.properties;
+function [h, sout, pout] = createhg_hilev (s, p, par)
+  fields = s.properties;
   if (isfield (fields, "contourmatrix"))
     ## contours
-    xdata = hgS.properties.xdata;
-    ydata = hgS.properties.ydata;
-    zdata = hgS.properties.zdata;
-    levellist = hgS.properties.levellist;
-    textlist = hgS.properties.textlist;
+    xdata = s.properties.xdata;
+    ydata = s.properties.ydata;
+    zdata = s.properties.zdata;
+    levellist = s.properties.levellist;
+    textlist = s.properties.textlist;
 
     ## contour creation
-    if (isempty (hgS.children(1).properties.zdata))
-      if (strcmpi (hgS.properties.fill, "on"))
+    if (isempty (s.children(1).properties.zdata))
+      if (strcmpi (s.properties.fill, "on"))
         [cm2, h] = contourf (xdata, ydata, zdata, levellist);
       else
         [cm2, h] = contour (xdata, ydata, zdata, levellist);
       endif
 
       ## labels
-      if (strcmpi (hgS.properties.showtext, "on"))
+      if (strcmpi (s.properties.showtext, "on"))
         clabel (cm2, h, textlist);
       endif
     else
       [cm2, h] = contour3 (xdata, ydata, zdata, levellist);
     endif
 
     ## delete already set properties and children
-    hgS.properties = rmfield (hgS.properties, ...
+    s.properties = rmfield (s.properties, ...
                               {"xdata", "ydata", "zdata", ...
                                "contourmatrix", "levellist", ...
                                "fill", "labelspacing", ...
                                "levellistmode", "levelstep", ...
                                "levelstepmode", "textlist"...
                                "textlistmode" , "textstep", ...
                                "textstepmode", "zlevel", ...
                                "zlevelmode"});
 
   elseif (isfield (fields, "udata") && isfield (fields, "vdata"))
     ## quiver
-    xdata = hgS.properties.xdata;
-    ydata = hgS.properties.ydata;
+    xdata = s.properties.xdata;
+    ydata = s.properties.ydata;
 
-    udata = hgS.properties.udata;
-    vdata = hgS.properties.vdata;
+    udata = s.properties.udata;
+    vdata = s.properties.vdata;
 
     h = quiver (xdata, ydata, udata, vdata);
 
     ## delete already set properties and children
-    hgS.properties = rmfield (hgS.properties, ...
+    s.properties = rmfield (s.properties, ...
                               {"xdata", "ydata", "zdata", ...
                                "xdatasource", "ydatasource", "zdatasource", ...
                                "udata", "vdata", "wdata", ...
                                "udatasource", "vdatasource", "wdatasource"});
 
   elseif (isfield (fields, "format"))
     ##errorbar
-    form = hgS.properties.format;
-    xdata = hgS.properties.xdata;
-    ydata = hgS.properties.ydata;
-    xldata = hgS.properties.xldata;
-    ldata = hgS.properties.ldata;
-    xudata = hgS.properties.xudata;
-    udata = hgS.properties.udata;
+    form = s.properties.format;
+    xdata = s.properties.xdata;
+    ydata = s.properties.ydata;
+    xldata = s.properties.xldata;
+    ldata = s.properties.ldata;
+    xudata = s.properties.xudata;
+    udata = s.properties.udata;
 
     switch form
       case "xerr"
         h = errorbar (xdata, ydata, xldata, xudata, ">");
       case "yerr"
         h = errorbar (xdata, ydata, ldata, udata, "~");
       case "xyerr"
         h = errorbar (xdata, ydata, xldata, xudata, ldata, udata, "~>");
       case "box"
         h = errorbar (xdata, ydata, xldata, xudata, "#");
       case "boxy"
         h = errorbar (xdata, ydata, ldata, udata, "#~");
       case "boxxy"
         h = errorbar (xdata, ydata, xldata, xudata, ldata, udata, "#~>");
       otherwise
-        error ("struct2hdl: couldn't guess the errorbar format")
+        error ("struct2hdl: couldn't guess the errorbar format");
     endswitch
     ## delete already set properties
-    hgS.properties = rmfield (hgS.properties, ...
+    s.properties = rmfield (s.properties, ...
                               {"xdata", "ydata", ...
                                "xldata", "ldata", ...
                                "xudata", "udata", ...
                                "xldatasource", "ldatasource", ...
                                "xudatasource", "udatasource", ...
                                "format"});
 
   elseif (isfield (fields, "bargroup"))
     ## bar plot
     ## FIXME - here we don't have access to brothers so we first create all
     ## the barseries of the bargroup (but the last), then retrieve information,
     ## and rebuild the whole bargroup.
     ## The duplicate are deleted after calling "setprops"
 
-    bargroup = hgS.properties.bargroup;
-    oldh = hgS.handle;
+    bargroup = s.properties.bargroup;
+    oldh = s.handle;
 
-    temp = arrayfun (@(x) any(x == bargroup), [matchin(1:2:end) oldh]);
+    temp = arrayfun (@(x) any(x == bargroup), [p(1:2:end) oldh]);
     tst = sum (temp) == length (bargroup);
 
     if (isscalar (bargroup) || !tst)
-      xdata = hgS.properties.xdata;
-      ydata = hgS.properties.ydata;
+      xdata = s.properties.xdata;
+      ydata = s.properties.ydata;
 
       h = bar (xdata, ydata);
 
       ## delete already set properties,
-      hgS.properties = rmfield (hgS.properties, ...
+      s.properties = rmfield (s.properties, ...
                                 {"xdata", "ydata", ...
                                  "xdatasource", "ydatasource", ...
                                  "bargroup", ...
                                  "barwidth", "baseline"});
     else
       xdata = [];
       ydata = [];
 
       ##build x/y matrix
       nbar = length (bargroup);
-      tmp = struct ("handle", NaN,"type", "", "children", [], "special", []);
+      tmp = struct ("handle", NaN, "type", "", "children", [], "special", []);
       for ii = 1:(nbar - 1)
-        idx = find (matchin(1:2:end) == bargroup(ii)) * 2;
-        hdl = matchin (idx);
+        idx = find (p(1:2:end) == bargroup(ii)) * 2;
+        hdl = p (idx);
         xdata = [xdata get(hdl).xdata];
         ydata = [ydata get(hdl).ydata];
         tmp.children(ii) = hdl2struct (hdl);
       endfor
 
-      xdata = [xdata hgS.properties.xdata];
-      ydata = [ydata hgS.properties.ydata];
-      width = hgS.properties.barwidth;
+      xdata = [xdata s.properties.xdata];
+      ydata = [ydata s.properties.ydata];
+      width = s.properties.barwidth;
       h = bar (ydata, width);
 
       ## replace previous handles in "match", copy props and delete redundant
       for ii = 1:(nbar - 1)
         props = tmp.children(ii).properties;
         bl = props.baseline;
         tmp.children(ii).properties = rmfield (props, {"baseline", "bargroup"});
-        setprops (tmp.children(ii), h(ii), matchin, 1);
+        setprops (tmp.children(ii), h(ii), p, 1);
         delete (tmp.children(ii).handle);
         delete (bl);
-        idxpar = find (matchin == tmp.children(ii).handle);
-        matchin (idxpar) = h(ii);
+        idxpar = find (p == tmp.children(ii).handle);
+        p(idxpar) = h(ii);
         idxkid = idxpar - 2;
-        matchin (idxkid) = get (h(ii), "children");
+        p(idxkid) = get (h(ii), "children");
       endfor
-      matchin (2,((end-nbar+2):end)) = h (1:(end-1));
-      h = h (end);
+      p(2,((end-nbar+2):end)) = h(1:(end-1));
+      h = h(end);
 
       ## delete already set properties ,
-      hgS.properties = rmfield (hgS.properties, ...
+      s.properties = rmfield (s.properties, ...
                                 {"xdata", "ydata", "bargroup"...
                                  "barwidth", "baseline"});
     endif
   elseif (isfield (fields, "baseline"))
     ## stem plot
-    xdata = hgS.properties.xdata;
-    ydata = hgS.properties.ydata;
+    xdata = s.properties.xdata;
+    ydata = s.properties.ydata;
 
     h = stem (xdata, ydata);
 
     ## delete already set properties,
-    hgS.properties = rmfield (hgS.properties, ...
+    s.properties = rmfield (s.properties, ...
                               {"xdata", "ydata", ...
                                "xdatasource", "ydatasource", ...
                                "baseline"});
   elseif (isfield (fields, "basevalue"))
     ## area plot
-    xdata = hgS.properties.xdata;
-    ydata = hgS.properties.ydata;
-    level = hgS.properties.basevalue;
+    xdata = s.properties.xdata;
+    ydata = s.properties.ydata;
+    level = s.properties.basevalue;
 
     h = area (xdata, ydata, level);
 
     ## delete already set properties,
-    hgS.properties = rmfield (hgS.properties, ...
+    s.properties = rmfield (s.properties, ...
                               {"xdata", "ydata", ...
                                "xdatasource", "ydatasource"});
   else
-    warning ("struct2hdl: couldn't infer the hggroup type. Will build objects but listener/callback functions will be lost");
+    warning ("struct2hdl: could not infer the hggroup type. Will build objects but listener/callback functions will be lost");
     h = hggroup ("parent", par);
-    addmissingprops (h, hgS.properties);
-    hgS.special = [];           # children will be treated as normal children
+    addmissingprops (h, s.properties);
+    s.special = [];           # children will be treated as normal children
   endif
-  hgSout = hgS;
-  matchout = matchin;
+  sout = s;
+  pout = p;
 endfunction
 
-function setprops (hgS, h, matchin, hilev)
-  more off
-  if (strcmpi (hgS.properties.tag, ""))
-    specs = hgS.children(hgS.special);
+function setprops (s, h, p, hilev)
+  more off;
+  if (strcmpi (s.properties.tag, ""))
+    specs = s.children(s.special);
     hdls = arrayfun (@(x) x.handle, specs);
-    nh = length(hdls);
+    nh = length (hdls);
     msg = "";
     if (! nh)
-      set (h, hgS.properties);
+      set (h, s.properties);
     else
       ## Specials are objects that where automatically constructed with
       ## current object. Among them are "x(yz)labels", "title", high
       ## level hggroup children
-      fields = fieldnames (hgS.properties);
-      vals = struct2cell (hgS.properties);
+      fields = fieldnames (s.properties);
+      vals = struct2cell (s.properties);
       idx = find (cellfun (@(x) valcomp(x, hdls) , vals));
-      hgS.properties = rmfield (hgS.properties, fields(idx));
+      s.properties = rmfield (s.properties, fields(idx));
 
       ## set all properties but special handles
-      set (h, hgS.properties);
+      set (h, s.properties);
 
       ## find  props with val == (one of special handles)
       nf = length (idx);
       fields = fields(idx);
       vals = vals(idx);
-      while nf
+      while (nf)
         field = fields{nf};
         idx = find (hdls == vals{nf});
         spec = specs(idx);
         if (isprop (h, field))
            h2 = get (h , field);
            set (h2, spec.properties);
         endif
         nf--;
       endwhile
 
       ## If hggroup children  were created by high level functions,
       ## copy only usefull properties.
       if (hilev)
-        if (strcmpi (hgS.type, "hggroup"))
-          nold = numel (hgS.children);
-          nnew = numel (get(h).children);
+        if (strcmp (s.type, "hggroup"))
+          nold = numel (s.children);
+          nnew = numel (get (h).children);
 
           if (nold == nnew)
-            hnew = get(h).children;
+            hnew = get (h).children;
             ii = 1;
-            while ii <= nnew
+            while (ii <= nnew)
               try
                 set (hnew (ii), "displayname", ...
-                     hgS.children(ii).properties.displayname);
+                     s.children(ii).properties.displayname);
               catch
-                sprintf ("struct2hdl: couldn't set hggroup children #%d props.", ii)
+                sprintf ("struct2hdl: couldn't set hggroup children #%d props.", ii);
               end_try_catch
               ii ++;
             endwhile
 
           else
-            error ("struct2hdl: non-conformant number of children in hgggroup")
+            error ("struct2hdl: non-conformant number of children in hgggroup");
           endif
         endif
       endif
     endif
 
-  elseif (strcmpi (hgS.properties.tag, "legend")
-          || strcmpi (hgS.properties.tag, "colorbar"))
-    set (h, hgS.properties);
+  elseif (strcmpi (s.properties.tag, "legend")
+          || strcmpi (s.properties.tag, "colorbar"))
+    set (h, s.properties);
   endif
 
 endfunction
 
 function out = valcomp (x, hdls)
-  if (isfloat(x) && isscalar(x))
+  if (isfloat (x) && isscalar (x))
     out = any (x == hdls);
   else
     out = 0;
   endif
 endfunction
 
 function addmissingprops (h, props)
   hid = {"autopos_tag", "looseinset"};
   oldfields = fieldnames (props);
   curfields = fieldnames (get (h));
   missing = cellfun (@(x) !any (strcmp (x, curfields)), oldfields);
   idx = find (missing);
-  for ii = 1:length(idx)
+  for ii = 1:length (idx)
     prop = oldfields{idx(ii)};
     if (! any (strcmp (prop, hid)))
       addproperty (prop, h, "any");
     endif
   endfor
 endfunction
+
+
+## FIXME: Need validation tests
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -76,17 +76,17 @@ function [retfile, retpath, retindex] = 
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 7)
     error ("uigetfile: number of input arguments must be less than eight");
   endif
 
-  defaultvals = {cell (0, 2),        # File Filter
+  defaultvals = {cell(0, 2),         # File Filter
                  "Open File",        # Dialog Title
                  "",                 # Default file name
                  [240, 120],         # Dialog Position (pixel x/y)
                  "off",              # MultiSelect on/off
                  pwd};               # Default directory
 
   outargs = cell (6, 1);
   for i = 1 : 6
diff --git a/scripts/plot/uiputfile.m b/scripts/plot/uiputfile.m
--- a/scripts/plot/uiputfile.m
+++ b/scripts/plot/uiputfile.m
@@ -67,17 +67,17 @@ function [retfile, retpath, retindex] = 
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 3)
     print_usage ();
   endif
 
-  defaultvals = {cell (0, 2),    # File Filter
+  defaultvals = {cell(0, 2),     # File Filter
                  "Save File",    # Dialog Title
                  "",             # Default file name
                  [240, 120],     # Dialog Position (pixel x/y)
                  "create",
                  pwd};           # Default directory
 
   outargs = cell (6, 1);
   for i = 1 : 6
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -329,20 +329,16 @@ function [__ret1, __ret2, __ret3, __ret4
       catch
         ## Couldn't declare, so don't initialize.
         __code = "";
         __success = 0;
         __msg = sprintf ("%sshared variable initialization failed\n",
                          __signal_fail);
       end_try_catch
 
-      ## Clear shared function definitions.
-      eval (__clear, "");
-      __clear = "";
-
       ## Initialization code will be evaluated below.
 
 ### FUNCTION
 
     elseif (strcmp (__type, "function"))
       __istest = 0;
       persistent __fn = 0;
       __name_position = function_name (__block);
@@ -550,16 +546,17 @@ function [__ret1, __ret2, __ret3, __ret4
           fclose (__fid);
         endif
         return;
       endif
     endif
     __tests += __istest;
     __successes += __success * __istest;
   endfor
+  ## Clear any test functions created
   eval (__clear, "");
 
   if (nargout == 0)
     if (__tests || __xfail || __xskip)
       if (__xfail)
         printf ("PASSES %d out of %d tests (%d expected failures)\n",
                 __successes, __tests, __xfail);
       else
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -159,63 +159,63 @@ colamd, symamd, and other related orderi
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [CCOLAMD_LU] = (User_knobs (0) != 0);
+            knobs[CCOLAMD_LU] = (User_knobs(0) != 0);
           if (nel_User_knobs > 1)
-            knobs [CCOLAMD_DENSE_ROW]  = User_knobs (1);
+            knobs[CCOLAMD_DENSE_ROW] = User_knobs(1);
           if (nel_User_knobs > 2)
-            knobs [CCOLAMD_DENSE_COL]  = User_knobs (2);
+            knobs[CCOLAMD_DENSE_COL] = User_knobs(2);
           if (nel_User_knobs > 3)
-            knobs [CCOLAMD_AGGRESSIVE] = (User_knobs (3) != 0);
+            knobs[CCOLAMD_AGGRESSIVE] = (User_knobs(3) != 0);
           if (nel_User_knobs > 4)
-            spumoni = (User_knobs (4) != 0);
+            spumoni = (User_knobs(4) != 0);
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE
-                            << ":\nknobs(1): " << User_knobs (0) << ", order for ";
-              if ( knobs [CCOLAMD_LU] != 0)
+                            << ":\nknobs(1): " << User_knobs(0) << ", order for ";
+              if (knobs[CCOLAMD_LU] != 0)
                 octave_stdout << "lu (A)\n";
               else
                 octave_stdout << "chol (A'*A)\n";
 
-              if (knobs [CCOLAMD_DENSE_ROW] >= 0)
-                octave_stdout << "knobs(2): " << User_knobs (1)
+              if (knobs[CCOLAMD_DENSE_ROW] >= 0)
+                octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", rows with > max (16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
-                octave_stdout << "knobs(2): " << User_knobs (1)
+                octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", no dense rows removed\n";
 
-              if (knobs [CCOLAMD_DENSE_COL] >= 0)
-                octave_stdout << "knobs(3): " << User_knobs (2)
+              if (knobs[CCOLAMD_DENSE_COL] >= 0)
+                octave_stdout << "knobs(3): " << User_knobs(2)
                               << ", cols with > max (16,"
-                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt (size(A)))"
+                              << knobs[CCOLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
-                octave_stdout << "knobs(3): " << User_knobs (2)
+                octave_stdout << "knobs(3): " << User_knobs(2)
                               << ", no dense columns removed\n";
 
-              if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+              if (knobs[CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: yes";
               else
                 octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: no";
 
-              octave_stdout << "knobs(5): " << User_knobs (4)
+              octave_stdout << "knobs(5): " << User_knobs(4)
                             << ", statistics and knobs printed\n";
             }
         }
 
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseComplexMatrix scm;
       SparseMatrix sm;
@@ -254,22 +254,22 @@ colamd, symamd, and other related orderi
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       // Allocate workspace for ccolamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
-        p[i] = cidx [i];
+        p[i] = cidx[i];
 
       octave_idx_type Alen = CCOLAMD_NAME (_recommended) (nnz, n_row, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
-        A[i] = ridx [i];
+        A[i] = ridx[i];
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
           NDArray in_cmember = args(2).array_value ();
           octave_idx_type cslen = in_cmember.length ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
@@ -310,17 +310,17 @@ colamd, symamd, and other related orderi
       if (spumoni > 0)
         CCOLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (CCOLAMD_INFO1) ++ ;
           out_stats (CCOLAMD_INFO2) ++ ;
         }
@@ -414,46 +414,46 @@ colamd, symamd, and other related orderi
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [CCOLAMD_DENSE_ROW] = User_knobs (0);
+            knobs[CCOLAMD_DENSE_ROW] = User_knobs(0);
           if (nel_User_knobs > 0)
-            knobs [CCOLAMD_AGGRESSIVE] = User_knobs (1);
+            knobs[CCOLAMD_AGGRESSIVE] = User_knobs(1);
           if (nel_User_knobs > 1)
-            spumoni = static_cast<int> (User_knobs (2));
+            spumoni = static_cast<int> (User_knobs(2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
 
-              if (knobs [CCOLAMD_DENSE_ROW] >= 0)
-                octave_stdout << "knobs(1): " << User_knobs (0)
+              if (knobs[CCOLAMD_DENSE_ROW] >= 0)
+                octave_stdout << "knobs(1): " << User_knobs(0)
                               << ", rows/cols with > max (16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
-                octave_stdout << "knobs(1): " << User_knobs (0)
+                octave_stdout << "knobs(1): " << User_knobs(0)
                               << ", no dense rows/cols removed\n";
 
-              if (knobs [CCOLAMD_AGGRESSIVE] != 0)
+              if (knobs[CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: yes";
               else
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: no";
 
 
-              octave_stdout << "knobs(3): " << User_knobs (2)
+              octave_stdout << "knobs(3): " << User_knobs(2)
                             << ", statistics and knobs printed\n";
             }
         }
 
       octave_idx_type n_row, n_col;
       octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
@@ -538,17 +538,17 @@ colamd, symamd, and other related orderi
 
       retval(0) = out_perm;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (CCOLAMD_INFO1) ++ ;
           out_stats (CCOLAMD_INFO2) ++ ;
         }
@@ -557,17 +557,17 @@ colamd, symamd, and other related orderi
       if (spumoni > 0)
         CSYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (CCOLAMD_INFO1) ++ ;
           out_stats (CCOLAMD_INFO2) ++ ;
         }
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -58,38 +58,38 @@ static void
 symetree (const octave_idx_type *ridx, const octave_idx_type *cidx,
           octave_idx_type *Parent, octave_idx_type *P, octave_idx_type n)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Flag, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Pinv, (P ? n : 0));
   if (P)
     // If P is present then compute Pinv, the inverse of P
     for (octave_idx_type k = 0 ; k < n ; k++)
-      Pinv [P [k]] = k ;
+      Pinv[P[k]] = k ;
 
   for (octave_idx_type k = 0 ; k < n ; k++)
     {
       // L(k,:) pattern: all nodes reachable in etree from nz in A(0:k-1,k)
-      Parent [k] = n ;                // parent of k is not yet known
-      Flag [k] = k ;                  // mark node k as visited
-      octave_idx_type kk = (P) ? (P [k]) : (k) ;  // kth original, or permuted, column
-      octave_idx_type p2 = cidx [kk+1] ;
-      for (octave_idx_type p = cidx [kk] ; p < p2 ; p++)
+      Parent[k] = n ;                // parent of k is not yet known
+      Flag[k] = k ;                  // mark node k as visited
+      octave_idx_type kk = (P) ? (P[k]) : (k) ;  // kth original, or permuted, column
+      octave_idx_type p2 = cidx[kk+1] ;
+      for (octave_idx_type p = cidx[kk] ; p < p2 ; p++)
         {
           // A (i,k) is nonzero (original or permuted A)
-          octave_idx_type i = (Pinv) ? (Pinv [ridx [p]]) : (ridx [p]) ;
+          octave_idx_type i = (Pinv) ? (Pinv[ridx[p]]) : (ridx[p]) ;
           if (i < k)
             {
               // follow path from i to root of etree, stop at flagged node
-              for ( ; Flag [i] != k ; i = Parent [i])
+              for ( ; Flag[i] != k ; i = Parent[i])
                 {
                   // find parent of i if not yet determined
-                  if (Parent [i] == n)
-                    Parent [i] = k ;
-                  Flag [i] = k ;        // mark i as visited
+                  if (Parent[i] == n)
+                    Parent[i] = k ;
+                  Flag[i] = k ;        // mark i as visited
                 }
             }
         }
     }
 }
 
 // The elimination tree post-ordering code below is taken from SuperLU
 static inline octave_idx_type
@@ -294,42 +294,42 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [COLAMD_DENSE_ROW] = User_knobs (0);
+            knobs[COLAMD_DENSE_ROW] = User_knobs(0);
           if (nel_User_knobs > 1)
-            knobs [COLAMD_DENSE_COL] = User_knobs (1) ;
+            knobs[COLAMD_DENSE_COL] = User_knobs(1) ;
           if (nel_User_knobs > 2)
-            spumoni = static_cast<int> (User_knobs (2));
+            spumoni = static_cast<int> (User_knobs(2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
 
               octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
                             <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
 
-              if (knobs [COLAMD_DENSE_ROW] >= 0)
+              if (knobs[COLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", rows with > max (16,"
-                              << knobs [COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", only completely dense rows removed\n";
 
-              if (knobs [COLAMD_DENSE_COL] >= 0)
+              if (knobs[COLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", cols with > max (16,"
-                              << knobs [COLAMD_DENSE_COL] << "*sqrt (size(A)))"
+                              << knobs[COLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", only completely dense columns removed\n";
 
               octave_stdout << "knobs(3): " << User_knobs (2)
                             << ", statistics and knobs printed\n";
 
@@ -375,22 +375,22 @@ Ng, Oak Ridge National Laboratory.  (see
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       // Allocate workspace for colamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
-        p[i] = cidx [i];
+        p[i] = cidx[i];
 
       octave_idx_type Alen = COLAMD_NAME (_recommended) (nnz, n_row, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
-        A[i] = ridx [i];
+        A[i] = ridx[i];
 
       // Order the columns (destroys A)
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
       if (! COLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats))
         {
           COLAMD_NAME (_report) (stats) ;
           error ("colamd: internal error!");
           return retval;
@@ -410,30 +410,30 @@ Ng, Oak Ridge National Laboratory.  (see
       coletree (ridx, colbeg, colend, etree, n_row, n_col);
 
       // Calculate the tree post-ordering
       tree_postorder (n_col, etree, colbeg);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p[colbeg [i]] + 1;
+        out_perm(i) = p[colbeg[i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         COLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, COLAMD_STATS));
           for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (COLAMD_INFO1) ++ ;
           out_stats (COLAMD_INFO2) ++ ;
         }
@@ -529,25 +529,25 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
           if (nel_User_knobs > 0)
-            knobs [COLAMD_DENSE_ROW] = User_knobs (COLAMD_DENSE_ROW);
+            knobs[COLAMD_DENSE_ROW] = User_knobs(COLAMD_DENSE_ROW);
           if (nel_User_knobs > 1)
             spumoni = static_cast<int> (User_knobs (1));
         }
 
       // print knob settings if spumoni is set
       if (spumoni > 0)
         octave_stdout << "symamd: dense row/col fraction: "
-                      << knobs [COLAMD_DENSE_ROW] << std::endl;
+                      << knobs[COLAMD_DENSE_ROW] << std::endl;
 
       octave_idx_type n_row, n_col;
       octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
       if (args(0).is_sparse_type ())
         {
@@ -603,30 +603,30 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Calculate the tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
       tree_postorder (n_col, etree, post);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm[post [i]] + 1;
+        out_perm(i) = perm[post[i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         SYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, COLAMD_STATS));
           for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
-            out_stats (i) = stats [i] ;
+            out_stats(i) = stats[i] ;
           retval(1) = out_stats;
 
           // fix stats (5) and (6), for 1-based information on
           // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
           out_stats (COLAMD_INFO1) ++ ;
           out_stats (COLAMD_INFO2) ++ ;
         }
diff --git a/src/DLD-FUNCTIONS/config-module.awk b/src/DLD-FUNCTIONS/config-module.awk
--- a/src/DLD-FUNCTIONS/config-module.awk
+++ b/src/DLD-FUNCTIONS/config-module.awk
@@ -47,17 +47,17 @@ BEGIN {
     print "\t  of=$(<F:.la=.oct) && \\";
     print "\t  cd DLD-FUNCTIONS && \\";
     print "\t  $(LN_S) .libs/`$(SED) -n -e \"s/dlname='\\([^']*\\)'/\\1/p\" < $$la` $$of && \\";
     print "\t  touch $(@F)";
     print "";
   }
   print "else";
   print "";
-  print "noinst_LTLIBRARIES = $(DLD_FUNCTIONS_LIBS)";
+  print "noinst_LTLIBRARIES += $(DLD_FUNCTIONS_LIBS)";
   print "";
   print "endif";
 
   for (i = 1; i <= nfiles; i++) {
     basename = files[i];
     sub (/\.cc$/, "", basename);
     print "";
     printf ("DLD_FUNCTIONS_%s_la_SOURCES = DLD-FUNCTIONS/%s\n",
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -253,16 +253,17 @@ Flag if @code{chol (@var{B})} is passed 
 false.\n\
 \n\
 @item permB\n\
 The permutation vector of the Cholesky@tie{}factorization of @var{B} if\n\
 @code{cholB} is true.  That is @code{chol (@var{B}(permB, permB))}.  The\n\
 default is @code{1:@var{n}}.\n\
 \n\
 @end table\n\
+\n\
 It is also possible to represent @var{A} by a function denoted @var{af}.\n\
 @var{af} must be followed by a scalar argument @var{n} defining the length\n\
 of the vector argument accepted by @var{af}.  @var{af} can be\n\
 a function handle, an inline function, or a string.  When @var{af} is a\n\
 string it holds the name of the function to use.\n\
 \n\
 @var{af} is a function of the form @code{y = af (x)}\n\
 where the required return value of @var{af} is determined by\n\
diff --git a/src/DLD-FUNCTIONS/module-files b/src/DLD-FUNCTIONS/module-files
--- a/src/DLD-FUNCTIONS/module-files
+++ b/src/DLD-FUNCTIONS/module-files
@@ -1,83 +1,22 @@
 # FILE|CPPFLAGS|LDFLAGS|LIBRARIES
-__contourc__.cc
+chol.cc
 __delaunayn__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
-__dispatch__.cc
 __dsearchn__.cc
 __fltk_uigetfile__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
 __glpk__.cc|$(GLPK_CPPFLAGS)|$(GLPK_LDFLAGS)|$(GLPK_LIBS)
 __init_fltk__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
 __init_gnuplot__.cc
-__lin_interpn__.cc
 __magick_read__.cc|$(MAGICK_CPPFLAGS)|$(MAGICK_LDFLAGS)|$(MAGICK_LIBS)
-__pchip_deriv__.cc
-__qp__.cc
 __voronoi__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 amd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-balance.cc
-besselj.cc
-betainc.cc
-bsxfun.cc
 ccolamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-cellfun.cc
-chol.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
 colamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-colloc.cc
-conv2.cc
 convhulln.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
-daspk.cc
-dasrt.cc
-dassl.cc
-det.cc
-dlmread.cc
 dmperm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-dot.cc
-eig.cc
 eigs.cc|$(ARPACK_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(ARPACK_LDFLAGS) $(SPARSE_XLDFLAGS)|$(ARPACK_LIBS) $(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
-fft.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
-fft2.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
-fftn.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fftw.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
-filter.cc
-find.cc
-gammainc.cc
-gcd.cc
-getgrent.cc
-getpwent.cc
-getrusage.cc
-givens.cc
-hess.cc
-hex2num.cc
-inv.cc
-kron.cc
-lookup.cc
-lsode.cc
-lu.cc
-luinc.cc
-matrix_type.cc
-max.cc
-md5sum.cc
-mgorth.cc
-nproc.cc
-pinv.cc
 qr.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
-quad.cc
-quadcc.cc
-qz.cc|||$(LAPACK_LIBS) $(BLAS_LIBS)
-rand.cc
-rcond.cc
-regexp.cc|$(REGEX_CPPFLAGS)|$(REGEX_LDFLAGS)|$(REGEX_LIBS)
-schur.cc
-spparms.cc
-sqrtm.cc
-strfind.cc
-str2double.cc
-sub2ind.cc
-svd.cc
-syl.cc
 symbfact.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 symrcm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-time.cc
-tril.cc
 tsearch.cc
-typecast.cc
 urlwrite.cc|$(CURL_CPPFLAGS)|$(CURL_LDFLAGS)|$(CURL_LIBS)
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -265,28 +265,28 @@ factorization as determined by @var{typ}
             {
               A1 = A;
               A2 = F;
             }
 
           // count the total number of entries in L
           octave_idx_type lnz = 0 ;
           for (octave_idx_type j = 0 ; j < n ; j++)
-            lnz += ColCount [j] ;
+            lnz += ColCount[j];
 
 
           // allocate the output matrix L (pattern-only)
           SparseBoolMatrix L (n, n, lnz);
 
           // initialize column pointers
           lnz = 0;
           for (octave_idx_type j = 0 ; j < n ; j++)
             {
               L.xcidx(j) = lnz;
-              lnz += ColCount [j];
+              lnz += ColCount[j];
             }
           L.xcidx(n) = lnz;
 
 
           /* create a copy of the column pointers */
           octave_idx_type *W = First;
           for (octave_idx_type j = 0 ; j < n ; j++)
             W[j] = L.xcidx (j);
@@ -297,21 +297,21 @@ factorization as determined by @var{typ}
           octave_idx_type *Rp = static_cast<octave_idx_type *>(R->p);
           octave_idx_type *Ri = static_cast<octave_idx_type *>(R->i);
 
           // compute L one row at a time
           for (octave_idx_type k = 0 ; k < n ; k++)
             {
               // get the kth row of L and store in the columns of L
               CHOLMOD_NAME (row_subtree) (A1, A2, k, Parent, R, cm) ;
-              for (octave_idx_type p = 0 ; p < Rp [1] ; p++)
-                L.xridx (W [Ri [p]]++) = k ;
+              for (octave_idx_type p = 0 ; p < Rp[1] ; p++)
+                L.xridx (W[Ri[p]]++) = k ;
 
               // add the diagonal entry
-              L.xridx (W [k]++) = k ;
+              L.xridx (W[k]++) = k ;
             }
 
           // free workspace
           cholmod_free_sparse (&R, cm) ;
 
 
           // transpose L to get R, or leave as is
           if (nargin < 3)
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -400,17 +400,17 @@ transpose (octave_idx_type N, const octa
     }
   cidx2[N] = nz;
   w[N] = nz;
 
   for (octave_idx_type j = 0; j < N; j++)
     for (octave_idx_type k = cidx[j]; k < cidx[j + 1]; k++)
       {
         OCTAVE_QUIT;
-        octave_idx_type q = w [ridx[k]]++;
+        octave_idx_type q = w[ridx[k]]++;
         ridx2[q] = j;
       }
 }
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})\n\
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -20,16 +20,17 @@
 
 include $(top_srcdir)/build-aux/common.mk
 
 ## Search local directories before those specified by the user.
 AM_CPPFLAGS = \
   -I../libgnu -I$(top_srcdir)/libgnu \
   -I$(top_srcdir)/libcruft/misc \
   -I../liboctave -I$(top_srcdir)/liboctave \
+  -Icorefcn -I$(srcdir)/corefcn \
   -I. -I$(srcdir) \
   @CPPFLAGS@
 
 AUTOMAKE_OPTIONS = subdir-objects
 
 octlib_LTLIBRARIES = liboctinterp.la
 
 if AMCOND_BUILD_COMPILED_AUX_PROGRAMS
@@ -39,17 +40,17 @@ bin_PROGRAMS = \
   octave-config
 
 mkoctfile_SOURCES =
 nodist_mkoctfile_SOURCES = mkoctfile.cc
 mkoctfile_LDADD = ../libgnu/libgnu.la $(LIBS)
 
 octave_config_SOURCES =
 nodist_octave_config_SOURCES = octave-config.cc
-octave_config_LDADD = ../libgnu/libgnu.la $(LIBS)
+octave_config_LDADD = corefcn/libcorefcn.la ../libgnu/libgnu.la $(LIBS)
 
 BUILT_SOURCES_EXTRA = \
   mkoctfile.cc \
   octave-config.cc
 else
 bin_PROGRAMS = \
   octave
 
@@ -226,16 +227,22 @@ PT_INCLUDES = \
   pt-misc.h \
   pt-pr-code.h \
   pt-select.h \
   pt-stmt.h \
   pt-unop.h \
   pt-walk.h \
   pt.h
 
+JIT_INCLUDES = \
+  jit-util.h \
+  jit-typeinfo.h \
+  jit-ir.h \
+  pt-jit.h
+
 octinclude_HEADERS = \
   Cell.h \
   builtins.h \
   c-file-ptr-stream.h \
   comment-list.h \
   cutils.h \
   data.h \
   debug.h \
@@ -304,17 +311,18 @@ octinclude_HEADERS = \
   utils.h \
   variables.h \
   xdiv.h \
   xnorm.h \
   xpow.h \
   zfstream.h \
   $(OV_INCLUDES) \
   $(OV_SPARSE_INCLUDES) \
-  $(PT_INCLUDES)
+  $(PT_INCLUDES) \
+  $(JIT_INCLUDES)
 
 nodist_octinclude_HEADERS = \
   defaults.h \
   graphics.h \
   oct-conf.h \
   mxarray.h \
   version.h
 
@@ -397,16 +405,26 @@ PT_SRC = \
   pt-mat.cc \
   pt-misc.cc \
   pt-pr-code.cc \
   pt-select.cc \
   pt-stmt.cc \
   pt-unop.cc \
   pt.cc
 
+JIT_SRC = \
+  jit-util.cc \
+  jit-typeinfo.cc \
+  jit-ir.cc \
+  pt-jit.cc
+
+#noinst_LTLIBRARIES =
+#
+#include corefcn/module.mk
+#
 DIST_SRC = \
   Cell.cc \
   bitfcns.cc \
   c-file-ptr-stream.cc \
   comment-list.cc \
   cutils.c \
   data.cc \
   debug.cc \
@@ -468,19 +486,24 @@ DIST_SRC = \
   unwind-prot.cc \
   utils.cc \
   variables.cc \
   xdiv.cc \
   xgl2ps.c \
   xnorm.cc \
   xpow.cc \
   zfstream.cc \
+  $(corefcn_SRC) \
   $(OV_SRC) \
-  $(PT_SRC)
+  $(PT_SRC) \
+  $(JIT_SRC)
 
+noinst_LTLIBRARIES =
+
+include corefcn/module.mk
 include DLD-FUNCTIONS/module.mk
 
 $(srcdir)/DLD-FUNCTIONS/module.mk: $(srcdir)/DLD-FUNCTIONS/config-module.sh $(srcdir)/DLD-FUNCTIONS/config-module.awk $(srcdir)/DLD-FUNCTIONS/module-files
 	$(srcdir)/DLD-FUNCTIONS/config-module.sh $(top_srcdir)
 
 include OPERATORS/module.mk
 include TEMPLATE-INST/module.mk
 
@@ -529,16 +552,19 @@ liboctinterp_version_info = $(liboctinte
 liboctinterp_la_LDFLAGS = \
   -version-info $(liboctinterp_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
   -bindir $(bindir) \
   $(LIBOCTINTERP_LINK_OPTS)
 
 display.df display.lo: CPPFLAGS += $(X11_FLAGS)
 
+## FIXME: Does this rule need to be uncommented?
+#fft.df fft.lo fft2.df fft2.lo fftn.df fftn.lo: CPPFLAGS += $(FFTW_XCPPFLAGS)
+
 octave_SOURCES = main.c
 
 octave_LDADD = \
   liboctinterp.la \
   ../liboctave/liboctave.la \
   ../libcruft/libcruft.la \
   $(OCTAVE_LINK_DEPS)
 
diff --git a/src/TEMPLATE-INST/Array-jit.cc b/src/TEMPLATE-INST/Array-jit.cc
new file mode 100644
--- /dev/null
+++ b/src/TEMPLATE-INST/Array-jit.cc
@@ -0,0 +1,40 @@
+/*
+
+Copyright (C) 2012 Max Brister <max@2bass.com>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef HAVE_LLVM
+
+#include "Array.h"
+#include "Array.cc"
+
+extern template class OCTAVE_API Array<octave_idx_type>;
+
+#include "pt-jit.h"
+
+NO_INSTANTIATE_ARRAY_SORT (jit_function);
+
+INSTANTIATE_ARRAY (jit_function, OCTINTERP_API);
+
+#endif
diff --git a/src/TEMPLATE-INST/module.mk b/src/TEMPLATE-INST/module.mk
--- a/src/TEMPLATE-INST/module.mk
+++ b/src/TEMPLATE-INST/module.mk
@@ -1,5 +1,6 @@
 EXTRA_DIST += TEMPLATE-INST/module.mk
 
 TEMPLATE_INST_SRC = \
   TEMPLATE-INST/Array-os.cc \
-  TEMPLATE-INST/Array-tc.cc
+  TEMPLATE-INST/Array-tc.cc \
+  TEMPLATE-INST/Array-jit.cc
diff --git a/src/DLD-FUNCTIONS/__contourc__.cc b/src/corefcn/__contourc__.cc
rename from src/DLD-FUNCTIONS/__contourc__.cc
rename to src/corefcn/__contourc__.cc
--- a/src/DLD-FUNCTIONS/__contourc__.cc
+++ b/src/corefcn/__contourc__.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
 
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 static Matrix this_contour;
 static Matrix contourc;
 static int elem;
 
 // This is the quanta in which we increase this_contour.
@@ -294,19 +294,19 @@ cntr (const RowVector& X, const RowVecto
     }
 
   for (unsigned int r = 0; r < nr - 1; r++)
     for (unsigned int c = 0; c < nc - 1; c++)
       if (mark (r, c) > 0)
         drawcn (X, Y, Z, lvl, r, c, 0.0, 0.0, 255, true, mark);
 }
 
-DEFUN_DLD (__contourc__, args, ,
+DEFUN (__contourc__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __contourc__ (@var{x}, @var{y}, @var{z}, @var{levels})\n\
+@deftypefn {Built-in Function} {} __contourc__ (@var{x}, @var{y}, @var{z}, @var{levels})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 4)
     {
       RowVector X = args (0).row_vector_value ();
diff --git a/src/DLD-FUNCTIONS/__dispatch__.cc b/src/corefcn/__dispatch__.cc
rename from src/DLD-FUNCTIONS/__dispatch__.cc
rename to src/corefcn/__dispatch__.cc
--- a/src/DLD-FUNCTIONS/__dispatch__.cc
+++ b/src/corefcn/__dispatch__.cc
@@ -25,26 +25,26 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <list>
 #include <map>
 #include <string>
 
 #include "Cell.h"
 #include "oct-map.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "ov.h"
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 #include "pager.h"
 #include "parse.h"
 #include "symtab.h"
 #include "variables.h"
 
-DEFUN_DLD (__dispatch__, args, nargout,
+DEFUN (__dispatch__, args, nargout,
   "Undocumented internal function")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   std::string f, r, t;
 
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/corefcn/__lin_interpn__.cc
rename from src/DLD-FUNCTIONS/__lin_interpn__.cc
rename to src/corefcn/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/corefcn/__lin_interpn__.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-ieee.h"
 #include "dNDArray.h"
 #include "oct-locbuf.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 // equivalent to isvector.m
 
 template <class T>
 bool
 isvector (const T& array)
@@ -262,19 +262,19 @@ lin_interpn (int n, M *X, const M V, M *
 // @var{x1}, @var{x2}, @dots{}, @var{xn} are either @var{n}-dimensional
 // arrays of the same size as the array @var{v} in the \"ndgrid\" format
 // or vectors.  The parameters @var{y1}, @var{y2}, @dots{}, @var{yn} are
 // all @var{n}-dimensional arrays of the same size and represent the
 // points at which the array @var{vi} is interpolated.
 //
 //This function only performs linear interpolation.
 
-DEFUN_DLD (__lin_interpn__, args, ,
+DEFUN (__lin_interpn__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{vi} =} __lin_interpn__ (@var{x1}, @var{x2}, @dots{}, @var{xn}, @var{v}, @var{y1}, @var{y2}, @dots{}, @var{yn})\n\
+@deftypefn {Built-in Function} {@var{vi} =} __lin_interpn__ (@var{x1}, @var{x2}, @dots{}, @var{xn}, @var{v}, @var{y1}, @var{y2}, @dots{}, @var{yn})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 ||  nargin % 2 == 0)
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/corefcn/__pchip_deriv__.cc
rename from src/DLD-FUNCTIONS/__pchip_deriv__.cc
rename to src/corefcn/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/corefcn/__pchip_deriv__.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "f77-fcn.h"
 
 extern "C"
 {
@@ -45,19 +45,19 @@ extern "C"
                            const float *f, float *d,
                            const octave_idx_type& incfd,
                            octave_idx_type *ierr);
 }
 
 // Wrapper for SLATEC/PCHIP function DPCHIM to calculate the derivates
 // for piecewise polynomials.
 
-DEFUN_DLD (__pchip_deriv__, args, ,
+DEFUN (__pchip_deriv__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
+@deftypefn {Built-in Function} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   const int nargin = args.length ();
 
   bool rows = (nargin == 3 && args (2).uint_value () == 2);
 
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/corefcn/__qp__.cc
rename from src/DLD-FUNCTIONS/__qp__.cc
rename to src/corefcn/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/corefcn/__qp__.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <cfloat>
 
 #include "dbleCHOL.h"
 #include "dbleSVD.h"
 #include "mx-m-dm.h"
 #include "EIG.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "pr-output.h"
 #include "utils.h"
 
 static Matrix
 null (const Matrix& A, octave_idx_type& rank)
@@ -474,19 +474,19 @@ qp (const Matrix& H, const ColumnVector&
               break;
             }
         }
     }
 
   return info;
 }
 
-DEFUN_DLD (__qp__, args, ,
+DEFUN (__qp__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
+@deftypefn {Built-in Function} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 8)
     {
       const ColumnVector x0  (args(0) . vector_value ());
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/corefcn/balance.cc
rename from src/DLD-FUNCTIONS/balance.cc
rename to src/corefcn/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/corefcn/balance.cc
@@ -34,30 +34,30 @@ along with Octave; see the file COPYING.
 #include "dbleAEPBAL.h"
 #include "floatAEPBAL.h"
 #include "CmplxGEPBAL.h"
 #include "fCmplxGEPBAL.h"
 #include "dbleGEPBAL.h"
 #include "floatGEPBAL.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (balance, args, nargout,
+DEFUN (balance, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{AA} =} balance (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{AA} =} balance (@var{A}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{D}, @var{P}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{CC}, @var{DD}, @var{AA}, @var{BB}] =} balance (@var{A}, @var{B}, @var{opt})\n\
+@deftypefn  {Built-in Function} {@var{AA} =} balance (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{AA} =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{D}, @var{P}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{CC}, @var{DD}, @var{AA}, @var{BB}] =} balance (@var{A}, @var{B}, @var{opt})\n\
 \n\
 Compute @code{@var{AA} = @var{DD} \\ @var{A} * @var{DD}} in which @var{AA}\n\
 is a matrix whose row and column norms are roughly equal in magnitude, and\n\
 @code{@var{DD} = @var{P} * @var{D}}, in which @var{P} is a permutation\n\
 matrix and @var{D} is a diagonal matrix of powers of two.  This allows the\n\
 equilibration to be computed without round-off.  Results of eigenvalue\n\
 calculation are typically improved by balancing first.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/corefcn/besselj.cc
rename from src/DLD-FUNCTIONS/besselj.cc
rename to src/corefcn/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/corefcn/besselj.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 enum bessel_type
 {
   BESSEL_J,
@@ -371,23 +371,23 @@ do_bessel (enum bessel_type type, const 
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (besselj, args, nargout,
+DEFUN (besselj, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
+@deftypefn  {Built-in Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
 @item besselj\n\
 Bessel functions of the first kind.  If the argument @var{opt} is supplied,\n\
 the result is multiplied by @code{exp (-abs (imag (@var{x})))}.\n\
 \n\
 @item bessely\n\
@@ -445,46 +445,46 @@ Complete loss of significance by argumen
 Error---no computation, algorithm termination condition not met,\n\
 return @code{NaN}.\n\
 @end enumerate\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_J, "besselj", args, nargout);
 }
 
-DEFUN_DLD (bessely, args, nargout,
+DEFUN (bessely, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_Y, "bessely", args, nargout);
 }
 
-DEFUN_DLD (besseli, args, nargout,
+DEFUN (besseli, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_I, "besseli", args, nargout);
 }
 
-DEFUN_DLD (besselk, args, nargout,
+DEFUN (besselk, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_K, "besselk", args, nargout);
 }
 
-DEFUN_DLD (besselh, args, nargout,
+DEFUN (besselh, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
@@ -516,19 +516,19 @@ See besselj.\n\
         error ("besselh: invalid value of K");
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (airy, args, nargout,
+DEFUN (airy, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
+@deftypefn {Built-in Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their\n\
 derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if 'opt' is supplied)\n\
 ---  --------   ---------------------------------------\n\
  0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/corefcn/betainc.cc
rename from src/DLD-FUNCTIONS/betainc.cc
rename to src/corefcn/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/corefcn/betainc.cc
@@ -21,26 +21,26 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // FIXME: These functions do not need to be dynamically loaded.  They should
 //        be placed elsewhere in the Octave code hierarchy.
 
-DEFUN_DLD (betainc, args, ,
+DEFUN (betainc, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} betainc (@var{x}, @var{a}, @var{b})\n\
 Return the regularized incomplete Beta function,\n\
 @tex\n\
 $$\n\
  I (x, a, b) = {1 \\over {B (a, b)}} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
 @end tex\n\
@@ -324,17 +324,17 @@ compatible dimensions.\n\
 %! assert (v3, v4, sqrt (eps ("single")));
 
 %!error betainc ()
 %!error betainc (1)
 %!error betainc (1,2)
 %!error betainc (1,2,3,4)
 */
 
-DEFUN_DLD (betaincinv, args, ,
+DEFUN (betaincinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} betaincinv (@var{y}, @var{a}, @var{b})\n\
 Compute the inverse of the incomplete Beta function, i.e., @var{x} such that\n\
 \n\
 @example\n\
 @var{y} == betainc (@var{x}, @var{a}, @var{b}) \n\
 @end example\n\
 @seealso{betainc, beta, betaln}\n\
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/corefcn/bsxfun.cc
rename from src/DLD-FUNCTIONS/bsxfun.cc
rename to src/corefcn/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/corefcn/bsxfun.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 #include <vector>
 #include <list>
 
 #include "lo-mappers.h"
 
 #include "oct-map.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "parse.h"
 #include "variables.h"
 #include "ov-colon.h"
 #include "unwind-prot.h"
 #include "ov-fcn-handle.h"
 
 // Optimized bsxfun operations
 enum bsxfun_builtin_op
@@ -304,19 +304,19 @@ update_index (Array<int>& idx, const dim
   idx(0) = 0;
   for (octave_idx_type j = 1; j < nd; j++)
     {
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
-DEFUN_DLD (bsxfun, args, ,
+DEFUN (bsxfun, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
+@deftypefn {Built-in Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
 The binary singleton expansion function applier performs broadcasting,\n\
 that is, applies a binary function @var{f} element-by-element to two\n\
 array arguments @var{A} and @var{B}, and expands as necessary\n\
 singleton dimensions in either input argument.  @var{f} is a function\n\
 handle, inline function, or string containing the name of the function\n\
 to evaluate.  The function @var{f} must be capable of accepting two\n\
 column-vector arguments of equal length, or one column vector argument\n\
 and a scalar.\n\
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/corefcn/cellfun.cc
rename from src/DLD-FUNCTIONS/cellfun.cc
rename to src/corefcn/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/corefcn/cellfun.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include <memory>
 
 #include "caseless-str.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "oct-map.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "parse.h"
 #include "variables.h"
 #include "ov-colon.h"
 #include "unwind-prot.h"
 #include "gripes.h"
 #include "utils.h"
 
 #include "ov-class.h"
@@ -244,26 +244,26 @@ get_mapper_fun_options (const octave_val
         }
 
       nargin -= 2;
     }
 
   nargin -= 1;
 }
 
-DEFUN_DLD (cellfun, args, nargout,
+DEFUN (cellfun, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} cellfun (@var{name}, @var{C})\n\
-@deftypefnx {Loadable Function} {} cellfun (\"size\", @var{C}, @var{k})\n\
-@deftypefnx {Loadable Function} {} cellfun (\"isclass\", @var{C}, @var{class})\n\
-@deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{C})\n\
-@deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{C}, @var{D})\n\
-@deftypefnx {Loadable Function} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
-@deftypefnx {Loadable Function} {} cellfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
-@deftypefnx {Loadable Function} {} cellfun (@dots{}, \"UniformOutput\", @var{val})\n\
+@deftypefn  {Built-in Function} {} cellfun (@var{name}, @var{C})\n\
+@deftypefnx {Built-in Function} {} cellfun (\"size\", @var{C}, @var{k})\n\
+@deftypefnx {Built-in Function} {} cellfun (\"isclass\", @var{C}, @var{class})\n\
+@deftypefnx {Built-in Function} {} cellfun (@var{func}, @var{C})\n\
+@deftypefnx {Built-in Function} {} cellfun (@var{func}, @var{C}, @var{D})\n\
+@deftypefnx {Built-in Function} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
+@deftypefnx {Built-in Function} {} cellfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
+@deftypefnx {Built-in Function} {} cellfun (@dots{}, \"UniformOutput\", @var{val})\n\
 \n\
 Evaluate the function named @var{name} on the elements of the cell array\n\
 @var{C}.  Elements in @var{C} are passed on to the named function\n\
 individually.  The function @var{name} can be one of the functions\n\
 \n\
 @table @code\n\
 @item isempty\n\
 Return 1 for empty elements.\n\
@@ -1009,17 +1009,17 @@ v = cellfun (@@det, a); # faster\n\
 %!error cellfun (@sin, {[]}, "UniformOuput")
 %!error cellfun (@sin, {[]}, "ErrorHandler")
 */
 
 // Arrayfun was originally a .m file written by Bill Denney and Jaroslav
 // Hajek.  It was converted to C++ by jwe so that it could properly
 // handle the nargout = 0 case.
 
-DEFUN_DLD (arrayfun, args, nargout,
+DEFUN (arrayfun, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} arrayfun (@var{func}, @var{A})\n\
 @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A})\n\
 @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A}, @var{b}, @dots{})\n\
 @deftypefnx {Function File} {[@var{x}, @var{y}, @dots{}] =} arrayfun (@var{func}, @var{A}, @dots{})\n\
 @deftypefnx {Function File} {} arrayfun (@dots{}, \"UniformOutput\", @var{val})\n\
 @deftypefnx {Function File} {} arrayfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
 \n\
@@ -1800,20 +1800,20 @@ do_object2cell (const octave_value& obj,
   else
     {
       error ("num2cell (A, dim) not implemented for class objects");
     }
 
   return retval;
 }
 
-DEFUN_DLD (num2cell, args, ,
+DEFUN (num2cell, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{C} =} num2cell (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
+@deftypefn  {Built-in Function} {@var{C} =} num2cell (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
 Convert the numeric matrix @var{A} to a cell array.  If @var{dim} is\n\
 defined, the value @var{C} is of dimension 1 in this dimension and the\n\
 elements of @var{A} are placed into @var{C} in slices.  For example:\n\
 \n\
 @example\n\
 @group\n\
 num2cell ([1,2;3,4])\n\
    @result{}\n\
@@ -2129,21 +2129,21 @@ do_mat2cell (octave_value& a, const Arra
         break;
 
       rdv.increment_index (ridx);
     }
 
   return retval;
 }
 
-DEFUN_DLD (mat2cell, args, ,
+DEFUN (mat2cell, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{C} =} mat2cell (@var{A}, @var{m}, @var{n})\n\
-@deftypefnx {Loadable Function} {@var{C} =} mat2cell (@var{A}, @var{d1}, @var{d2}, @dots{})\n\
-@deftypefnx {Loadable Function} {@var{C} =} mat2cell (@var{A}, @var{r})\n\
+@deftypefn  {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{m}, @var{n})\n\
+@deftypefnx {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{d1}, @var{d2}, @dots{})\n\
+@deftypefnx {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{r})\n\
 Convert the matrix @var{A} to a cell array.  If @var{A} is 2-D, then\n\
 it is required that @code{sum (@var{m}) == size (@var{A}, 1)} and\n\
 @code{sum (@var{n}) == size (@var{A}, 2)}.  Similarly, if @var{A} is\n\
 multi-dimensional and the number of dimensional arguments is equal\n\
 to the dimensions of @var{A}, then it is required that @code{sum (@var{di})\n\
 == size (@var{A}, i)}.\n\
 \n\
 Given a single dimensional argument @var{r}, the other dimensional\n\
@@ -2299,19 +2299,19 @@ do_cellslices_nda (const NDA& array,
           idx(dim) = idx_vector (lb(i) - 1, ub(i));
           retval(i) = array.index (idx);
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (cellslices, args, ,
+DEFUN (cellslices, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub}, @var{dim})\n\
+@deftypefn {Built-in Function} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub}, @var{dim})\n\
 Given an array @var{x}, this function produces a cell array of slices from\n\
 the array determined by the index vectors @var{lb}, @var{ub}, for lower and\n\
 upper bounds, respectively.  In other words, it is equivalent to the\n\
 following code:\n\
 \n\
 @example\n\
 @group\n\
 n = length (lb);\n\
@@ -2420,19 +2420,19 @@ slicing is done along the first non-sing
 
 /*
 %!test
 %! m = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12];
 %! c = cellslices (m, [1, 2], [2, 3], 2);
 %! assert (c, {[1, 2; 5, 6; 9, 10], [2, 3; 6, 7; 10, 11]});
 */
 
-DEFUN_DLD (cellindexmat, args, ,
+DEFUN (cellindexmat, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
+@deftypefn {Built-in Function} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
 Given a cell array of matrices @var{x}, this function computes\n\
 \n\
 @example\n\
 @group\n\
 Y = cell (size (X));\n\
 for i = 1:numel (X)\n\
   Y@{i@} = X@{i@}(varargin@{:@});\n\
 endfor\n\
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/corefcn/colloc.cc
rename from src/DLD-FUNCTIONS/colloc.cc
rename to src/corefcn/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/corefcn/colloc.cc
@@ -24,24 +24,24 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <string>
 
 #include "CollocWt.h"
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (colloc, args, ,
+DEFUN (colloc, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{r}, @var{amat}, @var{bmat}, @var{q}] =} colloc (@var{n}, \"left\", \"right\")\n\
+@deftypefn {Built-in Function} {[@var{r}, @var{amat}, @var{bmat}, @var{q}] =} colloc (@var{n}, \"left\", \"right\")\n\
 Compute derivative and integral weight matrices for orthogonal\n\
 collocation using the subroutines given in J. Villadsen and\n\
 M. L. Michelsen, @cite{Solution of Differential Equation Models by\n\
 Polynomial Approximation}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/corefcn/conv2.cc
rename from src/DLD-FUNCTIONS/conv2.cc
rename to src/corefcn/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/corefcn/conv2.cc
@@ -22,28 +22,28 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct-convn.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 enum Shape { SHAPE_FULL, SHAPE_SAME, SHAPE_VALID };
 
-DEFUN_DLD (conv2, args, ,
+DEFUN (conv2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} conv2 (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
-@deftypefnx {Loadable Function} {} conv2 (@dots{}, @var{shape})\n\
+@deftypefn  {Built-in Function} {} conv2 (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
+@deftypefnx {Built-in Function} {} conv2 (@dots{}, @var{shape})\n\
 Return the 2-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = \"full\"\n\
 Return the full convolution.  (default)\n\
 \n\
@@ -278,20 +278,20 @@ When the third argument is a matrix, ret
 %!error conv2 ()
 %!error conv2 (1)
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
 %% Test alternate calling form which should be 2 vectors and a matrix
 %!error conv2 (ones (2), 1, 1)
 %!error conv2 (1, ones (2), 1)
 */
 
-DEFUN_DLD (convn, args, ,
+DEFUN (convn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{C} =} convn (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
+@deftypefn  {Built-in Function} {@var{C} =} convn (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
 Return the n-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = \"full\"\n\
 Return the full convolution.  (default)\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/corefcn/daspk.cc
rename from src/DLD-FUNCTIONS/daspk.cc
rename to src/corefcn/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/corefcn/daspk.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include <iomanip>
 #include <iostream>
 
 #include "DASPK.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "unwind-prot.h"
 #include "utils.h"
@@ -165,19 +165,19 @@ daspk_user_jacobian (const ColumnVector&
 #define DASPK_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("daspk: " fmt, arg); \
       DASPK_ABORT (); \
     } \
   while (0)
 
-DEFUN_DLD (daspk, args, nargout,
+DEFUN (daspk, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/corefcn/dasrt.cc
rename from src/DLD-FUNCTIONS/dasrt.cc
rename to src/corefcn/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/corefcn/dasrt.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <iostream>
 #include <string>
 
 #include "DASRT.h"
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "parse.h"
 #include "unwind-prot.h"
@@ -201,22 +201,22 @@ dasrt_user_j (const ColumnVector& x, con
 #define DASRT_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("dasrt: " fmt, arg); \
       DASRT_ABORT; \
     } \
   while (0)
 
-DEFUN_DLD (dasrt, args, nargout,
+DEFUN (dasrt, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
-@deftypefnx {Loadable Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t})\n\
-@deftypefnx {Loadable Function} {@dots{} =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
-@deftypefnx {Loadable Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefn  {Built-in Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
+@deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t})\n\
+@deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/corefcn/dassl.cc
rename from src/DLD-FUNCTIONS/dassl.cc
rename to src/corefcn/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/corefcn/dassl.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include <iomanip>
 #include <iostream>
 
 #include "DASSL.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "unwind-prot.h"
 #include "utils.h"
@@ -165,19 +165,19 @@ dassl_user_jacobian (const ColumnVector&
 #define DASSL_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("dassl: " fmt, arg); \
       DASSL_ABORT (); \
     } \
   while (0)
 
-DEFUN_DLD (dassl, args, nargout,
+DEFUN (dassl, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/corefcn/det.cc
rename from src/DLD-FUNCTIONS/det.cc
rename to src/corefcn/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/corefcn/det.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "DET.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "ops.h"
 
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
@@ -42,20 +42,20 @@ along with Octave; see the file COPYING.
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
 #define MAYBE_CAST(VAR, CLASS) \
   const CLASS *VAR = arg.type_id () == CLASS::static_type_id () ? \
    dynamic_cast<const CLASS *> (&arg.get_rep ()) : 0
 
-DEFUN_DLD (det, args, nargout,
+DEFUN (det, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} det (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{d}, @var{rcond}] =} det (@var{A})\n\
+@deftypefn  {Built-in Function} {} det (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{d}, @var{rcond}] =} det (@var{A})\n\
 Compute the determinant of @var{A}.\n\
 \n\
 Return an estimate of the reciprocal condition number if requested.\n\
 \n\
 Routines from @sc{lapack} are used for full matrices and code from\n\
 @sc{umfpack} is used for sparse matrices.\n\
 \n\
 The determinant should not be used to check a matrix for singularity.\n\
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/corefcn/dlmread.cc
rename from src/DLD-FUNCTIONS/dlmread.cc
rename to src/corefcn/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/corefcn/dlmread.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 
 #include <cctype>
 #include <fstream>
 #include <limits>
 
 #include "file-ops.h"
 #include "lo-ieee.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "oct-stream.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 static const octave_idx_type idx_max =  std::numeric_limits<octave_idx_type>::max ();
 
 static bool
@@ -150,23 +150,23 @@ parse_range_spec (const octave_value& ra
       cup = static_cast<octave_idx_type> (range(3));
     }
   else
     stat = false;
 
   return stat;
 }
 
-DEFUN_DLD (dlmread, args, ,
+DEFUN (dlmread, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{data} =} dlmread (@var{file})\n\
-@deftypefnx {Loadable Function} {@var{data} =} dlmread (@var{file}, @var{sep})\n\
-@deftypefnx {Loadable Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{r0}, @var{c0})\n\
-@deftypefnx {Loadable Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{range})\n\
-@deftypefnx {Loadable Function} {@var{data} =} dlmread (@dots{}, \"emptyvalue\", @var{EMPTYVAL})\n\
+@deftypefn  {Built-in Function} {@var{data} =} dlmread (@var{file})\n\
+@deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep})\n\
+@deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{r0}, @var{c0})\n\
+@deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{range})\n\
+@deftypefnx {Built-in Function} {@var{data} =} dlmread (@dots{}, \"emptyvalue\", @var{EMPTYVAL})\n\
 Read the matrix @var{data} from a text file.  If not defined the separator\n\
 between fields is determined from the file itself.  Otherwise the\n\
 separation character is defined by @var{sep}.\n\
 \n\
 Given two scalar arguments @var{r0} and @var{c0}, these define the starting\n\
 row and column of the data to be read.  These values are indexed from zero,\n\
 such that the first row corresponds to an index of zero.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/corefcn/dot.cc
rename from src/DLD-FUNCTIONS/dot.cc
rename to src/corefcn/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/corefcn/dot.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "f77-fcn.h"
 #include "mx-base.h"
 #include "error.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "parse.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (ddot3, DDOT3) (const octave_idx_type&, const octave_idx_type&,
                            const octave_idx_type&, const double*,
                            const double*, double*);
@@ -98,19 +98,19 @@ get_red_dims (const dim_vector& x, const
       else
         {
           k = x(i);
           z(i) = 1;
         }
     }
 }
 
-DEFUN_DLD (dot, args, ,
+DEFUN (dot, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} dot (@var{x}, @var{y}, @var{dim})\n\
+@deftypefn {Built-in Function} {} dot (@var{x}, @var{y}, @var{dim})\n\
 Compute the dot product of two vectors.  If @var{x} and @var{y}\n\
 are matrices, calculate the dot products along the first\n\
 non-singleton dimension.  If the optional argument @var{dim} is\n\
 given, calculate the dot products along this dimension.\n\
 \n\
 This is equivalent to\n\
 @code{sum (conj (@var{X}) .* @var{Y}, @var{dim})},\n\
 but avoids forming a temporary array and is faster.  When @var{X} and\n\
@@ -244,19 +244,19 @@ but avoids forming a temporary array and
 %! y = [-0.5, 2; 0.5, -2];
 %! assert (dot (x, y), [0 0]);
 
 %!test
 %! x = [1+i, 3-i; 1-i, 3-i];
 %! assert (dot (x, x), [4, 20]);
 */
 
-DEFUN_DLD (blkmm, args, ,
+DEFUN (blkmm, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} blkmm (@var{A}, @var{B})\n\
+@deftypefn {Built-in Function} {} blkmm (@var{A}, @var{B})\n\
 Compute products of matrix blocks.  The blocks are given as\n\
 2-dimensional subarrays of the arrays @var{A}, @var{B}.\n\
 The size of @var{A} must have the form @code{[m,k,@dots{}]} and\n\
 size of @var{B} must be @code{[k,n,@dots{}]}.  The result is\n\
 then of size @code{[m,n,@dots{}]} and is computed as follows:\n\
 \n\
 @example\n\
 @group\n\
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/corefcn/eig.cc
rename from src/DLD-FUNCTIONS/eig.cc
rename to src/corefcn/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/corefcn/eig.cc
@@ -22,34 +22,34 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "EIG.h"
 #include "fEIG.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (eig, args, nargout,
+DEFUN (eig, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{lambda} =} eig (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{lambda} =} eig (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{lambda}] =} eig (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})\n\
-Compute the eigenvalues and eigenvectors of a matrix.\n\
+@deftypefn  {Built-in Function} {@var{lambda} =} eig (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{lambda} =} eig (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {[@var{V}, @var{lambda}] =} eig (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})\n\
+Compute the eigenvalues (and optionally the eigenvectors) of a matrix\n\
+or a pair of matrices\n\
 \n\
-Eigenvalues are computed in a several step process which begins with a\n\
-Hessenberg decomposition, followed by a Schur@tie{}decomposition, from which\n\
-the eigenvalues are apparent.  The eigenvectors, when desired, are computed\n\
-by further manipulations of the Schur@tie{}decomposition.\n\
+The algorithm used depends on whether there are one or two input\n\
+matrices, if they are real or complex and if they are symmetric\n\
+(Hermitian if complex) or non-symmetric.\n\
 \n\
 The eigenvalues returned by @code{eig} are not ordered.\n\
 @seealso{eigs, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/corefcn/fft.cc
rename from src/DLD-FUNCTIONS/fft.cc
rename to src/corefcn/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/corefcn/fft.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 #if defined (HAVE_FFTW)
 #define FFTSRC "@sc{fftw}"
 #else
@@ -192,21 +192,21 @@ do_fft (const octave_value_list &args, c
 %!assert (fft (single (1)), single (1))
 %!assert (fft (ones (2,2,"single")), single ([2,2; 0,0]))
 %!assert (fft (eye (2,2,"single")), single ([1,1; 1,-1]))
 
 %!error (fft ())
 */
 
 
-DEFUN_DLD (fft, args, ,
+DEFUN (fft, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} fft (@var{x})\n\
-@deftypefnx {Loadable Function} {} fft (@var{x}, @var{n})\n\
-@deftypefnx {Loadable Function} {} fft (@var{x}, @var{n}, @var{dim})\n\
+@deftypefn  {Built-in Function} {} fft (@var{x})\n\
+@deftypefnx {Built-in Function} {} fft (@var{x}, @var{n})\n\
+@deftypefnx {Built-in Function} {} fft (@var{x}, @var{n}, @var{dim})\n\
 Compute the discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The FFT is calculated along the first non-singleton dimension of the\n\
 array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes the\n\
 FFT for each column of @var{x}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
@@ -221,21 +221,21 @@ If called with three arguments, @var{dim
 dimension of the matrix along which the FFT is performed\n\
 @seealso{ifft, fft2, fftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft (args, "fft", 0);
 }
 
 
-DEFUN_DLD (ifft, args, ,
+DEFUN (ifft, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} ifft (@var{x})\n\
-@deftypefnx {Loadable Function} {} ifft (@var{x}, @var{n})\n\
-@deftypefnx {Loadable Function} {} ifft (@var{x}, @var{n}, @var{dim})\n\
+@deftypefn  {Built-in Function} {} ifft (@var{x})\n\
+@deftypefnx {Built-in Function} {} ifft (@var{x}, @var{n})\n\
+@deftypefnx {Built-in Function} {} ifft (@var{x}, @var{n}, @var{dim})\n\
 Compute the inverse discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The inverse FFT is calculated along the first non-singleton dimension\n\
 of the array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes\n\
 the inverse FFT for each column of @var{x}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/corefcn/fft2.cc
rename from src/DLD-FUNCTIONS/fft2.cc
rename to src/corefcn/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/corefcn/fft2.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
 #if defined (HAVE_FFTW)
@@ -162,20 +162,20 @@ do_fft2 (const octave_value_list &args, 
         {
           gripe_wrong_type_arg (fcn, arg);
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (fft2, args, ,
+DEFUN (fft2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} fft2 (@var{A})\n\
-@deftypefnx {Loadable Function} {} fft2 (@var{A}, @var{m}, @var{n})\n\
+@deftypefn  {Built-in Function} {} fft2 (@var{A})\n\
+@deftypefnx {Built-in Function} {} fft2 (@var{A}, @var{m}, @var{n})\n\
 Compute the two-dimensional discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional arguments @var{m} and @var{n} may be used specify the\n\
 number of rows and columns of @var{A} to use.  If either of these is\n\
 larger than the size of @var{A}, @var{A} is resized and padded with\n\
 zeros.\n\
 \n\
@@ -183,20 +183,20 @@ If @var{A} is a multi-dimensional matrix
 of @var{A} is treated separately.\n\
 @seealso {ifft2, fft, fftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft2 (args, "fft2", 0);
 }
 
 
-DEFUN_DLD (ifft2, args, ,
+DEFUN (ifft2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} ifft2 (@var{A})\n\
-@deftypefnx {Loadable Function} {} ifft2 (@var{A}, @var{m}, @var{n})\n\
+@deftypefn  {Built-in Function} {} ifft2 (@var{A})\n\
+@deftypefnx {Built-in Function} {} ifft2 (@var{A}, @var{m}, @var{n})\n\
 Compute the inverse two-dimensional discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional arguments @var{m} and @var{n} may be used specify the\n\
 number of rows and columns of @var{A} to use.  If either of these is\n\
 larger than the size of @var{A}, @var{A} is resized and padded with\n\
 zeros.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/corefcn/fftn.cc
rename from src/DLD-FUNCTIONS/fftn.cc
rename to src/corefcn/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/corefcn/fftn.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
 #if defined (HAVE_FFTW)
@@ -144,39 +144,39 @@ do_fftn (const octave_value_list &args, 
         {
           gripe_wrong_type_arg (fcn, arg);
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (fftn, args, ,
+DEFUN (fftn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} fftn (@var{A})\n\
-@deftypefnx {Loadable Function} {} fftn (@var{A}, @var{size})\n\
+@deftypefn  {Built-in Function} {} fftn (@var{A})\n\
+@deftypefnx {Built-in Function} {} fftn (@var{A}, @var{size})\n\
 Compute the N-dimensional discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension of @var{A}, then the dimension of\n\
 @var{A} is truncated prior to performing the FFT@.  Otherwise, if an element\n\
 of @var{size} is larger than the corresponding dimension then @var{A}\n\
 is resized and padded with zeros.\n\
 @seealso{ifftn, fft, fft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "fftn", 0);
 }
 
-DEFUN_DLD (ifftn, args, ,
+DEFUN (ifftn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} ifftn (@var{A})\n\
-@deftypefnx {Loadable Function} {} ifftn (@var{A}, @var{size})\n\
+@deftypefn  {Built-in Function} {} ifftn (@var{A})\n\
+@deftypefnx {Built-in Function} {} ifftn (@var{A}, @var{size})\n\
 Compute the inverse N-dimensional discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension of @var{A}, then the dimension of\n\
 @var{A} is truncated prior to performing the inverse FFT@.  Otherwise, if an\n\
 element of @var{size} is larger than the corresponding dimension then @var{A}\n\
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/corefcn/filter.cc
rename from src/DLD-FUNCTIONS/filter.cc
rename to src/corefcn/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/corefcn/filter.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 // jwe, Wed Nov  1 19:15:29 1995.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern MArray<double>
 filter (MArray<double>&, MArray<double>&, MArray<double>&, int dim);
 
 extern MArray<Complex>
@@ -280,22 +280,22 @@ filter (MArray<T>& b, MArray<T>& a, MArr
     si_dims(i) = si_dims(i-1);
   si_dims(0) = si_len;
 
   MArray<T> si (si_dims, T (0.0));
 
   return filter (b, a, x, si, dim);
 }
 
-DEFUN_DLD (filter, args, nargout,
+DEFUN (filter, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, [], @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si}, @var{dim})\n\
+@deftypefn  {Built-in Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
+@deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
+@deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, [], @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si}, @var{dim})\n\
 Return the solution to the following linear, time-invariant difference\n\
 equation:\n\
 @tex\n\
 $$\n\
 \\sum_{k=0}^N a_{k+1} y_{n-k} = \\sum_{k=0}^M b_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/corefcn/find.cc
rename from src/DLD-FUNCTIONS/find.cc
rename to src/corefcn/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/corefcn/find.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 // Find at most N_TO_FIND nonzero elements in NDA.  Search forward if
 // DIRECTION is 1, backward if it is -1.  NARGOUT is the number of
 // output arguments.  If N_TO_FIND is -1, find all nonzero elements.
 
@@ -327,23 +327,23 @@ find_nonzero_elem_idx (const PermMatrix&
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
-DEFUN_DLD (find, args, nargout,
+DEFUN (find, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{idx} =} find (@var{x})\n\
-@deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n})\n\
-@deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
-@deftypefnx {Loadable Function} {[i, j] =} find (@dots{})\n\
-@deftypefnx {Loadable Function} {[i, j, v] =} find (@dots{})\n\
+@deftypefn  {Built-in Function} {@var{idx} =} find (@var{x})\n\
+@deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n})\n\
+@deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
+@deftypefnx {Built-in Function} {[i, j] =} find (@dots{})\n\
+@deftypefnx {Built-in Function} {[i, j, v] =} find (@dots{})\n\
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
 @var{x} is a row vector or as a column otherwise.  To obtain a single index\n\
 for each matrix element, Octave pretends that the columns of a matrix form\n\
 one long vector (like Fortran arrays are stored).  For example:\n\
 \n\
 @example\n\
 @group\n\
 find (eye (2))\n\
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/corefcn/gammainc.cc
rename from src/DLD-FUNCTIONS/gammainc.cc
rename to src/corefcn/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/corefcn/gammainc.cc
@@ -21,23 +21,23 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-specfun.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (gammainc, args, ,
+DEFUN (gammainc, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} gammainc (@var{x}, @var{a})\n\
 @deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"lower\")\n\
 @deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"upper\")\n\
 Compute the normalized incomplete gamma function,\n\
 @tex\n\
 $$\n\
  \\gamma (x, a) = {1 \\over {\\Gamma (a)}}\\displaystyle{\\int_0^x t^{a-1} e^{-t} dt}\n\
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/corefcn/gcd.cc
rename from src/DLD-FUNCTIONS/gcd.cc
rename to src/corefcn/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/corefcn/gcd.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include "dNDArray.h"
 #include "CNDArray.h"
 #include "fNDArray.h"
 #include "fCNDArray.h"
 #include "lo-mappers.h"
 #include "oct-binmap.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 static double
 simple_gcd (double a, double b)
 {
   if (! xisinteger (a) || ! xisinteger (b))
     (*current_liboctave_error_handler)
@@ -427,20 +427,20 @@ do_extended_gcd (const octave_value& a, 
       retval = retval.float_array_value ();
       x = x.float_array_value ();
       y = y.float_array_value ();
     }
 
   return retval;
 }
 
-DEFUN_DLD (gcd, args, nargout,
+DEFUN (gcd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
+@deftypefn  {Built-in Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
+@deftypefnx {Built-in Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 \n\
 Compute the greatest common divisor of @var{a1}, @var{a2}, @dots{}.  If more\n\
 than one argument is given all arguments must be the same size or scalar.\n\
 In this case the greatest common divisor is calculated for each element\n\
 individually.  All elements must be ordinary or Gaussian (complex)\n\
 integers.  Note that for Gaussian integers, the gcd is not unique up to\n\
 units (multiplication by 1, -1, @var{i} or -@var{i}), so an arbitrary\n\
 greatest common divisor amongst four possible is returned.\n\
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/corefcn/getgrent.cc
rename from src/DLD-FUNCTIONS/getgrent.cc
rename to src/corefcn/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/corefcn/getgrent.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <string>
 
 #include <sys/types.h>
 
 #include "oct-group.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // Group file functions.  (Why not?)
@@ -57,19 +57,19 @@ mk_gr_map (const octave_group& gr)
       retval = m;
     }
   else
     retval = 0;
 
   return retval;
 }
 
-DEFUN_DLD (getgrent, args, ,
+DEFUN (getgrent, args, ,
  "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{grp_struct} =} getgrent ()\n\
+@deftypefn {Built-in Function} {@var{grp_struct} =} getgrent ()\n\
 Return an entry from the group database, opening it if necessary.\n\
 Once the end of data has been reached, @code{getgrent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = 0;
@@ -84,19 +84,19 @@ Once the end of data has been reached, @
       retval(0) = mk_gr_map (octave_group::getgrent (msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (getgrgid, args, ,
+DEFUN (getgrgid, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
+@deftypefn {Built-in Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
 Return the first entry from the group database with the group ID\n\
 @var{gid}.  If the group ID does not exist in the database,\n\
 @code{getgrgid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -124,19 +124,19 @@ Return the first entry from the group da
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (getgrnam, args, ,
+DEFUN (getgrnam, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
+@deftypefn {Built-in Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
 Return the first entry from the group database with the group name\n\
 @var{name}.  If the group name does not exist in the database,\n\
 @code{getgrnam} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -157,19 +157,19 @@ Return the first entry from the group da
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (setgrent, args, ,
+DEFUN (setgrent, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} setgrent ()\n\
+@deftypefn {Built-in Function} {} setgrent ()\n\
 Return the internal pointer to the beginning of the group database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
@@ -183,19 +183,19 @@ Return the internal pointer to the begin
       retval(0) = static_cast<double> (octave_group::setgrent (msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (endgrent, args, ,
+DEFUN (endgrent, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} endgrent ()\n\
+@deftypefn {Built-in Function} {} endgrent ()\n\
 Close the group database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/corefcn/getpwent.cc
rename from src/DLD-FUNCTIONS/getpwent.cc
rename to src/corefcn/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/corefcn/getpwent.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <string>
 
 #include <sys/types.h>
 
 #include "oct-passwd.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // Password file functions.  (Why not?)
@@ -60,19 +60,19 @@ mk_pw_map (const octave_passwd& pw)
       retval = m;
     }
   else
     retval = 0;
 
   return retval;
 }
 
-DEFUN_DLD (getpwent, args, ,
+DEFUN (getpwent, args, ,
  "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{pw_struct} =} getpwent ()\n\
+@deftypefn {Built-in Function} {@var{pw_struct} =} getpwent ()\n\
 Return a structure containing an entry from the password database,\n\
 opening it if necessary.  Once the end of the data has been reached,\n\
 @code{getpwent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -88,19 +88,19 @@ opening it if necessary.  Once the end o
       retval(0) = mk_pw_map (octave_passwd::getpwent (msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (getpwuid, args, ,
+DEFUN (getpwuid, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
+@deftypefn {Built-in Function} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
 Return a structure containing the first entry from the password database\n\
 with the user ID @var{uid}.  If the user ID does not exist in the\n\
 database, @code{getpwuid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -128,19 +128,19 @@ database, @code{getpwuid} returns 0.\n\
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (getpwnam, args, ,
+DEFUN (getpwnam, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{pw_struct} =} getpwnam (@var{name})\n\
+@deftypefn {Built-in Function} {@var{pw_struct} =} getpwnam (@var{name})\n\
 Return a structure containing the first entry from the password database\n\
 with the user name @var{name}.  If the user name does not exist in the\n\
 database, @code{getpwname} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -161,19 +161,19 @@ database, @code{getpwname} returns 0.\n\
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (setpwent, args, ,
+DEFUN (setpwent, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} setpwent ()\n\
+@deftypefn {Built-in Function} {} setpwent ()\n\
 Return the internal pointer to the beginning of the password database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
@@ -187,19 +187,19 @@ Return the internal pointer to the begin
       retval(0) = static_cast<double> (octave_passwd::setpwent (msg));
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (endpwent, args, ,
+DEFUN (endpwent, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} endpwent ()\n\
+@deftypefn {Built-in Function} {} endpwent ()\n\
 Close the password database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
 
diff --git a/src/DLD-FUNCTIONS/getrusage.cc b/src/corefcn/getrusage.cc
rename from src/DLD-FUNCTIONS/getrusage.cc
rename to src/corefcn/getrusage.cc
--- a/src/DLD-FUNCTIONS/getrusage.cc
+++ b/src/corefcn/getrusage.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #endif
 
 #if defined (HAVE_SYS_PARAM_H)
 #include <sys/param.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "oct-map.h"
 #include "sysdep.h"
 #include "ov.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 #if !defined (HZ)
 #if defined (CLK_TCK)
@@ -54,19 +54,19 @@ along with Octave; see the file COPYING.
 #endif
 
 #ifndef RUSAGE_SELF
 #define RUSAGE_SELF 0
 #endif
 
 // System resource functions.
 
-DEFUN_DLD (getrusage, , ,
+DEFUN (getrusage, , ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} getrusage ()\n\
+@deftypefn {Built-in Function} {} getrusage ()\n\
 Return a structure containing a number of statistics about the current\n\
 Octave process.  Not all fields are available on all systems.  If it is\n\
 not possible to get CPU time statistics, the CPU time slots are set to\n\
 zero.  Other missing data are replaced by NaN@.  The list of possible\n\
 fields is:\n\
 \n\
 @table @code\n\
 @item idrss\n\
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/corefcn/givens.cc
rename from src/DLD-FUNCTIONS/givens.cc
rename to src/corefcn/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/corefcn/givens.cc
@@ -21,24 +21,24 @@ along with Octave; see the file COPYING.
 */
 
 // Originally written by A. S. Hodel <scotte@eng.auburn.edu>
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
-DEFUN_DLD (givens, args, nargout,
+DEFUN (givens, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{g} =} givens (@var{x}, @var{y})\n\
-@deftypefnx {Loadable Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {@var{g} =} givens (@var{x}, @var{y})\n\
+@deftypefnx {Built-in Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})\n\
 @tex\n\
 Return a $2\\times 2$ orthogonal matrix\n\
 $$\n\
  G = \\left[\\matrix{c & s\\cr -s'& c\\cr}\\right]\n\
 $$\n\
 such that\n\
 $$\n\
  G \\left[\\matrix{x\\cr y}\\right] = \\left[\\matrix{\\ast\\cr 0}\\right]\n\
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/corefcn/hess.cc
rename from src/DLD-FUNCTIONS/hess.cc
rename to src/corefcn/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/corefcn/hess.cc
@@ -24,26 +24,26 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "CmplxHESS.h"
 #include "dbleHESS.h"
 #include "fCmplxHESS.h"
 #include "floatHESS.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (hess, args, nargout,
+DEFUN (hess, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{H} =} hess (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{P}, @var{H}] =} hess (@var{A})\n\
+@deftypefn  {Built-in Function} {@var{H} =} hess (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{P}, @var{H}] =} hess (@var{A})\n\
 @cindex Hessenberg decomposition\n\
 Compute the Hessenberg decomposition of the matrix @var{A}.\n\
 \n\
 The Hessenberg decomposition is\n\
 @tex\n\
 $$\n\
 A = PHP^T\n\
 $$\n\
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/corefcn/hex2num.cc
rename from src/DLD-FUNCTIONS/hex2num.cc
rename to src/corefcn/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/corefcn/hex2num.cc
@@ -21,25 +21,25 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <algorithm>
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (hex2num, args, ,
+DEFUN (hex2num, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{n} =} hex2num (@var{s})\n\
+@deftypefn {Built-in Function} {@var{n} =} hex2num (@var{s})\n\
 Typecast the 16 character hexadecimal character string to an IEEE 754\n\
 double precision number.  If fewer than 16 characters are given the\n\
 strings are right padded with '0' characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate\n\
 number.\n\
 \n\
 @example\n\
@@ -117,19 +117,19 @@ hex2num ([\"4005bf0a8b145769\"; \"402400
 
   return retval;
 }
 
 /*
 %!assert (hex2num (["c00";"bff";"000";"3ff";"400"]), [-2:2]')
 */
 
-DEFUN_DLD (num2hex, args, ,
+DEFUN (num2hex, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{s} =} num2hex (@var{n})\n\
+@deftypefn {Built-in Function} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double precision number or vector to a 16 character hexadecimal\n\
 string of the IEEE 754 representation of the number.  For example:\n\
 \n\
 @example\n\
 @group\n\
 num2hex ([-1, 1, e, Inf, NaN, NA])\n\
 @result{} \"bff0000000000000\n\
     3ff0000000000000\n\
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/corefcn/inv.cc
rename from src/DLD-FUNCTIONS/inv.cc
rename to src/corefcn/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/corefcn/inv.cc
@@ -19,32 +19,32 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ops.h"
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 #include "utils.h"
 
-DEFUN_DLD (inv, args, nargout,
+DEFUN (inv, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{x} =} inv (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{x}, @var{rcond}] =} inv (@var{A})\n\
+@deftypefn  {Built-in Function} {@var{x} =} inv (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{x}, @var{rcond}] =} inv (@var{A})\n\
 Compute the inverse of the square matrix @var{A}.  Return an estimate\n\
 of the reciprocal condition number if requested, otherwise warn of an\n\
 ill-conditioned matrix if the reciprocal condition number is small.\n\
 \n\
 In general it is best to avoid calculating the inverse of a matrix\n\
 directly.  For example, it is both faster and more accurate to solve\n\
 systems of equations (@var{A}*@math{x} = @math{b}) with\n\
 @code{@var{y} = @var{A} \\ @math{b}}, rather than\n\
@@ -231,20 +231,20 @@ of a sparse matrix if possible.\n\
 %!error inv ([1, 2; 3, 4], 2)
 %!error <argument must be a square matrix> inv ([1, 2; 3, 4; 5, 6])
 */
 
 // FIXME -- this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
-DEFUN_DLD (inverse, args, nargout,
+DEFUN (inverse, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{x} =} inverse (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{x}, @var{rcond}] =} inverse (@var{A})\n\
+@deftypefn  {Built-in Function} {@var{x} =} inverse (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{x}, @var{rcond}] =} inverse (@var{A})\n\
 Compute the inverse of the square matrix @var{A}.\n\
 \n\
 This is an alias for @code{inv}.\n\
 @seealso{inv}\n\
 @end deftypefn")
 {
   return Finv (args, nargout);
 }
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/corefcn/kron.cc
rename from src/DLD-FUNCTIONS/kron.cc
rename to src/corefcn/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/corefcn/kron.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "CDiagMatrix.h"
 #include "fCDiagMatrix.h"
 
 #include "PermMatrix.h"
 
 #include "mx-inlines.cc"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 template <class R, class T>
 static MArray<T>
 kron (const MArray<R>& a, const MArray<T>& b)
 {
   assert (a.ndims () == 2);
@@ -238,19 +238,19 @@ dispatch_kron (const octave_value& a, co
         retval = do_kron<Matrix, ComplexMatrix> (a, b);
       else
         retval = do_kron<Matrix, Matrix> (a, b);
     }
   return retval;
 }
 
 
-DEFUN_DLD (kron, args, , "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} kron (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {} kron (@var{A1}, @var{A2}, @dots{})\n\
+DEFUN (kron, args, , "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {} kron (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {} kron (@var{A1}, @var{A2}, @dots{})\n\
 Form the Kronecker product of two or more matrices, defined block by \n\
 block as\n\
 \n\
 @example\n\
 x = [ a(i,j)*b ]\n\
 @end example\n\
 \n\
 For example:\n\
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/corefcn/lookup.cc
rename from src/DLD-FUNCTIONS/lookup.cc
rename to src/corefcn/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/corefcn/lookup.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <cctype>
 #include <functional>
 #include <algorithm>
 
 #include "dNDArray.h"
 #include "CNDArray.h"
 
 #include "Cell.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 
 static
 bool
 contains_char (const std::string& str, char c)
@@ -181,20 +181,20 @@ do_numeric_lookup (const ArrayT& array, 
         }
     }
   else
     retval = idx;
 
   return retval;
 }
 
-DEFUN_DLD (lookup, args, ,
+DEFUN (lookup, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y})\n\
-@deftypefnx {Loadable Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
+@deftypefn  {Built-in Function} {@var{idx} =} lookup (@var{table}, @var{y})\n\
+@deftypefnx {Built-in Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
 Lookup values in a sorted table.  Usually used as a prelude to\n\
 interpolation.\n\
 \n\
 If table is increasing and @code{idx = lookup (table, y)}, then\n\
 @code{table(idx(i)) <= y(i) < table(idx(i+1))} for all @code{y(i)}\n\
 within the table.  If @code{y(i) < table(1)} then\n\
 @code{idx(i)} is 0. If @code{y(i) >= table(end)} or @code{isnan (y(i))} then\n\
 @code{idx(i)} is @code{n}.\n\
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/corefcn/lsode.cc
rename from src/DLD-FUNCTIONS/lsode.cc
rename to src/corefcn/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/corefcn/lsode.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include <iomanip>
 #include <iostream>
 
 #include "LSODE.h"
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "unwind-prot.h"
@@ -151,20 +151,20 @@ lsode_user_jacobian (const ColumnVector&
 #define LSODE_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("lsode: " fmt, arg); \
       LSODE_ABORT (); \
     } \
   while (0)
 
-DEFUN_DLD (lsode, args, nargout,
+DEFUN (lsode, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
-@deftypefnx {Loadable Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
+@deftypefn  {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
+@deftypefnx {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential equations\n\
 @tex\n\
 $$ {dx \\over dt} = f (x, t) $$\n\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/corefcn/lu.cc
rename from src/DLD-FUNCTIONS/lu.cc
rename to src/corefcn/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/corefcn/lu.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include "CmplxLU.h"
 #include "dbleLU.h"
 #include "fCmplxLU.h"
 #include "floatLU.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 template <class MT>
@@ -56,25 +56,25 @@ get_lu_u (const base_lu<MT>& fact)
 {
   MT U = fact.U ();
   if (U.is_square () && fact.regular ())
     return octave_value (U, MatrixType (MatrixType::Upper));
   else
     return U;
 }
 
-DEFUN_DLD (lu, args, nargout,
+DEFUN (lu, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{L}, @var{U}] =} lu (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} lu (@var{S}, @var{thres})\n\
-@deftypefnx {Loadable Function} {@var{y} =} lu (@dots{})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} lu (@dots{}, \"vector\")\n\
+@deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} lu (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})\n\
+@deftypefnx {Built-in Function} {[@dots{}] =} lu (@var{S}, @var{thres})\n\
+@deftypefnx {Built-in Function} {@var{y} =} lu (@dots{})\n\
+@deftypefnx {Built-in Function} {[@dots{}] =} lu (@dots{}, \"vector\")\n\
 @cindex LU decomposition\n\
 Compute the LU@tie{}decomposition of @var{A}.  If @var{A} is full\n\
 subroutines from\n\
 @sc{lapack} are used and if @var{A} is sparse then @sc{umfpack} is used.  The\n\
 result is returned in a permuted form, according to the optional return\n\
 value @var{P}.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
@@ -588,20 +588,20 @@ bool check_lu_dims (const octave_value& 
                     const octave_value& p)
 {
   octave_idx_type m = l.rows (), k = u.rows (), n = u.columns ();
   return ((l.ndims () == 2 && u.ndims () == 2 && k == l.columns ())
             && k == std::min (m, n) &&
             (p.is_undefined () || p.rows () == m));
 }
 
-DEFUN_DLD (luupdate, args, ,
+DEFUN (luupdate, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
+@deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 Given an LU@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{L}*@var{U}}, @var{L}@tie{}lower unit trapezoidal and\n\
 @var{U}@tie{}upper trapezoidal, return the LU@tie{}factorization\n\
 of @w{@var{A} + @var{x}*@var{y}.'}, where @var{x} and @var{y} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).\n\
 Optionally, row-pivoted updating can be used by supplying\n\
 a row permutation (pivoting) matrix @var{P};\n\
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/corefcn/luinc.cc
rename from src/DLD-FUNCTIONS/luinc.cc
rename to src/corefcn/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/corefcn/luinc.cc
@@ -19,34 +19,34 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "oct-map.h"
 
 #include "MatrixType.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
-DEFUN_DLD (luinc, args, nargout,
+DEFUN (luinc, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, '0')\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{droptol})\n\
-@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
+@deftypefn  {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, '0')\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{droptol})\n\
+@deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
 @cindex LU decomposition\n\
 Produce the incomplete LU@tie{}factorization of the sparse matrix @var{A}.\n\
 Two types of incomplete factorization are possible, and the type\n\
 is determined by the second argument to @code{luinc}.\n\
 \n\
 Called with a second argument of '0', the zero-level incomplete\n\
 LU@tie{}factorization is produced.  This creates a factorization of @var{A}\n\
 where the position of the non-zero arguments correspond to the same\n\
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/corefcn/matrix_type.cc
rename from src/DLD-FUNCTIONS/matrix_type.cc
rename to src/corefcn/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/corefcn/matrix_type.cc
@@ -22,33 +22,33 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <algorithm>
 
 #include "ov.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "MatrixType.h"
 #include "oct-locbuf.h"
 
-DEFUN_DLD (matrix_type, args, ,
+DEFUN (matrix_type, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{type} =} matrix_type (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{type} =} matrix_type (@var{A}, \"nocompute\")\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, @var{type})\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, \"upper\", @var{perm})\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, \"lower\", @var{perm})\n\
-@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, \"banded\", @var{nl}, @var{nu})\n\
+@deftypefn  {Built-in Function} {@var{type} =} matrix_type (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{type} =} matrix_type (@var{A}, \"nocompute\")\n\
+@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, @var{type})\n\
+@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"upper\", @var{perm})\n\
+@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"lower\", @var{perm})\n\
+@deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"banded\", @var{nl}, @var{nu})\n\
 Identify the matrix type or mark a matrix as a particular type.  This allows\n\
 more rapid solutions of linear equations involving @var{A} to be performed.\n\
 Called with a single argument, @code{matrix_type} returns the type of the\n\
 matrix and caches it for future use.  Called with more than one argument,\n\
 @code{matrix_type} allows the type of the matrix to be defined.\n\
 \n\
 If the option \"nocompute\" is given, the function will not attempt to guess\n\
 the type if it is still unknown.  This is useful for debugging purposes.\n\
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/corefcn/max.cc
rename from src/DLD-FUNCTIONS/max.cc
rename to src/corefcn/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/corefcn/max.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-math.h"
 #include "dNDArray.h"
 #include "CNDArray.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
@@ -300,23 +300,23 @@ do_minmax_body (const octave_value_list&
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (min, args, nargout,
+DEFUN (min, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} min (@var{x})\n\
-@deftypefnx {Loadable Function} {} min (@var{x}, @var{y})\n\
-@deftypefnx {Loadable Function} {} min (@var{x}, [], @var{dim})\n\
-@deftypefnx {Loadable Function} {} min (@var{x}, @var{y}, @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
+@deftypefn  {Built-in Function} {} min (@var{x})\n\
+@deftypefnx {Built-in Function} {} min (@var{x}, @var{y})\n\
+@deftypefnx {Built-in Function} {} min (@var{x}, [], @var{dim})\n\
+@deftypefnx {Built-in Function} {} min (@var{x}, @var{y}, @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
 For a vector argument, return the minimum value.  For a matrix\n\
 argument, return the minimum value from each column, as a row\n\
 vector, or over the dimension @var{dim} if defined, in which case @var{y} \n\
 should be set to the empty matrix (it's ignored otherwise).  For two matrices\n\
 (or a matrix and scalar), return the pair-wise minimum.\n\
 Thus,\n\
 \n\
 @example\n\
@@ -371,23 +371,23 @@ minimum value(s).  Thus,\n\
 %! assert (y, [5, 7; 6, 8]);
 %! assert (ndims (i), 2);
 %! assert (i, [2, 2; 2, 2]);
 
 %!error min ()
 %!error min (1, 2, 3, 4)
 */
 
-DEFUN_DLD (max, args, nargout,
+DEFUN (max, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} max (@var{x})\n\
-@deftypefnx {Loadable Function} {} max (@var{x}, @var{y})\n\
-@deftypefnx {Loadable Function} {} max (@var{x}, [], @var{dim})\n\
-@deftypefnx {Loadable Function} {} max (@var{x}, @var{y}, @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} max (@var{x})\n\
+@deftypefn  {Built-in Function} {} max (@var{x})\n\
+@deftypefnx {Built-in Function} {} max (@var{x}, @var{y})\n\
+@deftypefnx {Built-in Function} {} max (@var{x}, [], @var{dim})\n\
+@deftypefnx {Built-in Function} {} max (@var{x}, @var{y}, @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} max (@var{x})\n\
 For a vector argument, return the maximum value.  For a matrix\n\
 argument, return the maximum value from each column, as a row\n\
 vector, or over the dimension @var{dim} if defined, in which case @var{y} \n\
 should be set to the empty matrix (it's ignored otherwise).  For two matrices\n\
 (or a matrix and scalar), return the pair-wise maximum.\n\
 Thus,\n\
 \n\
 @example\n\
@@ -543,21 +543,21 @@ do_cumminmax_body (const octave_value_li
       }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN_DLD (cummin, args, nargout,
+DEFUN (cummin, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} cummin (@var{x})\n\
-@deftypefnx {Loadable Function} {} cummin (@var{x}, @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
+@deftypefn  {Built-in Function} {} cummin (@var{x})\n\
+@deftypefnx {Built-in Function} {} cummin (@var{x}, @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
 Return the cumulative minimum values along dimension @var{dim}.  If @var{dim}\n\
 is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummin ([5 4 6 2 3 1])\n\
    @result{}  5  4  4  2  2  1\n\
 @end group\n\
@@ -585,21 +585,21 @@ endfor\n\
 @noindent\n\
 but computed in a much faster manner.\n\
 @seealso{cummax, min, max}\n\
 @end deftypefn")
 {
   return do_cumminmax_body (args, nargout, true);
 }
 
-DEFUN_DLD (cummax, args, nargout,
+DEFUN (cummax, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} cummax (@var{x})\n\
-@deftypefnx {Loadable Function} {} cummax (@var{x}, @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
+@deftypefn  {Built-in Function} {} cummax (@var{x})\n\
+@deftypefnx {Built-in Function} {} cummax (@var{x}, @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
 Return the cumulative maximum values along dimension @var{dim}.  If @var{dim}\n\
 is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummax ([1 3 2 6 4 5])\n\
    @result{}  1  3  3  6  6  6\n\
 @end group\n\
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/corefcn/md5sum.cc
rename from src/DLD-FUNCTIONS/md5sum.cc
rename to src/corefcn/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/corefcn/md5sum.cc
@@ -23,28 +23,28 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 #include <vector>
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "file-stat.h"
 #include "file-ops.h"
 #include "gripes.h"
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-md5.h"
 
-DEFUN_DLD (md5sum, args, ,
+DEFUN (md5sum, args, ,
    "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} md5sum (@var{file})\n\
-@deftypefnx {Loadable Function} {} md5sum (@var{str}, @var{opt})\n\
+@deftypefn  {Built-in Function} {} md5sum (@var{file})\n\
+@deftypefnx {Built-in Function} {} md5sum (@var{str}, @var{opt})\n\
 Calculate the MD5 sum of the file @var{file}.  If the second parameter\n\
 @var{opt} exists and is true, then calculate the MD5 sum of the\n\
 string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/mgorth.cc b/src/corefcn/mgorth.cc
rename from src/DLD-FUNCTIONS/mgorth.cc
rename to src/corefcn/mgorth.cc
--- a/src/DLD-FUNCTIONS/mgorth.cc
+++ b/src/corefcn/mgorth.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct-norm.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 
 template <class ColumnVector, class Matrix, class RowVector>
 static void
 do_mgorth (ColumnVector& x, const Matrix& V, RowVector& h)
 {
   octave_idx_type Vc = V.columns ();
@@ -43,19 +43,19 @@ do_mgorth (ColumnVector& x, const Matrix
       x -= h(j) * Vcj;
     }
 
   h(Vc) = xnorm (x);
   if (real (h(Vc)) > 0)
     x = x / h(Vc);
 }
 
-DEFUN_DLD (mgorth, args, nargout,
+DEFUN (mgorth, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})\n\
+@deftypefn {Built-in Function} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})\n\
 Orthogonalize a given column vector @var{x} with respect to a given\n\
 orthonormal basis @var{v} using a modified Gram-Schmidt orthogonalization.  \n\
 On exit, @var{y} is a unit vector such that:\n\
 \n\
 @example\n\
 @group\n\
   norm (@var{y}) = 1\n\
   @var{v}' * @var{y} = 0\n\
diff --git a/src/corefcn/module.mk b/src/corefcn/module.mk
new file mode 100644
--- /dev/null
+++ b/src/corefcn/module.mk
@@ -0,0 +1,70 @@
+EXTRA_DIST += \
+  corefcn/module.mk
+
+corefcn_SRC = \
+  corefcn/__contourc__.cc \
+  corefcn/__dispatch__.cc \
+  corefcn/__lin_interpn__.cc \
+  corefcn/__pchip_deriv__.cc \
+  corefcn/__qp__.cc \
+  corefcn/balance.cc \
+  corefcn/besselj.cc \
+  corefcn/betainc.cc \
+  corefcn/bsxfun.cc \
+  corefcn/cellfun.cc \
+  corefcn/colloc.cc \
+  corefcn/conv2.cc \
+  corefcn/daspk.cc \
+  corefcn/dasrt.cc \
+  corefcn/dassl.cc \
+  corefcn/det.cc \
+  corefcn/dlmread.cc \
+  corefcn/dot.cc \
+  corefcn/eig.cc \
+  corefcn/fft.cc \
+  corefcn/fft2.cc \
+  corefcn/fftn.cc \
+  corefcn/filter.cc \
+  corefcn/find.cc \
+  corefcn/gammainc.cc \
+  corefcn/gcd.cc \
+  corefcn/getgrent.cc \
+  corefcn/getpwent.cc \
+  corefcn/getrusage.cc \
+  corefcn/givens.cc \
+  corefcn/hess.cc \
+  corefcn/hex2num.cc \
+  corefcn/inv.cc \
+  corefcn/kron.cc \
+  corefcn/lookup.cc \
+  corefcn/lsode.cc \
+  corefcn/lu.cc \
+  corefcn/luinc.cc \
+  corefcn/matrix_type.cc \
+  corefcn/max.cc \
+  corefcn/md5sum.cc \
+  corefcn/mgorth.cc \
+  corefcn/nproc.cc \
+  corefcn/pinv.cc \
+  corefcn/quad.cc \
+  corefcn/quadcc.cc \
+  corefcn/qz.cc \
+  corefcn/rand.cc \
+  corefcn/rcond.cc \
+  corefcn/regexp.cc \
+  corefcn/schur.cc \
+  corefcn/spparms.cc \
+  corefcn/sqrtm.cc \
+  corefcn/str2double.cc \
+  corefcn/strfind.cc \
+  corefcn/sub2ind.cc \
+  corefcn/svd.cc \
+  corefcn/syl.cc \
+  corefcn/time.cc \
+  corefcn/tril.cc \
+  corefcn/typecast.cc
+
+noinst_LTLIBRARIES += corefcn/libcorefcn.la
+
+corefcn_libcorefcn_la_SOURCES = $(corefcn_SRC)
+
diff --git a/src/DLD-FUNCTIONS/nproc.cc b/src/corefcn/nproc.cc
rename from src/DLD-FUNCTIONS/nproc.cc
rename to src/corefcn/nproc.cc
--- a/src/DLD-FUNCTIONS/nproc.cc
+++ b/src/corefcn/nproc.cc
@@ -19,23 +19,23 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "nproc.h"
 
-DEFUN_DLD (nproc, args, nargout,
+DEFUN (nproc, args, nargout,
    "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} nproc ()\n\
-@deftypefnx {Loadable Function} {} nproc (@var{query})\n\
+@deftypefn  {Built-in Function} {} nproc ()\n\
+@deftypefnx {Built-in Function} {} nproc (@var{query})\n\
 Return the current number of available processors.\n\
 \n\
 If called with the optional argument @var{query}, modify how processors\n\
 are counted as follows:\n\
 \n\
 @table @code\n\
 @item all\n\
 total number of processors.\n\
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/corefcn/pinv.cc
rename from src/DLD-FUNCTIONS/pinv.cc
rename to src/corefcn/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/corefcn/pinv.cc
@@ -19,32 +19,32 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "ops.h"
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
-DEFUN_DLD (pinv, args, ,
+DEFUN (pinv, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} pinv (@var{x})\n\
-@deftypefnx {Loadable Function} {} pinv (@var{x}, @var{tol})\n\
+@deftypefn  {Built-in Function} {} pinv (@var{x})\n\
+@deftypefnx {Built-in Function} {} pinv (@var{x}, @var{tol})\n\
 Return the pseudoinverse of @var{x}.  Singular values less than\n\
 @var{tol} are ignored.\n\
 \n\
 If the second argument is omitted, it is taken to be\n\
 \n\
 @example\n\
 tol = max (size (@var{x})) * sigma_max (@var{x}) * eps,\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/corefcn/quad.cc
rename from src/DLD-FUNCTIONS/quad.cc
rename to src/corefcn/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/corefcn/quad.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include <iomanip>
 #include <iostream>
 
 #include "Quad.h"
 #include "lo-mappers.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "pager.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
@@ -167,22 +167,22 @@ quad_float_user_function (float x)
 #define QUAD_ABORT2(fmt, arg) \
   do \
     { \
       ::error ("quad: " fmt, arg); \
       QUAD_ABORT (); \
     } \
   while (0)
 
-DEFUN_DLD (quad, args, nargout,
+DEFUN (quad, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
-@deftypefnx {Loadable Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
-@deftypefnx {Loadable Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
-@deftypefnx {Loadable Function} {[@var{q}, @var{ier}, @var{nfun}, @var{err}] =} quad (@dots{})\n\
+@deftypefn  {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
+@deftypefnx {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
+@deftypefnx {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
+@deftypefnx {Built-in Function} {[@var{q}, @var{ier}, @var{nfun}, @var{err}] =} quad (@dots{})\n\
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b} using\n\
 Fortran routines from @w{@sc{quadpack}}.  @var{f} is a function handle,\n\
 inline function, or a string containing the name of the function to\n\
 evaluate.  The function must have the form @code{y = f (x)} where @var{y} and\n\
 @var{x} are scalars.\n\
 \n\
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both may be infinite.\n\
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/corefcn/quadcc.cc
rename from src/DLD-FUNCTIONS/quadcc.cc
rename to src/corefcn/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/corefcn/quadcc.cc
@@ -19,22 +19,27 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <stdlib.h>
-#include "lo-math.h"
 #include "lo-ieee.h"
-#include "oct.h"
 #include "parse.h"
-#include "ov-fcn-handle.h"
+#include "variables.h"
+
+#include "defun.h"
+#include "error.h"
+#include "oct-obj.h"
+#include "utils.h"
+
+//#include "oct.h"
+//#include "defun.h"
 
 /* Define the size of the interval heap. */
 #define cquad_heapsize                  200
 
 
 /* Data of a single interval */
 typedef struct
 {
@@ -1464,17 +1469,17 @@ downdate (double *c, int n, int d, int *
       n--;
     }
 
 }
 
 
 /* The actual integration routine.  */
 
-DEFUN_DLD (quadcc, args, nargout,
+DEFUN (quadcc, args, nargout,
 "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b})\n\
 @deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol})\n\
 @deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
 @deftypefnx {Function File} {[@var{q}, @var{err}, @var{nr_points}] =} quadcc (@dots{})\n\
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b}\n\
 using the doubly-adaptive Clenshaw-Curtis quadrature described by P. Gonnet\n\
 in @cite{Increasing the Reliability of Adaptive Quadrature Using Explicit\n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/corefcn/qz.cc
rename from src/DLD-FUNCTIONS/qz.cc
rename to src/corefcn/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/corefcn/qz.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 
 #include "CmplxQRP.h"
 #include "CmplxQR.h"
 #include "dbleQR.h"
 #include "f77-fcn.h"
 #include "lo-math.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "pager.h"
 #if defined (DEBUG) || defined (DEBUG_SORT)
 #include "pr-output.h"
@@ -285,20 +285,20 @@ fout (const octave_idx_type& lsize, cons
     return (fabs (alpha) >= fabs (beta) ? 1 : -1);
   else
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
 
 //FIXME: Matlab does not produce lambda as the first output argument.
 //       Compatibility problem?
-DEFUN_DLD (qz, args, nargout,
+DEFUN (qz, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{lambda} =} qz (@var{A}, @var{B})\n\
-@deftypefnx {Loadable Function} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})\n\
+@deftypefn  {Built-in Function} {@var{lambda} =} qz (@var{A}, @var{B})\n\
+@deftypefnx {Built-in Function} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})\n\
 QZ@tie{}decomposition of the generalized eigenvalue problem\n\
 (@math{A x = s B x}).  There are three ways to call this function:\n\
 @enumerate\n\
 @item @code{@var{lambda} = qz (@var{A}, @var{B})}\n\
 \n\
 Computes the generalized eigenvalues\n\
 @tex\n\
 $\\lambda$\n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/corefcn/rand.cc
rename from src/DLD-FUNCTIONS/rand.cc
rename to src/corefcn/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/corefcn/rand.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #endif
 #include <string>
 
 #include "f77-fcn.h"
 #include "lo-mappers.h"
 #include "oct-rand.h"
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-re-mat.h"
 
 /*
@@ -358,29 +358,29 @@ do_rand (const octave_value_list& args, 
               return m;
             }
         }
       else
         return octave_rand::nd_array (dims);
     }
 }
 
-DEFUN_DLD (rand, args, ,
+DEFUN (rand, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} rand (@var{n})\n\
-@deftypefnx {Loadable Function} {} rand (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} rand ([@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} rand (\"state\")\n\
-@deftypefnx {Loadable Function} {} rand (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} rand (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} rand (\"seed\")\n\
-@deftypefnx {Loadable Function} {} rand (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} rand (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} rand (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} rand (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} rand (@var{n})\n\
+@deftypefnx {Built-in Function} {} rand (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} rand ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} rand (\"state\")\n\
+@deftypefnx {Built-in Function} {} rand (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} rand (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} rand (\"seed\")\n\
+@deftypefnx {Built-in Function} {} rand (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} rand (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} rand (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} rand (@dots{}, \"double\")\n\
 Return a matrix with random elements uniformly distributed on the\n\
 interval (0, 1).  The arguments are handled the same as the arguments\n\
 for @code{eye}.\n\
 \n\
 You can query the state of the random number generator using the\n\
 form\n\
 \n\
 @example\n\
@@ -530,29 +530,29 @@ or \"single\" argument.  These are the o
 %!   assert (var (x), 1/48, 0.0632);
 %!   assert (skewness (x), 0, 0.012);
 %!   assert (kurtosis (x), -6/5, 0.0094);
 %! endif
 */
 
 static std::string current_distribution = octave_rand::distribution ();
 
-DEFUN_DLD (randn, args, ,
+DEFUN (randn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randn (@var{n})\n\
-@deftypefnx {Loadable Function} {} randn (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} randn ([@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} randn (\"state\")\n\
-@deftypefnx {Loadable Function} {} randn (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randn (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} randn (\"seed\")\n\
-@deftypefnx {Loadable Function} {} randn (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randn (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} randn (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} randn (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} randn (@var{n})\n\
+@deftypefnx {Built-in Function} {} randn (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} randn ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} randn (\"state\")\n\
+@deftypefnx {Built-in Function} {} randn (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randn (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} randn (\"seed\")\n\
+@deftypefnx {Built-in Function} {} randn (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randn (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} randn (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} randn (@dots{}, \"double\")\n\
 Return a matrix with normally distributed random\n\
 elements having zero mean and variance one.  The arguments are\n\
 handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to a normal distribution.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
@@ -601,29 +601,29 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   x = randn (100000, 1);
 %!   assert (mean (x), 0, 0.01);
 %!   assert (var (x), 1, 0.02);
 %!   assert (skewness (x), 0, 0.02);
 %!   assert (kurtosis (x), 0, 0.04);
 %! endif
 */
 
-DEFUN_DLD (rande, args, ,
+DEFUN (rande, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} rande (@var{n})\n\
-@deftypefnx {Loadable Function} {} rande (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} rande ([@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} rande (\"state\")\n\
-@deftypefnx {Loadable Function} {} rande (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} rande (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} rande (\"seed\")\n\
-@deftypefnx {Loadable Function} {} rande (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} rande (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} rande (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} rande (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} rande (@var{n})\n\
+@deftypefnx {Built-in Function} {} rande (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} rande ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} rande (\"state\")\n\
+@deftypefnx {Built-in Function} {} rande (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} rande (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} rande (\"seed\")\n\
+@deftypefnx {Built-in Function} {} rande (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} rande (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} rande (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} rande (@dots{}, \"double\")\n\
 Return a matrix with exponentially distributed random elements.  The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to an exponential distribution.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
 or \"single\" argument.  These are the only valid classes.\n\
@@ -673,29 +673,29 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert (min (x)>0);   # *** Please report this!!! ***
 %!   assert (mean (x), 1, 0.01);
 %!   assert (var (x), 1, 0.03);
 %!   assert (skewness (x), 2, 0.06);
 %!   assert (kurtosis (x), 6, 0.7);
 %! endif
 */
 
-DEFUN_DLD (randg, args, ,
+DEFUN (randg, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randg (@var{n})\n\
-@deftypefnx {Loadable Function} {} randg (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} randg ([@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} randg (\"state\")\n\
-@deftypefnx {Loadable Function} {} randg (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randg (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} randg (\"seed\")\n\
-@deftypefnx {Loadable Function} {} randg (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randg (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} randg (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} randg (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} randg (@var{n})\n\
+@deftypefnx {Built-in Function} {} randg (@var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} randg ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} randg (\"state\")\n\
+@deftypefnx {Built-in Function} {} randg (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randg (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} randg (\"seed\")\n\
+@deftypefnx {Built-in Function} {} randg (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randg (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} randg (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} randg (@dots{}, \"double\")\n\
 Return a matrix with @code{gamma (@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
 except for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
 \n\
 @table @asis\n\
 @item @code{gamma (a, b)} for @code{a > -1}, @code{b > 0}\n\
@@ -944,29 +944,29 @@ or \"single\" argument.  These are the o
 %!   x = randg (a, 100000, 1);
 %!   assert (mean (x),     a,          0.2);
 %!   assert (var (x),      a,          2);
 %!   assert (skewness (x), 2/sqrt (a), 0.05);
 %!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
 */
 
-DEFUN_DLD (randp, args, ,
+DEFUN (randp, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randp (@var{l}, @var{n})\n\
-@deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Loadable Function} {} randp (@var{l}, [@var{n} @var{m} @dots{}])\n\
-@deftypefnx {Loadable Function} {@var{v} =} randp (\"state\")\n\
-@deftypefnx {Loadable Function} {} randp (\"state\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randp (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {@var{v} =} randp (\"seed\")\n\
-@deftypefnx {Loadable Function} {} randp (\"seed\", @var{v})\n\
-@deftypefnx {Loadable Function} {} randp (\"seed\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} randp (@dots{}, \"single\")\n\
-@deftypefnx {Loadable Function} {} randp (@dots{}, \"double\")\n\
+@deftypefn  {Built-in Function} {} randp (@var{l}, @var{n})\n\
+@deftypefnx {Built-in Function} {} randp (@var{l}, @var{n}, @var{m}, @dots{})\n\
+@deftypefnx {Built-in Function} {} randp (@var{l}, [@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {@var{v} =} randp (\"state\")\n\
+@deftypefnx {Built-in Function} {} randp (\"state\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randp (\"state\", \"reset\")\n\
+@deftypefnx {Built-in Function} {@var{v} =} randp (\"seed\")\n\
+@deftypefnx {Built-in Function} {} randp (\"seed\", @var{v})\n\
+@deftypefnx {Built-in Function} {} randp (\"seed\", \"reset\")\n\
+@deftypefnx {Built-in Function} {} randp (@dots{}, \"single\")\n\
+@deftypefnx {Built-in Function} {} randp (@dots{}, \"double\")\n\
 Return a matrix with Poisson distributed random elements with mean value\n\
 parameter given by the first argument, @var{l}.  The arguments\n\
 are handled the same as the arguments for @code{rand}, except for the\n\
 argument @var{l}.\n\
 \n\
 Five different algorithms are used depending on the range of @var{l}\n\
 and whether or not @var{l} is a scalar or a matrix.\n\
 \n\
@@ -1091,20 +1091,20 @@ or \"single\" argument.  These are the o
 %!     assert (mean (x), a(1), a(2));
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 */
 
-DEFUN_DLD (randperm, args, ,
+DEFUN (randperm, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} randperm (@var{n})\n\
-@deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
+@deftypefn  {Built-in Function} {} randperm (@var{n})\n\
+@deftypefnx {Built-in Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} unique entries, sampled without\n\
 replacement from @code{1:@var{n}}.  The complexity is O(@var{n}) in\n\
 memory and O(@var{m}) in time, unless @var{m} < @var{n}/5, in which case\n\
 O(@var{m}) memory is used as well.  The randomization is performed using\n\
 rand().  All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/corefcn/rcond.cc
rename from src/DLD-FUNCTIONS/rcond.cc
rename to src/corefcn/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/corefcn/rcond.cc
@@ -19,25 +19,25 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (rcond, args, ,
+DEFUN (rcond, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{c} =} rcond (@var{A})\n\
+@deftypefn {Built-in Function} {@var{c} =} rcond (@var{A})\n\
 Compute the 1-norm estimate of the reciprocal condition number as returned\n\
 by @sc{lapack}.  If the matrix is well-conditioned then @var{c} will be near\n\
 1 and if the matrix is poorly conditioned it will be close to zero.\n\
 \n\
 The matrix @var{A} must not be sparse.  If the matrix is sparse then\n\
 @code{condest (@var{A})} or @code{rcond (full (@var{A}))} should be used\n\
 instead.\n\
 @seealso{cond, condest}\n\
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/corefcn/regexp.cc
rename from src/DLD-FUNCTIONS/regexp.cc
rename to src/corefcn/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/corefcn/regexp.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <pcre.h>
 
 #include "base-list.h"
 #include "oct-locbuf.h"
 #include "quit.h"
 #include "regexp.h"
 #include "str-vec.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "Cell.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // Replace backslash escapes in a string with the real values.  We need
@@ -531,20 +531,20 @@ octcellregexp (const octave_value_list &
     }
   else
     retval = octregexp (args, nargout, who, case_insensitive);
 
   return retval;
 
 }
 
-DEFUN_DLD (regexp, args, nargout,
+DEFUN (regexp, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexp (@var{str}, @var{pat})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} regexp (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
+@deftypefn  {Built-in Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexp (@var{str}, @var{pat})\n\
+@deftypefnx {Built-in Function} {[@dots{}] =} regexp (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 Regular expression string matching.  Search for @var{pat} in @var{str} and\n\
 return the positions and substrings of any matches, or empty values if there\n\
 are none.\n\
 \n\
 The matched pattern @var{pat} can include any of the standard regex\n\
 operators, including:\n\
 \n\
 @table @code\n\
@@ -1011,20 +1011,20 @@ zero or more 'b' characters at positions
 %! [a, b] = regexp (str, "[o]+", "match", "split");
 %! assert (a, {"oo"});
 %! assert (b, {"f", " bar"});
 
 %!assert (regexp ("\n", '\n'), 1);
 %!assert (regexp ("\n", "\n"), 1);
 */
 
-DEFUN_DLD (regexpi, args, nargout,
+DEFUN (regexpi, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexpi (@var{str}, @var{pat})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
+@deftypefn  {Built-in Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexpi (@var{str}, @var{pat})\n\
+@deftypefnx {Built-in Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 \n\
 Case insensitive regular expression string matching.  Search for @var{pat} in\n\
 @var{str} and return the positions and substrings of any matches, or empty\n\
 values if there are none.  @xref{doc-regexp,,regexp}, for details on the\n\
 syntax of the search pattern.\n\
 @seealso{regexp}\n\
 @end deftypefn")
 {
@@ -1223,20 +1223,20 @@ octregexprep (const octave_value_list &a
   bool extra_args = false;
   parse_options (options, regexpargs, who, 0, extra_args);
   if (error_state)
     return retval;
 
   return regexp_replace (pattern, buffer, replacement, options, who);
 }
 
-DEFUN_DLD (regexprep, args, ,
+DEFUN (regexprep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
-@deftypefnx {Loadable Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
+@deftypefn  {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
+@deftypefnx {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
 Replace occurrences of pattern @var{pat} in @var{string} with @var{repstr}.\n\
 \n\
 The pattern is a regular expression as documented for @code{regexp}.\n\
 @xref{doc-regexp,,regexp}.\n\
 \n\
 The replacement string may contain @code{$i}, which substitutes\n\
 for the ith set of parentheses in the match string.  For example,\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/corefcn/schur.cc
rename from src/DLD-FUNCTIONS/schur.cc
rename to src/corefcn/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/corefcn/schur.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "CmplxSCHUR.h"
 #include "dbleSCHUR.h"
 #include "fCmplxSCHUR.h"
 #include "floatSCHUR.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 template <class Matrix>
 static octave_value
 mark_upper_triangular (const Matrix& a)
@@ -52,23 +52,23 @@ mark_upper_triangular (const Matrix& a)
     if (a(i,i) == zero)
       return retval;
 
   retval.matrix_type (MatrixType::Upper);
 
   return retval;
 }
 
-DEFUN_DLD (schur, args, nargout,
+DEFUN (schur, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{S} =} schur (@var{A})\n\
-@deftypefnx {Loadable Function} {@var{S} =} schur (@var{A}, \"real\")\n\
-@deftypefnx {Loadable Function} {@var{S} =} schur (@var{A}, \"complex\")\n\
-@deftypefnx {Loadable Function} {@var{S} =} schur (@var{A}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{U}, @var{S}] =} schur (@var{A}, @dots{})\n\
+@deftypefn  {Built-in Function} {@var{S} =} schur (@var{A})\n\
+@deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, \"real\")\n\
+@deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, \"complex\")\n\
+@deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, @var{opt})\n\
+@deftypefnx {Built-in Function} {[@var{U}, @var{S}] =} schur (@var{A}, @dots{})\n\
 @cindex Schur decomposition\n\
 Compute the Schur@tie{}decomposition of @var{A}\n\
 @tex\n\
 $$\n\
  S = U^T A U\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -287,17 +287,17 @@ Riccati equations in control (see @code{
 
 %!test
 %! fail ("schur ([1, 2; 3, 4], 2)", "warning");
 
 %!error schur ()
 %!error <argument must be a square matrix> schur ([1, 2, 3; 4, 5, 6])
 */
 
-DEFUN_DLD (rsf2csf, args, nargout,
+DEFUN (rsf2csf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
 Convert a real, upper quasi-triangular Schur@tie{}form @var{TR} to a complex,\n\
 upper triangular Schur@tie{}form @var{T}.\n\
 \n\
 Note that the following relations hold:\n\
 \n\
 @tex\n\
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/corefcn/spparms.cc
rename from src/DLD-FUNCTIONS/spparms.cc
rename to src/corefcn/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/corefcn/spparms.cc
@@ -20,34 +20,34 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "ov.h"
 #include "pager.h"
 #include "error.h"
 #include "gripes.h"
 
 #include "oct-spparms.h"
 
-DEFUN_DLD (spparms, args, nargout,
+DEFUN (spparms, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} { } spparms ()\n\
-@deftypefnx {Loadable Function} {@var{vals} =} spparms ()\n\
-@deftypefnx {Loadable Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
-@deftypefnx {Loadable Function} {@var{val} =} spparms (@var{key})\n\
-@deftypefnx {Loadable Function} { } spparms (@var{vals})\n\
-@deftypefnx {Loadable Function} { } spparms (\"defaults\")\n\
-@deftypefnx {Loadable Function} { } spparms (\"tight\")\n\
-@deftypefnx {Loadable Function} { } spparms (@var{key}, @var{val})\n\
+@deftypefn  {Built-in Function} { } spparms ()\n\
+@deftypefnx {Built-in Function} {@var{vals} =} spparms ()\n\
+@deftypefnx {Built-in Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
+@deftypefnx {Built-in Function} {@var{val} =} spparms (@var{key})\n\
+@deftypefnx {Built-in Function} { } spparms (@var{vals})\n\
+@deftypefnx {Built-in Function} { } spparms (\"defaults\")\n\
+@deftypefnx {Built-in Function} { } spparms (\"tight\")\n\
+@deftypefnx {Built-in Function} { } spparms (@var{key}, @var{val})\n\
 Query or set the parameters used by the sparse solvers and factorization\n\
 functions.  The first four calls above get information about the current\n\
 settings, while the others change the current settings.  The parameters are\n\
 stored as pairs of keys and values, where the values are all floats and the\n\
 keys are one of the following strings:\n\
 \n\
 @table @samp\n\
 @item spumoni\n\
@@ -121,17 +121,17 @@ running time.\n\
     }
   else if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           std::string str = args(0).string_value ();
           int len = str.length ();
           for (int i = 0; i < len; i++)
-            str [i] = tolower (str [i]);
+            str[i] = tolower (str[i]);
 
           if (str == "defaults")
             octave_sparse_params::defaults ();
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/corefcn/sqrtm.cc
rename from src/DLD-FUNCTIONS/sqrtm.cc
rename to src/corefcn/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/corefcn/sqrtm.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <float.h>
 
 #include "CmplxSCHUR.h"
 #include "fCmplxSCHUR.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "oct-norm.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "utils.h"
 #include "xnorm.h"
 
 template <class Matrix>
 static void
 sqrtm_utri_inplace (Matrix& T)
@@ -194,20 +194,20 @@ do_sqrtm (const octave_value& arg)
           }
           break;
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (sqrtm, args, nargout,
+DEFUN (sqrtm, args, nargout,
  "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{s} =} sqrtm (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{s}, @var{error_estimate}] =} sqrtm (@var{A})\n\
+@deftypefn  {Built-in Function} {@var{s} =} sqrtm (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{s}, @var{error_estimate}] =} sqrtm (@var{A})\n\
 Compute the matrix square root of the square matrix @var{A}.\n\
 \n\
 Ref: N.J. Higham.  @cite{A New sqrtm for @sc{matlab}}.  Numerical\n\
 Analysis Report No. 336, Manchester @nospell{Centre} for Computational\n\
 Mathematics, Manchester, England, January 1999.\n\
 @seealso{expm, logm}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/corefcn/str2double.cc
rename from src/DLD-FUNCTIONS/str2double.cc
rename to src/corefcn/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/corefcn/str2double.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <cctype>
 #include <sstream>
 #include <algorithm>
 
 #include "lo-ieee.h"
 
 #include "Cell.h"
 #include "ov.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "gripes.h"
 #include "utils.h"
 
 static inline bool
 is_imag_unit (int c)
 { return c == 'i' || c == 'j'; }
 
 static std::istringstream&
@@ -289,17 +289,17 @@ str2double1 (const std::string& str_arg)
           else
             set_component (val, num, i2);
         }
     }
 
   return val;
 }
 
-DEFUN_DLD (str2double, args, ,
+DEFUN (str2double, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} str2double (@var{s})\n\
 Convert a string to a real or complex number.\n\
 \n\
 The string must be in one of the following formats where\n\
 a and b are real numbers and the complex unit is 'i' or 'j':\n\
 \n\
 @itemize\n\
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/corefcn/strfind.cc
rename from src/DLD-FUNCTIONS/strfind.cc
rename to src/corefcn/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/corefcn/strfind.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 #include <climits>
 #include <algorithm>
 #include <deque>
 
 #include "Cell.h"
 #include "ov.h"
-#include "defun-dld.h"
+#include "defun.h"
 #include "unwind-prot.h"
 #include "gripes.h"
 #include "utils.h"
 
 // This allows safe indexing with char. In C++, char may be (and often is) signed!
 #define ORD(ch) static_cast<unsigned char>(ch)
 #define TABSIZE (UCHAR_MAX + 1)
 
@@ -140,20 +140,20 @@ qs_search (const Array<char>& needle,
        iter != accum.end (); iter++)
     {
       result.xelem (k++) = *iter;
     }
 
   return result;
 }
 
-DEFUN_DLD (strfind, args, ,
+DEFUN (strfind, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
-@deftypefnx {Loadable Function} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
+@deftypefn  {Built-in Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
+@deftypefnx {Built-in Function} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
 Search for @var{pattern} in the string @var{str} and return the\n\
 starting index of every such occurrence in the vector @var{idx}.\n\
 If there is no such occurrence, or if @var{pattern} is longer\n\
 than @var{str}, then @var{idx} is the empty array @code{[]}.\n\
 \n\
 If a cell array of strings @var{cellstr} is specified\n\
 then @var{idx} is a cell array of vectors, as specified\n\
 above.  Examples:\n\
@@ -314,20 +314,20 @@ qs_replace (const Array<char>& str, cons
 
           std::copy (src + k, src + siz, dest);
         }
     }
 
   return ret;
 }
 
-DEFUN_DLD (strrep, args, ,
+DEFUN (strrep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep})\n\
-@deftypefnx {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep}, \"overlaps\", @var{o})\n\
+@deftypefn  {Built-in Function} {} strrep (@var{s}, @var{ptn}, @var{rep})\n\
+@deftypefnx {Built-in Function} {} strrep (@var{s}, @var{ptn}, @var{rep}, \"overlaps\", @var{o})\n\
 Replace all occurrences of the substring @var{ptn} in the string @var{s}\n\
 with the string @var{rep} and return the result.  For example:\n\
 \n\
 @example\n\
 @group\n\
 strrep (\"This is a test string\", \"is\", \"&%$\")\n\
     @result{}  \"Th&%$ &%$ a test string\"\n\
 @end group\n\
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/corefcn/sub2ind.cc
rename from src/DLD-FUNCTIONS/sub2ind.cc
rename to src/corefcn/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/corefcn/sub2ind.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 
 static dim_vector
 get_dim_vector (const octave_value& val, const char *name)
 {
@@ -56,17 +56,17 @@ get_dim_vector (const octave_value& val,
               break;
             }
         }
     }
 
   return dv;
 }
 
-DEFUN_DLD (sub2ind, args, ,
+DEFUN (sub2ind, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})\n\
 @deftypefnx {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{s1}, @var{s2}, @dots{}, @var{sN})\n\
 Convert subscripts to a linear index.\n\
 \n\
 The following example shows how to convert the two-dimensional\n\
 index @code{(2,3)} of a 3-by-3 matrix to a linear index.  The matrix\n\
 is linearly indexed moving from one column to next, filling up\n\
@@ -162,17 +162,17 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
 %!error <all subscripts .* same size> sub2ind ([10 10], ones (1,2), ones (2,1))
 
 ## Test input validation
 %!error <dimension vector> sub2ind ([10 10.5], 1, 1)
 %!error <subscript indices> sub2ind ([10 10], 1.5, 1)
 %!error <subscript indices> sub2ind ([10 10], 1, 1.5)
 */
 
-DEFUN_DLD (ind2sub, args, nargout,
+DEFUN (ind2sub, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})\n\
 Convert a linear index to subscripts.\n\
 \n\
 The following example shows how to convert the linear index @code{8}\n\
 in a 3-by-3 matrix into a subscript.  The matrix is linearly indexed\n\
 moving from one column to next, filling up all rows in each column.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/corefcn/svd.cc
rename from src/DLD-FUNCTIONS/svd.cc
rename to src/corefcn/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/corefcn/svd.cc
@@ -24,31 +24,31 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "CmplxSVD.h"
 #include "dbleSVD.h"
 #include "fCmplxSVD.h"
 #include "floatSVD.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 static int Vsvd_driver = SVD::GESVD;
 
-DEFUN_DLD (svd, args, nargout,
+DEFUN (svd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{s} =} svd (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})\n\
-@deftypefnx {Loadable Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, @var{econ})\n\
+@deftypefn  {Built-in Function} {@var{s} =} svd (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})\n\
+@deftypefnx {Built-in Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, @var{econ})\n\
 @cindex singular value decomposition\n\
 Compute the singular value decomposition of @var{A}\n\
 @tex\n\
 $$\n\
  A = U S V^{\\dagger}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -397,21 +397,21 @@ decomposition, eliminating the unnecessa
 %! assert (size (s), [0, 0]);
 %! assert (size (v), [0, 0]);
 
 %!error svd ()
 %!error svd ([1, 2; 4, 5], 2, 3)
 %!error [u, v] = svd ([1, 2; 3, 4])
 */
 
-DEFUN_DLD (svd_driver, args, nargout,
+DEFUN (svd_driver, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{val} =} svd_driver ()\n\
-@deftypefnx {Loadable Function} {@var{old_val} =} svd_driver (@var{new_val})\n\
-@deftypefnx {Loadable Function} {} svd_driver (@var{new_val}, \"local\")\n\
+@deftypefn  {Built-in Function} {@var{val} =} svd_driver ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} svd_driver (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} svd_driver (@var{new_val}, \"local\")\n\
 Query or set the underlying @sc{lapack} driver used by @code{svd}.\n\
 Currently recognized values are \"gesvd\" and \"gesdd\".  The default\n\
 is \"gesvd\".\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @seealso{svd}\n\
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/corefcn/syl.cc
rename from src/DLD-FUNCTIONS/syl.cc
rename to src/corefcn/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/corefcn/syl.cc
@@ -21,25 +21,25 @@ along with Octave; see the file COPYING.
 */
 
 // Author: A. S. Hodel <scotte@eng.auburn.edu>
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD (syl, args, nargout,
+DEFUN (syl, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{x} =} syl (@var{A}, @var{B}, @var{C})\n\
+@deftypefn {Built-in Function} {@var{x} =} syl (@var{A}, @var{B}, @var{C})\n\
 Solve the Sylvester equation\n\
 @tex\n\
 $$\n\
  A X + X B + C = 0\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/corefcn/time.cc
rename from src/DLD-FUNCTIONS/time.cc
rename to src/corefcn/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/corefcn/time.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-map.h"
 #include "oct-time.h"
 #include "ov.h"
 #include "oct-obj.h"
 
 // Date and time functions.
 
@@ -96,19 +96,19 @@ extract_tm (const octave_scalar_map& m)
   tm.wday (intfield (m, "wday"));
   tm.yday (intfield (m, "yday"));
   tm.isdst (intfield (m, "isdst"));
   tm.zone (stringfield (m, "zone"));
 
   return tm;
 }
 
-DEFUN_DLD (time, args, ,
+DEFUN (time, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{seconds} =} time ()\n\
+@deftypefn {Built-in Function} {@var{seconds} =} time ()\n\
 Return the current time as the number of seconds since the epoch.  The\n\
 epoch is referenced to 00:00:00 CUT (Coordinated Universal Time) 1 Jan\n\
 1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the\n\
 value returned by @code{time} was 856163706.\n\
 @seealso{strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -120,19 +120,19 @@ value returned by @code{time} was 856163
 
   return retval;
 }
 
 /*
 %!assert (time () > 0)
 */
 
-DEFUN_DLD (gmtime, args, ,
+DEFUN (gmtime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{tm_struct} =} gmtime (@var{t})\n\
+@deftypefn {Built-in Function} {@var{tm_struct} =} gmtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to CUT (Coordinated Universal Time).\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 gmtime (time ())\n\
      @result{} @{\n\
@@ -182,19 +182,19 @@ gmtime (time ())\n\
 %! assert (isfield (ts, "hour"));
 %! assert (isfield (ts, "isdst"));
 %! assert (isfield (ts, "yday"));
 
 %!error gmtime ()
 %!error gmtime (1, 2)
 */
 
-DEFUN_DLD (localtime, args, ,
+DEFUN (localtime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{tm_struct} =} localtime (@var{t})\n\
+@deftypefn {Built-in Function} {@var{tm_struct} =} localtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to the local time zone.\n\
 \n\
 @example\n\
 @group\n\
 localtime (time ())\n\
      @result{} @{\n\
            usec = 0\n\
@@ -243,19 +243,19 @@ localtime (time ())\n\
 %! assert (isfield (ts, "hour"));
 %! assert (isfield (ts, "isdst"));
 %! assert (isfield (ts, "yday"));
 
 %!error localtime ()
 %!error localtime (1, 2)
 */
 
-DEFUN_DLD (mktime, args, ,
+DEFUN (mktime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{seconds} =} mktime (@var{tm_struct})\n\
+@deftypefn {Built-in Function} {@var{seconds} =} mktime (@var{tm_struct})\n\
 Convert a time structure corresponding to the local time to the number\n\
 of seconds since the epoch.  For example:\n\
 \n\
 @example\n\
 @group\n\
 mktime (localtime (time ()))\n\
      @result{} 856163706\n\
 @end group\n\
@@ -297,19 +297,19 @@ mktime (localtime (time ()))\n\
 %!assert (datestr (datenum (1969, 1, 1), 0), "01-Jan-1969 00:00:00")
 %!assert (datestr (datenum (1901, 1, 1), 0), "01-Jan-1901 00:00:00")
 %!assert (datestr (datenum (1795, 1, 1), 0), "01-Jan-1795 00:00:00")
 
 %!error mktime ()
 %!error mktime (1, 2, 3)
 */
 
-DEFUN_DLD (strftime, args, ,
+DEFUN (strftime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} strftime (@var{fmt}, @var{tm_struct})\n\
+@deftypefn {Built-in Function} {} strftime (@var{fmt}, @var{tm_struct})\n\
 Format the time structure @var{tm_struct} in a flexible way using the\n\
 format string @var{fmt} that contains @samp{%} substitutions\n\
 similar to those in @code{printf}.  Except where noted, substituted\n\
 fields have a fixed size; numeric fields are padded if necessary.\n\
 Padding is with zeros by default; for fields that display a single\n\
 number, padding can be changed or inhibited by following the @samp{%}\n\
 with one of the modifiers described below.  Unknown field specifiers are\n\
 copied as normal characters.  All other characters are copied to the\n\
@@ -492,19 +492,19 @@ Year (1970-).\n\
 %!assert (ischar (strftime ("%X%Z%z%a%A%b%B", localtime (time ()))));
 %!assert (ischar (strftime ("%c%C%d%e%D%h%j", localtime (time ()))));
 %!assert (ischar (strftime ("%m%U%w%W%x%y%Y", localtime (time ()))));
 
 %!error strftime ()
 %!error strftime ("foo", localtime (time ()), 1)
 */
 
-DEFUN_DLD (strptime, args, ,
+DEFUN (strptime, args, ,
  "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
+@deftypefn {Built-in Function} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
 Convert the string @var{str} to the time structure @var{tm_struct} under\n\
 the control of the format string @var{fmt}.\n\
 \n\
 If @var{fmt} fails to match, @var{nchars} is 0; otherwise, it is set to the\n\
 position of last matched character plus 1. Always check for this unless\n\
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/corefcn/tril.cc
rename from src/DLD-FUNCTIONS/tril.cc
rename to src/corefcn/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/corefcn/tril.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <algorithm>
 #include "Array.h"
 #include "Sparse.h"
 #include "mx-base.h"
 
 #include "ov.h"
 #include "Cell.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 // The bulk of the work.
 template <class T>
 static Array<T>
 do_tril (const Array<T>& a, octave_idx_type k, bool pack)
 {
@@ -334,17 +334,17 @@ do_trilu (const std::string& name,
               }
             }
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (tril, args, ,
+DEFUN (tril, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} tril (@var{A})\n\
 @deftypefnx {Function File} {} tril (@var{A}, @var{k})\n\
 @deftypefnx {Function File} {} tril (@var{A}, @var{k}, @var{pack})\n\
 @deftypefnx {Function File} {} triu (@var{A})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
 Return a new matrix formed by extracting the lower (@code{tril})\n\
@@ -390,17 +390,17 @@ If the option \"pack\" is given as third
 are not inserted into a matrix, but rather stacked column-wise one above\n\
 other.\n\
 @seealso{diag}\n\
 @end deftypefn")
 {
   return do_trilu ("tril", args);
 }
 
-DEFUN_DLD (triu, args, ,
+DEFUN (triu, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} triu (@var{A})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
 See the documentation for the @code{tril} function (@pxref{tril}).\n\
 @end deftypefn")
 {
   return do_trilu ("triu", args);
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/corefcn/typecast.cc
rename from src/DLD-FUNCTIONS/typecast.cc
rename to src/corefcn/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/corefcn/typecast.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-base.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 
 static dim_vector
 get_vec_dims (const dim_vector& old_dims, octave_idx_type n)
 {
@@ -81,19 +81,19 @@ reinterpret_copy (const void *data, octa
   else
     {
       error ("typecast: incorrect number of input values to make output value");
       return ArrayType ();
     }
 }
 
 
-DEFUN_DLD (typecast, args, ,
+DEFUN (typecast, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} typecast (@var{x}, @var{class})\n\
+@deftypefn {Built-in Function} {} typecast (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting the data of\n\
 @var{x} in memory as data of the numeric class @var{class}.  Both the class\n\
 of @var{x} and @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"logical\"\n\
 \"char\"\n\
@@ -266,19 +266,19 @@ do_bitpack (const boolNDArray& bitp)
     }
   else
     {
       error ("bitpack: incorrect number of bits to make up output value");
       return ArrayType ();
     }
 }
 
-DEFUN_DLD (bitpack, args, ,
+DEFUN (bitpack, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
+@deftypefn {Built-in Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting an array\n\
 @var{x} as raw bit patterns for data of the numeric class @var{class}.\n\
 @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"char\"\n\
 \"int8\"\n\
@@ -375,19 +375,19 @@ do_bitunpack (const ArrayType& array)
       for (int j = 1; j < CHAR_BIT; j++)
         bits[j] = (c >>= 1) & 1;
       bits += CHAR_BIT;
     }
 
   return retval;
 }
 
-DEFUN_DLD (bitunpack, args, ,
+DEFUN (bitunpack, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{y} =} bitunpack (@var{x})\n\
+@deftypefn {Built-in Function} {@var{y} =} bitunpack (@var{x})\n\
 Return an array @var{y} corresponding to the raw bit patterns of\n\
 @var{x}.  @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"char\"\n\
 \"int8\"\n\
 \"int16\"\n\
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -209,16 +209,17 @@ any (eye (2, 4), 2)\n\
 // These mapping functions may also be useful in other places, eh?
 
 DEFUN (atan2, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})\n\
 Compute atan (@var{y} / @var{x}) for corresponding elements of @var{y}\n\
 and @var{x}.  Signal an error if @var{y} and @var{x} do not match in size\n\
 and orientation.\n\
+@seealso{tan, tand, tanh, atanh}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
@@ -2365,16 +2366,17 @@ returns the original array @var{A}.\n\
 }
 
 DEFUN (length, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} length (@var{a})\n\
 Return the \"length\" of the object @var{a}.  For matrix objects, the\n\
 length is the number of rows or columns, whichever is greater (this\n\
 odd definition is used for compatibility with @sc{matlab}).\n\
+@seealso{size}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).length ();
   else
     print_usage ();
@@ -2390,16 +2392,17 @@ For any array, the result will always be
 Trailing singleton dimensions are not counted.\n\
 \n\
 @example\n\
 @group\n\
 ndims (ones (4, 1, 2, 1))\n\
     @result{} 3\n\
 @end group\n\
 @end example\n\
+@seealso{size}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).ndims ();
   else
     print_usage ();
@@ -2483,17 +2486,17 @@ corresponding dimension.  For example,\n
 @group\n\
 size ([1, 2; 3, 4; 5, 6], 2)\n\
     @result{} 2\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 returns the number of columns in the given matrix.\n\
-@seealso{numel}\n\
+@seealso{numel, ndims, length, rows, columns}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -2546,17 +2549,17 @@ returns the number of columns in the giv
 }
 
 DEFUN (size_equal, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} size_equal (@var{a}, @var{b}, @dots{})\n\
 Return true if the dimensions of all arguments agree.\n\
 Trailing singleton dimensions are ignored.\n\
 Called with a single or no argument, size_equal returns true.\n\
-@seealso{size, numel}\n\
+@seealso{size, numel, ndims}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   retval = true;
 
@@ -2578,17 +2581,17 @@ Called with a single or no argument, siz
 
   return retval;
 }
 
 DEFUN (nnz, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{scalar} =} nnz (@var{a})\n\
 Return the number of non zero elements in @var{a}.\n\
-@seealso{sparse}\n\
+@seealso{sparse, nzmax}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).nnz ();
   else
     print_usage ();
@@ -2599,17 +2602,17 @@ Return the number of non zero elements i
 DEFUN (nzmax, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{scalar} =} nzmax (@var{SM})\n\
 Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
 Note that Octave tends to crop unused memory at the first opportunity\n\
 for sparse objects.  There are some cases of user created sparse objects\n\
 where the value returned by @dfn{nzmax} will not be the same as @dfn{nnz},\n\
 but in general they will give the same result.\n\
-@seealso{sparse, spalloc}\n\
+@seealso{nnz, spalloc, sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).nzmax ();
   else
     print_usage ();
@@ -2877,17 +2880,17 @@ is omitted, it defaults to the first non
 This function is conceptually equivalent to computing\n\
 \n\
 @example\n\
 sum (x .* conj (x), dim)\n\
 @end example\n\
 \n\
 @noindent\n\
 but it uses less memory and avoids calling @code{conj} if @var{x} is real.\n\
-@seealso{sum}\n\
+@seealso{sum, prod}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (sumsq);
 }
 
 /*
 %!assert (sumsq ([1, 2, 3]), 14)
 %!assert (sumsq ([-1; -2; 4i]), 21)
@@ -2958,17 +2961,17 @@ Octave are double precision floating poi
 
   return retval;
 }
 
 DEFUN (iscomplex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscomplex (@var{x})\n\
 Return true if @var{x} is a complex-valued numeric object.\n\
-@seealso{isreal, isnumeric}\n\
+@seealso{isreal, isnumeric, islogical, ischar, isfloat, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_complex_type ();
   else
     print_usage ();
@@ -3008,17 +3011,17 @@ often be more convenient than expression
 For example:\n\
 \n\
 @example\n\
 @group\n\
 complex ([1, 2], [3, 4])\n\
   @result{} [ 1 + 3i   2 + 4i ]\n\
 @end group\n\
 @end example\n\
-@seealso{real, imag, iscomplex}\n\
+@seealso{real, imag, iscomplex, abs, arg}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -3287,17 +3290,17 @@ complex ([1, 2], [3, 4])\n\
 }
 
 DEFUN (isreal, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isreal (@var{x})\n\
 Return true if @var{x} is a non-complex matrix or scalar.\n\
 For compatibility with @sc{matlab}, this includes logical and character\n\
 matrices.\n\
-@seealso{iscomplex, isnumeric}\n\
+@seealso{iscomplex, isnumeric, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_real_type ();
   else
     print_usage ();
@@ -3305,17 +3308,17 @@ matrices.\n\
   return retval;
 }
 
 DEFUN (isempty, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isempty (@var{a})\n\
 Return true if @var{a} is an empty matrix (any one of its dimensions is\n\
 zero).  Otherwise, return false.\n\
-@seealso{isnull}\n\
+@seealso{isnull, isa}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     retval = args(0).is_empty ();
   else
     print_usage ();
@@ -3324,17 +3327,17 @@ zero).  Otherwise, return false.\n\
 }
 
 DEFUN (isnumeric, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnumeric (@var{x})\n\
 Return true if @var{x} is a numeric object, i.e., an integer, real, or\n\
 complex array.  Logical and character arrays are not considered to be\n\
 numeric.\n\
-@seealso{isinteger, isfloat, isreal, iscomplex, islogical, ischar, iscell, isstruct}\n\
+@seealso{isinteger, isfloat, isreal, iscomplex, islogical, ischar, iscell, isstruct, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_numeric_type ();
   else
     print_usage ();
@@ -3360,17 +3363,17 @@ numeric.\n\
 
 DEFUN (ismatrix, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ismatrix (@var{a})\n\
 Return true if @var{a} is a numeric, logical, or character matrix.\n\
 Scalars (1x1 matrices) and vectors (@nospell{1xN} or @nospell{Nx1} matrices)\n\
 are subsets of the more general N-dimensional matrix and @code{ismatrix}\n\
 will return true for these objects as well.\n\
-@seealso{isscalar, isvector, iscell, isstruct, issparse}\n\
+@seealso{isscalar, isvector, iscell, isstruct, issparse, isa}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
 
@@ -3942,17 +3945,17 @@ produce infinity are division by zero an
 \n\
 When called with no arguments, return a scalar with the value @samp{Inf}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
-@seealso{isinf}\n\
+@seealso{isinf, NaN}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_inf_value (),
                       lo_ieee_float_inf_value (), "Inf");
 }
 
 DEFALIAS (inf, Inf);
 
@@ -4001,17 +4004,17 @@ find NaN values, use the @code{isnan} fu
 \n\
 When called with no arguments, return a scalar with the value @samp{NaN}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
-@seealso{isnan}\n\
+@seealso{isnan, Inf}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_nan_value (),
                       lo_ieee_float_nan_value (), "NaN");
 }
 
 DEFALIAS (nan, NaN);
 
@@ -4050,16 +4053,17 @@ to the base of natural logarithms.  The 
 \n\
 When called with no arguments, return a scalar with the value @math{e}.  When\n\
 called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
+@seealso{log, exp, pi, i, j}\n\
 @end deftypefn")
 {
 #if defined (M_E)
   double e_val = M_E;
 #else
   double e_val = exp (1.0);
 #endif
 
@@ -4090,16 +4094,17 @@ When called with no arguments, return a 
 @code{eps (1.0)}.\n\
 Given a single argument @var{x}, return the distance between @var{x} and\n\
 the next largest value.\n\
 When called with more than one argument the first two arguments are taken as\n\
 the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
+@seealso{realmax, realmin, intmax, bitmax}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 1 && ! args(0).is_string ())
     {
       if (args(0).is_single_type ())
@@ -4205,16 +4210,17 @@ When called with no arguments, return a 
 pi.\n\
 @end ifnottex\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
+@seealso{e, i, j}\n\
 @end deftypefn")
 {
 #if defined (M_PI)
   double pi_val = M_PI;
 #else
   double pi_val = 4.0 * atan (1.0);
 #endif
 
@@ -4243,17 +4249,17 @@ for single precision.\n\
 When called with no arguments, return a scalar with the value\n\
 @code{realmax (\"double\")}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
-@seealso{realmin, intmax, bitmax}\n\
+@seealso{realmin, intmax, bitmax, eps}\n\
 @end deftypefn")
 {
   return fill_matrix (args, DBL_MAX, FLT_MAX, "realmax");
 }
 
 DEFUN (realmin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} realmin\n\
@@ -4276,17 +4282,17 @@ for single precision.\n\
 When called with no arguments, return a scalar with the value\n\
 @code{realmin (\"double\")}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
-@seealso{realmax, intmin}\n\
+@seealso{realmax, intmin, eps}\n\
 @end deftypefn")
 {
   return fill_matrix (args, DBL_MIN, FLT_MIN, "realmin");
 }
 
 DEFUN (I, args, ,
   "-*- texinfo -*-\n\
 @c List other forms of function in documentation index\n\
@@ -4302,26 +4308,28 @@ DEFUN (I, args, ,
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the pure imaginary unit, defined as\n\
 @tex\n\
 $\\sqrt{-1}$.\n\
 @end tex\n\
 @ifnottex\n\
 @code{sqrt (-1)}.\n\
 @end ifnottex\n\
- I, and its equivalents i, J, and j, are functions so any of the names may\n\
+\n\
+I, and its equivalents i, j, and J, are functions so any of the names may\n\
 be reused for other purposes (such as i for a counter variable).\n\
 \n\
 When called with no arguments, return a scalar with the value @math{i}.  When\n\
 called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
+@seealso{e, pi, log, exp, i, j, J}\n\
 @end deftypefn")
 {
   return fill_matrix (args, Complex (0.0, 1.0), "I");
 }
 
 DEFALIAS (i, I);
 DEFALIAS (J, I);
 DEFALIAS (j, I);
@@ -4544,17 +4552,17 @@ the specified type, like\n\
 \n\
 @example\n\
 val = zeros (n,m, \"uint8\")\n\
 @end example\n\
 \n\
 Calling @code{eye} with no arguments is equivalent to calling it\n\
 with an argument of 1.  Any negative dimensions are treated as zero. \n\
 These odd definitions are for compatibility with @sc{matlab}.\n\
-@seealso{speye}\n\
+@seealso{speye, ones, zeros}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
@@ -4674,16 +4682,17 @@ stored in decreasing order.  If the numb
 value of 100 is used.\n\
 \n\
 The @code{linspace} function always returns a row vector if both\n\
 @var{base} and @var{limit} are scalars.  If one, or both, of them are column\n\
 vectors, @code{linspace} returns a matrix.\n\
 \n\
 For compatibility with @sc{matlab}, return the second argument (@var{limit})\n\
 if fewer than two values are requested.\n\
+@seealso{logspace}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   octave_idx_type npoints = 100;
 
@@ -4781,17 +4790,17 @@ result is @var{m}-by-@var{m}.\n\
 If @var{m}, @var{n}, @dots{} are all scalars, then the dimensions of\n\
 the result are @var{m}-by-@var{n}-by-@dots{}.\n\
 If given a vector as input, then the\n\
 dimensions of the result are given by the elements of that vector.\n\
 \n\
 An object can be resized to more dimensions than it has;\n\
 in such case the missing dimensions are assumed to be 1.\n\
 Resizing an object to fewer dimensions is not possible.\n\
-@seealso{reshape, postpad}\n\
+@seealso{reshape, postpad, prepad, cat}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       Array<double> vec = args(1).vector_value ();
@@ -4856,17 +4865,17 @@ reshape ([1, 2, 3, 4], 2, 2)\n\
 @noindent\n\
 Note that the total number of elements in the original\n\
 matrix (@code{prod (size (@var{A}))}) must match the total number of elements\n\
 in the new matrix (@code{prod ([@var{m} @var{n} @dots{}])}).\n\
 \n\
 A single dimension of the return matrix may be left unspecified and Octave\n\
 will determine its size automatically.  An empty matrix ([]) is used to flag\n\
 the unspecified dimension.\n\
-@seealso{resize}\n\
+@seealso{resize, vec, postpad, cat, squeeze}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   dim_vector new_dims;
 
@@ -4974,17 +4983,17 @@ DEFUN (vec, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{v} =} vec (@var{x})\n\
 @deftypefnx {Built-in Function} {@var{v} =} vec (@var{x}, @var{dim})\n\
 Return the vector obtained by stacking the columns of the matrix @var{x}\n\
 one above the other.  Without @var{dim} this is equivalent to\n\
 @code{@var{x}(:)}.  If @var{dim} is supplied, the dimensions of @var{v}\n\
 are set to @var{dim} with all elements along the last dimension.\n\
 This is equivalent to @code{shiftdim (@var{x}(:), 1-@var{dim})}.\n\
-@seealso{vech}\n\
+@seealso{vech, resize, cat}\n\
 @end deftypefn")
 {
   octave_value retval;
   int dim = 1;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
@@ -5037,31 +5046,32 @@ This is equivalent to @code{shiftdim (@v
 */
 
 DEFUN (squeeze, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} squeeze (@var{x})\n\
 Remove singleton dimensions from @var{x} and return the result.\n\
 Note that for compatibility with @sc{matlab}, all objects have\n\
 a minimum of two dimensions and row vectors are left unchanged.\n\
+@seealso{reshape}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).squeeze ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (full, args, ,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{FM} =} full (@var{SM})\n\
+@deftypefn {Built-in Function} {@var{FM} =} full (@var{SM})\n\
 Return a full storage matrix from a sparse, diagonal, permutation matrix\n\
 or a range.\n\
 @seealso{sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -5276,25 +5286,27 @@ Return the logical NOT of @var{x}.  This
 {
   return unary_op_defun_body (octave_value::op_not, args);
 }
 
 DEFUN (uplus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uplus (@var{x})\n\
 This function and @w{@xcode{+ x}} are equivalent.\n\
+@seealso{uminus, plus, minus}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uplus, args);
 }
 
 DEFUN (uminus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uminus (@var{x})\n\
 This function and @w{@xcode{- x}} are equivalent.\n\
+@seealso{uplus, minus}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uminus, args);
 }
 
 DEFUN (transpose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} transpose (@var{x})\n\
@@ -5408,28 +5420,28 @@ This function and @w{@xcode{x + y}} are 
 If more arguments are given, the summation is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 + x2) + x3) + @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
-@seealso{minus}\n\
+@seealso{minus, uplus}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_add,
                                      octave_value::op_add_eq, args);
 }
 
 DEFUN (minus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} minus (@var{x}, @var{y})\n\
 This function and @w{@xcode{x - y}} are equivalent.\n\
-@seealso{plus}\n\
+@seealso{plus, uminus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_sub, args);
 }
 
 DEFUN (mtimes, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mtimes (@var{x}, @var{y})\n\
@@ -5439,109 +5451,113 @@ This function and @w{@xcode{x * y}} are 
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 * x2) * x3) * @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
-@seealso{times}\n\
+@seealso{times, plus, minus, rdivide, mrdivide, mldivide, mpower}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_mul,
                                      octave_value::op_mul_eq, args);
 }
 
 DEFUN (mrdivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mrdivide (@var{x}, @var{y})\n\
 Return the matrix right division of @var{x} and @var{y}.\n\
 This function and @w{@xcode{x / y}} are equivalent.\n\
-@seealso{mldivide, rdivide}\n\
+@seealso{mldivide, rdivide, plus, minus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_div, args);
 }
 
 DEFUN (mpower, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mpower (@var{x}, @var{y})\n\
 Return the matrix power operation of @var{x} raised to the @var{y} power.\n\
 This function and @w{@xcode{x ^ y}} are equivalent.\n\
-@seealso{power}\n\
+@seealso{power, mtimes, plus, minus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_pow, args);
 }
 
 DEFUN (mldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mldivide (@var{x}, @var{y})\n\
 Return the matrix left division of @var{x} and @var{y}.\n\
 This function and @w{@xcode{x @xbackslashchar{} y}} are equivalent.\n\
-@seealso{mrdivide, ldivide}\n\
+@seealso{mrdivide, ldivide, rdivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ldiv, args);
 }
 
 DEFUN (lt, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} lt (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x < y}}.\n\
+@seealso{le, eq, ge, gt, ne}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_lt, args);
 }
 
 DEFUN (le, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} le (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x <= y}}.\n\
+@seealso{eq, ge, gt, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_le, args);
 }
 
 DEFUN (eq, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} eq (@var{x}, @var{y})\n\
 Return true if the two inputs are equal.\n\
 This function is equivalent to @w{@code{x == y}}.\n\
-@seealso{ne, isequal}\n\
+@seealso{ne, isequal, le, ge, gt, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_eq, args);
 }
 
 DEFUN (ge, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ge (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x >= y}}.\n\
+@seealso{le, eq, gt, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ge, args);
 }
 
 DEFUN (gt, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} gt (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x > y}}.\n\
+@seealso{le, eq, ge, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_gt, args);
 }
 
 DEFUN (ne, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ne (@var{x}, @var{y})\n\
 Return true if the two inputs are not equal.\n\
 This function is equivalent to @w{@code{x != y}}.\n\
-@seealso{eq, isequal}\n\
+@seealso{eq, isequal, le, ge, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ne, args);
 }
 
 DEFUN (times, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} times (@var{x}, @var{y})\n\
@@ -5551,29 +5567,29 @@ This function and @w{@xcode{x .* y}} are
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 .* x2) .* x3) .* @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
-@seealso{mtimes}\n\
+@seealso{mtimes, rdivide}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_mul,
                                      octave_value::op_el_mul_eq, args);
 }
 
 DEFUN (rdivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rdivide (@var{x}, @var{y})\n\
 Return the element-by-element right division of @var{x} and @var{y}.\n\
 This function and @w{@xcode{x ./ y}} are equivalent.\n\
-@seealso{ldivide, mrdivide}\n\
+@seealso{ldivide, mrdivide, times, plus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_div, args);
 }
 
 DEFUN (power, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} power (@var{x}, @var{y})\n\
@@ -5590,17 +5606,17 @@ This function and @w{@xcode{x .^ y}} are
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
 Return the element-by-element left division of @var{x} and @var{y}.\n\
 This function and @w{@xcode{x .@xbackslashchar{} y}} are equivalent.\n\
-@seealso{rdivide, mldivide}\n\
+@seealso{rdivide, mldivide, times, plus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_ldiv, args);
 }
 
 DEFUN (and, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} and (@var{x}, @var{y})\n\
@@ -5681,16 +5697,17 @@ id = tic; sleep (5); toc (id)\n\
 \n\
 Calling @code{tic} and @code{toc} this way allows nested timing calls.\n\
 \n\
 If you are more interested in the CPU time that your process used, you\n\
 should use the @code{cputime} function instead.  The @code{tic} and\n\
 @code{toc} functions report the actual wall clock time that elapsed\n\
 between the calls.  This may include time spent processing other jobs or\n\
 doing nothing at all.\n\
+@seealso{toc, cputime}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 0)
     warning ("tic: ignoring extra arguments");
@@ -5713,17 +5730,17 @@ doing nothing at all.\n\
   return retval;
 }
 
 DEFUN (toc, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} toc ()\n\
 @deftypefnx {Built-in Function} {} toc (@var{id})\n\
 @deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
-See tic.\n\
+@seealso{tic, cputime}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   double start_time = tic_toc_timestamp;
 
@@ -5785,16 +5802,17 @@ Return the CPU time used by your Octave 
 the total time spent executing your process and is equal to the sum of\n\
 second and third outputs, which are the number of CPU seconds spent\n\
 executing in user mode and the number of CPU seconds spent executing in\n\
 system mode, respectively.  If your system does not have a way to report\n\
 CPU time usage, @code{cputime} returns 0 for each of its output values.\n\
 Note that because Octave used some CPU time to start, it is reasonable\n\
 to check to see if @code{cputime} works by checking to see if the total\n\
 CPU time used is nonzero.\n\
+@seealso{tic, toc}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   double usr = 0.0;
   double sys = 0.0;
 
   if (nargin != 0)
@@ -5842,20 +5860,20 @@ CPU time used is nonzero.\n\
   retval(1) = usr;
   retval(0) = sys + usr;
 
   return retval;
 }
 
 DEFUN (sort, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x})\n\
-@deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
-@deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{mode})\n\
-@deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim}, @var{mode})\n\
+@deftypefn  {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x})\n\
+@deftypefnx {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
+@deftypefnx {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{mode})\n\
+@deftypefnx {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim}, @var{mode})\n\
 Return a copy of @var{x} with the elements arranged in increasing\n\
 order.  For matrices, @code{sort} orders the elements within columns\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 sort ([1, 2; 2, 3; 3, 1])\n\
@@ -5905,16 +5923,17 @@ NaN values are treated as being greater 
 to the end of the list.\n\
 \n\
 The @code{sort} function may also be used to sort strings and cell arrays\n\
 of strings, in which case ASCII dictionary order (uppercase 'A' precedes\n\
 lowercase 'a') of the strings is used.\n\
 \n\
 The algorithm used in @code{sort} is optimized for the sorting of partially\n\
 ordered lists.\n\
+@seealso{sortrows, issorted}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
   sortmode smode = ASCENDING;
 
   if (nargin < 1 || nargin > 3)
@@ -6794,17 +6813,17 @@ constructed as follows:\n\
 @group\n\
 result(mask) = tval(mask);\n\
 result(! mask) = fval(! mask);\n\
 @end group\n\
 @end example\n\
 \n\
 @var{mask} can also be arbitrary numeric type, in which case\n\
 it is first converted to logical.\n\
-@seealso{logical}\n\
+@seealso{logical, diff}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 3 && (args(0).is_bool_type () || args(0).is_numeric_type ()))
     {
       octave_value mask_val = args(0);
@@ -7022,16 +7041,17 @@ the first non-singleton dimension of the
 @code{diff} continues to take the differences along the next\n\
 non-singleton dimension.\n\
 \n\
 The dimension along which to take the difference can be explicitly\n\
 stated with the optional variable @var{dim}.  In this case the\n\
 @var{k}-th order differences are calculated along this dimension.\n\
 In the case where @var{k} exceeds @code{size (@var{x}, @var{dim})}\n\
 an empty matrix is returned.\n\
+@seealso{sort, merge}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   else if (! (args(0).is_numeric_type () || args(0).is_bool_type ()))
@@ -7132,17 +7152,17 @@ Conceptually the result is calculated as
 @example\n\
 @group\n\
 y = [];\n\
 for i = 1:columns (@var{r})\n\
   y = [y, @var{x}(@var{r}(1,i)*ones(1, @var{r}(2,i)))];\n\
 endfor\n\
 @end group\n\
 @end example\n\
-@seealso{repmat}\n\
+@seealso{repmat, cat}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       octave_value x = args(0);
 
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -499,18 +499,18 @@ intmap_to_ov (const bp_table::intmap& li
 
   retval.resize (dim_vector (1, idx));
 
   return retval;
 }
 
 DEFUN (dbstop, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{rline} =} dbstop (\"@var{func}\")\n\
-@deftypefnx {Loadable Function} {@var{rline} =} dbstop (\"@var{func}\", @var{line}, @dots{})\n\
+@deftypefn  {Built-in Function} {@var{rline} =} dbstop (\"@var{func}\")\n\
+@deftypefnx {Built-in Function} {@var{rline} =} dbstop (\"@var{func}\", @var{line}, @dots{})\n\
 Set a breakpoint in function @var{func}.\n\
 \n\
 Arguments are\n\
 \n\
 @table @var\n\
 @item func\n\
 Function name as a string variable.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
@@ -543,18 +543,18 @@ next executable line.\n\
   if (! error_state)
     retval = bp_table::add_breakpoint (symbol_name, lines);
 
   return intmap_to_ov (retval);
 }
 
 DEFUN (dbclear, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} dbclear (\"@var{func}\")\n\
-@deftypefnx {Loadable Function} {} dbclear (\"@var{func}\", @var{line}, @dots{})\n\
+@deftypefn  {Built-in Function} {} dbclear (\"@var{func}\")\n\
+@deftypefnx {Built-in Function} {} dbclear (\"@var{func}\", @var{line}, @dots{})\n\
 Delete a breakpoint in the function @var{func}.\n\
 \n\
 Arguments are\n\
 \n\
 @table @var\n\
 @item func\n\
 Function name as a string variable.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
@@ -580,19 +580,19 @@ If the requested line is not a breakpoin
   if (! error_state)
     bp_table::remove_breakpoint (symbol_name, lines);
 
   return retval;
 }
 
 DEFUN (dbstatus, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} dbstatus ()\n\
-@deftypefnx {Loadable Function} {@var{brk_list} =} dbstatus ()\n\
-@deftypefnx {Loadable Function} {@var{brk_list} =} dbstatus (\"@var{func}\")\n\
+@deftypefn  {Built-in Function} {} dbstatus ()\n\
+@deftypefnx {Built-in Function} {@var{brk_list} =} dbstatus ()\n\
+@deftypefnx {Built-in Function} {@var{brk_list} =} dbstatus (\"@var{func}\")\n\
 Report the location of active breakpoints.\n\
 \n\
 When called with no input or output arguments, print the list of\n\
 all functions with breakpoints and the line numbers where those\n\
 breakpoints are set.\n\
 If a function name @var{func} is specified then only report breakpoints\n\
 for the named function.\n\
 \n\
@@ -696,17 +696,17 @@ A line number, or vector of line numbers
       retval.assign ("line", line);
 
       return octave_value (retval);
     }
 }
 
 DEFUN (dbwhere, , ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} dbwhere ()\n\
+@deftypefn {Built-in Function} {} dbwhere ()\n\
 In debugging mode, report the current file and line number where\n\
 execution is stopped.\n\
 @seealso{dbstatus, dbcont, dbstep, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_user_code *dbg_fcn = get_user_code ();
@@ -789,23 +789,23 @@ do_dbtype (std::ostream& os, const std::
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} dbtype ()\n\
-@deftypefnx {Loadable Function} {} dbtype (\"startl:endl\")\n\
-@deftypefnx {Loadable Function} {} dbtype (\"startl:end\")\n\
-@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\")\n\
-@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\", \"startl\")\n\
-@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\", \"startl:endl\")\n\
-@deftypefnx {Loadable Function} {} dbtype (\"@var{func}\", \"startl:end\")\n\
+@deftypefn  {Built-in Function} {} dbtype ()\n\
+@deftypefnx {Built-in Function} {} dbtype (\"startl:endl\")\n\
+@deftypefnx {Built-in Function} {} dbtype (\"startl:end\")\n\
+@deftypefnx {Built-in Function} {} dbtype (\"@var{func}\")\n\
+@deftypefnx {Built-in Function} {} dbtype (\"@var{func}\", \"startl\")\n\
+@deftypefnx {Built-in Function} {} dbtype (\"@var{func}\", \"startl:endl\")\n\
+@deftypefnx {Built-in Function} {} dbtype (\"@var{func}\", \"startl:end\")\n\
 When in debugging mode and called with no arguments, list the script file\n\
 being debugged with line numbers.  An optional range specification,\n\
 specified as a string, can be used to list only a portion of the file.\n\
 The special keyword \"end\" is a valid line number specification.\n\
 \n\
 When called with the name of a function, list that script file\n\
 with line numbers.\n\
 @seealso{dbstatus, dbstop}\n\
@@ -1017,19 +1017,19 @@ do_dbstack (const octave_value_list& arg
 void
 show_octave_dbstack (void)
 {
   do_dbstack (octave_value_list (), 0, std::cerr);
 }
 
 DEFUN (dbstack, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} dbstack ()\n\
-@deftypefnx {Loadable Function} {} dbstack (@var{n})\n\
-@deftypefnx {Loadable Function} {[@var{stack}, @var{idx}] =} dbstack (@dots{})\n\
+@deftypefn  {Built-in Function} {} dbstack ()\n\
+@deftypefnx {Built-in Function} {} dbstack (@var{n})\n\
+@deftypefnx {Built-in Function} {[@var{stack}, @var{idx}] =} dbstack (@dots{})\n\
 Display or return current debugging function stack information.\n\
 With optional argument @var{n}, omit the @var{n} innermost stack frames.\n\
 \n\
 The optional return argument @var{stack} is a struct array with the\n\
 following fields:\n\
 \n\
 @table @asis\n\
 @item file\n\
@@ -1085,34 +1085,34 @@ do_dbupdown (const octave_value_list& ar
 
       if (! octave_call_stack::goto_frame_relative (n, true))
         error ("%s: invalid stack frame", who.c_str ());
     }
 }
 
 DEFUN (dbup, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} dbup\n\
-@deftypefnx {Loadable Function} {} dbup (@var{n})\n\
+@deftypefn  {Built-in Function} {} dbup\n\
+@deftypefnx {Built-in Function} {} dbup (@var{n})\n\
 In debugging mode, move up the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move up one frame.\n\
 @seealso{dbstack, dbdown}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbup");
 
   return retval;
 }
 
 DEFUN (dbdown, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} dbdown\n\
-@deftypefnx {Loadable Function} {} dbdown (@var{n})\n\
+@deftypefn  {Built-in Function} {} dbdown\n\
+@deftypefnx {Built-in Function} {} dbdown (@var{n})\n\
 In debugging mode, move down the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move down one frame.\n\
 @seealso{dbstack, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbdown");
@@ -1247,17 +1247,17 @@ return to the Octave prompt.\n\
   else
     error ("dbquit: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (isdebugmode, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} isdebugmode ()\n\
+@deftypefn {Built-in Function} {} isdebugmode ()\n\
 Return true if in debugging mode, otherwise false.\n\
 @seealso{dbwhere, dbstack, dbstatus}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = Vdebugging;
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -34,17 +34,17 @@ class octave_value;
 
 extern OCTINTERP_API void print_usage (void);
 extern OCTINTERP_API void print_usage (const std::string&);
 
 extern OCTINTERP_API void check_version (const std::string& version, const std::string& fcn);
 
 extern OCTINTERP_API void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
-                          const std::string& doc,
+                          const std::string& file, const std::string& doc,
                           bool can_hide_function = true);
 
 extern OCTINTERP_API void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
                       const octave_shlib& shl, const std::string& doc,
                       bool relative = false);
 
 extern OCTINTERP_API void
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -75,20 +75,20 @@ check_version (const std::string& versio
              version.c_str (), fcn.c_str (), OCTAVE_API_VERSION);
     }
 }
 
 // Install variables and functions in the symbol tables.
 
 void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
-                          const std::string& doc,
+                          const std::string& file, const std::string& doc,
                           bool /* can_hide_function -- not yet implemented */)
 {
-  octave_value fcn (new octave_builtin (f, name, doc));
+  octave_value fcn (new octave_builtin (f, name, file, doc));
 
   symbol_table::install_built_in_function (name, fcn);
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
                       const octave_shlib& shl, const std::string& doc,
                       bool relative)
diff --git a/src/find-defun-files.sh b/src/find-defun-files.sh
--- a/src/find-defun-files.sh
+++ b/src/find-defun-files.sh
@@ -16,11 +16,11 @@ shift
 for arg
 do
   if [ -f "$arg" ]; then
     file="$arg"
   else
     file="$srcdir/$arg"
   fi
   if [ "`$EGREP -l "$DEFUN_PATTERN" $file`" ]; then
-    echo "$file" | $SED 's,.*/,,; s/\.cc$/.df/; s/\.ll$/.df/; s/\.yy$/.df/';
+    echo "$file" | $SED "s,\\$srcdir/,," | $SED 's/\.cc$/.df/; s/\.ll$/.df/; s/\.yy$/.df/';
   fi
 done
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -6828,19 +6828,19 @@ axes::properties::translate_view (double
 
 void
 axes::properties::rotate_view (double delta_el, double delta_az)
 {
   Matrix v = get_view ().matrix_value ();
 
   v(1) += delta_el;
 
-  if(v(1) > 90)
+  if (v(1) > 90)
     v(1) = 90;
-  if(v(1) < -90)
+  if (v(1) < -90)
     v(1) = -90;
 
   v(0) = fmod (v(0) - delta_az + 720,360);
 
   set_view (v);
   update_transform ();
 }
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -757,17 +757,17 @@ Begin a while loop.\n\
 
 // Return a copy of the operator or keyword names.
 static string_vector
 names (const map_type& lst)
 {
   string_vector retval (lst.size ());
   int j = 0;
   for (map_iter iter = lst.begin (); iter != lst.end (); iter ++)
-    retval [j++] = iter->first;
+    retval[j++] = iter->first;
   return retval;
 }
 
 const static map_type operators_map (operators, operators + size (operators));
 const static map_type keywords_map (keywords, keywords + size (keywords));
 const static string_vector keyword_names = names (keywords_map);
 
 // FIXME -- It's not likely that this does the right thing now.
@@ -949,17 +949,17 @@ do_get_help_text (const std::string& nam
       else
         {
           format = "plain text";
         }
     }
 }
 
 DEFUN (get_help_text, args, , "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{text}, @var{format}] =} get_help_text (@var{name})\n\
+@deftypefn {Built-in Function} {[@var{text}, @var{format}] =} get_help_text (@var{name})\n\
 Return the raw help text of function @var{name}.\n\
 \n\
 The raw help text is returned in @var{text} and the format in @var{format}\n\
 The format is a string which is one of @t{\"texinfo\"}, @t{\"html\"}, or\n\
 @t{\"plain text\"}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -1018,17 +1018,17 @@ do_get_help_text_from_file (const std::s
         {
           format = "plain text";
         }
     }
 }
 
 DEFUN (get_help_text_from_file, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{text}, @var{format}] =} get_help_text_from_file (@var{fname})\n\
+@deftypefn {Built-in Function} {[@var{text}, @var{format}] =} get_help_text_from_file (@var{fname})\n\
 Return the raw help text from the file @var{fname}.\n\
 \n\
 The raw help text is returned in @var{text} and the format in @var{format}\n\
 The format is a string which is one of @t{\"texinfo\"}, @t{\"html\"}, or\n\
 @t{\"plain text\"}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -1113,17 +1113,20 @@ do_which (const std::string& name, std::
             {
               file = fcn->fcn_file_name ();
 
               if (file.empty ())
                 {
                   if (fcn->is_user_function ())
                     type = "command-line function";
                   else
-                    type = "built-in function";
+                    {
+                      file = fcn->src_file_name ();
+                      type = "built-in function";
+                    }
                 }
               else
                 type = val.is_user_script ()
                   ? std::string ("script") : std::string ("function");
             }
         }
       else
         {
@@ -1210,21 +1213,21 @@ Undocumented internal function.\n\
 // FIXME -- Are we sure this function always does the right thing?
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
 {
   if (filename.find (dir) == 0)
     {
       const int dir_len = dir.size ();
       const int filename_len = filename.size ();
-      const int max_allowed_seps = file_ops::is_dir_sep (dir [dir_len-1]) ? 0 : 1;
+      const int max_allowed_seps = file_ops::is_dir_sep (dir[dir_len-1]) ? 0 : 1;
 
       int num_seps = 0;
       for (int i = dir_len; i < filename_len; i++)
-        if (file_ops::is_dir_sep (filename [i]))
+        if (file_ops::is_dir_sep (filename[i]))
           num_seps ++;
 
       return (num_seps <= max_allowed_seps);
     }
   else
     return false;
 }
 
diff --git a/src/jit-ir.cc b/src/jit-ir.cc
new file mode 100644
--- /dev/null
+++ b/src/jit-ir.cc
@@ -0,0 +1,601 @@
+/*
+
+Copyright (C) 2012 Max Brister <max@2bass.com>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// defines required by llvm
+#define __STDC_LIMIT_MACROS
+#define __STDC_CONSTANT_MACROS
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef HAVE_LLVM
+
+#include "jit-ir.h"
+
+#include <llvm/BasicBlock.h>
+#include <llvm/Instructions.h>
+
+#include "error.h"
+#include "pt-jit.h"
+
+// -------------------- jit_use --------------------
+jit_block *
+jit_use::user_parent (void) const
+{
+  return muser->parent ();
+}
+
+// -------------------- jit_value --------------------
+jit_value::~jit_value (void)
+{}
+
+jit_block *
+jit_value::first_use_block (void)
+{
+  jit_use *use = first_use ();
+  while (use)
+    {
+      if (! isa<jit_error_check> (use->user ()))
+        return use->user_parent ();
+
+      use = use->next ();
+    }
+
+  return 0;
+}
+
+void
+jit_value::replace_with (jit_value *value)
+{
+  while (first_use ())
+    {
+      jit_instruction *user = first_use ()->user ();
+      size_t idx = first_use ()->index ();
+      user->stash_argument (idx, value);
+    }
+}
+
+#define JIT_METH(clname)                                \
+  void                                                  \
+  jit_ ## clname::accept (jit_ir_walker& walker)        \
+  {                                                     \
+    walker.visit (*this);                               \
+  }
+
+JIT_VISIT_IR_NOTEMPLATE
+#undef JIT_METH
+
+std::ostream&
+operator<< (std::ostream& os, const jit_value& value)
+{
+  return value.short_print (os);
+}
+
+std::ostream&
+jit_print (std::ostream& os, jit_value *avalue)
+{
+  if (avalue)
+    return avalue->print (os);
+  return os << "NULL";
+}
+
+// -------------------- jit_instruction --------------------
+void
+jit_instruction::remove (void)
+{
+  if (mparent)
+    mparent->remove (mlocation);
+  resize_arguments (0);
+}
+
+llvm::BasicBlock *
+jit_instruction::parent_llvm (void) const
+{
+  return mparent->to_llvm ();
+}
+
+std::ostream&
+jit_instruction::short_print (std::ostream& os) const
+{
+  if (type ())
+    jit_print (os, type ()) << ": ";
+  return os << "#" << mid;
+}
+
+void
+jit_instruction::do_construct_ssa (size_t start, size_t end)
+{
+  for (size_t i = start; i < end; ++i)
+    {
+      jit_value *arg = argument (i);
+      jit_variable *var = dynamic_cast<jit_variable *> (arg);
+      if (var && var->has_top ())
+        stash_argument (i, var->top ());
+    }
+}
+
+// -------------------- jit_block --------------------
+void
+jit_block::replace_with (jit_value *value)
+{
+  assert (isa<jit_block> (value));
+  jit_block *block = static_cast<jit_block *> (value);
+
+  jit_value::replace_with (block);
+
+  while (ILIST_T::first_use ())
+    {
+      jit_phi_incomming *incomming = ILIST_T::first_use ();
+      incomming->stash_value (block);
+    }
+}
+
+void
+jit_block::replace_in_phi (jit_block *ablock, jit_block *with)
+{
+  jit_phi_incomming *node = ILIST_T::first_use ();
+  while (node)
+    {
+      jit_phi_incomming *prev = node;
+      node = node->next ();
+
+      if (prev->user_parent () == ablock)
+        prev->stash_value (with);
+    }
+}
+
+jit_block *
+jit_block::maybe_merge ()
+{
+  if (successor_count () == 1 && successor (0) != this
+      && (successor (0)->use_count () == 1 || instructions.size () == 1))
+    {
+      jit_block *to_merge = successor (0);
+      merge (*to_merge);
+      return to_merge;
+    }
+
+  return 0;
+}
+
+void
+jit_block::merge (jit_block& block)
+{
+  // the merge block will contain a new terminator
+  jit_terminator *old_term = terminator ();
+  if (old_term)
+    old_term->remove ();
+
+  bool was_empty = end () == begin ();
+  iterator merge_begin = end ();
+  if (! was_empty)
+    --merge_begin;
+
+  instructions.splice (end (), block.instructions);
+  if (was_empty)
+    merge_begin = begin ();
+  else
+    ++merge_begin;
+
+  // now merge_begin points to the start of the new instructions, we must
+  // update their parent information
+  for (iterator iter = merge_begin; iter != end (); ++iter)
+    {
+      jit_instruction *instr = *iter;
+      instr->stash_parent (this, iter);
+    }
+
+  block.replace_with (this);
+}
+
+jit_instruction *
+jit_block::prepend (jit_instruction *instr)
+{
+  instructions.push_front (instr);
+  instr->stash_parent (this, instructions.begin ());
+  return instr;
+}
+
+jit_instruction *
+jit_block::prepend_after_phi (jit_instruction *instr)
+{
+  // FIXME: Make this O(1)
+  for (iterator iter = begin (); iter != end (); ++iter)
+    {
+      jit_instruction *temp = *iter;
+      if (! isa<jit_phi> (temp))
+        {
+          insert_before (iter, instr);
+          return instr;
+        }
+    }
+
+  return append (instr);
+}
+
+void
+jit_block::internal_append (jit_instruction *instr)
+{
+  instructions.push_back (instr);
+  instr->stash_parent (this, --instructions.end ());
+}
+
+jit_instruction *
+jit_block::insert_before (iterator loc, jit_instruction *instr)
+{
+  iterator iloc = instructions.insert (loc, instr);
+  instr->stash_parent (this, iloc);
+  return instr;
+}
+
+jit_instruction *
+jit_block::insert_after (iterator loc, jit_instruction *instr)
+{
+  ++loc;
+  iterator iloc = instructions.insert (loc, instr);
+  instr->stash_parent (this, iloc);
+  return instr;
+}
+
+jit_terminator *
+jit_block::terminator (void) const
+{
+  assert (this);
+  if (instructions.empty ())
+    return 0;
+
+  jit_instruction *last = instructions.back ();
+  return dynamic_cast<jit_terminator *> (last);
+}
+
+bool
+jit_block::branch_alive (jit_block *asucc) const
+{
+  return terminator ()->alive (asucc);
+}
+
+jit_block *
+jit_block::successor (size_t i) const
+{
+  jit_terminator *term = terminator ();
+  return term->successor (i);
+}
+
+size_t
+jit_block::successor_count (void) const
+{
+  jit_terminator *term = terminator ();
+  return term ? term->successor_count () : 0;
+}
+
+llvm::BasicBlock *
+jit_block::to_llvm (void) const
+{
+  return llvm::cast<llvm::BasicBlock> (llvm_value);
+}
+
+std::ostream&
+jit_block::print_dom (std::ostream& os) const
+{
+  short_print (os);
+  os << ":\n";
+  os << "  mid: " << mid << std::endl;
+  os << "  predecessors: ";
+  for (jit_use *use = first_use (); use; use = use->next ())
+    os << *use->user_parent () << " ";
+  os << std::endl;
+
+  os << "  successors: ";
+  for (size_t i = 0; i < successor_count (); ++i)
+    os << *successor (i) << " ";
+  os << std::endl;
+
+  os << "  idom: ";
+  if (idom)
+    os << *idom;
+  else
+    os << "NULL";
+  os << std::endl;
+  os << "  df: ";
+  for (df_iterator iter = df_begin (); iter != df_end (); ++iter)
+    os << **iter << " ";
+  os << std::endl;
+
+  os << "  dom_succ: ";
+  for (size_t i = 0; i < dom_succ.size (); ++i)
+    os << *dom_succ[i] << " ";
+
+  return os << std::endl;
+}
+
+void
+jit_block::compute_df (size_t avisit_count)
+{
+  if (visited (avisit_count))
+    return;
+
+  if (use_count () >= 2)
+    {
+      for (jit_use *use = first_use (); use; use = use->next ())
+        {
+          jit_block *runner = use->user_parent ();
+          while (runner != idom)
+            {
+              runner->mdf.insert (this);
+              runner = runner->idom;
+            }
+        }
+    }
+
+  for (size_t i = 0; i < successor_count (); ++i)
+    successor (i)->compute_df (avisit_count);
+}
+
+bool
+jit_block::update_idom (size_t avisit_count)
+{
+  if (visited (avisit_count) || ! use_count ())
+    return false;
+
+  bool changed = false;
+  for (jit_use *use = first_use (); use; use = use->next ())
+    {
+      jit_block *pred = use->user_parent ();
+      changed = pred->update_idom (avisit_count) || changed;
+    }
+
+  jit_use *use = first_use ();
+  jit_block *new_idom = use->user_parent ();
+  use = use->next ();
+
+  for (; use; use = use->next ())
+    {
+      jit_block *pred = use->user_parent ();
+      jit_block *pidom = pred->idom;
+      if (pidom)
+        new_idom = idom_intersect (pidom, new_idom);
+    }
+
+  if (idom != new_idom)
+    {
+      idom = new_idom;
+      return true;
+    }
+
+  return changed;
+}
+
+void
+jit_block::pop_all (void)
+{
+  for (iterator iter = begin (); iter != end (); ++iter)
+    {
+      jit_instruction *instr = *iter;
+      instr->pop_variable ();
+    }
+}
+
+jit_block *
+jit_block::maybe_split (jit_convert& convert, jit_block *asuccessor)
+{
+  if (successor_count () > 1)
+    {
+      jit_terminator *term = terminator ();
+      size_t idx = term->successor_index (asuccessor);
+      jit_block *split = convert.create<jit_block> ("phi_split", mvisit_count);
+
+      // try to place splits where they make sense
+      if (id () < asuccessor->id ())
+        convert.insert_before (asuccessor, split);
+      else
+        convert.insert_after (this, split);
+
+      term->stash_argument (idx, split);
+      jit_branch *br = split->append (convert.create<jit_branch> (asuccessor));
+      replace_in_phi (asuccessor, split);
+
+      if (alive ())
+        {
+          split->mark_alive ();
+          br->infer ();
+        }
+
+      return split;
+    }
+
+  return this;
+}
+
+void
+jit_block::create_dom_tree (size_t avisit_count)
+{
+  if (visited (avisit_count))
+    return;
+
+  if (idom != this)
+    idom->dom_succ.push_back (this);
+
+  for (size_t i = 0; i < successor_count (); ++i)
+    successor (i)->create_dom_tree (avisit_count);
+}
+
+jit_block *
+jit_block::idom_intersect (jit_block *i, jit_block *j)
+{
+  while (i && j && i != j)
+    {
+      while (i && i->id () > j->id ())
+        i = i->idom;
+
+      while (i && j && j->id () > i->id ())
+        j = j->idom;
+    }
+
+  return i ? i : j;
+}
+
+// -------------------- jit_phi_incomming --------------------
+
+jit_block *
+jit_phi_incomming::user_parent (void) const
+{ return muser->parent (); }
+
+// -------------------- jit_phi --------------------
+bool
+jit_phi::prune (void)
+{
+  jit_block *p = parent ();
+  size_t new_idx = 0;
+  jit_value *unique = argument (1);
+
+  for (size_t i = 0; i < argument_count (); ++i)
+    {
+      jit_block *inc = incomming (i);
+      if (inc->branch_alive (p))
+        {
+          if (unique != argument (i))
+            unique = 0;
+
+          if (new_idx != i)
+            {
+              stash_argument (new_idx, argument (i));
+              mincomming[new_idx].stash_value (inc);
+            }
+
+          ++new_idx;
+        }
+    }
+
+  if (new_idx != argument_count ())
+    {
+      resize_arguments (new_idx);
+      mincomming.resize (new_idx);
+    }
+
+  assert (argument_count () > 0);
+  if (unique)
+    {
+      replace_with (unique);
+      return true;
+    }
+
+  return false;
+}
+
+bool
+jit_phi::infer (void)
+{
+  jit_block *p = parent ();
+  if (! p->alive ())
+    return false;
+
+  jit_type *infered = 0;
+  for (size_t i = 0; i < argument_count (); ++i)
+    {
+      jit_block *inc = incomming (i);
+      if (inc->branch_alive (p))
+        infered = jit_typeinfo::join (infered, argument_type (i));
+    }
+
+  if (infered != type ())
+    {
+      stash_type (infered);
+      return true;
+    }
+
+  return false;
+}
+
+llvm::PHINode *
+jit_phi::to_llvm (void) const
+{
+  return llvm::cast<llvm::PHINode> (jit_value::to_llvm ());
+}
+
+// -------------------- jit_terminator --------------------
+size_t
+jit_terminator::successor_index (const jit_block *asuccessor) const
+{
+  size_t scount = successor_count ();
+  for (size_t i = 0; i < scount; ++i)
+    if (successor (i) == asuccessor)
+      return i;
+
+  panic_impossible ();
+}
+
+bool
+jit_terminator::infer (void)
+{
+  if (! parent ()->alive ())
+    return false;
+
+  bool changed = false;
+  for (size_t i = 0; i < malive.size (); ++i)
+    if (! malive[i] && check_alive (i))
+      {
+        changed = true;
+        malive[i] = true;
+        successor (i)->mark_alive ();
+      }
+
+  return changed;
+}
+
+llvm::TerminatorInst *
+jit_terminator::to_llvm (void) const
+{
+  return llvm::cast<llvm::TerminatorInst> (jit_value::to_llvm ());
+}
+
+// -------------------- jit_call --------------------
+bool
+jit_call::infer (void)
+{
+  // FIXME: explain algorithm
+  for (size_t i = 0; i < argument_count (); ++i)
+    {
+      already_infered[i] = argument_type (i);
+      if (! already_infered[i])
+        return false;
+    }
+
+  jit_type *infered = moperation.result (already_infered);
+  if (! infered && use_count ())
+    {
+      std::stringstream ss;
+      ss << "Missing overload in type inference for ";
+      print (ss, 0);
+      throw jit_fail_exception (ss.str ());
+    }
+
+  if (infered != type ())
+    {
+      stash_type (infered);
+      return true;
+    }
+
+  return false;
+}
+
+#endif
diff --git a/src/jit-ir.h b/src/jit-ir.h
new file mode 100644
--- /dev/null
+++ b/src/jit-ir.h
@@ -0,0 +1,1247 @@
+/*
+
+Copyright (C) 2012 Max Brister <max@2bass.com>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_jit_ir_h)
+#define octave_jit_ir_h 1
+
+#ifdef HAVE_LLVM
+
+#include <list>
+#include <stack>
+#include <set>
+
+#include "jit-typeinfo.h"
+
+// The low level octave jit ir
+// this ir is close to llvm, but contains information for doing type inference.
+// We convert the octave parse tree to this IR directly.
+
+#define JIT_VISIT_IR_NOTEMPLATE                 \
+  JIT_METH(block);                              \
+  JIT_METH(branch);                             \
+  JIT_METH(cond_branch);                        \
+  JIT_METH(call);                               \
+  JIT_METH(extract_argument);                   \
+  JIT_METH(store_argument);                     \
+  JIT_METH(phi);                                \
+  JIT_METH(variable);                           \
+  JIT_METH(error_check);                        \
+  JIT_METH(assign)                              \
+  JIT_METH(argument)
+
+#define JIT_VISIT_IR_CONST                      \
+  JIT_METH(const_bool);                         \
+  JIT_METH(const_scalar);                       \
+  JIT_METH(const_complex);                      \
+  JIT_METH(const_index);                        \
+  JIT_METH(const_string);                       \
+  JIT_METH(const_range)
+
+#define JIT_VISIT_IR_CLASSES                    \
+  JIT_VISIT_IR_NOTEMPLATE                       \
+  JIT_VISIT_IR_CONST
+
+// forward declare all ir classes
+#define JIT_METH(cname)                         \
+  class jit_ ## cname;
+
+JIT_VISIT_IR_NOTEMPLATE
+
+#undef JIT_METH
+
+class jit_convert;
+
+// ABCs which aren't included in  JIT_VISIT_IR_ALL
+class jit_instruction;
+class jit_terminator;
+
+template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T = T,
+          bool QUOTE=false>
+class jit_const;
+
+typedef jit_const<bool, jit_typeinfo::get_bool> jit_const_bool;
+typedef jit_const<double, jit_typeinfo::get_scalar> jit_const_scalar;
+typedef jit_const<Complex, jit_typeinfo::get_complex> jit_const_complex;
+typedef jit_const<octave_idx_type, jit_typeinfo::get_index> jit_const_index;
+
+typedef jit_const<std::string, jit_typeinfo::get_string, const std::string&,
+                  true> jit_const_string;
+typedef jit_const<jit_range, jit_typeinfo::get_range, const jit_range&>
+jit_const_range;
+
+class jit_ir_walker;
+class jit_use;
+
+class
+jit_value : public jit_internal_list<jit_value, jit_use>
+{
+public:
+  jit_value (void) : llvm_value (0), ty (0), mlast_use (0),
+                     min_worklist (false) {}
+
+  virtual ~jit_value (void);
+
+  bool in_worklist (void) const
+  {
+    return min_worklist;
+  }
+
+  void stash_in_worklist (bool ain_worklist)
+  {
+    min_worklist = ain_worklist;
+  }
+
+  // The block of the first use which is not a jit_error_check
+  // So this is not necessarily first_use ()->parent ().
+  jit_block *first_use_block (void);
+
+  // replace all uses with
+  virtual void replace_with (jit_value *value);
+
+  jit_type *type (void) const { return ty; }
+
+  llvm::Type *type_llvm (void) const
+  {
+    return ty ? ty->to_llvm () : 0;
+  }
+
+  const std::string& type_name (void) const
+  {
+    return ty->name ();
+  }
+
+  void stash_type (jit_type *new_ty) { ty = new_ty; }
+
+  std::string print_string (void)
+  {
+    std::stringstream ss;
+    print (ss);
+    return ss.str ();
+  }
+
+  jit_instruction *last_use (void) const { return mlast_use; }
+
+  void stash_last_use (jit_instruction *alast_use)
+  {
+    mlast_use = alast_use;
+  }
+
+  virtual bool needs_release (void) const { return false; }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const = 0;
+
+  virtual std::ostream& short_print (std::ostream& os) const
+  { return print (os); }
+
+  virtual void accept (jit_ir_walker& walker) = 0;
+
+  bool has_llvm (void) const
+  {
+    return llvm_value;
+  }
+
+  llvm::Value *to_llvm (void) const
+  {
+    assert (llvm_value);
+    return llvm_value;
+  }
+
+  void stash_llvm (llvm::Value *compiled)
+  {
+    llvm_value = compiled;
+  }
+
+protected:
+  std::ostream& print_indent (std::ostream& os, size_t indent = 0) const
+  {
+    for (size_t i = 0; i < indent * 8; ++i)
+      os << " ";
+    return os;
+  }
+
+  llvm::Value *llvm_value;
+private:
+  jit_type *ty;
+  jit_instruction *mlast_use;
+  bool min_worklist;
+};
+
+std::ostream& operator<< (std::ostream& os, const jit_value& value);
+std::ostream& jit_print (std::ostream& os, jit_value *avalue);
+
+class
+jit_use : public jit_internal_node<jit_value, jit_use>
+{
+public:
+  jit_use (void) : muser (0), mindex (0) {}
+
+  // we should really have a move operator, but not until c++11 :(
+  jit_use (const jit_use& use) : muser (0), mindex (0)
+  {
+    *this = use;
+  }
+
+  jit_use& operator= (const jit_use& use)
+  {
+    stash_value (use.value (), use.user (), use.index ());
+    return *this;
+  }
+
+  size_t index (void) const { return mindex; }
+
+  jit_instruction *user (void) const { return muser; }
+
+  jit_block *user_parent (void) const;
+
+  std::list<jit_block *> user_parent_location (void) const;
+
+  void stash_value (jit_value *avalue, jit_instruction *auser = 0,
+                    size_t aindex = -1)
+  {
+    jit_internal_node::stash_value (avalue);
+    mindex = aindex;
+    muser = auser;
+  }
+private:
+  jit_instruction *muser;
+  size_t mindex;
+};
+
+class
+jit_instruction : public jit_value
+{
+public:
+  // FIXME: this code could be so much pretier with varadic templates...
+  jit_instruction (void) : mid (next_id ()), mparent (0)
+  {}
+
+  jit_instruction (size_t nargs) : mid (next_id ()), mparent (0)
+  {
+    already_infered.reserve (nargs);
+    marguments.reserve (nargs);
+  }
+
+#define STASH_ARG(i) stash_argument (i, arg ## i);
+#define JIT_INSTRUCTION_CTOR(N)                                         \
+  jit_instruction (OCT_MAKE_DECL_LIST (jit_value *, arg, N))            \
+  : already_infered (N), marguments (N), mid (next_id ()), mparent (0)  \
+  {                                                                     \
+    OCT_ITERATE_MACRO (STASH_ARG, N);                                   \
+  }
+
+  JIT_INSTRUCTION_CTOR(1)
+  JIT_INSTRUCTION_CTOR(2)
+  JIT_INSTRUCTION_CTOR(3)
+  JIT_INSTRUCTION_CTOR(4)
+
+#undef STASH_ARG
+#undef JIT_INSTRUCTION_CTOR
+
+  static void reset_ids (void)
+  {
+    next_id (true);
+  }
+
+  jit_value *argument (size_t i) const
+  {
+    return marguments[i].value ();
+  }
+
+  llvm::Value *argument_llvm (size_t i) const
+  {
+    assert (argument (i));
+    return argument (i)->to_llvm ();
+  }
+
+  jit_type *argument_type (size_t i) const
+  {
+    return argument (i)->type ();
+  }
+
+  llvm::Type *argument_type_llvm (size_t i) const
+  {
+    assert (argument (i));
+    return argument_type (i)->to_llvm ();
+  }
+
+  std::ostream& print_argument (std::ostream& os, size_t i) const
+  {
+    if (argument (i))
+      return argument (i)->short_print (os);
+    else
+      return os << "NULL";
+  }
+
+  void stash_argument (size_t i, jit_value *arg)
+  {
+    marguments[i].stash_value (arg, this, i);
+  }
+
+  void push_argument (jit_value *arg)
+  {
+    marguments.push_back (jit_use ());
+    stash_argument (marguments.size () - 1, arg);
+    already_infered.push_back (0);
+  }
+
+  size_t argument_count (void) const
+  {
+    return marguments.size ();
+  }
+
+  void resize_arguments (size_t acount, jit_value *adefault = 0)
+  {
+    size_t old = marguments.size ();
+    marguments.resize (acount);
+    already_infered.resize (acount);
+
+    if (adefault)
+      for (size_t i = old; i < acount; ++i)
+        stash_argument (i, adefault);
+  }
+
+  const std::vector<jit_use>& arguments (void) const { return marguments; }
+
+  // argument types which have been infered already
+  const std::vector<jit_type *>& argument_types (void) const
+  { return already_infered; }
+
+  virtual void push_variable (void) {}
+
+  virtual void pop_variable (void) {}
+
+  virtual void construct_ssa (void)
+  {
+    do_construct_ssa (0, argument_count ());
+  }
+
+  virtual bool infer (void) { return false; }
+
+  void remove (void);
+
+  virtual std::ostream& short_print (std::ostream& os) const;
+
+  jit_block *parent (void) const { return mparent; }
+
+  std::list<jit_instruction *>::iterator location (void) const
+  {
+    return mlocation;
+  }
+
+  llvm::BasicBlock *parent_llvm (void) const;
+
+  void stash_parent (jit_block *aparent,
+                     std::list<jit_instruction *>::iterator alocation)
+  {
+    mparent = aparent;
+    mlocation = alocation;
+  }
+
+  size_t id (void) const { return mid; }
+protected:
+
+  // Do SSA replacement on arguments in [start, end)
+  void do_construct_ssa (size_t start, size_t end);
+
+  std::vector<jit_type *> already_infered;
+private:
+  static size_t next_id (bool reset = false)
+  {
+    static size_t ret = 0;
+    if (reset)
+      return ret = 0;
+
+    return ret++;
+  }
+
+  std::vector<jit_use> marguments;
+
+  size_t mid;
+  jit_block *mparent;
+  std::list<jit_instruction *>::iterator mlocation;
+};
+
+// defnie accept methods for subclasses
+#define JIT_VALUE_ACCEPT                        \
+  virtual void accept (jit_ir_walker& walker);
+
+// for use as a dummy argument during conversion to LLVM
+class
+jit_argument : public jit_value
+{
+public:
+  jit_argument (jit_type *atype, llvm::Value *avalue)
+  {
+    stash_type (atype);
+    stash_llvm (avalue);
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent);
+    return jit_print (os, type ()) << ": DUMMY";
+  }
+
+  JIT_VALUE_ACCEPT;
+};
+
+template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T,
+          bool QUOTE>
+class
+jit_const : public jit_value
+{
+public:
+  typedef PASS_T pass_t;
+
+  jit_const (PASS_T avalue) : mvalue (avalue)
+  {
+    stash_type (EXTRACT_T ());
+  }
+
+  PASS_T value (void) const { return mvalue; }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent);
+    jit_print (os, type ()) << ": ";
+    if (QUOTE)
+      os << "\"";
+    os << mvalue;
+    if (QUOTE)
+      os << "\"";
+    return os;
+  }
+
+  JIT_VALUE_ACCEPT;
+private:
+  T mvalue;
+};
+
+class jit_phi_incomming;
+
+class
+jit_block : public jit_value, public jit_internal_list<jit_block,
+                                                       jit_phi_incomming>
+{
+  typedef jit_internal_list<jit_block, jit_phi_incomming> ILIST_T;
+public:
+  typedef std::list<jit_instruction *> instruction_list;
+  typedef instruction_list::iterator iterator;
+  typedef instruction_list::const_iterator const_iterator;
+
+  typedef std::set<jit_block *> df_set;
+  typedef df_set::const_iterator df_iterator;
+
+  static const size_t NO_ID = static_cast<size_t> (-1);
+
+  jit_block (const std::string& aname, size_t avisit_count = 0)
+    : mvisit_count (avisit_count), mid (NO_ID), idom (0), mname (aname),
+      malive (false)
+  {}
+
+  virtual void replace_with (jit_value *value);
+
+  void replace_in_phi (jit_block *ablock, jit_block *with);
+
+  // we have a new internal list, but we want to stay compatable with jit_value
+  jit_use *first_use (void) const { return jit_value::first_use (); }
+
+  size_t use_count (void) const { return jit_value::use_count (); }
+
+  // if a block is alive, then it might be visited during execution
+  bool alive (void) const { return malive; }
+
+  void mark_alive (void) { malive = true; }
+
+  // If we can merge with a successor, do so and return the now empty block
+  jit_block *maybe_merge ();
+
+  // merge another block into this block, leaving the merge block empty
+  void merge (jit_block& merge);
+
+  const std::string& name (void) const { return mname; }
+
+  jit_instruction *prepend (jit_instruction *instr);
+
+  jit_instruction *prepend_after_phi (jit_instruction *instr);
+
+  template <typename T>
+  T *append (T *instr)
+  {
+    internal_append (instr);
+    return instr;
+  }
+
+  jit_instruction *insert_before (iterator loc, jit_instruction *instr);
+
+  jit_instruction *insert_before (jit_instruction *loc, jit_instruction *instr)
+  {
+    return insert_before (loc->location (), instr);
+  }
+
+  jit_instruction *insert_after (iterator loc, jit_instruction *instr);
+
+  jit_instruction *insert_after (jit_instruction *loc, jit_instruction *instr)
+  {
+    return insert_after (loc->location (), instr);
+  }
+
+  iterator remove (iterator iter)
+  {
+    jit_instruction *instr = *iter;
+    iter = instructions.erase (iter);
+    instr->stash_parent (0, instructions.end ());
+    return iter;
+  }
+
+  jit_terminator *terminator (void) const;
+
+  // is the jump from pred alive?
+  bool branch_alive (jit_block *asucc) const;
+
+  jit_block *successor (size_t i) const;
+
+  size_t successor_count (void) const;
+
+  iterator begin (void) { return instructions.begin (); }
+
+  const_iterator begin (void) const { return instructions.begin (); }
+
+  iterator end (void) { return instructions.end (); }
+
+  const_iterator end (void) const { return instructions.end (); }
+
+  iterator phi_begin (void);
+
+  iterator phi_end (void);
+
+  iterator nonphi_begin (void);
+
+  // must label before id is valid
+  size_t id (void) const { return mid; }
+
+  // dominance frontier
+  const df_set& df (void) const { return mdf; }
+
+  df_iterator df_begin (void) const { return mdf.begin (); }
+
+  df_iterator df_end (void) const { return mdf.end (); }
+
+  // label with a RPO walk
+  void label (void)
+  {
+    size_t number = 0;
+    label (mvisit_count, number);
+  }
+
+  void label (size_t avisit_count, size_t& number)
+  {
+    if (visited (avisit_count))
+      return;
+
+    for (jit_use *use = first_use (); use; use = use->next ())
+      {
+        jit_block *pred = use->user_parent ();
+        pred->label (avisit_count, number);
+      }
+
+    mid = number++;
+  }
+
+  // See for idom computation algorithm
+  // Cooper, Keith D.; Harvey, Timothy J; and Kennedy, Ken (2001).
+  // "A Simple, Fast Dominance Algorithm"
+  void compute_idom (jit_block *entry_block)
+  {
+    bool changed;
+    entry_block->idom = entry_block;
+    do
+      changed = update_idom (mvisit_count);
+    while (changed);
+  }
+
+  // compute dominance frontier
+  void compute_df (void)
+  {
+    compute_df (mvisit_count);
+  }
+
+  void create_dom_tree (void)
+  {
+    create_dom_tree (mvisit_count);
+  }
+
+  jit_block *dom_successor (size_t idx) const
+  {
+    return dom_succ[idx];
+  }
+
+  size_t dom_successor_count (void) const
+  {
+    return dom_succ.size ();
+  }
+
+  // call pop_varaible on all instructions
+  void pop_all (void);
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent);
+    short_print (os) << ":        %pred = ";
+    for (jit_use *use = first_use (); use; use = use->next ())
+      {
+        jit_block *pred = use->user_parent ();
+        os << *pred;
+        if (use->next ())
+          os << ", ";
+      }
+    os << std::endl;
+
+    for (const_iterator iter = begin (); iter != end (); ++iter)
+      {
+        jit_instruction *instr = *iter;
+        instr->print (os, indent + 1) << std::endl;
+      }
+    return os;
+  }
+
+  // ...
+  jit_block *maybe_split (jit_convert& convert, jit_block *asuccessor);
+
+  jit_block *maybe_split (jit_convert& convert, jit_block& asuccessor)
+  {
+    return maybe_split (convert, &asuccessor);
+  }
+
+  // print dominator infomration
+  std::ostream& print_dom (std::ostream& os) const;
+
+  virtual std::ostream& short_print (std::ostream& os) const
+  {
+    os << mname;
+    if (mid != NO_ID)
+      os << mid;
+    return os;
+  }
+
+  llvm::BasicBlock *to_llvm (void) const;
+
+  std::list<jit_block *>::iterator location (void) const
+  { return mlocation; }
+
+  void stash_location (std::list<jit_block *>::iterator alocation)
+  { mlocation = alocation; }
+
+  // used to prevent visiting the same node twice in the graph
+  size_t visit_count (void) const { return mvisit_count; }
+
+  // check if this node has been visited yet at the given visit count. If we
+  // have not been visited yet, mark us as visited.
+  bool visited (size_t avisit_count)
+  {
+    if (mvisit_count <= avisit_count)
+      {
+        mvisit_count = avisit_count + 1;
+        return false;
+      }
+
+    return true;
+  }
+
+  JIT_VALUE_ACCEPT;
+private:
+  void internal_append (jit_instruction *instr);
+
+  void compute_df (size_t avisit_count);
+
+  bool update_idom (size_t avisit_count);
+
+  void create_dom_tree (size_t avisit_count);
+
+  static jit_block *idom_intersect (jit_block *i, jit_block *j);
+
+  size_t mvisit_count;
+  size_t mid;
+  jit_block *idom;
+  df_set mdf;
+  std::vector<jit_block *> dom_succ;
+  std::string mname;
+  instruction_list instructions;
+  bool malive;
+  std::list<jit_block *>::iterator mlocation;
+};
+
+// keeps track of phi functions that use a block on incomming edges
+class
+jit_phi_incomming : public jit_internal_node<jit_block, jit_phi_incomming>
+{
+public:
+  jit_phi_incomming (void) : muser (0) {}
+
+  jit_phi_incomming (jit_phi *auser) : muser (auser) {}
+
+  jit_phi_incomming (const jit_phi_incomming& use) : jit_internal_node ()
+  {
+    *this = use;
+  }
+
+  jit_phi_incomming& operator= (const jit_phi_incomming& use)
+  {
+    stash_value (use.value ());
+    muser = use.muser;
+    return *this;
+  }
+
+  jit_phi *user (void) const { return muser; }
+
+  jit_block *user_parent (void) const;
+private:
+  jit_phi *muser;
+};
+
+// A non-ssa variable
+class
+jit_variable : public jit_value
+{
+public:
+  jit_variable (const std::string& aname) : mname (aname), mlast_use (0) {}
+
+  const std::string &name (void) const { return mname; }
+
+  // manipulate the value_stack, for use during SSA construction. The top of the
+  // value stack represents the current value for this variable
+  bool has_top (void) const
+  {
+    return ! value_stack.empty ();
+  }
+
+  jit_value *top (void) const
+  {
+    return value_stack.top ();
+  }
+
+  void push (jit_instruction *v)
+  {
+    value_stack.push (v);
+    mlast_use = v;
+  }
+
+  void pop (void)
+  {
+    value_stack.pop ();
+  }
+
+  jit_instruction *last_use (void) const
+  {
+    return mlast_use;
+  }
+
+  void stash_last_use (jit_instruction *instr)
+  {
+    mlast_use = instr;
+  }
+
+  // blocks in which we are used
+  void use_blocks (jit_block::df_set& result)
+  {
+    jit_use *use = first_use ();
+    while (use)
+      {
+        result.insert (use->user_parent ());
+        use = use->next ();
+      }
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    return print_indent (os, indent) << mname;
+  }
+
+  JIT_VALUE_ACCEPT;
+private:
+  std::string mname;
+  std::stack<jit_value *> value_stack;
+  jit_instruction *mlast_use;
+};
+
+class
+jit_assign_base : public jit_instruction
+{
+public:
+  jit_assign_base (jit_variable *adest) : jit_instruction (), mdest (adest) {}
+
+  jit_assign_base (jit_variable *adest, size_t npred) : jit_instruction (npred),
+                                                        mdest (adest) {}
+
+  jit_assign_base (jit_variable *adest, jit_value *arg0, jit_value *arg1)
+    : jit_instruction (arg0, arg1), mdest (adest) {}
+
+  jit_variable *dest (void) const { return mdest; }
+
+  virtual void push_variable (void)
+  {
+    mdest->push (this);
+  }
+
+  virtual void pop_variable (void)
+  {
+    mdest->pop ();
+  }
+
+  virtual std::ostream& short_print (std::ostream& os) const
+  {
+    if (type ())
+      jit_print (os, type ()) << ": ";
+
+    dest ()->short_print (os);
+    return os << "#" << id ();
+  }
+private:
+  jit_variable *mdest;
+};
+
+class
+jit_assign : public jit_assign_base
+{
+public:
+  jit_assign (jit_variable *adest, jit_value *asrc)
+    : jit_assign_base (adest, adest, asrc), martificial (false) {}
+
+  jit_value *overwrite (void) const
+  {
+    return argument (0);
+  }
+
+  jit_value *src (void) const
+  {
+    return argument (1);
+  }
+
+  // variables don't get modified in an SSA, but COW requires we modify
+  // variables. An artificial assign is for when a variable gets modified. We
+  // need an assign in the SSA, but the reference counts shouldn't be updated.
+  bool artificial (void) const { return martificial; }
+
+  void mark_artificial (void) { martificial = true; }
+
+  virtual bool infer (void)
+  {
+    jit_type *stype = src ()->type ();
+    if (stype != type())
+      {
+        stash_type (stype);
+        return true;
+      }
+
+    return false;
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent) << *this << " = " << *src ();
+
+    if (artificial ())
+      os << " [artificial]";
+
+    return os;
+  }
+
+  JIT_VALUE_ACCEPT;
+private:
+  bool martificial;
+};
+
+class
+jit_phi : public jit_assign_base
+{
+public:
+  jit_phi (jit_variable *adest, size_t npred)
+    : jit_assign_base (adest, npred)
+  {
+    mincomming.reserve (npred);
+  }
+
+  // removes arguments form dead incomming jumps
+  bool prune (void);
+
+  void add_incomming (jit_block *from, jit_value *value)
+  {
+    push_argument (value);
+    mincomming.push_back (jit_phi_incomming (this));
+    mincomming[mincomming.size () - 1].stash_value (from);
+  }
+
+  jit_block *incomming (size_t i) const
+  {
+    return mincomming[i].value ();
+  }
+
+  llvm::BasicBlock *incomming_llvm (size_t i) const
+  {
+    return incomming (i)->to_llvm ();
+  }
+
+  virtual void construct_ssa (void) {}
+
+  virtual bool infer (void);
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    std::stringstream ss;
+    print_indent (ss, indent);
+    short_print (ss) << " phi ";
+    std::string ss_str = ss.str ();
+    std::string indent_str (ss_str.size (), ' ');
+    os << ss_str;
+
+    for (size_t i = 0; i < argument_count (); ++i)
+      {
+        if (i > 0)
+          os << indent_str;
+        os << "| ";
+
+        os << *incomming (i) << " -> ";
+        os << *argument (i);
+
+        if (i + 1 < argument_count ())
+          os << std::endl;
+      }
+
+    return os;
+  }
+
+  llvm::PHINode *to_llvm (void) const;
+
+  JIT_VALUE_ACCEPT;
+private:
+  std::vector<jit_phi_incomming> mincomming;
+};
+
+class
+jit_terminator : public jit_instruction
+{
+public:
+#define JIT_TERMINATOR_CONST(N)                                         \
+  jit_terminator (size_t asuccessor_count,                              \
+                  OCT_MAKE_DECL_LIST (jit_value *, arg, N))             \
+    : jit_instruction (OCT_MAKE_ARG_LIST (arg, N)),                     \
+      malive (asuccessor_count, false) {}
+
+  JIT_TERMINATOR_CONST (1)
+  JIT_TERMINATOR_CONST (2)
+  JIT_TERMINATOR_CONST (3)
+
+#undef JIT_TERMINATOR_CONST
+
+  jit_block *successor (size_t idx = 0) const
+  {
+    return static_cast<jit_block *> (argument (idx));
+  }
+
+  llvm::BasicBlock *successor_llvm (size_t idx = 0) const
+  {
+    return successor (idx)->to_llvm ();
+  }
+
+  size_t successor_index (const jit_block *asuccessor) const;
+
+  std::ostream& print_successor (std::ostream& os, size_t idx = 0) const
+  {
+    if (alive (idx))
+      os << "[live] ";
+    else
+      os << "[dead] ";
+
+    return successor (idx)->short_print (os);
+  }
+
+  // Check if the jump to successor is live
+  bool alive (const jit_block *asuccessor) const
+  {
+    return alive (successor_index (asuccessor));
+  }
+
+  bool alive (size_t idx) const { return malive[idx]; }
+
+  bool alive (int idx) const { return malive[idx]; }
+
+  size_t successor_count (void) const { return malive.size (); }
+
+  virtual bool infer (void);
+
+  llvm::TerminatorInst *to_llvm (void) const;
+protected:
+  virtual bool check_alive (size_t) const { return true; }
+private:
+  std::vector<bool> malive;
+};
+
+class
+jit_branch : public jit_terminator
+{
+public:
+  jit_branch (jit_block *succ) : jit_terminator (1, succ) {}
+
+  virtual size_t successor_count (void) const { return 1; }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent) << "branch: ";
+    return print_successor (os);
+  }
+
+  JIT_VALUE_ACCEPT;
+};
+
+class
+jit_cond_branch : public jit_terminator
+{
+public:
+  jit_cond_branch (jit_value *c, jit_block *ctrue, jit_block *cfalse)
+    : jit_terminator (2, ctrue, cfalse, c) {}
+
+  jit_value *cond (void) const { return argument (2); }
+
+  std::ostream& print_cond (std::ostream& os) const
+  {
+    return cond ()->short_print (os);
+  }
+
+  llvm::Value *cond_llvm (void) const
+  {
+    return cond ()->to_llvm ();
+  }
+
+  virtual size_t successor_count (void) const { return 2; }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent) << "cond_branch: ";
+    print_cond (os) << ", ";
+    print_successor (os, 0) << ", ";
+    return print_successor (os, 1);
+  }
+
+  JIT_VALUE_ACCEPT;
+};
+
+class
+jit_call : public jit_instruction
+{
+public:
+#define JIT_CALL_CONST(N)                                               \
+  jit_call (const jit_operation& aoperation,                            \
+            OCT_MAKE_DECL_LIST (jit_value *, arg, N))                   \
+    : jit_instruction (OCT_MAKE_ARG_LIST (arg, N)), moperation (aoperation) {} \
+                                                                        \
+  jit_call (const jit_operation& (*aoperation) (void),                  \
+            OCT_MAKE_DECL_LIST (jit_value *, arg, N))                   \
+    : jit_instruction (OCT_MAKE_ARG_LIST (arg, N)), moperation (aoperation ()) \
+  {}
+
+  JIT_CALL_CONST (1)
+  JIT_CALL_CONST (2)
+  JIT_CALL_CONST (3)
+  JIT_CALL_CONST (4)
+
+#undef JIT_CALL_CONST
+
+
+  const jit_operation& operation (void) const { return moperation; }
+
+  bool can_error (void) const
+  {
+    return overload ().can_error ();
+  }
+
+  const jit_function& overload (void) const
+  {
+    return moperation.overload (argument_types ());
+  }
+
+  virtual bool needs_release (void) const
+  {
+    return type () && jit_typeinfo::get_release (type ()).valid ();
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent);
+
+    if (use_count ())
+      short_print (os) << " = ";
+    os << "call " << moperation.name () << " (";
+
+    for (size_t i = 0; i < argument_count (); ++i)
+      {
+        print_argument (os, i);
+        if (i + 1 < argument_count ())
+          os << ", ";
+      }
+    return os << ")";
+  }
+
+  virtual bool infer (void);
+
+  JIT_VALUE_ACCEPT;
+private:
+  const jit_operation& moperation;
+};
+
+// FIXME: This is just ugly...
+// checks error_state, if error_state is false then goto the normal branche,
+// otherwise goto the error branch
+class
+jit_error_check : public jit_terminator
+{
+public:
+  jit_error_check (jit_call *acheck_for, jit_block *normal, jit_block *error)
+    : jit_terminator (2, error, normal, acheck_for) {}
+
+  jit_call *check_for (void) const
+  {
+    return static_cast<jit_call *> (argument (2));
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent) << "error_check " << *check_for () << ", ";
+    print_successor (os, 1) << ", ";
+    return print_successor (os, 0);
+  }
+
+  JIT_VALUE_ACCEPT;
+protected:
+  virtual bool check_alive (size_t idx) const
+  {
+    return idx == 1 ? true : check_for ()->can_error ();
+  }
+};
+
+class
+jit_extract_argument : public jit_assign_base
+{
+public:
+  jit_extract_argument (jit_type *atype, jit_variable *adest)
+    : jit_assign_base (adest)
+  {
+    stash_type (atype);
+  }
+
+  const std::string& name (void) const
+  {
+    return dest ()->name ();
+  }
+
+  const jit_function& overload (void) const
+  {
+    return jit_typeinfo::cast (type (), jit_typeinfo::get_any ());
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    print_indent (os, indent);
+
+    return short_print (os) << " = extract " << name ();
+  }
+
+  JIT_VALUE_ACCEPT;
+};
+
+class
+jit_store_argument : public jit_instruction
+{
+public:
+  jit_store_argument (jit_variable *var)
+  : jit_instruction (var), dest (var)
+  {}
+
+  const std::string& name (void) const
+  {
+    return dest->name ();
+  }
+
+  const jit_function& overload (void) const
+  {
+    return jit_typeinfo::cast (jit_typeinfo::get_any (), result_type ());
+  }
+
+  jit_value *result (void) const
+  {
+    return argument (0);
+  }
+
+  jit_type *result_type (void) const
+  {
+    return result ()->type ();
+  }
+
+  llvm::Value *result_llvm (void) const
+  {
+    return result ()->to_llvm ();
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
+  {
+    jit_value *res = result ();
+    print_indent (os, indent) << "store ";
+    dest->short_print (os);
+
+    if (! isa<jit_variable> (res))
+      {
+        os << " = ";
+        res->short_print (os);
+      }
+
+    return os;
+  }
+
+  JIT_VALUE_ACCEPT;
+private:
+  jit_variable *dest;
+};
+
+class
+jit_ir_walker
+{
+public:
+  virtual ~jit_ir_walker () {}
+
+#define JIT_METH(clname) \
+  virtual void visit (jit_ ## clname&) = 0;
+
+  JIT_VISIT_IR_CLASSES;
+
+#undef JIT_METH
+};
+
+template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T, bool QUOTE>
+void
+jit_const<T, EXTRACT_T, PASS_T, QUOTE>::accept (jit_ir_walker& walker)
+{
+  walker.visit (*this);
+}
+
+#undef JIT_VALUE_ACCEPT
+
+#endif
+#endif
diff --git a/src/jit-typeinfo.cc b/src/jit-typeinfo.cc
new file mode 100644
--- /dev/null
+++ b/src/jit-typeinfo.cc
@@ -0,0 +1,1819 @@
+/*
+
+Copyright (C) 2012 Max Brister <max@2bass.com>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// defines required by llvm
+#define __STDC_LIMIT_MACROS
+#define __STDC_CONSTANT_MACROS
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef HAVE_LLVM
+
+#include "jit-typeinfo.h"
+
+#include <llvm/Analysis/Verifier.h>
+#include <llvm/GlobalVariable.h>
+#include <llvm/ExecutionEngine/ExecutionEngine.h>
+#include <llvm/LLVMContext.h>
+#include <llvm/Function.h>
+#include <llvm/Instructions.h>
+#include <llvm/Intrinsics.h>
+#include <llvm/Support/IRBuilder.h>
+#include <llvm/Support/raw_os_ostream.h>
+
+#include "jit-ir.h"
+#include "ov.h"
+#include "ov-builtin.h"
+#include "ov-complex.h"
+#include "ov-scalar.h"
+#include "pager.h"
+
+static llvm::LLVMContext& context = llvm::getGlobalContext ();
+
+jit_typeinfo *jit_typeinfo::instance = 0;
+
+std::ostream& jit_print (std::ostream& os, jit_type *atype)
+{
+  if (! atype)
+    return os << "null";
+  return os << atype->name ();
+}
+
+// function that jit code calls
+extern "C" void
+octave_jit_print_any (const char *name, octave_base_value *obv)
+{
+  obv->print_with_name (octave_stdout, name, true);
+}
+
+extern "C" void
+octave_jit_print_scalar (const char *name, double value)
+{
+  // FIXME: We should avoid allocating a new octave_scalar each time
+  octave_value ov (value);
+  ov.print_with_name (octave_stdout, name);
+}
+
+extern "C" octave_base_value*
+octave_jit_binary_any_any (octave_value::binary_op op, octave_base_value *lhs,
+                           octave_base_value *rhs)
+{
+  octave_value olhs (lhs, true);
+  octave_value orhs (rhs, true);
+  octave_value result = do_binary_op (op, olhs, orhs);
+  octave_base_value *rep = result.internal_rep ();
+  rep->grab ();
+  return rep;
+}
+
+extern "C" octave_idx_type
+octave_jit_compute_nelem (double base, double limit, double inc)
+{
+  Range rng = Range (base, limit, inc);
+  return rng.nelem ();
+}
+
+extern "C" void
+octave_jit_release_any (octave_base_value *obv)
+{
+  obv->release ();
+}
+
+extern "C" void
+octave_jit_release_matrix (jit_matrix *m)
+{
+  delete m->array;
+}
+
+extern "C" octave_base_value *
+octave_jit_grab_any (octave_base_value *obv)
+{
+  obv->grab ();
+  return obv;
+}
+
+extern "C" void
+octave_jit_grab_matrix (jit_matrix *result, jit_matrix *m)
+{
+  *result = *m->array;
+}
+
+extern "C" octave_base_value *
+octave_jit_cast_any_matrix (jit_matrix *m)
+{
+  octave_value ret (*m->array);
+  octave_base_value *rep = ret.internal_rep ();
+  rep->grab ();
+  delete m->array;
+
+  return rep;
+}
+
+extern "C" void
+octave_jit_cast_matrix_any (jit_matrix *ret, octave_base_value *obv)
+{
+  NDArray m = obv->array_value ();
+  *ret = m;
+  obv->release ();
+}
+
+extern "C" octave_base_value *
+octave_jit_cast_any_range (jit_range *rng)
+{
+  Range temp (*rng);
+  octave_value ret (temp);
+  octave_base_value *rep = ret.internal_rep ();
+  rep->grab ();
+
+  return rep;
+}
+extern "C" void
+octave_jit_cast_range_any (jit_range *ret, octave_base_value *obv)
+{
+
+  jit_range r (obv->range_value ());
+  *ret = r;
+  obv->release ();
+}
+
+extern "C" double
+octave_jit_cast_scalar_any (octave_base_value *obv)
+{
+  double ret = obv->double_value ();
+  obv->release ();
+  return ret;
+}
+
+extern "C" octave_base_value *
+octave_jit_cast_any_scalar (double value)
+{
+  return new octave_scalar (value);
+}
+
+extern "C" Complex
+octave_jit_cast_complex_any (octave_base_value *obv)
+{
+  Complex ret = obv->complex_value ();
+  obv->release ();
+  return ret;
+}
+
+extern "C" octave_base_value *
+octave_jit_cast_any_complex (Complex c)
+{
+  if (c.imag () == 0)
+    return new octave_scalar (c.real ());
+  else
+    return new octave_complex (c);
+}
+
+extern "C" void
+octave_jit_gripe_nan_to_logical_conversion (void)
+{
+  try
+    {
+      gripe_nan_to_logical_conversion ();
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_library_execution_error ();
+    }
+}
+
+extern "C" void
+octave_jit_ginvalid_index (void)
+{
+  try
+    {
+      gripe_invalid_index ();
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_library_execution_error ();
+    }
+}
+
+extern "C" void
+octave_jit_gindex_range (int nd, int dim, octave_idx_type iext,
+                         octave_idx_type ext)
+{
+  try
+    {
+      gripe_index_out_of_range (nd, dim, iext, ext);
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_library_execution_error ();
+    }
+}
+
+extern "C" void
+octave_jit_paren_subsasgn_impl (jit_matrix *ret, jit_matrix *mat,
+                                octave_idx_type index, double value)
+{
+  NDArray *array = mat->array;
+  if (array->nelem () < index)
+    array->resize1 (index);
+
+  double *data = array->fortran_vec ();
+  data[index - 1] = value;
+
+  mat->update ();
+  *ret = *mat;
+}
+
+extern "C" void
+octave_jit_paren_subsasgn_matrix_range (jit_matrix *result, jit_matrix *mat,
+                                        jit_range *index, double value)
+{
+  NDArray *array = mat->array;
+  bool done = false;
+
+  // optimize for the simple case (no resizing and no errors)
+  if (*array->jit_ref_count () == 1
+      && index->all_elements_are_ints ())
+    {
+      // this code is similar to idx_vector::fill, but we avoid allocating an
+      // idx_vector and its associated rep
+      octave_idx_type start = static_cast<octave_idx_type> (index->base) - 1;
+      octave_idx_type step = static_cast<octave_idx_type> (index->inc);
+      octave_idx_type nelem = index->nelem;
+      octave_idx_type final = start + nelem * step;
+      if (step < 0)
+        {
+          step = -step;
+          std::swap (final, start);
+        }
+
+      if (start >= 0 && final < mat->slice_len)
+        {
+          done = true;
+
+          double *data = array->jit_slice_data ();
+          if (step == 1)
+            std::fill (data + start, data + start + nelem, value);
+          else
+            {
+              for (octave_idx_type i = start; i < final; i += step)
+                data[i] = value;
+            }
+        }
+    }
+
+  if (! done)
+    {
+      idx_vector idx (*index);
+      NDArray avalue (dim_vector (1, 1));
+      avalue.xelem (0) = value;
+      array->assign (idx, avalue);
+    }
+
+  result->update (array);
+}
+
+extern "C" Complex
+octave_jit_complex_div (Complex lhs, Complex rhs)
+{
+  // see src/OPERATORS/op-cs-cs.cc
+  if (rhs == 0.0)
+    gripe_divide_by_zero ();
+
+  return lhs / rhs;
+}
+
+// FIXME: CP form src/xpow.cc
+static inline int
+xisint (double x)
+{
+  return (D_NINT (x) == x
+          && ((x >= 0 && x < INT_MAX)
+              || (x <= 0 && x > INT_MIN)));
+}
+
+extern "C" Complex
+octave_jit_pow_scalar_scalar (double lhs, double rhs)
+{
+  // FIXME: almost CP from src/xpow.cc
+  if (lhs < 0.0 && ! xisint (rhs))
+    return std::pow (Complex (lhs), rhs);
+  return std::pow (lhs, rhs);
+}
+
+extern "C" Complex
+octave_jit_pow_complex_complex (Complex lhs, Complex rhs)
+{
+  if (lhs.imag () == 0 && rhs.imag () == 0)
+    return octave_jit_pow_scalar_scalar (lhs.real (), rhs.real ());
+  return std::pow (lhs, rhs);
+}
+
+extern "C" Complex
+octave_jit_pow_complex_scalar (Complex lhs, double rhs)
+{
+  if (lhs.imag () == 0)
+    return octave_jit_pow_scalar_scalar (lhs.real (), rhs);
+  return std::pow (lhs, rhs);
+}
+
+extern "C" Complex
+octave_jit_pow_scalar_complex (double lhs, Complex rhs)
+{
+  if (rhs.imag () == 0)
+    return octave_jit_pow_scalar_scalar (lhs, rhs.real ());
+  return std::pow (lhs, rhs);
+}
+
+extern "C" void
+octave_jit_print_matrix (jit_matrix *m)
+{
+  std::cout << *m << std::endl;
+}
+
+static void
+gripe_bad_result (void)
+{
+  error ("incorrect type information given to the JIT compiler");
+}
+
+// FIXME: Add support for multiple outputs
+extern "C" octave_base_value *
+octave_jit_call (octave_builtin::fcn fn, size_t nargin,
+                 octave_base_value **argin, jit_type *result_type)
+{
+  octave_value_list ovl (nargin);
+  for (size_t i = 0; i < nargin; ++i)
+    ovl.xelem (i) = octave_value (argin[i]);
+
+  ovl = fn (ovl, 1);
+
+  // These type checks are not strictly required, but I'm guessing that
+  // incorrect types will be entered on occasion. This will be very difficult to
+  // debug unless we do the sanity check here.
+  if (result_type)
+    {
+      if (ovl.length () != 1)
+        {
+          gripe_bad_result ();
+          return 0;
+        }
+
+      octave_value& result = ovl.xelem (0);
+      jit_type *jtype = jit_typeinfo::join (jit_typeinfo::type_of (result),
+                                            result_type);
+      if (jtype != result_type)
+        {
+          gripe_bad_result ();
+          return 0;
+        }
+
+      octave_base_value *ret = result.internal_rep ();
+      ret->grab ();
+      return ret;
+    }
+
+  if (! (ovl.length () == 0
+         || (ovl.length () == 1 && ovl.xelem (0).is_undefined ())))
+    gripe_bad_result ();
+
+  return 0;
+}
+
+// -------------------- jit_range --------------------
+bool
+jit_range::all_elements_are_ints () const
+{
+  Range r (*this);
+  return r.all_elements_are_ints ();
+}
+
+std::ostream&
+operator<< (std::ostream& os, const jit_range& rng)
+{
+  return os << "Range[" << rng.base << ", " << rng.limit << ", " << rng.inc
+            << ", " << rng.nelem << "]";
+}
+
+// -------------------- jit_matrix --------------------
+
+std::ostream&
+operator<< (std::ostream& os, const jit_matrix& mat)
+{
+  return os << "Matrix[" << mat.ref_count << ", " << mat.slice_data << ", "
+            << mat.slice_len << ", " << mat.dimensions << ", "
+            << mat.array << "]";
+}
+
+// -------------------- jit_type --------------------
+jit_type::jit_type (const std::string& aname, jit_type *aparent,
+                    llvm::Type *allvm_type, int aid) :
+  mname (aname), mparent (aparent), llvm_type (allvm_type), mid (aid),
+  mdepth (aparent ? aparent->mdepth + 1 : 0)
+{
+  std::memset (msret, 0, sizeof (msret));
+  std::memset (mpointer_arg, 0, sizeof (mpointer_arg));
+  std::memset (mpack, 0, sizeof (mpack));
+  std::memset (munpack, 0, sizeof (munpack));
+
+  for (size_t i = 0; i < jit_convention::length; ++i)
+    mpacked_type[i] = llvm_type;
+}
+
+llvm::Type *
+jit_type::to_llvm_arg (void) const
+{
+  return llvm_type ? llvm_type->getPointerTo () : 0;
+}
+
+// -------------------- jit_function --------------------
+jit_function::jit_function () : module (0), llvm_function (0), mresult (0),
+                                call_conv (jit_convention::length),
+                                mcan_error (false)
+{}
+
+jit_function::jit_function (llvm::Module *amodule,
+                            jit_convention::type acall_conv,
+                            const llvm::Twine& aname, jit_type *aresult,
+                            const std::vector<jit_type *>& aargs)
+  : module (amodule), mresult (aresult), args (aargs), call_conv (acall_conv),
+    mcan_error (false)
+{
+  llvm::SmallVector<llvm::Type *, 15> llvm_args;
+
+  llvm::Type *rtype = llvm::Type::getVoidTy (context);
+  if (mresult)
+    {
+      rtype = mresult->packed_type (call_conv);
+      if (sret ())
+        {
+          llvm_args.push_back (rtype->getPointerTo ());
+          rtype = llvm::Type::getVoidTy (context);
+        }
+    }
+
+  for (std::vector<jit_type *>::const_iterator iter = args.begin ();
+       iter != args.end (); ++iter)
+    {
+      jit_type *ty = *iter;
+      assert (ty);
+      llvm::Type *argty = ty->packed_type (call_conv);
+      if (ty->pointer_arg (call_conv))
+        argty = argty->getPointerTo ();
+
+      llvm_args.push_back (argty);
+    }
+
+  // we mark all functinos as external linkage because this prevents llvm
+  // from getting rid of always inline functions
+  llvm::FunctionType *ft = llvm::FunctionType::get (rtype, llvm_args, false);
+  llvm_function = llvm::Function::Create (ft, llvm::Function::ExternalLinkage,
+                                          aname, module);
+  if (call_conv == jit_convention::internal)
+    llvm_function->addFnAttr (llvm::Attribute::AlwaysInline);
+}
+
+jit_function::jit_function (const jit_function& fn, jit_type *aresult,
+                            const std::vector<jit_type *>& aargs)
+  : module (fn.module), llvm_function (fn.llvm_function), mresult (aresult),
+    args (aargs), call_conv (fn.call_conv), mcan_error (fn.mcan_error)
+{
+}
+
+jit_function::jit_function (const jit_function& fn)
+  : module (fn.module), llvm_function (fn.llvm_function), mresult (fn.mresult),
+    args (fn.args), call_conv (fn.call_conv), mcan_error (fn.mcan_error)
+{}
+
+std::string
+jit_function::name (void) const
+{
+  return llvm_function->getName ();
+}
+
+llvm::BasicBlock *
+jit_function::new_block (const std::string& aname,
+                         llvm::BasicBlock *insert_before)
+{
+  return llvm::BasicBlock::Create (context, aname, llvm_function,
+                                   insert_before);
+}
+
+llvm::Value *
+jit_function::call (llvm::IRBuilderD& builder,
+                    const std::vector<jit_value *>& in_args) const
+{
+  assert (in_args.size () == args.size ());
+
+  std::vector<llvm::Value *> llvm_args (args.size ());
+  for (size_t i = 0; i < in_args.size (); ++i)
+    llvm_args[i] = in_args[i]->to_llvm ();
+
+  return call (builder, llvm_args);
+}
+
+llvm::Value *
+jit_function::call (llvm::IRBuilderD& builder,
+                    const std::vector<llvm::Value *>& in_args) const
+{
+  assert (valid ());
+  assert (in_args.size () == args.size ());
+  llvm::Function *stacksave
+    = llvm::Intrinsic::getDeclaration (module, llvm::Intrinsic::stacksave);
+  llvm::SmallVector<llvm::Value *, 10> llvm_args;
+  llvm_args.reserve (in_args.size () + sret ());
+
+  llvm::Value *sret_mem = 0;
+  llvm::Value *saved_stack = 0;
+  if (sret ())
+    {
+      saved_stack = builder.CreateCall (stacksave);
+      sret_mem = builder.CreateAlloca (mresult->packed_type (call_conv));
+      llvm_args.push_back (sret_mem);
+    }
+
+  for (size_t i = 0; i < in_args.size (); ++i)
+    {
+      llvm::Value *arg = in_args[i];
+      jit_type::convert_fn convert = args[i]->pack (call_conv);
+      if (convert)
+        arg = convert (builder, arg);
+
+      if (args[i]->pointer_arg (call_conv))
+        {
+          if (! saved_stack)
+            saved_stack = builder.CreateCall (stacksave);
+
+          arg = builder.CreateAlloca (args[i]->to_llvm ());
+          builder.CreateStore (in_args[i], arg);
+        }
+
+      llvm_args.push_back (arg);
+    }
+
+  llvm::Value *ret = builder.CreateCall (llvm_function, llvm_args);
+  if (sret_mem)
+    ret = builder.CreateLoad (sret_mem);
+
+  if (mresult)
+    {
+      jit_type::convert_fn unpack = mresult->unpack (call_conv);
+      if (unpack)
+        ret = unpack (builder, ret);
+    }
+
+  if (saved_stack)
+    {
+      llvm::Function *stackrestore
+        = llvm::Intrinsic::getDeclaration (module,
+                                           llvm::Intrinsic::stackrestore);
+      builder.CreateCall (stackrestore, saved_stack);
+    }
+
+  return ret;
+}
+
+llvm::Value *
+jit_function::argument (llvm::IRBuilderD& builder, size_t idx) const
+{
+  assert (idx < args.size ());
+
+  // FIXME: We should be treating arguments like a list, not a vector. Shouldn't
+  // matter much for now, as the number of arguments shouldn't be much bigger
+  // than 4
+  llvm::Function::arg_iterator iter = llvm_function->arg_begin ();
+  if (sret ())
+    ++iter;
+
+  for (size_t i = 0; i < idx; ++i, ++iter);
+
+  if (args[idx]->pointer_arg (call_conv))
+    return builder.CreateLoad (iter);
+
+  return iter;
+}
+
+void
+jit_function::do_return (llvm::IRBuilderD& builder, llvm::Value *rval)
+{
+  assert (! rval == ! mresult);
+
+  if (rval)
+    {
+      jit_type::convert_fn convert = mresult->pack (call_conv);
+      if (convert)
+        rval = convert (builder, rval);
+
+      if (sret ())
+        builder.CreateStore (rval, llvm_function->arg_begin ());
+      else
+        builder.CreateRet (rval);
+    }
+  else
+    builder.CreateRetVoid ();
+
+  llvm::verifyFunction (*llvm_function);
+}
+
+void
+jit_function::do_add_mapping (llvm::ExecutionEngine *engine, void *fn)
+{
+  assert (valid ());
+  engine->addGlobalMapping (llvm_function, fn);
+}
+
+std::ostream&
+operator<< (std::ostream& os, const jit_function& fn)
+{
+  llvm::Function *lfn = fn.to_llvm ();
+  os << "jit_function: cc=" << fn.call_conv;
+  llvm::raw_os_ostream llvm_out (os);
+  lfn->print (llvm_out);
+  llvm_out.flush ();
+  return os;
+}
+
+// -------------------- jit_operation --------------------
+void
+jit_operation::add_overload (const jit_function& func,
+                            const std::vector<jit_type*>& args)
+{
+  if (args.size () >= overloads.size ())
+    overloads.resize (args.size () + 1);
+
+  Array<jit_function>& over = overloads[args.size ()];
+  dim_vector dv (over.dims ());
+  Array<octave_idx_type> idx = to_idx (args);
+  bool must_resize = false;
+
+  if (dv.length () != idx.numel ())
+    {
+      dv.resize (idx.numel ());
+      must_resize = true;
+    }
+
+  for (octave_idx_type i = 0; i < dv.length (); ++i)
+    if (dv(i) <= idx(i))
+      {
+        must_resize = true;
+        dv(i) = idx(i) + 1;
+      }
+
+  if (must_resize)
+    over.resize (dv);
+
+  over(idx) = func;
+}
+
+const jit_function&
+jit_operation::overload (const std::vector<jit_type*>& types) const
+{
+  // FIXME: We should search for the next best overload on failure
+  static jit_function null_overload;
+  if (types.size () >= overloads.size ())
+    return null_overload;
+
+  for (size_t i  =0; i < types.size (); ++i)
+    if (! types[i])
+      return null_overload;
+
+  const Array<jit_function>& over = overloads[types.size ()];
+  dim_vector dv (over.dims ());
+  Array<octave_idx_type> idx = to_idx (types);
+  for (octave_idx_type i = 0; i < dv.length (); ++i)
+    if (idx(i) >= dv(i))
+      return null_overload;
+
+  return over(idx);
+}
+
+Array<octave_idx_type>
+jit_operation::to_idx (const std::vector<jit_type*>& types) const
+{
+  octave_idx_type numel = types.size ();
+  if (numel == 1)
+    numel = 2;
+
+  Array<octave_idx_type> idx (dim_vector (1, numel));
+  for (octave_idx_type i = 0; i < static_cast<octave_idx_type> (types.size ());
+       ++i)
+    idx(i) = types[i]->type_id ();
+
+  if (types.size () == 1)
+    {
+      idx(1) = idx(0);
+      idx(0) = 0;
+    }
+
+  return idx;
+}
+
+// -------------------- jit_typeinfo --------------------
+void
+jit_typeinfo::initialize (llvm::Module *m, llvm::ExecutionEngine *e)
+{
+  new jit_typeinfo (m, e);
+}
+
+jit_typeinfo::jit_typeinfo (llvm::Module *m, llvm::ExecutionEngine *e)
+  : module (m), engine (e), next_id (0),
+    builder (*new llvm::IRBuilderD (context))
+{
+  instance = this;
+
+  // FIXME: We should be registering types like in octave_value_typeinfo
+  llvm::Type *any_t = llvm::StructType::create (context, "octave_base_value");
+  any_t = any_t->getPointerTo ();
+
+  llvm::Type *scalar_t = llvm::Type::getDoubleTy (context);
+  llvm::Type *bool_t = llvm::Type::getInt1Ty (context);
+  llvm::Type *string_t = llvm::Type::getInt8Ty (context);
+  string_t = string_t->getPointerTo ();
+  llvm::Type *index_t = llvm::Type::getIntNTy (context,
+                                               sizeof(octave_idx_type) * 8);
+
+  llvm::StructType *range_t = llvm::StructType::create (context, "range");
+  std::vector<llvm::Type *> range_contents (4, scalar_t);
+  range_contents[3] = index_t;
+  range_t->setBody (range_contents);
+
+  llvm::Type *refcount_t = llvm::Type::getIntNTy (context, sizeof(int) * 8);
+
+  llvm::StructType *matrix_t = llvm::StructType::create (context, "matrix");
+  llvm::Type *matrix_contents[5];
+  matrix_contents[0] = refcount_t->getPointerTo ();
+  matrix_contents[1] = scalar_t->getPointerTo ();
+  matrix_contents[2] = index_t;
+  matrix_contents[3] = index_t->getPointerTo ();
+  matrix_contents[4] = string_t;
+  matrix_t->setBody (llvm::makeArrayRef (matrix_contents, 5));
+
+  llvm::Type *complex_t = llvm::VectorType::get (scalar_t, 2);
+
+  // complex_ret is what is passed to C functions in order to get calling
+  // convention right
+  complex_ret = llvm::StructType::create (context, "complex_ret");
+  llvm::Type *complex_ret_contents[] = {scalar_t, scalar_t};
+  complex_ret->setBody (complex_ret_contents);
+
+  // create types
+  any = new_type ("any", 0, any_t);
+  matrix = new_type ("matrix", any, matrix_t);
+  complex = new_type ("complex", any, complex_t);
+  scalar = new_type ("scalar", complex, scalar_t);
+  range = new_type ("range", any, range_t);
+  string = new_type ("string", any, string_t);
+  boolean = new_type ("bool", any, bool_t);
+  index = new_type ("index", any, index_t);
+
+  create_int (8);
+  create_int (16);
+  create_int (32);
+  create_int (64);
+
+  casts.resize (next_id + 1);
+  identities.resize (next_id + 1);
+
+  // specify calling conventions
+  // FIXME: We should detect architecture and do something sane based on that
+  // here we assume x86 or x86_64
+  matrix->mark_sret ();
+  matrix->mark_pointer_arg ();
+
+  range->mark_sret ();
+  range->mark_pointer_arg ();
+
+  complex->set_pack (jit_convention::external, &jit_typeinfo::pack_complex);
+  complex->set_unpack (jit_convention::external, &jit_typeinfo::unpack_complex);
+  complex->set_packed_type (jit_convention::external, complex_ret);
+
+  if (sizeof (void *) == 4)
+    complex->mark_sret ();
+
+  // bind global variables
+  lerror_state = new llvm::GlobalVariable (*module, bool_t, false,
+                                           llvm::GlobalValue::ExternalLinkage,
+                                           0, "error_state");
+  engine->addGlobalMapping (lerror_state,
+                            reinterpret_cast<void *> (&error_state));
+
+  // any with anything is an any op
+  jit_function fn;
+  jit_type *binary_op_type = intN (sizeof (octave_value::binary_op) * 8);
+  llvm::Type *llvm_bo_type = binary_op_type->to_llvm ();
+  jit_function any_binary = create_function (jit_convention::external,
+                                             "octave_jit_binary_any_any",
+                                             any, binary_op_type, any, any);
+  any_binary.add_mapping (engine, &octave_jit_binary_any_any);
+  any_binary.mark_can_error ();
+  binary_ops.resize (octave_value::num_binary_ops);
+  for (size_t i = 0; i < octave_value::num_binary_ops; ++i)
+    {
+      octave_value::binary_op op = static_cast<octave_value::binary_op> (i);
+      std::string op_name = octave_value::binary_op_as_string (op);
+      binary_ops[i].stash_name ("binary" + op_name);
+    }
+
+  for (int op = 0; op < octave_value::num_binary_ops; ++op)
+    {
+      llvm::Twine fn_name ("octave_jit_binary_any_any_");
+      fn_name = fn_name + llvm::Twine (op);
+
+      fn = create_function (jit_convention::internal, fn_name, any, any, any);
+      fn.mark_can_error ();
+      llvm::BasicBlock *block = fn.new_block ();
+      builder.SetInsertPoint (block);
+      llvm::APInt op_int(sizeof (octave_value::binary_op) * 8, op,
+                         std::numeric_limits<octave_value::binary_op>::is_signed);
+      llvm::Value *op_as_llvm = llvm::ConstantInt::get (llvm_bo_type, op_int);
+      llvm::Value *ret = any_binary.call (builder, op_as_llvm,
+                                          fn.argument (builder, 0),
+                                          fn.argument (builder, 1));
+      fn.do_return (builder, ret);
+      binary_ops[op].add_overload (fn);
+    }
+
+  // grab any
+  fn = create_function (jit_convention::external, "octave_jit_grab_any", any,
+                        any);
+  fn.add_mapping (engine, &octave_jit_grab_any);
+  grab_fn.add_overload (fn);
+  grab_fn.stash_name ("grab");
+
+  // grab matrix
+  fn = create_function (jit_convention::external, "octave_jit_grab_matrix",
+                        matrix, matrix);
+  fn.add_mapping (engine, &octave_jit_grab_matrix);
+  grab_fn.add_overload (fn);
+
+  // release any
+  fn = create_function (jit_convention::external, "octave_jit_release_any", 0,
+                        any);
+  fn.add_mapping (engine, &octave_jit_release_any);
+  release_fn.add_overload (fn);
+  release_fn.stash_name ("release");
+
+  // release matrix
+  fn = create_function (jit_convention::external, "octave_jit_release_matrix",
+                        0, matrix);
+  fn.add_mapping (engine, &octave_jit_release_matrix);
+  release_fn.add_overload (fn);
+
+  // release scalar
+  fn = create_identity (scalar);
+  release_fn.add_overload (fn);
+
+  // release complex
+  fn = create_identity (complex);
+  release_fn.add_overload (fn);
+
+  // release index
+  fn = create_identity (index);
+  release_fn.add_overload (fn);
+
+  // now for binary scalar operations
+  // FIXME: Finish all operations
+  add_binary_op (scalar, octave_value::op_add, llvm::Instruction::FAdd);
+  add_binary_op (scalar, octave_value::op_sub, llvm::Instruction::FSub);
+  add_binary_op (scalar, octave_value::op_mul, llvm::Instruction::FMul);
+  add_binary_op (scalar, octave_value::op_el_mul, llvm::Instruction::FMul);
+
+  add_binary_fcmp (scalar, octave_value::op_lt, llvm::CmpInst::FCMP_ULT);
+  add_binary_fcmp (scalar, octave_value::op_le, llvm::CmpInst::FCMP_ULE);
+  add_binary_fcmp (scalar, octave_value::op_eq, llvm::CmpInst::FCMP_UEQ);
+  add_binary_fcmp (scalar, octave_value::op_ge, llvm::CmpInst::FCMP_UGE);
+  add_binary_fcmp (scalar, octave_value::op_gt, llvm::CmpInst::FCMP_UGT);
+  add_binary_fcmp (scalar, octave_value::op_ne, llvm::CmpInst::FCMP_UNE);
+
+  jit_function gripe_div0 = create_function (jit_convention::external,
+                                             "gripe_divide_by_zero", 0);
+  gripe_div0.add_mapping (engine, &gripe_divide_by_zero);
+  gripe_div0.mark_can_error ();
+
+  // divide is annoying because it might error
+  fn = create_function (jit_convention::internal,
+                        "octave_jit_div_scalar_scalar", scalar, scalar, scalar);
+  fn.mark_can_error ();
+
+  llvm::BasicBlock *body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::BasicBlock *warn_block = fn.new_block ("warn");
+    llvm::BasicBlock *normal_block = fn.new_block ("normal");
+
+    llvm::Value *zero = llvm::ConstantFP::get (scalar_t, 0);
+    llvm::Value *check = builder.CreateFCmpUEQ (zero, fn.argument (builder, 0));
+    builder.CreateCondBr (check, warn_block, normal_block);
+
+    builder.SetInsertPoint (warn_block);
+    gripe_div0.call (builder);
+    builder.CreateBr (normal_block);
+
+    builder.SetInsertPoint (normal_block);
+    llvm::Value *ret = builder.CreateFDiv (fn.argument (builder, 0),
+                                           fn.argument (builder, 1));
+    fn.do_return (builder, ret);
+  }
+  binary_ops[octave_value::op_div].add_overload (fn);
+  binary_ops[octave_value::op_el_div].add_overload (fn);
+
+  // ldiv is the same as div with the operators reversed
+  fn = mirror_binary (fn);
+  binary_ops[octave_value::op_ldiv].add_overload (fn);
+  binary_ops[octave_value::op_el_ldiv].add_overload (fn);
+
+  // In general, the result of scalar ^ scalar is a complex number. We might be
+  // able to improve on this if we keep track of the range of values varaibles
+  // can take on.
+  fn = create_function (jit_convention::external,
+                        "octave_jit_pow_scalar_scalar", complex, scalar,
+                        scalar);
+  fn.add_mapping (engine, &octave_jit_pow_scalar_scalar);
+  binary_ops[octave_value::op_pow].add_overload (fn);
+  binary_ops[octave_value::op_el_pow].add_overload (fn);
+
+  // now for binary complex operations
+  add_binary_op (complex, octave_value::op_add, llvm::Instruction::FAdd);
+  add_binary_op (complex, octave_value::op_sub, llvm::Instruction::FSub);
+
+  fn = create_function (jit_convention::internal,
+                        "octave_jit_*_complex_complex", complex, complex,
+                        complex);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    // (x0*x1 - y0*y1, x0*y1 + y0*x1) = (x0,y0) * (x1,y1)
+    // We compute this in one vectorized multiplication, a subtraction, and an
+    // addition.
+    llvm::Value *lhs = fn.argument (builder, 0);
+    llvm::Value *rhs = fn.argument (builder, 1);
+
+    // FIXME: We need a better way of doing this, working with llvm's IR
+    // directly is sort of a pain.
+    llvm::Value *zero = builder.getInt32 (0);
+    llvm::Value *one = builder.getInt32 (1);
+    llvm::Value *two = builder.getInt32 (2);
+    llvm::Value *three = builder.getInt32 (3);
+
+    llvm::Type *vec4 = llvm::VectorType::get (scalar_t, 4);
+    llvm::Value *mlhs = llvm::UndefValue::get (vec4);
+    llvm::Value *mrhs = mlhs;
+
+    llvm::Value *temp = complex_real (lhs);
+    mlhs = builder.CreateInsertElement (mlhs, temp, zero);
+    mlhs = builder.CreateInsertElement (mlhs, temp, two);
+    temp = complex_imag (lhs);
+    mlhs = builder.CreateInsertElement (mlhs, temp, one);
+    mlhs = builder.CreateInsertElement (mlhs, temp, three);
+
+    temp = complex_real (rhs);
+    mrhs = builder.CreateInsertElement (mrhs, temp, zero);
+    mrhs = builder.CreateInsertElement (mrhs, temp, three);
+    temp = complex_imag (rhs);
+    mrhs = builder.CreateInsertElement (mrhs, temp, one);
+    mrhs = builder.CreateInsertElement (mrhs, temp, two);
+
+    llvm::Value *mres = builder.CreateFMul (mlhs, mrhs);
+    llvm::Value *tlhs = builder.CreateExtractElement (mres, zero);
+    llvm::Value *trhs = builder.CreateExtractElement (mres, one);
+    llvm::Value *ret_real = builder.CreateFSub (tlhs, trhs);
+
+    tlhs = builder.CreateExtractElement (mres, two);
+    trhs = builder.CreateExtractElement (mres, three);
+    llvm::Value *ret_imag = builder.CreateFAdd (tlhs, trhs);
+    fn.do_return (builder, complex_new (ret_real, ret_imag));
+  }
+
+  binary_ops[octave_value::op_mul].add_overload (fn);
+  binary_ops[octave_value::op_el_mul].add_overload (fn);
+
+  jit_function complex_div = create_function (jit_convention::external,
+                                              "octave_jit_complex_div",
+                                              complex, complex, complex);
+  complex_div.add_mapping (engine, &octave_jit_complex_div);
+  complex_div.mark_can_error ();
+  binary_ops[octave_value::op_div].add_overload (fn);
+  binary_ops[octave_value::op_ldiv].add_overload (fn);
+
+  fn = mirror_binary (complex_div);
+  binary_ops[octave_value::op_ldiv].add_overload (fn);
+  binary_ops[octave_value::op_el_ldiv].add_overload (fn);
+
+  fn = create_function (jit_convention::external,
+                        "octave_jit_pow_complex_complex", complex, complex,
+                        complex);
+  fn.add_mapping (engine, &octave_jit_pow_complex_complex);
+  binary_ops[octave_value::op_pow].add_overload (fn);
+  binary_ops[octave_value::op_el_pow].add_overload (fn);
+
+  fn = create_function (jit_convention::internal,
+                        "octave_jit_*_scalar_complex", complex, scalar,
+                        complex);
+  jit_function mul_scalar_complex = fn;
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *lhs = fn.argument (builder, 0);
+    llvm::Value *tlhs = complex_new (lhs, lhs);
+    llvm::Value *rhs = fn.argument (builder, 1);
+    fn.do_return (builder, builder.CreateFMul (tlhs, rhs));
+  }
+  binary_ops[octave_value::op_mul].add_overload (fn);
+  binary_ops[octave_value::op_el_mul].add_overload (fn);
+
+
+  fn = mirror_binary (mul_scalar_complex);
+  binary_ops[octave_value::op_mul].add_overload (fn);
+  binary_ops[octave_value::op_el_mul].add_overload (fn);
+
+  fn = create_function (jit_convention::internal, "octave_jit_+_scalar_complex",
+                        complex, scalar, complex);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *lhs = fn.argument (builder, 0);
+    llvm::Value *rhs = fn.argument (builder, 1);
+    llvm::Value *real = builder.CreateFAdd (lhs, complex_real (rhs));
+    fn.do_return (builder, complex_real (rhs, real));
+  }
+  binary_ops[octave_value::op_add].add_overload (fn);
+
+  fn = mirror_binary (fn);
+  binary_ops[octave_value::op_add].add_overload (fn);
+
+  fn = create_function (jit_convention::internal, "octave_jit_-_complex_scalar",
+                        complex, complex, scalar);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *lhs = fn.argument (builder, 0);
+    llvm::Value *rhs = fn.argument (builder, 1);
+    llvm::Value *real = builder.CreateFSub (complex_real (lhs), rhs);
+    fn.do_return (builder, complex_real (lhs, real));
+  }
+  binary_ops[octave_value::op_sub].add_overload (fn);
+
+  fn = create_function (jit_convention::internal, "octave_jit_-_scalar_complex",
+                        complex, scalar, complex);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *lhs = fn.argument (builder, 0);
+    llvm::Value *rhs = fn.argument (builder, 1);
+    llvm::Value *real = builder.CreateFSub (lhs, complex_real (rhs));
+    fn.do_return (builder, complex_real (rhs, real));
+  }
+  binary_ops[octave_value::op_sub].add_overload (fn);
+
+  fn = create_function (jit_convention::external,
+                        "octave_jit_pow_scalar_complex", complex, scalar,
+                        complex);
+  fn.add_mapping (engine, &octave_jit_pow_scalar_complex);
+  binary_ops[octave_value::op_pow].add_overload (fn);
+  binary_ops[octave_value::op_el_pow].add_overload (fn);
+
+  fn = create_function (jit_convention::external,
+                        "octave_jit_pow_complex_scalar", complex, complex,
+                        scalar);
+  fn.add_mapping (engine, &octave_jit_pow_complex_scalar);
+  binary_ops[octave_value::op_pow].add_overload (fn);
+  binary_ops[octave_value::op_el_pow].add_overload (fn);
+
+  // now for binary index operators
+  add_binary_op (index, octave_value::op_add, llvm::Instruction::Add);
+
+  // and binary bool operators
+  add_binary_op (boolean, octave_value::op_el_or, llvm::Instruction::Or);
+  add_binary_op (boolean, octave_value::op_el_and, llvm::Instruction::And);
+
+  // now for printing functions
+  print_fn.stash_name ("print");
+  add_print (any, reinterpret_cast<void *> (&octave_jit_print_any));
+  add_print (scalar, reinterpret_cast<void *> (&octave_jit_print_scalar));
+
+  // initialize for loop
+  for_init_fn.stash_name ("for_init");
+
+  fn = create_function (jit_convention::internal, "octave_jit_for_range_init",
+                        index, range);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *zero = llvm::ConstantInt::get (index_t, 0);
+    fn.do_return (builder, zero);
+  }
+  for_init_fn.add_overload (fn);
+
+  // bounds check for for loop
+  for_check_fn.stash_name ("for_check");
+
+  fn = create_function (jit_convention::internal, "octave_jit_for_range_check",
+                        boolean, range, index);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *nelem
+      = builder.CreateExtractValue (fn.argument (builder, 0), 3);
+    llvm::Value *idx = fn.argument (builder, 1);
+    llvm::Value *ret = builder.CreateICmpULT (idx, nelem);
+    fn.do_return (builder, ret);
+  }
+  for_check_fn.add_overload (fn);
+
+  // index variabe for for loop
+  for_index_fn.stash_name ("for_index");
+
+  fn = create_function (jit_convention::internal, "octave_jit_for_range_idx",
+                        scalar, range, index);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *idx = fn.argument (builder, 1);
+    llvm::Value *didx = builder.CreateSIToFP (idx, scalar_t);
+    llvm::Value *rng = fn.argument (builder, 0);
+    llvm::Value *base = builder.CreateExtractValue (rng, 0);
+    llvm::Value *inc = builder.CreateExtractValue (rng, 2);
+
+    llvm::Value *ret = builder.CreateFMul (didx, inc);
+    ret = builder.CreateFAdd (base, ret);
+    fn.do_return (builder, ret);
+  }
+  for_index_fn.add_overload (fn);
+
+  // logically true
+  logically_true_fn.stash_name ("logically_true");
+
+  jit_function gripe_nantl
+    = create_function (jit_convention::external,
+                       "octave_jit_gripe_nan_to_logical_conversion", 0);
+  gripe_nantl.add_mapping (engine, &octave_jit_gripe_nan_to_logical_conversion);
+  gripe_nantl.mark_can_error ();
+
+  fn = create_function (jit_convention::internal,
+                        "octave_jit_logically_true_scalar", boolean, scalar);
+  fn.mark_can_error ();
+
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::BasicBlock *error_block = fn.new_block ("error");
+    llvm::BasicBlock *normal_block = fn.new_block ("normal");
+
+    llvm::Value *check = builder.CreateFCmpUNE (fn.argument (builder, 0),
+                                                fn.argument (builder, 0));
+    builder.CreateCondBr (check, error_block, normal_block);
+
+    builder.SetInsertPoint (error_block);
+    gripe_nantl.call (builder);
+    builder.CreateBr (normal_block);
+    builder.SetInsertPoint (normal_block);
+
+    llvm::Value *zero = llvm::ConstantFP::get (scalar_t, 0);
+    llvm::Value *ret = builder.CreateFCmpONE (fn.argument (builder, 0), zero);
+    fn.do_return (builder, ret);
+  }
+  logically_true_fn.add_overload (fn);
+
+  // logically_true boolean
+  fn = create_identity (boolean);
+  logically_true_fn.add_overload (fn);
+
+  // make_range
+  // FIXME: May be benificial to implement all in LLVM
+  make_range_fn.stash_name ("make_range");
+  jit_function compute_nelem
+    = create_function (jit_convention::external, "octave_jit_compute_nelem",
+                       index, scalar, scalar, scalar);
+  compute_nelem.add_mapping (engine, &octave_jit_compute_nelem);
+
+  fn = create_function (jit_convention::internal, "octave_jit_make_range",
+                        range, scalar, scalar, scalar);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *base = fn.argument (builder, 0);
+    llvm::Value *limit = fn.argument (builder, 1);
+    llvm::Value *inc = fn.argument (builder, 2);
+    llvm::Value *nelem = compute_nelem.call (builder, base, limit, inc);
+
+    llvm::Value *dzero = llvm::ConstantFP::get (scalar_t, 0);
+    llvm::Value *izero = llvm::ConstantInt::get (index_t, 0);
+    llvm::Value *rng = llvm::ConstantStruct::get (range_t, dzero, dzero, dzero,
+                                                  izero, NULL);
+    rng = builder.CreateInsertValue (rng, base, 0);
+    rng = builder.CreateInsertValue (rng, limit, 1);
+    rng = builder.CreateInsertValue (rng, inc, 2);
+    rng = builder.CreateInsertValue (rng, nelem, 3);
+    fn.do_return (builder, rng);
+  }
+  make_range_fn.add_overload (fn);
+
+  // paren_subsref
+  jit_type *jit_int = intN (sizeof (int) * 8);
+  llvm::Type *int_t = jit_int->to_llvm ();
+  jit_function ginvalid_index
+    = create_function (jit_convention::external, "octave_jit_ginvalid_index",
+                       0);
+  ginvalid_index.add_mapping (engine, &octave_jit_ginvalid_index);
+  jit_function gindex_range = create_function (jit_convention::external,
+                                               "octave_jit_gindex_range",
+                                               0, jit_int, jit_int, index,
+                                               index);
+  gindex_range.add_mapping (engine, &octave_jit_gindex_range);
+
+  fn = create_function (jit_convention::internal, "()subsref", scalar, matrix,
+                        scalar);
+  fn.mark_can_error ();
+
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *one = llvm::ConstantInt::get (index_t, 1);
+    llvm::Value *ione;
+    if (index_t == int_t)
+      ione = one;
+    else
+      ione = llvm::ConstantInt::get (int_t, 1);
+
+    llvm::Value *undef = llvm::UndefValue::get (scalar_t);
+    llvm::Value *mat = fn.argument (builder, 0);
+    llvm::Value *idx = fn.argument (builder, 1);
+
+    // convert index to scalar to integer, and check index >= 1
+    llvm::Value *int_idx = builder.CreateFPToSI (idx, index_t);
+    llvm::Value *check_idx = builder.CreateSIToFP (int_idx, scalar_t);
+    llvm::Value *cond0 = builder.CreateFCmpUNE (idx, check_idx);
+    llvm::Value *cond1 = builder.CreateICmpSLT (int_idx, one);
+    llvm::Value *cond = builder.CreateOr (cond0, cond1);
+
+    llvm::BasicBlock *done = fn.new_block ("done");
+    llvm::BasicBlock *conv_error = fn.new_block ("conv_error", done);
+    llvm::BasicBlock *normal = fn.new_block ("normal", done);
+    builder.CreateCondBr (cond, conv_error, normal);
+
+    builder.SetInsertPoint (conv_error);
+    ginvalid_index.call (builder);
+    builder.CreateBr (done);
+
+    builder.SetInsertPoint (normal);
+    llvm::Value *len = builder.CreateExtractValue (mat,
+                                                   llvm::ArrayRef<unsigned> (2));
+    cond = builder.CreateICmpSGT (int_idx, len);
+
+
+    llvm::BasicBlock *bounds_error = fn.new_block ("bounds_error", done);
+    llvm::BasicBlock *success = fn.new_block ("success", done);
+    builder.CreateCondBr (cond, bounds_error, success);
+
+    builder.SetInsertPoint (bounds_error);
+    gindex_range.call (builder, ione, ione, int_idx, len);
+    builder.CreateBr (done);
+
+    builder.SetInsertPoint (success);
+    llvm::Value *data = builder.CreateExtractValue (mat,
+                                                    llvm::ArrayRef<unsigned> (1));
+    llvm::Value *gep = builder.CreateInBoundsGEP (data, int_idx);
+    llvm::Value *ret = builder.CreateLoad (gep);
+    builder.CreateBr (done);
+
+    builder.SetInsertPoint (done);
+
+    llvm::PHINode *merge = llvm::PHINode::Create (scalar_t, 3);
+    builder.Insert (merge);
+    merge->addIncoming (undef, conv_error);
+    merge->addIncoming (undef, bounds_error);
+    merge->addIncoming (ret, success);
+    fn.do_return (builder, merge);
+  }
+  paren_subsref_fn.add_overload (fn);
+
+  // paren subsasgn
+  paren_subsasgn_fn.stash_name ("()subsasgn");
+
+  jit_function resize_paren_subsasgn
+    = create_function (jit_convention::external,
+                       "octave_jit_paren_subsasgn_impl", matrix, matrix, index,
+                       scalar);
+  resize_paren_subsasgn.add_mapping (engine, &octave_jit_paren_subsasgn_impl);
+  fn = create_function (jit_convention::internal, "octave_jit_paren_subsasgn",
+                        matrix, matrix, scalar, scalar);
+  fn.mark_can_error ();
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *one = llvm::ConstantInt::get (index_t, 1);
+
+    llvm::Value *mat = fn.argument (builder, 0);
+    llvm::Value *idx = fn.argument (builder, 1);
+    llvm::Value *value = fn.argument (builder, 2);
+
+    llvm::Value *int_idx = builder.CreateFPToSI (idx, index_t);
+    llvm::Value *check_idx = builder.CreateSIToFP (int_idx, scalar_t);
+    llvm::Value *cond0 = builder.CreateFCmpUNE (idx, check_idx);
+    llvm::Value *cond1 = builder.CreateICmpSLT (int_idx, one);
+    llvm::Value *cond = builder.CreateOr (cond0, cond1);
+
+    llvm::BasicBlock *done = fn.new_block ("done");
+
+    llvm::BasicBlock *conv_error = fn.new_block ("conv_error", done);
+    llvm::BasicBlock *normal = fn.new_block ("normal", done);
+    builder.CreateCondBr (cond, conv_error, normal);
+    builder.SetInsertPoint (conv_error);
+    ginvalid_index.call (builder);
+    builder.CreateBr (done);
+
+    builder.SetInsertPoint (normal);
+    llvm::Value *len = builder.CreateExtractValue (mat,
+                                                   llvm::ArrayRef<unsigned> (2));
+    cond0 = builder.CreateICmpSGT (int_idx, len);
+
+    llvm::Value *rcount = builder.CreateExtractValue (mat, 0);
+    rcount = builder.CreateLoad (rcount);
+    cond1 = builder.CreateICmpSGT (rcount, one);
+    cond = builder.CreateOr (cond0, cond1);
+
+    llvm::BasicBlock *bounds_error = fn.new_block ("bounds_error", done);
+    llvm::BasicBlock *success = fn.new_block ("success", done);
+    builder.CreateCondBr (cond, bounds_error, success);
+
+    // resize on out of bounds access
+    builder.SetInsertPoint (bounds_error);
+    llvm::Value *resize_result = resize_paren_subsasgn.call (builder, mat,
+                                                             int_idx, value);
+    builder.CreateBr (done);
+
+    builder.SetInsertPoint (success);
+    llvm::Value *data = builder.CreateExtractValue (mat,
+                                                    llvm::ArrayRef<unsigned> (1));
+    llvm::Value *gep = builder.CreateInBoundsGEP (data, int_idx);
+    builder.CreateStore (value, gep);
+    builder.CreateBr (done);
+
+    builder.SetInsertPoint (done);
+
+    llvm::PHINode *merge = llvm::PHINode::Create (matrix_t, 3);
+    builder.Insert (merge);
+    merge->addIncoming (mat, conv_error);
+    merge->addIncoming (resize_result, bounds_error);
+    merge->addIncoming (mat, success);
+    fn.do_return (builder, merge);
+  }
+  paren_subsasgn_fn.add_overload (fn);
+
+  fn = create_function (jit_convention::external,
+                        "octave_jit_paren_subsasgn_matrix_range", matrix,
+                        matrix, range, scalar);
+  fn.add_mapping (engine, &octave_jit_paren_subsasgn_matrix_range);
+  fn.mark_can_error ();
+  paren_subsasgn_fn.add_overload (fn);
+
+  casts[any->type_id ()].stash_name ("(any)");
+  casts[scalar->type_id ()].stash_name ("(scalar)");
+  casts[complex->type_id ()].stash_name ("(complex)");
+  casts[matrix->type_id ()].stash_name ("(matrix)");
+  casts[any->type_id ()].stash_name ("(range)");
+
+  // cast any <- matrix
+  fn = create_function (jit_convention::external, "octave_jit_cast_any_matrix",
+                        any, matrix);
+  fn.add_mapping (engine, &octave_jit_cast_any_matrix);
+  casts[any->type_id ()].add_overload (fn);
+
+  // cast matrix <- any
+  fn = create_function (jit_convention::external, "octave_jit_cast_matrix_any",
+                        matrix, any);
+  fn.add_mapping (engine, &octave_jit_cast_matrix_any);
+  casts[matrix->type_id ()].add_overload (fn);
+
+  // cast any <- range
+  fn = create_function (jit_convention::external, "octave_jit_cast_any_range",
+                        any, range);
+  fn.add_mapping (engine, &octave_jit_cast_any_range);
+  casts[any->type_id ()].add_overload (fn);
+
+  // cast range <- any
+  fn = create_function (jit_convention::external, "octave_jit_cast_range_any",
+                        range, any);
+  fn.add_mapping (engine, &octave_jit_cast_range_any);
+  casts[range->type_id ()].add_overload (fn);
+
+  // cast any <- scalar
+  fn = create_function (jit_convention::external, "octave_jit_cast_any_scalar",
+                        any, scalar);
+  fn.add_mapping (engine, &octave_jit_cast_any_scalar);
+  casts[any->type_id ()].add_overload (fn);
+
+  // cast scalar <- any
+  fn = create_function (jit_convention::external, "octave_jit_cast_scalar_any",
+                        scalar, any);
+  fn.add_mapping (engine, &octave_jit_cast_scalar_any);
+  casts[scalar->type_id ()].add_overload (fn);
+
+  // cast any <- complex
+  fn = create_function (jit_convention::external, "octave_jit_cast_any_complex",
+                        any, complex);
+  fn.add_mapping (engine, &octave_jit_cast_any_complex);
+  casts[any->type_id ()].add_overload (fn);
+
+  // cast complex <- any
+  fn = create_function (jit_convention::external, "octave_jit_cast_complex_any",
+                        complex, any);
+  fn.add_mapping (engine, &octave_jit_cast_complex_any);
+  casts[complex->type_id ()].add_overload (fn);
+
+  // cast complex <- scalar
+  fn = create_function (jit_convention::internal,
+                        "octave_jit_cast_complex_scalar", complex, scalar);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  {
+    llvm::Value *zero = llvm::ConstantFP::get (scalar_t, 0);
+    fn.do_return (builder, complex_new (fn.argument (builder, 0), zero));
+  }
+  casts[complex->type_id ()].add_overload (fn);
+
+  // cast scalar <- complex
+  fn = create_function (jit_convention::internal,
+                        "octave_jit_cast_scalar_complex", scalar, complex);
+  body = fn.new_block ();
+  builder.SetInsertPoint (body);
+  fn.do_return (builder, complex_real (fn.argument (builder, 0)));
+  casts[scalar->type_id ()].add_overload (fn);
+
+  // cast any <- any
+  fn = create_identity (any);
+  casts[any->type_id ()].add_overload (fn);
+
+  // cast scalar <- scalar
+  fn = create_identity (scalar);
+  casts[scalar->type_id ()].add_overload (fn);
+
+  // cast complex <- complex
+  fn = create_identity (complex);
+  casts[complex->type_id ()].add_overload (fn);
+
+  // -------------------- builtin functions --------------------
+  add_builtin ("#unknown_function");
+  unknown_function = builtins["#unknown_function"];
+
+  add_builtin ("sin");
+  register_intrinsic ("sin", llvm::Intrinsic::sin, scalar, scalar);
+  register_generic ("sin", matrix, matrix);
+
+  add_builtin ("cos");
+  register_intrinsic ("cos", llvm::Intrinsic::cos, scalar, scalar);
+  register_generic ("cos", matrix, matrix);
+
+  add_builtin ("exp");
+  register_intrinsic ("exp", llvm::Intrinsic::cos, scalar, scalar);
+  register_generic ("exp", matrix, matrix);
+
+  casts.resize (next_id + 1);
+  jit_function any_id = create_identity (any);
+  jit_function release_any = get_release (any);
+  std::vector<jit_type *> args;
+  args.resize (1);
+
+  for (std::map<std::string, jit_type *>::iterator iter = builtins.begin ();
+       iter != builtins.end (); ++iter)
+    {
+      jit_type *btype = iter->second;
+      args[0] = btype;
+
+      release_fn.add_overload (jit_function (release_any, 0, args));
+      casts[any->type_id ()].add_overload (jit_function (any_id, any, args));
+
+      args[0] = any;
+      casts[btype->type_id ()].add_overload (jit_function (any_id, btype,
+                                                           args));
+    }
+}
+
+void
+jit_typeinfo::add_print (jit_type *ty, void *fptr)
+{
+  std::stringstream name;
+  name << "octave_jit_print_" << ty->name ();
+  jit_function fn = create_function (jit_convention::external, name.str (), 0,
+                                     intN (8), ty);
+  fn.add_mapping (engine, fptr);
+  print_fn.add_overload (fn);
+}
+
+// FIXME: cp between add_binary_op, add_binary_icmp, and add_binary_fcmp
+void
+jit_typeinfo::add_binary_op (jit_type *ty, int op, int llvm_op)
+{
+  std::stringstream fname;
+  octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
+  fname << "octave_jit_" << octave_value::binary_op_as_string (ov_op)
+        << "_" << ty->name ();
+
+  jit_function fn = create_function (jit_convention::internal, fname.str (),
+                                        ty, ty, ty);
+  llvm::BasicBlock *block = fn.new_block ();
+  builder.SetInsertPoint (block);
+  llvm::Instruction::BinaryOps temp
+    = static_cast<llvm::Instruction::BinaryOps>(llvm_op);
+
+  llvm::Value *ret = builder.CreateBinOp (temp, fn.argument (builder, 0),
+                                          fn.argument (builder, 1));
+  fn.do_return (builder, ret);
+  binary_ops[op].add_overload (fn);
+}
+
+void
+jit_typeinfo::add_binary_icmp (jit_type *ty, int op, int llvm_op)
+{
+  std::stringstream fname;
+  octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
+  fname << "octave_jit" << octave_value::binary_op_as_string (ov_op)
+        << "_" << ty->name ();
+
+  jit_function fn = create_function (jit_convention::internal, fname.str (),
+                                     boolean, ty, ty);
+  llvm::BasicBlock *block = fn.new_block ();
+  builder.SetInsertPoint (block);
+  llvm::CmpInst::Predicate temp
+    = static_cast<llvm::CmpInst::Predicate>(llvm_op);
+  llvm::Value *ret = builder.CreateICmp (temp, fn.argument (builder, 0),
+                                         fn.argument (builder, 1));
+  fn.do_return (builder, ret);
+  binary_ops[op].add_overload (fn);
+}
+
+void
+jit_typeinfo::add_binary_fcmp (jit_type *ty, int op, int llvm_op)
+{
+  std::stringstream fname;
+  octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
+  fname << "octave_jit" << octave_value::binary_op_as_string (ov_op)
+        << "_" << ty->name ();
+
+  jit_function fn = create_function (jit_convention::internal, fname.str (),
+                                     boolean, ty, ty);
+  llvm::BasicBlock *block = fn.new_block ();
+  builder.SetInsertPoint (block);
+  llvm::CmpInst::Predicate temp
+    = static_cast<llvm::CmpInst::Predicate>(llvm_op);
+  llvm::Value *ret = builder.CreateFCmp (temp, fn.argument (builder, 0),
+                                         fn.argument (builder, 1));
+  fn.do_return (builder, ret);
+  binary_ops[op].add_overload (fn);
+}
+
+jit_function
+jit_typeinfo::create_function (jit_convention::type cc, const llvm::Twine& name,
+                               jit_type *ret,
+                               const std::vector<jit_type *>& args)
+{
+  jit_function result (module, cc, name, ret, args);
+  return result;
+}
+
+jit_function
+jit_typeinfo::create_identity (jit_type *type)
+{
+  size_t id = type->type_id ();
+  if (id >= identities.size ())
+    identities.resize (id + 1);
+
+  if (! identities[id].valid ())
+    {
+      jit_function fn = create_function (jit_convention::internal, "id", type,
+                                         type);
+      llvm::BasicBlock *body = fn.new_block ();
+      builder.SetInsertPoint (body);
+      fn.do_return (builder, fn.argument (builder, 0));
+      return identities[id] = fn;
+    }
+
+  return identities[id];
+}
+
+llvm::Value *
+jit_typeinfo::do_insert_error_check (llvm::IRBuilderD& abuilder)
+{
+  return abuilder.CreateLoad (lerror_state);
+}
+
+void
+jit_typeinfo::add_builtin (const std::string& name)
+{
+  jit_type *btype = new_type (name, any, any->to_llvm ());
+  builtins[name] = btype;
+
+  octave_builtin *ov_builtin = find_builtin (name);
+  if (ov_builtin)
+    ov_builtin->stash_jit (*btype);
+}
+
+void
+jit_typeinfo::register_intrinsic (const std::string& name, size_t iid,
+                                  jit_type *result,
+                                  const std::vector<jit_type *>& args)
+{
+  jit_type *builtin_type = builtins[name];
+  size_t nargs = args.size ();
+  llvm::SmallVector<llvm::Type *, 5> llvm_args (nargs);
+  for (size_t i = 0; i < nargs; ++i)
+    llvm_args[i] = args[i]->to_llvm ();
+
+  llvm::Intrinsic::ID id = static_cast<llvm::Intrinsic::ID> (iid);
+  llvm::Function *ifun = llvm::Intrinsic::getDeclaration (module, id,
+                                                          llvm_args);
+  std::stringstream fn_name;
+  fn_name << "octave_jit_" << name;
+
+  std::vector<jit_type *> args1 (nargs + 1);
+  args1[0] = builtin_type;
+  std::copy (args.begin (), args.end (), args1.begin () + 1);
+
+  // The first argument will be the Octave function, but we already know that
+  // the function call is the equivalent of the intrinsic, so we ignore it and
+  // call the intrinsic with the remaining arguments.
+  jit_function fn = create_function (jit_convention::internal, fn_name.str (),
+                                     result, args1);
+  llvm::BasicBlock *body = fn.new_block ();
+  builder.SetInsertPoint (body);
+
+  llvm::SmallVector<llvm::Value *, 5> fargs (nargs);
+  for (size_t i = 0; i < nargs; ++i)
+    fargs[i] = fn.argument (builder, i + 1);
+
+  llvm::Value *ret = builder.CreateCall (ifun, fargs);
+  fn.do_return (builder, ret);
+  paren_subsref_fn.add_overload (fn);
+}
+
+octave_builtin *
+jit_typeinfo::find_builtin (const std::string& name)
+{
+  // FIXME: Finalize what we want to store in octave_builtin, then add functions
+  // to access these values in octave_value
+  octave_value ov_builtin = symbol_table::find (name);
+  return dynamic_cast<octave_builtin *> (ov_builtin.internal_rep ());
+}
+
+void
+jit_typeinfo::register_generic (const std::string&, jit_type *,
+                                const std::vector<jit_type *>&)
+{
+  // FIXME: Implement
+}
+
+jit_function
+jit_typeinfo::mirror_binary (const jit_function& fn)
+{
+  jit_function ret = create_function (jit_convention::internal,
+                                      fn.name () + "_reverse",
+                                      fn.result (), fn.argument_type (1),
+                                      fn.argument_type (0));
+  if (fn.can_error ())
+    ret.mark_can_error ();
+
+  llvm::BasicBlock *body = ret.new_block ();
+  builder.SetInsertPoint (body);
+  llvm::Value *result = fn.call (builder, ret.argument (builder, 1),
+                                 ret.argument (builder, 0));
+  if (ret.result ())
+    ret.do_return (builder, result);
+  else
+    ret.do_return (builder);
+
+  return ret;
+}
+
+llvm::Value *
+jit_typeinfo::pack_complex (llvm::IRBuilderD& bld, llvm::Value *cplx)
+{
+  llvm::Type *complex_ret = instance->complex_ret;
+  llvm::Value *real = bld.CreateExtractElement (cplx, bld.getInt32 (0));
+  llvm::Value *imag = bld.CreateExtractElement (cplx, bld.getInt32 (1));
+  llvm::Value *ret = llvm::UndefValue::get (complex_ret);
+  ret = bld.CreateInsertValue (ret, real, 0);
+  return bld.CreateInsertValue (ret, imag, 1);
+}
+
+llvm::Value *
+jit_typeinfo::unpack_complex (llvm::IRBuilderD& bld, llvm::Value *result)
+{
+  llvm::Type *complex_t = get_complex ()->to_llvm ();
+  llvm::Value *real = bld.CreateExtractValue (result, 0);
+  llvm::Value *imag = bld.CreateExtractValue (result, 1);
+  llvm::Value *ret = llvm::UndefValue::get (complex_t);
+  ret = bld.CreateInsertElement (ret, real, bld.getInt32 (0));
+  return bld.CreateInsertElement (ret, imag, bld.getInt32 (1));
+}
+
+llvm::Value *
+jit_typeinfo::complex_real (llvm::Value *cx)
+{
+  return builder.CreateExtractElement (cx, builder.getInt32 (0));
+}
+
+llvm::Value *
+jit_typeinfo::complex_real (llvm::Value *cx, llvm::Value *real)
+{
+  return builder.CreateInsertElement (cx, real, builder.getInt32 (0));
+}
+
+llvm::Value *
+jit_typeinfo::complex_imag (llvm::Value *cx)
+{
+  return builder.CreateExtractElement (cx, builder.getInt32 (1));
+}
+
+llvm::Value *
+jit_typeinfo::complex_imag (llvm::Value *cx, llvm::Value *imag)
+{
+  return builder.CreateInsertElement (cx, imag, builder.getInt32 (1));
+}
+
+llvm::Value *
+jit_typeinfo::complex_new (llvm::Value *real, llvm::Value *imag)
+{
+  llvm::Value *ret = llvm::UndefValue::get (complex->to_llvm ());
+  ret = complex_real (ret, real);
+  return complex_imag (ret, imag);
+}
+
+void
+jit_typeinfo::create_int (size_t nbits)
+{
+  std::stringstream tname;
+  tname << "int" << nbits;
+  ints[nbits] = new_type (tname.str (), any, llvm::Type::getIntNTy (context,
+                                                                    nbits));
+}
+
+jit_type *
+jit_typeinfo::intN (size_t nbits) const
+{
+  std::map<size_t, jit_type *>::const_iterator iter = ints.find (nbits);
+  if (iter != ints.end ())
+    return iter->second;
+
+  throw jit_fail_exception ("No such integer type");
+}
+
+jit_type *
+jit_typeinfo::do_type_of (const octave_value &ov) const
+{
+  if (ov.is_function ())
+    {
+      // FIXME: This is ugly, we need to finalize how we want to to this, then
+      // have octave_value fully support the needed functionality
+      octave_builtin *builtin
+        = dynamic_cast<octave_builtin *> (ov.internal_rep ());
+      return builtin && builtin->to_jit () ? builtin->to_jit ()
+        : unknown_function;
+    }
+
+  if (ov.is_range ())
+    return get_range ();
+
+  if (ov.is_double_type ())
+    {
+      if (ov.is_real_scalar ())
+        return get_scalar ();
+
+      if (ov.is_matrix_type ())
+        return get_matrix ();
+    }
+
+  if (ov.is_complex_scalar ())
+    return get_complex ();
+
+  return get_any ();
+}
+
+jit_type*
+jit_typeinfo::new_type (const std::string& name, jit_type *parent,
+                        llvm::Type *llvm_type)
+{
+  jit_type *ret = new jit_type (name, parent, llvm_type, next_id++);
+  id_to_type.push_back (ret);
+  return ret;
+}
+
+#endif
diff --git a/src/jit-typeinfo.h b/src/jit-typeinfo.h
new file mode 100644
--- /dev/null
+++ b/src/jit-typeinfo.h
@@ -0,0 +1,669 @@
+/*
+
+Copyright (C) 2012 Max Brister <max@2bass.com>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_jit_typeinfo_h)
+#define octave_jit_typeinfo_h 1
+
+#ifdef HAVE_LLVM
+
+#include <map>
+#include <vector>
+
+#include "Range.h"
+#include "jit-util.h"
+
+// Defines the type system used by jit and a singleton class, jit_typeinfo, to
+// manage the types.
+//
+// FIXME:
+// Operations are defined and implemented in jit_typeinfo. Eventually they
+// should be moved elsewhere. (just like with octave_typeinfo)
+
+// jit_range is compatable with the llvm range structure
+struct
+jit_range
+{
+  jit_range (const Range& from) : base (from.base ()), limit (from.limit ()),
+                                  inc (from.inc ()), nelem (from.nelem ())
+  {}
+
+  operator Range () const
+  {
+    return Range (base, limit, inc);
+  }
+
+  bool all_elements_are_ints () const;
+
+  double base;
+  double limit;
+  double inc;
+  octave_idx_type nelem;
+};
+
+std::ostream& operator<< (std::ostream& os, const jit_range& rng);
+
+// jit_array is compatable with the llvm array/matrix structures
+template <typename T, typename U>
+struct
+jit_array
+{
+  jit_array (T& from) : array (new T (from))
+  {
+    update ();
+  }
+
+  void update (void)
+  {
+    ref_count = array->jit_ref_count ();
+    slice_data = array->jit_slice_data () - 1;
+    slice_len = array->capacity ();
+    dimensions = array->jit_dimensions ();
+  }
+
+  void update (T *aarray)
+  {
+    array = aarray;
+    update ();
+  }
+
+  operator T () const
+  {
+    return *array;
+  }
+
+  int *ref_count;
+
+  U *slice_data;
+  octave_idx_type slice_len;
+  octave_idx_type *dimensions;
+
+  T *array;
+};
+
+typedef jit_array<NDArray, double> jit_matrix;
+
+std::ostream& operator<< (std::ostream& os, const jit_matrix& mat);
+
+// calling convention
+namespace
+jit_convention
+{
+  enum
+  type
+  {
+    // internal to jit
+    internal,
+
+    // an external C call
+    external,
+
+    length
+  };
+}
+
+// Used to keep track of estimated (infered) types during JIT. This is a
+// hierarchical type system which includes both concrete and abstract types.
+//
+// The types form a lattice. Currently we only allow for one parent type, but
+// eventually we may allow for multiple predecessors.
+class
+jit_type
+{
+public:
+  typedef llvm::Value *(*convert_fn) (llvm::IRBuilderD&, llvm::Value *);
+
+  jit_type (const std::string& aname, jit_type *aparent, llvm::Type *allvm_type,
+            int aid);
+
+  // a user readable type name
+  const std::string& name (void) const { return mname; }
+
+  // a unique id for the type
+  int type_id (void) const { return mid; }
+
+  // An abstract base type, may be null
+  jit_type *parent (void) const { return mparent; }
+
+  // convert to an llvm type
+  llvm::Type *to_llvm (void) const { return llvm_type; }
+
+  // how this type gets passed as a function argument
+  llvm::Type *to_llvm_arg (void) const;
+
+  size_t depth (void) const { return mdepth; }
+
+  // -------------------- Calling Convention information --------------------
+
+  // A function declared like: mytype foo (int arg0, int arg1);
+  // Will be converted to: void foo (mytype *retval, int arg0, int arg1)
+  // if mytype is sret. The caller is responsible for allocating space for
+  // retval. (on the stack)
+  bool sret (jit_convention::type cc) const { return msret[cc]; }
+
+  void mark_sret (jit_convention::type cc = jit_convention::external)
+  { msret[cc] = true; }
+
+  // A function like: void foo (mytype arg0)
+  // Will be converted to: void foo (mytype *arg0)
+  // Basically just pass by reference.
+  bool pointer_arg (jit_convention::type cc) const { return mpointer_arg[cc]; }
+
+  void mark_pointer_arg (jit_convention::type cc = jit_convention::external)
+  { mpointer_arg[cc] = true; }
+
+  // Convert into an equivalent form before calling. For example, complex is
+  // represented as two values llvm vector, but we need to pass it as a two
+  // valued llvm structure to C functions.
+  convert_fn pack (jit_convention::type cc) { return mpack[cc]; }
+
+  void set_pack (jit_convention::type cc, convert_fn fn) { mpack[cc] = fn; }
+
+  // The inverse operation of pack.
+  convert_fn unpack (jit_convention::type cc) { return munpack[cc]; }
+
+  void set_unpack (jit_convention::type cc, convert_fn fn)
+  { munpack[cc] = fn; }
+
+  // The resulting type after pack is called.
+  llvm::Type *packed_type (jit_convention::type cc)
+  { return mpacked_type[cc]; }
+
+  void set_packed_type (jit_convention::type cc, llvm::Type *ty)
+  { mpacked_type[cc] = ty; }
+private:
+  std::string mname;
+  jit_type *mparent;
+  llvm::Type *llvm_type;
+  int mid;
+  size_t mdepth;
+
+  bool msret[jit_convention::length];
+  bool mpointer_arg[jit_convention::length];
+
+  convert_fn mpack[jit_convention::length];
+  convert_fn munpack[jit_convention::length];
+
+  llvm::Type *mpacked_type[jit_convention::length];
+};
+
+// seperate print function to allow easy printing if type is null
+std::ostream& jit_print (std::ostream& os, jit_type *atype);
+
+class jit_value;
+
+// An abstraction for calling llvm functions with jit_values. Deals with calling
+// convention details.
+class
+jit_function
+{
+  friend std::ostream& operator<< (std::ostream& os, const jit_function& fn);
+public:
+  // create a function in an invalid state
+  jit_function ();
+
+  jit_function (llvm::Module *amodule, jit_convention::type acall_conv,
+                const llvm::Twine& aname, jit_type *aresult,
+                const std::vector<jit_type *>& aargs);
+
+  // Use an existing function, but change the argument types. The new argument
+  // types must behave the same for the current calling convention.
+  jit_function (const jit_function& fn, jit_type *aresult,
+                const std::vector<jit_type *>& aargs);
+
+  jit_function (const jit_function& fn);
+
+  template <typename T>
+  void add_mapping (llvm::ExecutionEngine *engine, T fn)
+  {
+    do_add_mapping (engine, reinterpret_cast<void *> (fn));
+  }
+
+  bool valid (void) const { return llvm_function; }
+
+  std::string name (void) const;
+
+  llvm::BasicBlock *new_block (const std::string& aname = "body",
+                               llvm::BasicBlock *insert_before = 0);
+
+  llvm::Value *call (llvm::IRBuilderD& builder,
+                     const std::vector<jit_value *>& in_args) const;
+
+  llvm::Value *call (llvm::IRBuilderD& builder,
+                     const std::vector<llvm::Value *>& in_args
+                     = std::vector<llvm::Value *> ()) const;
+
+#define JIT_PARAM_ARGS llvm::IRBuilderD& builder,
+#define JIT_PARAMS builder,
+#define JIT_CALL(N) JIT_EXPAND (llvm::Value *, call, llvm::Value *, const, N)
+
+  JIT_CALL (1)
+  JIT_CALL (2)
+  JIT_CALL (3)
+  JIT_CALL (4)
+  JIT_CALL (5)
+
+#undef JIT_CALL
+
+#define JIT_CALL(N) JIT_EXPAND (llvm::Value *, call, jit_value *, const, N)
+
+  JIT_CALL (1);
+  JIT_CALL (2);
+
+#undef JIT_CALL
+#undef JIT_PARAMS
+#undef JIT_PARAM_ARGS
+
+  llvm::Value *argument (llvm::IRBuilderD& builder, size_t idx) const;
+
+  void do_return (llvm::IRBuilderD& builder, llvm::Value *rval = 0);
+
+  llvm::Function *to_llvm (void) const { return llvm_function; }
+
+  // If true, then the return value is passed as a pointer in the first argument
+  bool sret (void) const { return mresult && mresult->sret (call_conv); }
+
+  bool can_error (void) const { return mcan_error; }
+
+  void mark_can_error (void) { mcan_error = true; }
+
+  jit_type *result (void) const { return mresult; }
+
+  jit_type *argument_type (size_t idx) const
+  {
+    assert (idx < args.size ());
+    return args[idx];
+  }
+
+  const std::vector<jit_type *>& arguments (void) const { return args; }
+private:
+  void do_add_mapping (llvm::ExecutionEngine *engine, void *fn);
+
+  llvm::Module *module;
+  llvm::Function *llvm_function;
+  jit_type *mresult;
+  std::vector<jit_type *> args;
+  jit_convention::type call_conv;
+  bool mcan_error;
+};
+
+std::ostream& operator<< (std::ostream& os, const jit_function& fn);
+
+
+// Keeps track of information about how to implement operations (+, -, *, ect)
+// and their resulting types.
+class
+jit_operation
+{
+public:
+  void add_overload (const jit_function& func)
+  {
+    add_overload (func, func.arguments ());
+  }
+
+  void add_overload (const jit_function& func,
+                     const std::vector<jit_type*>& args);
+
+  const jit_function& overload (const std::vector<jit_type *>& types) const;
+
+  jit_type *result (const std::vector<jit_type *>& types) const
+  {
+    const jit_function& temp = overload (types);
+    return temp.result ();
+  }
+
+#define JIT_PARAMS
+#define JIT_PARAM_ARGS
+#define JIT_OVERLOAD(N)                                              \
+  JIT_EXPAND (const jit_function&, overload, jit_type *, const, N)   \
+  JIT_EXPAND (jit_type *, result, jit_type *, const, N)
+
+  JIT_OVERLOAD (1);
+  JIT_OVERLOAD (2);
+  JIT_OVERLOAD (3);
+
+#undef JIT_PARAMS
+#undef JIT_PARAM_ARGS
+
+  const std::string& name (void) const { return mname; }
+
+  void stash_name (const std::string& aname) { mname = aname; }
+private:
+  Array<octave_idx_type> to_idx (const std::vector<jit_type*>& types) const;
+
+  std::vector<Array<jit_function> > overloads;
+
+  std::string mname;
+};
+
+// A singleton class which handles the construction of jit_types and
+// jit_operations.
+class
+jit_typeinfo
+{
+public:
+  static void initialize (llvm::Module *m, llvm::ExecutionEngine *e);
+
+  static jit_type *join (jit_type *lhs, jit_type *rhs)
+  {
+    return instance->do_join (lhs, rhs);
+  }
+
+  static jit_type *get_any (void) { return instance->any; }
+
+  static jit_type *get_matrix (void) { return instance->matrix; }
+
+  static jit_type *get_scalar (void) { return instance->scalar; }
+
+  static llvm::Type *get_scalar_llvm (void)
+  { return instance->scalar->to_llvm (); }
+
+  static jit_type *get_range (void) { return instance->range; }
+
+  static jit_type *get_string (void) { return instance->string; }
+
+  static jit_type *get_bool (void) { return instance->boolean; }
+
+  static jit_type *get_index (void) { return instance->index; }
+
+  static llvm::Type *get_index_llvm (void)
+  { return instance->index->to_llvm (); }
+
+  static jit_type *get_complex (void) { return instance->complex; }
+
+  // Get the jit_type of an octave_value
+  static jit_type *type_of (const octave_value& ov)
+  {
+    return instance->do_type_of (ov);
+  }
+
+  static const jit_operation& binary_op (int op)
+  {
+    return instance->do_binary_op (op);
+  }
+
+  static const jit_operation& grab (void) { return instance->grab_fn; }
+
+  static const jit_function& get_grab (jit_type *type)
+  {
+    return instance->grab_fn.overload (type);
+  }
+
+  static const jit_operation& release (void)
+  {
+    return instance->release_fn;
+  }
+
+  static const jit_function& get_release (jit_type *type)
+  {
+    return instance->release_fn.overload (type);
+  }
+
+  static const jit_operation& print_value (void)
+  {
+    return instance->print_fn;
+  }
+
+  static const jit_operation& for_init (void)
+  {
+    return instance->for_init_fn;
+  }
+
+  static const jit_operation& for_check (void)
+  {
+    return instance->for_check_fn;
+  }
+
+  static const jit_operation& for_index (void)
+  {
+    return instance->for_index_fn;
+  }
+
+  static const jit_operation& make_range (void)
+  {
+    return instance->make_range_fn;
+  }
+
+  static const jit_operation& paren_subsref (void)
+  {
+    return instance->paren_subsref_fn;
+  }
+
+  static const jit_operation& paren_subsasgn (void)
+  {
+    return instance->paren_subsasgn_fn;
+  }
+
+  static const jit_operation& logically_true (void)
+  {
+    return instance->logically_true_fn;
+  }
+
+  static const jit_operation& cast (jit_type *result)
+  {
+    return instance->do_cast (result);
+  }
+
+  static const jit_function& cast (jit_type *to, jit_type *from)
+  {
+    return instance->do_cast (to, from);
+  }
+
+  static llvm::Value *insert_error_check (llvm::IRBuilderD& bld)
+  {
+    return instance->do_insert_error_check (bld);
+  }
+private:
+  jit_typeinfo (llvm::Module *m, llvm::ExecutionEngine *e);
+
+  // FIXME: Do these methods really need to be in jit_typeinfo?
+  jit_type *do_join (jit_type *lhs, jit_type *rhs)
+  {
+    // empty case
+    if (! lhs)
+      return rhs;
+
+    if (! rhs)
+      return lhs;
+
+    // check for a shared parent
+    while (lhs != rhs)
+      {
+        if (lhs->depth () > rhs->depth ())
+          lhs = lhs->parent ();
+        else if (lhs->depth () < rhs->depth ())
+          rhs = rhs->parent ();
+        else
+          {
+            // we MUST have depth > 0 as any is the base type of everything
+            do
+              {
+                lhs = lhs->parent ();
+                rhs = rhs->parent ();
+              }
+            while (lhs != rhs);
+          }
+      }
+
+    return lhs;
+  }
+
+  jit_type *do_difference (jit_type *lhs, jit_type *)
+  {
+    // FIXME: Maybe we can do something smarter?
+    return lhs;
+  }
+
+  jit_type *do_type_of (const octave_value &ov) const;
+
+  const jit_operation& do_binary_op (int op) const
+  {
+    assert (static_cast<size_t>(op) < binary_ops.size ());
+    return binary_ops[op];
+  }
+
+  const jit_operation& do_cast (jit_type *to)
+  {
+    static jit_operation null_function;
+    if (! to)
+      return null_function;
+
+    size_t id = to->type_id ();
+    if (id >= casts.size ())
+      return null_function;
+    return casts[id];
+  }
+
+  const jit_function& do_cast (jit_type *to, jit_type *from)
+  {
+    return do_cast (to).overload (from);
+  }
+
+  jit_type *new_type (const std::string& name, jit_type *parent,
+                      llvm::Type *llvm_type);
+
+
+  void add_print (jit_type *ty, void *fptr);
+
+  void add_binary_op (jit_type *ty, int op, int llvm_op);
+
+  void add_binary_icmp (jit_type *ty, int op, int llvm_op);
+
+  void add_binary_fcmp (jit_type *ty, int op, int llvm_op);
+
+  jit_function create_function (jit_convention::type cc,
+                                const llvm::Twine& name, jit_type *ret,
+                                const std::vector<jit_type *>& args
+                                = std::vector<jit_type *> ());
+
+#define JIT_PARAM_ARGS jit_convention::type cc, const llvm::Twine& name, \
+    jit_type *ret,
+#define JIT_PARAMS cc, name, ret,
+#define CREATE_FUNCTION(N) JIT_EXPAND(jit_function, create_function,    \
+                                      jit_type *, /* empty */, N)
+
+  CREATE_FUNCTION(1);
+  CREATE_FUNCTION(2);
+  CREATE_FUNCTION(3);
+  CREATE_FUNCTION(4);
+
+#undef JIT_PARAM_ARGS
+#undef JIT_PARAMS
+#undef CREATE_FUNCTION
+
+  jit_function create_identity (jit_type *type);
+
+  llvm::Value *do_insert_error_check (llvm::IRBuilderD& bld);
+
+  void add_builtin (const std::string& name);
+
+  void register_intrinsic (const std::string& name, size_t id,
+                           jit_type *result, jit_type *arg0)
+  {
+    std::vector<jit_type *> args (1, arg0);
+    register_intrinsic (name, id, result, args);
+  }
+
+  void register_intrinsic (const std::string& name, size_t id, jit_type *result,
+                           const std::vector<jit_type *>& args);
+
+  void register_generic (const std::string& name, jit_type *result,
+                         jit_type *arg0)
+  {
+    std::vector<jit_type *> args (1, arg0);
+    register_generic (name, result, args);
+  }
+
+  void register_generic (const std::string& name, jit_type *result,
+                         const std::vector<jit_type *>& args);
+
+  octave_builtin *find_builtin (const std::string& name);
+
+  jit_function mirror_binary (const jit_function& fn);
+
+  llvm::Function *wrap_complex (llvm::Function *wrap);
+
+  static llvm::Value *pack_complex (llvm::IRBuilderD& bld,
+                                    llvm::Value *cplx);
+
+  static llvm::Value *unpack_complex (llvm::IRBuilderD& bld,
+                                      llvm::Value *result);
+
+  llvm::Value *complex_real (llvm::Value *cx);
+
+  llvm::Value *complex_real (llvm::Value *cx, llvm::Value *real);
+
+  llvm::Value *complex_imag (llvm::Value *cx);
+
+  llvm::Value *complex_imag (llvm::Value *cx, llvm::Value *imag);
+
+  llvm::Value *complex_new (llvm::Value *real, llvm::Value *imag);
+
+  void create_int (size_t nbits);
+
+  jit_type *intN (size_t nbits) const;
+
+  static jit_typeinfo *instance;
+
+  llvm::Module *module;
+  llvm::ExecutionEngine *engine;
+  int next_id;
+
+  llvm::GlobalVariable *lerror_state;
+
+  std::vector<jit_type*> id_to_type;
+  jit_type *any;
+  jit_type *matrix;
+  jit_type *scalar;
+  jit_type *range;
+  jit_type *string;
+  jit_type *boolean;
+  jit_type *index;
+  jit_type *complex;
+  jit_type *unknown_function;
+  std::map<size_t, jit_type *> ints;
+  std::map<std::string, jit_type *> builtins;
+
+  llvm::StructType *complex_ret;
+
+  std::vector<jit_operation> binary_ops;
+  jit_operation grab_fn;
+  jit_operation release_fn;
+  jit_operation print_fn;
+  jit_operation for_init_fn;
+  jit_operation for_check_fn;
+  jit_operation for_index_fn;
+  jit_operation logically_true_fn;
+  jit_operation make_range_fn;
+  jit_operation paren_subsref_fn;
+  jit_operation paren_subsasgn_fn;
+
+  // type id -> cast function TO that type
+  std::vector<jit_operation> casts;
+
+  // type id -> identity function
+  std::vector<jit_function> identities;
+
+  llvm::IRBuilderD& builder;
+};
+
+#endif
+#endif
diff --git a/src/jit-util.cc b/src/jit-util.cc
new file mode 100644
--- /dev/null
+++ b/src/jit-util.cc
@@ -0,0 +1,44 @@
+/*
+
+Copyright (C) 2012 Max Brister <max@2bass.com>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// defines required by llvm
+#define __STDC_LIMIT_MACROS
+#define __STDC_CONSTANT_MACROS
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef HAVE_LLVM
+
+#include <llvm/Value.h>
+#include <llvm/Support/raw_os_ostream.h>
+
+std::ostream&
+operator<< (std::ostream& os, const llvm::Value& v)
+{
+  llvm::raw_os_ostream llvm_out (os);
+  v.print (llvm_out);
+  return os;
+}
+
+#endif
diff --git a/src/jit-util.h b/src/jit-util.h
new file mode 100644
--- /dev/null
+++ b/src/jit-util.h
@@ -0,0 +1,203 @@
+/*
+
+Copyright (C) 2012 Max Brister <max@2bass.com>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// Some utility classes and functions used throughout jit
+
+#if !defined (octave_jit_util_h)
+#define octave_jit_util_h 1
+
+#ifdef HAVE_LLVM
+
+#include <stdexcept>
+
+// we don't want to include llvm headers here, as they require
+// __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS be defined in the entire
+// compilation unit
+namespace llvm
+{
+  class Value;
+  class Module;
+  class FunctionPassManager;
+  class PassManager;
+  class ExecutionEngine;
+  class Function;
+  class BasicBlock;
+  class LLVMContext;
+  class Type;
+  class StructType;
+  class Twine;
+  class GlobalVariable;
+  class TerminatorInst;
+  class PHINode;
+
+  class ConstantFolder;
+
+  template <bool preserveNames>
+  class IRBuilderDefaultInserter;
+
+  template <bool preserveNames, typename T, typename Inserter>
+  class IRBuilder;
+
+typedef IRBuilder<true, ConstantFolder, IRBuilderDefaultInserter<true> >
+IRBuilderD;
+}
+
+class octave_base_value;
+class octave_builtin;
+class octave_value;
+class tree;
+class tree_expression;
+
+// thrown when we should give up on JIT and interpret
+class jit_fail_exception : public std::runtime_error
+{
+public:
+  jit_fail_exception (void) : std::runtime_error ("unknown"), mknown (false) {}
+  jit_fail_exception (const std::string& reason) : std::runtime_error (reason),
+                                                   mknown (true)
+  {}
+
+  bool known (void) const { return mknown; }
+private:
+  bool mknown;
+};
+
+// llvm doesn't provide this, and it's really useful for debugging
+std::ostream& operator<< (std::ostream& os, const llvm::Value& v);
+
+template <typename HOLDER_T, typename SUB_T>
+class jit_internal_node;
+
+// jit_internal_list and jit_internal_node implement generic embedded doubly
+// linked lists. List items extend from jit_internal_list, and can be placed
+// in nodes of type jit_internal_node. We use CRTP twice.
+template <typename LIST_T, typename NODE_T>
+class
+jit_internal_list
+{
+  friend class jit_internal_node<LIST_T, NODE_T>;
+public:
+  jit_internal_list (void) : use_head (0), use_tail (0), muse_count (0) {}
+
+  virtual ~jit_internal_list (void)
+  {
+    while (use_head)
+      use_head->stash_value (0);
+  }
+
+  NODE_T *first_use (void) const { return use_head; }
+
+  size_t use_count (void) const { return muse_count; }
+private:
+  NODE_T *use_head;
+  NODE_T *use_tail;
+  size_t muse_count;
+};
+
+// a node for internal linked lists
+template <typename LIST_T, typename NODE_T>
+class
+jit_internal_node
+{
+public:
+  typedef jit_internal_list<LIST_T, NODE_T> jit_ilist;
+
+  jit_internal_node (void) : mvalue (0), mnext (0), mprev (0) {}
+
+  ~jit_internal_node (void) { remove (); }
+
+  LIST_T *value (void) const { return mvalue; }
+
+  void stash_value (LIST_T *avalue)
+  {
+    remove ();
+
+    mvalue = avalue;
+
+    if (mvalue)
+      {
+        jit_ilist *ilist = mvalue;
+        NODE_T *sthis = static_cast<NODE_T *> (this);
+        if (ilist->use_head)
+          {
+            ilist->use_tail->mnext = sthis;
+            mprev = ilist->use_tail;
+          }
+        else
+          ilist->use_head = sthis;
+
+        ilist->use_tail = sthis;
+        ++ilist->muse_count;
+      }
+  }
+
+  NODE_T *next (void) const { return mnext; }
+
+  NODE_T *prev (void) const { return mprev; }
+private:
+  void remove ()
+  {
+    if (mvalue)
+      {
+        jit_ilist *ilist = mvalue;
+        if (mprev)
+          mprev->mnext = mnext;
+        else
+          // we are the use_head
+          ilist->use_head = mnext;
+
+        if (mnext)
+          mnext->mprev = mprev;
+        else
+          // we are the use tail
+          ilist->use_tail = mprev;
+
+        mnext = mprev = 0;
+        --ilist->muse_count;
+        mvalue = 0;
+      }
+  }
+
+  LIST_T *mvalue;
+  NODE_T *mnext;
+  NODE_T *mprev;
+};
+
+// Use like: isa<jit_phi> (value)
+// basically just a short cut type typing dyanmic_cast.
+template <typename T, typename U>
+bool isa (U *value)
+{
+  return dynamic_cast<T *> (value);
+}
+
+#define JIT_ASSIGN_ARG(i) the_args[i] = arg ## i;
+#define JIT_EXPAND(ret, fname, type, isconst, N)                        \
+  ret fname (JIT_PARAM_ARGS OCT_MAKE_DECL_LIST (type, arg, N)) isconst  \
+  {                                                                     \
+    std::vector<type> the_args (N);                                     \
+    OCT_ITERATE_MACRO (JIT_ASSIGN_ARG, N);                              \
+    return fname (JIT_PARAMS the_args);                                 \
+  }
+
+#endif
+#endif
diff --git a/src/link-deps.mk b/src/link-deps.mk
--- a/src/link-deps.mk
+++ b/src/link-deps.mk
@@ -6,26 +6,31 @@ else
   LIBOCTINTERP_LINK_DEPS = $(DLD_FUNCTIONS_LIBS)
 endif
 
 LIBOCTINTERP_LINK_DEPS += \
   $(GRAPHICS_LIBS) \
   $(FT2_LIBS) \
   $(HDF5_LIBS) \
   $(Z_LIBS) \
+  $(FFTW_XLIBS) \
+  $(REGEX_LIBS) \
   $(OPENGL_LIBS) \
   $(X11_LIBS) \
-  $(CARBON_LIBS)
+  $(CARBON_LIBS) \
+  $(LLVM_LIBS)
 
 LIBOCTINTERP_LINK_OPTS = \
   $(GRAPHICS_LDFLAGS) \
   $(FT2_LDFLAGS) \
   $(HDF5_LDFLAGS) \
   $(Z_LDFLAGS) \
-  $(REGEX_LDFLAGS)
+  $(REGEX_LDFLAGS) \
+  $(FFTW_XLDFLAGS) \
+  $(LLVM_LDFLAGS)
 
 OCT_LINK_DEPS =
 
 OCT_LINK_OPTS = $(LDFLAGS)
 
 if AMCOND_LINK_ALL_DEPS
   LIBOCTINTERP_LINK_DEPS += $(LIBOCTAVE_LINK_DEPS)
   LIBOCTINTERP_LINK_OPTS += $(LIBOCTAVE_LINK_OPTS)
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -518,46 +518,19 @@ load_path::do_initialize (bool set_initi
     }
   else
     xpath = sys_path;
 
   do_set (xpath, false, true);
 }
 
 void
-load_path::do_clear (std::set<std::string>& new_elts)
+load_path::do_clear (void)
 {
-  bool warn_default_path_clobbered = false;
-  for (dir_info_list_iterator i = dir_info_list.begin ();
-       i != dir_info_list.end ();
-       /* conditionally advance iterator in loop body */)
-    {
-      //Don't remove it if it's gonna be added again, but remove it from
-      //list of items to add, to avoid duplicates later on
-      std::set<std::string>::iterator j = new_elts.find (i->dir_name);
-      if (j != new_elts.end ())
-        {
-          new_elts.erase (j);
-          i++;
-        }
-      else
-        {
-          //Warn if removing a default directory and not immediately adding
-          //it back again
-          if (i->is_init)
-            warn_default_path_clobbered = true;
-          i = dir_info_list.erase (i);
-        }
-    }
-
-  if (warn_default_path_clobbered)
-    warning_with_id ("Octave:remove-init-dir",
-                     "default load path altered.  Some built-in functions may "
-                     "not be found.  Try restoredefaultpath() to recover it.");
-
+  dir_info_list.clear ();
   fcn_map.clear ();
   private_fcn_map.clear ();
   method_map.clear ();
 }
 
 static std::list<std::string>
 split_path (const std::string& p)
 {
@@ -589,32 +562,50 @@ split_path (const std::string& p)
     retval.push_back (elt);
 
   return retval;
 }
 
 void
 load_path::do_set (const std::string& p, bool warn, bool is_init)
 {
-  std::list<std::string> elts_l = split_path (p);
-  std::set<std::string> elts(elts_l.begin (), elts_l.end ());
+  // Use a list when we need to preserve order.
+  std::list<std::string> elts = split_path (p);
+
+  // Use a set when we need to search and order is not important.
+  std::set<std::string> elts_set (elts.begin (), elts.end ());
+
+  if (is_init)
+    init_dirs = elts_set;
+  else
+    {
+      for (std::set<std::string>::const_iterator it = init_dirs.begin ();
+           it != init_dirs.end (); it++)
+        {
+          if (elts_set.find (*it) == elts_set.end ())
+            {
+              warning_with_id ("Octave:remove-init-dir",
+                               "default load path altered.  Some built-in functions may not be found.  Try restoredefaultpath() to recover it.");
+              break;
+            }
+        }
+    }
 
   // Temporarily disable add hook.
 
   unwind_protect frame;
   frame.protect_var (add_hook);
 
   add_hook = 0;
 
-  do_clear (elts);
-
-  for (std::set<std::string>::const_iterator i = elts.begin ();
-       i != elts.end ();
-       i++)
-    do_append (*i, warn, is_init);
+  do_clear ();
+
+  for (std::list<std::string>::const_iterator i = elts.begin ();
+       i != elts.end (); i++)
+    do_append (*i, warn);
 
   // Restore add hook and execute for all newly added directories.
   frame.run_top ();
 
   for (dir_info_list_iterator i = dir_info_list.begin ();
        i != dir_info_list.end ();
        i++)
     {
@@ -622,20 +613,20 @@ load_path::do_set (const std::string& p,
         add_hook (i->dir_name);
     }
 
   // Always prepend current directory.
   do_prepend (".", warn);
 }
 
 void
-load_path::do_append (const std::string& dir, bool warn, bool is_init)
+load_path::do_append (const std::string& dir, bool warn)
 {
   if (! dir.empty ())
-    do_add (dir, true, warn, is_init);
+    do_add (dir, true, warn);
 }
 
 void
 load_path::do_prepend (const std::string& dir, bool warn)
 {
   if (! dir.empty ())
     do_add (dir, false, warn);
 }
@@ -654,18 +645,17 @@ strip_trailing_separators (const std::st
 
   if (k < dir.length ())
     dir.resize (k);
 
   return dir;
 }
 
 void
-load_path::do_add (const std::string& dir_arg, bool at_end, bool warn,
-                   bool is_init)
+load_path::do_add (const std::string& dir_arg, bool at_end, bool warn)
 {
   size_t len = dir_arg.length ();
 
   if (len > 1 && dir_arg.substr (len-2) == "//")
     warning_with_id ("Octave:recursive-path-search",
                      "trailing `//' is no longer special in search path elements");
 
   std::string dir = file_ops::tilde_expand (dir_arg);
@@ -680,17 +670,16 @@ load_path::do_add (const std::string& di
     {
       file_stat fs (dir);
 
       if (fs)
         {
           if (fs.is_dir ())
             {
               dir_info di (dir);
-              di.is_init = is_init;
 
               if (! error_state)
                 {
                   if (at_end)
                     dir_info_list.push_back (di);
                   else
                     dir_info_list.push_front (di);
 
@@ -1793,17 +1782,21 @@ load_path::add_to_fcn_map (const dir_inf
               if (! file_info_list.empty ())
                 {
                   file_info& old = file_info_list.front ();
 
                   // FIXME -- do we need to be more careful about the
                   // way we look for old.dir_name in sys_path to avoid
                   // partial matches?
 
-                  if (sys_path.find (old.dir_name) != std::string::npos
+                  // Don't warn about Contents.m files since we expect
+                  // more than one to exist in the load path.
+
+                  if (fname != "Contents.m"
+                      && sys_path.find (old.dir_name) != std::string::npos
                       && in_path_list (sys_path, old.dir_name))
                     {
                       std::string fcn_path = file_ops::concat (dir_name, fname);
 
                       warning_with_id ("Octave:shadowed-function",
                                        "function %s shadows a core library function",
                                        fcn_path.c_str ());
                     }
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -34,37 +34,35 @@ along with Octave; see the file COPYING.
 
 class
 OCTINTERP_API
 load_path
 {
 protected:
 
   load_path (void)
-    : dir_info_list (), fcn_map (), private_fcn_map (), method_map () { }
+    : dir_info_list (), fcn_map (), private_fcn_map (), method_map (),
+      init_dirs () { }
 
 public:
 
   typedef void (*hook_fcn_ptr) (const std::string& dir);
 
   ~load_path (void) { }
 
   static void initialize (bool set_initial_path = false)
   {
     if (instance_ok ())
       instance->do_initialize (set_initial_path);
   }
 
   static void clear (void)
   {
     if (instance_ok ())
-      {
-        std::set<std::string> no_new_elts;
-        instance->do_clear (no_new_elts);
-      }
+      instance->do_clear ();
   }
 
   static void set (const std::string& p, bool warn = false)
   {
     if (instance_ok ())
       instance->do_set (p, warn);
   }
 
@@ -292,65 +290,62 @@ private:
     typedef method_file_map_type::const_iterator const_method_file_map_iterator;
     typedef method_file_map_type::iterator method_file_map_iterator;
 
     // This default constructor is only provided so we can create a
     // std::map of dir_info objects.  You should not use this
     // constructor for any other purpose.
     dir_info (void)
       : dir_name (), abs_dir_name (), is_relative (false),
-        is_init (false), dir_mtime (), dir_time_last_checked (),
+        dir_mtime (), dir_time_last_checked (),
         all_files (), fcn_files (), private_file_map (), method_file_map ()
       { }
 
     dir_info (const std::string& d)
       : dir_name (d), abs_dir_name (), is_relative (false),
-        is_init (false), dir_mtime (), dir_time_last_checked (),
+        dir_mtime (), dir_time_last_checked (),
         all_files (), fcn_files (), private_file_map (), method_file_map ()
     {
       initialize ();
     }
 
     dir_info (const dir_info& di)
       : dir_name (di.dir_name), abs_dir_name (di.abs_dir_name),
         is_relative (di.is_relative),
-        is_init (di.is_init),
         dir_mtime (di.dir_mtime),
         dir_time_last_checked (di.dir_time_last_checked),
         all_files (di.all_files), fcn_files (di.fcn_files),
         private_file_map (di.private_file_map),
         method_file_map (di.method_file_map) { }
 
     ~dir_info (void) { }
 
     dir_info& operator = (const dir_info& di)
     {
       if (&di != this)
         {
           dir_name = di.dir_name;
           abs_dir_name = di.abs_dir_name;
           is_relative = di.is_relative;
-          is_init = di.is_init;
           dir_mtime = di.dir_mtime;
           dir_time_last_checked = di.dir_time_last_checked;
           all_files = di.all_files;
           fcn_files = di.fcn_files;
           private_file_map = di.private_file_map;
           method_file_map = di.method_file_map;
         }
 
       return *this;
     }
 
     void update (void);
 
     std::string dir_name;
     std::string abs_dir_name;
     bool is_relative;
-    bool is_init; //Was this directory set by init? Warn when clearing it.
     octave_time dir_mtime;
     octave_time dir_time_last_checked;
     string_vector all_files;
     string_vector fcn_files;
     fcn_file_map_type private_file_map;
     method_file_map_type method_file_map;
 
   private:
@@ -442,16 +437,18 @@ private:
   mutable dir_info_list_type dir_info_list;
 
   mutable fcn_map_type fcn_map;
 
   mutable private_fcn_map_type private_fcn_map;
 
   mutable method_map_type method_map;
 
+  mutable std::set<std::string> init_dirs;
+
   static load_path *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static hook_fcn_ptr add_hook;
 
   static hook_fcn_ptr remove_hook;
 
@@ -472,26 +469,25 @@ private:
                      const string_vector& fcn_files, bool at_end);
 
   void move_method_map (const std::string& dir, bool at_end);
 
   void move (std::list<dir_info>::iterator i, bool at_end);
 
   void do_initialize (bool set_initial_path);
 
-  void do_clear (std::set<std::string>& new_elts);
+  void do_clear (void);
 
-  void do_set (const std::string& p, bool warn, bool is_init=false);
+  void do_set (const std::string& p, bool warn, bool is_init = false);
 
-  void do_append (const std::string& dir, bool warn, bool is_init=false);
+  void do_append (const std::string& dir, bool warn);
 
   void do_prepend (const std::string& dir, bool warn);
 
-  void do_add (const std::string& dir, bool at_end, bool warn,
-               bool is_init=false);
+  void do_add (const std::string& dir, bool at_end, bool warn);
 
   void remove_fcn_map (const std::string& dir, const string_vector& fcn_files);
 
   void remove_private_fcn_map (const std::string& dir);
 
   void remove_method_map (const std::string& dir);
 
   bool do_remove (const std::string& dir);
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -86,25 +86,25 @@ along with Octave; see the file COPYING.
 #ifdef open
 #undef open
 #endif
 
 #ifdef HAVE_ZLIB
 #include "zfstream.h"
 #endif
 
-// Write octave-core file if Octave crashes or is killed by a signal.
+// Write octave-workspace file if Octave crashes or is killed by a signal.
 static bool Vcrash_dumps_octave_core = true;
 
 // The maximum amount of memory (in kilobytes) that we will attempt to
 // write to the Octave core file.
 static double Voctave_core_file_limit = -1.0;
 
 // The name of the Octave core file.
-static std::string Voctave_core_file_name = "octave-core";
+static std::string Voctave_core_file_name = "octave-workspace";
 
 // The default output format.  May be one of "binary", "text",
 // "mat-binary", or "hdf5".
 static std::string Vdefault_save_options = "-text";
 
 // The output format for Octave core files.
 static std::string Voctave_core_file_options = "-binary";
 
@@ -1746,17 +1746,17 @@ the file @file{data} in Octave's binary 
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} crash_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} crash_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
-to save all current variables to the file \"octave-core\" if it\n\
+to save all current variables to the file \"octave-workspace\" if it\n\
 crashes or receives a hangup, terminate or similar signal.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @seealso{octave_core_file_limit, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
@@ -1807,17 +1807,17 @@ variable value is restored when exiting 
 
 DEFUN (octave_core_file_name, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} octave_core_file_name ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_name (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} octave_core_file_name (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the file\n\
 used for saving data from the top-level workspace if Octave aborts.\n\
-The default value is @code{\"octave-core\"}\n\
+The default value is @code{\"octave-workspace\"}\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_name);
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -1931,17 +1931,17 @@ save_mat5_array_length (const double* va
     {
       int size = 8;
 
       if (save_as_floats)
         {
           bool too_large_for_float = false;
           for (octave_idx_type i = 0; i < nel; i++)
             {
-              double tmp = val [i];
+              double tmp = val[i];
 
               if (! (xisnan (tmp) || xisinf (tmp))
                   && fabs (tmp) > FLT_MAX)
                 {
                   too_large_for_float = true;
                   break;
                 }
             }
diff --git a/src/mkbuiltins b/src/mkbuiltins
--- a/src/mkbuiltins
+++ b/src/mkbuiltins
@@ -52,29 +52,30 @@ cat << \EOF
 #define XDEFUN_DLD_INTERNAL(name, args_name, nargout_name, doc) \
   XDEFUN_INTERNAL(name, args_name, nargout_name, doc)
 
 #define XDEFUNX_DLD_INTERNAL(name, fname, args_name, nargout_name, doc) \
   XDEFUNX_INTERNAL(name, fname, args_name, nargout_name, doc)
 
 #endif
 
-#define XDEFUN_FILE_NAME(name)
+#define XDEFUN_FILE_NAME(name) \
+  std::string file = name;
 
 #define XDEFUN_INTERNAL(name, args_name, nargout_name, doc) \
   extern DECLARE_FUN (name, args_name, nargout_name); \
-  install_builtin_function (F ## name, #name, doc); \
+  install_builtin_function (F ## name, #name, file, doc); \
 
 #define XDEFCONSTFUN_INTERNAL(name, args_name, nargout_name, doc) \
   extern DECLARE_FUN (name, args_name, nargout_name); \
-  install_builtin_function (F ## name, #name, doc, false); \
+  install_builtin_function (F ## name, #name, file, doc, false); \
 
 #define XDEFUNX_INTERNAL(name, fname, args_name, nargout_name, doc) \
   extern DECLARE_FUNX (fname, args_name, nargout_name); \
-  install_builtin_function (fname, name, doc); \
+  install_builtin_function (fname, name, file, doc); \
 
 #define XDEFALIAS_INTERNAL(alias, name) \
   alias_builtin (#alias, #name);
 
 #define XDEFCONST_INTERNAL(name, defn, doc)
 
 EOF
 
diff --git a/src/oct-conf.in.h b/src/oct-conf.in.h
--- a/src/oct-conf.in.h
+++ b/src/oct-conf.in.h
@@ -379,16 +379,28 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_MAGICK_LDFLAGS
 #define OCTAVE_CONF_MAGICK_LDFLAGS %OCTAVE_CONF_MAGICK_LDFLAGS%
 #endif
 
 #ifndef OCTAVE_CONF_MAGICK_LIBS
 #define OCTAVE_CONF_MAGICK_LIBS %OCTAVE_CONF_MAGICK_LIBS%
 #endif
 
+#ifndef OCTAVE_CONF_LLVM_CPPFLAGS
+#define OCTAVE_CONF_LLVM_CPPFLAGS %OCTAVE_CONF_LLVM_CPPFLAGS%
+#endif
+
+#ifndef OCTAVE_CONF_LLVM_LDFLAGS
+#define OCTAVE_CONF_LLVM_LDFLAGS %OCTAVE_CONF_LLVM_LDFLAGS%
+#endif
+
+#ifndef OCTAVE_CONF_LLVM_LIBS
+#define OCTAVE_CONF_LLVM_LIBS %OCTAVE_CONF_LLVM_LIBS%
+#endif
+
 #ifndef OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS
 #define OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS %OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS%
 #endif
 
 #ifndef OCTAVE_CONF_OCTAVE_LINK_DEPS
 #define OCTAVE_CONF_OCTAVE_LINK_DEPS %OCTAVE_CONF_OCTAVE_LINK_DEPS%
 #endif
 
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -751,16 +751,31 @@ public:
   fast_elem_insert (octave_idx_type n, const octave_value& x);
 
   // This is a helper for the above, to be overriden in scalar types.  The
   // whole point is to handle the insertion efficiently with just *two* VM
   // calls, which is basically the theoretical minimum.
   virtual bool
   fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
+  // Grab the reference count. For use by jit.
+  void
+  grab (void)
+  {
+    ++count;
+  }
+
+  // Release the reference count. For use by jit.
+  void
+  release (void)
+  {
+    if (--count == 0)
+      delete this;
+  }
+
 protected:
 
   // This should only be called for derived types.
 
   octave_value numeric_assign (const std::string& type,
                                const std::list<octave_value_list>& idx,
                                const octave_value& rhs);
 
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -147,10 +147,27 @@ octave_builtin::do_multi_index_op (int n
         {
           gripe_library_execution_error ();
         }
     }
 
   return retval;
 }
 
+jit_type *
+octave_builtin::to_jit (void) const
+{
+  return jtype;
+}
+
+void
+octave_builtin::stash_jit (jit_type &type)
+{
+  jtype = &type;
+}
+
+octave_builtin::fcn
+octave_builtin::function (void) const
+{
+  return f;
+}
 
 const std::list<octave_lvalue> *octave_builtin::curr_lvalue_list = 0;
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -25,35 +25,42 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 
 class octave_value;
 class octave_value_list;
+class jit_type;
 
 // Builtin functions.
 
 class
 OCTINTERP_API
 octave_builtin : public octave_function
 {
 public:
 
-  octave_builtin (void) : octave_function (), f (0) { }
+  octave_builtin (void) : octave_function (), f (0), file (), jtype (0) { }
 
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
   octave_builtin (fcn ff, const std::string& nm = std::string (),
                   const std::string& ds = std::string ())
-    : octave_function (nm, ds), f (ff) { }
+    : octave_function (nm, ds), f (ff), file (), jtype (0) { }
+
+  octave_builtin (fcn ff, const std::string& nm, const std::string& fnm,
+                  const std::string& ds)
+    : octave_function (nm, ds), f (ff), file (fnm), jtype (0) { }
 
   ~octave_builtin (void) { }
 
+  std::string src_file_name (void) const { return file; }
+
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
   octave_value_list subsref (const std::string& type,
@@ -70,23 +77,35 @@ public:
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
+  jit_type *to_jit (void) const;
+
+  void stash_jit (jit_type& type);
+
+  fcn function (void) const;
+
   static const std::list<octave_lvalue> *curr_lvalue_list;
 
 protected:
 
   // A pointer to the actual function.
   fcn f;
 
+  // The name of the file where this function was defined.
+  std::string file;
+
+  // A pointer to the jit type that represents the function.
+  jit_type *jtype;
+
 private:
 
   // No copying!
 
   octave_builtin (const octave_builtin& ob);
 
   octave_builtin& operator = (const octave_builtin& ob);
 
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -1272,17 +1272,17 @@ octave_class::reconstruct_parents (void)
   // First, check to see if there might be an issue with inheritance.
   for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
     {
       std::string  key = map.key (p);
       Cell         val = map.contents (p);
       if ( val(0).is_object () )
         {
           dbgstr = "blork";
-          if( key == val(0).class_name () )
+          if ( key == val(0).class_name () )
             {
               might_have_inheritance = true;
               dbgstr = "cork";
               break;
             }
         }
     }
 
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -56,16 +56,18 @@ public:
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
   virtual bool is_system_fcn_file (void) const { return false; }
 
   virtual std::string fcn_file_name (void) const { return std::string (); }
 
+  virtual std::string src_file_name (void) const { return std::string (); }
+
   // The name to show in the profiler (also used as map-key).
   virtual std::string profiler_name (void) const { return name (); }
 
   virtual std::string parent_fcn_name (void) const { return std::string (); }
 
   virtual symbol_table::scope_id parent_fcn_scope (void) const { return -1; }
 
   virtual void mark_fcn_file_up_to_date (const octave_time&) { }
diff --git a/src/ov-oncleanup.cc b/src/ov-oncleanup.cc
--- a/src/ov-oncleanup.cc
+++ b/src/ov-oncleanup.cc
@@ -186,17 +186,17 @@ octave_oncleanup::print_raw (std::ostrea
   os << "onCleanup (";
   if (fcn.is_defined ())
     fcn.print_raw (os, pr_as_read_syntax);
   os << ")";
 }
 
 DEFUN (onCleanup, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{c} =} onCleanup (@var{action})\n\
+@deftypefn {Built-in Function} {@var{c} =} onCleanup (@var{action})\n\
 Create a special object that executes a given function upon destruction.\n\
 If the object is copied to multiple variables (or cell or struct array\n\
 elements) or returned from a function, @var{action} will be executed after\n\
 clearing the last copy of the object.  Note that if multiple local onCleanup\n\
 variables are created, the order in which they are called is unspecified.\n\
 For similar functionality @xref{The @code{unwind_protect} Statement}.\n\
 @end deftypefn")
 {
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -39,16 +39,22 @@ along with Octave; see the file COPYING.
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "variables.h"
 #include "pt-all.h"
 #include "pt-eval.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 
+#if HAVE_LLVM
+//FIXME: This should be part of tree_evaluator
+#include "pt-jit.h"
+static tree_jit jiter;
+#endif
+
 static tree_evaluator std_evaluator;
 
 tree_evaluator *current_evaluator = &std_evaluator;
 
 int tree_evaluator::dbstep_flag = 0;
 
 size_t tree_evaluator::current_frame = 0;
 
@@ -298,16 +304,21 @@ tree_evaluator::visit_simple_for_command
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
+#if HAVE_LLVM
+  if (jiter.execute (cmd, rhs))
+    return;
+#endif
+
   if (error_state || rhs.is_undefined ())
     return;
 
   {
     tree_expression *lhs = cmd.left_hand_side ();
 
     octave_lvalue ult = lhs->lvalue ();
 
@@ -1018,16 +1029,21 @@ tree_evaluator::visit_unwind_protect_com
 }
 
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
   if (error_state)
     return;
 
+#if HAVE_LLVM
+  if (jiter.execute (cmd))
+    return;
+#endif
+
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.condition ();
 
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -60,17 +60,17 @@ tree_identifier::eval_undefined_error (v
 octave_value_list
 tree_identifier::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
-  octave_value val = xsym ().find ();
+  octave_value val = sym->find ();
 
   if (val.is_defined ())
     {
       // GAGME -- this would be cleaner if we required
       // parens to indicate function calls.
       //
       // If this identifier refers to a function, we need to know
       // whether it is indexed so that we can do the same thing
@@ -111,17 +111,17 @@ tree_identifier::rvalue1 (int nargout)
     retval = tmp(0);
 
   return retval;
 }
 
 octave_lvalue
 tree_identifier::lvalue (void)
 {
-  return octave_lvalue (&(xsym ().varref ()));
+  return octave_lvalue (&(sym->varref ()));
 }
 
 tree_identifier *
 tree_identifier::dup (symbol_table::scope_id sc,
                       symbol_table::context_id) const
 {
   // The new tree_identifier object contains a symbol_record
   // entry from the duplicated scope.
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -41,36 +41,36 @@ class tree_walker;
 class
 tree_identifier : public tree_expression
 {
   friend class tree_index_expression;
 
 public:
 
   tree_identifier (int l = -1, int c = -1)
-    : tree_expression (l, c), sym (), scope (-1) { }
+    : tree_expression (l, c) { }
 
   tree_identifier (const symbol_table::symbol_record& s,
                    int l = -1, int c = -1,
                    symbol_table::scope_id sc = symbol_table::current_scope ())
-    : tree_expression (l, c), sym (s), scope (sc) { }
+    : tree_expression (l, c), sym (s, sc) { }
 
   ~tree_identifier (void) { }
 
   bool has_magic_end (void) const { return (name () == "__end__"); }
 
   bool is_identifier (void) const { return true; }
 
   // The name doesn't change with scope, so use sym instead of
   // accessing it through sym so that this function may remain const.
   std::string name (void) const { return sym.name (); }
 
-  bool is_defined (void) { return xsym ().is_defined (); }
+  bool is_defined (void) { return sym->is_defined (); }
 
-  virtual bool is_variable (void) { return xsym ().is_variable (); }
+  virtual bool is_variable (void) { return sym->is_variable (); }
 
   virtual bool is_black_hole (void) { return false; }
 
   // Try to find a definition for an identifier.  Here's how:
   //
   //   * If the identifier is already defined and is a function defined
   //     in an function file that has been modified since the last time
   //     we parsed it, parse it again.
@@ -82,24 +82,24 @@ public:
   //     function file to parse.
   //
   //   * On systems that support dynamic linking, we prefer .oct files,
   //     then .mex files, then .m files.
 
   octave_value
   do_lookup (const octave_value_list& args = octave_value_list ())
   {
-    return xsym ().find (args);
+    return sym->find (args);
   }
 
-  void mark_global (void) { xsym ().mark_global (); }
+  void mark_global (void) { sym->mark_global (); }
 
-  void mark_as_static (void) { xsym ().init_persistent (); }
+  void mark_as_static (void) { sym->init_persistent (); }
 
-  void mark_as_formal_parameter (void) { xsym ().mark_formal (); }
+  void mark_as_formal_parameter (void) { sym->mark_formal (); }
 
   // We really need to know whether this symbol referst to a variable
   // or a function, but we may not know that yet.
 
   bool lvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
@@ -109,38 +109,24 @@ public:
 
   void eval_undefined_error (void);
 
   tree_identifier *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
+  symbol_table::symbol_reference symbol (void) const
+  {
+    return sym;
+  }
 private:
 
   // The symbol record that this identifier references.
-  symbol_table::symbol_record sym;
-
-  symbol_table::scope_id scope;
-
-  // A script may be executed in multiple scopes.  If the last one was
-  // different from the one we are in now, update sym to be from the
-  // new scope.
-  symbol_table::symbol_record& xsym (void)
-  {
-    symbol_table::scope_id curr_scope = symbol_table::current_scope ();
-
-    if (scope != curr_scope || ! sym.is_valid ())
-      {
-        scope = curr_scope;
-        sym = symbol_table::insert (sym.name ());
-      }
-
-    return sym;
-  }
+  symbol_table::symbol_reference sym;
 
   // No copying!
 
   tree_identifier (const tree_identifier&);
 
   tree_identifier& operator = (const tree_identifier&);
 };
 
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -527,17 +527,17 @@ tree_index_expression::lvalue (void)
                 octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
                 if (error_state)
                   break;
 
                 bool autoconv = (tmp.is_zero_by_zero ()
                                  && (tmp.is_matrix_type () || tmp.is_string ()
                                      || tmp.is_cell ()));
 
-                if (i > 0 && type [i-1] == '(')
+                if (i > 0 && type[i-1] == '(')
                   {
                     octave_value_list pidx = idx.back ();
 
                     // Use octave_map, not octave_scalar_map so that the
                     // dimensions are 0x0, not 1x1.
                     if (tmp.is_undefined ())
                       {
                         if (pidx.has_magic_colon ())
diff --git a/src/pt-jit.cc b/src/pt-jit.cc
new file mode 100644
--- /dev/null
+++ b/src/pt-jit.cc
@@ -0,0 +1,1826 @@
+/*
+
+Copyright (C) 2012 Max Brister <max@2bass.com>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#define __STDC_LIMIT_MACROS
+#define __STDC_CONSTANT_MACROS
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef HAVE_LLVM
+
+#include "pt-jit.h"
+
+#include <llvm/Analysis/CallGraph.h>
+#include <llvm/Analysis/Passes.h>
+#include <llvm/Analysis/Verifier.h>
+#include <llvm/LLVMContext.h>
+#include <llvm/ExecutionEngine/ExecutionEngine.h>
+#include <llvm/ExecutionEngine/JIT.h>
+#include <llvm/Module.h>
+#include <llvm/PassManager.h>
+#include <llvm/Support/IRBuilder.h>
+#include <llvm/Support/raw_os_ostream.h>
+#include <llvm/Support/TargetSelect.h>
+#include <llvm/Target/TargetData.h>
+#include <llvm/Transforms/IPO.h>
+#include <llvm/Transforms/Scalar.h>
+
+#ifdef OCTAVE_JIT_DEBUG
+#include <llvm/Bitcode/ReaderWriter.h>
+#endif
+
+#include "symtab.h"
+#include "pt-all.h"
+
+static llvm::IRBuilder<> builder (llvm::getGlobalContext ());
+
+static llvm::LLVMContext& context = llvm::getGlobalContext ();
+
+// -------------------- jit_convert --------------------
+jit_convert::jit_convert (llvm::Module *module, tree &tee,
+                          jit_type *for_bounds)
+  : iterator_count (0), for_bounds_count (0), short_count (0), breaking (false)
+{
+  jit_instruction::reset_ids ();
+
+  entry_block = create<jit_block> ("body");
+  final_block = create<jit_block> ("final");
+  append (entry_block);
+  entry_block->mark_alive ();
+  block = entry_block;
+
+  if (for_bounds)
+    create_variable (next_for_bounds (false), for_bounds);
+
+  visit (tee);
+
+  // FIXME: Remove if we no longer only compile loops
+  assert (! breaking);
+  assert (breaks.empty ());
+  assert (continues.empty ());
+
+  block->append (create<jit_branch> (final_block));
+  append (final_block);
+
+  for (vmap_t::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
+    {
+      jit_variable *var = iter->second;
+      const std::string& name = var->name ();
+      if (name.size () && name[0] != '#')
+        final_block->append (create<jit_store_argument> (var));
+    }
+
+  construct_ssa ();
+
+  // initialize the worklist to instructions derived from constants
+  for (std::list<jit_value *>::iterator iter = constants.begin ();
+       iter != constants.end (); ++iter)
+    append_users (*iter);
+
+  // the entry block terminator may be a regular branch statement
+  if (entry_block->terminator ())
+    push_worklist (entry_block->terminator ());
+
+  // FIXME: Describe algorithm here
+  while (worklist.size ())
+    {
+      jit_instruction *next = worklist.front ();
+      worklist.pop_front ();
+      next->stash_in_worklist (false);
+
+      if (next->infer ())
+        {
+          // terminators need to be handles specially
+          if (jit_terminator *term = dynamic_cast<jit_terminator *> (next))
+            append_users_term (term);
+          else
+            append_users (next);
+        }
+    }
+
+  remove_dead ();
+  merge_blocks ();
+  final_block->label ();
+  place_releases ();
+  simplify_phi ();
+
+#ifdef OCTAVE_JIT_DEBUG
+  final_block->label ();
+  std::cout << "-------------------- Compiling tree --------------------\n";
+  std::cout << tee.str_print_code () << std::endl;
+  print_blocks ("octave jit ir");
+#endif
+
+  // for now just init arguments from entry, later we will have to do something
+  // more interesting
+  for (jit_block::iterator iter = entry_block->begin ();
+       iter != entry_block->end (); ++iter)
+    if (jit_extract_argument *extract
+        = dynamic_cast<jit_extract_argument *> (*iter))
+      arguments.push_back (std::make_pair (extract->name (), true));
+
+  convert_llvm to_llvm (*this);
+  function = to_llvm.convert (module, arguments, blocks, constants);
+
+#ifdef OCTAVE_JIT_DEBUG
+  std::cout << "-------------------- llvm ir --------------------";
+  llvm::raw_os_ostream llvm_cout (std::cout);
+  function->print (llvm_cout);
+  std::cout << std::endl;
+  llvm::verifyFunction (*function);
+#endif
+}
+
+jit_convert::~jit_convert (void)
+{
+  for (std::list<jit_value *>::iterator iter = all_values.begin ();
+       iter != all_values.end (); ++iter)
+    delete *iter;
+}
+
+void
+jit_convert::visit_anon_fcn_handle (tree_anon_fcn_handle&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_argument_list (tree_argument_list&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_binary_expression (tree_binary_expression& be)
+{
+  if (be.op_type () >= octave_value::num_binary_ops)
+    {
+      tree_boolean_expression *boole;
+      boole = dynamic_cast<tree_boolean_expression *> (&be);
+      assert (boole);
+      bool is_and = boole->op_type () == tree_boolean_expression::bool_and;
+
+      std::string short_name = next_shortcircut_result ();
+      jit_variable *short_result = create<jit_variable> (short_name);
+      vmap[short_name] = short_result;
+
+      jit_block *done = create<jit_block> (block->name ());
+      tree_expression *lhs = be.lhs ();
+      jit_value *lhsv = visit (lhs);
+      lhsv = create_checked (&jit_typeinfo::logically_true, lhsv);
+
+      jit_block *short_early = create<jit_block> ("short_early");
+      append (short_early);
+
+      jit_block *short_cont = create<jit_block> ("short_cont");
+
+      if (is_and)
+        block->append (create<jit_cond_branch> (lhsv, short_cont, short_early));
+      else
+        block->append (create<jit_cond_branch> (lhsv, short_early, short_cont));
+
+      block = short_early;
+
+      jit_value *early_result = create<jit_const_bool> (! is_and);
+      block->append (create<jit_assign> (short_result, early_result));
+      block->append (create<jit_branch> (done));
+
+      append (short_cont);
+      block = short_cont;
+
+      tree_expression *rhs = be.rhs ();
+      jit_value *rhsv = visit (rhs);
+      rhsv = create_checked (&jit_typeinfo::logically_true, rhsv);
+      block->append (create<jit_assign> (short_result, rhsv));
+      block->append (create<jit_branch> (done));
+
+      append (done);
+      block = done;
+      result = short_result;
+    }
+  else
+    {
+      tree_expression *lhs = be.lhs ();
+      jit_value *lhsv = visit (lhs);
+
+      tree_expression *rhs = be.rhs ();
+      jit_value *rhsv = visit (rhs);
+
+      const jit_operation& fn = jit_typeinfo::binary_op (be.op_type ());
+      result = create_checked (fn, lhsv, rhsv);
+    }
+}
+
+void
+jit_convert::visit_break_command (tree_break_command&)
+{
+  breaks.push_back (block);
+  breaking = true;
+}
+
+void
+jit_convert::visit_colon_expression (tree_colon_expression& expr)
+{
+  // in the futher we need to add support for classes and deal with rvalues
+  jit_value *base = visit (expr.base ());
+  jit_value *limit = visit (expr.limit ());
+  jit_value *increment;
+  tree_expression *tinc = expr.increment ();
+
+  if (tinc)
+    increment = visit (tinc);
+  else
+    increment = create<jit_const_scalar> (1);
+
+  result = block->append (create<jit_call> (jit_typeinfo::make_range, base,
+                                            limit, increment));
+}
+
+void
+jit_convert::visit_continue_command (tree_continue_command&)
+{
+  continues.push_back (block);
+  breaking = true;
+}
+
+void
+jit_convert::visit_global_command (tree_global_command&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_persistent_command (tree_persistent_command&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_decl_elt (tree_decl_elt&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_decl_init_list (tree_decl_init_list&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_simple_for_command (tree_simple_for_command& cmd)
+{
+  // Note we do an initial check to see if the loop will run atleast once.
+  // This allows us to get better type inference bounds on variables defined
+  // and used only inside the for loop (e.g. the index variable)
+
+  // If we are a nested for loop we need to store the previous breaks
+  assert (! breaking);
+  unwind_protect prot;
+  prot.protect_var (breaks);
+  prot.protect_var (continues);
+  prot.protect_var (breaking);
+  breaks.clear ();
+  continues.clear ();
+
+  // we need a variable for our iterator, because it is used in multiple blocks
+  std::string iter_name = next_iterator ();
+  jit_variable *iterator = create<jit_variable> (iter_name);
+  create<jit_variable> (iter_name);
+  vmap[iter_name] = iterator;
+
+  jit_block *body = create<jit_block> ("for_body");
+  append (body);
+
+  jit_block *tail = create<jit_block> ("for_tail");
+
+  // do control expression, iter init, and condition check in prev_block (block)
+  // if we are the top level for loop, the bounds is an input argument.
+  jit_value *control = find_variable (next_for_bounds ());
+  if (! control)
+    control = visit (cmd.control_expr ());
+  jit_call *init_iter = create<jit_call> (jit_typeinfo::for_init, control);
+  block->append (init_iter);
+  block->append (create<jit_assign> (iterator, init_iter));
+
+  jit_value *check = block->append (create<jit_call> (jit_typeinfo::for_check,
+                                                      control, iterator));
+  block->append (create<jit_cond_branch> (check, body, tail));
+  block = body;
+
+  // compute the syntactical iterator
+  jit_call *idx_rhs = create<jit_call> (jit_typeinfo::for_index, control,
+                                        iterator);
+  block->append (idx_rhs);
+  do_assign (cmd.left_hand_side (), idx_rhs);
+
+  // do loop
+  tree_statement_list *pt_body = cmd.body ();
+  pt_body->accept (*this);
+
+  if (breaking && continues.empty ())
+    {
+      // WTF are you doing user? Every branch was a continue, why did you have
+      // a loop??? Users are silly people...
+      finish_breaks (tail, breaks);
+      append (tail);
+      block = tail;
+      return;
+    }
+
+  // check our condition, continues jump to this block
+  jit_block *check_block = create<jit_block> ("for_check");
+  append (check_block);
+
+  if (! breaking)
+    block->append (create<jit_branch> (check_block));
+  finish_breaks (check_block, continues);
+
+  block = check_block;
+  const jit_operation& add_fn = jit_typeinfo::binary_op (octave_value::op_add);
+  jit_value *one = create<jit_const_index> (1);
+  jit_call *iter_inc = create<jit_call> (add_fn, iterator, one);
+  block->append (iter_inc);
+  block->append (create<jit_assign> (iterator, iter_inc));
+  check = block->append (create<jit_call> (jit_typeinfo::for_check, control,
+                                           iterator));
+  block->append (create<jit_cond_branch> (check, body, tail));
+
+  // breaks will go to our tail
+  append (tail);
+  finish_breaks (tail, breaks);
+  block = tail;
+}
+
+void
+jit_convert::visit_complex_for_command (tree_complex_for_command&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_octave_user_script (octave_user_script&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_octave_user_function (octave_user_function&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_octave_user_function_header (octave_user_function&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_octave_user_function_trailer (octave_user_function&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_function_def (tree_function_def&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_identifier (tree_identifier& ti)
+{
+  result = get_variable (ti.name ());
+}
+
+void
+jit_convert::visit_if_clause (tree_if_clause&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_if_command (tree_if_command& cmd)
+{
+  tree_if_command_list *lst = cmd.cmd_list ();
+  assert (lst); // jwe: Can this be null?
+  lst->accept (*this);
+}
+
+void
+jit_convert::visit_if_command_list (tree_if_command_list& lst)
+{
+  tree_if_clause *last = lst.back ();
+  size_t last_else = static_cast<size_t> (last->is_else_clause ());
+
+  // entry_blocks represents the block you need to enter in order to execute
+  // the condition check for the ith clause. For the else, it is simple the
+  // else body. If there is no else body, then it is padded with the tail
+  std::vector<jit_block *> entry_blocks (lst.size () + 1 - last_else);
+  std::vector<jit_block *> branch_blocks (lst.size (), 0); // final blocks
+  entry_blocks[0] = block;
+
+  // we need to construct blocks first, because they have jumps to eachother
+  tree_if_command_list::iterator iter = lst.begin ();
+  ++iter;
+  for (size_t i = 1; iter != lst.end (); ++iter, ++i)
+    {
+      tree_if_clause *tic = *iter;
+      if (tic->is_else_clause ())
+        entry_blocks[i] = create<jit_block> ("else");
+      else
+        entry_blocks[i] = create<jit_block> ("ifelse_cond");
+    }
+
+  jit_block *tail = create<jit_block> ("if_tail");
+  if (! last_else)
+    entry_blocks[entry_blocks.size () - 1] = tail;
+
+  size_t num_incomming = 0; // number of incomming blocks to our tail
+  iter = lst.begin ();
+  for (size_t i = 0; iter != lst.end (); ++iter, ++i)
+    {
+      tree_if_clause *tic = *iter;
+      block = entry_blocks[i];
+      assert (block);
+
+      if (i) // the first block is prev_block, so it has already been added
+        append (entry_blocks[i]);
+
+      if (! tic->is_else_clause ())
+        {
+          tree_expression *expr = tic->condition ();
+          jit_value *cond = visit (expr);
+          jit_call *check = create_checked (&jit_typeinfo::logically_true,
+                                            cond);
+          jit_block *body = create<jit_block> (i == 0 ? "if_body"
+                                               : "ifelse_body");
+          append (body);
+
+          jit_instruction *br = create<jit_cond_branch> (check, body,
+                                                        entry_blocks[i + 1]);
+          block->append (br);
+          block = body;
+        }
+
+      tree_statement_list *stmt_lst = tic->commands ();
+      assert (stmt_lst); // jwe: Can this be null?
+      stmt_lst->accept (*this);
+
+      if (breaking)
+        breaking = false;
+      else
+        {
+          ++num_incomming;
+          block->append (create<jit_branch> (tail));
+        }
+    }
+
+  if (num_incomming || ! last_else)
+    {
+      append (tail);
+      block = tail;
+    }
+  else
+    // every branch broke, so we don't have a tail
+    breaking = true;
+}
+
+void
+jit_convert::visit_index_expression (tree_index_expression& exp)
+{
+  std::pair<jit_value *, jit_value *> res = resolve (exp);
+  jit_value *object = res.first;
+  jit_value *index = res.second;
+
+  result = create_checked (jit_typeinfo::paren_subsref, object, index);
+}
+
+void
+jit_convert::visit_matrix (tree_matrix&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_cell (tree_cell&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_multi_assignment (tree_multi_assignment&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_no_op_command (tree_no_op_command&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_constant (tree_constant& tc)
+{
+  octave_value v = tc.rvalue1 ();
+  if (v.is_real_scalar () && v.is_double_type ())
+    {
+      double dv = v.double_value ();
+      result = create<jit_const_scalar> (dv);
+    }
+  else if (v.is_range ())
+    {
+      Range rv = v.range_value ();
+      result = create<jit_const_range> (rv);
+    }
+  else if (v.is_complex_scalar ())
+    {
+      Complex cv = v.complex_value ();
+      result = create<jit_const_complex> (cv);
+    }
+  else
+    throw jit_fail_exception ("Unknown constant");
+}
+
+void
+jit_convert::visit_fcn_handle (tree_fcn_handle&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_parameter_list (tree_parameter_list&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_postfix_expression (tree_postfix_expression&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_prefix_expression (tree_prefix_expression&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_return_command (tree_return_command&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_return_list (tree_return_list&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_simple_assignment (tree_simple_assignment& tsa)
+{
+  if (tsa.op_type () != octave_value::op_asn_eq)
+    throw jit_fail_exception ("Unsupported assign");
+
+  // resolve rhs
+  tree_expression *rhs = tsa.right_hand_side ();
+  jit_value *rhsv = visit (rhs);
+
+  result = do_assign (tsa.left_hand_side (), rhsv);
+}
+
+void
+jit_convert::visit_statement (tree_statement& stmt)
+{
+  tree_command *cmd = stmt.command ();
+  tree_expression *expr = stmt.expression ();
+
+  if (cmd)
+    visit (cmd);
+  else
+    {
+      // stolen from tree_evaluator::visit_statement
+      bool do_bind_ans = false;
+
+      if (expr->is_identifier ())
+        {
+          tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
+
+          do_bind_ans = (! id->is_variable ());
+        }
+      else
+        do_bind_ans = (! expr->is_assignment_expression ());
+
+      jit_value *expr_result = visit (expr);
+
+      if (do_bind_ans)
+        do_assign ("ans", expr_result, expr->print_result ());
+      else if (expr->is_identifier () && expr->print_result ())
+        {
+          // FIXME: ugly hack, we need to come up with a way to pass
+          // nargout to visit_identifier
+          const jit_operation& fn = jit_typeinfo::print_value ();
+          jit_const_string *name = create<jit_const_string> (expr->name ());
+          block->append (create<jit_call> (fn, name, expr_result));
+        }
+    }
+}
+
+void
+jit_convert::visit_statement_list (tree_statement_list& lst)
+{
+  for (tree_statement_list::iterator iter = lst.begin (); iter != lst.end();
+       ++iter)
+    {
+      tree_statement *elt = *iter;
+      // jwe: Can this ever be null?
+      assert (elt);
+      elt->accept (*this);
+
+      if (breaking)
+        break;
+    }
+}
+
+void
+jit_convert::visit_switch_case (tree_switch_case&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_switch_case_list (tree_switch_case_list&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_switch_command (tree_switch_command&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_try_catch_command (tree_try_catch_command&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_unwind_protect_command (tree_unwind_protect_command&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::visit_while_command (tree_while_command& wc)
+{
+  assert (! breaking);
+  unwind_protect prot;
+  prot.protect_var (breaks);
+  prot.protect_var (continues);
+  prot.protect_var (breaking);
+  breaks.clear ();
+  continues.clear ();
+
+  jit_block *cond_check = create<jit_block> ("while_cond_check");
+  block->append (create<jit_branch> (cond_check));
+  append (cond_check);
+  block = cond_check;
+
+  tree_expression *expr = wc.condition ();
+  assert (expr && "While expression can not be null");
+  jit_value *check = visit (expr);
+  check = create_checked (&jit_typeinfo::logically_true, check);
+
+  jit_block *body = create<jit_block> ("while_body");
+  append (body);
+
+  jit_block *tail = create<jit_block> ("while_tail");
+  block->append (create<jit_cond_branch> (check, body, tail));
+  block = body;
+
+  tree_statement_list *loop_body = wc.body ();
+  if (loop_body)
+    loop_body->accept (*this);
+
+  finish_breaks (tail, breaks);
+  finish_breaks (cond_check, continues);
+
+  if (! breaking)
+    block->append (create<jit_branch> (cond_check));
+
+  append (tail);
+  block = tail;
+}
+
+void
+jit_convert::visit_do_until_command (tree_do_until_command&)
+{
+  throw jit_fail_exception ();
+}
+
+void
+jit_convert::append (jit_block *ablock)
+{
+  blocks.push_back (ablock);
+  ablock->stash_location (--blocks.end ());
+}
+
+void
+jit_convert::insert_before (block_iterator iter, jit_block *ablock)
+{
+  iter = blocks.insert (iter, ablock);
+  ablock->stash_location (iter);
+}
+
+void
+jit_convert::insert_after (block_iterator iter, jit_block *ablock)
+{
+  ++iter;
+  insert_before (iter, ablock);
+}
+
+jit_variable *
+jit_convert::find_variable (const std::string& vname) const
+{
+  vmap_t::const_iterator iter;
+  iter = vmap.find (vname);
+  return iter != vmap.end () ? iter->second : 0;
+}
+
+jit_variable *
+jit_convert::get_variable (const std::string& vname)
+{
+  jit_variable *ret = find_variable (vname);
+  if (ret)
+    return ret;
+
+  octave_value val = symbol_table::find (vname);
+  jit_type *type = jit_typeinfo::type_of (val);
+  return create_variable (vname, type);
+}
+
+jit_variable *
+jit_convert::create_variable (const std::string& vname, jit_type *type)
+{
+  jit_variable *var = create<jit_variable> (vname);
+  jit_extract_argument *extract;
+  extract = create<jit_extract_argument> (type, var);
+  entry_block->prepend (extract);
+  return vmap[vname] = var;
+}
+
+std::string
+jit_convert::next_name (const char *prefix, size_t& count, bool inc)
+{
+  std::stringstream ss;
+  ss << prefix << count;
+  if (inc)
+    ++count;
+  return ss.str ();
+}
+
+std::pair<jit_value *, jit_value *>
+jit_convert::resolve (tree_index_expression& exp)
+{
+  std::string type = exp.type_tags ();
+  if (! (type.size () == 1 && type[0] == '('))
+    throw jit_fail_exception ("Unsupported index operation");
+
+  std::list<tree_argument_list *> args = exp.arg_lists ();
+  if (args.size () != 1)
+    throw jit_fail_exception ("Bad number of arguments in tree_index_expression");
+
+  tree_argument_list *arg_list = args.front ();
+  if (! arg_list)
+    throw jit_fail_exception ("null argument list");
+
+  if (arg_list->size () != 1)
+    throw jit_fail_exception ("Bad number of arguments in arg_list");
+
+  tree_expression *tree_object = exp.expression ();
+  jit_value *object = visit (tree_object);
+  tree_expression *arg0 = arg_list->front ();
+  jit_value *index = visit (arg0);
+
+  return std::make_pair (object, index);
+}
+
+jit_value *
+jit_convert::do_assign (tree_expression *exp, jit_value *rhs, bool artificial)
+{
+  if (! exp)
+    throw jit_fail_exception ("NULL lhs in assign");
+
+  if (isa<tree_identifier> (exp))
+    return do_assign (exp->name (), rhs, exp->print_result (), artificial);
+  else if (tree_index_expression *idx
+           = dynamic_cast<tree_index_expression *> (exp))
+    {
+      std::pair<jit_value *, jit_value *> res = resolve (*idx);
+      jit_value *object = res.first;
+      jit_value *index = res.second;
+      jit_call *new_object = create<jit_call> (&jit_typeinfo::paren_subsasgn,
+                                               object, index, rhs);
+      block->append (new_object);
+      do_assign (idx->expression (), new_object, true);
+      create_check (new_object);
+
+      // FIXME: Will not work for values that must be release/grabed
+      return rhs;
+    }
+  else
+    throw jit_fail_exception ("Unsupported assignment");
+}
+
+jit_value *
+jit_convert::do_assign (const std::string& lhs, jit_value *rhs,
+                        bool print, bool artificial)
+{
+  jit_variable *var = get_variable (lhs);
+  jit_assign *assign = block->append (create<jit_assign> (var, rhs));
+
+  if (artificial)
+    assign->mark_artificial ();
+
+  if (print)
+    {
+      const jit_operation& print_fn = jit_typeinfo::print_value ();
+      jit_const_string *name = create<jit_const_string> (lhs);
+      block->append (create<jit_call> (print_fn, name, var));
+    }
+
+  return var;
+}
+
+jit_value *
+jit_convert::visit (tree& tee)
+{
+  result = 0;
+  tee.accept (*this);
+
+  jit_value *ret = result;
+  result = 0;
+  return ret;
+}
+
+void
+jit_convert::append_users_term (jit_terminator *term)
+{
+  for (size_t i = 0; i < term->successor_count (); ++i)
+    {
+      if (term->alive (i))
+        {
+          jit_block *succ = term->successor (i);
+          for (jit_block::iterator iter = succ->begin (); iter != succ->end ()
+                 && isa<jit_phi> (*iter); ++iter)
+            push_worklist (*iter);
+
+          jit_terminator *sterm = succ->terminator ();
+          if (sterm)
+            push_worklist (sterm);
+        }
+    }
+}
+
+void
+jit_convert::merge_blocks (void)
+{
+  std::vector<jit_block *> dead;
+  for (block_list::iterator iter = blocks.begin (); iter != blocks.end ();
+       ++iter)
+    {
+      jit_block *b = *iter;
+      jit_block *merged = b->maybe_merge ();
+
+      if (merged)
+        {
+          if (merged == final_block)
+            final_block = b;
+
+          if (merged == entry_block)
+            entry_block = b;
+
+          dead.push_back (merged);
+        }
+    }
+
+  for (size_t i = 0; i < dead.size (); ++i)
+    blocks.erase (dead[i]->location ());
+}
+
+void
+jit_convert::construct_ssa (void)
+{
+  merge_blocks ();
+  final_block->label ();
+  final_block->compute_idom (entry_block);
+  entry_block->compute_df ();
+  entry_block->create_dom_tree ();
+
+  // insert phi nodes where needed, this is done on a per variable basis
+  for (vmap_t::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
+    {
+      jit_block::df_set visited, added_phi;
+      std::list<jit_block *> ssa_worklist;
+      iter->second->use_blocks (visited);
+      ssa_worklist.insert (ssa_worklist.begin (), visited.begin (),
+                           visited.end ());
+
+      while (ssa_worklist.size ())
+        {
+          jit_block *b = ssa_worklist.front ();
+          ssa_worklist.pop_front ();
+
+          for (jit_block::df_iterator diter = b->df_begin ();
+               diter != b->df_end (); ++diter)
+            {
+              jit_block *dblock = *diter;
+              if (! added_phi.count (dblock))
+                {
+                  jit_phi *phi = create<jit_phi> (iter->second,
+                                                  dblock->use_count ());
+                  dblock->prepend (phi);
+                  added_phi.insert (dblock);
+                }
+
+              if (! visited.count (dblock))
+                {
+                  ssa_worklist.push_back (dblock);
+                  visited.insert (dblock);
+                }
+            }
+        }
+    }
+
+  do_construct_ssa (*entry_block, entry_block->visit_count ());
+}
+
+void
+jit_convert::do_construct_ssa (jit_block& ablock, size_t avisit_count)
+{
+  if (ablock.visited (avisit_count))
+    return;
+
+  // replace variables with their current SSA value
+  for (jit_block::iterator iter = ablock.begin (); iter != ablock.end (); ++iter)
+    {
+      jit_instruction *instr = *iter;
+      instr->construct_ssa ();
+      instr->push_variable ();
+    }
+
+  // finish phi nodes of successors
+  for (size_t i = 0; i < ablock.successor_count (); ++i)
+    {
+      jit_block *finish = ablock.successor (i);
+
+      for (jit_block::iterator iter = finish->begin (); iter != finish->end ()
+             && isa<jit_phi> (*iter);)
+        {
+          jit_phi *phi = static_cast<jit_phi *> (*iter);
+          jit_variable *var = phi->dest ();
+          if (var->has_top ())
+            {
+              phi->add_incomming (&ablock, var->top ());
+              ++iter;
+            }
+          else
+            {
+              // temporaries may have extranious phi nodes which can be removed
+              assert (! phi->use_count ());
+              assert (var->name ().size () && var->name ()[0] == '#');
+              iter = finish->remove (iter);
+            }
+        }
+    }
+
+  for (size_t i = 0; i < ablock.dom_successor_count (); ++i)
+    do_construct_ssa (*ablock.dom_successor (i), avisit_count);
+
+  ablock.pop_all ();
+}
+
+void
+jit_convert::remove_dead ()
+{
+  block_list::iterator biter;
+  for (biter = blocks.begin (); biter != blocks.end (); ++biter)
+    {
+      jit_block *b = *biter;
+      if (b->alive ())
+        {
+          for (jit_block::iterator iter = b->begin (); iter != b->end ()
+                 && isa<jit_phi> (*iter);)
+            {
+              jit_phi *phi = static_cast<jit_phi *> (*iter);
+              if (phi->prune ())
+                iter = b->remove (iter);
+              else
+                ++iter;
+            }
+        }
+    }
+
+  for (biter = blocks.begin (); biter != blocks.end ();)
+    {
+      jit_block *b = *biter;
+      if (b->alive ())
+        {
+          // FIXME: A special case for jit_error_check, if we generalize to
+          // we will need to change!
+          jit_terminator *term = b->terminator ();
+          if (term && term->successor_count () == 2 && ! term->alive (0))
+            {
+              jit_block *succ = term->successor (1);
+              term->remove ();
+              jit_branch *abreak = b->append (create<jit_branch> (succ));
+              abreak->infer ();
+            }
+
+          ++biter;
+        }
+      else
+        {
+          jit_terminator *term = b->terminator ();
+          if (term)
+            term->remove ();
+          biter = blocks.erase (biter);
+        }
+    }
+}
+
+void
+jit_convert::place_releases (void)
+{
+  std::set<jit_value *> temporaries;
+  for (block_list::iterator iter = blocks.begin (); iter != blocks.end ();
+       ++iter)
+    {
+      jit_block& ablock = **iter;
+      if (ablock.id () != jit_block::NO_ID)
+        {
+          release_temp (ablock, temporaries);
+          release_dead_phi (ablock);
+        }
+    }
+}
+
+void
+jit_convert::release_temp (jit_block& ablock, std::set<jit_value *>& temp)
+{
+  for (jit_block::iterator iter = ablock.begin (); iter != ablock.end ();
+       ++iter)
+    {
+      jit_instruction *instr = *iter;
+
+      // check for temporaries that require release and live across
+      // multiple blocks
+      if (instr->needs_release ())
+        {
+          jit_block *fu_block = instr->first_use_block ();
+          if (fu_block && fu_block != &ablock)
+            temp.insert (instr);
+        }
+
+      if (isa<jit_call> (instr))
+        {
+          // place releases for temporary arguments
+          for (size_t i = 0; i < instr->argument_count (); ++i)
+            {
+              jit_value *arg = instr->argument (i);
+              if (arg->needs_release ())
+                {
+                  jit_call *release = create<jit_call> (&jit_typeinfo::release,
+                                                        arg);
+                  release->infer ();
+                  ablock.insert_after (iter, release);
+                  ++iter;
+                  temp.erase (arg);
+                }
+            }
+        }
+    }
+
+  if (! temp.size () || ! isa<jit_error_check> (ablock.terminator ()))
+    return;
+
+  // FIXME: If we support try/catch or unwind_protect final_block may not be the
+  // destination
+  jit_block *split = ablock.maybe_split (*this, final_block);
+  jit_terminator *term = split->terminator ();
+  for (std::set<jit_value *>::const_iterator iter = temp.begin ();
+       iter != temp.end (); ++iter)
+    {
+      jit_value *value = *iter;
+      jit_call *release = create<jit_call> (&jit_typeinfo::release, value);
+      split->insert_before (term, release);
+      release->infer ();
+    }
+}
+
+void
+jit_convert::release_dead_phi (jit_block& ablock)
+{
+  jit_block::iterator iter = ablock.begin ();
+  while (iter != ablock.end () && isa<jit_phi> (*iter))
+    {
+      jit_phi *phi = static_cast<jit_phi *> (*iter);
+      ++iter;
+
+      jit_use *use = phi->first_use ();
+      if (phi->use_count () == 1 && isa<jit_assign> (use->user ()))
+        {
+          // instead of releasing on assign, release on all incomming branches,
+          // this can get rid of casts inside loops
+          for (size_t i = 0; i < phi->argument_count (); ++i)
+            {
+              jit_value *arg = phi->argument (i);
+              jit_block *inc = phi->incomming (i);
+              jit_block *split = inc->maybe_split (*this, ablock);
+              jit_terminator *term = split->terminator ();
+              jit_call *release = create<jit_call> (jit_typeinfo::release, arg);
+              release->infer ();
+              split->insert_before (term, release);
+            }
+
+          phi->replace_with (0);
+          phi->remove ();
+        }
+    }
+}
+
+void
+jit_convert::simplify_phi (void)
+{
+  for (block_list::iterator biter = blocks.begin (); biter != blocks.end ();
+       ++biter)
+    {
+      jit_block &ablock = **biter;
+      for (jit_block::iterator iter = ablock.begin (); iter != ablock.end ()
+             && isa<jit_phi> (*iter); ++iter)
+        simplify_phi (*static_cast<jit_phi *> (*iter));
+    }
+}
+
+void
+jit_convert::simplify_phi (jit_phi& phi)
+{
+  jit_block& pblock = *phi.parent ();
+  const jit_operation& cast_fn = jit_typeinfo::cast (phi.type ());
+  jit_variable *dest = phi.dest ();
+  for (size_t i = 0; i < phi.argument_count (); ++i)
+    {
+      jit_value *arg = phi.argument (i);
+      if (arg->type () != phi.type ())
+        {
+          jit_block *pred = phi.incomming (i);
+          jit_block *split = pred->maybe_split (*this, pblock);
+          jit_terminator *term = split->terminator ();
+          jit_instruction *cast = create<jit_call> (cast_fn, arg);
+          jit_assign *assign = create<jit_assign> (dest, cast);
+
+          split->insert_before (term, cast);
+          split->insert_before (term, assign);
+          cast->infer ();
+          assign->infer ();
+          phi.stash_argument (i, assign);
+        }
+    }
+}
+
+void
+jit_convert::finish_breaks (jit_block *dest, const block_list& lst)
+{
+  for (block_list::const_iterator iter = lst.begin (); iter != lst.end ();
+       ++iter)
+    {
+      jit_block *b = *iter;
+      b->append (create<jit_branch> (dest));
+    }
+}
+
+// -------------------- jit_convert::convert_llvm --------------------
+llvm::Function *
+jit_convert::convert_llvm::convert (llvm::Module *module,
+                                    const std::vector<std::pair< std::string, bool> >& args,
+                                    const std::list<jit_block *>& blocks,
+                                    const std::list<jit_value *>& constants)
+{
+  jit_type *any = jit_typeinfo::get_any ();
+
+  // argument is an array of octave_base_value*, or octave_base_value**
+  llvm::Type *arg_type = any->to_llvm (); // this is octave_base_value*
+  arg_type = arg_type->getPointerTo ();
+  llvm::FunctionType *ft = llvm::FunctionType::get (llvm::Type::getVoidTy (context),
+                                                    arg_type, false);
+  function = llvm::Function::Create (ft, llvm::Function::ExternalLinkage,
+                                     "foobar", module);
+
+  try
+    {
+      prelude = llvm::BasicBlock::Create (context, "prelude", function);
+      builder.SetInsertPoint (prelude);
+
+      llvm::Value *arg = function->arg_begin ();
+      for (size_t i = 0; i < args.size (); ++i)
+        {
+          llvm::Value *loaded_arg = builder.CreateConstInBoundsGEP1_32 (arg, i);
+          arguments[args[i].first] = loaded_arg;
+        }
+
+      std::list<jit_block *>::const_iterator biter;
+      for (biter = blocks.begin (); biter != blocks.end (); ++biter)
+        {
+          jit_block *jblock = *biter;
+          llvm::BasicBlock *block = llvm::BasicBlock::Create (context,
+                                                              jblock->name (),
+                                                              function);
+          jblock->stash_llvm (block);
+        }
+
+      jit_block *first = *blocks.begin ();
+      builder.CreateBr (first->to_llvm ());
+
+      // constants aren't in the IR, we visit those first
+      for (std::list<jit_value *>::const_iterator iter = constants.begin ();
+           iter != constants.end (); ++iter)
+        if (! isa<jit_instruction> (*iter))
+          visit (*iter);
+
+      // convert all instructions
+      for (biter = blocks.begin (); biter != blocks.end (); ++biter)
+        visit (*biter);
+
+      // now finish phi nodes
+      for (biter = blocks.begin (); biter != blocks.end (); ++biter)
+        {
+          jit_block& block = **biter;
+          for (jit_block::iterator piter = block.begin ();
+               piter != block.end () && isa<jit_phi> (*piter); ++piter)
+            {
+              jit_instruction *phi = *piter;
+              finish_phi (static_cast<jit_phi *> (phi));
+            }
+        }
+
+      jit_block *last = blocks.back ();
+      builder.SetInsertPoint (last->to_llvm ());
+      builder.CreateRetVoid ();
+    } catch (const jit_fail_exception& e)
+    {
+      function->eraseFromParent ();
+      throw;
+    }
+
+  return function;
+}
+
+void
+jit_convert::convert_llvm::finish_phi (jit_phi *phi)
+{
+  llvm::PHINode *llvm_phi = phi->to_llvm ();
+  for (size_t i = 0; i < phi->argument_count (); ++i)
+    {
+      llvm::BasicBlock *pred = phi->incomming_llvm (i);
+      llvm_phi->addIncoming (phi->argument_llvm (i), pred);
+    }
+}
+
+void
+jit_convert::convert_llvm::visit (jit_const_string& cs)
+{
+  cs.stash_llvm (builder.CreateGlobalStringPtr (cs.value ()));
+}
+
+void
+jit_convert::convert_llvm::visit (jit_const_bool& cb)
+{
+  cb.stash_llvm (llvm::ConstantInt::get (cb.type_llvm (), cb.value ()));
+}
+
+void
+jit_convert::convert_llvm::visit (jit_const_scalar& cs)
+{
+  cs.stash_llvm (llvm::ConstantFP::get (cs.type_llvm (), cs.value ()));
+}
+
+void
+jit_convert::convert_llvm::visit (jit_const_complex& cc)
+{
+  llvm::Type *scalar_t = jit_typeinfo::get_scalar_llvm ();
+  llvm::Constant *values[2];
+  Complex value = cc.value ();
+  values[0] = llvm::ConstantFP::get (scalar_t, value.real ());
+  values[1] = llvm::ConstantFP::get (scalar_t, value.imag ());
+  cc.stash_llvm (llvm::ConstantVector::get (values));
+}
+
+void jit_convert::convert_llvm::visit (jit_const_index& ci)
+{
+  ci.stash_llvm (llvm::ConstantInt::get (ci.type_llvm (), ci.value ()));
+}
+
+void
+jit_convert::convert_llvm::visit (jit_const_range& cr)
+{
+  llvm::StructType *stype = llvm::cast<llvm::StructType>(cr.type_llvm ());
+  llvm::Type *scalar_t = jit_typeinfo::get_scalar_llvm ();
+  llvm::Type *idx = jit_typeinfo::get_index_llvm ();
+  const jit_range& rng = cr.value ();
+
+  llvm::Constant *constants[4];
+  constants[0] = llvm::ConstantFP::get (scalar_t, rng.base);
+  constants[1] = llvm::ConstantFP::get (scalar_t, rng.limit);
+  constants[2] = llvm::ConstantFP::get (scalar_t, rng.inc);
+  constants[3] = llvm::ConstantInt::get (idx, rng.nelem);
+
+  llvm::Value *as_llvm;
+  as_llvm = llvm::ConstantStruct::get (stype,
+                                       llvm::makeArrayRef (constants, 4));
+  cr.stash_llvm (as_llvm);
+}
+
+void
+jit_convert::convert_llvm::visit (jit_block& b)
+{
+  llvm::BasicBlock *block = b.to_llvm ();
+  builder.SetInsertPoint (block);
+  for (jit_block::iterator iter = b.begin (); iter != b.end (); ++iter)
+    visit (*iter);
+}
+
+void
+jit_convert::convert_llvm::visit (jit_branch& b)
+{
+  b.stash_llvm (builder.CreateBr (b.successor_llvm ()));
+}
+
+void
+jit_convert::convert_llvm::visit (jit_cond_branch& cb)
+{
+  llvm::Value *cond = cb.cond_llvm ();
+  llvm::Value *br;
+  br = builder.CreateCondBr (cond, cb.successor_llvm (0),
+                             cb.successor_llvm (1));
+  cb.stash_llvm (br);
+}
+
+void
+jit_convert::convert_llvm::visit (jit_call& call)
+{
+  const jit_function& ol = call.overload ();
+
+  std::vector<jit_value *> args (call.arguments ().size ());
+  for (size_t i = 0; i < args.size (); ++i)
+    args[i] = call.argument (i);
+
+  llvm::Value *ret = ol.call (builder, args);
+  call.stash_llvm (ret);
+}
+
+void
+jit_convert::convert_llvm::visit (jit_extract_argument& extract)
+{
+  llvm::Value *arg = arguments[extract.name ()];
+  assert (arg);
+  arg = builder.CreateLoad (arg);
+
+  const jit_function& ol = extract.overload ();
+  extract.stash_llvm (ol.call (builder, arg));
+}
+
+void
+jit_convert::convert_llvm::visit (jit_store_argument& store)
+{
+  const jit_function& ol = store.overload ();
+  llvm::Value *arg_value = ol.call (builder, store.result ());
+  llvm::Value *arg = arguments[store.name ()];
+  store.stash_llvm (builder.CreateStore (arg_value, arg));
+}
+
+void
+jit_convert::convert_llvm::visit (jit_phi& phi)
+{
+  // we might not have converted all incoming branches, so we don't
+  // set incomming branches now
+  llvm::PHINode *node = llvm::PHINode::Create (phi.type_llvm (),
+                                               phi.argument_count ());
+  builder.Insert (node);
+  phi.stash_llvm (node);
+}
+
+void
+jit_convert::convert_llvm::visit (jit_variable&)
+{
+  throw jit_fail_exception ("ERROR: SSA construction should remove all variables");
+}
+
+void
+jit_convert::convert_llvm::visit (jit_error_check& check)
+{
+  llvm::Value *cond = jit_typeinfo::insert_error_check (builder);
+  llvm::Value *br = builder.CreateCondBr (cond, check.successor_llvm (0),
+                                          check.successor_llvm (1));
+  check.stash_llvm (br);
+}
+
+void
+jit_convert::convert_llvm::visit (jit_assign& assign)
+{
+  jit_value *new_value = assign.src ();
+  assign.stash_llvm (new_value->to_llvm ());
+
+  if (assign.artificial ())
+    return;
+
+  if (isa<jit_assign_base> (new_value))
+    {
+      const jit_function& ol =  jit_typeinfo::get_grab (new_value->type ());
+      if (ol.valid ())
+        assign.stash_llvm (ol.call (builder, new_value));
+    }
+
+  jit_value *overwrite = assign.overwrite ();
+  if (isa<jit_assign_base> (overwrite))
+    {
+      const jit_function& ol = jit_typeinfo::get_release (overwrite->type ());
+      ol.call (builder, overwrite);
+    }
+}
+
+void
+jit_convert::convert_llvm::visit (jit_argument&)
+{}
+
+// -------------------- tree_jit --------------------
+
+tree_jit::tree_jit (void) : module (0), engine (0)
+{
+}
+
+tree_jit::~tree_jit (void)
+{}
+
+bool
+tree_jit::execute (tree_simple_for_command& cmd, const octave_value& bounds)
+{
+  const size_t MIN_TRIP_COUNT = 1000;
+
+  size_t tc = trip_count (bounds);
+  if (! tc || ! initialize ())
+    return false;
+
+  jit_info::vmap extra_vars;
+  extra_vars["#for_bounds0"] = &bounds;
+
+  jit_info *info = cmd.get_info ();
+  if (! info || ! info->match (extra_vars))
+    {
+      if (tc < MIN_TRIP_COUNT)
+        return false;
+
+      delete info;
+      info = new jit_info (*this, cmd, bounds);
+      cmd.stash_info (info);
+    }
+
+  return info->execute (extra_vars);
+}
+
+bool
+tree_jit::execute (tree_while_command& cmd)
+{
+  if (! initialize ())
+    return false;
+
+  jit_info *info = cmd.get_info ();
+  if (! info || ! info->match ())
+    {
+      delete info;
+      info = new jit_info (*this, cmd);
+      cmd.stash_info (info);
+    }
+
+  return info->execute ();
+}
+
+bool
+tree_jit::initialize (void)
+{
+  if (engine)
+    return true;
+
+  if (! module)
+    {
+      llvm::InitializeNativeTarget ();
+      module = new llvm::Module ("octave", context);
+    }
+
+  // sometimes this fails pre main
+  engine = llvm::ExecutionEngine::createJIT (module);
+
+  if (! engine)
+    return false;
+
+  module_pass_manager = new llvm::PassManager ();
+  module_pass_manager->add (llvm::createAlwaysInlinerPass ());
+
+  pass_manager = new llvm::FunctionPassManager (module);
+  pass_manager->add (new llvm::TargetData(*engine->getTargetData ()));
+  pass_manager->add (llvm::createBasicAliasAnalysisPass ());
+  pass_manager->add (llvm::createPromoteMemoryToRegisterPass ());
+  pass_manager->add (llvm::createInstructionCombiningPass ());
+  pass_manager->add (llvm::createReassociatePass ());
+  pass_manager->add (llvm::createGVNPass ());
+  pass_manager->add (llvm::createCFGSimplificationPass ());
+  pass_manager->doInitialization ();
+
+  jit_typeinfo::initialize (module, engine);
+
+  return true;
+}
+
+size_t
+tree_jit::trip_count (const octave_value& bounds) const
+{
+  if (bounds.is_range ())
+    {
+      Range rng = bounds.range_value ();
+      return rng.nelem ();
+    }
+
+  // unsupported type
+  return 0;
+}
+
+
+void
+tree_jit::optimize (llvm::Function *fn)
+{
+  module_pass_manager->run (*module);
+  pass_manager->run (*fn);
+
+#ifdef OCTAVE_JIT_DEBUG
+  std::string error;
+  llvm::raw_fd_ostream fout ("test.bc", error,
+                             llvm::raw_fd_ostream::F_Binary);
+  llvm::WriteBitcodeToFile (module, fout);
+#endif
+}
+
+// -------------------- jit_info --------------------
+jit_info::jit_info (tree_jit& tjit, tree& tee)
+  : engine (tjit.get_engine ()), function (0), llvm_function (0)
+{
+  try
+    {
+      jit_convert conv (tjit.get_module (), tee);
+      initialize (tjit, conv);
+    }
+  catch (const jit_fail_exception& e)
+    {
+#ifdef OCTAVE_JIT_DEBUG
+      if (e.known ())
+        std::cout << "jit fail: " << e.what () << std::endl;
+#endif
+    }
+}
+
+jit_info::jit_info (tree_jit& tjit, tree& tee, const octave_value& for_bounds)
+  : engine (tjit.get_engine ()), function (0), llvm_function (0)
+{
+  try
+    {
+      jit_convert conv (tjit.get_module (), tee,
+                        jit_typeinfo::type_of (for_bounds));
+      initialize (tjit, conv);
+    }
+  catch (const jit_fail_exception& e)
+    {
+#ifdef OCTAVE_JIT_DEBUG
+      if (e.known ())
+        std::cout << "jit fail: " << e.what () << std::endl;
+#endif
+    }
+}
+
+jit_info::~jit_info (void)
+{
+  if (llvm_function)
+    llvm_function->eraseFromParent ();
+}
+
+bool
+jit_info::execute (const vmap& extra_vars) const
+{
+  if (! function)
+    return false;
+
+  std::vector<octave_base_value *> real_arguments (arguments.size ());
+  for (size_t i = 0; i < arguments.size (); ++i)
+    {
+      if (arguments[i].second)
+        {
+          octave_value current = find (extra_vars, arguments[i].first);
+          octave_base_value *obv = current.internal_rep ();
+          obv->grab ();
+          real_arguments[i] = obv;
+        }
+    }
+
+  function (&real_arguments[0]);
+
+  for (size_t i = 0; i < arguments.size (); ++i)
+    {
+      const std::string& name = arguments[i].first;
+
+      // do not store for loop bounds temporary
+      if (name.size () && name[0] != '#')
+        symbol_table::varref (arguments[i].first) = real_arguments[i];
+    }
+
+  return true;
+}
+
+bool
+jit_info::match (const vmap& extra_vars) const
+{
+  if (! function)
+    return true;
+
+  for (size_t i = 0; i < bounds.size (); ++i)
+    {
+      const std::string& arg_name = bounds[i].second;
+      octave_value value = find (extra_vars, arg_name);
+      jit_type *type = jit_typeinfo::type_of (value);
+
+      // FIXME: Check for a parent relationship
+      if (type != bounds[i].first)
+        return false;
+    }
+
+  return true;
+}
+
+void
+jit_info::initialize (tree_jit& tjit, jit_convert& conv)
+{
+  llvm_function = conv.get_function ();
+  arguments = conv.get_arguments ();
+  bounds = conv.get_bounds ();
+
+  if (llvm_function)
+    {
+      tjit.optimize (llvm_function);
+
+#ifdef OCTAVE_JIT_DEBUG
+      std::cout << "-------------------- optimized llvm ir "
+                << "--------------------\n";
+      llvm::raw_os_ostream llvm_cout (std::cout);
+      llvm_function->print (llvm_cout);
+      llvm_cout.flush ();
+      std::cout << std::endl;
+#endif
+
+      void *void_fn = engine->getPointerToFunction (llvm_function);
+      function = reinterpret_cast<jited_function> (void_fn);
+    }
+}
+
+octave_value
+jit_info::find (const vmap& extra_vars, const std::string& vname) const
+{
+  vmap::const_iterator iter = extra_vars.find (vname);
+  return iter == extra_vars.end () ? symbol_table::varval (vname)
+    : *iter->second;
+}
+
+#endif
+
+
+/*
+Test some simple cases that compile.
+
+%!test
+%! inc = 1e-5;
+%! result = 0;
+%! for ii = 0:inc:1
+%!   result = result + inc * (1/3 * ii * ii);
+%! endfor
+%! assert (abs (result - 1/9) < 1e-5);
+
+%!test
+%! inc = 1e-5;
+%! result = 0;
+%! for ii = 0:inc:1
+%!   # the ^ operator's result is complex
+%!   result = result + inc * (1/3 * ii ^ 2);
+%! endfor
+%! assert (abs (result - 1/9) < 1e-5);
+
+%!test
+%! nr = 1001;
+%! mat = zeros (1, nr);
+%! for i = 1:nr
+%!   mat(i) = i;
+%! endfor
+%! assert (mat == 1:nr);
+
+%!test
+%! nr = 1001;
+%! mat = 1:nr;
+%! mat(end) = 0; # force mat to a matrix
+%! total = 0;
+%! for i = 1:nr
+%!   total = mat(i) + total;
+%! endfor
+%! assert (sum (mat) == total);
+
+%!test
+%! nr = 1001;
+%! mat = [3 1 5];
+%! try
+%!   for i = 1:nr
+%!     if i > 500
+%!       result = mat(100);
+%!     else
+%!       result = i;
+%!     endif
+%!   endfor
+%! catch
+%! end
+%! assert (result == 500);
+
+%!function result = gen_test (n)
+%!  result = double (rand (1, n) > .01);
+%!endfunction
+
+%!function z = vectorized (A, K)
+%!  temp = ones (1, K);
+%!  z = conv (A, temp);
+%!  z = z > K-1;
+%!  z = conv (z, temp);
+%!  z = z(K:end-K+1);
+%!  z = z >= 1;
+%!endfunction
+
+%!function z = loopy (A, K)
+%!  z = A;
+%!  n = numel (A);
+%!  counter = 0;
+%!  for ii=1:n
+%!    if z(ii)
+%!      counter = counter + 1;
+%!    else
+%!      if counter > 0 && counter < K
+%!        z(ii-counter:ii-1) = 0;
+%!      endif
+%!      counter = 0;
+%!    endif
+%!  endfor
+%!
+%!  if counter > 0 && counter < K
+%!    z(end-counter+1:end) = 0;
+%!  endif
+%!endfunction
+
+%!test
+%! test_set = gen_test (10000);
+%! assert (all (vectorized (test_set, 3) == loopy (test_set, 3)));
+
+%!test
+%! niter = 1001;
+%! i = 0;
+%! while (i < niter)
+%!   i = i + 1;
+%! endwhile
+%! assert (i == niter);
+
+*/
diff --git a/src/pt-jit.h b/src/pt-jit.h
new file mode 100644
--- /dev/null
+++ b/src/pt-jit.h
@@ -0,0 +1,487 @@
+/*
+
+Copyright (C) 2012 Max Brister <max@2bass.com>
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_tree_jit_h)
+#define octave_tree_jit_h 1
+
+#ifdef HAVE_LLVM
+
+#include "jit-ir.h"
+
+#include "pt-walk.h"
+
+// -------------------- Current status --------------------
+// Simple binary operations (+-*/) on octave_scalar's (doubles) are optimized.
+// a = 5;
+// b = a * 5 + a;
+//
+// Indexing matrices with scalars works.
+//
+// if, elseif, else, break, continue, and for compile. Compilation is triggered
+// at the start of a simple for loop.
+//
+// The octave low level IR is a linear IR, it works by converting everything to
+// calls to jit_operations. This turns expressions like c = a + b into
+// c = call binary+ (a, b)
+// The jit_operations contain information about overloads for different types.
+// For, example, if we know a and b are scalars, then c must also be a scalar.
+//
+// Support for function calls is in progress. Currently, calls to sin with a
+// scalar argument will compile.
+//
+// TODO:
+// 1. Function calls (In progress)
+// 2. Cleanup/documentation
+// 3. ...
+// ---------------------------------------------------------
+
+// convert between IRs
+// FIXME: Class relationships are messy from here on down. They need to be
+// cleaned up.
+class
+jit_convert : public tree_walker
+{
+public:
+  typedef std::pair<jit_type *, std::string> type_bound;
+  typedef std::vector<type_bound> type_bound_vector;
+
+  jit_convert (llvm::Module *module, tree &tee, jit_type *for_bounds = 0);
+
+  ~jit_convert (void);
+
+  llvm::Function *get_function (void) const { return function; }
+
+  const std::vector<std::pair<std::string, bool> >& get_arguments(void) const
+  { return arguments; }
+
+  const type_bound_vector& get_bounds (void) const { return bounds; }
+
+  void visit_anon_fcn_handle (tree_anon_fcn_handle&);
+
+  void visit_argument_list (tree_argument_list&);
+
+  void visit_binary_expression (tree_binary_expression&);
+
+  void visit_break_command (tree_break_command&);
+
+  void visit_colon_expression (tree_colon_expression&);
+
+  void visit_continue_command (tree_continue_command&);
+
+  void visit_global_command (tree_global_command&);
+
+  void visit_persistent_command (tree_persistent_command&);
+
+  void visit_decl_elt (tree_decl_elt&);
+
+  void visit_decl_init_list (tree_decl_init_list&);
+
+  void visit_simple_for_command (tree_simple_for_command&);
+
+  void visit_complex_for_command (tree_complex_for_command&);
+
+  void visit_octave_user_script (octave_user_script&);
+
+  void visit_octave_user_function (octave_user_function&);
+
+  void visit_octave_user_function_header (octave_user_function&);
+
+  void visit_octave_user_function_trailer (octave_user_function&);
+
+  void visit_function_def (tree_function_def&);
+
+  void visit_identifier (tree_identifier&);
+
+  void visit_if_clause (tree_if_clause&);
+
+  void visit_if_command (tree_if_command&);
+
+  void visit_if_command_list (tree_if_command_list&);
+
+  void visit_index_expression (tree_index_expression&);
+
+  void visit_matrix (tree_matrix&);
+
+  void visit_cell (tree_cell&);
+
+  void visit_multi_assignment (tree_multi_assignment&);
+
+  void visit_no_op_command (tree_no_op_command&);
+
+  void visit_constant (tree_constant&);
+
+  void visit_fcn_handle (tree_fcn_handle&);
+
+  void visit_parameter_list (tree_parameter_list&);
+
+  void visit_postfix_expression (tree_postfix_expression&);
+
+  void visit_prefix_expression (tree_prefix_expression&);
+
+  void visit_return_command (tree_return_command&);
+
+  void visit_return_list (tree_return_list&);
+
+  void visit_simple_assignment (tree_simple_assignment&);
+
+  void visit_statement (tree_statement&);
+
+  void visit_statement_list (tree_statement_list&);
+
+  void visit_switch_case (tree_switch_case&);
+
+  void visit_switch_case_list (tree_switch_case_list&);
+
+  void visit_switch_command (tree_switch_command&);
+
+  void visit_try_catch_command (tree_try_catch_command&);
+
+  void visit_unwind_protect_command (tree_unwind_protect_command&);
+
+  void visit_while_command (tree_while_command&);
+
+  void visit_do_until_command (tree_do_until_command&);
+
+  // this would be easier with variadic templates
+  template <typename T>
+  T *create (void)
+  {
+    T *ret = new T();
+    track_value (ret);
+    return ret;
+  }
+
+#define DECL_ARG(n) const ARG ## n& arg ## n
+#define JIT_CREATE(N)                                           \
+  template <typename T, OCT_MAKE_DECL_LIST (typename, ARG, N)>  \
+  T *create (OCT_MAKE_LIST (DECL_ARG, N))                       \
+  {                                                             \
+    T *ret = new T (OCT_MAKE_ARG_LIST (arg, N));                \
+    track_value (ret);                                          \
+    return ret;                                                 \
+  }
+
+  JIT_CREATE (1)
+  JIT_CREATE (2)
+  JIT_CREATE (3)
+  JIT_CREATE (4)
+
+#undef JIT_CREATE
+
+#define JIT_CREATE_CHECKED(N)                                           \
+  template <OCT_MAKE_DECL_LIST (typename, ARG, N)>                      \
+  jit_call *create_checked (OCT_MAKE_LIST (DECL_ARG, N))                \
+  {                                                                     \
+    jit_call *ret = create<jit_call> (OCT_MAKE_ARG_LIST (arg, N));      \
+    return create_checked_impl (ret);                                   \
+  }
+
+  JIT_CREATE_CHECKED (1)
+  JIT_CREATE_CHECKED (2)
+  JIT_CREATE_CHECKED (3)
+  JIT_CREATE_CHECKED (4)
+
+#undef JIT_CREATE_CHECKED
+#undef DECL_ARG
+
+  typedef std::list<jit_block *> block_list;
+  typedef block_list::iterator block_iterator;
+
+  void append (jit_block *ablock);
+
+  void insert_before (block_iterator iter, jit_block *ablock);
+
+  void insert_before (jit_block *loc, jit_block *ablock)
+  {
+    insert_before (loc->location (), ablock);
+  }
+
+  void insert_after (block_iterator iter, jit_block *ablock);
+
+  void insert_after (jit_block *loc, jit_block *ablock)
+  {
+    insert_after (loc->location (), ablock);
+  }
+private:
+  std::vector<std::pair<std::string, bool> > arguments;
+  type_bound_vector bounds;
+
+  // used instead of return values from visit_* functions
+  jit_value *result;
+
+  jit_block *entry_block;
+
+  jit_block *final_block;
+
+  jit_block *block;
+
+  llvm::Function *function;
+
+  std::list<jit_block *> blocks;
+
+  std::list<jit_instruction *> worklist;
+
+  std::list<jit_value *> constants;
+
+  std::list<jit_value *> all_values;
+
+  size_t iterator_count;
+  size_t for_bounds_count;
+  size_t short_count;
+
+  typedef std::map<std::string, jit_variable *> vmap_t;
+  vmap_t vmap;
+
+  jit_call *create_checked_impl (jit_call *ret)
+  {
+    block->append (ret);
+    create_check (ret);
+    return ret;
+  }
+
+  jit_error_check *create_check (jit_call *call)
+  {
+    jit_block *normal = create<jit_block> (block->name ());
+    jit_error_check *ret
+      = block->append (create<jit_error_check> (call, normal, final_block));
+    append (normal);
+    block = normal;
+
+    return ret;
+  }
+
+  // get an existing vairable. If the variable does not exist, it will not be
+  // created
+  jit_variable *find_variable (const std::string& vname) const;
+
+  // get a variable, create it if it does not exist. The type will default to
+  // the variable's current type in the symbol table.
+  jit_variable *get_variable (const std::string& vname);
+
+  // create a variable of the given name and given type. Will also insert an
+  // extract statement
+  jit_variable *create_variable (const std::string& vname, jit_type *type);
+
+  // The name of the next for loop iterator. If inc is false, then the iterator
+  // counter will not be incremented.
+  std::string next_iterator (bool inc = true)
+  { return next_name ("#iter", iterator_count, inc); }
+
+  std::string next_for_bounds (bool inc = true)
+  { return next_name ("#for_bounds", for_bounds_count, inc); }
+
+  std::string next_shortcircut_result (bool inc = true)
+  { return next_name ("#shortcircut_result", short_count, inc); }
+
+  std::string next_name (const char *prefix, size_t& count, bool inc);
+
+  std::pair<jit_value *, jit_value *> resolve (tree_index_expression& exp);
+
+  jit_value *do_assign (tree_expression *exp, jit_value *rhs,
+                        bool artificial = false);
+
+  jit_value *do_assign (const std::string& lhs, jit_value *rhs, bool print,
+                        bool artificial = false);
+
+  jit_value *visit (tree *tee) { return visit (*tee); }
+
+  jit_value *visit (tree& tee);
+
+  void push_worklist (jit_instruction *instr)
+  {
+    if (! instr->in_worklist ())
+      {
+        instr->stash_in_worklist (true);
+        worklist.push_back (instr);
+      }
+  }
+
+  void append_users (jit_value *v)
+  {
+    for (jit_use *use = v->first_use (); use; use = use->next ())
+      push_worklist (use->user ());
+  }
+
+  void append_users_term (jit_terminator *term);
+
+  void track_value (jit_value *value)
+  {
+    if (value->type ())
+      constants.push_back (value);
+    all_values.push_back (value);
+  }
+
+  void merge_blocks (void);
+
+  void construct_ssa (void);
+
+  void do_construct_ssa (jit_block& block, size_t avisit_count);
+
+  void remove_dead ();
+
+  void place_releases (void);
+
+  void release_temp (jit_block& ablock, std::set<jit_value *>& temp);
+
+  void release_dead_phi (jit_block& ablock);
+
+  void simplify_phi (void);
+
+  void simplify_phi (jit_phi& phi);
+
+  void print_blocks (const std::string& header)
+  {
+    std::cout << "-------------------- " << header << " --------------------\n";
+    for (std::list<jit_block *>::iterator iter = blocks.begin ();
+         iter != blocks.end (); ++iter)
+      {
+        assert (*iter);
+        (*iter)->print (std::cout, 0);
+      }
+    std::cout << std::endl;
+  }
+
+  void print_dom (void)
+  {
+    std::cout << "-------------------- dom info --------------------\n";
+    for (std::list<jit_block *>::iterator iter = blocks.begin ();
+         iter != blocks.end (); ++iter)
+      {
+        assert (*iter);
+        (*iter)->print_dom (std::cout);
+      }
+    std::cout << std::endl;
+  }
+
+  bool breaking; // true if we are breaking OR continuing
+  block_list breaks;
+  block_list continues;
+
+  void finish_breaks (jit_block *dest, const block_list& lst);
+
+  // this case is much simpler, just convert from the jit ir to llvm
+  class
+  convert_llvm : public jit_ir_walker
+  {
+  public:
+    convert_llvm (jit_convert& jc) : jthis (jc) {}
+
+    llvm::Function *convert (llvm::Module *module,
+                             const std::vector<std::pair<std::string, bool> >& args,
+                             const std::list<jit_block *>& blocks,
+                             const std::list<jit_value *>& constants);
+
+#define JIT_METH(clname)                        \
+    virtual void visit (jit_ ## clname&);
+
+    JIT_VISIT_IR_CLASSES;
+
+#undef JIT_METH
+  private:
+    // name -> llvm argument
+    std::map<std::string, llvm::Value *> arguments;
+
+    void finish_phi (jit_phi *phi);
+
+    void visit (jit_value *jvalue)
+    {
+      return visit (*jvalue);
+    }
+
+    void visit (jit_value &jvalue)
+    {
+      jvalue.accept (*this);
+    }
+  private:
+    jit_convert &jthis;
+    llvm::Function *function;
+    llvm::BasicBlock *prelude;
+  };
+};
+
+class jit_info;
+
+class
+tree_jit
+{
+public:
+  tree_jit (void);
+
+  ~tree_jit (void);
+
+  bool execute (tree_simple_for_command& cmd, const octave_value& bounds);
+
+  bool execute (tree_while_command& cmd);
+
+  llvm::ExecutionEngine *get_engine (void) const { return engine; }
+
+  llvm::Module *get_module (void) const { return module; }
+
+  void optimize (llvm::Function *fn);
+ private:
+  bool initialize (void);
+
+  size_t trip_count (const octave_value& bounds) const;
+
+  // FIXME: Temorary hack to test
+  typedef std::map<tree *, jit_info *> compiled_map;
+  llvm::Module *module;
+  llvm::PassManager *module_pass_manager;
+  llvm::FunctionPassManager *pass_manager;
+  llvm::ExecutionEngine *engine;
+};
+
+class
+jit_info
+{
+public:
+  // we use a pointer here so we don't have to include ov.h
+  typedef std::map<std::string, const octave_value *> vmap;
+
+  jit_info (tree_jit& tjit, tree& tee);
+
+  jit_info (tree_jit& tjit, tree& tee, const octave_value& for_bounds);
+
+  ~jit_info (void);
+
+  bool execute (const vmap& extra_vars = vmap ()) const;
+
+  bool match (const vmap& extra_vars = vmap ()) const;
+private:
+  typedef jit_convert::type_bound type_bound;
+  typedef jit_convert::type_bound_vector type_bound_vector;
+  typedef void (*jited_function)(octave_base_value**);
+
+  void initialize (tree_jit& tjit, jit_convert& conv);
+
+  octave_value find (const vmap& extra_vars, const std::string& vname) const;
+
+  llvm::ExecutionEngine *engine;
+  jited_function function;
+  llvm::Function *llvm_function;
+
+  std::vector<std::pair<std::string, bool> > arguments;
+  type_bound_vector bounds;
+};
+
+#endif
+#endif
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -30,30 +30,34 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-cmd.h"
 #include "pt-exp.h"
+#include "pt-jit.h"
 #include "pt-jump.h"
 #include "pt-loop.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "unwind-prot.h"
 
 // While.
 
 tree_while_command::~tree_while_command (void)
 {
   delete expr;
   delete list;
   delete lead_comm;
   delete trail_comm;
+#ifdef HAVE_LLVM
+  delete compiled;
+#endif
 }
 
 tree_command *
 tree_while_command::dup (symbol_table::scope_id scope,
                          symbol_table::context_id context) const
 {
   return new tree_while_command (expr ? expr->dup (scope, context) : 0,
                                  list ? list->dup (scope, context) : 0,
@@ -92,16 +96,19 @@ tree_do_until_command::accept (tree_walk
 tree_simple_for_command::~tree_simple_for_command (void)
 {
   delete lhs;
   delete expr;
   delete maxproc;
   delete list;
   delete lead_comm;
   delete trail_comm;
+#ifdef HAVE_LLVM
+  delete compiled;
+#endif
 }
 
 tree_command *
 tree_simple_for_command::dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const
 {
   return new tree_simple_for_command
     (parallel, lhs ? lhs->dup (scope, context) : 0,
diff --git a/src/pt-loop.h b/src/pt-loop.h
--- a/src/pt-loop.h
+++ b/src/pt-loop.h
@@ -31,72 +31,104 @@ class tree_expression;
 class tree_statement_list;
 
 class tree_walker;
 
 #include "comment-list.h"
 #include "pt-cmd.h"
 #include "symtab.h"
 
+class jit_info;
+
 // While.
 
 class
 tree_while_command : public tree_command
 {
 public:
 
   tree_while_command (int l = -1, int c = -1)
     : tree_command (l, c), expr (0), list (0), lead_comm (0),
-      trail_comm (0) { }
+      trail_comm (0)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   tree_while_command (tree_expression *e,
                       octave_comment_list *lc = 0,
                       octave_comment_list *tc = 0,
                       int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (0), lead_comm (lc),
-      trail_comm (tc) { }
+      trail_comm (tc)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   tree_while_command (tree_expression *e, tree_statement_list *lst,
                       octave_comment_list *lc = 0,
                       octave_comment_list *tc = 0,
                       int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
-      trail_comm (tc) { }
+      trail_comm (tc)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   ~tree_while_command (void);
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
+#ifdef HAVE_LLVM
+  // some functions use by tree_jit
+  jit_info *get_info (void) const
+  {
+    return compiled;
+  }
+
+  void stash_info (jit_info *jinfo)
+  {
+    compiled = jinfo;
+  }
+#endif
+
 protected:
 
   // Expression to test.
   tree_expression *expr;
 
   // List of commands to execute.
   tree_statement_list *list;
 
   // Comment preceding WHILE token.
   octave_comment_list *lead_comm;
 
   // Comment preceding ENDWHILE token.
   octave_comment_list *trail_comm;
 
 private:
 
+#ifdef HAVE_LLVM
+  // compiled version of the loop
+  jit_info *compiled;
+#endif
+
   // No copying!
 
   tree_while_command (const tree_while_command&);
 
   tree_while_command& operator = (const tree_while_command&);
 };
 
 // Do-Until.
@@ -141,28 +173,36 @@ private:
 
 class
 tree_simple_for_command : public tree_command
 {
 public:
 
   tree_simple_for_command (int l = -1, int c = -1)
     : tree_command (l, c), parallel (false), lhs (0), expr (0),
-      maxproc (0), list (0), lead_comm (0), trail_comm (0) { }
+      maxproc (0), list (0), lead_comm (0), trail_comm (0)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   tree_simple_for_command (bool parallel_arg, tree_expression *le,
                            tree_expression *re,
                            tree_expression *maxproc_arg,
                            tree_statement_list *lst,
                            octave_comment_list *lc = 0,
                            octave_comment_list *tc = 0,
                            int l = -1, int c = -1)
     : tree_command (l, c), parallel (parallel_arg), lhs (le),
       expr (re), maxproc (maxproc_arg), list (lst),
-      lead_comm (lc), trail_comm (tc) { }
+      lead_comm (lc), trail_comm (tc)
+#ifdef HAVE_LLVM
+    , compiled (0)
+#endif
+  { }
 
   ~tree_simple_for_command (void);
 
   bool in_parallel (void) { return parallel; }
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *control_expr (void) { return expr; }
@@ -175,18 +215,30 @@ public:
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   tree_command *dup (symbol_table::scope_id scope,
                      symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
+#ifdef HAVE_LLVM
+  // some functions use by tree_jit
+  jit_info *get_info (void) const
+  {
+    return compiled;
+  }
+
+  void stash_info (jit_info *jinfo)
+  {
+    compiled = jinfo;
+  }
+#endif
+
 private:
-
   // TRUE means operate in parallel (subject to the value of the
   // maxproc expression).
   bool parallel;
 
   // Expression to modify.
   tree_expression *lhs;
 
   // Expression to evaluate.
@@ -200,16 +252,19 @@ private:
   tree_statement_list *list;
 
   // Comment preceding FOR token.
   octave_comment_list *lead_comm;
 
   // Comment preceding ENDFOR token.
   octave_comment_list *trail_comm;
 
+  // compiled version of the loop
+  jit_info *compiled;
+
   // No copying!
 
   tree_simple_for_command (const tree_simple_for_command&);
 
   tree_simple_for_command& operator = (const tree_simple_for_command&);
 };
 
 class
diff --git a/src/pt-stmt.h b/src/pt-stmt.h
--- a/src/pt-stmt.h
+++ b/src/pt-stmt.h
@@ -30,22 +30,23 @@ class tree_expression;
 
 class tree_walker;
 
 #include <deque>
 
 #include "base-list.h"
 #include "comment-list.h"
 #include "symtab.h"
+#include "pt.h"
 
 // A statement is either a command to execute or an expression to
 // evaluate.
 
 class
-tree_statement
+tree_statement : public tree
 {
 public:
 
   tree_statement (void)
     : cmd (0), expr (0), comm (0) { }
 
   tree_statement (tree_command *c, octave_comment_list *cl)
     : cmd (c), expr (0), comm (cl) { }
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -58,17 +58,17 @@ along with Octave; see the file COPYING.
 int pipe_handler_error_count = 0;
 
 // TRUE means we can be interrupted.
 bool can_interrupt = false;
 
 // TRUE means we should try to enter the debugger on SIGINT.
 static bool Vdebug_on_interrupt = false;
 
-// Allow users to avoid writing octave-core for SIGHUP (sent by
+// Allow users to avoid writing octave-workspace for SIGHUP (sent by
 // closing gnome-terminal, for example).  Note that this variable has
 // no effect if Vcrash_dumps_octave_core is FALSE.
 static bool Vsighup_dumps_octave_core = true;
 
 // Similar to Vsighup_dumps_octave_core, but for SIGTERM signal.
 static bool Vsigterm_dumps_octave_core = true;
 
 // List of signals we have caught since last call to octave_signal_handler.
@@ -142,22 +142,22 @@ octave_signal_handler (void)
                 UNBLOCK_CHILD (oset);
 
                 octave_child_list::reap ();
               }
               break;
 #endif
 
             case SIGFPE:
-              std::cerr << "warning: floating point exception -- trying to return to prompt" << std::endl;
+              std::cerr << "warning: floating point exception" << std::endl;
               break;
 
 #ifdef SIGPIPE
             case SIGPIPE:
-              std::cerr << "warning: broken pipe -- some output may be lost" << std::endl;
+              std::cerr << "warning: broken pipe" << std::endl;
               break;
 #endif
             }
         }
     }
 }
 
 static void
@@ -996,17 +996,17 @@ variable value is restored when exiting 
 */
 
 DEFUN (sighup_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sighup_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
-to save all current variables to the file \"octave-core\" if it receives\n\
+to save all current variables to the file \"octave-workspace\" if it receives\n\
 a hangup signal.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sighup_dumps_octave_core);
@@ -1025,17 +1025,17 @@ variable value is restored when exiting 
 */
 
 DEFUN (sigterm_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sigterm_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
-to save all current variables to the file \"octave-core\" if it receives\n\
+to save all current variables to the file \"octave-workspace\" if it receives\n\
 a terminate signal.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sigterm_dumps_octave_core);
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -38,37 +38,37 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "ov-bool-sparse.h"
 
 DEFUN (issparse, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} issparse (@var{x})\n\
+@deftypefn {Built-in Function} {} issparse (@var{x})\n\
 Return true if @var{x} is a sparse matrix.\n\
 @seealso{ismatrix}\n\
 @end deftypefn")
 {
    if (args.length () != 1)
      {
        print_usage ();
        return octave_value ();
      }
    else
      return octave_value (args(0).is_sparse_type ());
 }
 
 DEFUN (sparse, args, ,
     "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{s} =} sparse (@var{a})\n\
-@deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n}, @var{nzmax})\n\
-@deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})\n\
-@deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{s}, @var{m}, @var{n}, \"unique\")\n\
-@deftypefnx {Loadable Function} {@var{s} =} sparse (@var{m}, @var{n})\n\
+@deftypefn  {Built-in Function} {@var{s} =} sparse (@var{a})\n\
+@deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n}, @var{nzmax})\n\
+@deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})\n\
+@deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{s}, @var{m}, @var{n}, \"unique\")\n\
+@deftypefnx {Built-in Function} {@var{s} =} sparse (@var{m}, @var{n})\n\
 Create a sparse matrix from the full matrix or row, column, value triplets.\n\
 If @var{a} is a full matrix, convert it to a sparse matrix representation,\n\
 removing all zero values in the process.\n\
 \n\
 Given the integer index vectors @var{i} and @var{j}, a 1-by-@code{nnz} vector\n\
 of real of complex values @var{sv}, overall dimensions @var{m} and @var{n}\n\
 of the sparse matrix.  The argument @code{nzmax} is ignored but accepted for\n\
 compatibility with @sc{matlab}.  If @var{m} or @var{n} are not specified\n\
@@ -204,17 +204,17 @@ to have a common size.\n\
          }
      }
 
    return retval;
 }
 
 DEFUN (spalloc, args, ,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{s} =} spalloc (@var{m}, @var{n}, @var{nz})\n\
+@deftypefn {Built-in Function} {@var{s} =} spalloc (@var{m}, @var{n}, @var{nz})\n\
 Create an @var{m}-by-@var{n} sparse matrix with pre-allocated space for at\n\
 most @var{nz} nonzero elements.  This is useful for building the matrix\n\
 incrementally by a sequence of indexed assignments.  Subsequent indexed\n\
 assignments will reuse the pre-allocated memory, provided they are of one of\n\
 the simple forms\n\
 \n\
 @itemize\n\
 @item @code{@var{s}(I:J) = @var{x}}\n\
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1708,8 +1708,37 @@ DEFUN (variable_value, args, , "VALUE = 
         error ("variable_value: expecting variable name as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 #endif
+
+
+/*
+bug #34497: 'clear -f' does not work for command line functions
+
+This test relies on bar being a core function that is implemented in an m-file.
+If the first assert fails, this is no longer the case and the tests need to be
+updated to use some other function.
+
+%!assert (! strcmp (which ("bar"), ""));
+
+%!function x = bar ()
+%!  x = 5;
+%!endfunction
+%!test
+%! assert (bar == 5);
+%! assert (strcmp (which ("bar"), ""));
+%! clear -f bar;
+%! assert (! strcmp (which ("bar"), ""));
+
+%!function x = bar ()
+%!  x = 5;
+%!endfunction
+%!test
+%! assert (bar == 5);
+%! assert (strcmp (which ("bar"), ""));
+%! clear bar;
+%! assert (! strcmp (which ("bar"), ""));
+ */
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -479,17 +479,17 @@ public:
         delete rep;
     }
 
     symbol_record dup (scope_id new_scope) const
     {
       return symbol_record (rep->dup (new_scope));
     }
 
-    std::string name (void) const { return rep->name; }
+    const std::string& name (void) const { return rep->name; }
 
     octave_value
     find (const octave_value_list& args = octave_value_list ()) const;
 
     void force_variable (context_id context = xdefault_context)
     {
       rep->force_variable (context);
     }
@@ -576,16 +576,76 @@ public:
 
   private:
 
     symbol_record_rep *rep;
 
     symbol_record (symbol_record_rep *new_rep) : rep (new_rep) { }
   };
 
+  // Always access a symbol from the current scope.
+  // Useful for scripts, as they may be executed in more than one scope.
+  class
+  symbol_reference
+  {
+  public:
+    symbol_reference (void) : scope (-1) {}
+
+    symbol_reference (symbol_record record,
+                       scope_id curr_scope = symbol_table::current_scope ())
+      : scope (curr_scope), sym (record)
+    {}
+
+    symbol_reference& operator = (const symbol_reference& ref)
+    {
+      scope = ref.scope;
+      sym = ref.sym;
+      return *this;
+    }
+
+    // The name is the same regardless of scope.
+    const std::string& name (void) const { return sym.name (); }
+
+    symbol_record *operator-> (void)
+    {
+      update ();
+      return &sym;
+    }
+
+    symbol_record *operator-> (void) const
+    {
+      update ();
+      return &sym;
+    }
+
+    // can be used to place symbol_reference in maps, we don't overload < as
+    // it doesn't make any sense for symbol_reference
+    struct comparator
+    {
+      bool operator ()(const symbol_reference& lhs,
+                       const symbol_reference& rhs) const
+      {
+        return lhs.name () < rhs.name ();
+      }
+    };
+  private:
+    void update (void) const
+    {
+      scope_id curr_scope = symbol_table::current_scope ();
+      if (scope != curr_scope || ! sym.is_valid ())
+        {
+          scope = curr_scope;
+          sym = symbol_table::insert (sym.name ());
+        }
+    }
+
+    mutable scope_id scope;
+    mutable symbol_record sym;
+  };
+
   class
   fcn_info
   {
   public:
 
     typedef std::map<std::string, std::string> dispatch_map_type;
 
     typedef std::map<scope_id, octave_value>::const_iterator scope_val_const_iterator;
@@ -703,53 +763,49 @@ public:
           {
             if (p->second.islocked ())
               p++;
             else
               map.erase (p++);
           }
       }
 
-      void clear_cmdline_function (void)
-      {
-        if (! cmdline_function.islocked ())
-          cmdline_function = octave_value ();
-      }
-
       void clear_autoload_function (void)
       {
         if (! autoload_function.islocked ())
           autoload_function = octave_value ();
       }
 
-      // FIXME -- should this also clear the cmdline and other "user
-      // defined" functions?
+      // We also clear command line functions here, as these are both
+      // "user defined"
       void clear_user_function (void)
       {
         if (! function_on_path.islocked ())
           {
             function_on_path.erase_subfunctions ();
 
             function_on_path = octave_value ();
           }
+
+        if (! cmdline_function.islocked ())
+          cmdline_function = octave_value ();
       }
 
       void clear_mex_function (void)
       {
         if (function_on_path.is_mex_function ())
           clear_user_function ();
       }
 
       void clear (void)
       {
         clear_unlocked (subfunctions);
         clear_unlocked (private_functions);
         clear_unlocked (class_constructors);
         clear_unlocked (class_methods);
-        clear_cmdline_function ();
         clear_autoload_function ();
         clear_user_function ();
       }
 
       void add_dispatch (const std::string& type, const std::string& fname)
       {
         dispatch_map[type] = fname;
       }
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -1320,16 +1320,19 @@ specified option.\n\
       { false, "LIBFLAGS", OCTAVE_CONF_LIBFLAGS },
       { false, "LIBOCTAVE", OCTAVE_CONF_LIBOCTAVE },
       { false, "LIBOCTINTERP", OCTAVE_CONF_LIBOCTINTERP },
       { false, "LIBS", OCTAVE_CONF_LIBS },
       { false, "LN_S", OCTAVE_CONF_LN_S },
       { false, "MAGICK_CPPFLAGS", OCTAVE_CONF_MAGICK_CPPFLAGS },
       { false, "MAGICK_LDFLAGS", OCTAVE_CONF_MAGICK_LDFLAGS },
       { false, "MAGICK_LIBS", OCTAVE_CONF_MAGICK_LIBS },
+      { false, "LLVM_CPPFLAGS", OCTAVE_CONF_LLVM_CPPFLAGS },
+      { false, "LLVM_LDFLAGS", OCTAVE_CONF_LLVM_LDFLAGS },
+      { false, "LLVM_LIBS", OCTAVE_CONF_LLVM_LIBS },
       { false, "MKOCTFILE_DL_LDFLAGS", OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS },
       { false, "OCTAVE_LINK_DEPS", OCTAVE_CONF_OCTAVE_LINK_DEPS },
       { false, "OCTAVE_LINK_OPTS", OCTAVE_CONF_OCTAVE_LINK_OPTS },
       { false, "OCT_LINK_DEPS", OCTAVE_CONF_OCT_LINK_DEPS },
       { false, "OCT_LINK_OPTS", OCTAVE_CONF_OCT_LINK_OPTS },
       { false, "OPENGL_LIBS", OCTAVE_CONF_OPENGL_LIBS },
       { false, "PTHREAD_CFLAGS", OCTAVE_CONF_PTHREAD_CFLAGS },
       { false, "PTHREAD_LIBS", OCTAVE_CONF_PTHREAD_LIBS },
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -465,17 +465,17 @@ fcn_file_in_path (const std::string& nam
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
-      else if (len > 2 && name [len - 2] == '.' && name [len - 1] == 'm')
+      else if (len > 2 && name[len - 2] == '.' && name[len - 1] == 'm')
         retval = load_path::find_fcn_file (name.substr (0, len-2));
       else
         {
           std::string fname = name;
           size_t pos = name.find_first_of (Vfilemarker);
           if (pos != std::string::npos)
             fname = name.substr (0, pos);
 
@@ -522,18 +522,18 @@ oct_file_in_path (const std::string& nam
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
-      else if (len > 4 && name [len - 4] == '.' && name [len - 3] == 'o'
-               && name [len - 2] == 'c' && name [len - 1] == 't')
+      else if (len > 4 && name[len - 4] == '.' && name[len - 3] == 'o'
+               && name[len - 2] == 'c' && name[len - 1] == 't')
         retval = load_path::find_oct_file (name.substr (0, len-4));
       else
         retval = load_path::find_oct_file (name);
     }
 
   return retval;
 }
 
@@ -551,18 +551,18 @@ mex_file_in_path (const std::string& nam
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
-      else if (len > 4 && name [len - 4] == '.' && name [len - 3] == 'm'
-               && name [len - 2] == 'e' && name [len - 1] == 'x')
+      else if (len > 4 && name[len - 4] == '.' && name[len - 3] == 'm'
+               && name[len - 2] == 'e' && name[len - 1] == 'x')
         retval = load_path::find_mex_file (name.substr (0, len-4));
       else
         retval = load_path::find_mex_file (name);
     }
 
   return retval;
 }
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -543,16 +543,17 @@ Check only for variables.\n\
 Check only for built-in functions.\n\
 \n\
 @item \"file\"\n\
 Check only for files.\n\
 \n\
 @item \"dir\"\n\
 Check only for directories.\n\
 @end table\n\
+\n\
 @seealso{file_in_loadpath}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
@@ -1553,17 +1554,17 @@ do_who (int argc, const string_vector& a
           // It would be better to refecat symbol_info_list to not store the
           // symbol records and then use it in load-save.cc (do_load) to
           // implement this option there so that the variables are never
           // stored at all.
           if (i == argc - 1)
             error ("whos: -file argument must be followed by a file name");
           else
             {
-              std::string nm = argv [i + 1];
+              std::string nm = argv[i + 1];
 
               unwind_protect frame;
 
               // Set up temporary scope.
 
               symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
               frame.add_fcn (symbol_table::erase_scope, tmp_scope);
 
@@ -2319,16 +2320,17 @@ Clears the local variable names.\n\
 \n\
 @item -classes, -c\n\
 Clears the class structure table and clears all objects.\n\
 \n\
 @item -regexp, -r\n\
 The arguments are treated as regular expressions as any variables that\n\
 match will be cleared.\n\
 @end table\n\
+\n\
 With the exception of @code{exclusive}, all long options can be used\n\
 without the dash as well.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -398,30 +398,30 @@ gzfilebuf::enable_buffer ()
 {
   // If internal buffer required, allocate one
   if (own_buffer && !buffer)
   {
     // Check for buffered vs. "unbuffered"
     if (buffer_size > 0)
     {
       // Allocate internal buffer
-      buffer = new char_type[buffer_size];
+      buffer = new char_type [buffer_size];
       // Get area starts empty and will be expanded by underflow as need arises
       this->setg (buffer, buffer, buffer);
       // Setup entire internal buffer as put area.
       // The one-past-end pointer actually points to the last element of the buffer,
       // so that overflow(c) can safely add the extra character c to the sequence.
       // These pointers remain in place for the duration of the buffer
       this->setp (buffer, buffer + buffer_size - 1);
     }
     else
     {
       // Even in "unbuffered" case, (small?) get buffer is still required
       buffer_size = SMALLBUFSIZE;
-      buffer = new char_type[buffer_size];
+      buffer = new char_type [buffer_size];
       this->setg (buffer, buffer, buffer);
       // "Unbuffered" means no put buffer
       this->setp (0, 0);
     }
   }
   else
   {
     // If buffer already allocated, reset buffer pointers just to make sure no
