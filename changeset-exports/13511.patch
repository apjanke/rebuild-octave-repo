# HG changeset patch
# User Jacob Dawid <jacob.dawid@googlemail.com>
# Date 1310981380 -7200
#      Mon Jul 18 11:29:40 2011 +0200
# Node ID 9d7b0043fa4b17696849247d99b54b986fcae152
# Parent  e4403848424e08f74ec20267775ea742da66f575
# Parent  5236c9518f88d2955ee0209729970b1ec45946dd
Merge.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -25,21 +25,21 @@ Summary of important user-visible change
       spatan2             spkron       str2mat
       spchol              splchol      unmark_command
       spchol2inv          split        unmark_rawcommand
 
     The following functions have been deprecated in Octave 3.6 and will
     be removed from Octave 3.10 (or whatever version is the second major
     release after 3.6):
 
-      __error_text__
+      cut                is_duplicate_entry
+      cor                polyderiv
+      corrcoef           studentize
+      __error_text__     sylvester_matrix
       error_text
-      is_duplicate_entry
-      studentize
-      sylvester_matrix
 
 Summary of important user-visible changes for version 3.4.2:
 -----------------------------------------------------------
 
  ** Octave 3.2.4 fixes some minor installation problems that affected
     version 3.4.1.
 
 Summary of important user-visible changes for version 3.4.1:
diff --git a/build-aux/bootstrap.conf b/build-aux/bootstrap.conf
--- a/build-aux/bootstrap.conf
+++ b/build-aux/bootstrap.conf
@@ -54,16 +54,17 @@ gnulib_modules="
   strftime
   strptime
   symlink
   sys_stat
   sys_time
   sys_times
   time
   times
+  tmpfile
   trunc
   truncf
   unistd
   unlink
   vsnprintf
 "
 
 # Additional xgettext options to use.  Use "\\\newline" to break lines.
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -1,10 +1,11 @@
 Ben Abbott
 Andy Adler
+Giles Anderson
 Joel Andersson
 Muthiah Annamalai
 Shai Ayal
 Roger Banks
 Ben Barrowes
 Alexander Barth
 David Bateman
 Heinz Bauschke
@@ -201,16 +202,17 @@ Michel D. Schmid
 Julian Schnidder
 Nicol N. Schraudolph
 Sebastian Schubert
 Ludwig Schwardt
 Thomas L. Scofield
 Daniel J. Sebald
 Dmitri A. Sergatskov
 Baylis Shanks
+Andriy Shinkarchuck
 Joseph P. Skudlarek
 John Smith
 Julius Smith
 Shan G. Smith
 Joerg Specht
 Quentin H. Spencer
 Christoph Spiel
 Richard Stallman
@@ -227,23 +229,25 @@ Georg Thimm
 Duncan Temple Lang
 Kris Thielemans
 Olaf Till
 Christophe Tournery
 Thomas Treichl
 Frederick Umminger
 Utkarsh Upadhyay
 Stefan van der Walt
+David Wells
 Peter Van Wieren
 James R. Van Zandt
 Gregory Vanuxem
 Ivana Varekova
 Thomas Walter
 Olaf Weber
 Thomas Weber
 Rik Wehbring
 Bob Weigel
 Andreas Weingessel
 Michael Weitzel
 Fook Fah Yap
+Sean Young
 Michael Zeising
 Federico Zenith
 Alex Zvoleff
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -163,19 +163,17 @@ using the @code{hist} function as descri
 
 @node Correlation and Regression Analysis
 @section Correlation and Regression Analysis
 
 @c FIXME: Need Intro Here
 
 @DOCSTRING(cov)
 
-@DOCSTRING(cor)
-
-@DOCSTRING(corrcoef)
+@DOCSTRING(corr)
 
 @DOCSTRING(spearman)
 
 @DOCSTRING(kendall)
 
 @c FIXME: Need discussion of ols & gls and references to them in optim.txi
 
 
diff --git a/etc/CHECKLIST b/etc/CHECKLIST
--- a/etc/CHECKLIST
+++ b/etc/CHECKLIST
@@ -1,18 +1,13 @@
 Things to do before making a release:
 
-  * Ask testers for the type(s) of machines they are using.
-
-  * Update the version number in src/version.h.
-
-  * Update the version number in doc/refcard/refcard.tex.
-
-  * Add a `Version M.N.P released.' line to the ChangeLog.
+  * Update the version number and release date in configure.ac.
 
   * Update the NEWS file.
 
-  * Check the README file.
+  * Update the NEWS-<VERSION>.html, index.in, news.in, and download.in
+    files for the web site.
 
-  * Run autoconf, autoheader, and configure before making tar files.
+  * Copy tarballs to ftp.gnu.org.
 
-  * Update the NEWS and README.octave files in the anonymous ftp
-    directory.
+  * Post a release announcement to the help@octave.org and
+    info-gnu@gnu.org lists.
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -235,12 +235,11 @@ function chunk_size = find_chunk (fid, c
     chunk_size += rem (chunk_size, 2);
     offset = offset + 8 + chunk_size;
   endwhile
   if (! strcmp (id, chunk_id))
     chunk_size = -1;
   endif
 endfunction
 
-
-%% Tests for wavread/wavwrite pair are in wavrite.m
-%!assert(1)  # stop fntests.m from reporting no tests for wavread
-
+## Mark file as being tested.  Tests for wavread/wavwrite pair are in
+## wavwrite.m
+%!assert(1)
diff --git a/scripts/statistics/base/cor.m b/scripts/deprecated/cor.m
rename from scripts/statistics/base/cor.m
rename to scripts/deprecated/cor.m
--- a/scripts/statistics/base/cor.m
+++ b/scripts/deprecated/cor.m
@@ -22,16 +22,23 @@
 ## Compute matrix of correlation coefficients.
 ##
 ## This is an alias for @code{corrcoef}.
 ## @seealso{corrcoef}
 ## @end deftypefn
 
 function retval = cor (x, y = x)
 
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "cor is obsolete and will be removed from a future version of Octave; please use corr instead");
+  endif
+
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   retval = corrcoef (x, y);
 
 endfunction
 
diff --git a/scripts/statistics/base/corrcoef.m b/scripts/deprecated/corrcoef.m
rename from scripts/statistics/base/corrcoef.m
rename to scripts/deprecated/corrcoef.m
--- a/scripts/statistics/base/corrcoef.m
+++ b/scripts/deprecated/corrcoef.m
@@ -43,16 +43,23 @@
 ## @end deftypefn
 
 ## Author: Kurt Hornik <hornik@wu-wien.ac.at>
 ## Created: March 1993
 ## Adapted-By: jwe
 
 function retval = corrcoef (x, y = [])
 
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "corrcoef is not equivalent to Matlab and will be removed from a future version of Octave; for similar functionality see corr");
+  endif
+
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   ## Input validation is done by cov.m.  Don't repeat tests here
 
   ## Special case, scalar is always 100% correlated with itself
   if (isscalar (x))
diff --git a/scripts/statistics/base/cut.m b/scripts/deprecated/cut.m
rename from scripts/statistics/base/cut.m
rename to scripts/deprecated/cut.m
--- a/scripts/statistics/base/cut.m
+++ b/scripts/deprecated/cut.m
@@ -32,16 +32,23 @@
 ## @seealso{histc}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Cut data into intervals
 
 function group = cut (x, breaks)
 
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "cut is obsolete and will be removed from a future version of Octave; please use histc instead");
+  endif
+
   if (nargin != 2)
     print_usage ();
   endif
 
   if (!isvector (x))
     error ("cut: X must be a vector");
   endif
   if isscalar (breaks)
diff --git a/scripts/deprecated/module.mk b/scripts/deprecated/module.mk
--- a/scripts/deprecated/module.mk
+++ b/scripts/deprecated/module.mk
@@ -1,27 +1,31 @@
 FCN_FILE_DIRS += deprecated
 
 deprecated_FCN_FILES = \
   deprecated/autocor.m \
   deprecated/autocov.m \
   deprecated/betai.m \
   deprecated/cellidx.m \
   deprecated/clg.m \
+  deprecated/cor.m \
+  deprecated/corrcoef.m \
   deprecated/cquad.m \
+  deprecated/cut.m \
   deprecated/dispatch.m \
   deprecated/fstat.m \
   deprecated/gammai.m \
   deprecated/glpkmex.m \
   deprecated/intwarning.m \
   deprecated/is_duplicate_entry.m \
   deprecated/is_global.m \
   deprecated/isstr.m \
   deprecated/krylovb.m \
   deprecated/perror.m \
+  deprecated/polyderiv.m \
   deprecated/replot.m \
   deprecated/saveimage.m \
   deprecated/setstr.m \
   deprecated/sphcat.m \
   deprecated/spvcat.m \
   deprecated/strerror.m \
   deprecated/studentize.m \
   deprecated/sylvester_matrix.m \
diff --git a/scripts/polynomial/polyderiv.m b/scripts/deprecated/polyderiv.m
rename from scripts/polynomial/polyderiv.m
rename to scripts/deprecated/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/deprecated/polyderiv.m
@@ -31,16 +31,23 @@
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [q, d] = polyderiv (p, a)
 
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "polyderiv is obsolete and will be removed from a future version of Octave; please use polyder instead");
+  endif
+
   if (nargin == 1 || nargin == 2)
     if (! isvector (p))
       error ("polyderiv: argument must be a vector");
     endif
     if (nargin == 2)
       if (! isvector (a))
         error ("polyderiv: argument must be a vector");
       endif
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -74,8 +74,36 @@ function C = bitget (A, n)
   m = double (n(:));
   if (any (m < 1) || any (m > Amax))
     error ("bitget: N must be in the range [1,%d]", Amax);
   endif
 
   C = bitand (A, bitshift (_conv (1), uint8 (n) - uint8 (1))) != _conv (0);
 
 endfunction
+
+%!error bitget (1);
+%!error bitget (1, 2, 3);
+
+%!test
+%! assert (bitget ([4, 14], [3, 3]), logical ([1, 1]));
+%! pfx = {"", "u"};
+%! for i = 1:2
+%!   for prec = [8, 16, 32, 64]
+%!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
+%!     assert (bitget (fcn ([4, 14]), [3, 3]), logical ([1, 1]));
+%!   endfor
+%! endfor
+
+%!error bitget (0, 0);
+%!error bitget (0, 55);
+
+%!error bitget (int8 (0), 9);
+%!error bitget (uint8 (0), 9);
+
+%!error bitget (int16 (0), 17);
+%!error bitget (uint16 (0), 17);
+
+%!error bitget (int32 (0), 33);
+%!error bitget (uint32 (0), 33);
+
+%!error bitget (int64 (0), 65);
+%!error bitget (uint64 (0), 65);
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -87,8 +87,36 @@ function C = bitset (A, n, val)
   mask = bitshift (_conv (1), uint8 (n) - uint8 (1));
   C = bitxor (A, bitand (A, mask));
 
   if (val)
     C = bitor (A, mask);
   endif
 
 endfunction
+
+%!error bitset (1);
+%!error bitset (1, 2, 3, 4);
+
+%!test
+%! assert (bitset ([0, 10], [3, 3]), [4, 14]);
+%! pfx = {"", "u"};
+%! for i = 1:2
+%!   for prec = [8, 16, 32, 64]
+%!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
+%!     assert (bitset (fcn ([0, 10]), [3, 3]), fcn ([4, 14]));
+%!   endfor
+%! endfor
+
+%!error bitset (0, 0);
+%!error bitset (0, 55);
+
+%!error bitset (int8 (0), 9);
+%!error bitset (uint8 (0), 9);
+
+%!error bitset (int16 (0), 17);
+%!error bitset (uint16 (0), 17);
+
+%!error bitset (int32 (0), 33);
+%!error bitset (uint32 (0), 33);
+
+%!error bitset (int64 (0), 65);
+%!error bitset (uint64 (0), 65);
diff --git a/scripts/general/colon.m b/scripts/general/colon.m
--- a/scripts/general/colon.m
+++ b/scripts/general/colon.m
@@ -33,8 +33,12 @@
 ## @seealso{class, subsref, subsasgn}
 ## @end deftypefn
 
 function r = colon (varargin)
   if (nargin != 0)
     error ("colon: not defined for class \"%s\"", class(varargin{1}));
   endif
 endfunction
+
+%!error colon (1)
+
+## FIXME -- what does colon () mean since it doesn't set a return value?
diff --git a/scripts/general/common_size.m b/scripts/general/common_size.m
--- a/scripts/general/common_size.m
+++ b/scripts/general/common_size.m
@@ -73,8 +73,18 @@ function [errorcode, varargout] = common
           dims = size (varargin{find (nscal, 1)});
           subs = arrayfun (@ones, 1, dims, "uniformoutput", false);
           varargout(scal) = cellindexmat (varargin(scal), subs{:});
         endif
       endif
     endif
   endif
 endfunction
+
+%!error common_size ();
+
+%!test
+%! m = [1,2;3,4];
+%! [err, a, b, c] = common_size (m, 3, 5);
+%! assert (err, 0);
+%! assert (a, m);
+%! assert (b, [3,3;3,3]);
+%! assert (c, [5,5;5,5]);
diff --git a/scripts/general/flipdim.m b/scripts/general/flipdim.m
--- a/scripts/general/flipdim.m
+++ b/scripts/general/flipdim.m
@@ -38,20 +38,30 @@
 
 function y = flipdim (x, dim)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   nd = ndims (x);
+  sz = size (x);
   if (nargin == 1)
     ## Find the first non-singleton dimension.
     (dim = find (sz > 1, 1)) || (dim = 1);
   elseif (! (isscalar (dim) && isindex (dim)))
     error ("flipdim: DIM must be a positive integer");
   endif
 
   idx(1:max(nd, dim)) = {':'};
   idx{dim} = size (x, dim):-1:1;
   y = x(idx{:});
 
 endfunction
+
+%!error flipdim ();
+%!error flipdim (1, 2, 3);
+
+%!assert (flipdim ([1,2;3,4]), flipdim ([1,2 ; 3,4], 1));
+%!assert (flipdim ([1,2;3,4], 2), [2,1;4,3]);
+%!assert (flipdim ([1,2;3,4], 3), [1,2;3,4]);
+
+## FIXME -- we need tests for multidimensional arrays.
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -44,38 +44,43 @@
 ## results, use @code{sprintf} (@pxref{Formatted Output}).
 ## @seealso{sprintf, num2str, mat2str}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = int2str (n)
 
-  if (nargin == 1)
-    n = round (real(n));
-    sz = size(n);
-    nd = ndims (n);
-    nc = columns (n);
-    if (nc > 1)
-      idx = repmat ({':'}, nd, 1);
-      idx(2) = 1;
-      ifmt = get_fmt (n(idx{:}), 0);
-      idx(2) = 2:sz(2);
-      rfmt = get_fmt (n(idx{:}), 2);
-      fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n");
-    else
-      fmt = cstrcat (get_fmt (n, 0), "\n");
-    endif
-    tmp = sprintf (fmt, permute (n, [2, 1, 3 : nd]));
-    tmp(end) = "";
-    retval = char (strsplit (tmp, "\n"));
-  else
+  if (nargin != 1)
     print_usage ();
   endif
 
+  if (isempty (n))
+    retval = '';
+    return;
+  endif
+
+  n = round (real(n));
+  sz = size(n);
+  nd = ndims (n);
+  nc = columns (n);
+  if (nc > 1)
+    idx = repmat ({':'}, nd, 1);
+    idx(2) = 1;
+    ifmt = get_fmt (n(idx{:}), 0);
+    idx(2) = 2:sz(2);
+    rfmt = get_fmt (n(idx{:}), 2);
+    fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n");
+  else
+    fmt = cstrcat (get_fmt (n, 0), "\n");
+  endif
+  tmp = sprintf (fmt, permute (n, [2, 1, 3 : nd]));
+  tmp(end) = "";
+  retval = char (strsplit (tmp, "\n"));
+
 endfunction
 
 function fmt = get_fmt (x, sep)
 
   t = x(:);
   t = t(t != 0);
   if (isempty (t))
     ## All zeros.
@@ -104,13 +109,15 @@ function fmt = get_fmt (x, sep)
         fw++;
       endif
       fmt = sprintf ("%%%dd", max (fw, min_fw));
     endif
   endif
 
 endfunction
 
-%!assert(strcmp (int2str (-123), "-123") && strcmp (int2str (1.2), "1"));
+%!assert (strcmp (int2str (-123), "-123") && strcmp (int2str (1.2), "1"));
 %!assert (all (int2str ([1, 2, 3; 4, 5, 6]) == ["1  2  3";"4  5  6"]));
+%!assert (int2str([]), "");
+
 %!error int2str ();
 %!error int2str (1, 2);
 
diff --git a/scripts/general/isdir.m b/scripts/general/isdir.m
--- a/scripts/general/isdir.m
+++ b/scripts/general/isdir.m
@@ -26,8 +26,14 @@ function retval = isdir (f)
   if (nargin != 1)
     print_usage ("isdir");
   endif
 
   ## Exist returns an integer but isdir should return a logical.
   retval = (exist (f, "dir") == 7);
 
 endfunction
+
+%!error isdir ();
+%!error isdir (1, 2);
+
+%!assert (isdir (pwd ()));
+%!assert (! isdir ("this is highly unlikely to be a directory name"));
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -50,8 +50,19 @@ function n = nextpow2 (x)
   endif
 
   [f, n] = log2 (abs (x));
   if (f == 0.5)
     n = n - 1;
   endif
 
 endfunction
+
+%!error nexpow2 ();
+%!error nexpow2 (1, 2);
+
+%!assert (nextpow2 (16), 4);
+%!assert (nextpow2 (17), 5);
+%!assert (nextpow2 (31), 5);
+%!assert (nextpow2 (-16), 4);
+%!assert (nextpow2 (-17), 5);
+%!assert (nextpow2 (-31), 5);
+%!assert (nextpow2 (1:17), 5);
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -77,8 +77,21 @@ function y = postpad (x, l, c, dim)
     idx{dim} = 1:l;
     y = x(idx{:});
   else
     sz (dim) = l - d;
     y = cat (dim, x, c * ones (sz));
   endif
 
 endfunction
+
+%!error postpad ();
+%!error postpad (1);
+%!error postpad (1,2,3,4,5);
+%!error postpad ([1,2], 2, 2,3);
+
+%!assert (postpad ([1,2], 4), [1,2,0,0]);
+%!assert (postpad ([1;2], 4), [1;2;0;0]);
+
+%!assert (postpad ([1,2], 4, 2), [1,2,2,2]);
+%!assert (postpad ([1;2], 4, 2), [1;2;2;2]);
+
+%!assert (postpad ([1,2], 2, 2, 1), [1,2;2,2]);
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -77,8 +77,23 @@ function y = prepad (x, l, c, dim)
     idx{dim} = d-l+1:d;
     y = x(idx{:});
   else
     sz (dim) = l - d;
     y = cat (dim, c * ones (sz), x);
   endif
 
 endfunction
+
+%!error prepad ();
+%!error prepad (1);
+%!error prepad (1,2,3,4,5);
+%!error prepad ([1,2], 2, 2,3);
+
+%!assert (prepad ([1,2], 4), [0,0,1,2]);
+%!assert (prepad ([1;2], 4), [0;0;1;2]);
+
+%!assert (prepad ([1,2], 4, 2), [2,2,1,2]);
+%!assert (prepad ([1;2], 4, 2), [2;2;1;2]);
+
+%!assert (prepad ([1,2], 2, 2, 1), [2,2;1,2]);
+
+## FIXME -- we need tests for multidimensional arrays.
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -189,8 +189,30 @@ endfunction
 function r = need_warning (v)
   persistent w = [];
   if (nargin == 0)
     r = w;
   else
     w = v;
   endif
 endfunction
+
+
+## basic functionality
+%!assert( quadl (@(x) sin (x), 0, pi, [], []), 2, -3e-16)
+
+## the values here are very high so it may be unavoidable that this fails
+%!assert ( quadl (@(x) sin (3*x).*cosh (x).*sinh (x),10,15),
+%!         2.588424538641647e+10, -9e-15)
+
+## extra parameters
+%!assert (quadl (@(x,a,b) sin (a + b*x), 0, 1, [], [], 2, 3),
+%!        cos(2)/3 - cos(5)/3, - 3e-16)
+
+## test different tolerances. This test currently fails for a very high
+## tolerances.
+%!assert ( quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.3, []),
+%!        (60 + sin(4) - sin(64))/12, -0.3)
+
+
+## for lower tolerances the test passes.
+%!assert ( quadl (@(x) sin (2 + 3*x).^2, 0, 10, 0.1, []),
+%!        (60 + sin(4) - sin(64))/12, -0.1)
\ No newline at end of file
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -145,8 +145,16 @@ function [n,d] = rat(x,tol)
       elseif (s_nc > n_nc)
         n(:,n_nc+1:s_nc) = " ";
       endif
       n = cat (1, n, s);
     endfor
   endif
 
 endfunction
+
+%!error rat ();
+%!error rat (1, 2, 3);
+
+%!test
+%! [n, d] = rat ([0.5, 0.3, 1/3]);
+%! assert (n, [1, 3, 1]);
+%! assert (d, [2, 10, 3]);
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -66,32 +66,36 @@ function y = rotdim (x, n, plane)
     endif
   else
     n = 1;
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin < 3)
-    ## Find the first two non-singleton dimension.
-    plane = [];
-    dim = 0;
-    while (dim < nd)
-      dim = dim + 1;
-      if (sz (dim) != 1)
-        plane = [plane, dim];
-        if (length (plane) == 2)
-          break;
+    if (nd > 2)
+      ## Find the first two non-singleton dimension.
+      plane = [];
+      dim = 0;
+      while (dim < nd)
+        dim = dim + 1;
+        if (sz (dim) != 1)
+          plane = [plane, dim];
+          if (length (plane) == 2)
+            break;
+          endif
         endif
+      endwhile
+      if (length (plane) < 1)
+        plane = [1, 2];
+      elseif (length (plane) < 2)
+        plane = [1, plane];
       endif
-    endwhile
-    if (length (plane) < 1)
+    else
       plane = [1, 2];
-    elseif (length (plane) < 2)
-      plane = [1, plane];
     endif
   else
     if (! (isvector (plane) && length (plane) == 2
            && all (plane == round (plane)) && all (plane > 0)
            && all (plane < (nd + 1)) && plane(1) != plane(2)))
       error ("rotdim: PLANE must be a 2 element integer vector defining a valid PLANE");
     endif
   endif
@@ -114,8 +118,41 @@ function y = rotdim (x, n, plane)
     else
       y = flipdim (y, max (plane));
     endif
   else
     error ("rotdim: internal error!");
   endif
 
 endfunction
+
+%!error rotdim ();
+%!error rotdim (1, 2, 3, 4);
+
+%!shared r, rr
+%! r = [1,2,3]; rr = [3,2,1];
+%!assert (rotdim (r, 0), r);
+%!assert (rotdim (r, 1), rr');
+%!assert (rotdim (r, 2), rr);
+%!assert (rotdim (r, 3), r');
+%!assert (rotdim (r, 3), rotdim (r, -1));
+%!assert (rotdim (r, 1), rotdim (r));
+
+%!shared c, cr
+%! c = [1;2;3]; cr = [3;2;1];
+%!assert (rotdim (c, 0), c);
+%!assert (rotdim (c, 1), c');
+%!assert (rotdim (c, 2), cr);
+%!assert (rotdim (c, 3), cr');
+%!assert (rotdim (c, 3), rotdim (c, -1));
+%!assert (rotdim (c, 1), rotdim (c));
+
+%!shared m
+%! m = [1,2;3,4];
+%!assert (rotdim (m, 0), m);
+%!assert (rotdim (m, 1), [2,4;1,3]);
+%!assert (rotdim (m, 2), [4,3;2,1]);
+%!assert (rotdim (m, 3), [3,1;4,2]);
+%!assert (rotdim (m, 3), rotdim (m, -1));
+%!assert (rotdim (m, 1), rotdim (m));
+
+## FIXME -- we need tests for multidimensional arrays and different
+## values of PLANE.
diff --git a/scripts/geometry/module.mk b/scripts/geometry/module.mk
--- a/scripts/geometry/module.mk
+++ b/scripts/geometry/module.mk
@@ -7,19 +7,16 @@ geometry_FCN_FILES = \
   geometry/delaunay.m \
   geometry/dsearch.m \
   geometry/dsearchn.m \
   geometry/griddata.m \
   geometry/griddata3.m \
   geometry/griddatan.m \
   geometry/inpolygon.m \
   geometry/rectint.m \
-  geometry/trimesh.m \
-  geometry/triplot.m \
-  geometry/trisurf.m \
   geometry/tsearchn.m \
   geometry/voronoi.m \
   geometry/voronoin.m
 
 FCN_FILES += $(geometry_FCN_FILES)
 
 PKG_ADD_FILES += geometry/PKG_ADD
 
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -161,8 +161,18 @@ function [vvx, vvy] = voronoi (varargin)
   elseif (nargout == 2)
     vvx = vx;
     vvy = vy;
   else
     error ("voronoi: only two or zero output arguments supported");
   endif
 
 endfunction
+
+%!testif HAVE_QHULL
+%! phi=linspace(-pi,3/4*pi,8);
+%! [x,y]=pol2cart(phi,1);
+%! [vx,vy]=voronoi(x,y);
+%! assert(vx(2,:),zeros(1,size(vx,2)),eps);
+%! assert(vy(2,:),zeros(1,size(vy,2)),eps);
+
+%!demo
+%! voronoi (rand(10,1), rand(10,1));
diff --git a/scripts/help/module.mk b/scripts/help/module.mk
--- a/scripts/help/module.mk
+++ b/scripts/help/module.mk
@@ -1,23 +1,24 @@
 FCN_FILE_DIRS += help
 
 help_PRIVATE_FCN_FILES = \
-  help/private/__additional_help_message__.m
+  help/private/__additional_help_message__.m \
+  help/private/__strip_html_tags__.m
 
 help_FCN_FILES = \
   help/__makeinfo__.m \
-  help/__strip_html_tags__.m \
   help/doc.m \
   help/gen_doc_cache.m \
   help/get_first_help_sentence.m \
   help/help.m \
   help/lookfor.m \
   help/print_usage.m \
   help/type.m \
+  help/unimplemented.m \
   help/which.m \
   $(help_PRIVATE_FCN_FILES)
 
 FCN_FILES += $(help_FCN_FILES)
 
 PKG_ADD_FILES += help/PKG_ADD
 
 DIRSTAMP_FILES += help/$(octave_dirstamp)
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -131,8 +131,12 @@ endfunction
 function [retval, status] = get_usage_html (help_text, max_len)
   ## Strip tags
   [help_text, status] = strip_html_tags (help_text);
 
   ## Extract first line with plain text method.
   retval = get_usage_plain_text (help_text, max_len);
 endfunction
 
+
+## Stop reporting function as missing tests.  No good tests possible.
+%!assert (1)
+
diff --git a/scripts/help/__strip_html_tags__.m b/scripts/help/private/__strip_html_tags__.m
rename from scripts/help/__strip_html_tags__.m
rename to scripts/help/private/__strip_html_tags__.m
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -106,9 +106,19 @@ function retval = type (varargin)
     if (nargout == 0)
       disp (text);
     else
       retval {n} = text;
     endif
   endfor
 endfunction
 
+%!test
+%! var = 1;
+%! typestr = type ("var");
+%! typestr = typestr{1}(1:17);
+%! assert (typestr, "var is a variable");
 
+%!assert (type ('dot'){1}, "dot is a dynamically-linked function")
+%!assert (type ('cat'){1}, "cat is a built-in function")
+%!assert (type ('+'){1}, "+ is an operator")
+%!assert (type ('end'){1}, "end is a keyword")
+%!error (type ('NO_NAME'))
diff --git a/scripts/miscellaneous/unimplemented.m b/scripts/help/unimplemented.m
rename from scripts/miscellaneous/unimplemented.m
rename to scripts/help/unimplemented.m
--- a/scripts/miscellaneous/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -421,8 +421,19 @@ function list = missing_functions ()
   "xlsread",
   "xlswrite",
   "xmlread",
   "xmlwrite",
   "xslt",
   "zoom",
   };
 endfunction
+
+
+%!test
+%! str = unimplemented ("no_name_function");
+%! assert (isempty (str));
+%! str = unimplemented ("quad2d");
+%! assert (str(1:51), "quad2d is not implemented.  Consider using dblquad.");
+%! str = unimplemented ("MException");
+%! assert (str(1:58), "the `MException' function is not yet implemented in Octave");
+
+
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -48,8 +48,18 @@ function varargout = which (varargin)
     else
       varargout = {m.file};
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
+
+%!test
+%! str = which ("ls");
+%! assert (str(end-17:end), strcat ("miscellaneous", filesep(), "ls.m"));
+%!test
+%! str = which ("dot");
+%! assert (str(end-6:end), "dot.oct");
+
+%!assert (which ("NO_NAME"), "");
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -90,8 +90,30 @@ function k = commutation_matrix (m, n)
   k = zeros (m * n, m * n);
   for i = 1 : m
     for j = 1 : n
       k ((i - 1) * n + j, (j - 1) * m + i) = 1;
     endfor
   endfor
 
 endfunction
+
+%!test
+%! c = commutation_matrix(1,1);
+%! assert(c,1);
+
+%!test
+%! A = rand(3,5);
+%! vc = vec(A);
+%! vr = vec(A');
+%! c = commutation_matrix(3,5);
+%! assert(c*vc,vr);
+
+%!test
+%! A = rand(4,6);
+%! vc = vec(A);
+%! vr = vec(A');
+%! c = commutation_matrix(4,6);
+%! assert(c*vc,vr);
+
+%!error commutation_matrix(0,0);
+%!error commutation_matrix(1,0);
+%!error commutation_matrix(0,1);
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -58,8 +58,27 @@ function retval = isdefinite (x, tol)
     if (p == 0)
       retval = 0;
     else
       retval = -1;
     endif
   endif
 
 endfunction
+
+%!test
+%! A = [-1 0; 0 -1];
+%! assert (isdefinite (A), -1)
+
+%!test
+%! A = [1 0; 0 1];
+%! assert (isdefinite (A), 1)
+
+%!test
+%! A = [2 -1 0; -1 2 -1; 0 -1 2];
+%! assert (isdefinite (A), 1)
+
+%!test
+%! A = [1 0; 0 0];
+%! assert (isdefinite (A), 0)
+
+%!error isdefinite ()
+%!error isdefinite ([1 2; 3 4])
\ No newline at end of file
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -72,8 +72,40 @@ function retval = null (A, tol)
         retval(abs (retval) < eps) = 0;
       endif
     else
       retval = zeros (cols, 0);
     endif
   endif
 
 endfunction
+
+%!test
+%! A = 0;
+%! assert(null(A), 1);
+
+%!test
+%! A = 1;
+%! assert(null(A), zeros(1,0))
+
+%!test
+%! A = [1 0; 0 1];
+%! assert(null(A), zeros(2,0));
+
+%!test
+%! A = [1 0; 1 0];
+%! assert(null(A), [0 1]')
+
+%!test
+%! A = [1 1; 0 0];
+%! assert(null(A), [-1/sqrt(2) 1/sqrt(2)]')
+
+%!test
+%! tol = 1e-4;
+%! A = [1 0; 0 tol-eps];
+%! assert(null(A,tol), [0 1]')
+
+%!test
+%! tol = 1e-4;
+%! A = [1 0; 0 tol+eps];
+%! assert(null(A,tol), zeros(2,0));
+
+%!error null()
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -53,8 +53,59 @@ function retval = rank (A, tol)
     tolerance = tol;
   else
     print_usage ();
   endif
 
   retval = sum (sigma > tolerance);
 
 endfunction
+
+%!test
+%! A = [1 2 3 4 5 6 7; 
+%!      4 5 6 7 8 9 12; 
+%!      1 2 3.1 4 5 6 7; 
+%!      2 3 4 5 6 7 8; 
+%!      3 4 5 6 7 8 9; 
+%!      4 5 6 7 8 9 10; 
+%!      5 6 7 8 9 10 11];
+%! assert(rank(A),4);
+
+%!test
+%! A = [1 2 3 4 5 6 7; 
+%!      4 5 6 7 8 9 12; 
+%!      1 2 3.0000001 4 5 6 7; 
+%!      4 5 6 7 8 9 12.00001; 
+%!      3 4 5 6 7 8 9; 
+%!      4 5 6 7 8 9 10; 
+%!      5 6 7 8 9 10 11];
+%! assert(rank(A),4);
+
+%!test
+%! A = [1 2 3 4 5 6 7; 
+%!      4 5 6 7 8 9 12; 
+%!      1 2 3 4 5 6 7; 
+%!      4 5 6 7 8 9 12.00001; 
+%!      3 4 5 6 7 8 9;
+%!      4 5 6 7 8 9 10; 
+%!      5 6 7 8 9 10 11];
+%! assert(rank(A),3);
+
+%!test
+%! A = [1 2 3 4 5 6 7; 
+%!      4 5 6 7 8 9 12;
+%!      1 2 3 4 5 6 7;
+%!      4 5 6 7 8 9 12; 
+%!      3 4 5 6 7 8 9; 
+%!      4 5 6 7 8 9 10; 
+%!      5 6 7 8 9 10 11];
+%! assert(rank(A),3);
+
+%!test
+%! A = eye(100);
+%! assert(rank(A),100);
+
+%!test
+%! A = [1, 2, 3; 1, 2.001, 3; 1, 2, 3.0000001];
+%! assert(rank(A),3)
+%! assert(rank(A,0.0009),1)
+%! assert(rank(A,0.0006),2)
+%! assert(rank(A,0.00000002),3)
\ No newline at end of file
diff --git a/scripts/miscellaneous/ans.m b/scripts/miscellaneous/ans.m
--- a/scripts/miscellaneous/ans.m
+++ b/scripts/miscellaneous/ans.m
@@ -23,8 +23,12 @@
 ##
 ## @example
 ## 3^2 + 4^2
 ## @end example
 ##
 ## @noindent
 ## is evaluated, the value returned by @code{ans} is 25.
 ## @end defvr
+
+## Mark file as being tested.  No real test needed for a documentation .m file
+%!assert (1)
+
diff --git a/scripts/miscellaneous/bug_report.m b/scripts/miscellaneous/bug_report.m
--- a/scripts/miscellaneous/bug_report.m
+++ b/scripts/miscellaneous/bug_report.m
@@ -38,8 +38,11 @@ function bug_report ()
   puts ("    http://www.octave.org/bugs.html\n");
   puts ("\n");
   puts ("  to learn how to submit useful bug reports that will\n");
   puts ("  help the Octave community diagnose and fix the problem\n");
   puts ("  quickly and efficiently.\n");
   puts ("\n");
 
 endfunction
+
+## Mark file as being tested.  No real test needed for this function.
+%!assert (1)
diff --git a/scripts/miscellaneous/comma.m b/scripts/miscellaneous/comma.m
--- a/scripts/miscellaneous/comma.m
+++ b/scripts/miscellaneous/comma.m
@@ -16,8 +16,12 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Operator} {} ,
 ## Array index, function argument, or command separator.
 ## @seealso{semicolon}
 ## @end deftypefn
+
+## Mark file as being tested.  No real test needed for a documentation .m file
+%!assert (1)
+
diff --git a/scripts/miscellaneous/info.m b/scripts/miscellaneous/info.m
--- a/scripts/miscellaneous/info.m
+++ b/scripts/miscellaneous/info.m
@@ -38,8 +38,11 @@ function info ()
   http://octave.sourceforge.net\n\
 \n\
   Report bugs to the bug tracker at\n\
   http://bugs.octave.org\n\
   But first, please read the guidelines to writing a helpful report at\n\
   http://www.octave.org/bugs.html\n");
 
 endfunction
+
+## Mark file as being tested.  No real test needed for this function.
+%! assert (1)
diff --git a/scripts/miscellaneous/ismac.m b/scripts/miscellaneous/ismac.m
--- a/scripts/miscellaneous/ismac.m
+++ b/scripts/miscellaneous/ismac.m
@@ -27,8 +27,10 @@ function retval = ismac ()
   if (nargin == 0)
     retval = octave_config_info ("mac");
   else
     print_usage ();
   endif
 
 endfunction
 
+%!error ismac (1);
+%!assert (islogical (ismac ()));
diff --git a/scripts/miscellaneous/ispc.m b/scripts/miscellaneous/ispc.m
--- a/scripts/miscellaneous/ispc.m
+++ b/scripts/miscellaneous/ispc.m
@@ -26,8 +26,11 @@ function retval = ispc ()
 
   if (nargin == 0)
     retval = octave_config_info ("windows");
   else
     print_usage ();
   endif
 
 endfunction
+
+%!error ispc (1);
+%!assert (islogical (ispc ()));
diff --git a/scripts/miscellaneous/isunix.m b/scripts/miscellaneous/isunix.m
--- a/scripts/miscellaneous/isunix.m
+++ b/scripts/miscellaneous/isunix.m
@@ -26,8 +26,11 @@ function retval = isunix ()
 
   if (nargin == 0)
     retval = octave_config_info ("unix");
   else
     print_usage ();
   endif
 
 endfunction
+
+%!error isunix (1);
+%!assert (islogical (isunix ()));
diff --git a/scripts/miscellaneous/module.mk b/scripts/miscellaneous/module.mk
--- a/scripts/miscellaneous/module.mk
+++ b/scripts/miscellaneous/module.mk
@@ -56,17 +56,16 @@ miscellaneous_FCN_FILES = \
   miscellaneous/setappdata.m \
   miscellaneous/setfield.m \
   miscellaneous/substruct.m \
   miscellaneous/swapbytes.m \
   miscellaneous/symvar.m \
   miscellaneous/tar.m \
   miscellaneous/tempdir.m \
   miscellaneous/tempname.m \
-  miscellaneous/unimplemented.m \
   miscellaneous/unix.m \
   miscellaneous/unpack.m \
   miscellaneous/untar.m \
   miscellaneous/unzip.m \
   miscellaneous/ver.m \
   miscellaneous/version.m \
   miscellaneous/warning_ids.m \
   miscellaneous/what.m \
diff --git a/scripts/miscellaneous/news.m b/scripts/miscellaneous/news.m
--- a/scripts/miscellaneous/news.m
+++ b/scripts/miscellaneous/news.m
@@ -31,8 +31,12 @@ function news ()
     while (ischar (line = fgets (f)))
       puts (line);
     endwhile
   else
     error ("news: unable to locate NEWS file");
   endif
 
 endfunction
+
+
+## Remove from test statistics.  No real tests possible
+%!assert (1)
diff --git a/scripts/miscellaneous/paren.m b/scripts/miscellaneous/paren.m
--- a/scripts/miscellaneous/paren.m
+++ b/scripts/miscellaneous/paren.m
@@ -16,8 +16,12 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Operator} {} (
 ## @deftypefnx {Operator} {} )
 ## Array index or function argument delimeter.
 ## @end deftypefn
+
+## Mark file as being tested.  No real test needed for a documentation .m file
+%!assert (1)
+
diff --git a/scripts/miscellaneous/semicolon.m b/scripts/miscellaneous/semicolon.m
--- a/scripts/miscellaneous/semicolon.m
+++ b/scripts/miscellaneous/semicolon.m
@@ -16,8 +16,12 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Operator} {} ;
 ## Array row or command separator.
 ## @seealso{comma}
 ## @end deftypefn
+
+## Mark file as being tested.  No real test needed for a documentation .m file
+%!assert (1)
+
diff --git a/scripts/miscellaneous/swapbytes.m b/scripts/miscellaneous/swapbytes.m
--- a/scripts/miscellaneous/swapbytes.m
+++ b/scripts/miscellaneous/swapbytes.m
@@ -27,16 +27,17 @@
 ## @result{} [   256   512   768  1024]
 ## @end group
 ## @end example
 ##
 ## @seealso{typecast, cast}
 ## @end deftypefn
 
 function y = swapbytes (x)
+
   if (nargin != 1)
     print_usage ();
   endif
 
   clx = class (x);
   if (strcmp (clx, "int8") || strcmp (clx, "uint8") || isempty (x))
     y = x;
   else
@@ -48,9 +49,16 @@ function y = swapbytes (x)
             || strcmp (clx, "double"))
       nb = 8;
     else
       error ("swapbytes: invalid class of object");
     endif
     y = reshape (typecast (reshape (typecast (x(:), "uint8"), nb, numel (x))
                            ([nb : -1 : 1], :) (:), clx), size(x));
   endif
+
 endfunction
+
+
+%!assert (double (swapbytes (uint16 (1:4))), [256 512 768 1024])
+%!error (swapbytes ())
+%!error (swapbytes (1, 2))
+
diff --git a/scripts/miscellaneous/symvar.m b/scripts/miscellaneous/symvar.m
--- a/scripts/miscellaneous/symvar.m
+++ b/scripts/miscellaneous/symvar.m
@@ -23,8 +23,11 @@
 ## @code{eps}, @code{i} or @code{j} are ignored.  The arguments that are
 ## found are returned in a cell array of strings.  If no variables are
 ## found then the returned cell array is empty.
 ## @end deftypefn
 
 function args = symvar (s)
   args = argnames (inline (s));
 endfunction
+
+## This function is tested by the tests for argnames().
+%!assert (1)
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -279,8 +279,11 @@
 ## will print a warning if a switch label is not a constant or constant
 ## expression.  By default, the @code{Octave:variable-switch-label}
 ## warning is disabled.
 ## @end table
 
 function warning_ids ()
   help ("warning_ids");
 endfunction
+
+## Remove from test statistics.  No real tests possible
+%!assert (1)
diff --git a/scripts/path/matlabroot.m b/scripts/path/matlabroot.m
--- a/scripts/path/matlabroot.m
+++ b/scripts/path/matlabroot.m
@@ -26,10 +26,10 @@
 ## @end deftypefn
 
 function val = matlabroot ()
 
   val = OCTAVE_HOME;
 
 endfunction
 
+%!assert (matlabroot(), OCTAVE_HOME())
 
-
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -15,18 +15,20 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} pkg @var{command} @var{pkg_name}
 ## @deftypefnx {Command} {} pkg @var{command} @var{option} @var{pkg_name}
-## This command interacts with the package manager.  Different actions will
-## be taken depending on the value of @var{command}.
+## Manage packages (groups of add-on functions) for Octave.  Different actions
+## are available depending on the value of @var{command}.  
+##
+## Available commands:
 ##
 ## @table @samp
 ##
 ## @item install
 ## Install named packages.  For example,
 ##
 ## @example
 ## pkg install image-1.0.0.tar.gz
@@ -35,44 +37,54 @@
 ## @noindent
 ## installs the package found in the file @file{image-1.0.0.tar.gz}.
 ##
 ## The @var{option} variable can contain options that affect the manner
 ## in which a package is installed.  These options can be one or more of
 ##
 ## @table @code
 ## @item -nodeps
-## The package manager will disable the dependency checking.  That way it
-## is possible to install a package even if it depends on another package
-## that's not installed on the system.  @strong{Use this option with care.}
+## The package manager will disable dependency checking.  With this option it
+## is possible to install a package even when it depends on another package
+## which is not installed on the system.  @strong{Use this option with care.}
 ##
 ## @item -noauto
 ## The package manager will not automatically load the installed package
-## when starting Octave, even if the package requests that it is.
+## when starting Octave.  This overrides any setting within the package.
 ##
 ## @item -auto
 ## The package manager will automatically load the installed package when
-## starting Octave, even if the package requests that it isn't.
+## starting Octave.  This overrides any setting within the package.
 ##
 ## @item -local
-## A local installation is forced, even if the user has system privileges.
+## A local installation (package available only to current user) is forced, 
+## even if the user has system privileges.
 ##
 ## @item -global
-## A global installation is forced, even if the user doesn't normally have
-## system privileges
+## A global installation (package available to all users) is forced, even if
+## the user doesn't normally have system privileges.
 ##
 ## @item -forge
 ## Install a package directly from the Octave-Forge repository.  This
 ## requires an internet connection and the cURL library.
 ##
 ## @item -verbose
-## The package manager will print the output of all of the commands that are
-## performed.
+## The package manager will print the output of all commands as
+## they are performed.
 ## @end table
 ##
+## @item update
+## Check installed Octave-Forge pacakages against repository and update any
+## outdated items.  This requires an internet connection and the cURL library.
+## Usage:
+##
+## @example
+## pkg update
+## @end example
+##
 ## @item uninstall
 ## Uninstall named packages.  For example,
 ##
 ## @example
 ## pkg uninstall image
 ## @end example
 ##
 ## @noindent
@@ -85,75 +97,81 @@
 ## possible to use the functions provided by the package.  For example,
 ##
 ## @example
 ## pkg load image
 ## @end example
 ##
 ## @noindent
 ## adds the @code{image} package to the path.  It is possible to load all
-## installed packages at once with the command
+## installed packages at once with the keyword @samp{all}.  Usage:
 ##
 ## @example
 ## pkg load all
 ## @end example
 ##
 ## @item unload
-## Removes named packages from the path.  After unloading a package it is
-## no longer possible to use the functions provided by the package.
-## This command behaves like the @code{load} command.
+## Remove named packages from the path.  After unloading a package it is
+## no longer possible to use the functions provided by the package.  It is
+## possible to unload all installed packages at once with the keyword
+## @samp{all}.  Usage:
+##
+## @example
+## pkg unload all
+## @end example
 ##
 ## @item list
-## Show a list of the currently installed packages.  By requesting one or two
-## output argument it is possible to get a list of the currently installed
-## packages.  For example,
+## Show the list of currently installed packages.  For example,
 ##
 ## @example
-## installed_packages = pkg list;
+## installed_packages = pkg ("list")
 ## @end example
 ##
 ## @noindent
 ## returns a cell array containing a structure for each installed package.
-## The command
 ##
+## If two output arguments are requested @code{pkg} splits the list of
+## installed packages into those which were installed by the current user,
+## and those which were installed by the system administrator.
+## 
 ## @example
-## [@var{user_packages}, @var{system_packages}] = pkg list
+## [user_packages, system_packages] = pkg ("list")
 ## @end example
 ##
-## @noindent
-## splits the list of installed packages into those who are installed by
-## the current user, and those installed by the system administrator.
+## The option '-forge' lists packages available at the Octave-Forge repository.
+## This requires an internet connection and the cURL library.  For example:
 ##
-## The option '-forge' lists packages available at the Octave-Forge repository.
-## This requires an internet connection and the cURL library.
+## @example
+## oct_forge_pkgs = pkg ("list", "-forge")
+## @end example
 ##
 ## @item describe
 ## Show a short description of the named installed packages, with the option
-## '-verbose' also list functions provided by the package, e.g.:
+## '-verbose' also list functions provided by the package.  For example,
 ##
 ## @example
-##  pkg describe -verbose all
+## pkg describe -verbose all
 ## @end example
 ##
 ## @noindent
 ## will describe all installed packages and the functions they provide.
 ## If one output is requested a cell of structure containing the
 ## description and list of functions of each package is returned as
 ## output rather than printed on screen:
 ##
 ## @example
-##  desc = pkg ("describe", "secs1d", "image")
+## desc = pkg ("describe", "secs1d", "image")
 ## @end example
 ##
 ## @noindent
 ## If any of the requested packages is not installed, pkg returns an
 ## error, unless a second output is requested:
 ##
 ## @example
-##  [ desc, flag] = pkg ("describe", "secs1d", "image")
+## [desc, flag] = pkg ("describe", "secs1d", "image")
 ## @end example
 ##
 ## @noindent
 ## @var{flag} will take one of the values "Not installed", "Loaded" or
 ## "Not loaded" for each of the named packages.
 ##
 ## @item prefix
 ## Set the installation prefix directory.  For example,
@@ -165,83 +183,84 @@
 ## @noindent
 ## sets the installation prefix to @file{~/my_octave_packages}.
 ## Packages will be installed in this directory.
 ##
 ## It is possible to get the current installation prefix by requesting an
 ## output argument.  For example:
 ##
 ## @example
-## p = pkg prefix
+## pfx = pkg ("prefix")
 ## @end example
 ##
 ## The location in which to install the architecture dependent files can be
-## independent specified with an addition argument.  For example:
+## independently specified with an addition argument.  For example:
 ##
 ## @example
 ## pkg prefix ~/my_octave_packages ~/my_arch_dep_pkgs
 ## @end example
 ##
 ## @item local_list
-## Set the file in which to look for information on the locally
+## Set the file in which to look for information on locally
 ## installed packages.  Locally installed packages are those that are
-## typically available only to the current user.  For example:
+## available only to the current user.  For example:
 ##
 ## @example
 ## pkg local_list ~/.octave_packages
 ## @end example
 ##
 ## It is possible to get the current value of local_list with the following
 ##
 ## @example
 ## pkg local_list
 ## @end example
 ##
 ## @item global_list
-## Set the file in which to look for, for information on the globally
+## Set the file in which to look for information on globally
 ## installed packages.  Globally installed packages are those that are
-## typically available to all users.  For example:
+## available to all users.  For example:
 ##
 ## @example
 ## pkg global_list /usr/share/octave/octave_packages
 ## @end example
 ##
 ## It is possible to get the current value of global_list with the following
 ##
 ## @example
 ## pkg global_list
 ## @end example
 ##
-## @item rebuild
-## Rebuilds the package database from the installed directories.  This can
-## be used in cases where for some reason the package database is corrupted.
-## It can also take the @option{-auto} and @option{-noauto} options to allow the
-## autoloading state of a package to be changed.  For example,
-##
-## @example
-## pkg rebuild -noauto image
-## @end example
-##
-## @noindent
-## will remove the autoloading status of the image package.
-##
 ## @item build
-## Builds a binary form of a package or packages.  The binary file produced
+## Build a binary form of a package or packages.  The binary file produced
 ## will itself be an Octave package that can be installed normally with
 ## @code{pkg}.  The form of the command to build a binary package is
 ##
 ## @example
 ## pkg build builddir image-1.0.0.tar.gz @dots{}
 ## @end example
 ##
 ## @noindent
 ## where @code{builddir} is the name of a directory where the temporary
 ## installation will be produced and the binary packages will be found.
 ## The options @option{-verbose} and @option{-nodeps} are respected, while
-## the other options are ignored.
+## all other options are ignored.
+##
+## @item rebuild
+## Rebuild the package database from the installed directories.  This can
+## be used in cases where the package database has been corrupted.
+## It can also take the @option{-auto} and @option{-noauto} options to allow the
+## autoloading state of a package to be changed.  For example,
+##
+## @example
+## pkg rebuild -noauto image
+## @end example
+##
+## @noindent
+## will remove the autoloading status of the image package.
+##
 ## @end table
 ## @end deftypefn
 
 function [local_packages, global_packages] = pkg (varargin)
   ## Installation prefix (FIXME: what should these be on windows?)
   persistent user_prefix = false;
   persistent prefix = -1;
   persistent archprefix = -1;
@@ -262,17 +281,18 @@ function [local_packages, global_package
       archprefix = prefix;
     endif
     prefix = tilde_expand (prefix);
     archprefix = tilde_expand (archprefix);
   endif
 
   available_actions = {"list", "install", "uninstall", "load", ...
                        "unload", "prefix", "local_list", ...
-                       "global_list", "rebuild", "build","describe"};
+                       "global_list", "rebuild", "build", ...
+                       "describe", "update"};
   ## Handle input
   if (length (varargin) == 0 || ! iscellstr (varargin))
     print_usage ();
   endif
   files = {};
   deps = true;
   auto = 0;
   action = "none";
@@ -487,16 +507,31 @@ function [local_packages, global_package
           [pkg_desc_list, flag] = describe (files, verbose, local_list, ...
                                             global_list);
           local_packages  = pkg_desc_list;
           global_packages = flag;
         otherwise
           error ("you can request at most two outputs when calling 'pkg describe'");
       endswitch
 
+    case "update"
+      if (nargout == 0)
+        installed_pkgs_lst = installed_packages (local_list, global_list);
+        for i = 1:length (installed_pkgs_lst)
+          installed_pkg_name = installed_pkgs_lst{i}.name;
+          installed_pkg_version = installed_pkgs_lst{i}.version;
+          forge_pkg_version = get_forge_pkg (installed_pkg_name);
+          if (compare_versions (forge_pkg_version, installed_pkg_version, ">"))
+            feval (@pkg, "install", "-forge", installed_pkg_name);
+          endif
+        endfor
+      else
+        error ("no output arguments available");
+      endif
+
     otherwise
       error ("you must specify a valid action for 'pkg'. See 'help pkg' for details");
   endswitch
 endfunction
 
 function descriptions = rebuild (prefix, archprefix, list, files, auto, verbose)
   if (isempty (files))
     [dirlist, err, msg] = readdir (prefix);
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -15,48 +15,48 @@ plot_PRIVATE_FCN_FILES = \
   plot/private/__clabel__.m \
   plot/private/__color_str_rgb__.m \
   plot/private/__contour__.m \
   plot/private/__default_plot_options__.m \
   plot/private/__errcomm__.m \
   plot/private/__errplot__.m \
   plot/private/__ezplot__.m \
   plot/private/__fltk_file_filter__.m \
-  plot/private/__ghostscript__.m \
+  plot/private/__fltk_ginput__.m \
+  plot/private/__fltk_print__.m \
   plot/private/__getlegenddata__.m \
+  plot/private/__ghostscript__.m \
+  plot/private/__gnuplot_get_var__.m \
+  plot/private/__gnuplot_ginput__.m \
+  plot/private/__gnuplot_has_feature__.m \
   plot/private/__gnuplot_has_terminal__.m\
+  plot/private/__gnuplot_open_stream__.m \
+  plot/private/__gnuplot_print__.m \
+  plot/private/__gnuplot_version__.m \
+  plot/private/__go_draw_axes__.m \
+  plot/private/__go_draw_figure__.m \
   plot/private/__interp_cube__.m \
   plot/private/__line__.m \
+  plot/private/__marching_cube__.m \
+  plot/private/__next_line_color__.m \
+  plot/private/__next_line_style__.m \
   plot/private/__patch__.m \
   plot/private/__pie__.m \
   plot/private/__plt__.m \
   plot/private/__pltopt__.m \
+  plot/private/__print_parse_opts__.m \
   plot/private/__quiver__.m \
   plot/private/__scatter__.m \
   plot/private/__stem__.m \
   plot/private/__tight_eps_bbox__.m
 
 plot_FCN_FILES = \
-  plot/__fltk_ginput__.m \
-  plot/__fltk_print__.m \
   plot/__gnuplot_drawnow__.m \
-  plot/__gnuplot_get_var__.m \
-  plot/__gnuplot_ginput__.m \
-  plot/__gnuplot_has_feature__.m \
-  plot/__gnuplot_open_stream__.m \
-  plot/__gnuplot_print__.m \
-  plot/__gnuplot_version__.m \
   plot/__go_close_all__.m \
-  plot/__go_draw_axes__.m \
-  plot/__go_draw_figure__.m \
-  plot/__marching_cube__.m \
-  plot/__next_line_color__.m \
-  plot/__next_line_style__.m \
   plot/__plt_get_axis_arg__.m \
-  plot/__print_parse_opts__.m \
   plot/allchild.m \
   plot/ancestor.m \
   plot/area.m \
   plot/axes.m \
   plot/axis.m \
   plot/bar.m \
   plot/barh.m \
   plot/box.m \
@@ -166,16 +166,19 @@ plot_FCN_FILES = \
   plot/subplot.m \
   plot/surf.m \
   plot/surface.m \
   plot/surfc.m \
   plot/surfl.m \
   plot/surfnorm.m \
   plot/text.m \
   plot/title.m \
+  plot/trimesh.m \
+  plot/triplot.m \
+  plot/trisurf.m \
   plot/uigetdir.m \
   plot/uigetfile.m \
   plot/uimenu.m \
   plot/uiputfile.m \
   plot/view.m \
   plot/waitforbuttonpress.m \
   plot/whitebg.m \
   plot/xlabel.m \
diff --git a/scripts/plot/pcolor.m b/scripts/plot/pcolor.m
--- a/scripts/plot/pcolor.m
+++ b/scripts/plot/pcolor.m
@@ -75,8 +75,19 @@ function h = pcolor (x, y, c)
     set (ax, "view", [0, 90]);
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
+
+%!demo
+%! clf
+%! [~,~,Z]=peaks;
+%! pcolor(Z);
+
+%!demo
+%! [X,Y,Z]=sombrero;
+%! [Fx,Fy] = gradient(Z);
+%! pcolor(X,Y,Fx+Fy);
+%! shading interp;
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -206,8 +206,20 @@ function retval = __plr2__ (h, theta, rh
     else
       error ("__plr2__: invalid data for plotting");
     endif
   else
     error ("__plr2__: invalid data for plotting");
   endif
 
 endfunction
+
+
+%!demo
+%! theta = linspace (0, 2*pi, 1000);
+%! rho = sin (7*theta);
+%! polar (theta, rho);
+
+%!demo
+%! theta = linspace (0, 10*pi, 1000);
+%! rho = sin (5/4*theta);
+%! polar (theta, rho);
+
diff --git a/scripts/plot/__fltk_ginput__.m b/scripts/plot/private/__fltk_ginput__.m
rename from scripts/plot/__fltk_ginput__.m
rename to scripts/plot/private/__fltk_ginput__.m
diff --git a/scripts/plot/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
rename from scripts/plot/__fltk_print__.m
rename to scripts/plot/private/__fltk_print__.m
diff --git a/scripts/plot/__gnuplot_get_var__.m b/scripts/plot/private/__gnuplot_get_var__.m
rename from scripts/plot/__gnuplot_get_var__.m
rename to scripts/plot/private/__gnuplot_get_var__.m
diff --git a/scripts/plot/__gnuplot_ginput__.m b/scripts/plot/private/__gnuplot_ginput__.m
rename from scripts/plot/__gnuplot_ginput__.m
rename to scripts/plot/private/__gnuplot_ginput__.m
diff --git a/scripts/plot/__gnuplot_has_feature__.m b/scripts/plot/private/__gnuplot_has_feature__.m
rename from scripts/plot/__gnuplot_has_feature__.m
rename to scripts/plot/private/__gnuplot_has_feature__.m
diff --git a/scripts/plot/__gnuplot_open_stream__.m b/scripts/plot/private/__gnuplot_open_stream__.m
rename from scripts/plot/__gnuplot_open_stream__.m
rename to scripts/plot/private/__gnuplot_open_stream__.m
diff --git a/scripts/plot/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
rename from scripts/plot/__gnuplot_print__.m
rename to scripts/plot/private/__gnuplot_print__.m
diff --git a/scripts/plot/__gnuplot_version__.m b/scripts/plot/private/__gnuplot_version__.m
rename from scripts/plot/__gnuplot_version__.m
rename to scripts/plot/private/__gnuplot_version__.m
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
rename from scripts/plot/__go_draw_axes__.m
rename to scripts/plot/private/__go_draw_axes__.m
diff --git a/scripts/plot/__go_draw_figure__.m b/scripts/plot/private/__go_draw_figure__.m
rename from scripts/plot/__go_draw_figure__.m
rename to scripts/plot/private/__go_draw_figure__.m
diff --git a/scripts/plot/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
rename from scripts/plot/__marching_cube__.m
rename to scripts/plot/private/__marching_cube__.m
diff --git a/scripts/plot/__next_line_color__.m b/scripts/plot/private/__next_line_color__.m
rename from scripts/plot/__next_line_color__.m
rename to scripts/plot/private/__next_line_color__.m
diff --git a/scripts/plot/__next_line_style__.m b/scripts/plot/private/__next_line_style__.m
rename from scripts/plot/__next_line_style__.m
rename to scripts/plot/private/__next_line_style__.m
diff --git a/scripts/plot/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
rename from scripts/plot/__print_parse_opts__.m
rename to scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -356,66 +356,67 @@ function arg_st = __print_parse_opts__ (
         warning ("print:missing_pstoedit", "print.m: pstoedit binary is not available.\nSome output formats are not available.");
       endif
     endif
     warn_on_missing_binary = false;
   endif
 
 endfunction
 
-%!test
+## Test blocks are not allowed (and not needed) for private functions
+#%!test
 %! opts = __print_parse_opts__ ();
 %! assert (opts.devopt, "pswrite");
 %! assert (opts.use_color, 1);
 %! assert (opts.send_to_printer, true);
 %! assert (opts.canvas_size, [576, 432]);
 %! assert (opts.ghostscript.device, "pswrite")
 
-%!test
+#%!test
 %! opts = __print_parse_opts__ ("test.pdf", "-S640,480");
 %! assert (opts.canvas_size, [307.2, 230.4], 0.1);
 
-%!test
+#%!test
 %! opts = __print_parse_opts__ ("-dpsc", "-append", "-loose");
 %! assert (opts.devopt, "pswrite");
 %! assert (opts.send_to_printer, true);
 %! assert (opts.use_color, 1);
 %! assert (opts.append_to_file, false);
 %! assert (opts.ghostscript.device, "pswrite")
 %! assert (opts.ghostscript.epscrop, false);
 
-%!test
+#%!test
 %! opts = __print_parse_opts__ ("-deps", "-tight");
 %! assert (opts.tight_flag, true);
 %! assert (opts.send_to_printer, true);
 %! assert (opts.use_color, -1);
 %! assert (opts.ghostscript.device, "")
 
-%!test
+#%!test
 %! opts = __print_parse_opts__ ("-djpg", "foobar", "-mono", "-loose");
 %! assert (opts.devopt, "jpeg")
 %! assert (opts.name, "foobar.jpg")
 %! assert (opts.ghostscript.device, "jpeg")
 %! assert (opts.ghostscript.epscrop, true);
 %! assert (opts.ghostscript.papersize, "");
 %! assert (opts.ghostscript.pageoffset, [0, 0]);
 %! assert (opts.send_to_printer, false);
 %! assert (opts.printer, "");
 %! assert (opts.use_color, -1);
 
-%!test
+#%!test
 %! opts = __print_parse_opts__ ("-ddeskjet", "foobar", "-mono", "-Pmyprinter");
 %! assert (opts.ghostscript.output, "foobar.deskjet")
 %! assert (opts.ghostscript.device, "deskjet")
 %! assert (opts.devopt, "deskjet")
 %! assert (opts.send_to_printer, true);
 %! assert (opts.printer, "-Pmyprinter");
 %! assert (opts.use_color, -1);
 
-%!test
+#%!test
 %! opts = __print_parse_opts__ ("-f5", "-dljet3");
 %! assert (opts.ghostscript.device, "ljet3")
 %! assert (strfind (opts.ghostscript.output, ".ljet3"))
 %! assert (opts.devopt, "ljet3")
 %! assert (opts.send_to_printer, true);
 %! assert (opts.figure, 5)
 
 function cmd = __quote_path__ (cmd)
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -150,8 +150,12 @@ function [h, bad_usage] = __surface__ (a
                         other_args{:});
 
     if (! ishold ())
       set (ax, "view", [0, 90], "box", "off");
     endif
   endif
 
 endfunction
+
+## Mark file as being tested.  Tests for surface are in
+## surf.m, surfc.m, surfl.m, and pcolor.m
+%!assert(1)
diff --git a/scripts/geometry/trimesh.m b/scripts/plot/trimesh.m
rename from scripts/geometry/trimesh.m
rename to scripts/plot/trimesh.m
diff --git a/scripts/geometry/triplot.m b/scripts/plot/triplot.m
rename from scripts/geometry/triplot.m
rename to scripts/plot/triplot.m
diff --git a/scripts/geometry/trisurf.m b/scripts/plot/trisurf.m
rename from scripts/geometry/trisurf.m
rename to scripts/plot/trisurf.m
diff --git a/scripts/polynomial/module.mk b/scripts/polynomial/module.mk
--- a/scripts/polynomial/module.mk
+++ b/scripts/polynomial/module.mk
@@ -5,17 +5,16 @@ polynomial_FCN_FILES = \
   polynomial/conv.m \
   polynomial/deconv.m \
   polynomial/mkpp.m \
   polynomial/mpoles.m \
   polynomial/pchip.m \
   polynomial/poly.m \
   polynomial/polyaffine.m \
   polynomial/polyder.m \
-  polynomial/polyderiv.m \
   polynomial/polyfit.m \
   polynomial/polygcd.m \
   polynomial/polyint.m \
   polynomial/polyout.m \
   polynomial/polyreduce.m \
   polynomial/polyval.m \
   polynomial/polyvalm.m \
   polynomial/ppval.m \
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1995-2011 John W. Eaton
+## Copyright (C) 1994-2011 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -12,32 +12,89 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} polyderiv (@var{p})
-## @deftypefnx {Function File} {[@var{k}] =} polyderiv (@var{a}, @var{b})
-## @deftypefnx {Function File} {[@var{q}, @var{d}] =} polyderiv (@var{b}, @var{a})
-## An alias for @code{polyderiv}.
-## @seealso{polyderiv}
+## @deftypefn  {Function File} {} polyder (@var{p})
+## @deftypefnx {Function File} {[@var{k}] =} polyder (@var{a}, @var{b})
+## @deftypefnx {Function File} {[@var{q}, @var{d}] =} polyder (@var{b}, @var{a})
+## Return the coefficients of the derivative of the polynomial whose
+## coefficients are given by the vector @var{p}.  If a pair of polynomials
+## is given, return the derivative of the product @math{@var{a}*@var{b}}.
+## If two inputs and two outputs are given, return the derivative of the
+## polynomial quotient @math{@var{b}/@var{a}}.  The quotient numerator is
+## in @var{q} and the denominator in @var{d}.
+## @seealso{poly, polyint, polyreduce, roots, conv, deconv, residue,
+## filter, polygcd, polyval, polyvalm}
 ## @end deftypefn
 
-## Author: John W. Eaton
+## Author: Tony Richardson <arichard@stark.cc.oh.us>
+## Created: June 1994
+## Adapted-By: jwe
 
 function [q, d] = polyder (p, a)
 
-  if (nargin == 1)
-    q = polyderiv (p);
-  elseif (nargin == 2)
-    if (nargout == 2)
-      [q, d] = polyderiv (p, a);
+  if (nargin == 1 || nargin == 2)
+    if (! isvector (p))
+      error ("polyder: argument must be a vector");
+    endif
+    if (nargin == 2)
+      if (! isvector (a))
+        error ("polyder: argument must be a vector");
+      endif
+      if (nargout == 1)
+        ## derivative of p*a returns a single polynomial
+        q = polyder (conv (p, a));
+      else
+        ## derivative of p/a returns numerator and denominator
+        d = conv (a, a);
+        if (numel (p) == 1)
+          q = -p * polyder (a);
+        elseif (numel (a) == 1)
+          q = a * polyder (p);
+        else
+          q = conv (polyder (p), a) - conv (p, polyder (a));
+          q = polyreduce (q);
+        endif
+
+        ## remove common factors from numerator and denominator
+        x = polygcd (q, d);
+        if (length(x) != 1)
+          q = deconv (q, x);
+          d = deconv (d, x);
+        endif
+
+        ## move all the gain into the numerator
+        q = q/d(1);
+        d = d/d(1);
+      endif
     else
-      q = polyderiv (p, a);
+      lp = numel (p);
+      if (lp == 1)
+        q = 0;
+        return;
+      elseif (lp == 0)
+        q = [];
+        return;
+      endif
+
+      ## Force P to be a row vector.
+      p = p(:).';
+
+      q = p(1:(lp-1)) .* [(lp-1):-1:1];
     endif
   else
     print_usage ();
   endif
 
 endfunction
+
+
+%!assert(all (all (polyder ([1, 2, 3]) == [2, 2])));
+%!assert(polyder (13) == 0);
+
+%!error polyder ([]);
+%!error polyder ([1, 2; 3, 4]);
+
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -56,8 +56,23 @@ function retval = polyint (p, k)
   if (rows (p) > 1)
     ## Convert to column vector
     p = p.';
   endif
 
   retval = [(p ./ [lp:-1:1]), k];
 
 endfunction
+
+%!test
+%! A = [3, 2, 1];
+%! assert (polyint(A),polyint(A,0));
+%! assert (polyint(A),polyint(A'));
+%! assert (polyint(A),[1, 1, 1, 0]);
+%! assert (polyint(A,1),ones(1,4));
+
+%!test
+%! A = ones(1,8);
+%! B = [length(A):-1:1];
+%! assert (polyint(A),[1./B, 0]);
+
+%!error polyint()
+%!error polyint(ones(2,2))
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -92,8 +92,14 @@ function str = coeff (c)
       str = sprintf ("(%s)", num2str (c, 5));
     else
       str = num2str (c, 5);
     endif
   else
     str = num2str (c, 5);
   endif
 endfunction
+
+%!assert (polyout ([3 2 1]), '3*s^2 + 2*s^1 + 1')
+%!assert (polyout ([3 2 1], 'x'), '3*x^2 + 2*x^1 + 1')
+%!assert (polyout ([3 2 1], 'wxyz'), '3*wxyz^2 + 2*wxyz^1 + 1')
+%!assert (polyout ([5 4 3 2 1], '1'),'5*1^4 + 4*1^3 + 3*1^2 + 2*1^1 + 1')
+%!error polyout ([])
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -70,8 +70,14 @@ function p = powerset (a, byrows_arg)
         p = mat2cell (a(i), 1, k);
       else
         p = mat2cell (a(i), k, 1);
       endif
     endif
   endif
 
 endfunction
+
+
+%!test
+%! c = sort (cellstr ({ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]}));
+%! p = sort (cellstr (powerset ([1, 2, 3])));
+%! assert (p, c);
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -1,41 +1,40 @@
-## Copyright (C) 2008-2011 Jaroslav Hajek
+## Copyright (C) 2008-2011 Jaroslav Hajek 
 ## Copyright (C) 2000, 2006-2007 Paul Kienzle
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
+## under the terms of the GNU General Public License as published by the
+## Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
+## Octave is distributed in the hope that it will be useful, but WITHOUT
+## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} setxor (@var{a}, @var{b})
 ## @deftypefnx {Function File} {} setxor (@var{a}, @var{b}, 'rows')
+## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} setxor (@var{a}, @var{b})
 ##
 ## Return the elements exclusive to @var{a} or @var{b}, sorted in ascending
 ## order.  If @var{a} and @var{b} are both column vectors return a column
 ## vector, otherwise return a row vector.
 ## @var{a}, @var{b} may be cell arrays of string(s).
 ##
-## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} setxor (@var{a}, @var{b})
-##
-## Return index vectors @var{ia} and @var{ib} such that @code{a(ia)} and
-## @code{b(ib)} are
-## disjoint sets whose union is @var{c}.
+## With three output arguments, return index vectors @var{ia} and @var{ib}
+## such that @code{a(ia)} and @code{b(ib)} are disjoint sets whose union
+## is @var{c}.
 ##
 ## @seealso{unique, union, intersect, setdiff, ismember}
 ## @end deftypefn
 
 function [c, ia, ib] = setxor (a, b, varargin)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -42,8 +42,21 @@ function X = autoreg_matrix (y, k)
   T = length (y);
   y = reshape (y, T, 1);
   X = ones (T, k+1);
   for j = 1 : k;
     X(:, j+1) = [(zeros (j, 1)); y(1:T-j)];
   endfor
 
 endfunction
+
+
+%!test
+%! K=4;
+%! A = zeros(1,K+1);
+%! A(1) = 1;
+%! B = eye(K+1);
+%! B(:,1) = 1;
+%! assert (autoreg_matrix(A,K),B);
+
+%!error autoreg_matrix()
+%!error autoreg_matrix(1)
+%!error autoreg_matrix(ones(4,1),5)
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -40,8 +40,15 @@ function result = sinc (x)
   i = (x != 0);
 
   if (any (i(:)))
     t = pi * x(i);
     result(i) = sin (t) ./ t;
   endif
 
 endfunction
+
+
+%!assert (sinc (0), 1);
+%!assert (sinc (1), 0,1e-6);
+%!assert (sinc (1/2), 2/pi, 1e-6)
+
+%!error sinc()
diff --git a/scripts/signal/sinewave.m b/scripts/signal/sinewave.m
--- a/scripts/signal/sinewave.m
+++ b/scripts/signal/sinewave.m
@@ -38,8 +38,18 @@ function x = sinewave (m, n, d)
       n = m;
     endif
     x = sin (((1 : m) + d - 1) * 2 * pi / n);
   else
     print_usage ();
   endif
 
 endfunction
+
+%!assert (sinewave (1), 0);
+%!assert (sinewave (1, 4, 1), 1);
+%!assert (sinewave (1, 12, 1), 1/2, 1e-6);
+%!assert (sinewave (1, 12, 2), sqrt (3)/2, 1e-6);
+%!assert (sinewave (1, 20, 1), (sqrt (5)-1)/4, 1e-6);
+%!assert (sinewave (1), sinewave (1, 1,0));
+%!assert (sinewave (3, 4), sinewave(3, 4, 0));
+
+%!error sinewave ();
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -86,8 +86,9 @@
 ## return @code{NaN}.
 ## @end enumerate
 ## @end deftypefn
 
 function bessel ()
   error ("bessel: you must use besselj, bessely, besseli, or besselk");
 endfunction
 
+%!error bessel ()
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -58,8 +58,16 @@ function A = perms (v)
         A(idx,1:i-1) = B(:,1:i-1);
         A(idx,i) = v(j);
         A(idx,i+1:j) = B(:,i:j-1);
         idx += k;
       endfor
     endfor
   endif
 endfunction
+
+%!error perms ();
+%!error perms (1, 2);
+
+%!assert (perms ([1,2,3]), [1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1]);
+%!assert (perms (1:3), perms ([1,2,3]));
+
+%!assert (perms (int8([1,2,3])), int8([1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1]));
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -87,8 +87,16 @@ function x = primes (n)
          109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, ...
          173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, ...
          233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, ...
          293, 307, 311, 313, 317, 331, 337, 347, 349];
     x = a(a <= n);
   endif
 
 endfunction
+
+%!error primes ();
+%!error primes (1, 2);
+
+%!assert (size (primes (350)), [1, 70]);
+%!assert (size (primes (350)), [1, 70]);
+
+%!assert (primes (357)(end), 353);
diff --git a/scripts/startup/__finish__.m b/scripts/startup/__finish__.m
--- a/scripts/startup/__finish__.m
+++ b/scripts/startup/__finish__.m
@@ -31,8 +31,10 @@ function __finish__ ()
 
   if (exist ("finish", "file"))
     ## No arg list here since finish might be a script.
     finish;
   endif
 
 endfunction
 
+## No test needed for internal helper function.
+%!assert (1)
diff --git a/scripts/statistics/base/corr.m b/scripts/statistics/base/corr.m
new file mode 100644
--- /dev/null
+++ b/scripts/statistics/base/corr.m
@@ -0,0 +1,112 @@
+## Copyright (C) 1996-2011 John W. Eaton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} corr (@var{x})
+## @deftypefnx {Function File} {} corr (@var{x}, @var{y})
+## Compute matrix of correlation coefficients.
+##
+## If each row of @var{x} and @var{y} is an observation and each column is
+## a variable, then the @w{(@var{i}, @var{j})-th} entry of
+## @code{corr (@var{x}, @var{y})} is the correlation between the
+## @var{i}-th variable in @var{x} and the @var{j}-th variable in @var{y}.
+## @tex
+## $$
+## {\rm corr}(x,y) = {{\rm cov}(x,y) \over {\rm std}(x) {\rm std}(y)}
+## $$
+## @end tex
+## @ifnottex
+##
+## @example
+## corr(x,y) = cov(x,y)/(std(x)*std(y))
+## @end example
+##
+## @end ifnottex
+## If called with one argument, compute @code{corr (@var{x}, @var{x})},
+## the correlation between the columns of @var{x}.
+## @seealso{cov}
+## @end deftypefn
+
+## Author: Kurt Hornik <hornik@wu-wien.ac.at>
+## Created: March 1993
+## Adapted-By: jwe
+
+function retval = corr (x, y = [])
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
+
+  ## Input validation is done by cov.m.  Don't repeat tests here
+
+  ## Special case, scalar is always 100% correlated with itself
+  if (isscalar (x))
+    if (isa (x, 'single'))
+      retval = single (1);
+    else
+      retval = 1;
+    endif
+    return;
+  endif
+
+  ## No check for division by zero error, which happens only when
+  ## there is a constant vector and should be rare.
+  if (nargin == 2)
+    c = cov (x, y);
+    s = std (x)' * std (y);
+    retval = c ./ s;
+  else
+    c = cov (x);
+    s = sqrt (diag (c));
+    retval = c ./ (s * s');
+  endif
+
+endfunction
+
+
+%!test
+%! x = rand (10);
+%! cc1 = corr (x);
+%! cc2 = corr (x, x);
+%! assert (size (cc1) == [10, 10] && size (cc2) == [10, 10]);
+%! assert (cc1, cc2, sqrt (eps));
+
+%!test
+%! x = [1:3]';
+%! y = [3:-1:1]';
+%! assert (corr (x,y), -1, 5*eps)
+%! assert (corr (x,flipud (y)), 1, 5*eps)
+%! assert (corr ([x, y]), [1 -1; -1 1], 5*eps)
+
+%!test
+%! x = single ([1:3]');
+%! y = single ([3:-1:1]');
+%! assert (corr (x,y), single (-1), 5*eps)
+%! assert (corr (x,flipud (y)), single (1), 5*eps)
+%! assert (corr ([x, y]), single ([1 -1; -1 1]), 5*eps)
+
+%!assert (corr (5), 1);
+%!assert (corr (single(5)), single(1));
+
+%% Test input validation
+%!error corr ();
+%!error corr (1, 2, 3);
+%!error corr ([1; 2], ["A", "B"]);
+%!error corr (ones (2,2,2));
+%!error corr (ones (2,2), ones (2,2,2));
+
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -50,17 +50,17 @@
 ## @table @asis
 ## @item 0:
 ##   normalize with @math{N-1}, provides the best unbiased estimator of the
 ## covariance [default]
 ##
 ## @item 1:
 ##   normalize with @math{N}, this provides the second moment around the mean
 ## @end table
-## @seealso{corrcoef, cor}
+## @seealso{corr}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute covariances
 
 function c = cov (x, y = [], opt = 0)
 
   if (nargin < 1 || nargin > 3)
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -101,17 +101,17 @@ function tau = kendall (x, y = [])
 
   if (isa (x, 'single') || isa (y, 'single'))
     cls = 'single';
   else
     cls = 'double';
   endif
   r   = ranks (x);
   m   = sign (kron (r, ones (n, 1, cls)) - kron (ones (n, 1, cls), r));
-  tau = corrcoef (m);
+  tau = corr (m);
 
   if (nargin == 2)
     tau = tau(1 : c, (c + 1) : columns (x));
   endif
 
 endfunction
 
 
diff --git a/scripts/statistics/base/module.mk b/scripts/statistics/base/module.mk
--- a/scripts/statistics/base/module.mk
+++ b/scripts/statistics/base/module.mk
@@ -1,17 +1,15 @@
 FCN_FILE_DIRS += statistics/base
 
 statistics_base_FCN_FILES = \
   statistics/base/center.m \
   statistics/base/cloglog.m \
-  statistics/base/cor.m \
-  statistics/base/corrcoef.m \
+  statistics/base/corr.m \
   statistics/base/cov.m \
-  statistics/base/cut.m \
   statistics/base/gls.m \
   statistics/base/histc.m \
   statistics/base/iqr.m \
   statistics/base/kendall.m \
   statistics/base/kurtosis.m \
   statistics/base/logit.m \
   statistics/base/mahalanobis.m \
   statistics/base/mean.m \
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/base/spearman.m
--- a/scripts/statistics/base/spearman.m
+++ b/scripts/statistics/base/spearman.m
@@ -52,25 +52,25 @@ function rho = spearman (x, y = [])
     error ("spearman: X and Y must be 2-D matrices or vectors");
   endif
 
   if (isrow (x))
     x = x.';
   endif
 
   if (nargin == 1)
-    rho = corrcoef (ranks (x));
+    rho = corr (ranks (x));
   else
     if (isrow (y))
       y = y.';
     endif
     if (rows (x) != rows (y))
       error ("spearman: X and Y must have the same number of observations");
     endif
-    rho = corrcoef (ranks (x), ranks (y));
+    rho = corr (ranks (x), ranks (y));
   endif
 
   ## Restore class cleared by ranks
   if (isa (x, 'single') || isa (y, 'single'))
     rho = single (rho);
   endif
 
 endfunction
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -86,26 +86,24 @@ function retval = std (x, opt = 0, dim)
   else
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("std: DIM must be an integer and a valid dimension");
     endif
   endif
 
   n = sz(dim);
-  if (n == 1)
+  if (n == 1 || isempty (x))
     if (isa (x, 'single'))
       retval = zeros (sz, 'single');
     else
       retval = zeros (sz);
     endif
-  elseif (numel (x) > 0)
+  else
     retval = sqrt (sumsq (center (x, dim), dim) / (n - 1 + opt));
-  else
-    error ("std: X must not be empty");
   endif
 
 endfunction
 
 
 %!test
 %! x = ones (10, 2);
 %! y = [1, 3];
@@ -113,16 +111,17 @@ endfunction
 %! assert(std (y), sqrt (2), sqrt (eps));
 %! assert(std (x, 0, 2), zeros (10, 1));
 
 %!assert(std (ones (3, 1, 2), 0, 2), zeros (3, 1, 2));
 %!assert(std ([1 2], 0), sqrt(2)/2, 5*eps);
 %!assert(std ([1 2], 1), 0.5, 5*eps);
 %!assert(std(1), 0);
 %!assert(std(single(1)), single(0));
+%!assert(std([]), []);
+%!assert(std(ones (1,3,0,2)), ones (1,3,0,2));
 
 %% Test input validation
 %!error std ();
 %!error std (1, 2, 3, 4);
 %!error std (['A'; 'B'])
 %!error std (1, -1);
-%!error std ([], 1);
 
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -86,17 +86,17 @@ function t = cor_test (x, y, alt, method
   elseif (! ischar (method))
     error ("cor_test: METHOD must be a string");
   endif
 
   n = length (x);
   m = method (1);
 
   if (m == "p")
-    r = cor (x, y);
+    r = corr (x, y);
     df = n - 2;
     t.method = "Pearson's product moment correlation";
     t.params = df;
     t.stat = sqrt (df) .* r / sqrt (1 - r.^2);
     t.dist = "t";
     cdf  = tcdf (t.stat, df);
   elseif (m == "k")
     tau = kendall (x, y);
diff --git a/scripts/time/now.m b/scripts/time/now.m
--- a/scripts/time/now.m
+++ b/scripts/time/now.m
@@ -32,21 +32,30 @@
 ## @end deftypefn
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Created: 10 October 2001 (CVS)
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function t = now ()
 
-  t = datenum (clock ());
+  if (nargin == 0)
+    t = datenum (clock ());
+  else
+    print_usage ();
+  endif
 
   ## The following doesn't work (e.g., one hour off on 2005-10-04):
   ##
   ##   seconds since 1970-1-1 corrected by seconds from GMT to local time
   ##   divided by 86400 sec/day plus day num for 1970-1-1
   ##   t = (time - mktime(gmtime(0)))/86400 + 719529;
   ##
   ## mktime(gmtime(0)) does indeed return the offset from Greenwich to the
   ## local time zone, but we need to account for daylight savings time
   ## changing by an hour the offset from CUT for part of the year.
 
 endfunction
+
+%!error now (1);
+%!assert (isnumeric (now ()));
+%!assert (now () > 0);
+%!assert (now () <= now ());
diff --git a/src/DLD-FUNCTIONS/__contourc__.cc b/src/DLD-FUNCTIONS/__contourc__.cc
--- a/src/DLD-FUNCTIONS/__contourc__.cc
+++ b/src/DLD-FUNCTIONS/__contourc__.cc
@@ -328,8 +328,15 @@ Undocumented internal function.\n\
       else
         error ("__contourc__: invalid argument values");
     }
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -221,8 +221,15 @@ Undocumented internal function.\n\
     }
 
 #else
   error ("__delaunayn__: not available in this version of Octave");
 #endif
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/__dispatch__.cc b/src/DLD-FUNCTIONS/__dispatch__.cc
--- a/src/DLD-FUNCTIONS/__dispatch__.cc
+++ b/src/DLD-FUNCTIONS/__dispatch__.cc
@@ -124,8 +124,15 @@ DEFUN_DLD (__dispatch__, args, nargout,
       else
         symbol_table::add_dispatch (f, t, r);
     }
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/__dsearchn__.cc b/src/DLD-FUNCTIONS/__dsearchn__.cc
--- a/src/DLD-FUNCTIONS/__dsearchn__.cc
+++ b/src/DLD-FUNCTIONS/__dsearchn__.cc
@@ -103,8 +103,15 @@ Undocumented internal function.\n\
 
           retval(1) = dist;
           retval(0) = idx;
         }
     }
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
--- a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
+++ b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
@@ -125,9 +125,16 @@ Undocumented internal function.\n\
     }
 
   fc.hide ();
   Fl::flush ();
 
   return retval;
 }
 
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
+
 #endif
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -849,8 +849,15 @@ Undocumented internal function.\n\
 #else
 
   gripe_not_supported ("glpk");
 
 #endif
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/DLD-FUNCTIONS/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/DLD-FUNCTIONS/__lin_interpn__.cc
@@ -350,8 +350,15 @@ Undocumented internal function.\n\
             }
         }
 
       retval = lin_interpn<double, NDArray> (n, X, V, Y);
     }
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -526,16 +526,23 @@ function.  Instead use @code{imread}.\n\
 
   error ("imread: image reading capabilities were disabled when Octave was compiled");
 
 #endif
 
   return output;
 }
 
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
+
 #ifdef HAVE_MAGICK
 
 static void
 jpg_settings (std::vector<Magick::Image>& imvec,
               const Octave_map& options,
               bool)
 {
   bool something_set = false;
@@ -912,16 +919,23 @@ function.  Instead use @code{imwrite}.\n
 
   error ("__magick_write__: not available in this version of Octave");
 
 #endif
 
 return retval;
 }
 
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
+
 #ifdef HAVE_MAGICK
 
 template<class T>
 static octave_value
 magick_to_octave_value (const T magick)
 {
   return octave_value (magick);
 }
@@ -1130,16 +1144,23 @@ not be using this function.  Instead use
 
   error ("imfinfo: not available in this version of Octave");
 
 #endif
 
   return retval;
 }
 
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
+
 #undef GET_PARAM
 
 // Determine the file formats supported by GraphicsMagick.  This is
 // called once at the beginning of imread or imwrite to determine
 // exactly which file formats are supported, so error messages can be
 // displayed properly.
 
 DEFUN_DLD (__magick_format_list__, args, ,
@@ -1189,8 +1210,15 @@ Undocumented internal function.\n\
 #else
 
   error ("__magick_format_list__: not available in this version of Octave");
 
 #endif
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
@@ -142,8 +142,15 @@ Undocumented internal function.\n\
             }
 
           retval = dmat;
         }
     }
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/DLD-FUNCTIONS/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/DLD-FUNCTIONS/__qp__.cc
@@ -523,8 +523,15 @@ Undocumented internal function.\n\
       else
         error ("__qp__: invalid arguments");
     }
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -243,8 +243,15 @@ Undocumented internal function.\n\
     error ("__voronoi__: qhull failed");
 
 #else
   error ("__voronoi__: not available in this version of Octave");
 #endif
 
   return retval;
 }
+
+/*
+
+## No test needed for internal helper function.
+%!assert (1)
+
+*/
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -52,17 +52,17 @@ Return the regularized incomplete Beta f
 betainc (x, a, b) = -----------    | t^(a-1) (1-t)^(b-1) dt.\n\
                      beta (a, b)    /\n\
                                  t=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
-If x has more than one component, both @var{a} and @var{b} must be\n\
+If @var{x} has more than one component, both @var{a} and @var{b} must be\n\
 scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of\n\
 compatible dimensions.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -233,16 +233,27 @@ but avoids forming a temporary array and
   else
     error ("dot: X and Y must be numeric");
 
   return retval;
 }
 
 /*
 
+%! assert(dot ([1, 2], [2, 3]), 11);
+
+%!test
+%! x = [2, 1; 2, 1];
+%! y = [-0.5, 2; 0.5, -2];
+%! assert(dot (x, y), [0 0]);
+
+%!test
+%! x = [ 1+i, 3-i; 1-i, 3-i];
+%! assert(dot (x, x), [4, 20]);
+
 */
 
 DEFUN_DLD (blkmm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} blkmm (@var{A}, @var{B})\n\
 Compute products of matrix blocks.  The blocks are given as\n\
 2-dimensional subarrays of the arrays @var{A}, @var{B}.\n\
 The size of @var{A} must have the form @code{[m,k,@dots{}]} and\n\
@@ -339,8 +350,19 @@ then of size @code{[m,n,@dots{}]} and is
                dimx.str ().c_str (), dimy.str ().c_str ());
 
     }
   else
     error ("blkmm: A and B must be numeric");
 
   return retval;
 }
+
+/*
+
+%!test
+%! x(:,:,1) = [1 2; 3 4];
+%! x(:,:,2) = [1 1; 1 1];
+%! z(:,:,1) = [7 10; 15 22];
+%! z(:,:,2) = [2 2; 2 2];
+%! assert(blkmm (x,x),z);
+
+*/
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -198,8 +198,18 @@ givens (1, 1)\n\
                     }
                 }
             }
         }
     }
 
   return retval;
 }
+
+/*
+
+%!assert (givens (1,1), [1, 1; -1, 1]/sqrt(2));
+%!assert (givens (1,0), eye(2));
+%!assert (givens (0,1), [0, 1; -1 0]);
+%!error givens(1);
+%!error givens()
+
+*/
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -259,8 +259,20 @@ kron (1:4, ones (3, 1))\n\
             return do_kron<Matrix, ComplexMatrix> (a, b);
           else
             return do_kron<Matrix, Matrix> (a, b);
         }
     }
 
   return retval;
 }
+
+/*
+
+%!test
+%! x = ones(2);
+%! assert( kron (x, x), ones (4));
+
+%!test
+%! z =  [1,  2,  3,  4; 1,  2,  3,  4; 1,  2,  3,  4];
+%! assert( kron (1:4, ones (3, 1)), z)
+
+*/
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -80,8 +80,17 @@ instead.\n\
       Matrix m = args(0).matrix_value ();
       MatrixType mattyp;
       retval = m.rcond (mattyp);
       args(0).matrix_type (mattyp);
     }
 
   return retval;
 }
+
+/*
+
+%!assert( rcond (eye (2)), 1)
+%!assert( rcond (ones (2)), 0)
+%!assert( rcond ([1 1; 2 1]), 1/9)
+%!assert( rcond (magic (4)), 0, eps)
+
+*/
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -265,8 +265,25 @@ Mathematics, Manchester, England, Januar
       //   norm (s*s - x, "fro") / norm (x, "fro");
 
       octave_value s = retval(0);
       retval(1) = xfrobnorm (s*s - arg) / xfrobnorm (arg);
     }
 
   return retval;
 }
+
+/*
+
+%!assert (sqrtm (2*ones (2)), ones (2), 3*eps)
+
+## The following two tests are from the reference in the docstring above.
+
+%!assert (isnan (sqrtm ([0 1; 0 0])))
+
+%!test
+%! x = eye (4); x(2,2) = x(3,3) = 2^-26; x(1,4) = 1;
+%! z = eye (4); z(2,2) = z(3,3) = 2^-13; z(1,4) = 0.5;
+%! [y, err] = sqrtm(x);
+%! assert (y, z)
+%! assert (err, 0)## Yes, this one has to hold exactly
+
+*/
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -45,17 +45,17 @@ along with Octave; see the file COPYING.
 // http://www-igm.univ-mlv.fr/~lecroq/string/node19.html
 static void
 qs_preprocess (const Array<char>& needle,
                octave_idx_type table[TABSIZE])
 {
   const char *x = needle.data ();
   octave_idx_type m = needle.numel ();
 
-   for (octave_idx_type i = 0; i < UCHAR_MAX; i++)
+   for (octave_idx_type i = 0; i < TABSIZE; i++)
       table[i] = m + 1;
    for (octave_idx_type i = 0; i < m; i++)
       table[ORD(x[i])] = m - i;
 }
 
 
 static Array<octave_idx_type>
 qs_search (const Array<char>& needle,
@@ -198,17 +198,17 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
     }
 
   if (nargin == 2)
     {
       octave_value argstr = args(0), argpat = args(1);
       if (argpat.is_string ())
         {
           Array<char> needle = argpat.char_array_value ();
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, table, UCHAR_MAX);
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
           qs_preprocess (needle, table);
 
           if (argstr.is_string ())
             retval = octave_value (qs_search (needle, argstr.char_array_value (),
                                               table, overlaps),
                                    true, true);
           else if (argstr.is_cell ())
             {
@@ -362,17 +362,17 @@ done for each element and a cell array i
   if (nargin == 3)
     {
       octave_value argstr = args(0), argpat = args(1), argrep = args(2);
       if (argpat.is_string () && argrep.is_string ())
         {
           const Array<char> pat = argpat.char_array_value ();
           const Array<char> rep = argrep.char_array_value ();
 
-          OCTAVE_LOCAL_BUFFER (octave_idx_type, table, UCHAR_MAX);
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
           qs_preprocess (pat, table);
 
           if (argstr.is_string ())
             retval = qs_replace (argstr.char_array_value (), pat, rep, table, overlaps);
           else if (argstr.is_cell ())
             {
               const Cell argsc = argstr.cell_value ();
               Cell retc (argsc.dims ());
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -335,23 +335,23 @@ strftime (\"%r (%Z) %A %e %B %Y\", local
 \n\
 Octave's @code{strftime} function supports a superset of the ANSI C\n\
 field specifiers.\n\
 \n\
 @noindent\n\
 Literal character fields:\n\
 \n\
 @table @code\n\
-@item %\n\
+@item %%\n\
 % character.\n\
 \n\
-@item n\n\
+@item %n\n\
 Newline character.\n\
 \n\
-@item t\n\
+@item %t\n\
 Tab character.\n\
 @end table\n\
 \n\
 @noindent\n\
 Numeric modifiers (a nonstandard extension):\n\
 \n\
 @table @code\n\
 @item - (dash)\n\
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -47,17 +47,16 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #include "oct-map.h"
 #include "unwind-prot.h"
 
 #ifdef HAVE_CURL
 
 #include <curl/curl.h>
 #include <curl/curlver.h>
-#include <curl/types.h>
 #include <curl/easy.h>
 
 static int
 write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
 {
   std::ostream& stream = *(static_cast<std::ostream*> (streamp));
   stream.write (static_cast<const char*> (buffer), size*nmemb);
   return (stream.fail () ? 0 : size * nmemb);
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -305,16 +305,17 @@ octinclude_HEADERS = \
   $(OV_INCLUDES) \
   $(OV_SPARSE_INCLUDES) \
   $(PT_INCLUDES)
 
 nodist_octinclude_HEADERS = \
   defaults.h \
   graphics.h \
   oct-conf.h \
+  profiler.h \
   mxarray.h \
   version.h
 
 OV_INTTYPE_SRC = \
   ov-int16.cc \
   ov-int32.cc \
   ov-int64.cc \
   ov-int8.cc \
@@ -441,16 +442,17 @@ DIST_SRC = \
   oct-prcstrm.cc \
   oct-procbuf.cc \
   oct-stream.cc \
   oct-strstrm.cc \
   octave.cc \
   pager.cc \
   pr-output.cc \
   procstream.cc \
+  profiler.cc \
   sighandlers.cc \
   siglist.c \
   sparse.cc \
   sparse-xdiv.cc \
   sparse-xpow.cc \
   strfns.cc \
   symtab.cc \
   syscalls.cc \
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -414,16 +414,27 @@ the environment variable @w{@env{EDITOR}
 environment variable is not initialized, @w{@env{EDITOR}} will be set to\n\
 @code{\"emacs\"}.\n\
 @seealso{edit_history}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EDITOR);
 }
 
+/*
+%!error (EDITOR (1, 2));
+%!test
+%! orig_val = EDITOR ();
+%! old_val = EDITOR ("X");
+%! assert (orig_val, old_val);
+%! assert (EDITOR (), "X");
+%! EDITOR (orig_val);
+%! assert (EDITOR (), orig_val);
+*/
+
 DEFUN (EXEC_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories to append to the shell PATH when executing external\n\
 programs.  The initial value of is taken from the environment variable\n\
 @w{@env{OCTAVE_EXEC_PATH}}, but that value can be overridden by\n\
@@ -433,43 +444,70 @@ the command line argument @option{--exec
   octave_value retval = SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EXEC_PATH);
 
   if (args.length () > 0)
     set_exec_path (VEXEC_PATH);
 
   return retval;
 }
 
+/*
+%!error (EXEC_PATH (1, 2));
+%!test
+%! orig_val = EXEC_PATH ();
+%! old_val = EXEC_PATH ("X");
+%! assert (orig_val, old_val);
+%! assert (EXEC_PATH (), "X");
+%! EXEC_PATH (orig_val);
+%! assert (EXEC_PATH (), orig_val);
+*/
+
 DEFUN (IMAGE_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} IMAGE_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} IMAGE_PATH (@var{new_val})\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories in which to search for image files.\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (IMAGE_PATH);
 }
 
+/*
+%!error (IMAGE_PATH (1, 2));
+%!test
+%! orig_val = IMAGE_PATH ();
+%! old_val = IMAGE_PATH ("X");
+%! assert (orig_val, old_val);
+%! assert (IMAGE_PATH (), "X");
+%! IMAGE_PATH (orig_val);
+%! assert (IMAGE_PATH (), orig_val);
+*/
+
 DEFUN (OCTAVE_HOME, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_HOME ()\n\
 Return the name of the top-level Octave installation directory.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = Voctave_home;
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error OCTAVE_HOME (1);
+%!assert (ischar (OCTAVE_HOME ()));
+*/
+
 DEFUNX ("OCTAVE_VERSION", FOCTAVE_VERSION, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_VERSION ()\n\
 Return the version number of Octave, as a string.\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -477,8 +515,13 @@ Return the version number of Octave, as 
 
   if (nargin == 0)
     retval = OCTAVE_VERSION;
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+%!error OCTAVE_VERSION (1);
+%!assert (ischar (OCTAVE_VERSION ()));
+*/
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1917,17 +1917,17 @@ system-dependent error message.\n\
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      FILE *fid = tmpfile ();
+      FILE *fid = gnulib::tmpfile ();
 
       if (fid)
         {
           std::string nm;
 
           std::ios::openmode md = fopen_mode_to_ios_mode ("w+b");
 
           octave_stream s = octave_stdiostream::create (nm, fid, md);
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -3167,16 +3167,17 @@ axes::properties::init (void)
   Matrix upv (1, 3, 0.0);
   upv(2) = 1.0;
   cameraupvector = upv;
   cameraupvector.add_constraint (dim_vector (1, 3));
   currentpoint.add_constraint (dim_vector (2, 3));
   ticklength.add_constraint (dim_vector (1, 2));
   tightinset.add_constraint (dim_vector (1, 4));
   looseinset.add_constraint (dim_vector (1, 4));
+  update_font ();
 
   x_zlim.resize (1, 2);
 
   sx = "linear";
   sy = "linear";
   sz = "linear";
 
   calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
@@ -4794,16 +4795,29 @@ axes::properties::update_aspectratios (v
       else
         {
           normalized_aspectratios (pba, da, dx, dy, dz);
           plotboxaspectratio.set (pba, false);
         }
     }
 }
 
+void
+axes::properties::update_font (void)
+{
+#ifdef HAVE_FREETYPE
+#ifdef HAVE_FONTCONFIG
+  text_renderer.set_font (get ("fontname").string_value (),
+                          get ("fontweight").string_value (),
+                          get ("fontangle").string_value (),
+                          get ("fontsize").double_value ());
+#endif
+#endif
+}
+
 // The INTERNAL flag defines whether position or outerposition is used.
 
 Matrix
 axes::properties::get_boundingbox (bool internal) const
 {
   graphics_object obj = gh_manager::get_object (get_parent ());
   Matrix parent_bb = obj.get_properties ().get_boundingbox (true);
   Matrix pos = (internal ?
@@ -5297,24 +5311,17 @@ axes::properties::calc_ticklabels (const
   labels = c;
 }
 
 Matrix
 axes::properties::get_ticklabel_extents (const Matrix& ticks,
                                          const string_vector& ticklabels,
                                          const Matrix& limits)
 {
-#ifdef HAVE_FREETYPE
-  //FIXME: text_renderer could be cached
-  ft_render text_renderer;
-  text_renderer.set_font (get ("fontname").string_value (),
-                          get ("fontweight").string_value (),
-                          get ("fontangle").string_value (),
-                          get ("fontsize").double_value ());
-#else
+#ifndef HAVE_FREETYPE
   double fontsize = get ("fontsize").double_value ();
 #endif
 
   Matrix ext (1, 2, 0.0);
   double wmax = 0., hmax = 0.;
   int n = std::min (ticklabels.numel (), ticks.numel ());
   for (int i = 0; i < n; i++)
     {
@@ -5957,29 +5964,33 @@ octave_value
 text::properties::get_extent (void) const
 {
   Matrix m = extent.get ().matrix_value ();
 
   return convert_text_position (m, *this, "pixels", get_units ());
 }
 
 void
-text::properties::update_text_extent (void)
+text::properties::update_font (void)
 {
 #ifdef HAVE_FREETYPE
-
-  // FIXME: font and color should be set only when modified, for efficiency
 #ifdef HAVE_FONTCONFIG
   renderer.set_font (get ("fontname").string_value (),
                      get ("fontweight").string_value (),
                      get ("fontangle").string_value (),
                      get ("fontsize").double_value ());
 #endif
   renderer.set_color (get_color_rgb ());
-
+#endif
+}
+
+void
+text::properties::update_text_extent (void)
+{
+#ifdef HAVE_FREETYPE
   int halign = 0, valign = 0;
 
   if (horizontalalignment_is ("center"))
     halign = 1;
   else if (horizontalalignment_is ("right"))
     halign = 2;
 
   if (verticalalignment_is ("top"))
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -3201,16 +3201,21 @@ public:
     double xPlane, xPlaneN, yPlane, yPlaneN, zPlane, zPlaneN;
     double xpTick, xpTickN, ypTick, ypTickN, zpTick, zpTickN;
     double fx, fy, fz;
     double xticklen, yticklen, zticklen;
     double xtickoffset, ytickoffset, ztickoffset;
     bool x2Dtop, y2Dright, layer2Dtop;
     bool xySym, xyzSym, zSign, nearhoriz;
 
+#if HAVE_FREETYPE
+    // freetype renderer, used for calculation of text (tick labels) size
+    ft_render text_renderer;
+#endif
+
     void set_text_child (handle_property& h, const std::string& who,
                          const octave_value& v);
 
     void delete_text_child (handle_property& h);
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
@@ -3283,21 +3288,21 @@ public:
       array_property cameraupvector m , Matrix ()
       double_property cameraviewangle m , 10.0
       radio_property camerapositionmode , "{auto}|manual"
       radio_property cameratargetmode , "{auto}|manual"
       radio_property cameraupvectormode , "{auto}|manual"
       radio_property cameraviewanglemode , "{auto}|manual"
       array_property currentpoint , Matrix (2, 3, 0.0)
       radio_property drawmode , "{normal}|fast"
-      radio_property fontangle , "{normal}|italic|oblique"
-      string_property fontname , OCTAVE_DEFAULT_FONTNAME
-      double_property fontsize , 10
+      radio_property fontangle u , "{normal}|italic|oblique"
+      string_property fontname u , OCTAVE_DEFAULT_FONTNAME
+      double_property fontsize u , 10
       radio_property fontunits SU , "{points}|normalized|inches|centimeters|pixels"
-      radio_property fontweight , "{normal}|light|demi|bold"
+      radio_property fontweight u , "{normal}|light|demi|bold"
       radio_property gridlinestyle , "-|--|{:}|-.|none"
       string_array_property linestyleorder , "-"
       double_property linewidth , 0.5
       radio_property minorgridlinestyle , "-|--|{:}|-.|none"
       array_property plotboxaspectratio mu , Matrix (1, 3, 1.0)
       radio_property plotboxaspectratiomode u , "{auto}|manual"
       radio_property projection , "{orthographic}|perpective"
       radio_property tickdir mu , "{in}|out"
@@ -3408,16 +3413,22 @@ public:
           calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
       }
     void update_zticklabelmode (void)
       {
         if (zticklabelmode.is ("auto"))
           calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
       }
 
+    void update_font (void);
+    void update_fontname (void) { update_font (); }
+    void update_fontsize (void) { update_font (); }
+    void update_fontangle (void) { update_font (); }
+    void update_fontweight (void) { update_font (); }
+
     void sync_positions (const Matrix& linset);
     void sync_positions (void);
 
     void update_outerposition (void)
     {
       set_activepositionproperty ("outerposition");
       sync_positions ();
     }
@@ -3711,26 +3722,27 @@ public:
       radio_property verticalalignmentmode hu , "{auto}|manual"
       radio_property autopos_tag h , "{none}|xlabel|ylabel|zlabel|title"
     END_PROPERTIES
 
     Matrix get_data_position (void) const;
     Matrix get_extent_matrix (void) const;
     const uint8NDArray& get_pixels (void) const { return pixels; }
 #if HAVE_FREETYPE
-    // freetype render, used for text rendering
+    // freetype renderer, used for calculation of text size
     ft_render renderer;
 #endif
 
   protected:
     void init (void)
       {
         position.add_constraint (dim_vector (1, 2));
         position.add_constraint (dim_vector (1, 3));
         cached_units = get_units ();
+        update_font ();
       }
 
   private:
     void update_position (void)
       {
         Matrix pos = get_data_position ();
         Matrix lim;
 
@@ -3756,23 +3768,24 @@ public:
     void update_text_extent (void);
 
     void request_autopos (void);
     void update_positionmode (void) { request_autopos (); }
     void update_rotationmode (void) { request_autopos (); }
     void update_horizontalalignmentmode (void) { request_autopos (); }
     void update_verticalalignmentmode (void) { request_autopos (); }
 
+    void update_font (void);
     void update_string (void) { request_autopos (); update_text_extent (); }
     void update_rotation (void) { update_text_extent (); }
-    void update_color (void) { update_text_extent (); }
-    void update_fontname (void) { update_text_extent (); }
-    void update_fontsize (void) { update_text_extent (); }
-    void update_fontangle (void) { update_text_extent (); }
-    void update_fontweight (void) { update_text_extent (); }
+    void update_color (void) { update_font (); }
+    void update_fontname (void) { update_font (); update_text_extent (); }
+    void update_fontsize (void) { update_font (); update_text_extent (); }
+    void update_fontangle (void) { update_font (); update_text_extent (); }
+    void update_fontweight (void) { update_font (); update_text_extent (); }
     void update_interpreter (void) { update_text_extent (); }
     void update_horizontalalignment (void) { update_text_extent (); }
     void update_verticalalignment (void) { update_text_extent (); }
 
     void update_units (void);
 
   private:
     std::string cached_units;
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -3445,16 +3445,24 @@ is omitted, return a list of keywords.\n
       retval = is_keyword (argv[1]);
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert (iskeyword ("for"))
+%!assert (iskeyword ("fort"), false)
+%!assert (iskeyword ("fft"), false)
+
+*/
+
 void
 prep_lexer_for_script_file (void)
 {
   BEGIN (SCRIPT_FILE_BEGIN);
 }
 
 void
 prep_lexer_for_function_file (void)
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -2895,16 +2895,17 @@ frob_function (const std::string& fname,
            && reading_script_file
            && curr_fcn_file_name == id_name)
     {
       warning ("function `%s' defined within script file `%s'",
                id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
+  fcn->stash_fcn_location (input_line_number, current_input_column);
 
   if (! help_buf.empty () && current_function_depth == 1
       && ! parsing_subfunctions)
     {
       fcn->document (help_buf.top ());
 
       help_buf.pop ();
     }
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -966,16 +966,21 @@ for an example of how to create an execu
   if (args.length () == 0)
     retval = Cell (octave_argv);
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error argv (1);
+%!assert (iscellstr (argv ()));
+*/
+
 DEFUN (program_invocation_name, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} program_invocation_name ()\n\
 Return the name that was typed at the shell prompt to run Octave.\n\
 \n\
 If executing a script from the command line (e.g., @code{octave foo.m})\n\
 or using an executable Octave script, the program name is set to the\n\
 name of the script.  @xref{Executable Octave Programs}, for an example of\n\
@@ -988,16 +993,21 @@ how to create an executable Octave scrip
   if (args.length () == 0)
     retval = octave_program_invocation_name;
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error program_invocation_name (1);
+%!assert (ischar (program_invocation_name ()));
+*/
+
 DEFUN (program_name, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} program_name ()\n\
 Return the last component of the value returned by\n\
 @code{program_invocation_name}.\n\
 @seealso{program_invocation_name}\n\
 @end deftypefn")
 {
@@ -1005,8 +1015,13 @@ Return the last component of the value r
 
   if (args.length () == 0)
     retval = octave_program_name;
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+%!error program_name (1);
+%!assert (ischar (program_name ()));
+*/
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1543,8 +1543,21 @@ s (1, :) = 1;\n\
 typeinfo (s)\n\
 @result{} matrix\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sparse_auto_mutate);
 }
+
+/*
+
+%!test
+ s = speye(3);
+ sparse_auto_mutate (false);
+ s(:, 1) = 1;
+ assert (typeinfo (s), "sparse matrix");
+ sparse_auto_mutate (true);
+ s(1, :) = 1;
+ assert (typeinfo (s), "matrix");
+
+*/
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-builtin.h"
 #include "ov.h"
+#include "profiler.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_builtin);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_builtin,
                                      "built-in function",
                                      "built-in function");
@@ -120,16 +121,18 @@ octave_builtin::do_multi_index_op (int n
       if (lvalue_list || curr_lvalue_list)
         {
           frame.protect_var (curr_lvalue_list);
           curr_lvalue_list = lvalue_list;
         }
 
       try
         {
+          profile_data_accumulator::enter pe (profiler, *this);
+
           retval = (*f) (args, nargout);
           // Do not allow null values to be returned from functions.
           // FIXME -- perhaps true builtins should be allowed?
           retval.make_storable_values ();
           // Fix the case of a single undefined value.
           // This happens when a compiled function uses
           //   octave_value retval;
           // instead of
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -55,16 +55,19 @@ public:
 
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
   virtual bool is_system_fcn_file (void) const { return false; }
 
   virtual std::string fcn_file_name (void) const { return std::string (); }
+  
+  // The name to show in the profiler (also used as map-key).
+  virtual std::string profiler_name (void) const { return name (); }
 
   virtual std::string parent_fcn_name (void) const { return std::string (); }
 
   virtual symbol_table::scope_id parent_fcn_scope (void) const { return -1; }
 
   virtual void mark_fcn_file_up_to_date (const octave_time&) { }
 
   virtual symbol_table::scope_id scope (void) { return -1; }
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -834,8 +834,37 @@ Convert @var{x} to single precision type
           OCTAVE_TYPE_CONV_BODY3 (single, octave_float_matrix, octave_float_scalar);
         }
     }
   else
     print_usage ();
 
   return octave_value ();
 }
+
+/*
+
+%!assert (class (single(1)), "single")
+%!assert (class (single(1 + i)), "single")
+%!assert (class (single (int8 (1))), "single")
+%!assert (class (single (uint8 (1))), "single")
+%!assert (class (single (int16 (1))), "single")
+%!assert (class (single (uint16 (1))), "single")
+%!assert (class (single (int32 (1))), "single")
+%!assert (class (single (uint32 (1))), "single")
+%!assert (class (single (int64 (1))), "single")
+%!assert (class (single (uint64 (1))), "single")
+%!assert (class (single (true)), "single")
+%!assert (class (single ("A")), "single")
+%!error (single (sparse (1)))
+%!test
+%! x = diag ([1 3 2]);
+%! y = single (x);
+%! assert (class (x), "double");
+%! assert (class (y), "single");
+%!test
+%! x = diag ([i 3 2]);
+%! y = single (x);
+%! assert (class (x), "double");
+%! assert (class (y), "single");
+
+*/
+
diff --git a/src/ov-int16.cc b/src/ov-int16.cc
--- a/src/ov-int16.cc
+++ b/src/ov-int16.cc
@@ -77,8 +77,20 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFUN (int16, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int16 (@var{x})\n\
 Convert @var{x} to 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int16);
 }
+
+/*
+
+%!assert (class (int16 (1)), "int16")
+%!assert (int16 (1.25), int16 (1))
+%!assert (int16 (1.5), int16 (2))
+%!assert (int16 (-1.5), int16 (-2))
+%!assert (int16 (2^17), int16 (2^16-1))
+%!assert (int16 (-2^17), int16 (-2^16))
+
+*/
+
diff --git a/src/ov-int32.cc b/src/ov-int32.cc
--- a/src/ov-int32.cc
+++ b/src/ov-int32.cc
@@ -77,8 +77,20 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFUN (int32, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int32 (@var{x})\n\
 Convert @var{x} to 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int32);
 }
+
+/*
+
+%!assert (class (int32 (1)), "int32")
+%!assert (int32 (1.25), int32 (1))
+%!assert (int32 (1.5), int32 (2))
+%!assert (int32 (-1.5), int32 (-2))
+%!assert (int32 (2^33), int32 (2^32-1))
+%!assert (int32 (-2^33), int32 (-2^32))
+
+*/
+
diff --git a/src/ov-int64.cc b/src/ov-int64.cc
--- a/src/ov-int64.cc
+++ b/src/ov-int64.cc
@@ -77,8 +77,20 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFUN (int64, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int64 (@var{x})\n\
 Convert @var{x} to 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int64);
 }
+
+/*
+
+%!assert (class (int64 (1)), "int64")
+%!assert (int64 (1.25), int64 (1))
+%!assert (int64 (1.5), int64 (2))
+%!assert (int64 (-1.5), int64 (-2))
+%!assert (int64 (2^65), int64 (2^64-1))
+%!assert (int64 (-2^65), int64 (-2^64))
+
+*/
+
diff --git a/src/ov-int8.cc b/src/ov-int8.cc
--- a/src/ov-int8.cc
+++ b/src/ov-int8.cc
@@ -77,8 +77,19 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFUN (int8, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int8 (@var{x})\n\
 Convert @var{x} to 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int8);
 }
+
+/*
+
+%!assert (class (int8 (1)), "int8")
+%!assert (int8 (1.25), int8 (1))
+%!assert (int8 (1.5), int8 (2))
+%!assert (int8 (-1.5), int8 (-2))
+%!assert (int8 (2^9), int8 (2^8-1))
+%!assert (int8 (-2^9), int8 (-2^8))
+
+*/
diff --git a/src/ov-mex-fcn.cc b/src/ov-mex-fcn.cc
--- a/src/ov-mex-fcn.cc
+++ b/src/ov-mex-fcn.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 #include <defaults.h>
 #include "dynamic-ld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-mex-fcn.h"
 #include "ov.h"
+#include "profiler.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_mex_function);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_mex_function,
                                      "mex function", "mex function");
 
@@ -142,16 +143,17 @@ octave_mex_function::do_multi_index_op (
       unwind_protect frame;
 
       octave_call_stack::push (this);
 
       frame.add_fcn (octave_call_stack::pop);
 
       try
         {
+          profile_data_accumulator::enter pe (profiler, *this);
           retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
         }
       catch (octave_execution_exception)
         {
           gripe_library_execution_error ();
         }
     }
 
diff --git a/src/ov-null-mat.cc b/src/ov-null-mat.cc
--- a/src/ov-null-mat.cc
+++ b/src/ov-null-mat.cc
@@ -113,8 +113,22 @@ This should give an error if @code{I} is
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).is_null_value ();
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+
+%!assert (isnull ([]), true)
+%!assert (isnull ([1]), false)
+%!assert (isnull (zeros (0,3)), false)
+%!assert (isnull (""), true)
+%!assert (isnull ("A"), false)
+%!assert (isnull (''), true)
+%!assert (isnull ('A'), false)
+%!test
+%! x = [];
+%! assert (isnull (x), false);
+
+*/
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -974,8 +974,41 @@ Convert @var{x} to double precision type
           OCTAVE_TYPE_CONV_BODY3 (double, octave_matrix, octave_scalar);
         }
     }
   else
     print_usage ();
 
   return octave_value ();
 }
+
+/*
+
+%!assert (class (double (single (1))), "double")
+%!assert (class (double (single (1 + i))), "double")
+%!assert (class (double (int8 (1))), "double")
+%!assert (class (double (uint8 (1))), "double")
+%!assert (class (double (int16 (1))), "double")
+%!assert (class (double (uint16 (1))), "double")
+%!assert (class (double (int32 (1))), "double")
+%!assert (class (double (uint32 (1))), "double")
+%!assert (class (double (int64 (1))), "double")
+%!assert (class (double (uint64 (1))), "double")
+%!assert (class (double (true)), "double")
+%!assert (class (double ("A")), "double")
+%!test
+%! x = sparse (logical ([1 0; 0 1]));
+%! y = double (x);
+%! assert (class (x), "logical");
+%! assert (class (y), "double");
+%! assert (issparse (y));
+%!test
+%! x = diag (single ([1 3 2]));
+%! y = double (x);
+%! assert (class (x), "single");
+%! assert (class (y), "double");
+%!test
+%! x = diag (single ([i 3 2]));
+%! y = double (x);
+%! assert (class (x), "single");
+%! assert (class (y), "double");
+
+*/
diff --git a/src/ov-uint16.cc b/src/ov-uint16.cc
--- a/src/ov-uint16.cc
+++ b/src/ov-uint16.cc
@@ -77,8 +77,20 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFUN (uint16, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint16 (@var{x})\n\
 Convert @var{x} to unsigned 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint16);
 }
+
+/*
+
+%!assert (class (uint16 (1)), "uint16")
+%!assert (uint16 (1.25), uint16 (1))
+%!assert (uint16 (1.5), uint16 (2))
+%!assert (uint16 (-1.5), uint16 (0))
+%!assert (uint16 (2^17), uint16 (2^16-1))
+%!assert (uint16 (-2^17), uint16 (0))
+
+*/
+
diff --git a/src/ov-uint32.cc b/src/ov-uint32.cc
--- a/src/ov-uint32.cc
+++ b/src/ov-uint32.cc
@@ -77,8 +77,19 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFUN (uint32, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint32 (@var{x})\n\
 Convert @var{x} to unsigned 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint32);
 }
+
+/*
+
+%!assert (class (uint32 (1)), "uint32")
+%!assert (uint32 (1.25), uint32 (1))
+%!assert (uint32 (1.5), uint32 (2))
+%!assert (uint32 (-1.5), uint32 (0))
+%!assert (uint32 (2^33), uint32 (2^32-1))
+%!assert (uint32 (-2^33), uint32 (0))
+
+*/
diff --git a/src/ov-uint64.cc b/src/ov-uint64.cc
--- a/src/ov-uint64.cc
+++ b/src/ov-uint64.cc
@@ -77,8 +77,19 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFUN (uint64, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint64 (@var{x})\n\
 Convert @var{x} to unsigned 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint64);
 }
+
+/*
+
+%!assert (class (uint64 (1)), "uint64")
+%!assert (uint64 (1.25), uint64 (1))
+%!assert (uint64 (1.5), uint64 (2))
+%!assert (uint64 (-1.5), uint64 (0))
+%!assert (uint64 (2^65), uint64 (2^64-1))
+%!assert (uint64 (-2^65), uint64 (0))
+
+*/
diff --git a/src/ov-uint8.cc b/src/ov-uint8.cc
--- a/src/ov-uint8.cc
+++ b/src/ov-uint8.cc
@@ -77,8 +77,19 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFUN (uint8, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint8 (@var{x})\n\
 Convert @var{x} to unsigned 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint8);
 }
+
+/*
+
+%!assert (class (uint8 (1)), "uint8")
+%!assert (uint8 (1.25), uint8 (1))
+%!assert (uint8 (1.5), uint8 (2))
+%!assert (uint8 (-1.5), uint8 (0))
+%!assert (uint8 (2^9), uint8 (2^8-1))
+%!assert (uint8 (-2^9), uint8 (0))
+
+*/
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -19,16 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <sstream>
+
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
@@ -42,16 +44,17 @@ along with Octave; see the file COPYING.
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "symtab.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "parse.h"
+#include "profiler.h"
 #include "variables.h"
 
 // Whether to optimize subsasgn method calls.
 static bool Voptimize_subsasgn_calls = true;
 
 // User defined scripts.
 
 DEFINE_OCTAVE_ALLOCATOR (octave_user_script);
@@ -126,17 +129,20 @@ octave_user_script::do_multi_index_op (i
                 {
                   octave_call_stack::push (this);
 
                   frame.add_fcn (octave_call_stack::pop);
 
                   frame.protect_var (tree_evaluator::statement_context);
                   tree_evaluator::statement_context = tree_evaluator::script;
 
-                  cmd_list->accept (*current_evaluator);
+                  {
+                    profile_data_accumulator::enter pe (profiler, *this);
+                    cmd_list->accept (*current_evaluator);
+                  }
 
                   if (tree_return_command::returning)
                     tree_return_command::returning = 0;
 
                   if (tree_break_command::breaking)
                     tree_break_command::breaking--;
 
                   if (error_state)
@@ -171,16 +177,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
   (symbol_table::scope_id sid, tree_parameter_list *pl,
    tree_parameter_list *rl, tree_statement_list *cl)
   : octave_user_code (std::string (), std::string ()),
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
+    location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
     class_constructor (false), class_method (false),
     parent_scope (-1), local_scope (sid),
     curr_unwind_protect_frame (0)
@@ -212,16 +219,32 @@ octave_user_function::define_ret_list (t
 }
 
 void
 octave_user_function::stash_fcn_file_name (const std::string& nm)
 {
   file_name = nm;
 }
 
+std::string
+octave_user_function::profiler_name (void) const
+{
+  std::ostringstream result;
+
+  if (is_inline_function ())
+    result << "anonymous@" << fcn_file_name ()
+           << ":" << location_line << ":" << location_column;
+  else if (is_subfunction ())
+    result << parent_fcn_name () << ">" << name ();
+  else
+    result << name ();
+
+  return result.str ();
+}
+
 void
 octave_user_function::mark_as_system_fcn_file (void)
 {
   if (! file_name.empty ())
     {
       // We really should stash the whole path to the file we found,
       // when we looked it up, to avoid possible race conditions...
       // FIXME
@@ -426,32 +449,36 @@ octave_user_function::do_multi_index_op 
   // Evaluate the commands that make up the function.
 
   frame.protect_var (tree_evaluator::statement_context);
   tree_evaluator::statement_context = tree_evaluator::function;
 
   bool special_expr = (is_inline_function ()
                        || cmd_list->is_anon_function_body ());
 
-  if (special_expr)
-    {
-      assert (cmd_list->length () == 1);
+  {
+    profile_data_accumulator::enter pe (profiler, *this);
 
-      tree_statement *stmt = 0;
+    if (special_expr)
+      {
+        assert (cmd_list->length () == 1);
+
+        tree_statement *stmt = 0;
 
-      if ((stmt = cmd_list->front ())
-          && stmt->is_expression ())
-        {
-          tree_expression *expr = stmt->expression ();
+        if ((stmt = cmd_list->front ())
+            && stmt->is_expression ())
+          {
+            tree_expression *expr = stmt->expression ();
 
-          retval = expr->rvalue (nargout);
-        }
-    }
-  else
-    cmd_list->accept (*current_evaluator);
+            retval = expr->rvalue (nargout);
+          }
+      }
+    else
+      cmd_list->accept (*current_evaluator);
+  }
 
   if (echo_commands)
     print_code_function_trailer ();
 
   if (tree_return_command::returning)
     tree_return_command::returning = 0;
 
   if (tree_break_command::breaking)
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -184,16 +184,22 @@ public:
   octave_user_code *user_code_value (bool = false) { return this; }
 
   octave_user_function *define_param_list (tree_parameter_list *t);
 
   octave_user_function *define_ret_list (tree_parameter_list *t);
 
   void stash_fcn_file_name (const std::string& nm);
 
+  void stash_fcn_location (int line, int col)
+    {
+      location_line = line;
+      location_column = col;
+    }
+
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
   void stash_parent_fcn_scope (symbol_table::scope_id ps) { parent_scope = ps; }
 
   void stash_leading_comment (octave_comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave_comment_list *tc) { trail_comm = tc; }
 
@@ -202,16 +208,18 @@ public:
   void stash_fcn_file_time (const octave_time& t)
     {
       t_parsed = t;
       mark_fcn_file_up_to_date (t);
     }
 
   std::string fcn_file_name (void) const { return file_name; }
 
+  std::string profiler_name (void) const;
+
   std::string parent_fcn_name (void) const { return parent_name; }
 
   symbol_table::scope_id parent_fcn_scope (void) const { return parent_scope; }
 
   symbol_table::scope_id scope (void) { return local_scope; }
 
   octave_time time_parsed (void) const { return t_parsed; }
 
@@ -339,16 +347,20 @@ private:
   octave_comment_list *lead_comm;
 
   // The comments preceding the ENDFUNCTION token.
   octave_comment_list *trail_comm;
 
   // The name of the file we parsed.
   std::string file_name;
 
+  // Location where this function was defined.
+  int location_line;
+  int location_column;
+
   // The name of the parent function, if any.
   std::string parent_name;
 
   // The time the file was parsed.
   octave_time t_parsed;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
diff --git a/src/profiler.cc b/src/profiler.cc
new file mode 100644
--- /dev/null
+++ b/src/profiler.cc
@@ -0,0 +1,222 @@
+/*
+
+Copyright (C) 2011 Daniel Kraft
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <iostream>
+
+#include "Cell.h"
+#include "defun.h"
+#include "oct-time.h"
+#include "ov-fcn.h"
+#include "ov-struct.h"
+#include "pager.h"
+#include "profiler.h"
+
+profile_data_accumulator::enter::enter (profile_data_accumulator& a,
+                                        const octave_function& f)
+  : acc (a)
+{
+  if (acc.is_active ())
+    {
+      fcn = &f;
+      acc.enter_function (*fcn);
+    }
+  else
+    fcn = NULL;
+}
+
+profile_data_accumulator::enter::~enter ()
+{
+  if (fcn)
+    acc.exit_function (*fcn);
+}
+
+profile_data_accumulator::profile_data_accumulator ()
+  : enabled (false), call_stack (), times (), last_time (-1.0)
+{}
+
+void
+profile_data_accumulator::set_active (bool value)
+{
+  // If we enable, clear the call-stack.  This ensures we freshly start
+  // with collecting times now.
+  if (value)
+    {
+      while (!call_stack.empty ())
+        call_stack.pop ();
+    }
+
+  enabled = value;
+}
+
+void
+profile_data_accumulator::enter_function (const octave_function& fcn)
+{
+  // The enter class will check and only call us if the profiler is active.
+  assert (is_active ());
+
+  // If there is already an active function, add to its time before
+  // pushing the new one.
+  if (!call_stack.empty ())
+    add_current_time ();
+
+  call_stack.push (&fcn);
+  last_time = query_time ();
+}
+
+void
+profile_data_accumulator::exit_function (const octave_function& fcn)
+{
+  assert (!call_stack.empty ());
+  assert (&fcn == call_stack.top ());
+
+  // Usually, if we are disabled this function is not even called.  But the
+  // call disabling the profiler is an exception.  So also check here
+  // and only record the time if enabled.
+  if (is_active ())
+    add_current_time ();
+
+  call_stack.pop ();
+
+  // If this was an "inner call", we resume executing the parent function
+  // up the stack.  So note the start-time for this!
+  last_time = query_time ();
+}
+
+void
+profile_data_accumulator::reset (void)
+{
+  if (is_active ())
+    {
+      error ("Can't reset active profiler.");
+      return;
+    }
+
+  times.clear ();
+  last_time = -1.0;
+}
+
+Cell
+profile_data_accumulator::get_data (void) const
+{
+  const int n = times.size ();
+
+  Cell retval (1, n);
+  int i = 0;
+  for (timing_map::const_iterator p = times.begin (); p != times.end (); ++p)
+    {
+      octave_scalar_map entry;
+
+      entry.contents ("name") = octave_value (p->first);
+      entry.contents ("time") = octave_value (p->second);
+
+      retval (i++) = entry;
+    }
+  assert (i == n);
+
+  return retval;
+}
+
+double
+profile_data_accumulator::query_time (void) const
+{
+  octave_time now;
+  return now.double_value ();
+}
+
+void
+profile_data_accumulator::add_current_time (void)
+{
+  const double t = query_time ();
+  assert (last_time >= 0.0 && last_time <= t);
+
+  assert (!call_stack.empty ());
+  const std::string name = call_stack.top ()->profiler_name ();
+
+  // If the key is not yet present in the map, it is constructed
+  // with default value 0.
+  times[name] += t - last_time;
+}
+
+profile_data_accumulator profiler;
+
+DEFUN (profiler_enable, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {} profiler_enable (enabled)\n\
+Enable or disable the profiler data collection.\n\
+@end deftypefn")
+{
+  octave_value_list retval;
+
+  const int nargin = args.length ();
+  if (nargin > 0)
+    {
+      if (nargin > 1)
+        {
+          print_usage ();
+          return retval;
+        }
+
+      profiler.set_active (args(0).bool_value ());
+    }
+
+  retval(0) = profiler.is_active ();
+
+  return retval;
+}
+
+DEFUN (profiler_reset, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {} profiler_reset ()\n\
+Clear all collected profiling data.\n\
+@end deftypefn")
+{
+  octave_value_list retval;
+  const int nargin = args.length ();
+
+  if (nargin > 0)
+    warning ("profiler_reset: ignoring extra arguments");
+
+  profiler.reset ();
+
+  return retval;
+}
+
+DEFUN (profiler_data, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {} data = profiler_data ()\n\
+Query the timings collected by the profiler.\n\
+@end deftypefn")
+{
+  octave_value_list retval;
+  const int nargin = args.length ();
+
+  if (nargin > 0)
+    warning ("profiler_data: ignoring extra arguments");
+
+  retval(0) = profiler.get_data ();
+
+  return retval;
+}
diff --git a/src/profiler.h b/src/profiler.h
new file mode 100644
--- /dev/null
+++ b/src/profiler.h
@@ -0,0 +1,111 @@
+/*
+
+Copyright (C) 2011 Daniel Kraft
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_profiler_h)
+#define octave_profiler_h 1
+
+#include <stack>
+#include <map>
+
+class octave_function;
+class Cell;
+
+class
+OCTAVE_API
+profile_data_accumulator
+{
+public:
+
+  // This is a utility class that can be used to call the enter/exit
+  // functions in a manner protected from stack unwinding.
+  class enter
+  {
+    private:
+
+      profile_data_accumulator& acc;
+
+      const octave_function* fcn;
+
+    public:
+
+      enter (profile_data_accumulator&, const octave_function& fcn);
+
+      virtual ~enter (void);
+
+    private:
+
+      // No copying!
+
+      enter (const enter&);
+
+      enter& operator = (const enter&);
+  };
+
+  profile_data_accumulator (void);
+
+  bool is_active (void) const { return enabled; }
+
+  void set_active (bool);
+
+  void reset (void);
+
+  Cell get_data (void) const;
+
+private:
+
+  bool enabled;
+
+  std::stack<const octave_function*> call_stack;
+
+  typedef std::map<std::string, double> timing_map;
+  timing_map times;
+
+  // Store last timestamp we had, when the currently active function was called.
+  double last_time;
+
+  // These are private as only the unwind-protecting inner class enter
+  // should be allowed to call them.
+  void enter_function (const octave_function&);
+  void exit_function (const octave_function&);
+
+  // Query a timestamp, used for timing calls (obviously).
+  // This is not static because in the future, maybe we want a flag
+  // in the profiler or something to choose between cputime, wall-time
+  // user-time, system-time, ...
+  double query_time () const;
+
+  // Add the time elapsed since last_time to the function on the top
+  // of our call-stack.  This is called from two different positions,
+  // thus it is useful to have it as a seperate function.
+  void add_current_time (void);
+
+  // No copying!
+
+  profile_data_accumulator (const profile_data_accumulator&);
+
+  profile_data_accumulator& operator = (const profile_data_accumulator&);
+};
+
+// The instance used.
+extern profile_data_accumulator profiler;
+
+#endif
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -274,8 +274,24 @@ This feature is only provided for compat
 not be used unless you are porting old code that relies on this feature.\n\
 \n\
 To obtain short-circuit behavior for logical expressions in new programs,\n\
 you should always use the @samp{&&} and @samp{||} operators.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (do_braindead_shortcircuit_evaluation);
 }
+
+/*
+
+%!test
+%! x = 0;
+%! do_braindead_shortcircuit_evaluation (0);
+%! if (1 | (x = 1)) 
+%! endif
+%! assert (x, 1);
+%! do_braindead_shortcircuit_evaluation (1);
+%! if (1 | (x = 0)) 
+%! endif
+%! assert (x, 1);
+
+*/
+
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -1197,20 +1197,42 @@ DEFUN (max_recursion_depth, args, nargou
 Query or set the internal limit on the number of times a function may\n\
 be called recursively.  If the limit is exceeded, an error message is\n\
 printed and control returns to the top level.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (max_recursion_depth);
 }
 
+/*
+%!error (max_recursion_depth (1, 2));
+%!test
+%! orig_val = max_recursion_depth ();
+%! old_val = max_recursion_depth (2*orig_val);
+%! assert (orig_val, old_val);
+%! assert (max_recursion_depth (), 2*orig_val);
+%! max_recursion_depth (orig_val);
+%! assert (max_recursion_depth (), orig_val);
+*/
+
 DEFUN (silent_functions, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} silent_functions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
 Query or set the internal variable that controls whether internal\n\
 output from a function is suppressed.  If this option is disabled,\n\
 Octave will display the results produced by evaluating expressions\n\
 within a function body that are not terminated with a semicolon.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (silent_functions);
 }
+
+/*
+%!error (silent_functions (1, 2));
+%!test
+%! orig_val = silent_functions ();
+%! old_val = silent_functions (! orig_val);
+%! assert (orig_val, old_val);
+%! assert (silent_functions (), ! orig_val);
+%! silent_functions (orig_val);
+%! assert (silent_functions (), orig_val);
+*/
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -122,16 +122,17 @@ tree_anon_fcn_handle::rvalue1 (int)
 
       if (parent_scope < 0)
         parent_scope = curr_fcn->scope ();
 
       uf->stash_parent_fcn_scope (parent_scope);
     }
 
   uf->mark_as_inline_function ();
+  uf->stash_fcn_location (line (), column ());
 
   octave_value ov_fcn (uf);
 
   octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn));
 
   return fh;
 }
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1141,8 +1141,20 @@ string_fill_char (\"X\");\n\
         \"areXXXX\"\n\
         \"strings\"\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (string_fill_char);
 }
+
+/*
+%!error (string_fill_char (1, 2));
+%!test
+%! orig_val = string_fill_char ();
+%! old_val = string_fill_char ("X");
+%! assert (orig_val, old_val);
+%! assert (string_fill_char (), "X");
+%! assert (["these"; "are"; "strings"], ["theseXX"; "areXXXX"; "strings"]);
+%! string_fill_char (orig_val);
+%! assert (string_fill_char (), orig_val);
+*/
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -940,44 +940,83 @@ Return a structure containing Unix signa
       retval = m;
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error SIG (1);
+%!assert (isstruct (SIG ()));
+%!assert (! isempty (SIG ()));
+*/
+
 DEFUN (debug_on_interrupt, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter debugging mode when it receives an interrupt signal (typically\n\
 generated with @kbd{C-c}).  If a second interrupt signal is received\n\
 before reaching the debugging mode, a normal interrupt will occur.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_interrupt);
 }
 
+/*
+%!error (debug_on_interrupt (1, 2));
+%!test
+%! orig_val = debug_on_interrupt ();
+%! old_val = debug_on_interrupt (! orig_val);
+%! assert (orig_val, old_val);
+%! assert (debug_on_interrupt (), ! orig_val);
+%! debug_on_interrupt (orig_val);
+%! assert (debug_on_interrupt (), orig_val);
+*/
+
 DEFUN (sighup_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file \"octave-core\" if it receives\n\
 a hangup signal.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sighup_dumps_octave_core);
 }
 
+/*
+%!error (sighup_dumps_octave_core (1, 2));
+%!test
+%! orig_val = sighup_dumps_octave_core ();
+%! old_val = sighup_dumps_octave_core (! orig_val);
+%! assert (orig_val, old_val);
+%! assert (sighup_dumps_octave_core (), ! orig_val);
+%! sighup_dumps_octave_core (orig_val);
+%! assert (sighup_dumps_octave_core (), orig_val);
+*/
+
 DEFUN (sigterm_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file \"octave-core\" if it receives\n\
 a terminate signal.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sigterm_dumps_octave_core);
 }
+
+/*
+%!error (sigterm_dumps_octave_core (1, 2));
+%!test
+%! orig_val = sigterm_dumps_octave_core ();
+%! old_val = sigterm_dumps_octave_core (! orig_val);
+%! assert (orig_val, old_val);
+%! assert (sigterm_dumps_octave_core (), ! orig_val);
+%! sigterm_dumps_octave_core (orig_val);
+%! assert (sigterm_dumps_octave_core (), orig_val);
+*/
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -581,18 +581,26 @@ Set the value of the environment variabl
       else
         error ("putenv: VAR must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
+
 DEFALIAS (setenv, putenv);
 
+/*
+%!assert (ischar (getenv ("OCTAVE_HOME")));
+%!test
+%! setenv ("dummy_variable_that_cannot_matter", "foobar");
+%! assert (getenv ("dummy_variable_that_cannot_matter"), "foobar");
+*/
+
 // FIXME -- perhaps kbhit should also be able to print a prompt?
 
 DEFUN (kbhit, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} kbhit ()\n\
 Read a single keystroke from the keyboard.  If called with one\n\
 argument, don't wait for a keypress.  For example,\n\
 \n\
@@ -690,16 +698,22 @@ clc;\n\
       feval ("drawnow");
       flush_octave_stdout ();
       octave_kbhit ();
     }
 
   return retval;
 }
 
+/*
+%!error (pause (1, 2));
+%!test
+%! pause (1);
+*/
+
 DEFUN (sleep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sleep (@var{seconds})\n\
 Suspend the execution of the program for the given number of seconds.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -719,16 +733,23 @@ Suspend the execution of the program for
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error (sleep ());
+%!error (sleep (1, 2));
+%!test
+%! sleep (1);
+*/
+
 DEFUN (usleep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usleep (@var{microseconds})\n\
 Suspend the execution of the program for the given number of\n\
 microseconds.  On systems where it is not possible to sleep for periods\n\
 of time less than one second, @code{usleep} will pause the execution for\n\
 @code{round (@var{microseconds} / 1e6)} seconds.\n\
 @end deftypefn")
@@ -755,43 +776,58 @@ of time less than one second, @code{usle
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error (usleep ());
+%!error (usleep (1, 2));
+%!test
+%! usleep (1000);
+*/
+
 // FIXME -- maybe this should only return 1 if IEEE floating
 // point functions really work.
 
 DEFUN (isieee, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isieee ()\n\
 Return true if your computer @emph{claims} to conform to the IEEE standard\n\
 for floating point calculations.  No actual tests are performed.\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
                        || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 }
 
+/*
+%!assert (islogical (isieee ()));
+*/
+
 DEFUN (native_float_format, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} native_float_format ()\n\
 Return the native floating point format as a string\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (oct_mach_info::float_format_as_string (flt_fmt));
 }
 
+/*
+%!assert (ischar (native_float_format ()));
+*/
+
 DEFUN (tilde_expand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} tilde_expand (@var{string})\n\
 Perform tilde expansion on @var{string}.  If @var{string} begins with a\n\
 tilde character, (@samp{~}), all of the characters preceding the first\n\
 slash (or all characters, if there is no slash) are treated as a\n\
 possible user name, and the tilde and the following characters up to the\n\
 slash are replaced by the home directory of the named user.  If the\n\
@@ -830,8 +866,19 @@ tilde_expand (\"~/bin\")\n\
       else
         error ("tilde_expand: expecting argument to be char or cellstr object");
     }
   else
     print_usage ();
 
   return retval;
 }
+
+/*
+%!test
+%! if (isempty (getenv ("HOME")))
+%!   setenv ("HOME", "foobar");
+%! endif
+%! home = getenv ("HOME");
+%! assert (tilde_expand ("~/foobar"), fullfile (home, "foobar"));
+%! assert (tilde_expand ("/foo/bar"), "/foo/bar");
+%! assert (tilde_expand ("foo/bar"), "foo/bar");
+*/
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -996,16 +996,30 @@ command shell that is started to run the
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (shell_cmd, system);
 
+/*
+%!error (system ());
+%!error (system (1, 2, 3));
+%!test
+%! if (ispc ())
+%!   cmd = "dir";
+%! else
+%!   cmd = "ls";
+%! endif
+%! [status, output] = system (cmd);
+%! assert (ischar (output));
+%! assert (! isempty (output));
+*/
+
 // FIXME -- this should really be static, but that causes
 // problems on some systems.
 std::list<std::string> octave_atexit_functions;
 
 void
 do_octave_atexit (void)
 {
   static bool deja_vu = false;
@@ -1434,16 +1448,25 @@ specified option.\n\
   else if (nargin == 0)
     retval = m;
   else
     print_usage ();
 
   return retval;
 }
 
+/*
+%!error octave_config_info (1, 2);
+%!assert (ischar (octave_config_info ("version")));
+%!test
+%! x = octave_config_info ();
+%! assert (isstruct (x));
+%! assert (! isempty (x));
+*/
+
 #if defined (__GNUG__) && defined (DEBUG_NEW_DELETE)
 
 int debug_new_delete = 0;
 
 typedef void (*vfp)(void);
 extern vfp __new_handler;
 
 void *
