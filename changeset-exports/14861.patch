# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1342272176 25200
#      Sat Jul 14 06:22:56 2012 -0700
# Node ID f7afecdd87efc09fb1c240082208db7d34fb895d
# Parent  e027f98403c39b488fbec3d48f3fb447d9b53326
maint: Use Octave coding conventions for cuddling parentheses in src/ directory

* bitfcns.cc, comment-list.cc, data.cc, defun.cc, error.cc, gl-render.cc,
graphics.cc, graphics.in.h, load-path.cc, load-path.h, load-save.cc,
ls-hdf5.cc, ls-mat4.cc, ls-mat5.cc, ls-oct-ascii.cc, mappers.cc, mex.cc,
oct-map.cc, oct-obj.cc, ov-base-int.cc, ov-base-mat.h, ov-base-sparse.cc,
ov-bool-mat.cc, ov-bool-sparse.cc, ov-cell.cc, ov-class.cc, ov-complex.cc,
ov-cx-mat.cc, ov-cx-sparse.cc, ov-fcn-handle.cc, ov-flt-cx-mat.cc,
ov-flt-re-mat.cc, ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.cc, ov-str-mat.cc,
ov-struct.cc, ov-usr-fcn.cc, ov.cc, pr-output.cc, procstream.h, sighandlers.cc,
sparse-xdiv.cc, sparse-xpow.cc, sparse.cc, symtab.cc, syscalls.cc, sysdep.cc,
txt-eng-ft.cc, variables.cc, zfstream.cc, zfstream.h: Use Octave coding
conventions for cuddling parentheses.

diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -67,18 +67,18 @@ namespace std
   public: 
     T operator() (const T & op1, const T & op2) const { return (op1 ^ op2); }
   };
 }
 #endif
 
 template <typename OP, typename T>
 octave_value
-bitopxx(const OP& op, const std::string& fname,
-        const Array<T>& x, const Array<T>& y)
+bitopxx (const OP& op, const std::string& fname,
+         const Array<T>& x, const Array<T>& y)
 {
   int nelx = x.numel ();
   int nely = y.numel ();
 
   bool is_scalar_op = (nelx == 1 || nely == 1);
 
   dim_vector dvx = x.dims ();
   dim_vector dvy = y.dims ();
@@ -93,48 +93,48 @@ bitopxx(const OP& op, const std::string&
       if (nelx != 1)
         result.resize (dvx);
       else
         result.resize (dvy);
 
       for (int i = 0; i < nelx; i++)
         if (is_scalar_op)
           for (int k = 0; k < nely; k++)
-            result(i+k) = op(x(i), y(k));
+            result(i+k) = op (x(i), y(k));
         else
-          result(i) = op(x(i), y(i));
+          result(i) = op (x(i), y(i));
 
       retval = result;
     }
   else
     error ("%s: size of X and Y must match, or one operand must be a scalar",
            fname.c_str ());
 
   return retval;
 }
 
 // Trampoline function, instantiates the proper template above, with
 // reflective information hardwired. We can't hardwire this information
 // in Fbitxxx DEFUNs below, because at that moment, we still don't have
 // information about which integer types we need to instantiate.
 template<typename T>
 octave_value
-bitopx(const std::string& fname, const Array<T>& x, const Array<T>& y)
+bitopx (const std::string& fname, const Array<T>& x, const Array<T>& y)
 {
   if (fname == "bitand")
     return bitopxx (std::bit_and<T>(), fname, x, y);
   if (fname == "bitor")
     return bitopxx (std::bit_or<T>(), fname, x, y);
 
   //else (fname == "bitxor")
   return bitopxx (std::bit_xor<T>(), fname, x, y);
 }
 
 octave_value
-bitop(const std::string& fname, const octave_value_list& args)
+bitop (const std::string& fname, const octave_value_list& args)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       if ((args(0).class_name () == octave_scalar::static_class_name ())
diff --git a/src/comment-list.cc b/src/comment-list.cc
--- a/src/comment-list.cc
+++ b/src/comment-list.cc
@@ -83,17 +83,17 @@ octave_comment_buffer::get_comment (void
 {
   return (instance_ok ()) ? instance->do_get_comment () : 0;
 }
 
 void
 octave_comment_buffer::do_append (const std::string& s,
                                   octave_comment_elt::comment_type t)
 {
-  comment_list->append(s, t);
+  comment_list->append (s, t);
 }
 
 octave_comment_list *
 octave_comment_buffer::do_get_comment (void)
 {
   octave_comment_list *retval = 0;
 
   if (comment_list && comment_list->length () > 0)
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1829,17 +1829,17 @@ do_cat (const octave_value_list& xargs, 
             return retval;
 
           int dv_len = dv.length ();
           Array<octave_idx_type> ra_idx (dim_vector (dv_len, 1), 0);
 
           for (int j = 0; j < n_args; j++)
             {
               // Can't fast return here to skip empty matrices as something
-              // like cat(1,[],single([])) must return an empty matrix of
+              // like cat (1,[],single ([])) must return an empty matrix of
               // the right type.
               tmp = do_cat_op (tmp, args (j), ra_idx);
 
               if (error_state)
                 return retval;
 
               dim_vector dv_tmp = args (j).dims ();
 
@@ -2335,17 +2335,17 @@ do_permute (const octave_value_list& arg
   return retval;
 }
 
 DEFUN (permute, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} permute (@var{A}, @var{perm})\n\
 Return the generalized transpose for an N-D array object @var{A}.\n\
 The permutation vector @var{perm} must contain the elements\n\
-@code{1:ndims(A)} (in any order, but each element must appear only once).\n\
+@code{1:ndims (A)} (in any order, but each element must appear only once).\n\
 @seealso{ipermute}\n\
 @end deftypefn")
 {
   return do_permute (args, false);
 }
 
 DEFUN (ipermute, args, ,
   "-*- texinfo -*-\n\
@@ -3095,20 +3095,20 @@ complex ([1, 2], [3, 4])\n\
                     {
                       result = SparseComplexMatrix (im_val.dims (), re_val (0));
                       octave_idx_type nr = im_val.rows ();
                       octave_idx_type nc = im_val.cols ();
 
                       for (octave_idx_type j = 0; j < nc; j++)
                         {
                           octave_idx_type off = j * nr;
-                          for (octave_idx_type i = im_val.cidx(j);
-                               i < im_val.cidx(j + 1); i++)
-                            result.data (im_val.ridx(i) + off) =
-                              result.data (im_val.ridx(i) + off) +
+                          for (octave_idx_type i = im_val.cidx (j);
+                               i < im_val.cidx (j + 1); i++)
+                            result.data (im_val.ridx (i) + off) =
+                              result.data (im_val.ridx (i) + off) +
                               Complex (0, im_val.data (i));
                         }
                     }
                   retval = octave_value (new octave_sparse_complex_matrix (result));
                 }
               else if (im.numel () == 1)
                 {
                   SparseComplexMatrix result;
@@ -3118,20 +3118,20 @@ complex ([1, 2], [3, 4])\n\
                     {
                       result = SparseComplexMatrix (re_val.rows (), re_val.cols (), Complex (0, im_val (0)));
                       octave_idx_type nr = re_val.rows ();
                       octave_idx_type nc = re_val.cols ();
 
                       for (octave_idx_type j = 0; j < nc; j++)
                         {
                           octave_idx_type off = j * nr;
-                          for (octave_idx_type i = re_val.cidx(j);
-                               i < re_val.cidx(j + 1); i++)
-                            result.data (re_val.ridx(i) + off) =
-                              result.data (re_val.ridx(i) + off) +
+                          for (octave_idx_type i = re_val.cidx (j);
+                               i < re_val.cidx (j + 1); i++)
+                            result.data (re_val.ridx (i) + off) =
+                              result.data (re_val.ridx (i) + off) +
                               re_val.data (i);
                         }
                     }
                   retval = octave_value (new octave_sparse_complex_matrix (result));
                 }
               else
                 {
                   if (re_val.dims () == im_val.dims ())
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -189,12 +189,12 @@ void defun_isargout (int nargout, int no
                 isargout[k++] = true;
             }
         }
     }
   else
     for (int i = 0; i < nout; i++)
       isargout[i] = true;
 
-  for (int i = std::max(nargout, 1); i < nout; i++)
+  for (int i = std::max (nargout, 1); i < nout; i++)
     isargout[i] = false;
 }
 
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -845,44 +845,44 @@ location of the error.  Typically @var{e
   else
     {
       const octave_scalar_map err = args(0).scalar_map_value ();
 
       if (! error_state)
         {
           if (err.contains ("message") && err.contains ("identifier"))
             {
-              std::string msg = err.contents("message").string_value ();
-              std::string id = err.contents("identifier").string_value ();
+              std::string msg = err.contents ("message").string_value ();
+              std::string id = err.contents ("identifier").string_value ();
               int len = msg.length ();
 
               std::string file;
               std::string nm;
               int l = -1;
               int c = -1;
 
               octave_map err_stack = initialize_last_error_stack ();
 
               if (err.contains ("stack"))
                 {
-                  err_stack = err.contents("stack").map_value ();
+                  err_stack = err.contents ("stack").map_value ();
 
                   if (err_stack.numel () > 0)
                     {
                       if (err_stack.contains ("file"))
-                        file = err_stack.contents("file")(0).string_value ();
+                        file = err_stack.contents ("file")(0).string_value ();
 
                       if (err_stack.contains ("name"))
-                        nm = err_stack.contents("name")(0).string_value ();
+                        nm = err_stack.contents ("name")(0).string_value ();
 
                       if (err_stack.contains ("line"))
-                        l = err_stack.contents("line")(0).nint_value ();
+                        l = err_stack.contents ("line")(0).nint_value ();
 
                       if (err_stack.contains ("column"))
-                        c = err_stack.contents("column")(0).nint_value ();
+                        c = err_stack.contents ("column")(0).nint_value ();
                     }
                 }
 
               // Ugh.
               char *tmp_msg = strsave (msg.c_str ());
               if (tmp_msg[len-1] == '\n')
                 {
                   if (len > 1)
@@ -1580,72 +1580,72 @@ set to their default values.\n\
               if (args(0).string_value () == "reset")
                 {
                   Vlast_error_message = std::string ();
                   Vlast_error_id = std::string ();
 
                   Vlast_error_stack = initialize_last_error_stack ();
                 }
               else
-                error("lasterror: unrecognized string argument");
+                error ("lasterror: unrecognized string argument");
             }
           else if (args(0).is_map ())
             {
               octave_scalar_map new_err = args(0).scalar_map_value ();
               std::string new_error_message;
               std::string new_error_id;
               std::string new_error_file;
               std::string new_error_name;
               int new_error_line = -1;
               int new_error_column = -1;
 
               if (! error_state && new_err.contains ("message"))
                 {
                   const std::string tmp =
-                    new_err.getfield("message").string_value ();
+                    new_err.getfield ("message").string_value ();
                   new_error_message = tmp;
                 }
 
               if (! error_state && new_err.contains ("identifier"))
                 {
                   const std::string tmp =
-                    new_err.getfield("identifier").string_value ();
+                    new_err.getfield ("identifier").string_value ();
                   new_error_id = tmp;
                 }
 
               if (! error_state && new_err.contains ("stack"))
                 {
                   octave_scalar_map new_err_stack =
-                    new_err.getfield("stack").scalar_map_value ();
+                    new_err.getfield ("stack").scalar_map_value ();
 
                   if (! error_state && new_err_stack.contains ("file"))
                     {
                       const std::string tmp =
-                        new_err_stack.getfield("file").string_value ();
+                        new_err_stack.getfield ("file").string_value ();
                       new_error_file = tmp;
                     }
 
                   if (! error_state && new_err_stack.contains ("name"))
                     {
                       const std::string tmp =
-                        new_err_stack.getfield("name").string_value ();
+                        new_err_stack.getfield ("name").string_value ();
                       new_error_name = tmp;
                     }
 
                   if (! error_state && new_err_stack.contains ("line"))
                     {
                       const int tmp =
-                        new_err_stack.getfield("line").nint_value ();
+                        new_err_stack.getfield ("line").nint_value ();
                       new_error_line = tmp;
                     }
 
                   if (! error_state && new_err_stack.contains ("column"))
                     {
                       const int tmp =
-                        new_err_stack.getfield("column").nint_value ();
+                        new_err_stack.getfield ("column").nint_value ();
                       new_error_column = tmp;
                     }
                 }
 
               if (! error_state)
                 {
                   Vlast_error_message = new_error_message;
                   Vlast_error_id = new_error_id;
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -411,42 +411,42 @@ public:
       : opengl_tesselator (), renderer (r),
         color_mode (cmode), light_mode (lmode), index (idx),
         first (true), tmp_vdata ()
   { }
 
 protected:
   void begin (GLenum type)
     {
-      //printf("patch_tesselator::begin (%d)\n", type);
+      //printf ("patch_tesselator::begin (%d)\n", type);
       first = true;
 
       if (color_mode == 2 || light_mode == 2)
         glShadeModel (GL_SMOOTH);
       else
         glShadeModel (GL_FLAT);
 
       if (is_filled ())
         renderer->set_polygon_offset (true, 1+index);
 
       glBegin (type);
     }
 
   void end (void)
     {
-      //printf("patch_tesselator::end\n");
+      //printf ("patch_tesselator::end\n");
       glEnd ();
       renderer->set_polygon_offset (false);
     }
 
   void vertex (void *data)
     {
       vertex_data::vertex_data_rep *v
           = reinterpret_cast<vertex_data::vertex_data_rep *> (data);
-      //printf("patch_tesselator::vertex (%g, %g, %g)\n", v->coords(0), v->coords(1), v->coords(2));
+      //printf ("patch_tesselator::vertex (%g, %g, %g)\n", v->coords(0), v->coords(1), v->coords(2));
 
       // FIXME: why did I need to keep the first vertex of the face
       // in JHandles? I think it's related to the fact that the
       // tessellation process might re-order the vertices, such that
       // the first one you get here might not be the first one of the face;
       // but I can't figure out the actual reason.
       if (color_mode > 0 && (first || color_mode == 2))
         {
@@ -476,17 +476,17 @@ protected:
       glVertex3dv (v->coords.data ());
 
       first = false;
     }
 
   void combine (GLdouble xyz[3], void *data[4], GLfloat w[4],
                 void **out_data)
     {
-      //printf("patch_tesselator::combine\n");
+      //printf ("patch_tesselator::combine\n");
 
       vertex_data::vertex_data_rep *v[4];
       int vmax = 4;
 
       for (int i = 0; i < 4; i++)
         {
           v[i] = reinterpret_cast<vertex_data::vertex_data_rep *> (data[i]);
 
@@ -503,24 +503,24 @@ protected:
       vv(1) = xyz[1];
       vv(2) = xyz[2];
 
       if (v[0]->color.numel ())
         {
           cc.resize (1, 3, 0.0);
           for (int ic = 0; ic < 3; ic++)
             for (int iv = 0; iv < vmax; iv++)
-              cc(ic) += (w[iv] * v[iv]->color(ic));
+              cc(ic) += (w[iv] * v[iv]->color (ic));
         }
 
       if (v[0]->normal.numel () > 0)
         {
           for (int in = 0; in < 3; in++)
             for (int iv = 0; iv < vmax; iv++)
-              nn(in) += (w[iv] * v[iv]->normal(in));
+              nn(in) += (w[iv] * v[iv]->normal (in));
         }
 
       for (int iv = 0; iv < vmax; iv++)
         aa += (w[iv] * v[iv]->alpha);
 
       vertex_data new_v (vv, cc, nn, aa, v[0]->ambient, v[0]->diffuse,
                          v[0]->specular, v[0]->specular_exp);
       tmp_vdata.push_back (new_v);
@@ -802,17 +802,17 @@ opengl_renderer::setup_opengl_transforma
 #else
   int vw[4];
 #endif
 
   glGetIntegerv (GL_VIEWPORT, vw);
 
   glMatrixMode (GL_MODELVIEW);
   glLoadIdentity ();
-  glScaled(1, 1, -1);
+  glScaled (1, 1, -1);
   glMultMatrixd (x_mat1.data ());
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
   glOrtho (0, vw[2], vw[3], 0, xZ1, xZ2);
   glMultMatrixd (x_mat2.data ());
   glMatrixMode (GL_MODELVIEW);
 
   glClear (GL_DEPTH_BUFFER_BIT);
@@ -1011,61 +1011,61 @@ opengl_renderer::draw_axes_x_grid (const
                      yPlane, yPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 0, (zstate != AXE_DEPTH_DIR));
 
       // tick marks
       if (tick_along_z)
         {
           render_tickmarks (xticks, x_min, x_max, ypTick, ypTick,
                             zpTick, zpTickN, 0., 0.,
-                            signum(zpTick-zpTickN)*fz*xticklen,
+                            signum (zpTick-zpTickN)*fz*xticklen,
                             0, mirror);
         }
       else
         {
           render_tickmarks (xticks, x_min, x_max, ypTick, ypTickN,
                             zpTick, zpTick, 0.,
-                            signum(ypTick-ypTickN)*fy*xticklen,
+                            signum (ypTick-ypTickN)*fy*xticklen,
                             0., 0, mirror);
         }
 
       // tick texts
       if (xticklabels.numel () > 0)
         {
           int halign = (xstate == AXE_HORZ_DIR ? 1 : (xyzSym ? 0 : 2));
           int valign = (xstate == AXE_VERT_DIR ? 1 : (x2Dtop ? 0 : 2));
 
           if (tick_along_z)
             render_ticktexts (xticks, xticklabels, x_min, x_max, ypTick,
-                              zpTick+signum(zpTick-zpTickN)*fz*xtickoffset,
+                              zpTick+signum (zpTick-zpTickN)*fz*xtickoffset,
                               0, halign, valign, wmax, hmax);
           else
             render_ticktexts (xticks, xticklabels, x_min, x_max,
-                              ypTick+signum(ypTick-ypTickN)*fy*xtickoffset,
+                              ypTick+signum (ypTick-ypTickN)*fy*xtickoffset,
                               zpTick, 0, halign, valign, wmax, hmax);
         }
 
       // minor grid lines
       if (do_xminorgrid)
         render_grid (minorgridstyle, xmticks, x_min, x_max,
                      yPlane, yPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 0, (zstate != AXE_DEPTH_DIR));
 
       // minor tick marks
       if (do_xminortick)
         {
           if (tick_along_z)
             render_tickmarks (xmticks, x_min, x_max, ypTick, ypTick,
                               zpTick, zpTickN, 0., 0.,
-                              signum(zpTick-zpTickN)*fz*xticklen/2,
+                              signum (zpTick-zpTickN)*fz*xticklen/2,
                               0, mirror);
           else
             render_tickmarks (xmticks, x_min, x_max, ypTick, ypTickN,
                               zpTick, zpTick, 0.,
-                              signum(ypTick-ypTickN)*fy*xticklen/2,
+                              signum (ypTick-ypTickN)*fy*xticklen/2,
                               0., 0, mirror);
         }
 
       gh_manager::get_object (props.get_xlabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_xlabel ()).set ("visible", "off");
 }
@@ -1118,59 +1118,59 @@ opengl_renderer::draw_axes_y_grid (const
         render_grid (gridstyle, yticks, y_min, y_max,
                      xPlane, xPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 1, (zstate != AXE_DEPTH_DIR));
 
       // tick marks
       if (tick_along_z)
         render_tickmarks (yticks, y_min, y_max, xpTick, xpTick,
                           zpTick, zpTickN, 0., 0.,
-                          signum(zpTick-zpTickN)*fz*yticklen,
+                          signum (zpTick-zpTickN)*fz*yticklen,
                           1, mirror);
       else
         render_tickmarks (yticks, y_min, y_max, xpTick, xpTickN,
                           zpTick, zpTick,
-                          signum(xPlaneN-xPlane)*fx*yticklen,
+                          signum (xPlaneN-xPlane)*fx*yticklen,
                           0., 0., 1, mirror);
 
       // tick texts
       if (yticklabels.numel () > 0)
         {
           int halign = (ystate == AXE_HORZ_DIR
                         ? 1 : (!xyzSym || y2Dright ? 0 : 2));
           int valign = (ystate == AXE_VERT_DIR ? 1 : 2);
 
           if (tick_along_z)
             render_ticktexts (yticks, yticklabels, y_min, y_max, xpTick,
-                              zpTick+signum(zpTick-zpTickN)*fz*ytickoffset,
+                              zpTick+signum (zpTick-zpTickN)*fz*ytickoffset,
                               1, halign, valign, wmax, hmax);
           else
             render_ticktexts (yticks, yticklabels, y_min, y_max,
-                              xpTick+signum(xpTick-xpTickN)*fx*ytickoffset,
+                              xpTick+signum (xpTick-xpTickN)*fx*ytickoffset,
                               zpTick, 1, halign, valign, wmax, hmax);
         }
 
       // minor grid lines
       if (do_yminorgrid)
         render_grid (minorgridstyle, ymticks, y_min, y_max,
                      xPlane, xPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 1, (zstate != AXE_DEPTH_DIR));
 
       // minor tick marks
       if (do_yminortick)
         {
           if (tick_along_z)
             render_tickmarks (ymticks, y_min, y_max, xpTick, xpTick,
                               zpTick, zpTickN, 0., 0.,
-                              signum(zpTick-zpTickN)*fz*yticklen/2,
+                              signum (zpTick-zpTickN)*fz*yticklen/2,
                               1, mirror);
           else
             render_tickmarks (ymticks, y_min, y_max, xpTick, xpTickN,
                               zpTick, zpTick,
-                              signum(xpTick-xpTickN)*fx*yticklen/2,
+                              signum (xpTick-xpTickN)*fx*yticklen/2,
                               0., 0., 1, mirror);
         }
 
       gh_manager::get_object (props.get_ylabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_ylabel ()).set ("visible", "off");
 }
@@ -1215,64 +1215,64 @@ opengl_renderer::draw_axes_z_grid (const
                      xPlane, xPlaneN, yPlane, yPlaneN, 2, true);
 
       // tick marks
       if (xySym)
         {
           if (xisinf (fy))
             render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlane,
                               yPlane, yPlane,
-                              signum(xPlaneN-xPlane)*fx*zticklen,
+                              signum (xPlaneN-xPlane)*fx*zticklen,
                               0., 0., 2, mirror);
           else
             render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlaneN,
                               yPlane, yPlane, 0.,
-                              signum(yPlane-yPlaneN)*fy*zticklen,
+                              signum (yPlane-yPlaneN)*fy*zticklen,
                               0., 2, false);
         }
       else
         {
           if (xisinf (fx))
             render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlane,
                               yPlaneN, yPlane, 0.,
-                              signum(yPlaneN-yPlane)*fy*zticklen,
+                              signum (yPlaneN-yPlane)*fy*zticklen,
                               0., 2, mirror);
           else
             render_tickmarks (zticks, z_min, z_max, xPlane, xPlane,
                               yPlaneN, yPlane,
-                              signum(xPlane-xPlaneN)*fx*zticklen,
+                              signum (xPlane-xPlaneN)*fx*zticklen,
                               0., 0., 2, false);
         }
 
       // FIXME: tick texts
       if (zticklabels.numel () > 0)
         {
           int halign = 2;
           int valign = (zstate == AXE_VERT_DIR ? 1 : (zSign ? 3 : 2));
 
           if (xySym)
             {
               if (xisinf (fy))
                 render_ticktexts (zticks, zticklabels, z_min, z_max,
-                                  xPlaneN+signum(xPlaneN-xPlane)*fx*ztickoffset,
+                                  xPlaneN+signum (xPlaneN-xPlane)*fx*ztickoffset,
                                   yPlane, 2, halign, valign, wmax, hmax);
               else
                 render_ticktexts (zticks, zticklabels, z_min, z_max, xPlaneN,
-                                  yPlane+signum(yPlane-yPlaneN)*fy*ztickoffset,
+                                  yPlane+signum (yPlane-yPlaneN)*fy*ztickoffset,
                                   2, halign, valign, wmax, hmax);
             }
           else
             {
               if (xisinf (fx))
                 render_ticktexts (zticks, zticklabels, z_min, z_max, xPlane,
-                                  yPlaneN+signum(yPlaneN-yPlane)*fy*ztickoffset,
+                                  yPlaneN+signum (yPlaneN-yPlane)*fy*ztickoffset,
                                   2, halign, valign, wmax, hmax);
               else
                 render_ticktexts (zticks, zticklabels, z_min, z_max,
-                                  xPlane+signum(xPlane-xPlaneN)*fx*ztickoffset,
+                                  xPlane+signum (xPlane-xPlaneN)*fx*ztickoffset,
                                   yPlaneN, 2, halign, valign, wmax, hmax);
             }
         }
 
       // minor grid lines
       if (do_zminorgrid)
         render_grid (minorgridstyle, zmticks, z_min, z_max,
                      xPlane, xPlaneN, yPlane, yPlaneN, 2, true);
@@ -1280,35 +1280,35 @@ opengl_renderer::draw_axes_z_grid (const
       // minor tick marks
       if (do_zminortick)
         {
           if (xySym)
             {
               if (xisinf (fy))
                 render_tickmarks (zmticks, z_min, z_max, xPlaneN, xPlane,
                                   yPlane, yPlane,
-                                  signum(xPlaneN-xPlane)*fx*zticklen/2,
+                                  signum (xPlaneN-xPlane)*fx*zticklen/2,
                                   0., 0., 2, mirror);
               else
                 render_tickmarks (zmticks, z_min, z_max, xPlaneN, xPlaneN,
                                   yPlane, yPlane, 0.,
-                                  signum(yPlane-yPlaneN)*fy*zticklen/2,
+                                  signum (yPlane-yPlaneN)*fy*zticklen/2,
                                   0., 2, false);
             }
           else
             {
               if (xisinf (fx))
                 render_tickmarks (zmticks, z_min, z_max, xPlane, xPlane,
                                   yPlaneN, yPlane, 0.,
-                                  signum(yPlaneN-yPlane)*fy*zticklen/2,
+                                  signum (yPlaneN-yPlane)*fy*zticklen/2,
                                   0., 2, mirror);
               else
                 render_tickmarks (zmticks, z_min, z_max, xPlane, xPlane,
                                   yPlaneN, yPlaneN,
-                                  signum(xPlane-xPlaneN)*fx*zticklen/2,
+                                  signum (xPlane-xPlaneN)*fx*zticklen/2,
                                   0., 0., 2, false);
             }
         }
 
       gh_manager::get_object (props.get_zlabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_zlabel ()).set ("visible", "off");
@@ -2099,26 +2099,26 @@ opengl_renderer::draw_patch (const patch
   // int vmax = v.columns ();
   int nf = f.rows ();
   int fcmax = f.columns ();
 
   bool has_z = (v.columns () > 2);
   bool has_facecolor = false;
   bool has_facealpha = false;
 
-  int fc_mode = ((props.facecolor_is("none")
+  int fc_mode = ((props.facecolor_is ("none")
                   || props.facecolor_is_rgb ()) ? 0 :
-                 (props.facecolor_is("flat") ? 1 : 2));
+                 (props.facecolor_is ("flat") ? 1 : 2));
   int fl_mode = (props.facelighting_is ("none") ? 0 :
                  (props.facelighting_is ("flat") ? 1 : 2));
   int fa_mode = (props.facealpha_is_double () ? 0 :
                  (props.facealpha_is ("flat") ? 1 : 2));
-  int ec_mode = ((props.edgecolor_is("none")
+  int ec_mode = ((props.edgecolor_is ("none")
                   || props.edgecolor_is_rgb ()) ? 0 :
-                 (props.edgecolor_is("flat") ? 1 : 2));
+                 (props.edgecolor_is ("flat") ? 1 : 2));
   int el_mode = (props.edgelighting_is ("none") ? 0 :
                  (props.edgelighting_is ("flat") ? 1 : 2));
   int ea_mode = (props.edgealpha_is_double () ? 0 :
                  (props.edgealpha_is ("flat") ? 1 : 2));
 
   Matrix fcolor = props.get_facecolor_rgb ();
   Matrix ecolor = props.get_edgecolor_rgb ();
 
@@ -2464,17 +2464,17 @@ opengl_renderer::draw_text (const text::
   const Matrix bbox = props.get_extent_matrix ();
 
   // FIXME: handle margin and surrounding box
   bool blend = glIsEnabled (GL_BLEND);
 
   glEnable (GL_BLEND);
   glEnable (GL_ALPHA_TEST);
   glRasterPos3d (pos(0), pos(1), pos.numel () > 2 ? pos(2) : 0.0);
-  glBitmap(0, 0, 0, 0, bbox(0), bbox(1), 0);
+  glBitmap (0, 0, 0, 0, bbox(0), bbox(1), 0);
   glDrawPixels (bbox(2), bbox(3),
                 GL_RGBA, GL_UNSIGNED_BYTE, props.get_pixels ().data ());
   glDisable (GL_ALPHA_TEST);
   if (! blend)
     glDisable (GL_BLEND);
 
 }
 
@@ -2548,17 +2548,17 @@ opengl_renderer::draw_image (const image
       if (im_ymin < ymin)
         i0 += (ymin - im_ymin)/nor_dy + 1;
       if (im_ymax > ymax)
         i1 -= (im_ymax - ymax)/nor_dy;
     }
   else // clip to viewport
     {
       GLfloat vp[4];
-      glGetFloatv(GL_VIEWPORT, vp);
+      glGetFloatv (GL_VIEWPORT, vp);
       // FIXME -- actually add the code to do it!
 
     }
 
   if (i0 >= i1 || j0 >= j1)
     return;
 
   glPixelZoom (pix_dx, -pix_dy);
@@ -2857,17 +2857,17 @@ opengl_renderer::make_marker_list (const
       glBegin (GL_LINES);
       glVertex2f (-sz/2, 0);
       glVertex2f (sz/2, 0);
       glVertex2f (0, -sz/2);
       glVertex2f (0, sz/2);
       glEnd ();
       break;
     case 'x':
-      glBegin(GL_LINES);
+      glBegin (GL_LINES);
       glVertex2f (-sz/2, -sz/2);
       glVertex2f (sz/2, sz/2);
       glVertex2f (-sz/2, sz/2);
       glVertex2f (sz/2, -sz/2);
       glEnd ();
       break;
     case '*':
       glBegin (GL_LINES);
@@ -2882,17 +2882,17 @@ opengl_renderer::make_marker_list (const
       glEnd ();
       break;
     case '.':
       {
         double ang_step = M_PI / 5;
 
         glBegin (GL_POLYGON);
         for (double ang = 0; ang < (2*M_PI); ang += ang_step)
-          glVertex2d (sz*cos(ang)/3, sz*sin(ang)/3);
+          glVertex2d (sz*cos (ang)/3, sz*sin (ang)/3);
         glEnd ();
       }
       break;
     case 's':
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2d (-sz/2, -sz/2);
       glVertex2d (-sz/2, sz/2);
       glVertex2d (sz/2, sz/2);
@@ -2900,17 +2900,17 @@ opengl_renderer::make_marker_list (const
       glEnd ();
       break;
     case 'o':
       {
         double ang_step = M_PI / 5;
 
         glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
         for (double ang = 0; ang < (2*M_PI); ang += ang_step)
-          glVertex2d (sz*cos(ang)/2, sz*sin(ang)/2);
+          glVertex2d (sz*cos (ang)/2, sz*sin (ang)/2);
         glEnd ();
       }
       break;
     case 'd':
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2d (0, -sz/2);
       glVertex2d (sz/2, 0);
       glVertex2d (0, sz/2);
@@ -2944,40 +2944,40 @@ opengl_renderer::make_marker_list (const
       glVertex2f (sz/2, -sz/2);
       glVertex2f (sz/2, sz/2);
       glEnd ();
       break;
     case 'p':
       {
         double ang;
         double r;
-        double dr = 1.0 - sin(M_PI/10)/sin(3*M_PI/10)*1.02;
+        double dr = 1.0 - sin (M_PI/10)/sin (3*M_PI/10)*1.02;
 
         glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
         for (int i = 0; i < 2*5; i++)
           {
             ang = (-0.5 + double(i+1)/5) * M_PI;
-            r = 1.0 - (dr * fmod(double(i+1), 2.0));
-            glVertex2d (sz*r*cos(ang)/2, sz*r*sin(ang)/2);
+            r = 1.0 - (dr * fmod (double(i+1), 2.0));
+            glVertex2d (sz*r*cos (ang)/2, sz*r*sin (ang)/2);
           }
         glEnd ();
       }
       break;
     case 'h':
       {
         double ang;
         double r;
-        double dr = 1.0 - 0.5/sin(M_PI/3)*1.02;
+        double dr = 1.0 - 0.5/sin (M_PI/3)*1.02;
 
         glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
         for (int i = 0; i < 2*6; i++)
           {
             ang = (0.5 + double(i+1)/6.0) * M_PI;
-            r = 1.0 - (dr * fmod(double(i+1), 2.0));
-            glVertex2d (sz*r*cos(ang)/2, sz*r*sin(ang)/2);
+            r = 1.0 - (dr * fmod (double(i+1), 2.0));
+            glVertex2d (sz*r*cos (ang)/2, sz*r*sin (ang)/2);
           }
         glEnd ();
       }
       break;
     default:
       warning ("opengl_renderer: unsupported marker `%s'",
                marker.c_str ());
       break;
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1036,33 +1036,33 @@ bool
 color_values::str2rgb (std::string str)
 {
   double tmp_rgb[3] = {0, 0, 0};
   bool retval = true;
   unsigned int len = str.length ();
 
   std::transform (str.begin (), str.end (), str.begin (), tolower);
 
-  if (str.compare(0, len, "blue", 0, len) == 0)
+  if (str.compare (0, len, "blue", 0, len) == 0)
     tmp_rgb[2] = 1;
-  else if (str.compare(0, len, "black", 0, len) == 0
-           || str.compare(0, len, "k", 0, len) == 0)
+  else if (str.compare (0, len, "black", 0, len) == 0
+           || str.compare (0, len, "k", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = tmp_rgb[2] = 0;
-  else if (str.compare(0, len, "red", 0, len) == 0)
+  else if (str.compare (0, len, "red", 0, len) == 0)
     tmp_rgb[0] = 1;
-  else if (str.compare(0, len, "green", 0, len) == 0)
+  else if (str.compare (0, len, "green", 0, len) == 0)
     tmp_rgb[1] = 1;
-  else if (str.compare(0, len, "yellow", 0, len) == 0)
+  else if (str.compare (0, len, "yellow", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = 1;
-  else if (str.compare(0, len, "magenta", 0, len) == 0)
+  else if (str.compare (0, len, "magenta", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[2] = 1;
-  else if (str.compare(0, len, "cyan", 0, len) == 0)
+  else if (str.compare (0, len, "cyan", 0, len) == 0)
     tmp_rgb[1] = tmp_rgb[2] = 1;
-  else if (str.compare(0, len, "white", 0, len) == 0
-           || str.compare(0, len, "w", 0, len) == 0)
+  else if (str.compare (0, len, "white", 0, len) == 0
+           || str.compare (0, len, "w", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = tmp_rgb[2] = 1;
   else
     retval = false;
 
   if (retval)
     {
       for (int i = 0; i < 3; i++)
         xrgb(i) = tmp_rgb[i];
@@ -1118,17 +1118,17 @@ color_property::do_set (const octave_val
            get_name ().c_str ());
     }
   else if (val.is_numeric_type ())
     {
       Matrix m = val.matrix_value ();
 
       if (m.numel () == 3)
         {
-          color_values col (m (0), m (1), m(2));
+          color_values col (m(0), m(1), m(2));
           if (! error_state)
             {
               if (current_type != color_t || col != color_val)
                 {
                   color_val = col;
                   current_type = color_t;
                   return true;
                 }
@@ -1978,17 +1978,17 @@ graphics_object::set (const octave_value
 
 // Set properties given in two cell arrays containing names and values.
 void
 graphics_object::set (const Array<std::string>& names,
                       const Cell& values, octave_idx_type row)
 {
   if (names.numel () != values.columns ())
     {
-      error("set: number of names must match number of value columns (%d != %d)",
+      error ("set: number of names must match number of value columns (%d != %d)",
             names.numel (), values.columns ());
     }
 
   octave_idx_type k = names.columns ();
 
   for (octave_idx_type column = 0; column < k; column++)
     {
       caseless_str name = names(column);
@@ -3958,39 +3958,39 @@ axes::properties::sync_positions (void)
            std::vector<bool> l_aligned, b_aligned, r_aligned, t_aligned;
            for (octave_idx_type i = 0; i < kids.numel (); i++)
              {
                graphics_object go = gh_manager::get_object (kids(i));
                if (go.isa ("axes"))
                  {
                    axes::properties& props =
                      dynamic_cast<axes::properties&> (go.get_properties ());
-                   if (props.autopos_tag_is("subplot"))
+                   if (props.autopos_tag_is ("subplot"))
                      {
                        Matrix outpos = go.get ("outerposition").matrix_value ();
-                       bool l_align=(std::abs (outpos(0)-ref_outbox(0)) < 1e-15);
-                       bool b_align=(std::abs (outpos(1)-ref_outbox(1)) < 1e-15);
-                       bool r_align=(std::abs (outpos(0)+outpos(2)-ref_outbox(2)) < 1e-15);
-                       bool t_align=(std::abs (outpos(1)+outpos(3)-ref_outbox(3)) < 1e-15);
+                       bool l_align = (std::abs (outpos(0)-ref_outbox(0)) < 1e-15);
+                       bool b_align = (std::abs (outpos(1)-ref_outbox(1)) < 1e-15);
+                       bool r_align = (std::abs (outpos(0)+outpos(2)-ref_outbox(2)) < 1e-15);
+                       bool t_align = (std::abs (outpos(1)+outpos(3)-ref_outbox(3)) < 1e-15);
                        if (l_align || b_align || r_align || t_align)
                          {
-                           aligned.push_back(kids(i));
-                           l_aligned.push_back(l_align);
-                           b_aligned.push_back(b_align);
-                           r_aligned.push_back(r_align);
-                           t_aligned.push_back(t_align);
+                           aligned.push_back (kids(i));
+                           l_aligned.push_back (l_align);
+                           b_aligned.push_back (b_align);
+                           r_aligned.push_back (r_align);
+                           t_aligned.push_back (t_align);
                            // FIXME: the temporarily deleted tags should be
                            //        protected from interrupts
                            props.set_autopos_tag ("none");
                          }
                      }
                  }
              }
            // Determine a minimum box which aligns the subplots
-           Matrix ref_box(1, 4, 0.);
+           Matrix ref_box (1, 4, 0.);
            ref_box(2) = 1.;
            ref_box(3) = 1.;
            for (size_t i = 0; i < aligned.size (); i++)
              {
                graphics_object go = gh_manager::get_object (aligned[i]);
                axes::properties& props =
                  dynamic_cast<axes::properties&> (go.get_properties ());
                Matrix linset = props.get_looseinset ().matrix_value ();
@@ -4535,17 +4535,17 @@ translate (ColumnVector& v, double x, do
   v(0) += x;
   v(1) += y;
   v(2) += z;
 }
 
 inline void
 normalize (ColumnVector& v)
 {
-  double fact = 1.0/sqrt(v(0)*v(0)+v(1)*v(1)+v(2)*v(2));
+  double fact = 1.0 / sqrt (v(0)*v(0)+v(1)*v(1)+v(2)*v(2));
   scale (v, fact, fact, fact);
 }
 
 inline double
 dot (const ColumnVector& v1, const ColumnVector& v2)
 {
   return (v1(0)*v2(0)+v1(1)*v2(1)+v1(2)*v2(2));
 }
@@ -4574,25 +4574,25 @@ unit_cube (void)
       1,0,0,1,
       0,1,0,1,
       0,0,1,1,
       1,1,0,1,
       1,0,1,1,
       0,1,1,1,
       1,1,1,1};
   Matrix m (4, 8);
-  memcpy (m.fortran_vec (), data, sizeof(double)*32);
+  memcpy (m.fortran_vec (), data, sizeof (double)*32);
   return m;
 }
 
 inline ColumnVector
 cam2xform (const Array<double>& m)
 {
   ColumnVector retval (4, 1.0);
-  memcpy (retval.fortran_vec (), m.fortran_vec (), sizeof(double)*3);
+  memcpy (retval.fortran_vec (), m.fortran_vec (), sizeof (double)*3);
   return retval;
 }
 
 inline RowVector
 xform2cam (const ColumnVector& v)
 {
   return v.extract_n (0, 3).transpose ();
 }
@@ -4613,17 +4613,17 @@ axes::properties::update_camera (void)
   double zo = zlimits(zd > 0 ? 0 : 1);
 
   Matrix pb  = get_plotboxaspectratio ().matrix_value ();
 
   bool autocam = (camerapositionmode_is ("auto")
                   && cameratargetmode_is ("auto")
                   && cameraupvectormode_is ("auto")
                   && cameraviewanglemode_is ("auto"));
-  bool dowarp = (autocam && dataaspectratiomode_is("auto")
+  bool dowarp = (autocam && dataaspectratiomode_is ("auto")
                  && plotboxaspectratiomode_is ("auto"));
 
   ColumnVector c_eye (xform_vector ());
   ColumnVector c_center (xform_vector ());
   ColumnVector c_upv (xform_vector ());
 
   if (cameratargetmode_is ("auto"))
     {
@@ -4635,27 +4635,27 @@ axes::properties::update_camera (void)
     }
   else
     c_center = cam2xform (get_cameratarget ().matrix_value ());
 
   if (camerapositionmode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0), el = tview(1);
-      double d = 5*sqrt(pb(0)*pb(0)+pb(1)*pb(1)+pb(2)*pb(2));
+      double d = 5 * sqrt (pb(0)*pb(0)+pb(1)*pb(1)+pb(2)*pb(2));
 
       if (el == 90 || el == -90)
-        c_eye(2) = d*signum(el);
+        c_eye(2) = d*signum (el);
       else
         {
           az *= M_PI/180.0;
           el *= M_PI/180.0;
-          c_eye(0) = d*cos(el)*sin(az);
-          c_eye(1) = -d*cos(el)*cos(az);
-          c_eye(2) = d*sin(el);
+          c_eye(0) = d * cos (el) * sin (az);
+          c_eye(1) = -d* cos (el) * cos (az);
+          c_eye(2) = d * sin (el);
         }
       c_eye(0) = c_eye(0)*(xlimits(1)-xlimits(0))/(xd*pb(0))+c_center(0);
       c_eye(1) = c_eye(1)*(ylimits(1)-ylimits(0))/(yd*pb(1))+c_center(1);
       c_eye(2) = c_eye(2)*(zlimits(1)-zlimits(0))/(zd*pb(2))+c_center(2);
 
       cameraposition = xform2cam (c_eye);
     }
   else
@@ -4664,19 +4664,19 @@ axes::properties::update_camera (void)
   if (cameraupvectormode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0), el = tview(1);
 
       if (el == 90 || el == -90)
         {
           c_upv(0) =
-            -signum(el)*sin(az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
+            -signum (el) *sin (az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
           c_upv(1) =
-            signum(el)*cos(az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
+            signum (el) * cos (az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
         }
       else
         c_upv(2) = 1;
 
       cameraupvector = xform2cam (c_upv);
     }
   else
     c_upv = cam2xform (get_cameraupvector ().matrix_value ());
@@ -4703,17 +4703,17 @@ axes::properties::update_camera (void)
   translate (c_center, -c_eye(0), -c_eye(1), -c_eye(2));
 
   ColumnVector F (c_center), f (F), UP (c_upv);
   normalize (f);
   normalize (UP);
 
   if (std::abs (dot (f, UP)) > 1e-15)
     {
-      double fa = 1/sqrt(1-f(2)*f(2));
+      double fa = 1 / sqrt(1-f(2)*f(2));
       scale (UP, fa, fa, fa);
     }
 
   ColumnVector s = cross (f, UP);
   ColumnVector u = cross (s, f);
 
   scale (x_view, 1, 1, -1);
   Matrix l = xform_matrix ();
@@ -4861,17 +4861,17 @@ axes::properties::update_axes_layout (vo
         xPlane = (dir(0) > 0 ? x_max : x_min);
       else
         xPlane = (dir(1) < 0 ? x_max : x_min);
     }
   else
     xPlane = (dir(2) < 0 ? x_min : x_max);
 
   xPlaneN = (xPlane == x_min ? x_max : x_min);
-  fx = (x_max-x_min)/sqrt(dir(0)*dir(0)+dir(1)*dir(1));
+  fx = (x_max-x_min) / sqrt (dir(0)*dir(0)+dir(1)*dir(1));
 
   p1 = xform.transform ((x_min+x_max)/2, y_min, (z_min+z_max)/2, false);
   p2 = xform.transform ((x_min+x_max)/2, y_max, (z_min+z_max)/2, false);
   dir(0) = xround (p2(0)-p1(0));
   dir(1) = xround (p2(1)-p1(1));
   dir(2) = (p2(2)-p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     ystate = AXE_DEPTH_DIR;
@@ -4889,21 +4889,21 @@ axes::properties::update_axes_layout (vo
         yPlane = (dir(0) > 0 ? y_max : y_min);
       else
         yPlane = (dir(1) < 0 ? y_max : y_min);
     }
   else
     yPlane = (dir(2) < 0 ? y_min : y_max);
 
   yPlaneN = (yPlane == y_min ? y_max : y_min);
-  fy = (y_max-y_min)/sqrt(dir(0)*dir(0)+dir(1)*dir(1));
-
-  p1 = xform.transform((x_min+x_max)/2, (y_min+y_max)/2, z_min, false);
-  p2 = xform.transform((x_min+x_max)/2, (y_min+y_max)/2, z_max, false);
-  dir(0) = xround(p2(0)-p1(0));
+  fy = (y_max-y_min) / sqrt (dir(0)*dir(0)+dir(1)*dir(1));
+
+  p1 = xform.transform ((x_min+x_max)/2, (y_min+y_max)/2, z_min, false);
+  p2 = xform.transform ((x_min+x_max)/2, (y_min+y_max)/2, z_max, false);
+  dir(0) = xround (p2(0)-p1(0));
   dir(1) = xround (p2(1)-p1(1));
   dir(2) = (p2(2)-p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     zstate = AXE_DEPTH_DIR;
   else if (dir(2) == 0)
     {
       if (dir(0) == 0)
         zstate = AXE_VERT_DIR;
@@ -4917,17 +4917,17 @@ axes::properties::update_axes_layout (vo
         zPlane = (dir(0) > 0 ? z_min : z_max);
       else
         zPlane = (dir(1) < 0 ? z_min : z_max);
     }
   else
     zPlane = (dir(2) < 0 ? z_min : z_max);
 
   zPlaneN = (zPlane == z_min ? z_max : z_min);
-  fz = (z_max-z_min)/sqrt(dir(0)*dir(0)+dir(1)*dir(1));
+  fz = (z_max-z_min) / sqrt (dir(0)*dir(0)+dir(1)*dir(1));
 
   unwind_protect frame;
   frame.protect_var (updating_axes_layout);
   updating_axes_layout = true;
 
   xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
   zSign = (zd*(zPlane-zPlaneN) <= 0);
   xyzSym = zSign ? xySym : !xySym;
@@ -4967,17 +4967,17 @@ axes::properties::update_axes_layout (vo
         zpTick = zPlaneN;
         layer2Dtop = true;
       }
     else
       zpTick = zPlane;
   }
 
   Matrix viewmat = get_view ().matrix_value ();
-  nearhoriz = std::abs(viewmat(1)) <= 5;
+  nearhoriz = std::abs (viewmat(1)) <= 5;
 
   update_ticklength ();
 }
 
 void
 axes::properties::update_ticklength (void)
 {
   bool mode2d = (((xstate > AXE_DEPTH_DIR ? 1 : 0) +
@@ -5074,19 +5074,19 @@ axes::properties::update_xlabel_position
                                    get_xlim ().matrix_value ());
 
       double wmax = ext(0), hmax = ext(1), angle = 0;
       ColumnVector p =
         graphics_xform::xform_vector ((xpTickN+xpTick)/2, ypTick, zpTick);
 
       bool tick_along_z = nearhoriz || xisinf (fy);
       if (tick_along_z)
-        p(2) += (signum(zpTick-zpTickN)*fz*xtickoffset);
+        p(2) += (signum (zpTick-zpTickN)*fz*xtickoffset);
       else
-        p(1) += (signum(ypTick-ypTickN)*fy*xtickoffset);
+        p(1) += (signum (ypTick-ypTickN)*fy*xtickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (xstate)
         {
           case AXE_ANY_DIR:
             p(0) += (xyzSym ? wmax : -wmax);
             p(1) += hmax;
@@ -5165,19 +5165,19 @@ axes::properties::update_ylabel_position
                                    get_ylim ().matrix_value ());
 
       double wmax = ext(0), hmax = ext(1), angle = 0;
       ColumnVector p =
         graphics_xform::xform_vector (xpTick, (ypTickN+ypTick)/2, zpTick);
 
       bool tick_along_z = nearhoriz || xisinf (fx);
       if (tick_along_z)
-        p(2) += (signum(zpTick-zpTickN)*fz*ytickoffset);
+        p(2) += (signum (zpTick-zpTickN)*fz*ytickoffset);
       else
-        p(0) += (signum(xpTick-xpTickN)*fx*ytickoffset);
+        p(0) += (signum (xpTick-xpTickN)*fx*ytickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (ystate)
         {
           case AXE_ANY_DIR:
             p(0) += (!xyzSym ? wmax : -wmax);
             p(1) += hmax;
@@ -5259,28 +5259,28 @@ axes::properties::update_zlabel_position
       double wmax = ext(0), hmax = ext(1), angle = 0;
       ColumnVector p;
 
       if (xySym)
         {
           p = graphics_xform::xform_vector (xPlaneN, yPlane,
                                             (zpTickN+zpTick)/2);
           if (xisinf (fy))
-            p(0) += (signum(xPlaneN-xPlane)*fx*ztickoffset);
+            p(0) += (signum (xPlaneN-xPlane)*fx*ztickoffset);
           else
-            p(1) += (signum(yPlane-yPlaneN)*fy*ztickoffset);
+            p(1) += (signum (yPlane-yPlaneN)*fy*ztickoffset);
         }
       else
         {
           p = graphics_xform::xform_vector (xPlane, yPlaneN,
                                             (zpTickN+zpTick)/2);
           if (xisinf (fx))
-            p(1) += (signum(yPlaneN-yPlane)*fy*ztickoffset);
+            p(1) += (signum (yPlaneN-yPlane)*fy*ztickoffset);
           else
-            p(0) += (signum(xPlane-xPlaneN)*fx*ztickoffset);
+            p(0) += (signum (xPlane-xPlaneN)*fx*ztickoffset);
         }
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (zstate)
         {
           case AXE_ANY_DIR:
             if (camAuto)
@@ -5354,17 +5354,17 @@ axes::properties::update_title_position 
           ext = get_ticklabel_extents (get_xtick ().matrix_value (),
                                        get_xticklabel ().all_strings (),
                                        get_xlim ().matrix_value ());
           p(1) -= ext(1);
         }
 
       p = xform.untransform (p(0), p(1), p(2), true);
 
-      title_props.set_position (p.extract_n(0, 3).transpose ());
+      title_props.set_position (p.extract_n (0, 3).transpose ());
       title_props.set_positionmode ("auto");
     }
 }
 
 void
 axes::properties::update_autopos (const std::string& elem_type)
 {
   if (elem_type == "xlabel")
@@ -5710,17 +5710,17 @@ axes::properties::update_fontunits (cons
 
 double
 axes::properties::get_fontsize_points (double box_pix_height) const
 {
   double fs = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
-    parent_height = get_boundingbox (true).elem(3);
+    parent_height = get_boundingbox (true).elem (3);
 
   return convert_font_size (fs, get_fontunits (), "points", parent_height);
 }
 
 ColumnVector
 graphics_xform::xform_vector (double x, double y, double z)
 {
   return ::xform_vector (x, y, z);
@@ -6298,17 +6298,17 @@ axes::update_axis_limits (const std::str
       if (! (xisinf (val) || xisnan (val))) \
         min_pos = val; \
       val = limits(3); \
       if (! (xisinf (val) || xisnan (val))) \
         max_neg = val; \
     } \
   else \
     { \
-      limits.resize(4, 1); \
+      limits.resize (4, 1); \
       limits(0) = min_val; \
       limits(1) = max_val; \
       limits(2) = min_pos; \
       limits(3) = max_neg; \
     }
 
   if (axis_type == "xdata" || axis_type == "xscale"
       || axis_type == "xlimmode" || axis_type == "xliminclude"
@@ -6826,26 +6826,26 @@ axes::properties::translate_view (double
   zoom (xlims, ylims, false);
 }
 
 void
 axes::properties::rotate_view (double delta_el, double delta_az)
 {
   Matrix v = get_view ().matrix_value ();
 
-  v (1) += delta_el;
+  v(1) += delta_el;
 
   if(v(1) > 90)
     v(1) = 90;
   if(v(1) < -90)
     v(1) = -90;
 
-  v (0) = fmod(v(0) - delta_az + 720,360);
-
-  set_view(v);
+  v(0) = fmod (v(0) - delta_az + 720,360);
+
+  set_view (v);
   update_transform ();
 }
 
 void
 axes::properties::unzoom (void)
 {
   if (zoom_stack.size () >= 4)
     {
@@ -7052,17 +7052,17 @@ text::properties::get_fontsize_points (d
   double fs = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
     {
       graphics_object go (gh_manager::get_object (get___myhandle__ ()));
       graphics_object ax (go.get_ancestor ("axes"));
 
-      parent_height = ax.get_properties ().get_boundingbox (true).elem(3);
+      parent_height = ax.get_properties ().get_boundingbox (true).elem (3);
     }
 
   return convert_font_size (fs, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
@@ -7269,17 +7269,17 @@ hggroup::update_axis_limits (const std::
       if (! (xisinf (val) || xisnan (val)))
         min_pos = val;
       val = limits(3);
       if (! (xisinf (val) || xisnan (val)))
         max_neg = val;
     }
   else
     {
-      limits.resize(4,1);
+      limits.resize (4,1);
       limits(0) = min_val;
       limits(1) = max_val;
       limits(2) = min_pos;
       limits(3) = max_neg;
     }
 
   get_children_limits (min_val, max_val, min_pos, max_neg, kids, update_type);
 
@@ -7538,17 +7538,17 @@ uicontrol::properties::update_fontunits 
 
 double
 uicontrol::properties::get_fontsize_points (double box_pix_height) const
 {
   double fs = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
-    parent_height = get_boundingbox (false).elem(3);
+    parent_height = get_boundingbox (false).elem (3);
 
   return convert_font_size (fs, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 Matrix
 uipanel::properties::get_boundingbox (bool internal,
@@ -7674,17 +7674,17 @@ uipanel::properties::update_fontunits (c
 
 double
 uipanel::properties::get_fontsize_points (double box_pix_height) const
 {
   double fs = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
-    parent_height = get_boundingbox (false).elem(3);
+    parent_height = get_boundingbox (false).elem (3);
 
   return convert_font_size (fs, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 uitoolbar::get_default (const caseless_str& name) const
@@ -8423,17 +8423,17 @@ the dimensions of @var{pv}.\n\
                         }
                       else if (hcv.length () == args(2).cell_value ().rows ())
                         {
                           obj.set (args(1).cellstr_value (),
                                    args(2).cell_value (), n);
                         }
                       else
                         {
-                          error("set: number of graphics handles must match number of value rows (%d != %d)",
+                          error ("set: number of graphics handles must match number of value rows (%d != %d)",
                                 hcv.length (), args(2).cell_value ().rows ());
                           break;
 
                         }
                     }
                   else if (nargin == 2 && args(1).is_map ())
                     {
                       obj.set (args(1).map_value ());
@@ -8921,17 +8921,17 @@ calc_dimensions (const graphics_object& 
   Matrix kids = go.get_properties ().get_children ();
 
   for (octave_idx_type i = 0; i < kids.length (); i++)
     {
       graphics_handle hnd = gh_manager::lookup (kids(i));
 
       if (hnd.ok ())
         {
-          const graphics_object& kid = gh_manager::get_object(hnd);
+          const graphics_object& kid = gh_manager::get_object (hnd);
 
           if (kid.valid_object ())
             nd = calc_dimensions (kid);
 
           if (nd == 3)
             break;
         }
     }
@@ -9942,21 +9942,21 @@ do_cleanup_waitfor_listener (const octav
                     }
                 }
             }
         }
     }
 }
 
 static void
-cleanup_waitfor_postset_listener(const octave_value& listener)
+cleanup_waitfor_postset_listener (const octave_value& listener)
 { do_cleanup_waitfor_listener (listener, POSTSET); }
 
 static void
-cleanup_waitfor_predelete_listener(const octave_value& listener)
+cleanup_waitfor_predelete_listener (const octave_value& listener)
 { do_cleanup_waitfor_listener (listener, PREDELETE); }
 
 static octave_value_list
 waitfor_listener (const octave_value_list& args, int)
 {
   if (args.length () > 3)
     {
       uint32_t id = args(2).uint32_scalar_value ().value ();
diff --git a/src/graphics.in.h b/src/graphics.in.h
--- a/src/graphics.in.h
+++ b/src/graphics.in.h
@@ -460,17 +460,17 @@ public:
                 {
                   found = true;
                   break;
                 }
             }
           if (found)
             {
               for (int j = i; j < l.length () - 1; j++)
-                l(j) = l (j + 1);
+                l(j) = l(j + 1);
 
               l.resize (l.length () - 1);
             }
         }
       else
         {
           if (mode == PERSISTENT)
             l.resize (0);
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -527,29 +527,29 @@ load_path::do_clear (std::set<std::strin
 {
   bool warn_default_path_clobbered = false;
   for (dir_info_list_iterator i = dir_info_list.begin ();
        i != dir_info_list.end ();
        /* conditionally advance iterator in loop body */)
     {
       //Don't remove it if it's gonna be added again, but remove it from
       //list of items to add, to avoid duplicates later on
-      std::set<std::string>::iterator j = new_elts.find(i->dir_name);
+      std::set<std::string>::iterator j = new_elts.find (i->dir_name);
       if (j != new_elts.end ())
         {
-          new_elts.erase(j);
+          new_elts.erase (j);
           i++;
         }
       else
         {
           //Warn if removing a default directory and not immediately adding
           //it back again
-          if(i->is_init)
+          if (i->is_init)
             warn_default_path_clobbered = true;
-          i = dir_info_list.erase(i);
+          i = dir_info_list.erase (i);
         }
     }
 
   if (warn_default_path_clobbered)
     warning_with_id ("Octave:remove-init-dir",
                      "default load path altered.  Some built-in functions may "
                      "not be found.  Try restoredefaultpath() to recover it.");
 
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -292,23 +292,23 @@ private:
     typedef method_file_map_type::const_iterator const_method_file_map_iterator;
     typedef method_file_map_type::iterator method_file_map_iterator;
 
     // This default constructor is only provided so we can create a
     // std::map of dir_info objects.  You should not use this
     // constructor for any other purpose.
     dir_info (void)
       : dir_name (), abs_dir_name (), is_relative (false),
-        is_init(false), dir_mtime (), dir_time_last_checked (),
+        is_init (false), dir_mtime (), dir_time_last_checked (),
         all_files (), fcn_files (), private_file_map (), method_file_map ()
       { }
 
     dir_info (const std::string& d)
       : dir_name (d), abs_dir_name (), is_relative (false),
-        is_init(false), dir_mtime (), dir_time_last_checked (),
+        is_init (false), dir_mtime (), dir_time_last_checked (),
         all_files (), fcn_files (), private_file_map (), method_file_map ()
     {
       initialize ();
     }
 
     dir_info (const dir_info& di)
       : dir_name (di.dir_name), abs_dir_name (di.abs_dir_name),
         is_relative (di.is_relative),
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -644,17 +644,17 @@ Force Octave to assume the file is in Oc
 
   if (error_state)
     return retval;
 
   int i = 1;
   std::string orig_fname = "";
 
   // Function called with Matlab-style ["filename", options] syntax
-  if (argc > 1 && ! argv[1].empty () && argv[1].at(0) != '-')
+  if (argc > 1 && ! argv[1].empty () && argv[1].at (0) != '-')
     {
       orig_fname = argv[1];
       i++;
     }
 
   // It isn't necessary to have the default load format stored in a
   // user preference variable since we can determine the type of file
   // as we are reading.
@@ -996,17 +996,17 @@ save_fields (std::ostream& os, const oct
   glob_match pat (pattern);
 
   size_t saved = 0;
 
   for (octave_scalar_map::const_iterator p = m.begin (); p != m.end (); p++)
     {
       std::string empty_str;
 
-      if (pat.match(m.key (p)))
+      if (pat.match (m.key (p)))
         {
           do_save (os, m.contents (p), m.key (p), empty_str,
                    0, fmt, save_as_floats);
 
           saved++;
         }
     }
 
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -744,17 +744,17 @@ save_hdf5_empty (hid_t loc_id, const cha
 
 // Load an empty matrix, if needed. Returns
 //    > 0  loaded empty matrix, dimensions returned
 //    = 0  Not an empty matrix; did nothing
 //    < 0  Error condition
 int
 load_hdf5_empty (hid_t loc_id, const char *name, dim_vector &d)
 {
-  if (!hdf5_check_attr(loc_id, "OCTAVE_EMPTY_MATRIX"))
+  if (! hdf5_check_attr (loc_id, "OCTAVE_EMPTY_MATRIX"))
     return 0;
 
   hsize_t hdims, maxdims;
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -339,28 +339,28 @@ read_mat_binary_data (std::istream& is, 
             Array<Complex> data (dim_vector (1, nr - 1));
             Array<octave_idx_type> c (dim_vector (1, nr - 1));
             Array<octave_idx_type> r (dim_vector (1, nr - 1));
             OCTAVE_LOCAL_BUFFER (double, dtmp, nr);
             OCTAVE_LOCAL_BUFFER (double, ctmp, nr);
 
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              r.xelem(i) = dtmp[i] - 1;
+              r.xelem (i) = dtmp[i] - 1;
             nr_new = dtmp[nr - 1];
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              c.xelem(i) = dtmp[i] - 1;
+              c.xelem (i) = dtmp[i] - 1;
             nc_new = dtmp[nr - 1];
             read_mat_binary_data (is, dtmp, prec, nr - 1, swap, flt_fmt);
             read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
             read_mat_binary_data (is, ctmp, prec, nr - 1, swap, flt_fmt);
 
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              data.xelem(i) = Complex (dtmp[i], ctmp[i]);
+              data.xelem (i) = Complex (dtmp[i], ctmp[i]);
             read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
 
             SparseComplexMatrix smc = SparseComplexMatrix (data, r, c,
                                                            nr_new, nc_new);
 
             tc = order ? smc.transpose () : smc;
           }
         else
@@ -368,21 +368,21 @@ read_mat_binary_data (std::istream& is, 
             octave_idx_type nr_new, nc_new;
             Array<double> data (dim_vector (1, nr - 1));
             Array<octave_idx_type> c (dim_vector (1, nr - 1));
             Array<octave_idx_type> r (dim_vector (1, nr - 1));
             OCTAVE_LOCAL_BUFFER (double, dtmp, nr);
 
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              r.xelem(i) = dtmp[i] - 1;
+              r.xelem (i) = dtmp[i] - 1;
             nr_new = dtmp[nr - 1];
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              c.xelem(i) = dtmp[i] - 1;
+              c.xelem (i) = dtmp[i] - 1;
             nc_new = dtmp[nr - 1];
             read_mat_binary_data (is, data.fortran_vec (), prec, nr - 1, swap, flt_fmt);
             read_mat_binary_data (is, dtmp, prec, 1, swap, flt_fmt);
 
             SparseMatrix sm = SparseMatrix (data, r, c, nr_new, nc_new);
 
             tc = order ? sm.transpose () : sm;
           }
@@ -504,17 +504,17 @@ save_mat_binary_data (std::ostream& os, 
       for (octave_idx_type i = 0; i < nrow; i++)
         {
           std::string tstr = chm.row_as_string (i);
           const char *s = tstr.data ();
 
           for (octave_idx_type j = 0; j < ncol; j++)
             buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
         }
-      os.write (reinterpret_cast<char *> (buf), nrow*ncol*sizeof(double));
+      os.write (reinterpret_cast<char *> (buf), nrow*ncol*sizeof (double));
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
       octave_idx_type nel = r.nelem ();
       for (octave_idx_type i = 0; i < nel; i++)
@@ -532,53 +532,53 @@ save_mat_binary_data (std::ostream& os, 
     {
       double ds;
       OCTAVE_LOCAL_BUFFER (double, dtmp, len);
       if (tc.is_complex_matrix ())
         {
           SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp [i] = m.ridx(i) + 1;
+            dtmp[i] = m.ridx (i) + 1;
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = nr;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           octave_idx_type ii = 0;
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+            for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
               dtmp[ii++] = j + 1;
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = nc;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp [i] = std::real (m.data(i));
+            dtmp[i] = std::real (m.data (i));
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = 0.;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp [i] = std::imag (m.data(i));
+            dtmp[i] = std::imag (m.data (i));
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           os.write (reinterpret_cast<const char *> (&ds), 8);
         }
       else
         {
           SparseMatrix m = tc.sparse_matrix_value ();
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp [i] = m.ridx(i) + 1;
+            dtmp[i] = m.ridx (i) + 1;
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = nr;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           octave_idx_type ii = 0;
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+            for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
               dtmp[ii++] = j + 1;
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = nc;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           os.write (reinterpret_cast<const char *> (m.data ()), 8 * len);
           ds = 0.;
           os.write (reinterpret_cast<const char *> (&ds), 8);
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -662,17 +662,17 @@ read_mat5_binary_element (std::istream& 
         }
 
       std::streampos tmp_pos = is.tellg ();
       is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (dim_len) - dim_len));
     }
   else
     {
       // Why did mathworks decide to not have dims for a workspace!!!
-      dims.resize(2);
+      dims.resize (2);
       dims(0) = 1;
       dims(1) = 1;
     }
 
   if (read_mat5_tag (is, swap, type, len) || type != miINT8)
     {
       error ("load: invalid array name subelement");
       goto early_read_error;
@@ -859,33 +859,33 @@ read_mat5_binary_element (std::istream& 
 
         if (! is || error_state)
           goto data_read_error;
 
         // Octave can handle both "/" and "\" as a directry seperator
         // and so can ignore the seperator field of m0. I think the
         // sentinel field is also save to ignore.
         Octave_map m0 = tc2.map_value ();
-        Octave_map m1 = m0.contents("function_handle")(0).map_value ();
-        std::string ftype = m1.contents("type")(0).string_value ();
-        std::string fname = m1.contents("function")(0).string_value ();
-        std::string fpath = m1.contents("file")(0).string_value ();
+        Octave_map m1 = m0.contents ("function_handle")(0).map_value ();
+        std::string ftype = m1.contents ("type")(0).string_value ();
+        std::string fname = m1.contents ("function")(0).string_value ();
+        std::string fpath = m1.contents ("file")(0).string_value ();
 
         if (ftype == "simple" || ftype == "scopedfunction")
           {
             if (fpath.length () == 0)
               // We have a builtin function
               tc = make_fcn_handle (fname);
             else
               {
                 std::string mroot =
-                  m0.contents("matlabroot")(0).string_value ();
+                  m0.contents ("matlabroot")(0).string_value ();
 
                 if ((fpath.length () >= mroot.length ()) &&
-                    fpath.substr(0, mroot.length ()) == mroot &&
+                    fpath.substr (0, mroot.length ()) == mroot &&
                     OCTAVE_EXEC_PREFIX != mroot)
                   {
                     // If fpath starts with matlabroot, and matlabroot
                     // doesn't equal octave_config_info ("exec_prefix")
                     // then the function points to a version of Octave
                     // or Matlab other than the running version. In that
                     // case we replace with the same function in the
                     // running version of Octave?
@@ -974,22 +974,22 @@ read_mat5_binary_element (std::istream& 
           }
         else if (ftype == "nested")
           {
             warning ("load: can't load nested function");
             goto skip_ahead;
           }
         else if (ftype == "anonymous")
           {
-            Octave_map m2 = m1.contents("workspace")(0).map_value ();
-            uint32NDArray MCOS = m2.contents("MCOS")(0).uint32_array_value ();
+            Octave_map m2 = m1.contents ("workspace")(0).map_value ();
+            uint32NDArray MCOS = m2.contents ("MCOS")(0).uint32_array_value ();
             octave_idx_type off = static_cast<octave_idx_type>(MCOS(4).double_value ());
             m2 = subsys_ov.map_value ();
-            m2 = m2.contents("MCOS")(0).map_value ();
-            tc2 = m2.contents("MCOS")(0).cell_value ()(1 + off).cell_value ()(1);
+            m2 = m2.contents ("MCOS")(0).map_value ();
+            tc2 = m2.contents ("MCOS")(0).cell_value ()(1 + off).cell_value ()(1);
             m2 = tc2.map_value ();
 
             unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
             symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
@@ -1002,18 +1002,18 @@ read_mat5_binary_element (std::istream& 
 
             if (m2.nfields () > 0)
               {
                 octave_value tmp;
 
                 for (Octave_map::iterator p0 = m2.begin () ;
                      p0 != m2.end (); p0++)
                   {
-                    std::string key = m2.key(p0);
-                    octave_value val = m2.contents(p0)(0);
+                    std::string key = m2.key (p0);
+                    octave_value val = m2.contents (p0)(0);
 
                     symbol_table::varref (key, local_scope, 0) = val;
                   }
               }
 
             int parse_status;
             octave_value anon_fcn_handle =
               eval_string (fname.substr (4), true, parse_status);
@@ -1214,18 +1214,18 @@ read_mat5_binary_element (std::istream& 
 
         if (isclass)
           {
             if (classname == "inline")
               {
                 // inline is not an object in Octave but rather an
                 // overload of a function handle. Special case.
                 tc =
-                  new octave_fcn_inline (m.contents("expr")(0).string_value (),
-                                         m.contents("args")(0).string_value ());
+                  new octave_fcn_inline (m.contents ("expr")(0).string_value (),
+                                         m.contents ("args")(0).string_value ());
               }
             else
               {
                 octave_class* cls
                   = new octave_class (m, classname,
                                       std::list<std::string> ());
 
                 if (cls->reconstruct_exemplar ())
@@ -1272,17 +1272,17 @@ read_mat5_binary_element (std::istream& 
 
         if (logicalvar)
           {
             uint8NDArray in = tc.uint8_array_value ();
             octave_idx_type nel = in.numel ();
             boolNDArray out (dims);
 
             for (octave_idx_type i = 0; i < nel; i++)
-              out (i) = in(i).bool_value ();
+              out(i) = in(i).bool_value ();
 
             tc = out;
           }
       }
       break;
 
     case MAT_FILE_INT16_CLASS:
       OCTAVE_MAT5_INTEGER_READ (int16NDArray);
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -105,17 +105,17 @@ extract_keyword (std::istream& is, const
           bool match = (tmp.compare (0, strlen (keyword), keyword) == 0);
 
           if (match)
             {
               std::ostringstream value;
               while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
                 ; // Skip whitespace and the colon.
 
-              is.putback(c);
+              is.putback (c);
               retval = read_until_newline (is, false);
               break;
             }
           else if (next_only)
             break;
           else
             skip_until_newline (is, false);
         }
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -1172,23 +1172,23 @@ isinf ([13, Inf, NA, NaN])\n\
 
   return retval;
 }
 
 /*
 %!assert (isinf (Inf))
 %!assert (!isinf (NaN))
 %!assert (!isinf (NA))
-%!assert (isinf (rand(1,10)), false (1,10))
+%!assert (isinf (rand (1,10)), false (1,10))
 %!assert (isinf ([NaN -Inf -1 0 1 Inf NA]), [false, true, false, false, false, true, false])
 
 %!assert (isinf (single (Inf)))
 %!assert (!isinf (single (NaN)))
 %!assert (!isinf (single (NA)))
-%!assert (isinf (single (rand(1,10))), false (1,10))
+%!assert (isinf (single (rand (1,10))), false (1,10))
 %!assert (isinf (single ([NaN -Inf -1 0 1 Inf NA])), [false, true, false, false, false, true, false])
 
 %!error isinf ()
 %!error isinf (1, 2)
 */
 
 DEFUNX ("isgraph", Fisgraph, args, ,
     "-*- texinfo -*-\n\
@@ -1271,23 +1271,23 @@ isna ([13, Inf, NA, NaN])\n\
 
   return retval;
 }
 
 /*
 %!assert (!isna (Inf))
 %!assert (!isna (NaN))
 %!assert (isna (NA))
-%!assert (isna (rand(1,10)), false (1,10))
+%!assert (isna (rand (1,10)), false (1,10))
 %!assert (isna ([NaN -Inf -1 0 1 Inf NA]), [false, false, false, false, false, false, true])
 
 %!assert (!isna (single (Inf)))
 %!assert (!isna (single (NaN)))
 %!assert (isna (single (NA)))
-%!assert (isna (single (rand(1,10))), false (1,10))
+%!assert (isna (single (rand (1,10))), false (1,10))
 %!assert (isna (single ([NaN -Inf -1 0 1 Inf NA])), [false, false, false, false, false, false, true])
 
 %!error isna ()
 %!error isna (1, 2)
 */
 
 DEFUN (isnan, args, ,
     "-*- texinfo -*-\n\
@@ -1313,23 +1313,23 @@ isnan ([13, Inf, NA, NaN])\n\
 
   return retval;
 }
 
 /*
 %!assert (!isnan (Inf))
 %!assert (isnan (NaN))
 %!assert (isnan (NA))
-%!assert (isnan (rand(1,10)), false (1,10))
+%!assert (isnan (rand (1,10)), false (1,10))
 %!assert (isnan ([NaN -Inf -1 0 1 Inf NA]), [true, false, false, false, false, false, true])
 
 %!assert (!isnan (single (Inf)))
 %!assert (isnan (single (NaN)))
 %!assert (isnan (single (NA)))
-%!assert (isnan (single (rand(1,10))), false (1,10))
+%!assert (isnan (single (rand (1,10))), false (1,10))
 %!assert (isnan (single ([NaN -Inf -1 0 1 Inf NA])), [true, false, false, false, false, false, true])
 
 %!error isnan ()
 %!error isnan (1, 2)
 */
 
 DEFUNX ("isprint", Fisprint, args, ,
     "-*- texinfo -*-\n\
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -1571,22 +1571,22 @@ protected:
         {
           bool *ppr = static_cast<bool *> (pr);
 
           SparseBoolMatrix val (get_m (), get_n (),
                                 static_cast<octave_idx_type> (nzmax));
 
           for (mwIndex i = 0; i < nzmax; i++)
             {
-              val.xdata(i) = ppr[i];
-              val.xridx(i) = ir[i];
+              val.xdata (i) = ppr[i];
+              val.xridx (i) = ir[i];
             }
 
           for (mwIndex i = 0; i < get_n () + 1; i++)
-            val.xcidx(i) = jc[i];
+            val.xcidx (i) = jc[i];
 
           retval = val;
         }
         break;
 
       case mxSINGLE_CLASS:
         error ("single precision sparse data type not supported");
         break;
@@ -1598,40 +1598,40 @@ protected:
               double *ppr = static_cast<double *> (pr);
               double *ppi = static_cast<double *> (pi);
 
               SparseComplexMatrix val (get_m (), get_n (),
                                        static_cast<octave_idx_type> (nzmax));
 
               for (mwIndex i = 0; i < nzmax; i++)
                 {
-                  val.xdata(i) = Complex (ppr[i], ppi[i]);
-                  val.xridx(i) = ir[i];
+                  val.xdata (i) = Complex (ppr[i], ppi[i]);
+                  val.xridx (i) = ir[i];
                 }
 
               for (mwIndex i = 0; i < get_n () + 1; i++)
-                val.xcidx(i) = jc[i];
+                val.xcidx (i) = jc[i];
 
               retval = val;
             }
           else
             {
               double *ppr = static_cast<double *> (pr);
 
               SparseMatrix val (get_m (), get_n (),
                                 static_cast<octave_idx_type> (nzmax));
 
               for (mwIndex i = 0; i < nzmax; i++)
                 {
-                  val.xdata(i) = ppr[i];
-                  val.xridx(i) = ir[i];
+                  val.xdata (i) = ppr[i];
+                  val.xridx (i) = ir[i];
                 }
 
               for (mwIndex i = 0; i < get_n () + 1; i++)
-                val.xcidx(i) = jc[i];
+                val.xcidx (i) = jc[i];
 
               retval = val;
             }
         }
         break;
 
       default:
         panic_impossible ();
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -147,17 +147,17 @@ octave_fields::equal_up_to_order (const 
 
 string_vector
 octave_fields::fieldnames (void) const
 {
   octave_idx_type n = nfields ();
   string_vector retval(n);
 
   for (iterator p = begin (); p != end (); p++)
-    retval.xelem(p->second) = p->first;
+    retval.xelem (p->second) = p->first;
 
   return retval;
 }
 
 octave_value
 octave_scalar_map::getfield (const std::string& k) const
 {
   octave_idx_type idx = xkeys.getfield (k);
@@ -192,17 +192,17 @@ octave_scalar_map::orderfields (void) co
 octave_scalar_map
 octave_scalar_map::orderfields (Array<octave_idx_type>& perm) const
 {
   octave_scalar_map retval (xkeys);
   retval.xkeys.orderfields (perm);
 
   octave_idx_type nf = nfields ();
   for (octave_idx_type i = 0; i < nf; i++)
-    retval.xvals[i] = xvals[perm.xelem(i)];
+    retval.xvals[i] = xvals[perm.xelem (i)];
 
   return retval;
 }
 
 octave_scalar_map
 octave_scalar_map::orderfields (const octave_scalar_map& other,
                                 Array<octave_idx_type>& perm) const
 {
@@ -210,17 +210,17 @@ octave_scalar_map::orderfields (const oc
     return *this;
   else
     {
       octave_scalar_map retval (other.xkeys);
       if (other.xkeys.equal_up_to_order (xkeys, perm))
         {
           octave_idx_type nf = nfields ();
           for (octave_idx_type i = 0; i < nf; i++)
-            retval.xvals[i] = xvals[perm.xelem(i)];
+            retval.xvals[i] = xvals[perm.xelem (i)];
         }
       else
         error ("orderfields: structs must have same fields up to order");
 
       return retval;
     }
 }
 
@@ -242,17 +242,17 @@ octave_scalar_map::contents (const std::
 octave_map::octave_map (const octave_scalar_map& m)
   : xkeys (m.xkeys), xvals (), dimensions (1, 1)
 {
   octave_idx_type nf = m.nfields ();
   xvals.reserve (nf);
   for (octave_idx_type i = 0; i < nf; i++)
     {
       xvals.push_back (Cell (dimensions));
-      xvals[i].xelem(0) = m.xvals[i];
+      xvals[i].xelem (0) = m.xvals[i];
     }
 }
 
 octave_map::octave_map (const Octave_map& m)
   : xkeys (m.keys ()), xvals (m.nfields ()), dimensions (m.dims ())
 {
   for (iterator p = begin (); p != end (); p++)
     contents(p) = m.contents (key (p));
@@ -303,17 +303,17 @@ octave_map::orderfields (void) const
 octave_map
 octave_map::orderfields (Array<octave_idx_type>& perm) const
 {
   octave_map retval (xkeys);
   retval.xkeys.orderfields (perm);
 
   octave_idx_type nf = nfields ();
   for (octave_idx_type i = 0; i < nf; i++)
-    retval.xvals[i] = xvals[perm.xelem(i)];
+    retval.xvals[i] = xvals[perm.xelem (i)];
 
   return retval;
 }
 
 octave_map
 octave_map::orderfields (const octave_map& other,
                          Array<octave_idx_type>& perm) const
 {
@@ -321,17 +321,17 @@ octave_map::orderfields (const octave_ma
     return *this;
   else
     {
       octave_map retval (other.xkeys);
       if (other.xkeys.equal_up_to_order (xkeys, perm))
         {
           octave_idx_type nf = nfields ();
           for (octave_idx_type i = 0; i < nf; i++)
-            retval.xvals[i] = xvals[perm.xelem(i)];
+            retval.xvals[i] = xvals[perm.xelem (i)];
         }
       else
         error ("orderfields: structs must have same fields up to order");
 
       return retval;
     }
 }
 
@@ -586,17 +586,17 @@ octave_map::do_cat (int dim, octave_idx_
   rd(0) = rd(1) = 1;
   rd(dim) = n;
 
   for (octave_idx_type j = 0; j < nf; j++)
     {
       retval.xvals.push_back (Cell (rd));
       assert (retval.xvals[j].numel () == n);
       for (octave_idx_type i = 0; i < n; i++)
-        retval.xvals[j].xelem(i) = map_list[i].xvals[j];
+        retval.xvals[j].xelem (i) = map_list[i].xvals[j];
     }
 }
 
 void
 octave_map::do_cat (int dim, octave_idx_type n, const octave_map *map_list,
                     octave_map& retval)
 {
   octave_idx_type nf = retval.nfields ();
@@ -1273,17 +1273,17 @@ octave_map::concat (const octave_map& rb
           const_iterator pb = rb.seek (key(pa));
 
           if (pb == rb.end ())
             {
               error ("field name mismatch in structure concatenation");
               break;
             }
 
-          contents(pa).insert (rb.contents(pb), ra_idx);
+          contents(pa).insert (rb.contents (pb), ra_idx);
         }
     }
   else
     {
       dim_vector dv = dims ();
 
       if (dv.all_zero ())
         *this = rb;
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -152,17 +152,17 @@ octave_value_list::splice (octave_idx_ty
   retval.resize (new_len);
 
   octave_idx_type k = 0;
 
   for (octave_idx_type i = 0; i < offset; i++)
     retval(k++) = elem (i);
 
   for (octave_idx_type i = 0; i < lst_len; i++)
-    retval(k++) = lst(i);
+    retval(k++) = lst (i);
 
   for (octave_idx_type i = offset + rep_length; i < len; i++)
     retval(k++) = elem (i);
 
   return retval;
 }
 
 bool
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -376,17 +376,17 @@ template <class T>
 bool
 octave_base_int_matrix<T>::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   bool retval = false;
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    this->matrix.resize(dv);
+    this->matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -48,17 +48,17 @@ octave_base_matrix : public octave_base_
 {
 public:
 
   octave_base_matrix (void)
     : octave_base_value (), matrix (), typ (), idx_cache () { }
 
   octave_base_matrix (const MT& m, const MatrixType& t = MatrixType ())
     : octave_base_value (), matrix (m),
-      typ (t.is_known () ? new MatrixType(t) : 0), idx_cache ()
+      typ (t.is_known () ? new MatrixType (t) : 0), idx_cache ()
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_matrix (const octave_base_matrix& m)
     : octave_base_value (), matrix (m.matrix),
       typ (m.typ ? new MatrixType (*m.typ) : 0),
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -365,23 +365,23 @@ octave_base_sparse<T>::print_raw (std::o
           octave_quit ();
 
           // FIXME -- is there an easy way to get the max row
           // and column indices so we can set the width appropriately
           // and line up the columns here?  Similarly, we should look
           // at all the nonzero values and display them with the same
           // formatting rules that apply to columns of a matrix.
 
-          for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
+          for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
             {
               os << "\n";
-              os << "  (" << matrix.ridx(i)+1 <<
+              os << "  (" << matrix.ridx (i)+1 <<
                 ", "  << j+1 << ") -> ";
 
-              octave_print_internal (os, matrix.data(i), pr_as_read_syntax);
+              octave_print_internal (os, matrix.data (i), pr_as_read_syntax);
             }
         }
     }
 }
 
 template <class T>
 bool
 octave_base_sparse<T>::save_ascii (std::ostream& os)
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -464,17 +464,17 @@ octave_bool_matrix::save_hdf5 (hid_t loc
 bool
 octave_bool_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -158,29 +158,29 @@ ComplexNDArray
 octave_sparse_bool_matrix::complex_array_value (bool) const
 {
   return ComplexNDArray (ComplexMatrix (matrix.matrix_value ()));
 }
 
 NDArray
 octave_sparse_bool_matrix::array_value (bool) const
 {
-  return NDArray (Matrix(matrix.matrix_value ()));
+  return NDArray (Matrix (matrix.matrix_value ()));
 }
 
 charNDArray
 octave_sparse_bool_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims (), 0);
   octave_idx_type nc = matrix.cols ();
   octave_idx_type nr = matrix.rows ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
-      retval(matrix.ridx(i) + nr * j) = static_cast<char>(matrix.data (i));
+    for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
+      retval(matrix.ridx (i) + nr * j) = static_cast<char>(matrix.data (i));
 
   return retval;
 }
 
 boolMatrix
 octave_sparse_bool_matrix::bool_matrix_value (bool) const
 {
   return matrix.matrix_value ();
@@ -233,24 +233,24 @@ octave_sparse_bool_matrix::save_binary (
   itmp= nz;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
   for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
-      itmp = matrix.cidx(i);
+      itmp = matrix.cidx (i);
       os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
   for (int i = 0; i < nz; i++)
     {
       octave_quit ();
-      itmp = matrix.ridx(i);
+      itmp = matrix.ridx (i);
       os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   for (int i = 0; i < nz; i++)
     htmp[i] = (matrix.data (i) ? 1 : 0);
 
@@ -295,27 +295,27 @@ octave_sparse_bool_matrix::load_binary (
 
   for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.cidx(i) = tmp;
+      m.cidx (i) = tmp;
     }
 
   for (int i = 0; i < nz; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.ridx(i) = tmp;
+      m.ridx (i) = tmp;
     }
 
   if (error_state || ! is)
     return false;
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   if (! is.read (htmp, nz))
@@ -546,17 +546,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
@@ -777,17 +777,17 @@ octave_sparse_bool_matrix::as_mxArray (v
   mxArray *retval = new mxArray (mxLOGICAL_CLASS, rows (), columns (),
                                  nz, mxREAL);
   bool *pr = static_cast<bool *> (retval->get_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
-      pr[i] = matrix.data(i);
-      ir[i] = matrix.ridx(i);
+      pr[i] = matrix.data (i);
+      ir[i] = matrix.ridx (i);
     }
 
   for (mwIndex i = 0; i < columns () + 1; i++)
-    jc[i] = matrix.cidx(i);
+    jc[i] = matrix.cidx (i);
 
   return retval;
 }
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1150,17 +1150,17 @@ octave_cell::load_hdf5 (hid_t loc_id, co
 {
   clear_cellstr_cache ();
 
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t group_id = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t group_id = H5Gopen (loc_id, name);
 #endif
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -137,17 +137,17 @@ octave_class::octave_class (const octave
                       Cell c (parent_dims);
 
                       octave_map pmap = parent.map_value ();
 
                       std::list<std::string> plist
                         = parent.parent_class_name_list ();
 
                       for (octave_idx_type i = 0; i < p_nel; i++)
-                        c(i) = octave_value (pmap.index(i), pcnm, plist);
+                        c(i) = octave_value (pmap.index (i), pcnm, plist);
 
                       map.assign (pcnm, c);
                     }
                   else
                     error ("class: parent class dimension mismatch");
                 }
               else if (nel == 1 && p_nel == 1)
                 {
@@ -182,17 +182,17 @@ octave_class::octave_class (const octave
                       Cell c (parent.dims ());
 
                       octave_map pmap = parent.map_value ();
 
                       std::list<std::string> plist
                         = parent.parent_class_name_list ();
 
                       for (octave_idx_type i = 0; i < p_nel; i++)
-                        c(i) = octave_value (pmap.index(i), pcnm, plist);
+                        c(i) = octave_value (pmap.index (i), pcnm, plist);
 
                       map.assign (pcnm, c);
                     }
                   else
                     error ("class: parent class dimension mismatch");
                 }
             }
         }
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -60,18 +60,18 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_float_complex (v.float_complex_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info(default_numeric_demotion_function,
-                                           octave_float_complex::static_type_id ());
+  return octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                            octave_float_complex::static_type_id ());
 }
 
 octave_base_value *
 octave_complex::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   double im = std::imag (scalar);
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -68,18 +68,18 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_complex_matrix&);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_matrix::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info(default_numeric_demotion_function,
-                                           octave_float_complex_matrix::static_type_id ());
+  return octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                            octave_float_complex_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_complex_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.numel () == 1)
@@ -639,17 +639,17 @@ octave_complex_matrix::save_hdf5 (hid_t 
 bool
 octave_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -183,18 +183,18 @@ octave_sparse_complex_matrix::char_array
                                "sparse complex matrix", "string");
   else
     {
       retval = charNDArray (dims (), 0);
       octave_idx_type nc = matrix.cols ();
       octave_idx_type nr = matrix.rows ();
 
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
-          retval(matrix.ridx(i) + nr * j) =
+        for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
+          retval(matrix.ridx (i) + nr * j) =
             static_cast<char>(std::real (matrix.data (i)));
     }
 
   return retval;
 }
 
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
@@ -270,24 +270,24 @@ octave_sparse_complex_matrix::save_binar
         st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)
      {
        octave_quit ();
-       itmp = matrix.cidx(i);
+       itmp = matrix.cidx (i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    for (int i = 0; i < nz; i++)
      {
        octave_quit ();
-       itmp = matrix.ridx(i);
+       itmp = matrix.ridx (i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    write_doubles (os, reinterpret_cast<const double *> (matrix.data ()), st, 2 * nz);
 
   return true;
 }
 
@@ -329,27 +329,27 @@ octave_sparse_complex_matrix::load_binar
 
   for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.cidx(i) = tmp;
+      m.cidx (i) = tmp;
     }
 
   for (int i = 0; i < nz; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.ridx(i) = tmp;
+      m.ridx (i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
 
   read_doubles (is, reinterpret_cast<double *> (m.data ()),
                 static_cast<save_type> (ctmp), 2 * nz, swap, fmt);
 
@@ -617,17 +617,17 @@ octave_sparse_complex_matrix::load_hdf5 
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
@@ -857,24 +857,24 @@ octave_sparse_complex_matrix::as_mxArray
                                  nz, mxCOMPLEX);
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
-      Complex val = matrix.data(i);
+      Complex val = matrix.data (i);
       pr[i] = std::real (val);
       pi[i] = std::imag (val);
-      ir[i] = matrix.ridx(i);
+      ir[i] = matrix.ridx (i);
     }
 
   for (mwIndex i = 0; i < columns () + 1; i++)
-    jc[i] = matrix.cidx(i);
+    jc[i] = matrix.cidx (i);
 
   return retval;
 }
 
 octave_value
 octave_sparse_complex_matrix::map (unary_mapper_t umap) const
 {
   switch (umap)
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1631,18 +1631,18 @@ Return a struct containing information a
               else
                 {
                   m.setfield ("function", fh_nm);
 
                   if (fcn->is_subfunction ())
                     {
                       m.setfield ("type", "subfunction");
                       Cell parentage (dim_vector (1, 2));
-                      parentage.elem(0) = fh_nm;
-                      parentage.elem(1) = fcn->parent_fcn_name ();
+                      parentage.elem (0) = fh_nm;
+                      parentage.elem (1) = fcn->parent_fcn_name ();
                       m.setfield ("parentage", octave_value (parentage));
                     }
                   else if (fcn->is_private_function ())
                     m.setfield ("type", "private");
                   else if (fh->is_overloaded ())
                     m.setfield ("type", "overloaded");
                   else
                     m.setfield ("type", "simple");
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -606,17 +606,17 @@ octave_float_complex_matrix::save_hdf5 (
 bool
 octave_float_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -619,17 +619,17 @@ octave_float_matrix::save_hdf5 (hid_t lo
 bool
 octave_float_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
@@ -855,18 +855,18 @@ Convert @var{x} to single precision type
     }
   else
     print_usage ();
 
   return octave_value ();
 }
 
 /*
-%!assert (class (single(1)), "single")
-%!assert (class (single(1 + i)), "single")
+%!assert (class (single (1)), "single")
+%!assert (class (single (1 + i)), "single")
 %!assert (class (single (int8 (1))), "single")
 %!assert (class (single (uint8 (1))), "single")
 %!assert (class (single (int16 (1))), "single")
 %!assert (class (single (uint16 (1))), "single")
 %!assert (class (single (int32 (1))), "single")
 %!assert (class (single (uint32 (1))), "single")
 %!assert (class (single (int64 (1))), "single")
 %!assert (class (single (uint64 (1))), "single")
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -84,18 +84,18 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_float_matrix (v.float_array_value ());
 }
 
 octave_base_value::type_conv_info
 octave_matrix::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info(default_numeric_demotion_function,
-                                           octave_float_matrix::static_type_id ());
+  return octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                            octave_float_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.nelem () == 1)
@@ -742,17 +742,17 @@ octave_matrix::save_hdf5 (hid_t loc_id, 
 bool
 octave_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -155,18 +155,18 @@ octave_sparse_matrix::bool_array_value (
 charNDArray
 octave_sparse_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims (), 0);
   octave_idx_type nc = matrix.cols ();
   octave_idx_type nr = matrix.rows ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
-      retval(matrix.ridx(i) + nr * j) = static_cast<char>(matrix.data (i));
+    for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
+      retval(matrix.ridx (i) + nr * j) = static_cast<char>(matrix.data (i));
 
   return retval;
 }
 
 ComplexMatrix
 octave_sparse_matrix::complex_matrix_value (bool) const
 {
   return ComplexMatrix (matrix.matrix_value ());
@@ -211,18 +211,18 @@ octave_sparse_matrix::convert_to_str_int
     {
       octave_idx_type nr = matrix.rows ();
       octave_idx_type nc = matrix.cols ();
       charNDArray chm (dv, static_cast<char> (0));
 
       bool warned = false;
 
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = matrix.cidx(j);
-             i < matrix.cidx(j+1); i++)
+        for (octave_idx_type i = matrix.cidx (j);
+             i < matrix.cidx (j+1); i++)
           {
             octave_quit ();
 
             double d = matrix.data (i);
 
               if (xisnan (d))
                 {
                   gripe_nan_to_character_conversion ();
@@ -241,17 +241,17 @@ octave_sparse_matrix::convert_to_str_int
 
                       if (! warned)
                         {
                           ::warning ("range error for conversion to character value");
                           warned = true;
                         }
                     }
 
-                  chm (matrix.ridx(i) + j * nr) =
+                  chm (matrix.ridx (i) + j * nr) =
                     static_cast<char> (ival);
                 }
           }
 
       retval = octave_value (chm, type);
     }
 
   return retval;
@@ -303,24 +303,24 @@ octave_sparse_matrix::save_binary (std::
         st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)
      {
        octave_quit ();
-       itmp = matrix.cidx(i);
+       itmp = matrix.cidx (i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    for (int i = 0; i < nz; i++)
      {
        octave_quit ();
-       itmp = matrix.ridx(i);
+       itmp = matrix.ridx (i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    write_doubles (os, matrix.data (), st, nz);
 
   return true;
 }
 
@@ -362,27 +362,27 @@ octave_sparse_matrix::load_binary (std::
 
   for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.xcidx(i) = tmp;
+      m.xcidx (i) = tmp;
     }
 
   for (int i = 0; i < nz; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.xridx(i) = tmp;
+      m.xridx (i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
 
   read_doubles (is, m.xdata (), static_cast<save_type> (ctmp), nz, swap, fmt);
 
   if (error_state || ! is)
@@ -632,17 +632,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
@@ -862,22 +862,22 @@ octave_sparse_matrix::as_mxArray (void) 
   mwSize nc = columns ();
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, nr, nc, nz, mxREAL);
   double *pr = static_cast<double *> (retval->get_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
-      pr[i] = matrix.data(i);
-      ir[i] = matrix.ridx(i);
+      pr[i] = matrix.data (i);
+      ir[i] = matrix.ridx (i);
     }
 
   for (mwIndex i = 0; i < nc + 1; i++)
-    jc[i] = matrix.cidx(i);
+    jc[i] = matrix.cidx (i);
 
   return retval;
 }
 
 octave_value
 octave_sparse_matrix::map (unary_mapper_t umap) const
 {
   switch (umap)
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -62,18 +62,18 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_float_scalar (v.float_value ());
 }
 
 octave_base_value::type_conv_info
 octave_scalar::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info(default_numeric_demotion_function,
-                                           octave_float_scalar::static_type_id ());
+  return octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                            octave_float_scalar::static_type_id ());
 }
 
 octave_value
 octave_scalar::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
   // FIXME -- this doesn't solve the problem of
   //
   //   a = 1; a([1,1], [1,1], [1,1])
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -247,17 +247,17 @@ octave_char_matrix_str::cellstr_value (v
   Array<std::string> retval;
 
   if (matrix.ndims () == 2)
     {
       const charMatrix chm = matrix.matrix_value ();
       octave_idx_type nr = chm.rows ();
       retval.clear (nr, 1);
       for (octave_idx_type i = 0; i < nr; i++)
-        retval.xelem(i) = chm.row_as_string (i);
+        retval.xelem (i) = chm.row_as_string (i);
     }
   else
     error ("cellstr: cannot convert multidimensional arrays");
 
   return retval;
 }
 
 void
@@ -610,17 +610,17 @@ octave_char_matrix_str::save_hdf5 (hid_t
 bool
 octave_char_matrix_str::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1995,21 +1995,21 @@ Return the number of fields of the struc
   return retval;
 }
 
 /*
 ## test isfield
 %!test
 %! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;
 %! assert (isfield (x, "b"));
-%!assert (isfield (struct("a", "1"), "a"))
+%!assert (isfield (struct ("a", "1"), "a"))
 %!assert (isfield ({1}, "c"), false)
-%!assert (isfield (struct("a", "1"), 10), false)
-%!assert (isfield (struct("a", "b"), "a "), false)
-%!assert (isfield (struct("a", 1, "b", 2), {"a", "c"}), [true, false])
+%!assert (isfield (struct ("a", "1"), 10), false)
+%!assert (isfield (struct ("a", "b"), "a "), false)
+%!assert (isfield (struct ("a", 1, "b", 2), {"a", "c"}), [true, false])
 */
 
 DEFUN (cell2struct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
 Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
 must match the number of elements in @var{cell} along dimension @var{dim},\n\
 that is @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.\n\
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -183,17 +183,17 @@ octave_user_function::octave_user_functi
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
-    anonymous_function (false), nested_function(false),
+    anonymous_function (false), nested_function (false),
     class_constructor (false), class_method (false),
     parent_scope (-1), local_scope (sid),
     curr_unwind_protect_frame (0)
 {
   if (cmd_list)
     cmd_list->mark_as_function_body ();
 
   if (local_scope >= 0)
@@ -866,17 +866,17 @@ DEFUN (isargout, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isargout (@var{k})\n\
 Within a function, return a logical value indicating whether the argument\n\
 @var{k} will be assigned on output to a variable.  If the result is false,\n\
 the argument has been ignored during the function call through the use of\n\
 the tilde (~) special output argument.  Functions can use @code{isargout} to\n\
 avoid performing unnecessary calculations for outputs which are unwanted.\n\
 \n\
-If @var{k} is outside the range @code{1:max(nargout)}, the function returns\n\
+If @var{k} is outside the range @code{1:max (nargout)}, the function returns\n\
 false.  @var{k} can also be an array, in which case the function works\n\
 element-by-element and a logical array is returned.  At the top level,\n\
 @code{isargout} returns an error.\n\
 @seealso{nargout, nargin, varargin, varargout, nthargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2746,17 +2746,17 @@ decode_subscripts (const char* name, con
               if (item == "{}")
                 type_string[k] = '{';
               else if (item == "()")
                 type_string[k] = '(';
               else if (item == ".")
                 type_string[k] = '.';
               else
                 {
-                  error("%s: invalid indexing type `%s'", name, item.c_str ());
+                  error ("%s: invalid indexing type `%s'", name, item.c_str ());
                   return;
                 }
             }
           else
             {
               error ("%s: expecting type(%d) to be a character string",
                      name, k+1);
               return;
@@ -2805,17 +2805,17 @@ are @samp{\"()\"}, @samp{\"@{@}\"}, and 
 The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
 of index values.\n\
 \n\
 The following example shows how to extract the two first columns of\n\
 a matrix\n\
 \n\
 @example\n\
 @group\n\
-val = magic(3)\n\
+val = magic (3)\n\
     @result{} val = [ 8   1   6\n\
                3   5   7\n\
                4   9   2 ]\n\
 idx.type = \"()\";\n\
 idx.subs = @{\":\", 1:2@};\n\
 subsref (val, idx)\n\
      @result{} [ 8   1\n\
           3   5\n\
@@ -2952,17 +2952,17 @@ and @samp{subs}, return @var{rhs}.\n\
 %! idx2 = substruct  ("()", {2:2:5, 2:2:5});
 %! idx3 = substruct  ("()", {":", [1,5]});
 %! idx2p = substruct ("{}", {2:2:5, 2:2:5});
 %! idx3p = substruct ("{}", {":", [1,5]});
 %! idx4 = struct ("type", {}, "subs", {});
 %! assert ({ subsref(c, idx1) }, {13});
 %! assert ({ subsref(c, idx2p) }, {7 9 17 19});
 %! assert ({ subsref(c, idx3p) }, num2cell ([1:5, 21:25]));
-%! assert (subsref(c, idx4), c);
+%! assert (subsref (c, idx4), c);
 %! c = subsasgn (c, idx1, 0);
 %! c = subsasgn (c, idx2, 0);
 %! c = subsasgn (c, idx3, 0);
 %!# c = subsasgn (c, idx4, 0);
 %! d = {0    6   11   16    0
 %!      0    0   12    0    0
 %!      0    8    0   18    0
 %!      0    0   14    0    0
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -298,18 +298,18 @@ operator << (std::ostream& os, const pr_
   if (ex < 0)
     {
       os << std::setw (0) << "e-";
       ex = -ex;
     }
   else
     os << std::setw (0) << "e+";
 
-  os << std::setw (pef.f.ex - 2) << std::setfill('0') << ex
-     << std::setfill(' ');
+  os << std::setw (pef.f.ex - 2) << std::setfill ('0') << ex
+     << std::setfill (' ');
 
   os.flags (oflags);
 
   return os;
 }
 
 class
 pr_formatted_float
@@ -355,17 +355,17 @@ rational_approx (double val, int len)
   if (xisinf (val))
     s = "1/0";
   else if (xisnan (val))
     s = "0/0";
   else if (val < INT_MIN || val > INT_MAX || D_NINT (val) == val)
     {
       std::ostringstream buf;
       buf.flags (std::ios::fixed);
-      buf << std::setprecision (0) << xround(val);
+      buf << std::setprecision (0) << xround (val);
       s = buf.str ();
     }
   else
     {
       double lastn = 1.;
       double lastd = 0.;
       double n = xround (val);
       double d = 1.;
@@ -1999,18 +1999,18 @@ octave_print_internal (std::ostream& os,
                     os << "\n";
                 }
             }
         }
     }
 }
 
 template <typename NDA_T, typename ELT_T, typename MAT_T>
-void print_nd_array(std::ostream& os, const NDA_T& nda,
-                    bool pr_as_read_syntax)
+void print_nd_array (std::ostream& os, const NDA_T& nda,
+                     bool pr_as_read_syntax)
 {
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else
     {
 
       int ndims = nda.ndims ();
@@ -3549,17 +3549,17 @@ Note that the output from @code{fdisp} a
 %! fclose (fd);
 
 %!test
 %! foo.real = pi * ones (3,20,3);
 %! foo.complex = pi * ones (3,20,3) + 1i;
 %! foo.char = repmat ("- Hello World -", [3, 20]);
 %! foo.cell = {foo.real, foo.complex, foo.char};
 %! fields = fieldnames (foo);
-%! for f = 1:numel(fields)
+%! for f = 1:numel (fields)
 %!   format loose;
 %!   loose = disp (foo.(fields{f}));
 %!   format compact;
 %!   compact = disp (foo.(fields{f}));
 %!   expected = strrep (loose, "\n\n", "\n");
 %!   assert (expected, compact);
 %! endfor
 */
diff --git a/src/procstream.h b/src/procstream.h
--- a/src/procstream.h
+++ b/src/procstream.h
@@ -103,20 +103,20 @@ OCTINTERP_API
 oprocstream : public std::ostream, public procstreambase
 // oprocstream : public procstreambase, public std::ostream
 {
 public:
 
   oprocstream (void) : std::ostream (0), procstreambase () { }
 
   oprocstream (const std::string& name, int mode = std::ios::out)
-    : std::ostream (0), procstreambase(name, mode) { }
+    : std::ostream (0), procstreambase (name, mode) { }
 
   oprocstream (const char *name, int mode = std::ios::out)
-    : std::ostream (0), procstreambase(name, mode) { }
+    : std::ostream (0), procstreambase (name, mode) { }
 
   ~oprocstream (void) { }
 
   void open (const std::string& name, int mode = std::ios::out)
     { procstreambase::open (name, mode); }
 
   void open (const char *name, int mode = std::ios::out)
     { procstreambase::open (name, mode); }
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -247,34 +247,34 @@ generic_sig_handler (int sig)
 #ifdef SIGCHLD
 static void
 sigchld_handler (int /* sig */)
 {
   octave_signal_caught = 1;
 
   octave_signals_caught[SIGCHLD] = true;
 }
-#endif /* defined(SIGCHLD) */
+#endif /* defined (SIGCHLD) */
 
 #ifdef SIGFPE
 #if defined (__alpha__)
 static void
 sigfpe_handler (int /* sig */)
 {
   if (can_interrupt && octave_interrupt_state >= 0)
     {
       octave_signal_caught = 1;
 
       octave_signals_caught[SIGFPE] = true;
 
       octave_interrupt_state++;
     }
 }
-#endif /* defined(__alpha__) */
-#endif /* defined(SIGFPE) */
+#endif /* defined (__alpha__) */
+#endif /* defined (SIGFPE) */
 
 #if defined (SIGHUP) || defined (SIGTERM)
 static void
 sig_hup_or_term_handler (int sig)
 {
   switch (sig)
     {
 #if defined (SIGHUP)
@@ -396,25 +396,25 @@ sigpipe_handler (int /* sig */)
 
   octave_signals_caught[SIGPIPE] = true;
 
   // Don't loop forever on account of this.
 
   if (pipe_handler_error_count++ > 100 && octave_interrupt_state >= 0)
     octave_interrupt_state++;
 }
-#endif /* defined(SIGPIPE) */
+#endif /* defined (SIGPIPE) */
 
 #ifdef USE_W32_SIGINT
 static BOOL CALLBACK
 w32_sigint_handler (DWORD sig)
 {
   const char *sig_name;
 
-  switch(sig)
+  switch (sig)
     {
       case CTRL_BREAK_EVENT:
         sig_name = "Ctrl-Break";
         break;
       case CTRL_C_EVENT:
         sig_name = "Ctrl-C";
         break;
       case CTRL_CLOSE_EVENT:
@@ -426,33 +426,33 @@ w32_sigint_handler (DWORD sig)
       case CTRL_SHUTDOWN_EVENT:
         sig_name = "shutdown";
         break;
       default:
         sig_name = "unknown console event";
         break;
     }
 
-  switch(sig)
+  switch (sig)
     {
       case CTRL_BREAK_EVENT:
       case CTRL_C_EVENT:
         w32_raise (SIGINT);
         break;
 
       case CTRL_CLOSE_EVENT:
         clean_up_and_exit (0);
         break;
       case CTRL_LOGOFF_EVENT:
       case CTRL_SHUTDOWN_EVENT:
       default:
         // We should do the following:
         //    clean_up_and_exit (0);
         // We can't because we aren't running in the normal Octave thread.
-        user_abort(sig_name, sig);
+        user_abort (sig_name, sig);
         break;
     }
 
   // Return TRUE if the event was handled, or FALSE if another handler
   // should be called.
   // FIXME check that windows terminates the thread.
   return TRUE;
 }
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -112,17 +112,17 @@ INSTANTIATE_MX_DIV_CONFORM (Matrix, Spar
 INSTANTIATE_MX_DIV_CONFORM (Matrix, SparseComplexMatrix);
 INSTANTIATE_MX_DIV_CONFORM (ComplexMatrix, SparseMatrix);
 INSTANTIATE_MX_DIV_CONFORM (ComplexMatrix, SparseComplexMatrix);
 INSTANTIATE_MX_DIV_CONFORM (SparseMatrix, DiagMatrix);
 INSTANTIATE_MX_DIV_CONFORM (SparseMatrix, ComplexDiagMatrix);
 INSTANTIATE_MX_DIV_CONFORM (SparseComplexMatrix, DiagMatrix);
 INSTANTIATE_MX_DIV_CONFORM (SparseComplexMatrix, ComplexDiagMatrix);
 
-// Right division functions.  X / Y = X * inv(Y) = (inv (Y') * X')'
+// Right division functions.  X / Y = X * inv (Y) = (inv (Y') * X')'
 //
 //                  Y / X:   m   cm   sm  scm
 //                   +--   +---+----+----+----+
 //   sparse matrix         | 1 |  3 |  5 |  7 |
 //                         +---+----+----+----+
 //   sparse complex_matrix | 2 |  4 |  6 |  8 |
 //                         +---+----+----+----+
 //   diagonal matrix                |  9 | 11 |
@@ -379,80 +379,80 @@ x_el_div (double a, const SparseMatrix& 
     result = Matrix (nr, nc, octave_NaN);
   else if (a > 0.)
     result = Matrix (nr, nc, octave_Inf);
   else
     result = Matrix (nr, nc, -octave_Inf);
 
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+    for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
-        result.elem (b.ridx(i), j) = a / b.data (i);
+        result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
-  ComplexMatrix  result (nr, nc, Complex(octave_NaN, octave_NaN));
+  ComplexMatrix  result (nr, nc, Complex (octave_NaN, octave_NaN));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+    for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
-        result.elem (b.ridx(i), j) = a / b.data (i);
+        result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+    for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
-        result.elem (b.ridx(i), j) = a / b.data (i);
+        result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+    for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
-        result.elem (b.ridx(i), j) = a / b.data (i);
+        result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
   return result;
 }
 
-// Left division functions.  X \ Y = inv(X) * Y
+// Left division functions.  X \ Y = inv (X) * Y
 //
 //               Y  \  X :   sm  scm  dm  dcm
 //                   +--   +---+----+
 //   matrix                | 1 |  5 |
 //                         +---+----+
 //   complex_matrix        | 2 |  6 |
 //                         +---+----+----+----+
 //   sparse matrix         | 3 |  7 |  9 | 11 |
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -245,32 +245,32 @@ elem_xpow (double a, const SparseMatrix&
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result (i, j) = std::pow (atmp, b(i,j));
+              result(i, j) = std::pow (atmp, b(i,j));
             }
         }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result (i, j) = std::pow (a, b(i,j));
+              result(i, j) = std::pow (a, b(i,j));
             }
         }
 
       retval = result;
     }
 
   return retval;
 }
@@ -285,17 +285,17 @@ elem_xpow (double a, const SparseComplex
   Complex atmp (a);
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          result (i, j) = std::pow (atmp, b(i,j));
+          result(i, j) = std::pow (atmp, b(i,j));
         }
     }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
@@ -318,36 +318,36 @@ elem_xpow (const SparseMatrix& a, double
         {
           ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
 
           // FIXME -- avoid apparent GNU libm bug by
           // converting A and B to complex instead of just A.
           Complex btmp (b);
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
               {
                 octave_quit ();
 
                 Complex atmp (a.data (i));
 
-                result (a.ridx(i), j) = std::pow (atmp, btmp);
+                result(a.ridx (i), j) = std::pow (atmp, btmp);
               }
 
           retval = octave_value (result);
         }
       else
         {
           Matrix result (nr, nc, (std::pow (0.0, b)));
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
               {
                 octave_quit ();
-                result (a.ridx(i), j) = std::pow (a.data (i), b);
+                result(a.ridx (i), j) = std::pow (a.data (i), b);
               }
 
           retval = octave_value (result);
         }
     }
   else if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       SparseComplexMatrix result (a);
@@ -402,21 +402,21 @@ elem_xpow (const SparseMatrix& a, const 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+    for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
       {
         if (a.data(i) < 0.0)
           {
-            double btmp = b (a.ridx(i), j);
+            double btmp = b (a.ridx (i), j);
             if (static_cast<int> (btmp) != btmp)
               {
                 convert_to_complex = 1;
                 goto done;
               }
           }
       }
 
@@ -424,41 +424,41 @@ done:
 
   // This is a dumb operator for sparse matrices anyway, and there is
   // no sensible way to handle the 0.^0 versus the 0.^x cases. Therefore
   // allocate a full matrix filled for the 0.^0 case and shrink it later
   // as needed
 
   if (convert_to_complex)
     {
-      SparseComplexMatrix complex_result (nr, nc, Complex(1.0, 0.0));
+      SparseComplexMatrix complex_result (nr, nc, Complex (1.0, 0.0));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+          for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
             {
               octave_quit ();
-              complex_result.xelem(a.ridx(i), j) =
-                std::pow (Complex(a.data(i)), Complex(b(a.ridx(i), j)));
+              complex_result.xelem (a.ridx (i), j) =
+                std::pow (Complex (a.data (i)), Complex (b(a.ridx (i), j)));
             }
         }
       complex_result.maybe_compress (true);
       retval = complex_result;
     }
   else
     {
       SparseMatrix result (nr, nc, 1.0);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+          for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
             {
               octave_quit ();
-              result.xelem(a.ridx(i), j) = std::pow (a.data(i),
-                                                     b (a.ridx(i), j));
+              result.xelem (a.ridx (i), j) = std::pow (a.data (i),
+                                                       b(a.ridx (i), j));
             }
         }
       result.maybe_compress (true);
       retval = result;
     }
 
   return retval;
 }
@@ -502,23 +502,23 @@ elem_xpow (const SparseMatrix& a, const 
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
-  SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
+  SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+      for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
-          result.xelem(a.ridx(i), j) = std::pow (a.data(i), b (a.ridx(i), j));
+          result.xelem (a.ridx(i), j) = std::pow (a.data (i), b(a.ridx (i), j));
         }
     }
 
   result.maybe_compress (true);
 
   return result;
 }
 
@@ -576,30 +576,30 @@ elem_xpow (const SparseComplexMatrix& a,
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
 
       if (xisint (b))
         {
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
               {
                 octave_quit ();
-                result (a.ridx(i), j) =
+                result (a.ridx (i), j) =
                   std::pow (a.data (i), static_cast<int> (b));
               }
         }
       else
         {
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
               {
                 octave_quit ();
-                result (a.ridx(i), j) = std::pow (a.data (i), b);
+                result (a.ridx (i), j) = std::pow (a.data (i), b);
               }
         }
 
       retval = result;
     }
   else
     {
       octave_idx_type nz = a.nnz ();
@@ -642,30 +642,30 @@ elem_xpow (const SparseComplexMatrix& a,
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
-  SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
+  SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+      for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
-          double btmp = b (a.ridx(i), j);
+          double btmp = b(a.ridx (i), j);
           Complex tmp;
 
           if (xisint (btmp))
-            result.xelem(a.ridx(i), j) = std::pow (a.data (i),
+            result.xelem (a.ridx (i), j) = std::pow (a.data (i),
                                               static_cast<int> (btmp));
           else
-            result.xelem(a.ridx(i), j) = std::pow (a.data (i), btmp);
+            result.xelem (a.ridx (i), j) = std::pow (a.data (i), btmp);
         }
     }
 
   result.maybe_compress (true);
 
   return result;
 }
 
@@ -710,21 +710,21 @@ elem_xpow (const SparseComplexMatrix& a,
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
-  SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
+  SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+      for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
-          result.xelem(a.ridx(i), j) = std::pow (a.data (i), b (a.ridx(i), j));
+          result.xelem (a.ridx (i), j) = std::pow (a.data (i), b(a.ridx (i), j));
         }
     }
   result.maybe_compress (true);
 
   return result;
 }
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -89,17 +89,17 @@ s = sparse (i, j, s, m, n)\n\
 s = sparse (i, j, s, m, n, \"summation\")\n\
 s = sparse (i, j, s, m, n, \"sum\")\n\
 @end group\n\
 @end example\n\
 \n\
 Given the option \"unique\". if more than two values are specified for the\n\
 same @var{i}, @var{j} indices, the last specified value will be used.\n\
 \n\
-@code{sparse(@var{m}, @var{n})} is equivalent to\n\
+@code{sparse (@var{m}, @var{n})} is equivalent to\n\
 @code{sparse ([], [], [], @var{m}, @var{n}, 0)}\n\
 \n\
 If any of @var{sv}, @var{i} or @var{j} are scalars, they are expanded\n\
 to have a common size.\n\
 @seealso{full, accumarray}\n\
 @end deftypefn")
 {
    octave_value retval;
@@ -222,19 +222,19 @@ the simple forms\n\
 @item @code{@var{s}(:,I:J) = @var{x}}\n\
 \n\
 @item @code{@var{s}(K:L,I:J) = @var{x}}\n\
 @end itemize\n\
 \n\
 @b{and} that the following conditions are met:\n\
 \n\
 @itemize\n\
-@item the assignment does not decrease nnz(@var{S}).\n\
+@item the assignment does not decrease nnz (@var{S}).\n\
 \n\
-@item after the assignment, nnz(@var{S}) does not exceed @var{nz}.\n\
+@item after the assignment, nnz (@var{S}) does not exceed @var{nz}.\n\
 \n\
 @item no index is out of bounds.\n\
 @end itemize\n\
 \n\
 Partial movement of data may still occur, but in general the assignment will\n\
 be more memory and time-efficient under these circumstances.  In particular,\n\
 it is possible to efficiently build a pre-allocated sparse matrix from\n\
 contiguous block of columns.\n\
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1196,17 +1196,17 @@ symbol_table::find_function (const std::
 
       if (pos == std::string::npos)
         retval = find (name, args, true, local_funcs);
       else
         {
           std::string fcn_scope = name.substr (0, pos);
           scope_id stored_scope = xcurrent_scope;
           xcurrent_scope = xtop_scope;
-          octave_value parent = find_function (name.substr(0, pos),
+          octave_value parent = find_function (name.substr (0, pos),
                                                octave_value_list (), false);
 
           if (parent.is_defined ())
             {
               octave_function *parent_fcn = parent.function_value ();
 
               if (parent_fcn)
                 {
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -398,19 +398,19 @@ exit status, it will linger until Octave
 %!       done = true;
 %!     endif
 %!   else
 %!     done = true;
 %!   endif
 %! until (done)
 %! fclose (out);
 %! if (isunix ())
-%!   assert(str, {"these\n","strings\n","some\n","are\n"});
+%!   assert (str, {"these\n","strings\n","some\n","are\n"});
 %! else
-%!   assert(str, {"these\r\n","strings\r\n","some\r\n","are\r\n"});
+%!   assert (str, {"these\r\n","strings\r\n","some\r\n","are\r\n"});
 %! endif
 */
 
 DEFUNX ("fcntl", Ffcntl, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})\n\
 Change the properties of the open file @var{fid}.  The following values\n\
 may be passed as @var{request}:\n\
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -250,17 +250,17 @@ same_file_internal (const std::string& f
           && fs_file1.dev () == fs_file2.dev ());
 
 #endif
 }
 
 void
 sysdep_init (void)
 {
-#if defined (__386BSD__) || defined (__FreeBSD__) || defined(__NetBSD__)
+#if defined (__386BSD__) || defined (__FreeBSD__) || defined (__NetBSD__)
   BSD_init ();
 #elif defined (__MINGW32__)
   MINGW_init ();
 #elif defined (_MSC_VER)
   MSVC_init ();
 #endif
 }
 
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -328,17 +328,17 @@ ft_render::visit (text_element_string& e
             gripe_missing_glyph (str[i]);
           else
             {
               switch (mode)
                 {
                 case MODE_RENDER:
                   if (str[i] == '\n')
                     {
-                    glyph_index = FT_Get_Char_Index(face, ' ');
+                    glyph_index = FT_Get_Char_Index (face, ' ');
                     if (!glyph_index || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
                       {
                         gripe_missing_glyph (' ');
                       }
                     else
                       {
                         line_index++;
                         xoffset = multiline_align_xoffsets[line_index];
@@ -392,25 +392,25 @@ ft_render::visit (text_element_string& e
 
                       xoffset += (face->glyph->advance.x >> 6);
                     }
                   break;
 
                 case MODE_BBOX:
                   if (str[i] == '\n')
                     {
-                      glyph_index = FT_Get_Char_Index(face, ' ');
+                      glyph_index = FT_Get_Char_Index (face, ' ');
                       if (! glyph_index
                           || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
                       {
                         gripe_missing_glyph (' ');
                       }
                     else
                       {
-                        multiline_align_xoffsets.push_back(box_line_width);
+                        multiline_align_xoffsets.push_back (box_line_width);
                         // Reset the pixel width for this newline, so we don't
                         // allocate a bounding box larger than the horizontal
                         // width of the multi-line
                         box_line_width = 0;
                         bbox(1) -= (face->size->metrics.height >> 6);
                       }
                     }
                   else
@@ -460,17 +460,17 @@ ft_render::visit (text_element_string& e
                   previous = 0;
                 else
                   previous = glyph_index;
             }
         }
       if (mode == MODE_BBOX)
         {
           /* Push last the width associated with the last line */
-          multiline_align_xoffsets.push_back(box_line_width);
+          multiline_align_xoffsets.push_back (box_line_width);
 
           for (unsigned int i = 0; i < multiline_align_xoffsets.size (); i++)
             {
             /* Center align */
             if (multiline_halign == 1)
               multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i])/2;
             /* Right align */
             else if (multiline_halign == 2)
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1331,17 +1331,17 @@ public:
     param_names(pos_b) = "Bytes";
     param_names(pos_c) = "Class";
     param_names(pos_e) = "Elements";
     param_names(pos_n) = "Name";
     param_names(pos_s) = "Size";
     param_names(pos_t) = "Type";
 
     for (size_t i = 0; i < param_string.length (); i++)
-      param_length(i) = param_names(i) . length ();
+      param_length(i) = param_names(i).length ();
 
     // The attribute column needs size 5.
     param_length(pos_a) = 5;
 
     // Calculating necessary spacing for name column,
     // bytes column, elements column and class column
 
     for (std::list<symbol_info>::const_iterator p = lst.begin ();
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -69,152 +69,152 @@ gzfilebuf::~gzfilebuf ()
   if (own_fd)
     this->close ();
   // Make sure internal buffer is deallocated
   this->disable_buffer ();
 }
 
 // Set compression level and strategy
 int
-gzfilebuf::setcompression(int comp_level,
-                          int comp_strategy)
+gzfilebuf::setcompression (int comp_level,
+                           int comp_strategy)
 {
-  return gzsetparams(file, comp_level, comp_strategy);
+  return gzsetparams (file, comp_level, comp_strategy);
 }
 
 // Open gzipped file
 gzfilebuf*
-gzfilebuf::open(const char *name,
-                std::ios_base::openmode mode)
+gzfilebuf::open (const char *name,
+                 std::ios_base::openmode mode)
 {
   // Fail if file already open
   if (this->is_open ())
     return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
     return 0;
 
   // Build mode string for gzopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
+  if (! this->open_mode (mode, char_mode))
     return 0;
 
   // Attempt to open file
-  if ((file = gzopen(name, char_mode)) == 0)
+  if ((file = gzopen (name, char_mode)) == 0)
     return 0;
 
   // On success, allocate internal buffer and set flags
   this->enable_buffer ();
   io_mode = mode;
   own_fd = true;
   return this;
 }
 
 // Attach to gzipped file
 gzfilebuf*
-gzfilebuf::attach(int fd,
-                  std::ios_base::openmode mode)
+gzfilebuf::attach (int fd,
+                   std::ios_base::openmode mode)
 {
   // Fail if file already open
   if (this->is_open ())
     return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
     return 0;
 
   // Build mode string for gzdopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
+  if (! this->open_mode (mode, char_mode))
     return 0;
 
   // Attempt to attach to file
-  if ((file = gzdopen(fd, char_mode)) == 0)
+  if ((file = gzdopen (fd, char_mode)) == 0)
     return 0;
 
   // On success, allocate internal buffer and set flags
   this->enable_buffer ();
   io_mode = mode;
   own_fd = false;
   return this;
 }
 
 // Close gzipped file
 gzfilebuf*
 gzfilebuf::close ()
 {
   // Fail immediately if no file is open
-  if (!this->is_open ())
+  if (! this->is_open ())
     return 0;
   // Assume success
   gzfilebuf* retval = this;
   // Attempt to sync and close gzipped file
   if (this->sync () == -1)
     retval = 0;
-  if (gzclose(file) < 0)
+  if (gzclose (file) < 0)
     retval = 0;
   // File is now gone anyway (postcondition [27.8.1.3.8])
   file = 0;
   own_fd = false;
   // Destroy internal buffer if it exists
   this->disable_buffer ();
   return retval;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Convert int open mode to mode string
 bool
-gzfilebuf::open_mode(std::ios_base::openmode mode,
-                     char* c_mode) const
+gzfilebuf::open_mode (std::ios_base::openmode mode,
+                      char* c_mode) const
 {
   // FIXME -- do we need testb?
   // bool testb = mode & std::ios_base::binary;
   bool testi = mode & std::ios_base::in;
   bool testo = mode & std::ios_base::out;
   bool testt = mode & std::ios_base::trunc;
   bool testa = mode & std::ios_base::app;
 
   // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)
   // Original zfstream hardcoded the compression level to maximum here...
   // Double the time for less than 1% size improvement seems
   // excessive though - keeping it at the default level
   // To change back, just append "9" to the next three mode strings
   if (!testi && testo && !testt && !testa)
-    strcpy(c_mode, "w");
+    strcpy (c_mode, "w");
   if (!testi && testo && !testt && testa)
-    strcpy(c_mode, "a");
+    strcpy (c_mode, "a");
   if (!testi && testo && testt && !testa)
-    strcpy(c_mode, "w");
+    strcpy (c_mode, "w");
   if (testi && !testo && !testt && !testa)
-    strcpy(c_mode, "r");
+    strcpy (c_mode, "r");
   // No read/write mode yet
 //  if (testi && testo && !testt && !testa)
 //    strcpy(c_mode, "r+");
 //  if (testi && testo && testt && !testa)
 //    strcpy(c_mode, "w+");
 
   // Mode string should be empty for invalid combination of flags
-  if (strlen(c_mode) == 0)
+  if (strlen (c_mode) == 0)
     return false;
 
-  strcat(c_mode, "b");
+  strcat (c_mode, "b");
 
   return true;
 }
 
 // Determine number of characters in internal get buffer
 std::streamsize
 gzfilebuf::showmanyc ()
 {
   // Calls to underflow will fail if file not opened for reading
-  if (!this->is_open () || !(io_mode & std::ios_base::in))
+  if (! this->is_open () || !(io_mode & std::ios_base::in))
     return -1;
   // Make sure get area is in use
   if (this->gptr () && (this->gptr () < this->egptr ()))
-    return std::streamsize(this->egptr () - this->gptr ());
+    return std::streamsize (this->egptr () - this->gptr ());
   else
     return 0;
 }
 
 // Puts back a character to the stream in two cases. Firstly, when there
 // is no putback position available, and secondly when the character putback
 // differs from the one in the file. We can only support the first case
 // with gzipped files.
@@ -226,31 +226,31 @@ gzfilebuf::pbackfail (gzfilebuf::int_typ
       if (gzseek (file, this->gptr () - this->egptr () - 1, SEEK_CUR) < 0)
         return traits_type::eof ();
 
       // Invalidates contents of the buffer
       enable_buffer ();
 
       // Attempt to fill internal buffer from gzipped file
       // (buffer must be guaranteed to exist...)
-      int bytes_read = gzread(file, buffer, buffer_size);
+      int bytes_read = gzread (file, buffer, buffer_size);
       // Indicates error or EOF
       if (bytes_read <= 0)
         {
           // Reset get area
-          this->setg(buffer, buffer, buffer);
+          this->setg (buffer, buffer, buffer);
           return traits_type::eof ();
         }
 
       // Make all bytes read from file available as get area
-      this->setg(buffer, buffer, buffer + bytes_read);
+      this->setg (buffer, buffer, buffer + bytes_read);
 
       // If next character in get area differs from putback character
       // flag a failure
-      gzfilebuf::int_type ret = traits_type::to_int_type(*(this->gptr ()));
+      gzfilebuf::int_type ret = traits_type::to_int_type (*(this->gptr ()));
       if (ret != c)
         return traits_type::eof ();
       else
         return ret;
     }
   else
     return traits_type::eof ();
 }
@@ -258,107 +258,107 @@ gzfilebuf::pbackfail (gzfilebuf::int_typ
 // Fill get area from gzipped file
 gzfilebuf::int_type
 gzfilebuf::underflow ()
 {
   // If something is left in the get area by chance, return it
   // (this shouldn't normally happen, as underflow is only supposed
   // to be called when gptr >= egptr, but it serves as error check)
   if (this->gptr () && (this->gptr () < this->egptr ()))
-    return traits_type::to_int_type(*(this->gptr ()));
+    return traits_type::to_int_type (*(this->gptr ()));
 
   // If the file hasn't been opened for reading, produce error
-  if (!this->is_open () || !(io_mode & std::ios_base::in))
+  if (! this->is_open () || !(io_mode & std::ios_base::in))
     return traits_type::eof ();
 
   // Copy the final characters to the front of the buffer
   int stash = 0;
   if (this->eback () && buffer && buffer_size > STASHED_CHARACTERS)
     {
       char_type *ptr1 = buffer;
       char_type *ptr2 = this->egptr () - STASHED_CHARACTERS + 1;
       if (ptr2 > this->eback ())
         while (stash++ <= STASHED_CHARACTERS)
           *ptr1++ = *ptr2++;
     }
 
   // Attempt to fill internal buffer from gzipped file
   // (buffer must be guaranteed to exist...)
-  int bytes_read = gzread(file, buffer + stash, buffer_size - stash);
+  int bytes_read = gzread (file, buffer + stash, buffer_size - stash);
 
   // Indicates error or EOF
   if (bytes_read <= 0)
   {
     // Reset get area
-    this->setg(buffer, buffer, buffer);
+    this->setg (buffer, buffer, buffer);
     return traits_type::eof ();
   }
   // Make all bytes read from file plus the stash available as get area
-  this->setg(buffer, buffer + stash, buffer + bytes_read + stash);
+  this->setg (buffer, buffer + stash, buffer + bytes_read + stash);
 
   // Return next character in get area
-  return traits_type::to_int_type(*(this->gptr ()));
+  return traits_type::to_int_type (*(this->gptr ()));
 }
 
 // Write put area to gzipped file
 gzfilebuf::int_type
-gzfilebuf::overflow(int_type c)
+gzfilebuf::overflow (int_type c)
 {
   // Determine whether put area is in use
   if (this->pbase ())
   {
     // Double-check pointer range
     if (this->pptr () > this->epptr () || this->pptr () < this->pbase ())
       return traits_type::eof ();
     // Add extra character to buffer if not EOF
-    if (!traits_type::eq_int_type(c, traits_type::eof ()))
+    if (! traits_type::eq_int_type (c, traits_type::eof ()))
     {
-      *(this->pptr()) = traits_type::to_char_type(c);
-      this->pbump(1);
+      *(this->pptr ()) = traits_type::to_char_type (c);
+      this->pbump (1);
     }
     // Number of characters to write to file
     int bytes_to_write = this->pptr () - this->pbase ();
     // Overflow doesn't fail if nothing is to be written
     if (bytes_to_write > 0)
     {
       // If the file hasn't been opened for writing, produce error
-      if (!this->is_open () || !(io_mode & std::ios_base::out))
+      if (! this->is_open () || !(io_mode & std::ios_base::out))
         return traits_type::eof ();
       // If gzipped file won't accept all bytes written to it, fail
-      if (gzwrite(file, this->pbase (), bytes_to_write) != bytes_to_write)
+      if (gzwrite (file, this->pbase (), bytes_to_write) != bytes_to_write)
         return traits_type::eof ();
       // Reset next pointer to point to pbase on success
-      this->pbump(-bytes_to_write);
+      this->pbump (-bytes_to_write);
     }
   }
   // Write extra character to file if not EOF
-  else if (!traits_type::eq_int_type(c, traits_type::eof ()))
+  else if (! traits_type::eq_int_type (c, traits_type::eof ()))
   {
     // If the file hasn't been opened for writing, produce error
-    if (!this->is_open () || !(io_mode & std::ios_base::out))
+    if (! this->is_open () || !(io_mode & std::ios_base::out))
       return traits_type::eof ();
     // Impromptu char buffer (allows "unbuffered" output)
-    char_type last_char = traits_type::to_char_type(c);
+    char_type last_char = traits_type::to_char_type (c);
     // If gzipped file won't accept this character, fail
-    if (gzwrite(file, &last_char, 1) != 1)
+    if (gzwrite (file, &last_char, 1) != 1)
       return traits_type::eof ();
   }
 
   // If you got here, you have succeeded (even if c was EOF)
   // The return value should therefore be non-EOF
-  if (traits_type::eq_int_type(c, traits_type::eof ()))
-    return traits_type::not_eof(c);
+  if (traits_type::eq_int_type (c, traits_type::eof ()))
+    return traits_type::not_eof (c);
   else
     return c;
 }
 
 // Assign new buffer
 std::streambuf*
-gzfilebuf::setbuf(char_type* p,
-                  std::streamsize n)
+gzfilebuf::setbuf (char_type* p,
+                   std::streamsize n)
 {
   // First make sure stuff is sync'ed, for safety
   if (this->sync () == -1)
     return 0;
   // If buffering is turned off on purpose via setbuf(0,0), still allocate one...
   // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
   // least a buffer of size 1 (very inefficient though, therefore make it bigger?)
   // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)
@@ -382,17 +382,17 @@ gzfilebuf::setbuf(char_type* p,
   }
   return this;
 }
 
 // Write put area to gzipped file (i.e. ensures that put area is empty)
 int
 gzfilebuf::sync ()
 {
-  return traits_type::eq_int_type(this->overflow (), traits_type::eof ()) ? -1 : 0;
+  return traits_type::eq_int_type (this->overflow (), traits_type::eof ()) ? -1 : 0;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Allocate internal buffer
 void
 gzfilebuf::enable_buffer ()
 {
@@ -400,73 +400,73 @@ gzfilebuf::enable_buffer ()
   if (own_buffer && !buffer)
   {
     // Check for buffered vs. "unbuffered"
     if (buffer_size > 0)
     {
       // Allocate internal buffer
       buffer = new char_type[buffer_size];
       // Get area starts empty and will be expanded by underflow as need arises
-      this->setg(buffer, buffer, buffer);
+      this->setg (buffer, buffer, buffer);
       // Setup entire internal buffer as put area.
       // The one-past-end pointer actually points to the last element of the buffer,
       // so that overflow(c) can safely add the extra character c to the sequence.
       // These pointers remain in place for the duration of the buffer
-      this->setp(buffer, buffer + buffer_size - 1);
+      this->setp (buffer, buffer + buffer_size - 1);
     }
     else
     {
       // Even in "unbuffered" case, (small?) get buffer is still required
       buffer_size = SMALLBUFSIZE;
       buffer = new char_type[buffer_size];
-      this->setg(buffer, buffer, buffer);
+      this->setg (buffer, buffer, buffer);
       // "Unbuffered" means no put buffer
-      this->setp(0, 0);
+      this->setp (0, 0);
     }
   }
   else
   {
     // If buffer already allocated, reset buffer pointers just to make sure no
     // stale chars are lying around
-    this->setg(buffer, buffer, buffer);
-    this->setp(buffer, buffer + buffer_size - 1);
+    this->setg (buffer, buffer, buffer);
+    this->setp (buffer, buffer + buffer_size - 1);
   }
 }
 
 // Destroy internal buffer
 void
 gzfilebuf::disable_buffer ()
 {
   // If internal buffer exists, deallocate it
   if (own_buffer && buffer)
   {
     // Preserve unbuffered status by zeroing size
-    if (!this->pbase ())
+    if (! this->pbase ())
       buffer_size = 0;
     delete[] buffer;
     buffer = 0;
-    this->setg(0, 0, 0);
-    this->setp(0, 0);
+    this->setg (0, 0, 0);
+    this->setp (0, 0);
   }
   else
   {
     // Reset buffer pointers to initial state if external buffer exists
-    this->setg(buffer, buffer, buffer);
+    this->setg (buffer, buffer, buffer);
     if (buffer)
-      this->setp(buffer, buffer + buffer_size - 1);
+      this->setp (buffer, buffer + buffer_size - 1);
     else
-      this->setp(0, 0);
+      this->setp (0, 0);
   }
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Seek functions
 gzfilebuf::pos_type
-gzfilebuf::seekoff(off_type off, std::ios_base::seekdir way,
+gzfilebuf::seekoff (off_type off, std::ios_base::seekdir way,
                    std::ios_base::openmode)
 {
   pos_type ret = pos_type (off_type (-1));
 
   if (this->is_open ())
     {
       off_type computed_off = off;
 
@@ -488,17 +488,17 @@ gzfilebuf::seekoff(off_type off, std::io
         // flush contents of buffer to file
         overflow ();
     }
 
   return ret;
 }
 
 gzfilebuf::pos_type
-gzfilebuf::seekpos(pos_type sp, std::ios_base::openmode)
+gzfilebuf::seekpos (pos_type sp, std::ios_base::openmode)
 {
   pos_type ret = pos_type (off_type (-1));
 
   if (this->is_open ())
     {
       ret = pos_type (gzseek (file, sp, SEEK_SET));
 
       if (io_mode & std::ios_base::in)
@@ -511,115 +511,115 @@ gzfilebuf::seekpos(pos_type sp, std::ios
 
   return ret;
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
 gzifstream::gzifstream ()
-: std::istream(0), sb ()
-{ this->init(&sb); }
+: std::istream (0), sb ()
+{ this->init (&sb); }
 
 // Initialize stream buffer and open file
-gzifstream::gzifstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::istream(0), sb ()
+gzifstream::gzifstream (const char* name,
+                        std::ios_base::openmode mode)
+: std::istream (0), sb ()
 {
-  this->init(&sb);
-  this->open(name, mode);
+  this->init (&sb);
+  this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
-gzifstream::gzifstream(int fd,
-                       std::ios_base::openmode mode)
-: std::istream(0), sb ()
+gzifstream::gzifstream (int fd,
+                        std::ios_base::openmode mode)
+: std::istream (0), sb ()
 {
-  this->init(&sb);
-  this->attach(fd, mode);
+  this->init (&sb);
+  this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
-gzifstream::open(const char* name,
-                 std::ios_base::openmode mode)
+gzifstream::open (const char* name,
+                  std::ios_base::openmode mode)
 {
-  if (!sb.open(name, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
+  if (! sb.open (name, mode | std::ios_base::in))
+    this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
 void
-gzifstream::attach(int fd,
-                   std::ios_base::openmode mode)
+gzifstream::attach (int fd,
+                    std::ios_base::openmode mode)
 {
-  if (!sb.attach(fd, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
+  if (! sb.attach (fd, mode | std::ios_base::in))
+    this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Close file
 void
 gzifstream::close ()
 {
-  if (!sb.close ())
-    this->setstate(std::ios_base::failbit);
+  if (! sb.close ())
+    this->setstate (std::ios_base::failbit);
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
 gzofstream::gzofstream ()
-: std::ostream(0), sb ()
-{ this->init(&sb); }
+: std::ostream (0), sb ()
+{ this->init (&sb); }
 
 // Initialize stream buffer and open file
-gzofstream::gzofstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::ostream(0), sb ()
+gzofstream::gzofstream (const char* name,
+                        std::ios_base::openmode mode)
+: std::ostream (0), sb ()
 {
-  this->init(&sb);
-  this->open(name, mode);
+  this->init (&sb);
+  this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
-gzofstream::gzofstream(int fd,
-                       std::ios_base::openmode mode)
-: std::ostream(0), sb ()
+gzofstream::gzofstream (int fd,
+                        std::ios_base::openmode mode)
+: std::ostream (0), sb ()
 {
-  this->init(&sb);
-  this->attach(fd, mode);
+  this->init (&sb);
+  this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
-gzofstream::open(const char* name,
-                 std::ios_base::openmode mode)
+gzofstream::open (const char* name,
+                  std::ios_base::openmode mode)
 {
-  if (!sb.open(name, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
+  if (! sb.open (name, mode | std::ios_base::out))
+    this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
 void
-gzofstream::attach(int fd,
-                   std::ios_base::openmode mode)
+gzofstream::attach (int fd,
+                    std::ios_base::openmode mode)
 {
-  if (!sb.attach(fd, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
+  if (! sb.attach (fd, mode | std::ios_base::out))
+    this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Close file
 void
 gzofstream::close ()
 {
-  if (!sb.close ())
-    this->setstate(std::ios_base::failbit);
+  if (! sb.close ())
+    this->setstate (std::ios_base::failbit);
 }
 
 #endif // HAVE_ZLIB
diff --git a/src/zfstream.h b/src/zfstream.h
--- a/src/zfstream.h
+++ b/src/zfstream.h
@@ -66,61 +66,61 @@ public:
    *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.
    *
    *  Unfortunately, these parameters cannot be modified separately, as the
    *  previous zfstream version assumed. Since the strategy is seldom changed,
    *  it can default and setcompression(level) then becomes like the old
    *  setcompressionlevel(level).
   */
   int
-  setcompression(int comp_level,
-                 int comp_strategy = Z_DEFAULT_STRATEGY);
+  setcompression (int comp_level,
+                  int comp_strategy = Z_DEFAULT_STRATEGY);
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
   is_open () const { return (file != 0); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  File name.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
-  open(const char* name,
-       std::ios_base::openmode mode);
+  open (const char* name,
+        std::ios_base::openmode mode);
 
   /**
    *  @brief  Attach to already open gzipped file.
    *  @param  fd  File descriptor.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
-  attach(int fd,
-         std::ios_base::openmode mode);
+  attach (int fd,
+          std::ios_base::openmode mode);
 
   /**
    *  @brief  Close gzipped file.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
   close ();
 
 protected:
   /**
    *  @brief  Convert ios open mode int to mode string used by zlib.
    *  @return  True if valid mode flag combination.
   */
   bool
-  open_mode(std::ios_base::openmode mode,
-            char* c_mode) const;
+  open_mode (std::ios_base::openmode mode,
+             char* c_mode) const;
 
   /**
    *  @brief  Number of characters available in stream buffer.
    *  @return  Number of characters.
    *
    *  This indicates number of characters in get area of stream buffer.
    *  These characters can be read without accessing the gzipped file.
   */
@@ -142,57 +142,57 @@ protected:
    *  @param  c  Extra character to add to buffer contents.
    *  @return  Non-EOF on success, EOF on error.
    *
    *  This actually writes characters in stream buffer to
    *  gzipped file. With unbuffered output this is done one
    *  character at a time.
   */
   virtual int_type
-  overflow(int_type c = traits_type::eof ());
+  overflow (int_type c = traits_type::eof ());
 
   /**
    *  @brief  Installs external stream buffer.
    *  @param  p  Pointer to char buffer.
    *  @param  n  Size of external buffer.
    *  @return  @c this on success, NULL on failure.
    *
    *  Call setbuf(0,0) to enable unbuffered output.
   */
   virtual std::streambuf*
-  setbuf(char_type* p,
-         std::streamsize n);
+  setbuf (char_type* p,
+          std::streamsize n);
 
   /**
    *  @brief  Flush stream buffer to file.
    *  @return  0 on success, -1 on error.
    *
    *  This calls underflow(EOF) to do the job.
   */
   virtual int
   sync ();
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
-  seekoff(off_type off, std::ios_base::seekdir way,
-          std::ios_base::openmode mode =
-          std::ios_base::in|std::ios_base::out);
+  seekoff (off_type off, std::ios_base::seekdir way,
+           std::ios_base::openmode mode =
+           std::ios_base::in|std::ios_base::out);
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
-  seekpos(pos_type sp, std::ios_base::openmode mode =
-          std::ios_base::in|std::ios_base::out);
+  seekpos (pos_type sp, std::ios_base::openmode mode =
+           std::ios_base::in|std::ios_base::out);
 
   virtual int_type
   pbackfail (int_type c = traits_type::eof ());
 
 //
 // Some future enhancements
 //
 //  virtual int_type uflow();
@@ -285,27 +285,27 @@ public:
   gzifstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::in).
   */
   explicit
-  gzifstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::in);
+  gzifstream (const char* name,
+              std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Construct stream on already open gzipped file.
    *  @param  fd    File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::in).
   */
   explicit
-  gzifstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::in);
+  gzifstream (int fd,
+              std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  Obtain underlying stream buffer.
   */
   gzfilebuf*
   rdbuf () const
   { return const_cast<gzfilebuf*>(&sb); }
 
@@ -324,30 +324,30 @@ public:
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail(). This differs from the behavior of
    *  ifstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
    *  you manually clear() the state. The choice is a matter of
    *  convenience.
   */
   void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::in);
+  open (const char* name,
+        std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Attach to already open gzipped file.
    *  @param  fd  File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::in).
    *
    *  Stream will be in state good() if attach succeeded; otherwise
    *  in state fail().
   */
   void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::in);
+  attach (int fd,
+          std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Close gzipped file.
    *
    *  Stream will be in state fail() if close failed.
   */
   void
   close ();
@@ -374,27 +374,27 @@ public:
   gzofstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::out).
   */
   explicit
-  gzofstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::out);
+  gzofstream (const char* name,
+              std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Construct stream on already open gzipped file.
    *  @param  fd    File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::out).
   */
   explicit
-  gzofstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::out);
+  gzofstream (int fd,
+              std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  Obtain underlying stream buffer.
   */
   gzfilebuf*
   rdbuf () const
   { return const_cast<gzfilebuf*>(&sb); }
 
@@ -413,30 +413,30 @@ public:
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail(). This differs from the behavior of
    *  ofstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
    *  you manually clear() the state. The choice is a matter of
    *  convenience.
   */
   void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::out);
+  open (const char* name,
+        std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Attach to already open gzipped file.
    *  @param  fd  File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::out).
    *
    *  Stream will be in state good() if attach succeeded; otherwise
    *  in state fail().
   */
   void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::out);
+  attach (int fd,
+          std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Close gzipped file.
    *
    *  Stream will be in state fail() if close failed.
   */
   void
   close ();
@@ -462,54 +462,54 @@ template<typename T1, typename T2>
   public:
     // Allows insertor to peek at internals
     template <typename Ta, typename Tb>
       friend gzofstream&
       operator<<(gzofstream&,
                  const gzomanip2<Ta,Tb>&);
 
     // Constructor
-    gzomanip2(gzofstream& (*f)(gzofstream&, T1, T2),
-              T1 v1,
-              T2 v2);
+    gzomanip2 (gzofstream& (*f)(gzofstream&, T1, T2),
+               T1 v1,
+               T2 v2);
   private:
     // Underlying manipulator function
     gzofstream&
     (*func)(gzofstream&, T1, T2);
 
     // Arguments for manipulator function
     T1 val1;
     T2 val2;
   };
 
 /*****************************************************************************/
 
 // Manipulator function thunks through to stream buffer
 inline gzofstream&
-setcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
+setcompression (gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
 {
-  (gzs.rdbuf ())->setcompression(l, s);
+  (gzs.rdbuf ())->setcompression (l, s);
   return gzs;
 }
 
 // Manipulator constructor stores arguments
 template<typename T1, typename T2>
   inline
-  gzomanip2<T1,T2>::gzomanip2(gzofstream &(*f)(gzofstream &, T1, T2),
-                              T1 v1,
-                              T2 v2)
+  gzomanip2<T1,T2>::gzomanip2 (gzofstream &(*f)(gzofstream &, T1, T2),
+                               T1 v1,
+                               T2 v2)
   : func(f), val1(v1), val2(v2)
   { }
 
 // Insertor applies underlying manipulator function to stream
 template<typename T1, typename T2>
   inline gzofstream&
   operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)
   { return (*m.func)(s, m.val1, m.val2); }
 
 // Insert this onto stream to simplify setting of compression level
 inline gzomanip2<int,int>
-setcompression(int l, int s = Z_DEFAULT_STRATEGY)
+setcompression (int l, int s = Z_DEFAULT_STRATEGY)
 { return gzomanip2<int,int>(&setcompression, l, s); }
 
 #endif // HAVE_ZLIB
 
 #endif // ZFSTREAM_H
