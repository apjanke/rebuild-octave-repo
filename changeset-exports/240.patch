# HG changeset patch
# User jwe
# Date 754691076 0
#      Tue Nov 30 20:24:36 1993 +0000
# Node ID a99f28f5e351451994aef3f9bd73f43e9619954b
# Parent  4f8134fa54a9d4b8eb05feee3a993cb57fa2f6c9
[project @ 1993-11-30 20:24:36 by jwe]

diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <iostream.h>
 #include <stdlib.h>
 
 #include "Matrix.h"
 #include "Range.h"
 #include "idx-vector.h"
@@ -81,17 +81,17 @@ idx_vector::idx_vector (const Matrix& m,
       num_zeros = 0;
       num_ones = 0;
       one_zero = 0;
       initialized = 1;
       return;
     }
   else if (nr > 1 && nc > 1 && do_ftn_idx)
     {
-      double *cop_out = m.fortran_vec ();
+      const double *cop_out = m.data ();
       len = nr * nc;
       data = new int [len];
       for (int i = 0; i < len; i++)
 	data[i] = tree_to_mat_idx (*cop_out++);
     }
   else if (nr == 1 && nc > 0)
     {
       len = nc;
@@ -103,32 +103,32 @@ idx_vector::idx_vector (const Matrix& m,
     {
       len = nr;
       data = new int [len];
       for (int i = 0; i < len; i++)
 	data[i] = tree_to_mat_idx (m.elem (i, 0));
     }
   else
     {
-      error ("invalid matrix used as index");
+      ::error ("invalid matrix used as index");
       return;
     }
 
   init_state (rc, z_len);
 }
 
 idx_vector::idx_vector (const Range& r)
 {
   initialized = 0;
 
   len = r.nelem ();
 
   if (len < 0)
     {
-      error ("invalid range used as index");
+      ::error ("invalid range used as index");
       return;
     }
   else if (len == 0)
     {
       data = (int *) 0;
       num_zeros = 0;
       num_ones = 0;
       one_zero = 0;
@@ -212,17 +212,17 @@ idx_vector::init_state (const char *rc, 
 	  num_ones = 0;
 	  one_zero = 0;
 	}
       else if (num_ones != len || user_pref.prefer_zero_one_indexing)
 	convert_one_zero_to_idx ();
     }
   else if (min_val < 0)
     {
-      error ("%s index %d out of range", rc, min_val+1);
+      ::error ("%s index %d out of range", rc, min_val+1);
       initialized = 0;
       return;
     }
 
   initialized = 1;
 }
 
 void
@@ -270,17 +270,17 @@ intcmp (int *i, int *j)
   return (*i - *j);
 }
 
 int
 idx_vector::checkelem (int n) const
 {
   if (n < 0 || n >= len)
     {
-      error ("idx-vector: index out of range");
+      ::error ("idx-vector: index out of range");
       return 0;
     }
 
   return elem (n);
 }
 
 void
 idx_vector::sort (void)
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_idx_vector_h)
 #define _idx_vector_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class ostream;
 class Matrix;
 class Range;
 
 class idx_vector
 {
 public:
   idx_vector (void);
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -8,20 +8,16 @@
 
 TOPDIR = ..
 
 include $(TOPDIR)/Makeconf
 
 srcdir = @srcdir@
 VPATH = @srcdir@:@srcdir@/../bsd-math
 
-# Can this be fixed?
-
-INCFLAGS = -I. -I$(srcdir)/../liboctave -I$(srcdir)/.. -I$(srcdir) -I$(TOPDIR)/liboctave -I$(TOPDIR)
-
 LIBOBJS = @LIBOBJS@
 
 # Cancel default rule for .c from .y and make .cc from .y instead.
 
 %.c : %.y
 
 %.cc : %.y
 	$(YACC) $(YFLAGS) $<
@@ -82,17 +78,17 @@ SOURCES = arith-ops.cc builtins.cc dynam
 	f-npsol.cc f-qpsol.cc f-qr.cc f-quad.cc f-qzval.cc f-rand.cc \
 	f-schur.cc f-svd.cc f-syl.cc file-io.cc	g-builtins.cc \
 	getopt.c getopt1.c gripes.cc help.cc idx-vector.cc input.cc \
 	lex.l mappers.cc octave.cc octave-hist.cc pager.cc parse.y \
 	pr-output.cc procstream.cc sighandlers.cc symtab.cc \
 	sysdep.cc t-builtins.cc tc-assign.cc tc-extras.cc \
 	tc-index.cc tc-inlines.cc token.cc tree.cc tree-const.cc \
 	tree-plot.cc unwind-prot.cc user-prefs.cc utils.cc \
-	variables.cc xdiv.cc xpow.cc
+	variables.cc xdiv.cc xpow.cc SLStack.cc
 
 DEP_SOURCES_2 = $(patsubst %.l, %.cc, $(SOURCES))
 DEP_SOURCES_1 = $(patsubst %.y, %.cc, $(DEP_SOURCES_2))
 DEP_SOURCES = $(patsubst %.c, %.d, $(DEP_SOURCES_1))
 MAKEDEPS = $(patsubst %.cc, %.d, $(DEP_SOURCES))
 
 DLD_OBJECTS = f-balance.o f-chol.o f-colloc.o f-dassl.o f-det.o \
 	f-eig.o f-expm.o f-fft.o f-fsolve.o f-fsqp.o f-givens.o \
@@ -101,17 +97,17 @@ DLD_OBJECTS = f-balance.o f-chol.o f-col
 	f-schur.o f-svd.o f-syl.o 
 
 OBJECTS = arith-ops.o builtins.o error.o file-io.o g-builtins.o \
 	getopt.o getopt1.o gripes.o help.o idx-vector.o input.o \
 	lex.o mappers.o octave.o octave-hist.o pager.o parse.o \
 	pr-output.o procstream.o sighandlers.o symtab.o sysdep.o \
 	t-builtins.o tc-assign.o tc-extras.o tc-index.o token.o \
 	tree.o tree-const.o tree-plot.o unwind-prot.o user-prefs.o \
-	utils.o variables.o xdiv.o xpow.o \
+	utils.o variables.o xdiv.o xpow.o SLStack.o \
 	@DYNAMIC_LD_OBJ@
 
 OCTAVE_LIBS = ../liboctave.a ../libcruft.a ../libinfo.a \
 	../libreadline.a @LIBDLD@
 
 DISTFILES = Makefile.in move-if-change parse.cc lex.cc y.tab.h \
 	$(INCLUDES) $(SOURCES)
 
diff --git a/src/SLStack.h b/src/SLStack.h
--- a/src/SLStack.h
+++ b/src/SLStack.h
@@ -11,22 +11,22 @@ option) any later version.  This library
 that it will be useful, but WITHOUT ANY WARRANTY; without even the
 implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 PURPOSE.  See the GNU Library General Public License for more details.
 You should have received a copy of the GNU Library General Public
 License along with this library; if not, write to the Free Software
 Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#if !defined (_SLStack_h)
+#define _SLStack_h 1
 
-#ifndef _SLStack_h
-#ifdef __GNUG__
-//#pragma interface
+#if defined (__GNUG__) && defined (USE_EXTERNAL_TEMPLATES)
+#pragma interface
 #endif
-#define _SLStack_h 1
 
 #include "SLList.h"
 #include "Stack.h"
 
 template <class T>
 class SLStack : public Stack<T>
 {
  private:
@@ -48,88 +48,20 @@ class SLStack : public Stack<T>
   int full (void);
   int length (void);
 
   void clear (void);
 
   int OK (void);
 };
 
-template <class T>
-inline SLStack<T>::SLStack (void) : p () { }
-
-template <class T>
-inline SLStack<T>::SLStack (const SLStack<T>& a) : p (a.p) { }
-
-template <class T>
-inline SLStack<T>::~SLStack (void) { }
-
-template <class T>
-inline void
-SLStack<T>::push (const T& item)
-{
-  p.prepend (item);
-}
-
-template <class T>
-inline T
-SLStack<T>::pop (void)
-{
-  return p.remove_front ();
-}
-
-template <class T>
-inline T&
-SLStack<T>::top (void)
-{
-  return p.front ();
-}
-
-template <class T>
-inline void
-SLStack<T>::del_top (void)
-{
-  p.del_front ();
-}
-
-template <class T>
-inline void
-SLStack<T>::operator = (const SLStack<T>& s)
-{
-  p = s.p;
-}
-
-template <class T>
-inline int
-SLStack<T>::empty (void)
-{
-  return p.empty ();
-}
-
-template <class T>
-inline int
-SLStack<T>::full (void)
-{
-  return 0;
-}
-
-template <class T>
-inline int
-SLStack<T>::length (void)
-{
-  return p.length ();
-}
-
-template <class T>
-inline int
-SLStack<T>::OK (void)
-{
-  return p.OK ();
-}
-
-template <class T>
-inline void
-SLStack<T>::clear (void)
-{
-  p.clear ();
-}
+#if defined (__GNUG__) && ! defined (USE_EXTERNAL_TEMPLATES)
+#include "SLStack.cc"
+#endif
 
 #endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; page-delimiter: "^/\\*" ***
+;;; End: ***
+*/
diff --git a/src/Stack.h b/src/Stack.h
--- a/src/Stack.h
+++ b/src/Stack.h
@@ -13,20 +13,21 @@ implied warranty of MERCHANTABILITY or F
 PURPOSE.  See the GNU Library General Public License for more details.
 You should have received a copy of the GNU Library General Public
 License along with this library; if not, write to the Free Software
 Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 
 #ifndef _Stack_h
-#ifdef __GNUG__
-//#pragma interface
+#define _Stack_h 1
+
+#if defined (__GNUG__) && defined (USE_EXTERNAL_TEMPLATES)
+// #pragma interface
 #endif
-#define _Stack_h 1
 
 template <class T>
 class Stack
 {
  public:
   Stack (void) { }
   virtual ~Stack (void) { }
 
diff --git a/src/arith-ops.cc b/src/arith-ops.cc
--- a/src/arith-ops.cc
+++ b/src/arith-ops.cc
@@ -17,18 +17,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <ctype.h>
 #include <setjmp.h>
 #include <math.h>
 #include <Complex.h>
 
 #include "error.h"
@@ -1324,29 +1324,29 @@ do_binary_op (const Matrix& a, const Mat
 	result = a + b;
       break;
     case tree::subtract:
       if (m_add_conform (a, b, 1))
 	result = a - b;
       break;
     case tree::el_mul:
       if (m_add_conform (a, b, 1))
-	result = a.product (b);
+	result = product (a, b);
       break;
     case tree::multiply:
       if (m_mul_conform (a, b, 1))
 	result = a * b;
       break;
     case tree::el_div:
       if (m_add_conform (a, b, 1))
-	result = a.quotient (b);
+	result = quotient (a, b);
       break;
     case tree::el_leftdiv:
       if (m_add_conform (a, b, 1))
-	result = b.quotient (a);
+	result = quotient (b, a);
       break;
     case tree::leftdiv:
       return xleftdiv (a, b);
       break;
     case tree::divide:
       return xdiv (a, b);
       break;
     case tree::power:
@@ -1509,32 +1509,32 @@ do_binary_op (const Matrix& a, const Com
     case tree::subtract:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a - b;
       break;
     case tree::el_mul:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
-	complex_result = a.product (b);
+	complex_result = product (a, b);
       break;
     case tree::multiply:
       result_type = RT_complex;
       if (m_mul_conform (a, b, 1))
 	complex_result = a * b;
       break;
     case tree::el_div:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
-	complex_result = a.quotient (b);
+	complex_result = quotient (a, b);
       break;
     case tree::el_leftdiv:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
-	complex_result = b.quotient (a);
+	complex_result = quotient (b, a);
       break;
     case tree::leftdiv:
       return xleftdiv (a, b);
       break;
     case tree::divide:
       return xdiv (a, b);
       break;
     case tree::power:
@@ -2077,32 +2077,32 @@ do_binary_op (const ComplexMatrix& a, co
     case tree::subtract:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a - b;
       break;
     case tree::el_mul:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
-	complex_result = a.product (b);
+	complex_result = product (a, b);
       break;
     case tree::multiply:
       result_type = RT_complex;
       if (m_mul_conform (a, b, 1))
 	complex_result = a * b;
       break;
     case tree::el_div:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
-	complex_result = a.quotient (b);
+	complex_result = quotient (a, b);
       break;
     case tree::el_leftdiv:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
-	complex_result = a.quotient (b);
+	complex_result = quotient (a, b);
       break;
     case tree::leftdiv:
       return xleftdiv (a, b);
       break;
     case tree::divide:
       return xdiv (a, b);
       break;
     case tree::power:
@@ -2280,32 +2280,32 @@ do_binary_op (const ComplexMatrix& a, co
     case tree::subtract:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
 	complex_result = a - b;
       break;
     case tree::el_mul:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
-	complex_result = a.product (b);
+	complex_result = product (a, b);
       break;
     case tree::multiply:
       result_type = RT_complex;
       if (m_mul_conform (a, b, 1))
 	complex_result = a * b;
       break;
     case tree::el_div:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
-	complex_result = a.quotient (b);
+	complex_result = quotient (a, b);
       break;
     case tree::el_leftdiv:
       result_type = RT_complex;
       if (m_add_conform (a, b, 1))
-	complex_result = b.quotient (a);
+	complex_result = quotient (b, a);
       break;
     case tree::leftdiv:
       return xleftdiv (a, b);
       break;
     case tree::divide:
       return xdiv (a, b);
       break;
     case tree::power:
diff --git a/src/arith-ops.h b/src/arith-ops.h
--- a/src/arith-ops.h
+++ b/src/arith-ops.h
@@ -20,20 +20,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_arith_ops_h)
 #define _arith_ops_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include "tree-base.h"
 
 class Complex;
 class Matrix;
 class ComplexMatrix;
 class tree_constant;
 
 extern tree_constant do_unary_op (double d, tree::expression_type t);
diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -18,18 +18,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 // Written by A. S. Hodel <scotte@eng.auburn.edu>
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
@@ -213,17 +213,17 @@ balance (const tree_constant *args, int 
 	    for (int i = 0; i < a_nr; i++)
 	      for (int j = 0; j < a_nr; j++)
 		{
 		  aa.elem (i, j) = abs (caa.elem (i, j));
 		  bb.elem (i, j) = abs (cbb.elem (i, j));
 		}
 	  }
 
-	GEPBALANCE result(aa, bb, bal_job);
+	GEPBALANCE result (aa, bb, bal_job);
 
 	if (arg.is_complex_type () || brg.is_complex_type ())
 	  {
 	    caa = result.left_balancing_matrix () * caa
 	      * result.right_balancing_matrix ();
 
 	    cbb = result.left_balancing_matrix () * cbb
 	      * result.right_balancing_matrix ();
diff --git a/src/builtins.cc b/src/builtins.cc
--- a/src/builtins.cc
+++ b/src/builtins.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <iostream.h>
 #include <strstream.h>
 #include <math.h>
 #include <float.h>
 
 #include "tree-const.h"
diff --git a/src/builtins.h b/src/builtins.h
--- a/src/builtins.h
+++ b/src/builtins.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_builtins_h)
 #define _builtins_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class ostrstream;
 class Complex;
 struct help_list;
 
 #ifndef MAPPER_FCN_TYPEDEFS
 #define MAPPER_FCN_TYPEDEFS 1
 
 typedef double (*d_d_Mapper)(double);
diff --git a/src/chol.cc b/src/chol.cc
--- a/src/chol.cc
+++ b/src/chol.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "CollocWt.h"
 
 #include "tree-const.h"
 #include "error.h"
 #include "utils.h"
 #include "f-colloc.h"
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "DAE.h"
 
 #include "tree-const.h"
 #include "variables.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/det.cc b/src/det.cc
--- a/src/det.cc
+++ b/src/det.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 extern "C"
 {
 #include "dld/dld.h"
 }
 
 #include "dynamic-ld.h"
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_dynamic_ld_h)
 #define _dynamic_ld_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class tree_constant;
 
 typedef tree_constant* (*builtin_fcn_ptr) (tree_constant*, int, int);
 
 extern void octave_dld_tc2_unlink_by_symbol (const char *name, int hard = 1);
 
 extern void octave_dld_tc2_unlink_by_file (const char *name, int hard = 1);
 
diff --git a/src/eig.cc b/src/eig.cc
--- a/src/eig.cc
+++ b/src/eig.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 
 #include "error.h"
 #include "pager.h"
@@ -92,16 +92,17 @@ panic (const char *fmt, ...)
 {
   flush_output_to_pager ();
 
   va_list args;
   va_start (args, fmt);
   verror ("panic", fmt, args);
   va_end (args);
   abort ();
+  exit (1);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_error_h)
 #define _error_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #define panic_impossible() \
   panic ("impossible state reached in file `%s' at line %d", \
 	 __FILE__, __LINE__)
 
 // Tell g++ that panic doesn't return;
 
 #ifdef __GNUG__
 typedef void v_fcn_cpc_x (const char *, ...);
diff --git a/src/expm.cc b/src/expm.cc
--- a/src/expm.cc
+++ b/src/expm.cc
@@ -18,18 +18,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 // Written by A. S. Hodel <scotte@eng.auburn.edu>
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <math.h>
 
 #include "Matrix.h"
 #include "f77-uscore.h"
 
 #include "tree-const.h"
diff --git a/src/fft.cc b/src/fft.cc
--- a/src/fft.cc
+++ b/src/fft.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -18,18 +18,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 // Written by John C. Campbell <jcc@che.utexas.edu>.
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <DLList.h>
 #include <unistd.h>
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <strstream.h>
@@ -45,129 +45,133 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "pager.h"
 
 // keeps a count of how many files are open and in the file list
 static int file_count = 0;
 
 // keeps a count of args sent to printf or scanf
 static int fmt_arg_count = 0;
 
-class File_info
+class file_info
 {
  public:
-  File_info (void);
-  File_info (int num, const char *nm, FILE *t, const char *md);
-  File_info (const File_info& f);
+  file_info (void);
+  file_info (int num, const char *nm, FILE *t, const char *md);
+  file_info (const file_info& f);
 
-  File_info& operator = (const File_info& f);
+  file_info& operator = (const file_info& f);
 
-  ~File_info (void);
+  ~file_info (void);
 
   int number (void) const;
-  char *name (void) const;
+  const char *name (void) const;
   FILE *fptr (void) const;
-  char *mode (void) const;
+  const char *mode (void) const;
 
  private:
   int _number;
   char *_name;
   FILE *_fptr;
   char *_mode;
 };
 
-File_info::File_info (void)
+file_info::file_info (void)
 {
   _number = -1;
   _name = (char *) NULL;
   _fptr = (FILE *) NULL;
   _mode = (char *) NULL;
 }
 
-File_info::File_info (const File_info& f)
+file_info::file_info (int n, const char *nm, FILE *t, const char *md)
+{
+  _number = n;
+  _name = strsave (nm);
+  _fptr = t;
+  _mode = strsave (md);
+}
+
+file_info::file_info (const file_info& f)
 {
   _number = f._number;
   _name = strsave (f._name);
   _fptr = f._fptr;
   _mode = strsave (f._mode);
 }
 
-File_info&
-File_info::operator = (const File_info& f)
+file_info&
+file_info::operator = (const file_info& f)
 {
-  _number = f._number;
-  _name = strsave (f._name);
-  _fptr = f._fptr;
-  _mode = strsave (f._mode);
-
+  if (this != & f)
+    {
+      _number = f._number;
+      delete [] _name;
+      _name = strsave (f._name);
+      _fptr = f._fptr;
+      delete [] _mode;
+      _mode = strsave (f._mode);
+    }
   return *this;
 }
 
-File_info::~File_info (void)
+file_info::~file_info (void)
 {
   delete [] _name;
   delete [] _mode;
 }
 
-File_info::File_info (int n, const char *nm, FILE *t, const char *md)
-{
-  _number = n;
-  _name = strsave (nm);
-  _fptr = t;
-  _mode = strsave (md);
-}
-
 int
-File_info::number (void) const
+file_info::number (void) const
 {
   return _number;
 }
 
-char *
-File_info::name (void) const
+const char *
+file_info::name (void) const
 {
   return _name;
 }
 
 FILE *
-File_info::fptr (void) const
+file_info::fptr (void) const
 {
   return _fptr;
 }
 
-char *
-File_info::mode (void) const
+const char *
+file_info::mode (void) const
 {
   return _mode;
 }
 
 
 // double linked list containing relevant information about open files
-static DLList <File_info> file_list;
+static DLList <file_info> file_list;
 
 void
 initialize_file_io (void)
 {
-  File_info _stdin (0, "stdin", stdin, "r");
-  File_info _stdout (1, "stdout", stdout, "w");
-  File_info _stderr (2, "stderr", stderr, "w");
+  file_info _stdin (0, "stdin", stdin, "r");
+  file_info _stdout (1, "stdout", stdout, "w");
+  file_info _stderr (2, "stderr", stderr, "w");
 
   file_list.append (_stdin);
   file_list.append (_stdout);
   file_list.append (_stderr);
 
   file_count = 3;
 }
 
 Pix
 return_valid_file (const tree_constant& arg)
 {
   if (arg.is_string_type ())
     {
       Pix p = file_list.first ();
-      File_info file;
+      file_info file;
       for (int i = 0; i < file_count; i++)
 	{
 	  char *file_name = arg.string_value ();
 	  file = file_list (p);
 	  if (strcmp (file.name (), file_name) == 0)
 	    return p;
 	  file_list.next (p);
 	}
@@ -175,17 +179,17 @@ return_valid_file (const tree_constant& 
   else if (arg.is_scalar_type ())
     {
       double file_num = arg.double_value ();
       if ((double) NINT (file_num) != file_num)
 	error ("file number not an integer value");
       else
 	{
 	  Pix p = file_list.first ();
-	  File_info file;
+	  file_info file;
 	  for (int i = 0; i < file_count; i++)
 	    {
 	      file = file_list (p);
 	      if (file.number () == file_num)
 		return p;
 	      file_list.next (p);
 	    }
 	  error ("no file with that number");
@@ -200,47 +204,48 @@ return_valid_file (const tree_constant& 
 static Pix 
 fopen_file_for_user (const tree_constant& arg, const char *mode)
 {
   char *file_name = arg.string_value ();
 
   FILE *file_ptr = fopen (file_name, mode);
   if (file_ptr != (FILE *) NULL)
     {
-      File_info file (++file_count, file_name, file_ptr, mode);
+      file_info file (++file_count, file_name, file_ptr, mode);
       file_list.append (file);
       
       Pix p = file_list.first ();
-      File_info file_from_list;
+      file_info file_from_list;
       
       for (int i = 0; i < file_count; i++)
 	{
 	  file_from_list = file_list (p);
 	  if (strcmp (file_from_list.name (), file_name) == 0)
 	    return p;
 	  file_list.next (p);
 	}
     }
 
   error ("problems automatically opening file for user");
+
   return (Pix) NULL;
 }
 
 
 tree_constant *
 fclose_internal (const tree_constant *args)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   Pix p = return_valid_file (args[1]);
 
   if (p == (Pix) NULL)
     return retval;
 
-  File_info file = file_list (p);
+  file_info file = file_list (p);
 
   if (file.number () < 3)
     {
       warning ("fclose: can't close stdin, stdout, or stderr!");
       return retval;
     }
 
   int success = fclose (file.fptr ());
@@ -264,25 +269,26 @@ fflush_internal (const tree_constant *ar
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   Pix p = return_valid_file (args[1]);
 
   if (p == (Pix) NULL)
     return retval;
 
-  File_info file = file_list (p);
+  file_info file = file_list (p);
 
   if (strcmp (file.mode (), "r") == 0)
     {
       warning ("can't flush an input stream");
       return retval;
     }
 
   int success = 0;
+
   if (file.number () == 1)
     flush_output_to_pager ();
   else
     success = fflush (file.fptr ());
 
   retval = new tree_constant[2];
   if (success == 0)
     retval[0] = tree_constant (1.0); // succeeded
@@ -346,17 +352,17 @@ fgets_internal (const tree_constant *arg
       if ((double) NINT (length) != length)
 	{
 	  error ("fgets: length not an integer value");
 	  return retval;
 	}
     }
 
   char string[length+1];
-  File_info file = file_list (p);
+  file_info file = file_list (p);
   char *success = fgets (string, length+1, file.fptr ());
 
   if (success == (char *) NULL)
     {
       retval = new tree_constant[2];
       retval[0] = tree_constant (-1.0);
       return retval;
     }
@@ -385,17 +391,17 @@ fopen_internal (const tree_constant *arg
       error ("fopen: file name must be a string");
       return retval;
     }
 
   p = return_valid_file (args[1]);
 
   if (p != (Pix) NULL)
     {
-      File_info file = file_list (p);
+      file_info file = file_list (p);
 
       retval = new tree_constant[2];
       retval[0] = tree_constant ((double) file.number ());
 
       return retval;
     }
 
   if (! args[2].is_string_type ())
@@ -425,17 +431,17 @@ fopen_internal (const tree_constant *arg
   if (file_ptr == (FILE *) NULL)
     {
       error ("fopen: file does not exist");
       return retval;
     }
 
   int number = file_count++;
 
-  File_info file (number, name, file_ptr, mode);
+  file_info file (number, name, file_ptr, mode);
   file_list.append (file);
 
   retval = new tree_constant[2];
   retval[0] = tree_constant ((double) number);
 
   return retval;
 }
 
@@ -445,17 +451,17 @@ freport_internal (void)
   tree_constant *retval = NULL_TREE_CONST;
   Pix p = file_list.first ();
 
   ostrstream output_buf;
 
   output_buf << "\n number  mode  name\n\n";
   for (int i = 0; i < file_count; i++)
     {
-      File_info file = file_list (p);
+      file_info file = file_list (p);
       output_buf.form ("%7d%6s  %s\n", file.number (), file.mode (),
 		       file.name ());
       file_list.next (p);
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 
@@ -466,17 +472,17 @@ tree_constant *
 frewind_internal (const tree_constant *args)
 {
   tree_constant *retval = NULL_TREE_CONST;
 
   Pix p = return_valid_file (args[1]);
   if (p == (Pix) NULL)
     p = fopen_file_for_user (args[1], "a+");   
 
-  File_info file = file_list (p);
+  file_info file = file_list (p);
   rewind (file.fptr ());
 
   return retval;
 }
 
 tree_constant *
 fseek_internal (const tree_constant *args, int nargin)
 {
@@ -511,17 +517,17 @@ fseek_internal (const tree_constant *arg
 	  if ((double) NINT (origin) != origin)
 	    {
 	      error ("fseek: origin not an integer value");
 	      return retval;
 	    }
 	}
     }
 
-  File_info file = file_list (p);
+  file_info file = file_list (p);
   int success = fseek (file.fptr (), offset, origin);
   retval = new tree_constant[2];
 
   if (success == 0)
     retval[0] = tree_constant (1.0); // succeeded
   else
     {
       error ("fseek: file error");
@@ -535,17 +541,17 @@ tree_constant *
 ftell_internal (const tree_constant *args)
 {
   tree_constant *retval = NULL_TREE_CONST;
   Pix p = return_valid_file (args[1]);
 
   if (p == (Pix) NULL)
     p = fopen_file_for_user (args[1], "a+");
 
-  File_info file = file_list (p);
+  file_info file = file_list (p);
   long offset = ftell (file.fptr ());
   retval = new tree_constant[2];
   retval[0] = tree_constant ((double) offset);
 
   if (offset == -1L)
     error ("ftell: write error");
 
   return retval;
@@ -553,17 +559,17 @@ ftell_internal (const tree_constant *arg
 
 void
 close_files (void)
 {
   Pix p = file_list.first ();
 
   for (int i = 0; i < file_count; i++)
     {
-      File_info file = file_list (p);
+      file_info file = file_list (p);
       if (i > 2)   // do not close stdin, stdout, stderr!
 	{
 	  int success = fclose (file.fptr ());
 	  if (success != 0)
 	    error ("closing %s", file.name ());
 	}
       file_list.del (p);
     }
@@ -770,17 +776,17 @@ process_printf_format (const char *s, co
 
 tree_constant *
 do_printf (const char *type, const tree_constant *args, int nargin,
 	   int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   fmt_arg_count = 1;
   char *fmt;
-  File_info file;
+  file_info file;
 
   if (strcmp (type, "fprintf") == 0)
     {
       Pix p;
 
       if (args[2].is_string_type ())
 	{
 	  fmt = args[2].string_value ();
@@ -1053,17 +1059,17 @@ process_scanf_format (const char *s, con
 tree_constant *
 do_scanf (const char *type, const tree_constant *args, int nargin, int nargout)
 {
   tree_constant *retval = NULL_TREE_CONST;
   char *scanf_fmt = (char *) NULL;
   char *tmp_file = (char *) NULL;
   int tmp_file_open = 0;
   FILE *fptr = (FILE *) NULL;
-  File_info file;
+  file_info file;
 
   fmt_arg_count = 0;
 
   if (strcmp (type, "scanf") != 0)
     {
       if ( args[2].is_string_type ())
 	scanf_fmt = args[2].string_value ();
       else
diff --git a/src/file-io.h b/src/file-io.h
--- a/src/file-io.h
+++ b/src/file-io.h
@@ -21,20 +21,16 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 // Written by John C. Campbell <jcc@che.utexas.edu>.
 
 #if !defined (_files_h)
 #define _files_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include <Pix.h>
 
 class tree_constant;
 
 extern Pix return_valid_file (const tree_constant& arg);
 
 extern tree_constant *fclose_internal (const tree_constant *args);
 extern tree_constant *fflush_internal (const tree_constant *args);
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "NLEqn.h"
 
 #include "tree-const.h"
 #include "variables.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/fsqp.cc b/src/fsqp.cc
--- a/src/fsqp.cc
+++ b/src/fsqp.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #ifndef FSQP_MISSING
 
 #include "FSQP.h"
 
 #include "tree-const.h"
 #include "error.h"
diff --git a/src/g-builtins.cc b/src/g-builtins.cc
--- a/src/g-builtins.cc
+++ b/src/g-builtins.cc
@@ -24,18 +24,18 @@ Software Foundation, 675 Mass Ave, Cambr
 /*
 
 The function builtin_pwd adapted from a similar function from GNU
 Bash, the Bourne Again SHell, copyright (C) 1987, 1989, 1991 Free
 Software Foundation, Inc.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <strstream.h>
 #include <iostream.h>
diff --git a/src/g-builtins.h b/src/g-builtins.h
--- a/src/g-builtins.h
+++ b/src/g-builtins.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_g_builtins_h)
 #define _g_builtins_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include "tree-const.h"
 
 struct builtin_general_functions
 {
   char *name;
   int nargin_max;
   int nargout_max;
   General_fcn general_fcn;
diff --git a/src/givens.cc b/src/givens.cc
--- a/src/givens.cc
+++ b/src/givens.cc
@@ -18,18 +18,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 // Written by A. S. Hodel <scotte@eng.auburn.edu>
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 #include "f77-uscore.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "gripes.h"
 #include "error.h"
 
 void
 gripe_string_invalid (void)
 {
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_gripes_h)
 #define _gripes_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 extern void gripe_string_invalid (void);
 extern void gripe_range_invalid (void);
 extern void gripe_nonconformant (void);
 extern void gripe_nonconformant (int r1, int c1, int r2, int c2);
 extern void gripe_empty_arg (const char *name, int is_error);
 extern void gripe_square_matrix_required (const char *name);
 extern void gripe_user_supplied_eval (const char *name);
 extern void gripe_user_returned_invalid (const char *name);
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -16,21 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <iostream.h>
+
 #include "builtins.h"
 #include "help.h"
 
 static help_list operators[] =
 {
   { "!",
     "Logical not operator.  See also `~'.\n", },
 
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_help_h)
 #define _help_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 typedef struct help_list
 {
   char *name;
   char *help;
 };
 
 extern char **names (help_list *l, int& count);
 extern help_list *operator_help (void);
diff --git a/src/hess.cc b/src/hess.cc
--- a/src/hess.cc
+++ b/src/hess.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
diff --git a/src/ifft.cc b/src/ifft.cc
--- a/src/ifft.cc
+++ b/src/ifft.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -18,18 +18,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 // Use the GNU readline library for command line editing and hisory.
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <iostream.h>
 #include <string.h>
 #include <assert.h>
 
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -21,20 +21,16 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 // Use the GNU readline library for command line editing and hisory.
 
 #if !defined (_input_h)
 #define _input_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include <stdio.h>
 
 extern char *octave_gets (void);
 extern int octave_read (char *buf, int max_size);
 extern FILE *get_input_from_file (char *name, int warn = 1);
 extern FILE *get_input_from_stdin (void);
 extern char *command_generator (char *text, int state);
 extern char **command_completer (char *text, int start, int end);
diff --git a/src/inv.cc b/src/inv.cc
--- a/src/inv.cc
+++ b/src/inv.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -88,16 +88,19 @@ extern void delete_buffer (YY_BUFFER_STA
 extern void restore_input_buffer (void *buf);
 
 // Delete a buffer (for unwind-prot).
 extern void delete_input_buffer (void *buf);
 
 // See if a function file has extra garbage after the end statement.
 extern void check_for_garbage_after_fcn_def (void);
 
+// Return transpose or start a string?
+extern int quote_is_transpose;
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -25,16 +25,20 @@ Software Foundation, 675 Mass Ave, Cambr
 %x HELP_FCN
 %s TEXT_FCN
 %s DQSTRING
 %s STRING
 %s MATRIX
 
 %{
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "input.h"
 #include "token.h"
 
 #include "SLStack.h"
 
 // Stack to hold tokens so that we can delete them when the parser is
 // reset and avoid growing forever just because we are stashing some
 // information.  This has to appear before lex.h is included, because
@@ -60,17 +64,17 @@ static int doing_set = 0;
 
 // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
 static do_comma_insert = 0;
 
 // Brace level count.
 static int braceflag = 0;
 
 // Return transpose or start a string?
-static int quote_is_transpose = 0;
+int quote_is_transpose = 0;
 
 // Nonzero means that we should convert spaces to a comma inside a
 // matrix definition.
 static int convert_spaces_to_comma = 1;
 
 // Another context hack, this time for the plot command's `using',
 // `title', and `with' keywords.
 static int cant_be_identifier = 0;
diff --git a/src/lpsolve.cc b/src/lpsolve.cc
--- a/src/lpsolve.cc
+++ b/src/lpsolve.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "LPsolve.h"
 
 #include "tree-const.h"
 #include "error.h"
 #include "f-lpsolve.h"
 
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "ODE.h"
 
 #include "tree-const.h"
 #include "variables.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/lu.cc b/src/lu.cc
--- a/src/lu.cc
+++ b/src/lu.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "f-lu.h"
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <float.h>
 #include <Complex.h>
 
 #include "mappers.h"
 #include "utils.h"
 
diff --git a/src/mappers.h b/src/mappers.h
--- a/src/mappers.h
+++ b/src/mappers.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_mappers_h)
 #define _mappers_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class Complex;
 
 #include "missing-math.h"
 
 extern double arg (double x);
 extern double conj (double x);
 extern double fix (double x);
 extern double imag (double x);
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #ifndef NPSOL_MISSING
 
 #include "NPSOL.h"
 
 #include "tree-const.h"
 #include "variables.h"
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -23,18 +23,18 @@ The functions listed below were adapted 
 GNU Bash, the Bourne Again SHell, copyright (C) 1987, 1989, 1991 Free
 Software Foundation, Inc.
 
   do_history         edit_history_readline
   do_edit_history    edit_history_add_hist
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <fcntl.h>
 #include <stdlib.h>
diff --git a/src/oct-hist.h b/src/oct-hist.h
--- a/src/oct-hist.h
+++ b/src/oct-hist.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_octave_hist_h)
 #define _octave_hist_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 extern void initialize_history (void);
 extern void clean_up_history (void);
 extern void maybe_save_history (char*);
 extern void do_history (int, char**);
 extern void do_edit_history (int, char**);
 extern void do_run_history (int, char**);
 extern int current_history_number (void);
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -18,18 +18,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 // Born February 20, 1992.
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/stat.h>
 #include <time.h>
@@ -39,17 +39,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include <string.h>
 #include <signal.h>
 #include <assert.h>
 #include <iostream.h>
 #include <fstream.h>
 
 #include "getopt.h"
 
-#include "liboctave-error.h"
+#include "lo-error.h"
 
 #include "sighandlers.h"
 #include "variables.h"
 #include "error.h"
 #include "tree-const.h"
 #include "utils.h"
 #include "builtins.h"
 #include "input.h"
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <iostream.h>
 #include <strstream.h>
 #include <stdlib.h>
 
 #include "procstream.h"
 
diff --git a/src/pager.h b/src/pager.h
--- a/src/pager.h
+++ b/src/pager.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_pager_h)
 #define _pager_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class ostrstream;
 
 extern char *get_pager (void);
 extern int terminal_columns (void);
 extern int terminal_rows (void);
 extern void initialize_pager (void);
 extern void maybe_page_output (ostrstream& msg_buf);
 extern void flush_output_to_pager (void);
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -23,16 +23,20 @@ Software Foundation, 675 Mass Ave, Cambr
 // Parser for Octave.
 
 /*
  * C decarations.
  */
 %{
 #define YYDEBUG 1
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "SLStack.h"
 
 #include "Matrix.h"
 
 #include "error.h"
 #include "variables.h"
 #include "octave-hist.h"
 #include "user-prefs.h"
@@ -760,16 +764,26 @@ simple_expr1	: NUM
 		    if ($2->is_assignment_expression ())
 		      ((tree_assignment_expression *) $2) -> in_parens++;
 		    $$ = $2;
 		  }
 		| variable
 		  { $$ = $1; }
 		| matrix
 		  { $$ = $1; }
+		| '[' ']'
+		  {
+		    mlnm.pop ();
+		    $$ = new tree_constant (Matrix ());
+		  }
+		| '[' ';' ']'
+		  {
+		    mlnm.pop ();
+		    $$ = new tree_constant (Matrix ());
+		  }
 		| colon_expr
 		  { $$ = $1; }
 		| PLUS_PLUS identifier %prec UNARY
 		  { $$ = new tree_prefix_expression
 		      ($2, tree::increment, $1->line (), $1->column ()); }
 		| MINUS_MINUS identifier %prec UNARY
 		  { $$ = new tree_prefix_expression
 		      ($2, tree::decrement, $1->line (), $1->column ()); }
@@ -914,18 +928,16 @@ func_def2	: identifier safe local_symtab
 		  }
 		;
 
 func_def3	: param_list optsep opt_list fcn_end_or_eof
 		  {
 		    tree_function *fcn = new tree_function ($3, curr_sym_tab);
 		    $$ = fcn->define_param_list ($1);
 		  }
-		| '(' ')' optsep opt_list fcn_end_or_eof
-		  { $$ = new tree_function ($4, curr_sym_tab); }
 		| optsep opt_list fcn_end_or_eof
 		  { $$ = new tree_function ($2, curr_sym_tab); }
 		;
 
 fcn_end_or_eof	: END
 		  {
 		    if (check_end ($1, token::function_end))
 			ABORT_PARSE;
@@ -961,24 +973,31 @@ variable	: identifier
 		    yyerror ("parse error");
 		    error ("use `(\' and `)\' as index operators, not\
  `[\' and `]\'"); 
 		    $$ = (tree_index_expression *) NULL;
 		    ABORT_PARSE;
 		  }
 		;
 
-param_list	: param_list1 ')'
+param_list	: '(' ')'
 		  {
+		    quote_is_transpose = 0;
+		    $$ = (tree_parameter_list *) NULL;
+		  }
+		| param_list1 ')'
+		  {
+		    quote_is_transpose = 0;
 		    tree_parameter_list *tmp = $1->reverse ();
 		    tmp->mark_as_formal_parameters ();
 		    $$ = tmp;
 		  }
 		| param_list1 ',' ELLIPSIS ')'
 		  {
+		    quote_is_transpose = 0;
 		    tree_parameter_list *tmp = $1->reverse ();
 		    tmp->mark_as_formal_parameters ();
 		    tmp->mark_varargs ();
 		    $$ = tmp;
 		  }
 
 param_list1	: '(' identifier
 		  { $$ = new tree_parameter_list ($2); }
@@ -1031,27 +1050,17 @@ arg_list1	: ':'
 		    if ($$ == NULL_TREE)
 		      {
 			yyerror ("parse error");
 			ABORT_PARSE;
 		      }
 		  }
 		;
 
-matrix		: '[' ']'
-		  {
-		    mlnm.pop ();
-		    $$ = new tree_matrix ();
-		  }
-		| '[' ';' ']'
-		  {
-		    mlnm.pop ();
-		    $$ = new tree_matrix ();
-		  }
-		| '[' screwed_again rows ']'
+matrix		: '[' screwed_again rows ']'
 		  {
 		    mlnm.pop ();
 		    maybe_screwed_again--;
 		    tree_matrix *tmp = ml.pop ();
 		    $$ = tmp->reverse ();
 		  }
 		;
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <iostream.h>
 #include <strstream.h>
 #include <stdio.h>
 #include <string.h>
 #include <math.h>
 #include <float.h>
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_pr_output_h)
 #define _pr_output_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class ostrstream;
 
 class Matrix;
 class Complex;
 class ComplexMatrix;
 class Range;
 
 extern void octave_print_internal (ostrstream& os, double d);
diff --git a/src/procstream.cc b/src/procstream.cc
--- a/src/procstream.cc
+++ b/src/procstream.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "procstream.h"
 
 procstreambase::procstreambase (void)
 {
   init (new procbuf ());
 }
diff --git a/src/procstream.h b/src/procstream.h
--- a/src/procstream.h
+++ b/src/procstream.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_procstream_h)
 #define _procstream_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include <iostream.h>
 #include <procbuf.h>
 
 class
 procstreambase : virtual public ios
 {
  public:
   procstreambase (void);
diff --git a/src/pt-base.h b/src/pt-base.h
--- a/src/pt-base.h
+++ b/src/pt-base.h
@@ -23,19 +23,16 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_tree_base_h)
 #define _tree_base_h 1
 
 #include <stdio.h>
 #include <time.h>
 #include <assert.h>
 
-// NOTE: don\'t put #pragma interface here because there is no
-// corresponding tree-base.cc file that implements this class!
-
 #ifndef NULL_TREE
 #define NULL_TREE (tree *)NULL
 #endif
 
 #ifndef NULL_TREE_CONST
 #define NULL_TREE_CONST (tree_constant *)NULL
 #endif
 
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <ctype.h>
 #include <string.h>
 #include <iostream.h>
 #include <strstream.h>
 #include <math.h>
 
@@ -391,19 +391,19 @@ tree_constant_rep::tree_constant_rep (do
 {
   range = new Range (b, l, i);
   int nel = range->nelem ();
   if (nel < 0)
     {
       delete range;
       type_tag = unknown_constant;
       if (nel == -1)
-	error ("number of elements in range exceeds INT_MAX");
+	::error ("number of elements in range exceeds INT_MAX");
       else
-	error ("invalid range");
+	::error ("invalid range");
     }
   else if (nel > 1)
     type_tag = range_constant;
   else
     {
       delete range;
       if (nel == 1)
 	{
@@ -577,21 +577,21 @@ tree_constant_rep::maybe_resize (int i, 
 
   if (i > nr || j > nc)
     {
       if (user_pref.resize_on_range_error)
 	resize (MAX (i, nr), MAX (j, nc), 0.0);
       else
 	{
 	  if (i > nr)
-	    error ("row index = %d exceeds max row dimension = %d", i, nr);
+	    ::error ("row index = %d exceeds max row dimension = %d", i, nr);
 
 	  if (j > nc)
-	    error ("column index = %d exceeds max column dimension = %d",
-		   j, nc);
+	    ::error ("column index = %d exceeds max column dimension = %d",
+		     j, nc);
 	}
     }
 }
 
 void
 tree_constant_rep::maybe_resize (int i, force_orient f_orient = no_orient)
 {
   int nr = rows ();
@@ -610,31 +610,31 @@ tree_constant_rep::maybe_resize (int i, 
 	  else if (f_orient == column_orient)
 	    resize (i, 1, 0.0);
 	  else if (user_pref.prefer_column_vectors)
 	    resize (i, 1, 0.0);
 	  else
 	    resize (1, i, 0.0);
 	}
       else
-	error ("matrix index = %d exceeds max dimension = %d", i, nc);
+	::error ("matrix index = %d exceeds max dimension = %d", i, nc);
     }
   else if (nr == 1 && i > nc)
     {
       if (user_pref.resize_on_range_error)
 	resize (1, i, 0.0);
       else
-	error ("matrix index = %d exceeds max dimension = %d", i, nc);
+	::error ("matrix index = %d exceeds max dimension = %d", i, nc);
     }
   else if (nc == 1 && i > nr)
     {
       if (user_pref.resize_on_range_error)
 	resize (i, 1, 0.0);
       else
-	error ("matrix index = %d exceeds max dimension = ", i, nc);
+	::error ("matrix index = %d exceeds max dimension = ", i, nc);
     }
 }
 
 double
 tree_constant_rep::to_scalar (void) const
 {
   tree_constant tmp = make_numeric ();
 
@@ -658,24 +658,24 @@ tree_constant_rep::to_scalar (void) cons
 	{
 	  int flag = user_pref.ok_to_lose_imaginary_part;
 	  if (flag == -1)
 	    warning ("implicit conversion of complex value to real value");
 
 	  if (flag != 0)
 	    {
 	      ComplexMatrix m = tmp.complex_matrix_value ();
-	      return real (m (0, 0));
+	      return ::real (m (0, 0));
 	    }
 	  else
 	    jump_to_top_level ();
 	}
       else
 	{
-	  error ("complex matrix used in invalid context");
+	  ::error ("complex matrix used in invalid context");
 	  jump_to_top_level ();
 	}
       break;
     default:
       break;
     }
   return retval;
 }
@@ -752,18 +752,18 @@ tree_constant_rep::force_numeric (int fo
     case matrix_constant:
     case complex_scalar_constant:
     case complex_matrix_constant:
       break;
     case string_constant:
       {
 	if (! force_str_conv && ! user_pref.implicit_str_to_num_ok)
 	  {
-	    error ("failed to convert `%s' to a numeric type --", string);
-	    error ("default conversion turned off");
+	    ::error ("failed to convert `%s' to a numeric type --", string);
+	    ::error ("default conversion turned off");
 // Abort!
 	    jump_to_top_level ();
 	  }
 
 	int len = strlen (string);
 	if (len > 1)
 	  {
 	    type_tag = matrix_constant;
@@ -772,16 +772,23 @@ tree_constant_rep::force_numeric (int fo
 	      tm->elem (0, i) = toascii ((int) string[i]);
 	    matrix = tm;
 	  }
 	else if (len == 1)
 	  {
 	    type_tag = scalar_constant;
 	    scalar = toascii ((int) string[0]);
 	  }
+	else if (len == 0)
+	  {
+	    type_tag = matrix_constant;
+	    matrix = new Matrix (0, 0);
+	  }
+	else
+	  panic_impossible ();
       }
       break;
     case range_constant:
       {
 	int len = range->nelem ();
 	if (len > 1)
 	  {
 	    type_tag = matrix_constant;
@@ -851,17 +858,17 @@ do_binary_op (tree_constant& a, tree_con
 
   if (first_empty || second_empty)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	warning ("binary operation on empty matrix");
       else if (flag == 0)
 	{
-	  error ("invalid binary operation on empty matrix");
+	  ::error ("invalid binary operation on empty matrix");
 	  return ans;
 	}
     }
 
   tree_constant tmp_a = a.make_numeric ();
   tree_constant tmp_b = b.make_numeric ();
 
   tree_constant_rep::constant_type a_type = tmp_a.const_type ();
@@ -993,17 +1000,17 @@ do_unary_op (tree_constant& a, tree::exp
 
   if (a.rows () == 0 || a.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	warning ("unary operation on empty matrix");
       else if (flag == 0)
 	{
-	  error ("invalid unary operation on empty matrix");
+	  ::error ("invalid unary operation on empty matrix");
 	  return ans;
 	}
     }
 
   tree_constant tmp_a = a.make_numeric ();
 
   switch (tmp_a.const_type ())
     {
@@ -1049,17 +1056,17 @@ tree_constant_rep::bump_value (tree::exp
 	  break;
 	case complex_scalar_constant:
 	  *complex_scalar = *complex_scalar + 1.0;
 	  break;
 	case complex_matrix_constant:
 	  *complex_matrix = *complex_matrix + 1.0;
 	  break;
 	case string_constant:
-	  error ("string++ and ++string not implemented yet, ok?");
+	  ::error ("string++ and ++string not implemented yet, ok?");
 	  break;
 	case range_constant:
 	  range->set_base (range->base () + 1.0);
 	  range->set_limit (range->limit () + 1.0);
 	  break;
 	case magic_colon:
 	default:
 	  panic_impossible ();
@@ -1071,17 +1078,17 @@ tree_constant_rep::bump_value (tree::exp
 	{
 	case scalar_constant:
 	  scalar--;
 	  break;
 	case matrix_constant:
 	  *matrix = *matrix - 1.0;
 	  break;
 	case string_constant:
-	  error ("string-- and -- string not implemented yet, ok?");
+	  ::error ("string-- and -- string not implemented yet, ok?");
 	  break;
 	case range_constant:
 	  range->set_base (range->base () - 1.0);
 	  range->set_limit (range->limit () - 1.0);
 	  break;
 	case magic_colon:
 	default:
 	  panic_impossible ();
@@ -1098,28 +1105,28 @@ void
 tree_constant_rep::eval (int print)
 {
   if (error_state)
     return;
 
   switch (type_tag)
     {
     case complex_scalar_constant:
-      if (imag (*complex_scalar) == 0.0)
+      if (::imag (*complex_scalar) == 0.0)
 	{
-	  double d = real (*complex_scalar);
+	  double d = ::real (*complex_scalar);
 	  delete complex_scalar;
 	  scalar = d;
 	  type_tag = scalar_constant;
 	}
       break;
     case complex_matrix_constant:
       if (! any_element_is_complex (*complex_matrix))
 	{
-	  Matrix *m = new Matrix (real (*complex_matrix));
+	  Matrix *m = new Matrix (::real (*complex_matrix));
 	  delete complex_matrix;
 	  matrix = m;
 	  type_tag = matrix_constant;
 	}
       break;
     case scalar_constant:
     case matrix_constant:
     case string_constant:
@@ -1365,17 +1372,17 @@ tree_constant_rep::save_three_d (ostream
 	    {
 	      os << matrix->extract (0, i, nr-1, i);
 	      if (i+1 < nc)
 		os << "\n";
 	    }
 	}
       break;
     default:
-      error ("for now, I can only save real matrices in 3D format");
+      ::error ("for now, I can only save real matrices in 3D format");
       return 0;
       break;
     }
 // Really want to return 1 only if write is successful.
   return 1;
 }
 
 int
@@ -1410,20 +1417,20 @@ tree_constant_rep::load (istream& is)
 	    type_tag = load (is, complex_scalar_constant);
 	  else if (strncmp (ptr, "complex matrix", 14) == 0)
 	    type_tag = load (is, complex_matrix_constant);
 	  else if (strncmp (ptr, "string", 6) == 0)
 	    type_tag = load (is, string_constant);
 	  else if (strncmp (ptr, "range", 5) == 0)
 	    type_tag = load (is, range_constant);
 	  else
-	    error ("unknown constant type `%s'", tag);
+	    ::error ("unknown constant type `%s'", tag);
 	}
       else
-	error ("failed to extract keyword specifying value type");
+	::error ("failed to extract keyword specifying value type");
     }
 
   return is_global;
 }
 
 tree_constant_rep::constant_type
 tree_constant_rep::load (istream& is, tree_constant_rep::constant_type t)
 {
@@ -1431,85 +1438,85 @@ tree_constant_rep::load (istream& is, tr
 
   switch (t)
     {
     case scalar_constant:
       is >> scalar;
       if (is)
 	status = scalar_constant;
       else
-	error ("failed to load scalar constant");
+	::error ("failed to load scalar constant");
       break;
     case matrix_constant:
       {
 	int nr = 0, nc = 0;
 
 	if (extract_keyword (is, "rows", nr) && nr > 0
 	    && extract_keyword (is, "columns", nc) && nc > 0)
 	  {
 	    matrix = new Matrix (nr, nc);
 	    is >> *matrix;
 	    if (is)
 	      status = matrix_constant;
 	    else
-	      error ("failed to load matrix constant");
+	      ::error ("failed to load matrix constant");
 	  }
 	else
-	  error ("failed to extract number of rows and columns");
+	  ::error ("failed to extract number of rows and columns");
       }
       break;
     case complex_scalar_constant:
       is >> *complex_scalar;
       if (is)
 	status = complex_scalar_constant;
       else
-	error ("failed to load complex scalar constant");
+	::error ("failed to load complex scalar constant");
       break;
     case complex_matrix_constant:
       {
 	int nr = 0, nc = 0;
 
 	if (extract_keyword (is, "rows", nr) && nr > 0
 	    && extract_keyword (is, "columns", nc) && nc > 0)
 	  {
 	    complex_matrix = new ComplexMatrix (nr, nc);
 	    is >> *complex_matrix;
 	    if (is)
 	      status = complex_matrix_constant;
 	    else
-	      error ("failed to load complex matrix constant");
+	      ::error ("failed to load complex matrix constant");
 	  }
 	else
-	  error ("failed to extract number of rows and columns");
+	  ::error ("failed to extract number of rows and columns");
       }
       break;
     case string_constant:
       {
 	int len;
 	if (extract_keyword (is, "length", len) && len > 0)
 	  {
 	    string = new char [len+1];
 	    is.get (string, len+1, EOF);
 	    if (is)
 	      status = string_constant;
 	    else
-	      error ("failed to load string constant");
+	      ::error ("failed to load string constant");
 	  }
 	else
-	  error ("failed to extract string length");
+	  ::error ("failed to extract string length");
       }
       break;
     case range_constant:
       skip_comments (is);
       range = new Range ();
       is >> *range;
       if (is)
 	status = range_constant;
       else
-	error ("failed to load range constant");
+	::error ("failed to load range constant");
       break;
     default:
       panic_impossible ();
       break;
     }
   return status;
 }
 
@@ -1522,54 +1529,58 @@ tree_constant_rep::double_value (void) c
       return scalar;
     case complex_scalar_constant:
       {
 	int flag = user_pref.ok_to_lose_imaginary_part;
 	if (flag == -1)
 	  warning ("implicit conversion of complex value to real value");
 
 	if (flag != 0)
-	  return real (*complex_scalar);
+	  return ::real (*complex_scalar);
 
-	error ("implicit conversion of complex value to real value not allowed");
+	::error ("implicit conversion of complex value to real value");
+	::error ("not allowed");
 	jump_to_top_level ();
       }
     default:
       panic_impossible ();
       break;
     }
 }
 
 Matrix
 tree_constant_rep::matrix_value (void) const
 {
   switch (type_tag)
     {
     case scalar_constant:
-      return Matrix (scalar);
+      return Matrix (1, 1, scalar);
     case matrix_constant:
       return *matrix;
     case complex_scalar_constant:
     case complex_matrix_constant:
       {
 	int flag = user_pref.ok_to_lose_imaginary_part;
 	if (flag == -1)
 	  warning ("implicit conversion of complex matrix to real matrix"); 
 
 	if (flag != 0)
 	  {
 	    if (type_tag == complex_scalar_constant)
-	      return Matrix (real (*complex_scalar));
+	      return Matrix (1, 1, ::real (*complex_scalar));
 	    else if (type_tag == complex_matrix_constant)
-	      return real (*complex_matrix);
+	      return ::real (*complex_matrix);
 	    else
 	      panic_impossible ();
 	  }
 	else
-	  error ("implicit conversion of complex matrix to real matrix not allowed");
+	  {
+	    ::error ("implicit conversion of complex matrix to real matrix");
+	    ::error ("not allowed");
+	  }
 	jump_to_top_level ();
       }
     default:
       panic_impossible ();
       break;
     }
 }
 
@@ -1590,21 +1601,21 @@ tree_constant_rep::complex_value (void) 
 
 ComplexMatrix
 tree_constant_rep::complex_matrix_value (void) const
 {
   switch (type_tag)
     {
     case scalar_constant:
       {
-	return ComplexMatrix (scalar);
+	return ComplexMatrix (1, 1, Complex (scalar));
       }
     case complex_scalar_constant:
       {
-	return ComplexMatrix (*complex_scalar);
+	return ComplexMatrix (1, 1, *complex_scalar);
       }
     case matrix_constant:
       {
         return ComplexMatrix (*matrix);
       }
     case complex_matrix_constant:
       return *complex_matrix;
       break;
@@ -1642,17 +1653,17 @@ tree_constant_rep::rows (void) const
       break;
     case matrix_constant:
       retval = matrix->rows ();
       break;
     case complex_matrix_constant:
       retval = complex_matrix->rows ();
       break;
     case magic_colon:
-      error ("invalid use of colon operator");
+      ::error ("invalid use of colon operator");
       break;
     case unknown_constant:
       retval = 0;
       break;
     default:
       panic_impossible ();
       break;
     }
@@ -1677,17 +1688,17 @@ tree_constant_rep::columns (void) const
       break;
     case string_constant:
       retval = strlen (string);
       break;
     case range_constant:
       retval = range->nelem ();
       break;
     case magic_colon:
-      error ("invalid use of colon operator");
+      ::error ("invalid use of colon operator");
       break;
     case unknown_constant:
       retval = 0;
       break;
     default:
       panic_impossible ();
       break;
     }
@@ -1806,26 +1817,27 @@ tree_constant_rep::convert_to_str (void)
     case complex_scalar_constant:
     case scalar_constant:
       {
 	double d = double_value ();
 	int i = NINT (d);
 // Warn about out of range conversions?
 	char s[2];
 	s[0] = (char) i;
+	s[1] = '\0';
 	retval = tree_constant (s);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
       {
 	ColumnVector v = to_vector ();
 	int len = v.length ();
 	if (len == 0)
-	  error ("can only convert vectors and scalars to strings");
+	  ::error ("can only convert vectors and scalars to strings");
 	else
 	  {
 	    char *s = new char [len+1];
 	    s[len] = '\0';
 	    for (int i = 0; i < len; i++)
 	      {
 		double d = v.elem (i);
 		int ival = NINT (d);
@@ -2258,17 +2270,17 @@ tree_constant_rep::diag (const tree_cons
 	    retval = make_diag (matrix_value (), k);
 	  else
 	    {
 	      ColumnVector d = matrix->diag (k);
 	      retval = tree_constant (d);
 	    }
 	}
       else
-	error ("diag: invalid second argument");
+	::error ("diag: invalid second argument");
 
       break;
     case complex_scalar_constant:
       if (a_type == scalar_constant)
 	{
 	  int k = NINT (tmp_a.double_value ());
 	  int n = ABS (k) + 1;
 	  if (k == 0)
@@ -2297,17 +2309,17 @@ tree_constant_rep::diag (const tree_cons
 	    retval = make_diag (complex_matrix_value (), k);
 	  else
 	    {
 	      ComplexColumnVector d = complex_matrix->diag (k);
 	      retval = tree_constant (d);
 	    }
 	}
       else
-	error ("diag: invalid second argument");
+	::error ("diag: invalid second argument");
 
       break;
     case string_constant:
     case range_constant:
     case magic_colon:
     default:
       panic_impossible ();
       break;
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_tree_const_h)
 #define _tree_const_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include <stdlib.h>
 
 #include "builtins.h"
 #include "tree-base.h"
 #include "Matrix.h" // Needed for some inline functions.
 #include "Range.h"  // Ditto.
 
 class idx_vector;
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <iostream.h>
 #include <fstream.h>
 #include <strstream.h>
 
 #include "error.h"
 #include "utils.h"
@@ -420,34 +420,34 @@ tree_plot_range::print (ostrstream& plot
 {
   plot_buf << " [";
 
   if (lower != NULL_TREE)
     {
       tree_constant lower_val = lower->eval (0);
       if (error_state)
 	{
-	  error ("evaluating lower bound of plot range");
+	  ::error ("evaluating lower bound of plot range");
 	  return;
 	}
       else
 	{
 	  double lo = lower_val.to_scalar ();
 	  plot_buf << lo;
 	}
     }
 
   plot_buf << ":";
 
   if (upper != NULL_TREE)
     {
       tree_constant upper_val = upper->eval (0);
       if (error_state)
 	{
-	  error ("evaluating upper bound of plot range");
+	  ::error ("evaluating upper bound of plot range");
 	  return;
 	}
       else
 	{
 	  double hi = upper_val.to_scalar ();
 	  plot_buf << hi;
 	}
     }
@@ -514,34 +514,34 @@ tree_subplot_using::print (int ndim, int
 
   for (int i = 0; i < qualifier_count; i++)
     {
       if (x[i] != NULL_TREE)
 	{
 	  tree_constant tmp = x[i]->eval (0);
 	  if (error_state)
 	    {
-	      error ("evaluating plot using command");
+	      ::error ("evaluating plot using command");
 	      return -1;
 	    }
 
 	  double val;
 	  if (tmp.is_defined ())
 	    {
 	      val = tmp.to_scalar ();
 	      if (i == 0)
 		plot_buf << " using ";
 	      else
 		plot_buf << ":";
 
 	      int n = NINT (val);
 
 	      if (n > n_max || n < 1)
 		{
-		  error ("using: column %d out of range", n); 
+		  ::error ("using: column %d out of range", n); 
 		  return -1;
 		}
 	      else
 		plot_buf << n;
 	    }
 	  else
 	    return -1;
 	}
@@ -609,32 +609,32 @@ tree_subplot_style::print (ostrstream& p
 	  tree_constant tmp = linetype->eval (0);
 	  if (! error_state && tmp.is_defined ())
 	    {
 	      double val = tmp.to_scalar ();
 	      plot_buf << " " << NINT (val);
 	    }
 	  else
 	    {
-	      error ("evaluating plot style command");
+	      ::error ("evaluating plot style command");
 	      return -1;
 	    }
 	}
 
       if (pointtype != NULL_TREE)
 	{
 	  tree_constant tmp = pointtype->eval (0);
 	  if (! error_state && tmp.is_defined ())
 	    {
 	      double val = tmp.to_scalar ();
 	      plot_buf << " " << NINT (val);
 	    }
 	  else
 	    {
-	      error ("evaluating plot style command");
+	      ::error ("evaluating plot style command");
 	      return -1;
 	    }
 	}
     }
   else
     return -1;
 
   return 0;
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #ifndef QPSOL_MISSING
 
 #include "QPSOL.h"
 
 #include "tree-const.h"
 #include "variables.h"
diff --git a/src/qr.cc b/src/qr.cc
--- a/src/qr.cc
+++ b/src/qr.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "f-qr.h"
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Quad.h"
 
 #include "tree-const.h"
 #include "variables.h"
 #include "mappers.h"
 #include "gripes.h"
diff --git a/src/qzval.cc b/src/qzval.cc
--- a/src/qzval.cc
+++ b/src/qzval.cc
@@ -18,18 +18,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 // Written by A. S. Hodel <scotte@eng.auburn.edu>
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <float.h>
 
 #include "Matrix.h"
 #include "f77-uscore.h"
 
 #include "tree-const.h"
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "tree-const.h"
 #include "f77-uscore.h"
 #include "error.h"
 #include "utils.h"
 #include "f-rand.h"
 
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <signal.h>
 
 #include "sighandlers.h"
 #include "octave.h"
 #include "error.h"
 #include "utils.h"
diff --git a/src/sighandlers.h b/src/sighandlers.h
--- a/src/sighandlers.h
+++ b/src/sighandlers.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_sighandlers_h)
 #define _sighandlers_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 // Nonzero means we have already printed a message for this series of
 // SIGPIPES.  We assume that the writer will eventually give up.
 extern int pipe_handler_error_count;
 
 // Nonzero means we can be interrupted.
 extern int can_interrupt;
 
 typedef RETSIGTYPE sig_handler (...);
diff --git a/src/svd.cc b/src/svd.cc
--- a/src/svd.cc
+++ b/src/svd.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
diff --git a/src/syl.cc b/src/syl.cc
--- a/src/syl.cc
+++ b/src/syl.cc
@@ -18,18 +18,18 @@ for more details.
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 // Written by A. S. Hodel <scotte@eng.auburn.edu>
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "Matrix.h"
 #include "f77-uscore.h"
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -16,22 +16,22 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+// Don't even think about moving the tree.h include to symtab.h...
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
-// Don't even think about moving the tree.h include to symtab.h...
-
 #include "symtab.h"
 #include "error.h"
 #include "variables.h"
 #include "utils.h"
 #include "tree.h"
 #include "tree-const.h"
 
 /*
@@ -661,17 +661,17 @@ symbol_record::read_only_error (void)
   if (is_read_only ())
     {
       char *tag = "symbol";
       if (is_variable ())
 	tag = "variable";
       else if (is_function ())
 	tag = "function";
 	
-      error ("can't redefined read-only %s `%s'", tag, nm);
+      ::error ("can't redefined read-only %s `%s'", tag, nm);
 
       return 1;
     }
   else
     return 0;
 }
 
 void
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_symtab_h)
 #define _symtab_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include <stdlib.h>
 #include <string.h>
 #include <iostream.h>
 #include <assert.h>
 
 #include "SLStack.h"
 
 #ifndef SV_FUNCTION_TYPEDEFS
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <stdlib.h>
 
 #include "error.h"
 
 #ifdef NeXT
 extern "C"
diff --git a/src/t-builtins.cc b/src/t-builtins.cc
--- a/src/t-builtins.cc
+++ b/src/t-builtins.cc
@@ -28,18 +28,18 @@ Bash, the Bourne Again SHell, copyright 
 Software Foundation, Inc.
 
 The function list_in_columns was adapted from a similar function from
 GNU ls, print_many_per_line, copyright (C) 1985, 1988, 1990, 1991 Free
 Software Foundation, Inc.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <iostream.h>
 #include <strstream.h>
diff --git a/src/t-builtins.h b/src/t-builtins.h
--- a/src/t-builtins.h
+++ b/src/t-builtins.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_t_builtins_h)
 #define _t_builtins_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include "tree-const.h"
 
 struct builtin_text_functions
 {
   char *name;
   int nargin_max;
   Text_fcn text_fcn;
   char *help_string;
diff --git a/src/tc-assign.cc b/src/tc-assign.cc
--- a/src/tc-assign.cc
+++ b/src/tc-assign.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "idx-vector.h"
 #include "user-prefs.h"
 #include "tree-const.h"
 #include "utils.h"
 #include "gripes.h"
 #include "error.h"
@@ -49,17 +49,17 @@ tree_constant_rep::assign (tree_constant
     case unknown_constant:
       do_scalar_assignment (rhs_tmp, args, nargs);
       break;
     case complex_matrix_constant:
     case matrix_constant:
       do_matrix_assignment (rhs_tmp, args, nargs);
       break;
     case string_constant:
-      error ("invalid assignment to string type");
+      ::error ("invalid assignment to string type");
       break;
     case range_constant:
     case magic_colon:
     default:
       panic_impossible ();
       break;
     }
 }
@@ -83,17 +83,17 @@ tree_constant_rep::do_scalar_assignment 
 	    }
 	  else if (rhs.const_type () == complex_scalar_constant)
 	    {
 	      complex_scalar = new Complex (rhs.complex_value ());
 	      type_tag = complex_scalar_constant;
 	    }
 	  else
 	    {
-	      error ("invalid assignment to scalar");
+	      ::error ("invalid assignment to scalar");
 	      return;
 	    }
 	}
       else
 	{
 	  if (rhs.const_type () == scalar_constant)
 	    {
 	      scalar = rhs.double_value ();
@@ -101,17 +101,17 @@ tree_constant_rep::do_scalar_assignment 
 	    }
 	  else if (rhs.const_type () == complex_scalar_constant)
 	    {
 	      *complex_scalar = rhs.complex_value ();
 	      type_tag = complex_scalar_constant;
 	    }
 	  else
 	    {
-	      error ("invalid assignment to scalar");
+	      ::error ("invalid assignment to scalar");
 	      return;
 	    }
 	}
     }
   else if (user_pref.resize_on_range_error)
     {
       tree_constant_rep::constant_type old_type_tag = type_tag;
 
@@ -143,19 +143,19 @@ tree_constant_rep::do_scalar_assignment 
 	    delete matrix;
 	  else if (type_tag == complex_matrix_constant)
 	    delete complex_matrix;
 
 	  type_tag = unknown_constant;
 	}
     }
   else if (nargs > 3 || nargs < 2)
-    error ("invalid index expression for scalar type");
+    ::error ("invalid index expression for scalar type");
   else
-    error ("index invalid or out of range for scalar type");
+    ::error ("index invalid or out of range for scalar type");
 }
 
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant *args, int nargs)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == matrix_constant
@@ -181,57 +181,57 @@ tree_constant_rep::do_matrix_assignment 
 	  type_tag = matrix_constant;
 	}
     }
 
   switch (nargs)
     {
     case 2:
       if (args == NULL_TREE_CONST)
-	error ("matrix index is null");
+	::error ("matrix index is null");
       else if (args[1].is_undefined ())
-	error ("matrix index is undefined");
+	::error ("matrix index is undefined");
       else if (args[1].is_empty ())
-	error ("matrix index is an empty matrix");
+	::error ("matrix index is an empty matrix");
       else
 	do_matrix_assignment (rhs, args[1]);
       break;
     case 3:
       if (args == NULL_TREE_CONST)
-	error ("matrix indices are null");
+	::error ("matrix indices are null");
       else if (args[1].is_undefined ())
-	error ("first matrix index is undefined");
+	::error ("first matrix index is undefined");
       else if (args[2].is_undefined ())
-	error ("second matrix index is undefined");
+	::error ("second matrix index is undefined");
       else if (args[1].is_empty ())
-	error ("first matrix index is an empty matrix");
+	::error ("first matrix index is an empty matrix");
       else if (args[2].is_empty ())
-	error ("second matrix index is an empty matrix");
+	::error ("second matrix index is an empty matrix");
       else
 	do_matrix_assignment (rhs, args[1], args[2]);
       break;
     default:
-      error ("too many indices for matrix expression");
+      ::error ("too many indices for matrix expression");
       break;
     }
 }
 
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant& i_arg)
 {
   int nr = rows ();
   int nc = columns ();
 
   if (user_pref.do_fortran_indexing)
     fortran_style_matrix_assignment (rhs, i_arg);
   else if (nr <= 1 || nc <= 1)
     vector_assignment (rhs, i_arg);
   else
-    error ("single index only valid for row or column vector");
+    ::error ("single index only valid for row or column vector");
 }
 
 void
 tree_constant_rep::fortran_style_matrix_assignment (tree_constant& rhs,
 						    tree_constant& i_arg)
 {
   tree_constant tmp_i = i_arg.make_numeric_or_magic ();
 
@@ -260,17 +260,17 @@ tree_constant_rep::fortran_style_matrix_
 	else if (range_max_check (i-1, nr * nc) < 0)
 	  return;
 
 	nr = rows ();
 	nc = columns ();
 
 	if (! indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
 	  {
-	    error ("for A(int) = X: X must be a scalar");
+	    ::error ("for A(int) = X: X must be a scalar");
 	    return;
 	  }
 	int ii = fortran_row (i, nr) - 1;
 	int jj = fortran_column (i, nr) - 1;
 	do_matrix_assignment (rhs, ii, jj);
       }
       break;
     case complex_matrix_constant:
@@ -288,18 +288,18 @@ tree_constant_rep::fortran_style_matrix_
 	    if (error_state)
 	      return;
 	  }
 	else if (range_max_check (ii.max () - 1, len) < 0)
 	  return;
 
 	if (ii.capacity () != rhs_nr * rhs_nc)
 	  {
-	    error ("A(matrix) = X: X and matrix must have the same number");
-	    error ("of elements"); 
+	    ::error ("A(matrix) = X: X and matrix must have the same number");
+	    ::error ("of elements"); 
 	    return;
 	  }
 	fortran_style_matrix_assignment (rhs, ii);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
       break;
@@ -376,17 +376,17 @@ tree_constant_rep::vector_assignment (tr
       break;
     case magic_colon:
       {
 	int rhs_nr = rhs.rows ();
 	int rhs_nc = rhs.columns ();
 
 	if (! indexed_assign_conforms (nr, nc, rhs_nr, rhs_nc))
 	  {
-	    error ("A(:) = X: X and A must have the same dimensions");
+	    ::error ("A(:) = X: X and A must have the same dimensions");
 	    return;
 	  }
 	do_matrix_assignment (rhs, magic_colon, magic_colon);
       }
       break;
     default:
       panic_impossible ();
       break;
@@ -399,34 +399,34 @@ tree_constant_rep::check_vector_assign (
 {
   int nr = rows ();
   int nc = columns ();
 
   if ((nr == 1 && nc == 1) || nr == 0 || nc == 0)  // No orientation.
     {
       if (! (ilen == rhs_nr || ilen == rhs_nc))
 	{
-	  error ("A(%s) = X: X and %s must have the same number of elements",
+	  ::error ("A(%s) = X: X and %s must have the same number of elements",
 		 rm, rm);
 	}
     }
   else if (nr == 1)  // Preserve current row orientation.
     {
       if (! (rhs_nr == 1 && rhs_nc == ilen))
 	{
-	  error ("A(%s) = X: where A is a row vector, X must also be a", rm);
-	  error ("row vector with the same number of elements as %s", rm);
+	  ::error ("A(%s) = X: where A is a row vector, X must also be a", rm);
+	  ::error ("row vector with the same number of elements as %s", rm);
 	}
     }
   else if (nc == 1)  // Preserve current column orientation.
     {
       if (! (rhs_nc == 1 && rhs_nr == ilen))
 	{
-	  error ("A(%s) = X: where A is a column vector, X must also be", rm);
-	  error ("a column vector with the same number of elements as %s", rm);
+	  ::error ("A(%s) = X: where A is a column vector, X must also be", rm);
+	  ::error ("a column vector with the same number of elements as %s", rm);
 	}
     }
   else
     panic_impossible ();
 }
 
 void
 tree_constant_rep::do_vector_assign (tree_constant& rhs, int i)
@@ -460,47 +460,47 @@ tree_constant_rep::do_vector_assign (tre
     {
       int nr = rows ();
       int nc = columns ();
 
       int len = nr > nc ? nr : nc;
 
       if (i < 0 || i >= len)
 	{
-	  error ("A(int) = []: index out of range");
+	  ::error ("A(int) = []: index out of range");
 	  return;
 	}
 
       if (nr == 1)
 	delete_column (i);
       else if (nc == 1)
 	delete_row (i);
       else
 	panic_impossible ();
     }
   else
     {
-      error ("for A(int) = X: X must be a scalar");
+      ::error ("for A(int) = X: X must be a scalar");
       return;
     }
 }
 
 void
 tree_constant_rep::do_vector_assign (tree_constant& rhs, idx_vector& iv)
 {
   if (rhs.is_zero_by_zero ())
     {
       int nr = rows ();
       int nc = columns ();
 
       int len = nr > nc ? nr : nc;
 
       if (iv.max () >= len)
 	{
-	  error ("A(matrix) = []: index out of range");
+	  ::error ("A(matrix) = []: index out of range");
 	  return;
 	}
 
       if (nr == 1)
 	delete_columns (iv);
       else if (nc == 1)
 	delete_rows (iv);
       else
@@ -554,17 +554,17 @@ tree_constant_rep::do_vector_assign (tre
       int nc = columns ();
 
       int len = nr > nc ? nr : nc;
 
       int b = tree_to_mat_idx (ri.min ());
       int l = tree_to_mat_idx (ri.max ());
       if (b < 0 || l >= len)
 	{
-	  error ("A(range) = []: index out of range");
+	  ::error ("A(range) = []: index out of range");
 	  return;
 	}
 
       if (nr == 1)
 	delete_columns (ri);
       else if (nc == 1)
 	delete_rows (ri);
       else
@@ -641,17 +641,17 @@ tree_constant_rep::fortran_style_matrix_
 	  matrix = new Matrix (0, 0);
 	  return;
 	}
       else
 	panic_impossible ();
     }
   else if (nr*nc != rhs_size)
     {
-      error ("A(:) = X: X and A must have the same number of elements");
+      ::error ("A(:) = X: X and A must have the same number of elements");
       return;
     }
 
   if (rhs.const_type () == matrix_constant)
     {
       double *cop_out = rhs_m.fortran_vec ();
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
@@ -700,17 +700,17 @@ tree_constant_rep::fortran_style_matrix_
 	      int ii = fortran_row (i.elem (k) + 1, nr) - 1;
 	      int jj = fortran_column (i.elem (k) + 1, nr) - 1;
 
 	      complex_matrix->elem (ii, jj) = *cop_out++;
 	    }
 	}
     }
   else
-    error ("number of rows and columns must match for indexed assignment");
+    ::error ("number of rows and columns must match for indexed assignment");
 }
 
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
 					 tree_constant& i_arg, 
 					 tree_constant& j_arg)
 {
   tree_constant tmp_i = i_arg.make_numeric_or_range_or_magic ();
@@ -787,17 +787,17 @@ tree_constant_rep::do_matrix_assignment 
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
 	if (index_check (j, "column") < 0)
 	  return;
 	if (! indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
 	  {
-	    error ("A(int,int) = X, X must be a scalar");
+	    ::error ("A(int,int) = X, X must be a scalar");
 	    return;
 	  }
 	maybe_resize (i, j);
 	if (error_state)
 	  return;
 
 	do_matrix_assignment (rhs, i, j);
       }
@@ -808,18 +808,18 @@ tree_constant_rep::do_matrix_assignment 
 	Matrix mj = tmp_j.matrix_value ();
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
 	if (! jv)
 	  return;
 
 	if (! indexed_assign_conforms (1, jv.capacity (), rhs_nr, rhs_nc))
 	  {
-	    error ("A(int,matrix) = X: X must be a row vector with the same");
-	    error ("number of elements as matrix"); 
+	    ::error ("A(int,matrix) = X: X must be a row vector with the same");
+	    ::error ("number of elements as matrix"); 
 	    return;
 	  }
 	maybe_resize (i, jv.max ());
 	if (error_state)
 	  return;
 
 	do_matrix_assignment (rhs, i, jv);
       }
@@ -827,18 +827,18 @@ tree_constant_rep::do_matrix_assignment 
     case string_constant:
       gripe_string_invalid ();
       break;
     case range_constant:
       {
 	Range rj = tmp_j.range_value ();
 	if (! indexed_assign_conforms (1, rj.nelem (), rhs_nr, rhs_nc))
 	  {
-	    error ("A(int,range) = X: X must be a row vector with the same");
-	    error ("number of elements as range"); 
+	    ::error ("A(int,range) = X: X must be a row vector with the same");
+	    ::error ("number of elements as range"); 
 	    return;
 	  }
 
 	int nc = columns ();
 	if (nc == 2 && is_zero_one (rj) && rhs_nc == 1)
 	  {
 	    do_matrix_assignment (rhs, i, 1);
 	  }
@@ -883,24 +883,24 @@ tree_constant_rep::do_matrix_assignment 
 	    maybe_resize (i, nc-1);
 	    if (error_state)
 	      return;
 	  }
 	else if (rhs_nr == 0 && rhs_nc == 0)
 	  {
 	    if (i < 0 || i >= nr)
 	      {
-		error ("A(int,:) = []: row index out of range");
+		::error ("A(int,:) = []: row index out of range");
 		return;
 	      }
 	  }
 	else
 	  {
-	    error ("A(int,:) = X: X must be a row vector with the same");
-	    error ("number of columns as A"); 
+	    ::error ("A(int,:) = X: X must be a row vector with the same");
+	    ::error ("number of columns as A"); 
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, i, magic_colon);
       }
       break;
     default:
       panic_impossible ();
@@ -924,18 +924,18 @@ tree_constant_rep::do_matrix_assignment 
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
 	if (index_check (j, "column") < 0)
 	  return;
 	if (! indexed_assign_conforms (iv.capacity (), 1, rhs_nr, rhs_nc))
 	  {
-	    error ("A(matrix,int) = X: X must be a column vector with the");
-	    error ("same number of elements as matrix");  
+	    ::error ("A(matrix,int) = X: X must be a column vector with the");
+	    ::error ("same number of elements as matrix");  
 	    return;
 	  }
 	maybe_resize (iv.max (), j);
 	if (error_state)
 	  return;
 
 	do_matrix_assignment (rhs, iv, j);
       }
@@ -947,19 +947,19 @@ tree_constant_rep::do_matrix_assignment 
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
 	if (! jv)
 	  return;
 
 	if (! indexed_assign_conforms (iv.capacity (), jv.capacity (),
 				       rhs_nr, rhs_nc))
 	  {
-	    error ("A(r_mat,c_mat) = X: the number of rows in X must match");
-	    error ("the number of elements in r_mat and the number of");
-	    error ("columns in X must match the number of elements in c_mat");
+	    ::error ("A(r_mat,c_mat) = X: the number of rows in X must match");
+	    ::error ("the number of elements in r_mat and the number of");
+	    ::error ("columns in X must match the number of elements in c_mat");
 	    return;
 	  }
 	maybe_resize (iv.max (), jv.max ());
 	if (error_state)
 	  return;
 
 	do_matrix_assignment (rhs, iv, jv);
       }
@@ -968,19 +968,19 @@ tree_constant_rep::do_matrix_assignment 
       gripe_string_invalid ();
       break;
     case range_constant:
       {
 	Range rj = tmp_j.range_value ();
 	if (! indexed_assign_conforms (iv.capacity (), rj.nelem (),
 				       rhs_nr, rhs_nc))
 	  {
-	    error ("A(matrix,range) = X: the number of rows in X must match");
-	    error ("the number of elements in matrix and the number of");
-	    error ("columns in X must match the number of elements in range");
+	    ::error ("A(matrix,range) = X: the number of rows in X must match");
+	    ::error ("the number of elements in matrix and the number of");
+	    ::error ("columns in X must match the number of elements in range");
 	    return;
 	  }
 
 	int nc = columns ();
 	if (nc == 2 && is_zero_one (rj) && rhs_nc == 1)
 	  {
 	    do_matrix_assignment (rhs, iv, 1);
 	  }
@@ -1013,25 +1013,25 @@ tree_constant_rep::do_matrix_assignment 
 	    maybe_resize (iv.max (), new_nc-1);
 	    if (error_state)
 	      return;
 	  }
 	else if (rhs_nr == 0 && rhs_nc == 0)
 	  {
 	    if (iv.max () >= rows ())
 	      {
-		error ("A(matrix,:) = []: row index out of range");
+		::error ("A(matrix,:) = []: row index out of range");
 		return;
 	      }
 	  }
 	else
 	  {
-	    error ("A(matrix,:) = X: the number of rows in X must match the");
-	    error ("number of elements in matrix, and the number of columns");
-	    error ("in X must match the number of columns in A");
+	    ::error ("A(matrix,:) = X: the number of rows in X must match the");
+	    ::error ("number of elements in matrix, and the number of columns");
+	    ::error ("in X must match the number of columns in A");
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, iv, magic_colon);
       }
       break;
     default:
       panic_impossible ();
@@ -1055,18 +1055,18 @@ tree_constant_rep::do_matrix_assignment 
     case complex_scalar_constant:
     case scalar_constant:
       {
 	int j = tree_to_mat_idx (tmp_j.double_value ());
 	if (index_check (j, "column") < 0)
 	  return;
 	if (! indexed_assign_conforms (ri.nelem (), 1, rhs_nr, rhs_nc))
 	  {
-	    error ("A(range,int) = X: X must be a column vector with the");
-	    error ("same number of elements as range");
+	    ::error ("A(range,int) = X: X must be a column vector with the");
+	    ::error ("same number of elements as range");
 	    return;
 	  }
 	maybe_resize (tree_to_mat_idx (ri.max ()), j);
 	if (error_state)
 	  return;
 
 	do_matrix_assignment (rhs, ri, j);
       }
@@ -1078,19 +1078,19 @@ tree_constant_rep::do_matrix_assignment 
 	idx_vector jv (mj, user_pref.do_fortran_indexing, "column",
 		       columns ());
 	if (! jv)
 	  return;
 
 	if (! indexed_assign_conforms (ri.nelem (), jv.capacity (),
 				       rhs_nr, rhs_nc))
 	  {
-	    error ("A(range,matrix) = X: the number of rows in X must match");
-	    error ("the number of elements in range and the number of");
-	    error ("columns in X must match the number of elements in matrix");
+	    ::error ("A(range,matrix) = X: the number of rows in X must match");
+	    ::error ("the number of elements in range and the number of");
+	    ::error ("columns in X must match the number of elements in matrix");
 	    return;
 	  }
 	maybe_resize (tree_to_mat_idx (ri.max ()), jv.max ());
 	if (error_state)
 	  return;
 
 	do_matrix_assignment (rhs, ri, jv);
       }
@@ -1099,20 +1099,20 @@ tree_constant_rep::do_matrix_assignment 
       gripe_string_invalid ();
       break;
     case range_constant:
       {
 	Range rj = tmp_j.range_value ();
 	if (! indexed_assign_conforms (ri.nelem (), rj.nelem (),
 				       rhs_nr, rhs_nc))
 	  {
-	    error ("A(r_range,c_range) = X: the number of rows in X must");
-	    error ("match the number of elements in r_range and the number");
-	    error ("of columns in X must match the number of elements in");
-	    error ("c_range");
+	    ::error ("A(r_range,c_range) = X: the number of rows in X must");
+	    ::error ("match the number of elements in r_range and the number");
+	    ::error ("of columns in X must match the number of elements in");
+	    ::error ("c_range");
 	    return;
 	  }
 
 	int nc = columns ();
 	if (nc == 2 && is_zero_one (rj) && rhs_nc == 1)
 	  {
 	    do_matrix_assignment (rhs, ri, 1);
 	  }
@@ -1149,25 +1149,25 @@ tree_constant_rep::do_matrix_assignment 
 	      return;
 	  }
 	else if (rhs_nr == 0 && rhs_nc == 0)
 	  {
 	    int b = tree_to_mat_idx (ri.min ());
 	    int l = tree_to_mat_idx (ri.max ());
 	    if (b < 0 || l >= rows ())
 	      {
-		error ("A(range,:) = []: row index out of range");
+		::error ("A(range,:) = []: row index out of range");
 		return;
 	      }
 	  }
 	else
 	  {
-	    error ("A(range,:) = X: the number of rows in X must match the");
-	    error ("number of elements in range, and the number of columns");
-	    error ("in X must match the number of columns in A");  
+	    ::error ("A(range,:) = X: the number of rows in X must match the");
+	    ::error ("number of elements in range, and the number of columns");
+	    ::error ("in X must match the number of columns in A");  
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, ri, magic_colon);
       }
       break;
     default:
       panic_impossible ();
@@ -1218,24 +1218,24 @@ tree_constant_rep::do_matrix_assignment 
 	    maybe_resize (nr-1, j);
 	    if (error_state)
 	      return;
 	  }
 	else if (rhs_nr == 0 && rhs_nc == 0)
 	  {
 	    if (j < 0 || j >= nc)
 	      {
-		error ("A(:,int) = []: column index out of range");
+		::error ("A(:,int) = []: column index out of range");
 		return;
 	      }
 	  }
 	else
 	  {
-	    error ("A(:,int) = X: X must be a column vector with the same");
-	    error ("number of rows as A"); 
+	    ::error ("A(:,int) = X: X must be a column vector with the same");
+	    ::error ("number of rows as A"); 
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, magic_colon, j);
       }
       break;
     case complex_matrix_constant:
     case matrix_constant:
@@ -1257,25 +1257,25 @@ tree_constant_rep::do_matrix_assignment 
 	    maybe_resize (new_nr-1, jv.max ());
 	    if (error_state)
 	      return;
 	  }
 	else if (rhs_nr == 0 && rhs_nc == 0)
 	  {
 	    if (jv.max () >= columns ())
 	      {
-		error ("A(:,matrix) = []: column index out of range");
+		::error ("A(:,matrix) = []: column index out of range");
 		return;
 	      }
 	  }
 	else
 	  {
-	    error ("A(:,matrix) = X: the number of rows in X must match the");
-	    error ("number of rows in A, and the number of columns in X must");
-	    error ("match the number of elements in matrix");   
+	    ::error ("A(:,matrix) = X: the number of rows in X must match the");
+	    ::error ("number of rows in A, and the number of columns in X must");
+	    ::error ("match the number of elements in matrix");   
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, magic_colon, jv);
       }
       break;
     case string_constant:
       gripe_string_invalid ();
@@ -1309,25 +1309,25 @@ tree_constant_rep::do_matrix_assignment 
 	      }
 	  }
 	else if (rhs_nr == 0 && rhs_nc == 0)
 	  {
 	    int b = tree_to_mat_idx (rj.min ());
 	    int l = tree_to_mat_idx (rj.max ());
 	    if (b < 0 || l >= columns ())
 	      {
-		error ("A(:,range) = []: column index out of range");
+		::error ("A(:,range) = []: column index out of range");
 		return;
 	      }
 	  }
 	else
 	  {
-	    error ("A(:,range) = X: the number of rows in X must match the");
-	    error ("number of rows in A, and the number of columns in X");
-	    error ("must match the number of elements in range");
+	    ::error ("A(:,range) = X: the number of rows in X must match the");
+	    ::error ("number of rows in A, and the number of columns in X");
+	    ::error ("must match the number of elements in range");
 	    return;
 	  }
 
 	do_matrix_assignment (rhs, magic_colon, rj);
       }
       break;
     case magic_colon:
 // a(:,:) = foo is equivalent to a = foo.
diff --git a/src/tc-extras.cc b/src/tc-extras.cc
--- a/src/tc-extras.cc
+++ b/src/tc-extras.cc
@@ -17,18 +17,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <strstream.h>
 #include <iostream.h>
 #include <fstream.h>
 #include <string.h>
 #include <ctype.h>
 
diff --git a/src/tc-index.cc b/src/tc-index.cc
--- a/src/tc-index.cc
+++ b/src/tc-index.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include "idx-vector.h"
 #include "user-prefs.h"
 #include "tree-const.h"
 #include "utils.h"
 #include "gripes.h"
 #include "error.h"
@@ -131,54 +131,54 @@ tree_constant_rep::do_scalar_index (cons
 		ComplexMatrix cm (rows, cols, *complex_scalar);
 		return tree_constant (cm);
 	      }
 	    else
 	      panic_impossible ();
 	  }
 	  break;
 	default:
-	  error ("illegal number of arguments for scalar type");
+	  ::error ("illegal number of arguments for scalar type");
 	  return tree_constant ();
 	  break;
 	}
     }
 
-  error ("index invalid or out of range for scalar type");
+  ::error ("index invalid or out of range for scalar type");
   return tree_constant ();
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (const tree_constant *args,
 				    int nargin) const
 {
   tree_constant retval;
 
   switch (nargin)
     {
     case 2:
       if (args == NULL_TREE_CONST)
-	error ("matrix index is null");
+	::error ("matrix index is null");
       else if (args[1].is_undefined ())
-	error ("matrix index is a null expression");
+	::error ("matrix index is a null expression");
       else
 	retval = do_matrix_index (args[1]);
       break;
     case 3:
       if (args == NULL_TREE_CONST)
-	error ("matrix indices are null");
+	::error ("matrix indices are null");
       else if (args[1].is_undefined ())
-	error ("first matrix index is a null expression");
+	::error ("first matrix index is a null expression");
       else if (args[2].is_undefined ())
-	error ("second matrix index is a null expression");
+	::error ("second matrix index is a null expression");
       else
 	retval = do_matrix_index (args[1], args[2]);
       break;
     default:
-      error ("too many indices for matrix expression");
+      ::error ("too many indices for matrix expression");
       break;
     }
 
   return  retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (const tree_constant& i_arg) const
@@ -188,17 +188,17 @@ tree_constant_rep::do_matrix_index (cons
   int nr = rows ();
   int nc = columns ();
 
   if (user_pref.do_fortran_indexing)
     retval = fortran_style_matrix_index (i_arg);
   else if (nr <= 1 || nc <= 1)
     retval = do_vector_index (i_arg);
   else
-    error ("single index only valid for row or column vector");
+    ::error ("single index only valid for row or column vector");
 
   return retval;
 }
 
 tree_constant
 tree_constant_rep::fortran_style_matrix_index
   (const tree_constant& i_arg) const
 {
@@ -271,25 +271,25 @@ tree_constant_rep::fortran_style_matrix_
 
   int len = nr * nc;
 
   int index_nr = mi.rows ();
   int index_nc = mi.columns ();
 
   if (index_nr >= 1 && index_nc >= 1)
     {
-      double *cop_out = (double *) NULL;
-      Complex *c_cop_out = (Complex *) NULL;
+      const double *cop_out = (const double *) NULL;
+      const Complex *c_cop_out = (const Complex *) NULL;
       int real_type = type_tag == matrix_constant;
       if (real_type)
-	cop_out = matrix->fortran_vec ();
+	cop_out = matrix->data ();
       else
-	c_cop_out = complex_matrix->fortran_vec ();
+	c_cop_out = complex_matrix->data ();
 
-      double *cop_out_index = mi.fortran_vec ();
+      const double *cop_out_index = mi.data ();
 
       idx_vector iv (mi, 1, "", len);
       if (! iv)
 	return tree_constant ();
 
       int result_size = iv.length ();
 
       if (columns () == 1 || iv.one_zero_only ())
@@ -332,19 +332,19 @@ tree_constant_rep::fortran_style_matrix_
 	      }
 
 	  ASSIGN_CRMATRIX_TO (retval, m, cm);
 	}
     }
   else
     {
       if (index_nr == 0 || index_nc == 0)
-	error ("empty matrix invalid as index");
+	::error ("empty matrix invalid as index");
       else
-	error ("invalid matrix index");
+	::error ("invalid matrix index");
       return tree_constant ();
     }
 
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_vector_index (const tree_constant& i_arg) const
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <assert.h>
 
 #include "token.h"
 #include "utils.h"
 #include "symtab.h"
 
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_token_h)
 #define _token_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class symbol_record;
 
 class token
 {
 public:
   enum token_type
     {
       generic_token,
diff --git a/src/tree.h.old b/src/tree.h.old
--- a/src/tree.h.old
+++ b/src/tree.h.old
@@ -19,23 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_tree_h)
 #define _tree_h 1
 
-// This seems to leave vt$tree undefined with g++ 2.3.3.
-#if 0
-#ifdef __GNUG__
-#pragma interface
-#endif
-#endif
-
 #include <stdio.h>
 
 class ostrstream;
 
 #include "builtins.h"
 #include "tree-base.h"
 #include "tree-const.h"
 
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -16,51 +16,30 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <stddef.h>
 
 #include "SLStack.h"
 
 #include "Matrix.h"
 
 #include "unwind-prot.h"
 #include "error.h"
 #include "utils.h"
 
-class unwind_elem
-{
- public:
-  unwind_elem (void);
-  unwind_elem (char *t);
-  unwind_elem (cleanup_func f, void *p);
-  unwind_elem (const unwind_elem& el);
-  ~unwind_elem (void);
-
-  unwind_elem& operator = (const unwind_elem& el);
-
-  char *tag (void);
-  cleanup_func fptr (void);
-  void *ptr (void);
-
- private:
-  char *_tag;
-  cleanup_func _fptr;
-  void *_ptr;
-};
-
 unwind_elem::unwind_elem (void)
 {
   _tag = (char *) NULL;
   _fptr = (cleanup_func) NULL;
   _ptr = (void *) NULL;
 }
 
 unwind_elem::unwind_elem (char *t)
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_unwind_prot_h)
 #define _unwind_prot_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 typedef void (*cleanup_func)(void *ptr);
 
 void add_unwind_protect (cleanup_func fptr, void *ptr);
 void run_unwind_protect (void);
 void discard_unwind_protect (void);
 void begin_unwind_frame (char *tag);
 void run_unwind_frame (char *tag);
 void discard_unwind_frame (char *tag);
@@ -50,16 +46,37 @@ void unwind_protect_var_internal (void *
   unwind_protect_int_internal (&(i), (i))
 
 #define unwind_protect_ptr(p) \
   unwind_protect_ptr_internal ((void **) &(p), (void *) (p))
 
 #define unwind_protect_var(i) \
   unwind_protect_var_internal ((void *) &(i), (void *) &(i), sizeof (int))
 
+class unwind_elem
+{
+ public:
+  unwind_elem (void);
+  unwind_elem (char *t);
+  unwind_elem (cleanup_func f, void *p);
+  unwind_elem (const unwind_elem& el);
+  ~unwind_elem (void);
+
+  unwind_elem& operator = (const unwind_elem& el);
+
+  char *tag (void);
+  cleanup_func fptr (void);
+  void *ptr (void);
+
+ private:
+  char *_tag;
+  cleanup_func _fptr;
+  void *_ptr;
+};
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/user-prefs.cc b/src/user-prefs.cc
--- a/src/user-prefs.cc
+++ b/src/user-prefs.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <string.h>
 
 #include "user-prefs.h"
 #include "error.h"
 #include "variables.h"
 #include "utils.h"
diff --git a/src/user-prefs.h b/src/user-prefs.h
--- a/src/user-prefs.h
+++ b/src/user-prefs.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_user_prefs_h)
 #define _user_prefs_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 struct user_preferences
 {
   int do_fortran_indexing;
   int empty_list_elements_ok;
   int implicit_str_to_num_ok;
   int ok_to_lose_imaginary_part;
   int prefer_column_vectors;
   int prefer_zero_one_indexing;
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -31,18 +31,18 @@ Free Software Foundation, Inc.
   absolute_program         base_pathname
   read_octal               sub_append_string
   decode_prompt_string     pathname_backup
   make_absolute            get_working_directory
   change_to_directory
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <sys/param.h>
 #include <setjmp.h>
@@ -344,48 +344,58 @@ kbhit (void)
 char **
 pathstring_to_vector (char *pathstring)
 {
   static char **path = (char **) NULL;
 
   if (pathstring != (char *) NULL)
     {
       int nelem = 0;
-      pathstring = strsave (pathstring);
-      if (*pathstring != '\0')
+      char *tmp_path = strsave (pathstring);
+      if (*tmp_path != '\0')
 	{
 	  nelem++;
-	  char *ptr = pathstring;
+	  char *ptr = tmp_path;
 	  while (*ptr != '\0')
 	    {
 	      if (*ptr == ':')
 		nelem++;
 	      ptr++;
 	    }
 	}
 
+// Why do I have to do this?
+
+      char **foo = path;
+      while (foo && *foo)
+	{
+	  delete [] *foo;
+	  *foo = (char *) NULL;
+	  foo++;
+	}
+      
       delete [] path;
       path = new char * [nelem+1];
       path[nelem] = (char *) NULL;
 
       int i = 0;
-      char *ptr = pathstring;
+      char *ptr = tmp_path;
       while (i < nelem)
 	{
 	  char *end = strchr (ptr, ':');
 	  if (end != (char *) NULL)
 	    *end = '\0';
 	  char *result = tilde_expand (ptr);
 	  path[i] = strsave (result);
 	  free (result);
 	  ptr = end + 1;
 	  i++;
 	}
 
-      delete [] pathstring;
+      delete [] tmp_path;
     }
 
   return path;
 }
 
 char *
 octave_home (void)
 {
@@ -528,51 +538,54 @@ default_pager (void)
 }
 
 /*
  * See if the given file is in the path.
  */
 char *
 file_in_path (const char *name, const char *suffix)
 {
+  char *retval = (char *) NULL;
+
   char *nm = strconcat ("/", name);
-  char *tmp = nm;
   if (suffix != (char *) NULL)
     {
+      char *tmp = nm;
       nm = strconcat (tmp, suffix);
       delete [] tmp;
     }
 
-  if (!the_current_working_directory)
+  if (! the_current_working_directory)
     get_working_directory ("file_in_path");
 
   char **path = pathstring_to_vector (user_pref.loadpath);
 
   char **ptr = path;
   if (ptr != (char **) NULL)
     {
       while (*ptr != (char *) NULL)
 	{
-	  char *tmp_p = strconcat (*ptr, nm);
-	  char *p = make_absolute (tmp_p, the_current_working_directory);
-	  delete [] tmp_p;
+	  char *tmp = strconcat (*ptr, nm);
+	  char *p = make_absolute (tmp, the_current_working_directory);
+	  delete [] tmp;
 	  ifstream in_file (p);
 	  if (in_file)
 	    {
 	      in_file.close ();
-	      delete [] nm;
-	      return p;
+	      retval = p;
+	      goto done;
 	    }
 	  delete [] p;
 	  ptr++;
 	}
     }
 
+ done:
   delete [] nm;
-  return (char *) NULL;
+  return retval;
 }
 
 /*
  * See if there is an M-file in the path.  If so, return the full path
  * to the file.
  */
 char *
 m_file_in_path (const char *name)
@@ -585,45 +598,45 @@ m_file_in_path (const char *name)
  * same as $HOME, then replace that with `~'.
  */
 char *
 polite_directory_format (char *name)
 {
   int l = home_directory ? strlen (home_directory) : 0;
 
   if (l > 1 && strncmp (home_directory, name, l) == 0
-      && (!name[l] || name[l] == '/'))
+      && (! name[l] || name[l] == '/'))
     {
       strcpy (tdir + 1, name + l);
       tdir[0] = '~';
       return (tdir);
     }
   else
     return name;
 }
 
 /*
  * Return 1 if STRING contains an absolute pathname, else 0.
  */
 int
 absolute_pathname (const char *string)
 {
-  if (!string || !*string)
+  if (! string || ! *string)
     return 0;
 
   if (*string == '/')
     return 1;
 
   if (*string++ == '.')
     {
-      if ((!*string) || *string == '/')
+      if ((! *string) || *string == '/')
 	return 1;
 
       if (*string++ == '.')
-	if (!*string || *string == '/')
+	if (! *string || *string == '/')
 	  return 1;
     }
   return 0;
 }
 
 /*
  * Return 1 if STRING is an absolute program name; it is absolute if
  * it contains any slashes.  This is used to decide whether or not to
@@ -639,17 +652,17 @@ absolute_program (const char *string)
  * Return the `basename' of the pathname in STRING (the stuff after
  * the last '/').  If STRING is not a full pathname, simply return it.
  */
 char *
 base_pathname (char *string)
 {
   char *p = strrchr (string, '/');
 
-  if (!absolute_pathname (string))
+  if (! absolute_pathname (string))
     return (string);
 
   if (p)
     return (++p);
   else
     return (string);
 }
 
@@ -664,17 +677,17 @@ read_octal (const char *string)
   int digits = 0;
 
   while (*string && *string >= '0' && *string < '8')
     {
       digits++;
       result = (result * 8) + *string++ - '0';
     }
 
-  if (!digits || result > 0777 || *string)
+  if (! digits || result > 0777 || *string)
     result = -1;
 
   return result;
 }
 
 /*
  * Append SOURCE to TARGET at INDEX.  SIZE is the current amount of
  * space allocated to TARGET.  SOURCE can be NULL, in which case
@@ -781,17 +794,17 @@ decode_prompt_string (const char *string
 		  }
 		else
 		  temp[10] = '\0';
 
 		goto add_string;
 	      }
 
 	    case 'n':
-	      if (!no_line_editing)
+	      if (! no_line_editing)
 		temp = strsave ("\r\n");
 	      else
 		temp = strsave ("\n");
 	      goto add_string;
 
 	    case 's':
 	      {
 		temp = base_pathname (prog_name);
@@ -805,17 +818,17 @@ decode_prompt_string (const char *string
 		char t_string[MAXPATHLEN];
 #define EFFICIENT
 #ifdef EFFICIENT
 
 // Use the value of PWD because it is much more effecient.
 
 		temp = user_pref.pwd;
 
-		if (!temp)
+		if (! temp)
 		  getcwd (t_string, MAXPATHLEN);
 		else
 		  strcpy (t_string, temp);
 #else
 		getcwd (t_string, MAXPATHLEN);
 #endif	/* EFFICIENT */
 
 		if (c == 'W')
@@ -902,17 +915,17 @@ decode_prompt_string (const char *string
 	    }
 	  result[result_index++] = c;
 	  result[result_index] = '\0';
 	}
     }
 
 #if 0
   /* I don't really think that this is a good idea.  Do you? */
-  if (!find_variable ("NO_PROMPT_VARS"))
+  if (! find_variable ("NO_PROMPT_VARS"))
     {
       WORD_LIST *expand_string (), *list;
       char *string_list ();
 
       list = expand_string (result, 1);
       free (result);
       result = string_list (list);
       dispose_words (list);
@@ -926,17 +939,17 @@ decode_prompt_string (const char *string
  * Remove the last N directories from PATH.  Do not PATH blank.
  * PATH must contain enough space for MAXPATHLEN characters.
  */
 void
 pathname_backup (char *path, int n)
 {
   register char *p;
 
-  if (!*path)
+  if (! *path)
     return;
 
   p = path + (strlen (path) - 1);
 
   while (n--)
     {
       while (*p == '/' && p != path)
 	p--;
@@ -955,45 +968,45 @@ pathname_backup (char *path, int n)
  * begin with.
  */
 char *
 make_absolute (const char *string, const char *dot_path)
 {
   static char current_path[MAXPATHLEN];
   register char *cp;
 
-  if (!dot_path || *string == '/')
+  if (! dot_path || *string == '/')
     return strsave (string);
 
   strcpy (current_path, dot_path);
 
-  if (!current_path[0])
+  if (! current_path[0])
     strcpy (current_path, "./");
 
   cp = current_path + (strlen (current_path) - 1);
 
   if (*cp++ != '/')
     *cp++ = '/';
 
   *cp = '\0';
 
   while (*string)
     {
       if (*string == '.')
 	{
-	  if (!string[1])
+	  if (! string[1])
 	    return strsave (current_path);
 
 	  if (string[1] == '/')
 	    {
 	      string += 2;
 	      continue;
 	    }
 
-	  if (string[1] == '.' && (string[2] == '/' || !string[2]))
+	  if (string[1] == '.' && (string[2] == '/' || ! string[2]))
 	    {
 	      string += 2;
 
 	      if (*string)
 		string++;
 
 	      pathname_backup (current_path, 1);
 	      cp = current_path + strlen (current_path);
@@ -1014,31 +1027,31 @@ make_absolute (const char *string, const
 
 /*
  * Return a consed string which is the current working directory.
  * FOR_WHOM is the name of the caller for error printing.
  */ 
 char *
 get_working_directory (const char *for_whom)
 {
-  if (!follow_symbolic_links)
+  if (! follow_symbolic_links)
     {
       if (the_current_working_directory)
 	delete [] the_current_working_directory;
 
       the_current_working_directory = (char *)NULL;
     }
 
-  if (!the_current_working_directory)
+  if (! the_current_working_directory)
     {
       char *directory;
 
       the_current_working_directory = new char [MAXPATHLEN];
       directory = getcwd (the_current_working_directory, MAXPATHLEN);
-      if (!directory)
+      if (! directory)
 	{
 	  message (for_whom, the_current_working_directory);
 	  delete [] the_current_working_directory;
 	  the_current_working_directory = (char *)NULL;
 	  return (char *)NULL;
 	}
     }
 
@@ -1051,17 +1064,17 @@ get_working_directory (const char *for_w
  */ 
 int
 change_to_directory (const char *newdir)
 {
   char *t;
 
   if (follow_symbolic_links)
     {
-      if (!the_current_working_directory)
+      if (! the_current_working_directory)
 	get_working_directory ("cd_links");
 
       if (the_current_working_directory)
 	t = make_absolute (newdir, the_current_working_directory);
       else
 	t = strsave (newdir);
 
       /* Get rid of trailing `/'. */
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_utils_h)
 #define _utils_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 #include <time.h>
 
 class istream;
 class ostrstream;
 class tree_constant;
 
 // Tell g++ that jump_to_top_level doesn't return;
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <ctype.h>
 #include <iostream.h>
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_variables_h)
 #define _variables_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class istream;
 class symbol_record;
 class symbol_table;
 class tree;
 class tree_constant;
 
 struct builtin_mapper_functions;
 struct builtin_text_functions;
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <assert.h>
 #include <Complex.h>
 
 #include "xdiv.h"
 #include "Matrix.h"
 #include "tree-const.h"
diff --git a/src/xdiv.h b/src/xdiv.h
--- a/src/xdiv.h
+++ b/src/xdiv.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_xdiv_h)
 #define _xdiv_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class Complex;
 class Matrix;
 class ComplexMatrix;
 class tree_constant;
 
 extern tree_constant xdiv (const Matrix& a, const Matrix& b);
 extern tree_constant xdiv (const Matrix& a, const ComplexMatrix& b);
 extern tree_constant xdiv (const ComplexMatrix& a, const Matrix& b);
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -16,18 +16,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#ifdef __GNUG__
-#pragma implementation
+#ifdef HAVE_CONFIG_H
+#include "config.h"
 #endif
 
 #include <assert.h>
 #include <Complex.h>
 
 #include "xpow.h"
 #include "Matrix.h"
 #include "tree-const.h"
diff --git a/src/xpow.h b/src/xpow.h
--- a/src/xpow.h
+++ b/src/xpow.h
@@ -19,20 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (_xpow_h)
 #define _xpow_h 1
 
-#ifdef __GNUG__
-#pragma interface
-#endif
-
 class Complex;
 class Matrix;
 class ComplexMatrix;
 class tree_constant;
 
 extern tree_constant xpow (double a, double b);
 extern tree_constant xpow (double a, const Matrix& b);
 extern tree_constant xpow (double a, const Complex& b);
