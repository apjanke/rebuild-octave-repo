# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449258789 18000
#      Fri Dec 04 14:53:09 2015 -0500
# Node ID 2d6ddb2b157c2ccafe6efc1a08c825973c75008e
# Parent  a6eaedd8bd7548d4a495019f85c4337153d8ef8c
eliminate return statements after calls to print_usage

* file-io.cc, mappers.cc:
Eliminate return statements after calls to print_usage.

diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -239,50 +239,40 @@ Close the file specified by the file des
 \n\
 If successful, @code{fclose} returns 0, otherwise, it returns -1.  The\n\
 second form of the @code{fclose} call closes all open files except\n\
 @code{stdin}, @code{stdout}, @code{stderr}, and any FIDs associated\n\
 with gnuplot.\n\
 @seealso{fopen, fflush, freport}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    retval = octave_stream_list::remove (args(0), "fclose");
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (octave_stream_list::remove (args(0), "fclose"));
 }
 
 DEFUN (fclear, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fclear (@var{fid})\n\
 Clear the stream state for the file specified by the file descriptor\n\
 @var{fid}.\n\
 @seealso{ferror, fopen}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    {
-      int fid = octave_stream_list::get_file_number (args(0));
+  if (args.length () != 1)
+    print_usage ();
 
-      octave_stream os = octave_stream_list::lookup (fid, "fclear");
+  int fid = octave_stream_list::get_file_number (args(0));
 
-      os.clearerr ();
-    }
-  else
-    print_usage ();
+  octave_stream os = octave_stream_list::lookup (fid, "fclear");
+
+  os.clearerr ();
 
   return retval;
 }
 
 DEFUN (fflush, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fflush (@var{fid})\n\
 Flush output to file descriptor @var{fid}.\n\
@@ -294,39 +284,35 @@ Programming Note: Flushing is useful for
 makes it to the screen before some other event occurs.  For example, it is\n\
 always a good idea to flush the standard output stream before calling\n\
 @code{input}.\n\
 @seealso{fopen, fclose}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
-  int nargin = args.length ();
+  if (args.length () != 1)
+    print_usage ();
 
-  if (nargin == 1)
-    {
-      // FIXME: any way to avoid special case for stdout?
-
-      int fid = octave_stream_list::get_file_number (args(0));
+  // FIXME: any way to avoid special case for stdout?
 
-      if (fid == 1)
-        {
-          flush_octave_stdout ();
+  int fid = octave_stream_list::get_file_number (args(0));
 
-          retval = 0;
-        }
-      else
-        {
-          octave_stream os = octave_stream_list::lookup (fid, "fflush");
+  if (fid == 1)
+    {
+      flush_octave_stdout ();
 
-          retval = os.flush ();
-        }
+      retval = 0;
     }
   else
-    print_usage ();
+    {
+      octave_stream os = octave_stream_list::lookup (fid, "fflush");
+
+      retval = os.flush ();
+    }
 
   return retval;
 }
 
 DEFUN (fgetl, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{str} =} fgetl (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{str} =} fgetl (@var{fid}, @var{len})\n\
@@ -343,39 +329,37 @@ If there are no more characters to read,
 To read a line and return the terminating newline see @code{fgets}.\n\
 @seealso{fgets, fscanf, fread, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fgetl";
 
   octave_value_list retval;
 
+  int nargin = args.length ();
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
   retval(1) = 0;
   retval(0) = -1;
 
-  int nargin = args.length ();
+  octave_stream os = octave_stream_list::lookup (args(0), who);
 
-  if (nargin == 1 || nargin == 2)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), who);
+  octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
-      octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
-
-      bool err = false;
+  bool err = false;
 
-      std::string tmp = os.getl (len_arg, err, who);
+  std::string tmp = os.getl (len_arg, err, who);
 
-      if (! err)
-        {
-          retval(1) = tmp.length ();
-          retval(0) = tmp;
-        }
+  if (! err)
+    {
+      retval(1) = tmp.length ();
+      retval(0) = tmp;
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (fgets, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{str} =} fgets (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{str} =} fgets (@var{fid}, @var{len})\n\
@@ -392,39 +376,37 @@ If there are no more characters to read,
 To read a line and discard the terminating newline see @code{fgetl}.\n\
 @seealso{fputs, fgetl, fscanf, fread, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fgets";
 
   octave_value_list retval;
 
+  int nargin = args.length ();
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
   retval(1) = 0.0;
   retval(0) = -1.0;
 
-  int nargin = args.length ();
+  octave_stream os = octave_stream_list::lookup (args(0), who);
 
-  if (nargin == 1 || nargin == 2)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), who);
+  octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
-      octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
-
-      bool err = false;
+  bool err = false;
 
-      std::string tmp = os.gets (len_arg, err, who);
+  std::string tmp = os.gets (len_arg, err, who);
 
-      if (! err)
-        {
-          retval(1) = tmp.length ();
-          retval(0) = tmp;
-        }
+  if (! err)
+    {
+      retval(1) = tmp.length ();
+      retval(0) = tmp;
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (fskipl, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{nlines} =} fskipl (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{nlines} =} fskipl (@var{fid}, @var{count})\n\
@@ -444,31 +426,29 @@ Returns the number of lines skipped (end
 @end deftypefn")
 {
   static std::string who = "fskipl";
 
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), who);
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
 
-      octave_value count_arg = (nargin == 2) ? args(1) : octave_value ();
+  octave_stream os = octave_stream_list::lookup (args(0), who);
 
-      bool err = false;
+  octave_value count_arg = (nargin == 2) ? args(1) : octave_value ();
 
-      off_t tmp = os.skipl (count_arg, err, who);
+  bool err = false;
 
-      if (! err)
-        retval = tmp;
-    }
-  else
-    print_usage ();
+  off_t tmp = os.skipl (count_arg, err, who);
+
+  if (! err)
+    retval = tmp;
 
   return retval;
 }
 
 
 static octave_stream
 do_stream_open (const std::string& name, const std::string& mode_arg,
                 const std::string& arch, int& fid)
@@ -752,26 +732,22 @@ descriptor @var{fid}.\n\
 is equivalent to @code{fseek (@var{fid}, 0, SEEK_SET)}.\n\
 @seealso{fseek, ftell, fopen}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int result = -1;
 
-  int nargin = args.length ();
+  if (args.length () != 1)
+    print_usage ();
 
-  if (nargin == 1)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), "frewind");
+  octave_stream os = octave_stream_list::lookup (args(0), "frewind");
 
-      result = os.rewind ();
-    }
-  else
-    print_usage ();
+  result = os.rewind ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (fseek, args, ,
@@ -792,51 +768,45 @@ be positive, negative, or zero but not a
 @code{fseek} returns 0 on success and -1 on error.\n\
 @seealso{fskipl, frewind, ftell, fopen}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
-  if (nargin == 2 || nargin == 3)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), "fseek");
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
+  octave_stream os = octave_stream_list::lookup (args(0), "fseek");
 
-      octave_value origin_arg = (nargin == 3)
-        ? args(2) : octave_value (-1.0);
+  octave_value origin_arg = (nargin == 3)
+    ? args(2) : octave_value (-1.0);
 
-      retval = os.seek (args(1), origin_arg);
-    }
-  else
-    print_usage ();
+  retval = os.seek (args(1), origin_arg);
 
   return retval;
 }
 
 DEFUN (ftell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{pos} =} ftell (@var{fid})\n\
 Return the position of the file pointer as the number of characters from the\n\
 beginning of the file specified by file descriptor @var{fid}.\n\
 @seealso{fseek, frewind, feof, fopen}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
-  int nargin = args.length ();
+  if (args.length () != 1)
+    print_usage ();
 
-  if (nargin == 1)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), "ftell");
+  octave_stream os = octave_stream_list::lookup (args(0), "ftell");
 
-      retval = os.tell ();
-    }
-  else
-    print_usage ();
+  retval = os.tell ();
 
   return retval;
 }
 
 DEFUN (fprintf, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} fprintf (@var{template}, @dots{})\n\
@@ -858,50 +828,48 @@ expanded even when the template string i
   static std::string who = "fprintf";
 
   octave_value retval;
 
   int result = -1;
 
   int nargin = args.length ();
 
-  if (nargin > 1 || (nargin > 0 && args(0).is_string ()))
+  if (! (nargin > 1 || (nargin > 0 && args(0).is_string ())))
+    print_usage ();
+
+  octave_stream os;
+  int fmt_n = 0;
+
+  if (args(0).is_string ())
     {
-      octave_stream os;
-      int fmt_n = 0;
+      os = octave_stream_list::lookup (1, who);
+    }
+  else
+    {
+      fmt_n = 1;
+      os = octave_stream_list::lookup (args(0), who);
+    }
 
-      if (args(0).is_string ())
+  if (args(fmt_n).is_string ())
+    {
+      octave_value_list tmp_args;
+
+      if (nargin > 1 + fmt_n)
         {
-          os = octave_stream_list::lookup (1, who);
-        }
-      else
-        {
-          fmt_n = 1;
-          os = octave_stream_list::lookup (args(0), who);
+          tmp_args.resize (nargin-fmt_n-1, octave_value ());
+
+          for (int i = fmt_n + 1; i < nargin; i++)
+            tmp_args(i-fmt_n-1) = args(i);
         }
 
-      if (args(fmt_n).is_string ())
-        {
-          octave_value_list tmp_args;
-
-          if (nargin > 1 + fmt_n)
-            {
-              tmp_args.resize (nargin-fmt_n-1, octave_value ());
-
-              for (int i = fmt_n + 1; i < nargin; i++)
-                tmp_args(i-fmt_n-1) = args(i);
-            }
-
-          result = os.printf (args(fmt_n), tmp_args, who);
-        }
-      else
-        error ("%s: format TEMPLATE must be a string", who.c_str ());
+      result = os.printf (args(fmt_n), tmp_args, who);
     }
   else
-    print_usage ();
+    error ("%s: format TEMPLATE must be a string", who.c_str ());
 
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (printf, args, nargout,
@@ -925,37 +893,35 @@ expanded even when the template string i
   static std::string who = "printf";
 
   octave_value retval;
 
   int result = -1;
 
   int nargin = args.length ();
 
-  if (nargin > 0)
+  if (nargin == 0)
+    print_usage ();
+
+  if (args(0).is_string ())
     {
-      if (args(0).is_string ())
-        {
-          octave_value_list tmp_args;
+      octave_value_list tmp_args;
 
-          if (nargin > 1)
-            {
-              tmp_args.resize (nargin-1, octave_value ());
+      if (nargin > 1)
+        {
+          tmp_args.resize (nargin-1, octave_value ());
 
-              for (int i = 1; i < nargin; i++)
-                tmp_args(i-1) = args(i);
-            }
+          for (int i = 1; i < nargin; i++)
+            tmp_args(i-1) = args(i);
+        }
 
-          result = stdout_stream.printf (args(0), tmp_args, who);
-        }
-      else
-        error ("%s: format TEMPLATE must be a string", who.c_str ());
+      result = stdout_stream.printf (args(0), tmp_args, who);
     }
   else
-    print_usage ();
+    error ("%s: format TEMPLATE must be a string", who.c_str ());
 
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (fputs, args, ,
@@ -969,30 +935,22 @@ The string is written to the file with n
 for the local machine.\n\
 \n\
 Return a non-negative number on success or EOF on error.\n\
 @seealso{fdisp, fprintf, fwrite, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fputs";
 
-  octave_value retval = -1;
-
-  int nargin = args.length ();
-
-  if (nargin == 2)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), who);
-
-      retval = os.puts (args(1), who);
-    }
-  else
+  if (args.length () != 2)
     print_usage ();
 
-  return retval;
+  octave_stream os = octave_stream_list::lookup (args(0), who);
+
+  return octave_value (os.puts (args(1), who));
 }
 
 DEFUN (puts, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} puts (@var{string})\n\
 @deftypefnx {Built-in Function} {@var{status} =} puts (@var{string})\n\
 Write a string to the standard output with no formatting.\n\
 \n\
@@ -1000,24 +958,20 @@ The string is written verbatim to the st
 automatically append a newline character appropriate for the local machine.\n\
 \n\
 Return a non-negative number on success and EOF on error.\n\
 @seealso{fputs, disp}\n\
 @end deftypefn")
 {
   static std::string who = "puts";
 
-  octave_value retval = -1;
-
-  if (args.length () == 1)
-    retval = stdout_stream.puts (args(0), who);
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (stdout_stream.puts (args(0), who));
 }
 
 DEFUN (sprintf, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sprintf (@var{template}, @dots{})\n\
 This is like @code{printf}, except that the output is returned as a\n\
 string.\n\
 \n\
@@ -1032,60 +986,58 @@ expanded even when the template string i
 @end deftypefn")
 {
   static std::string who = "sprintf";
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin > 0)
-    {
-      retval(2) = -1.0;
-      retval(1) = "unknown error";
-      retval(0) = "";
+  if (nargin == 0)
+    print_usage ();
 
-      octave_ostrstream *ostr = new octave_ostrstream ();
+  retval(2) = -1.0;
+  retval(1) = "unknown error";
+  retval(0) = "";
 
-      octave_stream os (ostr);
+  octave_ostrstream *ostr = new octave_ostrstream ();
+
+  octave_stream os (ostr);
 
-      if (os.is_valid ())
-        {
-          octave_value fmt_arg = args(0);
-
-          if (fmt_arg.is_string ())
-            {
-              octave_value_list tmp_args;
+  if (os.is_valid ())
+    {
+      octave_value fmt_arg = args(0);
 
-              if (nargin > 1)
-                {
-                  tmp_args.resize (nargin-1, octave_value ());
+      if (fmt_arg.is_string ())
+        {
+          octave_value_list tmp_args;
 
-                  for (int i = 1; i < nargin; i++)
-                    tmp_args(i-1) = args(i);
-                }
+          if (nargin > 1)
+            {
+              tmp_args.resize (nargin-1, octave_value ());
 
-              retval(2) = os.printf (fmt_arg, tmp_args, who);
-              retval(1) = os.error ();
+              for (int i = 1; i < nargin; i++)
+                tmp_args(i-1) = args(i);
+            }
 
-              std::string result = ostr->str ();
-              char type = fmt_arg.is_sq_string () ? '\'' : '"';
+          retval(2) = os.printf (fmt_arg, tmp_args, who);
+          retval(1) = os.error ();
 
-              retval(0) = (result.empty ()
-                           ? octave_value (charMatrix (1, 0), type)
-                           : octave_value (result, type));
-            }
-          else
-            error ("%s: format TEMPLATE must be a string", who.c_str ());
+          std::string result = ostr->str ();
+          char type = fmt_arg.is_sq_string () ? '\'' : '"';
+
+          retval(0) = (result.empty ()
+                       ? octave_value (charMatrix (1, 0), type)
+                       : octave_value (result, type));
         }
       else
-        error ("%s: unable to create output buffer", who.c_str ());
+        error ("%s: format TEMPLATE must be a string", who.c_str ());
     }
   else
-    print_usage ();
+    error ("%s: unable to create output buffer", who.c_str ());
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, \"C\")\n\
@@ -1136,55 +1088,53 @@ complete description of the syntax of th
 @end deftypefn")
 {
   static std::string who = "fscanf";
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
   if (nargin == 3 && args(2).is_string ())
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (args(1).is_string ())
         retval = os.oscanf (args(1), who);
       else
         error ("%s: format TEMPLATE must be a string", who.c_str ());
     }
   else
     {
       retval(2) = "unknown error";
       retval(1) = 0.0;
       retval(0) = Matrix ();
 
-      if (nargin == 2 || nargin == 3)
-        {
-          octave_stream os = octave_stream_list::lookup (args(0), who);
+      octave_stream os = octave_stream_list::lookup (args(0), who);
 
-          if (args(1).is_string ())
-            {
-              octave_idx_type count = 0;
+      if (args(1).is_string ())
+        {
+          octave_idx_type count = 0;
 
-              Array<double> size = (nargin == 3)
-                ? args(2).vector_value ()
-                : Array<double> (dim_vector (1, 1),
-                                 lo_ieee_inf_value ());
-
-              octave_value tmp = os.scanf (args(1), size, count, who);
+          Array<double> size = (nargin == 3)
+            ? args(2).vector_value ()
+            : Array<double> (dim_vector (1, 1),
+                             lo_ieee_inf_value ());
 
-              retval(2) = os.error ();
-              retval(1) = count;
-              retval(0) = tmp;
-            }
-          else
-            error ("%s: format must be a string", who.c_str ());
+          octave_value tmp = os.scanf (args(1), size, count, who);
+
+          retval(2) = os.error ();
+          retval(1) = count;
+          retval(0) = tmp;
         }
       else
-        print_usage ();
+        error ("%s: format must be a string", who.c_str ());
     }
 
   return retval;
 }
 
 static std::string
 get_sscanf_data (const octave_value& val)
 {
@@ -1216,16 +1166,19 @@ character to be read is returned in @var
 @end deftypefn")
 {
   static std::string who = "sscanf";
 
   octave_value_list retval;
 
   int nargin = args.length ();
 
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
   if (nargin == 3 && args(2).is_string ())
     {
       std::string data = get_sscanf_data (args(0));
 
       octave_stream os = octave_istrstream::create (data);
 
       if (os.is_valid ())
         {
@@ -1234,60 +1187,55 @@ character to be read is returned in @var
           else
             error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
       else
         error ("%s: unable to create temporary input buffer", who.c_str ());
     }
   else
     {
-      if (nargin == 2 || nargin == 3)
-        {
-          retval(3) = -1.0;
-          retval(2) = "unknown error";
-          retval(1) = 0.0;
-          retval(0) = Matrix ();
+      retval(3) = -1.0;
+      retval(2) = "unknown error";
+      retval(1) = 0.0;
+      retval(0) = Matrix ();
+
+      std::string data = get_sscanf_data (args(0));
 
-          std::string data = get_sscanf_data (args(0));
-
-          octave_stream os = octave_istrstream::create (data);
+      octave_stream os = octave_istrstream::create (data);
 
-          if (os.is_valid ())
+      if (os.is_valid ())
+        {
+          if (args(1).is_string ())
             {
-              if (args(1).is_string ())
-                {
-                  octave_idx_type count = 0;
+              octave_idx_type count = 0;
 
-                  Array<double> size = (nargin == 3)
-                    ? args(2).vector_value ()
-                    : Array<double> (dim_vector (1, 1),
-                                     lo_ieee_inf_value ());
+              Array<double> size = (nargin == 3)
+                ? args(2).vector_value ()
+                : Array<double> (dim_vector (1, 1),
+                                 lo_ieee_inf_value ());
 
-                  octave_value tmp = os.scanf (args(1), size, count, who);
+              octave_value tmp = os.scanf (args(1), size, count, who);
 
-                  // FIXME: is this the right thing to do?
-                  // Extract error message first, because getting
-                  // position will clear it.
-                  std::string errmsg = os.error ();
+              // FIXME: is this the right thing to do?
+              // Extract error message first, because getting
+              // position will clear it.
+              std::string errmsg = os.error ();
 
-                  retval(3) = (os.eof () ? data.length () : os.tell ()) + 1;
-                  retval(2) = errmsg;
-                  retval(1) = count;
-                  retval(0) = tmp;
-                }
-              else
-                error ("%s: format TEMPLATE must be a string",
-                       who.c_str ());
+              retval(3) = (os.eof () ? data.length () : os.tell ()) + 1;
+              retval(2) = errmsg;
+              retval(1) = count;
+              retval(0) = tmp;
             }
           else
-            error ("%s: unable to create temporary input buffer",
-                   who.c_str  ());
+            error ("%s: format TEMPLATE must be a string",
+                   who.c_str ());
         }
       else
-        print_usage ();
+        error ("%s: unable to create temporary input buffer",
+               who.c_str  ());
     }
 
   return retval;
 }
 
 DEFUN (scanf, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
@@ -1524,56 +1472,54 @@ The output argument @var{val} contains t
 The optional return value @var{count} contains the number of elements read.\n\
 @seealso{fwrite, fgets, fgetl, fscanf, fopen}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin > 0 && nargin < 6)
-    {
-      retval(1) = -1.0;
-      retval(0) = Matrix ();
+  if (nargin < 1 || nargin > 5)
+    print_usage ();
 
-      octave_stream os = octave_stream_list::lookup (args(0), "fread");
+  retval(1) = -1.0;
+  retval(0) = Matrix ();
+
+  octave_stream os = octave_stream_list::lookup (args(0), "fread");
 
-      octave_value size = lo_ieee_inf_value ();
-      octave_value prec = "uchar";
-      octave_value skip = 0;
-      octave_value arch = "unknown";
+  octave_value size = lo_ieee_inf_value ();
+  octave_value prec = "uchar";
+  octave_value skip = 0;
+  octave_value arch = "unknown";
 
-      int idx = 1;
+  int idx = 1;
 
-      if (nargin > idx && ! args(idx).is_string ())
-        size = args(idx++);
-
-      if (nargin > idx)
-        prec = args(idx++);
+  if (nargin > idx && ! args(idx).is_string ())
+    size = args(idx++);
 
-      if (nargin > idx)
-        skip = args(idx++);
+  if (nargin > idx)
+    prec = args(idx++);
+
+  if (nargin > idx)
+    skip = args(idx++);
 
-      if (nargin > idx)
-        arch = args(idx++);
-      else if (skip.is_string ())
-        {
-          arch = skip;
-          skip = 0;
-        }
+  if (nargin > idx)
+    arch = args(idx++);
+  else if (skip.is_string ())
+    {
+      arch = skip;
+      skip = 0;
+    }
 
-      octave_idx_type count = -1;
-
-      octave_value tmp = do_fread (os, size, prec, skip, arch, count);
+  octave_idx_type count = -1;
 
-      retval(1) = count;
-      retval(0) = tmp;
-    }
-  else
-    print_usage ();
+  octave_value tmp = do_fread (os, size, prec, skip, arch, count);
+
+  retval(1) = count;
+  retval(0) = tmp;
 
   return retval;
 }
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
            const octave_value& prec_arg, const octave_value& skip_arg,
            const octave_value& arch_arg)
@@ -1628,82 +1574,66 @@ the file.  The values are extracted in c
 The remaining arguments @var{precision}, @var{skip}, and @var{arch} are\n\
 optional, and are interpreted as described for @code{fread}.\n\
 \n\
 The behavior of @code{fwrite} is undefined if the values in @var{data}\n\
 are too large to fit in the specified precision.\n\
 @seealso{fread, fputs, fprintf, fopen}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
   int nargin = args.length ();
 
-  if (nargin > 1 && nargin < 6)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), "fwrite");
-
-      octave_value prec = "uchar";
-      octave_value skip = 0;
-      octave_value arch = "unknown";
-
-      int idx = 1;
-
-      octave_value data = args(idx++);
-
-      if (nargin > idx)
-        prec = args(idx++);
-
-      if (nargin > idx)
-        skip = args(idx++);
-
-      if (nargin > idx)
-        arch = args(idx++);
-      else if (skip.is_string ())
-        {
-          arch = skip;
-          skip = 0;
-        }
-
-      double status = do_fwrite (os, data, prec, skip, arch);
-
-      retval = status;
-    }
-  else
+  if (nargin < 2 || nargin > 5)
     print_usage ();
 
-  return retval;
+  octave_stream os = octave_stream_list::lookup (args(0), "fwrite");
+
+  octave_value prec = "uchar";
+  octave_value skip = 0;
+  octave_value arch = "unknown";
+
+  int idx = 1;
+
+  octave_value data = args(idx++);
+
+  if (nargin > idx)
+    prec = args(idx++);
+
+  if (nargin > idx)
+    skip = args(idx++);
+
+  if (nargin > idx)
+    arch = args(idx++);
+  else if (skip.is_string ())
+    {
+      arch = skip;
+      skip = 0;
+    }
+
+  return octave_value (do_fwrite (os, data, prec, skip, arch));
 }
 
 DEFUNX ("feof", Ffeof, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{status} =} feof (@var{fid})\n\
 Return 1 if an end-of-file condition has been encountered for the file\n\
 specified by file descriptor @var{fid} and 0 otherwise.\n\
 \n\
 Note that @code{feof} will only return 1 if the end of the file has already\n\
 been encountered, not if the next read operation will result in an\n\
 end-of-file condition.\n\
 @seealso{fread, frewind, fseek, fclear, fopen}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), "feof");
-
-      retval = os.eof () ? 1.0 : 0.0;
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  octave_stream os = octave_stream_list::lookup (args(0), "feof");
+
+  return octave_value (os.eof () ? 1.0 : 0.0);
 }
 
 DEFUNX ("ferror", Fferror, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{msg} =} ferror (@var{fid})\n\
 @deftypefnx {Built-in Function} {[@var{msg}, @var{err}] =} ferror (@var{fid})\n\
 @deftypefnx {Built-in Function} {[@var{dots}] =} ferror (@var{fid}, \"clear\")\n\
 Query the error status of the stream specified by file descriptor @var{fid}\n\
@@ -1721,38 +1651,36 @@ Note that @code{ferror} indicates if an 
 whether the next operation will result in an error condition.\n\
 @seealso{fclear, fopen}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
-    {
-      octave_stream os = octave_stream_list::lookup (args(0), "ferror");
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
 
-      bool clear = false;
+  octave_stream os = octave_stream_list::lookup (args(0), "ferror");
 
-      if (nargin == 2)
-        {
-          std::string opt = args(1).string_value ();
+  bool clear = false;
 
-          clear = (opt == "clear");
-        }
+  if (nargin == 2)
+    {
+      std::string opt = args(1).string_value ();
 
-      int error_number = 0;
+      clear = (opt == "clear");
+    }
 
-      std::string error_message = os.error (clear, error_number);
+  int error_number = 0;
 
-      retval(1) = error_number;
-      retval(0) = error_message;
-    }
-  else
-    print_usage ();
+  std::string error_message = os.error (clear, error_number);
+
+  retval(1) = error_number;
+  retval(0) = error_message;
 
   return retval;
 }
 
 DEFUNX ("popen", Fpopen, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{fid} =} popen (@var{command}, @var{mode})\n\
 Start a process and create a pipe.\n\
@@ -1787,63 +1715,53 @@ endwhile\n\
    @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp\n\
 @end group\n\
 @end example\n\
 @seealso{popen2}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
-  int nargin = args.length ();
+  if (args.length () != 2)
+    print_usage ();
 
-  if (nargin == 2)
-    {
-      std::string name = args(0).xstring_value ("popen: COMMAND must be a string");
-      std::string mode = args(1).xstring_value ("popen: MODE must be a string");
-
-      if (mode == "r")
-        {
-          octave_stream ips = octave_iprocstream::create (name);
+  std::string name = args(0).xstring_value ("popen: COMMAND must be a string");
+  std::string mode = args(1).xstring_value ("popen: MODE must be a string");
 
-          retval = octave_stream_list::insert (ips);
-        }
-      else if (mode == "w")
-        {
-          octave_stream ops = octave_oprocstream::create (name);
+  if (mode == "r")
+    {
+      octave_stream ips = octave_iprocstream::create (name);
 
-          retval = octave_stream_list::insert (ops);
-        }
-      else
-        error ("popen: invalid MODE specified");
+      retval = octave_stream_list::insert (ips);
+    }
+  else if (mode == "w")
+    {
+      octave_stream ops = octave_oprocstream::create (name);
+
+      retval = octave_stream_list::insert (ops);
     }
   else
-    print_usage ();
+    error ("popen: invalid MODE specified");
 
   return retval;
 }
 
 DEFUNX ("pclose", Fpclose, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pclose (@var{fid})\n\
 Close a file identifier that was opened by @code{popen}.\n\
 \n\
 The function @code{fclose} may also be used for the same purpose.\n\
 @seealso{fclose, popen}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    retval = octave_stream_list::remove (args(0), "pclose");
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (octave_stream_list::remove (args(0), "pclose"));
 }
 
 DEFUN (tempname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{fname} =} tempname ()\n\
 @deftypefnx {Built-in Function} {@var{fname} =} tempname (@var{dir})\n\
 @deftypefnx {Built-in Function} {@var{fname} =} tempname (@var{dir}, @var{prefix})\n\
 Return a unique temporary filename as a string.\n\
@@ -1860,34 +1778,30 @@ by the time your program attempts to ope
 see @code{tmpfile}.\n\
 @seealso{mkstemp, tempdir, P_tmpdir, tmpfile}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int len = args.length ();
 
-  if (len < 3)
-    {
-      std::string dir;
-
-      if (len > 0)
-        dir = args(0).xstring_value ("tempname: DIR must be a string");
-
-      std::string pfx ("oct-");
-
-      if (len > 1)
-        pfx = args(1).xstring_value ("tempname: PREFIX must be a string");
-
-      retval = octave_tempnam (dir, pfx);
-    }
-  else
+  if (len > 2)
     print_usage ();
 
-  return retval;
+  std::string dir;
+
+  if (len > 0)
+    dir = args(0).xstring_value ("tempname: DIR must be a string");
+
+  std::string pfx ("oct-");
+
+  if (len > 1)
+    pfx = args(1).xstring_value ("tempname: PREFIX must be a string");
+
+  return octave_value (octave_tempnam (dir, pfx));
 }
 
 /*
 %!test
 %! if (ispc ())
 %!   envname = "TMP";
 %! else
 %!   envname = "TMPDIR";
@@ -1945,47 +1859,43 @@ deleted automatically when it is closed 
 If successful, @var{fid} is a valid file ID and @var{msg} is an empty\n\
 string.  Otherwise, @var{fid} is -1 and @var{msg} contains a\n\
 system-dependent error message.\n\
 @seealso{tempname, mkstemp, tempdir, P_tmpdir}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
+  if (args.length () != 0)
+    print_usage ();
+
   retval(1) = std::string ();
   retval(0) = -1;
 
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    {
-      FILE *fid = gnulib::tmpfile ();
+  FILE *fid = gnulib::tmpfile ();
 
-      if (fid)
-        {
-          std::string nm;
+  if (fid)
+    {
+      std::string nm;
 
-          std::ios::openmode md = fopen_mode_to_ios_mode ("w+b");
+      std::ios::openmode md = fopen_mode_to_ios_mode ("w+b");
 
-          octave_stream s = octave_stdiostream::create (nm, fid, md);
-
-          if (s)
-            retval(0) = octave_stream_list::insert (s);
-          else
-            error ("tmpfile: failed to create octave_stdiostream object");
+      octave_stream s = octave_stdiostream::create (nm, fid, md);
 
-        }
+      if (s)
+        retval(0) = octave_stream_list::insert (s);
       else
-        {
-          retval(1) = gnulib::strerror (errno);
-          retval(0) = -1;
-        }
+        error ("tmpfile: failed to create octave_stdiostream object");
+
     }
   else
-    print_usage ();
+    {
+      retval(1) = gnulib::strerror (errno);
+      retval(0) = -1;
+    }
 
   return retval;
 }
 
 DEFUN (mkstemp, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (\"@var{template}\")\n\
 @deftypefnx {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (\"@var{template}\", @var{delete})\n\
@@ -2005,70 +1915,68 @@ be deleted automatically when Octave exi
 If successful, @var{fid} is a valid file ID, @var{name} is the name of the\n\
 file, and @var{msg} is an empty string.  Otherwise, @var{fid} is -1,\n\
 @var{name} is empty, and @var{msg} contains a system-dependent error message.\n\
 @seealso{tempname, tempdir, P_tmpdir, tmpfile, fopen}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
+  int nargin = args.length ();
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
   retval(2) = std::string ();
   retval(1) = std::string ();
   retval(0) = -1;
 
-  int nargin = args.length ();
+  std::string tmpl8 = args(0).xstring_value ("mkstemp: TEMPLATE argument must be a string");
+
+  OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
+  strcpy (tmp, tmpl8.c_str ());
+
+  int fd = gnulib::mkostemp (tmp, O_BINARY);
 
-  if (nargin == 1 || nargin == 2)
+  if (fd < 0)
     {
-      std::string tmpl8 = args(0).xstring_value ("mkstemp: TEMPLATE argument must be a string");
+      retval(2) = gnulib::strerror (errno);
+      retval(0) = fd;
+    }
+  else
+    {
+      const char *fopen_mode = "w+b";
+
+      FILE *fid = fdopen (fd, fopen_mode);
 
-      OCTAVE_LOCAL_BUFFER (char, tmp, tmpl8.size () + 1);
-      strcpy (tmp, tmpl8.c_str ());
+      if (fid)
+        {
+          std::string nm = tmp;
 
-      int fd = gnulib::mkostemp (tmp, O_BINARY);
+          std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
+
+          octave_stream s = octave_stdiostream::create (nm, fid, md);
 
-      if (fd < 0)
-        {
-          retval(2) = gnulib::strerror (errno);
-          retval(0) = fd;
+          if (s)
+            {
+              retval(1) = nm;
+              retval(0) = octave_stream_list::insert (s);
+
+              if (nargin == 2 && args(1).is_true ())
+                mark_for_deletion (nm);
+            }
+          else
+            error ("mkstemp: failed to create octave_stdiostream object");
         }
       else
         {
-          const char *fopen_mode = "w+b";
-
-          FILE *fid = fdopen (fd, fopen_mode);
-
-          if (fid)
-            {
-              std::string nm = tmp;
-
-              std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
-
-              octave_stream s = octave_stdiostream::create (nm, fid, md);
-
-              if (s)
-                {
-                  retval(1) = nm;
-                  retval(0) = octave_stream_list::insert (s);
-
-                  if (nargin == 2 && args(1).is_true ())
-                    mark_for_deletion (nm);
-                }
-              else
-                error ("mkstemp: failed to create octave_stdiostream object");
-            }
-          else
-            {
-              retval(2) = gnulib::strerror (errno);
-              retval(0) = -1;
-            }
+          retval(2) = gnulib::strerror (errno);
+          retval(0) = -1;
         }
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 // FIXME: This routine also exists verbatim in syscalls.cc.
 //        Maybe change to be a general utility routine.
 static int
 convert (int x, int ibase, int obase)
@@ -2116,79 +2024,65 @@ modified according to the octal value of
 for the new object are @code{@var{mode} - @var{mask}}.\n\
 @seealso{fopen, mkdir, mkfifo}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int status = 0;
 
-  if (args.length () == 1)
-    {
-      int mask = args(0).xint_value ("umask: MASK must be an integer");
+  if (args.length () != 1)
+    print_usage ();
+
+  int mask = args(0).xint_value ("umask: MASK must be an integer");
 
-      if (mask < 0)
-        {
-          status = -1;
-          error ("umask: MASK must be a positive integer value");
-        }
-      else
-        {
-          int oct_mask = convert (mask, 8, 10);
-
-          status = convert (octave_umask (oct_mask), 10, 8);
-        }
+  if (mask < 0)
+    {
+      status = -1;
+      error ("umask: MASK must be a positive integer value");
     }
   else
-    print_usage ();
+    {
+      int oct_mask = convert (mask, 8, 10);
+
+      status = convert (octave_umask (oct_mask), 10, 8);
+    }
 
   if (status >= 0)
     retval(0) = status;
 
   return retval;
 }
 
 static octave_value
 const_value (const char *, const octave_value_list& args, int val)
 {
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    retval = val;
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (val);
 }
 
 DEFUNX ("P_tmpdir", FP_tmpdir, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} P_tmpdir ()\n\
 Return the name of the host system's @strong{default} directory for\n\
 temporary files.\n\
 \n\
 Programming Note: The value returned by @code{P_tmpdir} is always the\n\
 default location.  This value may not agree with that returned from\n\
 @code{tempdir} if the user has overridden the default with the @env{TMPDIR}\n\
 environment variable.\n\
 @seealso{tempdir, tempname, mkstemp, tmpfile}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    retval = get_P_tmpdir ();
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (get_P_tmpdir ());
 }
 
 // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
 // this way for Matlab compatibility.
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} SEEK_SET ()\n\
@@ -2234,26 +2128,20 @@ position the file pointer relative to th
 {
   return const_value ("SEEK_END", args, 1);
 }
 
 static octave_value
 const_value (const char *, const octave_value_list& args,
              const octave_value& val)
 {
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    retval = val;
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (val);
 }
 
 DEFUNX ("stdin", Fstdin, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} stdin ()\n\
 Return the numeric value corresponding to the standard input stream.\n\
 \n\
 When Octave is used interactively, stdin is filtered through the command\n\
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -55,23 +55,20 @@ For example:\n\
 @group\n\
 abs (3 + 4i)\n\
      @result{} 5\n\
 @end group\n\
 @end example\n\
 @seealso{arg}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).abs ();
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  return octave_value (args(0).abs ());
 }
 
 /*
 %!assert (abs (1), 1)
 %!assert (abs (-3.5), 3.5)
 %!assert (abs (3+4i), 5)
 %!assert (abs (3-4i), 5)
 %!assert (abs ([1.1, 3i; 3+4i, -3-4i]), [1.1, 3; 5, 5])
@@ -88,23 +85,20 @@ abs (3 + 4i)\n\
 
 DEFUN (acos, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acos (@var{x})\n\
 Compute the inverse cosine in radians for each element of @var{x}.\n\
 @seealso{cos, acosd}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).acos ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).acos ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -137,23 +131,20 @@ Compute the inverse cosine in radians fo
 
 DEFUN (acosh, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine for each element of @var{x}.\n\
 @seealso{cosh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).acosh ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).acosh ());
 }
 
 /*
 %!test
 %! x = [1, 0, -1, 0];
 %! v = [0, pi/2*i, pi*i, pi/2*i];
 %! assert (acosh (x), v, sqrt (eps));
 
@@ -179,23 +170,20 @@ Compute the inverse hyperbolic cosine fo
 
 DEFUN (angle, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} angle (@var{z})\n\
 See @code{arg}.\n\
 @seealso{arg}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).arg ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).arg ());
 }
 
 DEFUN (arg, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} arg (@var{z})\n\
 @deftypefnx {Mapping Function} {} angle (@var{z})\n\
 Compute the argument, i.e., angle of @var{z}.\n\
 \n\
@@ -214,23 +202,20 @@ For example:\n\
 @group\n\
 arg (3 + 4i)\n\
      @result{} 0.92730\n\
 @end group\n\
 @end example\n\
 @seealso{abs}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).arg ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).arg ());
 }
 
 /*
 %!assert (arg (1), 0)
 %!assert (arg (i), pi/2)
 %!assert (arg (-1), pi)
 %!assert (arg (-i), -pi/2)
 %!assert (arg ([1, i; -1, -i]), [0, pi/2; pi, -pi/2])
@@ -253,23 +238,20 @@ arg (3 + 4i)\n\
 
 DEFUN (asin, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
 Compute the inverse sine in radians for each element of @var{x}.\n\
 @seealso{sin, asind}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).asin ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).asin ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -301,23 +283,20 @@ Compute the inverse sine in radians for 
 
 DEFUN (asinh, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asinh (@var{x})\n\
 Compute the inverse hyperbolic sine for each element of @var{x}.\n\
 @seealso{sinh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).asinh ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).asinh ());
 }
 
 /*
 %!test
 %! v = [0, pi/2*i, 0, -pi/2*i];
 %! x = [0, i, 0, -i];
 %! assert (asinh (x), v,  sqrt (eps));
 
@@ -332,23 +311,20 @@ Compute the inverse hyperbolic sine for 
 
 DEFUN (atan, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
 Compute the inverse tangent in radians for each element of @var{x}.\n\
 @seealso{tan, atand}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).atan ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).atan ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -367,23 +343,20 @@ Compute the inverse tangent in radians f
 
 DEFUN (atanh, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tangent for each element of @var{x}.\n\
 @seealso{tanh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).atanh ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).atanh ());
 }
 
 /*
 %!test
 %! v = [0, 0];
 %! x = [0, 0];
 %! assert (atanh (x), v, sqrt (eps));
 
@@ -401,23 +374,20 @@ DEFUN (cbrt, args, ,
 @deftypefn {Mapping Function} {} cbrt (@var{x})\n\
 Compute the real cube root of each element of @var{x}.\n\
 \n\
 Unlike @code{@var{x}^(1/3)}, the result will be negative if @var{x} is\n\
 negative.\n\
 @seealso{nthroot}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).cbrt ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).cbrt ());
 }
 
 /*
 %!assert (cbrt (64), 4)
 %!assert (cbrt (-125), -5)
 %!assert (cbrt (0), 0)
 %!assert (cbrt (Inf), Inf)
 %!assert (cbrt (-Inf), -Inf)
@@ -443,23 +413,20 @@ If @var{x} is complex, return\n\
 @group\n\
 ceil ([-2.7, 2.7])\n\
     @result{} -2    3\n\
 @end group\n\
 @end example\n\
 @seealso{floor, round, fix}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).ceil ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).ceil ());
 }
 
 /*
 ## double precision
 %!assert (ceil ([2, 1.1, -1.1, -1]), [2, 2, -1, -1])
 
 ## complex double precison
 %!assert (ceil ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 2+2i, -1-i, -1-i])
@@ -484,23 +451,20 @@ The complex conjugate is defined as\n\
 $\\bar{z} = x - iy$.\n\
 @end tex\n\
 @ifnottex\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
 @end ifnottex\n\
 @seealso{real, imag}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).conj ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).conj ());
 }
 
 /*
 %!assert (conj (1), 1)
 %!assert (conj (i), -i)
 %!assert (conj (1+i), 1-i)
 %!assert (conj (1-i), 1+i)
 %!assert (conj ([-1, -i; -1+i, -1-i]), [-1, i; -1-i, -1+i])
@@ -517,23 +481,20 @@ The complex conjugate is defined as\n\
 
 DEFUN (cos, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cos (@var{x})\n\
 Compute the cosine for each element of @var{x} in radians.\n\
 @seealso{acos, cosd, cosh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).cos ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).cos ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -554,23 +515,20 @@ Compute the cosine for each element of @
 
 DEFUN (cosh, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine for each element of @var{x}.\n\
 @seealso{acosh, sinh, tanh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).cosh ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).cosh ());
 }
 
 /*
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [1, 0, -1, 0];
 %! assert (cosh (x), v, sqrt (eps));
 
@@ -605,23 +563,20 @@ erf (z) = --------- *  | e^(-t^2) dt\n\
                     t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erfcx, erfi, dawson, erfinv, erfcinv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).erf ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).erf ());
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (erf (a), erf (real (a)));
 
 %!test
@@ -663,23 +618,20 @@ Compute the inverse error function.\n\
 The inverse error function is defined such that\n\
 \n\
 @example\n\
 erf (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erf, erfc, erfcx, erfi, dawson, erfcinv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).erfinv ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).erfinv ());
 }
 
 /*
 ## middle region
 %!assert (erf (erfinv ([-0.9 -0.3 0 0.4 0.8])), [-0.9 -0.3 0 0.4 0.8], eps)
 %!assert (erf (erfinv (single ([-0.9 -0.3 0 0.4 0.8]))), single ([-0.9 -0.3 0 0.4 0.8]), eps ("single"))
 ## tail region
 %!assert (erf (erfinv ([-0.999 -0.99 0.9999 0.99999])), [-0.999 -0.99 0.9999 0.99999], eps)
@@ -703,23 +655,20 @@ Compute the inverse complementary error 
 The inverse complementary error function is defined such that\n\
 \n\
 @example\n\
 erfc (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erfc, erf, erfcx, erfi, dawson, erfinv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).erfcinv ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).erfcinv ());
 }
 
 /*
 ## middle region
 %!assert (erfc (erfcinv ([1.9 1.3 1 0.6 0.2])), [1.9 1.3 1 0.6 0.2], eps)
 %!assert (erfc (erfcinv (single ([1.9 1.3 1 0.6 0.2]))), single ([1.9 1.3 1 0.6 0.2]), eps ("single"))
 ## tail region
 %!assert (erfc (erfcinv ([0.001 0.01 1.9999 1.99999])), [0.001 0.01 1.9999 1.99999], eps)
@@ -745,23 +694,20 @@ The complementary error function is defi
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
 @ifnottex\n\
 @w{@code{1 - erf (@var{z})}}.\n\
 @end ifnottex\n\
 @seealso{erfcinv, erfcx, erfi, dawson, erf, erfinv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).erfc ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).erfc ());
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (erfc (a), erfc (real (a)));
 
 %!error erfc ()
@@ -784,23 +730,20 @@ The scaled complementary error function 
 @example\n\
 exp (z^2) * erfc (z)\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erf, erfi, dawson, erfinv, erfcinv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).erfcx ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).erfcx ());
 }
 
 /*
 
 %!test
 %! x = [1+2i,-1+2i,1e-6+2e-6i,0+2i];
 %! assert (erfcx (x), exp (x.^2) .* erfc(x), -1.e-10);
 
@@ -829,23 +772,20 @@ The imaginary error function is defined 
 @example\n\
 -i * erf (i*z)\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erf, erfcx, dawson, erfinv, erfcinv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).erfi ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).erfi ());
 }
 
 /*
 
 %!test
 %! x = [-0.1, 0.1, 1, 1+2i,-1+2i,1e-6+2e-6i,0+2i];
 %! assert (erfi (x), -i * erf(i*x), -1.e-10);
 
@@ -869,23 +809,20 @@ The Dawson function is defined as\n\
 @example\n\
 (sqrt (pi) / 2) * exp (-z^2) * erfi (z)\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erf, erfcx, erfi, erfinv, erfcinv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).dawson ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).dawson ());
 }
 
 /*
 
 %!test
 %! x = [0.1, 1, 1+2i,-1+2i,1e-4+2e-4i,0+2i];
 %! v = [0.099335992397852861, 0.53807950691, -13.38892731648-11.828715104i, 13.38892731648-11.828715104i, 0.0001000000073333+0.000200000001333i, 48.160012114291i];
 %! assert (dawson (x), v, -1.e-10);
@@ -906,23 +843,20 @@ Compute\n\
 @code{e^x}\n\
 @end ifnottex\n\
 for each element of @var{x}.\n\
 \n\
 To compute the matrix exponential, see @ref{Linear Algebra}.\n\
 @seealso{log}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).exp ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).exp ());
 }
 
 /*
 %!assert (exp ([0, 1, -1, -1000]), [1, e, 1/e, 0], sqrt (eps))
 %!assert (exp (1+i), e * (cos (1) + sin (1) * i), sqrt (eps))
 %!assert (exp (single ([0, 1, -1, -1000])), single ([1, e, 1/e, 0]), sqrt (eps ("single")))
 %!assert (exp (single (1+i)), single (e * (cos (1) + sin (1) * i)), sqrt (eps ("single")))
 
@@ -942,23 +876,20 @@ Compute\n\
 @end tex\n\
 @ifnottex\n\
 @code{exp (@var{x}) - 1}\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
 @seealso{exp}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).expm1 ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).expm1 ());
 }
 
 /*
 %!assert (expm1 (2*eps), 2*eps, 1e-29)
 
 %!assert (expm1 ([Inf, -Inf, NaN]), [Inf -1 NaN])
 %!assert (expm1 (single ([Inf, -Inf, NaN])), single ([Inf -1 NaN]))
 
@@ -978,23 +909,20 @@ For example:\n\
 @group\n\
 isfinite ([13, Inf, NA, NaN])\n\
      @result{} [ 1, 0, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isinf, isnan, isna}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).finite ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).finite ());
 }
 
 /*
 %!assert (!isfinite (Inf))
 %!assert (!isfinite (NaN))
 %!assert (isfinite (rand (1,10)))
 
 %!assert (!isfinite (single (Inf)))
@@ -1017,23 +945,20 @@ This is equivalent to rounding towards z
 @group\n\
 fix ([-2.7, 2.7])\n\
    @result{} -2    2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, round}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).fix ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).fix ());
 }
 
 /*
 %!assert (fix ([1.1, 1, -1.1, -1]), [1, 1, -1, -1])
 %!assert (fix ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i]), [1+i, 1+i, -1-i, -1-i])
 %!assert (fix (single ([1.1, 1, -1.1, -1])), single ([1, 1, -1, -1]))
 %!assert (fix (single ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i])), single ([1+i, 1+i, -1-i, -1-i]))
 
@@ -1053,23 +978,20 @@ complex, return @code{floor (real (@var{
 @group\n\
 floor ([-2.7, 2.7])\n\
      @result{} -3    2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, round, fix}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).floor ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).floor ());
 }
 
 /*
 %!assert (floor ([2, 1.1, -1.1, -1]), [2, 1, -2, -1])
 %!assert (floor ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 1+i, -2-2i, -1-i])
 %!assert (floor (single ([2, 1.1, -1.1, -1])), single ([2, 1, -2, -1]))
 %!assert (floor (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 1+i, -2-2i, -1-i]))
 
@@ -1105,23 +1027,20 @@ gamma (z) = | t^(z-1) exp (-t) dt.\n\
 Programming Note: The gamma function can grow quite large even for small\n\
 input values.  In many cases it may be preferable to use the natural\n\
 logarithm of the gamma function (@code{gammaln}) in calculations to minimize\n\
 loss of precision.  The final result is then\n\
 @code{exp (@var{result_using_gammaln}).}\n\
 @seealso{gammainc, gammaln, factorial}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).gamma ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).gamma ());
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (gamma (a), gamma (real (a)));
 
 %!test
@@ -1151,23 +1070,20 @@ loss of precision.  The final result is 
 
 DEFUN (imag, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
 @seealso{real, conj}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).imag ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).imag ());
 }
 
 /*
 %!assert (imag (1), 0)
 %!assert (imag (i), 1)
 %!assert (imag (1+i), 1)
 %!assert (imag ([i, 1; 1, i]), full (eye (2)))
 
@@ -1185,23 +1101,20 @@ DEFUNX ("isalnum", Fisalnum, args, ,
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 letters or digits and false where they are not.\n\
 \n\
 This is equivalent to (@code{isalpha (@var{s}) | isdigit (@var{s})}).\n\
 @seealso{isalpha, isdigit, ispunct, isspace, iscntrl}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xisalnum ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xisalnum ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! result(toascii ("0":"9") + 1) = true;
@@ -1217,23 +1130,20 @@ DEFUNX ("isalpha", Fisalpha, args, ,
 @deftypefn {Mapping Function} {} isalpha (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 letters and false where they are not.\n\
 \n\
 This is equivalent to (@code{islower (@var{s}) | isupper (@var{s})}).\n\
 @seealso{isdigit, ispunct, isspace, iscntrl, isalnum, islower, isupper}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xisalpha ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xisalpha ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! result(toascii ("a":"z") + 1) = true;
@@ -1246,23 +1156,20 @@ This is equivalent to (@code{islower (@v
 DEFUNX ("isascii", Fisascii, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isascii (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 ASCII characters (in the range 0 to 127 decimal) and false where they are\n\
 not.\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xisascii ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xisascii ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = true (1, 128);
 %! assert (isascii (charset), result);
 
@@ -1273,23 +1180,20 @@ not.\n\
 DEFUNX ("iscntrl", Fiscntrl, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} iscntrl (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 control characters and false where they are not.\n\
 @seealso{ispunct, isspace, isalpha, isdigit}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xiscntrl ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xiscntrl ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(1:32) = true;
 %! result(128) = true;
@@ -1302,23 +1206,20 @@ control characters and false where they 
 DEFUNX ("isdigit", Fisdigit, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isdigit (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 decimal digits (0-9) and false where they are not.\n\
 @seealso{isxdigit, isalpha, isletter, ispunct, isspace, iscntrl}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xisdigit ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xisdigit ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("0":"9") + 1) = true;
 %! assert (isdigit (charset), result);
@@ -1339,23 +1240,20 @@ For example:\n\
 @group\n\
 isinf ([13, Inf, NA, NaN])\n\
       @result{} [ 0, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isfinite, isnan, isna}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).isinf ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).isinf ());
 }
 
 /*
 %!assert (isinf (Inf))
 %!assert (!isinf (NaN))
 %!assert (!isinf (NA))
 %!assert (isinf (rand (1,10)), false (1,10))
 %!assert (isinf ([NaN -Inf -1 0 1 Inf NA]), [false, true, false, false, false, true, false])
@@ -1374,23 +1272,20 @@ DEFUNX ("isgraph", Fisgraph, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isgraph (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 printable characters (but not the space character) and false where they are\n\
 not.\n\
 @seealso{isprint}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xisgraph ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xisgraph ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(34:127) = true;
 %! assert (isgraph (charset), result);
@@ -1402,23 +1297,20 @@ not.\n\
 DEFUNX ("islower", Fislower, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} islower (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 lowercase letters and false where they are not.\n\
 @seealso{isupper, isalpha, isletter, isalnum}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xislower ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xislower ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("a":"z") + 1) = true;
 %! assert (islower (charset), result);
@@ -1439,23 +1331,20 @@ For example:\n\
 @group\n\
 isna ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 0, 1, 0 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isnan, isinf, isfinite}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).isna ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).isna ());
 }
 
 /*
 %!assert (!isna (Inf))
 %!assert (!isna (NaN))
 %!assert (isna (NA))
 %!assert (isna (rand (1,10)), false (1,10))
 %!assert (isna ([NaN -Inf -1 0 1 Inf NA]), [false, false, false, false, false, false, true])
@@ -1482,23 +1371,20 @@ NA values are also considered NaN values
 @group\n\
 isnan ([13, Inf, NA, NaN])\n\
       @result{} [ 0, 0, 1, 1 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isna, isinf, isfinite}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).isnan ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).isnan ());
 }
 
 /*
 %!assert (!isnan (Inf))
 %!assert (isnan (NaN))
 %!assert (isnan (NA))
 %!assert (isnan (rand (1,10)), false (1,10))
 %!assert (isnan ([NaN -Inf -1 0 1 Inf NA]), [true, false, false, false, false, false, true])
@@ -1517,23 +1403,20 @@ DEFUNX ("isprint", Fisprint, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isprint (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 printable characters (including the space character) and false where they\n\
 are not.\n\
 @seealso{isgraph}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xisprint ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xisprint ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(33:127) = true;
 %! assert (isprint (charset), result);
@@ -1545,23 +1428,20 @@ are not.\n\
 DEFUNX ("ispunct", Fispunct, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ispunct (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 punctuation characters and false where they are not.\n\
 @seealso{isalpha, isdigit, isspace, iscntrl}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xispunct ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xispunct ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(34:48) = true;
 %! result(59:65) = true;
@@ -1577,23 +1457,20 @@ DEFUNX ("isspace", Fisspace, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isspace (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 whitespace characters (space, formfeed, newline, carriage return, tab, and\n\
 vertical tab) and false where they are not.\n\
 @seealso{iscntrl, ispunct, isalpha, isdigit}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xisspace ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xisspace ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii (" \f\n\r\t\v") + 1) = true;
 %! assert (isspace (charset), result);
@@ -1605,23 +1482,20 @@ vertical tab) and false where they are n
 DEFUNX ("isupper", Fisupper, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isupper (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 uppercase letters and false where they are not.\n\
 @seealso{islower, isalpha, isletter, isalnum}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xisupper ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xisupper ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! assert (isupper (charset), result);
@@ -1633,23 +1507,20 @@ uppercase letters and false where they a
 DEFUNX ("isxdigit", Fisxdigit, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isxdigit (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 hexadecimal digits (0-9 and @nospell{a-fA-F}).\n\
 @seealso{isdigit}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xisxdigit ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xisxdigit ());
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"F") + 1) = true;
 %! result(toascii ("0":"9") + 1) = true;
@@ -1663,23 +1534,20 @@ hexadecimal digits (0-9 and @nospell{a-f
 DEFUN (lgamma, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} gammaln (@var{x})\n\
 @deftypefnx {Mapping Function} {} lgamma (@var{x})\n\
 Return the natural logarithm of the gamma function of @var{x}.\n\
 @seealso{gamma, gammainc}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).lgamma ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).lgamma ());
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (gammaln (a), gammaln (real (a)));
 
 %!test
@@ -1717,23 +1585,20 @@ Compute the natural logarithm,\n\
 @code{ln (@var{x})},\n\
 @end ifnottex\n\
 for each element of @var{x}.\n\
 \n\
 To compute the matrix logarithm, see @ref{Linear Algebra}.\n\
 @seealso{exp, log1p, log2, log10, logspace}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).log ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).log ());
 }
 
 /*
 %!assert (log ([1, e, e^2]), [0, 1, 2], sqrt (eps))
 %!assert (log ([-0.5, -1.5, -2.5]), log ([0.5, 1.5, 2.5]) + pi*1i, sqrt (eps))
 
 %!assert (log (single ([1, e, e^2])), single ([0, 1, 2]), sqrt (eps ("single")))
 %!assert (log (single ([-0.5, -1.5, -2.5])), single (log ([0.5, 1.5, 2.5]) + pi*1i), 4*eps ("single"))
@@ -1744,23 +1609,20 @@ To compute the matrix logarithm, see @re
 
 DEFUN (log10, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm of each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).log10 ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).log10 ());
 }
 
 /*
 %!assert (log10 ([0.01, 0.1, 1, 10, 100]), [-2, -1, 0, 1, 2], sqrt (eps))
 %!assert (log10 (single ([0.01, 0.1, 1, 10, 100])), single ([-2, -1, 0, 1, 2]), sqrt (eps ("single")))
 
 %!error log10 ()
 %!error log10 (1, 2)
@@ -1775,23 +1637,20 @@ Compute\n\
 @end tex\n\
 @ifnottex\n\
 @code{log (1 + @var{x})}\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
 @seealso{log, exp, expm1}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).log1p ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).log1p ());
 }
 
 /*
 %!assert (log1p ([0, 2*eps, -2*eps]), [0, 2*eps, -2*eps], 1e-29)
 %!assert (log1p (single ([0, 2*eps, -2*eps])), single ([0, 2*eps, -2*eps]), 1e-29)
 
 %!error log1p ()
 %!error log1p (1, 2)
@@ -1799,23 +1658,20 @@ accurately in the neighborhood of zero.\
 
 DEFUN (real, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
 @seealso{imag, conj}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).real ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).real ());
 }
 
 /*
 %!assert (real (1), 1)
 %!assert (real (i), 0)
 %!assert (real (1+i), 1)
 %!assert (real ([1, i; i, 1]), full (eye (2)))
 
@@ -1841,23 +1697,20 @@ are two nearest integers, return the one
 @group\n\
 round ([-2.7, 2.7])\n\
      @result{} -3    3\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, fix, roundb}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).round ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).round ());
 }
 
 /*
 %!assert (round (1), 1)
 %!assert (round (1.1), 1)
 %!assert (round (5.5), 6)
 %!assert (round (i), i)
 %!assert (round (2.5+3.5i), 3+4i)
@@ -1882,23 +1735,20 @@ DEFUN (roundb, args, ,
 Return the integer nearest to @var{x}.  If there are two nearest\n\
 integers, return the even one (banker's rounding).\n\
 \n\
 If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
 @seealso{round}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).roundb ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).roundb ());
 }
 
 /*
 %!assert (roundb (1), 1)
 %!assert (roundb (1.1), 1)
 %!assert (roundb (1.5), 2)
 %!assert (roundb (4.5), 4)
 %!assert (roundb (i), i)
@@ -1945,23 +1795,20 @@ sign (x) =  0, x = 0;\n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
 \n\
 Note that @code{sign (-0.0)} is 0.  Although IEEE 754 floating point\n\
 allows zero to be signed, 0.0 and -0.0 compare equal.  If you must test\n\
 whether zero is signed, use the @code{signbit} function.\n\
 @seealso{signbit}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).signum ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).signum ());
 }
 
 /*
 %!assert (sign (-2) , -1)
 %!assert (sign (0), 0)
 %!assert (sign (3), 1)
 %!assert (sign ([1, -pi; e, 0]), [1, -1; 1, 0])
 
@@ -1985,26 +1832,22 @@ See @ref{Logical Values}.  The behavior 
 which returns nonzero if the sign bit is set.\n\
 \n\
 This is not the same as @code{x < 0.0}, because IEEE 754 floating point\n\
 allows zero to be signed.  The comparison @code{-0.0 < 0.0} is false,\n\
 but @code{signbit (-0.0)} will return a nonzero value.\n\
 @seealso{sign}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    {
-      retval = args(0).xsignbit ();
-      retval = (retval != 0);
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  octave_value tmp = args(0).xsignbit ();
+
+  return octave_value (tmp != 0);
 }
 
 /*
 %!assert (signbit (1) == 0)
 %!assert (signbit (-2) != 0)
 %!assert (signbit (0) == 0)
 %!assert (signbit (-0) != 0)
 
@@ -2019,23 +1862,20 @@ but @code{signbit (-0.0)} will return a 
 
 DEFUN (sin, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
 Compute the sine for each element of @var{x} in radians.\n\
 @seealso{asin, sind, sinh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).sin ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).sin ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -2054,23 +1894,20 @@ Compute the sine for each element of @va
 
 DEFUN (sinh, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
 Compute the hyperbolic sine for each element of @var{x}.\n\
 @seealso{asinh, cosh, tanh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).sinh ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).sinh ());
 }
 
 /*
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [0, i, 0, -i];
 %! assert (sinh (x), v, sqrt (eps));
 
@@ -2089,23 +1926,20 @@ DEFUN (sqrt, args, ,
 Compute the square root of each element of @var{x}.\n\
 \n\
 If @var{x} is negative, a complex result is returned.\n\
 \n\
 To compute the matrix square root, see @ref{Linear Algebra}.\n\
 @seealso{realsqrt, nthroot}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).sqrt ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).sqrt ());
 }
 
 /*
 %!assert (sqrt (4), 2)
 %!assert (sqrt (-1), i)
 %!assert (sqrt (1+i), exp (0.5 * log (1+i)), sqrt (eps))
 %!assert (sqrt ([4, -4; i, 1-i]), [2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))], sqrt (eps))
 
@@ -2120,23 +1954,20 @@ To compute the matrix square root, see @
 
 DEFUN (tan, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
 Compute the tangent for each element of @var{x} in radians.\n\
 @seealso{atan, tand, tanh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).tan ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).tan ());
 }
 
 /*
 %!shared rt2, rt3
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 
 %!test
@@ -2155,23 +1986,20 @@ Compute the tangent for each element of 
 
 DEFUN (tanh, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
 Compute hyperbolic tangent for each element of @var{x}.\n\
 @seealso{atanh, sinh, cosh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).tanh ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).tanh ());
 }
 
 /*
 %!test
 %! x = [0, pi*i];
 %! v = [0, 0];
 %! assert (tanh (x), v, sqrt (eps));
 
@@ -2196,23 +2024,20 @@ For example:\n\
 toascii (\"ASCII\")\n\
      @result{} [ 65, 83, 67, 73, 73 ]\n\
 @end group\n\
 \n\
 @end example\n\
 @seealso{char}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xtoascii ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xtoascii ());
 }
 
 /*
 %!assert (toascii (char (0:127)), 0:127)
 %!assert (toascii (" ":"@"), 32:64)
 %!assert (toascii ("A":"Z"), 65:90)
 %!assert (toascii ("[":"`"), 91:96)
 %!assert (toascii ("a":"z"), 97:122)
@@ -2236,23 +2061,20 @@ For example:\n\
 @group\n\
 tolower (\"MiXeD cAsE 123\")\n\
       @result{} \"mixed case 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{toupper}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xtolower ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xtolower ());
 }
 
 DEFALIAS (lower, tolower);
 
 /*
 %!assert (tolower ("OCTAVE"), "octave")
 %!assert (tolower ("123OCTave!_&"), "123octave!_&")
 %!assert (tolower ({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}})
@@ -2298,23 +2120,20 @@ For example:\n\
 @group\n\
 toupper (\"MiXeD cAsE 123\")\n\
       @result{} \"MIXED CASE 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{tolower}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  if (args.length () == 1)
-    retval = args(0).xtoupper ();
-  else
+  if (args.length () != 1)
     print_usage ();
-
-  return retval;
+  
+  return octave_value (args(0).xtoupper ());
 }
 
 DEFALIAS (upper, toupper);
 
 /*
 %!assert (toupper ("octave"), "OCTAVE")
 %!assert (toupper ("123OCTave!_&"), "123OCTAVE!_&")
 %!assert (toupper ({"abc", "def", {"ghi", {"jkl"}}}), {"ABC", "DEF", {"GHI", {"JKL"}}})
