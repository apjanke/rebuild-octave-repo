# HG changeset patch
# User jwe
# Date 948274588 0
#      Wed Jan 19 09:36:28 2000 +0000
# Node ID d25bc039237bec8f505881b833de8f6ebbb198c8
# Parent  e031284eea27befe6e0a6e771d6a97c49022bd81
[project @ 2000-01-19 09:36:14 by jwe]

diff --git a/scripts/audio/record.m b/scripts/audio/record.m
--- a/scripts/audio/record.m
+++ b/scripts/audio/record.m
@@ -21,23 +21,16 @@
 ## @deftypefn {Function File} {} record (@var{sec}, @var{sampling_rate})
 ## Records @var{sec} seconds of audio input into the vector @var{x}.  The
 ## default value for @var{sampling_rate} is 8000 samples per second, or
 ## 8kHz.  The program waits until the user types @key{RET} and then
 ## immediately starts to record.
 ## @end deftypefn
 ## @seealso{lin2mu, mu2lin, loadaudio, saveaudio, playaudio, and setaudio}
 
-## usage:  X = record (sec [, sampling_rate])
-##
-## Records sec seconds of audio into the vector X.
-## The default value for the sampling_rate is 8000, ie. 8kHz.
-## The program waits for you to hit the ENTER key, then the recording
-## starts immediatly.
-
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 19 September 1994
 ## Adapted-By: jwe
 
 function X = record (sec, sampling_rate)
 
   if (nargin == 1)
     sampling_rate = 8000;
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -48,17 +48,17 @@ function saveaudio (name, X, ext, bit)
   endif
 
   [nr, nc] = size (X);
   if (nc != 1)
     if (nr == 1)
       X = X';
       nr = nc;
     else
-      error ("saveaudio: X must be a vector.");
+      error ("saveaudio: X must be a vector");
     endif
   endif
 
   num = fopen ([name, ".", ext], "wb");
 
   if (strcmp (ext, "lin") || strcmp (ext, "raw"))
     if (bit == 8)
       ld = max (abs (X));
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -48,17 +48,17 @@ function l = lcm (a, ...)
   if (nargin > 1)
     va_start;
     for k = 2:nargin;
       a = [a, (va_arg ())];
     endfor
   endif
 
   if (round (a) != a)
-    error ("lcm:  all arguments must be integer");
+    error ("lcm: all arguments must be integer");
   endif
 
   if (any (a) == 0)
     l = 0;
   else
     a = abs (a);
     l = a (1);
     for k = 1:(length (a) - 1)
diff --git a/scripts/finance/fv.m b/scripts/finance/fv.m
--- a/scripts/finance/fv.m
+++ b/scripts/finance/fv.m
@@ -26,54 +26,54 @@
 ## The optional argument @var{method} may be used ot specify whether the
 ## payments are made at the end (@code{"e"}, default) or at the
 ## beginning (@code{"b"}) of each period.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Future value of an investment
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Future value of an investment
 
 function v = fv (r, n, p, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("fv (r, n, p, l, method)");
   endif
 
   if (! (is_scalar (r) && (r > -1)))
-    error ("fv:  r must be a scalar > -1");
+    error ("fv: r must be a scalar > -1");
   elseif (! (is_scalar (n) && (n > 0)))
-    error ("fv:  n must be a positive scalar");
+    error ("fv: n must be a positive scalar");
   elseif (! is_scalar (p))
-    error ("fv:  p must be a scalar.");
+    error ("fv: p must be a scalar");
   endif
 
   if (r != 0)
     v = p * ((1 + r)^n - 1) / r;
   else
     v = p * n;
   endif
 
   if (nargin > 3)
     if (nargin == 5)
       if (! isstr (m))
-        error ("fv:  `method' must be a string");
+        error ("fv: `method' must be a string");
       endif
     elseif isstr (l)
       m = l;
       l = 0;
     else
       m = "e";
     endif
     if strcmp (m, "b")
       v = v * (1 + r);
     endif
     if is_scalar (l)
       v = v + fvl (r, n, l);
     else
-      error ("fv:  l must be a scalar");
+      error ("fv: l must be a scalar");
     endif
   endif
 
 endfunction
 
diff --git a/scripts/finance/fvl.m b/scripts/finance/fvl.m
--- a/scripts/finance/fvl.m
+++ b/scripts/finance/fvl.m
@@ -19,28 +19,28 @@
 ## Return the future value at the end of @var{n} periods of an initial
 ## lump sum investment @var{l}, given a per-period interest rate
 ## @var{r}.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Future value of an initial lump sum investment
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Future value of an initial lump sum investment
 
 function v = fvl (r, n, l)
 
   if (nargin != 3)
     usage ("fvl (r, n, l)");
   endif
 
   if (! (is_scalar (r) && (r > -1)))
-    error ("fvl:  r has to be a scalar > -1");
+    error ("fvl: r has to be a scalar > -1");
   elseif (! (is_scalar (n) && (n > 0)))
-    error ("fvl:  n has to be a positive scalar");
+    error ("fvl: n has to be a positive scalar");
   elseif (! is_scalar (l))
-    error ("fvl:  l has to be a scalar");
+    error ("fvl: l has to be a scalar");
   endif
 
   v = l * (1 + r)^n;
 
 endfunction
\ No newline at end of file
diff --git a/scripts/finance/irr.m b/scripts/finance/irr.m
--- a/scripts/finance/irr.m
+++ b/scripts/finance/irr.m
@@ -18,32 +18,32 @@
 ## @deftypefn {Function File} {} irr (@var{p}, @var{i})
 ## Return the internal rate of return of a series of payments @var{p}
 ## from an initial investment @var{i} (i.e., the solution of
 ## @code{npv (r, p) = i}.  If the second argument is omitted, a value of
 ## 0 is used.
 ## @end deftypefn
 ## @seealso{npv, pv, and rate}
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Internal rate of return of an investment
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Internal rate of return of an investment
 
 function r = irr (p, i)
 
   if (nargin == 1)
     i = 0;
   elseif (! (nargin == 2))
     usage ("irr (p, i)");
   endif
 
   if (! (is_vector (p)))
-    error ("irr:  p must be a vector");
+    error ("irr: p must be a vector");
   else
     p_string = strcat ("[", sprintf ("%.15f, ", p), "]");
   endif
 
   if (! is_scalar (i))
-    error ("irr:  i must be a scalar");
+    error ("irr: i must be a scalar");
   endif
 
   r = fsolve (sprintf ("npv (x, %s) - %g", p_string, i), 0.01);
 
 endfunction
diff --git a/scripts/finance/nper.m b/scripts/finance/nper.m
--- a/scripts/finance/nper.m
+++ b/scripts/finance/nper.m
@@ -26,36 +26,36 @@
 ## payments are made at the end (@var{"e"}, default) or at the beginning
 ## (@var{"b"}) of each period.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
 ## @end deftypefn
 ## @seealso{pv, pmt, rate, and npv}
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Number of payments needed for amortizing a loan
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Number of payments needed for amortizing a loan
 
 function n = nper (r, p, a, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("nper (r, p, a, l, method)");
   endif
 
   if (! (is_scalar (r) && (r > -1)))
-    error ("nper:  r must be a scalar > -1");
+    error ("nper: r must be a scalar > -1");
   elseif (! is_scalar (p))
-    error ("nper:  p must be a scalar");
+    error ("nper: p must be a scalar");
   elseif (! is_scalar (a))
-    error ("nper:  a must be a scalar");
+    error ("nper: a must be a scalar");
   endif
 
   if (nargin == 5)
     if (! isstr (m))
-      error ("nper:  `method' must be a string");
+      error ("nper: `method' must be a string");
     endif
   elseif (nargin == 4)
     if (isstr (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
diff --git a/scripts/finance/npv.m b/scripts/finance/npv.m
--- a/scripts/finance/npv.m
+++ b/scripts/finance/npv.m
@@ -25,46 +25,46 @@
 ## The optional argument @var{i} may be used to specify an initial
 ## investment.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
 ## @end deftypefn
 ## @seealso{irr and pv}
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Net present value of a series of payments
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Net present value of a series of payments
 
 function v = npv (r, p, i)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("npv (r, p, i");
   endif
 
   if (! (is_vector (p)))
-    error ("npv:  p has to be a vector");
+    error ("npv: p has to be a vector");
   else
     n = length (p);
     p = reshape (p, 1, n);
   endif
 
   if (any (any (r <= -1)))
-    error ("npv:  all interest rates must be > -1");
+    error ("npv: all interest rates must be > -1");
   endif
   if (is_scalar (r))
     d = 1 ./ (1 + r) .^ (0 : n);
   elseif (is_vector (r) && (length (r) == n))
     d = [1, (1 ./ cumprod (reshape (1 + r, 1, n)))];
   else
     error ("npv: r must be a scalar or a vector of the same length as p");
   endif
 
   if (nargin == 3)
     if (! is_scalar (i))
-      error ("npv:  I_0 must be a scalar");
+      error ("npv: I_0 must be a scalar");
     endif
   else
     i = 0;
   endif
 
   p = [i, p];
   v = sum (d .* p);
 
diff --git a/scripts/finance/pmt.m b/scripts/finance/pmt.m
--- a/scripts/finance/pmt.m
+++ b/scripts/finance/pmt.m
@@ -23,36 +23,36 @@
 ## lump-sum payment.
 ##
 ## The optional argument @var{method} may be used to specify whether
 ## payments are made at the end (@var{"e"}, default) or at the beginning
 ## (@var{"b"}) of each period.
 ## @end deftypefn
 ## @seealso{pv, nper, and rate}
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Amount of periodic payment needed to amortize a loan
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Amount of periodic payment needed to amortize a loan
 
 function p = pmt (r, n, a, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("pmt (r, n, a, l, method)");
   endif
 
   if (! (is_scalar (r) && (r > -1)))
-    error ("pmt:  rate must be a scalar > -1");
+    error ("pmt: rate must be a scalar > -1");
   elseif (! (is_scalar (n) && (n > 0)))
-    error ("pmt:  n must be a positive scalar");
+    error ("pmt: n must be a positive scalar");
   elseif (! (is_scalar (a) && (a > 0)))
-    error ("pmt:  a must be a positive scalar.");
+    error ("pmt: a must be a positive scalar");
   endif
 
   if (nargin == 5)
     if (! isstr (m))
-      error ("pmt:  `method' must be a string");
+      error ("pmt: `method' must be a string");
     endif
   elseif (nargin == 4)
     if (isstr (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
diff --git a/scripts/finance/pv.m b/scripts/finance/pv.m
--- a/scripts/finance/pv.m
+++ b/scripts/finance/pv.m
@@ -26,54 +26,54 @@
 ## payments are made at the end (@code{"e"}, default) or at the
 ## beginning (@code{"b"}) of each period.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
 ## @end deftypefn
 ## @seealso{pmt, nper, rate, and npv}
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Present value of an investment
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Present value of an investment
 
 function v = pv (r, n, p, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("pv (r, n, p, l, method)");
   endif
 
   if (! (is_scalar (r) && (r > -1)))
-    error ("pv:  r must be a scalar > -1");
+    error ("pv: r must be a scalar > -1");
   elseif (! (is_scalar (n) && (n > 0)))
-    error ("pv:  n must be a positive scalar");
+    error ("pv: n must be a positive scalar");
   elseif (! is_scalar (p))
-    error ("pv:  p must be a scalar.");
+    error ("pv: p must be a scalar");
   endif
 
   if (r != 0)
     v = p * (1 - (1 + r)^(-n)) / r;
   else
     v = p * n;
   endif
 
   if (nargin > 3)
     if (nargin == 5)
       if (! isstr (m))
-        error ("pv:  `method' must be a string");
+        error ("pv: `method' must be a string");
       endif
     elseif (isstr (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
     if (strcmp (m, "b"))
       v = v * (1 + r);
     endif
     if (is_scalar (l))
       v = v + pvl (r, n, l);
     else
-      error ("pv:  l must be a scalar");
+      error ("pv: l must be a scalar");
     endif
   endif
 
 endfunction
 
diff --git a/scripts/finance/pvl.m b/scripts/finance/pvl.m
--- a/scripts/finance/pvl.m
+++ b/scripts/finance/pvl.m
@@ -19,28 +19,28 @@
 ## Return the present value of an investment that will pay off @var{p}
 ## in one lump sum at the end of @var{n} periods, given the interest
 ## rate @var{r}.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Present value of an investment that pays off at the end
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Present value of an investment that pays off at the end
 
 function v = pvl (r, n, p)
 
   if (nargin != 3)
     usage ("pvl (r, n, p)");
   endif
 
   if (! (is_scalar (r) && (r > -1)))
-    error ("pvl:  r has to be a scalar > -1");
+    error ("pvl: r has to be a scalar > -1");
   elseif (! (is_scalar (n) && (n > 0)))
-    error ("pvl:  n has to be a positive scalar");
+    error ("pvl: n has to be a positive scalar");
   elseif (! is_scalar (p))
-    error ("pvl:  p has to be a scalar");
+    error ("pvl: p has to be a scalar");
   endif
 
   v = p / (1 + r)^n;
 
 endfunction
diff --git a/scripts/finance/rate.m b/scripts/finance/rate.m
--- a/scripts/finance/rate.m
+++ b/scripts/finance/rate.m
@@ -23,49 +23,49 @@
 ## lump-sum payment made at the end of @var{n} periods.
 ##
 ## The optional string argument @var{method} may be used to specify
 ## whether payments are made at the end (@code{"e"}, default) or at the
 ## beginning (@code{"b"}) of each period.
 ## @end deftypefn
 ## @seealso{pv, pmt, nper, and npv}
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Rate of return of an investment
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Rate of return of an investment
 
 function r = rate (n, p, v, l, m)
 
   if ((nargin < 3) || (nargin > 5))
     usage ("rate (n, p, v, l, method)");
   endif
 
   if (! (is_scalar (n) && (n > 0)))
-    error ("rate:  n must be a positive scalar");
+    error ("rate: n must be a positive scalar");
   elseif (! is_scalar (p))
-    error ("rate:  p must be a scalar");
+    error ("rate: p must be a scalar");
   elseif (! is_scalar (v))
-    error ("rate:  p must be a scalar");
+    error ("rate: p must be a scalar");
   endif
 
   if (nargin == 5)
     if (! isstr (m))
-      error ("rate:  `method' must be a string");
+      error ("rate: `method' must be a string");
     endif
   elseif (nargin == 4)
     if (isstr (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
   else
     l = 0;
     m = "e";
   endif
 
   if (! is_scalar (l))
-    error ("rate:  l must be a scalar");
+    error ("rate: l must be a scalar");
   endif
 
   [r, info] = fsolve (sprintf ("pv (x, %g, %g, %g, \"%s\") - %g",
 			       n, p, l, m, v), 0);
 
 endfunction
diff --git a/scripts/finance/vol.m b/scripts/finance/vol.m
--- a/scripts/finance/vol.m
+++ b/scripts/finance/vol.m
@@ -20,44 +20,44 @@
 ## The number of data sets per period is given by @var{m} (e.g. the
 ## number of data per year if you want to compute the volatility per
 ## year).  The optional parameter @var{n} gives the number of past
 ## periods used for computation, if it is omitted, a value of 1 is used.
 ## If @var{t} is the number of rows of @var{x}, @code{vol} returns the
 ## volatility from @code{n*m} to @var{t}.
 ## @end deftypefn
 
-## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description:  Volatility of financial time series data
+## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
+## Description: Volatility of financial time series data
 
 function retval = vol (X, m, n)
 
   if (nargin < 2)
     usage ("vol (X, m, n)");
   endif
 
   [xr, xc] = size (X);
 
   if (nargin > 2)
     if (n * m > xr)
-      error ("vol:  I need more data!");
+      error ("vol: I need more data!");
     endif
   else
     n = 1;
     if (n * m > xr)
-      error ("vol:  I need more data!");
+      error ("vol: I need more data!");
     endif
   endif
 
   U = zeros (xr - 1, xc);
 
   if (all (X))
     U = X ((2 : xr), :) ./ X((1 : (xr-1)), :);
   else
-    error ("vol:  zero element in X");
+    error ("vol: zero element in X");
   endif
 
   U = log(U);
   U = U - ones (xr - 1, 1) * sum (U) / (xr - 1);
 
   retval = zeros (xr - n * m, xc);
 
   retval(1, :) = sumsq (U((1 : n*m), :));
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{x} =} postpad (@var{x}, @var{l}, @var{c})
 ## See prepad.
+## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 
 function y = postpad (x, l, c)
 
   if (nargin == 2)
     c = 0;
diff --git a/scripts/general/triu.m b/scripts/general/triu.m
--- a/scripts/general/triu.m
+++ b/scripts/general/triu.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} triu (@var{a}, @var{k})
 ## See tril.
+## @end deftypefn
 
 ## Author: jwe
 
 function retval = triu (x, k)
 
   if (nargin > 0)
     [nr, nc] = size (x);
     retval = zeros (nr, nc);
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -58,20 +58,20 @@ function cmap = colormap (map)
         unwind_protect_cleanup
           default_eval_print_flag = save_default_eval_print_flag;
         end_unwind_protect
       endif
     endif
 
     if (! isempty (map))
       if (columns (map) != 3)
-        error ("colormap: map must have 3 columns: [R,G,B].");
+        error ("colormap: map must have 3 columns: [R,G,B]");
       endif
       if (min (min (map)) < 0 || max (max (map)) > 1)
-        error ("colormap: map must have values in [0,1].");
+        error ("colormap: map must have values in [0,1]");
       endif
       ## Set the new color map
       __current_color_map__ = map;
     endif
 
   endif
 
   ## Return current color map.
diff --git a/scripts/linear-algebra/dmult.m b/scripts/linear-algebra/dmult.m
--- a/scripts/linear-algebra/dmult.m
+++ b/scripts/linear-algebra/dmult.m
@@ -15,25 +15,25 @@
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dmult (@var{a}, @var{b})
 ## If @var{a} is a vector of length @code{rows (@var{b})}, return
 ## @code{diag (@var{a}) * @var{b}} (but computed much more efficiently).
 ## @end deftypefn
 
-## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
-## Description:  Rescale the rows of a matrix
+## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
+## Description: Rescale the rows of a matrix
 
 function M = dmult (a, B)
 
   if (nargin != 2)
     usage ("dmult (a, B)");
   endif
 
   s = size (a);
   if ((min (s) > 1) || (max (s) != rows (B)))
-    error ("dmult:  a must be a vector of length rows (B)");
+    error ("dmult: a must be a vector of length rows (B)");
   endif
 
   M = (reshape (a, max (s), 1) * ones (1, columns (B))) .* B;
 
 endfunction
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -30,17 +30,17 @@
 
 function v = vech (x)
 
   if (nargin != 1)
     usage ("vech (x)");
   endif
 
   if (! is_square (x))
-    error ("vech:  x must be square");
+    error ("vech: x must be square");
   endif
 
   ## This should be quicker than having an inner `for' loop as well.
   ## Ideally, vech should be written in C++.
   n = rows (x);
   v = zeros ((n+1)*n/2, 1);
   count = 0;
   for j = 1 : n
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -54,17 +54,17 @@
 function b = bincoeff (n, k)
 
   if (nargin != 2)
     usage ("bincoeff (n, k)");
   endif
 
   [retval, n, k] = common_size (n, k);
   if (retval > 0)
-    error ("bincoeff:  n and k must be of common size or scalars");
+    error ("bincoeff: n and k must be of common size or scalars");
   endif
 
   [r, c] = size (n);
   s = r * c;
   n   = reshape (n, s, 1);
   k   = reshape (k, s, 1);
   b   = zeros (s, 1);
 
diff --git a/scripts/miscellaneous/toc.m b/scripts/miscellaneous/toc.m
--- a/scripts/miscellaneous/toc.m
+++ b/scripts/miscellaneous/toc.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} toc ()
 ## See tic.
+## @end deftypefn
 
 ## Author: jwe
 
 function secs = toc ()
 
   if (nargin != 0)
     warning ("toc: ignoring extra arguments");
   endif
diff --git a/scripts/plot/bottom_title.m b/scripts/plot/bottom_title.m
--- a/scripts/plot/bottom_title.m
+++ b/scripts/plot/bottom_title.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} bottom_title (@var{string})
 ## See top_title.
+## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
 
 function bottom_title (text)
 
   if (! gnuplot_has_multiplot)
     error ("bottom_title: gnuplot does not appear to support this feature");
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} ylabel (@var{string})
 ## See xlabel.
+## @end deftypefn
 
 ## Author: jwe
 
 function ylabel (text)
 
   if (nargin != 1)
     usage ("ylabel (text)");
   endif
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} zlabel (@var{string})
 ## See xlabel.
+## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Created: 3 July 95
 ## Adapted-By: jwe
 
 function zlabel (text)
 
   if (nargin != 1)
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -61,17 +61,17 @@
 
 function A = compan (c)
 
   if (nargin != 1)
     usage ("compan (vector)");
   endif
 
   if (! is_vector (c))
-    error("compan: expecting a vector argument.");
+    error ("compan: expecting a vector argument");
   endif
 
   ## Ensure that c is a row vector.
 
   if (rows (c) > 1)
     c = c.';
   endif
 
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -12,17 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} polyder (@var{c})
 ## See polyderiv.
+## @end deftypefn
 
 ## Author: jwe
 
 function q = polyder (p)
 
   if (nargin == 1)
     q = polyderiv (p);
   else
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -36,17 +36,17 @@
 
 function y = polyval (c, x)
 
   if (nargin != 2)
     usage ("polyval (c, x)");
   endif
 
   if (! (is_vector (c) || isempty (c)))
-    error ("polyval: first argument must be a vector.");
+    error ("polyval: first argument must be a vector");
   endif
 
   if (isempty (x))
     y = [];
     return;
   endif
 
   if (length (c) == 0)
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -36,21 +36,21 @@
 
 function y = polyvalm (c, x)
 
   if (nargin != 2)
     usage ("polyvalm (c, x)");
   endif
 
   if (! (is_vector (c) || isempty (c)))
-    error ("polyvalm: first argument must be a vector.");
+    error ("polyvalm: first argument must be a vector");
   endif
 
   if (! is_square (x))
-    error("polyvalm: second argument must be a square matrix.");
+    error ("polyvalm: second argument must be a square matrix");
   endif
 
   if (isempty (c))
     y = [];
     return;
   endif
 
   [v, d] = eig (x);
diff --git a/scripts/quaternion/qderiv.m b/scripts/quaternion/qderiv.m
--- a/scripts/quaternion/qderiv.m
+++ b/scripts/quaternion/qderiv.m
@@ -41,16 +41,16 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function Dmat = qderivmat (Omega)
 
   Omega = vec (Omega);
 
   if (length (Omega) != 3)
-    error ("qderivmat: Omega must be a length 3 vector.");
+    error ("qderivmat: Omega must be a length 3 vector");
   endif
 
   Dmat = 0.5 * [      0.0,  Omega(3), -Omega(2),  Omega(1);
                 -Omega(3),       0.0,  Omega(1),  Omega(2);
                  Omega(2), -Omega(1),       0.0,  Omega(3);
                 -Omega(1), -Omega(2), -Omega(3),       0.0 ];
 endfunction
diff --git a/scripts/quaternion/qderivmat.m b/scripts/quaternion/qderivmat.m
--- a/scripts/quaternion/qderivmat.m
+++ b/scripts/quaternion/qderivmat.m
@@ -41,16 +41,16 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Adapted-By: jwe
 
 function Dmat = qderivmat (Omega)
 
   Omega = vec (Omega);
 
   if (length (Omega) != 3)
-    error ("qderivmat: Omega must be a length 3 vector.");
+    error ("qderivmat: Omega must be a length 3 vector");
   endif
 
   Dmat = 0.5 * [      0.0,  Omega(3), -Omega(2),  Omega(1);
                 -Omega(3),       0.0,  Omega(1),  Omega(2);
                  Omega(2), -Omega(1),       0.0,  Omega(3);
                 -Omega(1), -Omega(2), -Omega(3),       0.0 ];
 endfunction
diff --git a/scripts/quaternion/qtransv.m b/scripts/quaternion/qtransv.m
--- a/scripts/quaternion/qtransv.m
+++ b/scripts/quaternion/qtransv.m
@@ -36,17 +36,17 @@
 
 function vi = qtransv (vb, qib)
 
   if (! is_vector (vb) || length (vb) != 3)
     error ("qtransv: v(%d,%d) must be a 3-D vector", rows (vb), columns (vb));
   elseif (! is_vector (qib) || length (qib) != 4)
     error ("qtransv: q(%d,%d) must be a quaternion", rows (qib), columns (qib));
   elseif (max (abs (imag (vb))) + max (abs (imag (qib))) != 0)
-    error ("qtransv: input values must be real.");
+    error ("qtransv: input values must be real");
   endif
 
   qr = qib(4);
   qimag = vec (qib(1:3));
   vb = vec (vb);
   vi = (2*qr^2 - 1)*vb + 2*qimag*(qimag'*vb) + 2*qr*cross (qimag, vb);
 
 endfunction
diff --git a/scripts/quaternion/qtransvmat.m b/scripts/quaternion/qtransvmat.m
--- a/scripts/quaternion/qtransvmat.m
+++ b/scripts/quaternion/qtransvmat.m
@@ -28,17 +28,17 @@
 ## Adapted-By: jwe
 
 function Aib = qtransvmat (qib)
 
   if (! is_vector(qib) || length (qib) != 4)
     error ("qtransvmat: q(%d,%d) must be a quaternion", rows (qib), \
 	   columns (qib));
   elseif (max (abs (imag (qib))) != 0)
-    error("qtransvmat: input values must be real.");
+    error ("qtransvmat: input values must be real");
   endif
 
   Aib = [(2.*(qib(1)^2 + qib(4)^2) -1.),
 	 (2.*(qib(1)*qib(2)-qib(3)*qib(4))),
 	 (2.*(qib(1)*qib(3)+qib(2)*qib(4)));
 	 (2.*(qib(1)*qib(2)+qib(3)*qib(4))),
 	 (2.*(qib(2)*qib(2)+qib(4)*qib(4))-1.),
 	 (2.*(qib(2)*qib(3)-qib(1)*qib(4)));
diff --git a/scripts/quaternion/quaternion.m b/scripts/quaternion/quaternion.m
--- a/scripts/quaternion/quaternion.m
+++ b/scripts/quaternion/quaternion.m
@@ -80,17 +80,17 @@ function [a, b, c, d] = quaternion (w, x
     vv = w;
     theta = x;
 
     if (! is_vector (vv) || length (vv) != 3)
       error ("vv must be a length three vector");
     elseif (! is_scalar (theta))
       error ("theta must be a scalar");
     elseif (norm (vv) == 0)
-      error ("quaternion: vv is zero.");
+      error ("quaternion: vv is zero");
     elseif (abs (norm (vv) - 1) > 1e-12)
       warning ("quaternion: ||vv|| != 1, normalizing")
       vv = vv / norm (vv);
     endif
 
     if (abs (theta) > 2*pi)
       warning ("quaternion: |theta| > 2 pi, normalizing")
       theta = rem (theta, 2*pi);
@@ -99,17 +99,17 @@ function [a, b, c, d] = quaternion (w, x
     d = cos (theta / 2);
     a = quaternion (vv(1), vv(2), vv(3), d);
 
   case(4)
     if (nargout != 1)
       usage ("w = quaterion (a, b, c, d)");
     endif
     if (! (is_scalar (w) && is_scalar (x) && is_scalar (y) && is_scalar (z)))
-      error ("input values must be scalars.");
+      error ("input values must be scalars");
     endif
     a = [w, x, y, z];
 
   otherwise
     usage ("[a, b, c, d] = quaternion (w) or a = quaternion (w, x, y, z)");
 
   endswitch
 
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -76,17 +76,17 @@ function [pval, lm] = arch_test (y, X, p
   y   = reshape (y, T, 1);
   [rx, cx] = size (X);
   if ((rx == 1) && (cx == 1))
     X = autoreg_matrix (y, X);
   elseif (! (rx == T))
     error ("arch_test: either rows(X) == length(y), or X is a scalar");
   endif
   if (! (is_scalar(p) && (rem(p, 1) == 0) && (p > 0)))
-    error ("arch_test: p must be a positive integer.");
+    error ("arch_test: p must be a positive integer");
   endif
 
   [b, v_b, e] = ols (y, X);
   Z    = autoreg_matrix (e.^2, p);
   f    = e.^2 / v_b - ones (T, 1);
   f    = Z' * f;
   lm   = f' * inv (Z'*Z) * f / 2;
   pval = 1 - chisquare_cdf (lm, p);
diff --git a/scripts/specfun/betai.m b/scripts/specfun/betai.m
--- a/scripts/specfun/betai.m
+++ b/scripts/specfun/betai.m
@@ -12,20 +12,24 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} betai (@var{a}, @var{b}, @var{x})
 ## This function is provided for compatibility with older versions of
 ## Octave.  New programs should use betainc instead.
 ##
-## betai (a, b, x) is the same as betainc (x, a, b).
+## @code{betai (@var{a}, @var{b}, @var{x})} is the same as @code{betainc
+## (@var{x}, @var{a}, @var{b})}. 
+## @end deftypefn
 
 ## Author: jwe
 ## Created: 30 Jan 1998
 
 function retval = betai (a, b, x)
 
   if (nargin == 3)
     retval = betainc (x, a, b);
diff --git a/scripts/specfun/gammai.m b/scripts/specfun/gammai.m
--- a/scripts/specfun/gammai.m
+++ b/scripts/specfun/gammai.m
@@ -12,20 +12,24 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
+## -*- texinfo -*-
+## @deftypefn {Function File} {} gammai (@var{a}, @var{x})
 ## This function is provided for compatibility with older versions of
-## Octave.  New programs should use gammainc instead.
+## Octave.  New programs should use @code{gammainc} instead.
 ##
-## gammai (a, x) is the same as gammainc (x, a).
+## @code{gammai (@var{a}, @var{x})} is the same as @code{gammainc
+## (@var{x}, @var{a})}.
+## @end deftypefn
 
 ## Author: jwe
 ## Created: 30 Jan 1998
 
 function retval = gammai (a, x)
 
   if (nargin == 2)
     retval = gammainc (x, a);
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -29,12 +29,12 @@ function retval = center (x)
     usage ("center (x)");
   endif
 
   if is_vector (x)
     retval = x - mean(x);
   elseif is_matrix (x)
     retval = x - ones (rows (x), 1) * mean(x);
   else
-    error ("center: x must be a vector or a matrix.");
+    error ("center: x must be a vector or a matrix");
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -37,17 +37,17 @@ function c = cov (x, y)
   endif
   n = rows (x);
 
   if (nargin == 2)
     if (rows (y) == 1)
       y = y';
     endif
     if (rows (y) != n)
-      error ("cov: x and y must have the same number of observations.");
+      error ("cov: x and y must have the same number of observations");
     endif
     x = x - ones (n, 1) * sum (x) / n;
     y = y - ones (n, 1) * sum (y) / n;
     c = conj (x' * y / (n - 1));
   elseif (nargin == 1)
     x = x - ones (n, 1) * sum (x) / n;
     c = conj (x' * x / (n - 1));
   endif
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -59,12 +59,12 @@ function retval = kurtosis (x)
   elseif (is_matrix (x))
     [nr, nc] = size (x);
     x = x - ones (nr, 1) * mean (x);
     retval = zeros (1, nc);
     s      = std (x);
     ind    = find (s > 0);
     retval (ind) = sum (x (:, ind) .^ 4) ./ (nr * s (ind) .^ 4) - 3;
   else
-    error ("kurtosis: x has to be a matrix or a vector.");
+    error ("kurtosis: x has to be a matrix or a vector");
   endif
 
 endfunction
diff --git a/scripts/statistics/base/mahalanobis.m b/scripts/statistics/base/mahalanobis.m
--- a/scripts/statistics/base/mahalanobis.m
+++ b/scripts/statistics/base/mahalanobis.m
@@ -34,17 +34,17 @@ function retval = mahalanobis (X, Y)
   if (nargin != 2)
     usage ("mahalanobis (X, Y)");
   endif
 
   [xr, xc] = size (X);
   [yr, yc] = size (Y);
 
   if (xc != yc)
-    error ("mahalanobis: X and Y must have the same number of columns.");
+    error ("mahalanobis: X and Y must have the same number of columns");
   endif
 
   Xm = sum (X) / xr;
   Ym = sum (Y) / yr;
 
   X = X - ones (xr, 1) * Xm;
   Y = Y - ones (yr, 1) * Ym;
 
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-##  -*- texinfo -*-
+## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{beta}, @var{sigma}, @var{r}] =} ols (@var{y}, @var{x})
 ## Ordinary least squares estimation for the multivariate model
 ## @iftex
 ## @tex
 ## $y = x b + e$
 ## with
 ## $\bar{e} = 0$, and cov(vec($e$)) = kron ($s, I$)
 ## @end tex
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -42,17 +42,17 @@
 
 function [p, y] = ppplot (x, dist, ...)
 
   if (nargin < 1)
     usage ("ppplot (x, dist, params)");
   endif
 
   if (! is_vector (x))
-    error ("ppplot: x must be a vector.");
+    error ("ppplot: x must be a vector");
   endif
 
   s = sort (x);
   n = length (x);
   p = ((1 : n)' - 0.5) / n;
   if (nargin == 1)
     F = "stdnormal_cdf";
   else
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -44,17 +44,17 @@
 
 function [q, s] = qqplot (x, dist, ...)
 
   if (nargin < 1)
     usage ("qqplot (x, dist, params)");
   endif
 
   if (! (is_vector(x)))
-    error ("qqplot: x must be a vector.");
+    error ("qqplot: x must be a vector");
   endif
 
   s = sort (x);
   n = length (x);
   t = ((1 : n)' - .5) / n;
   if (nargin == 1)
     f = "stdnormal_inv";
   else
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -59,12 +59,12 @@ function retval = skewness (x)
   elseif (is_matrix (x))
     [nr, nc] = size (x);
     x = x - ones (nr, 1) * mean (x);
     retval = zeros (1, nc);
     s      = std (x);
     ind    = find (s > 0);
     retval (ind) = sum (x (:, ind) .^ 3) ./ (nr * s (ind) .^ 3);
   else
-    error ("skewness: x has to be a matrix or a vector.");
+    error ("skewness: x has to be a matrix or a vector");
   endif
 
 endfunction
diff --git a/scripts/statistics/base/studentize.m b/scripts/statistics/base/studentize.m
--- a/scripts/statistics/base/studentize.m
+++ b/scripts/statistics/base/studentize.m
@@ -37,12 +37,12 @@ function t = studentize (x)
     else
       t = (x - mean (x)) / std (x);
     endif
   elseif is_matrix (x)
     l = ones (rows (x), 1);
     t = x - l * mean (x);
     t = t ./ (l * max ([(std (t)); (! any (t))]));
   else
-    error ("studentize: x must be a vector or a matrix.");
+    error ("studentize: x must be a vector or a matrix");
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/distributions/f_pdf.m b/scripts/statistics/distributions/f_pdf.m
--- a/scripts/statistics/distributions/f_pdf.m
+++ b/scripts/statistics/distributions/f_pdf.m
@@ -22,17 +22,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description: PDF of the F distribution
 
 function pdf = f_pdf (x, m, n)
 
   if (nargin != 3)
-    usage ("f_pdf (x, m, n).");
+    usage ("f_pdf (x, m, n)");
   endif
 
   [retval, x, m, n] = common_size (x, m, n);
   if (retval > 0)
     error ("f_pdf: x, m and n must be of common size or scalar");
   endif
 
   [r, c] = size (x);
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -26,17 +26,17 @@
 function cdf = stdnormal_cdf (x)
 
   if (nargin != 1)
     usage ("stdnormal_cdf (x)");
   endif
 
   [r_x, c_x] = size (x);
   if (r_x * c_x == 0)
-    error ("stdnormal_cdf: x must not be empty.");
+    error ("stdnormal_cdf: x must not be empty");
   endif
 
   cdf = (ones (r_x, c_x) + erf (x / sqrt (2))) / 2;
 
 endfunction
 
 
 
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -36,24 +36,24 @@
 function [pval, Tsq] = hotelling_test (x, m)
 
   if (nargin != 2)
     usage ("hotelling_test (x, m)");
   endif
 
   if (is_vector (x))
     if (! is_scalar (m))
-      error ("hotelling_test: If x is a vector, m must be a scalar.");
+      error ("hotelling_test: if x is a vector, m must be a scalar");
     endif
     n = length (x);
     p = 1;
   elseif (is_matrix (x))
     [n, p] = size (x);
     if (n <= p)
-      error ("hotelling_test: x must have more rows than columns.");
+      error ("hotelling_test: x must have more rows than columns");
     endif
     if (is_vector (m) && length (m) == p)
       m = reshape (m, 1, p);
     else
       error ("hotelling_test: if x is a matrix, m must be a vector of length columns (x)");
     endif
   else
     error ("hotelling_test: x must be a matrix or vector");
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -44,17 +44,17 @@ function [pval, Tsq] = hotelling_test_2 
 
   if (nargin != 2)
     usage ("hotelling_test_2 (x, y)");
   endif
 
   if (is_vector (x))
     n_x = length (x);
     if (! is_vector (y))
-      error ("hotelling_test_2: If x is a vector, y must be too.");
+      error ("hotelling_test_2: if x is a vector, y must also be a vector");
     else
       n_y = length (y);
       p   = 1;
     endif
   elseif (is_matrix (x))
     [n_x, p] = size (x);
     [n_y, q] = size (y);
     if (p != q)
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -49,17 +49,17 @@
 
 function [pval, ks] = kolmogorov_smirnov_test (x, dist, ...)
 
   if (nargin < 2)
     usage ("[pval, ks] = kolmogorov_smirnov_test (x, dist,, params, alt)");
   endif
 
   if (! is_vector (x))
-    error ("kolmogorov_smirnov_test: x must be a vector.");
+    error ("kolmogorov_smirnov_test: x must be a vector");
   endif
 
   n = length (x);
   s = sort (x);
   f = sprintf ("%s_cdf", dist);
 
   alt  = "!=";
 
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -42,24 +42,24 @@
 
 function [pval, ks] = kolmogorov_smirnov_test_2 (x, y, alt)
 
   if (nargin < 2 || nargin > 3)
     usage ("[pval, ks] = kolmogorov_smirnov_test_2 (x, y, tol)");
   endif
 
   if (! (is_vector (x) && is_vector (y)))
-    error ("kolmogorov_smirnov_test_2: both x and y must be vectors.");
+    error ("kolmogorov_smirnov_test_2: both x and y must be vectors");
   endif
 
   if (nargin == 2)
     alt = "!=";
   else
     if (! isstr (alt))
-      error ("kolmogorov_smirnov_test_2: alt must be a string.");
+      error ("kolmogorov_smirnov_test_2: alt must be a string");
     endif
   endif
 
   n_x = length (x);
   n_y = length (y);
   n   = n_x * n_y / (n_x + n_y);
   x   = reshape (x, n_x, 1);
   y   = reshape (y, n_y, 1);
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -41,20 +41,20 @@
 
 function [pval, t, df] = t_test (x, m, alt)
 
   if ((nargin < 2) || (nargin > 3))
     usage ("[pval, t, df] = t_test (x, m, alt)");
   endif
 
   if (! is_vector (x))
-    error ("t_test: x must be a vector.");
+    error ("t_test: x must be a vector");
   endif
   if (! is_scalar (m))
-    error ("t_test: m must be a scalar.");
+    error ("t_test: m must be a scalar");
   endif
 
   n   = length (x);
   df  = n - 1;
   t   = sqrt (n) * (sum (x) / n - m) / std (x);
   cdf = t_cdf (t, df);
 
   if (nargin == 2)
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -41,23 +41,23 @@
 
 function [pval, z] = z_test (x, m, v, alt)
 
   if ((nargin < 3) || (nargin > 4))
     usage ("[pval, z] = z_test (x, m, v, alt)");
   endif
 
   if (! is_vector (x))
-    error ("z_test: x must be a vector.");
+    error ("z_test: x must be a vector");
   endif
   if (! is_scalar (m))
-    error ("z_test: m must be a scalar.");
+    error ("z_test: m must be a scalar");
   endif
   if (! (is_scalar (v) && (v > 0)))
-    error ("z_test: v must be a positive scalar.");
+    error ("z_test: v must be a positive scalar");
   endif
 
   n = length (x);
   z = sqrt (n/v) * (sum (x) / n - m);
   cdf = stdnormal_cdf (z);
 
   if (nargin == 3)
     alt = "!=";
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -44,17 +44,17 @@ function [pval, z] = z_test_2 (x, y, v_x
   if ((nargin < 4) || (nargin > 5))
     usage ("[pval, z] = z_test_2 (x, y, v_x, v_y, alt)");
   endif
 
   if (! (is_vector (x) && is_vector (y)))
     error("z_test_2: both x and y must be vectors");
   elseif (! (is_scalar (v_x) && (v_x > 0)
              && is_scalar (v_y) && (v_y > 0)))
-    error ("z_test_2: both v_x and v_y must be positive scalars.");
+    error ("z_test_2: both v_x and v_y must be positive scalars");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
   mu_y = sum (y) / n_y;
   z    = (mu_x - mu_y) / sqrt (v_x / n_x + v_y / n_y);
   cdf  = stdnormal_cdf (z);
diff --git a/scripts/strings/com2str.m b/scripts/strings/com2str.m
--- a/scripts/strings/com2str.m
+++ b/scripts/strings/com2str.m
@@ -36,17 +36,17 @@ function retval = com2str (zz, flg)
   if (nargin < 1 || nargin > 2)
     usage ("com2str (zz, flg)");
   endif
   if (nargin == 1)
     flg = 0;
   endif
 
   if (! (is_scalar (zz) && is_scalar (flg)))
-    error("com2str: arguments must be a scalar.");
+    error ("com2str: arguments must be a scalar");
   endif
 
   if (flg != 0 && flg != 1)
     error ("invalid flg value: %d", flg);
   endif
 
   sgns = "+-";
   rz = real (zz);
diff --git a/scripts/strings/split.m b/scripts/strings/split.m
--- a/scripts/strings/split.m
+++ b/scripts/strings/split.m
@@ -77,12 +77,12 @@ function m = split (s, t)
       cmd = sprintf ("%s\"%s\"", cmd, undo_string_escapes (s (range)));
     endif
 
   endfor
 
   m = eval (sprintf ("str2mat (%s);", cmd));
 
   else
-    error ("split:  both s and t must be strings");
+    error ("split: both s and t must be strings");
   endif
 
 endfunction
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -105,17 +105,20 @@ Compute the inverse of the square matrix
   return retval;
 }
 
 // XXX FIXME XXX -- this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
 DEFUN_DLD (inverse, args, nargout,
-  "inverse (X): inverse of a square matrix")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} inverse (@var{a})\n\
+See inv.\n\
+@end deftypefn")
 {
   return Finv (args, nargout);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/lpsolve.cc b/src/DLD-FUNCTIONS/lpsolve.cc
--- a/src/DLD-FUNCTIONS/lpsolve.cc
+++ b/src/DLD-FUNCTIONS/lpsolve.cc
@@ -26,37 +26,40 @@ Software Foundation, 59 Temple Place - S
 
 #include "LPsolve.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 DEFUN_DLD (lp_solve, , ,
-  "lp_solve (): solve linear programs using lp_solve.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} lp_solve ()\n\
+Not implemented yet...\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   // Force a bad value of inform, and empty matrices for x and phi.
 
   Matrix m;
   retval(2) = -1.0;
   retval(1) = m;
   retval(0) = m;
 
   error ("lp_solve: not implemented yet");
 
   return retval;
 }
 
 DEFUN_DLD (lp_solve_options, , ,
-  "lp_solve_options (KEYWORD, VALUE)\n\
-\n\
-Set or show options for lp_solve.  Keywords may be abbreviated\n\
-to the shortest match.")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} lp_solve_options ()\n\
+Not implemented yet...\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   error ("lp_solve_options: not implemented yet");
 
   return retval;
 }
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1581,20 +1581,26 @@ Position file relative to the beginning.
 Position file relative to the current position.\n\
 \n\
 @item SEEK_END\n\
 used with fseek to position file relative to the end.\n\
 @end table\n\
 @end defvr");
 
   DEFCONSTX ("SEEK_CUR", SBV_SEEK_CUR, 0.0,
-    "See SEEK_SET");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} SEEK_CUR\n\
+See SEEK_SET.\n\
+@end defvr");
 
   DEFCONSTX ("SEEK_END", SBV_SEEK_END, 1.0,
-    "See SEEK_SET");
+    "-*- texinfo -*-\n\
+@defvr {Built-in Variable} SEEK_END\n\
+See SEEK_SET.\n\
+@end defvr");
 
   DEFCONSTX ("stdin", SBV_stdin, stdin_file,
     "-*- texinfo -*-\n\
 @defvr {Built-in Variable} stdin\n\
 The standard input stream (file id 0).  When Octave is used\n\
 interactively, this is filtered through the command line editing\n\
 functions.\n\
 @end defvr");
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -162,21 +162,25 @@ Compute the inverse cosine of each eleme
 
   DEFUN_MAPPER (acosh, 0, 0, 0, acosh, 0, acosh, 1.0, DBL_MAX, 1,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine of each element of @var{x}.\n\
 @end deftypefn");
 
   DEFUN_MAPPER (angle, 0, 0, 0, arg, arg, 0, 0.0, 0.0, 0,
-    "See arg.");
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} angle (@var{z})\n\
+See arg.\n\
+@end deftypefn");
 
   DEFUN_MAPPER (arg, 0, 0, 0, arg, arg, 0, 0.0, 0.0, 0,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} arg (@var{z})\n\
+@deftypefnx {Mapping Function} {} angle (@var{z})\n\
 Compute the argument of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $\\theta = \\tan^{-1}(y/x)$.\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @var{theta} = @code{atan (@var{y}/@var{x})}.\n\
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -1136,17 +1136,18 @@ Set plotting options for gnuplot\n\
   send_to_plot_stream (plot_command);
 
   delete [] plot_command;
 
   return retval;
 }
 
 DEFUN_TEXT (set, args, nargout,
-  "This command is has been replaced by `gset'.")
+  "-*- texinfo -*-\n\
+This command is has been replaced by @code{gset}.")
 {
   warning ("set is obsolete -- use gset instead");
   return Fgset (args, nargout);
 }
 
 DEFUN_TEXT (gshow, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} gshow options\n\
@@ -1173,17 +1174,18 @@ Show plotting options.\n\
   send_to_plot_stream (plot_command);
 
   delete [] plot_command;
 
   return retval;
 }
 
 DEFUN_TEXT (show, args, nargout,
-  "This command is has been replaced by `gshow'.")
+  "-*- texinfo -*-\n\
+This command is has been replaced by @code{gshow}.")
 {
   warning ("show is obsolete -- use gshow instead");
   return Fgshow (args, nargout);
 }
 
 static int
 automatic_replot (void)
 {
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -485,17 +485,20 @@ Return the real user id of the current p
     retval = octave_syscalls::getuid ();
   else
     print_usage ("getuid");
 
   return retval;
 }
 
 DEFUN (lstat, args, ,
-  "See stat.")
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})\n\
+See stat.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       string fname = file_ops::tilde_expand (args(0).string_value ());
 
       if (! error_state)
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -956,20 +956,20 @@ The command @kbd{whos} is equivalent to 
     return retval;
 
   retval = do_who (argc, argv);
 
   return retval;
 }
 
 DEFUN_TEXT (whos, args, ,
-  "whos [-all] [-builtins] [-functions] [-long] [-variables]\n\
-\n\
-List currently defined symbol(s).  Options may be shortened to one\n\
-character, but may not be combined.")
+  "-*- texinfo -*-\n\
+@deffn {Command} whos options pattern @dots{}\n\
+See who.\n\
+@end deffn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   octave_value_list tmp_args;
   for (int i = nargin; i > 0; i--)
     tmp_args(i) = args(i-1);
