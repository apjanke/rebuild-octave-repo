# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1531345296 14400
#      Wed Jul 11 17:41:36 2018 -0400
# Node ID 59f4fda5c548d93959b8b8b6da2e152e638b3f94
# Parent  3858334e81c4677492f1842d2d419d8ea0df0bea
remove fftpack sources

We now require FFTW to perform FFT calculations.

* liboctave/external/fftpack: Delete directory and all files.
* liboctave/external/module.mk: Update.

* lo-fftpack-proto.h: Delete.
* liboctave/numeric/module.mk: Update.

* CMatrix.cc, CNDArray.cc, dMatrix.cc, dNDArray.cc, fCMatrix.cc,
fCNDArray.cc, fMatrix.cc, fNDArray.cc: Require FFTW to compute FFT.

* interpft.m, fftconv.m, fftfilt.m, freqz.m, fft.cc, fft2.cc, fftn.cc:
Use TESTIF HAVE_FFTW as needed.

* NEWS: Note change.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -10,16 +10,19 @@ Summary of important user-visible change
     with Matlab.  Change all uses of "ascending" and "descending" in
     existing code to the new options.
 
  ** Figure graphic objects have a new property "Number" which is
     read-only and will return the handle (number) of the figure.
     However, if the property "IntegerHandle" has been set to "off" then
     the property will return an empty matrix ([]).
 
+ ** We now require the FFTW library to perform FFT calculations.  The
+    FFTPACK sources have been removed from Octave.
+
  ** Deprecated functions.
 
     The following functions have been deprecated in Octave 5.0 and will
     be removed from Octave 7 (or whatever version is the second major
     release after 5.0):
 
       Function             | Replacement
       ---------------------|------------------
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -28,22 +28,16 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
-#if defined (HAVE_FFTW)
-#  define FFTSRC "@sc{fftw}"
-#else
-#  define FFTSRC "@sc{fftpack}"
-#endif
-
 static octave_value
 do_fft (const octave_value_list& args, const char *fcn, int type)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
@@ -156,31 +150,45 @@ do_fft (const octave_value_list& args, c
       else
         err_wrong_type_arg (fcn, arg);
     }
 
   return retval;
 }
 
 /*
-%!assert (fft ([]), [])
-%!assert (fft (zeros (10,0)), zeros (10,0))
-%!assert (fft (zeros (0,10)), zeros (0,10))
-%!assert (fft (0), 0)
-%!assert (fft (1), 1)
-%!assert (fft (ones (2,2)), [2,2; 0,0])
-%!assert (fft (eye (2,2)), [1,1; 1,-1])
+%!testif HAVE_FFTW
+%! assert (fft ([]), [])
+%!testif HAVE_FFTW
+%! assert (fft (zeros (10,0)), zeros (10,0))
+%!testif HAVE_FFTW
+%! assert (fft (zeros (0,10)), zeros (0,10))
+%!testif HAVE_FFTW
+%! assert (fft (0), 0)
+%!testif HAVE_FFTW
+%! assert (fft (1), 1)
+%!testif HAVE_FFTW
+%! assert (fft (ones (2,2)), [2,2; 0,0])
+%!testif HAVE_FFTW
+%! assert (fft (eye (2,2)), [1,1; 1,-1])
 
-%!assert (fft (single ([])), single ([]))
-%!assert (fft (zeros (10,0,"single")), zeros (10,0,"single"))
-%!assert (fft (zeros (0,10,"single")), zeros (0,10,"single"))
-%!assert (fft (single (0)), single (0))
-%!assert (fft (single (1)), single (1))
-%!assert (fft (ones (2,2,"single")), single ([2,2; 0,0]))
-%!assert (fft (eye (2,2,"single")), single ([1,1; 1,-1]))
+%!testif HAVE_FFTW
+%! assert (fft (single ([])), single ([]))
+%!testif HAVE_FFTW
+%! assert (fft (zeros (10,0,"single")), zeros (10,0,"single"))
+%!testif HAVE_FFTW
+%! assert (fft (zeros (0,10,"single")), zeros (0,10,"single"))
+%!testif HAVE_FFTW
+%! assert (fft (single (0)), single (0))
+%!testif HAVE_FFTW
+%! assert (fft (single (1)), single (1))
+%!testif HAVE_FFTW
+%! assert (fft (ones (2,2,"single")), single ([2,2; 0,0]))
+%!testif HAVE_FFTW
+%! assert (fft (eye (2,2,"single")), single ([1,1; 1,-1]))
 
 %!error (fft ())
 */
 
 
 DEFUN (fft, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} fft (@var{x})
@@ -237,64 +245,64 @@ dimension of the matrix along which the 
 {
   return do_fft (args, "ifft", 1);
 }
 
 /*
 ## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 ##         Comalco Research and Technology
 ##         02 May 2000
-%!test
+%!testif HAVE_FFTW
 %! N = 64;
 %! n = 4;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos (n*t);
 %! S = fft (s);
 %!
 %! answer = zeros (size (t));
 %! answer(n+1) = N/2;
 %! answer(N-n+1) = N/2;
 %!
 %! assert (S, answer, 4*N*eps);
 
 ## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 ##         Comalco Research and Technology
 ##         02 May 2000
-%!test
+%!testif HAVE_FFTW
 %! N = 64;
 %! n = 7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos (n*t);
 %!
 %! S = zeros (size (t));
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
 %!
 %! assert (ifft (S), s, 4*N*eps);
 
 ## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 ##         Comalco Research and Technology
 ##         02 May 2000
-%!test
+%!testif HAVE_FFTW
 %! N = 64;
 %! n = 4;
 %! t = single (2*pi*(0:1:N-1)/N);
 %! s = cos (n*t);
 %! S = fft (s);
 %!
 %! answer = zeros (size (t), "single");
 %! answer(n+1) = N/2;
 %! answer(N-n+1) = N/2;
 %!
 %! assert (S, answer, 4*N*eps ("single"));
 
 ## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 ##         Comalco Research and Technology
 ##         02 May 2000
-%!test
+%!testif HAVE_FFTW
 %! N = 64;
 %! n = 7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos (n*t);
 %!
 %! S = zeros (size (t), "single");
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -30,22 +30,16 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
-#if defined (HAVE_FFTW)
-#  define FFTSRC "@sc{fftw}"
-#else
-#  define FFTSRC "@sc{fftpack}"
-#endif
-
 static octave_value
 do_fft2 (const octave_value_list& args, const char *fcn, int type)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
@@ -177,17 +171,17 @@ of @var{A} is treated separately.
 {
   return do_fft2 (args, "ifft2", 1);
 }
 
 /*
 ## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 ##         Comalco Research and Technology
 ##         02 May 2000
-%!test
+%!testif HAVE_FFTW
 %! M = 16;
 %! N = 8;
 %!
 %! m = 5;
 %! n = 3;
 %!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
@@ -196,17 +190,17 @@ of @var{A} is treated separately.
 %! s = kron (sx',sy);
 %! S = fft2 (s);
 %! answer = kron (fft (sx)', fft (sy));
 %! assert (S, answer, 4*M*N*eps);
 
 ## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 ##         Comalco Research and Technology
 ##         02 May 2000
-%!test
+%!testif HAVE_FFTW
 %! M = 12;
 %! N = 7;
 %!
 %! m = 3;
 %! n = 2;
 %!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
@@ -218,17 +212,17 @@ of @var{A} is treated separately.
 %! answer = kron (sx', sy);
 %! s = ifft2 (S);
 %!
 %! assert (s, answer, 30*eps);
 
 ## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 ##         Comalco Research and Technology
 ##         02 May 2000
-%!test
+%!testif HAVE_FFTW
 %! M = 16;
 %! N = 8;
 %!
 %! m = 5;
 %! n = 3;
 %!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
@@ -237,17 +231,17 @@ of @var{A} is treated separately.
 %! s = kron (sx', sy);
 %! S = fft2 (s);
 %! answer = kron (fft (sx)', fft (sy));
 %! assert (S, answer, 4*M*N*eps ("single"));
 
 ## Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 ##         Comalco Research and Technology
 ##         02 May 2000
-%!test
+%!testif HAVE_FFTW
 %! M = 12;
 %! N = 7;
 %!
 %! m = 3;
 %! n = 2;
 %!
 %! x = single (2*pi*(0:1:M-1)/M);
 %! y = single (2*pi*(0:1:N-1)/N);
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -29,22 +29,16 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
-#if defined (HAVE_FFTW)
-#  define FFTSRC "@sc{fftw}"
-#else
-#  define FFTSRC "@sc{fftpack}"
-#endif
-
 static octave_value
 do_fftn (const octave_value_list& args, const char *fcn, int type)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1100,244 +1100,50 @@ ComplexMatrix::ifourier2d (void) const
 
   octave::fftw::ifftNd (in, out, 2, dv);
 
   return retval;
 }
 
 #else
 
-#include "lo-fftpack-proto.h"
-
 ComplexMatrix
 ComplexMatrix::fourier (void) const
 {
-  ComplexMatrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nsamples;
-
-  F77_INT npts;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = octave::to_f77_int (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = octave::to_f77_int (nr);
-      nsamples = nc;
-    }
-
-  octave_idx_type nn = 4*npts+15;
-
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  retval = *this;
-  Complex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return ComplexMatrix ();
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
 {
-  ComplexMatrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nsamples;
-
-  F77_INT npts;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = octave::to_f77_int (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = octave::to_f77_int (nr);
-      nsamples = nc;
-    }
-
-  octave_idx_type nn = 4*npts+15;
-
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  retval = *this;
-  Complex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-    }
-
-  for (octave_idx_type j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return ComplexMatrix ();
 }
 
 ComplexMatrix
 ComplexMatrix::fourier2d (void) const
 {
-  ComplexMatrix retval;
-
-  F77_INT nr = octave::to_f77_int (rows ());
-  F77_INT nc = octave::to_f77_int (cols ());
-
-  F77_INT npts, nsamples;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = nr;
-      nsamples = nc;
-    }
-
-  F77_INT nn = 4*npts+15;
-
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  retval = *this;
-  Complex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-    }
-
-  npts = nc;
-  nsamples = nr;
-  nn = 4*npts+15;
-
-  wsave.resize (dim_vector (nn, 1));
-  pwsave = wsave.fortran_vec ();
-
-  Array<Complex> tmp (dim_vector (npts, 1));
-  Complex *prow = tmp.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      for (F77_INT i = 0; i < npts; i++)
-        prow[i] = tmp_data[i*nr + j];
-
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-
-      for (F77_INT i = 0; i < npts; i++)
-        tmp_data[i*nr + j] = prow[i];
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return ComplexMatrix ();
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier2d (void) const
 {
-  ComplexMatrix retval;
-
-  F77_INT nr = octave::to_f77_int (rows ());
-  F77_INT nc = octave::to_f77_int (cols ());
-
-  F77_INT npts, nsamples;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = nr;
-      nsamples = nc;
-    }
-
-  F77_INT nn = 4*npts+15;
-
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  retval = *this;
-  Complex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-    }
-
-  for (F77_INT j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
-
-  npts = nc;
-  nsamples = nr;
-  nn = 4*npts+15;
-
-  wsave.resize (dim_vector (nn, 1));
-  pwsave = wsave.fortran_vec ();
-
-  Array<Complex> tmp (dim_vector (npts, 1));
-  Complex *prow = tmp.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      for (F77_INT i = 0; i < npts; i++)
-        prow[i] = tmp_data[i*nr + j];
-
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-
-      for (F77_INT i = 0; i < npts; i++)
-        tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return ComplexMatrix ();
 }
 
 #endif
 
 ComplexDET
 ComplexMatrix::determinant (void) const
 {
   octave_idx_type info;
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -182,309 +182,68 @@ ComplexNDArray::ifourierNd (void) const
 
   octave::fftw::ifftNd (in, out, rank, dv);
 
   return retval;
 }
 
 #else
 
-#include "lo-fftpack-proto.h"
-
 ComplexNDArray
 ComplexNDArray::fourier (int dim) const
 {
-  dim_vector dv = dims ();
-
-  if (dim > dv.ndims () || dim < 0)
-    return ComplexNDArray ();
-
-  ComplexNDArray retval (dv);
-  octave_idx_type npts = dv(dim);
-  octave_idx_type nn = 4*npts+15;
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
-
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < dim; i++)
-    stride *= dv(i);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-  octave_idx_type howmany = numel () / npts;
-  howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  octave_idx_type dist = (stride == 1 ? npts : 1);
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type k = 0; k < nloop; k++)
-    {
-      for (octave_idx_type j = 0; j < howmany; j++)
-        {
-          octave_quit ();
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem ((i + k*npts)*stride + j*dist);
-
-          F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (tmp),
-                                   F77_DBLE_CMPLX_ARG (pwsave));
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            retval((i + k*npts)*stride + j*dist) = tmp[i];
-        }
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
 {
-  dim_vector dv = dims ();
-
-  if (dim > dv.ndims () || dim < 0)
-    return ComplexNDArray ();
-
-  ComplexNDArray retval (dv);
-  octave_idx_type npts = dv(dim);
-  octave_idx_type nn = 4*npts+15;
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
-
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < dim; i++)
-    stride *= dv(i);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-  octave_idx_type howmany = numel () / npts;
-  howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  octave_idx_type dist = (stride == 1 ? npts : 1);
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type k = 0; k < nloop; k++)
-    {
-      for (octave_idx_type j = 0; j < howmany; j++)
-        {
-          octave_quit ();
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem ((i + k*npts)*stride + j*dist);
-
-          F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (tmp),
-                                   F77_DBLE_CMPLX_ARG (pwsave));
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            retval((i + k*npts)*stride + j*dist) = tmp[i] /
-                                                   static_cast<double> (npts);
-        }
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims ();
-  dim_vector dv2 (dv(0), dv(1));
-  int rank = 2;
-  ComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv2(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (dim_vector (nn, 1));
-      Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (dim_vector (npts, 1));
-      Complex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
-                                       F77_DBLE_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l];
-            }
-        }
-
-      stride *= dv2(i);
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims ();
-  dim_vector dv2 (dv(0), dv(1));
-  int rank = 2;
-  ComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv2(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (dim_vector (nn, 1));
-      Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (dim_vector (npts, 1));
-      Complex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
-
-      F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
-                                       F77_DBLE_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) =
-                  prow[l] / static_cast<double> (npts);
-            }
-        }
-
-      stride *= dv2(i);
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 ComplexNDArray::fourierNd (void) const
 {
-  dim_vector dv = dims ();
-  int rank = dv.ndims ();
-  ComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (dim_vector (nn, 1));
-      Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (dim_vector (npts, 1));
-      Complex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
-
-      F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
-                                       F77_DBLE_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l];
-            }
-        }
-
-      stride *= dv(i);
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 ComplexNDArray::ifourierNd (void) const
 {
-  dim_vector dv = dims ();
-  int rank = dv.ndims ();
-  ComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (dim_vector (nn, 1));
-      Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (dim_vector (npts, 1));
-      Complex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
-
-      F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
-                                       F77_DBLE_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) =
-                  prow[l] / static_cast<double> (npts);
-            }
-        }
-
-      stride *= dv(i);
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 #endif
 
 // unary operations
 
 boolNDArray
 ComplexNDArray::operator ! (void) const
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -795,244 +795,50 @@ Matrix::ifourier2d (void) const
 
   octave::fftw::ifftNd (out, out, 2, dv);
 
   return retval;
 }
 
 #else
 
-#include "lo-fftpack-proto.h"
-
 ComplexMatrix
 Matrix::fourier (void) const
 {
-  ComplexMatrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nsamples;
-
-  F77_INT npts;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = octave::to_f77_int (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = octave::to_f77_int (nr);
-      nsamples = nc;
-    }
-
-  octave_idx_type nn = 4*npts+15;
-
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  retval = ComplexMatrix (*this);
-  Complex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return ComplexMatrix ();
 }
 
 ComplexMatrix
 Matrix::ifourier (void) const
 {
-  ComplexMatrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nsamples;
-
-  F77_INT npts;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = octave::to_f77_int (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = octave::to_f77_int (nr);
-      nsamples = nc;
-    }
-
-  octave_idx_type nn = 4*npts+15;
-
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  retval = ComplexMatrix (*this);
-  Complex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-    }
-
-  for (octave_idx_type j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return ComplexMatrix ();
 }
 
 ComplexMatrix
 Matrix::fourier2d (void) const
 {
-  ComplexMatrix retval;
-
-  F77_INT nr = octave::to_f77_int (rows ());
-  F77_INT nc = octave::to_f77_int (cols ());
-
-  F77_INT npts, nsamples;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = nr;
-      nsamples = nc;
-    }
-
-  F77_INT nn = 4*npts+15;
-
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  retval = ComplexMatrix (*this);
-  Complex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-    }
-
-  npts = nc;
-  nsamples = nr;
-  nn = 4*npts+15;
-
-  wsave.resize (dim_vector (nn, 1));
-  pwsave = wsave.fortran_vec ();
-
-  Array<Complex> tmp (dim_vector (npts, 1));
-  Complex *prow = tmp.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      for (F77_INT i = 0; i < npts; i++)
-        prow[i] = tmp_data[i*nr + j];
-
-      F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-
-      for (F77_INT i = 0; i < npts; i++)
-        tmp_data[i*nr + j] = prow[i];
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return ComplexMatrix ();
 }
 
 ComplexMatrix
 Matrix::ifourier2d (void) const
 {
-  ComplexMatrix retval;
-
-  F77_INT nr = octave::to_f77_int (rows ());
-  F77_INT nc = octave::to_f77_int (cols ());
-
-  F77_INT npts, nsamples;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = nr;
-      nsamples = nc;
-    }
-
-  F77_INT nn = 4*npts+15;
-
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  retval = ComplexMatrix (*this);
-  Complex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-    }
-
-  for (F77_INT j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / static_cast<double> (npts);
-
-  npts = nc;
-  nsamples = nr;
-  nn = 4*npts+15;
-
-  wsave.resize (dim_vector (nn, 1));
-  pwsave = wsave.fortran_vec ();
-
-  Array<Complex> tmp (dim_vector (npts, 1));
-  Complex *prow = tmp.fortran_vec ();
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      for (F77_INT i = 0; i < npts; i++)
-        prow[i] = tmp_data[i*nr + j];
-
-      F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
-                               F77_DBLE_CMPLX_ARG (pwsave));
-
-      for (F77_INT i = 0; i < npts; i++)
-        tmp_data[i*nr + j] = prow[i] / static_cast<double> (npts);
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return ComplexMatrix ();
 }
 
 #endif
 
 DET
 Matrix::determinant (void) const
 {
   octave_idx_type info;
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -223,309 +223,68 @@ NDArray::ifourierNd (void) const
 
   octave::fftw::ifftNd (in, out, rank, dv);
 
   return retval;
 }
 
 #else
 
-#include "lo-fftpack-proto.h"
-
 ComplexNDArray
 NDArray::fourier (int dim) const
 {
-  dim_vector dv = dims ();
-
-  if (dim > dv.ndims () || dim < 0)
-    return ComplexNDArray ();
-
-  ComplexNDArray retval (dv);
-  octave_idx_type npts = dv(dim);
-  octave_idx_type nn = 4*npts+15;
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
-
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < dim; i++)
-    stride *= dv(i);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-  octave_idx_type howmany = numel () / npts;
-  howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  octave_idx_type dist = (stride == 1 ? npts : 1);
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type k = 0; k < nloop; k++)
-    {
-      for (octave_idx_type j = 0; j < howmany; j++)
-        {
-          octave_quit ();
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem ((i + k*npts)*stride + j*dist);
-
-          F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (tmp),
-                                   F77_DBLE_CMPLX_ARG (pwsave));
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            retval((i + k*npts)*stride + j*dist) = tmp[i];
-        }
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
 {
-  dim_vector dv = dims ();
-
-  if (dim > dv.ndims () || dim < 0)
-    return ComplexNDArray ();
-
-  ComplexNDArray retval (dv);
-  octave_idx_type npts = dv(dim);
-  octave_idx_type nn = 4*npts+15;
-  Array<Complex> wsave (dim_vector (nn, 1));
-  Complex *pwsave = wsave.fortran_vec ();
-
-  OCTAVE_LOCAL_BUFFER (Complex, tmp, npts);
-
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < dim; i++)
-    stride *= dv(i);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-  octave_idx_type howmany = numel () / npts;
-  howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  octave_idx_type dist = (stride == 1 ? npts : 1);
-
-  F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type k = 0; k < nloop; k++)
-    {
-      for (octave_idx_type j = 0; j < howmany; j++)
-        {
-          octave_quit ();
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem ((i + k*npts)*stride + j*dist);
-
-          F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (tmp),
-                                   F77_DBLE_CMPLX_ARG (pwsave));
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            retval((i + k*npts)*stride + j*dist) = tmp[i] /
-                                                   static_cast<double> (npts);
-        }
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
-  dim_vector dv = dims ();
-  dim_vector dv2 (dv(0), dv(1));
-  int rank = 2;
-  ComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv2(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (dim_vector (nn, 1));
-      Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (dim_vector (npts, 1));
-      Complex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
-
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
-                                       F77_DBLE_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l];
-            }
-        }
-
-      stride *= dv2(i);
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 NDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims ();
-  dim_vector dv2 (dv(0), dv(1));
-  int rank = 2;
-  ComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv2(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (dim_vector (nn, 1));
-      Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (dim_vector (npts, 1));
-      Complex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
-
-      F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
-                                       F77_DBLE_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) =
-                  prow[l] / static_cast<double> (npts);
-            }
-        }
-
-      stride *= dv2(i);
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 NDArray::fourierNd (void) const
 {
-  dim_vector dv = dims ();
-  int rank = dv.ndims ();
-  ComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (dim_vector (nn, 1));
-      Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (dim_vector (npts, 1));
-      Complex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
-
-      F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (zfftf, ZFFTF) (npts, F77_DBLE_CMPLX_ARG (prow),
-                                       F77_DBLE_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l];
-            }
-        }
-
-      stride *= dv(i);
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 ComplexNDArray
 NDArray::ifourierNd (void) const
 {
-  dim_vector dv = dims ();
-  int rank = dv.ndims ();
-  ComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<Complex> wsave (dim_vector (nn, 1));
-      Complex *pwsave = wsave.fortran_vec ();
-      Array<Complex> row (dim_vector (npts, 1));
-      Complex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
-
-      F77_FUNC (zffti, ZFFTI) (npts, F77_DBLE_CMPLX_ARG (pwsave));
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (zfftb, ZFFTB) (npts, F77_DBLE_CMPLX_ARG (prow),
-                                       F77_DBLE_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) =
-                  prow[l] / static_cast<double> (npts);
-            }
-        }
-
-      stride *= dv(i);
-    }
-
-  return retval;
+  return ComplexNDArray ();
 }
 
 #endif
 
 // unary operations
 
 boolNDArray
 NDArray::operator ! (void) const
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -1103,242 +1103,50 @@ FloatComplexMatrix::ifourier2d (void) co
 
   octave::fftw::ifftNd (in, out, 2, dv);
 
   return retval;
 }
 
 #else
 
-#include "lo-fftpack-proto.h"
-
 FloatComplexMatrix
 FloatComplexMatrix::fourier (void) const
 {
-  FloatComplexMatrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nsamples;
-
-  F77_INT npts;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = octave::to_f77_int (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = octave::to_f77_int (nr);
-      nsamples = nc;
-    }
-
-  octave_idx_type nn = 4*npts+15;
-
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  retval = *this;
-  FloatComplex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_CMPLX_ARG (pwsave));
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return FloatComplexMatrix ();
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ifourier (void) const
 {
-  FloatComplexMatrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nsamples;
-
-  F77_INT npts;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = octave::to_f77_int (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = octave::to_f77_int (nr);
-      nsamples = nc;
-    }
-
-  octave_idx_type nn = 4*npts+15;
-
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  retval = *this;
-  FloatComplex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_CMPLX_ARG (pwsave));
-    }
-
-  for (octave_idx_type j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return FloatComplexMatrix ();
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::fourier2d (void) const
 {
-  FloatComplexMatrix retval;
-
-  F77_INT nr = octave::to_f77_int (rows ());
-  F77_INT nc = octave::to_f77_int (cols ());
-
-  F77_INT npts, nsamples;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = nr;
-      nsamples = nc;
-    }
-
-  F77_INT nn = 4*npts+15;
-
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  retval = *this;
-  FloatComplex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_CMPLX_ARG (pwsave));
-    }
-
-  npts = nc;
-  nsamples = nr;
-  nn = 4*npts+15;
-
-  wsave.resize (dim_vector (nn, 1));
-  pwsave = wsave.fortran_vec ();
-
-  Array<FloatComplex> tmp (dim_vector (npts, 1));
-  FloatComplex *prow = tmp.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      for (F77_INT i = 0; i < npts; i++)
-        prow[i] = tmp_data[i*nr + j];
-
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-      for (F77_INT i = 0; i < npts; i++)
-        tmp_data[i*nr + j] = prow[i];
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return FloatComplexMatrix ();
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ifourier2d (void) const
 {
-  FloatComplexMatrix retval;
-
-  F77_INT nr = octave::to_f77_int (rows ());
-  F77_INT nc = octave::to_f77_int (cols ());
-
-  F77_INT npts, nsamples;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = nr;
-      nsamples = nc;
-    }
-
-  F77_INT nn = 4*npts+15;
-
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  retval = *this;
-  FloatComplex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_CMPLX_ARG (pwsave));
-    }
-
-  for (F77_INT j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
-
-  npts = nc;
-  nsamples = nr;
-  nn = 4*npts+15;
-
-  wsave.resize (dim_vector (nn, 1));
-  pwsave = wsave.fortran_vec ();
-
-  Array<FloatComplex> tmp (dim_vector (npts, 1));
-  FloatComplex *prow = tmp.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      for (F77_INT i = 0; i < npts; i++)
-        prow[i] = tmp_data[i*nr + j];
-
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-      for (F77_INT i = 0; i < npts; i++)
-        tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return FloatComplexMatrix ();
 }
 
 #endif
 
 FloatComplexDET
 FloatComplexMatrix::determinant (void) const
 {
   octave_idx_type info;
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -182,303 +182,68 @@ FloatComplexNDArray::ifourierNd (void) c
 
   octave::fftw::ifftNd (in, out, rank, dv);
 
   return retval;
 }
 
 #else
 
-#include "lo-fftpack-proto.h"
-
 FloatComplexNDArray
 FloatComplexNDArray::fourier (int dim) const
 {
-  dim_vector dv = dims ();
-
-  if (dim > dv.ndims () || dim < 0)
-    return FloatComplexNDArray ();
-
-  FloatComplexNDArray retval (dv);
-  octave_idx_type npts = dv(dim);
-  octave_idx_type nn = 4*npts+15;
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  OCTAVE_LOCAL_BUFFER (FloatComplex, tmp, npts);
-
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < dim; i++)
-    stride *= dv(i);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-  octave_idx_type howmany = numel () / npts;
-  howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  octave_idx_type dist = (stride == 1 ? npts : 1);
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type k = 0; k < nloop; k++)
-    {
-      for (octave_idx_type j = 0; j < howmany; j++)
-        {
-          octave_quit ();
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem ((i + k*npts)*stride + j*dist);
-
-          F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (tmp), F77_CMPLX_ARG (pwsave));
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            retval((i + k*npts)*stride + j*dist) = tmp[i];
-        }
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier (int dim) const
 {
-  dim_vector dv = dims ();
-
-  if (dim > dv.ndims () || dim < 0)
-    return FloatComplexNDArray ();
-
-  FloatComplexNDArray retval (dv);
-  octave_idx_type npts = dv(dim);
-  octave_idx_type nn = 4*npts+15;
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  OCTAVE_LOCAL_BUFFER (FloatComplex, tmp, npts);
-
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < dim; i++)
-    stride *= dv(i);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-  octave_idx_type howmany = numel () / npts;
-  howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  octave_idx_type dist = (stride == 1 ? npts : 1);
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type k = 0; k < nloop; k++)
-    {
-      for (octave_idx_type j = 0; j < howmany; j++)
-        {
-          octave_quit ();
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem ((i + k*npts)*stride + j*dist);
-
-          F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (tmp), F77_CMPLX_ARG (pwsave));
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            retval((i + k*npts)*stride + j*dist) = tmp[i] /
-                                                   static_cast<float> (npts);
-        }
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims ();
-  dim_vector dv2 (dv(0), dv(1));
-  int rank = 2;
-  FloatComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv2(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (dim_vector (nn, 1));
-      FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (dim_vector (npts, 1));
-      FloatComplex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l];
-            }
-        }
-
-      stride *= dv2(i);
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims ();
-  dim_vector dv2 (dv(0), dv(1));
-  int rank = 2;
-  FloatComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv2(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (dim_vector (nn, 1));
-      FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (dim_vector (npts, 1));
-      FloatComplex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) =
-                  prow[l] / static_cast<float> (npts);
-            }
-        }
-
-      stride *= dv2(i);
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourierNd (void) const
 {
-  dim_vector dv = dims ();
-  int rank = dv.ndims ();
-  FloatComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (dim_vector (nn, 1));
-      FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (dim_vector (npts, 1));
-      FloatComplex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l];
-            }
-        }
-
-      stride *= dv(i);
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourierNd (void) const
 {
-  dim_vector dv = dims ();
-  int rank = dv.ndims ();
-  FloatComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (dim_vector (nn, 1));
-      FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (dim_vector (npts, 1));
-      FloatComplex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
-
-      F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) =
-                  prow[l] / static_cast<float> (npts);
-            }
-        }
-
-      stride *= dv(i);
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 #endif
 
 // unary operations
 
 boolNDArray
 FloatComplexNDArray::operator ! (void) const
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -801,242 +801,50 @@ FloatMatrix::ifourier2d (void) const
 
   octave::fftw::ifftNd (out, out, 2, dv);
 
   return retval;
 }
 
 #else
 
-#include "lo-fftpack-proto.h"
-
 FloatComplexMatrix
 FloatMatrix::fourier (void) const
 {
-  FloatComplexMatrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nsamples;
-
-  F77_INT npts;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = octave::to_f77_int (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = octave::to_f77_int (nr);
-      nsamples = nc;
-    }
-
-  octave_idx_type nn = 4*npts+15;
-
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  retval = FloatComplexMatrix (*this);
-  FloatComplex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_CMPLX_ARG (pwsave));
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return FloatComplexMatrix ();
 }
 
 FloatComplexMatrix
 FloatMatrix::ifourier (void) const
 {
-  FloatComplexMatrix retval;
-
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nsamples;
-
-  F77_INT npts;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = octave::to_f77_int (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = F77_INT (nr);
-      nsamples = nc;
-    }
-
-  octave_idx_type nn = 4*npts+15;
-
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  retval = FloatComplexMatrix (*this);
-  FloatComplex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_CMPLX_ARG (pwsave));
-    }
-
-  for (octave_idx_type j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return FloatComplexMatrix ();
 }
 
 FloatComplexMatrix
 FloatMatrix::fourier2d (void) const
 {
-  FloatComplexMatrix retval;
-
-  F77_INT nr = octave::to_f77_int (rows ());
-  F77_INT nc = octave::to_f77_int (cols ());
-
-  F77_INT npts, nsamples;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = nr;
-      nsamples = nc;
-    }
-
-  F77_INT nn = 4*npts+15;
-
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  retval = FloatComplexMatrix (*this);
-  FloatComplex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_CMPLX_ARG (pwsave));
-    }
-
-  npts = nc;
-  nsamples = nr;
-  nn = 4*npts+15;
-
-  wsave.resize (dim_vector (nn, 1));
-  pwsave = wsave.fortran_vec ();
-
-  Array<FloatComplex> tmp (dim_vector (npts, 1));
-  FloatComplex *prow = tmp.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      for (F77_INT i = 0; i < npts; i++)
-        prow[i] = tmp_data[i*nr + j];
-
-      F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-      for (F77_INT i = 0; i < npts; i++)
-        tmp_data[i*nr + j] = prow[i];
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return FloatComplexMatrix ();
 }
 
 FloatComplexMatrix
 FloatMatrix::ifourier2d (void) const
 {
-  FloatComplexMatrix retval;
-
-  F77_INT nr = octave::to_f77_int (rows ());
-  F77_INT nc = octave::to_f77_int (cols ());
-
-  F77_INT npts, nsamples;
-
-  if (nr == 1 || nc == 1)
-    {
-      npts = (nr > nc ? nr : nc);
-      nsamples = 1;
-    }
-  else
-    {
-      npts = nr;
-      nsamples = nc;
-    }
-
-  F77_INT nn = 4*npts+15;
-
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  retval = FloatComplexMatrix (*this);
-  FloatComplex *tmp_data = retval.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (&tmp_data[npts*j]),
-                               F77_CMPLX_ARG (pwsave));
-    }
-
-  for (F77_INT j = 0; j < npts*nsamples; j++)
-    tmp_data[j] = tmp_data[j] / static_cast<float> (npts);
-
-  npts = nc;
-  nsamples = nr;
-  nn = 4*npts+15;
-
-  wsave.resize (dim_vector (nn, 1));
-  pwsave = wsave.fortran_vec ();
-
-  Array<FloatComplex> tmp (dim_vector (npts, 1));
-  FloatComplex *prow = tmp.fortran_vec ();
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (F77_INT j = 0; j < nsamples; j++)
-    {
-      octave_quit ();
-
-      for (F77_INT i = 0; i < npts; i++)
-        prow[i] = tmp_data[i*nr + j];
-
-      F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-      for (F77_INT i = 0; i < npts; i++)
-        tmp_data[i*nr + j] = prow[i] / static_cast<float> (npts);
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+
+  return FloatComplexMatrix ();
 }
 
 #endif
 
 FloatDET
 FloatMatrix::determinant (void) const
 {
   octave_idx_type info;
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -181,303 +181,67 @@ FloatNDArray::ifourierNd (void) const
 
   octave::fftw::ifftNd (in, out, rank, dv);
 
   return retval;
 }
 
 #else
 
-#include "lo-fftpack-proto.h"
-
 FloatComplexNDArray
 FloatNDArray::fourier (int dim) const
 {
-  dim_vector dv = dims ();
-
-  if (dim > dv.ndims () || dim < 0)
-    return FloatComplexNDArray ();
-
-  FloatComplexNDArray retval (dv);
-  octave_idx_type npts = dv(dim);
-  octave_idx_type nn = 4*npts+15;
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  OCTAVE_LOCAL_BUFFER (FloatComplex, tmp, npts);
-
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < dim; i++)
-    stride *= dv(i);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-  octave_idx_type howmany = numel () / npts;
-  howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  octave_idx_type dist = (stride == 1 ? npts : 1);
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type k = 0; k < nloop; k++)
-    {
-      for (octave_idx_type j = 0; j < howmany; j++)
-        {
-          octave_quit ();
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem ((i + k*npts)*stride + j*dist);
-
-          F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (tmp), F77_CMPLX_ARG (pwsave));
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            retval((i + k*npts)*stride + j*dist) = tmp[i];
-        }
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier (int dim) const
 {
-  dim_vector dv = dims ();
-
-  if (dim > dv.ndims () || dim < 0)
-    return FloatComplexNDArray ();
-
-  FloatComplexNDArray retval (dv);
-  octave_idx_type npts = dv(dim);
-  octave_idx_type nn = 4*npts+15;
-  Array<FloatComplex> wsave (dim_vector (nn, 1));
-  FloatComplex *pwsave = wsave.fortran_vec ();
-
-  OCTAVE_LOCAL_BUFFER (FloatComplex, tmp, npts);
-
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < dim; i++)
-    stride *= dv(i);
-
-  octave_idx_type howmany = numel () / npts;
-  howmany = (stride == 1 ? howmany : (howmany > stride ? stride : howmany));
-  octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-  octave_idx_type dist = (stride == 1 ? npts : 1);
-
-  F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-  for (octave_idx_type k = 0; k < nloop; k++)
-    {
-      for (octave_idx_type j = 0; j < howmany; j++)
-        {
-          octave_quit ();
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            tmp[i] = elem ((i + k*npts)*stride + j*dist);
-
-          F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (tmp), F77_CMPLX_ARG (pwsave));
-
-          for (octave_idx_type i = 0; i < npts; i++)
-            retval((i + k*npts)*stride + j*dist) = tmp[i] /
-                                                   static_cast<float> (npts);
-        }
-    }
-
-  return retval;
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims ();
-  dim_vector dv2 (dv(0), dv(1));
-  int rank = 2;
-  FloatComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv2(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (dim_vector (nn, 1));
-      FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (dim_vector (npts, 1));
-      FloatComplex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l];
-            }
-        }
-
-      stride *= dv2(i);
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims ();
-  dim_vector dv2 (dv(0), dv(1));
-  int rank = 2;
-  FloatComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv2(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (dim_vector (nn, 1));
-      FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (dim_vector (npts, 1));
-      FloatComplex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) =
-                  prow[l] / static_cast<float> (npts);
-            }
-        }
-
-      stride *= dv2(i);
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatNDArray::fourierNd (void) const
 {
-  dim_vector dv = dims ();
-  int rank = dv.ndims ();
-  FloatComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (dim_vector (nn, 1));
-      FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (dim_vector (npts, 1));
-      FloatComplex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
-
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (cfftf, CFFTF) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l];
-            }
-        }
-
-      stride *= dv(i);
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourierNd (void) const
 {
-  dim_vector dv = dims ();
-  int rank = dv.ndims ();
-  FloatComplexNDArray retval (*this);
-  octave_idx_type stride = 1;
-
-  for (int i = 0; i < rank; i++)
-    {
-      octave_idx_type npts = dv(i);
-      octave_idx_type nn = 4*npts+15;
-      Array<FloatComplex> wsave (dim_vector (nn, 1));
-      FloatComplex *pwsave = wsave.fortran_vec ();
-      Array<FloatComplex> row (dim_vector (npts, 1));
-      FloatComplex *prow = row.fortran_vec ();
-
-      octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany
-                             : (howmany > stride ? stride : howmany));
-      octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
-      octave_idx_type dist = (stride == 1 ? npts : 1);
-
-      F77_FUNC (cffti, CFFTI) (npts, F77_CMPLX_ARG (pwsave));
+  (*current_liboctave_error_handler)
+    ("support for FFTW was unavailable or disabled when liboctave was built");
 
-      for (octave_idx_type k = 0; k < nloop; k++)
-        {
-          for (octave_idx_type j = 0; j < howmany; j++)
-            {
-              octave_quit ();
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval((l + k*npts)*stride + j*dist);
-
-              F77_FUNC (cfftb, CFFTB) (npts, F77_CMPLX_ARG (prow), F77_CMPLX_ARG (pwsave));
-
-              for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) =
-                  prow[l] / static_cast<float> (npts);
-            }
-        }
-
-      stride *= dv(i);
-    }
-
-  return retval;
+  return FloatComplexNDArray ();
 }
 
 #endif
 
 // unary operations
 
 boolNDArray
 FloatNDArray::operator ! (void) const
diff --git a/liboctave/external/fftpack/cfftb.f b/liboctave/external/fftpack/cfftb.f
deleted file mode 100644
--- a/liboctave/external/fftpack/cfftb.f
+++ /dev/null
@@ -1,8 +0,0 @@
-      subroutine cfftb (n,c,wsave)
-      dimension       c(*)       ,wsave(*)
-      if (n .eq. 1) return
-      iw1 = n+n+1
-      iw2 = iw1+n+n
-      call cfftb1 (n,c,wsave,wsave(iw1),wsave(iw2))
-      return
-      end
diff --git a/liboctave/external/fftpack/cfftb1.f b/liboctave/external/fftpack/cfftb1.f
deleted file mode 100644
--- a/liboctave/external/fftpack/cfftb1.f
+++ /dev/null
@@ -1,61 +0,0 @@
-      subroutine cfftb1 (n,c,ch,wa,ifac)
-      dimension       ch(*)      ,c(*)       ,wa(*)      ,ifac(*)
-      nf = ifac(2)
-      na = 0
-      l1 = 1
-      iw = 1
-      do 116 k1=1,nf
-         ip = ifac(k1+2)
-         l2 = ip*l1
-         ido = n/l2
-         idot = ido+ido
-         idl1 = idot*l1
-         if (ip .ne. 4) go to 103
-         ix2 = iw+idot
-         ix3 = ix2+idot
-         if (na .ne. 0) go to 101
-         call passb4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
-         go to 102
-  101    call passb4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
-  102    na = 1-na
-         go to 115
-  103    if (ip .ne. 2) go to 106
-         if (na .ne. 0) go to 104
-         call passb2 (idot,l1,c,ch,wa(iw))
-         go to 105
-  104    call passb2 (idot,l1,ch,c,wa(iw))
-  105    na = 1-na
-         go to 115
-  106    if (ip .ne. 3) go to 109
-         ix2 = iw+idot
-         if (na .ne. 0) go to 107
-         call passb3 (idot,l1,c,ch,wa(iw),wa(ix2))
-         go to 108
-  107    call passb3 (idot,l1,ch,c,wa(iw),wa(ix2))
-  108    na = 1-na
-         go to 115
-  109    if (ip .ne. 5) go to 112
-         ix2 = iw+idot
-         ix3 = ix2+idot
-         ix4 = ix3+idot
-         if (na .ne. 0) go to 110
-         call passb5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
-         go to 111
-  110    call passb5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
-  111    na = 1-na
-         go to 115
-  112    if (na .ne. 0) go to 113
-         call passb (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
-         go to 114
-  113    call passb (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
-  114    if (nac .ne. 0) na = 1-na
-  115    l1 = l2
-         iw = iw+(ip-1)*idot
-  116 continue
-      if (na .eq. 0) return
-      n2 = n+n
-      do 117 i=1,n2
-         c(i) = ch(i)
-  117 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/cfftf.f b/liboctave/external/fftpack/cfftf.f
deleted file mode 100644
--- a/liboctave/external/fftpack/cfftf.f
+++ /dev/null
@@ -1,8 +0,0 @@
-      subroutine cfftf (n,c,wsave)
-      dimension       c(*)       ,wsave(*)
-      if (n .eq. 1) return
-      iw1 = n+n+1
-      iw2 = iw1+n+n
-      call cfftf1 (n,c,wsave,wsave(iw1),wsave(iw2))
-      return
-      end
diff --git a/liboctave/external/fftpack/cfftf1.f b/liboctave/external/fftpack/cfftf1.f
deleted file mode 100644
--- a/liboctave/external/fftpack/cfftf1.f
+++ /dev/null
@@ -1,61 +0,0 @@
-      subroutine cfftf1 (n,c,ch,wa,ifac)
-      dimension       ch(*)      ,c(*)       ,wa(*)      ,ifac(*)
-      nf = ifac(2)
-      na = 0
-      l1 = 1
-      iw = 1
-      do 116 k1=1,nf
-         ip = ifac(k1+2)
-         l2 = ip*l1
-         ido = n/l2
-         idot = ido+ido
-         idl1 = idot*l1
-         if (ip .ne. 4) go to 103
-         ix2 = iw+idot
-         ix3 = ix2+idot
-         if (na .ne. 0) go to 101
-         call passf4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
-         go to 102
-  101    call passf4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
-  102    na = 1-na
-         go to 115
-  103    if (ip .ne. 2) go to 106
-         if (na .ne. 0) go to 104
-         call passf2 (idot,l1,c,ch,wa(iw))
-         go to 105
-  104    call passf2 (idot,l1,ch,c,wa(iw))
-  105    na = 1-na
-         go to 115
-  106    if (ip .ne. 3) go to 109
-         ix2 = iw+idot
-         if (na .ne. 0) go to 107
-         call passf3 (idot,l1,c,ch,wa(iw),wa(ix2))
-         go to 108
-  107    call passf3 (idot,l1,ch,c,wa(iw),wa(ix2))
-  108    na = 1-na
-         go to 115
-  109    if (ip .ne. 5) go to 112
-         ix2 = iw+idot
-         ix3 = ix2+idot
-         ix4 = ix3+idot
-         if (na .ne. 0) go to 110
-         call passf5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
-         go to 111
-  110    call passf5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
-  111    na = 1-na
-         go to 115
-  112    if (na .ne. 0) go to 113
-         call passf (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
-         go to 114
-  113    call passf (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
-  114    if (nac .ne. 0) na = 1-na
-  115    l1 = l2
-         iw = iw+(ip-1)*idot
-  116 continue
-      if (na .eq. 0) return
-      n2 = n+n
-      do 117 i=1,n2
-         c(i) = ch(i)
-  117 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/cffti.f b/liboctave/external/fftpack/cffti.f
deleted file mode 100644
--- a/liboctave/external/fftpack/cffti.f
+++ /dev/null
@@ -1,8 +0,0 @@
-      subroutine cffti (n,wsave)
-      dimension       wsave(*)
-      if (n .eq. 1) return
-      iw1 = n+n+1
-      iw2 = iw1+n+n
-      call cffti1 (n,wsave(iw1),wsave(iw2))
-      return
-      end
diff --git a/liboctave/external/fftpack/cffti1.f b/liboctave/external/fftpack/cffti1.f
deleted file mode 100644
--- a/liboctave/external/fftpack/cffti1.f
+++ /dev/null
@@ -1,60 +0,0 @@
-      subroutine cffti1 (n,wa,ifac)
-      dimension       wa(*)      ,ifac(*)    ,ntryh(4)
-      data ntryh(1),ntryh(2),ntryh(3),ntryh(4)/3,4,2,5/
-      nl = n
-      nf = 0
-      j = 0
-  101 j = j+1
-      if (j-4) 102,102,103
-  102 ntry = ntryh(j)
-      go to 104
-  103 ntry = ntry+2
-  104 nq = nl/ntry
-      nr = nl-ntry*nq
-      if (nr) 101,105,101
-  105 nf = nf+1
-      ifac(nf+2) = ntry
-      nl = nq
-      if (ntry .ne. 2) go to 107
-      if (nf .eq. 1) go to 107
-      do 106 i=2,nf
-         ib = nf-i+2
-         ifac(ib+2) = ifac(ib+1)
-  106 continue
-      ifac(3) = 2
-  107 if (nl .ne. 1) go to 104
-      ifac(1) = n
-      ifac(2) = nf
-      tpi = 6.28318530717959
-      argh = tpi/dble(n)
-      i = 2
-      l1 = 1
-      do 110 k1=1,nf
-         ip = ifac(k1+2)
-         ld = 0
-         l2 = l1*ip
-         ido = n/l2
-         idot = ido+ido+2
-         ipm = ip-1
-         do 109 j=1,ipm
-            i1 = i
-            wa(i-1) = 1.
-            wa(i) = 0.
-            ld = ld+l1
-            fi = 0.
-            argld = dble(ld)*argh
-            do 108 ii=4,idot,2
-               i = i+2
-               fi = fi+1.
-               arg = fi*argld
-               wa(i-1) = cos(arg)
-               wa(i) = sin(arg)
-  108       continue
-            if (ip .le. 5) go to 109
-            wa(i1-1) = wa(i-1)
-            wa(i1) = wa(i)
-  109    continue
-         l1 = l2
-  110 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/fftpack.doc b/liboctave/external/fftpack/fftpack.doc
deleted file mode 100644
--- a/liboctave/external/fftpack/fftpack.doc
+++ /dev/null
@@ -1,865 +0,0 @@
-
-                      FFTPACK
-
-* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
-
-                  version 4  april 1985
-
-     a package of fortran subprograms for the fast fourier
-      transform of periodic and other symmetric sequences
-
-                         by
-
-                  paul n swarztrauber
-
-  national center for atmospheric research  boulder,colorado 80307
-
-   which is sponsored by the national science foundation
-
-* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
-
-
-this package consists of programs which perform fast fourier
-transforms for both complex and real periodic sequences and
-certain other symmetric sequences that are listed below.
-
-1.   rffti     initialize  rfftf and rfftb
-2.   rfftf     forward transform of a real periodic sequence
-3.   rfftb     backward transform of a real coefficient array
-
-4.   ezffti    initialize ezfftf and ezfftb
-5.   ezfftf    a simplified real periodic forward transform
-6.   ezfftb    a simplified real periodic backward transform
-
-7.   sinti     initialize sint
-8.   sint      sine transform of a real odd sequence
-
-9.   costi     initialize cost
-10.  cost      cosine transform of a real even sequence
-
-11.  sinqi     initialize sinqf and sinqb
-12.  sinqf     forward sine transform with odd wave numbers
-13.  sinqb     unnormalized inverse of sinqf
-
-14.  cosqi     initialize cosqf and cosqb
-15.  cosqf     forward cosine transform with odd wave numbers
-16.  cosqb     unnormalized inverse of cosqf
-
-17.  cffti     initialize cfftf and cfftb
-18.  cfftf     forward transform of a complex periodic sequence
-19.  cfftb     unnormalized inverse of cfftf
-
-
-******************************************************************
-
-subroutine rffti(n,wsave)
-
-  ****************************************************************
-
-subroutine rffti initializes the array wsave which is used in
-both rfftf and rfftb. the prime factorization of n together with
-a tabulation of the trigonometric functions are computed and
-stored in wsave.
-
-input parameter
-
-n       the length of the sequence to be transformed.
-
-output parameter
-
-wsave   a work array which must be dimensioned at least 2*n+15.
-        the same work array can be used for both rfftf and rfftb
-        as long as n remains unchanged. different wsave arrays
-        are required for different values of n. the contents of
-        wsave must not be changed between calls of rfftf or rfftb.
-
-******************************************************************
-
-subroutine rfftf(n,r,wsave)
-
-******************************************************************
-
-subroutine rfftf computes the fourier coefficients of a real
-perodic sequence (fourier analysis). the transform is defined
-below at output parameter r.
-
-input parameters
-
-n       the length of the array r to be transformed.  the method
-        is most efficient when n is a product of small primes.
-        n may change so long as different work arrays are provided
-
-r       a real array of length n which contains the sequence
-        to be transformed
-
-wsave   a work array which must be dimensioned at least 2*n+15.
-        in the program that calls rfftf. the wsave array must be
-        initialized by calling subroutine rffti(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-        the same wsave array can be used by rfftf and rfftb.
-
-
-output parameters
-
-r       r(1) = the sum from i=1 to i=n of r(i)
-
-        if n is even set l =n/2   , if n is odd set l = (n+1)/2
-
-          then for k = 2,...,l
-
-             r(2*k-2) = the sum from i = 1 to i = n of
-
-                  r(i)*cos((k-1)*(i-1)*2*pi/n)
-
-             r(2*k-1) = the sum from i = 1 to i = n of
-
-                 -r(i)*sin((k-1)*(i-1)*2*pi/n)
-
-        if n is even
-
-             r(n) = the sum from i = 1 to i = n of
-
-                  (-1)**(i-1)*r(i)
-
- *****  note
-             this transform is unnormalized since a call of rfftf
-             followed by a call of rfftb will multiply the input
-             sequence by n.
-
-wsave   contains results which must not be destroyed between
-        calls of rfftf or rfftb.
-
-
-******************************************************************
-
-subroutine rfftb(n,r,wsave)
-
-******************************************************************
-
-subroutine rfftb computes the real perodic sequence from its
-fourier coefficients (fourier synthesis). the transform is defined
-below at output parameter r.
-
-input parameters
-
-n       the length of the array r to be transformed.  the method
-        is most efficient when n is a product of small primes.
-        n may change so long as different work arrays are provided
-
-r       a real array of length n which contains the sequence
-        to be transformed
-
-wsave   a work array which must be dimensioned at least 2*n+15.
-        in the program that calls rfftb. the wsave array must be
-        initialized by calling subroutine rffti(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-        the same wsave array can be used by rfftf and rfftb.
-
-
-output parameters
-
-r       for n even and for i = 1,...,n
-
-             r(i) = r(1)+(-1)**(i-1)*r(n)
-
-                  plus the sum from k=2 to k=n/2 of
-
-                   2.*r(2*k-2)*cos((k-1)*(i-1)*2*pi/n)
-
-                  -2.*r(2*k-1)*sin((k-1)*(i-1)*2*pi/n)
-
-        for n odd and for i = 1,...,n
-
-             r(i) = r(1) plus the sum from k=2 to k=(n+1)/2 of
-
-                  2.*r(2*k-2)*cos((k-1)*(i-1)*2*pi/n)
-
-                 -2.*r(2*k-1)*sin((k-1)*(i-1)*2*pi/n)
-
- *****  note
-             this transform is unnormalized since a call of rfftf
-             followed by a call of rfftb will multiply the input
-             sequence by n.
-
-wsave   contains results which must not be destroyed between
-        calls of rfftb or rfftf.
-
-
-******************************************************************
-
-subroutine ezffti(n,wsave)
-
-******************************************************************
-
-subroutine ezffti initializes the array wsave which is used in
-both ezfftf and ezfftb. the prime factorization of n together with
-a tabulation of the trigonometric functions are computed and
-stored in wsave.
-
-input parameter
-
-n       the length of the sequence to be transformed.
-
-output parameter
-
-wsave   a work array which must be dimensioned at least 3*n+15.
-        the same work array can be used for both ezfftf and ezfftb
-        as long as n remains unchanged. different wsave arrays
-        are required for different values of n.
-
-
-******************************************************************
-
-subroutine ezfftf(n,r,azero,a,b,wsave)
-
-******************************************************************
-
-subroutine ezfftf computes the fourier coefficients of a real
-perodic sequence (fourier analysis). the transform is defined
-below at output parameters azero,a and b. ezfftf is a simplified
-but slower version of rfftf.
-
-input parameters
-
-n       the length of the array r to be transformed.  the method
-        is must efficient when n is the product of small primes.
-
-r       a real array of length n which contains the sequence
-        to be transformed. r is not destroyed.
-
-
-wsave   a work array which must be dimensioned at least 3*n+15.
-        in the program that calls ezfftf. the wsave array must be
-        initialized by calling subroutine ezffti(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-        the same wsave array can be used by ezfftf and ezfftb.
-
-output parameters
-
-azero   the sum from i=1 to i=n of r(i)/n
-
-a,b     for n even b(n/2)=0. and a(n/2) is the sum from i=1 to
-        i=n of (-1)**(i-1)*r(i)/n
-
-        for n even define kmax=n/2-1
-        for n odd  define kmax=(n-1)/2
-
-        then for  k=1,...,kmax
-
-             a(k) equals the sum from i=1 to i=n of
-
-                  2./n*r(i)*cos(k*(i-1)*2*pi/n)
-
-             b(k) equals the sum from i=1 to i=n of
-
-                  2./n*r(i)*sin(k*(i-1)*2*pi/n)
-
-
-******************************************************************
-
-subroutine ezfftb(n,r,azero,a,b,wsave)
-
-******************************************************************
-
-subroutine ezfftb computes a real perodic sequence from its
-fourier coefficients (fourier synthesis). the transform is
-defined below at output parameter r. ezfftb is a simplified
-but slower version of rfftb.
-
-input parameters
-
-n       the length of the output array r.  the method is most
-        efficient when n is the product of small primes.
-
-azero   the constant fourier coefficient
-
-a,b     arrays which contain the remaining fourier coefficients
-        these arrays are not destroyed.
-
-        the length of these arrays depends on whether n is even or
-        odd.
-
-        if n is even n/2    locations are required
-        if n is odd (n-1)/2 locations are required
-
-wsave   a work array which must be dimensioned at least 3*n+15.
-        in the program that calls ezfftb. the wsave array must be
-        initialized by calling subroutine ezffti(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-        the same wsave array can be used by ezfftf and ezfftb.
-
-
-output parameters
-
-r       if n is even define kmax=n/2
-        if n is odd  define kmax=(n-1)/2
-
-        then for i=1,...,n
-
-             r(i)=azero plus the sum from k=1 to k=kmax of
-
-             a(k)*cos(k*(i-1)*2*pi/n)+b(k)*sin(k*(i-1)*2*pi/n)
-
-********************* complex notation **************************
-
-        for j=1,...,n
-
-        r(j) equals the sum from k=-kmax to k=kmax of
-
-             c(k)*exp(i*k*(j-1)*2*pi/n)
-
-        where
-
-             c(k) = .5*cmplx(a(k),-b(k))   for k=1,...,kmax
-
-             c(-k) = conjg(c(k))
-
-             c(0) = azero
-
-                  and i=sqrt(-1)
-
-*************** amplitude - phase notation ***********************
-
-        for i=1,...,n
-
-        r(i) equals azero plus the sum from k=1 to k=kmax of
-
-             alpha(k)*cos(k*(i-1)*2*pi/n+beta(k))
-
-        where
-
-             alpha(k) = sqrt(a(k)*a(k)+b(k)*b(k))
-
-             cos(beta(k))=a(k)/alpha(k)
-
-             sin(beta(k))=-b(k)/alpha(k)
-
-******************************************************************
-
-subroutine sinti(n,wsave)
-
-******************************************************************
-
-subroutine sinti initializes the array wsave which is used in
-subroutine sint. the prime factorization of n together with
-a tabulation of the trigonometric functions are computed and
-stored in wsave.
-
-input parameter
-
-n       the length of the sequence to be transformed.  the method
-        is most efficient when n+1 is a product of small primes.
-
-output parameter
-
-wsave   a work array with at least int(2.5*n+15) locations.
-        different wsave arrays are required for different values
-        of n. the contents of wsave must not be changed between
-        calls of sint.
-
-******************************************************************
-
-subroutine sint(n,x,wsave)
-
-******************************************************************
-
-subroutine sint computes the discrete fourier sine transform
-of an odd sequence x(i). the transform is defined below at
-output parameter x.
-
-sint is the unnormalized inverse of itself since a call of sint
-followed by another call of sint will multiply the input sequence
-x by 2*(n+1).
-
-the array wsave which is used by subroutine sint must be
-initialized by calling subroutine sinti(n,wsave).
-
-input parameters
-
-n       the length of the sequence to be transformed.  the method
-        is most efficient when n+1 is the product of small primes.
-
-x       an array which contains the sequence to be transformed
-
-
-wsave   a work array with dimension at least int(2.5*n+15)
-        in the program that calls sint. the wsave array must be
-        initialized by calling subroutine sinti(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-
-output parameters
-
-x       for i=1,...,n
-
-             x(i)= the sum from k=1 to k=n
-
-                  2*x(k)*sin(k*i*pi/(n+1))
-
-             a call of sint followed by another call of
-             sint will multiply the sequence x by 2*(n+1).
-             hence sint is the unnormalized inverse
-             of itself.
-
-wsave   contains initialization calculations which must not be
-        destroyed between calls of sint.
-
-******************************************************************
-
-subroutine costi(n,wsave)
-
-******************************************************************
-
-subroutine costi initializes the array wsave which is used in
-subroutine cost. the prime factorization of n together with
-a tabulation of the trigonometric functions are computed and
-stored in wsave.
-
-input parameter
-
-n       the length of the sequence to be transformed.  the method
-        is most efficient when n-1 is a product of small primes.
-
-output parameter
-
-wsave   a work array which must be dimensioned at least 3*n+15.
-        different wsave arrays are required for different values
-        of n. the contents of wsave must not be changed between
-        calls of cost.
-
-******************************************************************
-
-subroutine cost(n,x,wsave)
-
-******************************************************************
-
-subroutine cost computes the discrete fourier cosine transform
-of an even sequence x(i). the transform is defined below at output
-parameter x.
-
-cost is the unnormalized inverse of itself since a call of cost
-followed by another call of cost will multiply the input sequence
-x by 2*(n-1). the transform is defined below at output parameter x
-
-the array wsave which is used by subroutine cost must be
-initialized by calling subroutine costi(n,wsave).
-
-input parameters
-
-n       the length of the sequence x. n must be greater than 1.
-        the method is most efficient when n-1 is a product of
-        small primes.
-
-x       an array which contains the sequence to be transformed
-
-wsave   a work array which must be dimensioned at least 3*n+15
-        in the program that calls cost. the wsave array must be
-        initialized by calling subroutine costi(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-
-output parameters
-
-x       for i=1,...,n
-
-            x(i) = x(1)+(-1)**(i-1)*x(n)
-
-             + the sum from k=2 to k=n-1
-
-                 2*x(k)*cos((k-1)*(i-1)*pi/(n-1))
-
-             a call of cost followed by another call of
-             cost will multiply the sequence x by 2*(n-1)
-             hence cost is the unnormalized inverse
-             of itself.
-
-wsave   contains initialization calculations which must not be
-        destroyed between calls of cost.
-
-******************************************************************
-
-subroutine sinqi(n,wsave)
-
-******************************************************************
-
-subroutine sinqi initializes the array wsave which is used in
-both sinqf and sinqb. the prime factorization of n together with
-a tabulation of the trigonometric functions are computed and
-stored in wsave.
-
-input parameter
-
-n       the length of the sequence to be transformed. the method
-        is most efficient when n is a product of small primes.
-
-output parameter
-
-wsave   a work array which must be dimensioned at least 3*n+15.
-        the same work array can be used for both sinqf and sinqb
-        as long as n remains unchanged. different wsave arrays
-        are required for different values of n. the contents of
-        wsave must not be changed between calls of sinqf or sinqb.
-
-******************************************************************
-
-subroutine sinqf(n,x,wsave)
-
-******************************************************************
-
-subroutine sinqf computes the fast fourier transform of quarter
-wave data. that is , sinqf computes the coefficients in a sine
-series representation with only odd wave numbers. the transform
-is defined below at output parameter x.
-
-sinqb is the unnormalized inverse of sinqf since a call of sinqf
-followed by a call of sinqb will multiply the input sequence x
-by 4*n.
-
-the array wsave which is used by subroutine sinqf must be
-initialized by calling subroutine sinqi(n,wsave).
-
-
-input parameters
-
-n       the length of the array x to be transformed.  the method
-        is most efficient when n is a product of small primes.
-
-x       an array which contains the sequence to be transformed
-
-wsave   a work array which must be dimensioned at least 3*n+15.
-        in the program that calls sinqf. the wsave array must be
-        initialized by calling subroutine sinqi(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-
-output parameters
-
-x       for i=1,...,n
-
-             x(i) = (-1)**(i-1)*x(n)
-
-                + the sum from k=1 to k=n-1 of
-
-                2*x(k)*sin((2*i-1)*k*pi/(2*n))
-
-             a call of sinqf followed by a call of
-             sinqb will multiply the sequence x by 4*n.
-             therefore sinqb is the unnormalized inverse
-             of sinqf.
-
-wsave   contains initialization calculations which must not
-        be destroyed between calls of sinqf or sinqb.
-
-******************************************************************
-
-subroutine sinqb(n,x,wsave)
-
-******************************************************************
-
-subroutine sinqb computes the fast fourier transform of quarter
-wave data. that is , sinqb computes a sequence from its
-representation in terms of a sine series with odd wave numbers.
-the transform is defined below at output parameter x.
-
-sinqf is the unnormalized inverse of sinqb since a call of sinqb
-followed by a call of sinqf will multiply the input sequence x
-by 4*n.
-
-the array wsave which is used by subroutine sinqb must be
-initialized by calling subroutine sinqi(n,wsave).
-
-
-input parameters
-
-n       the length of the array x to be transformed.  the method
-        is most efficient when n is a product of small primes.
-
-x       an array which contains the sequence to be transformed
-
-wsave   a work array which must be dimensioned at least 3*n+15.
-        in the program that calls sinqb. the wsave array must be
-        initialized by calling subroutine sinqi(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-
-output parameters
-
-x       for i=1,...,n
-
-             x(i)= the sum from k=1 to k=n of
-
-               4*x(k)*sin((2k-1)*i*pi/(2*n))
-
-             a call of sinqb followed by a call of
-             sinqf will multiply the sequence x by 4*n.
-             therefore sinqf is the unnormalized inverse
-             of sinqb.
-
-wsave   contains initialization calculations which must not
-        be destroyed between calls of sinqb or sinqf.
-
-******************************************************************
-
-subroutine cosqi(n,wsave)
-
-******************************************************************
-
-subroutine cosqi initializes the array wsave which is used in
-both cosqf and cosqb. the prime factorization of n together with
-a tabulation of the trigonometric functions are computed and
-stored in wsave.
-
-input parameter
-
-n       the length of the array to be transformed.  the method
-        is most efficient when n is a product of small primes.
-
-output parameter
-
-wsave   a work array which must be dimensioned at least 3*n+15.
-        the same work array can be used for both cosqf and cosqb
-        as long as n remains unchanged. different wsave arrays
-        are required for different values of n. the contents of
-        wsave must not be changed between calls of cosqf or cosqb.
-
-******************************************************************
-
-subroutine cosqf(n,x,wsave)
-
-******************************************************************
-
-subroutine cosqf computes the fast fourier transform of quarter
-wave data. that is , cosqf computes the coefficients in a cosine
-series representation with only odd wave numbers. the transform
-is defined below at output parameter x
-
-cosqf is the unnormalized inverse of cosqb since a call of cosqf
-followed by a call of cosqb will multiply the input sequence x
-by 4*n.
-
-the array wsave which is used by subroutine cosqf must be
-initialized by calling subroutine cosqi(n,wsave).
-
-
-input parameters
-
-n       the length of the array x to be transformed.  the method
-        is most efficient when n is a product of small primes.
-
-x       an array which contains the sequence to be transformed
-
-wsave   a work array which must be dimensioned at least 3*n+15
-        in the program that calls cosqf. the wsave array must be
-        initialized by calling subroutine cosqi(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-
-output parameters
-
-x       for i=1,...,n
-
-             x(i) = x(1) plus the sum from k=2 to k=n of
-
-                2*x(k)*cos((2*i-1)*(k-1)*pi/(2*n))
-
-             a call of cosqf followed by a call of
-             cosqb will multiply the sequence x by 4*n.
-             therefore cosqb is the unnormalized inverse
-             of cosqf.
-
-wsave   contains initialization calculations which must not
-        be destroyed between calls of cosqf or cosqb.
-
-******************************************************************
-
-subroutine cosqb(n,x,wsave)
-
-******************************************************************
-
-subroutine cosqb computes the fast fourier transform of quarter
-wave data. that is , cosqb computes a sequence from its
-representation in terms of a cosine series with odd wave numbers.
-the transform is defined below at output parameter x.
-
-cosqb is the unnormalized inverse of cosqf since a call of cosqb
-followed by a call of cosqf will multiply the input sequence x
-by 4*n.
-
-the array wsave which is used by subroutine cosqb must be
-initialized by calling subroutine cosqi(n,wsave).
-
-
-input parameters
-
-n       the length of the array x to be transformed.  the method
-        is most efficient when n is a product of small primes.
-
-x       an array which contains the sequence to be transformed
-
-wsave   a work array that must be dimensioned at least 3*n+15
-        in the program that calls cosqb. the wsave array must be
-        initialized by calling subroutine cosqi(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-
-output parameters
-
-x       for i=1,...,n
-
-             x(i)= the sum from k=1 to k=n of
-
-               4*x(k)*cos((2*k-1)*(i-1)*pi/(2*n))
-
-             a call of cosqb followed by a call of
-             cosqf will multiply the sequence x by 4*n.
-             therefore cosqf is the unnormalized inverse
-             of cosqb.
-
-wsave   contains initialization calculations which must not
-        be destroyed between calls of cosqb or cosqf.
-
-******************************************************************
-
-subroutine cffti(n,wsave)
-
-******************************************************************
-
-subroutine cffti initializes the array wsave which is used in
-both cfftf and cfftb. the prime factorization of n together with
-a tabulation of the trigonometric functions are computed and
-stored in wsave.
-
-input parameter
-
-n       the length of the sequence to be transformed
-
-output parameter
-
-wsave   a work array which must be dimensioned at least 4*n+15
-        the same work array can be used for both cfftf and cfftb
-        as long as n remains unchanged. different wsave arrays
-        are required for different values of n. the contents of
-        wsave must not be changed between calls of cfftf or cfftb.
-
-******************************************************************
-
-subroutine cfftf(n,c,wsave)
-
-******************************************************************
-
-subroutine cfftf computes the forward complex discrete fourier
-transform (the fourier analysis). equivalently , cfftf computes
-the fourier coefficients of a complex periodic sequence.
-the transform is defined below at output parameter c.
-
-the transform is not normalized. to obtain a normalized transform
-the output must be divided by n. otherwise a call of cfftf
-followed by a call of cfftb will multiply the sequence by n.
-
-the array wsave which is used by subroutine cfftf must be
-initialized by calling subroutine cffti(n,wsave).
-
-input parameters
-
-
-n      the length of the complex sequence c. the method is
-       more efficient when n is the product of small primes. n
-
-c      a complex array of length n which contains the sequence
-
-wsave   a real work array which must be dimensioned at least 4n+15
-        in the program that calls cfftf. the wsave array must be
-        initialized by calling subroutine cffti(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-        the same wsave array can be used by cfftf and cfftb.
-
-output parameters
-
-c      for j=1,...,n
-
-           c(j)=the sum from k=1,...,n of
-
-                 c(k)*exp(-i*(j-1)*(k-1)*2*pi/n)
-
-                       where i=sqrt(-1)
-
-wsave   contains initialization calculations which must not be
-        destroyed between calls of subroutine cfftf or cfftb
-
-******************************************************************
-
-subroutine cfftb(n,c,wsave)
-
-******************************************************************
-
-subroutine cfftb computes the backward complex discrete fourier
-transform (the fourier synthesis). equivalently , cfftb computes
-a complex periodic sequence from its fourier coefficients.
-the transform is defined below at output parameter c.
-
-a call of cfftf followed by a call of cfftb will multiply the
-sequence by n.
-
-the array wsave which is used by subroutine cfftb must be
-initialized by calling subroutine cffti(n,wsave).
-
-input parameters
-
-
-n      the length of the complex sequence c. the method is
-       more efficient when n is the product of small primes.
-
-c      a complex array of length n which contains the sequence
-
-wsave   a real work array which must be dimensioned at least 4n+15
-        in the program that calls cfftb. the wsave array must be
-        initialized by calling subroutine cffti(n,wsave) and a
-        different wsave array must be used for each different
-        value of n. this initialization does not have to be
-        repeated so long as n remains unchanged thus subsequent
-        transforms can be obtained faster than the first.
-        the same wsave array can be used by cfftf and cfftb.
-
-output parameters
-
-c      for j=1,...,n
-
-           c(j)=the sum from k=1,...,n of
-
-                 c(k)*exp(i*(j-1)*(k-1)*2*pi/n)
-
-                       where i=sqrt(-1)
-
-wsave   contains initialization calculations which must not be
-        destroyed between calls of subroutine cfftf or cfftb
-
-
-
-["send index for vfftpk" describes a vectorized version of fftpack]
diff --git a/liboctave/external/fftpack/module.mk b/liboctave/external/fftpack/module.mk
deleted file mode 100644
--- a/liboctave/external/fftpack/module.mk
+++ /dev/null
@@ -1,42 +0,0 @@
-FFTPACK_SRC = \
-  %reldir%/cfftb.f \
-  %reldir%/cfftb1.f \
-  %reldir%/cfftf.f \
-  %reldir%/cfftf1.f \
-  %reldir%/cffti.f \
-  %reldir%/cffti1.f \
-  %reldir%/passb.f \
-  %reldir%/passb2.f \
-  %reldir%/passb3.f \
-  %reldir%/passb4.f \
-  %reldir%/passb5.f \
-  %reldir%/passf.f \
-  %reldir%/passf2.f \
-  %reldir%/passf3.f \
-  %reldir%/passf4.f \
-  %reldir%/passf5.f \
-  %reldir%/zfftb.f \
-  %reldir%/zfftb1.f \
-  %reldir%/zfftf.f \
-  %reldir%/zfftf1.f \
-  %reldir%/zffti.f \
-  %reldir%/zffti1.f \
-  %reldir%/zpassb.f \
-  %reldir%/zpassb2.f \
-  %reldir%/zpassb3.f \
-  %reldir%/zpassb4.f \
-  %reldir%/zpassb5.f \
-  %reldir%/zpassf.f \
-  %reldir%/zpassf2.f \
-  %reldir%/zpassf3.f \
-  %reldir%/zpassf4.f \
-  %reldir%/zpassf5.f
-
-if AMCOND_HAVE_FFTW
-  liboctave_EXTRA_DIST += $(FFTPACK_SRC)
-else
-  EXTERNAL_SOURCES += $(FFTPACK_SRC)
-endif
-
-liboctave_EXTRA_DIST += \
-  %reldir%/fftpack.doc
diff --git a/liboctave/external/fftpack/passb.f b/liboctave/external/fftpack/passb.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passb.f
+++ /dev/null
@@ -1,116 +0,0 @@
-      subroutine passb (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
-      dimension       ch(ido,l1,ip)          ,cc(ido,ip,l1)          ,
-     1                c1(ido,l1,ip)          ,wa(1)      ,c2(idl1,ip),
-     2                ch2(idl1,ip)
-      idot = ido/2
-      nt = ip*idl1
-      ipp2 = ip+2
-      ipph = (ip+1)/2
-      idp = ip*ido
-c
-      if (ido .lt. l1) go to 106
-      do 103 j=2,ipph
-         jc = ipp2-j
-         do 102 k=1,l1
-            do 101 i=1,ido
-               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
-               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
-  101       continue
-  102    continue
-  103 continue
-      do 105 k=1,l1
-         do 104 i=1,ido
-            ch(i,k,1) = cc(i,1,k)
-  104    continue
-  105 continue
-      go to 112
-  106 do 109 j=2,ipph
-         jc = ipp2-j
-         do 108 i=1,ido
-            do 107 k=1,l1
-               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
-               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
-  107       continue
-  108    continue
-  109 continue
-      do 111 i=1,ido
-         do 110 k=1,l1
-            ch(i,k,1) = cc(i,1,k)
-  110    continue
-  111 continue
-  112 idl = 2-ido
-      inc = 0
-      do 116 l=2,ipph
-         lc = ipp2-l
-         idl = idl+ido
-         do 113 ik=1,idl1
-            c2(ik,l) = ch2(ik,1)+wa(idl-1)*ch2(ik,2)
-            c2(ik,lc) = wa(idl)*ch2(ik,ip)
-  113    continue
-         idlj = idl
-         inc = inc+ido
-         do 115 j=3,ipph
-            jc = ipp2-j
-            idlj = idlj+inc
-            if (idlj .gt. idp) idlj = idlj-idp
-            war = wa(idlj-1)
-            wai = wa(idlj)
-            do 114 ik=1,idl1
-               c2(ik,l) = c2(ik,l)+war*ch2(ik,j)
-               c2(ik,lc) = c2(ik,lc)+wai*ch2(ik,jc)
-  114       continue
-  115    continue
-  116 continue
-      do 118 j=2,ipph
-         do 117 ik=1,idl1
-            ch2(ik,1) = ch2(ik,1)+ch2(ik,j)
-  117    continue
-  118 continue
-      do 120 j=2,ipph
-         jc = ipp2-j
-         do 119 ik=2,idl1,2
-            ch2(ik-1,j) = c2(ik-1,j)-c2(ik,jc)
-            ch2(ik-1,jc) = c2(ik-1,j)+c2(ik,jc)
-            ch2(ik,j) = c2(ik,j)+c2(ik-1,jc)
-            ch2(ik,jc) = c2(ik,j)-c2(ik-1,jc)
-  119    continue
-  120 continue
-      nac = 1
-      if (ido .eq. 2) return
-      nac = 0
-      do 121 ik=1,idl1
-         c2(ik,1) = ch2(ik,1)
-  121 continue
-      do 123 j=2,ip
-         do 122 k=1,l1
-            c1(1,k,j) = ch(1,k,j)
-            c1(2,k,j) = ch(2,k,j)
-  122    continue
-  123 continue
-      if (idot .gt. l1) go to 127
-      idij = 0
-      do 126 j=2,ip
-         idij = idij+2
-         do 125 i=4,ido,2
-            idij = idij+2
-            do 124 k=1,l1
-               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
-               c1(i,k,j) = wa(idij-1)*ch(i,k,j)+wa(idij)*ch(i-1,k,j)
-  124       continue
-  125    continue
-  126 continue
-      return
-  127 idj = 2-ido
-      do 130 j=2,ip
-         idj = idj+ido
-         do 129 k=1,l1
-            idij = idj
-            do 128 i=4,ido,2
-               idij = idij+2
-               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
-               c1(i,k,j) = wa(idij-1)*ch(i,k,j)+wa(idij)*ch(i-1,k,j)
-  128       continue
-  129    continue
-  130 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/passb2.f b/liboctave/external/fftpack/passb2.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passb2.f
+++ /dev/null
@@ -1,23 +0,0 @@
-      subroutine passb2 (ido,l1,cc,ch,wa1)
-      dimension       cc(ido,2,l1)           ,ch(ido,l1,2)           ,
-     1                wa1(1)
-      if (ido .gt. 2) go to 102
-      do 101 k=1,l1
-         ch(1,k,1) = cc(1,1,k)+cc(1,2,k)
-         ch(1,k,2) = cc(1,1,k)-cc(1,2,k)
-         ch(2,k,1) = cc(2,1,k)+cc(2,2,k)
-         ch(2,k,2) = cc(2,1,k)-cc(2,2,k)
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ch(i-1,k,1) = cc(i-1,1,k)+cc(i-1,2,k)
-            tr2 = cc(i-1,1,k)-cc(i-1,2,k)
-            ch(i,k,1) = cc(i,1,k)+cc(i,2,k)
-            ti2 = cc(i,1,k)-cc(i,2,k)
-            ch(i,k,2) = wa1(i-1)*ti2+wa1(i)*tr2
-            ch(i-1,k,2) = wa1(i-1)*tr2-wa1(i)*ti2
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/passb3.f b/liboctave/external/fftpack/passb3.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passb3.f
+++ /dev/null
@@ -1,42 +0,0 @@
-      subroutine passb3 (ido,l1,cc,ch,wa1,wa2)
-      dimension       cc(ido,3,l1)           ,ch(ido,l1,3)           ,
-     1                wa1(1)     ,wa2(1)
-      data taur,taui /-.5,.866025403784439/
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         tr2 = cc(1,2,k)+cc(1,3,k)
-         cr2 = cc(1,1,k)+taur*tr2
-         ch(1,k,1) = cc(1,1,k)+tr2
-         ti2 = cc(2,2,k)+cc(2,3,k)
-         ci2 = cc(2,1,k)+taur*ti2
-         ch(2,k,1) = cc(2,1,k)+ti2
-         cr3 = taui*(cc(1,2,k)-cc(1,3,k))
-         ci3 = taui*(cc(2,2,k)-cc(2,3,k))
-         ch(1,k,2) = cr2-ci3
-         ch(1,k,3) = cr2+ci3
-         ch(2,k,2) = ci2+cr3
-         ch(2,k,3) = ci2-cr3
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            tr2 = cc(i-1,2,k)+cc(i-1,3,k)
-            cr2 = cc(i-1,1,k)+taur*tr2
-            ch(i-1,k,1) = cc(i-1,1,k)+tr2
-            ti2 = cc(i,2,k)+cc(i,3,k)
-            ci2 = cc(i,1,k)+taur*ti2
-            ch(i,k,1) = cc(i,1,k)+ti2
-            cr3 = taui*(cc(i-1,2,k)-cc(i-1,3,k))
-            ci3 = taui*(cc(i,2,k)-cc(i,3,k))
-            dr2 = cr2-ci3
-            dr3 = cr2+ci3
-            di2 = ci2+cr3
-            di3 = ci2-cr3
-            ch(i,k,2) = wa1(i-1)*di2+wa1(i)*dr2
-            ch(i-1,k,2) = wa1(i-1)*dr2-wa1(i)*di2
-            ch(i,k,3) = wa2(i-1)*di3+wa2(i)*dr3
-            ch(i-1,k,3) = wa2(i-1)*dr3-wa2(i)*di3
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/passb4.f b/liboctave/external/fftpack/passb4.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passb4.f
+++ /dev/null
@@ -1,51 +0,0 @@
-      subroutine passb4 (ido,l1,cc,ch,wa1,wa2,wa3)
-      dimension       cc(ido,4,l1)           ,ch(ido,l1,4)           ,
-     1                wa1(1)     ,wa2(1)     ,wa3(1)
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         ti1 = cc(2,1,k)-cc(2,3,k)
-         ti2 = cc(2,1,k)+cc(2,3,k)
-         tr4 = cc(2,4,k)-cc(2,2,k)
-         ti3 = cc(2,2,k)+cc(2,4,k)
-         tr1 = cc(1,1,k)-cc(1,3,k)
-         tr2 = cc(1,1,k)+cc(1,3,k)
-         ti4 = cc(1,2,k)-cc(1,4,k)
-         tr3 = cc(1,2,k)+cc(1,4,k)
-         ch(1,k,1) = tr2+tr3
-         ch(1,k,3) = tr2-tr3
-         ch(2,k,1) = ti2+ti3
-         ch(2,k,3) = ti2-ti3
-         ch(1,k,2) = tr1+tr4
-         ch(1,k,4) = tr1-tr4
-         ch(2,k,2) = ti1+ti4
-         ch(2,k,4) = ti1-ti4
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ti1 = cc(i,1,k)-cc(i,3,k)
-            ti2 = cc(i,1,k)+cc(i,3,k)
-            ti3 = cc(i,2,k)+cc(i,4,k)
-            tr4 = cc(i,4,k)-cc(i,2,k)
-            tr1 = cc(i-1,1,k)-cc(i-1,3,k)
-            tr2 = cc(i-1,1,k)+cc(i-1,3,k)
-            ti4 = cc(i-1,2,k)-cc(i-1,4,k)
-            tr3 = cc(i-1,2,k)+cc(i-1,4,k)
-            ch(i-1,k,1) = tr2+tr3
-            cr3 = tr2-tr3
-            ch(i,k,1) = ti2+ti3
-            ci3 = ti2-ti3
-            cr2 = tr1+tr4
-            cr4 = tr1-tr4
-            ci2 = ti1+ti4
-            ci4 = ti1-ti4
-            ch(i-1,k,2) = wa1(i-1)*cr2-wa1(i)*ci2
-            ch(i,k,2) = wa1(i-1)*ci2+wa1(i)*cr2
-            ch(i-1,k,3) = wa2(i-1)*cr3-wa2(i)*ci3
-            ch(i,k,3) = wa2(i-1)*ci3+wa2(i)*cr3
-            ch(i-1,k,4) = wa3(i-1)*cr4-wa3(i)*ci4
-            ch(i,k,4) = wa3(i-1)*ci4+wa3(i)*cr4
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/passb5.f b/liboctave/external/fftpack/passb5.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passb5.f
+++ /dev/null
@@ -1,75 +0,0 @@
-      subroutine passb5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
-      dimension       cc(ido,5,l1)           ,ch(ido,l1,5)           ,
-     1                wa1(1)     ,wa2(1)     ,wa3(1)     ,wa4(1)
-      data tr11,ti11,tr12,ti12 /.309016994374947,.951056516295154,
-     1-.809016994374947,.587785252292473/
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         ti5 = cc(2,2,k)-cc(2,5,k)
-         ti2 = cc(2,2,k)+cc(2,5,k)
-         ti4 = cc(2,3,k)-cc(2,4,k)
-         ti3 = cc(2,3,k)+cc(2,4,k)
-         tr5 = cc(1,2,k)-cc(1,5,k)
-         tr2 = cc(1,2,k)+cc(1,5,k)
-         tr4 = cc(1,3,k)-cc(1,4,k)
-         tr3 = cc(1,3,k)+cc(1,4,k)
-         ch(1,k,1) = cc(1,1,k)+tr2+tr3
-         ch(2,k,1) = cc(2,1,k)+ti2+ti3
-         cr2 = cc(1,1,k)+tr11*tr2+tr12*tr3
-         ci2 = cc(2,1,k)+tr11*ti2+tr12*ti3
-         cr3 = cc(1,1,k)+tr12*tr2+tr11*tr3
-         ci3 = cc(2,1,k)+tr12*ti2+tr11*ti3
-         cr5 = ti11*tr5+ti12*tr4
-         ci5 = ti11*ti5+ti12*ti4
-         cr4 = ti12*tr5-ti11*tr4
-         ci4 = ti12*ti5-ti11*ti4
-         ch(1,k,2) = cr2-ci5
-         ch(1,k,5) = cr2+ci5
-         ch(2,k,2) = ci2+cr5
-         ch(2,k,3) = ci3+cr4
-         ch(1,k,3) = cr3-ci4
-         ch(1,k,4) = cr3+ci4
-         ch(2,k,4) = ci3-cr4
-         ch(2,k,5) = ci2-cr5
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ti5 = cc(i,2,k)-cc(i,5,k)
-            ti2 = cc(i,2,k)+cc(i,5,k)
-            ti4 = cc(i,3,k)-cc(i,4,k)
-            ti3 = cc(i,3,k)+cc(i,4,k)
-            tr5 = cc(i-1,2,k)-cc(i-1,5,k)
-            tr2 = cc(i-1,2,k)+cc(i-1,5,k)
-            tr4 = cc(i-1,3,k)-cc(i-1,4,k)
-            tr3 = cc(i-1,3,k)+cc(i-1,4,k)
-            ch(i-1,k,1) = cc(i-1,1,k)+tr2+tr3
-            ch(i,k,1) = cc(i,1,k)+ti2+ti3
-            cr2 = cc(i-1,1,k)+tr11*tr2+tr12*tr3
-            ci2 = cc(i,1,k)+tr11*ti2+tr12*ti3
-            cr3 = cc(i-1,1,k)+tr12*tr2+tr11*tr3
-            ci3 = cc(i,1,k)+tr12*ti2+tr11*ti3
-            cr5 = ti11*tr5+ti12*tr4
-            ci5 = ti11*ti5+ti12*ti4
-            cr4 = ti12*tr5-ti11*tr4
-            ci4 = ti12*ti5-ti11*ti4
-            dr3 = cr3-ci4
-            dr4 = cr3+ci4
-            di3 = ci3+cr4
-            di4 = ci3-cr4
-            dr5 = cr2+ci5
-            dr2 = cr2-ci5
-            di5 = ci2-cr5
-            di2 = ci2+cr5
-            ch(i-1,k,2) = wa1(i-1)*dr2-wa1(i)*di2
-            ch(i,k,2) = wa1(i-1)*di2+wa1(i)*dr2
-            ch(i-1,k,3) = wa2(i-1)*dr3-wa2(i)*di3
-            ch(i,k,3) = wa2(i-1)*di3+wa2(i)*dr3
-            ch(i-1,k,4) = wa3(i-1)*dr4-wa3(i)*di4
-            ch(i,k,4) = wa3(i-1)*di4+wa3(i)*dr4
-            ch(i-1,k,5) = wa4(i-1)*dr5-wa4(i)*di5
-            ch(i,k,5) = wa4(i-1)*di5+wa4(i)*dr5
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/passf.f b/liboctave/external/fftpack/passf.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passf.f
+++ /dev/null
@@ -1,116 +0,0 @@
-      subroutine passf (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
-      dimension       ch(ido,l1,ip)          ,cc(ido,ip,l1)          ,
-     1                c1(ido,l1,ip)          ,wa(1)      ,c2(idl1,ip),
-     2                ch2(idl1,ip)
-      idot = ido/2
-      nt = ip*idl1
-      ipp2 = ip+2
-      ipph = (ip+1)/2
-      idp = ip*ido
-c
-      if (ido .lt. l1) go to 106
-      do 103 j=2,ipph
-         jc = ipp2-j
-         do 102 k=1,l1
-            do 101 i=1,ido
-               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
-               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
-  101       continue
-  102    continue
-  103 continue
-      do 105 k=1,l1
-         do 104 i=1,ido
-            ch(i,k,1) = cc(i,1,k)
-  104    continue
-  105 continue
-      go to 112
-  106 do 109 j=2,ipph
-         jc = ipp2-j
-         do 108 i=1,ido
-            do 107 k=1,l1
-               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
-               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
-  107       continue
-  108    continue
-  109 continue
-      do 111 i=1,ido
-         do 110 k=1,l1
-            ch(i,k,1) = cc(i,1,k)
-  110    continue
-  111 continue
-  112 idl = 2-ido
-      inc = 0
-      do 116 l=2,ipph
-         lc = ipp2-l
-         idl = idl+ido
-         do 113 ik=1,idl1
-            c2(ik,l) = ch2(ik,1)+wa(idl-1)*ch2(ik,2)
-            c2(ik,lc) = -wa(idl)*ch2(ik,ip)
-  113    continue
-         idlj = idl
-         inc = inc+ido
-         do 115 j=3,ipph
-            jc = ipp2-j
-            idlj = idlj+inc
-            if (idlj .gt. idp) idlj = idlj-idp
-            war = wa(idlj-1)
-            wai = wa(idlj)
-            do 114 ik=1,idl1
-               c2(ik,l) = c2(ik,l)+war*ch2(ik,j)
-               c2(ik,lc) = c2(ik,lc)-wai*ch2(ik,jc)
-  114       continue
-  115    continue
-  116 continue
-      do 118 j=2,ipph
-         do 117 ik=1,idl1
-            ch2(ik,1) = ch2(ik,1)+ch2(ik,j)
-  117    continue
-  118 continue
-      do 120 j=2,ipph
-         jc = ipp2-j
-         do 119 ik=2,idl1,2
-            ch2(ik-1,j) = c2(ik-1,j)-c2(ik,jc)
-            ch2(ik-1,jc) = c2(ik-1,j)+c2(ik,jc)
-            ch2(ik,j) = c2(ik,j)+c2(ik-1,jc)
-            ch2(ik,jc) = c2(ik,j)-c2(ik-1,jc)
-  119    continue
-  120 continue
-      nac = 1
-      if (ido .eq. 2) return
-      nac = 0
-      do 121 ik=1,idl1
-         c2(ik,1) = ch2(ik,1)
-  121 continue
-      do 123 j=2,ip
-         do 122 k=1,l1
-            c1(1,k,j) = ch(1,k,j)
-            c1(2,k,j) = ch(2,k,j)
-  122    continue
-  123 continue
-      if (idot .gt. l1) go to 127
-      idij = 0
-      do 126 j=2,ip
-         idij = idij+2
-         do 125 i=4,ido,2
-            idij = idij+2
-            do 124 k=1,l1
-               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
-               c1(i,k,j) = wa(idij-1)*ch(i,k,j)-wa(idij)*ch(i-1,k,j)
-  124       continue
-  125    continue
-  126 continue
-      return
-  127 idj = 2-ido
-      do 130 j=2,ip
-         idj = idj+ido
-         do 129 k=1,l1
-            idij = idj
-            do 128 i=4,ido,2
-               idij = idij+2
-               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
-               c1(i,k,j) = wa(idij-1)*ch(i,k,j)-wa(idij)*ch(i-1,k,j)
-  128       continue
-  129    continue
-  130 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/passf2.f b/liboctave/external/fftpack/passf2.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passf2.f
+++ /dev/null
@@ -1,23 +0,0 @@
-      subroutine passf2 (ido,l1,cc,ch,wa1)
-      dimension       cc(ido,2,l1)           ,ch(ido,l1,2)           ,
-     1                wa1(1)
-      if (ido .gt. 2) go to 102
-      do 101 k=1,l1
-         ch(1,k,1) = cc(1,1,k)+cc(1,2,k)
-         ch(1,k,2) = cc(1,1,k)-cc(1,2,k)
-         ch(2,k,1) = cc(2,1,k)+cc(2,2,k)
-         ch(2,k,2) = cc(2,1,k)-cc(2,2,k)
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ch(i-1,k,1) = cc(i-1,1,k)+cc(i-1,2,k)
-            tr2 = cc(i-1,1,k)-cc(i-1,2,k)
-            ch(i,k,1) = cc(i,1,k)+cc(i,2,k)
-            ti2 = cc(i,1,k)-cc(i,2,k)
-            ch(i,k,2) = wa1(i-1)*ti2-wa1(i)*tr2
-            ch(i-1,k,2) = wa1(i-1)*tr2+wa1(i)*ti2
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/passf3.f b/liboctave/external/fftpack/passf3.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passf3.f
+++ /dev/null
@@ -1,42 +0,0 @@
-      subroutine passf3 (ido,l1,cc,ch,wa1,wa2)
-      dimension       cc(ido,3,l1)           ,ch(ido,l1,3)           ,
-     1                wa1(1)     ,wa2(1)
-      data taur,taui /-.5,-.866025403784439/
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         tr2 = cc(1,2,k)+cc(1,3,k)
-         cr2 = cc(1,1,k)+taur*tr2
-         ch(1,k,1) = cc(1,1,k)+tr2
-         ti2 = cc(2,2,k)+cc(2,3,k)
-         ci2 = cc(2,1,k)+taur*ti2
-         ch(2,k,1) = cc(2,1,k)+ti2
-         cr3 = taui*(cc(1,2,k)-cc(1,3,k))
-         ci3 = taui*(cc(2,2,k)-cc(2,3,k))
-         ch(1,k,2) = cr2-ci3
-         ch(1,k,3) = cr2+ci3
-         ch(2,k,2) = ci2+cr3
-         ch(2,k,3) = ci2-cr3
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            tr2 = cc(i-1,2,k)+cc(i-1,3,k)
-            cr2 = cc(i-1,1,k)+taur*tr2
-            ch(i-1,k,1) = cc(i-1,1,k)+tr2
-            ti2 = cc(i,2,k)+cc(i,3,k)
-            ci2 = cc(i,1,k)+taur*ti2
-            ch(i,k,1) = cc(i,1,k)+ti2
-            cr3 = taui*(cc(i-1,2,k)-cc(i-1,3,k))
-            ci3 = taui*(cc(i,2,k)-cc(i,3,k))
-            dr2 = cr2-ci3
-            dr3 = cr2+ci3
-            di2 = ci2+cr3
-            di3 = ci2-cr3
-            ch(i,k,2) = wa1(i-1)*di2-wa1(i)*dr2
-            ch(i-1,k,2) = wa1(i-1)*dr2+wa1(i)*di2
-            ch(i,k,3) = wa2(i-1)*di3-wa2(i)*dr3
-            ch(i-1,k,3) = wa2(i-1)*dr3+wa2(i)*di3
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/passf4.f b/liboctave/external/fftpack/passf4.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passf4.f
+++ /dev/null
@@ -1,51 +0,0 @@
-      subroutine passf4 (ido,l1,cc,ch,wa1,wa2,wa3)
-      dimension       cc(ido,4,l1)           ,ch(ido,l1,4)           ,
-     1                wa1(1)     ,wa2(1)     ,wa3(1)
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         ti1 = cc(2,1,k)-cc(2,3,k)
-         ti2 = cc(2,1,k)+cc(2,3,k)
-         tr4 = cc(2,2,k)-cc(2,4,k)
-         ti3 = cc(2,2,k)+cc(2,4,k)
-         tr1 = cc(1,1,k)-cc(1,3,k)
-         tr2 = cc(1,1,k)+cc(1,3,k)
-         ti4 = cc(1,4,k)-cc(1,2,k)
-         tr3 = cc(1,2,k)+cc(1,4,k)
-         ch(1,k,1) = tr2+tr3
-         ch(1,k,3) = tr2-tr3
-         ch(2,k,1) = ti2+ti3
-         ch(2,k,3) = ti2-ti3
-         ch(1,k,2) = tr1+tr4
-         ch(1,k,4) = tr1-tr4
-         ch(2,k,2) = ti1+ti4
-         ch(2,k,4) = ti1-ti4
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ti1 = cc(i,1,k)-cc(i,3,k)
-            ti2 = cc(i,1,k)+cc(i,3,k)
-            ti3 = cc(i,2,k)+cc(i,4,k)
-            tr4 = cc(i,2,k)-cc(i,4,k)
-            tr1 = cc(i-1,1,k)-cc(i-1,3,k)
-            tr2 = cc(i-1,1,k)+cc(i-1,3,k)
-            ti4 = cc(i-1,4,k)-cc(i-1,2,k)
-            tr3 = cc(i-1,2,k)+cc(i-1,4,k)
-            ch(i-1,k,1) = tr2+tr3
-            cr3 = tr2-tr3
-            ch(i,k,1) = ti2+ti3
-            ci3 = ti2-ti3
-            cr2 = tr1+tr4
-            cr4 = tr1-tr4
-            ci2 = ti1+ti4
-            ci4 = ti1-ti4
-            ch(i-1,k,2) = wa1(i-1)*cr2+wa1(i)*ci2
-            ch(i,k,2) = wa1(i-1)*ci2-wa1(i)*cr2
-            ch(i-1,k,3) = wa2(i-1)*cr3+wa2(i)*ci3
-            ch(i,k,3) = wa2(i-1)*ci3-wa2(i)*cr3
-            ch(i-1,k,4) = wa3(i-1)*cr4+wa3(i)*ci4
-            ch(i,k,4) = wa3(i-1)*ci4-wa3(i)*cr4
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/passf5.f b/liboctave/external/fftpack/passf5.f
deleted file mode 100644
--- a/liboctave/external/fftpack/passf5.f
+++ /dev/null
@@ -1,75 +0,0 @@
-      subroutine passf5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
-      dimension       cc(ido,5,l1)           ,ch(ido,l1,5)           ,
-     1                wa1(1)     ,wa2(1)     ,wa3(1)     ,wa4(1)
-      data tr11,ti11,tr12,ti12 /.309016994374947,-.951056516295154,
-     1-.809016994374947,-.587785252292473/
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         ti5 = cc(2,2,k)-cc(2,5,k)
-         ti2 = cc(2,2,k)+cc(2,5,k)
-         ti4 = cc(2,3,k)-cc(2,4,k)
-         ti3 = cc(2,3,k)+cc(2,4,k)
-         tr5 = cc(1,2,k)-cc(1,5,k)
-         tr2 = cc(1,2,k)+cc(1,5,k)
-         tr4 = cc(1,3,k)-cc(1,4,k)
-         tr3 = cc(1,3,k)+cc(1,4,k)
-         ch(1,k,1) = cc(1,1,k)+tr2+tr3
-         ch(2,k,1) = cc(2,1,k)+ti2+ti3
-         cr2 = cc(1,1,k)+tr11*tr2+tr12*tr3
-         ci2 = cc(2,1,k)+tr11*ti2+tr12*ti3
-         cr3 = cc(1,1,k)+tr12*tr2+tr11*tr3
-         ci3 = cc(2,1,k)+tr12*ti2+tr11*ti3
-         cr5 = ti11*tr5+ti12*tr4
-         ci5 = ti11*ti5+ti12*ti4
-         cr4 = ti12*tr5-ti11*tr4
-         ci4 = ti12*ti5-ti11*ti4
-         ch(1,k,2) = cr2-ci5
-         ch(1,k,5) = cr2+ci5
-         ch(2,k,2) = ci2+cr5
-         ch(2,k,3) = ci3+cr4
-         ch(1,k,3) = cr3-ci4
-         ch(1,k,4) = cr3+ci4
-         ch(2,k,4) = ci3-cr4
-         ch(2,k,5) = ci2-cr5
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ti5 = cc(i,2,k)-cc(i,5,k)
-            ti2 = cc(i,2,k)+cc(i,5,k)
-            ti4 = cc(i,3,k)-cc(i,4,k)
-            ti3 = cc(i,3,k)+cc(i,4,k)
-            tr5 = cc(i-1,2,k)-cc(i-1,5,k)
-            tr2 = cc(i-1,2,k)+cc(i-1,5,k)
-            tr4 = cc(i-1,3,k)-cc(i-1,4,k)
-            tr3 = cc(i-1,3,k)+cc(i-1,4,k)
-            ch(i-1,k,1) = cc(i-1,1,k)+tr2+tr3
-            ch(i,k,1) = cc(i,1,k)+ti2+ti3
-            cr2 = cc(i-1,1,k)+tr11*tr2+tr12*tr3
-            ci2 = cc(i,1,k)+tr11*ti2+tr12*ti3
-            cr3 = cc(i-1,1,k)+tr12*tr2+tr11*tr3
-            ci3 = cc(i,1,k)+tr12*ti2+tr11*ti3
-            cr5 = ti11*tr5+ti12*tr4
-            ci5 = ti11*ti5+ti12*ti4
-            cr4 = ti12*tr5-ti11*tr4
-            ci4 = ti12*ti5-ti11*ti4
-            dr3 = cr3-ci4
-            dr4 = cr3+ci4
-            di3 = ci3+cr4
-            di4 = ci3-cr4
-            dr5 = cr2+ci5
-            dr2 = cr2-ci5
-            di5 = ci2-cr5
-            di2 = ci2+cr5
-            ch(i-1,k,2) = wa1(i-1)*dr2+wa1(i)*di2
-            ch(i,k,2) = wa1(i-1)*di2-wa1(i)*dr2
-            ch(i-1,k,3) = wa2(i-1)*dr3+wa2(i)*di3
-            ch(i,k,3) = wa2(i-1)*di3-wa2(i)*dr3
-            ch(i-1,k,4) = wa3(i-1)*dr4+wa3(i)*di4
-            ch(i,k,4) = wa3(i-1)*di4-wa3(i)*dr4
-            ch(i-1,k,5) = wa4(i-1)*dr5+wa4(i)*di5
-            ch(i,k,5) = wa4(i-1)*di5-wa4(i)*dr5
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zfftb.f b/liboctave/external/fftpack/zfftb.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zfftb.f
+++ /dev/null
@@ -1,9 +0,0 @@
-      subroutine zfftb (n,c,wsave)
-      implicit double precision (a-h,o-z)
-      dimension       c(*)       ,wsave(*)
-      if (n .eq. 1) return
-      iw1 = n+n+1
-      iw2 = iw1+n+n
-      call zfftb1 (n,c,wsave,wsave(iw1),wsave(iw2))
-      return
-      end
diff --git a/liboctave/external/fftpack/zfftb1.f b/liboctave/external/fftpack/zfftb1.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zfftb1.f
+++ /dev/null
@@ -1,62 +0,0 @@
-      subroutine zfftb1 (n,c,ch,wa,ifac)
-      implicit double precision (a-h,o-z)
-      dimension       ch(*)      ,c(*)       ,wa(*)      ,ifac(*)
-      nf = ifac(2)
-      na = 0
-      l1 = 1
-      iw = 1
-      do 116 k1=1,nf
-         ip = ifac(k1+2)
-         l2 = ip*l1
-         ido = n/l2
-         idot = ido+ido
-         idl1 = idot*l1
-         if (ip .ne. 4) go to 103
-         ix2 = iw+idot
-         ix3 = ix2+idot
-         if (na .ne. 0) go to 101
-         call zpassb4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
-         go to 102
-  101    call zpassb4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
-  102    na = 1-na
-         go to 115
-  103    if (ip .ne. 2) go to 106
-         if (na .ne. 0) go to 104
-         call zpassb2 (idot,l1,c,ch,wa(iw))
-         go to 105
-  104    call zpassb2 (idot,l1,ch,c,wa(iw))
-  105    na = 1-na
-         go to 115
-  106    if (ip .ne. 3) go to 109
-         ix2 = iw+idot
-         if (na .ne. 0) go to 107
-         call zpassb3 (idot,l1,c,ch,wa(iw),wa(ix2))
-         go to 108
-  107    call zpassb3 (idot,l1,ch,c,wa(iw),wa(ix2))
-  108    na = 1-na
-         go to 115
-  109    if (ip .ne. 5) go to 112
-         ix2 = iw+idot
-         ix3 = ix2+idot
-         ix4 = ix3+idot
-         if (na .ne. 0) go to 110
-         call zpassb5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
-         go to 111
-  110    call zpassb5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
-  111    na = 1-na
-         go to 115
-  112    if (na .ne. 0) go to 113
-         call zpassb (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
-         go to 114
-  113    call zpassb (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
-  114    if (nac .ne. 0) na = 1-na
-  115    l1 = l2
-         iw = iw+(ip-1)*idot
-  116 continue
-      if (na .eq. 0) return
-      n2 = n+n
-      do 117 i=1,n2
-         c(i) = ch(i)
-  117 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zfftf.f b/liboctave/external/fftpack/zfftf.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zfftf.f
+++ /dev/null
@@ -1,9 +0,0 @@
-      subroutine zfftf (n,c,wsave)
-      implicit double precision (a-h,o-z)
-      dimension       c(*)       ,wsave(*)
-      if (n .eq. 1) return
-      iw1 = n+n+1
-      iw2 = iw1+n+n
-      call zfftf1 (n,c,wsave,wsave(iw1),wsave(iw2))
-      return
-      end
diff --git a/liboctave/external/fftpack/zfftf1.f b/liboctave/external/fftpack/zfftf1.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zfftf1.f
+++ /dev/null
@@ -1,62 +0,0 @@
-      subroutine zfftf1 (n,c,ch,wa,ifac)
-      implicit double precision (a-h,o-z)
-      dimension       ch(*)      ,c(*)       ,wa(*)      ,ifac(*)
-      nf = ifac(2)
-      na = 0
-      l1 = 1
-      iw = 1
-      do 116 k1=1,nf
-         ip = ifac(k1+2)
-         l2 = ip*l1
-         ido = n/l2
-         idot = ido+ido
-         idl1 = idot*l1
-         if (ip .ne. 4) go to 103
-         ix2 = iw+idot
-         ix3 = ix2+idot
-         if (na .ne. 0) go to 101
-         call zpassf4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
-         go to 102
-  101    call zpassf4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
-  102    na = 1-na
-         go to 115
-  103    if (ip .ne. 2) go to 106
-         if (na .ne. 0) go to 104
-         call zpassf2 (idot,l1,c,ch,wa(iw))
-         go to 105
-  104    call zpassf2 (idot,l1,ch,c,wa(iw))
-  105    na = 1-na
-         go to 115
-  106    if (ip .ne. 3) go to 109
-         ix2 = iw+idot
-         if (na .ne. 0) go to 107
-         call zpassf3 (idot,l1,c,ch,wa(iw),wa(ix2))
-         go to 108
-  107    call zpassf3 (idot,l1,ch,c,wa(iw),wa(ix2))
-  108    na = 1-na
-         go to 115
-  109    if (ip .ne. 5) go to 112
-         ix2 = iw+idot
-         ix3 = ix2+idot
-         ix4 = ix3+idot
-         if (na .ne. 0) go to 110
-         call zpassf5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
-         go to 111
-  110    call zpassf5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
-  111    na = 1-na
-         go to 115
-  112    if (na .ne. 0) go to 113
-         call zpassf (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
-         go to 114
-  113    call zpassf (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
-  114    if (nac .ne. 0) na = 1-na
-  115    l1 = l2
-         iw = iw+(ip-1)*idot
-  116 continue
-      if (na .eq. 0) return
-      n2 = n+n
-      do 117 i=1,n2
-         c(i) = ch(i)
-  117 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zffti.f b/liboctave/external/fftpack/zffti.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zffti.f
+++ /dev/null
@@ -1,9 +0,0 @@
-      subroutine zffti (n,wsave)
-      implicit double precision (a-h,o-z)
-      dimension       wsave(*)
-      if (n .eq. 1) return
-      iw1 = n+n+1
-      iw2 = iw1+n+n
-      call zffti1 (n,wsave(iw1),wsave(iw2))
-      return
-      end
diff --git a/liboctave/external/fftpack/zffti1.f b/liboctave/external/fftpack/zffti1.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zffti1.f
+++ /dev/null
@@ -1,61 +0,0 @@
-      subroutine zffti1 (n,wa,ifac)
-      implicit double precision (a-h,o-z)
-      dimension       wa(*)      ,ifac(*)    ,ntryh(4)
-      data ntryh(1),ntryh(2),ntryh(3),ntryh(4)/3,4,2,5/
-      nl = n
-      nf = 0
-      j = 0
-  101 j = j+1
-      if (j-4) 102,102,103
-  102 ntry = ntryh(j)
-      go to 104
-  103 ntry = ntry+2
-  104 nq = nl/ntry
-      nr = nl-ntry*nq
-      if (nr) 101,105,101
-  105 nf = nf+1
-      ifac(nf+2) = ntry
-      nl = nq
-      if (ntry .ne. 2) go to 107
-      if (nf .eq. 1) go to 107
-      do 106 i=2,nf
-         ib = nf-i+2
-         ifac(ib+2) = ifac(ib+1)
-  106 continue
-      ifac(3) = 2
-  107 if (nl .ne. 1) go to 104
-      ifac(1) = n
-      ifac(2) = nf
-      tpi = 6.28318530717959d0
-      argh = tpi/dble(n)
-      i = 2
-      l1 = 1
-      do 110 k1=1,nf
-         ip = ifac(k1+2)
-         ld = 0
-         l2 = l1*ip
-         ido = n/l2
-         idot = ido+ido+2
-         ipm = ip-1
-         do 109 j=1,ipm
-            i1 = i
-            wa(i-1) = 1.
-            wa(i) = 0.
-            ld = ld+l1
-            fi = 0.
-            argld = dble(ld)*argh
-            do 108 ii=4,idot,2
-               i = i+2
-               fi = fi+1.
-               arg = fi*argld
-               wa(i-1) = cos(arg)
-               wa(i) = sin(arg)
-  108       continue
-            if (ip .le. 5) go to 109
-            wa(i1-1) = wa(i-1)
-            wa(i1) = wa(i)
-  109    continue
-         l1 = l2
-  110 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassb.f b/liboctave/external/fftpack/zpassb.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassb.f
+++ /dev/null
@@ -1,117 +0,0 @@
-      subroutine zpassb (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
-      implicit double precision (a-h,o-z)
-      dimension       ch(ido,l1,ip)          ,cc(ido,ip,l1)          ,
-     1                c1(ido,l1,ip)          ,wa(1)      ,c2(idl1,ip),
-     2                ch2(idl1,ip)
-      idot = ido/2
-      nt = ip*idl1
-      ipp2 = ip+2
-      ipph = (ip+1)/2
-      idp = ip*ido
-c
-      if (ido .lt. l1) go to 106
-      do 103 j=2,ipph
-         jc = ipp2-j
-         do 102 k=1,l1
-            do 101 i=1,ido
-               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
-               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
-  101       continue
-  102    continue
-  103 continue
-      do 105 k=1,l1
-         do 104 i=1,ido
-            ch(i,k,1) = cc(i,1,k)
-  104    continue
-  105 continue
-      go to 112
-  106 do 109 j=2,ipph
-         jc = ipp2-j
-         do 108 i=1,ido
-            do 107 k=1,l1
-               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
-               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
-  107       continue
-  108    continue
-  109 continue
-      do 111 i=1,ido
-         do 110 k=1,l1
-            ch(i,k,1) = cc(i,1,k)
-  110    continue
-  111 continue
-  112 idl = 2-ido
-      inc = 0
-      do 116 l=2,ipph
-         lc = ipp2-l
-         idl = idl+ido
-         do 113 ik=1,idl1
-            c2(ik,l) = ch2(ik,1)+wa(idl-1)*ch2(ik,2)
-            c2(ik,lc) = wa(idl)*ch2(ik,ip)
-  113    continue
-         idlj = idl
-         inc = inc+ido
-         do 115 j=3,ipph
-            jc = ipp2-j
-            idlj = idlj+inc
-            if (idlj .gt. idp) idlj = idlj-idp
-            war = wa(idlj-1)
-            wai = wa(idlj)
-            do 114 ik=1,idl1
-               c2(ik,l) = c2(ik,l)+war*ch2(ik,j)
-               c2(ik,lc) = c2(ik,lc)+wai*ch2(ik,jc)
-  114       continue
-  115    continue
-  116 continue
-      do 118 j=2,ipph
-         do 117 ik=1,idl1
-            ch2(ik,1) = ch2(ik,1)+ch2(ik,j)
-  117    continue
-  118 continue
-      do 120 j=2,ipph
-         jc = ipp2-j
-         do 119 ik=2,idl1,2
-            ch2(ik-1,j) = c2(ik-1,j)-c2(ik,jc)
-            ch2(ik-1,jc) = c2(ik-1,j)+c2(ik,jc)
-            ch2(ik,j) = c2(ik,j)+c2(ik-1,jc)
-            ch2(ik,jc) = c2(ik,j)-c2(ik-1,jc)
-  119    continue
-  120 continue
-      nac = 1
-      if (ido .eq. 2) return
-      nac = 0
-      do 121 ik=1,idl1
-         c2(ik,1) = ch2(ik,1)
-  121 continue
-      do 123 j=2,ip
-         do 122 k=1,l1
-            c1(1,k,j) = ch(1,k,j)
-            c1(2,k,j) = ch(2,k,j)
-  122    continue
-  123 continue
-      if (idot .gt. l1) go to 127
-      idij = 0
-      do 126 j=2,ip
-         idij = idij+2
-         do 125 i=4,ido,2
-            idij = idij+2
-            do 124 k=1,l1
-               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
-               c1(i,k,j) = wa(idij-1)*ch(i,k,j)+wa(idij)*ch(i-1,k,j)
-  124       continue
-  125    continue
-  126 continue
-      return
-  127 idj = 2-ido
-      do 130 j=2,ip
-         idj = idj+ido
-         do 129 k=1,l1
-            idij = idj
-            do 128 i=4,ido,2
-               idij = idij+2
-               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
-               c1(i,k,j) = wa(idij-1)*ch(i,k,j)+wa(idij)*ch(i-1,k,j)
-  128       continue
-  129    continue
-  130 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassb2.f b/liboctave/external/fftpack/zpassb2.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassb2.f
+++ /dev/null
@@ -1,24 +0,0 @@
-      subroutine zpassb2 (ido,l1,cc,ch,wa1)
-      implicit double precision (a-h,o-z)
-      dimension       cc(ido,2,l1)           ,ch(ido,l1,2)           ,
-     1                wa1(1)
-      if (ido .gt. 2) go to 102
-      do 101 k=1,l1
-         ch(1,k,1) = cc(1,1,k)+cc(1,2,k)
-         ch(1,k,2) = cc(1,1,k)-cc(1,2,k)
-         ch(2,k,1) = cc(2,1,k)+cc(2,2,k)
-         ch(2,k,2) = cc(2,1,k)-cc(2,2,k)
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ch(i-1,k,1) = cc(i-1,1,k)+cc(i-1,2,k)
-            tr2 = cc(i-1,1,k)-cc(i-1,2,k)
-            ch(i,k,1) = cc(i,1,k)+cc(i,2,k)
-            ti2 = cc(i,1,k)-cc(i,2,k)
-            ch(i,k,2) = wa1(i-1)*ti2+wa1(i)*tr2
-            ch(i-1,k,2) = wa1(i-1)*tr2-wa1(i)*ti2
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassb3.f b/liboctave/external/fftpack/zpassb3.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassb3.f
+++ /dev/null
@@ -1,43 +0,0 @@
-      subroutine zpassb3 (ido,l1,cc,ch,wa1,wa2)
-      implicit double precision (a-h,o-z)
-      dimension       cc(ido,3,l1)           ,ch(ido,l1,3)           ,
-     1                wa1(1)     ,wa2(1)
-      data taur,taui /-.5,.866025403784439d0/
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         tr2 = cc(1,2,k)+cc(1,3,k)
-         cr2 = cc(1,1,k)+taur*tr2
-         ch(1,k,1) = cc(1,1,k)+tr2
-         ti2 = cc(2,2,k)+cc(2,3,k)
-         ci2 = cc(2,1,k)+taur*ti2
-         ch(2,k,1) = cc(2,1,k)+ti2
-         cr3 = taui*(cc(1,2,k)-cc(1,3,k))
-         ci3 = taui*(cc(2,2,k)-cc(2,3,k))
-         ch(1,k,2) = cr2-ci3
-         ch(1,k,3) = cr2+ci3
-         ch(2,k,2) = ci2+cr3
-         ch(2,k,3) = ci2-cr3
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            tr2 = cc(i-1,2,k)+cc(i-1,3,k)
-            cr2 = cc(i-1,1,k)+taur*tr2
-            ch(i-1,k,1) = cc(i-1,1,k)+tr2
-            ti2 = cc(i,2,k)+cc(i,3,k)
-            ci2 = cc(i,1,k)+taur*ti2
-            ch(i,k,1) = cc(i,1,k)+ti2
-            cr3 = taui*(cc(i-1,2,k)-cc(i-1,3,k))
-            ci3 = taui*(cc(i,2,k)-cc(i,3,k))
-            dr2 = cr2-ci3
-            dr3 = cr2+ci3
-            di2 = ci2+cr3
-            di3 = ci2-cr3
-            ch(i,k,2) = wa1(i-1)*di2+wa1(i)*dr2
-            ch(i-1,k,2) = wa1(i-1)*dr2-wa1(i)*di2
-            ch(i,k,3) = wa2(i-1)*di3+wa2(i)*dr3
-            ch(i-1,k,3) = wa2(i-1)*dr3-wa2(i)*di3
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassb4.f b/liboctave/external/fftpack/zpassb4.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassb4.f
+++ /dev/null
@@ -1,52 +0,0 @@
-      subroutine zpassb4 (ido,l1,cc,ch,wa1,wa2,wa3)
-      implicit double precision (a-h,o-z)
-      dimension       cc(ido,4,l1)           ,ch(ido,l1,4)           ,
-     1                wa1(1)     ,wa2(1)     ,wa3(1)
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         ti1 = cc(2,1,k)-cc(2,3,k)
-         ti2 = cc(2,1,k)+cc(2,3,k)
-         tr4 = cc(2,4,k)-cc(2,2,k)
-         ti3 = cc(2,2,k)+cc(2,4,k)
-         tr1 = cc(1,1,k)-cc(1,3,k)
-         tr2 = cc(1,1,k)+cc(1,3,k)
-         ti4 = cc(1,2,k)-cc(1,4,k)
-         tr3 = cc(1,2,k)+cc(1,4,k)
-         ch(1,k,1) = tr2+tr3
-         ch(1,k,3) = tr2-tr3
-         ch(2,k,1) = ti2+ti3
-         ch(2,k,3) = ti2-ti3
-         ch(1,k,2) = tr1+tr4
-         ch(1,k,4) = tr1-tr4
-         ch(2,k,2) = ti1+ti4
-         ch(2,k,4) = ti1-ti4
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ti1 = cc(i,1,k)-cc(i,3,k)
-            ti2 = cc(i,1,k)+cc(i,3,k)
-            ti3 = cc(i,2,k)+cc(i,4,k)
-            tr4 = cc(i,4,k)-cc(i,2,k)
-            tr1 = cc(i-1,1,k)-cc(i-1,3,k)
-            tr2 = cc(i-1,1,k)+cc(i-1,3,k)
-            ti4 = cc(i-1,2,k)-cc(i-1,4,k)
-            tr3 = cc(i-1,2,k)+cc(i-1,4,k)
-            ch(i-1,k,1) = tr2+tr3
-            cr3 = tr2-tr3
-            ch(i,k,1) = ti2+ti3
-            ci3 = ti2-ti3
-            cr2 = tr1+tr4
-            cr4 = tr1-tr4
-            ci2 = ti1+ti4
-            ci4 = ti1-ti4
-            ch(i-1,k,2) = wa1(i-1)*cr2-wa1(i)*ci2
-            ch(i,k,2) = wa1(i-1)*ci2+wa1(i)*cr2
-            ch(i-1,k,3) = wa2(i-1)*cr3-wa2(i)*ci3
-            ch(i,k,3) = wa2(i-1)*ci3+wa2(i)*cr3
-            ch(i-1,k,4) = wa3(i-1)*cr4-wa3(i)*ci4
-            ch(i,k,4) = wa3(i-1)*ci4+wa3(i)*cr4
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassb5.f b/liboctave/external/fftpack/zpassb5.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassb5.f
+++ /dev/null
@@ -1,76 +0,0 @@
-      subroutine zpassb5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
-      implicit double precision (a-h,o-z)
-      dimension       cc(ido,5,l1)           ,ch(ido,l1,5)           ,
-     1                wa1(1)     ,wa2(1)     ,wa3(1)     ,wa4(1)
-      data tr11,ti11,tr12,ti12 /.309016994374947d0,.951056516295154d0,
-     1-.809016994374947d0,.587785252292473d0/
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         ti5 = cc(2,2,k)-cc(2,5,k)
-         ti2 = cc(2,2,k)+cc(2,5,k)
-         ti4 = cc(2,3,k)-cc(2,4,k)
-         ti3 = cc(2,3,k)+cc(2,4,k)
-         tr5 = cc(1,2,k)-cc(1,5,k)
-         tr2 = cc(1,2,k)+cc(1,5,k)
-         tr4 = cc(1,3,k)-cc(1,4,k)
-         tr3 = cc(1,3,k)+cc(1,4,k)
-         ch(1,k,1) = cc(1,1,k)+tr2+tr3
-         ch(2,k,1) = cc(2,1,k)+ti2+ti3
-         cr2 = cc(1,1,k)+tr11*tr2+tr12*tr3
-         ci2 = cc(2,1,k)+tr11*ti2+tr12*ti3
-         cr3 = cc(1,1,k)+tr12*tr2+tr11*tr3
-         ci3 = cc(2,1,k)+tr12*ti2+tr11*ti3
-         cr5 = ti11*tr5+ti12*tr4
-         ci5 = ti11*ti5+ti12*ti4
-         cr4 = ti12*tr5-ti11*tr4
-         ci4 = ti12*ti5-ti11*ti4
-         ch(1,k,2) = cr2-ci5
-         ch(1,k,5) = cr2+ci5
-         ch(2,k,2) = ci2+cr5
-         ch(2,k,3) = ci3+cr4
-         ch(1,k,3) = cr3-ci4
-         ch(1,k,4) = cr3+ci4
-         ch(2,k,4) = ci3-cr4
-         ch(2,k,5) = ci2-cr5
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ti5 = cc(i,2,k)-cc(i,5,k)
-            ti2 = cc(i,2,k)+cc(i,5,k)
-            ti4 = cc(i,3,k)-cc(i,4,k)
-            ti3 = cc(i,3,k)+cc(i,4,k)
-            tr5 = cc(i-1,2,k)-cc(i-1,5,k)
-            tr2 = cc(i-1,2,k)+cc(i-1,5,k)
-            tr4 = cc(i-1,3,k)-cc(i-1,4,k)
-            tr3 = cc(i-1,3,k)+cc(i-1,4,k)
-            ch(i-1,k,1) = cc(i-1,1,k)+tr2+tr3
-            ch(i,k,1) = cc(i,1,k)+ti2+ti3
-            cr2 = cc(i-1,1,k)+tr11*tr2+tr12*tr3
-            ci2 = cc(i,1,k)+tr11*ti2+tr12*ti3
-            cr3 = cc(i-1,1,k)+tr12*tr2+tr11*tr3
-            ci3 = cc(i,1,k)+tr12*ti2+tr11*ti3
-            cr5 = ti11*tr5+ti12*tr4
-            ci5 = ti11*ti5+ti12*ti4
-            cr4 = ti12*tr5-ti11*tr4
-            ci4 = ti12*ti5-ti11*ti4
-            dr3 = cr3-ci4
-            dr4 = cr3+ci4
-            di3 = ci3+cr4
-            di4 = ci3-cr4
-            dr5 = cr2+ci5
-            dr2 = cr2-ci5
-            di5 = ci2-cr5
-            di2 = ci2+cr5
-            ch(i-1,k,2) = wa1(i-1)*dr2-wa1(i)*di2
-            ch(i,k,2) = wa1(i-1)*di2+wa1(i)*dr2
-            ch(i-1,k,3) = wa2(i-1)*dr3-wa2(i)*di3
-            ch(i,k,3) = wa2(i-1)*di3+wa2(i)*dr3
-            ch(i-1,k,4) = wa3(i-1)*dr4-wa3(i)*di4
-            ch(i,k,4) = wa3(i-1)*di4+wa3(i)*dr4
-            ch(i-1,k,5) = wa4(i-1)*dr5-wa4(i)*di5
-            ch(i,k,5) = wa4(i-1)*di5+wa4(i)*dr5
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassf.f b/liboctave/external/fftpack/zpassf.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassf.f
+++ /dev/null
@@ -1,117 +0,0 @@
-      subroutine zpassf (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
-      implicit double precision (a-h,o-z)
-      dimension       ch(ido,l1,ip)          ,cc(ido,ip,l1)          ,
-     1                c1(ido,l1,ip)          ,wa(1)      ,c2(idl1,ip),
-     2                ch2(idl1,ip)
-      idot = ido/2
-      nt = ip*idl1
-      ipp2 = ip+2
-      ipph = (ip+1)/2
-      idp = ip*ido
-c
-      if (ido .lt. l1) go to 106
-      do 103 j=2,ipph
-         jc = ipp2-j
-         do 102 k=1,l1
-            do 101 i=1,ido
-               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
-               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
-  101       continue
-  102    continue
-  103 continue
-      do 105 k=1,l1
-         do 104 i=1,ido
-            ch(i,k,1) = cc(i,1,k)
-  104    continue
-  105 continue
-      go to 112
-  106 do 109 j=2,ipph
-         jc = ipp2-j
-         do 108 i=1,ido
-            do 107 k=1,l1
-               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
-               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
-  107       continue
-  108    continue
-  109 continue
-      do 111 i=1,ido
-         do 110 k=1,l1
-            ch(i,k,1) = cc(i,1,k)
-  110    continue
-  111 continue
-  112 idl = 2-ido
-      inc = 0
-      do 116 l=2,ipph
-         lc = ipp2-l
-         idl = idl+ido
-         do 113 ik=1,idl1
-            c2(ik,l) = ch2(ik,1)+wa(idl-1)*ch2(ik,2)
-            c2(ik,lc) = -wa(idl)*ch2(ik,ip)
-  113    continue
-         idlj = idl
-         inc = inc+ido
-         do 115 j=3,ipph
-            jc = ipp2-j
-            idlj = idlj+inc
-            if (idlj .gt. idp) idlj = idlj-idp
-            war = wa(idlj-1)
-            wai = wa(idlj)
-            do 114 ik=1,idl1
-               c2(ik,l) = c2(ik,l)+war*ch2(ik,j)
-               c2(ik,lc) = c2(ik,lc)-wai*ch2(ik,jc)
-  114       continue
-  115    continue
-  116 continue
-      do 118 j=2,ipph
-         do 117 ik=1,idl1
-            ch2(ik,1) = ch2(ik,1)+ch2(ik,j)
-  117    continue
-  118 continue
-      do 120 j=2,ipph
-         jc = ipp2-j
-         do 119 ik=2,idl1,2
-            ch2(ik-1,j) = c2(ik-1,j)-c2(ik,jc)
-            ch2(ik-1,jc) = c2(ik-1,j)+c2(ik,jc)
-            ch2(ik,j) = c2(ik,j)+c2(ik-1,jc)
-            ch2(ik,jc) = c2(ik,j)-c2(ik-1,jc)
-  119    continue
-  120 continue
-      nac = 1
-      if (ido .eq. 2) return
-      nac = 0
-      do 121 ik=1,idl1
-         c2(ik,1) = ch2(ik,1)
-  121 continue
-      do 123 j=2,ip
-         do 122 k=1,l1
-            c1(1,k,j) = ch(1,k,j)
-            c1(2,k,j) = ch(2,k,j)
-  122    continue
-  123 continue
-      if (idot .gt. l1) go to 127
-      idij = 0
-      do 126 j=2,ip
-         idij = idij+2
-         do 125 i=4,ido,2
-            idij = idij+2
-            do 124 k=1,l1
-               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
-               c1(i,k,j) = wa(idij-1)*ch(i,k,j)-wa(idij)*ch(i-1,k,j)
-  124       continue
-  125    continue
-  126 continue
-      return
-  127 idj = 2-ido
-      do 130 j=2,ip
-         idj = idj+ido
-         do 129 k=1,l1
-            idij = idj
-            do 128 i=4,ido,2
-               idij = idij+2
-               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
-               c1(i,k,j) = wa(idij-1)*ch(i,k,j)-wa(idij)*ch(i-1,k,j)
-  128       continue
-  129    continue
-  130 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassf2.f b/liboctave/external/fftpack/zpassf2.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassf2.f
+++ /dev/null
@@ -1,24 +0,0 @@
-      subroutine zpassf2 (ido,l1,cc,ch,wa1)
-      implicit double precision (a-h,o-z)
-      dimension       cc(ido,2,l1)           ,ch(ido,l1,2)           ,
-     1                wa1(1)
-      if (ido .gt. 2) go to 102
-      do 101 k=1,l1
-         ch(1,k,1) = cc(1,1,k)+cc(1,2,k)
-         ch(1,k,2) = cc(1,1,k)-cc(1,2,k)
-         ch(2,k,1) = cc(2,1,k)+cc(2,2,k)
-         ch(2,k,2) = cc(2,1,k)-cc(2,2,k)
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ch(i-1,k,1) = cc(i-1,1,k)+cc(i-1,2,k)
-            tr2 = cc(i-1,1,k)-cc(i-1,2,k)
-            ch(i,k,1) = cc(i,1,k)+cc(i,2,k)
-            ti2 = cc(i,1,k)-cc(i,2,k)
-            ch(i,k,2) = wa1(i-1)*ti2-wa1(i)*tr2
-            ch(i-1,k,2) = wa1(i-1)*tr2+wa1(i)*ti2
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassf3.f b/liboctave/external/fftpack/zpassf3.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassf3.f
+++ /dev/null
@@ -1,43 +0,0 @@
-      subroutine zpassf3 (ido,l1,cc,ch,wa1,wa2)
-      implicit double precision (a-h,o-z)
-      dimension       cc(ido,3,l1)           ,ch(ido,l1,3)           ,
-     1                wa1(1)     ,wa2(1)
-      data taur,taui /-.5d0,-.866025403784439d0/
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         tr2 = cc(1,2,k)+cc(1,3,k)
-         cr2 = cc(1,1,k)+taur*tr2
-         ch(1,k,1) = cc(1,1,k)+tr2
-         ti2 = cc(2,2,k)+cc(2,3,k)
-         ci2 = cc(2,1,k)+taur*ti2
-         ch(2,k,1) = cc(2,1,k)+ti2
-         cr3 = taui*(cc(1,2,k)-cc(1,3,k))
-         ci3 = taui*(cc(2,2,k)-cc(2,3,k))
-         ch(1,k,2) = cr2-ci3
-         ch(1,k,3) = cr2+ci3
-         ch(2,k,2) = ci2+cr3
-         ch(2,k,3) = ci2-cr3
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            tr2 = cc(i-1,2,k)+cc(i-1,3,k)
-            cr2 = cc(i-1,1,k)+taur*tr2
-            ch(i-1,k,1) = cc(i-1,1,k)+tr2
-            ti2 = cc(i,2,k)+cc(i,3,k)
-            ci2 = cc(i,1,k)+taur*ti2
-            ch(i,k,1) = cc(i,1,k)+ti2
-            cr3 = taui*(cc(i-1,2,k)-cc(i-1,3,k))
-            ci3 = taui*(cc(i,2,k)-cc(i,3,k))
-            dr2 = cr2-ci3
-            dr3 = cr2+ci3
-            di2 = ci2+cr3
-            di3 = ci2-cr3
-            ch(i,k,2) = wa1(i-1)*di2-wa1(i)*dr2
-            ch(i-1,k,2) = wa1(i-1)*dr2+wa1(i)*di2
-            ch(i,k,3) = wa2(i-1)*di3-wa2(i)*dr3
-            ch(i-1,k,3) = wa2(i-1)*dr3+wa2(i)*di3
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassf4.f b/liboctave/external/fftpack/zpassf4.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassf4.f
+++ /dev/null
@@ -1,52 +0,0 @@
-      subroutine zpassf4 (ido,l1,cc,ch,wa1,wa2,wa3)
-      implicit double precision (a-h,o-z)
-      dimension       cc(ido,4,l1)           ,ch(ido,l1,4)           ,
-     1                wa1(1)     ,wa2(1)     ,wa3(1)
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         ti1 = cc(2,1,k)-cc(2,3,k)
-         ti2 = cc(2,1,k)+cc(2,3,k)
-         tr4 = cc(2,2,k)-cc(2,4,k)
-         ti3 = cc(2,2,k)+cc(2,4,k)
-         tr1 = cc(1,1,k)-cc(1,3,k)
-         tr2 = cc(1,1,k)+cc(1,3,k)
-         ti4 = cc(1,4,k)-cc(1,2,k)
-         tr3 = cc(1,2,k)+cc(1,4,k)
-         ch(1,k,1) = tr2+tr3
-         ch(1,k,3) = tr2-tr3
-         ch(2,k,1) = ti2+ti3
-         ch(2,k,3) = ti2-ti3
-         ch(1,k,2) = tr1+tr4
-         ch(1,k,4) = tr1-tr4
-         ch(2,k,2) = ti1+ti4
-         ch(2,k,4) = ti1-ti4
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ti1 = cc(i,1,k)-cc(i,3,k)
-            ti2 = cc(i,1,k)+cc(i,3,k)
-            ti3 = cc(i,2,k)+cc(i,4,k)
-            tr4 = cc(i,2,k)-cc(i,4,k)
-            tr1 = cc(i-1,1,k)-cc(i-1,3,k)
-            tr2 = cc(i-1,1,k)+cc(i-1,3,k)
-            ti4 = cc(i-1,4,k)-cc(i-1,2,k)
-            tr3 = cc(i-1,2,k)+cc(i-1,4,k)
-            ch(i-1,k,1) = tr2+tr3
-            cr3 = tr2-tr3
-            ch(i,k,1) = ti2+ti3
-            ci3 = ti2-ti3
-            cr2 = tr1+tr4
-            cr4 = tr1-tr4
-            ci2 = ti1+ti4
-            ci4 = ti1-ti4
-            ch(i-1,k,2) = wa1(i-1)*cr2+wa1(i)*ci2
-            ch(i,k,2) = wa1(i-1)*ci2-wa1(i)*cr2
-            ch(i-1,k,3) = wa2(i-1)*cr3+wa2(i)*ci3
-            ch(i,k,3) = wa2(i-1)*ci3-wa2(i)*cr3
-            ch(i-1,k,4) = wa3(i-1)*cr4+wa3(i)*ci4
-            ch(i,k,4) = wa3(i-1)*ci4-wa3(i)*cr4
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/fftpack/zpassf5.f b/liboctave/external/fftpack/zpassf5.f
deleted file mode 100644
--- a/liboctave/external/fftpack/zpassf5.f
+++ /dev/null
@@ -1,76 +0,0 @@
-      subroutine zpassf5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
-      implicit double precision (a-h,o-z)
-      dimension       cc(ido,5,l1)           ,ch(ido,l1,5)           ,
-     1                wa1(1)     ,wa2(1)     ,wa3(1)     ,wa4(1)
-      data tr11,ti11,tr12,ti12 /.309016994374947d0,-.951056516295154d0,
-     1-.809016994374947d0,-.587785252292473d0/
-      if (ido .ne. 2) go to 102
-      do 101 k=1,l1
-         ti5 = cc(2,2,k)-cc(2,5,k)
-         ti2 = cc(2,2,k)+cc(2,5,k)
-         ti4 = cc(2,3,k)-cc(2,4,k)
-         ti3 = cc(2,3,k)+cc(2,4,k)
-         tr5 = cc(1,2,k)-cc(1,5,k)
-         tr2 = cc(1,2,k)+cc(1,5,k)
-         tr4 = cc(1,3,k)-cc(1,4,k)
-         tr3 = cc(1,3,k)+cc(1,4,k)
-         ch(1,k,1) = cc(1,1,k)+tr2+tr3
-         ch(2,k,1) = cc(2,1,k)+ti2+ti3
-         cr2 = cc(1,1,k)+tr11*tr2+tr12*tr3
-         ci2 = cc(2,1,k)+tr11*ti2+tr12*ti3
-         cr3 = cc(1,1,k)+tr12*tr2+tr11*tr3
-         ci3 = cc(2,1,k)+tr12*ti2+tr11*ti3
-         cr5 = ti11*tr5+ti12*tr4
-         ci5 = ti11*ti5+ti12*ti4
-         cr4 = ti12*tr5-ti11*tr4
-         ci4 = ti12*ti5-ti11*ti4
-         ch(1,k,2) = cr2-ci5
-         ch(1,k,5) = cr2+ci5
-         ch(2,k,2) = ci2+cr5
-         ch(2,k,3) = ci3+cr4
-         ch(1,k,3) = cr3-ci4
-         ch(1,k,4) = cr3+ci4
-         ch(2,k,4) = ci3-cr4
-         ch(2,k,5) = ci2-cr5
-  101 continue
-      return
-  102 do 104 k=1,l1
-         do 103 i=2,ido,2
-            ti5 = cc(i,2,k)-cc(i,5,k)
-            ti2 = cc(i,2,k)+cc(i,5,k)
-            ti4 = cc(i,3,k)-cc(i,4,k)
-            ti3 = cc(i,3,k)+cc(i,4,k)
-            tr5 = cc(i-1,2,k)-cc(i-1,5,k)
-            tr2 = cc(i-1,2,k)+cc(i-1,5,k)
-            tr4 = cc(i-1,3,k)-cc(i-1,4,k)
-            tr3 = cc(i-1,3,k)+cc(i-1,4,k)
-            ch(i-1,k,1) = cc(i-1,1,k)+tr2+tr3
-            ch(i,k,1) = cc(i,1,k)+ti2+ti3
-            cr2 = cc(i-1,1,k)+tr11*tr2+tr12*tr3
-            ci2 = cc(i,1,k)+tr11*ti2+tr12*ti3
-            cr3 = cc(i-1,1,k)+tr12*tr2+tr11*tr3
-            ci3 = cc(i,1,k)+tr12*ti2+tr11*ti3
-            cr5 = ti11*tr5+ti12*tr4
-            ci5 = ti11*ti5+ti12*ti4
-            cr4 = ti12*tr5-ti11*tr4
-            ci4 = ti12*ti5-ti11*ti4
-            dr3 = cr3-ci4
-            dr4 = cr3+ci4
-            di3 = ci3+cr4
-            di4 = ci3-cr4
-            dr5 = cr2+ci5
-            dr2 = cr2-ci5
-            di5 = ci2-cr5
-            di2 = ci2+cr5
-            ch(i-1,k,2) = wa1(i-1)*dr2+wa1(i)*di2
-            ch(i,k,2) = wa1(i-1)*di2-wa1(i)*dr2
-            ch(i-1,k,3) = wa2(i-1)*dr3+wa2(i)*di3
-            ch(i,k,3) = wa2(i-1)*di3-wa2(i)*dr3
-            ch(i-1,k,4) = wa3(i-1)*dr4+wa3(i)*di4
-            ch(i,k,4) = wa3(i-1)*di4-wa3(i)*dr4
-            ch(i-1,k,5) = wa4(i-1)*dr5+wa4(i)*di5
-            ch(i,k,5) = wa4(i-1)*di5-wa4(i)*dr5
-  103    continue
-  104 continue
-      return
-      end
diff --git a/liboctave/external/module.mk b/liboctave/external/module.mk
--- a/liboctave/external/module.mk
+++ b/liboctave/external/module.mk
@@ -9,17 +9,16 @@ EXTERNAL_INC =
 EXTERNAL_SOURCES =
 
 include %reldir%/amos/module.mk
 include %reldir%/blas-xtra/module.mk
 include %reldir%/daspk/module.mk
 include %reldir%/dasrt/module.mk
 include %reldir%/dassl/module.mk
 include %reldir%/Faddeeva/module.mk
-include %reldir%/fftpack/module.mk
 include %reldir%/lapack-xtra/module.mk
 include %reldir%/odepack/module.mk
 include %reldir%/quadpack/module.mk
 include %reldir%/ranlib/module.mk
 include %reldir%/slatec-err/module.mk
 include %reldir%/slatec-fn/module.mk
 
 %reldir%/external.def: $(%canon_reldir%_libexternal_la_SOURCES) %reldir%/mk-f77-def.sh
diff --git a/liboctave/numeric/lo-fftpack-proto.h b/liboctave/numeric/lo-fftpack-proto.h
deleted file mode 100644
--- a/liboctave/numeric/lo-fftpack-proto.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
-
-Copyright (C) 2016-2018 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software: you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-Octave is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<https://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_lo_fftpack_proto_h)
-#define octave_lo_fftpack_proto_h 1
-
-#include "octave-config.h"
-
-#include "f77-fcn.h"
-
-extern "C"
-{
-  // Note that the original complex fft routines were not written for
-  // float or double complex arguments.  They have been modified by
-  // adding an implicit float or double precision (a-h,o-z) statement
-  // at the beginning of each subroutine.
-
-  // FFTB
-
-  F77_RET_T
-  F77_FUNC (cfftb, CFFTB) (const F77_INT&, F77_CMPLX*, F77_CMPLX*);
-
-  F77_RET_T
-  F77_FUNC (zfftb, ZFFTB) (const F77_INT&, F77_DBLE_CMPLX*, F77_DBLE_CMPLX*);
-
-  // FFTF
-
-  F77_RET_T
-  F77_FUNC (cfftf, CFFTF) (const F77_INT&, F77_CMPLX*, F77_CMPLX*);
-
-  F77_RET_T
-  F77_FUNC (zfftf, ZFFTF) (const F77_INT&, F77_DBLE_CMPLX*, F77_DBLE_CMPLX*);
-
-  // FFTI
-
-  F77_RET_T
-  F77_FUNC (cffti, CFFTI) (const F77_INT&, F77_CMPLX*);
-
-  F77_RET_T
-  F77_FUNC (zffti, ZFFTI) (const F77_INT&, F77_DBLE_CMPLX*);
-}
-
-#endif
diff --git a/liboctave/numeric/module.mk b/liboctave/numeric/module.mk
--- a/liboctave/numeric/module.mk
+++ b/liboctave/numeric/module.mk
@@ -34,17 +34,16 @@ NUMERIC_INC = \
   %reldir%/chol.h \
   %reldir%/eigs-base.h \
   %reldir%/fEIG.h \
   %reldir%/gepbalance.h \
   %reldir%/hess.h \
   %reldir%/lo-amos-proto.h \
   %reldir%/lo-arpack-proto.h \
   %reldir%/lo-blas-proto.h \
-  %reldir%/lo-fftpack-proto.h \
   %reldir%/lo-lapack-proto.h \
   %reldir%/lo-mappers.h \
   %reldir%/lo-qrupdate-proto.h \
   %reldir%/lo-ranlib-proto.h \
   %reldir%/lo-slatec-proto.h \
   %reldir%/lo-specfun.h \
   %reldir%/lu.h \
   %reldir%/oct-convn.h \
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -113,31 +113,38 @@ endfunction
 %! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 %! yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
 %! plot (ti, yp, 'g', ti, interp1(t, y, ti, "spline"), 'b', ...
 %!       ti, interpft (y, k), 'c', t, y, "r+");
 %! legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
 
 %!shared n,y
 %! x = [0:10]';  y = sin(x);  n = length (x);
-%!assert (interpft (y, n), y, 20*eps)
-%!assert (interpft (y', n), y', 20*eps)
-%!assert (interpft ([y,y],n), [y,y], 20*eps)
+%!testif HAVE_FFTW
+%! assert (interpft (y, n), y, 20*eps)
+%!testif HAVE_FFTW
+%! assert (interpft (y', n), y', 20*eps)
+%!testif HAVE_FFTW
+%! assert (interpft ([y,y],n), [y,y], 20*eps)
 
 ## Test case with complex input
-%!test <*39566>
+%!testif HAVE_FFTW <*39566>
 %! x = (1 + j) * [1:4]';
 %! y = ifft ([15 + 15*j; -6; -1.5 - 1.5*j; 0; -1.5 - 1.5*j; -6*j]);
 %! assert (interpft (x, 6), y, 10*eps);
 
 ## Test for correct spectral symmetry with even/odd lengths
-%!assert (max (abs (imag (interpft ([1:8], 20)))), 0, 20*eps)
-%!assert (max (abs (imag (interpft ([1:8], 21)))), 0, 21*eps)
-%!assert (max (abs (imag (interpft ([1:9], 20)))), 0, 20*eps)
-%!assert (max (abs (imag (interpft ([1:9], 21)))), 0, 21*eps)
+%!testif HAVE_FFTW
+%! assert (max (abs (imag (interpft ([1:8], 20)))), 0, 20*eps)
+%!testif HAVE_FFTW
+%! assert (max (abs (imag (interpft ([1:8], 21)))), 0, 21*eps)
+%!testif HAVE_FFTW
+%! assert (max (abs (imag (interpft ([1:9], 20)))), 0, 20*eps)
+%!testif HAVE_FFTW
+%! assert (max (abs (imag (interpft ([1:9], 21)))), 0, 21*eps)
 
 ## Test input validation
 %!error interpft ()
 %!error interpft (1)
 %!error interpft (1,2,3)
 %!error <N must be a scalar integer> interpft (1,[2,2])
 %!error <N must be a scalar integer> interpft (1,2.1)
 %!error <invalid dimension DIM> interpft (1,2,0)
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -61,17 +61,17 @@ function c = fftconv (x, y, n)
       c = fftfilt (x, y, n);
     endif
   endif
 
 endfunction
 
 
 ## FIXME: Borrow tests from conv.m.  May need tolerance on the assert stmt.
-%!test
+%!testif HAVE_FFTW
 %! x = ones (3,1);
 %! y = ones (1,3);
 %! b = 2;
 %! c = 3;
 %! assert (fftconv (x, x), [1; 2; 3; 2; 1], 5*eps);
 %! assert (fftconv (y, y), [1, 2, 3, 2, 1], 5*eps);
 %! assert (fftconv (x, y), [1, 2, 3, 2, 1], 5*eps);
 %! assert (fftconv (y, x), [1; 2; 3; 2; 1], 5*eps);
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -127,61 +127,61 @@ function y = fftfilt (b, x, n)
     y = y.';
   endif
 
 endfunction
 
 
 %!shared b, x, r
 
-%!test
+%!testif HAVE_FFTW
 %! b = [1 1];
 %! x = [1, zeros(1,9)];
 %! assert (fftfilt (b,  x  ), [1 1 0 0 0 0 0 0 0 0]  );
 %! assert (fftfilt (b,  x.'), [1 1 0 0 0 0 0 0 0 0].');
 %! assert (fftfilt (b.',x  ), [1 1 0 0 0 0 0 0 0 0]  );
 %! assert (fftfilt (b.',x.'), [1 1 0 0 0 0 0 0 0 0].');
 %! assert (fftfilt (b,  [x.' x.']), [1 1 0 0 0 0 0 0 0 0].'*[1 1]);
 %! assert (fftfilt (b,  [x.'+2*eps x.']) == [1 1 0 0 0 0 0 0 0 0].'*[1 1], [false(10, 1) true(10, 1)]);
 
-%!test
+%!testif HAVE_FFTW
 %! r = sqrt (1/2) * (1+i);
 %! b = b*r;
 %! assert (fftfilt (b, x  ), r*[1 1 0 0 0 0 0 0 0 0]  , eps  );
 %! assert (fftfilt (b, r*x), r*r*[1 1 0 0 0 0 0 0 0 0], 2*eps);
 %! assert (fftfilt (b, x.'), r*[1 1 0 0 0 0 0 0 0 0].', eps  );
 
-%!test
+%!testif HAVE_FFTW
 %! b  = [1 1];
 %! x  = zeros (10,3); x(1,1)=-1; x(1,2)=1;
 %! y0 = zeros (10,3); y0(1:2,1)=-1; y0(1:2,2)=1;
 %! y  = fftfilt (b, x);
 %! assert (y0, y);
 %! y  = fftfilt (b*i, x);
 %! assert (y0*i, y);
 %! y  = fftfilt (b, x*i);
 %! assert (y0*i, y);
 %! y  = fftfilt (b*i, x*i);
 %! assert (-y0, y);
 %! x  = rand (10, 1);
 %! y  = fftfilt (b, [x x*i]);
 %! assert (true, isreal (y(:,1)));
 %! assert (false, any (real (y(:,2))));
 
-%!test
+%!testif HAVE_FFTW
 %! b  = rand (10, 1);
 %! x  = rand (10, 1);
 %! y0 = filter (b, 1, x);
 %! y  = fftfilt (b, x);
 %! assert (y0, y, 16*eps);
 %! y0 = filter (b*i, 1, x*i);
 %! y  = fftfilt (b*i, x*i);
 %! assert (y0, y, 16*eps);
 
-%!test
+%!testif HAVE_FFTW
 %! b  = rand (10, 1) + i*rand (10, 1);
 %! x  = rand (10, 1) + i*rand (10, 1);
 %! y0 = filter (b, 1, x);
 %! y  = fftfilt (b, x);
 %! assert (y0, y, 55*eps);
 
 ## Test input validation
 %!error fftfilt (1)
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -196,34 +196,34 @@ function [h_r, f_r] = freqz (b, a, n, re
     ## Return values and don't plot.
     h_r = h;
     f_r = f;
   endif
 
 endfunction
 
 
-%!test # correct values and fft-polyval consistency
+%!testif HAVE_FFTW # correct values and fft-polyval consistency
 %! ## butterworth filter, order 2, cutoff pi/2 radians
 %! b = [0.292893218813452  0.585786437626905  0.292893218813452];
 %! a = [1  0  0.171572875253810];
 %! [h,w] = freqz (b,a,32);
 %! assert (h(1),1,10*eps);
 %! assert (abs (h(17)).^2,0.5,10*eps);
 %! assert (h,freqz (b,a,w),10*eps);  # fft should be consistent with polyval
 
-%!test # whole-half consistency
+%!testif HAVE_FFTW # whole-half consistency
 %! b = [1 1 1]/3; # 3-sample average
 %! [h,w] = freqz (b,1,32,"whole");
 %! assert (h(2:16),conj (h(32:-1:18)),20*eps);
 %! [h2,w2] = freqz (b,1,16,"half");
 %! assert (h(1:16),h2,20*eps);
 %! assert (w(1:16),w2,20*eps);
 
-%!test # Sampling frequency properly interpreted
+%!testif HAVE_FFTW # Sampling frequency properly interpreted
 %! b = [1 1 1]/3; a = [1 0.2];
 %! [h,f] = freqz (b,a,16,320);
 %! assert (f,[0:15]'*10,10*eps);
 %! [h2,f2] = freqz (b,a,[0:15]*10,320);
 %! assert (f2,[0:15]*10,10*eps);
 %! assert (h,h2.',20*eps);
 %! [h3,f3] = freqz (b,a,32,"whole",320);
 %! assert (f3,[0:31]'*10,10*eps);
