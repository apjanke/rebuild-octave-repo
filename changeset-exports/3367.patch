# HG changeset patch
# User jwe
# Date 943109562 0
#      Sat Nov 20 14:52:42 1999 +0000
# Node ID 0748b03c351093eaa34099e1ca740ac7fac176a5
# Parent  abdd5ed1bb4eb71d2f415b1a4eece8d3e1712b83
[project @ 1999-11-20 14:52:38 by jwe]

diff --git a/doc/interpreter/signal.txi b/doc/interpreter/signal.txi
--- a/doc/interpreter/signal.txi
+++ b/doc/interpreter/signal.txi
@@ -4,220 +4,27 @@
 
 @node Signal Processing, Image Processing, Control Theory, Top
 @chapter Signal Processing
 
 I hope that someday Octave will include more signal processing
 functions.  If you would like to help improve Octave in this area,
 please contact @email{bug-octave@@bevo.che.wisc.edu}.
 
-@deftypefn {Function File} {} detrend (@var{x}, @var{p})
-If @var{x} is a vector, @code{detrend (@var{x}, @var{p})} removes the
-best fit of a polynomial of order @var{p} from the data @var{x}.
-
-If @var{x} is a matrix, @code{detrend (@var{x}, @var{p})} does the same
-for each column in @var{x}.
-
-The second argument is optional.  If it is not specified, a value of 1
-is assumed.  This corresponds to removing a linear trend.
-@end deftypefn
-
-@deftypefn {Function} {} fft (@var{a}, @var{n})
-Compute the FFT of @var{a} using subroutines from @sc{Fftpack}.  If @var{a}
-is a matrix, @code{fft} computes the FFT for each column of @var{a}.
+@DOCSTRING(detrend)
 
-If called with two arguments, @var{n} is expected to be an integer
-specifying the number of elements of @var{a} to use.  If @var{a} is a
-matrix, @var{n} specifies the number of rows of @var{a} to use.  If
-@var{n} is larger than the size of @var{a}, @var{a} is resized and
-padded with zeros.
-@end deftypefn
-
-@deftypefn {Loadable Function} {} ifft (@var{a}, @var{n})
-Compute the inverse FFT of @var{a} using subroutines from @sc{Fftpack}.  If
-@var{a} is a matrix, @code{fft} computes the inverse FFT for each column
-of @var{a}.
-
-If called with two arguments, @var{n} is expected to be an integer
-specifying the number of elements of @var{a} to use.  If @var{a} is a
-matrix, @var{n} specifies the number of rows of @var{a} to use.  If
-@var{n} is larger than the size of @var{a}, @var{a} is resized and
-padded with zeros.
-@end deftypefn
-
-@deftypefn {Loadable Function} {} fft2 (@var{a}, @var{n}, @var{m})
-Compute the two dimensional FFT of @var{a}.
-
-The optional arguments @var{n} and @var{m} may be used specify the
-number of rows and columns of @var{a} to use.  If either of these is
-larger than the size of @var{a}, @var{a} is resized and padded with
-zeros.
-@end deftypefn
+@DOCSTRING(fft)
 
-@deftypefn {Loadable Function} {} ifft2 (@var{a}, @var{n}, @var{m})
-Compute the two dimensional inverse FFT of @var{a}.
-
-The optional arguments @var{n} and @var{m} may be used specify the
-number of rows and columns of @var{a} to use.  If either of these is
-larger than the size of @var{a}, @var{a} is resized and padded with
-zeros.
-@end deftypefn
-
-@deftypefn {Built-in Function} {} fftconv (@var{a}, @var{b}, @var{n})
-Return the convolution of the vectors @var{a} and @var{b}, as a vector
-with length equal to the @code{length (a) + length (b) - 1}.  If @var{a}
-and @var{b} are the coefficient vectors of two polynomials, the returned
-value is the coefficient vector of the product polynomial.
-
-The computation uses the FFT by calling the function @code{fftfilt}.  If
-the optional argument @var{n} is specified, an N-point FFT is used.
-@end deftypefn
-
-@deftypefn {Function File} {} fftfilt (@var{b}, @var{x}, @var{n})
-
-With two arguments, @code{fftfilt} filters @var{x} with the FIR filter
-@var{b} using the FFT.
+@DOCSTRING(ifft)
 
-Given the optional third argument, @var{n}, @code{fftfilt} uses the
-overlap-add method to filter @var{x} with @var{b} using an N-point FFT.
-@end deftypefn
+@DOCSTRING(fft2)
 
-@deftypefn {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})
-Return the solution to the following linear, time-invariant difference
-equation:
-@iftex
-@tex
-$$
-\sum_{k=0}^N a_{k+1} y_{n-k} = \sum_{k=0}^M b_{k+1} x_{n-k}, \qquad
- 1 \le n \le P
-$$
-@end tex
-@end iftex
-@ifinfo
-
-@smallexample
-   N                   M
-  SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)
-  k=0                 k=0
-@end smallexample
-@end ifinfo
+@DOCSTRING(ifft2)
 
-@noindent
-where
-@ifinfo
- N=length(a)-1 and M=length(b)-1.
-@end ifinfo
-@iftex
-@tex
- $a \in \Re^{N-1}$, $b \in \Re^{M-1}$, and $x \in \Re^P$.
-@end tex
-@end iftex
-An equivalent form of this equation is:
-@iftex
-@tex
-$$
-y_n = -\sum_{k=1}^N c_{k+1} y_{n-k} + \sum_{k=0}^M d_{k+1} x_{n-k}, \qquad
- 1 \le n \le P
-$$
-@end tex
-@end iftex
-@ifinfo
+@DOCSTRING(fftconv)
 
-@smallexample
-            N                   M
-  y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)
-           k=1                 k=0
-@end smallexample
-@end ifinfo
-
-@noindent
-where
-@ifinfo
- c = a/a(1) and d = b/a(1).
-@end ifinfo
-@iftex
-@tex
-$c = a/a_1$ and $d = b/a_1$.
-@end tex
-@end iftex
-
-In terms of the z-transform, y is the result of passing the discrete-
-time signal x through a system characterized by the following rational
-system function:
-@iftex
-@tex
-$$
-H(z) = {\displaystyle\sum_{k=0}^M d_{k+1} z^{-k}
-        \over 1 + \displaystyle\sum_{k+1}^N c_{k+1} z^{-k}}
-$$
-@end tex
-@end iftex
-@ifinfo
+@DOCSTRING(fftfilt)
 
-@example
-             M
-            SUM d(k+1) z^(-k)
-            k=0
-  H(z) = ----------------------
-               N
-          1 + SUM c(k+1) z(-k)
-              k=1
-@end example
-@end ifinfo
-@end deftypefn
-
-@deftypefn {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})
-This is the same as the @code{filter} function described above, except
-that @var{si} is taken as the initial state of the system and the final
-state is returned as @var{sf}.  The state vector is a column vector
-whose length is equal to the length of the longest coefficient vector
-minus one.  If @var{si} is not set, the initial state vector is set to
-all zeros.
-@end deftypefn
-
-@deftypefn {Function File} {[@var{h}, @var{w}] =} freqz (@var{b}, @var{a}, @var{n}, "whole")
-Return the complex frequency response @var{h} of the rational IIR filter
-whose numerator and denominator coefficients are @var{b} and @var{a},
-respectively.  The response is evaluated at @var{n} angular frequencies
-between 0 and
-@ifinfo
- 2*pi.
-@end ifinfo
-@iftex
-@tex
- $2\pi$.
-@end tex
-@end iftex
+@DOCSTRING(filter)
 
-@noindent
-The output value @var{w} is a vector of the frequencies.
-
-If the fourth argument is omitted, the response is evaluated at
-frequencies between 0 and
-@ifinfo
- pi.
-@end ifinfo
-@iftex
-@tex
- $\pi$.
-@end tex
-@end iftex
-
-If @var{n} is omitted, a value of 512 is assumed.
+@DOCSTRING(freqz)
 
-If @var{a} is omitted, the denominator is assumed to be 1 (this
-corresponds to a simple FIR filter).
-
-For fastest computation, @var{n} should factor into a small number of
-small primes.
-@end deftypefn
-
-@deftypefn {Function File} {} sinc (@var{x})
-Return
-@iftex
-@tex
-$ \sin (\pi x)/(\pi x)$.
-@end tex
-@end iftex
-@ifinfo
- sin(pi*x)/(pi*x).
-@end ifinfo
-@end deftypefn
+@DOCSTRING(sinc)
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -4,137 +4,23 @@
 
 @node Statistics, Sets, Optimization, Top
 @chapter Statistics
 
 I hope that someday Octave will include more statistics functions.  If
 you would like to help improve Octave in this area, please contact
 @email{bug-octave@@bevo.che.wisc.edu}.
 
-@deftypefn {Function File} {} mean (@var{x})
-If @var{x} is a vector, compute the mean of the elements of @var{x}
-@iftex
-@tex
-$$ {\rm mean}(x) = \bar{x} = {1\over N} \sum_{i=1}^N x_i $$
-@end tex
-@end iftex
-@ifinfo
+@DOCSTRING(mean)
 
-@example
-mean (x) = SUM_i x(i) / N
-@end example
-@end ifinfo
-If @var{x} is a matrix, compute the mean for each column and return them
-in a row vector.
-@end deftypefn
-
-@deftypefn {Function File} {} median (@var{x})
-If @var{x} is a vector, compute the median value of the elements of
-@var{x}.
-@iftex
-@tex
-$$
-{\rm median} (x) =
-  \cases{x(\lceil N/2\rceil), & $N$ odd;\cr
-          (x(N/2)+x(N/2+1))/2, & $N$ even.}
-$$
-@end tex
-@end iftex
-@ifinfo
+@DOCSTRING(median)
 
-@example
-@group
-            x(ceil(N/2)),             N odd
-median(x) = 
-            (x(N/2) + x((N/2)+1))/2,  N even
-@end group
-@end example
-@end ifinfo
-If @var{x} is a matrix, compute the median value for each
-column and return them in a row vector.
-@end deftypefn
+@DOCSTRING(std)
 
-@deftypefn {Function File} {} std (@var{x})
-If @var{x} is a vector, compute the standard deviation of the elements
-of @var{x}.
-@iftex
-@tex
-$$
-{\rm std} (x) = \sigma (x) = \sqrt{{\sum_{i=1}^N (x_i - \bar{x}) \over N - 1}}
-$$
-@end tex
-@end iftex
-@ifinfo
-
-@example
-@group
-std (x) = sqrt (sumsq (x - mean (x)) / (n - 1))
-@end group
-@end example
-@end ifinfo
-If @var{x} is a matrix, compute the standard deviation for
-each column and return them in a row vector.
-@end deftypefn
+@DOCSTRING(cov)
 
-@deftypefn {Function File} {} cov (@var{x}, @var{y})
-If each row of @var{x} and @var{y} is an observation and each column is
-a variable, the (@var{i},@var{j})-th entry of
-@code{cov (@var{x}, @var{y})} is the covariance between the @var{i}-th
-variable in @var{x} and the @var{j}-th variable in @var{y}.  If called
-with one argument, compute @code{cov (@var{x}, @var{x})}.
-@end deftypefn
-
-@deftypefn {Function File} {} corrcoef (@var{x}, @var{y})
-If each row of @var{x} and @var{y} is an observation and each column is
-a variable, the (@var{i},@var{j})-th entry of
-@code{corrcoef (@var{x}, @var{y})} is the correlation between the
-@var{i}-th variable in @var{x} and the @var{j}-th variable in @var{y}.
-If called with one argument, compute @code{corrcoef (@var{x}, @var{x})}.
-@end deftypefn
+@DOCSTRING(corrcoef)
 
-@deftypefn {Function File} {} kurtosis (@var{x})
-If @var{x} is a vector of length @var{N}, return the kurtosis
-@iftex
-@tex
-$$
- {\rm kurtosis} (x) = {1\over N \sigma(x)^4} \sum_{i=1}^N (x_i-\bar{x})^4 - 3
-$$
-@end tex
-@end iftex
-@ifinfo
-
-@example
-kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3
-@end example
-@end ifinfo
+@DOCSTRING(kurtosis)
 
-@noindent
-of @var{x}.  If @var{x} is a matrix, return the row vector containing
-the kurtosis of each column.
-@end deftypefn
-
-@deftypefn {Function File} {} mahalanobis (@var{x}, @var{y})
-Return the Mahalanobis' D-square distance between the multivariate
-samples @var{x} and @var{y}, which must have the same number of
-components (columns), but may have a different number of observations
-(rows).
-@end deftypefn
+@DOCSTRING(mahalanobis)
 
-@deftypefn {Function File} {} skewness (@var{x})
-If @var{x} is a vector of length @var{N}, return the skewness
-@iftex
-@tex
-$$
-{\rm skewness} (x) = {1\over N \sigma(x)^3} \sum_{i=1}^N (x_i-\bar{x})^3
-$$
-@end tex
-@end iftex
-@ifinfo
-
-@example
-skewness (x) = N^(-1) std(x)^(-3) sum ((x - mean(x)).^3)
-@end example
-@end ifinfo
-
-@noindent
-of @var{x}.  If @var{x} is a matrix, return the row vector containing
-the skewness of each column.
-@end deftypefn
+@DOCSTRING(skewness)
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,24 @@
+1999-11-20  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* statistics/base/mean: Texinfoize doc string.
+	* statistics/base/median: Ditto.
+	* statistics/base/std: Ditto.
+	* statistics/base/cov: Ditto.
+	* statistics/base/corrcoef: Ditto.
+	* statistics/base/kurtosis: Ditto.
+	* statistics/base/mahalanobis: Ditto.
+	* statistics/base/skewness: Ditto.
+	* signal/detrend.m: Ditto.
+	* signal/freqz.m: Ditto.
+	* signal/sinc.m: Ditto.
+	* signal/fftconv.m: Ditto.
+	* signal/fftfilt.m: Ditto.
+
 1999-11-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* control/pinv.m: Delete.
 
 	* Makefile.in (DOCSTRINGS): Don't echo $(ALL_M_FILES).
 
 	* strings/blanks.m: Texinfoize doc string.
 	* strings/strcat.m: Ditto.
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -9,25 +9,26 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  detrend (x [, p])
-##
-## If x is a vector, detrend (x, p) removes the best fit of a
-## polynomial of order p from the data x.
-##
-## If x is a matrix, detrend (x, p) does the same for each column.
-##
-## If p is not specified, p = 1 is used, i.e., a linear trend is
-## removed.
+## @deftypefn {Function File} {} detrend (@var{x}, @var{p})
+## If @var{x} is a vector, @code{detrend (@var{x}, @var{p})} removes the
+## best fit of a polynomial of order @var{p} from the data @var{x}.
+## 
+## If @var{x} is a matrix, @code{detrend (@var{x}, @var{p})} does the same
+## for each column in @var{x}.
+## 
+## The second argument is optional.  If it is not specified, a value of 1
+## is assumed.  This corresponds to removing a linear trend.
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 11 October 1994
 ## Adapted-By: jwe
   
 function y = detrend (x, p)
   
   if (nargin == 1)
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -12,25 +12,26 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: fftconv (a, b [, N])
-##
-## c = fftconv (a, b) returns the convolution of the vectors a and b,
-## a vector with length equal to length (a) + length (b) - 1.
-## If a and b are the coefficient vectors of two polynomials, c is
-## the coefficient vector of the product polynomial.
-##
-## The computation uses the FFT by calling fftfilt.  If the optional
-## argument N is specified, an N-point FFT is used.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} fftconv (@var{a}, @var{b}, @var{n})
+## Return the convolution of the vectors @var{a} and @var{b}, as a vector
+## with length equal to the @code{length (a) + length (b) - 1}.  If @var{a}
+## and @var{b} are the coefficient vectors of two polynomials, the returned
+## value is the coefficient vector of the product polynomial.
+## 
+## The computation uses the FFT by calling the function @code{fftfilt}.  If
+## the optional argument @var{n} is specified, an N-point FFT is used.
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
 function c = fftconv (a, b, N)
 
   if (nargin < 2 || nargin > 3)
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -12,24 +12,25 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage:  fftfilt (b, x [, N])
-##
-## y = fftfilt (b, x) filters x with the FIR filter b using the FFT.
-## y = fftfilt (b, x, N) uses the overlap-add method to filter x with
-## b using an N-point FFT.
-##
-## Reference:  Oppenheim & Schafer (1989).  Discrete-time Signal
-## Processing (Chapter 8).  Prentice-Hall.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} fftfilt (@var{b}, @var{x}, @var{n})
+## 
+## With two arguments, @code{fftfilt} filters @var{x} with the FIR filter
+## @var{b} using the FFT.
+## 
+## Given the optional third argument, @var{n}, @code{fftfilt} uses the
+## overlap-add method to filter @var{x} with @var{b} using an N-point FFT.
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
 function y = fftfilt (b, x, N)
 
   ## If N is not specified explicitly, we do not use the overlap-add
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -12,35 +12,55 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## Compute the frequency response of a filter.
-##
-## [h,w] = resp(b)
-##   returns the complex frequency response h of the FIR filter with
-##   coefficients b. The response is evaluated at 512 angular frequencies
-##   between 0 and pi.  w is a vector containing the 512 frequencies.
-##
-## [h,w] = resp(b,a)
-##   returns the complex frequency response of the rational IIR filter
-##   whose numerator has coefficients b and denominator coefficients a.
-##
-## [h,w] = resp(b,a,n)
-##   returns the response evaluated at n angular frequencies.  For fastest
-##   computation n should factor into a small number of small primes.
-##
-## [h,w] = freqz(b,a,n,"whole")
-##   evaluates the response at n frequencies between 0 and 2*pi.
+## -*- texinfo -*-
+## @deftypefn {Function File} {[@var{h}, @var{w}] =} freqz (@var{b}, @var{a}, @var{n}, "whole")
+## Return the complex frequency response @var{h} of the rational IIR filter
+## whose numerator and denominator coefficients are @var{b} and @var{a},
+## respectively.  The response is evaluated at @var{n} angular frequencies
+## between 0 and
+## @ifinfo
+##  2*pi.
+## @end ifinfo
+## @iftex
+## @tex
+##  $2\pi$.
+## @end tex
+## @end iftex
+## 
+## @noindent
+## The output value @var{w} is a vector of the frequencies.
+## 
+## If the fourth argument is omitted, the response is evaluated at
+## frequencies between 0 and
+## @ifinfo
+##  pi.
+## @end ifinfo
+## @iftex
+## @tex
+##  $\pi$.
+## @end tex
+## @end iftex
+## 
+## If @var{n} is omitted, a value of 512 is assumed.
+## 
+## If @var{a} is omitted, the denominator is assumed to be 1 (this
+## corresponds to a simple FIR filter).
+## 
+## For fastest computation, @var{n} should factor into a small number of
+## small primes.
+## @end deftypefn
 
-## Author: jwe
+## Author: jwe ???
 
 function [h, w] = freqz(b,...)
 
   if (nargin == 1)
     ## Response of an FIR filter.
     a = 1;
     n = 512;
     region = "half";
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -12,21 +12,30 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: sinc(x)
-##
-##        Returns sin(pi*x)/(pi*x).
+## -*- texinfo -*-
+## @deftypefn {Function File} {} sinc (@var{x})
+## Return
+## @iftex
+## @tex
+## $ \sin (\pi x)/(\pi x)$.
+## @end tex
+## @end iftex
+## @ifinfo
+##  sin(pi*x)/(pi*x).
+## @end ifinfo
+## @end deftypefn
 
-## Author: jwe
+## Author: jwe ???
 
 function result = sinc (x)
 
   ## We either need to set the do_fortran_indexing variable to "true"
   ## or use reshape to convert the input matrix to a vector, so that
   ## we can use find to determine the elements of x that equal zero.
   ## I prefer reshaping.
 
diff --git a/scripts/statistics/base/corrcoef.m b/scripts/statistics/base/corrcoef.m
--- a/scripts/statistics/base/corrcoef.m
+++ b/scripts/statistics/base/corrcoef.m
@@ -12,23 +12,24 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: corrcoef (x, y)
-##
-## The (i,j)-th entry of corrcoef (x, y) is the correlation between the
-## i-th variable in x and the j-th variable in y.
-## For matrices, each row is an observation and each column a variable;
-## vectors are always observations and may be row or column vectors.
-## corrcoef (x) is corrcoef (x, x).
+## -*- texinfo -*-
+## @deftypefn {Function File} {} corrcoef (@var{x}, @var{y})
+## If each row of @var{x} and @var{y} is an observation and each column is
+## a variable, the (@var{i},@var{j})-th entry of
+## @code{corrcoef (@var{x}, @var{y})} is the correlation between the
+## @var{i}-th variable in @var{x} and the @var{j}-th variable in @var{y}.
+## If called with one argument, compute @code{corrcoef (@var{x}, @var{x})}.
+## @end deftypefn
 
 ## Author: Kurt Hornik <hornik@ci.tuwien.ac.at>
 ## Created: March 1993
 ## Adapted-By: jwe
 
 function retval = corrcoef (x, y)
 
   if (nargin < 1 || nargin > 2)
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -9,25 +9,24 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  cov (x [, y])
-##
-## The (i,j)-th entry of cov (x, y) is the covariance between the i-th
-## variable in x and the j-th variable in y.
-##
-## For matrices, each row is an observation and each column a variable;
-## vectors are always observations and may be row or column vectors.
-##
-## cov (x) is cov (x, x).
+## -*- texinfo -*-
+## @deftypefn {Function File} {} cov (@var{x}, @var{y})
+## If each row of @var{x} and @var{y} is an observation and each column is
+## a variable, the (@var{i},@var{j})-th entry of
+## @code{cov (@var{x}, @var{y})} is the covariance between the @var{i}-th
+## variable in @var{x} and the @var{j}-th variable in @var{y}.  If called
+## with one argument, compute @code{cov (@var{x}, @var{x})}.
+## @end deftypefn
 
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compute covariances
 
 function c = cov (x, y)
 
   if (nargin < 1 || nargin > 2)
     usage ("cov (x [, y])");
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -12,26 +12,37 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: kurtosis (x)
-##
-## If x is a vector of length N, return the kurtosis
-##
-##   kurtosis(x) = N^(-1) std(x)^(-4) SUM_i (x(i)-mean(x))^4 - 3
-##
-## of x.
-##
-## If x is a matrix, return a row vector containing the kurtosis for each
-## column.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} kurtosis (@var{x})
+## If @var{x} is a vector of length @var{N}, return the kurtosis
+## @iftex
+## @tex
+## $$
+##  {\rm kurtosis} (x) = {1\over N \sigma(x)^4} \sum_{i=1}^N (x_i-\bar{x})^4 - 3
+## $$
+## @end tex
+## @end iftex
+## @ifinfo
+## 
+## @example
+## kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3
+## @end example
+## @end ifinfo
+## 
+## @noindent
+## of @var{x}.  If @var{x} is a matrix, return the row vector containing
+## the kurtosis of each column.
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
 
 function retval = kurtosis (x)
 
   if (nargin != 1)
diff --git a/scripts/statistics/base/mahalanobis.m b/scripts/statistics/base/mahalanobis.m
--- a/scripts/statistics/base/mahalanobis.m
+++ b/scripts/statistics/base/mahalanobis.m
@@ -12,21 +12,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: mahalanobis (X, Y)
-##
-## Returns Mahalanobis' D-square distance between the multivariate
-## samples X and Y, which must have the same number of components
-## (columns), but may have a different number of observations (rows).
+## -*- texinfo -*-
+## @deftypefn {Function File} {} mahalanobis (@var{x}, @var{y})
+## Return the Mahalanobis' D-square distance between the multivariate
+## samples @var{x} and @var{y}, which must have the same number of
+## components (columns), but may have a different number of observations
+## (rows).
+## @end deftypefn
 
 ## Author: Friedrich Leisch <leisch@ci.tuwien.ac.at>
 ## Created: July 1993
 ## Adapted-By: jwe
 
 function retval = mahalanobis (X, Y)
 
   if (nargin != 2)
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -9,28 +9,47 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details. 
 ## 
 ## You should have received a copy of the GNU General Public License
 ## along with this file.  If not, write to the Free Software Foundation,
 ## 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-## usage:  mean (x [, opt])
-##
-## For vector arguments, return the mean the values.
-## For matrix arguments, return a row vector containing the mean for
-## each column.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} mean (@var{x}, @var{opt})
+## If @var{x} is a vector, compute the mean of the elements of @var{x}
+## @iftex
+## @tex
+## $$ {\rm mean}(x) = \bar{x} = {1\over N} \sum_{i=1}^N x_i $$
+## @end tex
+## @end iftex
+## @ifinfo
+## 
+## @example
+## mean (x) = SUM_i x(i) / N
+## @end example
+## @end ifinfo
+## If @var{x} is a matrix, compute the mean for each column and return them
+## in a row vector.
 ##
-## With the optional argument opt, the kind of mean computed can be
-## selected.
-## If opt is "a", the (ordinary) arithmetic mean is computed.  This
-## is the default.
-## If opt is "g", the geometric mean is computed.
-## If opt is "h", the harmonic mean is computed.
+## With the optional argument @var{opt}, the kind of mean computed can be
+## selected.  The following options are recognized:
+##
+## @table @code
+## @item "a"
+## Compute the (ordinary) arithmetic mean.  This is the default.
+##
+## @item "g"
+## Computer the geometric mean.
+##
+## @item "h"
+## Compute the harmonic mean.
+## @end table
+## @end deftypefn
   
 ## Author:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Compute arithmetic, geometric, and harmonic mean
 
 function y = mean (x, opt)
 
   if ((nargin < 1) || (nargin > 2))
     usage ("mean (x [, opt])");
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -12,23 +12,43 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: median (a)
-##
-## For vector arguments, return the median of the values.
-##
-## For matrix arguments, return a row vector containing the median for
-## each column.
-##
+## -*- texinfo -*-
+## @deftypefn {Function File} {} median (@var{x})
+## If @var{x} is a vector, compute the median value of the elements of
+## @var{x}.
+## @iftex
+## @tex
+## $$
+## {\rm median} (x) =
+##   \cases{x(\lceil N/2\rceil), & $N$ odd;\cr
+##           (x(N/2)+x(N/2+1))/2, & $N$ even.}
+## $$
+## @end tex
+## @end iftex
+## @ifinfo
+## 
+## @example
+## @group
+##             x(ceil(N/2)),             N odd
+## median(x) = 
+##             (x(N/2) + x((N/2)+1))/2,  N even
+## @end group
+## @end example
+## @end ifinfo
+## If @var{x} is a matrix, compute the median value for each
+## column and return them in a row vector.
+## @end deftypefn
+
 ## See also: std, mean
 
 ## Author: jwe
 
 function retval = median (a)
 
   if (nargin != 1)
     usage ("median (a)");
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -12,26 +12,37 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: skewness (x)
-##
-## If x is a vector of length N, return the skewness
-##
-##   skewness (x) = N^(-1) std(x)^(-3) SUM_i (x(i)-mean(x))^3
-##
-## of x.
-##
-## If x is a matrix, return a row vector containing the skewness for each
-## column.
+## -*- texinfo -*-
+## @deftypefn {Function File} {} skewness (@var{x})
+## If @var{x} is a vector of length @var{N}, return the skewness
+## @iftex
+## @tex
+## $$
+## {\rm skewness} (x) = {1\over N \sigma(x)^3} \sum_{i=1}^N (x_i-\bar{x})^3
+## $$
+## @end tex
+## @end iftex
+## @ifinfo
+## 
+## @example
+## skewness (x) = N^(-1) std(x)^(-3) sum ((x - mean(x)).^3)
+## @end example
+## @end ifinfo
+## 
+## @noindent
+## of @var{x}.  If @var{x} is a matrix, return the row vector containing
+## the skewness of each column.
+## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
 
 function retval = skewness (x)
 
   if (nargin != 1)
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -12,22 +12,39 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: std (a)
-##
-## For vector arguments, std returns the standard deviation of the
-## values.  For matrix arguments, std returns a row vector containing
-## the standard deviation for each column.
-##
+## -*- texinfo -*-
+## @deftypefn {Function File} {} std (@var{x})
+## If @var{x} is a vector, compute the standard deviation of the elements
+## of @var{x}.
+## @iftex
+## @tex
+## $$
+## {\rm std} (x) = \sigma (x) = \sqrt{{\sum_{i=1}^N (x_i - \bar{x}) \over N - 1}}
+## $$
+## @end tex
+## @end iftex
+## @ifinfo
+## 
+## @example
+## @group
+## std (x) = sqrt (sumsq (x - mean (x)) / (n - 1))
+## @end group
+## @end example
+## @end ifinfo
+## If @var{x} is a matrix, compute the standard deviation for
+## each column and return them in a row vector.
+## @end deftypefn
+
 ## See also: mean, median
 
 ## Author: jwe
 
 function retval = std (a)
 
   if (nargin != 1)
     usage ("std (a)");
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,18 @@
+1999-11-20  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* DLD-FUNCTIONS/fft.cc: Texinfoize doc string.
+	* DLD-FUNCTIONS/ifft.cc: Ditto.
+	* DLD-FUNCTIONS/fft2.cc: Ditto.
+	* DLD-FUNCTIONS/ifft2.cc: Ditto.
+	* DLD-FUNCTIONS/filter.cc: Ditto.
+
+	* Makefile.in (parse.cc): Expect 11 shift/reduce conflicts now.
+
 1999-11-19  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* parse.y (Vwarn_assign_as_truth_value,	Vwarn_variable_switch_label):
 	Texinfoize doc strings.
 
 	* DLD-FUNCTIONS/pinv.cc (Fpinv): Texinfoize doc string.
 
 	* defun-int.h (DEFUN_DLD_INTERNAL): New macro.
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -30,17 +30,27 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
 DEFUN_DLD (fft, args, ,
-  "fft (X [, N]): fast fourier transform of a vector")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} fft (@var{a}, @var{n})\n\
+Compute the FFT of @var{a} using subroutines from @sc{Fftpack}.  If @var{a}\n\
+is a matrix, @code{fft} computes the FFT for each column of @var{a}.\n\
+\n\
+If called with two arguments, @var{n} is expected to be an integer\n\
+specifying the number of elements of @var{a} to use.  If @var{a} is a\n\
+matrix, @var{n} specifies the number of rows of @var{a} to use.  If\n\
+@var{n} is larger than the size of @var{a}, @var{a} is resized and\n\
+padded with zeros.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("fft");
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -30,19 +30,25 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Fifft2.
 
 DEFUN_DLD (fft2, args, ,
-  "fft2 (X [, N] [, M])\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} fft2 (@var{a}, @var{n}, @var{m})\n\
+Compute the two dimensional FFT of @var{a}.\n\
 \n\
-two dimensional fast fourier transform of a vector")
+The optional arguments @var{n} and @var{m} may be used specify the\n\
+number of rows and columns of @var{a} to use.  If either of these is\n\
+larger than the size of @var{a}, @var{a} is resized and padded with\n\
+zeros.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
       print_usage ("fft2");
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -147,32 +147,108 @@ filter (MArray<T>& b, MArray<T>& a, MArr
   int si_len = (a_len > b_len ? a_len : b_len) - 1;
 
   MArray<T> si (si_len, T (0.0));
 
   return filter (b, a, x, si);
 }
 
 DEFUN_DLD (filter, args, nargout,
-  "usage: [y [, sf]] = filter (b, a, x [, si])\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
+@deftypefnx {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
+Return the solution to the following linear, time-invariant difference\n\
+equation:\n\
+@iftex\n\
+@tex\n\
+$$\n\
+\\sum_{k=0}^N a_{k+1} y_{n-k} = \\sum_{k=0}^M b_{k+1} x_{n-k}, \\qquad\n\
+ 1 \\le n \\le P\n\
+$$\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
 \n\
-y = filter (b, a, x) returns the solution to the following linear,\n\
-time-invariant difference equation:\n\
+@smallexample\n\
+   N                   M\n\
+  SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)\n\
+  k=0                 k=0\n\
+@end smallexample\n\
+@end ifinfo\n\
 \n\
-  a[1] y[n] + ... + a[la] y[n-la+1] = b[1] x[n] + ... + b[lb] x[n-lb+1],\n\
-where la = length (a) and lb = length (b).\n\
+@noindent\n\
+where\n\
+@ifinfo\n\
+ N=length(a)-1 and M=length(b)-1.\n\
+@end ifinfo\n\
+@iftex\n\
+@tex\n\
+ $a \\in \\Re^{N-1}$, $b \\in \\Re^{M-1}$, and $x \\in \\Re^P$.\n\
+@end tex\n\
+@end iftex\n\
+An equivalent form of this equation is:\n\
+@iftex\n\
+@tex\n\
+$$\n\
+y_n = -\\sum_{k=1}^N c_{k+1} y_{n-k} + \\sum_{k=0}^M d_{k+1} x_{n-k}, \\qquad\n\
+ 1 \\le n \\le P\n\
+$$\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
 \n\
-[y, sf] = filter (b, a, x, si) sets the initial state of the system, si,\n\
-and returns the final state, sf.  The state vector is a column vector\n\
-whose length is equal to the length of the longest coefficient vector\n\
-minus one.  If si is not set, the initial state vector is set to all\n\
+@smallexample\n\
+            N                   M\n\
+  y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)\n\
+           k=1                 k=0\n\
+@end smallexample\n\
+@end ifinfo\n\
+\n\
+@noindent\n\
+where\n\
+@ifinfo\n\
+ c = a/a(1) and d = b/a(1).\n\
+@end ifinfo\n\
+@iftex\n\
+@tex\n\
+$c = a/a_1$ and $d = b/a_1$.\n\
+@end tex\n\
+@end iftex\n\
+\n\
+If the fourth argument @var{si} is provided, it is taken as the\n\
+initial state of the system and the final state is returned as\n\
+@var{sf}.  The state vector is a column vector whose length is\n\
+equal to the length of the longest coefficient vector minus one.\n\
+If @var{si} is not supplied, the initial state vector is set to all\n\
 zeros.\n\
 \n\
-The particular algorithm employed is known as a transposed Direct Form II\n\
-implementation.")
+In terms of the z-transform, y is the result of passing the discrete-\n\
+time signal x through a system characterized by the following rational\n\
+system function:\n\
+@iftex\n\
+@tex\n\
+$$\n\
+H(z) = {\\displaystyle\\sum_{k=0}^M d_{k+1} z^{-k}\n\
+        \\over 1 + \\displaystyle\\sum_{k+1}^N c_{k+1} z^{-k}}\n\
+$$\n\
+@end tex\n\
+@end iftex\n\
+@ifinfo\n\
+\n\
+@example\n\
+             M\n\
+            SUM d(k+1) z^(-k)\n\
+            k=0\n\
+  H(z) = ----------------------\n\
+               N\n\
+          1 + SUM c(k+1) z(-k)\n\
+              k=1\n\
+@end example\n\
+@end ifinfo\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin  = args.length ();
 
   if (nargin < 3 || nargin > 4)
     {
       print_usage ("filter");
diff --git a/src/DLD-FUNCTIONS/ifft.cc b/src/DLD-FUNCTIONS/ifft.cc
--- a/src/DLD-FUNCTIONS/ifft.cc
+++ b/src/DLD-FUNCTIONS/ifft.cc
@@ -30,17 +30,28 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Ffft.
 
 DEFUN_DLD (ifft, args, ,
-  "ifft (X [, N]): inverse fast fourier transform of a vector")
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} ifft (@var{a}, @var{n})\n\
+Compute the inverse FFT of @var{a} using subroutines from @sc{Fftpack}.  If\n\
+@var{a} is a matrix, @code{fft} computes the inverse FFT for each column\n\
+of @var{a}.\n\
+\n\
+If called with two arguments, @var{n} is expected to be an integer\n\
+specifying the number of elements of @var{a} to use.  If @var{a} is a\n\
+matrix, @var{n} specifies the number of rows of @var{a} to use.  If\n\
+@var{n} is larger than the size of @var{a}, @var{a} is resized and\n\
+padded with zeros.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ("ifft");
diff --git a/src/DLD-FUNCTIONS/ifft2.cc b/src/DLD-FUNCTIONS/ifft2.cc
--- a/src/DLD-FUNCTIONS/ifft2.cc
+++ b/src/DLD-FUNCTIONS/ifft2.cc
@@ -30,19 +30,25 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Ffft2.
 
 DEFUN_DLD (ifft2, args, ,
-  "ifft2 (X [, N] [, M])\n\
+  "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {} ifft2 (@var{a}, @var{n}, @var{m})\n\
+Compute the two dimensional inverse FFT of @var{a}.\n\
 \n\
-two dimensional inverse fast fourier transform of a vector") 
+The optional arguments @var{n} and @var{m} may be used specify the\n\
+number of rows and columns of @var{a} to use.  If either of these is\n\
+larger than the size of @var{a}, @var{a} is resized and padded with\n\
+zeros.\n\
+@end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
       print_usage ("ifft2");
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -432,17 +432,17 @@ bin-dist:
 	if [ -n "$(BINDISTLIBS)" ]; then \
 	  echo $(BINDISTLIBS) >> ../`cat ../.fname`/LIBRARIES; \
 	fi
 .PHONY: bin-dist
 
 # Special rules -- these files need special things to be defined.
 
 parse.cc : parse.y
-	@echo "expect 10 shift/reduce conflicts"
+	@echo "expect 11 shift/reduce conflicts"
 	$(YACC) $(YFLAGS) $<
 	@$(top_srcdir)/move-if-change y.tab.c $(@F)
 
 lex.cc : lex.l
 	$(LEX) $(LFLAGS) $< > $(@F)
 
 defaults.h: defaults.h.in ../Makeconf Makefile
 	@$(do-subst-default-vals)
