# HG changeset patch
# User jwe
# Date 1058296700 0
#      Tue Jul 15 19:18:20 2003 +0000
# Node ID efb6301dae80c65bcfc13b9fd4a6e0d8f78023c4
# Parent  78046131cc1654e012b17da7ed3582e823f1d555
[project @ 2003-07-15 19:18:20 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,10 +1,12 @@
 2003-07-15  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* io/printf.m, io/puts.m: Delete.
+
 	* miscellaneous/dump_prefs.m: Delete define_all_return_values and
 	default_return_value from the list.
 	Add warn_undefined_return_values to the list.
 	
 
 2003-07-13  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* miscellaneous/dump_prefs.m: Delete default_global_variable_value
diff --git a/scripts/io/printf.m b/scripts/io/printf.m
deleted file mode 100644
--- a/scripts/io/printf.m
+++ /dev/null
@@ -1,40 +0,0 @@
-## Copyright (C) 1996, 1997 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 2, or (at your option)
-## any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
-## 02111-1307, USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} printf (@var{template}, @dots{})
-## The @code{printf} function prints the optional arguments under the
-## control of the template string @var{template} to the stream
-## @code{stdout}.
-## @end deftypefn
-## @seealso{fprintf and sprintf}
-
-## Author: jwe
-
-function retval = printf (fmt, varargin)
-
-  retval = -1;
-
-  if (nargin > 0)
-    retval = fprintf (stdout, fmt, varargin{:});
-  else
-    usage ("printf (fmt, ...)");
-  endif
-
-endfunction
diff --git a/scripts/io/puts.m b/scripts/io/puts.m
deleted file mode 100644
--- a/scripts/io/puts.m
+++ /dev/null
@@ -1,38 +0,0 @@
-## Copyright (C) 1996, 1997 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 2, or (at your option)
-## any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, write to the Free
-## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
-## 02111-1307, USA.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {} puts (@var{string})
-## Write a string to the standard output with no formatting.
-## @end deftypefn
-## @seealso{fputs, printf and fprintf}
-
-## Author: jwe
-
-function retval = puts (s)
-
-  retval = -1;
-
-  if (nargin == 1)
-    retval = fputs (stdout, s);
-  else
-    usage ("puts (string)");
-  endif
-
-endfunction
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,31 @@
 2003-07-15  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* oct-stream.cc (get_size, octave_base_stream::error,
+	octave_base_stream::do_gets, octave_base_stream::getl,
+	octave_base_stream::gets, octave_base_stream::do_scanf,
+	octave_base_stream::scanf, octave_base_stream::do_oscanf,
+	octave_base_stream::oscanf, do_printf_conv,
+	octave_base_stream::do_printf, octave_base_stream::printf,
+	octave_base_stream::puts, octave_base_stream::invalid_operation,
+	octave_stream::getl, octave_stream::gets, octave_stream::scanf,
+	octave_stream::oscanf, octave_stream::printf, octave_stream::puts,
+	octave_stream::invalid_stream_error): Handle name of calling
+	function for error messages as a std::string object.  Change all
+	callers.
+
+	* file-io.cc (Fprintf, Fputs): New functions, so we can get
+	function prefixes on error messages right.
+	(Ffgetl, Ffgets, Ffprintf, Fsprintf, Fputs, Ffscanf, Fsscanf):
+	Pass name of calling function to octave_stream method.
+
+	* oct-stream.h (octave_base_stream::do_char_scanf,
+	octave_base_stream::do_real_scanf): Delete unused decls.
+
 	* load-save.cc (read_mat5_binary_element): Correctly read struct
 	arrays.
 
 	* pt-misc.cc (tree_parameter_list::initialize_undefined_elements):
 	New args, warnfor and nargout.  Change all callers.
 	(symbols_of_pt_misc): New function.
 	(warn_undefined_return_values): New function.
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -68,28 +68,31 @@ Software Foundation, 59 Temple Place - S
 #include "sysdep.h"
 #include "utils.h"
 #include "variables.h"
 
 static octave_value stdin_file;
 static octave_value stdout_file;
 static octave_value stderr_file;
 
+static octave_stream stdin_stream;
+static octave_stream stdout_stream;
+static octave_stream stderr_stream;
+
 void
 initialize_file_io (void)
 {
-  octave_stream stdin_stream = octave_istream::create (&std::cin, "stdin");
+  stdin_stream = octave_istream::create (&std::cin, "stdin");
 
   // This uses octave_stdout (see pager.h), not std::cout so that Octave's
   // standard output stream will pass through the pager.
 
-  octave_stream stdout_stream
-    = octave_ostream::create (&octave_stdout, "stdout");
+  stdout_stream = octave_ostream::create (&octave_stdout, "stdout");
 
-  octave_stream stderr_stream = octave_ostream::create (&std::cerr, "stderr");
+  stderr_stream = octave_ostream::create (&std::cerr, "stderr");
 
   stdin_file = octave_stream_list::insert (stdin_stream);
   stdout_file = octave_stream_list::insert (stdout_stream);
   stderr_file = octave_stream_list::insert (stderr_stream);
 }
 
 void
 close_files (void)
@@ -222,45 +225,47 @@ or @var{len} characters have been read. 
 the possible trailing newline, are returned as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgetl} reads until the next newline\n\
 character.\n\
 \n\
 If there are no more characters to read, @code{fgetl} returns @minus{}1.\n\
 @end deftypefn")
 {
+  static std::string who = "fgetl";
+
   octave_value_list retval;
 
   retval(1) = 0;
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      octave_stream os = octave_stream_list::lookup (args(0), "fgetl");
+      octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
 	{
 	  octave_value len_arg = (nargin == 2)
 	    ? args(1) : octave_value (INT_MAX);
 
 	  bool err = false;
 
-	  std::string tmp = os.getl (len_arg, err);
+	  std::string tmp = os.getl (len_arg, err, who);
 
 	  if (! err)
 	    {
 	      retval(1) = tmp.length ();
 	      retval(0) = tmp;
 	    }
 	}
     }
   else
-    print_usage ("fgetl");
+    print_usage (who);
 
   return retval;
 }
 
 DEFUN (fgets, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fgets (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
@@ -268,45 +273,47 @@ or @var{len} characters have been read. 
 the possible trailing newline, are returned as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgets} reads until the next newline\n\
 character.\n\
 \n\
 If there are no more characters to read, @code{fgets} returns @minus{}1.\n\
 @end deftypefn")
 {
+  static std::string who = "fgets";
+
   octave_value_list retval;
 
   retval(1) = 0.0;
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      octave_stream os = octave_stream_list::lookup (args(0), "fgets");
+      octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
 	{
 	  octave_value len_arg = (nargin == 2)
 	    ? args(1) : octave_value (INT_MAX);
 
 	  bool err = false;
 
-	  std::string tmp = os.gets (len_arg, err);
+	  std::string tmp = os.gets (len_arg, err, who);
 
 	  if (! err)
 	    {
 	      retval(1) = tmp.length ();
 	      retval(0) = tmp;
 	    }
 	}
     }
   else
-    print_usage ("fgets");
+    print_usage (who);
 
   return retval;
 }
 
 static octave_stream
 do_stream_open (const std::string& name, const std::string& mode,
 		const std::string& arch, int& fid)
 {
@@ -636,106 +643,174 @@ from the beginning of the file @var{fid}
 
 DEFUN (fprintf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
 This function is just like @code{printf}, except that the output is\n\
 written to the stream @var{fid} instead of @code{stdout}.\n\
 @end deftypefn")
 {
+  static std::string who = "fprintf";
+
   octave_value retval = -1;
+
   bool return_char_count = true;
 
   int nargin = args.length ();
 
   if (nargin > 1 || (nargin > 0 && args(0).is_string ()))
     {
       octave_stream os;
       int fmt_n = 0;
 
       if (args(0).is_string ()) 
 	{
-	  os = octave_stream_list::lookup (1, "fprintf");
+	  os = octave_stream_list::lookup (1, who);
 
 	  // For compatibility with Matlab, which does not return the
 	  // character count when behaving like printf (no file id
 	  // parameter).
 
 	  return_char_count = (nargout != 0);
 	}
       else
 	{
 	  fmt_n = 1;
-	  os = octave_stream_list::lookup (args(0), "fprintf");
+	  os = octave_stream_list::lookup (args(0), who);
 	}
 
       if (! error_state)
 	{
+	  std::string who;
+
 	  if (args(fmt_n).is_string ())
 	    {
 	      std::string fmt = args(fmt_n).string_value ();
 
 	      octave_value_list tmp_args;
 
 	      if (nargin > 1 + fmt_n)
 		{
 		  tmp_args.resize (nargin-fmt_n-1, octave_value ());
 
 		  for (int i = fmt_n + 1; i < nargin; i++)
 		    tmp_args(i-fmt_n-1) = args(i);
 		}
 
-	      retval = os.printf (fmt, tmp_args);
+	      retval = os.printf (fmt, tmp_args, who);
 	    }
 	  else
-	    ::error ("fprintf: format must be a string");
+	    ::error ("%s: format must be a string", who.c_str ());
 	}
     }
   else
-    print_usage ("fprintf");
+    print_usage (who);
 
   if (return_char_count)
     return retval;
   else
     return octave_value();
 }
 
+DEFUN (printf, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} printf (@var{fid}, @var{template}, @dots{})\n\
+Print optional arguments under the control of the template string\n\
+@var{template} to the stream @code{stdout}.\n\
+@end deftypefn\n\
+@seealso{fprintf and sprintf}")
+{
+  static std::string who = "printf";
+
+  octave_value retval = -1;
+
+  int nargin = args.length ();
+
+  if (nargin > 0)
+    {
+      if (args(0).is_string ())
+	{
+	  std::string fmt = args(0).string_value ();
+
+	  octave_value_list tmp_args;
+
+	  if (nargin > 1)
+	    {
+	      tmp_args.resize (nargin-1, octave_value ());
+
+	      for (int i = 1; i < nargin; i++)
+		tmp_args(i-1) = args(i);
+	    }
+
+	  retval = stdout_stream.printf (fmt, tmp_args, who);
+	}
+      else
+	::error ("%s: format must be a string", who.c_str ());
+    }
+  else
+    print_usage (who);
+
+  return retval;
+}
+
 DEFUN (fputs, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fputs (@var{fid}, @var{string})\n\
 Write a string to a file with no formatting.\n\
 @end deftypefn")
 {
+  static std::string who = "fputs";
+
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      octave_stream os = octave_stream_list::lookup (args(0), "fputs");
+      octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
-	retval = os.puts (args(1));
+	retval = os.puts (args(1), who);
     }
   else
-    print_usage ("fputs");
+    print_usage (who);
+
+  return retval;
+}
+
+DEFUN (puts, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} puts (@var{string})\n\
+Write a string to the standard output with no formatting.\n\
+@end deftypefn")
+{
+  static std::string who = "puts";
+
+  octave_value retval = -1;
+
+  if (args.length () == 1)
+    retval = stdout_stream.puts (args(0), who);
+  else
+    print_usage (who);
 
   return retval;
 }
 
 DEFUN (sprintf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sprintf (@var{template}, @dots{})\n\
 This is like @code{printf}, except that the output is returned as a\n\
 string.  Unlike the C library function, which requires you to provide a\n\
 suitably sized string as an argument, Octave's @code{sprintf} function\n\
 returns the string, automatically sized to hold all of the items\n\
 converted.\n\
 @end deftypefn")
 {
+  static std::string who = "sprintf";
+
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       retval(2) = -1.0;
       retval(1) = "unknown error";
@@ -756,28 +831,28 @@ converted.\n\
 	      if (nargin > 1)
 		{
 		  tmp_args.resize (nargin-1, octave_value ());
 
 		  for (int i = 1; i < nargin; i++)
 		    tmp_args(i-1) = args(i);
 		}
 
-	      retval(2) = os.printf (fmt, tmp_args);
+	      retval(2) = os.printf (fmt, tmp_args, who);
 	      retval(1) = os.error ();
 	      retval(0) = ostr->str ();
 	    }
 	  else
-	    ::error ("sprintf: format must be a string");
+	    ::error ("%s: format must be a string", who.c_str ());
 	}
       else
-	::error ("sprintf: unable to create output buffer");
+	::error ("%s: unable to create output buffer", who.c_str ());
     }
   else
-    print_usage ("sprintf");
+    print_usage (who);
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] = } fscanf (@var{fid}, @var{template}, \"C\")\n\
@@ -815,85 +890,89 @@ The number of items successfully read is
 \n\
 In the second form, read from @var{fid} according to @var{template},\n\
 with each conversion specifier in @var{template} corresponding to a\n\
 single scalar return value.  This form is more `C-like', and also\n\
 compatible with previous versions of Octave.  The number of successful\n\
 conversions is returned in @var{count}\n\
 @end deftypefn")
 {
+  static std::string who = "fscanf";
+
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3 && args(2).is_string ())
     {
-      octave_stream os = octave_stream_list::lookup (args(0), "fscanf");
+      octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
 	{
 	  if (args(1).is_string ())
 	    {
 	      std::string fmt = args(1).string_value ();
 
-	      retval = os.oscanf (fmt);
+	      retval = os.oscanf (fmt, who);
 	    }
 	  else
-	    ::error ("fscanf: format must be a string");
+	    ::error ("%s: format must be a string", who.c_str ());
 	}
     }
   else
     {
       retval (1) = 0.0;
       retval (0) = Matrix ();
 
       if (nargin == 2 || nargin == 3)
 	{
-	  octave_stream os = octave_stream_list::lookup (args(0), "fscanf");
+	  octave_stream os = octave_stream_list::lookup (args(0), who);
 
 	  if (! error_state)
 	    {
 	      if (args(1).is_string ())
 		{
 		  std::string fmt = args(1).string_value ();
 
 		  int count = 0;
 
 		  Array<double> size = (nargin == 3)
 		    ? args(2).vector_value ()
 		    : Array<double> (1, lo_ieee_inf_value ());
 
 		  if (! error_state)
 		    {
-		      octave_value tmp = os.scanf (fmt, size, count);
+		      octave_value tmp = os.scanf (fmt, size, count, who);
 
 		      retval(1) = count;
 		      retval(0) = tmp;
 		    }
 		}
 	      else
-		::error ("fscanf: format must be a string");
+		::error ("%s: format must be a string", who.c_str ());
 	    }
 	}
       else
-	print_usage ("fscanf");
+	print_usage (who);
     }
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] = } sscanf (@var{string}, @var{template}, \"C\")\n\
 This is like @code{fscanf}, except that the characters are taken from the\n\
 string @var{string} instead of from a stream.  Reaching the end of the\n\
 string is treated as an end-of-file condition.\n\
 @end deftypefn")
 {
+  static std::string who = "sscanf";
+
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3 && args(2).is_string ())
     {
       if (args(0).is_string ())
 	{
@@ -902,26 +981,27 @@ string is treated as an end-of-file cond
 	  octave_stream os = octave_istrstream::create (data);
 
 	  if (os.is_valid ())
 	    {
 	      if (args(1).is_string ())
 		{
 		  std::string fmt = args(1).string_value ();
 
-		  retval = os.oscanf (fmt);
+		  retval = os.oscanf (fmt, who);
 		}
 	      else
-		::error ("sscanf: format must be a string");
+		::error ("%s: format must be a string", who.c_str ());
 	    }
 	  else
-	    ::error ("sscanf: unable to create temporary input buffer");
+	    ::error ("%s: unable to create temporary input buffer",
+		     who.c_str ());
 	}
       else
-	::error ("sscanf: first argument must be a string");
+	::error ("%s: first argument must be a string", who.c_str ());
     }
   else
     {
       if (nargin == 2 || nargin == 3)
 	{
 	  retval(3) = -1.0;
 	  retval(2) = "unknown error";
 	  retval(1) = 0.0;
@@ -940,39 +1020,40 @@ string is treated as an end-of-file cond
 		      std::string fmt = args(1).string_value ();
 
 		      int count = 0;
 
 		      Array<double> size = (nargin == 3)
 			? args(2).vector_value ()
 			: Array<double> (1, lo_ieee_inf_value ());
 
-		      octave_value tmp = os.scanf (fmt, size, count);
+		      octave_value tmp = os.scanf (fmt, size, count, who);
 
 		      // XXX FIXME XXX -- is this the right thing to do?
 		      // Extract error message first, because getting
 		      // position will clear it.
 		      std::string errmsg = os.error ();
 
 		      retval(3) = os.tell () + 1;
 		      retval(2) = errmsg;
 		      retval(1) = count;
 		      retval(0) = tmp;
 		    }
 		  else
-		    ::error ("sscanf: format must be a string");
+		    ::error ("%s: format must be a string", who.c_str ());
 		}
 	      else
-		::error ("sscanf: unable to create temporary input buffer");
+		::error ("%s: unable to create temporary input buffer",
+			 who.c_str  ());
 	    }
 	  else
-	    ::error ("sscanf: first argument must be a string");
+	    ::error ("%s: first argument must be a string", who.c_str ());
 	}
       else
-	print_usage ("sscanf");
+	print_usage (who);
     }
 
   return retval;
 }
 
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} scanf (@var{template}, @var{size})\n\
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -76,42 +76,42 @@ convert_to_valid_int (const octave_value
     }
   else
     conv_err = 1;
 
   return retval;
 }
 
 static int
-get_size (double d, const char *warn_for)
+get_size (double d, const std::string& who)
 {
   int retval = -1;
 
   if (! xisnan (d))
     {
       if (! xisinf (d))
 	{
 	  if (d >= 0.0)
 	    retval = NINT (d);
 	  else
 	    ::error ("%s: negative value invalid as size specification",
-		     warn_for);
+		     who.c_str ());
 	}
       else
 	retval = -1;
     }
   else
-    ::error ("%s: NaN is invalid as size specification", warn_for);
+    ::error ("%s: NaN is invalid as size specification", who.c_str ());
 
   return retval;
 }
 
 static void
 get_size (const Array<double>& size, int& nr, int& nc, bool& one_elt_size_spec,
-	  const char *warn_for)
+	  const std::string& who)
 {
   nr = -1;
   nc = -1;
 
   one_elt_size_spec = false;
 
   double dnr = -1.0;
   double dnc = -1.0;
@@ -128,27 +128,27 @@ get_size (const Array<double>& size, int
     }
   else if (sz_len == 2)
     {
       dnr = size (0);
 
       if (! xisinf (dnr))
 	dnc = size (1);
       else
-	::error ("%s: invalid size specification", warn_for);
+	::error ("%s: invalid size specification", who.c_str ());
     }
   else
-    ::error ("%s: invalid size specification", warn_for);
+    ::error ("%s: invalid size specification", who.c_str ());
 
   if (! error_state)
     {
-      nr = get_size (dnr, warn_for);
+      nr = get_size (dnr, who);
 
       if (! error_state && dnc >= 0.0)
-	nc = get_size (dnc, warn_for);
+	nc = get_size (dnc, who);
     }
 }
 
 scanf_format_list::scanf_format_list (const std::string& s)
   : nconv (0), curr_idx (0), list (16), buf (0)
 {
   int num_elts = 0;
 
@@ -921,28 +921,35 @@ octave_base_stream::file_number (void)
 void
 octave_base_stream::error (const std::string& msg)
 {
   fail = true;
   errmsg = msg;
 }
 
 void
+octave_base_stream::error (const std::string& who, const std::string& msg)
+{
+  fail = true;
+  errmsg = who + msg;
+}
+
+void
 octave_base_stream::clear (void)
 {
   fail = false;
   errmsg = "";
 }
 
 // Functions that are defined for all input streams (input streams
 // are those that define is).
 
 std::string
 octave_base_stream::do_gets (int max_len, bool& err,
-			     bool strip_newline, const char *fcn)
+			     bool strip_newline, const std::string& who)
 {
   std::string retval;
 
   err = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
@@ -979,43 +986,42 @@ octave_base_stream::do_gets (int max_len
 	{
 	  buf << OSSTREAM_ENDS;
 	  retval = OSSTREAM_STR (buf);
 	  OSSTREAM_FREEZE (buf);
 	}
       else
 	{
 	  err = true;
-	  std::string msg = fcn;
+
 	  if (is.eof () && char_count == 0)
-	    msg.append (": at end of file");
+	    error (who, "at end of file");
 	  else
-	    msg.append (": read error");
-	  error (msg);
+	    error (who, "read error");
 	}
     }
   else
     {
       err = true;
-      invalid_operation (fcn, "reading");
+      invalid_operation (who, "reading");
     }
 
   return retval;
 }
 
 std::string
-octave_base_stream::getl (int max_len, bool& err)
+octave_base_stream::getl (int max_len, bool& err, const std::string& who)
 {
-  return do_gets (max_len, err, true, "fgetl");
+  return do_gets (max_len, err, true, who);
 }
 
 std::string
-octave_base_stream::gets (int max_len, bool& err)
+octave_base_stream::gets (int max_len, bool& err, const std::string& who)
 {
-  return do_gets (max_len, err, false, "fgets");
+  return do_gets (max_len, err, false, who);
 }
 
 octave_value
 octave_base_stream::read (const Array<double>& size,
 			  oct_data_conv::data_type dt, int skip,
 			  oct_mach_info::float_format ffmt,
 			  int& char_count)
 {
@@ -1368,17 +1374,17 @@ do_scanf_conv (std::istream&, const scan
 	    } \
 	} \
     } \
   while (0)
 
 octave_value
 octave_base_stream::do_scanf (scanf_format_list& fmt_list,
 			      int nr, int nc, bool one_elt_size_spec,
-			      int& conversion_count)
+			      int& conversion_count, const std::string& who)
 {
   conversion_count = 0;
 
   int nconv = fmt_list.num_conversions ();
 
   int data_index = 0;
 
   octave_value retval = Matrix ();
@@ -1631,21 +1637,21 @@ octave_base_stream::do_scanf (scanf_form
 		  {
 		    BEGIN_CHAR_CLASS_CONVERSION ();
 
 		    FINISH_CHARACTER_CONVERSION ();
 		  }
 		  break;
 
 		case 'p':
-		  error ("fscanf: unsupported format specifier");
+		  error ("%s: unsupported format specifier", who.c_str ());
 		  break;
 
 		default:
-		  error ("fscanf: internal format error");
+		  error ("%s: internal format error", who.c_str ());
 		  break;
 		}
 
 	      if (! ok ())
 		{
 		  break;
 		}
 	      else if (! is)
@@ -1697,25 +1703,25 @@ octave_base_stream::do_scanf (scanf_form
 
 		  if (interactive && name () == "stdin")
 		    {
 		      is.clear ();
 
 		      // Skip to end of line.
 
 		      bool err;
-		      do_gets (-1, err, false, "fscanf");
+		      do_gets (-1, err, false, who);
 		    }
 
 		  break;
 		}
 	    }
 	  else
 	    {
-	      error ("fscanf: internal format error");
+	      error ("%s: internal format error", who.c_str ());
 	      break;
 	    }
 
 	  elt = fmt_list.next (nconv > 0);
 	}
     }
 
   if (ok ())
@@ -1728,53 +1734,53 @@ octave_base_stream::do_scanf (scanf_form
 	retval = retval.convert_to_str ();
     }
 
   return retval;
 }
 
 octave_value
 octave_base_stream::scanf (const std::string& fmt, const Array<double>& size,
-			   int& conversion_count)
+			   int& conversion_count, const std::string& who)
 {
   octave_value retval = Matrix ();
 
   conversion_count = 0;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       scanf_format_list fmt_list (fmt);
 
       if (fmt_list.num_conversions () == -1)
-	::error ("fscanf: invalid format specified");
+	::error ("%s: invalid format specified", who.c_str ());
       else
 	{
 	int nr = -1;
 	int nc = -1;
 
 	bool one_elt_size_spec;
 
-	get_size (size, nr, nc, one_elt_size_spec, "fscanf");
+	get_size (size, nr, nc, one_elt_size_spec, who);
 
 	if (! error_state)
 	  retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
-			     conversion_count);
+			     conversion_count, who);
 	}
     }
   else
-    invalid_operation ("fscanf", "reading");
+    invalid_operation (who, "reading");
 
   return retval;
 }
 
 bool
 octave_base_stream::do_oscanf (const scanf_format_elt *elt,
-			       octave_value& retval)
+			       octave_value& retval, const std::string& who)
 {
   bool quit = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       std::istream& is = *isp;
@@ -1883,61 +1889,61 @@ octave_base_stream::do_oscanf (const sca
 		  retval = tmp;
 
 		if (! is)
 		  quit = true;
 	      }
 	      break;
 
 	    case 'p':
-	      error ("fscanf: unsupported format specifier");
+	      error ("%s: unsupported format specifier", who.c_str ());
 	      break;
 
 	    default:
-	      error ("fscanf: internal format error");
+	      error ("%s: internal format error", who.c_str ());
 	      break;
 	    }
 	}
 
       if (ok () && is.fail ())
 	{
-	  error ("fscanf: read error");
+	  error ("%s: read error", who.c_str ());
 
 	  // XXX FIXME XXX -- is this the right thing to do?
 
 	  if (interactive && name () == "stdin")
 	    {
 	      // Skip to end of line.
 
 	      bool err;
-	      do_gets (-1, err, false, "fscanf");
+	      do_gets (-1, err, false, who);
 	    }
 	}
     }
 
   return quit;
 }
 
 octave_value_list
-octave_base_stream::oscanf (const std::string& fmt)
+octave_base_stream::oscanf (const std::string& fmt, const std::string& who)
 {
   octave_value_list retval;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       std::istream& is = *isp;
 
       scanf_format_list fmt_list (fmt);
 
       int nconv = fmt_list.num_conversions ();
 
       if (nconv == -1)
-	::error ("fscanf: invalid format specified");
+	::error ("%s: invalid format specified", who.c_str ());
       else
 	{
 	  is.clear ();
 
 	  int len = fmt_list.length ();
 
 	  retval.resize (nconv+1, Matrix ());
 
@@ -1946,17 +1952,17 @@ octave_base_stream::oscanf (const std::s
 	  int num_values = 0;
 
 	  bool quit = false;
 
 	  for (int i = 0; i < len; i++)
 	    {
 	      octave_value tmp;
 
-	      quit = do_oscanf (elt, tmp);
+	      quit = do_oscanf (elt, tmp, who);
 
 	      if (quit)
 		break;
 	      else
 		{
 		  if (tmp.is_defined ())
 		    retval (num_values++) = tmp;
 
@@ -1973,23 +1979,23 @@ octave_base_stream::oscanf (const std::s
 	    {
 	      // Pick up any trailing stuff.
 	      if (ok () && len > nconv)
 		{
 		  octave_value tmp;
 
 		  elt = fmt_list.next ();
 
-		  do_oscanf (elt, tmp);
+		  do_oscanf (elt, tmp, who);
 		}
 	    }
 	}
     }
   else
-    invalid_operation ("fscanf", "reading");
+    invalid_operation (who, "reading");
 
   return retval;
 }
 
 // Functions that are defined for all output streams (output streams
 // are those that define os).
 
 int
@@ -2208,17 +2214,17 @@ printf_value_cache::string_value (void)
   return retval;
 }
 
 // Ugh again and again.
 
 template <class T>
 int
 do_printf_conv (std::ostream& os, const char *fmt, int nsa, int sa_1,
-		int sa_2, T arg)
+		int sa_2, T arg, const std::string& who)
 {
   int retval = 0;
 
   switch (nsa)
     {
     case 2:
       retval = octave_format (os, fmt, sa_1, sa_2, arg);
       break;
@@ -2227,44 +2233,51 @@ do_printf_conv (std::ostream& os, const 
       retval = octave_format (os, fmt, sa_1, arg);
       break;
 
     case 0:
       retval = octave_format (os, fmt, arg);
       break;
 
     default:
-      ::error ("fprintf: internal error handling format");
+      ::error ("%s: internal error handling format", who.c_str ());
       break;
     }
 
   return retval;
 }
 
 template int
-do_printf_conv (std::ostream&, const char*, int, int, int, int);
-							   
-template int						   
-do_printf_conv (std::ostream&, const char*, int, int, int, long);
-							   
+do_printf_conv (std::ostream&, const char*, int, int, int, int,
+		const std::string&);
+
+template int
+do_printf_conv (std::ostream&, const char*, int, int, int, long,
+		const std::string&);
+
 template int
-do_printf_conv (std::ostream&, const char*, int, int, int, unsigned int);
-							   
-template int						   
-do_printf_conv (std::ostream&, const char*, int, int, int, unsigned long);
-							   
-template int						   
-do_printf_conv (std::ostream&, const char*, int, int, int, double);
-							   
-template int						   
-do_printf_conv (std::ostream&, const char*, int, int, int, const char*);
+do_printf_conv (std::ostream&, const char*, int, int, int, unsigned int,
+		const std::string&);
+
+template int
+do_printf_conv (std::ostream&, const char*, int, int, int, unsigned long,
+		const std::string&);
+
+template int
+do_printf_conv (std::ostream&, const char*, int, int, int, double,
+		const std::string&);
+
+template int
+do_printf_conv (std::ostream&, const char*, int, int, int, const char*,
+		const std::string&);
 
 int
 octave_base_stream::do_printf (printf_format_list& fmt_list,
-			       const octave_value_list& args)
+			       const octave_value_list& args,
+			       const std::string& who)
 {
   int retval = 0;
 
   int nconv = fmt_list.num_conversions ();
 
   std::ostream *osp = output_stream ();
 
   if (osp)
@@ -2319,17 +2332,17 @@ octave_base_stream::do_printf (printf_fo
 		  retval += strlen (elt->text);
 		}	      
 	      else if (elt->type == 's')
 		{
 		  std::string val = val_cache.string_value ();
 
 		  if (val_cache)
 		    retval += do_printf_conv (os, fmt, nsa, sa_1,
-					      sa_2, val.c_str ());
+					      sa_2, val.c_str (), who);
 		  else
 		    break;
 		}
 	      else
 		{
 		  double val = val_cache.double_value ();
 
 		  if (val_cache)
@@ -2349,117 +2362,122 @@ octave_base_stream::do_printf (printf_fo
 			  if (xisnan (val) || xisinf (val))
 			    {
 			      tfmt.replace (tfmt.rfind (elt->type), 1, 1, 's');
 
 			      const char *tval = xisinf (val)
 				? (val < 0 ? "-Inf" : "Inf") : "NaN";
 
 			      retval += do_printf_conv (os, tfmt.c_str (),
-							nsa, sa_1, sa_2, tval);
+							nsa, sa_1, sa_2,
+							tval, who);
 			    }
 			  else
 			    {
 			      tfmt.replace (tfmt.rfind (elt->type), 1, ".f");
 
 			      retval += do_printf_conv (os, tfmt.c_str (),
-							nsa, sa_1, sa_2, val);
+							nsa, sa_1, sa_2,
+							val, who);
 			    }
 			}
 		      else
 			{
 			  switch (elt->type)
 			    {
 			    case 'd': case 'i': case 'c':
 			      {
 				if (elt->modifier == 'l')
 				  retval += do_printf_conv
 				    (os, fmt, nsa, sa_1, sa_2,
-				     static_cast<long int> (val));
+				     static_cast<long int> (val), who);
 				else
 				  retval += do_printf_conv
 				    (os, fmt, nsa, sa_1, sa_2,
-				     static_cast<int> (val));
+				     static_cast<int> (val), who);
 			      }
 			      break;
 
 			    case 'o': case 'x': case 'X': case 'u':
 			      {
 				if (elt->modifier == 'l')
 				  retval += do_printf_conv
 				    (os, fmt, nsa, sa_1, sa_2,
-				     static_cast<unsigned long int> (val));
+				     static_cast<unsigned long int> (val),
+				     who);
 				else
 				  retval += do_printf_conv
 				    (os, fmt, nsa, sa_1, sa_2,
-				     static_cast<unsigned int> (val));
+				     static_cast<unsigned int> (val), who);
 			      }
 			      break;
 
 			    case 'f': case 'e': case 'E':
 			    case 'g': case 'G':
 			      retval
 				+= do_printf_conv (os, fmt, nsa, sa_1, sa_2,
-						   val);
+						   val, who);
 			      break;
 
 			    default:
-			      error ("fprintf: invalid format specifier");
+			      error ("%s: invalid format specifier",
+				     who.c_str ());
 			      return -1;
 			      break;
 			    }
 			}
 		    }
 		  else
 		    break;
 		}
 
 	      if (! os)
 		{
-		  error ("fprintf: write error");
+		  error ("%s: write error", who.c_str ());
 		  break;
 		}
 	    }
 	  else
 	    {
-	      ::error ("fprintf: internal error handling format");
+	      ::error ("%s: internal error handling format", who.c_str ());
 	      retval = -1;
 	      break;
 	    }
 
 	  elt = fmt_list.next (nconv > 0 && ! val_cache.exhausted ());
 
 	  if (! elt || (val_cache.exhausted () && elt->args > 0))
 	    break;
 	}	      
     }
   else
-    invalid_operation ("fprintf", "writing");
+    invalid_operation (who, "writing");
 
   return retval;
 }
 
 int
 octave_base_stream::printf (const std::string& fmt,
-			    const octave_value_list& args)
+			    const octave_value_list& args,
+			    const std::string& who)
 {
   int retval = 0;
 
   printf_format_list fmt_list (fmt);
 
   if (fmt_list.num_conversions () == -1)
-    ::error ("fprintf: invalid format specified");
+    ::error ("%s: invalid format specified", who.c_str ());
   else
-    retval = do_printf (fmt_list, args);
+    retval = do_printf (fmt_list, args, who);
 
   return retval;
 }
 
 int
-octave_base_stream::puts (const std::string& s)
+octave_base_stream::puts (const std::string& s, const std::string& who)
 {
   int retval = -1;
 
   std::ostream *osp = output_stream ();
 
   if (osp)
     {
       std::ostream& os = *osp;
@@ -2475,23 +2493,23 @@ octave_base_stream::puts (const std::str
 	  //
 	  // doesn't seem to go to the pager immediately.
 
 	  os.flush ();
 
 	  if (os)
 	    retval = 0;
 	  else
-	    error ("fputs: write error");
+	    error ("%s: write error", who.c_str ());
 	}
       else
-	error ("fputs: write error");
+	error ("%s: write error", who.c_str ());
     }
   else
-    invalid_operation ("fputs", "writing");
+    invalid_operation (who, "writing");
 
   return retval;
 }
 
 int
 octave_base_stream::rewind (void)
 {
   return seek (0, std::ios::beg);
@@ -2508,22 +2526,21 @@ octave_base_stream::error (bool clear_er
 
   if (clear_err)
     clear ();
 
   return tmp;
 }
 
 void
-octave_base_stream::invalid_operation (const char *op, const char *rw)
+octave_base_stream::invalid_operation (const std::string& who, const char *rw)
 {
-  std::string msg = op;
-  msg.append (": stream not open for ");
-  msg.append (rw);
-  error (msg);
+  // Note that this is not ::error () !
+
+  error (who + ": stream not open for " + rw);
 }
 
 octave_stream::octave_stream (octave_base_stream *bs)
   : rep (bs)
 {
   if (rep)
     rep->count = 1;
 }
@@ -2565,77 +2582,79 @@ octave_stream::flush (void)
 
   if (stream_ok ("fflush"))
     retval = rep->flush ();
 
   return retval;
 }
 
 std::string
-octave_stream::getl (int max_len, bool& err)
+octave_stream::getl (int max_len, bool& err, const std::string& who)
 {
   std::string retval;
 
-  if (stream_ok ("getl"))
-    retval = rep->getl (max_len, err);
+  if (stream_ok (who))
+    retval = rep->getl (max_len, err, who);
 
   return retval;
 }
 
 std::string
-octave_stream::getl (const octave_value& tc_max_len, bool& err)
+octave_stream::getl (const octave_value& tc_max_len, bool& err,
+		     const std::string& who)
 {
   std::string retval;
 
   err = false;
 
   int conv_err = 0;
 
   int max_len = convert_to_valid_int (tc_max_len, conv_err);
 
   if (conv_err || max_len < 0)
     {
       err = true;
-      ::error ("fgetl: invalid maximum length specified");
+      ::error ("%s: invalid maximum length specified", who.c_str ());
     }
   else
-    retval = getl (max_len, err);
+    retval = getl (max_len, err, who);
 
   return retval;
 }
 
 std::string
-octave_stream::gets (int max_len, bool& err)
+octave_stream::gets (int max_len, bool& err, const std::string& who)
 {
   std::string retval;
 
-  if (stream_ok ("fgets"))
-    retval = rep->gets (max_len, err);
+  if (stream_ok (who))
+    retval = rep->gets (max_len, err, who);
 
   return retval;
 }
 
 std::string
-octave_stream::gets (const octave_value& tc_max_len, bool& err)
+octave_stream::gets (const octave_value& tc_max_len, bool& err,
+		     const std::string& who)
 {
   std::string retval;
 
   err = false;
 
   int conv_err = 0;
 
   int max_len = convert_to_valid_int (tc_max_len, conv_err);
 
   if (conv_err || max_len < 0)
     {
       err = true;
-      ::error ("fgets: invalid maximum length specified");
+      ::error ("%s: invalid maximum length specified", who.c_str ());
     }
   else
-    retval = gets (max_len, err);
+    retval = gets (max_len, err, who);
 
   return retval;
 }
 
 int
 octave_stream::seek (std::streamoff offset, std::ios::seekdir origin)
 {
   int retval = -1;
@@ -2764,73 +2783,78 @@ octave_stream::write (const octave_value
   if (stream_ok ("fwrite"))
     retval = rep->write (data, dt, skip, flt_fmt);
 
   return retval;
 }
 
 octave_value
 octave_stream::scanf (const std::string& fmt, const Array<double>& size,
-		      int& count)
+		      int& count, const std::string& who)
 {
   octave_value retval;
 
-  if (stream_ok ("fscanf"))
-    retval = rep->scanf (fmt, size, count);
+  if (stream_ok (who))
+    retval = rep->scanf (fmt, size, count, who);
 
   return retval;
 }
 
 octave_value_list
-octave_stream::oscanf (const std::string& fmt)
+octave_stream::oscanf (const std::string& fmt, const std::string& who)
 {
   octave_value_list retval;
 
-  if (stream_ok ("fscanf"))
-    retval = rep->oscanf (fmt);
+  if (stream_ok (who))
+    retval = rep->oscanf (fmt, who);
 
   return retval;
 }
 
 int
-octave_stream::printf (const std::string& fmt, const octave_value_list& args)
+octave_stream::printf (const std::string& fmt, const octave_value_list& args,
+		       const std::string& who)
 {
   int retval = -1;
 
-  if (stream_ok ("fprintf"))
-    retval = rep->printf (fmt, args);
+  if (stream_ok (who))
+    retval = rep->printf (fmt, args, who);
 
   return retval;
 }
 
 int
-octave_stream::puts (const std::string& s)
+octave_stream::puts (const std::string& s, const std::string& who)
 {
   int retval = -1;
 
-  if (stream_ok ("fputs"))
-    retval = rep->puts (s);
+  if (stream_ok (who))
+    retval = rep->puts (s, who);
 
   return retval;
 }
 
 // XXX FIXME XXX -- maybe this should work for string arrays too.
 
 int
-octave_stream::puts (const octave_value& tc_s)
+octave_stream::puts (const octave_value& tc_s, const std::string& who)
 {
   int retval = -1;
 
   if (tc_s.is_string ())
     {
       std::string s = tc_s.string_value ();      
-      retval = rep->puts (s);
+      retval = rep->puts (s, who);
     }
   else
-    error ("fputs: argument must be a string");
+    {
+      // Note that this is not ::error () !
+
+      error (who + ": argument must be a string");
+    }
 
   return retval;
 }
 
 bool
 octave_stream::eof (void) const
 {
   int retval = -1;
@@ -2919,19 +2943,19 @@ octave_stream::mode_as_string (int mode)
   else if (in_mode == (std::ios::in | std::ios::out | std::ios::ate
 		       | std::ios::binary))
     retval = "a+b";
 
   return retval;
 }
 
 void
-octave_stream::invalid_stream_error (const char *op) const
+octave_stream::invalid_stream_error (const std::string& who) const
 {
-  ::error ("%s: attempt to use invalid I/O stream", op);
+  ::error ("%s: attempt to use invalid I/O stream", who.c_str ());
 }
 
 octave_stream_list *octave_stream_list::instance = 0;
 
 bool
 octave_stream_list::instance_ok (void)
 {
   bool retval = true;
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -387,16 +387,17 @@ protected:
 
   int mode (void) const { return md; }
 
   oct_mach_info::float_format float_format (void) const { return flt_fmt; }
 
   // Set current error state and set fail to TRUE.
 
   void error (const std::string& msg);
+  void error (const std::string& who, const std::string& msg);
 
   // Clear any error message and set fail to FALSE.
 
   void clear (void);
 
 private:
 
   // A reference count.
@@ -417,64 +418,64 @@ private:
 
   // Should contain error message if fail is TRUE.
   std::string errmsg;
 
   // Functions that are defined for all input streams (input streams
   // are those that define is).
 
   std::string do_gets (int max_len, bool& err, bool strip_newline,
-		  const char *fcn);
+		       const std::string& who /* = "gets" */);
 
-  std::string getl (int max_len, bool& err);
-  std::string gets (int max_len, bool& err);
+  std::string getl (int max_len, bool& err, const std::string& who /* = "getl" */);
+  std::string gets (int max_len, bool& err, const std::string& who /* = "gets" */);
 
   octave_value do_read (int nr, int nc, oct_data_conv::data_type dt,
 			int skip, oct_mach_info::float_format flt_fmt,
 			int& count);
 
   octave_value read (const Array<double>& size, oct_data_conv::data_type dt,
 		     int skip, oct_mach_info::float_format flt_fmt,
 		     int& count);
 
-  octave_value do_char_scanf (scanf_format_list& fmt_list,
-			      int nr, int nc, int& count);
-
-  octave_value do_real_scanf (scanf_format_list& fmt_list,
-			      int nr, int nc, int& count);
+  octave_value do_scanf (scanf_format_list& fmt_list, int nr, int nc,
+			 bool one_elt_size_spec, int& count,
+			 const std::string& who /* = "scanf" */);
 
-  octave_value do_scanf (scanf_format_list& fmt_list, int nr, int nc,
-			 bool one_elt_size_spec, int& count);
+  octave_value scanf (const std::string& fmt, const Array<double>& size,
+		      int& count, const std::string& who /* = "scanf" */);
 
-  octave_value scanf (const std::string& fmt, const Array<double>& size, int& count);
+  bool do_oscanf (const scanf_format_elt *elt, octave_value&,
+		  const std::string& who /* = "scanf" */);
 
-  bool do_oscanf (const scanf_format_elt *elt, octave_value&);
-
-  octave_value_list oscanf (const std::string& fmt);
+  octave_value_list oscanf (const std::string& fmt,
+			    const std::string& who /* = "scanf" */);
 
   // Functions that are defined for all output streams (output streams
   // are those that define os).
 
   int flush (void);
 
   int write (const octave_value& data, oct_data_conv::data_type dt,
 	     int skip, oct_mach_info::float_format flt_fmt);
 
-  int do_printf (printf_format_list& fmt_list, const octave_value_list& args);
+  int do_printf (printf_format_list& fmt_list, const octave_value_list& args,
+		 const std::string& who /* = "printf" */);
 
-  int printf (const std::string& fmt, const octave_value_list& args);
+  int printf (const std::string& fmt, const octave_value_list& args,
+	      const std::string& who /* = "printf" */);
 
-  int puts (const std::string& s);
+  int puts (const std::string& s, const std::string& who /* = "puts" */);
 
   // We can always do this in terms of seek(), so the derived class
   // only has to provide that.
 
   int rewind (void);
 
-  void invalid_operation (const char *op, const char *rw);
+  void invalid_operation (const std::string& who, const char *rw);
 
   // No copying!
 
   octave_base_stream (const octave_base_stream&);
 
   octave_base_stream& operator = (const octave_base_stream&);
 };
 
@@ -488,21 +489,23 @@ public:
   ~octave_stream (void);
 
   octave_stream (const octave_stream&);
 
   octave_stream& operator = (const octave_stream&);
 
   int flush (void);
 
-  std::string getl (int max_len, bool& err);
-  std::string getl (const octave_value& max_len, bool& err);
+  std::string getl (int max_len, bool& err, const std::string& who /* = "getl" */);
+  std::string getl (const octave_value& max_len, bool& err,
+		    const std::string& who /* = "getl" */);
 
-  std::string gets (int max_len, bool& err);
-  std::string gets (const octave_value& max_len, bool& err);
+  std::string gets (int max_len, bool& err, const std::string& who /* = "gets" */);
+  std::string gets (const octave_value& max_len, bool& err,
+		    const std::string& who /* = "gets" */);
 
   int seek (std::streamoff offset, std::ios::seekdir origin);
   int seek (const octave_value& offset, const octave_value& origin);
 
   long tell (void) const;
 
   int rewind (void);
 
@@ -512,24 +515,27 @@ public:
 
   octave_value read (const Array<double>& size, oct_data_conv::data_type dt,
 		     int skip, oct_mach_info::float_format flt_fmt,
 		     int& count);
 
   int write (const octave_value& data, oct_data_conv::data_type dt,
 	     int skip, oct_mach_info::float_format flt_fmt);
 
-  octave_value scanf (const std::string& fmt, const Array<double>& size, int& count);
+  octave_value scanf (const std::string& fmt, const Array<double>& size,
+		      int& count, const std::string& who /* = "scanf" */);
 
-  octave_value_list oscanf (const std::string& fmt);
+  octave_value_list oscanf (const std::string& fmt,
+			    const std::string& who /* = "scanf" */);
 
-  int printf (const std::string& fmt, const octave_value_list& args);
+  int printf (const std::string& fmt, const octave_value_list& args,
+	      const std::string& who /* = "printf" */);
 
-  int puts (const std::string& s);
-  int puts (const octave_value& s);
+  int puts (const std::string& s, const std::string& who /* = "puts" */);
+  int puts (const octave_value& s, const std::string& who /* = "puts" */);
 
   bool eof (void) const;
 
   std::string error (bool clear, int& err_num);
 
   std::string error (bool clear = false)
     {
       int err_num;
@@ -556,31 +562,31 @@ public:
 
   std::ostream *output_stream (void) { return rep ? rep->output_stream () : 0; }
 
 private:
 
   // The actual representation of this stream.
   octave_base_stream *rep;
 
-  void invalid_stream_error (const char *op) const;
+  void invalid_stream_error (const std::string& who) const;
 
-  bool stream_ok (const char *op, bool clear = true) const
+  bool stream_ok (const std::string& who, bool clear = true) const
     {
       bool retval = true;
 
       if (rep)
 	{
 	  if (clear)
 	    rep->clear ();
 	}
       else
 	{
 	  retval = false;
-	  invalid_stream_error (op);
+	  invalid_stream_error (who);
 	}
 
       return retval;
     }
 
   void error (const std::string& msg)
     {
       if (rep)
@@ -598,19 +604,21 @@ protected:
 public:
 
   ~octave_stream_list (void) { }
 
   static bool instance_ok (void);
 
   static octave_value insert (const octave_stream& os);
 
-  static octave_stream lookup (int fid, const std::string& who = std::string ());
-  static octave_stream lookup (const octave_value& fid,
-			       const std::string& who = std::string ());
+  static octave_stream
+  lookup (int fid, const std::string& who = std::string ());
+
+  static octave_stream
+  lookup (const octave_value& fid, const std::string& who = std::string ());
 
   static int remove (int fid, const std::string& who = std::string ());
   static int remove (const octave_value& fid,
 		     const std::string& who = std::string ());
 
   static void clear (void);
 
   static string_vector get_info (int fid);
diff --git a/test/octave.test/io/io.exp b/test/octave.test/io/io.exp
--- a/test/octave.test/io/io.exp
+++ b/test/octave.test/io/io.exp
@@ -14,21 +14,21 @@ set test puts-1
 set prog_output "foo\nans = 0"
 do_test puts-1.m
 
 set test puts-2
 set prog_output "^ans = -1"
 do_test puts-2.m
 
 set test puts-3
-set prog_output "^usage:.*"
+set prog_output "\n... puts:.*"
 do_test puts-3.m
 
 set test puts-4
-set prog_output "^usage:.*"
+set prog_output "\n... puts:.*"
 do_test puts-4.m
 
 set test sscanf-1
 set prog_output "^ans = 1"
 do_test sscanf-1.m
 
 set test sscanf-2
 set prog_output "\n... sscanf:.*"
@@ -50,17 +50,17 @@ set test printf-1
 set prog_output "test: 1\nans = 8"
 do_test printf-1.m
 
 set test printf-2
 set prog_output "^error:.*"
 do_test printf-2.m
 
 set test printf-3
-set prog_output "^usage:.*"
+set prog_output "\n... printf:.*"
 do_test printf-3.m
 
 set test sprintf-1
 set prog_output "^ans = 1"
 do_test sprintf-1.m
 
 set test sprintf-2
 set prog_output "^error:.*"
