# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1210800521 -7200
#      Wed May 14 23:28:41 2008 +0200
# Node ID f42c6f8d6d8e809e6a017db0e56d0541561f7301
# Parent  762801c50b2149f79c13bf19159a392bafea4cab
Extend rcond function to single precision types

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,10 +1,31 @@
 2008-05-21  David Bateman  <dbateman@free.fr>
 
+	* fCMatrix.cc (float rcond): Replace with float rcon everywhere
+	to avoid shadowed variable warning
+	(float ComplexMatrix::rcond (void) const): New method for
+	reciprocal condition number calculation.
+	(float ComplexMatrix::rcond (MatrixType &mattype) const): ditto.
+	* fCMatrix.h (float rcond):  Replace with float rcon everywhere
+	to avoid shadowed variable warning
+	(float ComplexMatrix::rcond (void) const): New method for
+	reciprocal condition number calculation.
+	(float ComplexMatrix::rcond (MatrixType &mattype) const): ditto.
+	* fMatrix.cc (float rcond): Replace with float rcon everywhere
+	to avoid shadowed variable warning
+	(float Matrix::rcond (void) const): New method for
+	reciprocal condition number calculation.
+	(float Matrix::rcond (MatrixType &mattype) const): ditto.
+	* fMatrix.h (float rcond):  Replace with float rcon everywhere
+	to avoid shadowed variable warning
+	(float Matrix::rcond (void) const): New method for
+	reciprocal condition number calculation.
+	(float Matrix::rcond (MatrixType &mattype) const): ditto.
+
 	* Array.cc: Fix transpose tests.
 
 	* CmplxGEBAL.cc (ComplexGEPBALANCE), dbleGEPBAL.cc (GEPBALANCE),
 	fCmplxGEPBAL.cc (FloatComplexGEPBALANCE), floatGEPBAL.cc
 	(FloatGEPBALANCE): New class for generalized eigenvalue balancing.
 	* CmplxGEBAL.h (ComplexGEPBALANCE), dbleGEPBAL.h (GEPBALANCE),
 	fCmplxGEPBAL.h (FloatComplexGEPBALANCE), floatGEPBAL.h
 	(FloatGEPBALANCE): Declare them.
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -956,55 +956,55 @@ FloatComplexMatrix::column (octave_idx_t
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (void) const
 {
   octave_idx_type info;
-  float rcond;
+  float rcon;
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, 0, 0);
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (octave_idx_type& info) const
 {
-  float rcond;
+  float rcon;
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, 0, 0);
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::inverse (octave_idx_type& info, float& rcond, int force,
+FloatComplexMatrix::inverse (octave_idx_type& info, float& rcon, int force,
 			int calc_cond) const
 {
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, force, calc_cond);
+  return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype) const
 {
   octave_idx_type info;
-  float rcond;
-  return inverse (mattype, info, rcond, 0, 0);
+  float rcon;
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
-  float rcond;
-  return inverse (mattype, info, rcond, 0, 0);
+  float rcon;
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
-			 float& rcond, int force, int calc_cond) const
+			 float& rcon, int force, int calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1018,31 +1018,31 @@ FloatComplexMatrix::tinverse (MatrixType
 
       F77_XFCN (ctrtri, CTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
 				 F77_CONST_CHAR_ARG2 (&udiag, 1),
 				 nr, tmp_data, nr, info 
 				 F77_CHAR_ARG_LEN (1)
 				 F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	info = -1;
       else if (calc_cond) 
 	{
 	  octave_idx_type ztrcon_info = 0;
 	  char job = '1';
 
 	  OCTAVE_LOCAL_BUFFER (FloatComplex, cwork, 2*nr);
 	  OCTAVE_LOCAL_BUFFER (float, rwork, nr);
 
 	  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     F77_CONST_CHAR_ARG2 (&uplo, 1),
 				     F77_CONST_CHAR_ARG2 (&udiag, 1),
-				     nr, tmp_data, nr, rcond, 
+				     nr, tmp_data, nr, rcon, 
 				     cwork, rwork, ztrcon_info 
 				     F77_CHAR_ARG_LEN (1)
 				     F77_CHAR_ARG_LEN (1)
 				     F77_CHAR_ARG_LEN (1)));
 
 	  if (ztrcon_info != 0) 
 	    info = -1;
 	}
@@ -1051,17 +1051,17 @@ FloatComplexMatrix::tinverse (MatrixType
 	retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
-			 float& rcond, int force, int calc_cond) const
+			 float& rcon, int force, int calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1091,29 +1091,29 @@ FloatComplexMatrix::finverse (MatrixType
       // Calculate the norm of the matrix, for later use.
       float anorm;
       if (calc_cond)
 	anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	info = -1;
       else if (calc_cond) 
 	{
 	  // Now calculate the condition number for non-singular matrix.
 	  octave_idx_type zgecon_info = 0;
 	  char job = '1';
 	  Array<float> rz (2 * nc);
 	  float *prz = rz.fortran_vec ();
 	  F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nc, tmp_data, nr, anorm, 
-				     rcond, pz, prz, zgecon_info
+				     rcon, pz, prz, zgecon_info
 				     F77_CHAR_ARG_LEN (1)));
 
 	  if (zgecon_info != 0) 
 	    info = -1;
 	}
 
       if (info == -1 && ! force)
 	retval = *this;  // Restore contents.
@@ -1132,47 +1132,47 @@ FloatComplexMatrix::finverse (MatrixType
 	mattype.mark_as_rectangular();
     }
   
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
-			float& rcond, int force, int calc_cond) const
+			float& rcon, int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   FloatComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
-    ret = tinverse (mattype, info, rcond, force, calc_cond);
+    ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
 	{
 	  FloatComplexCHOL chol (*this, info, calc_cond);
 	  if (info == 0)
 	    {
 	      if (calc_cond)
-		rcond = chol.rcond();
+		rcon = chol.rcond();
 	      else
-		rcond = 1.0;
+		rcon = 1.0;
 	      ret = chol.inverse ();
 	    }
 	  else
 	    mattype.mark_as_unsymmetric ();
 	}
 
       if (!mattype.is_hermitian ())
-	ret = finverse(mattype, info, rcond, force, calc_cond);
-
-      if ((mattype.is_hermitian () || calc_cond) && rcond == 0.)
+	ret = finverse(mattype, info, rcon, force, calc_cond);
+
+      if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
 	ret = FloatComplexMatrix (rows (), columns (), FloatComplex (octave_Float_Inf, 0.));
     }
 
   return ret;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::pseudo_inverse (float tol) const
@@ -1526,29 +1526,29 @@ FloatComplexMatrix::ifourier2d (void) co
 }
 
 #endif
 
 FloatComplexDET
 FloatComplexMatrix::determinant (void) const
 {
   octave_idx_type info;
-  float rcond;
-  return determinant (info, rcond, 0);
+  float rcon;
+  return determinant (info, rcon, 0);
 }
 
 FloatComplexDET
 FloatComplexMatrix::determinant (octave_idx_type& info) const
 {
-  float rcond;
-  return determinant (info, rcond, 0);
+  float rcon;
+  return determinant (info, rcon, 0);
 }
 
 FloatComplexDET
-FloatComplexMatrix::determinant (octave_idx_type& info, float& rcond, int calc_cond) const
+FloatComplexMatrix::determinant (octave_idx_type& info, float& rcon, int calc_cond) const
 {
   FloatComplexDET retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0)
     {
@@ -1567,17 +1567,17 @@ FloatComplexMatrix::determinant (octave_
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond) 
 	anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (cgetrf, CGETRF, (nr, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	{
 	  info = -1;
 	  retval = FloatComplexDET ();
 	} 
       else 
 	{
 	  if (calc_cond) 
@@ -1586,17 +1586,17 @@ FloatComplexMatrix::determinant (octave_
 	      char job = '1';
 	      Array<FloatComplex> z (2*nr);
 	      FloatComplex *pz = z.fortran_vec ();
 	      Array<float> rz (2*nr);
 	      float *prz = rz.fortran_vec ();
 
 	      F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					 nc, tmp_data, nr, anorm, 
-					 rcond, pz, prz, info
+					 rcon, pz, prz, info
 					 F77_CHAR_ARG_LEN (1)));
 	    }
 
 	  if (info != 0) 
 	    {
 	      info = -1;
 	      retval = FloatComplexDET ();
 	    } 
@@ -1631,19 +1631,186 @@ FloatComplexMatrix::determinant (octave_
 	      retval = FloatComplexDET (c, e);
 	    }
 	}
     }
   
   return retval;
 }
 
+float
+FloatComplexMatrix::rcond (void) const
+{
+  MatrixType mattype (*this);
+  return rcond (mattype);
+}
+
+float
+FloatComplexMatrix::rcond (MatrixType &mattype) const
+{
+  float rcon;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr != nc)
+    (*current_liboctave_error_handler) ("matrix must be square");
+  else if (nr == 0 || nc == 0)
+    rcon = octave_Inf;
+  else
+    {
+      int typ = mattype.type ();
+
+      if (typ == MatrixType::Unknown)
+	typ = mattype.type (*this);
+
+      // Only calculate the condition number for LU/Cholesky
+      if (typ == MatrixType::Upper)
+	{
+	  const FloatComplex *tmp_data = fortran_vec ();
+	  octave_idx_type info = 0;
+	  char norm = '1';
+	  char uplo = 'U';
+	  char dia = 'N';
+
+	  Array<FloatComplex> z (2 * nc);
+	  FloatComplex *pz = z.fortran_vec ();
+	  Array<float> rz (nc);
+	  float *prz = rz.fortran_vec ();
+
+	  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+				     F77_CONST_CHAR_ARG2 (&dia, 1), 
+				     nr, tmp_data, nr, rcon,
+				     pz, prz, info
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (info != 0) 
+	    rcon = 0;
+	}
+      else if  (typ == MatrixType::Permuted_Upper)
+	(*current_liboctave_error_handler)
+	  ("permuted triangular matrix not implemented");
+      else if (typ == MatrixType::Lower)
+	{
+	  const FloatComplex *tmp_data = fortran_vec ();
+	  octave_idx_type info = 0;
+	  char norm = '1';
+	  char uplo = 'L';
+	  char dia = 'N';
+
+	  Array<FloatComplex> z (2 * nc);
+	  FloatComplex *pz = z.fortran_vec ();
+	  Array<float> rz (nc);
+	  float *prz = rz.fortran_vec ();
+
+	  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+				     F77_CONST_CHAR_ARG2 (&dia, 1), 
+				     nr, tmp_data, nr, rcon,
+				     pz, prz, info
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (info != 0) 
+	    rcon = 0.0;
+	}
+      else if (typ == MatrixType::Permuted_Lower)
+	(*current_liboctave_error_handler)
+	  ("permuted triangular matrix not implemented");
+      else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
+	{
+	  float anorm = -1.0;
+	  FloatComplexMatrix atmp = *this;
+	  FloatComplex *tmp_data = atmp.fortran_vec ();
+
+	  if (typ == MatrixType::Hermitian)
+	    {
+	      octave_idx_type info = 0;
+	      char job = 'L';
+	      anorm = atmp.abs().sum().
+		row(static_cast<octave_idx_type>(0)).max();
+
+	      F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+					 tmp_data, nr, info
+					 F77_CHAR_ARG_LEN (1)));
+
+	      if (info != 0) 
+		{
+		  rcon = 0.0;
+
+		  mattype.mark_as_unsymmetric ();
+		  typ = MatrixType::Full;
+		}
+	      else 
+		{
+		  Array<FloatComplex> z (2 * nc);
+		  FloatComplex *pz = z.fortran_vec ();
+		  Array<float> rz (nc);
+		  float *prz = rz.fortran_vec ();
+
+		  F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, tmp_data, nr, anorm,
+					     rcon, pz, prz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    rcon = 0.0;
+		}
+	    }
+
+
+	  if (typ == MatrixType::Full)
+	    {
+	      octave_idx_type info = 0;
+
+	      Array<octave_idx_type> ipvt (nr);
+	      octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+	      if(anorm < 0.)
+		anorm = atmp.abs().sum().
+		  row(static_cast<octave_idx_type>(0)).max();
+
+	      Array<FloatComplex> z (2 * nc);
+	      FloatComplex *pz = z.fortran_vec ();
+	      Array<float> rz (2 * nc);
+	      float *prz = rz.fortran_vec ();
+
+	      F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+	      if (info != 0) 
+		{ 
+		  rcon = 0.0;
+		  mattype.mark_as_rectangular ();
+		} 
+	      else 
+		{
+		  char job = '1';
+		  F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nc, tmp_data, nr, anorm, 
+					     rcon, pz, prz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    rcon = 0.0;
+		}
+	    }
+	}
+      else
+	rcon = 0.0;
+    }
+
+  return rcon;
+}
+
 FloatComplexMatrix
 FloatComplexMatrix::utsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
-			octave_idx_type& info, float& rcond, 
+			octave_idx_type& info, float& rcon, 
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -1655,17 +1822,17 @@ FloatComplexMatrix::utsolve (MatrixType 
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
+	  rcon = 1.;
 	  info = 0;
 
 	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      (*current_liboctave_error_handler)
 		("permuted triangular matrix not implemented");
 	    }
 	  else
@@ -1681,37 +1848,37 @@ FloatComplexMatrix::utsolve (MatrixType 
 		  Array<FloatComplex> z (2 * nc);
 		  FloatComplex *pz = z.fortran_vec ();
 		  Array<float> rz (nc);
 		  float *prz = rz.fortran_vec ();
 
 		  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcond,
+					     nr, tmp_data, nr, rcon,
 					     pz, prz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile float rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile float rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  FloatComplex *result = retval.fortran_vec ();
 
@@ -1734,17 +1901,17 @@ FloatComplexMatrix::utsolve (MatrixType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ltsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
-			octave_idx_type& info, float& rcond, 
+			octave_idx_type& info, float& rcon, 
 			solve_singularity_handler sing_handler,
 			bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -1756,17 +1923,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
+	  rcon = 1.;
 	  info = 0;
 
 	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      (*current_liboctave_error_handler)
 		("permuted triangular matrix not implemented");
 	    }
 	  else
@@ -1782,37 +1949,37 @@ FloatComplexMatrix::ltsolve (MatrixType 
 		  Array<FloatComplex> z (2 * nc);
 		  FloatComplex *pz = z.fortran_vec ();
 		  Array<float> rz (nc);
 		  float *prz = rz.fortran_vec ();
 
 		  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcond,
+					     nr, tmp_data, nr, rcon,
 					     pz, prz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile float rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile float rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  FloatComplex *result = retval.fortran_vec ();
 
@@ -1835,17 +2002,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::fsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcond,
+		       octave_idx_type& info, float& rcon,
 		       solve_singularity_handler sing_handler,
 		       bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -1870,17 +2037,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 	  FloatComplex *tmp_data = atmp.fortran_vec ();
 	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
 	  F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
 				     tmp_data, nr, info
 				     F77_CHAR_ARG_LEN (1)));
 
 	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  rcon = 0.0;
 	  if (info != 0) 
 	    {
 	      info = -2;
 
 	      mattype.mark_as_unsymmetric ();
 	      typ = MatrixType::Full;
 	    }
 	  else 
@@ -1889,34 +2056,34 @@ FloatComplexMatrix::fsolve (MatrixType &
 		{
 		  Array<FloatComplex> z (2 * nc);
 		  FloatComplex *pz = z.fortran_vec ();
 		  Array<float> rz (nc);
 		  float *prz = rz.fortran_vec ();
 
 		  F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, tmp_data, nr, anorm,
-					     rcond, pz, prz, info
+					     rcon, pz, prz, info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile float rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile float rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  FloatComplex *result = retval.fortran_vec ();
 
@@ -1952,56 +2119,56 @@ FloatComplexMatrix::fsolve (MatrixType &
 
 	  // Calculate the norm of the matrix, for later use.
 	  if (anorm < 0.)
 	    anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
 	  F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
 	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  rcon = 0.0;
 	  if (info != 0) 
 	    { 
 	      info = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		sing_handler (rcon);
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	      mattype.mark_as_rectangular ();
 	    } 
 	  else 
 	    {
 	      if (calc_cond)
 		{
 		  // Now calculate the condition number for 
 		  // non-singular matrix.
 		  char job = '1';
 		  F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nc, tmp_data, nr, anorm, 
-					     rcond, pz, prz, info
+					     rcon, pz, prz, info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile float rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile float rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  FloatComplex *result = retval.fortran_vec ();
 
@@ -2021,345 +2188,345 @@ FloatComplexMatrix::fsolve (MatrixType &
   
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (typ, b, info, rcond, 0);
+  float rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, 
 		      octave_idx_type& info) const
 {
-  float rcond;
-  return solve (typ, b, info, rcond, 0);
+  float rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		      float& rcond) const
+		      float& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
-		      float& rcond, solve_singularity_handler sing_handler,
+		      float& rcon, solve_singularity_handler sing_handler,
 		      bool singular_fallback) const
 {
   FloatComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcond, sing_handler, singular_fallback);
+  return solve (typ, tmp, info, rcon, sing_handler, singular_fallback);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (typ, b, info, rcond, 0);
+  float rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, 
 		      octave_idx_type& info) const
 {
-  float rcond;
-  return solve (typ, b, info, rcond, 0);
+  float rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		      octave_idx_type& info, float& rcond) const
+		      octave_idx_type& info, float& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &mattype, const FloatComplexMatrix& b, 
-		      octave_idx_type& info, float& rcond,
+		      octave_idx_type& info, float& rcon,
 		      solve_singularity_handler sing_handler,
 		      bool singular_fallback) const
 {
   FloatComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    retval = utsolve (mattype, b, info, rcond, sing_handler, false);
+    retval = utsolve (mattype, b, info, rcon, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-    retval = ltsolve (mattype, b, info, rcond, sing_handler, false);
+    retval = ltsolve (mattype, b, info, rcon, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
-    retval = fsolve (mattype, b, info, rcond, sing_handler, true);
+    retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return FloatComplexMatrix ();
     }
 
   // Rectangular or one of the above solvers flags a singular matrix
   if (singular_fallback && mattype.type () == MatrixType::Rectangular)
     {
       octave_idx_type rank;
-      retval = lssolve (b, info, rank, rcond);
+      retval = lssolve (b, info, rank, rcon);
     }
 
   return retval;
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (typ, FloatComplexColumnVector (b), info, rcond, 0);
+  float rcon;
+  return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
 		      octave_idx_type& info) const
 {
-  float rcond;
-  return solve (typ, FloatComplexColumnVector (b), info, rcond, 0);
+  float rcon;
+  return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info, float& rcond) const
+		      octave_idx_type& info, float& rcon) const
 {
-  return solve (typ, FloatComplexColumnVector (b), info, rcond, 0);
+  return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info, float& rcond,
+		      octave_idx_type& info, float& rcon,
 		      solve_singularity_handler sing_handler) const
 {
-  return solve (typ, FloatComplexColumnVector (b), info, rcond, sing_handler);
+  return solve (typ, FloatComplexColumnVector (b), info, rcon, sing_handler);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (typ, b, info, rcond, 0);
+  float rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 		      octave_idx_type& info) const
 {
-  float rcond;
-  return solve (typ, b, info, rcond, 0);
+  float rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-		      octave_idx_type& info, float& rcond) const
+		      octave_idx_type& info, float& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-		      octave_idx_type& info, float& rcond,
+		      octave_idx_type& info, float& rcon,
 		      solve_singularity_handler sing_handler) const
 {
 
   FloatComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcond, sing_handler).column(static_cast<octave_idx_type> (0));
+  return solve (typ, tmp, info, rcon, sing_handler).column(static_cast<octave_idx_type> (0));
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (b, info, rcond, 0);
+  float rcon;
+  return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info) const
 {
-  float rcond;
-  return solve (b, info, rcond, 0);
+  float rcon;
+  return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcond) const
+FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcond,
+FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
 		      solve_singularity_handler sing_handler) const
 {
   FloatComplexMatrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler);
+  return solve (tmp, info, rcon, sing_handler);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (b, info, rcond, 0);
+  float rcon;
+  return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info) const
 {
-  float rcond;
-  return solve (b, info, rcond, 0);
+  float rcon;
+  return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcond) const
+FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcond,
+FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
 		      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcond, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (FloatComplexColumnVector (b), info, rcond, 0);
+  float rcon;
+  return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info) const
 {
-  float rcond;
-  return solve (FloatComplexColumnVector (b), info, rcond, 0);
+  float rcon;
+  return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, 
-		      float& rcond) const
+		      float& rcon) const
 {
-  return solve (FloatComplexColumnVector (b), info, rcond, 0);
+  return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, 
-		      float& rcond, 
+		      float& rcon, 
 		      solve_singularity_handler sing_handler) const
 {
-  return solve (FloatComplexColumnVector (b), info, rcond, sing_handler);
+  return solve (FloatComplexColumnVector (b), info, rcon, sing_handler);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (b, info, rcond, 0);
+  float rcon;
+  return solve (b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info) const
 {
-  float rcond;
-  return solve (b, info, rcond, 0);
+  float rcon;
+  return solve (b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-		      float& rcond) const
+		      float& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-		      float& rcond,
+		      float& rcon,
 		      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcond, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  float rcond;
-  return lssolve (FloatComplexMatrix (b), info, rank, rcond);
+  float rcon;
+  return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  float rcond;
-  return lssolve (FloatComplexMatrix (b), info, rank, rcond);
+  float rcon;
+  return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
 			octave_idx_type& rank) const
 {
-  float rcond;
-  return lssolve (FloatComplexMatrix (b), info, rank, rcond);
+  float rcon;
+  return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-			octave_idx_type& rank, float& rcond) const
+			octave_idx_type& rank, float& rcon) const
 {
-  return lssolve (FloatComplexMatrix (b), info, rank, rcond);
+  return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
 			octave_idx_type& rank) const
 {
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info, 
-			octave_idx_type& rank, float& rcond) const
+			octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2367,17 +2534,17 @@ FloatComplexMatrix::lssolve (const Float
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m== 0 || n == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (n, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
-      rcond = -1.0;
+      rcon = -1.0;
 
       if (m != n)
 	{
 	  retval = FloatComplexMatrix (maxmn, nrhs);
 
 	  for (octave_idx_type j = 0; j < nrhs; j++)
 	    for (octave_idx_type i = 0; i < m; i++)
 	      retval.elem (i, j) = b.elem (i, j);
@@ -2434,17 +2601,17 @@ FloatComplexMatrix::lssolve (const Float
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcond, rank, work.fortran_vec (),
+				 ps, rcon, rank, work.fortran_vec (),
 				 lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n >= mnthr)
 	{
@@ -2471,97 +2638,97 @@ FloatComplexMatrix::lssolve (const Float
 	  if (std::real (work(0)) < lworkaround)
 	    work(0) = lworkaround;
 	}
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork);
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcond, rank,
+				 maxmn, ps, rcon, rank,
 				 work.fortran_vec (), lwork, 
 				 prwork, piwork, info));
 
       if (rank < minmn)
 	(*current_liboctave_warning_handler) 
 	  ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-	   m, n, rank, rcond);
+	   m, n, rank, rcon);
 
       if (s.elem (0) == 0.0)
-	rcond = 0.0;
+	rcon = 0.0;
       else
-	rcond = s.elem (minmn - 1) / s.elem (0);
+	rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatColumnVector& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  float rcond;
-  return lssolve (FloatComplexColumnVector (b), info, rank, rcond);
+  float rcon;
+  return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  float rcond;
-  return lssolve (FloatComplexColumnVector (b), info, rank, rcond);
+  float rcon;
+  return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info, 
 			octave_idx_type& rank) const
 {
-  float rcond;
-  return lssolve (FloatComplexColumnVector (b), info, rank, rcond);
+  float rcon;
+  return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info, 
-			octave_idx_type& rank, float& rcond) const
+			octave_idx_type& rank, float& rcon) const
 {
-  return lssolve (FloatComplexColumnVector (b), info, rank, rcond);
+  return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
 			octave_idx_type& rank) const
 {
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank, float& rcond) const
+			octave_idx_type& rank, float& rcon) const
 {
   FloatComplexColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2569,17 +2736,17 @@ FloatComplexMatrix::lssolve (const Float
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0 || b.cols () == 0)
     retval = FloatComplexColumnVector (n, FloatComplex (0.0, 0.0));
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
-      rcond = -1.0;
+      rcon = -1.0;
 
       if (m != n)
 	{
 	  retval = FloatComplexColumnVector (maxmn);
 
 	  for (octave_idx_type i = 0; i < m; i++)
 	    retval.elem (i) = b.elem (i);
 	}
@@ -2628,40 +2795,40 @@ FloatComplexMatrix::lssolve (const Float
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcond, rank, work.fortran_vec (),
+				 ps, rcon, rank, work.fortran_vec (),
 				 lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (lwork);
       rwork.resize (static_cast<octave_idx_type> (rwork(0)));
       iwork.resize (iwork(0));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcond, rank,
+				 maxmn, ps, rcon, rank,
 				 work.fortran_vec (), lwork, 
 				 prwork, piwork, info));
 
       if (rank < minmn)
 	{
 	  if (rank < minmn)
 	    (*current_liboctave_warning_handler) 
 	      ("zgelsd: rank deficient %dx%d matrix, rank = %d, tol = %e",
-	       m, n, rank, rcond);
+	       m, n, rank, rcon);
 
 	  if (s.elem (0) == 0.0)
-	    rcond = 0.0;
+	    rcon = 0.0;
 	  else
-	    rcond = s.elem (minmn - 1) / s.elem (0);
+	    rcon = s.elem (minmn - 1) / s.elem (0);
 
 	  retval.resize (n, nrhs);
 	}
     }
 
   return retval;
 }
 
@@ -2675,21 +2842,21 @@ static float padec [] =
   1.6025641025641026e-3,
   1.0683760683760684e-4,
   4.8562548562548563e-6,
   1.3875013875013875e-7,
   1.9270852604185938e-9,
 };
 
 static void
-solve_singularity_warning (float rcond)
+solve_singularity_warning (float rcon)
 {
   (*current_liboctave_warning_handler) 
     ("singular matrix encountered in expm calculation, rcond = %g",
-     rcond);
+     rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::expm (void) const
 {
   FloatComplexMatrix retval;
 
   FloatComplexMatrix m = *this;
@@ -2806,18 +2973,18 @@ FloatComplexMatrix::expm (void) const
   for (octave_idx_type j = 0; j < nc; j++)
     {
       npp.elem (j, j) += 1.0;
       dpp.elem (j, j) += 1.0;
     }
 
   // Compute pade approximation = inverse (dpp) * npp.
 
-  float rcond;
-  retval = dpp.solve (npp, info, rcond, solve_singularity_warning);
+  float rcon;
+  retval = dpp.solve (npp, info, rcon, solve_singularity_warning);
 
   if (info < 0)
     return retval;
 
   // Reverse preconditioning step 3: repeated squaring.
 
   while (sqpow)
     {
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 
 class
 OCTAVE_API
 FloatComplexMatrix : public MArray2<FloatComplex>
 {
 public:
  
-  typedef void (*solve_singularity_handler) (float rcond);
+  typedef void (*solve_singularity_handler) (float rcon);
 
   FloatComplexMatrix (void) : MArray2<FloatComplex> () { }
 
   FloatComplexMatrix (octave_idx_type r, octave_idx_type c) : MArray2<FloatComplex> (r, c) { }
 
   FloatComplexMatrix (octave_idx_type r, octave_idx_type c, const FloatComplex& val)
     : MArray2<FloatComplex> (r, c, val) { }
 
@@ -142,163 +142,166 @@ public:
   // extract row or column i.
 
   FloatComplexRowVector row (octave_idx_type i) const;
 
   FloatComplexColumnVector column (octave_idx_type i) const;
 
 private:
   FloatComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
-			  float& rcond, int force, int calc_cond) const;
+			  float& rcon, int force, int calc_cond) const;
 
   FloatComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
-			  float& rcond, int force, int calc_cond) const;
+			  float& rcon, int force, int calc_cond) const;
 
 public:
   FloatComplexMatrix inverse (void) const;
   FloatComplexMatrix inverse (octave_idx_type& info) const;
-  FloatComplexMatrix inverse (octave_idx_type& info, float& rcond, int force = 0, 
+  FloatComplexMatrix inverse (octave_idx_type& info, float& rcon, int force = 0, 
 			 int calc_cond = 1) const;
 
   FloatComplexMatrix inverse (MatrixType &mattype) const;
   FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info,
-			 float& rcond, int force = 0, 
+			 float& rcon, int force = 0, 
 			 int calc_cond = 1) const;
 
   FloatComplexMatrix pseudo_inverse (float tol = 0.0) const;
 
   FloatComplexMatrix fourier (void) const;
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
 
   FloatComplexDET determinant (void) const;
   FloatComplexDET determinant (octave_idx_type& info) const;
-  FloatComplexDET determinant (octave_idx_type& info, float& rcond, int calc_cond = 1) const;
+  FloatComplexDET determinant (octave_idx_type& info, float& rcon, int calc_cond = 1) const;
+
+  float rcond (void) const;
+  float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   FloatComplexMatrix utsolve (MatrixType &typ, const FloatComplexMatrix& b,
-		  octave_idx_type& info, float& rcond, 
+		  octave_idx_type& info, float& rcon, 
 		  solve_singularity_handler sing_handler,
 		  bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
   FloatComplexMatrix ltsolve (MatrixType &typ, const FloatComplexMatrix& b,
-		  octave_idx_type& info, float& rcond, 
+		  octave_idx_type& info, float& rcon, 
 		  solve_singularity_handler sing_handler,
 		  bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
   FloatComplexMatrix fsolve (MatrixType &typ, const FloatComplexMatrix& b,
-		 octave_idx_type& info, float& rcond, 
+		 octave_idx_type& info, float& rcon, 
 		 solve_singularity_handler sing_handler,
 		 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, 
 		       octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, 
-		       octave_idx_type& info, float& rcond) const;
+		       octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		       float& rcond, solve_singularity_handler sing_handler,
+		       float& rcon, solve_singularity_handler sing_handler,
 		       bool singular_fallback = true) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
 		       octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcond) const;
+		       octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcond,
+		       octave_idx_type& info, float& rcon,
 		       solve_singularity_handler sing_handler,
 		       bool singular_fallback = true) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
 			     octave_idx_type& info) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-			     octave_idx_type& info, float& rcond) const;
+			     octave_idx_type& info, float& rcon) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-			     octave_idx_type& info, float& rcond,
+			     octave_idx_type& info, float& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, 
 			     const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 			     octave_idx_type& info) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info, float& rcond) const;
+			     octave_idx_type& info, float& rcon) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info, float& rcond,
+			     octave_idx_type& info, float& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   FloatComplexMatrix solve (const FloatMatrix& b) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
-  FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcond) const;
-  FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcond,
+  FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
+  FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
 		       solve_singularity_handler sing_handler) const;
 
   FloatComplexMatrix solve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcond) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcond,
+  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const;
+  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
 		       solve_singularity_handler sing_handler) const;
 
   FloatComplexColumnVector solve (const FloatColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info,
-			     float& rcond) const;
-  FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcond,
+			     float& rcon) const;
+  FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			     float& rcond) const;
+			     float& rcon) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			     float& rcond,
+			     float& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   FloatComplexMatrix lssolve (const FloatMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
 			 octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
-			 octave_idx_type& rank, float& rcond) const;
+			 octave_idx_type& rank, float& rcon) const;
 
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
 			 octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank, float& rcond) const;
+			 octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatColumnVector& b) const;
   FloatComplexColumnVector lssolve (const FloatColumnVector& b,
 			       octave_idx_type& info) const;
   FloatComplexColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
 			       octave_idx_type& rank) const;
   FloatComplexColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-			       octave_idx_type& rank, float& rcond) const;
+			       octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
 			       octave_idx_type& info) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
 			       octave_idx_type& info,
 			       octave_idx_type& rank) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
 			       octave_idx_type& info,
-			       octave_idx_type& rank, float& rcond) const;
+			       octave_idx_type& rank, float& rcon) const;
 
   FloatComplexMatrix expm (void) const;
 
   // matrix by diagonal matrix -> matrix operations
 
   FloatComplexMatrix& operator += (const FloatDiagMatrix& a);
   FloatComplexMatrix& operator -= (const FloatDiagMatrix& a);
 
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -645,54 +645,54 @@ FloatMatrix::column (octave_idx_type i) 
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::inverse (void) const
 {
   octave_idx_type info;
-  float rcond;
+  float rcon;
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, 0, 0);
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
 FloatMatrix::inverse (octave_idx_type& info) const
 {
-  float rcond;
+  float rcon;
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, 0, 0);
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
-FloatMatrix::inverse (octave_idx_type& info, float& rcond, int force,
+FloatMatrix::inverse (octave_idx_type& info, float& rcon, int force,
 		 int calc_cond) const
 {
   MatrixType mattype (*this);
-  return inverse (mattype, info, rcond, force, calc_cond);
+  return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 FloatMatrix
 FloatMatrix::inverse (MatrixType& mattype) const
 {
   octave_idx_type info;
-  float rcond;
-  return inverse (mattype, info, rcond, 0, 0);
+  float rcon;
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
 FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
-  float rcond;
-  return inverse (mattype, info, rcond, 0, 0);
+  float rcon;
+  return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
-FloatMatrix::tinverse (MatrixType &mattype, octave_idx_type& info, float& rcond, 
+FloatMatrix::tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
 		  int force, int calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -707,31 +707,31 @@ FloatMatrix::tinverse (MatrixType &matty
 
       F77_XFCN (strtri, STRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
 				 F77_CONST_CHAR_ARG2 (&udiag, 1),
 				 nr, tmp_data, nr, info 
 				 F77_CHAR_ARG_LEN (1)
 				 F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	info = -1;
       else if (calc_cond) 
 	{
 	  octave_idx_type dtrcon_info = 0;
 	  char job = '1';
 
 	  OCTAVE_LOCAL_BUFFER (float, work, 3 * nr);
 	  OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
 
 	  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     F77_CONST_CHAR_ARG2 (&uplo, 1),
 				     F77_CONST_CHAR_ARG2 (&udiag, 1),
-				     nr, tmp_data, nr, rcond, 
+				     nr, tmp_data, nr, rcon, 
 				     work, iwork, dtrcon_info 
 				     F77_CHAR_ARG_LEN (1)
 				     F77_CHAR_ARG_LEN (1)
 				     F77_CHAR_ARG_LEN (1)));
 
 	  if (dtrcon_info != 0) 
 	    info = -1;
 	}
@@ -740,17 +740,17 @@ FloatMatrix::tinverse (MatrixType &matty
 	retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 
 FloatMatrix
-FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcond, 
+FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
 		  int force, int calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -780,30 +780,30 @@ FloatMatrix::finverse (MatrixType &matty
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond) 
 	anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	info = -1;
       else if (calc_cond) 
 	{
 	  octave_idx_type dgecon_info = 0;
 
 	  // Now calculate the condition number for non-singular matrix.
 	  char job = '1';
 	  Array<octave_idx_type> iz (nc);
 	  octave_idx_type *piz = iz.fortran_vec ();
 	  F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 				     nc, tmp_data, nr, anorm, 
-				     rcond, pz, piz, dgecon_info
+				     rcon, pz, piz, dgecon_info
 				     F77_CHAR_ARG_LEN (1)));
 
 	  if (dgecon_info != 0) 
 	    info = -1;
 	}
 
       if (info == -1 && ! force)
 	retval = *this; // Restore matrix contents.
@@ -821,48 +821,48 @@ FloatMatrix::finverse (MatrixType &matty
       if (info != 0)
 	mattype.mark_as_rectangular();
     }
 
   return retval;
 }
 
 FloatMatrix
-FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcond, 
+FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
 		 int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   FloatMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
-    ret = tinverse (mattype, info, rcond, force, calc_cond);
+    ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
 	{
 	  FloatCHOL chol (*this, info, calc_cond);
 	  if (info == 0)
 	    {
 	      if (calc_cond)
-		rcond = chol.rcond ();
+		rcon = chol.rcond ();
 	      else
-		rcond = 1.0;
+		rcon = 1.0;
 	      ret = chol.inverse ();
 	    }
 	  else
 	    mattype.mark_as_unsymmetric ();
 	}
 
       if (!mattype.is_hermitian ())
-	ret = finverse(mattype, info, rcond, force, calc_cond);
-
-      if ((mattype.is_hermitian () || calc_cond) && rcond == 0.)
+	ret = finverse(mattype, info, rcon, force, calc_cond);
+
+      if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
 	ret = FloatMatrix (rows (), columns (), octave_Float_Inf);
     }
 
   return ret;
 }
 
 FloatMatrix
 FloatMatrix::pseudo_inverse (float tol) const
@@ -1210,29 +1210,29 @@ FloatMatrix::ifourier2d (void) const
 }
 
 #endif
 
 FloatDET
 FloatMatrix::determinant (void) const
 {
   octave_idx_type info;
-  float rcond;
-  return determinant (info, rcond, 0);
+  float rcon;
+  return determinant (info, rcon, 0);
 }
 
 FloatDET
 FloatMatrix::determinant (octave_idx_type& info) const
 {
-  float rcond;
-  return determinant (info, rcond, 0);
+  float rcon;
+  return determinant (info, rcon, 0);
 }
 
 FloatDET
-FloatMatrix::determinant (octave_idx_type& info, float& rcond, int calc_cond) const
+FloatMatrix::determinant (octave_idx_type& info, float& rcon, int calc_cond) const
 {
   FloatDET retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0)
     {
@@ -1251,17 +1251,17 @@ FloatMatrix::determinant (octave_idx_typ
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond) 
 	anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
-      rcond = 0.0;
+      rcon = 0.0;
       if (info != 0) 
 	{
 	  info = -1;
 	  retval = FloatDET ();
 	} 
       else 
 	{
 	  if (calc_cond) 
@@ -1270,17 +1270,17 @@ FloatMatrix::determinant (octave_idx_typ
 	      char job = '1';
 	      Array<float> z (4 * nc);
 	      float *pz = z.fortran_vec ();
 	      Array<octave_idx_type> iz (nc);
 	      octave_idx_type *piz = iz.fortran_vec ();
 
 	      F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					 nc, tmp_data, nr, anorm, 
-					 rcond, pz, piz, info
+					 rcon, pz, piz, info
 					 F77_CHAR_ARG_LEN (1)));
 	    }
 
 	  if (info != 0) 
 	    {
 	      info = -1;
 	      retval = FloatDET ();
 	    } 
@@ -1315,19 +1315,184 @@ FloatMatrix::determinant (octave_idx_typ
 	      retval = FloatDET (c, e);
 	    }
 	}
     }
 
   return retval;
 }
 
+float
+FloatMatrix::rcond (void) const
+{
+  MatrixType mattype (*this);
+  return rcond (mattype);
+}
+
+float
+FloatMatrix::rcond (MatrixType &mattype) const
+{
+  float rcon;
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr != nc)
+    (*current_liboctave_error_handler) ("matrix must be square");
+  else if (nr == 0 || nc == 0)
+    rcon = octave_Inf;
+  else
+    {
+      int typ = mattype.type ();
+
+      if (typ == MatrixType::Unknown)
+	typ = mattype.type (*this);
+
+      // Only calculate the condition number for LU/Cholesky
+      if (typ == MatrixType::Upper)
+	{
+	  const float *tmp_data = fortran_vec ();
+	  octave_idx_type info = 0;
+	  char norm = '1';
+	  char uplo = 'U';
+	  char dia = 'N';
+
+	  Array<float> z (3 * nc);
+	  float *pz = z.fortran_vec ();
+	  Array<octave_idx_type> iz (nc);
+	  octave_idx_type *piz = iz.fortran_vec ();
+
+	  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+				     F77_CONST_CHAR_ARG2 (&dia, 1), 
+				     nr, tmp_data, nr, rcon,
+				     pz, piz, info
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (info != 0) 
+	    rcon = 0.0;
+	}
+      else if  (typ == MatrixType::Permuted_Upper)
+	(*current_liboctave_error_handler)
+	  ("permuted triangular matrix not implemented");
+      else if (typ == MatrixType::Lower)
+	{
+	  const float *tmp_data = fortran_vec ();
+	  octave_idx_type info = 0;
+	  char norm = '1';
+	  char uplo = 'L';
+	  char dia = 'N';
+
+	  Array<float> z (3 * nc);
+	  float *pz = z.fortran_vec ();
+	  Array<octave_idx_type> iz (nc);
+	  octave_idx_type *piz = iz.fortran_vec ();
+
+	  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
+				     F77_CONST_CHAR_ARG2 (&uplo, 1), 
+				     F77_CONST_CHAR_ARG2 (&dia, 1), 
+				     nr, tmp_data, nr, rcon,
+				     pz, piz, info
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)
+				     F77_CHAR_ARG_LEN (1)));
+
+	  if (info != 0) 
+	    rcon = 0.0;
+	}
+      else if (typ == MatrixType::Permuted_Lower)
+	(*current_liboctave_error_handler)
+	  ("permuted triangular matrix not implemented");
+      else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
+	{
+	  float anorm = -1.0;
+	  FloatMatrix atmp = *this;
+	  float *tmp_data = atmp.fortran_vec ();
+
+	  if (typ == MatrixType::Hermitian)
+	    {
+	      octave_idx_type info = 0;
+	      char job = 'L';
+	      anorm = atmp.abs().sum().
+		row(static_cast<octave_idx_type>(0)).max();
+
+	      F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+					 tmp_data, nr, info
+					 F77_CHAR_ARG_LEN (1)));
+
+	      if (info != 0) 
+		{
+		  rcon = 0.0;
+		  mattype.mark_as_unsymmetric ();
+		  typ = MatrixType::Full;
+		}
+	      else 
+		{
+		  Array<float> z (3 * nc);
+		  float *pz = z.fortran_vec ();
+		  Array<octave_idx_type> iz (nc);
+		  octave_idx_type *piz = iz.fortran_vec ();
+
+		  F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nr, tmp_data, nr, anorm,
+					     rcon, pz, piz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    rcon = 0.0;
+		}
+	    }
+
+	  if (typ == MatrixType::Full)
+	    {
+	      octave_idx_type info = 0;
+
+	      Array<octave_idx_type> ipvt (nr);
+	      octave_idx_type *pipvt = ipvt.fortran_vec ();
+
+	      if(anorm < 0.)
+		anorm = atmp.abs().sum().
+		  row(static_cast<octave_idx_type>(0)).max();
+
+	      Array<float> z (4 * nc);
+	      float *pz = z.fortran_vec ();
+	      Array<octave_idx_type> iz (nc);
+	      octave_idx_type *piz = iz.fortran_vec ();
+
+	      F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+
+	      if (info != 0) 
+		{
+		  rcon = 0.0;
+		  mattype.mark_as_rectangular ();
+		}
+	      else 
+		{
+		  char job = '1';
+		  F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
+					     nc, tmp_data, nr, anorm, 
+					     rcon, pz, piz, info
+					     F77_CHAR_ARG_LEN (1)));
+
+		  if (info != 0) 
+		    rcon = 0.0;
+		}
+	    }
+	}
+      else
+	rcon = 0.0;
+    }
+
+  return rcon;
+}
+
 FloatMatrix
 FloatMatrix::utsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-		float& rcond, solve_singularity_handler sing_handler,
+		float& rcon, solve_singularity_handler sing_handler,
 		bool calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
@@ -1338,17 +1503,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Upper ||
 	  typ == MatrixType::Upper)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
+	  rcon = 1.;
 	  info = 0;
 
 	  if (typ == MatrixType::Permuted_Upper)
 	    {
 	      (*current_liboctave_error_handler)
 		("permuted triangular matrix not implemented");
 	    }
 	  else
@@ -1364,37 +1529,37 @@ FloatMatrix::utsolve (MatrixType &mattyp
 		  Array<float> z (3 * nc);
 		  float *pz = z.fortran_vec ();
 		  Array<octave_idx_type> iz (nc);
 		  octave_idx_type *piz = iz.fortran_vec ();
 
 		  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcond,
+					     nr, tmp_data, nr, rcon,
 					     pz, piz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile float rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile float rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  float *result = retval.fortran_vec ();
 
@@ -1417,17 +1582,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::ltsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-		float& rcond, solve_singularity_handler sing_handler,
+		float& rcon, solve_singularity_handler sing_handler,
 		bool calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
@@ -1438,17 +1603,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Permuted_Lower ||
 	  typ == MatrixType::Lower)
 	{
 	  octave_idx_type b_nc = b.cols ();
-	  rcond = 1.;
+	  rcon = 1.;
 	  info = 0;
 
 	  if (typ == MatrixType::Permuted_Lower)
 	    {
 	      (*current_liboctave_error_handler)
 		("permuted triangular matrix not implemented");
 	    }
 	  else
@@ -1464,37 +1629,37 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 		  Array<float> z (3 * nc);
 		  float *pz = z.fortran_vec ();
 		  Array<octave_idx_type> iz (nc);
 		  octave_idx_type *piz = iz.fortran_vec ();
 
 		  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
 					     F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
-					     nr, tmp_data, nr, rcond,
+					     nr, tmp_data, nr, rcon,
 					     pz, piz, info
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile float rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile float rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  float *result = retval.fortran_vec ();
 
@@ -1517,17 +1682,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::fsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-		float& rcond, solve_singularity_handler sing_handler,
+		float& rcon, solve_singularity_handler sing_handler,
 		bool calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr != b.rows ())
@@ -1550,17 +1715,17 @@ FloatMatrix::fsolve (MatrixType &mattype
 	  float *tmp_data = atmp.fortran_vec ();
 	  anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
 	  F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
 				     tmp_data, nr, info
 				     F77_CHAR_ARG_LEN (1)));
 
 	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  rcon = 0.0;
 	  if (info != 0) 
 	    {
 	      info = -2;
 
 	      mattype.mark_as_unsymmetric ();
 	      typ = MatrixType::Full;
 	    }
 	  else 
@@ -1569,34 +1734,34 @@ FloatMatrix::fsolve (MatrixType &mattype
 		{
 		  Array<float> z (3 * nc);
 		  float *pz = z.fortran_vec ();
 		  Array<octave_idx_type> iz (nc);
 		  octave_idx_type *piz = iz.fortran_vec ();
 
 		  F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nr, tmp_data, nr, anorm,
-					     rcond, pz, piz, info
+					     rcon, pz, piz, info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile float rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile float rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  float *result = retval.fortran_vec ();
 
@@ -1630,56 +1795,56 @@ FloatMatrix::fsolve (MatrixType &mattype
 	  Array<float> z (4 * nc);
 	  float *pz = z.fortran_vec ();
 	  Array<octave_idx_type> iz (nc);
 	  octave_idx_type *piz = iz.fortran_vec ();
 
 	  F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
 	  // Throw-away extra info LAPACK gives so as to not change output.
-	  rcond = 0.0;
+	  rcon = 0.0;
 	  if (info != 0) 
 	    {
 	      info = -2;
 
 	      if (sing_handler)
-		sing_handler (rcond);
+		sing_handler (rcon);
 	      else
 		(*current_liboctave_error_handler)
 		  ("matrix singular to machine precision");
 
 	      mattype.mark_as_rectangular ();
 	    }
 	  else 
 	    {
 	      if (calc_cond)
 		{
 		  // Now calculate the condition number for 
 		  // non-singular matrix.
 		  char job = '1';
 		  F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
 					     nc, tmp_data, nr, anorm, 
-					     rcond, pz, piz, info
+					     rcon, pz, piz, info
 					     F77_CHAR_ARG_LEN (1)));
 
 		  if (info != 0) 
 		    info = -2;
 
-		  volatile float rcond_plus_one = rcond + 1.0;
-
-		  if (rcond_plus_one == 1.0 || xisnan (rcond))
+		  volatile float rcond_plus_one = rcon + 1.0;
+
+		  if (rcond_plus_one == 1.0 || xisnan (rcon))
 		    {
 		      info = -2;
 
 		      if (sing_handler)
-			sing_handler (rcond);
+			sing_handler (rcon);
 		      else
 			(*current_liboctave_error_handler)
 			  ("matrix singular to machine precision, rcond = %g",
-			   rcond);
+			   rcon);
 		    }
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  float *result = retval.fortran_vec ();
 
@@ -1701,56 +1866,56 @@ FloatMatrix::fsolve (MatrixType &mattype
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (typ, b, info, rcond, 0);
+  float rcon;
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
-	       float& rcond) const
+	       float& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-	       float& rcond, solve_singularity_handler sing_handler,
+	       float& rcon, solve_singularity_handler sing_handler,
 	       bool singular_fallback) const
 {
   FloatMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    retval = utsolve (mattype, b, info, rcond, sing_handler, false);
+    retval = utsolve (mattype, b, info, rcon, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-    retval = ltsolve (mattype, b, info, rcond, sing_handler, false);
+    retval = ltsolve (mattype, b, info, rcon, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
-    retval = fsolve (mattype, b, info, rcond, sing_handler, true);
+    retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return FloatMatrix ();
     }
 
   // Rectangular or one of the above solvers flags a singular matrix
   if (singular_fallback && mattype.type () == MatrixType::Rectangular)
     {
       octave_idx_type rank;
-      retval = lssolve (b, info, rank, rcond);
+      retval = lssolve (b, info, rank, rcon);
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b) const
 {
@@ -1763,59 +1928,59 @@ FloatMatrix::solve (MatrixType &typ, con
   octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, octave_idx_type& info,
-	       float& rcond) const
+	       float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcond);
+  return tmp.solve (typ, b, info, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, octave_idx_type& info,
-	       float& rcond, solve_singularity_handler sing_handler,
+	       float& rcon, solve_singularity_handler sing_handler,
 	       bool singular_fallback) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcond, sing_handler, singular_fallback);
+  return tmp.solve (typ, b, info, rcon, sing_handler, singular_fallback);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b) const
 {
-  octave_idx_type info; float rcond;
-  return solve (typ, b, info, rcond);
+  octave_idx_type info; float rcon;
+  return solve (typ, b, info, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
 	       octave_idx_type& info) const
 {
-  float rcond;
-  return solve (typ, b, info, rcond);
+  float rcon;
+  return solve (typ, b, info, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
-	       float& rcond) const
+	       float& rcon) const
 {
-  return solve (typ, b, info, rcond, 0);
+  return solve (typ, b, info, rcon, 0);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
-	       float& rcond, solve_singularity_handler sing_handler) const
+	       float& rcon, solve_singularity_handler sing_handler) const
 {
   FloatMatrix tmp (b);
-  return solve (typ, tmp, info, rcond, sing_handler).column(static_cast<octave_idx_type> (0));
+  return solve (typ, tmp, info, rcon, sing_handler).column(static_cast<octave_idx_type> (0));
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
@@ -1825,58 +1990,58 @@ FloatMatrix::solve (MatrixType &typ, con
 	       octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-	       octave_idx_type& info, float& rcond) const
+	       octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcond);
+  return tmp.solve (typ, b, info, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-	       octave_idx_type& info, float& rcond,
+	       octave_idx_type& info, float& rcon,
 	       solve_singularity_handler sing_handler) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve(typ, b, info, rcond, sing_handler);
+  return tmp.solve(typ, b, info, rcon, sing_handler);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
-  float rcond;
-  return solve (b, info, rcond, 0);
+  float rcon;
+  return solve (b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info) const
 {
-  float rcond;
-  return solve (b, info, rcond, 0);
+  float rcon;
+  return solve (b, info, rcon, 0);
 }
 
 FloatMatrix
-FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcond) const
+FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
-	       float& rcond, solve_singularity_handler sing_handler) const
+	       float& rcon, solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcond, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
@@ -1884,56 +2049,56 @@ FloatMatrix::solve (const FloatComplexMa
 FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcond) const
+FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcond);
+  return tmp.solve (b, info, rcon);
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcond,
+FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
 	       solve_singularity_handler sing_handler) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcond, sing_handler);
+  return tmp.solve (b, info, rcon, sing_handler);
 }
 
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b) const
 {
-  octave_idx_type info; float rcond;
-  return solve (b, info, rcond);
+  octave_idx_type info; float rcon;
+  return solve (b, info, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info) const
 {
-  float rcond;
-  return solve (b, info, rcond);
+  float rcon;
+  return solve (b, info, rcon);
 }
 
 FloatColumnVector
-FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcond) const
+FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcon, 0);
 }
 
 FloatColumnVector
-FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcond,
+FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
 	       solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcond, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
@@ -1941,58 +2106,58 @@ FloatMatrix::solve (const FloatComplexCo
 FloatComplexColumnVector
 FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcond) const
+FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcond);
+  return tmp.solve (b, info, rcon);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcond,
+FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcon,
 	       solve_singularity_handler sing_handler) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcond, sing_handler);
+  return tmp.solve (b, info, rcon, sing_handler);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
 		 octave_idx_type& rank) const
 {
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-		 octave_idx_type& rank, float &rcond) const
+		 octave_idx_type& rank, float &rcon) const
 {
   FloatMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2000,17 +2165,17 @@ FloatMatrix::lssolve (const FloatMatrix&
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0 || b.cols () == 0)
     retval = FloatMatrix (n, b.cols (), 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
-      rcond = -1.0;
+      rcon = -1.0;
       if (m != n)
 	{
 	  retval = FloatMatrix (maxmn, nrhs, 0.0);
 
 	  for (octave_idx_type j = 0; j < nrhs; j++)
 	    for (octave_idx_type i = 0; i < m; i++)
 	      retval.elem (i, j) = b.elem (i, j);
 	}
@@ -2058,17 +2223,17 @@ FloatMatrix::lssolve (const FloatMatrix&
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcond, rank, work.fortran_vec (),
+				 ps, rcon, rank, work.fortran_vec (),
 				 lwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for DGELSD to operate
       // efficiently.
       if (n >= mnthr)
 	{
@@ -2102,98 +2267,98 @@ FloatMatrix::lssolve (const FloatMatrix&
 	  if (work(0) < lworkaround)
 	    work(0) = lworkaround;
 	}
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork);
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcond, rank,
+				 maxmn, ps, rcon, rank,
 				 work.fortran_vec (), lwork, 
 				 piwork, info));
 
       if (rank < minmn)
 	(*current_liboctave_warning_handler) 
 	  ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
       if (s.elem (0) == 0.0)
-	rcond = 0.0;
+	rcon = 0.0;
       else
-	rcond = s.elem (minmn - 1) / s.elem (0);
+	rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::lssolve (const FloatComplexMatrix& b) const
 {
   FloatComplexMatrix tmp (*this);
   octave_idx_type info;
   octave_idx_type rank;
-  float rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  float rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   octave_idx_type rank;
-  float rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  float rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info, 
 		 octave_idx_type& rank) const
 {
   FloatComplexMatrix tmp (*this);
-  float rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  float rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info, 
-		 octave_idx_type& rank, float& rcond) const
+		 octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.lssolve (b, info, rank, rcond);
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
 		 octave_idx_type& rank) const
 {
-  float rcond;
-  return lssolve (b, info, rank, rcond);
+  float rcon;
+  return lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
-		 octave_idx_type& rank, float &rcond) const
+		 octave_idx_type& rank, float &rcon) const
 {
   FloatColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2201,17 +2366,17 @@ FloatMatrix::lssolve (const FloatColumnV
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0)
     retval = FloatColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
-      rcond = -1.0;
+      rcon = -1.0;
  
       if (m != n)
 	{
 	  retval = FloatColumnVector (maxmn, 0.0);
 
 	  for (octave_idx_type i = 0; i < m; i++)
 	    retval.elem (i) = b.elem (i);
 	}
@@ -2252,78 +2417,78 @@ FloatMatrix::lssolve (const FloatColumnV
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
 	liwork = 1;
       Array<octave_idx_type> iwork (liwork);
       octave_idx_type* piwork = iwork.fortran_vec ();
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-				 ps, rcond, rank, work.fortran_vec (),
+				 ps, rcon, rank, work.fortran_vec (),
 				 lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (lwork);
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
-				 maxmn, ps, rcond, rank,
+				 maxmn, ps, rcon, rank,
 				 work.fortran_vec (), lwork, 
 				 piwork, info));
 
       if (rank < minmn)
 	{
 	  if (rank < minmn)
 	    (*current_liboctave_warning_handler) 
 	      ("dgelsd: rank deficient %dx%d matrix, rank = %d", m, n, rank);
 	  if (s.elem (0) == 0.0)
-	    rcond = 0.0;
+	    rcon = 0.0;
 	  else
-	    rcond = s.elem (minmn - 1) / s.elem (0);
+	    rcon = s.elem (minmn - 1) / s.elem (0);
 	}
 
       retval.resize (n, nrhs);
     }
 
   return retval;
 }
 
 FloatComplexColumnVector
 FloatMatrix::lssolve (const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   octave_idx_type info;
   octave_idx_type rank;
-  float rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  float rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   octave_idx_type rank;
-  float rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  float rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info, 
 		 octave_idx_type& rank) const
 {
   FloatComplexMatrix tmp (*this);
-  float rcond;
-  return tmp.lssolve (b, info, rank, rcond);
+  float rcon;
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info, 
-		 octave_idx_type& rank, float &rcond) const
+		 octave_idx_type& rank, float &rcon) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.lssolve (b, info, rank, rcond);
+  return tmp.lssolve (b, info, rank, rcon);
 }
 
 // Constants for matrix exponential calculation.
 
 static float padec [] =
 {
   5.0000000000000000e-1,
   1.1666666666666667e-1,
@@ -2331,21 +2496,21 @@ static float padec [] =
   1.6025641025641026e-3,
   1.0683760683760684e-4,
   4.8562548562548563e-6,
   1.3875013875013875e-7,
   1.9270852604185938e-9,
 };
 
 static void
-solve_singularity_warning (float rcond)
+solve_singularity_warning (float rcon)
 {
   (*current_liboctave_warning_handler) 
     ("singular matrix encountered in expm calculation, rcond = %g",
-     rcond);
+     rcon);
 }
 
 FloatMatrix
 FloatMatrix::expm (void) const
 {
   FloatMatrix retval;
 
   FloatMatrix m = *this;
@@ -2460,18 +2625,18 @@ FloatMatrix::expm (void) const
   for (octave_idx_type j = 0; j < nc; j++)
     {
       npp.elem (j, j) += 1.0;
       dpp.elem (j, j) += 1.0;
     }
   
   // Compute pade approximation = inverse (dpp) * npp.
 
-  float rcond;
-  retval = dpp.solve (npp, info, rcond, solve_singularity_warning);
+  float rcon;
+  retval = dpp.solve (npp, info, rcon, solve_singularity_warning);
 
   if (info < 0)
     return retval;
 
   // Reverse preconditioning step 3: repeated squaring.
   
   while (sqpow)
     {
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "mx-op-defs.h"
 
 class
 OCTAVE_API
 FloatMatrix : public MArray2<float>
 {
 public:
 
-  typedef void (*solve_singularity_handler) (float rcond);
+  typedef void (*solve_singularity_handler) (float rcon);
 
   FloatMatrix (void) : MArray2<float> () { }
 
   FloatMatrix (octave_idx_type r, octave_idx_type c) : MArray2<float> (r, c) { }
 
   FloatMatrix (octave_idx_type r, octave_idx_type c, float val) : MArray2<float> (r, c, val) { }
 
   FloatMatrix (const dim_vector& dv) : MArray2<float> (dv) { }
@@ -111,158 +111,161 @@ public:
 
   // extract row or column i.
 
   FloatRowVector row (octave_idx_type i) const;
 
   FloatColumnVector column (octave_idx_type i) const;
 
 private:
-  FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info, float& rcond, 
+  FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
 		   int force, int calc_cond) const;
 
-  FloatMatrix finverse (MatrixType &mattype, octave_idx_type& info, float& rcond, 
+  FloatMatrix finverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
 		   int force, int calc_cond) const;
 
 public:
   FloatMatrix inverse (void) const;
   FloatMatrix inverse (octave_idx_type& info) const;
-  FloatMatrix inverse (octave_idx_type& info, float& rcond, int force = 0,
+  FloatMatrix inverse (octave_idx_type& info, float& rcon, int force = 0,
 		  int calc_cond = 1) const;
 
   FloatMatrix inverse (MatrixType &mattype) const;
   FloatMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
-  FloatMatrix inverse (MatrixType &mattype, octave_idx_type& info, float& rcond,
+  FloatMatrix inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
 		  int force = 0, int calc_cond = 1) const;
 
   FloatMatrix pseudo_inverse (float tol = 0.0) const;
 
   FloatComplexMatrix fourier (void) const;
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
 
   FloatDET determinant (void) const;
   FloatDET determinant (octave_idx_type& info) const;
-  FloatDET determinant (octave_idx_type& info, float& rcond, int calc_cond = 1) const;
+  FloatDET determinant (octave_idx_type& info, float& rcon, int calc_cond = 1) const;
+
+  float rcond (void) const;
+  float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   FloatMatrix utsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		  float& rcond, solve_singularity_handler sing_handler,
+		  float& rcon, solve_singularity_handler sing_handler,
 		  bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
   FloatMatrix ltsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		  float& rcond, solve_singularity_handler sing_handler,
+		  float& rcon, solve_singularity_handler sing_handler,
 		  bool calc_cond = false) const;
 
   // Full matrix solvers (lu/cholesky)
   FloatMatrix fsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		 float& rcond, solve_singularity_handler sing_handler,
+		 float& rcon, solve_singularity_handler sing_handler,
 		 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
-		float& rcond) const;
+		float& rcon) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-		float& rcond, solve_singularity_handler sing_handler,
+		float& rcon, solve_singularity_handler sing_handler,
 		bool singular_fallback = true) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
 		       octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcond) const;
+		       octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
-		       octave_idx_type& info, float& rcond,
+		       octave_idx_type& info, float& rcon,
 		       solve_singularity_handler sing_handler,
 		       bool singular_fallback = true) const;
 
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
 		      octave_idx_type& info) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info, float& rcond) const;
+		      octave_idx_type& info, float& rcon) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
-		      octave_idx_type& info, float& rcond,
+		      octave_idx_type& info, float& rcon,
 		      solve_singularity_handler sing_handler) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, 
 			     const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 			     octave_idx_type& info) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info, float& rcond) const;
+			     octave_idx_type& info, float& rcon) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
-			     octave_idx_type& info, float& rcond,
+			     octave_idx_type& info, float& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   FloatMatrix solve (const FloatMatrix& b) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
-  FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcond) const;
-  FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcond,
+  FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
+  FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
 		solve_singularity_handler sing_handler) const;
 
   FloatComplexMatrix solve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcond) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcond,
+  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const;
+  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
 		       solve_singularity_handler sing_handler) const;
 
   FloatColumnVector solve (const FloatColumnVector& b) const;
   FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info) const;
-  FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcond) const;
-  FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcond,
+  FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon) const;
+  FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
 		      solve_singularity_handler sing_handler) const;
 
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			     float& rcond) const;
+			     float& rcon) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			     float& rcond,
+			     float& rcon,
 			     solve_singularity_handler sing_handler) const;
 
   // Singular solvers
   FloatMatrix lssolve (const FloatMatrix& b) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
 		  octave_idx_type& rank) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
-		  octave_idx_type& rank, float& rcond) const;
+		  octave_idx_type& rank, float& rcon) const;
 
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
 			 octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-			 octave_idx_type& rank, float &rcond) const;
+			 octave_idx_type& rank, float &rcon) const;
 
   FloatColumnVector lssolve (const FloatColumnVector& b) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
 			octave_idx_type& rank) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-			octave_idx_type& rank, float& rcond) const;
+			octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b, 
 			       octave_idx_type& info) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
 			       octave_idx_type& info,
 			       octave_idx_type& rank) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b, 
 			       octave_idx_type& info,
-			       octave_idx_type& rank, float& rcond) const;
+			       octave_idx_type& rank, float& rcon) const;
 
   FloatMatrix expm (void) const;
 
   FloatMatrix& operator += (const FloatDiagMatrix& a);
   FloatMatrix& operator -= (const FloatDiagMatrix& a);
 
   // unary operations
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,12 @@
 2008-05-21  David Bateman  <dbateman@free.fr>
 
+	* DLD-FUNCTIONS/rcond.cc (Frcond): Add support for single precision.
+
 	* DLD-FUNCTIONS/sqrt.m: Replace DBL_* with FLT_* for single
 	precision types.
 	* data.cc (static octave_value fill_matrix (const
 	octave_value_list&, double, float, const char *)): Add function
 	with additional argument to allow for different valid for double
 	and single precision.
 	(Finf, FNaN, FNA, Frealmax, Frealmin): Use it here.
 	(Feps): Modify behavior for a single numerical argument to give
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -46,16 +46,33 @@ instead.\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
   else if (args(0).is_sparse_type ())
     error ("rcond: for sparse matrices use 'rcond (full (a))' or 'condest (a)' instead");
+  else if (args(0).is_single_type ())
+    {
+      if (args(0).is_complex_type ())
+	{
+	  FloatComplexMatrix m = args(0).float_complex_matrix_value ();
+	  MatrixType mattyp;
+	  retval = m.rcond (mattyp);
+	  args(0).matrix_type (mattyp);
+	}
+      else
+	{
+	  FloatMatrix m = args(0).float_matrix_value ();
+	  MatrixType mattyp;
+	  retval = m.rcond (mattyp);
+	  args(0).matrix_type (mattyp);
+	}
+    }
   else if (args(0).is_complex_type ())
     {
       ComplexMatrix m = args(0).complex_matrix_value ();
       MatrixType mattyp;
       retval = m.rcond (mattyp);
       args(0).matrix_type (mattyp);
     }
   else
