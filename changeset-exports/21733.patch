# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463632398 14400
#      Thu May 19 00:33:18 2016 -0400
# Node ID cb0fdd941d84572ceb045cfac80338aa68a27d29
# Parent  6a1eded903559e4f813d2c5ed5ac60dc4554f785
use namespace for system file_ops class

* file-ops.h, file-ops.cc: Put file_ops class and related functions in
octave::sys:: namespace.  Change all uses.

diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -840,17 +840,17 @@ Figure::save_figure_callback (const std:
   Ffeval (ovl ("print", fnum, file));
 }
 
 void
 Figure::copy_figure_callback (const std::string& format)
 {
   std::string msg;
 
-  std::string file = octave_tempnam ("", "oct-", msg) + "." + format;
+  std::string file = octave::sys::tempnam ("", "oct-", msg) + "." + format;
 
   if (file.empty ())
     {
       // Report error?
       return;
     }
 
   save_figure_callback (file);
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -969,23 +969,23 @@ file_editor_tab::bp_info::bp_info (const
   q_function_name.chop (file_info.suffix ().length () + 1);
 
   dir = q_dir.toStdString ();
   function_name = q_function_name.toStdString ();
 
   // Is the last component of DIR @foo?  If so, strip it and prepend it
   // to the name of the function.
 
-  size_t pos = dir.rfind (file_ops::dir_sep_chars ());
+  size_t pos = dir.rfind (octave::sys::file_ops::dir_sep_chars ());
 
   if (pos != std::string::npos && pos < dir.length () - 1)
     {
       if (dir[pos+1] == '@')
         {
-          function_name = file_ops::concat (dir.substr (pos+1), function_name);
+          function_name = octave::sys::file_ops::concat (dir.substr (pos+1), function_name);
 
           dir = dir.substr (0, pos);
         }
     }
 }
 
 void
 file_editor_tab::handle_request_add_breakpoint (int line,
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -48,17 +48,17 @@ along with Octave; see the file COPYING.
 resource_manager *resource_manager::instance = 0;
 
 static QString
 default_qt_settings_file (void)
 {
   std::string dsf = octave::sys::env::getenv ("OCTAVE_DEFAULT_QT_SETTINGS");
 
   if (dsf.empty ())
-    dsf = Voct_etc_dir + file_ops::dir_sep_str () + "default-qt-settings";
+    dsf = Voct_etc_dir + octave::sys::file_ops::dir_sep_str () + "default-qt-settings";
 
   return QString::fromStdString (dsf);
 }
 
 resource_manager::resource_manager (void)
   : settings_directory (), settings_file (), settings (0),
     default_settings (0)
 {
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -181,22 +181,22 @@ get_user_code (const std::string& fname 
   octave_user_code *dbg_fcn = 0;
 
   if (fname.empty ())
     dbg_fcn = octave_call_stack::debug_user_code ();
   else
     {
       std::string name = fname;
 
-      if (file_ops::dir_sep_char () != '/' && name[0] == '@')
+      if (octave::sys::file_ops::dir_sep_char () != '/' && name[0] == '@')
         {
           int len = name.length () - 1;         // -1: can't have trailing '/'
           for (int i = 2; i < len; i++)         //  2: can't have @/method
             if (name[i] == '/')
-              name[i] = file_ops::dir_sep_char ();
+              name[i] = octave::sys::file_ops::dir_sep_char ();
         }
 
       size_t name_len = name.length ();
 
       if (! name.empty () && name_len > 2 && name.substr (name_len-2) == ".m")
         name = name.substr (0, name_len-2);
 
       octave_value fcn = symbol_table::find_function (name);
@@ -1490,17 +1490,17 @@ The @qcode{\"warn\"} field is set simila
       for (bp_table::const_fname_bp_map_iterator it = bp_list.begin ();
            it != bp_list.end (); it++)
         {
           std::string filename = it->first;
           const char *sub_fun = strchr (filename.c_str (), Vfilemarker);
           if (sub_fun)
             filename = filename.substr(0, sub_fun - filename.c_str ());
           octave_value path_name;
-          path_name = octave_canonicalize_file_name (do_which (filename));
+          path_name = octave::sys::canonicalize_file_name (do_which (filename));
 
           for (std::list<bp_type>::const_iterator j = it->second.begin ();
                j != it->second.end (); j++)
             {
               names(i) = it->first;
               file(i) = path_name;
               line(i) = octave_value (j->line);
               cond(i) = octave_value (j->cond);
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -109,19 +109,19 @@ subst_octave_home (const std::string& s)
   if (Voctave_home != prefix)
     {
       octave_idx_type len = prefix.length ();
 
       if (s.substr (0, len) == prefix)
         retval.replace (0, len, Voctave_home);
     }
 
-  if (file_ops::dir_sep_char () != '/')
+  if (octave::sys::file_ops::dir_sep_char () != '/')
     std::replace (retval.begin (), retval.end (), '/',
-                  file_ops::dir_sep_char ());
+                  octave::sys::file_ops::dir_sep_char ());
 
   return retval;
 }
 
 static void
 set_octave_home (void)
 {
   std::string oh = octave::sys::env::getenv ("OCTAVE_HOME");
@@ -404,17 +404,17 @@ static void
 set_built_in_docstrings_file (void)
 {
   if (Vbuilt_in_docstrings_file.empty ())
     {
       std::string df = octave::sys::env::getenv ("OCTAVE_BUILT_IN_DOCSTRINGS_FILE");
 
       if (df.empty ())
         Vbuilt_in_docstrings_file
-          = Voct_etc_dir + file_ops::dir_sep_str () + "built-in-docstrings";
+          = Voct_etc_dir + octave::sys::file_ops::dir_sep_str () + "built-in-docstrings";
       else
         Vbuilt_in_docstrings_file = df;
     }
 }
 
 void
 install_defaults (void)
 {
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -66,17 +66,17 @@ along with Octave; see the file COPYING.
 static bool Vconfirm_recursive_rmdir = true;
 
 // The time we last time we changed directories.
 octave::sys::time Vlast_chdir_time = 0.0;
 
 static int
 octave_change_to_directory (const std::string& newdir)
 {
-  std::string xdir = file_ops::tilde_expand (newdir);
+  std::string xdir = octave::sys::file_ops::tilde_expand (newdir);
 
   int cd_ok = octave::sys::env::chdir (xdir);
 
   if (! cd_ok)
     error ("%s: %s", newdir.c_str (), gnulib::strerror (errno));
 
   Vlast_chdir_time.stamp ();
 
@@ -213,35 +213,35 @@ Internal function called by mkdir.m.\n\
 
   std::string dirname;
 
   if (nargin == 2)
     {
       std::string parent = args(0).xstring_value ("mkdir: PARENT must be a string");
       std::string dir = args(1).xstring_value ("mkdir: DIR must be a string");
 
-      dirname = file_ops::concat (parent, dir);
+      dirname = octave::sys::file_ops::concat (parent, dir);
     }
   else if (nargin == 1)
     dirname = args(0).xstring_value ("mkdir: DIR must be a string");
 
-  dirname = file_ops::tilde_expand (dirname);
+  dirname = octave::sys::file_ops::tilde_expand (dirname);
 
   file_stat fs (dirname);
 
   if (fs && fs.is_dir ())
     {
       // For Matlab compatibility, return true when directory already exists.
       return ovl (true, "directory exists", "mkdir");
     }
   else
     {
       std::string msg;
 
-      int status = octave_mkdir (dirname, 0777, msg);
+      int status = octave::sys::mkdir (dirname, 0777, msg);
 
       if (status < 0)
         return ovl (false, msg, "mkdir");
       else
         return ovl (true, "", "");
     }
 }
 
@@ -265,17 +265,17 @@ identifier.\n\
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string dirname = args(0).xstring_value ("rmdir: DIR must be a string");
 
-  std::string fulldir = file_ops::tilde_expand (dirname);
+  std::string fulldir = octave::sys::file_ops::tilde_expand (dirname);
   int status = -1;
   std::string msg;
 
   if (nargin == 2)
     {
       if (args(1).string_value () != "s")
         error ("rmdir: second argument must be \"s\" for recursive removal");
 
@@ -284,20 +284,20 @@ identifier.\n\
       if (interactive && ! forced_interactive && Vconfirm_recursive_rmdir)
         {
           std::string prompt = "remove entire contents of " + fulldir + "? ";
 
           doit = octave_yes_or_no (prompt);
         }
 
       if (doit)
-        status = octave_recursive_rmdir (fulldir, msg);
+        status = octave::sys::recursive_rmdir (fulldir, msg);
     }
   else
-    status = octave_rmdir (fulldir, msg);
+    status = octave::sys::rmdir (fulldir, msg);
 
   if (status < 0)
     return ovl (false, msg, "rmdir");
   else
     return ovl (true, "", "");
 }
 
 DEFUNX ("link", Flink, args, ,
@@ -315,17 +315,17 @@ error message.\n\
   if (args.length () != 2)
     print_usage ();
 
   std::string from = args(0).xstring_value ("link: OLD must be a string");
   std::string to = args(1).xstring_value ("link: NEW must be a string");
 
   std::string msg;
 
-  int status = octave_link (from, to, msg);
+  int status = octave::sys::link (from, to, msg);
 
   if (status < 0)
     return ovl (-1.0, msg);
   else
     return ovl (status, "");
 }
 
 DEFUNX ("symlink", Fsymlink, args, ,
@@ -343,17 +343,17 @@ error message.\n\
   if (args.length () != 2)
     print_usage ();
 
   std::string from = args(0).xstring_value ("symlink: OLD must be a string");
   std::string to = args(1).xstring_value ("symlink: NEW must be a string");
 
   std::string msg;
 
-  int status = octave_symlink (from, to, msg);
+  int status = octave::sys::symlink (from, to, msg);
 
   if (status < 0)
     return ovl (-1.0, msg);
   else
     return ovl (status, "");
 }
 
 DEFUNX ("readlink", Freadlink, args, ,
@@ -371,17 +371,17 @@ error message.\n\
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string symlink = args(0).xstring_value ("readlink: SYMLINK must be a string");
 
   std::string result, msg;
 
-  int status = octave_readlink (symlink, result, msg);
+  int status = octave::sys::readlink (symlink, result, msg);
 
   if (status < 0)
     return ovl ("", -1.0, msg);
   else
     return ovl (result, status, "");
 }
 
 DEFUNX ("rename", Frename, args, ,
@@ -399,17 +399,17 @@ error message.\n\
   if (args.length () != 2)
     print_usage ();
 
   std::string from = args(0).xstring_value ("rename: OLD must be a string");
   std::string to = args(1).xstring_value ("rename: NEW must be a string");
 
   std::string msg;
 
-  int status = octave_rename (from, to, msg);
+  int status = octave::sys::rename (from, to, msg);
 
   if (status < 0)
     return ovl (-1.0, msg);
   else
     return ovl (status, "");
 }
 
 DEFUN (glob, args, ,
@@ -463,17 +463,17 @@ glob (\"file[12]\")\n\
 @seealso{ls, dir, readdir, what}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   string_vector pat = args(0).xstring_vector_value ("glob: PATTERN must be a string");
 
-  glob_match pattern (file_ops::tilde_expand (pat));
+  glob_match pattern (octave::sys::file_ops::tilde_expand (pat));
 
   return ovl (Cell (pattern.glob ()));
 }
 
 /*
 %!test
 %! tmpdir = tempname;
 %! filename = {"file1", "file2", "file3", "myfile1", "myfile1b"};
@@ -524,17 +524,17 @@ fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \
 @end deftypefn")
 {
   if (args.length () != 2)
     print_usage ();
 
   string_vector pat = args(0).string_vector_value ();
   string_vector str = args(1).string_vector_value ();
 
-  glob_match pattern (file_ops::tilde_expand (pat));
+  glob_match pattern (octave::sys::file_ops::tilde_expand (pat));
 
   return ovl (pattern.match (str));
 }
 
 DEFUN (filesep, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} filesep ()\n\
 @deftypefnx {} {} filesep (\"all\")\n\
@@ -550,24 +550,24 @@ It is @samp{/} (forward slash) under UNI
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   octave_value retval;
 
   if (nargin == 0)
-    retval = file_ops::dir_sep_str ();
+    retval = octave::sys::file_ops::dir_sep_str ();
   else
     {
       std::string s = args(0).xstring_value ("filesep: argument must be a string");
       if (s != "all")
         error ("filesep: argument must be \"all\"");
 
-      retval = file_ops::dir_sep_chars ();
+      retval = octave::sys::file_ops::dir_sep_chars ();
     }
 
   return retval;
 }
 
 DEFUN (pathsep, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} pathsep ()\n\
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -208,17 +208,17 @@ such as text, are also replaced by the @
   std::istream *input = 0;
   std::ifstream input_file;
 
   if (args(0).is_string ())
     {
       // Filename.
       std::string fname (args(0).string_value ());
 
-      std::string tname = file_ops::tilde_expand (fname);
+      std::string tname = octave::sys::file_ops::tilde_expand (fname);
 
       tname = find_data_file_in_load_path ("dlmread", tname);
 
       input_file.open (tname.c_str (), std::ios::in);
 
       if (! input_file)
         error ("dlmread: unable to open file '%s'", fname.c_str ());
 
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -445,17 +445,17 @@ do_stream_open (const std::string& name,
   bool use_zlib = false;
   normalize_fopen_mode (mode, use_zlib);
 
   std::ios::openmode md = fopen_mode_to_ios_mode (mode);
 
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::string_to_float_format (arch);
 
-  std::string fname = file_ops::tilde_expand (name);
+  std::string fname = octave::sys::file_ops::tilde_expand (name);
 
   file_stat fs (fname);
 
   if (! (md & std::ios::out))
     fname = find_data_file_in_load_path ("fopen", fname);
 
   if (! fs.is_dir ())
     {
@@ -2760,17 +2760,17 @@ see @code{tmpfile}.\n\
   if (nargin > 0)
     dir = args(0).xstring_value ("tempname: DIR must be a string");
 
   std::string pfx ("oct-");
 
   if (nargin > 1)
     pfx = args(1).xstring_value ("tempname: PREFIX must be a string");
 
-  return ovl (octave_tempnam (dir, pfx));
+  return ovl (octave::sys::tempnam (dir, pfx));
 }
 
 /*
 %!test
 %! if (ispc ())
 %!   envname = "TMP";
 %! else
 %!   envname = "TMPDIR";
@@ -2991,17 +2991,17 @@ for the new object are @code{@var{mode} 
 
   int mask = args(0).xint_value ("umask: MASK must be an integer");
 
   if (mask < 0)
     error ("umask: MASK must be a positive integer value");
 
   int oct_mask = convert (mask, 8, 10);
 
-  int status = convert (octave_umask (oct_mask), 10, 8);
+  int status = convert (octave::sys::umask (oct_mask), 10, 8);
 
   if (status >= 0)
     return ovl (status);
   else
     return ovl ();
 }
 
 static octave_value
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -10794,17 +10794,17 @@ undocumented.\n\
           file = args(1).xstring_value ("drawnow: FILE must be a string");
 
           if (file.empty ())
             error ("drawnow: empty output ''");
           else if (file.length () == 1 && file[0] == '|')
             error ("drawnow: empty pipe '|'");
           else if (file[0] != '|')
             {
-              size_t pos = file.find_last_of (file_ops::dir_sep_chars ());
+              size_t pos = file.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
               if (pos != std::string::npos)
                 {
                   std::string dirname = file.substr (0, pos+1);
 
                   file_stat fs (dirname);
 
                   if (! fs || ! fs.is_dir ())
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1305,22 +1305,22 @@ Undocumented internal function.\n\
 // FIXME: Are we sure this function always does the right thing?
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
 {
   if (filename.find (dir) == 0)
     {
       const int dir_len = dir.size ();
       const int filename_len = filename.size ();
-      const int max_allowed_seps = file_ops::is_dir_sep (dir[dir_len-1]) ? 0
+      const int max_allowed_seps = octave::sys::file_ops::is_dir_sep (dir[dir_len-1]) ? 0
                                                                          : 1;
 
       int num_seps = 0;
       for (int i = dir_len; i < filename_len; i++)
-        if (file_ops::is_dir_sep (filename[i]))
+        if (octave::sys::file_ops::is_dir_sep (filename[i]))
           num_seps++;
 
       return (num_seps <= max_allowed_seps);
     }
   else
     return false;
 }
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -190,17 +190,17 @@ load_path::dir_info::get_file_list (cons
 
       octave_idx_type all_files_count = 0;
       octave_idx_type fcn_files_count = 0;
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           std::string fname = flist[i];
 
-          std::string full_name = file_ops::concat (d, fname);
+          std::string full_name = octave::sys::file_ops::concat (d, fname);
 
           file_stat fs (full_name);
 
           if (fs)
             {
               if (fs.is_dir ())
                 {
                   if (fname == "private")
@@ -299,17 +299,17 @@ load_path::dir_info::get_private_file_ma
 }
 
 void
 load_path::dir_info::get_method_file_map (const std::string& d,
                                           const std::string& class_name)
 {
   method_file_map[class_name].method_file_map = get_fcn_files (d);
 
-  std::string pd = file_ops::concat (d, "private");
+  std::string pd = octave::sys::file_ops::concat (d, "private");
 
   file_stat fs (pd);
 
   if (fs && fs.is_dir ())
     method_file_map[class_name].private_file_map = get_fcn_files (pd);
 }
 
 void
@@ -338,17 +338,17 @@ load_path::instance_ok (void)
   return retval;
 }
 
 // FIXME: maybe we should also maintain a map to speed up this method of access.
 
 load_path::const_dir_info_list_iterator
 load_path::find_dir_info (const std::string& dir_arg) const
 {
-  std::string dir = file_ops::tilde_expand (dir_arg);
+  std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
 
   const_dir_info_list_iterator retval = dir_info_list.begin ();
 
   while (retval != dir_info_list.end ())
     {
       if (retval->dir_name == dir)
         break;
 
@@ -356,17 +356,17 @@ load_path::find_dir_info (const std::str
     }
 
   return retval;
 }
 
 load_path::dir_info_list_iterator
 load_path::find_dir_info (const std::string& dir_arg)
 {
-  std::string dir = file_ops::tilde_expand (dir_arg);
+  std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
 
   dir_info_list_iterator retval = dir_info_list.begin ();
 
   while (retval != dir_info_list.end ())
     {
       if (retval->dir_name == dir)
         break;
 
@@ -457,17 +457,17 @@ load_path::loader::move_method_map (cons
        i != method_map.end ();
        i++)
     {
       std::string class_name = i->first;
 
       fcn_map_type& fm = i->second;
 
       std::string full_dir_name
-        = file_ops::concat (dir_name, "@" + class_name);
+        = octave::sys::file_ops::concat (dir_name, "@" + class_name);
 
       for (fcn_map_iterator q = fm.begin (); q != fm.end (); q++)
         {
           file_info_list_type& file_info_list = q->second;
 
           if (file_info_list.size () == 1)
             continue;
           else
@@ -724,17 +724,17 @@ load_path::do_prepend (const std::string
 
 static std::string
 strip_trailing_separators (const std::string& dir_arg)
 {
   std::string dir = dir_arg;
 
   size_t k = dir.length ();
 
-  while (k > 1 && file_ops::is_dir_sep (dir[k-1]))
+  while (k > 1 && octave::sys::file_ops::is_dir_sep (dir[k-1]))
     k--;
 
   if (k < dir.length ())
     dir.resize (k);
 
   return dir;
 }
 
@@ -742,17 +742,17 @@ void
 load_path::do_add (const std::string& dir_arg, bool at_end, bool warn)
 {
   size_t len = dir_arg.length ();
 
   if (len > 1 && dir_arg.substr (len-2) == "//")
     warning_with_id ("Octave:recursive-path-search",
                      "trailing '//' is no longer special in search path elements");
 
-  std::string dir = file_ops::tilde_expand (dir_arg);
+  std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
 
   dir = strip_trailing_separators (dir);
 
   dir_info_list_iterator i = find_dir_info (dir);
 
   if (i != dir_info_list.end ())
     do_move (i, at_end);
   else
@@ -848,17 +848,17 @@ load_path::loader::remove_method_map (co
   for (method_map_iterator i = method_map.begin ();
        i != method_map.end ();
        i++)
     {
       std::string class_name = i->first;
 
       fcn_map_type& fm = i->second;
 
-      std::string full_dir_name = file_ops::concat (dir, "@" + class_name);
+      std::string full_dir_name = octave::sys::file_ops::concat (dir, "@" + class_name);
 
       for (fcn_map_iterator q = fm.begin (); q != fm.end (); q++)
         {
           file_info_list_type& file_info_list = q->second;
 
           if (file_info_list.size () == 1)
             continue;
           else
@@ -893,17 +893,17 @@ load_path::do_remove (const std::string&
         {
           warning ("rmpath: can't remove \".\" from path");
 
           // Avoid additional warnings.
           retval = true;
         }
       else
         {
-          std::string dir = file_ops::tilde_expand (dir_arg);
+          std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
 
           dir = strip_trailing_separators (dir);
 
           dir_info_list_iterator i = find_dir_info (dir);
 
           if (i != dir_info_list.end ())
             {
               retval = true;
@@ -1110,17 +1110,17 @@ load_path::loader::find_fcn (const std::
           const file_info_list_type& file_info_list = p->second;
 
           for (const_file_info_list_iterator i = file_info_list.begin ();
                i != file_info_list.end ();
                i++)
             {
               const file_info& fi = *i;
 
-              retval = file_ops::concat (fi.dir_name, fcn);
+              retval = octave::sys::file_ops::concat (fi.dir_name, fcn);
 
               if (check_file_type (retval, type, fi.types,
                                    fcn, "load_path::do_find_fcn"))
                 {
                   dir_name = fi.dir_name;
                   break;
                 }
               else
@@ -1146,17 +1146,17 @@ load_path::loader::find_private_fcn (con
     {
       const dir_info::fcn_file_map_type& m = q->second;
 
       dir_info::const_fcn_file_map_iterator p = m.find (fcn);
 
       if (p != m.end ())
         {
           std::string fname
-            = file_ops::concat (file_ops::concat (dir, "private"), fcn);
+            = octave::sys::file_ops::concat (octave::sys::file_ops::concat (dir, "private"), fcn);
 
           if (check_file_type (fname, type, p->second, fcn,
                                "load_path::find_private_fcn"))
             retval = fname;
         }
     }
 
   return retval;
@@ -1186,17 +1186,17 @@ load_path::loader::find_method (const st
           const file_info_list_type& file_info_list = p->second;
 
           for (const_file_info_list_iterator i = file_info_list.begin ();
                i != file_info_list.end ();
                i++)
             {
               const file_info& fi = *i;
 
-              retval = file_ops::concat (fi.dir_name, meth);
+              retval = octave::sys::file_ops::concat (fi.dir_name, meth);
 
               bool found = check_file_type (retval, type, fi.types,
                                             meth, "load_path::do_find_method");
 
               if (found)
                 {
                   dir_name = fi.dir_name;
                   break;
@@ -1302,18 +1302,18 @@ find_private_file (const std::string& fn
       // Even for private functions, dir_name doesn't contain the
       // "private" directory component so we append it here in all
       // cases.
 
       std::string dir_name = curr_fcn->dir_name ();
 
       if (! dir_name.empty ())
         {
-          std::string pfname = dir_name + file_ops::dir_sep_str ()
-                               + "private" + file_ops::dir_sep_str () + fname;
+          std::string pfname = dir_name + octave::sys::file_ops::dir_sep_str ()
+                               + "private" + octave::sys::file_ops::dir_sep_str () + fname;
 
           file_stat fs (pfname);
 
           if (fs.exists () && fs.is_reg ())
             retval = pfname;
         }
     }
 
@@ -1335,26 +1335,26 @@ load_path::do_find_file (const std::stri
   else
     {
       std::string tfile = find_private_file (file);
 
       if (! tfile.empty ())
         return tfile;
     }
 
-  if (file.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos)
+  if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos)
     {
       // Given name has a directory separator, so append it to each
       // element of the load path in turn.
 
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
            p++)
         {
-          std::string tfile = file_ops::concat (p->dir_name, file);
+          std::string tfile = octave::sys::file_ops::concat (p->dir_name, file);
 
           file_stat fs (tfile);
 
           if (fs.exists ())
             return tfile;
         }
     }
   else
@@ -1367,30 +1367,30 @@ load_path::do_find_file (const std::stri
         {
           string_vector all_files = p->all_files;
 
           octave_idx_type len = all_files.numel ();
 
           for (octave_idx_type i = 0; i < len; i++)
             {
               if (all_files[i] == file)
-                return file_ops::concat (p->dir_name, file);
+                return octave::sys::file_ops::concat (p->dir_name, file);
             }
         }
     }
 
   return retval;
 }
 
 std::string
 load_path::do_find_dir (const std::string& dir) const
 {
   std::string retval;
 
-  if (dir.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos
+  if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
       && (octave::sys::env::absolute_pathname (dir)
           || octave::sys::env::rooted_relative_pathname (dir)))
     {
       file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
         return dir;
     }
@@ -1399,26 +1399,26 @@ load_path::do_find_dir (const std::strin
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
            p++)
         {
           std::string dname = octave::sys::env::make_absolute (p->dir_name);
 
           size_t dname_len = dname.length ();
 
-          if (dname.substr (dname_len - 1) == file_ops::dir_sep_str ())
+          if (dname.substr (dname_len - 1) == octave::sys::file_ops::dir_sep_str ())
             {
               dname = dname.substr (0, dname_len - 1);
               dname_len--;
             }
 
           size_t dir_len = dir.length ();
 
           if (dname_len > dir_len
-              && file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
+              && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
               && dir == dname.substr (dname_len - dir_len))
             {
               file_stat fs (p->dir_name);
 
               if (fs.exists () && fs.is_dir ())
                 return p->dir_name;
             }
         }
@@ -1427,17 +1427,17 @@ load_path::do_find_dir (const std::strin
   return retval;
 }
 
 string_vector
 load_path::do_find_matching_dirs (const std::string& dir) const
 {
   std::list<std::string> retlist;
 
-  if (dir.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos
+  if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
       && (octave::sys::env::absolute_pathname (dir)
           || octave::sys::env::rooted_relative_pathname (dir)))
     {
       file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
         retlist.push_back (dir);
     }
@@ -1446,26 +1446,26 @@ load_path::do_find_matching_dirs (const 
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
            p++)
         {
           std::string dname = octave::sys::env::make_absolute (p->dir_name);
 
           size_t dname_len = dname.length ();
 
-          if (dname.substr (dname_len - 1) == file_ops::dir_sep_str ())
+          if (dname.substr (dname_len - 1) == octave::sys::file_ops::dir_sep_str ())
             {
               dname = dname.substr (0, dname_len - 1);
               dname_len--;
             }
 
           size_t dir_len = dir.length ();
 
           if (dname_len > dir_len
-              && file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
+              && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
               && dir == dname.substr (dname_len - dir_len))
             {
               file_stat fs (p->dir_name);
 
               if (fs.exists () && fs.is_dir ())
                 retlist.push_back (p->dir_name);
             }
         }
@@ -1486,33 +1486,33 @@ load_path::do_find_first_of (const strin
   octave_idx_type rel_flen = 0;
 
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       std::string file = flist[i];
 
-      if (file.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos)
+      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos)
         {
           if (octave::sys::env::absolute_pathname (file)
               || octave::sys::env::rooted_relative_pathname (file))
             {
               file_stat fs (file);
 
               if (fs.exists ())
                 return file;
             }
           else
             {
               for (const_dir_info_list_iterator p = dir_info_list.begin ();
                    p != dir_info_list.end ();
                    p++)
                 {
-                  std::string tfile = file_ops::concat (p->dir_name, file);
+                  std::string tfile = octave::sys::file_ops::concat (p->dir_name, file);
 
                   file_stat fs (tfile);
 
                   if (fs.exists ())
                     return tfile;
                 }
             }
         }
@@ -1543,17 +1543,17 @@ load_path::do_find_first_of (const strin
                 }
             }
         }
     }
 
 done:
 
   if (! dir_name.empty ())
-    retval = file_ops::concat (dir_name, file_name);
+    retval = octave::sys::file_ops::concat (dir_name, file_name);
 
   return retval;
 }
 
 string_vector
 load_path::do_find_all_first_of (const string_vector& flist) const
 {
   std::list<std::string> retlist;
@@ -1565,33 +1565,33 @@ load_path::do_find_all_first_of (const s
   octave_idx_type rel_flen = 0;
 
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       std::string file = flist[i];
 
-      if (file.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos)
+      if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos)
         {
           if (octave::sys::env::absolute_pathname (file)
               || octave::sys::env::rooted_relative_pathname (file))
             {
               file_stat fs (file);
 
               if (fs.exists ())
                 retlist.push_back (file);
             }
           else
             {
               for (const_dir_info_list_iterator p = dir_info_list.begin ();
                    p != dir_info_list.end ();
                    p++)
                 {
-                  std::string tfile = file_ops::concat (p->dir_name, file);
+                  std::string tfile = octave::sys::file_ops::concat (p->dir_name, file);
 
                   file_stat fs (tfile);
 
                   if (fs.exists ())
                     retlist.push_back (tfile);
                 }
             }
         }
@@ -1608,17 +1608,17 @@ load_path::do_find_all_first_of (const s
 
       octave_idx_type len = all_files.numel ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           for (octave_idx_type j = 0; j < rel_flen; j++)
             {
               if (all_files[i] == rel_flist[j])
-                retlist.push_back (file_ops::concat (p->dir_name,
+                retlist.push_back (octave::sys::file_ops::concat (p->dir_name,
                                                      rel_flist[j]));
             }
         }
     }
 
   return retlist;
 }
 
@@ -1931,17 +1931,17 @@ load_path::loader::add_to_fcn_map (const
           // but not if we are just updating (rehashing) the list.
 
           if (! updating)
             {
               if (file_info_list.empty ())
                 {
                   if (symbol_table::is_built_in_function_name (base))
                     {
-                      std::string fcn_path = file_ops::concat (dir_name, fname);
+                      std::string fcn_path = octave::sys::file_ops::concat (dir_name, fname);
 
                       warning_with_id ("Octave:shadowed-function",
                                        "function %s shadows a built-in function",
                                        fcn_path.c_str ());
                     }
                 }
               else if (! at_end)
                 {
@@ -1953,17 +1953,17 @@ load_path::loader::add_to_fcn_map (const
 
                   // Don't warn about Contents.m files since we expect
                   // more than one to exist in the load path.
 
                   if (fname != "Contents.m"
                       && sys_path.find (old.dir_name) != std::string::npos
                       && in_path_list (sys_path, old.dir_name))
                     {
-                      std::string fcn_path = file_ops::concat (dir_name, fname);
+                      std::string fcn_path = octave::sys::file_ops::concat (dir_name, fname);
 
                       warning_with_id ("Octave:shadowed-function",
                                        "function %s shadows a core library function",
                                        fcn_path.c_str ());
                     }
                 }
             }
 
@@ -2004,17 +2004,17 @@ load_path::loader::add_to_method_map (co
        q != method_file_map.end ();
        q++)
     {
       std::string class_name = q->first;
 
       fcn_map_type& fm = method_map[class_name];
 
       std::string full_dir_name
-        = file_ops::concat (dir_name, "@" + class_name);
+        = octave::sys::file_ops::concat (dir_name, "@" + class_name);
 
       const dir_info::class_info& ci = q->second;
 
       // <FCN_NAME, TYPES>
       const dir_info::fcn_file_map_type& m = ci.method_file_map;
 
       for (dir_info::const_fcn_file_map_iterator p = m.begin ();
            p != m.end ();
@@ -2072,17 +2072,17 @@ load_path::loader::display (std::ostream
        s != dir_list.end (); ++s)
     os << *s << "\n";
   os << "\n";
 
   for (const_private_fcn_map_iterator i = private_fcn_map.begin ();
        i != private_fcn_map.end (); i++)
     {
       os << "\n*** private functions in "
-         << file_ops::concat (i->first, "private") << ":\n\n";
+         << octave::sys::file_ops::concat (i->first, "private") << ":\n\n";
 
       print_fcn_list (os, i->second);
     }
 
 #if defined (DEBUG_LOAD_PATH)
 
   for (const_fcn_map_iterator i = fcn_map.begin ();
        i != fcn_map.end ();
@@ -2166,17 +2166,17 @@ genpath (const std::string& dirname, con
                 {
                   skip_p = (elt == skip[j]);
                   if (skip_p)
                     break;
                 }
 
               if (! skip_p)
                 {
-                  std::string nm = file_ops::concat (dirname, elt);
+                  std::string nm = octave::sys::file_ops::concat (dirname, elt);
 
                   file_stat fs (nm);
 
                   if (fs && fs.is_dir ())
                     retval += dir_path::path_sep_str () + genpath (nm, skip);
                 }
             }
         }
@@ -2204,17 +2204,17 @@ static void
 execute_pkg_add_or_del (const std::string& dir,
                         const std::string& script_file)
 {
   if (! octave_interpreter_ready)
     return;
 
   unwind_protect frame;
 
-  std::string file = file_ops::concat (dir, script_file);
+  std::string file = octave::sys::file_ops::concat (dir, script_file);
 
   file_stat fs (file);
 
   if (fs.exists ())
     source_file (file, "base");
 }
 
 void
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -489,17 +489,17 @@ do_load (std::istream& stream, const std
 }
 
 std::string
 find_file_to_load (const std::string& name, const std::string& orig_name)
 {
   std::string fname = find_data_file_in_load_path ("load", name, true);
 
   size_t dot_pos = fname.rfind (".");
-  size_t sep_pos = fname.find_last_of (file_ops::dir_sep_chars ());
+  size_t sep_pos = fname.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
   if (dot_pos == std::string::npos
       || (sep_pos != std::string::npos && dot_pos < sep_pos))
     {
       // Either no '.' in name or no '.' appears after last directory
       // separator.
 
       file_stat fs (fname);
@@ -744,17 +744,17 @@ Force Octave to assume the file is in Oc
                             list_only, swap, verbose, argv, i, argc,
                             nargout);
         }
       else
         error ("load: must specify file format if reading from stdin");
     }
   else
     {
-      std::string fname = file_ops::tilde_expand (orig_fname);
+      std::string fname = octave::sys::file_ops::tilde_expand (orig_fname);
 
       fname = find_file_to_load (fname, orig_fname);
 
       bool use_zlib = false;
 
       if (format == LS_UNKNOWN)
         format = get_file_format (fname, orig_fname, use_zlib);
 
@@ -1629,17 +1629,17 @@ the file @file{data} in Octave's binary 
     }
 
   // Guard against things like 'save a*', which are probably mistakes...
 
   else if (i == argc - 1 && glob_pattern_p (argv[i]))
     print_usage ();
   else
     {
-      std::string fname = file_ops::tilde_expand (argv[i]);
+      std::string fname = octave::sys::file_ops::tilde_expand (argv[i]);
 
       i++;
 
       // Matlab v7 files are always compressed
       if (format == LS_MAT7_BINARY)
         use_zlib = false;
 
       std::ios::openmode mode
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -876,17 +876,17 @@ read_mat5_binary_element (std::istream& 
                     // First check if just replacing matlabroot is enough
                     std::string str = OCTAVE_EXEC_PREFIX +
                                       fpath.substr (mroot.length ());
                     file_stat fs (str);
 
                     if (fs.exists ())
                       {
                         size_t xpos
-                          = str.find_last_of (file_ops::dir_sep_chars ());
+                          = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
                           = load_fcn_from_file (str, dir_name, "", "", fname);
 
                         if (fcn)
                           {
@@ -905,17 +905,17 @@ read_mat5_binary_element (std::istream& 
                         names(2) = fname + ".m";
 
                         dir_path p (load_path::system_path ());
 
                         str =
                           octave::sys::env::make_absolute (p.find_first_of (names));
 
                         size_t xpos
-                          = str.find_last_of (file_ops::dir_sep_chars ());
+                          = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
                           = load_fcn_from_file (str, dir_name, "", "", fname);
 
                         if (fcn)
                           {
@@ -930,17 +930,17 @@ read_mat5_binary_element (std::istream& 
                                      fpath.c_str ());
                             goto skip_ahead;
                           }
                       }
                   }
                 else
                   {
                     size_t xpos
-                      = fpath.find_last_of (file_ops::dir_sep_chars ());
+                      = fpath.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
                     std::string dir_name = fpath.substr (0, xpos);
 
                     octave_function *fcn
                       = load_fcn_from_file (fpath, dir_name, "", "", fname);
 
                     if (fcn)
                       {
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -78,17 +78,17 @@ default_history_file (void)
   std::string file;
 
   std::string env_file = octave::sys::env::getenv ("OCTAVE_HISTFILE");
 
   if (! env_file.empty ())
     file = env_file;
 
   if (file.empty ())
-    file = file_ops::concat (octave::sys::env::get_home_directory (),
+    file = octave::sys::file_ops::concat (octave::sys::env::get_home_directory (),
                              ".octave_hist");
 
   return file;
 }
 
 static int
 default_history_size (void)
 {
@@ -406,17 +406,17 @@ mk_tmp_hist_file (const octave_value_lis
     error ("%s: history specification out of range", warn_for);
 
   if (hist_end < hist_beg)
     {
       std::swap (hist_end, hist_beg);
       reverse = true;
     }
 
-  std::string name = octave_tempnam ("", "oct-");
+  std::string name = octave::sys::tempnam ("", "oct-");
 
   std::fstream file (name.c_str (), std::ios::out);
 
   if (! file)
     error ("%s: couldn't open temporary file '%s'", warn_for,
            name.c_str ());
 
   if (reverse)
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -392,17 +392,17 @@ symbol_table::fcn_info::fcn_info_rep::lo
   if (! file_name.empty ())
     {
       octave_function *fcn = load_fcn_from_file (file_name, dir_name);
 
       if (fcn)
         {
           std::string class_name;
 
-          size_t pos = dir_name.find_last_of (file_ops::dir_sep_chars ());
+          size_t pos = dir_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           if (pos != std::string::npos)
             {
               std::string tmp = dir_name.substr (pos+1);
 
               if (tmp[0] == '@')
                 class_name = tmp.substr (1);
             }
@@ -1052,17 +1052,17 @@ symbol_table::fcn_info::fcn_info_rep::fi
     out_of_date_check (autoload_function);
 
   if (! autoload_function.is_defined ())
     {
       std::string file_name = lookup_autoload (name);
 
       if (! file_name.empty ())
         {
-          size_t pos = file_name.find_last_of (file_ops::dir_sep_chars ());
+          size_t pos = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = file_name.substr (0, pos);
 
           octave_function *fcn = load_fcn_from_file (file_name, dir_name, "",
                                                      "", name, true);
 
           if (fcn)
             autoload_function = octave_value (fcn);
@@ -1278,20 +1278,20 @@ symbol_table::find_function (const std::
                              bool local_funcs)
 {
   octave_value retval;
 
   if (! name.empty () && name[0] == '@')
     {
       // Look for a class specific function.
       std::string dispatch_type =
-        name.substr (1, name.find_first_of (file_ops::dir_sep_str ()) - 1);
+        name.substr (1, name.find_first_of (octave::sys::file_ops::dir_sep_str ()) - 1);
 
       std::string method;
-      size_t pos = name.find_last_of (file_ops::dir_sep_str ());
+      size_t pos = name.find_last_of (octave::sys::file_ops::dir_sep_str ());
       if (pos != std::string::npos)
         method = name.substr (pos + 1);
 
       retval = find_method (method, dispatch_type);
     }
   else
     {
       size_t pos = name.find_first_of (Vfilemarker);
@@ -1328,17 +1328,17 @@ symbol_table::find_function (const std::
 
 // look for @class/method>subfunction
 octave_value
 symbol_table::find_submethod (const std::string& name,
                               const std::string& dispatch_type)
 {
   octave_value fcn;
 
-  std::string full_name = "@" + dispatch_type + file_ops::dir_sep_str () + name;
+  std::string full_name = "@" + dispatch_type + octave::sys::file_ops::dir_sep_str () + name;
   size_t pos = full_name.find_first_of (Vfilemarker);
 
   if (pos != std::string::npos)
     {
       std::string fcn_scope = full_name.substr (0, pos);
       scope_id stored_scope = xcurrent_scope;
       xcurrent_scope = xtop_scope;
       octave_value parent = find_function (full_name.substr (0, pos),
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -269,18 +269,18 @@ exit status, it will linger until Octave
     }
 
   bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
 
   int filedesc[2];
   std::string msg;
   pid_t pid;
 
-  pid = octave::sys::popen2 (exec_file, arg_list, sync_mode,
-                                 filedesc, msg, interactive);
+  pid = octave::sys::popen2 (exec_file, arg_list, sync_mode, filedesc,
+                             msg, interactive);
   if (pid < 0)
     error (msg.c_str ());
 
   FILE *ifile = fdopen (filedesc[1], "r");
   FILE *ofile = fdopen (filedesc[0], "w");
 
   octave_stream is = octave_stdiostream::create (exec_file + "-in",
                                                  ifile,
@@ -684,17 +684,17 @@ error message.\n\
 
   if (octal_mode < 0)
     error ("mkfifo: MODE must be a positive integer value");
 
   int mode = convert (octal_mode, 8, 10);
 
   std::string msg;
 
-  int status = octave_mkfifo (name, mode, msg);
+  int status = octave::sys::mkfifo (name, mode, msg);
 
   return ovl (status, msg);
 }
 
 /*
 
 ## Test input validation
 %!error mkfifo ()
@@ -1060,17 +1060,17 @@ error message.\n\
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("unlink: FILE must be a string");
 
   std::string msg;
 
-  int status = octave_unlink (name, msg);
+  int status = octave::sys::unlink (name, msg);
 
   return ovl (status, msg);
 }
 
 DEFUNX ("waitpid", Fwaitpid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {[@var{pid}, @var{status}, @var{msg}] =} waitpid (@var{pid}, @var{options})\n\
 Wait for process @var{pid} to terminate.\n\
@@ -1289,17 +1289,17 @@ If the file does not exist the empty str
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("canonicalize_file_name: NAME must be a string");
 
   std::string msg;
 
-  std::string result = octave_canonicalize_file_name (name, msg);
+  std::string result = octave::sys::canonicalize_file_name (name, msg);
 
   return ovl (result, msg.empty () ? 0 : -1, msg);
 }
 
 static inline octave_value
 const_value (const octave_value_list& args, int val)
 {
   if (args.length () != 0)
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -894,17 +894,17 @@ tilde_expand (\"~/bin\")\n\
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   string_vector sv = arg.xstring_vector_value ("tilde_expand: argument must be char or cellstr object");
 
-  sv = file_ops::tilde_expand (sv);
+  sv = octave::sys::file_ops::tilde_expand (sv);
 
   if (arg.is_cellstr ())
     return ovl (Cell (arg.dims (), sv));
   else
     return ovl (sv);
 }
 
 /*
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #include "oct-map.h"
 #include "oct-refcount.h"
 #include "unwind-prot.h"
 
 static void
 delete_file (const std::string& file)
 {
-  octave_unlink (file);
+  octave::sys::unlink (file);
 }
 
 typedef octave_handle curl_handle;
 
 class OCTINTERP_API ch_manager
 {
 protected:
 
@@ -804,17 +804,17 @@ Undocumented internal function\n\
 
   url_transfer curl = ch_manager::get_object (args(0));
 
   if (! curl.is_valid ())
     error ("__ftp_mput__: invalid ftp handle");
 
   string_vector file_list;
 
-  glob_match pattern (file_ops::tilde_expand (pat));
+  glob_match pattern (octave::sys::file_ops::tilde_expand (pat));
   string_vector files = pattern.glob ();
 
   for (octave_idx_type i = 0; i < files.numel (); i++)
     {
       std::string file = files(i);
 
       file_stat fs (file);
 
@@ -865,17 +865,17 @@ Undocumented internal function\n\
   if (nargin != 2 && nargin != 3)
     error ("__ftp_mget__: incorrect number of arguments");
 
   std::string file = args(1).xstring_value ("__ftp_mget__: PATTERN must be a string");
 
   std::string target;
 
   if (nargin == 3 && ! args(2).is_empty ())
-    target = args(2).xstring_value ("__ftp_mget__: TARGET must be a string") + file_ops::dir_sep_str ();
+    target = args(2).xstring_value ("__ftp_mget__: TARGET must be a string") + octave::sys::file_ops::dir_sep_str ();
 
   url_transfer curl = ch_manager::get_object (args(0));
 
   if (! curl.is_valid ())
     error ("__ftp_mget__: invalid ftp handle");
 
   string_vector sv = curl.list ();
   octave_idx_type n = 0;
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -511,17 +511,17 @@ fcn_file_in_path (const std::string& nam
 
 std::string
 contents_file_in_path (const std::string& dir)
 {
   std::string retval;
 
   if (dir.length () > 0)
     {
-      std::string tcontents = file_ops::concat (load_path::find_dir (dir),
+      std::string tcontents = octave::sys::file_ops::concat (load_path::find_dir (dir),
                                                 std::string ("Contents.m"));
 
       file_stat fs (tcontents);
 
       if (fs.exists ())
         retval = octave::sys::env::make_absolute (tcontents);
     }
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -288,17 +288,17 @@ generate_struct_completions (const std::
 
 // FIXME: this will have to be much smarter to work "correctly".
 
 bool
 looks_like_struct (const std::string& text)
 {
   bool retval = (! text.empty ()
                  && text != "."
-                 && text.find_first_of (file_ops::dir_sep_chars ()) == std::string::npos
+                 && text.find_first_of (octave::sys::file_ops::dir_sep_chars ()) == std::string::npos
                  && text.find ("..") == std::string::npos
                  && text.rfind ('.') != std::string::npos);
 
 #if 0
   symbol_record *sr = curr_sym_tab->lookup (text);
 
   if (sr && ! sr->is_function ())
     {
diff --git a/libinterp/dldfcn/__fltk_uigetfile__.cc b/libinterp/dldfcn/__fltk_uigetfile__.cc
--- a/libinterp/dldfcn/__fltk_uigetfile__.cc
+++ b/libinterp/dldfcn/__fltk_uigetfile__.cc
@@ -120,20 +120,20 @@ Undocumented internal function.\n\
               fname = fc.value (n);
               idx = fname.find_last_of (sep);
               file_cell(n - 1) = fname.substr (idx + 1);
             }
           retval(0) = file_cell;
         }
 
       if (multi_type == Fl_File_Chooser::DIRECTORY)
-        retval(0) = file_ops::native_separator_path (std::string (fc.value ()));
+        retval(0) = octave::sys::file_ops::native_separator_path (std::string (fc.value ()));
       else
         {
-          retval(1) = file_ops::native_separator_path (
+          retval(1) = octave::sys::file_ops::native_separator_path (
                         std::string (fc.directory ()) + sep);
           retval(2) = fc.filter_value () + 1;
         }
     }
 
   fc.hide ();
   Fl::flush ();
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -265,17 +265,17 @@ octave_fcn_handle::set_fcn (const std::s
     {
       // First check if just replacing matlabroot is enough
       std::string str = OCTAVE_EXEC_PREFIX +
                         fpath.substr (octaveroot.length ());
       file_stat fs (str);
 
       if (fs.exists ())
         {
-          size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
+          size_t xpos = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
           octave_function *xfcn
             = load_fcn_from_file (str, dir_name, "", "", nm);
 
           if (! xfcn)
             error ("function handle points to non-existent function");
@@ -291,17 +291,17 @@ octave_fcn_handle::set_fcn (const std::s
           names(0) = nm + ".oct";
           names(1) = nm + ".mex";
           names(2) = nm + ".m";
 
           dir_path p (load_path::system_path ());
 
           str = octave::sys::env::make_absolute (p.find_first_of (names));
 
-          size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
+          size_t xpos = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
           octave_function *xfcn = load_fcn_from_file (str, dir_name, "", "", nm);
 
           if (! xfcn)
             error ("function handle points to non-existent function");
 
@@ -309,17 +309,17 @@ octave_fcn_handle::set_fcn (const std::s
 
           fcn = octave_value (new octave_fcn_handle (tmp, nm));
         }
     }
   else
     {
       if (fpath.length () > 0)
         {
-          size_t xpos = fpath.find_last_of (file_ops::dir_sep_chars ());
+          size_t xpos = fpath.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = fpath.substr (0, xpos);
 
           octave_function *xfcn = load_fcn_from_file (fpath, dir_name, "", "", nm);
 
           if (! xfcn)
             error ("function handle points to non-existent function");
 
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -361,17 +361,17 @@ initial_java_dir (void)
 {
   static std::string java_dir;
 
   if (java_dir.empty ())
     {
       java_dir = octave::sys::env::getenv ("OCTAVE_JAVA_DIR");
 
       if (java_dir.empty ())
-        java_dir = Vfcn_file_dir + file_ops::dir_sep_str () + "java";
+        java_dir = Vfcn_file_dir + octave::sys::file_ops::dir_sep_str () + "java";
     }
 
   return java_dir;
 }
 
 // Read the content of a file filename (usually "classpath.txt")
 //
 // Returns a string with all lines concatenated and separated
@@ -405,17 +405,17 @@ read_classpath_txt (const std::string& f
               else
                 {
                   // prepend separator character
                   classpath.append (dir_path::path_sep_str ());
 
                   // append content of line without whitespace
                   int last = line.find_last_not_of (" \t\f\v\r\n");
 
-                  classpath.append (file_ops::tilde_expand (line.substr (0, last+1)));
+                  classpath.append (octave::sys::file_ops::tilde_expand (line.substr (0, last+1)));
                 }
             }
         }
     }
 
   return (classpath);
 }
 
@@ -424,17 +424,17 @@ initial_class_path (void)
 {
   std::string java_dir = initial_java_dir ();
 
   std::string retval = java_dir;
 
   // find octave.jar file
   if (! retval.empty ())
     {
-      std::string sep = file_ops::dir_sep_str ();
+      std::string sep = octave::sys::file_ops::dir_sep_str ();
 
       std::string jar_file = java_dir + sep + "octave.jar";
 
       file_stat jar_exists (jar_file);
 
       if (jar_exists)
         {
           // initialize static classpath to octave.jar
@@ -469,17 +469,17 @@ initial_class_path (void)
                   retval.append (classpath);
                 }
 
               // Try to find classpath file in the user's home directory.
 
               if (cwd != home_dir)
                 {
                   cp_file = "~" + sep + filename;
-                  cp_file = file_ops::tilde_expand (cp_file);
+                  cp_file = octave::sys::file_ops::tilde_expand (cp_file);
                   cp_exists = file_stat (cp_file);
                   if (cp_exists)
                     {
                       // File found.  Add its contents to the static classpath.
                       std::string classpath = read_classpath_txt (cp_file);
                       retval.append (classpath);
                     }
                 }
@@ -681,17 +681,17 @@ initialize_jvm (void)
     {
       // No JVM exists, create one
 
       JVMArgs vm_args;
 
       vm_args.add ("-Djava.class.path=" + initial_class_path ());
       vm_args.add ("-Xrs");
       vm_args.add ("-Djava.system.class.loader=org.octave.OctClassLoader");
-      vm_args.read_java_opts (initial_java_dir () + file_ops::dir_sep_str () +
+      vm_args.read_java_opts (initial_java_dir () + octave::sys::file_ops::dir_sep_str () +
                               "java.opts");
 
 #if ! defined (__APPLE__) && ! defined (__MACH__)
 
       if (create_vm (&jvm, &current_env, vm_args.to_args ()) != JNI_OK)
         error ("unable to start Java VM in %s", jvm_lib_path.c_str ());
     }
 
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -198,17 +198,17 @@ intern_argv (int argc, char **argv)
       while (--i > 0)
         octave_argv[i-1] = *(argv+i);
     }
 }
 
 static void
 execute_pkg_add (const std::string& dir)
 {
-  std::string file_name = file_ops::concat (dir, "PKG_ADD");
+  std::string file_name = octave::sys::file_ops::concat (dir, "PKG_ADD");
 
   try
     {
       load_path::execute_pkg_add (dir);
     }
   catch (const index_exception& e)
     {
       recover_from_exception ();
@@ -485,17 +485,17 @@ execute_command_line_file (const std::st
 
   frame.protect_var (octave_program_invocation_name);
   frame.protect_var (octave_program_name);
 
   interactive = false;
 
   octave_program_invocation_name = fname;
 
-  size_t pos = fname.find_last_of (file_ops::dir_sep_chars ());
+  size_t pos = fname.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
   octave_program_name
     = (pos != std::string::npos) ? fname.substr (pos+1) : fname;
 
   std::string context;
   bool verbose = false;
   bool require_file = true;
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3153,17 +3153,17 @@ octave_base_parser::frob_function (const
       && curr_fcn_depth == 1 && ! parsing_subfunctions)
   {
     // FIXME: should lexer.fcn_file_name already be
     // preprocessed when we get here?  It seems to only be a
     // problem with relative filenames.
 
     std::string nm = lexer.fcn_file_name;
 
-    size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
+    size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
       nm = lexer.fcn_file_name.substr (pos+1);
 
     if (nm != id_name)
       {
         warning_with_id
           ("Octave:function-name-clash",
@@ -3369,17 +3369,17 @@ octave_base_parser::make_classdef (token
                                    octave_comment_list *lc)
 {
   tree_classdef *retval = 0;
 
   std::string cls_name = id->name ();
 
   std::string nm = lexer.fcn_file_name;
 
-  size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
+  size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
   if (pos != std::string::npos)
     nm = lexer.fcn_file_name.substr (pos+1);
 
   if (nm != cls_name)
     {
       delete a;
       delete id;
@@ -4245,17 +4245,17 @@ get_help_from_file (const std::string& n
 
   if ((file_len > 4 && file.substr (file_len-4) == ".oct")
       || (file_len > 4 && file.substr (file_len-4) == ".mex")
       || (file_len > 2 && file.substr (file_len-2) == ".m"))
     {
       file = octave::sys::env::base_pathname (file);
       file = file.substr (0, file.find_last_of ('.'));
 
-      size_t pos = file.find_last_of (file_ops::dir_sep_str ());
+      size_t pos = file.find_last_of (octave::sys::file_ops::dir_sep_str ());
       if (pos != std::string::npos)
         file = file.substr (pos+1);
     }
 
   if (! file.empty ())
     {
       symbol_found = true;
 
@@ -4344,17 +4344,17 @@ load_fcn_from_file (const std::string& f
 
   if ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
       || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
       || (nm_len > 2 && nm.substr (nm_len-2) == ".m"))
     {
       nm = octave::sys::env::base_pathname (file);
       nm = nm.substr (0, nm.find_last_of ('.'));
 
-      size_t pos = nm.find_last_of (file_ops::dir_sep_str ());
+      size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_str ());
       if (pos != std::string::npos)
         nm = nm.substr (pos+1);
     }
 
   relative_lookup = ! octave::sys::env::absolute_pathname (file);
 
   file = octave::sys::env::make_absolute (file);
 
@@ -4489,17 +4489,17 @@ not loaded anymore during the current Oc
 
           if (fcn)
             {
               std::string fname = fcn->fcn_file_name ();
 
               if (! fname.empty ())
                 {
                   fname = octave::sys::env::make_absolute (fname);
-                  fname = fname.substr (0, fname.find_last_of (file_ops::dir_sep_str ()) + 1);
+                  fname = fname.substr (0, fname.find_last_of (octave::sys::file_ops::dir_sep_str ()) + 1);
 
                   file_stat fs (fname + nm);
 
                   if (fs.exists ())
                     {
                       nm = fname + nm;
                       found = true;
                     }
@@ -4561,17 +4561,17 @@ source_file (const std::string& file_nam
   // and called with
   //
   //   source ("foo1.m")
   //
   // (for example).
 
   static std::map<std::string, int> source_call_depth;
 
-  std::string file_full_name = file_ops::tilde_expand (file_name);
+  std::string file_full_name = octave::sys::file_ops::tilde_expand (file_name);
 
   file_full_name = octave::sys::env::make_absolute (file_full_name);
 
   unwind_protect frame;
 
   if (source_call_depth.find (file_full_name) == source_call_depth.end ())
     source_call_depth[file_full_name] = -1;
 
@@ -4594,34 +4594,34 @@ source_file (const std::string& file_nam
       frame.add_fcn (octave_call_stack::pop);
     }
 
   octave_function *fcn = 0;
   // Don't delete a function already in symbol_table
   bool delete_fcn = false;
 
   // Find symbol name that would be in symbol_table, if it were loaded.
-  size_t dir_end = file_name.find_last_of (file_ops::dir_sep_chars ());
+  size_t dir_end = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
   dir_end = (dir_end == std::string::npos) ? 0 : dir_end + 1;
 
   size_t extension = file_name.find_last_of ('.');
   if (extension == std::string::npos)
     extension = file_name.length ();
 
   std::string symbol = file_name.substr (dir_end, extension - dir_end);
-  std::string full_name = octave_canonicalize_file_name (file_name);
+  std::string full_name = octave::sys::canonicalize_file_name (file_name);
 
   // Check if this file is already loaded (or in the path)
   octave_value loaded_sym = symbol_table::find (symbol);
   if (loaded_sym.is_function ())
     {
       fcn = loaded_sym.function_value ();
       if (fcn)
         {
-          if (octave_canonicalize_file_name (fcn->fcn_file_name ())
+          if (octave::sys::canonicalize_file_name (fcn->fcn_file_name ())
               == full_name)
             delete_fcn = true;
           else
             fcn = 0;             // wrong file, so load it below
         }
     }
 
   // If no symbol of this name, or the symbol is for a different file, load
@@ -4709,17 +4709,17 @@ the filename and the extension.\n\
       if (fname.empty ())
         fname = fcn->name ();
     }
 
   if (arg == "fullpathext")
     retval = fname;
   else
     {
-      size_t dpos = fname.rfind (file_ops::dir_sep_char ());
+      size_t dpos = fname.rfind (octave::sys::file_ops::dir_sep_char ());
       size_t epos = fname.rfind ('.');
 
       if (epos <= dpos)
         epos = std::string::npos;
 
       fname = (epos != std::string::npos) ? fname.substr (0, epos) : fname;
 
       if (arg == "fullpath")
@@ -5490,17 +5490,17 @@ Undocumented internal function.\n\
 
   if ((file_len > 4 && file.substr (file_len-4) == ".oct")
       || (file_len > 4 && file.substr (file_len-4) == ".mex")
       || (file_len > 2 && file.substr (file_len-2) == ".m"))
     {
       file = octave::sys::env::base_pathname (file);
       file = file.substr (0, file.find_last_of ('.'));
 
-      size_t pos = file.find_last_of (file_ops::dir_sep_str ());
+      size_t pos = file.find_last_of (octave::sys::file_ops::dir_sep_str ());
       if (pos != std::string::npos)
         file = file.substr (pos+1);
     }
 
   if (nargin == 2)
     octave_stdout << "parsing " << full_file << std::endl;
 
   octave_function *fcn = parse_fcn_file (full_file, file, "", "",
diff --git a/liboctave/system/dir-ops.cc b/liboctave/system/dir-ops.cc
--- a/liboctave/system/dir-ops.cc
+++ b/liboctave/system/dir-ops.cc
@@ -46,17 +46,17 @@ dir_entry::open (const std::string& n)
 
   if (! n.empty ())
     name = n;
 
   if (! name.empty ())
     {
       close ();
 
-      std::string fullname = file_ops::tilde_expand (name);
+      std::string fullname = octave::sys::file_ops::tilde_expand (name);
 
       dir = static_cast<void *> (gnulib::opendir (fullname.c_str ()));
 
       if (dir)
         fail = false;
       else
         errmsg = gnulib::strerror (errno);
     }
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -53,699 +53,704 @@ extern "C" {
 #include "quit.h"
 #include "singleton-cleanup.h"
 #include "str-vec.h"
 
 #if (defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM))
 #  include <algorithm>
 #endif
 
-file_ops *file_ops::instance = 0;
-
-bool
-file_ops::instance_ok (void)
+namespace
+octave
 {
-  bool retval = true;
+  namespace
+  sys
+  {
+    file_ops *octave::sys::file_ops::instance = 0;
 
-  if (! instance)
+    bool
+    octave::sys::file_ops::instance_ok (void)
     {
+      bool retval = true;
+
+      if (! instance)
+        {
 #if (defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM))
-      char system_dir_sep_char = '\\';
-      std::string system_dir_sep_str = "\\";
+          char system_dir_sep_char = '\\';
+          std::string system_dir_sep_str = "\\";
 #else
-      char system_dir_sep_char = '/';
-      std::string system_dir_sep_str = "/";
+          char system_dir_sep_char = '/';
+          std::string system_dir_sep_str = "/";
 #endif
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM)
-      std::string system_dir_sep_chars = "/\\";
+          std::string system_dir_sep_chars = "/\\";
 #else
-      std::string system_dir_sep_chars = system_dir_sep_str;
+          std::string system_dir_sep_chars = system_dir_sep_str;
 #endif
 
-      instance = new file_ops (system_dir_sep_char, system_dir_sep_str,
-                               system_dir_sep_chars);
+          instance = new file_ops (system_dir_sep_char, system_dir_sep_str,
+                                   system_dir_sep_chars);
 
-      if (instance)
-        singleton_cleanup_list::add (cleanup_instance);
+          if (instance)
+            singleton_cleanup_list::add (cleanup_instance);
+        }
+
+      if (! instance)
+        (*current_liboctave_error_handler)
+          ("unable to create file_ops object!");
+
+      return retval;
     }
 
-  if (! instance)
-    (*current_liboctave_error_handler)
-      ("unable to create file_ops object!");
-
-  return retval;
-}
+    // The following tilde-expansion code was stolen and adapted from
+    // readline.
 
-// The following tilde-expansion code was stolen and adapted from
-// readline.
+    // The default value of tilde_additional_prefixes.  This is set to
+    // whitespace preceding a tilde so that simple programs which do not
+    // perform any word separation get desired behavior.
+    static const char *default_prefixes[] = { " ~", "\t~", ":~", 0 };
 
-// The default value of tilde_additional_prefixes.  This is set to
-// whitespace preceding a tilde so that simple programs which do not
-// perform any word separation get desired behavior.
-static const char *default_prefixes[] = { " ~", "\t~", ":~", 0 };
+    // The default value of tilde_additional_suffixes.  This is set to
+    // whitespace or newline so that simple programs which do not perform
+    // any word separation get desired behavior.
+    static const char *default_suffixes[] = { " ", "\n", ":", 0 };
 
-// The default value of tilde_additional_suffixes.  This is set to
-// whitespace or newline so that simple programs which do not perform
-// any word separation get desired behavior.
-static const char *default_suffixes[] = { " ", "\n", ":", 0 };
+    // If non-null, this contains the address of a function that the
+    // application wants called before trying the standard tilde
+    // expansions.  The function is called with the text sans tilde, and
+    // returns a malloc()'ed string which is the expansion, or a NULL
+    // pointer if the expansion fails.
+    octave::sys::file_ops::tilde_expansion_hook octave::sys::file_ops::tilde_expansion_preexpansion_hook = 0;
 
-// If non-null, this contains the address of a function that the
-// application wants called before trying the standard tilde
-// expansions.  The function is called with the text sans tilde, and
-// returns a malloc()'ed string which is the expansion, or a NULL
-// pointer if the expansion fails.
-file_ops::tilde_expansion_hook file_ops::tilde_expansion_preexpansion_hook = 0;
+    // If non-null, this contains the address of a function to call if the
+    // standard meaning for expanding a tilde fails.  The function is
+    // called with the text (sans tilde, as in "foo"), and returns a
+    // malloc()'ed string which is the expansion, or a NULL pointer if
+    // there is no expansion.
+    octave::sys::file_ops::tilde_expansion_hook octave::sys::file_ops::tilde_expansion_failure_hook = 0;
 
-// If non-null, this contains the address of a function to call if the
-// standard meaning for expanding a tilde fails.  The function is
-// called with the text (sans tilde, as in "foo"), and returns a
-// malloc()'ed string which is the expansion, or a NULL pointer if
-// there is no expansion.
-file_ops::tilde_expansion_hook file_ops::tilde_expansion_failure_hook = 0;
+    // When non-null, this is a NULL terminated array of strings which are
+    // duplicates for a tilde prefix.  Bash uses this to expand '=~' and
+    // ':~'.
+    string_vector octave::sys::file_ops::tilde_additional_prefixes = default_prefixes;
 
-// When non-null, this is a NULL terminated array of strings which are
-// duplicates for a tilde prefix.  Bash uses this to expand '=~' and
-// ':~'.
-string_vector file_ops::tilde_additional_prefixes = default_prefixes;
-
-// When non-null, this is a NULL terminated array of strings which
-// match the end of a username, instead of just "/".  Bash sets this
-// to ':' and '=~'.
-string_vector file_ops::tilde_additional_suffixes = default_suffixes;
+    // When non-null, this is a NULL terminated array of strings which
+    // match the end of a username, instead of just "/".  Bash sets this
+    // to ':' and '=~'.
+    string_vector octave::sys::file_ops::tilde_additional_suffixes = default_suffixes;
 
-// Find the start of a tilde expansion in S, and return the index
-// of the tilde which starts the expansion.  Place the length of the
-// text which identified this tilde starter in LEN, excluding the
-// tilde itself.
+    // Find the start of a tilde expansion in S, and return the index
+    // of the tilde which starts the expansion.  Place the length of the
+    // text which identified this tilde starter in LEN, excluding the
+    // tilde itself.
 
-static size_t
-tilde_find_prefix (const std::string& s, size_t& len)
-{
-  len = 0;
+    static size_t
+    tilde_find_prefix (const std::string& s, size_t& len)
+    {
+      len = 0;
+
+      size_t s_len = s.length ();
 
-  size_t s_len = s.length ();
+      if (s_len == 0 || s[0] == '~')
+        return 0;
 
-  if (s_len == 0 || s[0] == '~')
-    return 0;
-
-  string_vector prefixes = file_ops::tilde_additional_prefixes;
+      string_vector prefixes = octave::sys::file_ops::tilde_additional_prefixes;
 
-  if (! prefixes.empty ())
-    {
-      for (size_t i = 0; i < s_len; i++)
+      if (! prefixes.empty ())
         {
-          for (int j = 0; j < prefixes.numel (); j++)
+          for (size_t i = 0; i < s_len; i++)
             {
-              size_t pfx_len = prefixes[j].length ();
+              for (int j = 0; j < prefixes.numel (); j++)
+                {
+                  size_t pfx_len = prefixes[j].length ();
 
-              if (prefixes[j] == s.substr (i, pfx_len))
-                {
-                  len = pfx_len - 1;
-                  return i + len;
+                  if (prefixes[j] == s.substr (i, pfx_len))
+                    {
+                      len = pfx_len - 1;
+                      return i + len;
+                    }
                 }
             }
         }
+
+      return s_len;
     }
 
-  return s_len;
-}
-
-// Find the end of a tilde expansion in S, and return the index
-// of the character which ends the tilde definition.
+    // Find the end of a tilde expansion in S, and return the index
+    // of the character which ends the tilde definition.
 
-static size_t
-tilde_find_suffix (const std::string& s)
-{
-  size_t s_len = s.length ();
+    static size_t
+    tilde_find_suffix (const std::string& s)
+    {
+      size_t s_len = s.length ();
 
-  string_vector suffixes = file_ops::tilde_additional_suffixes;
+      string_vector suffixes = octave::sys::file_ops::tilde_additional_suffixes;
+
+      size_t i = 0;
 
-  size_t i = 0;
-
-  for ( ; i < s_len; i++)
-    {
-      if (file_ops::is_dir_sep (s[i]))
-        break;
+      for ( ; i < s_len; i++)
+        {
+          if (octave::sys::file_ops::is_dir_sep (s[i]))
+            break;
 
-      if (! suffixes.empty ())
-        {
-          for (int j = 0; j < suffixes.numel (); j++)
+          if (! suffixes.empty ())
             {
-              size_t sfx_len = suffixes[j].length ();
+              for (int j = 0; j < suffixes.numel (); j++)
+                {
+                  size_t sfx_len = suffixes[j].length ();
 
-              if (suffixes[j] == s.substr (i, sfx_len))
-                return i;
+                  if (suffixes[j] == s.substr (i, sfx_len))
+                    return i;
+                }
             }
         }
+
+      return i;
     }
 
-  return i;
-}
-
-// Take FNAME and return the tilde prefix we want expanded.
-
-static std::string
-isolate_tilde_prefix (const std::string& fname)
-{
-  size_t f_len = fname.length ();
+    // Take FNAME and return the tilde prefix we want expanded.
 
-  size_t len = 1;
-
-  while (len < f_len && ! file_ops::is_dir_sep (fname[len]))
-    len++;
-
-  return fname.substr (1, len);
-}
-
-// Do the work of tilde expansion on FILENAME.  FILENAME starts with a
-// tilde.
+    static std::string
+    isolate_tilde_prefix (const std::string& fname)
+    {
+      size_t f_len = fname.length ();
 
-static std::string
-tilde_expand_word (const std::string& filename)
-{
-  size_t f_len = filename.length ();
-
-  if (f_len == 0 || filename[0] != '~')
-    return filename;
-
-  // A leading '~/' or a bare '~' is *always* translated to the value
-  // of $HOME or the home directory of the current user, regardless of
-  // any preexpansion hook.
+      size_t len = 1;
 
-  if (f_len == 1 || file_ops::is_dir_sep (filename[1]))
-    return octave::sys::env::get_home_directory () + filename.substr (1);
-
-  std::string username = isolate_tilde_prefix (filename);
-
-  size_t user_len = username.length ();
+      while (len < f_len && ! octave::sys::file_ops::is_dir_sep (fname[len]))
+        len++;
 
-  std::string dirname;
-
-  if (file_ops::tilde_expansion_preexpansion_hook)
-    {
-      std::string expansion
-        = file_ops::tilde_expansion_preexpansion_hook (username);
-
-      if (! expansion.empty ())
-        return expansion + filename.substr (user_len+1);
+      return fname.substr (1, len);
     }
 
-  // No preexpansion hook, or the preexpansion hook failed.  Look in the
-  // password database.
+    // Do the work of tilde expansion on FILENAME.  FILENAME starts with a
+    // tilde.
 
-  octave::sys::password pw = octave::sys::password::getpwnam (username);
+    static std::string
+    tilde_expand_word (const std::string& filename)
+    {
+      size_t f_len = filename.length ();
+
+      if (f_len == 0 || filename[0] != '~')
+        return filename;
 
-  if (! pw)
-    {
-      // If the calling program has a special syntax for expanding tildes,
-      // and we couldn't find a standard expansion, then let them try.
+      // A leading '~/' or a bare '~' is *always* translated to the value
+      // of $HOME or the home directory of the current user, regardless of
+      // any preexpansion hook.
+
+      if (f_len == 1 || octave::sys::file_ops::is_dir_sep (filename[1]))
+        return octave::sys::env::get_home_directory () + filename.substr (1);
 
-      if (file_ops::tilde_expansion_failure_hook)
+      std::string username = isolate_tilde_prefix (filename);
+
+      size_t user_len = username.length ();
+
+      std::string dirname;
+
+      if (octave::sys::file_ops::tilde_expansion_preexpansion_hook)
         {
           std::string expansion
-            = file_ops::tilde_expansion_failure_hook (username);
+            = octave::sys::file_ops::tilde_expansion_preexpansion_hook (username);
 
           if (! expansion.empty ())
-            dirname = expansion + filename.substr (user_len+1);
+            return expansion + filename.substr (user_len+1);
         }
 
-      // If we don't have a failure hook, or if the failure hook did not
-      // expand the tilde, return a copy of what we were passed.
+      // No preexpansion hook, or the preexpansion hook failed.  Look in the
+      // password database.
 
-      if (dirname.length () == 0)
-        dirname = filename;
-    }
-  else
-    dirname = pw.dir () + filename.substr (user_len+1);
-
-  return dirname;
-}
+      octave::sys::password pw = octave::sys::password::getpwnam (username);
 
-// If NAME has a leading ~ or ~user, Unix-style, expand it to the
-// user's home directory.  If no ~, or no <pwd.h>, just return NAME.
+      if (! pw)
+        {
+          // If the calling program has a special syntax for expanding tildes,
+          // and we couldn't find a standard expansion, then let them try.
 
-std::string
-file_ops::tilde_expand (const std::string& name)
-{
-  if (name.find ('~') == std::string::npos)
-    return name;
-  else
-    {
-      std::string result;
+          if (octave::sys::file_ops::tilde_expansion_failure_hook)
+            {
+              std::string expansion
+                = octave::sys::file_ops::tilde_expansion_failure_hook (username);
 
-      size_t name_len = name.length ();
-
-      // Scan through S expanding tildes as we come to them.
+              if (! expansion.empty ())
+                dirname = expansion + filename.substr (user_len+1);
+            }
 
-      size_t pos = 0;
+          // If we don't have a failure hook, or if the failure hook did not
+          // expand the tilde, return a copy of what we were passed.
 
-      while (1)
-        {
-          if (pos > name_len)
-            break;
+          if (dirname.length () == 0)
+            dirname = filename;
+        }
+      else
+        dirname = pw.dir () + filename.substr (user_len+1);
 
-          size_t len;
-
-          // Make START point to the tilde which starts the expansion.
-
-          size_t start = tilde_find_prefix (name.substr (pos), len);
+      return dirname;
+    }
 
-          result.append (name.substr (pos, start));
-
-          // Advance STRING to the starting tilde.
-
-          pos += start;
+    // If NAME has a leading ~ or ~user, Unix-style, expand it to the
+    // user's home directory.  If no ~, or no <pwd.h>, just return NAME.
 
-          // Make FINI be the index of one after the last character of the
-          // username.
-
-          size_t fini = tilde_find_suffix (name.substr (pos));
-
-          // If both START and FINI are zero, we are all done.
-
-          if (! (start || fini))
-            break;
+    std::string
+    octave::sys::file_ops::tilde_expand (const std::string& name)
+    {
+      if (name.find ('~') == std::string::npos)
+        return name;
+      else
+        {
+          std::string result;
 
-          // Expand the entire tilde word, and copy it into RESULT.
+          size_t name_len = name.length ();
 
-          std::string tilde_word = name.substr (pos, fini);
+          // Scan through S expanding tildes as we come to them.
 
-          pos += fini;
+          size_t pos = 0;
 
-          std::string expansion = tilde_expand_word (tilde_word);
-
-          result.append (expansion);
-        }
+          while (1)
+            {
+              if (pos > name_len)
+                break;
 
-      return result;
-    }
-}
+              size_t len;
 
-// A vector version of the above.
+              // Make START point to the tilde which starts the expansion.
+
+              size_t start = tilde_find_prefix (name.substr (pos), len);
 
-string_vector
-file_ops::tilde_expand (const string_vector& names)
-{
-  string_vector retval;
+              result.append (name.substr (pos, start));
 
-  int n = names.numel ();
+              // Advance STRING to the starting tilde.
 
-  retval.resize (n);
-
-  for (int i = 0; i < n; i++)
-    retval[i] = tilde_expand (names[i]);
+              pos += start;
 
-  return retval;
-}
+              // Make FINI be the index of one after the last character of the
+              // username.
+
+              size_t fini = tilde_find_suffix (name.substr (pos));
 
-std::string
-file_ops::concat (const std::string& dir, const std::string& file)
-{
-  return dir.empty ()
-         ? file
-         : (is_dir_sep (dir[dir.length ()-1])
-            ? dir + file
-            : dir + dir_sep_char () + file);
-}
+              // If both START and FINI are zero, we are all done.
+
+              if (! (start || fini))
+                break;
 
-std::string
-file_ops::native_separator_path (const std::string& path)
-{
-  std::string retval;
+              // Expand the entire tilde word, and copy it into RESULT.
+
+              std::string tilde_word = name.substr (pos, fini);
+
+              pos += fini;
 
-  if (dir_sep_char () == '/')
-    retval = path;
-  else
-    {
-      size_t n = path.length ();
-      for (size_t i = 0; i < n; i++)
-        {
-          if (path[i] == '/')
-            retval += dir_sep_char();
-          else
-            retval += path[i];
+              std::string expansion = tilde_expand_word (tilde_word);
+
+              result.append (expansion);
+            }
+
+          return result;
         }
     }
 
-  return retval;
-}
+    // A vector version of the above.
 
-int
-octave_mkdir (const std::string& nm, mode_t md)
-{
-  std::string msg;
-  return octave_mkdir (nm, md, msg);
-}
+    string_vector
+    octave::sys::file_ops::tilde_expand (const string_vector& names)
+    {
+      string_vector retval;
+
+      int n = names.numel ();
+
+      retval.resize (n);
 
-int
-octave_mkdir (const std::string& name, mode_t mode, std::string& msg)
-{
-  msg = "";
+      for (int i = 0; i < n; i++)
+        retval[i] = tilde_expand (names[i]);
 
-  int status = -1;
+      return retval;
+    }
 
-  status = gnulib::mkdir (name.c_str (), mode);
-
-  if (status < 0)
-    msg = gnulib::strerror (errno);
-
-  return status;
-}
+    std::string
+    octave::sys::file_ops::concat (const std::string& dir, const std::string& file)
+    {
+      return dir.empty ()
+        ? file
+        : (is_dir_sep (dir[dir.length ()-1])
+           ? dir + file
+           : dir + dir_sep_char () + file);
+    }
 
-int
-octave_mkfifo (const std::string& nm, mode_t md)
-{
-  std::string msg;
-  return octave_mkfifo (nm, md, msg);
-}
-
-int
-octave_mkfifo (const std::string& name, mode_t mode, std::string& msg)
-{
-  msg = "";
-
-  int status = -1;
+    std::string
+    octave::sys::file_ops::native_separator_path (const std::string& path)
+    {
+      std::string retval;
 
-  // With gnulib we will always have mkfifo, but some systems like MinGW
-  // don't have working mkfifo functions.  On those systems, mkfifo will
-  // always return -1 and set errno.
-
-  status = gnulib::mkfifo (name.c_str (), mode);
-
-  if (status < 0)
-    msg = gnulib::strerror (errno);
+      if (dir_sep_char () == '/')
+        retval = path;
+      else
+        {
+          size_t n = path.length ();
+          for (size_t i = 0; i < n; i++)
+            {
+              if (path[i] == '/')
+                retval += dir_sep_char();
+              else
+                retval += path[i];
+            }
+        }
 
-  return status;
-}
+      return retval;
+    }
 
-int
-octave_link (const std::string& old_name, const std::string& new_name)
-{
-  std::string msg;
-  return octave_link (old_name, new_name, msg);
-}
+    int
+    mkdir (const std::string& nm, mode_t md)
+    {
+      std::string msg;
+      return octave::sys::mkdir (nm, md, msg);
+    }
+
+    int
+    mkdir (const std::string& name, mode_t mode, std::string& msg)
+    {
+      msg = "";
+
+      int status = -1;
 
-int
-octave_link (const std::string& old_name,
-             const std::string& new_name, std::string& msg)
-{
-  msg = "";
+      status = gnulib::mkdir (name.c_str (), mode);
 
-  int status = -1;
+      if (status < 0)
+        msg = gnulib::strerror (errno);
 
-  status = gnulib::link (old_name.c_str (), new_name.c_str ());
+      return status;
+    }
 
-  if (status < 0)
-    msg = gnulib::strerror (errno);
-
-  return status;
-}
+    int
+    mkfifo (const std::string& nm, mode_t md)
+    {
+      std::string msg;
+      return mkfifo (nm, md, msg);
+    }
 
-int
-octave_symlink (const std::string& old_name, const std::string& new_name)
-{
-  std::string msg;
-  return octave_symlink (old_name, new_name, msg);
-}
+    int
+    mkfifo (const std::string& name, mode_t mode, std::string& msg)
+    {
+      msg = "";
+
+      int status = -1;
 
-int
-octave_symlink (const std::string& old_name,
-                const std::string& new_name, std::string& msg)
-{
-  msg = "";
+      // With gnulib we will always have mkfifo, but some systems like MinGW
+      // don't have working mkfifo functions.  On those systems, mkfifo will
+      // always return -1 and set errno.
 
-  int status = -1;
+      status = gnulib::mkfifo (name.c_str (), mode);
 
-  status = gnulib::symlink (old_name.c_str (), new_name.c_str ());
+      if (status < 0)
+        msg = gnulib::strerror (errno);
 
-  if (status < 0)
-    msg = gnulib::strerror (errno);
-
-  return status;
-}
+      return status;
+    }
 
-int
-octave_readlink (const std::string& path, std::string& result)
-{
-  std::string msg;
-  return octave_readlink (path, result, msg);
-}
+    int
+    link (const std::string& old_name, const std::string& new_name)
+    {
+      std::string msg;
+      return link (old_name, new_name, msg);
+    }
+
+    int
+    link (const std::string& old_name, const std::string& new_name,
+          std::string& msg)
+    {
+      msg = "";
 
-int
-octave_readlink (const std::string& path, std::string& result,
-                 std::string& msg)
-{
-  int status = -1;
+      int status = -1;
 
-  msg = "";
+      status = gnulib::link (old_name.c_str (), new_name.c_str ());
 
-  char buf[MAXPATHLEN+1];
+      if (status < 0)
+        msg = gnulib::strerror (errno);
 
-  status = gnulib::readlink (path.c_str (), buf, MAXPATHLEN);
+      return status;
+    }
 
-  if (status < 0)
-    msg = gnulib::strerror (errno);
-  else
+    int
+    symlink (const std::string& old_name, const std::string& new_name)
     {
-      buf[status] = '\0';
-      result = std::string (buf);
-      status = 0;
+      std::string msg;
+      return symlink (old_name, new_name, msg);
     }
 
-  return status;
-}
+    int
+    symlink (const std::string& old_name,
+                    const std::string& new_name, std::string& msg)
+    {
+      msg = "";
+
+      int status = -1;
 
-int
-octave_rename (const std::string& from, const std::string& to)
-{
-  std::string msg;
-  return octave_rename (from, to, msg);
-}
+      status = gnulib::symlink (old_name.c_str (), new_name.c_str ());
+
+      if (status < 0)
+        msg = gnulib::strerror (errno);
+
+      return status;
+    }
 
-int
-octave_rename (const std::string& from, const std::string& to,
-               std::string& msg)
-{
-  int status = -1;
+    int
+    readlink (const std::string& path, std::string& result)
+    {
+      std::string msg;
+      return readlink (path, result, msg);
+    }
 
-  msg = "";
+    int
+    readlink (const std::string& path, std::string& result, std::string& msg)
+    {
+      int status = -1;
 
-  status = gnulib::rename (from.c_str (), to.c_str ());
+      msg = "";
+
+      char buf[MAXPATHLEN+1];
+
+      status = gnulib::readlink (path.c_str (), buf, MAXPATHLEN);
 
-  if (status < 0)
-    msg = gnulib::strerror (errno);
+      if (status < 0)
+        msg = gnulib::strerror (errno);
+      else
+        {
+          buf[status] = '\0';
+          result = std::string (buf);
+          status = 0;
+        }
 
-  return status;
-}
+      return status;
+    }
 
-int
-octave_rmdir (const std::string& name)
-{
-  std::string msg;
-  return octave_rmdir (name, msg);
-}
+    int
+    rename (const std::string& from, const std::string& to)
+    {
+      std::string msg;
+      return rename (from, to, msg);
+    }
 
-int
-octave_rmdir (const std::string& name, std::string& msg)
-{
-  msg = "";
+    int
+    rename (const std::string& from, const std::string& to, std::string& msg)
+    {
+      int status = -1;
+
+      msg = "";
 
-  int status = -1;
+      status = gnulib::rename (from.c_str (), to.c_str ());
 
-  status = gnulib::rmdir (name.c_str ());
+      if (status < 0)
+        msg = gnulib::strerror (errno);
 
-  if (status < 0)
-    msg = gnulib::strerror (errno);
+      return status;
+    }
 
-  return status;
-}
+    int
+    rmdir (const std::string& name)
+    {
+      std::string msg;
+      return rmdir (name, msg);
+    }
 
-// And a version that works recursively.
+    int
+    rmdir (const std::string& name, std::string& msg)
+    {
+      msg = "";
+
+      int status = -1;
+
+      status = gnulib::rmdir (name.c_str ());
 
-int
-octave_recursive_rmdir (const std::string& name)
-{
-  std::string msg;
-  return octave_recursive_rmdir (name, msg);
-}
+      if (status < 0)
+        msg = gnulib::strerror (errno);
+
+      return status;
+    }
+
+    // And a version that works recursively.
 
-int
-octave_recursive_rmdir (const std::string& name, std::string& msg)
-{
-  msg = "";
+    int
+    recursive_rmdir (const std::string& name)
+    {
+      std::string msg;
+      return recursive_rmdir (name, msg);
+    }
 
-  int status = 0;
-
-  dir_entry dir (name);
-
-  if (dir)
+    int
+    recursive_rmdir (const std::string& name, std::string& msg)
     {
-      string_vector dirlist = dir.read ();
+      msg = "";
+
+      int status = 0;
 
-      for (octave_idx_type i = 0; i < dirlist.numel (); i++)
+      dir_entry dir (name);
+
+      if (dir)
         {
-          octave_quit ();
+          string_vector dirlist = dir.read ();
 
-          std::string nm = dirlist[i];
+          for (octave_idx_type i = 0; i < dirlist.numel (); i++)
+            {
+              octave_quit ();
 
-          // Skip current directory and parent.
-          if (nm == "." || nm == "..")
-            continue;
+              std::string nm = dirlist[i];
+
+              // Skip current directory and parent.
+              if (nm == "." || nm == "..")
+                continue;
 
-          std::string fullnm = name + file_ops::dir_sep_str () + nm;
+              std::string fullnm = name + octave::sys::file_ops::dir_sep_str () + nm;
+
+              // Get info about the file.  Don't follow links.
+              file_stat fs (fullnm, false);
 
-          // Get info about the file.  Don't follow links.
-          file_stat fs (fullnm, false);
+              if (fs)
+                {
+                  if (fs.is_dir ())
+                    {
+                      status = recursive_rmdir (fullnm, msg);
 
-          if (fs)
-            {
-              if (fs.is_dir ())
-                {
-                  status = octave_recursive_rmdir (fullnm, msg);
+                      if (status < 0)
+                        break;
+                    }
+                  else
+                    {
+                      status = unlink (fullnm, msg);
 
-                  if (status < 0)
-                    break;
+                      if (status < 0)
+                        break;
+                    }
                 }
               else
                 {
-                  status = octave_unlink (fullnm, msg);
-
-                  if (status < 0)
-                    break;
+                  msg = fs.error ();
+                  break;
                 }
             }
-          else
+
+          if (status >= 0)
             {
-              msg = fs.error ();
-              break;
+              dir.close ();
+              status = rmdir (name, msg);
             }
         }
-
-      if (status >= 0)
+      else
         {
-          dir.close ();
-          status = octave_rmdir (name, msg);
+          status = -1;
+
+          msg = dir.error ();
         }
+
+      return status;
     }
-  else
+
+    int
+    umask (mode_t mode)
+    {
+#if defined (HAVE_UMASK)
+      return umask (mode);
+#else
+      return 0;
+#endif
+    }
+
+    int
+    unlink (const std::string& name)
     {
-      status = -1;
+      std::string msg;
+      return unlink (name, msg);
+    }
+
+    int
+    unlink (const std::string& name, std::string& msg)
+    {
+      msg = "";
+
+      int status = -1;
 
-      msg = dir.error ();
+      status = gnulib::unlink (name.c_str ());
+
+      if (status < 0)
+        msg = gnulib::strerror (errno);
+
+      return status;
+    }
+
+    std::string
+    tempnam (const std::string& dir, const std::string& pfx)
+    {
+      std::string msg;
+      return tempnam (dir, pfx, msg);
     }
 
-  return status;
-}
+    std::string
+    tempnam (const std::string& dir, const std::string& pfx,
+                    std::string& msg)
+    {
+      msg = "";
 
-int
-octave_umask (mode_t mode)
-{
-#if defined (HAVE_UMASK)
-  return umask (mode);
-#else
-  return 0;
-#endif
-}
-
-int
-octave_unlink (const std::string& name)
-{
-  std::string msg;
-  return octave_unlink (name, msg);
-}
-
-int
-octave_unlink (const std::string& name, std::string& msg)
-{
-  msg = "";
+      std::string retval;
 
-  int status = -1;
-
-  status = gnulib::unlink (name.c_str ());
-
-  if (status < 0)
-    msg = gnulib::strerror (errno);
-
-  return status;
-}
-
-std::string
-octave_tempnam (const std::string& dir, const std::string& pfx)
-{
-  std::string msg;
-  return octave_tempnam (dir, pfx, msg);
-}
-
-std::string
-octave_tempnam (const std::string& dir, const std::string& pfx,
-                std::string& msg)
-{
-  msg = "";
-
-  std::string retval;
+      // get dir path to use for template
+      std::string templatename;
+      if (dir.empty ())
+        templatename = octave::sys::env::get_temp_directory ();
+      else if (! file_stat (dir, false).is_dir ())
+        templatename = octave::sys::env::get_temp_directory ();
+      else
+        templatename = dir;
 
-  // get dir path to use for template
-  std::string templatename;
-  if (dir.empty ())
-    templatename = octave::sys::env::get_temp_directory ();
-  else if (! file_stat (dir, false).is_dir ())
-    templatename = octave::sys::env::get_temp_directory ();
-  else
-    templatename = dir;
-
-  // add dir sep char if it is not there
-  if (*templatename.rbegin () != file_ops::dir_sep_char ())
-    templatename += file_ops::dir_sep_char ();
+      // add dir sep char if it is not there
+      if (*templatename.rbegin () != octave::sys::file_ops::dir_sep_char ())
+        templatename += octave::sys::file_ops::dir_sep_char ();
 
-  if (pfx.empty ())
-    templatename += "file";
-  else
-    templatename += pfx;
+      if (pfx.empty ())
+        templatename += "file";
+      else
+        templatename += pfx;
 
-  // add the required XXXXXX for the template
-  templatename += "XXXXXX";
-
-  // create and copy template to char array for call to gen_tempname
-  char tname [templatename.length () + 1];
-
-  strcpy (tname, templatename.c_str ());
+      // add the required XXXXXX for the template
+      templatename += "XXXXXX";
 
-  if (gen_tempname (tname, 0, 0, GT_NOCREATE) == -1)
-    msg = gnulib::strerror (errno);
-  else
-    retval = tname;
+      // create and copy template to char array for call to gen_tempname
+      char tname [templatename.length () + 1];
 
-  return retval;
-}
+      strcpy (tname, templatename.c_str ());
 
-std::string
-octave_canonicalize_file_name (const std::string& name)
-{
-  std::string msg;
-  return octave_canonicalize_file_name (name, msg);
-}
+      if (gen_tempname (tname, 0, 0, GT_NOCREATE) == -1)
+        msg = gnulib::strerror (errno);
+      else
+        retval = tname;
 
-std::string
-octave_canonicalize_file_name (const std::string& name, std::string& msg)
-{
-  msg = "";
-
-  std::string retval;
-
-  char *tmp = gnulib::canonicalize_file_name (name.c_str ());
-
-  if (tmp)
-    {
-      retval = tmp;
-      free (tmp);
+      return retval;
     }
 
+    std::string
+    canonicalize_file_name (const std::string& name)
+    {
+      std::string msg;
+      return canonicalize_file_name (name, msg);
+    }
+
+    std::string
+    canonicalize_file_name (const std::string& name, std::string& msg)
+    {
+      msg = "";
+
+      std::string retval;
+
+      char *tmp = gnulib::canonicalize_file_name (name.c_str ());
+
+      if (tmp)
+        {
+          retval = tmp;
+          free (tmp);
+        }
+
 #if (defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM))
-  // Canonical Windows file separator is backslash.
-  std::replace (retval.begin (), retval.end (), '/', '\\');
+      // Canonical Windows file separator is backslash.
+      std::replace (retval.begin (), retval.end (), '/', '\\');
 #endif
 
-  if (retval.empty ())
-    msg = gnulib::strerror (errno);
+      if (retval.empty ())
+        msg = gnulib::strerror (errno);
 
-  return retval;
+      return retval;
+    }
+  }
 }
-
diff --git a/liboctave/system/file-ops.h b/liboctave/system/file-ops.h
--- a/liboctave/system/file-ops.h
+++ b/liboctave/system/file-ops.h
@@ -26,170 +26,349 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <string>
 
 #include <sys/types.h>
 
 #include "str-vec.h"
 
-struct
-OCTAVE_API
-file_ops
+namespace
+octave
 {
-public:
-
-  // Use a singleton class for dir_sep data members instead of just
-  // making them static members of the dir_path class so that we can
-  // ensure proper initialization.
-
-  file_ops (char dir_sep_char_arg = 0,
-            const std::string& dir_sep_str_arg = std::string ("/"),
-            const std::string& dir_sep_chars_arg = std::string ("/"))
-    : xdir_sep_char (dir_sep_char_arg), xdir_sep_str (dir_sep_str_arg),
-      xdir_sep_chars (dir_sep_chars_arg) { }
-
-  typedef std::string (*tilde_expansion_hook) (const std::string&);
-
-  static tilde_expansion_hook tilde_expansion_preexpansion_hook;
-
-  static tilde_expansion_hook tilde_expansion_failure_hook;
-
-  static string_vector tilde_additional_prefixes;
-
-  static string_vector tilde_additional_suffixes;
-
-  static char dir_sep_char (void)
-  {
-    return instance_ok () ? instance->xdir_sep_char : 0;
-  }
-
-  static std::string dir_sep_str (void)
-  {
-    return instance_ok () ? instance->xdir_sep_str : "";
-  }
-
-  static std::string dir_sep_chars (void)
+  namespace
+  sys
   {
-    return instance_ok () ? instance->xdir_sep_chars : "";
-  }
+    struct
+    OCTAVE_API
+    file_ops
+    {
+    public:
+
+      // Use a singleton class for dir_sep data members instead of just
+      // making them static members of the dir_path class so that we can
+      // ensure proper initialization.
+
+      file_ops (char dir_sep_char_arg = 0,
+                const std::string& dir_sep_str_arg = std::string ("/"),
+                const std::string& dir_sep_chars_arg = std::string ("/"))
+        : m_dir_sep_char (dir_sep_char_arg), m_dir_sep_str (dir_sep_str_arg),
+          m_dir_sep_chars (dir_sep_chars_arg) { }
+
+      typedef std::string (*tilde_expansion_hook) (const std::string&);
 
-  static bool is_dir_sep (char c)
-  {
-    std::string tmp = dir_sep_chars ();
-    return tmp.find (c) != std::string::npos;
-  }
+      static tilde_expansion_hook tilde_expansion_preexpansion_hook;
+
+      static tilde_expansion_hook tilde_expansion_failure_hook;
+
+      static string_vector tilde_additional_prefixes;
+
+      static string_vector tilde_additional_suffixes;
+
+      static char dir_sep_char (void)
+      {
+        return instance_ok () ? instance->m_dir_sep_char : 0;
+      }
+
+      static std::string dir_sep_str (void)
+      {
+        return instance_ok () ? instance->m_dir_sep_str : "";
+      }
 
-  static std::string tilde_expand (const std::string&);
+      static std::string dir_sep_chars (void)
+      {
+        return instance_ok () ? instance->m_dir_sep_chars : "";
+      }
+
+      static bool is_dir_sep (char c)
+      {
+        std::string tmp = dir_sep_chars ();
+        return tmp.find (c) != std::string::npos;
+      }
 
-  static string_vector tilde_expand (const string_vector&);
+      static std::string tilde_expand (const std::string&);
+
+      static string_vector tilde_expand (const string_vector&);
+
+      static std::string concat (const std::string&, const std::string&);
+
+      // Return the tail member of a filename.
+      static std::string tail (const std::string& path)
+      {
+        size_t ipos = path.find_last_of (dir_sep_chars ());
 
-  static std::string concat (const std::string&, const std::string&);
+        if (ipos != std::string::npos)
+          ipos++;
+        else
+          ipos = 0;
+
+        return path.substr (ipos);
+      }
+
+      // convert path from UNIX type separators to whatever is the system separators
+      static std::string native_separator_path (const std::string& path);
 
-  // Return the tail member of a filename.
-  static std::string tail (const std::string& path)
-  {
-    size_t ipos = path.find_last_of (dir_sep_chars ());
+    private:
+
+      static file_ops *instance;
+
+      static void cleanup_instance (void) { delete instance; instance = 0; }
+
+      // No copying!
+
+      file_ops (const file_ops&);
+
+      file_ops& operator = (const file_ops&);
 
-    if (ipos != std::string::npos)
-      ipos++;
-    else
-      ipos = 0;
+      static bool instance_ok (void);
+
+      char m_dir_sep_char;
+      std::string m_dir_sep_str;
+      std::string m_dir_sep_chars;
+    };
+
+    // We don't have these in the file_ops class with their simple names
+    // (i.e., mkdir instead of octave_mdir) because function names in
+    // standard headers may be #defined.
+
+    extern OCTAVE_API int
+    mkdir (const std::string&, mode_t);
+
+    extern OCTAVE_API int
+    mkdir (const std::string&, mode_t, std::string&);
+
+    extern OCTAVE_API int
+    mkfifo (const std::string&, mode_t);
 
-    return path.substr (ipos);
-  }
+    extern OCTAVE_API int
+    mkfifo (const std::string&, mode_t, std::string&);
+
+    extern OCTAVE_API int
+    link (const std::string&, const std::string&);
+
+    extern OCTAVE_API int
+    link (const std::string&, const std::string&, std::string&);
+
+    extern OCTAVE_API int
+    symlink (const std::string&, const std::string&);
+
+    extern OCTAVE_API int
+    symlink (const std::string&, const std::string&, std::string&);
+
+    extern OCTAVE_API int
+    readlink (const std::string&, std::string&);
+
+    extern OCTAVE_API int
+    readlink (const std::string&, std::string&, std::string&);
 
-  // convert path from UNIX type separators to whatever is the system separators
-  static std::string native_separator_path (const std::string& path);
+    extern OCTAVE_API int
+    rename (const std::string&, const std::string&);
+
+    extern OCTAVE_API int
+    rename (const std::string&, const std::string&, std::string&);
+
+    extern OCTAVE_API int
+    rmdir (const std::string&);
 
-private:
+    extern OCTAVE_API int
+    rmdir (const std::string&, std::string&);
+
+    extern OCTAVE_API int
+    recursive_rmdir (const std::string&);
+
+    extern OCTAVE_API int
+    recursive_rmdir (const std::string&, std::string&);
 
-  static file_ops *instance;
+    extern OCTAVE_API int
+    umask (mode_t);
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+    extern OCTAVE_API int
+    unlink (const std::string&);
+
+    extern OCTAVE_API int
+    unlink (const std::string&, std::string&);
 
-  // No copying!
+    extern OCTAVE_API std::string
+    tempnam (const std::string&, const std::string&);
+
+    extern OCTAVE_API std::string
+    tempnam (const std::string&, const std::string&, std::string&);
 
-  file_ops (const file_ops&);
+    extern OCTAVE_API std::string
+    canonicalize_file_name (const std::string&);
+
+    extern OCTAVE_API std::string
+    canonicalize_file_name (const std::string&, std::string&);
+  }
+}
 
-  file_ops& operator = (const file_ops&);
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  static bool instance_ok (void);
+OCTAVE_DEPRECATED ("use octave::sys::file_ops instead")
+  typedef octave::sys::file_ops file_ops;
 
-  char xdir_sep_char;
-  std::string xdir_sep_str;
-  std::string xdir_sep_chars;
-};
+OCTAVE_DEPRECATED ("use octave::sys::mkdir instead")
+inline int
+octave_mkdir (const std::string& nm, mode_t md)
+{
+  return octave::sys::mkdir (nm, md);
+}
+
+OCTAVE_DEPRECATED ("use octave::sys::mkdir instead")
+inline int
+octave_mkdir (const std::string& nm, mode_t md, std::string& msg)
+{
+  return octave::sys::mkdir (nm, md, msg);
+}
 
-// We don't have these in the file_ops class with their simple names
-// (i.e., mkdir instead of octave_mdir) because function names in
-// standard headers may be #defined.
+OCTAVE_DEPRECATED ("use octave::sys::mkfifo instead")
+inline int
+octave_mkfifo (const std::string& nm, mode_t md)
+{
+  return octave::sys::mkfifo (nm, md);
+}
 
-extern OCTAVE_API int
-octave_mkdir (const std::string& nm, mode_t md);
+OCTAVE_DEPRECATED ("use octave::sys::mkfifo instead")
+inline int
+octave_mkfifo (const std::string& nm, mode_t md, std::string& msg)
+{
+  return octave::sys::mkfifo (nm, md, msg);
+}
 
-extern OCTAVE_API int
-octave_mkdir (const std::string& nm, mode_t md, std::string& msg);
+OCTAVE_DEPRECATED ("use octave::sys::link instead")
+inline int
+octave_link (const std::string& old_name, const std::string& new_name)
+{
+  return octave::sys::link (old_name, new_name);
+}
 
-extern OCTAVE_API int
-octave_mkfifo (const std::string& nm, mode_t md);
+OCTAVE_DEPRECATED ("use octave::sys::link instead")
+inline int
+octave_link (const std::string& old_name, const std::string& new_name,
+             std::string& msg)
+{
+  return octave::sys::link (old_name, new_name, msg);
+}
 
-extern OCTAVE_API int
-octave_mkfifo (const std::string& nm, mode_t md, std::string& msg);
-
-extern OCTAVE_API int
-octave_link (const std::string&, const std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::symlink instead")
+inline int
+octave_symlink (const std::string& old_name, const std::string& new_name)
+{
+  return octave::sys::symlink (old_name, new_name);
+}
 
-extern OCTAVE_API int
-octave_link (const std::string&, const std::string&, std::string&);
-
-extern OCTAVE_API int
-octave_symlink (const std::string&, const std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::symlink instead")
+inline int
+octave_symlink (const std::string& old_name, const std::string& new_name,
+                std::string& msg)
+{
+  return octave::sys::symlink (old_name, new_name, msg);
+}
 
-extern OCTAVE_API int
-octave_symlink (const std::string&, const std::string&, std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::readlink instead")
+inline int
+octave_readlink (const std::string& path, std::string& result)
+{
+  return octave::sys::readlink (path, result);
+}
 
-extern OCTAVE_API int
-octave_readlink (const std::string&, std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::readlink instead")
+inline int
+octave_readlink (const std::string& path, std::string& result, std::string& msg)
+{
+  return octave::sys::readlink (path, result, msg);
+}
+
+OCTAVE_DEPRECATED ("use octave::sys::rename instead")
+inline int
+octave_rename (const std::string& from, const std::string& to)
+{
+  return octave::sys::rename (from, to);
+}
 
-extern OCTAVE_API int
-octave_readlink (const std::string&, std::string&, std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::rename instead")
+inline int
+octave_rename (const std::string& from, const std::string& to, std::string& msg)
+{
+  return octave::sys::rename (from, to, msg);
+}
 
-extern OCTAVE_API int
-octave_rename (const std::string&, const std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::rmdir instead")
+inline int
+octave_rmdir (const std::string& nm)
+{
+  return octave::sys::rmdir (nm);
+}
 
-extern OCTAVE_API int
-octave_rename (const std::string&, const std::string&, std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::rmdir instead")
+inline int
+octave_rmdir (const std::string& nm, std::string& msg)
+{
+  return octave::sys::rmdir (nm, msg);
+}
 
-extern OCTAVE_API int
-octave_rmdir (const std::string&);
-
-extern OCTAVE_API int
-octave_rmdir (const std::string&, std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::recursive_rmdir instead")
+inline int
+octave_recursive_rmdir (const std::string& nm)
+{
+  return octave::sys::recursive_rmdir (nm);
+}
 
-extern OCTAVE_API int
-octave_recursive_rmdir (const std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::recursive_rmdir instead")
+inline int
+octave_recursive_rmdir (const std::string& nm, std::string& msg)
+{
+  return octave::sys::recursive_rmdir (nm, msg);
+}
 
-extern OCTAVE_API int
-octave_recursive_rmdir (const std::string&, std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::umask instead")
+inline int
+octave_umask (mode_t md)
+{
+  return octave::sys::umask (md);
+}
 
-extern OCTAVE_API int
-octave_umask (mode_t);
+OCTAVE_DEPRECATED ("use octave::sys::unlink instead")
+inline int
+octave_unlink (const std::string& nm)
+{
+  return octave::sys::unlink (nm);
+}
 
-extern OCTAVE_API int
-octave_unlink (const std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::unlink instead")
+inline int
+octave_unlink (const std::string& nm, std::string& msg)
+{
+  return octave::sys::unlink (nm, msg);
+}
 
-extern OCTAVE_API int
-octave_unlink (const std::string&, std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::tempnam instead")
+inline std::string
+octave_tempnam (const std::string& dir, const std::string& pfx)
+{
+  return octave::sys::tempnam (dir, pfx);
+}
 
-extern OCTAVE_API std::string
-octave_tempnam (const std::string&, const std::string&);
-
-extern OCTAVE_API std::string
-octave_tempnam (const std::string&, const std::string&, std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::tempnam instead")
+inline std::string
+octave_tempnam (const std::string& dir, const std::string& pfx,
+                std::string& msg)
+{
+  return octave::sys::tempnam (dir, pfx, msg);
+}
 
-extern OCTAVE_API std::string
-octave_canonicalize_file_name (const std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::canonicalize_file_name instead")
+inline std::string
+octave_canonicalize_file_name (const std::string& nm)
+{
+  return octave::sys::canonicalize_file_name (nm);
+}
 
-extern OCTAVE_API std::string
-octave_canonicalize_file_name (const std::string&, std::string&);
+OCTAVE_DEPRECATED ("use octave::sys::canonicalize_file_name instead")
+inline std::string
+octave_canonicalize_file_name (const std::string& nm, std::string& msg)
+{
+  return octave::sys::canonicalize_file_name (nm, msg);
+}
 
 #endif
+
+#endif
diff --git a/liboctave/system/file-stat.cc b/liboctave/system/file-stat.cc
--- a/liboctave/system/file-stat.cc
+++ b/liboctave/system/file-stat.cc
@@ -178,21 +178,21 @@ base_file_stat::is_newer (const std::str
 void
 file_stat::update_internal (bool force)
 {
   if (! initialized || force)
     {
       initialized = false;
       fail = false;
 
-      std::string full_file_name = file_ops::tilde_expand (file_name);
+      std::string full_file_name = octave::sys::file_ops::tilde_expand (file_name);
 
 #if defined (__WIN32__)
       // Remove trailing slash.
-      if (file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
+      if (octave::sys::file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
           && full_file_name.length () != 1
           && ! (full_file_name.length () == 3 && full_file_name[1] == ':'))
         full_file_name.resize (full_file_name.length () - 1);
 #endif
 
       const char *cname = full_file_name.c_str ();
 
       struct stat buf;
diff --git a/liboctave/system/lo-sysdep.cc b/liboctave/system/lo-sysdep.cc
--- a/liboctave/system/lo-sysdep.cc
+++ b/liboctave/system/lo-sysdep.cc
@@ -63,17 +63,17 @@ octave_getcwd (void)
   free (tmp);
 
   return retval;
 }
 
 int
 octave_chdir (const std::string& path_arg)
 {
-  std::string path = file_ops::tilde_expand (path_arg);
+  std::string path = octave::sys::file_ops::tilde_expand (path_arg);
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
   if (path.length () == 2 && path[1] == ':')
     path += "\\";
 #endif
 
   return gnulib::chdir (path.c_str ());
 }
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -278,17 +278,17 @@ octave
 
           // For gnulib.
           ::set_program_name (strsave (s.c_str ()));
 
           // Let gnulib strip off things like the "lt-" prefix from libtool.
           prog_invocation_name = program_name;
 
           size_t pos
-            = prog_invocation_name.find_last_of (file_ops::dir_sep_chars ());
+            = prog_invocation_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           // Also keep a shortened version of the program name.
           prog_name = (pos == std::string::npos
                        ? prog_invocation_name
                        : prog_invocation_name.substr (pos+1));
 
           initialized = true;
         }
@@ -302,17 +302,17 @@ octave
     {
       std::string retval;
 
       std::string home_dir = do_get_home_directory ();
 
       size_t len = home_dir.length ();
 
       if (len > 1 && home_dir == name.substr (0, len)
-          && (name.length () == len || file_ops::is_dir_sep (name[len])))
+          && (name.length () == len || octave::sys::file_ops::is_dir_sep (name[len])))
         {
           retval = "~";
           retval.append (name.substr (len));
         }
       else
         retval = name;
 
       return retval;
@@ -321,23 +321,23 @@ octave
     bool
     env::do_absolute_pathname (const std::string& s) const
     {
       size_t len = s.length ();
 
       if (len == 0)
         return false;
 
-      if (file_ops::is_dir_sep (s[0]))
+      if (octave::sys::file_ops::is_dir_sep (s[0]))
         return true;
 
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM)
       if ((len == 2 && isalpha (s[0]) && s[1] == ':')
           || (len > 2 && isalpha (s[0]) && s[1] == ':'
-              && file_ops::is_dir_sep (s[2])))
+              && octave::sys::file_ops::is_dir_sep (s[2])))
         return true;
 #endif
 
       return false;
     }
 
     bool
     env::do_rooted_relative_pathname (const std::string& s) const
@@ -345,39 +345,39 @@ octave
       size_t len = s.length ();
 
       if (len == 0)
         return false;
 
       if (len == 1 && s[0] == '.')
         return true;
 
-      if (len > 1 && s[0] == '.' && file_ops::is_dir_sep (s[1]))
+      if (len > 1 && s[0] == '.' && octave::sys::file_ops::is_dir_sep (s[1]))
         return true;
 
       if (len == 2 && s[0] == '.' && s[1] == '.')
         return true;
 
-      if (len > 2 && s[0] == '.' && s[1] == '.' && file_ops::is_dir_sep (s[2]))
+      if (len > 2 && s[0] == '.' && s[1] == '.' && octave::sys::file_ops::is_dir_sep (s[2]))
         return true;
 
       return false;
     }
 
     // Return the 'basename' of the pathname in STRING (the stuff after
     // the last directory separator).  If STRING is not a full pathname,
     // simply return it.
 
     std::string
     env::do_base_pathname (const std::string& s) const
     {
       if (! (do_absolute_pathname (s) || do_rooted_relative_pathname (s)))
         return s;
 
-      size_t pos = s.find_last_of (file_ops::dir_sep_chars ());
+      size_t pos = s.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
       if (pos == std::string::npos)
         return s;
       else
         return s.substr (pos+1);
     }
 
     // Turn STRING (a pathname) into an absolute pathname, assuming that
@@ -392,52 +392,52 @@ octave
 
       std::string current_dir = dot_path;
 
       if (current_dir.empty ())
         current_dir = do_getcwd ();
 
       size_t pos = current_dir.length () - 1;
 
-      if (! file_ops::is_dir_sep (current_dir[pos]))
-        current_dir.append (file_ops::dir_sep_str ());
+      if (! octave::sys::file_ops::is_dir_sep (current_dir[pos]))
+        current_dir.append (octave::sys::file_ops::dir_sep_str ());
 
       // FIXME: this is probably not correct for all systems.
 
       size_t i = 0;
       size_t slen = s.length ();
 
       while (i < slen)
         {
           if (s[i] == '.')
             {
               if (i + 1 == slen)
                 return current_dir;
 
-              if (file_ops::is_dir_sep (s[i+1]))
+              if (octave::sys::file_ops::is_dir_sep (s[i+1]))
                 {
                   i += 2;
                   continue;
                 }
 
               if (s[i+1] == '.'
-                  && (i + 2 == slen || file_ops::is_dir_sep (s[i+2])))
+                  && (i + 2 == slen || octave::sys::file_ops::is_dir_sep (s[i+2])))
                 {
                   i += 2;
 
                   if (i != slen)
                     i++;
 
                   pathname_backup (current_dir, 1);
 
                   continue;
                 }
             }
 
-          size_t tmp = s.find_first_of (file_ops::dir_sep_chars (), i);
+          size_t tmp = s.find_first_of (octave::sys::file_ops::dir_sep_chars (), i);
 
           if (tmp == std::string::npos)
             {
               current_dir.append (s, i, tmp-i);
               break;
             }
           else
             {
@@ -482,17 +482,17 @@ octave
             hd = drv + do_getenv ("HOMEPATH");
         }
 #endif
 
       if (hd.empty ())
         {
           octave::sys::password pw = octave::sys::password::getpwuid (octave::sys::getuid ());
 
-          hd = pw ? pw.dir () : std::string (file_ops::dir_sep_str ());
+          hd = pw ? pw.dir () : std::string (octave::sys::file_ops::dir_sep_str ());
         }
 
       return hd;
     }
 
     std::string
     env::do_get_user_name (void) const
     {
@@ -550,17 +550,17 @@ octave
             tmp = do_make_absolute (newdir, current_directory);
 
           // Get rid of trailing directory separator.
 
           size_t len = tmp.length ();
 
           if (len > 1)
             {
-              if (file_ops::is_dir_sep (tmp[--len]))
+              if (octave::sys::file_ops::is_dir_sep (tmp[--len]))
                 tmp.resize (len);
             }
 
           if (! ::octave_chdir (tmp))
             {
               current_directory = tmp;
               retval = true;
             }
@@ -578,20 +578,20 @@ octave
     {
       if (path.empty ())
         return;
 
       size_t i = path.length () - 1;
 
       while (n--)
         {
-          while (file_ops::is_dir_sep (path[i]) && i > 0)
+          while (octave::sys::file_ops::is_dir_sep (path[i]) && i > 0)
             i--;
 
-          while (! file_ops::is_dir_sep (path[i]) && i > 0)
+          while (! octave::sys::file_ops::is_dir_sep (path[i]) && i > 0)
             i--;
 
           i++;
         }
 
       path.resize (i);
     }
 
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -1468,17 +1468,17 @@ command_editor::run_event_hooks (void)
   event_handler ();
 }
 
 void
 command_editor::read_init_file (const std::string& file_arg)
 {
   if (instance_ok ())
     {
-      std::string file = file_ops::tilde_expand (file_arg);
+      std::string file = octave::sys::file_ops::tilde_expand (file_arg);
 
       instance->do_read_init_file (file);
     }
 }
 
 void
 command_editor::re_read_init_file (void)
 {
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -545,17 +545,17 @@ command_history::is_initialized (void)
   return instance && instance->do_is_initialized ();
 }
 
 void
 command_history::set_file (const std::string& f_arg)
 {
   if (instance_ok ())
     {
-      std::string f = file_ops::tilde_expand (f_arg);
+      std::string f = octave::sys::file_ops::tilde_expand (f_arg);
 
       instance->do_set_file (f);
     }
 }
 
 std::string
 command_history::file (void)
 {
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -43,30 +43,30 @@ along with Octave; see the file COPYING.
 #  include <curl/curl.h>
 #  include <curl/curlver.h>
 #  include <curl/easy.h>
 #endif
 
 void
 base_url_transfer::delete_file (const std::string& file)
 {
-  octave_unlink (file);
+  octave::sys::unlink (file);
 }
 
 void
 base_url_transfer::mget_directory (const std::string& directory,
                                    const std::string& target)
 {
-  std::string sep = file_ops::dir_sep_str ();
+  std::string sep = octave::sys::file_ops::dir_sep_str ();
   file_stat fs (directory);
 
   if (! fs || ! fs.is_dir ())
     {
       std::string msg;
-      int status = octave_mkdir (directory, 0777, msg);
+      int status = octave::sys::mkdir (directory, 0777, msg);
 
       if (status < 0)
         {
           ok = false;
           errmsg = "__ftp_mget__: can not create directory '"
                    + target + sep + directory + "': " + msg;
           return;
         }
@@ -127,17 +127,17 @@ base_url_transfer::mget_directory (const
 string_vector
 base_url_transfer::mput_directory (const std::string& base,
                                    const std::string& directory)
 {
   string_vector file_list;
 
   std::string realdir
     = (base.length () == 0
-       ? directory : base + file_ops::dir_sep_str () + directory);
+       ? directory : base + octave::sys::file_ops::dir_sep_str () + directory);
 
   mkdir (directory);
 
   if (! good ())
     return file_list;
 
   cwd (directory);
 
@@ -155,17 +155,17 @@ base_url_transfer::mput_directory (const
 
           for (octave_idx_type i = 0; i < files.numel (); i++)
             {
               std::string file = files (i);
 
               if (file == "." || file == "..")
                 continue;
 
-              std::string realfile = realdir + file_ops::dir_sep_str () + file;
+              std::string realfile = realdir + octave::sys::file_ops::dir_sep_str () + file;
               file_stat fs (realfile);
 
               if (! fs.exists ())
                 {
                   ok = false;
                   errmsg = "__ftp__mput: file '" + realfile
                            + "' does not exist";
                   break;
