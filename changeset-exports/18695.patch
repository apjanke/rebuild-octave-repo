# HG changeset patch
# User Rik <rik@octave.org>
# Date 1398709025 25200
#      Mon Apr 28 11:17:05 2014 -0700
# Node ID 7c78430535db32d82badc127a55ae6ddf0d50d48
# Parent  fe0e34be55769b965df4d268d7fcb1e8119f0dd9
# Parent  1a5dabbaa5591ab11c4d2d322932e988b38d46c6
maint: Periodic merge of gui-release to stable.

diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -84,16 +84,19 @@ file_editor_tab::file_editor_tab (const 
            this,
            SLOT (execute_command_in_terminal (const QString&)));
 
   connect (_edit_area, 
            SIGNAL (cursorPositionChanged (int, int)),
            this,
            SLOT (handle_cursor_moved (int,int)));
 
+  connect (_edit_area, SIGNAL (create_context_menu_signal (QMenu*)),
+           this, SLOT (create_context_menu (QMenu*)));
+
   // create statusbar for row/col indicator
   _status_bar = new QStatusBar (this);
 
   _row_indicator = new QLabel ("", this);
   _row_indicator->setMinimumSize (30,0);
   QLabel *row_label = new QLabel (tr ("Line:"), this);
   _col_indicator = new QLabel ("", this);
   _col_indicator->setMinimumSize (25,0);
@@ -149,16 +152,19 @@ file_editor_tab::file_editor_tab (const 
 
   // connect modified signal
   connect (_edit_area, SIGNAL (modificationChanged (bool)),
            this, SLOT (update_window_title (bool)));
 
   connect (_edit_area, SIGNAL (copyAvailable (bool)),
            this, SLOT (handle_copy_available (bool)));
 
+  connect (_edit_area, SIGNAL (qsci_has_focus_signal (bool)),
+           this, SLOT (edit_area_has_focus (bool)));
+
   connect (&_file_system_watcher, SIGNAL (fileChanged (const QString&)),
            this, SLOT (file_has_changed (const QString&)));
 
   QSettings *settings = resource_manager::get_settings ();
   if (settings)
     notice_settings (settings);
 }
 
@@ -401,71 +407,16 @@ void
 file_editor_tab::set_focus (const QWidget *ID)
 {
   if (ID != this)
     return;
   _edit_area->setFocus ();
 }
 
 void
-file_editor_tab::undo (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->undo ();
-}
-
-void
-file_editor_tab::redo (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->redo ();
-}
-
-void
-file_editor_tab::copy (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->copy ();
-}
-
-void
-file_editor_tab::cut (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->cut ();
-}
-
-void
-file_editor_tab::paste (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->paste ();
-}
-
-void
-file_editor_tab::select_all (const QWidget *ID)
-{
-  if (ID != this)
-    return;
-
-  _edit_area->selectAll ();
-}
-
-
-void
 file_editor_tab::context_help (const QWidget *ID, bool doc)
 {
   if (ID != this)
     return;
 
   _edit_area->context_help_doc (doc);
 }
 
@@ -1659,9 +1610,21 @@ file_editor_tab::handle_cursor_moved (in
 {
   if (_edit_area->SendScintilla (QsciScintillaBase::SCI_AUTOCACTIVE))
     show_auto_completion (this);
 
   _row_indicator->setNum (line+1);
   _col_indicator->setNum (col+1);
 }
 
+void
+file_editor_tab::create_context_menu (QMenu *menu)
+{
+  emit create_context_menu_tab_signal (menu);
+}
+
+void
+file_editor_tab::edit_area_has_focus (bool focus)
+{
+  emit set_global_edit_shortcuts_signal (! focus);
+}
+
 #endif
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -42,16 +42,18 @@ class file_editor_tab : public QWidget
   Q_OBJECT
 
 public:
 
   file_editor_tab (const QString& directory = "");
 
   ~file_editor_tab (void);
 
+  octave_qscintilla *qsci_edit_area () { return _edit_area; }
+
 public slots:
 
   void update_window_title (bool modified);
   void handle_copy_available (bool enableCopy);
   void handle_margin_clicked (int line, int margin,
                               Qt::KeyboardModifiers state);
 
   // Tells the editor tab to react on changed settings.
@@ -62,22 +64,16 @@ public slots:
 
   // Change to a different editor tab by identifier tag.
   void change_editor_state (const QWidget *ID);
 
   // Simply transmit file name.
   void file_name_query (const QWidget *ID);
 
   void set_focus (const QWidget *ID);
-  void undo (const QWidget *ID);
-  void redo (const QWidget *ID);
-  void copy (const QWidget *ID);
-  void cut (const QWidget *ID);
-  void paste (const QWidget *ID);
-  void select_all (const QWidget *ID);
   void context_help (const QWidget *ID, bool);
   void context_edit (const QWidget *ID);
   void save_file (const QWidget *ID);
   void save_file (const QWidget *ID, const QString& fileName,
                   bool remove_on_success);
   void save_file_as (const QWidget *ID);
   void print_file (const QWidget *ID);
   void run_file (const QWidget *ID);
@@ -116,28 +112,32 @@ public slots:
   void set_modified (bool modified = true);
 
   QString load_file (const QString& fileName);
   void new_file (const QString& commands = QString ());
 
   void file_has_changed (const QString& fileName);
 
   void execute_command_in_terminal (const QString& command);
+  void edit_area_has_focus (bool foucs);
+  void create_context_menu (QMenu *);
 
 signals:
 
   void file_name_changed (const QString& fileName, const QString& toolTip);
   void editor_state_changed (bool copy_available, const QString& fileName);
   void tab_remove_request ();
   void add_filename_to_list (const QString&, QWidget *);
   void mru_add_file (const QString& file_name);
   void editor_check_conflict_save (const QString& saveFileName,
                                    bool remove_on_success);
   void run_file_signal (const QFileInfo& info);
   void execute_command_in_terminal_signal (const QString&);
+  void set_global_edit_shortcuts_signal (bool);
+  void create_context_menu_tab_signal (QMenu *);
 
 protected:
 
   void closeEvent (QCloseEvent *event);
   void set_file_name (const QString& fileName);
 
 private slots:
 
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -567,50 +567,55 @@ void
 file_editor::handle_edit_file_request (const QString& file)
 {
   request_open_file (file);
 }
 
 void
 file_editor::request_undo (bool)
 {
-  emit fetab_undo (_tab_widget->currentWidget ());
+  emit fetab_scintilla_command (_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_UNDO);
 }
 
 void
 file_editor::request_redo (bool)
 {
-  emit fetab_redo (_tab_widget->currentWidget ());
+  emit fetab_scintilla_command (_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_REDO);
 }
 
 void
 file_editor::request_copy (bool)
 {
-  emit fetab_copy (_tab_widget->currentWidget ());
+  emit fetab_scintilla_command (_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_COPY);
 }
 
 void
 file_editor::request_cut (bool)
 {
-  emit fetab_cut (_tab_widget->currentWidget ());
+  emit fetab_scintilla_command (_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_CUT);
 }
 
 void
 file_editor::request_paste (bool)
 {
-  emit fetab_paste (_tab_widget->currentWidget ());
+  emit fetab_scintilla_command (_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_PASTE);
 }
 
 void
 file_editor::request_selectall (bool)
 {
-  emit fetab_selectall (_tab_widget->currentWidget ());
+  emit fetab_scintilla_command (_tab_widget->currentWidget (),
+                                QsciScintillaBase::SCI_SELECTALL);
 }
 
-
 void
 file_editor::request_context_help (bool)
 {
   emit fetab_context_help (_tab_widget->currentWidget (), false);
 }
 void
 file_editor::request_context_doc (bool)
 {
@@ -702,65 +707,65 @@ file_editor::request_remove_breakpoint (
   emit fetab_remove_all_breakpoints (_tab_widget->currentWidget ());
 }
 
 // slots for Edit->Commands actions
 void
 file_editor::request_delete_start_word (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::DeleteWordLeft);
+                                QsciScintillaBase::SCI_DELWORDLEFT);
 }
 void
 file_editor::request_delete_end_word (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::DeleteWordRight);
+                                QsciScintillaBase::SCI_DELWORDRIGHT);
 }
 void
 file_editor::request_delete_start_line (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::DeleteLineLeft);
+                                QsciScintillaBase::SCI_DELLINELEFT);
 }
 void
 file_editor::request_delete_end_line (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::DeleteLineRight);
+                                QsciScintillaBase::SCI_DELLINERIGHT);
 }
 void
 file_editor::request_delete_line (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::LineDelete);
+                                QsciScintillaBase::SCI_LINEDELETE);
 }
 void
 file_editor::request_copy_line (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::LineCopy);
+                                QsciScintillaBase::SCI_LINECOPY);
 }
 void
 file_editor::request_cut_line (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::LineCut);
+                                QsciScintillaBase::SCI_LINECUT);
 }
 void
 file_editor::request_duplicate_selection (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::SelectionDuplicate);
+                                QsciScintillaBase::SCI_SELECTIONDUPLICATE);
 }
 void
 file_editor::request_transpose_line (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::LineTranspose);
+                                QsciScintillaBase::SCI_LINETRANSPOSE);
 }
 void
 file_editor::request_comment_selected_text (bool)
 {
   emit fetab_comment_selected_text (_tab_widget->currentWidget ());
 }
 void
 file_editor::request_uncomment_selected_text (bool)
@@ -768,23 +773,23 @@ file_editor::request_uncomment_selected_
   emit fetab_uncomment_selected_text (_tab_widget->currentWidget ());
 }
 
 // slots for Edit->Format actions
 void
 file_editor::request_upper_case (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::SelectionUpperCase);
+                                QsciScintillaBase::SCI_UPPERCASE);
 }
 void
 file_editor::request_lower_case (bool)
 {
   emit fetab_scintilla_command (_tab_widget->currentWidget (),
-                                QsciCommand::SelectionLowerCase);
+                                QsciScintillaBase::SCI_LOWERCASE);
 }
 void
 file_editor::request_indent_selected_text (bool)
 {
   emit fetab_indent_selected_text (_tab_widget->currentWidget ());
 }
 
 void
@@ -930,22 +935,43 @@ file_editor::handle_tab_remove_request (
 void
 file_editor::handle_add_filename_to_list (const QString& fileName, QWidget *ID)
 {
   // Should we allow multiple tabs for a single file?
 
   editor_tab_map[fileName] = ID;
 }
 
+// context menu of edit area
 void
 file_editor::active_tab_changed (int index)
 {
   emit fetab_change_request (_tab_widget->widget (index));
 }
 
+void file_editor::create_context_menu (QMenu *menu)
+{
+  // remove all standard actions from scintilla
+  QList<QAction *> all_actions = menu->actions ();
+  QAction* a;
+
+  foreach (a, all_actions)
+    menu->removeAction (a);
+
+  // add editor's actions with icons and customized shortcuts
+  menu->addAction (_undo_action);
+  menu->addAction (_redo_action);
+  menu->addSeparator ();
+  menu->addAction (_cut_action);
+  menu->addAction (_copy_action);
+  menu->addAction (_paste_action);
+  menu->addSeparator ();
+  menu->addAction (_selectall_action);
+}
+
 void
 file_editor::zoom_in (bool)
 {
   emit fetab_zoom_in (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::zoom_out (bool)
@@ -955,16 +981,23 @@ file_editor::zoom_out (bool)
 
 void
 file_editor::zoom_normal (bool)
 {
   emit fetab_zoom_normal (_tab_widget->currentWidget ());
 }
 
 void
+file_editor::edit_status_update (bool undo, bool redo)
+{
+  _undo_action->setEnabled (undo);
+  _redo_action->setEnabled (redo);
+}
+
+void
 file_editor::handle_editor_state_changed (bool copy_available,
                                           const QString& file_name)
 {
   // In case there is some scenario where traffic could be coming from
   // all the file editor tabs, just process info from the current active tab.
   if (sender () == _tab_widget->currentWidget ())
     {
       _copy_action->setEnabled (copy_available);
@@ -992,32 +1025,28 @@ file_editor::notice_settings (const QSet
   int icon_size = settings->value ("toolbar_icon_size", 16).toInt ();
   _tool_bar->setIconSize (QSize (icon_size, icon_size));
 
   int tab_width_min = settings->value ("editor/notebook_tab_width_min", 160)
                                       .toInt ();
   int tab_width_max = settings->value ("editor/notebook_tab_width_max", 300)
                                       .toInt ();
 
-  QString style_sheet;
   if (settings->value ("editor/longWindowTitle", false).toBool ())
     {
-      style_sheet = QString ("QTabBar::tab {max-height: 4ex; "
-                             "min-width: %1px; max-width: %2px;}")
+      QString style_sheet = QString ("QTabBar::tab "
+                                     "{min-width: %1px; max-width: %2px;}")
                              .arg (tab_width_min).arg (tab_width_max);
       _tab_widget->setElideMode (Qt::ElideLeft);
+      _tab_widget->setStyleSheet (style_sheet);
     }
   else
-    {
-      style_sheet = QString ("QTabBar::tab {max-height: 4ex;}");
-      _tab_widget->setElideMode (Qt::ElideNone);
-    }
+    _tab_widget->setElideMode (Qt::ElideNone);
 
   _tab_widget->setUsesScrollButtons (true);
-  _tab_widget->setStyleSheet (style_sheet);
 
   set_shortcuts ();
 
   // Relay signal to file editor tabs.
   emit fetab_settings_changed (settings);
 }
 
 void
@@ -1127,18 +1156,20 @@ file_editor::construct (void)
   _menu_bar->addMenu (_fileMenu);
 
   // edit menu
 
   QMenu *editMenu = new QMenu (tr ("&Edit"), _menu_bar);
 
   _undo_action = add_action (editMenu, QIcon (":/actions/icons/undo.png"),
           tr ("&Undo"), SLOT (request_undo (bool)));
+  _undo_action->setEnabled (false);
   _redo_action = add_action (editMenu, QIcon (":/actions/icons/redo.png"),
           tr ("&Redo"), SLOT (request_redo (bool)));
+  _redo_action->setEnabled (false);
 
   editMenu->addSeparator ();
 
   _copy_action = add_action (editMenu, QIcon (":/actions/icons/editcopy.png"),
           tr ("&Copy"), SLOT (request_copy (bool)));
   _copy_action->setEnabled (false);
   _cut_action = add_action (editMenu, QIcon (":/actions/icons/editcut.png"),
           tr ("Cu&t"), SLOT (request_cut (bool)));
@@ -1365,16 +1396,20 @@ file_editor::construct (void)
   check_actions ();
 }
 
 void
 file_editor::add_file_editor_tab (file_editor_tab *f, const QString& fn)
 {
   _tab_widget->addTab (f, fn);
 
+  // signals from the qscintilla edit area
+  connect (f->qsci_edit_area (), SIGNAL (status_update (bool, bool)),
+           this, SLOT (edit_status_update (bool, bool)));
+
   // Signals from the file editor_tab
   connect (f, SIGNAL (file_name_changed (const QString&, const QString&)),
            this, SLOT (handle_file_name_changed (const QString&,
                                                  const QString&)));
 
   connect (f, SIGNAL (editor_state_changed (bool, const QString&)),
            this, SLOT (handle_editor_state_changed (bool, const QString&)));
 
@@ -1385,22 +1420,28 @@ file_editor::add_file_editor_tab (file_e
            this, SLOT (handle_add_filename_to_list (const QString&, QWidget*)));
 
   connect (f, SIGNAL (editor_check_conflict_save (const QString&, bool)),
            this, SLOT (check_conflict_save (const QString&, bool)));
 
   connect (f, SIGNAL (mru_add_file (const QString&)),
            this, SLOT (handle_mru_add_file (const QString&)));
 
+  connect (f, SIGNAL (create_context_menu_tab_signal (QMenu *)),
+           this, SLOT (create_context_menu (QMenu *)));
+
   connect (f, SIGNAL (run_file_signal (const QFileInfo&)),
            main_win (), SLOT (run_file_in_terminal (const QFileInfo&)));
 
   connect (f, SIGNAL (execute_command_in_terminal_signal (const QString&)),
            main_win (), SLOT (execute_command_in_terminal (const QString&)));
 
+  connect (f, SIGNAL (set_global_edit_shortcuts_signal (bool)),
+           main_win (), SLOT (set_global_edit_shortcuts (bool)));
+
   // Signals from the file_editor non-trivial operations
   connect (this, SIGNAL (fetab_settings_changed (const QSettings *)),
            f, SLOT (notice_settings (const QSettings *)));
 
   connect (this, SIGNAL (fetab_close_request (const QWidget*,bool)),
            f, SLOT (conditional_close (const QWidget*,bool)));
 
   connect (this, SIGNAL (fetab_change_request (const QWidget*)),
@@ -1409,34 +1450,16 @@ file_editor::add_file_editor_tab (file_e
   connect (this, SIGNAL (fetab_file_name_query (const QWidget*)),
            f, SLOT (file_name_query (const QWidget*)));
 
   connect (this, SIGNAL (fetab_save_file (const QWidget*, const QString&,
                                           bool)),
            f, SLOT (save_file (const QWidget*, const QString&, bool)));
 
   // Signals from the file_editor trivial operations
-  connect (this, SIGNAL (fetab_undo (const QWidget*)),
-           f, SLOT (undo (const QWidget*)));
-
-  connect (this, SIGNAL (fetab_redo (const QWidget*)),
-           f, SLOT (redo (const QWidget*)));
-
-  connect (this, SIGNAL (fetab_copy (const QWidget*)),
-           f, SLOT (copy (const QWidget*)));
-
-  connect (this, SIGNAL (fetab_cut (const QWidget*)),
-           f, SLOT (cut (const QWidget*)));
-
-  connect (this, SIGNAL (fetab_paste (const QWidget*)),
-           f, SLOT (paste (const QWidget*)));
-
-  connect (this, SIGNAL (fetab_selectall (const QWidget*)),
-           f, SLOT (select_all (const QWidget*)));
-
   connect (this, SIGNAL (fetab_zoom_in (const QWidget*)),
            f, SLOT (zoom_in (const QWidget*)));
   connect (this, SIGNAL (fetab_zoom_out (const QWidget*)),
            f, SLOT (zoom_out (const QWidget*)));
   connect (this, SIGNAL (fetab_zoom_normal (const QWidget*)),
            f, SLOT (zoom_normal (const QWidget*)));
 
   connect (this, SIGNAL (fetab_context_help (const QWidget*, bool)),
@@ -1522,48 +1545,16 @@ file_editor::add_file_editor_tab (file_e
            f, SLOT (do_breakpoint_marker (bool, const QWidget*, int)));
 
   _tab_widget->setCurrentWidget (f);
 
   check_actions ();
 }
 
 void
-file_editor::copyClipboard ()
-{
-  QWidget * foc_w = focusWidget ();
-
-  if (foc_w && foc_w->inherits ("octave_qscintilla"))
-    {
-      request_copy (true);
-    }
-}
-void
-file_editor::pasteClipboard ()
-{
-  QWidget * foc_w = focusWidget ();
-
-  if (foc_w && foc_w->inherits ("octave_qscintilla"))
-    {
-      request_paste (true);
-    }
-}
-void
-file_editor::selectAll ()
-{
-  QWidget * foc_w = focusWidget ();
-
-  if (foc_w && foc_w->inherits ("octave_qscintilla"))
-    {
-      request_selectall (true);
-    }
-}
-
-
-void
 file_editor::set_shortcuts ()
 {
   // File menu
   shortcut_manager::set_shortcut (_edit_function_action, "editor_file:edit_function");
   shortcut_manager::set_shortcut (_save_action, "editor_file:save");
   shortcut_manager::set_shortcut (_save_as_action, "editor_file:save_as");
   shortcut_manager::set_shortcut (_close_action, "editor_file:close");
   shortcut_manager::set_shortcut (_close_all_action, "editor_file:close_all");
@@ -1600,19 +1591,19 @@ file_editor::set_shortcuts ()
   shortcut_manager::set_shortcut (_toggle_bookmark_action, "editor_edit:toggle_bookmark");
   shortcut_manager::set_shortcut (_next_bookmark_action, "editor_edit:next_bookmark");
   shortcut_manager::set_shortcut (_previous_bookmark_action, "editor_edit:previous_bookmark");
   shortcut_manager::set_shortcut (_remove_bookmark_action, "editor_edit:remove_bookmark");
   shortcut_manager::set_shortcut (_preferences_action, "editor_edit:preferences");
   shortcut_manager::set_shortcut (_styles_preferences_action, "editor_edit:styles_preferences");
 
   // View menu
-  shortcut_manager::set_shortcut (_zoom_in_action, "edit_edit:zoom_in");
-  shortcut_manager::set_shortcut (_zoom_out_action, "edit_edit:zoom_out");
-  shortcut_manager::set_shortcut (_zoom_normal_action, "edit_edit:zoom_normal");
+  shortcut_manager::set_shortcut (_zoom_in_action, "editor_view:zoom_in");
+  shortcut_manager::set_shortcut (_zoom_out_action, "editor_view:zoom_out");
+  shortcut_manager::set_shortcut (_zoom_normal_action, "editor_view:zoom_normal");
 
   // Debug menu
   shortcut_manager::set_shortcut (_toggle_breakpoint_action, "editor_debug:toggle_breakpoint");
   shortcut_manager::set_shortcut (_next_breakpoint_action, "editor_debug:next_breakpoint");
   shortcut_manager::set_shortcut (_previous_bookmark_action, "editor_debug:previous_breakpoint");
   shortcut_manager::set_shortcut (_remove_all_breakpoints_action, "editor_debug:remove_breakpoints");
 
   // Run menu
@@ -1653,18 +1644,16 @@ file_editor::check_actions ()
 
   _edit_function_action->setEnabled (have_tabs);
   _save_action->setEnabled (have_tabs);
   _save_as_action->setEnabled (have_tabs);
   _close_action->setEnabled (have_tabs);
   _close_all_action->setEnabled (have_tabs);
   _close_others_action->setEnabled (have_tabs && _tab_widget->count () > 1);
 
-  _undo_action->setEnabled (have_tabs);
-  _redo_action->setEnabled (have_tabs);
   _selectall_action->setEnabled (have_tabs);
 }
 
 // empty_script determines whether we have to create an empty script
 // 1. At startup, when the editor has to be (really) visible
 //    (Here we can not use the visibility changed signal)
 // 2. When the editor becomes visible when octave is running
 void
@@ -1722,29 +1711,29 @@ file_editor::handle_visibility (bool vis
   {
     empty_script (false, visible);
 
     if (visible && ! isFloating ())
       focus ();
   }
 
 void 
-file_editor::dragEnterEvent (QDragEnterEvent *event)
+file_editor::dragEnterEvent (QDragEnterEvent *e)
   {
-    if (event->mimeData ()->hasUrls ())
+    if (e->mimeData ()->hasUrls ())
       {
-        event->acceptProposedAction();
+        e->acceptProposedAction();
       }
   }
 
 void
-file_editor::dropEvent (QDropEvent *event)
+file_editor::dropEvent (QDropEvent *e)
   {
-    if (event->mimeData ()->hasUrls ())
+    if (e->mimeData ()->hasUrls ())
       {
-        foreach (QUrl url, event->mimeData ()->urls ())
+        foreach (QUrl url, e->mimeData ()->urls ())
         {
           request_open_file (url.toLocalFile ());
         }
       }
   }
 
 #endif
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -71,22 +71,16 @@ signals:
   void fetab_close_request (const QWidget* ID, bool app_closing = false);
   void fetab_change_request (const QWidget* ID);
   void fetab_file_name_query (const QWidget* ID);
   // Save is a ping-pong type of communication
   void fetab_save_file (const QWidget* ID, const QString& fileName,
                         bool remove_on_success);
   // No fetab_open, functionality in editor
   // No fetab_new, functionality in editor
-  void fetab_undo (const QWidget* ID);
-  void fetab_redo (const QWidget* ID);
-  void fetab_copy (const QWidget* ID);
-  void fetab_cut (const QWidget* ID);
-  void fetab_paste (const QWidget* ID);
-  void fetab_selectall (const QWidget* ID);
   void fetab_context_help (const QWidget* ID, bool);
   void fetab_context_edit (const QWidget* ID);
   void fetab_save_file (const QWidget* ID);
   void fetab_save_file_as (const QWidget* ID);
   void fetab_print_file (const QWidget* ID);
   void fetab_run_file (const QWidget* ID);
   void fetab_context_run (const QWidget* ID);
   void fetab_toggle_bookmark (const QWidget* ID);
@@ -199,34 +193,34 @@ public slots:
   void notice_settings (const QSettings *settings);
 
   void set_shortcuts ();
 
   void handle_visibility (bool visible);
 
 
 protected slots:
-  void copyClipboard ();
-  void pasteClipboard ();
-  void selectAll ();
 
 private slots:
 
   void request_open_files (const QStringList&);
   void request_open_file (const QString& fileName, int line = -1,
                           bool debug_pointer = false,
                           bool breakpoint_marker = false, bool insert = true);
   void request_preferences (bool);
   void request_styles_preferences (bool);
   void restore_create_file_setting ();
 
   void zoom_in (bool);
   void zoom_out (bool);
   void zoom_normal (bool);
 
+  void create_context_menu (QMenu *);
+  void edit_status_update (bool, bool);
+
 protected:
 
   void dragEnterEvent(QDragEnterEvent *event);
   void dropEvent(QDropEvent *event);
   
 private:
 
   bool is_editor_console_tabbed ();
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -34,33 +34,75 @@ along with Octave; see the file COPYING.
 
 #include "octave-qscintilla.h"
 #include "file-editor-tab.h"
 #include "shortcut-manager.h"
 
 octave_qscintilla::octave_qscintilla (QWidget *p)
   : QsciScintilla (p)
 {
+  connect (this, SIGNAL (textChanged ()), this, SLOT (text_changed ()));
+
   // clear scintilla edit shortcuts that are handled by the editor
-  QsciCommandSet  *cmd_set =  standardCommands ();
+  QsciCommandSet *cmd_set = standardCommands ();
+
+#ifdef HAVE_QSCI_VERSION_2_6_0
+  // find () was added in QScintilla 2.6
+  cmd_set->find (QsciCommand::SelectionCopy)->setKey (0);
+  cmd_set->find (QsciCommand::SelectionCut)->setKey (0);
+  cmd_set->find (QsciCommand::Paste)->setKey (0);
+  cmd_set->find (QsciCommand::SelectAll)->setKey (0);
   cmd_set->find (QsciCommand::SelectionDuplicate)->setKey (0);
   cmd_set->find (QsciCommand::LineTranspose)->setKey (0);
   cmd_set->find (QsciCommand::Undo)->setKey (0);
   cmd_set->find (QsciCommand::Redo)->setKey (0);
   cmd_set->find (QsciCommand::SelectionUpperCase)->setKey (0);
   cmd_set->find (QsciCommand::SelectionLowerCase)->setKey (0);
   cmd_set->find (QsciCommand::ZoomIn)->setKey (0);
   cmd_set->find (QsciCommand::ZoomOut)->setKey (0);
   cmd_set->find (QsciCommand::DeleteWordLeft)->setKey (0);
   cmd_set->find (QsciCommand::DeleteWordRight)->setKey (0);
   cmd_set->find (QsciCommand::DeleteLineLeft)->setKey (0);
   cmd_set->find (QsciCommand::DeleteLineRight)->setKey (0);
   cmd_set->find (QsciCommand::LineDelete)->setKey (0);
   cmd_set->find (QsciCommand::LineCut)->setKey (0);
   cmd_set->find (QsciCommand::LineCopy)->setKey (0);
+#else
+  // find commands via its default key (tricky way without find ())
+  QList< QsciCommand * > cmd_list = cmd_set->commands ();
+  for (int i = 0; i < cmd_list.length (); i++)
+    {
+      int cmd_key = cmd_list.at (i)->key ();
+      switch (cmd_key)
+        {
+          case Qt::Key_C | Qt::CTRL :               // SelectionCopy
+          case Qt::Key_X | Qt::CTRL :               // SelectionCut
+          case Qt::Key_V | Qt::CTRL :               // Paste
+          case Qt::Key_A | Qt::CTRL :               // SelectAll
+          case Qt::Key_D | Qt::CTRL :               // SelectionDuplicate
+          case Qt::Key_T | Qt::CTRL :               // LineTranspose
+          case Qt::Key_Z | Qt::CTRL :               // Undo
+          case Qt::Key_Y | Qt::CTRL :               // Redo
+          case Qt::Key_Z | Qt::CTRL | Qt::SHIFT :   // Redo
+          case Qt::Key_U | Qt::CTRL :               // SelectionLowerCase
+          case Qt::Key_U | Qt::CTRL | Qt::SHIFT :   // SelectionUpperCase
+          case Qt::Key_Plus | Qt::CTRL :            // ZoomIn
+          case Qt::Key_Minus | Qt::CTRL :           // ZoomOut
+          case Qt::Key_Backspace | Qt::CTRL | Qt::SHIFT :   // DeleteLineLeft
+          case Qt::Key_Delete | Qt::CTRL | Qt::SHIFT :      // DeleteLineRight
+          case Qt::Key_K | Qt::META :                       // DeleteLineRight
+          case Qt::Key_Backspace | Qt::CTRL :       // DeleteWordLeft
+          case Qt::Key_Delete | Qt::CTRL :          // DeleteWordRight
+          case Qt::Key_L | Qt::CTRL | Qt::SHIFT :   // LineDelete
+          case Qt::Key_L | Qt::CTRL :               // LineCut
+          case Qt::Key_T | Qt::CTRL | Qt::SHIFT :   // LineCopy
+            cmd_list.at (i)->setKey (0);
+        }
+    }
+#endif
 }
 
 octave_qscintilla::~octave_qscintilla ()
 { }
 
 void
 octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos,
                                               QPoint *local_pos)
@@ -110,21 +152,23 @@ octave_qscintilla::context_run ()
     contextmenu_run (true);
 }
 
 #ifdef HAVE_QSCI_VERSION_2_6_0
 // context menu requested
 void
 octave_qscintilla::contextMenuEvent (QContextMenuEvent *e)
 {
+  QPoint global_pos, local_pos;                         // the menu's position
   QMenu *context_menu = createStandardContextMenu ();  // standard menu
 
-  // the menu's position
-  QPoint global_pos, local_pos;
+  // fill context menu with editor's standard actions
+  emit create_context_menu_signal (context_menu);
 
+  // determine position depending on mouse or keyboard event
   if (e->reason () == QContextMenuEvent::Mouse)
     {
       // context menu by mouse
       global_pos = e->globalPos ();            // global mouse position
       local_pos  = e->pos ();                  // local mouse position
     }
   else
     {
@@ -202,9 +246,29 @@ void
 octave_qscintilla::contextmenu_run (bool)
 {
   QStringList commands = selectedText ().split (QRegExp("[\r\n]"),
                                                 QString::SkipEmptyParts);
   for (int i = 0; i < commands.size (); i++)
     emit execute_command_in_terminal_signal (commands.at (i));
 }
 
+void
+octave_qscintilla::focusInEvent (QFocusEvent *focusEvent)
+{
+  emit qsci_has_focus_signal (true);
+  QsciScintilla::focusInEvent(focusEvent);
+}
+
+void
+octave_qscintilla::focusOutEvent (QFocusEvent *focusEvent)
+{
+  emit qsci_has_focus_signal (false);
+  QsciScintilla::focusOutEvent(focusEvent);
+}
+
+void
+octave_qscintilla::text_changed ()
+{
+  emit status_update (isUndoAvailable (), isRedoAvailable ());
+}
+
 #endif
diff --git a/libgui/src/m-editor/octave-qscintilla.h b/libgui/src/m-editor/octave-qscintilla.h
--- a/libgui/src/m-editor/octave-qscintilla.h
+++ b/libgui/src/m-editor/octave-qscintilla.h
@@ -45,24 +45,34 @@ public:
   void context_edit ();
   void context_run ();
   void get_global_textcursor_pos (QPoint *global_pos, QPoint *local_pos);
   bool get_actual_word ();
 
 signals:
 
   void execute_command_in_terminal_signal (const QString&);
+  void create_context_menu_signal (QMenu*);
+  void qsci_has_focus_signal (bool);
+  void status_update (bool,bool);
 
 private slots:
 
   void contextmenu_help (bool);
   void contextmenu_doc (bool);
   void contextmenu_help_doc (bool);
   void contextmenu_edit (bool);
   void contextmenu_run (bool);
 
+  void text_changed (void);
+
+protected:
+
+  void focusInEvent (QFocusEvent *focusEvent);
+  void focusOutEvent (QFocusEvent *focusEvent);
+
 private:
 
   QString _word_at_cursor;
 
 };
 
 #endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -1432,21 +1432,21 @@ main_window::construct_file_menu (QMenuB
 
   construct_new_menu (file_menu);
 
   _open_action
     = file_menu->addAction (QIcon (":/actions/icons/folder_documents.png"),
                             tr ("Open..."));
   _open_action->setShortcutContext (Qt::ApplicationShortcut);
 
+#ifdef HAVE_QSCINTILLA
   editor_window->insert_new_open_actions (_new_script_action,
                                           _new_function_action,
                                           _open_action);
 
-#ifdef HAVE_QSCINTILLA
   file_menu->addMenu (editor_window->get_mru_menu ());
 #endif
 
   file_menu->addSeparator ();
 
   _load_workspace_action
     = file_menu->addAction (tr ("Load Workspace..."));
 
@@ -2273,16 +2273,36 @@ main_window::find_files (const QString &
 
 void
 main_window::find_files_finished (int)
 {
 
 }
 
 void
+main_window::set_global_edit_shortcuts (bool enable)
+{
+  if (enable)
+    {
+      shortcut_manager::set_shortcut (_copy_action, "main_edit:copy");
+      shortcut_manager::set_shortcut (_paste_action, "main_edit:paste");
+      shortcut_manager::set_shortcut (_undo_action, "main_edit:undo");
+      shortcut_manager::set_shortcut (_select_all_action, "main_edit:select_all");
+    }
+  else
+    {
+      QKeySequence no_key = QKeySequence ();
+      _copy_action->setShortcut (no_key);
+      _paste_action->setShortcut (no_key);
+      _undo_action->setShortcut (no_key);
+      _select_all_action->setShortcut (no_key);
+    }
+}
+
+void
 main_window::set_global_shortcuts (bool set_shortcuts)
 {
   if (set_shortcuts)
     {
 
       // file menu
       shortcut_manager::set_shortcut (_open_action, "main_file:open_file");
       shortcut_manager::set_shortcut (_new_script_action, "main_file:new_file");
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -189,16 +189,17 @@ public slots:
   void handle_octave_ready ();
 
   // find files dialog
   void find_files (const QString &startdir=QDir::currentPath ());
   void find_files_finished (int);
 
   // setting global shortcuts
   void set_global_shortcuts (bool enable);
+  void set_global_edit_shortcuts (bool enable);
 
   // handling the clipboard
   void clipboard_has_changed (QClipboard::Mode);
   void clear_clipboard ();
 
   // get the dockwidgets
   QList<octave_dock_widget *> get_dock_widget_list ()
     { return dock_widget_list (); }
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -55,17 +55,16 @@ webinfo::webinfo (QWidget *p)
 
   _tab_bar = new QTabBar (this);
   _tab_bar->setSizePolicy (QSizePolicy::Preferred,QSizePolicy::Preferred);
   _tab_bar->setExpanding (false);
   _tab_bar->setTabsClosable (true);
 #ifdef HAVE_QTABWIDGET_SETMOVABLE
   _tab_bar->setMovable (true);
 #endif
-  _tab_bar->setStyleSheet ("QTabBar::tab {max-height: 4ex; }");
   hbox_layout->addWidget (_tab_bar);
 
   _zoom_in_button = new QToolButton (this);
   _zoom_in_button->setIcon (QIcon (":/actions/icons/zoom-in.png"));
   hbox_layout->addWidget (_zoom_in_button);
 
   _zoom_out_button = new QToolButton (this);
   _zoom_out_button->setIcon (QIcon (":/actions/icons/zoom-out.png"));
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -175,18 +175,17 @@ shortcut_manager::do_init_data ()
 
   init (tr ("Preferences"), "editor_edit:preferences", QKeySequence ());
   init (tr ("Styles Preferences"), "editor_edit:styles_preferences",
         QKeySequence ());
 
   // view
   init (tr ("Zoom In"), "editor_view:zoom_in", QKeySequence::ZoomIn);
   init (tr ("Zoom Out"), "editor_view:zoom_out", QKeySequence::ZoomOut);
-  init (tr ("Zoom Normal"), "editor_view:zoom_normal",
-        QKeySequence (Qt::ControlModifier + Qt::Key_Slash));
+  init (tr ("Zoom Normal"), "editor_view:zoom_normal",  QKeySequence (Qt::ControlModifier + Qt::AltModifier + Qt::Key_0));
 
   // debug
   init (tr ("Toggle Breakpoint"), "editor_debug:toggle_breakpoint",
         QKeySequence ());
   init (tr ("Next Breakpoint"), "editor_debug:next_breakpoint",
         QKeySequence ());
   init (tr ("Previous Breakpoint"), "editor_debug:previous_breakpoint",
         QKeySequence ());
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -727,17 +727,19 @@ get_user_input (const octave_value_list&
 
   return retval;
 }
 
 DEFUN (input, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{ans} =} input (@var{prompt})\n\
 @deftypefnx {Built-in Function} {@var{ans} =} input (@var{prompt}, \"s\")\n\
-Print a prompt and wait for user input.  For example,\n\
+Print @var{prompt} and wait for user input.\n\
+\n\
+For example,\n\
 \n\
 @example\n\
 input (\"Pick a number, any number! \")\n\
 @end example\n\
 \n\
 @noindent\n\
 prints the prompt\n\
 \n\
@@ -757,17 +759,17 @@ If you are only interested in getting a 
 call @code{input} with the character string @qcode{\"s\"} as the second\n\
 argument.  This tells Octave to return the string entered by the user\n\
 directly, without evaluating it first.\n\
 \n\
 Because there may be output waiting to be displayed by the pager, it is\n\
 a good idea to always call @code{fflush (stdout)} before calling\n\
 @code{input}.  This will ensure that all pending output is written to\n\
 the screen before your prompt.\n\
-@seealso{yes_or_no, kbhit, pause}\n\
+@seealso{yes_or_no, kbhit, pause, menu, listdlg}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     retval = get_user_input (args, std::max (nargout, 1));
@@ -795,22 +797,23 @@ octave_yes_or_no (const std::string& pro
       else
         message (0, "Please answer yes or no.");
     }
 }
 
 DEFUN (yes_or_no, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{ans} =} yes_or_no (\"@var{prompt}\")\n\
-Ask the user a yes-or-no question.  Return logical true if the answer is yes\n\
-or false if the answer is no.  Takes one argument, @var{prompt}, which is\n\
-the string to display when asking the question.  @var{prompt} should end in\n\
-a space; @code{yes-or-no} adds the string @samp{(yes or no) } to it.  The\n\
-user must confirm the answer with @key{RET} and can edit it until it has\n\
-been confirmed.\n\
+Ask the user a yes-or-no question.\n\
+\n\
+Return logical true if the answer is yes or false if the answer is no.\n\
+Takes one argument, @var{prompt}, which is the string to display when asking\n\
+the question.  @var{prompt} should end in a space; @code{yes-or-no} adds the\n\
+string @samp{(yes or no) } to it.  The user must confirm the answer with\n\
+@key{RET} and can edit it until it has been confirmed.\n\
 @seealso{input}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
@@ -884,17 +887,17 @@ This function is normally used for simpl
 for user input.  The input strings are then evaluated and the results\n\
 are printed.  This makes it possible to examine the values of variables\n\
 within a function, and to assign new values if necessary.  To leave the\n\
 prompt and return to normal execution type @samp{return} or @samp{dbcont}.\n\
 The @code{keyboard} function does not return an exit status.\n\
 \n\
 If @code{keyboard} is invoked without arguments, a default prompt of\n\
 @samp{debug> } is used.\n\
-@seealso{dbcont, dbquit}\n\
+@seealso{dbstop, dbcont, dbquit}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -636,17 +636,17 @@ it is typed.\n\
 \n\
 @example\n\
 x = kbhit (1);\n\
 @end example\n\
 \n\
 @noindent\n\
 is identical to the above example, but doesn't wait for a keypress,\n\
 returning the empty string if no key is available.\n\
-@seealso{input}\n\
+@seealso{input, pause}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   // FIXME: add timeout and default value args?
 
   if (interactive || forced_interactive)
     {
@@ -662,30 +662,35 @@ returning the empty string if no key is 
       retval = s;
     }
 
   return retval;
 }
 
 DEFUN (pause, args, ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} pause (@var{seconds})\n\
-Suspend the execution of the program.  If invoked without any arguments,\n\
-Octave waits until you type a character.  With a numeric argument, it\n\
-pauses for the given number of seconds.  For example, the following\n\
-statement prints a message and then waits 5 seconds before clearing the\n\
-screen.\n\
+@deftypefn  {Built-in Function} {} pause ()\n\
+@deftypefnx {Built-in Function} {} pause (@var{n})\n\
+Suspend the execution of the program for @var{n} seconds.\n\
+\n\
+@var{n} is a positive real value and may be a fraction of a second.\n\
+If invoked without an input arguments then the program is suspended until a\n\
+character is typed.\n\
+\n\
+The following example prints a message and then waits 5 seconds before\n\
+clearing the screen.\n\
 \n\
 @example\n\
 @group\n\
 fprintf (stderr, \"wait please...\\n\");\n\
 pause (5);\n\
 clc;\n\
 @end group\n\
 @end example\n\
+@seealso{kbhit, sleep}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (! (nargin == 0 || nargin == 1))
     {
@@ -731,16 +736,17 @@ clc;\n\
 
 %!error (pause (1, 2))
 */
 
 DEFUN (sleep, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sleep (@var{seconds})\n\
 Suspend the execution of the program for the given number of seconds.\n\
+@seealso{usleep, pause}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double dval = args(0).double_value ();
 
@@ -771,16 +777,17 @@ Suspend the execution of the program for
 
 DEFUN (usleep, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usleep (@var{microseconds})\n\
 Suspend the execution of the program for the given number of\n\
 microseconds.  On systems where it is not possible to sleep for periods\n\
 of time less than one second, @code{usleep} will pause the execution for\n\
 @code{round (@var{microseconds} / 1e6)} seconds.\n\
+@seealso{sleep, pause}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double dval = args(0).double_value ();
 
@@ -910,14 +917,14 @@ tilde_expand (\"~/bin\")\n\
 
 // This function really belongs in display.cc, but including defun.h in
 // that file results in conflicts with symbols from headers that are
 // needed for X11 and Carbon functions.
 
 DEFUN (have_window_system, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} have_window_system ()\n\
-Return true if Octave a window system is available (X11, Windows,\n\
-or Apple OS X) and false otherwise.\n\
+Return true if a window system is available (X11, Windows, or Apple OS X)\n\
+and false otherwise.\n\
 @end deftypefn")
 {
   return octave_value (display_info::display_available ());
 }
diff --git a/scripts/gui/listdlg.m b/scripts/gui/listdlg.m
--- a/scripts/gui/listdlg.m
+++ b/scripts/gui/listdlg.m
@@ -69,17 +69,17 @@
 ## if (ok == 1)
 ##   for i = 1:numel (sel)
 ##     disp (sel(i));
 ##   endfor
 ## endif
 ## @end group
 ## @end example
 ##
-## @seealso{errordlg, helpdlg, inputdlg, msgbox, questdlg, warndlg}
+## @seealso{menu, errordlg, helpdlg, inputdlg, msgbox, questdlg, warndlg}
 ## @end deftypefn
 
 function [sel, ok] = listdlg (varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} menu (@var{title}, @var{opt1}, @dots{})
 ## Print a title string followed by a series of options.  Each option will
 ## be printed along with a number.  The return value is the number of the
 ## option selected by the user.  This function is useful for interactive
 ## programs.  There is no limit to the number of options that may be passed
 ## in, but it may be confusing to present more than will fit easily on one
 ## screen.
-## @seealso{disp, printf, input}
+## @seealso{input, listdlg}
 ## @end deftypefn
 
 ## Author: jwe
 
 function num = menu (title, varargin)
 
   if (nargin < 2)
     print_usage ();
diff --git a/scripts/plot/util/private/__gnuplot_get_var__.m b/scripts/plot/util/private/__gnuplot_get_var__.m
--- a/scripts/plot/util/private/__gnuplot_get_var__.m
+++ b/scripts/plot/util/private/__gnuplot_get_var__.m
@@ -22,17 +22,17 @@
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2009-02-07
 
 function gp_var_value = __gnuplot_get_var__ (h, gp_var_name, fmt = "")
 
   if (numel (h) == 1 && isfigure (h))
-    if (isempty (get (gcf, "__plot_stream__")))
+    if (isempty (get (h, "__plot_stream__")))
       ostream = __gnuplot_open_stream__ (2, h);
     else
       ostream = get (h, "__plot_stream__");
     endif
   else
     ostream = h;
   endif
   if (numel (ostream) < 1)
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -29,17 +29,17 @@
 
 function spy (x, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   markersize = NaN;
-  if (numel (x) < 1000)
+  if (nnz (x) < 1000)
     line_spec = "*";
   else
     line_spec = ".";
   endif
   for i = 1:length (varargin)
     if (ischar (varargin{i}))
       if (length (varargin{i}) == 1)
         line_spec = [line_spec, varargin{i}];
