# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1362406412 18000
#      Mon Mar 04 09:13:32 2013 -0500
# Node ID 49062521194516090e6c9d6687cff81db49dea64
# Parent  b4a6895a9863320947bbc1b2de75e9006fbc1901
don't use new to create parser object

* topleve.cc (main_loop): Don't use new to create parser object.
Change all uses.  Don't use unwind protect to clean up the parser
object.
* input.cc (get_debug_input): Likewise.
* oct-parse.in.yy (parse_fcn_file, eval_string): Likewise.
(yyerror, bison_error, %parse-param): Pass octave_parser argument by
reference, not pointer.
(#define curr_lexer): Update definition.

diff --git a/libinterp/interpfcn/input.cc b/libinterp/interpfcn/input.cc
--- a/libinterp/interpfcn/input.cc
+++ b/libinterp/interpfcn/input.cc
@@ -666,37 +666,36 @@ get_debug_input (const std::string& prom
 
       frame.protect_var (get_input_from_eval_string);
       get_input_from_eval_string = false;
     }
 
   // octave_parser constructor sets this for us.
   frame.protect_var (CURR_LEXER);
 
-  octave_parser *curr_parser = new octave_parser ();
-  frame.add_fcn (octave_parser::cleanup, curr_parser);
+  octave_parser curr_parser;
 
   while (Vdebugging)
     {
       unwind_protect middle_frame;
 
       reset_error_handler ();
 
-      curr_parser->reset ();
+      curr_parser.reset ();
 
       // Do this with an unwind-protect cleanup function so that the
       // forced variables will be unmarked in the event of an interrupt.
       symbol_table::scope_id scope = symbol_table::top_scope ();
       middle_frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
-      int retval = curr_parser->run ();
+      int retval = curr_parser.run ();
 
-      if (retval == 0 && curr_parser->stmt_list)
+      if (retval == 0 && curr_parser.stmt_list)
         {
-          curr_parser->stmt_list->accept (*current_evaluator);
+          curr_parser.stmt_list->accept (*current_evaluator);
 
           if (octave_completion_matches_called)
             octave_completion_matches_called = false;
         }
 
       octave_quit ();
     }
 }
diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -557,46 +557,45 @@ main_loop (void)
 
   // The big loop.
 
   unwind_protect frame;
 
   // octave_parser constructor sets this for us.
   frame.protect_var (CURR_LEXER);
 
-  octave_parser *curr_parser = new octave_parser ();
-  frame.add_fcn (octave_parser::cleanup, curr_parser);
+  octave_parser curr_parser;
 
   int retval = 0;
   do
     {
       try
         {
           unwind_protect inner_frame;
 
           reset_error_handler ();
 
-          curr_parser->reset ();
+          curr_parser.reset ();
 
           if (symbol_table::at_top_level ())
             tree_evaluator::reset_debug_state ();
 
           // Do this with an unwind-protect cleanup function so that
           // the forced variables will be unmarked in the event of an
           // interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
           inner_frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
-          retval = curr_parser->run ();
+          retval = curr_parser.run ();
 
           if (retval == 0)
             {
-              if (curr_parser->stmt_list)
+              if (curr_parser.stmt_list)
                 {
-                  curr_parser->stmt_list->accept (*current_evaluator);
+                  curr_parser.stmt_list->accept (*current_evaluator);
 
                   octave_quit ();
 
                   if (! (interactive || forced_interactive))
                     {
                       bool quit = (tree_return_command::returning
                                    || tree_break_command::breaking);
 
@@ -622,17 +621,17 @@ main_loop (void)
                   else
                     {
                       if (octave_completion_matches_called)
                         octave_completion_matches_called = false;
                       else
                         command_editor::increment_current_command_number ();
                     }
                 }
-              else if (curr_parser->curr_lexer->end_of_input)
+              else if (curr_parser.curr_lexer->end_of_input)
                 break;
             }
         }
       catch (octave_interrupt_exception)
         {
           recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -112,17 +112,17 @@ bool input_from_startup_file = false;
 symtab_context parser_symtab_context;
 
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
-static void yyerror (octave_parser *curr_parser, const char *s);
+static void yyerror (octave_parser& curr_parser, const char *s);
 
 // Finish building a statement.
 template <class T>
 static tree_statement *
 make_statement (T *arg)
 {
   octave_comment_list *comment = octave_comment_buffer::get_comment ();
 
@@ -138,17 +138,17 @@ make_statement (T *arg)
       if ((interactive || forced_interactive)   \
           && ! get_input_from_eval_string)      \
         YYACCEPT; \
       else \
         YYABORT; \
     } \
   while (0)
 
-#define curr_lexer curr_parser->curr_lexer
+#define curr_lexer curr_parser.curr_lexer
 #define scanner curr_lexer->scanner
 
 %}
 
 // Bison declarations.
 
 // Don't add spaces around the = here; it causes some versions of
 // bison to fail to properly recognize the directive.
@@ -161,17 +161,17 @@ make_statement (T *arg)
 // safe to create a parser object and call it while anotehr parser
 // object is active (to parse a callback function while the main
 // interactive parser is waiting for input, for example) if you take
 // care to properly save and restore (typically with an unwind_protect
 // object) relevant global values before and after the nested call.
 
 %define api.pure
 %PUSH_PULL_DECL%
-%parse-param { octave_parser *curr_parser }
+%parse-param { octave_parser& curr_parser }
 %lex-param { void *scanner }
 
 %union
 {
   // The type of the basic tokens returned by the lexer.
   token *tok_val;
 
   // Comment strings that we need to deal with mid-rule.
@@ -320,17 +320,17 @@ make_statement (T *arg)
 %%
 
 // ==============================
 // Statements and statement lists
 // ==============================
 
 input           : input1
                   {
-                    curr_parser->stmt_list = $1;
+                    curr_parser.stmt_list = $1;
                     promptflag = 1;
                     YYACCEPT;
                   }
                 | function_file
                   { YYACCEPT; }
                 | simple_list parse_error
                   { ABORT_PARSE; }
                 | parse_error
@@ -348,39 +348,39 @@ input1          : '\n'
                   { $$ = $1; }
                 | simple_list '\n'
                   { $$ = $1; }
                 | simple_list END_OF_INPUT
                   { $$ = $1; }
                 ;
 
 simple_list     : simple_list1 opt_sep_no_nl
-                  { $$ = curr_parser->set_stmt_print_flag ($1, $2, false); }
+                  { $$ = curr_parser.set_stmt_print_flag ($1, $2, false); }
                 ;
 
 simple_list1    : statement
-                  { $$ = curr_parser->make_statement_list ($1); }
+                  { $$ = curr_parser.make_statement_list ($1); }
                 | simple_list1 sep_no_nl statement
-                  { $$ = curr_parser->append_statement_list ($1, $2, $3, false); }
+                  { $$ = curr_parser.append_statement_list ($1, $2, $3, false); }
                 ;
 
 opt_list        : // empty
                   { $$ = new tree_statement_list (); }
                 | list
                   { $$ = $1; }
                 ;
 
 list            : list1 opt_sep
-                  { $$ = curr_parser->set_stmt_print_flag ($1, $2, true); }
+                  { $$ = curr_parser.set_stmt_print_flag ($1, $2, true); }
                 ;
 
 list1           : statement
-                  { $$ = curr_parser->make_statement_list ($1); }
+                  { $$ = curr_parser.make_statement_list ($1); }
                 | list1 sep statement
-                  { $$ = curr_parser->append_statement_list ($1, $2, $3, true); }
+                  { $$ = curr_parser.append_statement_list ($1, $2, $3, true); }
                 ;
 
 statement       : expression
                   { $$ = make_statement ($1); }
                 | command
                   { $$ = make_statement ($1); }
                 | word_list_cmd
                   { $$ = make_statement ($1); }
@@ -390,17 +390,17 @@ statement       : expression
 // Word-list command
 // =================
 
 // These are not really like expressions since they can't appear on
 // the RHS of an assignment.  But they are also not like commands (IF,
 // WHILE, etc.
 
 word_list_cmd   : identifier word_list
-                  { $$ = curr_parser->make_index_expression ($1, $2, '('); }
+                  { $$ = curr_parser.make_index_expression ($1, $2, '('); }
                 ;
 
 word_list       : string
                   { $$ = new tree_argument_list ($1); }
                 | word_list string
                   {
                     $1->append ($2);
                     $$ = $1;
@@ -423,25 +423,25 @@ superclass_identifier
                   { $$ = new tree_identifier ($1->line (), $1->column ()); }
                 ;
 
 meta_identifier : METAQUERY
                   { $$ = new tree_identifier ($1->line (), $1->column ()); }
                 ;
 
 string          : DQ_STRING
-                  { $$ = curr_parser->make_constant (DQ_STRING, $1); }
+                  { $$ = curr_parser.make_constant (DQ_STRING, $1); }
                 | SQ_STRING
-                  { $$ = curr_parser->make_constant (SQ_STRING, $1); }
+                  { $$ = curr_parser.make_constant (SQ_STRING, $1); }
                 ;
 
 constant        : NUM
-                  { $$ = curr_parser->make_constant (NUM, $1); }
+                  { $$ = curr_parser.make_constant (NUM, $1); }
                 | IMAG_NUM
-                  { $$ = curr_parser->make_constant (IMAG_NUM, $1); }
+                  { $$ = curr_parser.make_constant (IMAG_NUM, $1); }
                 | string
                   { $$ = $1; }
                 ;
 
 matrix          : '[' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
                     curr_lexer->looking_at_matrix_or_assign_lhs = false;
@@ -456,17 +456,17 @@ matrix          : '[' ']'
                 | '[' ',' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
                     curr_lexer->looking_at_matrix_or_assign_lhs = false;
                     curr_lexer->pending_local_variables.clear ();
                   }
                 | '[' matrix_rows ']'
                   {
-                    $$ = curr_parser->finish_matrix ($2);
+                    $$ = curr_parser.finish_matrix ($2);
                     curr_lexer->looking_at_matrix_or_assign_lhs = false;
                     curr_lexer->pending_local_variables.clear ();
                   }
                 ;
 
 matrix_rows     : matrix_rows1
                   { $$ = $1; }
                 | matrix_rows1 ';'      // Ignore trailing semicolon.
@@ -482,17 +482,17 @@ matrix_rows1    : cell_or_matrix_row
                   }
                 ;
 
 cell            : '{' '}'
                   { $$ = new tree_constant (octave_value (Cell ())); }
                 | '{' ';' '}'
                   { $$ = new tree_constant (octave_value (Cell ())); }
                 | '{' cell_rows '}'
-                  { $$ = curr_parser->finish_cell ($2); }
+                  { $$ = curr_parser.finish_cell ($2); }
                 ;
 
 cell_rows       : cell_rows1
                   { $$ = $1; }
                 | cell_rows1 ';'        // Ignore trailing semicolon.
                   { $$ = $1; }
                 ;
 
@@ -502,32 +502,32 @@ cell_rows1      : cell_or_matrix_row
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 cell_or_matrix_row
                 : arg_list
-                  { $$ = curr_parser->validate_matrix_row ($1); }
+                  { $$ = curr_parser.validate_matrix_row ($1); }
                 | arg_list ','  // Ignore trailing comma.
-                  { $$ = curr_parser->validate_matrix_row ($1); }
+                  { $$ = curr_parser.validate_matrix_row ($1); }
                 ;
 
 fcn_handle      : '@' FCN_HANDLE
                   {
-                    $$ = curr_parser->make_fcn_handle ($2);
+                    $$ = curr_parser.make_fcn_handle ($2);
                     curr_lexer->looking_at_function_handle--;
                   }
                 ;
 
 anon_fcn_handle : '@' param_list statement
                   {
                     curr_lexer->quote_is_transpose = false;
-                    $$ = curr_parser->make_anon_fcn_handle ($2, $3);
+                    $$ = curr_parser.make_anon_fcn_handle ($2, $3);
                   }
                 ;
 
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
                 | fcn_handle
@@ -582,110 +582,110 @@ arg_list        : expression
 
 indirect_ref_op : '.'
                   { curr_lexer->looking_at_indirect_ref = true; }
                 ;
 
 oper_expr       : primary_expr
                   { $$ = $1; }
                 | oper_expr PLUS_PLUS
-                  { $$ = curr_parser->make_postfix_op (PLUS_PLUS, $1, $2); }
+                  { $$ = curr_parser.make_postfix_op (PLUS_PLUS, $1, $2); }
                 | oper_expr MINUS_MINUS
-                  { $$ = curr_parser->make_postfix_op (MINUS_MINUS, $1, $2); }
+                  { $$ = curr_parser.make_postfix_op (MINUS_MINUS, $1, $2); }
                 | oper_expr '(' ')'
-                  { $$ = curr_parser->make_index_expression ($1, 0, '('); }
+                  { $$ = curr_parser.make_index_expression ($1, 0, '('); }
                 | oper_expr '(' arg_list ')'
-                  { $$ = curr_parser->make_index_expression ($1, $3, '('); }
+                  { $$ = curr_parser.make_index_expression ($1, $3, '('); }
                 | oper_expr '{' '}'
-                  { $$ = curr_parser->make_index_expression ($1, 0, '{'); }
+                  { $$ = curr_parser.make_index_expression ($1, 0, '{'); }
                 | oper_expr '{' arg_list '}'
-                  { $$ = curr_parser->make_index_expression ($1, $3, '{'); }
+                  { $$ = curr_parser.make_index_expression ($1, $3, '{'); }
                 | oper_expr QUOTE
-                  { $$ = curr_parser->make_postfix_op (QUOTE, $1, $2); }
+                  { $$ = curr_parser.make_postfix_op (QUOTE, $1, $2); }
                 | oper_expr TRANSPOSE
-                  { $$ = curr_parser->make_postfix_op (TRANSPOSE, $1, $2); }
+                  { $$ = curr_parser.make_postfix_op (TRANSPOSE, $1, $2); }
                 | oper_expr indirect_ref_op STRUCT_ELT
-                  { $$ = curr_parser->make_indirect_ref ($1, $3->text ()); }
+                  { $$ = curr_parser.make_indirect_ref ($1, $3->text ()); }
                 | oper_expr indirect_ref_op '(' expression ')'
-                  { $$ = curr_parser->make_indirect_ref ($1, $4); }
+                  { $$ = curr_parser.make_indirect_ref ($1, $4); }
                 | PLUS_PLUS oper_expr %prec UNARY
-                  { $$ = curr_parser->make_prefix_op (PLUS_PLUS, $2, $1); }
+                  { $$ = curr_parser.make_prefix_op (PLUS_PLUS, $2, $1); }
                 | MINUS_MINUS oper_expr %prec UNARY
-                  { $$ = curr_parser->make_prefix_op (MINUS_MINUS, $2, $1); }
+                  { $$ = curr_parser.make_prefix_op (MINUS_MINUS, $2, $1); }
                 | EXPR_NOT oper_expr %prec UNARY
-                  { $$ = curr_parser->make_prefix_op (EXPR_NOT, $2, $1); }
+                  { $$ = curr_parser.make_prefix_op (EXPR_NOT, $2, $1); }
                 | '+' oper_expr %prec UNARY
-                  { $$ = curr_parser->make_prefix_op ('+', $2, $1); }
+                  { $$ = curr_parser.make_prefix_op ('+', $2, $1); }
                 | '-' oper_expr %prec UNARY
-                  { $$ = curr_parser->make_prefix_op ('-', $2, $1); }
+                  { $$ = curr_parser.make_prefix_op ('-', $2, $1); }
                 | oper_expr POW oper_expr
-                  { $$ = curr_parser->make_binary_op (POW, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (POW, $1, $2, $3); }
                 | oper_expr EPOW oper_expr
-                  { $$ = curr_parser->make_binary_op (EPOW, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EPOW, $1, $2, $3); }
                 | oper_expr '+' oper_expr
-                  { $$ = curr_parser->make_binary_op ('+', $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op ('+', $1, $2, $3); }
                 | oper_expr '-' oper_expr
-                  { $$ = curr_parser->make_binary_op ('-', $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op ('-', $1, $2, $3); }
                 | oper_expr '*' oper_expr
-                  { $$ = curr_parser->make_binary_op ('*', $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op ('*', $1, $2, $3); }
                 | oper_expr '/' oper_expr
-                  { $$ = curr_parser->make_binary_op ('/', $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op ('/', $1, $2, $3); }
                 | oper_expr EPLUS oper_expr
-                  { $$ = curr_parser->make_binary_op ('+', $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op ('+', $1, $2, $3); }
                 | oper_expr EMINUS oper_expr
-                  { $$ = curr_parser->make_binary_op ('-', $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op ('-', $1, $2, $3); }
                 | oper_expr EMUL oper_expr
-                  { $$ = curr_parser->make_binary_op (EMUL, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EMUL, $1, $2, $3); }
                 | oper_expr EDIV oper_expr
-                  { $$ = curr_parser->make_binary_op (EDIV, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EDIV, $1, $2, $3); }
                 | oper_expr LEFTDIV oper_expr
-                  { $$ = curr_parser->make_binary_op (LEFTDIV, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (LEFTDIV, $1, $2, $3); }
                 | oper_expr ELEFTDIV oper_expr
-                  { $$ = curr_parser->make_binary_op (ELEFTDIV, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (ELEFTDIV, $1, $2, $3); }
                 ;
 
 colon_expr      : colon_expr1
-                  { $$ = curr_parser->finish_colon_expression ($1); }
+                  { $$ = curr_parser.finish_colon_expression ($1); }
                 ;
 
 colon_expr1     : oper_expr
                   { $$ = new tree_colon_expression ($1); }
                 | colon_expr1 ':' oper_expr
                   {
                     if (! ($$ = $1->append ($3)))
                       ABORT_PARSE;
                   }
                 ;
 
 simple_expr     : colon_expr
                   { $$ = $1; }
                 | simple_expr LSHIFT simple_expr
-                  { $$ = curr_parser->make_binary_op (LSHIFT, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (LSHIFT, $1, $2, $3); }
                 | simple_expr RSHIFT simple_expr
-                  { $$ = curr_parser->make_binary_op (RSHIFT, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (RSHIFT, $1, $2, $3); }
                 | simple_expr EXPR_LT simple_expr
-                  { $$ = curr_parser->make_binary_op (EXPR_LT, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EXPR_LT, $1, $2, $3); }
                 | simple_expr EXPR_LE simple_expr
-                  { $$ = curr_parser->make_binary_op (EXPR_LE, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EXPR_LE, $1, $2, $3); }
                 | simple_expr EXPR_EQ simple_expr
-                  { $$ = curr_parser->make_binary_op (EXPR_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EXPR_EQ, $1, $2, $3); }
                 | simple_expr EXPR_GE simple_expr
-                  { $$ = curr_parser->make_binary_op (EXPR_GE, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EXPR_GE, $1, $2, $3); }
                 | simple_expr EXPR_GT simple_expr
-                  { $$ = curr_parser->make_binary_op (EXPR_GT, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EXPR_GT, $1, $2, $3); }
                 | simple_expr EXPR_NE simple_expr
-                  { $$ = curr_parser->make_binary_op (EXPR_NE, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EXPR_NE, $1, $2, $3); }
                 | simple_expr EXPR_AND simple_expr
-                  { $$ = curr_parser->make_binary_op (EXPR_AND, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EXPR_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR simple_expr
-                  { $$ = curr_parser->make_binary_op (EXPR_OR, $1, $2, $3); }
+                  { $$ = curr_parser.make_binary_op (EXPR_OR, $1, $2, $3); }
                 | simple_expr EXPR_AND_AND simple_expr
-                  { $$ = curr_parser->make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
+                  { $$ = curr_parser.make_boolean_op (EXPR_AND_AND, $1, $2, $3); }
                 | simple_expr EXPR_OR_OR simple_expr
-                  { $$ = curr_parser->make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
+                  { $$ = curr_parser.make_boolean_op (EXPR_OR_OR, $1, $2, $3); }
                 ;
 
 // Arrange for the lexer to return CLOSE_BRACE for ']' by looking ahead
 // one token for an assignment op.
 
 assign_lhs      : simple_expr
                   {
                     $$ = new tree_argument_list ($1);
@@ -701,45 +701,45 @@ assign_lhs      : simple_expr
                       {
                         symbol_table::force_variable (*p);
                       }
                     curr_lexer->pending_local_variables.clear ();
                   }
                 ;
 
 assign_expr     : assign_lhs '=' expression
-                  { $$ = curr_parser->make_assign_op ('=', $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op ('=', $1, $2, $3); }
                 | assign_lhs ADD_EQ expression
-                  { $$ = curr_parser->make_assign_op (ADD_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (ADD_EQ, $1, $2, $3); }
                 | assign_lhs SUB_EQ expression
-                  { $$ = curr_parser->make_assign_op (SUB_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (SUB_EQ, $1, $2, $3); }
                 | assign_lhs MUL_EQ expression
-                  { $$ = curr_parser->make_assign_op (MUL_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (MUL_EQ, $1, $2, $3); }
                 | assign_lhs DIV_EQ expression
-                  { $$ = curr_parser->make_assign_op (DIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (DIV_EQ, $1, $2, $3); }
                 | assign_lhs LEFTDIV_EQ expression
-                  { $$ = curr_parser->make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (LEFTDIV_EQ, $1, $2, $3); }
                 | assign_lhs POW_EQ expression
-                  { $$ = curr_parser->make_assign_op (POW_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (POW_EQ, $1, $2, $3); }
                 | assign_lhs LSHIFT_EQ expression
-                  { $$ = curr_parser->make_assign_op (LSHIFT_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (LSHIFT_EQ, $1, $2, $3); }
                 | assign_lhs RSHIFT_EQ expression
-                  { $$ = curr_parser->make_assign_op (RSHIFT_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (RSHIFT_EQ, $1, $2, $3); }
                 | assign_lhs EMUL_EQ expression
-                  { $$ = curr_parser->make_assign_op (EMUL_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (EMUL_EQ, $1, $2, $3); }
                 | assign_lhs EDIV_EQ expression
-                  { $$ = curr_parser->make_assign_op (EDIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (EDIV_EQ, $1, $2, $3); }
                 | assign_lhs ELEFTDIV_EQ expression
-                  { $$ = curr_parser->make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
                 | assign_lhs EPOW_EQ expression
-                  { $$ = curr_parser->make_assign_op (EPOW_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (EPOW_EQ, $1, $2, $3); }
                 | assign_lhs AND_EQ expression
-                  { $$ = curr_parser->make_assign_op (AND_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (AND_EQ, $1, $2, $3); }
                 | assign_lhs OR_EQ expression
-                  { $$ = curr_parser->make_assign_op (OR_EQ, $1, $2, $3); }
+                  { $$ = curr_parser.make_assign_op (OR_EQ, $1, $2, $3); }
                 ;
 
 expression      : simple_expr
                   { $$ = $1; }
                 | assign_expr
                   { $$ = $1; }
                 | anon_fcn_handle
                   { $$ = $1; }
@@ -772,22 +772,22 @@ command         : declaration
 // =====================
 
 parsing_decl_list
                 : // empty
                   { curr_lexer->looking_at_decl_list = true; }
 
 declaration     : GLOBAL parsing_decl_list decl1
                   {
-                    $$ = curr_parser->make_decl_command (GLOBAL, $1, $3);
+                    $$ = curr_parser.make_decl_command (GLOBAL, $1, $3);
                     curr_lexer->looking_at_decl_list = false;
                   }
                 | PERSISTENT parsing_decl_list decl1
                   {
-                    $$ = curr_parser->make_decl_command (PERSISTENT, $1, $3);
+                    $$ = curr_parser.make_decl_command (PERSISTENT, $1, $3);
                     curr_lexer->looking_at_decl_list = false;
                   }
                 ;
 
 decl1           : decl2
                   { $$ = new tree_decl_init_list ($1); }
                 | decl1 decl2
                   {
@@ -823,17 +823,17 @@ select_command  : if_command
                 ;
 
 // ============
 // If statement
 // ============
 
 if_command      : IF stash_comment if_cmd_list END
                   {
-                    if (! ($$ = curr_parser->finish_if_command ($1, $3, $4, $2)))
+                    if (! ($$ = curr_parser.finish_if_command ($1, $3, $4, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 if_cmd_list     : if_cmd_list1
                   { $$ = $1; }
                 | if_cmd_list1 else_clause
                   {
@@ -841,44 +841,44 @@ if_cmd_list     : if_cmd_list1
                     $$ = $1;
                   }
                 ;
 
 if_cmd_list1    : expression opt_sep opt_list
                   {
                     $1->mark_braindead_shortcircuit (curr_fcn_file_full_name);
 
-                    $$ = curr_parser->start_if_command ($1, $3);
+                    $$ = curr_parser.start_if_command ($1, $3);
                   }
                 | if_cmd_list1 elseif_clause
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 elseif_clause   : ELSEIF stash_comment opt_sep expression opt_sep opt_list
                   {
                     $4->mark_braindead_shortcircuit (curr_fcn_file_full_name);
 
-                    $$ = curr_parser->make_elseif_clause ($1, $4, $6, $2);
+                    $$ = curr_parser.make_elseif_clause ($1, $4, $6, $2);
                   }
                 ;
 
 else_clause     : ELSE stash_comment opt_sep opt_list
                   { $$ = new tree_if_clause ($4, $2); }
                 ;
 
 // ================
 // Switch statement
 // ================
 
 switch_command  : SWITCH stash_comment expression opt_sep case_list END
                   {
-                    if (! ($$ = curr_parser->finish_switch_command ($1, $3, $5, $6, $2)))
+                    if (! ($$ = curr_parser.finish_switch_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 case_list       : // empty
                   { $$ = new tree_switch_case_list (); }
                 | default_case
                   { $$ = new tree_switch_case_list ($1); }
@@ -896,134 +896,134 @@ case_list1      : switch_case
                 | case_list1 switch_case
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 switch_case     : CASE stash_comment opt_sep expression opt_sep opt_list
-                  { $$ = curr_parser->make_switch_case ($1, $4, $6, $2); }
+                  { $$ = curr_parser.make_switch_case ($1, $4, $6, $2); }
                 ;
 
 default_case    : OTHERWISE stash_comment opt_sep opt_list
                   {
                     $$ = new tree_switch_case ($4, $2);
                   }
                 ;
 
 // =======
 // Looping
 // =======
 
 loop_command    : WHILE stash_comment expression opt_sep opt_list END
                   {
                     $3->mark_braindead_shortcircuit (curr_fcn_file_full_name);
 
-                    if (! ($$ = curr_parser->make_while_command ($1, $3, $5, $6, $2)))
+                    if (! ($$ = curr_parser.make_while_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 | DO stash_comment opt_sep opt_list UNTIL expression
                   {
-                    if (! ($$ = curr_parser->make_do_until_command ($5, $4, $6, $2)))
+                    if (! ($$ = curr_parser.make_do_until_command ($5, $4, $6, $2)))
                       ABORT_PARSE;
                   }
                 | FOR stash_comment assign_lhs '=' expression opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser->make_for_command (FOR, $1, $3, $5, 0,
+                    if (! ($$ = curr_parser.make_for_command (FOR, $1, $3, $5, 0,
                                                   $7, $8, $2)))
                       ABORT_PARSE;
                   }
                 | FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser->make_for_command (FOR, $1, $4, $6, 0,
+                    if (! ($$ = curr_parser.make_for_command (FOR, $1, $4, $6, 0,
                                                   $9, $10, $2)))
                       ABORT_PARSE;
                   }
                 | PARFOR stash_comment assign_lhs '=' expression opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser->make_for_command (PARFOR, $1, $3, $5,
+                    if (! ($$ = curr_parser.make_for_command (PARFOR, $1, $3, $5,
                                                   0, $7, $8, $2)))
                       ABORT_PARSE;
                   }
                 | PARFOR stash_comment '(' assign_lhs '=' expression ',' expression ')' opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser->make_for_command (PARFOR, $1, $4, $6,
+                    if (! ($$ = curr_parser.make_for_command (PARFOR, $1, $4, $6,
                                                   $8, $11, $12, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 // =======
 // Jumping
 // =======
 
 jump_command    : BREAK
                   {
-                    if (! ($$ = curr_parser->make_break_command ($1)))
+                    if (! ($$ = curr_parser.make_break_command ($1)))
                       ABORT_PARSE;
                   }
                 | CONTINUE
                   {
-                    if (! ($$ = curr_parser->make_continue_command ($1)))
+                    if (! ($$ = curr_parser.make_continue_command ($1)))
                       ABORT_PARSE;
                   }
                 | FUNC_RET
                   {
-                    if (! ($$ = curr_parser->make_return_command ($1)))
+                    if (! ($$ = curr_parser.make_return_command ($1)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ==========
 // Exceptions
 // ==========
 
 except_command  : UNWIND stash_comment opt_sep opt_list CLEANUP
                   stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser->make_unwind_command ($1, $4, $8, $9, $2, $6)))
+                    if (! ($$ = curr_parser.make_unwind_command ($1, $4, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
                 | TRY stash_comment opt_sep opt_list CATCH
                   stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser->make_try_command ($1, $4, $8, $9, $2, $6)))
+                    if (! ($$ = curr_parser.make_try_command ($1, $4, $8, $9, $2, $6)))
                       ABORT_PARSE;
                   }
                 | TRY stash_comment opt_sep opt_list END
                   {
-                    if (! ($$ = curr_parser->make_try_command ($1, $4, 0, $5, $2, 0)))
+                    if (! ($$ = curr_parser.make_try_command ($1, $4, 0, $5, $2, 0)))
                       ABORT_PARSE;
                   }
                 ;
 
 // ===========================================
 // Some 'subroutines' for function definitions
 // ===========================================
 
 push_fcn_symtab : // empty
                   {
-                    curr_parser->curr_fcn_depth++;
-
-                    if (curr_parser->max_fcn_depth < curr_parser->curr_fcn_depth)
-                      curr_parser->max_fcn_depth = curr_parser->curr_fcn_depth;
+                    curr_parser.curr_fcn_depth++;
+
+                    if (curr_parser.max_fcn_depth < curr_parser.curr_fcn_depth)
+                      curr_parser.max_fcn_depth = curr_parser.curr_fcn_depth;
 
                     parser_symtab_context.push ();
 
                     symbol_table::set_scope (symbol_table::alloc_scope ());
 
-                    curr_parser->function_scopes.push_back (symbol_table::current_scope ());
-
-                    if (! reading_script_file && curr_parser->curr_fcn_depth == 1
-                        && ! curr_parser->parsing_subfunctions)
-                      curr_parser->primary_fcn_scope = symbol_table::current_scope ();
-
-                    if (reading_script_file && curr_parser->curr_fcn_depth > 1)
-                      curr_parser->bison_error ("nested functions not implemented in this context");
+                    curr_parser.function_scopes.push_back (symbol_table::current_scope ());
+
+                    if (! reading_script_file && curr_parser.curr_fcn_depth == 1
+                        && ! curr_parser.parsing_subfunctions)
+                      curr_parser.primary_fcn_scope = symbol_table::current_scope ();
+
+                    if (reading_script_file && curr_parser.curr_fcn_depth > 1)
+                      curr_parser.bison_error ("nested functions not implemented in this context");
                   }
                 ;
 
 // ===========================
 // List of function parameters
 // ===========================
 
 param_list_beg  : '('
@@ -1049,17 +1049,17 @@ param_list_end  : ')'
 
 param_list      : param_list_beg param_list1 param_list_end
                   {
                     curr_lexer->quote_is_transpose = false;
                     $$ = $2;
                   }
                 | param_list_beg error
                   {
-                    curr_parser->bison_error ("invalid parameter list");
+                    curr_parser.bison_error ("invalid parameter list");
                     $$ = 0;
                     ABORT_PARSE;
                   }
                 ;
 
 param_list1     : // empty
                   { $$ = 0; }
                 | param_list2
@@ -1119,21 +1119,21 @@ return_list1    : identifier
 
 // ===========
 // Script file
 // ===========
 
 script_file     : SCRIPT_FILE opt_list END_OF_INPUT
                   {
                     tree_statement *end_of_script
-                      = curr_parser->make_end ("endscript",
+                      = curr_parser.make_end ("endscript",
                                                curr_lexer->input_line_number,
                                                curr_lexer->current_input_column);
 
-                    curr_parser->make_script ($2, end_of_script);
+                    curr_parser.make_script ($2, end_of_script);
 
                     $$ = 0;
                   }
                 ;
 
 // =============
 // Function file
 // =============
@@ -1156,23 +1156,23 @@ function_beg    : push_fcn_symtab FCN st
 
                     if (reading_classdef_file || curr_lexer->parsing_classdef)
                       curr_lexer->maybe_classdef_get_set_method = true;
                   }
                 ;
 
 function        : function_beg function1
                   {
-                    $$ = curr_parser->finish_function (0, $2, $1);
-                    curr_parser->recover_from_parsing_function ();
+                    $$ = curr_parser.finish_function (0, $2, $1);
+                    curr_parser.recover_from_parsing_function ();
                   }
                 | function_beg return_list '=' function1
                   {
-                    $$ = curr_parser->finish_function ($2, $4, $1);
-                    curr_parser->recover_from_parsing_function ();
+                    $$ = curr_parser.finish_function ($2, $4, $1);
+                    curr_parser.recover_from_parsing_function ();
                   }
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id_name = $1->name ();
 
                     curr_lexer->parsed_function_name.top () = true;
@@ -1195,66 +1195,66 @@ fcn_name        : identifier
                 ;
 
 function1       : fcn_name function2
                   {
                     std::string fname = $1->name ();
 
                     delete $1;
 
-                    if (! ($$ = curr_parser->frob_function (fname, $2)))
+                    if (! ($$ = curr_parser.frob_function (fname, $2)))
                       ABORT_PARSE;
                   }
                 ;
 
 function2       : param_list opt_sep opt_list function_end
-                  { $$ = curr_parser->start_function ($1, $3, $4); }
+                  { $$ = curr_parser.start_function ($1, $3, $4); }
                 | opt_sep opt_list function_end
-                  { $$ = curr_parser->start_function (0, $2, $3); }
+                  { $$ = curr_parser.start_function (0, $2, $3); }
                 ;
 
 function_end    : END
                   {
-                    curr_parser->endfunction_found = true;
-                    if (curr_parser->end_token_ok ($1, token::function_end))
-                      $$ = curr_parser->make_end ("endfunction", $1->line (), $1->column ());
+                    curr_parser.endfunction_found = true;
+                    if (curr_parser.end_token_ok ($1, token::function_end))
+                      $$ = curr_parser.make_end ("endfunction", $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 | END_OF_INPUT
                   {
 // A lot of tests are based on the assumption that this is OK
 //                  if (reading_script_file)
 //                    {
-//                      curr_parser->bison_error ("function body open at end of script");
+//                      curr_parser.bison_error ("function body open at end of script");
 //                      YYABORT;
 //                    }
 
-                    if (curr_parser->endfunction_found)
+                    if (curr_parser.endfunction_found)
                       {
-                        curr_parser->bison_error ("inconsistent function endings -- "
+                        curr_parser.bison_error ("inconsistent function endings -- "
                                  "if one function is explicitly ended, "
                                  "so must all the others");
                         YYABORT;
                       }
 
                     if (! (reading_fcn_file || reading_script_file
                            || get_input_from_eval_string))
                       {
-                        curr_parser->bison_error ("function body open at end of input");
+                        curr_parser.bison_error ("function body open at end of input");
                         YYABORT;
                       }
 
                     if (reading_classdef_file)
                       {
-                        curr_parser->bison_error ("classdef body open at end of input");
+                        curr_parser.bison_error ("classdef body open at end of input");
                         YYABORT;
                       }
 
-                    $$ = curr_parser->make_end ("endfunction",
+                    $$ = curr_parser.make_end ("endfunction",
                                                 curr_lexer->input_line_number,
                                                 curr_lexer->current_input_column);
                   }
                 ;
 
 // ========
 // Classdef
 // ========
@@ -1265,18 +1265,18 @@ classdef_beg    : CLASSDEF stash_comment
                     curr_lexer->parsing_classdef = true;
                   }
                 ;
 
 classdef_end    : END
                   {
                     curr_lexer->parsing_classdef = false;
 
-                    if (curr_parser->end_token_ok ($1, token::classdef_end))
-                      $$ = curr_parser->make_end ("endclassdef", $1->line (), $1->column ());
+                    if (curr_parser.end_token_ok ($1, token::classdef_end))
+                      $$ = curr_parser.make_end ("endclassdef", $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 ;
 
 classdef1       : classdef_beg opt_attr_list identifier opt_superclasses
                   { $$ = 0; }
                 ;
@@ -1416,17 +1416,17 @@ class_enum      : identifier '(' express
 // Miscellaneous
 // =============
 
 stash_comment   : // empty
                   { $$ = octave_comment_buffer::get_comment (); }
                 ;
 
 parse_error     : LEXICAL_ERROR
-                  { curr_parser->bison_error ("parse error"); }
+                  { curr_parser.bison_error ("parse error"); }
                 | error
                 ;
 
 sep_no_nl       : ','
                   { $$ = ','; }
                 | ';'
                   { $$ = ';'; }
                 | sep_no_nl ','
@@ -1469,19 +1469,19 @@ opt_comma       : // empty
 
 %%
 
 // Generic error messages.
 
 #undef curr_lexer
 
 static void
-yyerror (octave_parser *curr_parser, const char *s)
+yyerror (octave_parser& curr_parser, const char *s)
 {
-  curr_parser->bison_error (s);
+  curr_parser.bison_error (s);
 }
 
 octave_parser::~octave_parser (void)
 {
 #if defined (OCTAVE_USE_PUSH_PARSER)
   yypstate_delete (static_cast<yypstate *> (parser_state));
 #endif
 
@@ -1518,23 +1518,23 @@ octave_parser::run (void)
   do
     {
       YYSTYPE lval;
 
       int token = octave_lex (&lval, scanner);
 
       yypstate *pstate = static_cast<yypstate *> (parser_state);
 
-      status = octave_push_parse (pstate, token, &lval, this);
+      status = octave_push_parse (pstate, token, &lval, *this);
     }
   while (status == YYPUSH_MORE);
 
 #else
 
-  status = octave_parse (this);
+  status = octave_parse (*this);
 
 #endif
 
   return status;
 }
 
 // Error mesages for mismatched end tokens.
 
@@ -3394,28 +3394,27 @@ parse_fcn_file (const std::string& ff, c
 
   if (ffile)
     {
       bool eof;
 
       // octave_parser constructor sets this for us.
       frame.protect_var (CURR_LEXER);
 
-      octave_parser *curr_parser = new octave_parser ();
-      frame.add_fcn (octave_parser::cleanup, curr_parser);
-
-      curr_parser->curr_class_name = dispatch_type;
-      curr_parser->autoloading = autoload;
-      curr_parser->fcn_file_from_relative_lookup = relative_lookup;
+      octave_parser curr_parser;
+
+      curr_parser.curr_class_name = dispatch_type;
+      curr_parser.autoloading = autoload;
+      curr_parser.fcn_file_from_relative_lookup = relative_lookup;
 
       std::string help_txt
         = gobble_leading_white_space
             (ffile, eof,
-             curr_parser->curr_lexer->input_line_number,
-             curr_parser->curr_lexer->current_input_column);
+             curr_parser.curr_lexer->input_line_number,
+             curr_parser.curr_lexer->current_input_column);
 
       if (! help_txt.empty ())
         help_buf.push (help_txt);
 
       if (! eof)
         {
           std::string file_type;
 
@@ -3467,41 +3466,41 @@ parse_fcn_file (const std::string& ff, c
           // interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
           frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
           if (! help_txt.empty ())
             help_buf.push (help_txt);
 
           if (reading_script_file)
-            curr_parser->curr_lexer->prep_for_script_file ();
+            curr_parser.curr_lexer->prep_for_script_file ();
           else
-            curr_parser->curr_lexer->prep_for_function_file ();
-
-          curr_parser->curr_lexer->parsing_class_method = ! dispatch_type.empty ();
-
-          int status = curr_parser->run ();
-
-          fcn_ptr = curr_parser->primary_fcn_ptr;
+            curr_parser.curr_lexer->prep_for_function_file ();
+
+          curr_parser.curr_lexer->parsing_class_method = ! dispatch_type.empty ();
+
+          int status = curr_parser.run ();
+
+          fcn_ptr = curr_parser.primary_fcn_ptr;
 
           if (status != 0)
             error ("parse error while reading %s file %s",
                    file_type.c_str (), ff.c_str ());
         }
       else
         {
-          int l = curr_parser->curr_lexer->input_line_number;
-          int c = curr_parser->curr_lexer->current_input_column;
+          int l = curr_parser.curr_lexer->input_line_number;
+          int c = curr_parser.curr_lexer->current_input_column;
 
           tree_statement *end_of_script
-            = curr_parser->make_end ("endscript", l, c);
-
-          curr_parser->make_script (0, end_of_script);
-
-          fcn_ptr = curr_parser->primary_fcn_ptr;
+            = curr_parser.make_end ("endscript", l, c);
+
+          curr_parser.make_script (0, end_of_script);
+
+          fcn_ptr = curr_parser.primary_fcn_ptr;
         }
     }
   else if (require_file)
     error ("no such file, '%s'", ff.c_str ());
   else if (! warn_for.empty ())
     error ("%s: unable to open file '%s'", warn_for.c_str (), ff.c_str ());
 
   return fcn_ptr;
@@ -4186,18 +4185,17 @@ eval_string (const std::string& s, bool 
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
   // octave_parser constructor sets this for us.
   frame.protect_var (CURR_LEXER);
 
-  octave_parser *curr_parser = new octave_parser ();
-  frame.add_fcn (octave_parser::cleanup, curr_parser);
+  octave_parser curr_parser;
 
   frame.protect_var (get_input_from_eval_string);
   frame.protect_var (line_editing);
   frame.protect_var (current_eval_string);
   frame.protect_var (reading_fcn_file);
   frame.protect_var (reading_script_file);
   frame.protect_var (reading_classdef_file);
 
@@ -4206,37 +4204,37 @@ eval_string (const std::string& s, bool 
   reading_fcn_file = false;
   reading_script_file = false;
   reading_classdef_file = false;
 
   current_eval_string = s;
 
   do
     {
-      curr_parser->reset ();
+      curr_parser.reset ();
 
       // Do this with an unwind-protect cleanup function so that the
       // forced variables will be unmarked in the event of an
       // interrupt.
       symbol_table::scope_id scope = symbol_table::top_scope ();
       frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
-      parse_status = curr_parser->run ();
+      parse_status = curr_parser.run ();
 
       // Unmark forced variables.
       frame.run (1);
 
       if (parse_status == 0)
         {
-          if (curr_parser->stmt_list)
+          if (curr_parser.stmt_list)
             {
               tree_statement *stmt = 0;
 
-              if (curr_parser->stmt_list->length () == 1
-                  && (stmt = curr_parser->stmt_list->front ())
+              if (curr_parser.stmt_list->length () == 1
+                  && (stmt = curr_parser.stmt_list->front ())
                   && stmt->is_expression ())
                 {
                   tree_expression *expr = stmt->expression ();
 
                   if (silent)
                     expr->set_print_flag (false);
 
                   bool do_bind_ans = false;
@@ -4255,27 +4253,27 @@ eval_string (const std::string& s, bool 
 
                   if (do_bind_ans && ! (error_state || retval.empty ()))
                     bind_ans (retval(0), expr->print_result ());
 
                   if (nargout == 0)
                     retval = octave_value_list ();
                 }
               else if (nargout == 0)
-                curr_parser->stmt_list->accept (*current_evaluator);
+                curr_parser.stmt_list->accept (*current_evaluator);
               else
                 error ("eval: invalid use of statement list");
 
               if (error_state
                   || tree_return_command::returning
                   || tree_break_command::breaking
                   || tree_continue_command::continuing)
                 break;
             }
-          else if (curr_parser->curr_lexer->end_of_input)
+          else if (curr_parser.curr_lexer->end_of_input)
             break;
         }
     }
   while (parse_status == 0);
 
   return retval;
 }
 
