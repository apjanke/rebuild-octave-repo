# HG changeset patch
# User jwe
# Date 773734234 0
#      Sat Jul 09 06:10:34 1994 +0000
# Node ID 0f388340e6079daf89dc5e00ea1d2486f6188b37
# Parent  f264c1454c2b10852f0f24b6446d7070ddd0f3f1
[project @ 1994-07-09 06:10:34 by jwe]

diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -38,29 +38,31 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-balance.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_balance_2 (const Octave_object& args, int nargin, int nargout)
+builtin_balance_2 (const Octave_object& args, int nargout)
 {
-  return balance (args, nargin, nargout);
+  return balance (args, nargout);
 }
 #endif
 
 Octave_object
-balance (const Octave_object& args, int nargin, int nargout)
+balance (const Octave_object& args, int nargout)
 {
   char *bal_job;
   int my_nargin;		// # args w/o optional string arg
   Octave_object retval;
 
+  int nargin = args.length ();
+
   // determine if balancing option is listed
   // set my_nargin to the number of matrix inputs
   if (args(nargin-1).const_type () == tree_constant_rep::string_constant ){
     bal_job = args(nargin-1).string_value ();
     my_nargin = nargin-2;
   }
   else
   {
diff --git a/src/chol.cc b/src/chol.cc
--- a/src/chol.cc
+++ b/src/chol.cc
@@ -31,17 +31,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-chol.h"
 
 #ifdef WITH_DLD
 Octave_object*
-builtin_chol_2 (const Octave_object& args, int nargin, int nargout)
+builtin_chol_2 (const Octave_object& args, int nargout)
 {
   Octave_object retval (1);
   retval(0) = chol (args(1));
   return retval;
 }
 #endif
 
 tree_constant
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -29,27 +29,29 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "error.h"
 #include "utils.h"
 #include "f-colloc.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_colloc_2 (const Octave_object& args, int nargin, int nargout)
+builtin_colloc_2 (const Octave_object& args, int nargout)
 {
-  return collocation_weights (args, nargin);
+  return collocation_weights (args);
 }
 #endif
 
 Octave_object
-collocation_weights (const Octave_object& args, int nargin)
+collocation_weights (const Octave_object& args)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (args(1).const_type () != tree_constant_rep::complex_scalar_constant
       && args(1).const_type () != tree_constant_rep::scalar_constant)
     {
       error ("colloc: first argument must be a scalar");
       return retval;
     }
 
   int ncol = NINT (args(1).double_value ());
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -37,25 +37,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "pager.h"
 #include "f-dassl.h"
 
 // Global pointer for user defined function required by dassl.
 static tree_fvc *dassl_fcn;
 
 #ifdef WITH_DLD
 Octave_object
-builtin_dassl_2 (const Octave_object& args, int nargin, int nargout)
+builtin_dassl_2 (const Octave_object& args, int nargout)
 {
-  return dassl (args, nargin, nargout);
+  return dassl (args, nargout);
 }
 
 Octave_object
-builtin_dassl_options_2 (const Octave_object& args, int nargin, int nargout)
+builtin_dassl_options_2 (const Octave_object& args, int nargout)
 {
-  return dassl_options (args, nargin, nargout);
+  return dassl_options (args, nargout);
 }
 #endif
 
 static ODE_options dassl_opts;
 
 ColumnVector
 dassl_user_function (const ColumnVector& x, const ColumnVector& xdot, double t)
 {
@@ -91,17 +91,17 @@ dassl_user_function (const ColumnVector&
       tree_constant state (d1);
       tree_constant deriv (d2);
       args(1) = state;
       args(2) = deriv;
     }
 
   if (dassl_fcn != (tree_fvc *) NULL)
     {
-      Octave_object tmp = dassl_fcn->eval (0, 1, args, 4);
+      Octave_object tmp = dassl_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  gripe_user_supplied_eval ("dassl");
 	  return retval;
 	}
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
@@ -114,22 +114,24 @@ dassl_user_function (const ColumnVector&
       else
 	gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 Octave_object
-dassl (const Octave_object& args, int nargin, int nargout)
+dassl (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
 
+  int nargin = args.length ();
+
   dassl_fcn = is_valid_function (args(1), "dassl", 1);
   if (dassl_fcn == (tree_fvc *) NULL
       || takes_correct_nargs (dassl_fcn, 4, "dassl", 1) != 1)
     return retval;
 
   ColumnVector state = args(2).to_vector ();
   ColumnVector deriv = args(3).to_vector ();
   ColumnVector out_times = args(4).to_vector ();
@@ -263,20 +265,22 @@ do_dassl_option (char *keyword, double v
 	}
       list++;
     }
 
   warning ("dassl_options: no match for `%s'", keyword);
 }
 
 Octave_object
-dassl_options (const Octave_object& args, int nargin, int nargout)
+dassl_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 1)
     print_dassl_option_list ();
   else if (nargin == 3)
     {
       if (args(1).is_string_type ())
 	{
 	  char *keyword = args(1).string_value ();
 	  double val = args(2).double_value ();
diff --git a/src/det.cc b/src/det.cc
--- a/src/det.cc
+++ b/src/det.cc
@@ -31,17 +31,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-det.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_det_2 (const Octave_object& args, int nargin, int nargout)
+builtin_det_2 (const Octave_object& args, int nargout)
 {
   Octave_object retval (1);
   retval(0) = determinant (args(1));
   return retval;
 }
 #endif
 
 tree_constant
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -35,17 +35,17 @@ extern "C"
 #include "user-prefs.h"
 #include "octave.h"
 #include "utils.h"
 #include "error.h"
 
 void
 octave_dld_tc2_unlink_by_symbol (const char *name, int hard = 1)
 {
-  char *mangled_fcn_name = strconcat (name, "__FP13tree_constantii");
+  char *mangled_fcn_name = strconcat (name, "__FP13tree_constanti");
   int status = dld_unlink_by_symbol (mangled_fcn_name, hard);
   if (status != 0)
     dld_perror ("octave_dld_tc2_unlink_by_symbol");
   delete [] mangled_fcn_name;
 }
 
 void
 octave_dld_tc2_unlink_by_file (const char *name, int hard = 1)
@@ -112,17 +112,17 @@ octave_dld_tc2_link (const char *object)
 
 builtin_fcn_ptr
 octave_dld_tc2 (const char *name, const char *fcn, const char *object)
 {
   builtin_fcn_ptr retval = (builtin_fcn_ptr) NULL;
 
   octave_dld_init ();
 
-  char *mangled_fcn_name = strconcat (fcn, "__FP13tree_constantii");
+  char *mangled_fcn_name = strconcat (fcn, "__FP13tree_constanti");
 
 // See if the function has already been loaded.  If not, mark it as
 // undefined.
 
   if (dld_get_func (mangled_fcn_name) == 0)
     dld_create_reference (mangled_fcn_name);
 
   int status = octave_dld_link (object);
@@ -136,25 +136,25 @@ octave_dld_tc2 (const char *name, const 
 
   delete [] mangled_fcn_name;
 
   return retval;
     
 }
 
 Octave_object
-octave_dld_tc2_and_go (const Octave_object& args, int nargin, int nargout,
+octave_dld_tc2_and_go (const Octave_object& args, int nargout,
 		       const char *name, const char *fcn, const char *object)
 {
   Octave_object retval;
 
   builtin_fcn_ptr fcn_to_call = octave_dld_tc2 (name, fcn, object);
 
   if (fcn_to_call != (builtin_fcn_ptr) NULL)
-    retval = (*fcn_to_call) (args, nargin, nargout);
+    retval = (*fcn_to_call) (args, nargout);
   else
     error ("octave_dld_tc2_and_go: failed to load `%s'", name);
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -32,17 +32,17 @@ extern void octave_dld_tc2_unlink_by_sym
 
 extern void octave_dld_tc2_unlink_by_file (const char *name, int hard = 1);
 
 extern builtin_fcn_ptr octave_dld_tc2 (const char *name,
 				       const char *fcn,
 				       const char *object);
 
 extern Octave_object octave_dld_tc2_and_go (const Octave_object&,
-					    int nargin, int nargout,
+					    int nargout,
 					    const char *name,
 					    const char *fcn,
 					    const char *object);
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/eig.cc b/src/eig.cc
--- a/src/eig.cc
+++ b/src/eig.cc
@@ -30,24 +30,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-eig.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_eig_2 (const Octave_object& args, int nargin, int nargout)
+builtin_eig_2 (const Octave_object& args, int nargout)
 {
-  return eig (args, nargin, nargout);
+  return eig (args, nargout);
 }
 #endif
 
 Octave_object
-eig (const Octave_object& args, int nargin, int nargout)
+eig (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   tree_constant arg = args(1).make_numeric ();
 
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
diff --git a/src/expm.cc b/src/expm.cc
--- a/src/expm.cc
+++ b/src/expm.cc
@@ -39,17 +39,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-expm.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_matrix_exp_2 (const Octave_object& args, int nargin, int nargout)
+builtin_matrix_exp_2 (const Octave_object& args, int nargout)
 {
   Octave_object retval (1);
   retval(0) = matrix_exp (args(1));
   return retval;
 }
 #endif
 
 extern "C"
diff --git a/src/fft.cc b/src/fft.cc
--- a/src/fft.cc
+++ b/src/fft.cc
@@ -31,17 +31,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-fft.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_fft_2 (const Octave_object& args, int nargin, int nargout)
+builtin_fft_2 (const Octave_object& args, int nargout)
 {
   Octave_object retval (1);
   retval(0) = fft (args(1));
   return retval;
 }
 #endif
 
 tree_constant
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -507,20 +507,22 @@ frewind_internal (const Octave_object& a
       file_info file = file_list (p);
       rewind (file.fptr ());
     }
 
   return retval;
 }
 
 Octave_object
-fseek_internal (const Octave_object& args, int nargin)
+fseek_internal (const Octave_object& args)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   Pix p = file_io_get_file (args(1), "a+", "fseek");
 
   if (p == (Pix) NULL)
     return retval;
 
   long origin = SEEK_SET;
   long offset = 0;
   if (args(2).is_scalar_type ())
@@ -601,20 +603,22 @@ close_files (void)
 	    error ("closing %s", file.name ());
 	}
       file_list.del (p);
     }
 }
 
 static int
 process_printf_format (const char *s, const Octave_object& args,
-		       ostrstream& sb, const char *type, int nargin)
+		       ostrstream& sb, const char *type)
 {
   ostrstream fmt;
 
+  int nargin = args.length ();
+
   fmt << "%";  // do_printf() already blew past this one...
 
   tree_constant_rep::constant_type arg_type;
 
   int chars_from_fmt_str = 0;
 
  again:
   switch (*s)
@@ -799,18 +803,17 @@ process_printf_format (const char *s, co
 
  invalid_format:
   error ("%s: invalid format", type);
   return -1;
 }
 
 
 Octave_object
-do_printf (const char *type, const Octave_object& args, int nargin,
-	   int nargout)
+do_printf (const char *type, const Octave_object& args, int nargout)
 {
   Octave_object retval;
   fmt_arg_count = 1;
   char *fmt;
   file_info file;
 
   if (strcmp (type, "fprintf") == 0)
     {
@@ -873,18 +876,17 @@ do_printf (const char *type, const Octav
 	  ptr++;
 	  output_buf << c;
 	  continue;
 	}
 
 // We must be looking at a format specifier.  Extract it or fail.
 
 
-      int status = process_printf_format (ptr, args, output_buf, type,
-					  nargin);
+      int status = process_printf_format (ptr, args, output_buf, type);
 
       if (status < 0)
 	return retval;
 
       ptr += status;
     }
 
   output_buf << ends;
@@ -1064,17 +1066,17 @@ process_scanf_format (const char *s, ost
     invalid_format:
       warning ("%s: invalid format", type);
     }
 
   return -1;
 }
 
 Octave_object
-do_scanf (const char *type, const Octave_object& args, int nargin, int nargout)
+do_scanf (const char *type, const Octave_object& args, int nargout)
 {
   Octave_object retval;
   char *scanf_fmt = (char *) NULL;
   char *tmp_file = (char *) NULL;
   int tmp_file_open = 0;
   FILE *fptr = (FILE *) NULL;
   file_info file;
 
@@ -1266,20 +1268,22 @@ num_items_remaining (FILE *fptr, char *t
  *                 long, ulong, float, double
  *
  *                 Default  is uchar.
  *
  *     data	 : output data
  *     count	 : number of elements read
  */
 Octave_object
-fread_internal (const Octave_object& args, int nargin, int nargout)
+fread_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   Pix p = file_io_get_file (args(1), "r", "fread");
 
   if (p == (Pix) NULL)
     return retval;
 
 // Get type and number of bytes per element to read.
   char *prec = "uchar";
   if (nargin > 3)
@@ -1400,20 +1404,22 @@ fread_internal (const Octave_object& arg
  *                char, uchar, schar, short, ushort, int, uint,
  *                long, float, double
  *
  *                 Default is uchar.
  *
  *    count     : the number of elements written
  */
 Octave_object
-fwrite_internal (const Octave_object& args, int nargin, int nargout)
+fwrite_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   Pix p = file_io_get_file (args(1), "a+", "fwrite");
 
   if (p == (Pix) NULL)
     return retval;
 
 // Get type and number of bytes per element to read.
   char *prec = "uchar";
   if (nargin > 3)
@@ -1443,17 +1449,17 @@ fwrite_internal (const Octave_object& ar
  * Check for an EOF condition on a file opened by fopen.
  *
  *   eof = feof (fid)
  *
  *     fid : file id from fopen
  *     eof : non zero for an end of file condition
  */
 Octave_object
-feof_internal (const Octave_object& args, int nargin, int nargout)
+feof_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 // Get file info.
   Pix p = return_valid_file (args(1));
 
   if (p == (Pix) NULL)
     return retval;
@@ -1471,17 +1477,17 @@ feof_internal (const Octave_object& args
  *
  *   [message, errnum] = ferror (fid)
  *
  *     fid     : file id from fopen
  *     message : system error message
  *     errnum  : error number
  */
 Octave_object
-ferror_internal (const Octave_object& args, int nargin, int nargout)
+ferror_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 // Get file info.
   Pix p = return_valid_file (args(1));
 
   if (p == (Pix) NULL)
     return retval;
diff --git a/src/file-io.h b/src/file-io.h
--- a/src/file-io.h
+++ b/src/file-io.h
@@ -28,41 +28,37 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include <Pix.h>
 
 #include "oct-obj.h"
 
 extern Pix return_valid_file (const tree_constant& arg);
 
 extern Octave_object fclose_internal (const Octave_object& args);
-extern Octave_object feof_internal (const Octave_object& args,
-				    int nargin, int nargout);
-extern Octave_object ferror_internal (const Octave_object& args,
-				      int nargin, int nargout);
+extern Octave_object feof_internal (const Octave_object& args, int nargout);
+extern Octave_object ferror_internal (const Octave_object& args, int nargout);
 extern Octave_object fflush_internal (const Octave_object& args);
 extern Octave_object fgets_internal (const Octave_object& args, int nargout);
 extern Octave_object fopen_internal (const Octave_object& args);
-extern Octave_object fread_internal (const Octave_object& args,
-				     int nargin, int nargout);
+extern Octave_object fread_internal (const Octave_object& args, int nargout);
 extern Octave_object freport_internal (void);
 extern Octave_object frewind_internal (const Octave_object& args);
-extern Octave_object fseek_internal (const Octave_object& args, int nargin);
+extern Octave_object fseek_internal (const Octave_object& args);
 extern Octave_object ftell_internal (const Octave_object& args);
-extern Octave_object fwrite_internal (const Octave_object& args,
-				      int nargin, int nargout);
+extern Octave_object fwrite_internal (const Octave_object& args, int nargout);
 
 extern void initialize_file_io (void);
 
 extern void close_files (void);
 
 extern Octave_object do_printf (const char *type, const Octave_object& args,
-				int nargin, int nargout);
+				int nargout);
 
 extern Octave_object do_scanf (const char *type, const Octave_object& args,
-			       int nargin, int nargout);
+			       int nargout);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -37,25 +37,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "pager.h"
 #include "f-fsolve.h"
 
 // Global pointer for user defined function required by hybrd1.
 static tree_fvc *fsolve_fcn;
 
 #ifdef WITH_DLD
 Octave_object
-builtin_fsolve_2 (const Octave_object& args, int nargin, int nargout)
+builtin_fsolve_2 (const Octave_object& args, int nargout)
 {
-  return fsolve (args, nargin, nargout);
+  return fsolve (args, nargout);
 }
 
 Octave_object
-builtin_fsolve_options (const Octave_object& args, int nargin, int nargout)
+builtin_fsolve_options (const Octave_object& args, int nargout)
 {
-  return fsolve_options (args, nargin, nargout);
+  return fsolve_options (args, nargout);
 }
 #endif
 
 static NLEqn_options fsolve_opts;
 
 int
 hybrd_info_to_fsolve_info (int info)
 {
@@ -107,38 +107,40 @@ fsolve_user_function (const ColumnVector
     {
       double d = x.elem (0);
       tree_constant vars (d);
       args(1) = vars;
     }
 
   if (fsolve_fcn != (tree_fvc *) NULL)
     {
-      Octave_object tmp = fsolve_fcn->eval (0, 1, args, 2);
+      Octave_object tmp = fsolve_fcn->eval (0, 1, args);
       if (tmp.length () > 0 && tmp(0).is_defined ())
 	{
 	  retval = tmp(0).to_vector ();
 
 	  if (retval.length () <= 0)
 	    gripe_user_supplied_eval ("fsolve");
 	}
       else
 	gripe_user_supplied_eval ("fsolve");
     }
 
   return retval;
 }
 
 Octave_object
-fsolve (const Octave_object& args, int nargin, int nargout)
+fsolve (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
 
+  int nargin = args.length ();
+
   fsolve_fcn = is_valid_function (args(1), "fsolve", 1);
   if (fsolve_fcn == (tree_fvc *) NULL
       || takes_correct_nargs (fsolve_fcn, 2, "fsolve", 1) != 1)
     return retval;
 
   ColumnVector x = args(2).to_vector ();
 
   if (nargin > 3)
@@ -246,20 +248,22 @@ do_fsolve_option (char *keyword, double 
 	}
       list++;
     }
 
   warning ("fsolve_options: no match for `%s'", keyword);
 }
 
 Octave_object
-fsolve_options (const Octave_object& args, int nargin, int nargout)
+fsolve_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 1)
     print_fsolve_option_list ();
   else if (nargin == 3)
     {
       if (args(1).is_string_type ())
 	{
 	  char *keyword = args(1).string_value ();
 	  double val = args(2).double_value ();
diff --git a/src/fsqp.cc b/src/fsqp.cc
--- a/src/fsqp.cc
+++ b/src/fsqp.cc
@@ -34,25 +34,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "f-fsqp.h"
 
 // Global pointers for user defined functions required by fsqp.
 // static tree *fsqp_objective;
 // static tree *fsqp_constraints;
 
 #ifdef WITH_DLD
 Octave_object
-builtin_fsqp_2 (const Octave_object& args, int nargin, int nargout)
+builtin_fsqp_2 (const Octave_object& args, int nargout)
 {
-  return fsqp (args, nargin, nargout);
+  return fsqp (args nargout);
 }
 
 Octave_object
-builtin_fsqp_options_2 (const Octave_object& args, int nargin, int nargout)
+builtin_fsqp_options_2 (const Octave_object& args, int nargout)
 {
-  return fsqp_options (args, nargin, nargout);
+  return fsqp_options (args, nargout);
 }
 #endif
 
 double
 fsqp_objective_function (const ColumnVector& x)
 {
   return 0.0;
 }
@@ -60,17 +60,17 @@ fsqp_objective_function (const ColumnVec
 ColumnVector
 fsqp_constraint_function (const ColumnVector& x)
 {
   ColumnVector retval;
   return retval;
 }
 
 Octave_object
-fsqp (const Octave_object& args, int nargin, int nargout)
+fsqp (const Octave_object& args, int nargout)
 {
 /*
 
 Handle all of the following:
 
   1. fsqp (x, phi)
   2. fsqp (x, phi, lb, ub)
   3. fsqp (x, phi, lb, ub, llb, c, lub)
@@ -85,17 +85,17 @@ Handle all of the following:
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
   error ("fsqp: not implemented yet");
   return retval;
 }
 
 Octave_object
-fsqp_options (const Octave_object& args, int nargin, int nargout)
+fsqp_options (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
   error ("fsqp_options: not implemented yet");
   return retval;
 }
 
diff --git a/src/g-builtins.cc b/src/g-builtins.cc
--- a/src/g-builtins.cc
+++ b/src/g-builtins.cc
@@ -100,117 +100,125 @@ extern void _rl_output_character_functio
 #ifndef MAXPATHLEN
 #define MAXPATHLEN 1024
 #endif
 
 #ifdef WITH_DLD
 #include "dynamic-ld.h"
 #define Q_STR(name) #name
 #define DLD_FCN(name) Q_STR (builtin_##name##_2)
-#define DLD_OBJ(name) Q_STR (tc-##name##.o)
-#define DLD_BUILTIN(args,n_in,n_out,name,code) \
-return octave_dld_tc2_and_go (args, n_in, n_out, Q_STR (name), \
+#define DLD_OBJ(name) Q_STR (f-##name##.o)
+#define DLD_BUILTIN(args,n_out,name,code) \
+return octave_dld_tc2_and_go (args, n_out, Q_STR (name), \
 			      DLD_FCN (name), DLD_OBJ (name));
 
 #else
-#define DLD_BUILTIN(name,args,n_in,n_out,code) code
+#define DLD_BUILTIN(name,args,n_out,code) code
 #endif
 
 // Non-zero means that pwd always give verbatim directory, regardless
 // of symbolic link following.
 static int verbatim_pwd = 1;
 
 /*
  * Are all elements of a constant nonzero?
  */
 Octave_object
-builtin_all (const Octave_object& args, int nargin, int nargout)
+builtin_all (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("all");
   else
     {
-      if (args.length () > 0 && args(1).is_defined ())
+      if (nargin > 0 && args(1).is_defined ())
 	{
 	  retval.resize (1);
 	  retval(0) = args(1).all ();
 	}
     }
 
   return retval;
 }
 
 /*
  * Are any elements of a constant nonzero?
  */
 Octave_object
-builtin_any (const Octave_object& args, int nargin, int nargout)
+builtin_any (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("any");
   else
     {
-      if (args.length () > 0 && args(1).is_defined ())
+      if (nargin > 0 && args(1).is_defined ())
 	{
 	  retval.resize (1);
 	  retval(0) = args(1).any ();
 	}
     }
 
   return retval;
 }
 
 /*
  * Balancing for eigenvalue problems
  */
 Octave_object
-builtin_balance (const Octave_object& args, int nargin, int nargout)
+builtin_balance (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin <= 1 || nargin > 4 || nargout < 0 || nargout > 4)
     print_usage ("balance");
   else
     {
-      DLD_BUILTIN (args, nargin, nargout, balance,
-		   retval = balance (args, nargin, nargout));
+      DLD_BUILTIN (args, nargout, balance,
+		   retval = balance (args, nargout));
     }
 
   return retval;
 }
 
 /*
  * Cholesky factorization.
  */
 Octave_object
-builtin_chol (const Octave_object& args, int nargin, int nargout)
+builtin_chol (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 && (nargout == 0 || nargout == 1))
-    DLD_BUILTIN (args, nargin, nargout, chol,
+    DLD_BUILTIN (args, nargout, chol,
 		 {
 		   retval.resize (1);
 		   retval(0) = chol (args(1));
 		 })
   else
     usage ("R = chol(A) \n");
 
   return retval;
 }
 
 /*
  * Clear the screen?
  */
 Octave_object
-builtin_clc (const Octave_object& args, int nargin, int nargout)
+builtin_clc (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   rl_beg_of_line ();
   rl_kill_line (1);
 
 #if ! defined (_GO32_)
   if (term_clrpag)
@@ -225,17 +233,17 @@ builtin_clc (const Octave_object& args, 
 
   return retval;
 }
 
 /*
  * Time in a vector.
  */
 Octave_object
-builtin_clock (const Octave_object& args, int nargin, int nargout)
+builtin_clock (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   time_t now;
   struct tm *tm;
 
   time (&now);
   tm = localtime (&now);
@@ -253,114 +261,122 @@ builtin_clock (const Octave_object& args
 
   return retval;
 }
 
 /*
  * Close the stream to the plotter.
  */
 Octave_object
-builtin_closeplot (const Octave_object& args, int nargin, int nargout)
+builtin_closeplot (const Octave_object& args, int nargout)
 {
   Octave_object retval;
   close_plot_stream ();
   return retval;
 }
 
 /*
  * Collocation roots and weights.
  */
 Octave_object
-builtin_colloc (const Octave_object& args, int nargin, int nargout)
+builtin_colloc (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin < 2 || nargin > 4)
     print_usage ("colloc");
   else
-    DLD_BUILTIN (args, nargin, nargout, colloc,
-		 retval = collocation_weights (args, nargin);)
+    DLD_BUILTIN (args, nargout, colloc,
+		 retval = collocation_weights (args);)
 
   return retval;
 }
 
 /*
  * Cumulative sums and products.
  */
 Octave_object
-builtin_cumprod (const Octave_object& args, int nargin, int nargout)
+builtin_cumprod (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("cumprod");
   else
     {
-      if (args.length () > 0 && args(1).is_defined ())
+      if (nargin > 0 && args(1).is_defined ())
 	{
 	  retval.resize (1);
 	  retval(0) = args(1).cumprod ();
 	}
     }
 
   return retval;
 }
 
 Octave_object
-builtin_cumsum (const Octave_object& args, int nargin, int nargout)
+builtin_cumsum (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("cumsum");
   else
     {
-      if (args.length () > 0 && args(1).is_defined ())
+      if (nargin > 0 && args(1).is_defined ())
 	{
 	  retval.resize (1);
 	  retval(0) = args(1).cumsum ();
 	}
     }
 
   return retval;
 }
 
 /*
  * DAEs.
  */
 Octave_object
-builtin_dassl (const Octave_object& args, int nargin, int nargout)
+builtin_dassl (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if ((nargin == 5 || nargin == 6) && nargout >= 0)
-    DLD_BUILTIN (args, nargin, nargout, dassl,
-		 retval = dassl (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, dassl,
+		 retval = dassl (args, nargout);)
   else
     print_usage ("dassl");
 
   return retval;
 }
 
 Octave_object
-builtin_dassl_options (const Octave_object& args, int nargin, int nargout)
+builtin_dassl_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
-  DLD_BUILTIN (args, nargin, nargout, dassl_options,
-	       retval = dassl_options (args, nargin, nargout);)
+  DLD_BUILTIN (args, nargout, dassl_options,
+	       retval = dassl_options (args, nargout);)
 
   return retval;
 }
 
 /*
  * Time in a string.
  */
 Octave_object
-builtin_date (const Octave_object& args, int nargin, int nargout)
+builtin_date (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   time_t now;
   struct tm *tm;
 
   time (&now);
   tm = localtime (&now);
@@ -374,40 +390,44 @@ builtin_date (const Octave_object& args,
 
   return retval;
 }
 
 /*
  * Determinant of a matrix.
  */
 Octave_object
-builtin_det (const Octave_object& args, int nargin, int nargout)
+builtin_det (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
-    DLD_BUILTIN (args, nargin, nargout, det,
+    DLD_BUILTIN (args, nargout, det,
 		 {
 		   retval.resize (1);
 		   retval(0) = determinant (args(1));
 		 })
   else
     print_usage ("det");
 
   return retval;
 }
 
 /*
  * Diagonal elements of a matrix.
  */
 Octave_object
-builtin_diag (const Octave_object& args, int nargin, int nargout)
+builtin_diag (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
     {
       retval.resize (1);
       retval(0) = args(1).diag ();
     }
   else if (nargin == 3)
     {
       retval.resize (1);
@@ -418,58 +438,64 @@ builtin_diag (const Octave_object& args,
 
   return retval;
 }
 
 /*
  * Display value without trimmings.
  */
 Octave_object
-builtin_disp (const Octave_object& args, int nargin, int nargout)
+builtin_disp (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
     args(1).eval (1);
   else
     print_usage ("disp");
 
   return retval;
 }
 
 /*
  * Compute eigenvalues and eigenvectors.
  */
 Octave_object
-builtin_eig (const Octave_object& args, int nargin, int nargout)
+builtin_eig (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 && (nargout == 0 || nargout == 1 || nargout == 2))
-    DLD_BUILTIN (args, nargin, nargout, eig,
-		 retval = eig (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, eig,
+		 retval = eig (args, nargout);)
   else
     print_usage ("eig");
 
   return retval;
 }
 
 /*
  * Print error message and set the error state.  This should
  * eventually take us up to the top level, possibly printing traceback
  * messages as we go.
  */
 Octave_object
-builtin_error (const Octave_object& args, int nargin, int nargout)
+builtin_error (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   char *msg = "unspecified_error";
 
-  if (nargin == 2 && args.length () > 0 && args(1).is_defined ())
+  int nargin = args.length ();
+
+  if (nargin == 2 && args(1).is_defined ())
     {
       if (args(1).is_string_type ())
 	{
 	  msg = args(1).string_value ();
 
 	  if (msg == (char *) NULL || *msg == '\0')
 	    return retval;
 	}
@@ -483,80 +509,88 @@ builtin_error (const Octave_object& args
 
   return retval;
 }
 
 /*
  * Evaluate text argument as octave source.
  */
 Octave_object
-builtin_eval (const Octave_object& args, int nargin, int nargout)
+builtin_eval (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
     {
       int parse_status = 0;
       retval.resize (1);
       retval(0) = eval_string (args(1), parse_status);
     }
   else
     print_usage ("eval");
 
   return retval;
 }
 
 /*
  * Check if variable or file exists.
  */
 Octave_object
-builtin_exist (const Octave_object& args, int nargin, int nargout)
+builtin_exist (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 && args(1).is_string_type ())
     {
       int status = identifier_exists (args(1).string_value ());
       retval.resize (1);
       retval(0) = tree_constant ((double) status);
     }
   else
     print_usage ("exist");
 
   return retval;
 }
 
 /*
  * Matrix exponential.
  */
 Octave_object
-builtin_expm (const Octave_object& args, int nargin, int nargout)
+builtin_expm (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
-    DLD_BUILTIN (args, nargin, nargout, matrix_exp,
+    DLD_BUILTIN (args, nargout, matrix_exp,
 		 {
 		   retval.resize (1);
 		   retval(0) = matrix_exp (args(1));
 		 })
   else
     print_usage ("expm");
 
   return retval;
 }
 
 /*
  * Identity matrix.
  */
 Octave_object
-builtin_eye (const Octave_object& args, int nargin, int nargout)
+builtin_eye (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   switch (nargin)
     {
     case 2:
       retval.resize (1);
       retval(0) = identity_matrix (args(1));
       break;
     case 3:
       retval.resize (1);
@@ -569,385 +603,427 @@ builtin_eye (const Octave_object& args, 
 
   return retval;
 }
 
 /*
  * Closing a file
  */
 Octave_object
-builtin_fclose (const Octave_object& args, int nargin, int nargout)
+builtin_fclose (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("fclose");
   else
     retval = fclose_internal (args);
 
   return retval;
 }
 
 /*
  * Check file for EOF condition.
  */
 Octave_object
-builtin_feof (const Octave_object& args, int nargin, int nargout)
+builtin_feof (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("feof");
   else
-    retval = feof_internal (args, nargin, nargout);
+    retval = feof_internal (args, nargout);
 
   return retval;
 }
 
 /*
  * Check file for error condition.
  */
 Octave_object
-builtin_ferror (const Octave_object& args, int nargin, int nargout)
+builtin_ferror (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("ferror");
   else
-    retval = ferror_internal (args, nargin, nargout);
+    retval = ferror_internal (args, nargout);
 
   return retval;
 }
 
 /*
  * Evaluate first argument as a function.
  */
 Octave_object
-builtin_feval (const Octave_object& args, int nargin, int nargout)
+builtin_feval (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin > 1)
-    retval = feval (args, nargin, nargout);
+    retval = feval (args, nargout);
   else
     print_usage ("feval");
 
   return retval;
 }
 
 /*
  * Flushing output to a file.
  */
 Octave_object
-builtin_fflush (const Octave_object& args, int nargin, int nargout)
+builtin_fflush (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("fflush");
   else
     retval = fflush_internal (args);
 
   return retval;
 }
 
 /*
  * Fast Fourier Transform.
  */
 Octave_object
-builtin_fft (const Octave_object& args, int nargin, int nargout)
+builtin_fft (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
-    DLD_BUILTIN (args, nargin, nargout, fft,
+    DLD_BUILTIN (args, nargout, fft,
 		 {
 		   retval.resize (1);
 		   retval(0) = fft (args(1));
 		 })
   else
     print_usage ("fft");
 
   return retval;
 }
 
 /*
  * Get a string from a file.
  */
 Octave_object
-builtin_fgets (const Octave_object& args, int nargin, int nargout)
+builtin_fgets (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 3)
     print_usage ("fgets");
   else
     retval = fgets_internal (args, nargout);
 
   return retval;
 }
 
 /*
  * Find nonzero elements.  This should probably only work if
  * do_fortran_indexing is true...
  */
 Octave_object
-builtin_find (const Octave_object& args, int nargin, int nargout)
+builtin_find (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
     {
       retval.resize (1);
       retval(0) = find_nonzero_elem_idx (args(1));
     }
   else
     print_usage ("find");
 
   return retval;
 }
 
 /*
  * Don\'t really count floating point operations.
  */
 Octave_object
-builtin_flops (const Octave_object& args, int nargin, int nargout)
+builtin_flops (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin > 2)
     print_usage ("flops");
 
   warning ("flops always returns zero");
 
   retval.resize (1);
   retval(0) = tree_constant (0.0);
 
   return retval;
 }
 
 /*
  * Opening a file.
  */
 Octave_object
-builtin_fopen (const Octave_object& args, int nargin, int nargout)
+builtin_fopen (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 3)
     print_usage ("fopen");
   else
     retval = fopen_internal (args);
 
   return retval;
 }
 
 /*
  * Formatted printing to a file.
  */
 Octave_object
-builtin_fprintf (const Octave_object& args, int nargin, int nargout)
+builtin_fprintf (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin < 3)
     print_usage ("fprintf");
   else
-    retval = do_printf ("fprintf", args, nargin, nargout);
+    retval = do_printf ("fprintf", args, nargout);
 
   return retval;
 }
 
 /*
  * Read binary data from a file.
  */
 Octave_object
-builtin_fread (const Octave_object& args, int nargin, int nargout)
+builtin_fread (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin < 2 || nargin > 4)
     print_usage ("fread");
   else
-    retval = fread_internal (args, nargin, nargout);
+    retval = fread_internal (args, nargout);
 
   return retval;
 }
 
 /*
  * Rewind a file.
  */
 Octave_object
-builtin_frewind (const Octave_object& args, int nargin, int nargout)
+builtin_frewind (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("frewind");
   else
     retval = frewind_internal (args);
 
   return retval;
 }
 
 /*
  * Report on open files.
  */
 Octave_object
-builtin_freport (const Octave_object& args, int nargin, int nargout)
+builtin_freport (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin > 1)
     warning ("freport: ignoring extra arguments");
 
   retval = freport_internal ();
 
   return retval;
 }
 
 /*
  * Formatted reading from a file.
  */
 Octave_object
-builtin_fscanf (const Octave_object& args, int nargin, int nargout)
+builtin_fscanf (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2 && nargin != 3)
     print_usage ("fscanf");
   else
-    retval = do_scanf ("fscanf", args, nargin, nargout);
+    retval = do_scanf ("fscanf", args, nargout);
 
   return retval;
 }
 
 /*
  * Seek a point in a file for reading and/or writing.
  */
 Octave_object
-builtin_fseek (const Octave_object& args, int nargin, int nargout)
+builtin_fseek (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 3 && nargin != 4)
     print_usage ("fseek");
   else
-    retval = fseek_internal (args, nargin);
+    retval = fseek_internal (args);
 
   return retval;
 }
 
 /*
  * Nonlinear algebraic equations.
  */
 Octave_object
-builtin_fsolve (const Octave_object& args, int nargin, int nargout)
+builtin_fsolve (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin >= 3 && nargin <= 7 && nargout >= 0 && nargout <= 3)
-    DLD_BUILTIN (args, nargin, nargout, fsolve,
-		 retval = fsolve (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, fsolve,
+		 retval = fsolve (args, nargout);)
   else
     print_usage ("fsolve");
 
   return retval;
 }
 
 Octave_object
-builtin_fsolve_options (const Octave_object& args, int nargin, int nargout)
+builtin_fsolve_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
-  DLD_BUILTIN (args, nargin, nargout, fsolve_options,
-	       retval = fsolve_options (args, nargin, nargout);)
+  DLD_BUILTIN (args, nargout, fsolve_options,
+	       retval = fsolve_options (args, nargout);)
 
   return retval;
 }
 
 /*
  * NLPs.
  */
 Octave_object
-builtin_fsqp (const Octave_object& args, int nargin, int nargout)
+builtin_fsqp (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 #if defined (FSQP_MISSING)
   print_usage ("fsqp");
 #else
+  int nargin = args.length ();
+
   if ((nargin == 3 || nargin == 5 || nargin == 6 || nargin == 8
        || nargin == 9 || nargin == 11)
       && (nargout >= 0 && nargout <= 3))
-    DLD_BUILTIN (args, nargin, nargout, fsqp,
-		 retval = fsqp (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, fsqp,
+		 retval = fsqp (args, nargout);)
   else
     print_usage ("fsolve");
 #endif
 
   return retval;
 }
 
 Octave_object
-builtin_fsqp_options (const Octave_object& args, int nargin, int nargout)
+builtin_fsqp_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 #if defined (FSQP_MISSING)
   print_usage ("fsqp_options");
 #else
-  DLD_BUILTIN (args, nargin, nargout, fsqp_options,
-	       retval = fsqp_options (args, nargin, nargout);)
+  DLD_BUILTIN (args, nargout, fsqp_options,
+	       retval = fsqp_options (args, nargout);)
 #endif
 
   return retval;
 }
 
 /*
  * Tell current position of file.
  */
 Octave_object
-builtin_ftell (const Octave_object& args, int nargin, int nargout)
+builtin_ftell (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("ftell");
   else
     retval = ftell_internal (args);
 
   return retval;
 }
 
 /*
  * Write binary data to a file.
  */
 Octave_object
-builtin_fwrite (const Octave_object& args, int nargin, int nargout)
+builtin_fwrite (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin < 3 || nargin > 4)
     print_usage ("fwrite");
   else
-    retval = fwrite_internal (args, nargin, nargout);
+    retval = fwrite_internal (args, nargout);
 
   return retval;
 }
 
 /*
  * Get the value of an environment variable.
  */
 Octave_object
-builtin_getenv (const Octave_object& args, int nargin, int nargout)
+builtin_getenv (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 && args(1).is_string_type ())
     {
       retval.resize (1);
       char *value = getenv (args(1).string_value ());
       if (value != (char *) NULL)
 	retval(0) = tree_constant (value);
       else
 	retval(0) = tree_constant ("");
@@ -957,116 +1033,126 @@ builtin_getenv (const Octave_object& arg
 
   return retval;
 }
 
 /*
  * Inverse Fast Fourier Transform.
  */
 Octave_object
-builtin_ifft (const Octave_object& args, int nargin, int nargout)
+builtin_ifft (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
-    DLD_BUILTIN (args, nargin, nargout, ifft,
+    DLD_BUILTIN (args, nargout, ifft,
 		 {
 		   retval.resize (1);
 		   retval(0) = ifft (args(1));
 		 })
   else
     print_usage ("ifft");
 
   return retval;
 }
 
 /*
  * Inverse of a square matrix.
  */
 Octave_object
-builtin_inv (const Octave_object& args, int nargin, int nargout)
+builtin_inv (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
-    DLD_BUILTIN (args, nargin, nargout, inv,
+    DLD_BUILTIN (args, nargout, inv,
 		 {
 		   retval.resize (1);
 		   retval(0) = inverse (args(1));
 		 })
   else
     print_usage ("inv");
 
   return retval;
 }
 
 /*
  * Prompt user for input.
  */
 Octave_object
-builtin_input (const Octave_object& args, int nargin, int nargout)
+builtin_input (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 || nargin == 3)
     {
       retval.resize (1);
-      retval(0) = get_user_input (args, nargin, nargout);
+      retval(0) = get_user_input (args, nargout);
     }
   else
     print_usage ("input");
 
   return retval;
 }
 
 /*
  * Does the given string name a global variable?
  */
 Octave_object
-builtin_is_global (const Octave_object& args, int nargin, int nargout)
+builtin_is_global (const Octave_object& args, int nargout)
 {
   Octave_object retval(1);
   retval(0) = tree_constant (0.0);
 
+  int nargin = args.length ();
+
   if (nargin == 2 && args(1).is_string_type ())
     {
       char *name = args(1).string_value ();
       if (is_globally_visible (name))
 	retval(0) = tree_constant (1.0);
     }
   else
     print_usage ("is_global");
 
   return retval;
 }
 
 /*
  * Is the argument a string?
  */
 Octave_object
-builtin_isstr (const Octave_object& args, int nargin, int nargout)
+builtin_isstr (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("isstr");
   else
     {
-      if (args.length () > 0 && args(1).is_defined ())
+      if (nargin > 0 && args(1).is_defined ())
 	{
 	  retval.resize (1);
 	  retval(0) = args(1).isstr ();
 	}
     }
 
   return retval;
 }
 
 Octave_object
-builtin_kbhit (const Octave_object& args, int nargin, int nargout)
+builtin_kbhit (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 // XXX FIXME XXX -- add timeout and default value args?
 
   if (interactive)
     {
       int c = kbhit ();
@@ -1079,214 +1165,232 @@ builtin_kbhit (const Octave_object& args
 
   return retval;
 }
 
 /*
  * Maybe help in debugging.
  */
 Octave_object
-builtin_keyboard (const Octave_object& args, int nargin, int nargout)
+builtin_keyboard (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 1 || nargin == 2)
     {
       retval.resize (1);
-      retval(0) = get_user_input (args, nargin, nargout, 1);
+      retval(0) = get_user_input (args, nargout, 1);
     }
   else
     print_usage ("keyboard");
 
   return retval;
 }
 
 /*
  * Matrix logarithm.
  */
 Octave_object
-builtin_logm (const Octave_object& args, int nargin, int nargout)
+builtin_logm (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
     retval = matrix_log (args(1));
   else
     print_usage ("logm");
 
   return retval;
 }
 
 /*
  * LPs.
  */
 Octave_object
-builtin_lpsolve (const Octave_object& args, int nargin, int nargout)
+builtin_lpsolve (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 // Force a bad value of inform, and empty matrices for x and phi.
   retval.resize (3);
   Matrix m;
   retval(0) = tree_constant (m);
   retval(1) = tree_constant (m);
   retval(2) = tree_constant (-1.0);
 
+  int nargin = args.length ();
+
   if (nargin == 0)
-    DLD_BUILTIN (args, nargin, nargout, lpsolve,
-		 retval = lpsolve (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, lpsolve,
+		 retval = lpsolve (args, nargout);)
   else
     print_usage ("lp_solve");
 
   return retval;
 }
 
 Octave_object
-builtin_lpsolve_options (const Octave_object& args, int nargin, int nargout)
+builtin_lpsolve_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
-  DLD_BUILTIN (args, nargin, nargout, lpsolve_options,
-	       retval = lpsolve_options (args, nargin, nargout);)
+  DLD_BUILTIN (args, nargout, lpsolve_options,
+	       retval = lpsolve_options (args, nargout);)
 
   return retval;
 }
 
 /*
  * ODEs.
  */
 Octave_object
-builtin_lsode (const Octave_object& args, int nargin, int nargout)
+builtin_lsode (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if ((nargin == 4 || nargin == 5) && (nargout == 0 || nargout == 1))
-    DLD_BUILTIN (args, nargin, nargout, lsode,
-		 retval = lsode (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, lsode,
+		 retval = lsode (args, nargout);)
   else
     print_usage ("lsode");
 
   return retval;
 }
 
 Octave_object
-builtin_lsode_options (const Octave_object& args, int nargin, int nargout)
+builtin_lsode_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
-  DLD_BUILTIN (args, nargin, nargout, lsode_options,
-	       retval = lsode_options (args, nargin, nargout);)
+  DLD_BUILTIN (args, nargout, lsode_options,
+	       retval = lsode_options (args, nargout);)
 
   return retval;
 }
 
 /*
  * LU factorization.
  */
 Octave_object
-builtin_lu (const Octave_object& args, int nargin, int nargout)
+builtin_lu (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 && nargout < 4)
-    DLD_BUILTIN (args, nargin, nargout, lu,
+    DLD_BUILTIN (args, nargout, lu,
 		 retval = lu (args(1), nargout);)
   else
     print_usage ("lu");
 
   return retval;
 }
 
 /*
  * Max values.
  */
 Octave_object
-builtin_max (const Octave_object& args, int nargin, int nargout)
+builtin_max (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if ((nargin == 2 && (nargout == 0 || nargout == 1 || nargout == 2))
       || (nargin == 3 && (nargout == 0 || nargout == 1)))
-    retval = column_max (args, nargin, nargout);
+    retval = column_max (args, nargout);
   else
     print_usage ("max");
 
   return retval;
 }
 
 /*
  * Min values.
  */
 Octave_object
-builtin_min (const Octave_object& args, int nargin, int nargout)
+builtin_min (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if ((nargin == 2 && (nargout == 0 || nargout == 1 || nargout == 2))
       || (nargin == 3 && (nargout == 0 || nargout == 1)))
-    retval = column_min (args, nargin, nargout);
+    retval = column_min (args, nargout);
   else
     print_usage ("min");
 
   return retval;
 }
 
 /*
  * NLPs.
  */
 Octave_object
-builtin_npsol (const Octave_object& args, int nargin, int nargout)
+builtin_npsol (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 #if defined (NPSOL_MISSING)
 // Force a bad value of inform, and empty matrices for x, phi, and lambda.
   retval.resize (3);
   Matrix m;
   retval(0) = tree_constant (m);
   retval(1) = tree_constant (m);
   retval(2) = tree_constant (-1.0);
   retval(3) = tree_constant (m);
   print_usage ("npsol");
 #else
+  int nargin = args.length ();
+
   if ((nargin == 3 || nargin == 5 || nargin == 6 || nargin == 8
        || nargin == 9 || nargin == 11)
       && (nargout >= 0 && nargout <= 4))
-    DLD_BUILTIN (args, nargin, nargout, npsol,
-		 retval = npsol (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, npsol,
+		 retval = npsol (args, nargout);)
   else
     print_usage ("npsol");
 #endif
 
   return retval;
 }
 
 Octave_object
-builtin_npsol_options (const Octave_object& args, int nargin, int nargout)
+builtin_npsol_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 #if defined (NPSOL_MISSING)
   print_usage ("npsol_options");
 #else
-  DLD_BUILTIN (args, nargin, nargout, npsol_options,
-	       retval = npsol_options (args, nargin, nargout);)
+  DLD_BUILTIN (args, nargout, npsol_options,
+	       retval = npsol_options (args, nargout);)
 #endif
 
   return retval;
 }
 
 /*
  * A matrix of ones.
  */
 Octave_object
-builtin_ones (const Octave_object& args, int nargin, int nargout)
+builtin_ones (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   switch (nargin)
     {
     case 2:
       retval.resize (1);
       retval(0) = fill_matrix (args(1), 1.0, "ones");
       break;
     case 3:
       retval.resize (1);
@@ -1299,20 +1403,22 @@ builtin_ones (const Octave_object& args,
 
   return retval;
 }
 
 /*
  * You guessed it.
  */
 Octave_object
-builtin_pause (const Octave_object& args, int nargin, int nargout)
+builtin_pause (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (! (nargin == 1 || nargin == 2))
     {
       print_usage ("pause");
       return retval;
     }
 
   if (interactive)
     {
@@ -1336,66 +1442,70 @@ builtin_pause (const Octave_object& args
 
   return retval;
 }
 
 /*
  * Delete turds from /tmp.
  */
 Octave_object
-builtin_purge_tmp_files (const Octave_object& , int, int)
+builtin_purge_tmp_files (const Octave_object& args, int nargout)
 {
   Octave_object retval;
   cleanup_tmp_files ();
   return retval;
 }
 
 /*
  * Formatted printing.
  */
 Octave_object
-builtin_printf (const Octave_object& args, int nargin, int nargout)
+builtin_printf (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin < 2)
     print_usage ("printf");
   else
-    retval = do_printf ("printf", args, nargin, nargout);
+    retval = do_printf ("printf", args, nargout);
 
   return retval;
 }
 
 /*
  * Product.
  */
 Octave_object
-builtin_prod (const Octave_object& args, int nargin, int nargout)
+builtin_prod (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("prod");
   else
     {
-      if (args.length () > 0 && args(1).is_defined ())
+      if (nargin > 0 && args(1).is_defined ())
 	{
 	  retval.resize (1);
 	  retval(0) = args(1).prod ();
 	}
     }
 
   return retval;
 }
 
 /*
  * Print name of current working directory.
  */
 Octave_object
-builtin_pwd (const Octave_object& args, int nargin, int nargout)
+builtin_pwd (const Octave_object& args, int nargout)
 {
   Octave_object retval;
   char *directory;
 
   if (verbatim_pwd)
     {
       char *buffer = new char [MAXPATHLEN];
       directory = getcwd (buffer, MAXPATHLEN);
@@ -1420,190 +1530,206 @@ builtin_pwd (const Octave_object& args, 
     }
   return retval;
 }
 
 /*
  * QPs.
  */
 Octave_object
-builtin_qpsol (const Octave_object& args, int nargin, int nargout)
+builtin_qpsol (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 #if defined (QPSOL_MISSING)
 // Force a bad value of inform, and empty matrices for x, phi, and lambda.
   retval.resize (4);
   Matrix m;
   retval(0) = tree_constant (m);
   retval(1) = tree_constant (m);
   retval(2) = tree_constant (-1.0);
   retval(3) = tree_constant (m);
   print_usage ("qpsol");
 #else
+  int nargin = args.length ();
+
   if ((nargin == 4 || nargin == 6 || nargin == 7 || nargin == 9)
       && (nargout >= 0 && nargout <= 4))
-    DLD_BUILTIN (args, nargin, nargout, qpsol,
-		 retval = qpsol (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, qpsol,
+		 retval = qpsol (args, nargout);)
   else
     print_usage ("qpsol");
 #endif
 
   return retval;
 }
 
 Octave_object
-builtin_qpsol_options (const Octave_object& args, int nargin, int nargout)
+builtin_qpsol_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 #if defined (QPSOL_MISSING)
   print_usage ("qpsol");
 #else
-  DLD_BUILTIN (args, nargin, nargout, qpsol_options,
-	       retval = qpsol_options (args, nargin, nargout);)
+  DLD_BUILTIN (args, nargout, qpsol_options,
+	       retval = qpsol_options (args, nargout);)
 #endif
 
   return retval;
 }
 
 /*
  * QR factorization.
  */
 Octave_object
-builtin_qr (const Octave_object& args, int nargin, int nargout)
+builtin_qr (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 && nargout < 3)
-    DLD_BUILTIN (args, nargin, nargout, qr,
+    DLD_BUILTIN (args, nargout, qr,
 		 retval = qr (args(1), nargout);)
   else
     print_usage ("qr");
 
   return retval;
 }
 
 /*
  * generalized eigenvalues via qz
  */
 Octave_object
-builtin_qzval (const Octave_object& args, int nargin, int nargout)
+builtin_qzval (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 3 && nargout < 2)
-    DLD_BUILTIN (args, nargin, nargout, qzvalue,
-		 retval = qzvalue (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, qzvalue,
+		 retval = qzvalue (args, nargout);)
   else
     print_usage ("qzval");
 
   return retval;
 }
 
 /*
  * Random numbers.
  */
 Octave_object
-builtin_quad (const Octave_object& args, int nargin, int nargout)
+builtin_quad (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if ((nargin > 3 && nargin < 7) && (nargout >= 0 && nargout < 5))
-    DLD_BUILTIN (args, nargin, nargout, quad,
-		 retval = do_quad (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, quad,
+		 retval = do_quad (args, nargout);)
   else
     print_usage ("quad");
 
   return retval;
 }
 
 Octave_object
-builtin_quad_options (const Octave_object& args, int nargin, int nargout)
+builtin_quad_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
-  DLD_BUILTIN (args, nargin, nargout, quad_options,
-	       retval = quad_options (args, nargin, nargout);)
+  DLD_BUILTIN (args, nargout, quad_options,
+	       retval = quad_options (args, nargout);)
 
   return retval;
 }
 
 /*
  * I'm outta here.
  */
 Octave_object
-builtin_quit (const Octave_object& args, int nargin, int nargout)
+builtin_quit (const Octave_object& args, int nargout)
 {
   Octave_object retval;
   quitting_gracefully = 1;
   clean_up_and_exit (0);
   return retval;
 }
 
 /*
  * Random numbers.
  */
 Octave_object
-builtin_rand (const Octave_object& args, int nargin, int nargout)
+builtin_rand (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if ((nargin > 0 && nargin < 4) && (nargout == 0 || nargout == 1))
-    DLD_BUILTIN (args, nargin, nargout, rand,
-		 retval = rand_internal (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, rand,
+		 retval = rand_internal (args, nargout);)
   else
     print_usage ("rand");
 
   return retval;
 }
 
 /*
  * Formatted reading.
  */
 Octave_object
-builtin_scanf (const Octave_object& args, int nargin, int nargout)
+builtin_scanf (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("scanf");
   else
-    retval = do_scanf ("scanf", args, nargin, nargout);
+    retval = do_scanf ("scanf", args, nargout);
 
   return retval;
 }
 
 /*
  * Convert a vector to a string.
  */
 Octave_object
-builtin_setstr (const Octave_object& args, int nargin, int nargout)
+builtin_setstr (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
     {
       retval.resize (1);
       retval(0) = args(1).convert_to_str ();
     }
   else
     print_usage ("setstr");
 
   return retval;
 }
 
 /*
  * Execute a shell command.
  */
 Octave_object
-builtin_shell_command (const Octave_object& args, int nargin, int nargout)
+builtin_shell_command (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 && args(1).is_string_type ())
     {
       iprocstream cmd (args(1).string_value ());
       char ch;
       ostrstream output_buf;
       while (cmd.get (ch))
 	output_buf.put (ch);
       output_buf << ends;
@@ -1628,25 +1754,27 @@ builtin_shell_command (const Octave_obje
 
   return retval;
 }
 
 /*
  * Report rows and columns.
  */
 Octave_object
-builtin_size (const Octave_object& args, int nargin, int nargout)
+builtin_size (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("size");
   else
     {
-      if (args.length () > 0 && args(1).is_defined ())
+      if (nargin > 0 && args(1).is_defined ())
 	{
 	  int nr = args(1).rows ();
 	  int nc = args(1).columns ();
 	  if (nargout == 0 || nargout == 1)
 	    {
 	      Matrix m (1, 2);
 	      m.elem (0, 0) = nr;
 	      m.elem (0, 1) = nc;
@@ -1666,212 +1794,237 @@ builtin_size (const Octave_object& args,
 
   return retval;
 }
 
 /*
  * Sort columns.
  */
 Octave_object
-builtin_sort (const Octave_object& args, int nargin, int nargout)
+builtin_sort (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
-    retval = sort (args, nargin, nargout);
+    retval = sort (args, nargout);
   else
     print_usage ("sort");
 
   return retval;
 }
 
 /*
  * Formatted printing to a string.
  */
 Octave_object
-builtin_sprintf (const Octave_object& args, int nargin, int nargout)
+builtin_sprintf (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin < 2)
     print_usage ("sprintf");
   else
-    retval = do_printf ("sprintf", args, nargin, nargout);
+    retval = do_printf ("sprintf", args, nargout);
 
   return retval;
 }
 
 /*
  * Matrix sqrt.
  */
 Octave_object
-builtin_sqrtm (const Octave_object& args, int nargin, int nargout)
+builtin_sqrtm (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2)
     retval = matrix_sqrt (args(1));
   else
     print_usage ("sqrtm");
 
   return retval;
 }
 
 /*
  * Formatted reading from a string.
  */
 Octave_object
-builtin_sscanf (const Octave_object& args, int nargin, int nargout)
+builtin_sscanf (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 3)
     print_usage ("sscanf");
   else
-    retval = do_scanf ("sscanf", args, nargin, nargout);
+    retval = do_scanf ("sscanf", args, nargout);
 
   return retval;
 }
 
 /*
  * Sum.
  */
 Octave_object
-builtin_sum (const Octave_object& args, int nargin, int nargout)
+builtin_sum (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("sum");
   else
     {
-      if (args.length () > 0 && args(1).is_defined ())
+      if (nargin > 0 && args(1).is_defined ())
 	{
 	  retval.resize (1);
 	  retval(0) = args(1).sum ();
 	}
     }
 
   return retval;
 }
 
 /*
  * Sum of squares.
  */
 Octave_object
-builtin_sumsq (const Octave_object& args, int nargin, int nargout)
+builtin_sumsq (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin != 2)
     print_usage ("sumsq");
   else
     {
-      if (args.length () > 0 && args(1).is_defined ())
+      if (nargin > 0 && args(1).is_defined ())
 	{
 	  retval.resize (1);
 	  retval(0) = args(1).sumsq ();
 	}
     }
 
   return retval;
 }
 
 /*
  * Singluar value decomposition.
  */
 Octave_object
-builtin_svd (const Octave_object& args, int nargin, int nargout)
+builtin_svd (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 && (nargout == 0 || nargout == 1 || nargout == 3))
-    DLD_BUILTIN (args, nargin, nargout, svd,
-		 retval = svd (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, svd,
+		 retval = svd (args, nargout);)
   else
     print_usage ("svd");
 
   return retval;
 }
 
 /*
  * Sylvester equation solver.
  */
 Octave_object
-builtin_syl (const Octave_object& args, int nargin, int nargout)
+builtin_syl (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if ((nargin == 4) && (nargout == 0 || nargout == 1))
-    DLD_BUILTIN (args, nargin, nargout, syl,
-		 retval = syl (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, syl,
+		 retval = syl (args, nargout);)
   else
     print_usage ("syl");
 
   return retval;
 }
 
 /*
  * Schur Decomposition.
  */
 Octave_object
-builtin_schur (const Octave_object& args, int nargin, int nargout)
+builtin_schur (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if ((nargin == 3 || nargin == 2)
       && (nargout == 0 || nargout == 1 || nargout == 2))
-    DLD_BUILTIN (args, nargin, nargout, schur,
-		 retval = schur (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, schur,
+		 retval = schur (args, nargout);)
   else
     print_usage ("schur");
 
   return retval;
 }
 
 /*
  * Givens rotation.
  */
 Octave_object
-builtin_givens (const Octave_object& args, int nargin, int nargout)
+builtin_givens (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 3 && (nargout == 0 || nargout == 1 || nargout == 2 ))
-    retval = givens (args, nargin, nargout);
+    retval = givens (args, nargout);
   else
     print_usage ("givens");
 
   return retval;
 }
 
 /*
  * Hessenberg Decomposition.
  */
 Octave_object
-builtin_hess (const Octave_object& args, int nargin, int nargout)
+builtin_hess (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 2 && (nargout == 0 || nargout == 1 || nargout == 2))
-    DLD_BUILTIN (args, nargin, nargout, hess,
-		 retval = hess (args, nargin, nargout);)
+    DLD_BUILTIN (args, nargout, hess,
+		 retval = hess (args, nargout);)
   else
     print_usage ("hess");
 
   return retval;
 }
 
 /*
  * Variable argument lists.
  */
 Octave_object
-builtin_va_arg (const Octave_object& args, int nargin, int nargout)
+builtin_va_arg (const Octave_object& args, int nargout)
 {
   Octave_object retval;
+
+  int nargin = args.length ();
+
   if (nargin == 1)
     {
       if (curr_function != (tree_function *) NULL)
 	{
 	  if (curr_function->takes_varargs ())
 	    {
 	      retval.resize (1);
 	      retval(0) = curr_function->octave_va_arg ();
@@ -1887,19 +2040,22 @@ builtin_va_arg (const Octave_object& arg
     }
   else
     print_usage ("va_arg");
 
   return retval;
 }
 
 Octave_object
-builtin_va_start (const Octave_object& args, int nargin, int nargout)
+builtin_va_start (const Octave_object& args, int nargout)
 {
   Octave_object retval;
+
+  int nargin = args.length ();
+
   if (nargin == 1)
     {
       if (curr_function != (tree_function *) NULL)
 	{
 	  if (curr_function->takes_varargs ())
 	    curr_function->octave_va_start ();
 	  else
 	    {
@@ -1915,17 +2071,17 @@ builtin_va_start (const Octave_object& a
 
   return retval;
 }
 
 /*
  * Copying information.
  */
 Octave_object
-builtin_warranty (const Octave_object& args, int nargin, int nargout)
+builtin_warranty (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   ostrstream output_buf;
   output_buf << "\n    Octave, version " << version_string
 	     << ".  Copyright (C) 1992, 1993, 1994 John W. Eaton\n"
 	     << "\n\
     This program is free software; you can redistribute it and/or modify\n\
@@ -1945,20 +2101,22 @@ builtin_warranty (const Octave_object& a
 
   return retval;
 }
 
 /*
  * A matrix of zeros.
  */
 Octave_object
-builtin_zeros (const Octave_object& args, int nargin, int nargout)
+builtin_zeros (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   switch (nargin)
     {
     case 2:
       retval.resize (1);
       retval(0) = fill_matrix (args(1), 0.0, "zeros");
       break;
     case 3:
       retval.resize (1);
diff --git a/src/g-builtins.h b/src/g-builtins.h
--- a/src/g-builtins.h
+++ b/src/g-builtins.h
@@ -30,111 +30,217 @@ struct builtin_general_functions
 {
   char *name;
   int nargin_max;
   int nargout_max;
   General_fcn general_fcn;
   char *help_string;
 };
 
-extern Octave_object builtin_all (const Octave_object&, int, int);
-extern Octave_object builtin_any (const Octave_object&, int, int);
-extern Octave_object builtin_balance (const Octave_object&, int, int);
-extern Octave_object builtin_chol (const Octave_object&, int, int);
-extern Octave_object builtin_clc (const Octave_object&, int, int);
-extern Octave_object builtin_clock (const Octave_object&, int, int);
-extern Octave_object builtin_closeplot (const Octave_object&, int, int);
-extern Octave_object builtin_colloc (const Octave_object&, int, int);
-extern Octave_object builtin_cumprod (const Octave_object&, int, int);
-extern Octave_object builtin_cumsum (const Octave_object&, int, int);
-extern Octave_object builtin_dassl (const Octave_object&, int, int);
-extern Octave_object builtin_dassl_options (const Octave_object&, int, int);
-extern Octave_object builtin_date (const Octave_object&, int, int);
-extern Octave_object builtin_det (const Octave_object&, int, int);
-extern Octave_object builtin_diag (const Octave_object&, int, int);
-extern Octave_object builtin_disp (const Octave_object&, int, int);
-extern Octave_object builtin_eig (const Octave_object&, int, int);
-extern Octave_object builtin_error (const Octave_object&, int, int);
-extern Octave_object builtin_eval (const Octave_object&, int, int);
-extern Octave_object builtin_exist (const Octave_object&, int, int);
-extern Octave_object builtin_expm (const Octave_object&, int, int);
-extern Octave_object builtin_eye (const Octave_object&, int, int);
-extern Octave_object builtin_fclose (const Octave_object&, int, int);
-extern Octave_object builtin_feof (const Octave_object&, int, int);
-extern Octave_object builtin_ferror (const Octave_object&, int, int);
-extern Octave_object builtin_feval (const Octave_object&, int, int);
-extern Octave_object builtin_fflush (const Octave_object&, int, int);
-extern Octave_object builtin_fft (const Octave_object&, int, int);
-extern Octave_object builtin_fgets (const Octave_object&, int, int);
-extern Octave_object builtin_find (const Octave_object&, int, int);
-extern Octave_object builtin_flops (const Octave_object&, int, int);
-extern Octave_object builtin_fopen (const Octave_object&, int, int);
-extern Octave_object builtin_fprintf (const Octave_object&, int, int);
-extern Octave_object builtin_fread (const Octave_object&, int, int);
-extern Octave_object builtin_frewind (const Octave_object&, int, int);
-extern Octave_object builtin_freport (const Octave_object&, int, int);
-extern Octave_object builtin_fscanf (const Octave_object&, int, int);
-extern Octave_object builtin_fseek (const Octave_object&, int, int);
-extern Octave_object builtin_fsolve (const Octave_object&, int, int);
-extern Octave_object builtin_fsolve_options (const Octave_object&, int, int);
-extern Octave_object builtin_fsqp (const Octave_object&, int, int);
-extern Octave_object builtin_fsqp_options (const Octave_object&, int, int);
-extern Octave_object builtin_ftell (const Octave_object&, int, int);
-extern Octave_object builtin_fwrite (const Octave_object&, int, int);
-extern Octave_object builtin_getenv (const Octave_object&, int, int);
-extern Octave_object builtin_givens (const Octave_object&, int, int);
-extern Octave_object builtin_hess (const Octave_object&, int, int);
-extern Octave_object builtin_input (const Octave_object&, int, int);
-extern Octave_object builtin_ifft (const Octave_object&, int, int);
-extern Octave_object builtin_inv (const Octave_object&, int, int);
-extern Octave_object builtin_is_global (const Octave_object&, int, int);
-extern Octave_object builtin_isstr (const Octave_object&, int, int);
-extern Octave_object builtin_kbhit (const Octave_object&, int, int);
-extern Octave_object builtin_keyboard (const Octave_object&, int, int);
-extern Octave_object builtin_logm (const Octave_object&, int, int);
-extern Octave_object builtin_lpsolve (const Octave_object&, int, int);
-extern Octave_object builtin_lpsolve_options (const Octave_object&, int, int);
-extern Octave_object builtin_lsode (const Octave_object&, int, int);
-extern Octave_object builtin_lsode_options (const Octave_object&, int, int);
-extern Octave_object builtin_lu (const Octave_object&, int, int);
-extern Octave_object builtin_max (const Octave_object&, int, int);
-extern Octave_object builtin_min (const Octave_object&, int, int);
-extern Octave_object builtin_npsol (const Octave_object&, int, int);
-extern Octave_object builtin_npsol_options (const Octave_object&, int, int);
-extern Octave_object builtin_ones (const Octave_object&, int, int);
-extern Octave_object builtin_pause (const Octave_object&, int, int);
-extern Octave_object builtin_purge_tmp_files (const Octave_object&, int, int);
-extern Octave_object builtin_printf (const Octave_object&, int, int);
-extern Octave_object builtin_prod (const Octave_object&, int, int);
-extern Octave_object builtin_pwd (const Octave_object&, int, int);
-extern Octave_object builtin_qpsol (const Octave_object&, int, int);
-extern Octave_object builtin_qpsol_options (const Octave_object&, int, int);
-extern Octave_object builtin_qr (const Octave_object&, int, int);
-extern Octave_object builtin_quad (const Octave_object&, int, int);
-extern Octave_object builtin_quad_options (const Octave_object&, int, int);
-extern Octave_object builtin_quit (const Octave_object&, int, int);
-extern Octave_object builtin_qzval (const Octave_object&, int, int);
-extern Octave_object builtin_rand (const Octave_object&, int, int);
-extern Octave_object builtin_setstr (const Octave_object&, int, int);
-extern Octave_object builtin_scanf (const Octave_object&, int, int);
-extern Octave_object builtin_schur (const Octave_object&, int, int);
-extern Octave_object builtin_shell_command (const Octave_object&, int, int);
-extern Octave_object builtin_size (const Octave_object&, int, int);
-extern Octave_object builtin_sort (const Octave_object&, int, int);
-extern Octave_object builtin_sprintf (const Octave_object&, int, int);
-extern Octave_object builtin_sqrtm (const Octave_object&, int, int);
-extern Octave_object builtin_sscanf (const Octave_object&, int, int);
-extern Octave_object builtin_sum (const Octave_object&, int, int);
-extern Octave_object builtin_sumsq (const Octave_object&, int, int);
-extern Octave_object builtin_svd (const Octave_object&, int, int);
-extern Octave_object builtin_syl (const Octave_object&, int, int);
-extern Octave_object builtin_va_arg (const Octave_object&, int, int);
-extern Octave_object builtin_va_start (const Octave_object&, int, int);
-extern Octave_object builtin_warranty (const Octave_object&, int, int);
-extern Octave_object builtin_zeros (const Octave_object&, int, int);
+extern Octave_object builtin_all (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_any (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_balance (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_chol (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_clc (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_clock (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_closeplot (const Octave_object& args,
+					int nargout);
+
+extern Octave_object builtin_colloc (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_cumprod (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_cumsum (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_dassl (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_dassl_options (const Octave_object& args,
+					    int nargout);
+
+extern Octave_object builtin_date (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_det (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_diag (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_disp (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_eig (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_error (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_eval (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_exist (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_expm (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_eye (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fclose (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_feof (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_ferror (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_feval (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fflush (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fft (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fgets (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_find (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_flops (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fopen (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fprintf (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fread (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_frewind (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_freport (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fscanf (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fseek (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fsolve (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fsolve_options (const Octave_object& args,
+					     int nargout);
+
+extern Octave_object builtin_fsqp (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fsqp_options (const Octave_object& args,
+					   int nargout);
+
+extern Octave_object builtin_ftell (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_fwrite (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_getenv (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_givens (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_hess (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_input (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_ifft (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_inv (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_is_global (const Octave_object& args,
+					int nargout);
+
+extern Octave_object builtin_isstr (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_kbhit (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_keyboard (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_logm (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_lpsolve (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_lpsolve_options (const Octave_object& args,
+					      int nargout);
+
+extern Octave_object builtin_lsode (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_lsode_options (const Octave_object& args,
+					    int nargout);
+
+extern Octave_object builtin_lu (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_max (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_min (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_npsol (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_npsol_options (const Octave_object& args,
+					    int nargout);
+
+extern Octave_object builtin_ones (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_pause (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_purge_tmp_files (const Octave_object& args,
+					      int nargout);
+
+extern Octave_object builtin_printf (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_prod (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_pwd (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_qpsol (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_qpsol_options (const Octave_object& args,
+					    int nargout);
+
+extern Octave_object builtin_qr (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_quad (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_quad_options (const Octave_object& args,
+					   int nargout);
+
+extern Octave_object builtin_quit (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_qzval (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_rand (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_setstr (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_scanf (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_schur (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_shell_command (const Octave_object& args,
+					    int nargout);
+
+extern Octave_object builtin_size (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_sort (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_sprintf (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_sqrtm (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_sscanf (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_sum (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_sumsq (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_svd (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_syl (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_va_arg (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_va_start (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_warranty (const Octave_object& args, int nargout);
+
+extern Octave_object builtin_zeros (const Octave_object& args, int nargout);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/givens.cc b/src/givens.cc
--- a/src/givens.cc
+++ b/src/givens.cc
@@ -53,24 +53,24 @@ int F77_FCN (dorgqr) (const int*, const 
   
 int F77_FCN (zunghr) (const int*, const int*, const int*, Complex*,
 		      const int*, Complex*, Complex*, const int*,
 		      int*, long, long);
 #endif
 
 #ifdef WITH_DLD
 Octave_object
-builtin_givens_2 (const Octave_object& args, int nargin, int nargout)
+builtin_givens_2 (const Octave_object& args int nargout)
 {
-  return givens (args, nargin, nargout);
+  return givens (args, nargout);
 }
 #endif
 
 Octave_object
-givens (const Octave_object& args, int nargin, int nargout)
+givens (const Octave_object& args, int nargout)
 {
 
   Octave_object retval;
 
   tree_constant arga = args(1).make_numeric ();
   tree_constant argb = args(2).make_numeric ();
 
   if (! arga.is_scalar_type () && argb.is_scalar_type ())
diff --git a/src/hess.cc b/src/hess.cc
--- a/src/hess.cc
+++ b/src/hess.cc
@@ -31,24 +31,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
 #include "f-hess.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_hess_2 (const Octave_object& args, int nargin, int nargout)
+builtin_hess_2 (const Octave_object& args, int nargout)
 {
-  return hess (args, nargin, nargout);
+  return hess (args, nargout);
 }
 #endif
 
 Octave_object
-hess (const Octave_object& args, int nargin, int nargout)
+hess (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   tree_constant arg = args(1).make_numeric ();
 
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
diff --git a/src/ifft.cc b/src/ifft.cc
--- a/src/ifft.cc
+++ b/src/ifft.cc
@@ -31,17 +31,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-ifft.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_ifft_2 (const Octave_object& args, int nargin, int nargout)
+builtin_ifft_2 (const Octave_object& args, int nargout)
 {
   Octave_object retval (1);
   retval(0) = ifft (args(1));
   return retval;
 }
 #endif
 
 tree_constant
diff --git a/src/inv.cc b/src/inv.cc
--- a/src/inv.cc
+++ b/src/inv.cc
@@ -31,17 +31,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-inv.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_inv_2 (const Octave_object& args, int nargin, int nargout)
+builtin_inv_2 (const Octave_object& args, int nargout)
 {
   Octave_object retval (1);
   retval(0) = inverse (args(1));
   return retval;
 }
 #endif
 
 tree_constant
diff --git a/src/lpsolve.cc b/src/lpsolve.cc
--- a/src/lpsolve.cc
+++ b/src/lpsolve.cc
@@ -28,40 +28,40 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "LPsolve.h"
 
 #include "tree-const.h"
 #include "error.h"
 #include "f-lpsolve.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_lpsolve_2 (const Octave_object& args, int nargin, int nargout)
+builtin_lpsolve_2 (const Octave_object& args, int nargout)
 {
-  return lpsolve (args, nargin, nargout);
+  return lpsolve (args, nargout);
 }
 
 Octave_object
-builtin_lpsolve_options_2 (const Octave_object& args, int nargin, int nargout) 
+builtin_lpsolve_options_2 (const Octave_object& args, int nargout) 
 {
-  return lpsolve_options (args, nargin, nargout);
+  return lpsolve_options (args, nargout);
 }
 #endif
 
 Octave_object
-lpsolve (const Octave_object& args, int nargin, int nargout)
+lpsolve (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
   error ("lpsolve: not implemented yet");
   return retval;
 }
 
 Octave_object
-lpsolve_options (const Octave_object& args, int nargin, int nargout)
+lpsolve_options (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
   error ("lpsolve_options: not implemented yet");
   return retval;
 }
 
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -37,25 +37,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "pager.h"
 #include "f-lsode.h"
 
 // Global pointer for user defined function required by lsode.
 static tree_fvc *lsode_fcn;
 
 #ifdef WITH_DLD
 Octave_object
-builtin_lsode_2 (const Octave_object& args, int nargin, int nargout)
+builtin_lsode_2 (const Octave_object& args int nargout)
 {
-  return lsode (args, nargin, nargout);
+  return lsode (args, nargout);
 }
 
 Octave_object
-builtin_lsode_options_2 (const Octave_object& args, int nargin, int nargout)
+builtin_lsode_options_2 (const Octave_object& args, int nargout)
 {
-  return lsode_options (args, nargin, nargout);
+  return lsode_options (args, nargout);
 }
 #endif
 
 static ODE_options lsode_opts;
 
 ColumnVector
 lsode_user_function (const ColumnVector& x, double t)
 {
@@ -80,17 +80,17 @@ lsode_user_function (const ColumnVector&
     {
       double d = x.elem (0);
       tree_constant state (d);
       args(1) = state;
     }
 
   if (lsode_fcn != (tree_fvc *) NULL)
     {
-      Octave_object tmp = lsode_fcn->eval (0, 1, args, 3);
+      Octave_object tmp = lsode_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  gripe_user_supplied_eval ("lsode");
 	  return retval;
 	}
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
@@ -103,22 +103,24 @@ lsode_user_function (const ColumnVector&
       else
 	gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 Octave_object
-lsode (const Octave_object& args, int nargin, int nargout)
+lsode (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
 
+  int nargin = args.length ();
+
   lsode_fcn = is_valid_function (args(1), "lsode", 1);
   if (lsode_fcn == (tree_fvc *) NULL
       || takes_correct_nargs (lsode_fcn, 3, "lsode", 1) != 1)
     return retval;
 
   ColumnVector state = args(2).to_vector ();
   ColumnVector out_times = args(3).to_vector ();
   ColumnVector crit_times;
@@ -251,20 +253,22 @@ do_lsode_option (char *keyword, double v
 	}
       list++;
     }
 
   warning ("lsode_options: no match for `%s'", keyword);
 }
 
 Octave_object
-lsode_options (const Octave_object& args, int nargin, int nargout)
+lsode_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 1)
     print_lsode_option_list ();
   else if (nargin == 3)
     {
       if (args(1).is_string_type ())
 	{
 	  char *keyword = args(1).string_value ();
 	  double val = args(2).double_value ();
diff --git a/src/lu.cc b/src/lu.cc
--- a/src/lu.cc
+++ b/src/lu.cc
@@ -30,17 +30,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "f-lu.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_lu_2 (const Octave_object& args, int nargin, int nargout)
+builtin_lu_2 (const Octave_object& args, int nargout)
 {
   return lu (args(1), nargout);
 }
 #endif
 
 Octave_object
 lu (const tree_constant& a, int nargout)
 {
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -41,25 +41,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "f-npsol.h"
 
 // Global pointers for user defined functions required by npsol.
 static tree_fvc *npsol_objective;
 static tree_fvc *npsol_constraints;
 
 #ifdef WITH_DLD
 Octave_object
-builtin_npsol_2 (const Octave_object& args, int nargin, int nargout)
+builtin_npsol_2 (const Octave_object& args, int nargout)
 {
-  return npsol (args, nargin, nargout);
+  return npsol (args, nargout);
 }
 
 Octave_object
-builtin_npsol_options_2 (const Octave_object& args, int nargin, int nargout)
+builtin_npsol_options_2 (const Octave_object& args, int nargout)
 {
-  return npsol_options (args, nargin, nargout);
+  return npsol_options (args, nargout);
 }
 #endif
 
 static NPSOL_options npsol_opts;
 
 double
 npsol_objective_function (const ColumnVector& x)
 {
@@ -85,17 +85,17 @@ npsol_objective_function (const ColumnVe
   args(1) = decision_vars;
 
   static double retval;
   retval = 0.0;
 
   tree_constant objective_value;
   if (npsol_objective != (tree_fvc *) NULL)
     {
-      Octave_object tmp = npsol_objective->eval (0, 1, args, 2);
+      Octave_object tmp = npsol_objective->eval (0, 1, args);
 
       if (error_state)
 	{
 	  error ("npsol: error evaluating objective function");
 	  npsol_objective_error = 1; // XXX FIXME XXX
 	  return retval;
 	}
 
@@ -158,17 +158,17 @@ npsol_constraint_function (const ColumnV
 
 //  tree_constant name = tree_constant (npsol_constraints->name ());
   Octave_object args (2);
 //  args(0) = name;
   args(1) = decision_vars;
 
   if (npsol_constraints != (tree_fvc *)NULL)
     {
-      Octave_object tmp = npsol_constraints->eval (0, 1, args, 2);
+      Octave_object tmp = npsol_constraints->eval (0, 1, args);
 
       if (error_state)
 	{
 	  error ("npsol: error evaluating constraints");
 	  return retval;
 	}
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
@@ -241,17 +241,17 @@ nonlinear_constraints_ok (const ColumnVe
 	  error ("%s: nonlinear constraints have inconsistent dimensions",
 		 warn_for);
 	}
     }
   return ok;
 }
 
 Octave_object
-npsol (const Octave_object& args, int nargin, int nargout)
+npsol (const Octave_object& args, int nargout)
 {
 /*
 
 Handle all of the following:
 
   1. npsol (x, phi)
   2. npsol (x, phi, lb, ub)
   3. npsol (x, phi, lb, ub, llb, c, lub)
@@ -262,16 +262,18 @@ Handle all of the following:
   8. npsol (x, phi,                      nllb, g, nlub)
 
 */
 
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
 
+  int nargin = args.length ();
+
   ColumnVector x = args(1).to_vector ();
 
   if (x.capacity () == 0)
     {
       error ("npsol: expecting vector as first argument");
       return retval;
     }
 
@@ -691,20 +693,22 @@ do_npsol_option (char *keyword, double v
 	}
       list++;
     }
 
   warning ("npsol_options: no match for `%s'", keyword);
 }
 
 Octave_object
-npsol_options (const Octave_object& args, int nargin, int nargout)
+npsol_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 1)
     {
       print_npsol_option_list ();
     }
   else if (nargin == 3)
     {
       if (args(1).is_string_type ())
 	{
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -698,27 +698,29 @@ matrix_sqrt (const tree_constant& a)
       break;
     default:
       break;
     }
   return retval;
 }
 
 Octave_object
-column_max (const Octave_object& args, int nargin, int nargout)
+column_max (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   tree_constant arg1;
   tree_constant arg2;
   tree_constant_rep::constant_type arg1_type =
     tree_constant_rep::unknown_constant;
   tree_constant_rep::constant_type arg2_type =
     tree_constant_rep::unknown_constant;
 
+  int nargin = args.length ();
+
   switch (nargin)
     {
     case 3:
       arg2 = args(2).make_numeric ();
       arg2_type = arg2.const_type ();
 // Fall through...
     case 2:
       arg1 = args(1).make_numeric ();
@@ -869,27 +871,29 @@ column_max (const Octave_object& args, i
     }
   else
     panic_impossible ();
 
   return retval;
 }
 
 Octave_object
-column_min (const Octave_object& args, int nargin, int nargout)
+column_min (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   tree_constant arg1;
   tree_constant arg2;
   tree_constant_rep::constant_type arg1_type =
     tree_constant_rep::unknown_constant;
   tree_constant_rep::constant_type arg2_type =
     tree_constant_rep::unknown_constant;
 
+  int nargin = args.length ();
+
   switch (nargin)
     {
     case 3:
       arg2 = args(2).make_numeric ();
       arg2_type = arg2.const_type ();
 // Fall through...
     case 2:
       arg1 = args(1).make_numeric ();
@@ -1174,17 +1178,17 @@ mx_sort (ComplexRowVector& cv, RowVector
 	      double tmp = idx.elem (k);
 	      idx.elem (k) = idx.elem (k+gap);
 	      idx.elem (k+gap) = tmp;
 	    }
 	}
 }
 
 Octave_object
-sort (const Octave_object& args, int nargin, int nargout)
+sort (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
 
   int return_idx = nargout > 1;
   if (return_idx)
     retval.resize (2);
@@ -1269,29 +1273,30 @@ sort (const Octave_object& args, int nar
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 Octave_object
-feval (const Octave_object& args, int nargin, int nargout)
+feval (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
 
   tree_fvc *fcn = is_valid_function (args(1), "feval", 1);
   if (fcn != (tree_fvc *) NULL)
     {
-      Octave_object tmp_args (--nargin);
+      int nargin = args.length () - 1;
+      Octave_object tmp_args (nargin);
       for (int i = 0; i < nargin; i++)
 	tmp_args(i) = args(i+1);
-      retval = fcn->eval (0, nargout, tmp_args, nargin);
+      retval = fcn->eval (0, nargout, tmp_args);
     }
 
   return retval;
 }
 
 tree_constant
 eval_string (const char *string, int print, int ans_assign,
 	     int& parse_status)
@@ -1366,22 +1371,24 @@ match_sans_spaces (const char *standard,
     ep--;
 
   int len = ep - tp + 1;
 
   return (strncmp (standard, tp, len) == 0);
 }
 
 tree_constant
-get_user_input (const Octave_object& args, int nargin, int nargout,
-		int debug = 0)
+get_user_input (const Octave_object& args, int nargout, int debug = 0)
 {
   tree_constant retval;
 
+  int nargin = args.length ();
+
   int read_as_string = 0;
+
   if (nargin == 3)
     {
       if (args(2).is_string_type ()
 	  && strcmp ("s", args(2).string_value ()) == 0)
 	read_as_string++;
       else
 	{
 	  error ("input: unrecognized second argument");
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -167,26 +167,25 @@ public:
       if (is_numeric_type ()
 	  || rep->type_tag == tree_constant_rep::magic_colon
 	  || rep->type_tag == tree_constant_rep::range_constant)
 	return *this;
       else
 	return rep->make_numeric ();
     }
 
-  tree_constant assign (tree_constant& rhs, const Octave_object& args,
-			int nargs)
+  tree_constant assign (tree_constant& rhs, const Octave_object& args)
     {
       if (rep->count > 1)
 	{
 	  --rep->count;
 	  rep = new tree_constant_rep (*rep);
 	  rep->count = 1;
 	}
-      rep->assign (rhs, args, nargs);
+      rep->assign (rhs, args);
       return *this;
     }
 
   int save (ostream& os, int mark_as_global = 0, int precision = 17)
     { return rep->save (os, mark_as_global, precision); }
   int save_three_d (ostream& os, int parametric = 0)
     { return rep->save_three_d (os, parametric); }
 
@@ -262,23 +261,24 @@ public:
   tree_constant eval (int print)
     {
       rep->maybe_mutate ();
       if (print)
 	rep->print ();
       return *this;
     }
 
-  Octave_object eval (int print, int nargout, const Octave_object& args,
-		      int nargin)
+  Octave_object eval (int print, int nargout, const Octave_object& args)
     {
       Octave_object retval (1);
 
-      if (args.length () > 0 && nargin > 0)
-	retval(0) = rep->do_index (args, nargin);
+// XXX FIXME XXX -- make it safe to call do_index() with
+// args.length () == 0
+      if (args.length () > 0)
+	retval(0) = rep->do_index (args);
       else
 	retval(0) = *this;
 
       if (retval(0).is_defined ())
 	retval(0).eval (print);
       return retval;
     }
 
@@ -303,34 +303,28 @@ extern tree_constant identity_matrix (co
 extern tree_constant identity_matrix (const tree_constant& a,
 				      const tree_constant& b);
 
 extern tree_constant find_nonzero_elem_idx (const tree_constant& a);
 
 extern Octave_object matrix_log (const tree_constant& a);
 extern Octave_object matrix_sqrt (const tree_constant& a);
 
-extern Octave_object column_max (const Octave_object& args, int nargin,
-				 int nargout);
-
-extern Octave_object column_min (const Octave_object& args, int nargin,
-				 int nargout);
+extern Octave_object column_max (const Octave_object& args, int nargout);
+extern Octave_object column_min (const Octave_object& args, int nargout);
   
-extern Octave_object sort (const Octave_object& args, int nargin,
-			   int nargout);
+extern Octave_object sort (const Octave_object& args, int nargout);
  
-extern Octave_object feval (const Octave_object& args, int nargin,
-			    int nargout);
+extern Octave_object feval (const Octave_object& args, int nargout);
 
 extern tree_constant eval_string (const tree_constant& arg, int&
 				  parse_status);
 
 extern tree_constant get_user_input (const Octave_object& args,
-				     int nargin, int nargout,
-				     int debug = 0);
+				     int nargout, int debug = 0);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -103,35 +103,39 @@ print_as_scalar (const tree_constant& va
 		  || nr == 0
 		  || nc == 0)));
 }
 
 /*
  * Make sure that all arguments have values.
  */
 static int
-all_args_defined (const Octave_object& args, int nargs)
+all_args_defined (const Octave_object& args)
 {
-  while (--nargs > 0)
+  int nargin = args.length ();
+
+  while (--nargin > 0)
     {
-      if (args(nargs).is_undefined ())
+      if (args(nargin).is_undefined ())
 	return 0;
     }
   return 1;
 }
 
 /*
  * Are any of the arguments `:'?
  */
 static int
-any_arg_is_magic_colon (const Octave_object& args, int nargs)
+any_arg_is_magic_colon (const Octave_object& args)
 {
-  while (--nargs > 0)
+  int nargin = args.length ();
+
+  while (--nargin > 0)
     {
-      if (args(nargs).const_type () == tree_constant_rep::magic_colon)
+      if (args(nargin).const_type () == tree_constant_rep::magic_colon)
 	return 1;
     }
   return 0;
 }
 
 // NOTE: functions for the tree_constant_rep and tree_constant classes
 // are now defined in tree-const.cc.  This should help speed up
 // compilation when working only on the tree_constant class.
@@ -568,17 +572,17 @@ tree_matrix::eval (int print)
 
  done:
   delete [] list;
 
   return retval;
 }
 
 tree_constant
-tree_fvc::assign (tree_constant& t, const Octave_object& args, int nargs)
+tree_fvc::assign (tree_constant& t, const Octave_object& args)
 {
   panic_impossible ();
   return tree_constant ();
 }
 
 /*
  * Builtin functions.
  */
@@ -654,35 +658,36 @@ tree_builtin::eval (int print)
       if (tmp.length () > 0)
 	retval = tmp(0);
       delete [] argv;
     }
   else if (general_fcn != (General_fcn) NULL)
     {
       Octave_object args (1);
       args(0) = tree_constant (my_name);
-      Octave_object tmp = (*general_fcn) (args, 1, 1);
+      Octave_object tmp = (*general_fcn) (args, 1);
       if (tmp.length () > 0)
 	retval = tmp(0);
     }
   else // Assume mapper function
     ::error ("%s: argument expected", my_name);
 
   return retval;
 }
 
 Octave_object
-tree_builtin::eval (int print, int nargout, const Octave_object& args,
-		    int nargin)
+tree_builtin::eval (int print, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
+  int nargin = args.length ();
+
   if (text_fcn != (Text_fcn) NULL)
     {
 // XXX FIXME XXX -- what if some arg is not a string?
 
       int argc = nargin;
       char **argv = new char * [argc + 1];
       argv[0] = strsave (my_name);
       for (int i = 1; i < argc; i++)
@@ -692,20 +697,20 @@ tree_builtin::eval (int print, int nargo
       retval = (*text_fcn) (argc, argv, nargout);
 
       for (i = 0; i < argc; i++)
 	delete [] argv[i];
       delete [] argv;
     }
   else if (general_fcn != (General_fcn) NULL)
     {
-      if (any_arg_is_magic_colon (args, nargin))
+      if (any_arg_is_magic_colon (args))
 	::error ("invalid use of colon in function argument list");
       else
-	retval = (*general_fcn) (args, nargin, nargout);
+	retval = (*general_fcn) (args, nargout);
     }
   else
     {
       if (nargin > nargin_max)
 	::error ("%s: too many arguments", my_name);
       else if (nargin > 0 && args.length () > 0 && args(1).is_defined ())
 	{
 	  tree_constant tmp = args(1).mapper (mapper_fcn, 0);
@@ -831,18 +836,17 @@ tree_identifier::assign (tree_constant& 
 
   if (status)
     return rhs;
   else
     return tree_constant ();
 }
 
 tree_constant
-tree_identifier::assign (tree_constant& rhs, const Octave_object& args,
-			 int nargs)
+tree_identifier::assign (tree_constant& rhs, const Octave_object& args)
 {
   tree_constant retval;
 
   if (rhs.is_defined ())
     {
       if (! sym->is_defined ())
 	{
 	  if (! (sym->is_formal_parameter ()
@@ -854,31 +858,31 @@ tree_identifier::assign (tree_constant& 
       else if (sym->is_function ())
 	{
 	  sym->clear ();
 	}
 
       if (sym->is_variable () && sym->is_defined ())
 	{
 	  tree_fvc *tmp = sym->def ();
-	  retval = tmp->assign (rhs, args, nargs);
+	  retval = tmp->assign (rhs, args);
 	}
       else
 	{
 	  assert (! sym->is_defined ());
 
 	  if (! user_pref.resize_on_range_error)
 	    {
 	      ::error ("indexed assignment to previously undefined variables");
 	      ::error ("is only possible when resize_on_range_error is true");
 	      return retval;
 	    }
 
 	  tree_constant *tmp = new tree_constant ();
-	  retval = tmp->assign (rhs, args, nargs);
+	  retval = tmp->assign (rhs, args);
 	  if (retval.is_defined ())
 	    sym->define (tmp);
 	}
     }
 
   return retval;
 }
 
@@ -1148,17 +1152,17 @@ tree_identifier::eval (int print)
       if (ans == (tree_fvc *) NULL)
 	eval_undefined_error ();
       else
 	{
 	  int nargout = maybe_do_ans_assign ? 0 : 1;
 
 //	  int nargin = (ans->is_constant ()) ? 0 : 1;
 	  Octave_object tmp_args;
-	  Octave_object tmp = ans->eval (0, nargout, tmp_args, 0);
+	  Octave_object tmp = ans->eval (0, nargout, tmp_args);
 
 	  if (tmp.length () > 0)
 	    retval = tmp(0);
 	}
     }
 
   if (! error_state && retval.is_defined ())
     {
@@ -1212,18 +1216,17 @@ tree_identifier::eval (int print)
 		}
 	    }
 	}
     }
   return retval;
 }
 
 Octave_object
-tree_identifier::eval (int print, int nargout, const Octave_object& args,
-		       int nargin)
+tree_identifier::eval (int print, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   int script_file_executed = 0;
 
@@ -1237,17 +1240,17 @@ tree_identifier::eval (int print, int na
 	{
 	  if (maybe_do_ans_assign && nargout == 1)
 	    {
 
 // Don't count the output arguments that we create automatically.
 
 	      nargout = 0;
 
-	      retval = ans->eval (0, nargout, args, nargin);
+	      retval = ans->eval (0, nargout, args);
 
 	      if (retval.length () > 0 && retval(0).is_defined ())
 		{
 		  symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
 		  assert (sr != (symbol_record *) NULL);
       
 		  tree_identifier *ans_id = new tree_identifier (sr);
@@ -1257,17 +1260,17 @@ tree_identifier::eval (int print, int na
 		  tree_simple_assignment_expression tmp_ass (ans_id, tmp);
 
 		  tmp_ass.eval (print);
 
 		  delete ans_id;  // XXX FIXME XXX
 		}
 	    }
 	  else
-	    retval = ans->eval (print, nargout, args, nargin);
+	    retval = ans->eval (print, nargout, args);
 	}
     }
 
   return retval;
 }
 
 /*
  * User defined functions.
@@ -1440,17 +1443,17 @@ tree_constant
 tree_function::eval (int print)
 {
   tree_constant retval;
 
   if (error_state || cmd_list == NULL_TREE)
     return retval;
 
   Octave_object tmp_args;
-  Octave_object tmp = eval (print, 1, tmp_args, 0);
+  Octave_object tmp = eval (print, 1, tmp_args);
 
   if (! error_state && tmp.length () > 0)
     retval = tmp(0);
 
   return retval;
 }
 
 // For unwind protect.
@@ -1465,27 +1468,28 @@ pop_symbol_table_context (void *table)
 static void
 clear_symbol_table (void *table)
 {
   symbol_table *tmp = (symbol_table *) table;
   tmp->clear ();
 }
 
 Octave_object
-tree_function::eval (int print, int nargout, const Octave_object& args,
-		     int nargin)
+tree_function::eval (int print, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (cmd_list == NULL_TREE)
     return retval;
 
+  int nargin = args.length ();
+
   begin_unwind_frame ("func_eval");
 
   unwind_protect_int (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     {
       sym_tab->push_context ();
@@ -1511,17 +1515,17 @@ tree_function::eval (int print, int narg
   num_args_passed = nargin;
 
   unwind_protect_int (num_named_args);
   unwind_protect_int (curr_arg_number);
 
   if (param_list != (tree_parameter_list *) NULL
       && ! param_list->varargs_only ())
     {
-      param_list->define_from_arg_vector (args, nargin);
+      param_list->define_from_arg_vector (args);
       if (error_state)
 	goto abort;
     }
 
 // The following code is in a separate scope to avoid warnings from
 // G++ about `goto abort' crossing the initialization of some
 // variables.
 
@@ -1614,18 +1618,17 @@ tree_expression::~tree_expression (void)
 tree_constant
 tree_expression::eval (int print)
 {
   panic ("invalid evaluation of generic expression");
   return tree_constant ();
 }
 
 Octave_object
-tree_expression::eval (int print, int nargout, const Octave_object& args,
-		       int nargin)
+tree_expression::eval (int print, int nargout, const Octave_object& args)
 {
   panic_impossible ();
   return Octave_object ();
 }
 
 /*
  * Prefix expressions.
  */
@@ -2123,24 +2126,25 @@ tree_simple_assignment_expression::eval 
 	{
 	  ans = lhs->assign (rhs_val);
 	  if (error_state)
 	    eval_error ();
 	}
       else
 	{
 // Extract the arguments into a simple vector.
-	  int nargs = 0;
-	  Octave_object args = index->convert_to_const_vector (nargs);
+	  Octave_object args = index->convert_to_const_vector ();
+
+	  int nargin = args.length ();
 
 	  if (error_state)
 	    eval_error ();
-	  else if (nargs > 1)
+	  else if (nargin > 1)
 	    {
-	      ans = lhs->assign (rhs_val, args, nargs);
+	      ans = lhs->assign (rhs_val, args);
 	      if (error_state)
 		eval_error ();
 	    }
 	}
     }
 
   if (! error_state && ans.is_defined ())
     {
@@ -2223,37 +2227,36 @@ tree_constant
 tree_multi_assignment_expression::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   Octave_object tmp_args;
-  Octave_object result = eval (print, 1, tmp_args, 0);
+  Octave_object result = eval (print, 1, tmp_args);
 
   if (result.length () > 0)
     retval = result(0);
 
   return retval;
 }
 
 Octave_object
 tree_multi_assignment_expression::eval (int print, int nargout,
-					const Octave_object& args,
-					int nargin)
+					const Octave_object& args)
 {
   assert (etype == tree::multi_assignment);
 
   if (error_state || rhs == (tree_expression *) NULL)
     return Octave_object ();
 
   nargout = lhs->length ();
   Octave_object tmp_args;
-  Octave_object results = rhs->eval (0, nargout, tmp_args, 0);
+  Octave_object results = rhs->eval (0, nargout, tmp_args);
 
   if (error_state)
     eval_error ();
 
   int ma_line = line ();
   int ma_column = column ();
 
   if (results.length () > 0)
@@ -2562,62 +2565,60 @@ tree_index_expression::eval (int print)
     {
       retval = id->eval (print);
       if (error_state)
 	eval_error ();
     }
   else
     {
 // Extract the arguments into a simple vector.
-      int nargin = 0;
-      Octave_object args = list->convert_to_const_vector (nargin);
+      Octave_object args = list->convert_to_const_vector ();
 // Don't pass null arguments.
+      int nargin = args.length ();
       if (error_state)
 	eval_error ();
-      else if (nargin > 1 && all_args_defined (args, nargin))
+      else if (nargin > 1 && all_args_defined (args))
 	{
-	  Octave_object tmp = id->eval (print, 1, args, nargin);
+	  Octave_object tmp = id->eval (print, 1, args);
 
 	  if (error_state)
 	    eval_error ();
 
 	  if (tmp.length () > 0)
 	    retval = tmp(0);
 	}
     }
   return retval;
 }
 
 Octave_object
-tree_index_expression::eval (int print, int nargout,
-			     const Octave_object& args, int nargin)
+tree_index_expression::eval (int print, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (list == (tree_argument_list *) NULL)
     {
       Octave_object tmp_args;
-      retval = id->eval (print, nargout, tmp_args, 0);
+      retval = id->eval (print, nargout, tmp_args);
       if (error_state)
 	eval_error ();
     }
   else
     {
 // Extract the arguments into a simple vector.
-      int nargin = 0;
-      Octave_object args = list->convert_to_const_vector (nargin);
+      Octave_object args = list->convert_to_const_vector ();
 // Don't pass null arguments.
       if (error_state)
 	eval_error ();
-      else if (nargin > 1 && all_args_defined (args, nargin))
+      else if (args.length () > 1 && all_args_defined (args))
 	{
-	  retval = id->eval (print, nargout, args, nargin);
+	  retval = id->eval (print, nargout, args);
 	  if (error_state)
 	    eval_error ();
 	}
     }
   return retval;
 }
 
 void
@@ -2712,19 +2713,19 @@ tree_argument_list::next_elem (void)
   return next;
 }
 
 /*
  * Convert a linked list of trees to a vector of pointers to trees,
  * evaluating them along the way.
  */
 Octave_object
-tree_argument_list::convert_to_const_vector (int& len)
+tree_argument_list::convert_to_const_vector (void)
 {
-  len = length () + 1;
+  int len = length () + 1;
 
   Octave_object args (len);
 
 // args[0] may eventually hold something useful, like the function
 // name.
   tree_argument_list *tmp_list = this;
   for (int k = 1; k < len; k++)
     {
@@ -2857,22 +2858,23 @@ tree_parameter_list::varargs_only (void)
 
 tree_identifier *
 tree_parameter_list::define (tree_constant *t)
 {
   return param->define (t);
 }
 
 void
-tree_parameter_list::define_from_arg_vector (const Octave_object& args,
-					     int nargin)
+tree_parameter_list::define_from_arg_vector (const Octave_object& args)
 {
   if (args.length () <= 0)
     return;
 
+  int nargin = args.length ();
+
   int expected_nargin = length () + 1;
 
   tree_parameter_list *ptr = this;
 
   for (int i = 1; i < expected_nargin; i++)
     {
       tree_constant *tmp = NULL_TREE_CONST;
 
diff --git a/src/pt-exp-base.h b/src/pt-exp-base.h
--- a/src/pt-exp-base.h
+++ b/src/pt-exp-base.h
@@ -34,17 +34,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "error.h"
 #include "oct-obj.h"
 
 class tree_constant;
 class symbol_record;
 class symbol_table;
 
 typedef Octave_object (*Text_fcn)(int, char **, int);
-typedef Octave_object (*General_fcn)(const Octave_object&, int, int);
+typedef Octave_object (*General_fcn)(const Octave_object&, int);
 
 class tree_matrix;
 class tree_builtin;
 class tree_identifier;
 class tree_function;
 class tree_expression;
 class tree_prefix_expression;
 class tree_postfix_expression;
@@ -83,17 +83,17 @@ public:
 
   virtual int is_prefix_expression (void) const
     { return 0; }
 
   virtual void mark_for_possible_ans_assign (void)
     { panic_impossible (); }
 
   virtual Octave_object eval (int print, int nargout,
-			      const Octave_object& args, int nargin);
+			      const Octave_object& args);
 
 protected:
   expression_type etype;
 };
 
 /*
  * General matrices.  This allows us to construct matrices from
  * other matrices, variables, and functions.
@@ -263,18 +263,17 @@ tree_multi_assignment_expression : publi
   tree_multi_assignment_expression (tree_return_list *lst,
 				    tree_expression *r,
 				    int l = -1, int c = -1);
 
   ~tree_multi_assignment_expression (void);
 
   tree_constant eval (int print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args,
-		      int nargin);
+  Octave_object eval (int print, int nargout, const Octave_object& args);
 
   void eval_error (void);
 
  private:
   tree_return_list *lhs;
   tree_expression *rhs;
 };
 
@@ -322,18 +321,17 @@ tree_index_expression : public tree_expr
   tree_identifier *ident (void);
 
   tree_argument_list *arg_list (void);
 
   void mark_for_possible_ans_assign (void);
 
   tree_constant eval (int print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args,
-		      int nargin);
+  Octave_object eval (int print, int nargout, const Octave_object& args);
 
   void eval_error (void);
 
  private:
   tree_identifier *id;
   tree_argument_list *list;
 };
 
@@ -345,18 +343,17 @@ tree_fvc : public tree_expression
 {
 public:
   virtual int is_constant (void) const
     { return 0; }
 
 //  virtual int is_builtin (void) const
 //    { return 0; }
 
-  virtual tree_constant assign (tree_constant& t, const Octave_object& args,
-				int nargs);
+  virtual tree_constant assign (tree_constant& t, const Octave_object& args);
 
   virtual char *name (void) const
     { panic_impossible (); return (char *) NULL; }
 
   virtual void bump_value (tree::expression_type)
     { panic_impossible (); }
 
   virtual int max_expected_args (void)
@@ -395,18 +392,17 @@ public:
 		const char *nm = (char *) NULL);
 
   ~tree_builtin (void);
 
 //  int is_builtin (void) const;
 
   tree_constant eval (int print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args,
-		      int nargin);
+  Octave_object eval (int print, int nargout, const Octave_object& args);
 
   char *name (void) const;
 
   int max_expected_args (void);
 
 private:
   int nargin_max;
   int nargout_max;
@@ -436,18 +432,17 @@ public:
   void rename (const char *n);
 
   tree_identifier *define (tree_constant *t);
   tree_identifier *define (tree_function *t);
 
   void document (char *s);
 
   tree_constant assign (tree_constant& t);
-  tree_constant assign (tree_constant& t, const Octave_object& args,
-			int nargs);
+  tree_constant assign (tree_constant& t, const Octave_object& args);
 
   int is_defined (void);
 
   void bump_value (tree::expression_type);
 
   int parse_fcn_file (int exec_script = 1);
   int parse_fcn_file (char *ff, int exec_script = 1);
   void parse_fcn_file (FILE *ffile, char *ff);
@@ -455,18 +450,17 @@ public:
   tree_fvc *do_lookup (int& script_file_executed);
 
   void mark_as_formal_parameter (void);
 
   void mark_for_possible_ans_assign (void);
 
   tree_constant eval (int print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args,
-		      int nargin);
+  Octave_object eval (int print, int nargout, const Octave_object& args);
 
   void eval_undefined_error (void);
 
 private:
   symbol_record *sym;
   int maybe_do_ans_assign;
 };
 
@@ -499,18 +493,17 @@ public:
   void octave_va_start (void);
   tree_constant octave_va_arg (void);
 
   void stash_function_name (char *s);
   char *function_name (void);
 
   tree_constant eval (int print);
 
-  Octave_object eval (int print, int nargout, const Octave_object& args,
-		      int nargin);
+  Octave_object eval (int print, int nargout, const Octave_object& args);
 
   int max_expected_args (void);
 
   void traceback_error (void);
 
 private:
   int call_depth;
   tree_parameter_list *param_list;
@@ -541,17 +534,17 @@ tree_argument_list : public tree
   ~tree_argument_list (void);
 
   tree_argument_list *chain (tree *t);
   tree_argument_list *reverse (void);
   int length (void);
 
   tree_argument_list *next_elem (void);
 
-  Octave_object convert_to_const_vector (int& nargs);
+  Octave_object convert_to_const_vector (void);
 
   tree_constant eval (int print);
 
  private:
   tree *arg;
   tree_argument_list *next;
 };
 
@@ -580,17 +573,17 @@ tree_parameter_list : public tree
   void mark_varargs (void);
   int takes_varargs (void) const;
 
   void mark_varargs_only (void);
   int varargs_only (void);
 
   tree_identifier *define (tree_constant *t);
 
-  void define_from_arg_vector (const Octave_object& args, int nargin);
+  void define_from_arg_vector (const Octave_object& args);
 
   int is_defined (void);
 
   Octave_object convert_to_const_vector (void);
 
   tree_parameter_list *next_elem (void);
 
   tree_constant eval (int print);
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -43,48 +43,50 @@ Software Foundation, 675 Mass Ave, Cambr
 // a header file...
 extern int linear_constraints_ok (const ColumnVector& x,
 				  const ColumnVector& llb, const Matrix& c,
 				  const ColumnVector& lub, char *warn_for,
 				  int warn);
 
 #ifdef WITH_DLD
 Octave_object
-builtin_qpsol_2 (const Octave_object& args, int nargin, int nargout)
+builtin_qpsol_2 (const Octave_object& args, int nargout)
 {
-  return qpsol (args, nargin, nargout);
+  return qpsol (args, nargout);
 }
 
 Octave_object
-builtin_qpsol_options_2 (const Octave_object& args, int nargin, int nargout)
+builtin_qpsol_options_2 (const Octave_object& args, int nargout)
 {
-  return qpsol_options (args, nargin, nargout);
+  return qpsol_options (args, nargout);
 }
 #endif
 
 static QPSOL_options qpsol_opts;
 
 Octave_object
-qpsol (const Octave_object& args, int nargin, int nargout)
+qpsol (const Octave_object& args, int nargout)
 {
 /*
 
 Handle all of the following:
 
   1. qpsol (x, H, c)
   2. qpsol (x, H, c, lb, ub)
   3. qpsol (x, H, c, lb, ub, llb, A, lub)
   4. qpsol (x, H, c,         llb, A, lub)
 
 */
 
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
 
+  int nargin = args.length ();
+
   ColumnVector x = args(1).to_vector ();
   if (x.capacity () == 0)
     {
       error ("qpsol: expecting vector as first argument");
       return retval;
     }
 
   Matrix H = args(2).to_matrix ();
@@ -312,20 +314,22 @@ do_qpsol_option (char *keyword, double v
 	}
       list++;
     }
 
   warning ("qpsol_options: no match for `%s'", keyword);
 }
 
 Octave_object
-qpsol_options (const Octave_object& args, int nargin, int nargout)
+qpsol_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 1)
     {
       print_qpsol_option_list ();
     }
   else if (nargin == 3)
     {
       if (args(1).is_string_type ())
 	{
diff --git a/src/qr.cc b/src/qr.cc
--- a/src/qr.cc
+++ b/src/qr.cc
@@ -30,17 +30,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "f-qr.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_qr_2 (const Octave_object& args, int nargin, int nargout)
+builtin_qr_2 (const Octave_object& args, int nargout)
 {
   return qr (args(1), nargout);
 }
 #endif
 
 Octave_object
 qr (const tree_constant& a, int nargout)
 {
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -38,25 +38,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "pager.h"
 #include "f-quad.h"
 
 // Global pointer for user defined function required by quadrature functions.
 static tree_fvc *quad_fcn;
 
 #ifdef WITH_DLD
 Octave_object
-builtin_quad_2 (const Octave_object& args, int nargin, int nargout)
+builtin_quad_2 (const Octave_object& args, int nargout)
 {
-  return do_quad (args, nargin, nargout);
+  return do_quad (args, nargout);
 }
 
 Octave_object
-builtin_quad_options_2 (const Octave_object& args, int nargin, int nargout)
+builtin_quad_options_2 (const Octave_object& args, int nargout)
 {
-  return quad_options (args, nargin, nargout);
+  return quad_options (args, nargout);
 }
 #endif
 
 static Quad_options quad_opts;
 
 double
 quad_user_function (double x)
 {
@@ -64,17 +64,17 @@ quad_user_function (double x)
 
 //  tree_constant name = tree_constant (quad_fcn->name ());
   Octave_object args (2);
 //  args(0) = name;
   args(1) = tree_constant (x);
 
   if (quad_fcn != (tree_fvc *) NULL)
     {
-      Octave_object tmp = quad_fcn->eval (0, 1, args, 2);
+      Octave_object tmp = quad_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  quad_integration_error = 1;  // XXX FIXME XXX
 	  gripe_user_supplied_eval ("quad");
 	  return retval;
 	}
 
@@ -86,22 +86,24 @@ quad_user_function (double x)
 	  gripe_user_supplied_eval ("quad");
 	}
     }
 
   return retval;
 }
 
 Octave_object
-do_quad (const Octave_object& args, int nargin, int nargout)
+do_quad (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
 
+  int nargin = args.length ();
+
   quad_fcn = is_valid_function (args(1), "fsolve", 1);
   if (quad_fcn == (tree_fvc *) NULL
       || takes_correct_nargs (quad_fcn, 2, "fsolve", 1) != 1)
     return retval;
 
   double a = args(2).to_scalar ();
   double b = args(3).to_scalar ();
 
@@ -280,20 +282,22 @@ do_quad_option (char *keyword, double va
 	}
       list++;
     }
 
   warning ("quad_options: no match for `%s'", keyword);
 }
 
 Octave_object
-quad_options (const Octave_object& args, int nargin, int nargout)
+quad_options (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   if (nargin == 1)
     print_quad_option_list ();
   else if (nargin == 3)
     {
       if (args(1).is_string_type ())
 	{
 	  char *keyword = args(1).string_value ();
 	  double val = args(2).double_value ();
diff --git a/src/qzval.cc b/src/qzval.cc
--- a/src/qzval.cc
+++ b/src/qzval.cc
@@ -49,24 +49,24 @@ extern "C"
 		      double*, const long*, double*, int*);
  
   int F77_FCN (qzval) (const int*, const int*, double*, double*,
 		       double*, double*, double*, const long*, double*);
 }
 
 #ifdef WITH_DLD
 Octave_object
-builtin_qzvalue_2 (const Octave_object& args, int nargin, int nargout)
+builtin_qzvalue_2 (const Octave_object& args, int nargout)
 {
-  return qzvalue (args, nargin, nargout);
+  return qzvalue (args, nargout);
 }
 #endif
 
 Octave_object
-qzvalue (const Octave_object& args, int nargin, int nargout)
+qzvalue (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   tree_constant arga = args(1).make_numeric ();
   tree_constant argb = args(2).make_numeric();
 
   if (arga.is_empty () || argb.is_empty ())
     retval = vector_of_empties (nargout, "qzvalue");
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -42,19 +42,19 @@ extern "C"
   int *F77_FCN (dgennor) (double*, double*, double*);
   int *F77_FCN (dgenunf) (double*, double*, double*);
   int *F77_FCN (setall) (int*, int*);
   int *F77_FCN (getsd) (int*, int*);
 }
 
 #ifdef WITH_DLD
 Octave_object
-builtin_rand_2 (const Octave_object& args, int nargin, int nargout)
+builtin_rand_2 (const Octave_object& args, int nargout)
 {
-  return rand_internal (args, nargin, nargout);
+  return rand_internal (args, nargout);
 }
 #endif
 
 static double
 curr_rand_seed (void)
 {
   union d2i { double d; int i[2]; };
   union d2i u;
@@ -98,22 +98,24 @@ curr_rand_dist (void)
   else
     {
       panic_impossible ();
       return (char *) NULL;
     }
 }
 
 Octave_object
-rand_internal (const Octave_object& args, int nargin, int nargout)
+rand_internal (const Octave_object& args, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
   Octave_object retval;
 
+  int nargin = args.length ();
+
   static int initialized = 0;
   if (! initialized)
     {
 // Make the random number generator give us a different sequence every
 // time we start octave unless we specifically set the seed.
 #if 0
       int s0 = 1234567890;
       int s1 = 123456789;
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -31,27 +31,29 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "error.h"
 #include "gripes.h"
 #include "f-schur.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_schur_2 (const Octave_object& args, int nargin, int nargout)
+builtin_schur_2 (const Octave_object& args, int nargout)
 {
-  return schur (args, nargin, nargout);
+  return schur (args, nargout);
 }
 #endif
 
 Octave_object
-schur (const Octave_object& args, int nargin, int nargout)
+schur (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   tree_constant arg = args(1).make_numeric ();
 
   char *ord;
   if (nargin != 3)
     ord = "U";
   else
     ord = args(2).string_value ();
 
diff --git a/src/svd.cc b/src/svd.cc
--- a/src/svd.cc
+++ b/src/svd.cc
@@ -31,24 +31,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "gripes.h"
 #include "error.h"
 #include "f-svd.h"
 
 #ifdef WITH_DLD
 Octave_object
-builtin_svd_2 (const Octave_object& args, int nargin, int nargout)
+builtin_svd_2 (const Octave_object& args, int nargout)
 {
-  return svd (args, nargin, nargout);
+  return svd (args, nargout);
 }
 #endif
 
 Octave_object
-svd (const Octave_object& args, int nargin, int nargout)
+svd (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   tree_constant arg = args(1).make_numeric ();
 
   if (arg.rows () == 0 || arg.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
diff --git a/src/syl.cc b/src/syl.cc
--- a/src/syl.cc
+++ b/src/syl.cc
@@ -51,24 +51,24 @@ extern "C"
 			const int*, const int*, const Complex*,
 			const int*, const Complex*, const int*,
 			const Complex*, const int*, double*, int*,
 			long, long);
 }
 
 #ifdef WITH_DLD
 Octave_object
-builtin_syl_2 (const Octave_object& args, int nargin, int nargout)
+builtin_syl_2 (const Octave_object& args, int nargout)
 {
-  return syl (args, nargin, nargout);
+  return syl (args, nargout);
 }
 #endif
 
 Octave_object
-syl (const Octave_object& args, int nargin, int nargout)
+syl (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   tree_constant arga = args(1).make_numeric ();
   tree_constant argb = args(2).make_numeric ();
   tree_constant argc = args(3).make_numeric ();
 
   if (arga.is_empty () || argb.is_empty () || argc.is_empty ())
diff --git a/src/tc-inlines.h b/src/tc-inlines.h
--- a/src/tc-inlines.h
+++ b/src/tc-inlines.h
@@ -135,22 +135,23 @@ fortran_column (int i, int nr)
   int c;
   int r;
   r = fortran_row (i, nr);
   c = (i - r) / nr + 1;
   return c;
 }
 
 static inline int
-valid_scalar_indices (const Octave_object& args, int nargs)
+valid_scalar_indices (const Octave_object& args)
 {
-  int valid = (args.length () > 0)
-    && ((nargs == 3 && args(2).valid_as_scalar_index ()
-	 && args(1).valid_as_scalar_index ())
-	|| (nargs == 2 && args(1).valid_as_scalar_index ()));
+  int nargin = args.length ();
+  int valid = ((nargin == 3
+		&& args(2).valid_as_scalar_index ()
+		&& args(1).valid_as_scalar_index ())
+	       || (nargin == 2 && args(1).valid_as_scalar_index ()));
 
   return valid;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/tc-rep.cc b/src/tc-rep.cc
--- a/src/tc-rep.cc
+++ b/src/tc-rep.cc
@@ -1311,50 +1311,50 @@ tree_constant_rep::print (void)
 	}
 
       output_buf << ends;
       maybe_page_output (output_buf);
     }
 }
 
 tree_constant
-tree_constant_rep::do_index (const Octave_object& args, int nargin)
+tree_constant_rep::do_index (const Octave_object& args)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (rows () == 0 || columns () == 0)
     {
       ::error ("attempt to index empty matrix");
       return retval;
     }
 
   switch (type_tag)
     {
     case complex_scalar_constant:
     case scalar_constant:
-      retval = do_scalar_index (args, nargin);
+      retval = do_scalar_index (args);
       break;
     case complex_matrix_constant:
     case matrix_constant:
-      retval = do_matrix_index (args, nargin);
+      retval = do_matrix_index (args);
       break;
     case string_constant:
       gripe_string_invalid ();
-//      retval = do_string_index (args, nargin);
+//      retval = do_string_index (args);
       break;
     case magic_colon:
     case range_constant:
 // This isn\'t great, but it\'s easier than implementing a lot of
 // range indexing functions.
       force_numeric ();
       assert (type_tag != magic_colon && type_tag != range_constant);
-      retval = do_index (args, nargin);
+      retval = do_index (args);
       break;
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
 }
@@ -2651,39 +2651,38 @@ tree_constant_rep::mapper (Mapper_fcn& m
 }
 
 /*
  * Top-level tree-constant function that handles assignments.  Only
  * decide if the left-hand side is currently a scalar or a matrix and
  * hand off to other functions to do the real work.
  */
 void
-tree_constant_rep::assign (tree_constant& rhs,
-			   const Octave_object& args, int nargs)
+tree_constant_rep::assign (tree_constant& rhs, const Octave_object& args)
 {
   tree_constant rhs_tmp = rhs.make_numeric ();
 
 // This is easier than actually handling assignments to strings.
 // An assignment to a range will normally require a conversion to a
 // vector since it will normally destroy the equally-spaced property
 // of the range elements.
 
   if (type_tag == string_constant || type_tag == range_constant)
     force_numeric ();
 
   switch (type_tag)
     {
     case complex_scalar_constant:
     case scalar_constant:
     case unknown_constant:
-      do_scalar_assignment (rhs_tmp, args, nargs);
+      do_scalar_assignment (rhs_tmp, args);
       break;
     case complex_matrix_constant:
     case matrix_constant:
-      do_matrix_assignment (rhs_tmp, args, nargs);
+      do_matrix_assignment (rhs_tmp, args);
       break;
     case string_constant:
       ::error ("invalid assignment to string type");
       break;
     case range_constant:
     case magic_colon:
     default:
       panic_impossible ();
@@ -2692,24 +2691,26 @@ tree_constant_rep::assign (tree_constant
 }
 
 /*
  * Assignments to scalars.  If resize_on_range_error is true,
  * this can convert the left-hand side to a matrix.
  */
 void
 tree_constant_rep::do_scalar_assignment (tree_constant& rhs,
-					 const Octave_object& args, int nargs)
+					 const Octave_object& args)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == scalar_constant
 	  || type_tag == complex_scalar_constant);
 
+  int nargin = args.length ();
+
   if ((rhs.is_scalar_type () || rhs.is_zero_by_zero ())
-      && valid_scalar_indices (args, nargs))
+      && valid_scalar_indices (args))
     {
       if (rhs.is_zero_by_zero ())
 	{
 	  if (type_tag == complex_scalar_constant)
 	    delete complex_scalar;
 
 	  matrix = new Matrix (0, 0);
 	  type_tag = matrix_constant;
@@ -2768,46 +2769,46 @@ tree_constant_rep::do_scalar_assignment 
 	  matrix = new Matrix (1, 1, scalar);
 	  type_tag = matrix_constant;
 	}
 
 // If there is an error, the call to do_matrix_assignment should not
 // destroy the current value.  tree_constant_rep::eval(int) will take
 // care of converting single element matrices back to scalars.
 
-      do_matrix_assignment (rhs, args, nargs);
+      do_matrix_assignment (rhs, args);
 
 // I don't think there's any other way to revert back to unknown
 // constant types, so here it is.
 
       if (old_type_tag == unknown_constant && error_state)
 	{
 	  if (type_tag == matrix_constant)
 	    delete matrix;
 	  else if (type_tag == complex_matrix_constant)
 	    delete complex_matrix;
 
 	  type_tag = unknown_constant;
 	}
     }
-  else if (nargs > 3 || nargs < 2)
+  else if (nargin > 3 || nargin < 2)
     ::error ("invalid index expression for scalar type");
   else
     ::error ("index invalid or out of range for scalar type");
 }
 
 /*
  * Assignments to matrices (and vectors).
  *
  * For compatibility with Matlab, we allow assignment of an empty
  * matrix to an expression with empty indices to do nothing.
  */
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
-					 const Octave_object& args, int nargs)
+					 const Octave_object& args)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == matrix_constant
 	  || type_tag == complex_matrix_constant);
 
   if (type_tag == matrix_constant && rhs.is_complex_type ())
     {
       Matrix *old_matrix = matrix;
@@ -2824,19 +2825,21 @@ tree_constant_rep::do_matrix_assignment 
 	}
       else
 	{
 	  matrix = new Matrix ();
 	  type_tag = matrix_constant;
 	}
     }
 
+  int nargin = args.length ();
+
 // The do_matrix_assignment functions can't handle empty matrices, so
 // don't let any pass through here.
-  switch (nargs)
+  switch (nargin)
     {
     case 2:
       if (args.length () <= 0)
 	::error ("matrix index is null");
       else if (args(1).is_undefined ())
 	::error ("matrix index is undefined");
       else
 	do_matrix_assignment (rhs, args(1));
@@ -4996,34 +4999,35 @@ tree_constant_rep::valid_as_scalar_index
     || (type_tag == scalar_constant && NINT (scalar) == 1)
     || (type_tag == range_constant
 	&& range->nelem () == 1 && NINT (range->base ()) == 1);
 
   return valid;
 }
 
 tree_constant
-tree_constant_rep::do_scalar_index (const Octave_object& args,
-				    int nargs) const
+tree_constant_rep::do_scalar_index (const Octave_object& args) const
 {
-  if (valid_scalar_indices (args, nargs))
+  if (valid_scalar_indices (args))
     {
       if (type_tag == scalar_constant)
 	return tree_constant (scalar);
       else if (type_tag == complex_scalar_constant)
 	return tree_constant (*complex_scalar);
       else
 	panic_impossible ();
     }
   else
     {
       int rows = 0;
       int cols = 0;
 
-      switch (nargs)
+      int nargin = args.length ();
+
+      switch (nargin)
 	{
 	case 3:
 	  {
 	    if (args(2).is_matrix_type ())
 	      {
 		Matrix mj = args(2).matrix_value ();
 
 		idx_vector j (mj, user_pref.do_fortran_indexing, "");
@@ -5105,21 +5109,22 @@ tree_constant_rep::do_scalar_index (cons
 	}
     }
 
   ::error ("index invalid or out of range for scalar type");
   return tree_constant ();
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (const Octave_object& args,
-				    int nargin) const
+tree_constant_rep::do_matrix_index (const Octave_object& args) const
 {
   tree_constant retval;
 
+  int nargin = args.length ();
+
   switch (nargin)
     {
     case 2:
       if (args.length () <= 0)
 	::error ("matrix index is null");
       else if (args(1).is_undefined ())
 	::error ("matrix index is a null expression");
       else
diff --git a/src/tc-rep.h b/src/tc-rep.h
--- a/src/tc-rep.h
+++ b/src/tc-rep.h
@@ -151,26 +151,23 @@ public:
 
   double to_scalar (void) const;
   ColumnVector to_vector (void) const;
   Matrix to_matrix (void) const;
 
   tree_constant_rep::constant_type force_numeric (int force_str_conv = 0);
   tree_constant make_numeric (int force_str_conv = 0) const;
 
-  void assign (tree_constant& rhs, const Octave_object& args, int nargs);
+  void assign (tree_constant& rhs, const Octave_object& args);
 
-  void do_scalar_assignment
-    (tree_constant& rhs, const Octave_object& args, int nargin);
+  void do_scalar_assignment (tree_constant& rhs, const Octave_object& args);
 
-  void do_matrix_assignment
-    (tree_constant& rhs, const Octave_object& args, int nargin);
+  void do_matrix_assignment (tree_constant& rhs, const Octave_object& args);
 
-  void do_matrix_assignment
-    (tree_constant& rhs, tree_constant& i_arg);
+  void do_matrix_assignment (tree_constant& rhs, tree_constant& i_arg);
 
   void do_matrix_assignment
     (tree_constant& rhs, tree_constant& i_arg, tree_constant& j_arg);
 
   void fortran_style_matrix_assignment (tree_constant& rhs,
 					tree_constant& i_arg);
 
   void fortran_style_matrix_assignment (tree_constant& rhs, constant_type ci);
@@ -227,21 +224,21 @@ public:
   void delete_columns (idx_vector& j);
   void delete_columns (Range& j);
 
   void bump_value (tree::expression_type);
 
   void maybe_mutate (void);
   void print (void);
 
-  tree_constant do_index (const Octave_object& args, int nargin);
+  tree_constant do_index (const Octave_object& args);
 
-  tree_constant do_scalar_index (const Octave_object& args, int nargin) const;
+  tree_constant do_scalar_index (const Octave_object& args) const;
 
-  tree_constant do_matrix_index (const Octave_object& args, int nargin) const;
+  tree_constant do_matrix_index (const Octave_object& args) const;
 
   tree_constant do_matrix_index (const tree_constant& i_arg) const;
 
   tree_constant do_matrix_index (const tree_constant& i_arg,
 				 const tree_constant& j_arg) const; 
 
   tree_constant do_matrix_index (constant_type i) const;
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -672,23 +672,23 @@ is_valid_function (tree_constant& arg, c
 
 /*
  * Does this function take the right number of arguments?
  */
 int
 takes_correct_nargs (tree_fvc *fcn, int expected_nargin, char *warn_for,
 		     int warn = 0) 
 {
-  int nargs = fcn->max_expected_args () - 1;
-  int e_nargs = expected_nargin - 1;
-  if (nargs != e_nargs)
+  int nargin = fcn->max_expected_args () - 1;
+  int e_nargin = expected_nargin - 1;
+  if (nargin != e_nargin)
     {
       if (warn)
 	error ("%s: expecting function to take %d argument%c", 
-	       warn_for, e_nargs, s_plural (e_nargs));
+	       warn_for, e_nargin, s_plural (e_nargin));
       return 0;
     }
   return 1;
 }
 
 // It's not likely that this does the right thing now.  XXX FIXME XXX
 
 char **
