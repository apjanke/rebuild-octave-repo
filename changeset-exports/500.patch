# HG changeset patch
# User jwe
# Date 773634283 0
#      Fri Jul 08 02:24:43 1994 +0000
# Node ID 5f91088cb98e17226d18e3cf21aad4a2bc0ac497
# Parent  966db71124dc5ab472ca4fc887024fa0ea2f2942
[project @ 1994-07-08 02:16:02 by jwe]

diff --git a/src/g-builtins.h b/src/g-builtins.h
--- a/src/g-builtins.h
+++ b/src/g-builtins.h
@@ -30,113 +30,111 @@ struct builtin_general_functions
 {
   char *name;
   int nargin_max;
   int nargout_max;
   General_fcn general_fcn;
   char *help_string;
 };
 
-extern tree_constant *builtin_all (const tree_constant *, int, int);
-extern tree_constant *builtin_any (const tree_constant *, int, int);
-extern tree_constant *builtin_balance (const tree_constant *, int, int);
-extern tree_constant *builtin_chol (const tree_constant *, int, int);
-extern tree_constant *builtin_clc (const tree_constant *, int, int);
-extern tree_constant *builtin_clock (const tree_constant *, int, int);
-extern tree_constant *builtin_closeplot (const tree_constant *, int, int);
-extern tree_constant *builtin_colloc (const tree_constant *, int, int);
-extern tree_constant *builtin_cumprod (const tree_constant *, int, int);
-extern tree_constant *builtin_cumsum (const tree_constant *, int, int);
-extern tree_constant *builtin_dassl (const tree_constant *, int, int);
-extern tree_constant *builtin_dassl_options (const tree_constant *, int, int);
-extern tree_constant *builtin_date (const tree_constant *, int, int);
-extern tree_constant *builtin_det (const tree_constant *, int, int);
-extern tree_constant *builtin_diag (const tree_constant *, int, int);
-extern tree_constant *builtin_disp (tree_constant *, int, int);
-extern tree_constant *builtin_eig (const tree_constant *, int, int);
-extern tree_constant *builtin_error (tree_constant *, int, int);
-extern tree_constant *builtin_eval (const tree_constant *, int, int);
-extern tree_constant *builtin_exist (const tree_constant *, int, int);
-extern tree_constant *builtin_expm (const tree_constant *, int, int);
-extern tree_constant *builtin_eye (const tree_constant *, int, int);
-extern tree_constant *builtin_fclose (const tree_constant *, int, int);
-extern tree_constant *builtin_feof (const tree_constant *, int, int);
-extern tree_constant *builtin_ferror (const tree_constant *, int, int);
-extern tree_constant *builtin_feval (const tree_constant *, int, int);
-extern tree_constant *builtin_fflush (const tree_constant *, int, int);
-extern tree_constant *builtin_fft (const tree_constant *, int, int);
-extern tree_constant *builtin_fgets (const tree_constant *, int, int);
-extern tree_constant *builtin_find (const tree_constant *, int, int);
-extern tree_constant *builtin_flops (const tree_constant *, int, int);
-extern tree_constant *builtin_fopen (const tree_constant *, int, int);
-extern tree_constant *builtin_fprintf (const tree_constant *, int, int);
-extern tree_constant *builtin_fread (const tree_constant *, int, int);
-extern tree_constant *builtin_frewind (const tree_constant *, int, int);
-extern tree_constant *builtin_freport (const tree_constant *, int, int);
-extern tree_constant *builtin_fscanf (const tree_constant *, int, int);
-extern tree_constant *builtin_fseek (const tree_constant *, int, int);
-extern tree_constant *builtin_fsolve (const tree_constant *, int, int);
-extern tree_constant *builtin_fsolve_options (const tree_constant *, int, int);
-extern tree_constant *builtin_fsqp (const tree_constant *, int, int);
-extern tree_constant *builtin_fsqp_options (const tree_constant *, int, int);
-extern tree_constant *builtin_ftell (const tree_constant *, int, int);
-extern tree_constant *builtin_fwrite (const tree_constant *, int, int);
-extern tree_constant *builtin_getenv (const tree_constant *, int, int);
-extern tree_constant *builtin_givens (const tree_constant *, int, int);
-extern tree_constant *builtin_hess (const tree_constant *, int, int);
-extern tree_constant *builtin_input (const tree_constant *, int, int);
-extern tree_constant *builtin_ifft (const tree_constant *, int, int);
-extern tree_constant *builtin_inv (const tree_constant *, int, int);
-extern tree_constant *builtin_is_global (const tree_constant *, int, int);
-extern tree_constant *builtin_isstr (const tree_constant *, int, int);
-extern tree_constant *builtin_kbhit (const tree_constant *, int, int);
-extern tree_constant *builtin_keyboard (const tree_constant *, int, int);
-extern tree_constant *builtin_logm (const tree_constant *, int, int);
-extern tree_constant *builtin_lpsolve (const tree_constant *, int, int);
-extern tree_constant *builtin_lpsolve_options (const tree_constant *,
-					       int, int);
-extern tree_constant *builtin_lsode (const tree_constant *, int, int);
-extern tree_constant *builtin_lsode_options (const tree_constant *, int, int);
-extern tree_constant *builtin_lu (const tree_constant *, int, int);
-extern tree_constant *builtin_max (const tree_constant *, int, int);
-extern tree_constant *builtin_min (const tree_constant *, int, int);
-extern tree_constant *builtin_npsol (const tree_constant *, int, int);
-extern tree_constant *builtin_npsol_options (const tree_constant *, int, int);
-extern tree_constant *builtin_ones (const tree_constant *, int, int);
-extern tree_constant *builtin_pause (const tree_constant *, int, int);
-extern tree_constant *builtin_purge_tmp_files (const tree_constant *,
-					       int, int);
-extern tree_constant *builtin_printf (const tree_constant *, int, int);
-extern tree_constant *builtin_prod (const tree_constant *, int, int);
-extern tree_constant *builtin_pwd (const tree_constant *, int, int);
-extern tree_constant *builtin_qpsol (const tree_constant *, int, int);
-extern tree_constant *builtin_qpsol_options (const tree_constant *, int, int);
-extern tree_constant *builtin_qr (const tree_constant *, int, int);
-extern tree_constant *builtin_quad (const tree_constant *, int, int);
-extern tree_constant *builtin_quad_options (const tree_constant *, int, int);
-extern tree_constant *builtin_quit (const tree_constant *, int, int);
-extern tree_constant *builtin_qzval (const tree_constant *, int, int);
-extern tree_constant *builtin_rand (const tree_constant *, int, int);
-extern tree_constant *builtin_setstr (tree_constant *, int, int);
-extern tree_constant *builtin_scanf (const tree_constant *, int, int);
-extern tree_constant *builtin_schur (const tree_constant *, int, int);
-extern tree_constant *builtin_shell_command (const tree_constant *, int, int);
-extern tree_constant *builtin_size (const tree_constant *, int, int);
-extern tree_constant *builtin_sort (const tree_constant *, int, int);
-extern tree_constant *builtin_sprintf (const tree_constant *, int, int);
-extern tree_constant *builtin_sqrtm (const tree_constant *, int, int);
-extern tree_constant *builtin_sscanf (const tree_constant *, int, int);
-extern tree_constant *builtin_sum (const tree_constant *, int, int);
-extern tree_constant *builtin_sumsq (const tree_constant *, int, int);
-extern tree_constant *builtin_svd (const tree_constant *, int, int);
-extern tree_constant *builtin_syl (const tree_constant *, int, int);
-extern tree_constant *builtin_va_arg (const tree_constant *, int, int);
-extern tree_constant *builtin_va_start (const tree_constant *, int, int);
-extern tree_constant *builtin_warranty (const tree_constant *, int, int);
-extern tree_constant *builtin_zeros (const tree_constant *, int, int);
+extern Octave_object builtin_all (const Octave_object&, int, int);
+extern Octave_object builtin_any (const Octave_object&, int, int);
+extern Octave_object builtin_balance (const Octave_object&, int, int);
+extern Octave_object builtin_chol (const Octave_object&, int, int);
+extern Octave_object builtin_clc (const Octave_object&, int, int);
+extern Octave_object builtin_clock (const Octave_object&, int, int);
+extern Octave_object builtin_closeplot (const Octave_object&, int, int);
+extern Octave_object builtin_colloc (const Octave_object&, int, int);
+extern Octave_object builtin_cumprod (const Octave_object&, int, int);
+extern Octave_object builtin_cumsum (const Octave_object&, int, int);
+extern Octave_object builtin_dassl (const Octave_object&, int, int);
+extern Octave_object builtin_dassl_options (const Octave_object&, int, int);
+extern Octave_object builtin_date (const Octave_object&, int, int);
+extern Octave_object builtin_det (const Octave_object&, int, int);
+extern Octave_object builtin_diag (const Octave_object&, int, int);
+extern Octave_object builtin_disp (const Octave_object&, int, int);
+extern Octave_object builtin_eig (const Octave_object&, int, int);
+extern Octave_object builtin_error (const Octave_object&, int, int);
+extern Octave_object builtin_eval (const Octave_object&, int, int);
+extern Octave_object builtin_exist (const Octave_object&, int, int);
+extern Octave_object builtin_expm (const Octave_object&, int, int);
+extern Octave_object builtin_eye (const Octave_object&, int, int);
+extern Octave_object builtin_fclose (const Octave_object&, int, int);
+extern Octave_object builtin_feof (const Octave_object&, int, int);
+extern Octave_object builtin_ferror (const Octave_object&, int, int);
+extern Octave_object builtin_feval (const Octave_object&, int, int);
+extern Octave_object builtin_fflush (const Octave_object&, int, int);
+extern Octave_object builtin_fft (const Octave_object&, int, int);
+extern Octave_object builtin_fgets (const Octave_object&, int, int);
+extern Octave_object builtin_find (const Octave_object&, int, int);
+extern Octave_object builtin_flops (const Octave_object&, int, int);
+extern Octave_object builtin_fopen (const Octave_object&, int, int);
+extern Octave_object builtin_fprintf (const Octave_object&, int, int);
+extern Octave_object builtin_fread (const Octave_object&, int, int);
+extern Octave_object builtin_frewind (const Octave_object&, int, int);
+extern Octave_object builtin_freport (const Octave_object&, int, int);
+extern Octave_object builtin_fscanf (const Octave_object&, int, int);
+extern Octave_object builtin_fseek (const Octave_object&, int, int);
+extern Octave_object builtin_fsolve (const Octave_object&, int, int);
+extern Octave_object builtin_fsolve_options (const Octave_object&, int, int);
+extern Octave_object builtin_fsqp (const Octave_object&, int, int);
+extern Octave_object builtin_fsqp_options (const Octave_object&, int, int);
+extern Octave_object builtin_ftell (const Octave_object&, int, int);
+extern Octave_object builtin_fwrite (const Octave_object&, int, int);
+extern Octave_object builtin_getenv (const Octave_object&, int, int);
+extern Octave_object builtin_givens (const Octave_object&, int, int);
+extern Octave_object builtin_hess (const Octave_object&, int, int);
+extern Octave_object builtin_input (const Octave_object&, int, int);
+extern Octave_object builtin_ifft (const Octave_object&, int, int);
+extern Octave_object builtin_inv (const Octave_object&, int, int);
+extern Octave_object builtin_is_global (const Octave_object&, int, int);
+extern Octave_object builtin_isstr (const Octave_object&, int, int);
+extern Octave_object builtin_kbhit (const Octave_object&, int, int);
+extern Octave_object builtin_keyboard (const Octave_object&, int, int);
+extern Octave_object builtin_logm (const Octave_object&, int, int);
+extern Octave_object builtin_lpsolve (const Octave_object&, int, int);
+extern Octave_object builtin_lpsolve_options (const Octave_object&, int, int);
+extern Octave_object builtin_lsode (const Octave_object&, int, int);
+extern Octave_object builtin_lsode_options (const Octave_object&, int, int);
+extern Octave_object builtin_lu (const Octave_object&, int, int);
+extern Octave_object builtin_max (const Octave_object&, int, int);
+extern Octave_object builtin_min (const Octave_object&, int, int);
+extern Octave_object builtin_npsol (const Octave_object&, int, int);
+extern Octave_object builtin_npsol_options (const Octave_object&, int, int);
+extern Octave_object builtin_ones (const Octave_object&, int, int);
+extern Octave_object builtin_pause (const Octave_object&, int, int);
+extern Octave_object builtin_purge_tmp_files (const Octave_object&, int, int);
+extern Octave_object builtin_printf (const Octave_object&, int, int);
+extern Octave_object builtin_prod (const Octave_object&, int, int);
+extern Octave_object builtin_pwd (const Octave_object&, int, int);
+extern Octave_object builtin_qpsol (const Octave_object&, int, int);
+extern Octave_object builtin_qpsol_options (const Octave_object&, int, int);
+extern Octave_object builtin_qr (const Octave_object&, int, int);
+extern Octave_object builtin_quad (const Octave_object&, int, int);
+extern Octave_object builtin_quad_options (const Octave_object&, int, int);
+extern Octave_object builtin_quit (const Octave_object&, int, int);
+extern Octave_object builtin_qzval (const Octave_object&, int, int);
+extern Octave_object builtin_rand (const Octave_object&, int, int);
+extern Octave_object builtin_setstr (const Octave_object&, int, int);
+extern Octave_object builtin_scanf (const Octave_object&, int, int);
+extern Octave_object builtin_schur (const Octave_object&, int, int);
+extern Octave_object builtin_shell_command (const Octave_object&, int, int);
+extern Octave_object builtin_size (const Octave_object&, int, int);
+extern Octave_object builtin_sort (const Octave_object&, int, int);
+extern Octave_object builtin_sprintf (const Octave_object&, int, int);
+extern Octave_object builtin_sqrtm (const Octave_object&, int, int);
+extern Octave_object builtin_sscanf (const Octave_object&, int, int);
+extern Octave_object builtin_sum (const Octave_object&, int, int);
+extern Octave_object builtin_sumsq (const Octave_object&, int, int);
+extern Octave_object builtin_svd (const Octave_object&, int, int);
+extern Octave_object builtin_syl (const Octave_object&, int, int);
+extern Octave_object builtin_va_arg (const Octave_object&, int, int);
+extern Octave_object builtin_va_start (const Octave_object&, int, int);
+extern Octave_object builtin_warranty (const Octave_object&, int, int);
+extern Octave_object builtin_zeros (const Octave_object&, int, int);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -89,33 +89,33 @@ tree_constant::operator delete (void *p,
   ::delete p;
 }
 #endif
 
 /*
  * Construct return vector of empty matrices.  Return empty matrices
  * and/or gripe when appropriate.
  */
-tree_constant *
+Octave_object
 vector_of_empties (int nargout, const char *fcn_name)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
 // Got an empty argument, check if should gripe/return empty values.
 
   int flag = user_pref.propagate_empty_matrices;
   if (flag != 0)
     {
       if (flag < 0)
 	gripe_empty_arg (fcn_name, 0);
 
       Matrix m;
-      retval = new tree_constant [nargout+1];
+      retval.resize (nargout ? nargout : 1);
       for (int i = 0; i < nargout; i++)
-	retval[i] = tree_constant (m);
+	retval(i) = tree_constant (m);
     }
   else
     gripe_empty_arg (fcn_name, 1);
 
   return retval;
 }
 
 Matrix
@@ -477,33 +477,32 @@ find_nonzero_elem_idx (const tree_consta
       break;
     }
   return retval;
 }
 
 // XXX FIXME XXX -- the next two functions (and expm) should really be just
 // one...
 
-tree_constant *
+Octave_object
 matrix_log (const tree_constant& a)
 {
-  tree_constant *retval = new tree_constant [2];
+  Octave_object retval (1);
 
   tree_constant tmp = a.make_numeric ();;
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("logm", 0);
 	  Matrix m;
-	  retval = new tree_constant [2];
-	  retval[0] = tree_constant (m);
+	  retval(0) = tree_constant (m);
 	  return retval;
 	}
       else
 	gripe_empty_arg ("logm", 1);
     }
 
   switch (tmp.const_type ())
     {
@@ -529,17 +528,17 @@ matrix_log (const tree_constant& a)
 		  lambda.elem (i) = log (real (elt));
 		else
 		  lambda.elem (i) = log (elt);
 	      }
 
 	    ComplexDiagMatrix D (lambda);
 	    ComplexMatrix result = Q * D * Q.inverse ();
 
-	    retval[0] = tree_constant (result);
+	    retval(0) = tree_constant (result);
 	  }
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
 
 	int nr = m.rows ();
@@ -560,61 +559,60 @@ matrix_log (const tree_constant& a)
 		  lambda.elem (i) = log (real (elt));
 		else
 		  lambda.elem (i) = log (elt);
 	      }
 
 	    ComplexDiagMatrix D (lambda);
 	    ComplexMatrix result = Q * D * Q.inverse ();
 
-	    retval[0] = tree_constant (result);
+	    retval(0) = tree_constant (result);
 	  }
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
 	if (d > 0.0)
-	  retval[0] = tree_constant (log (d));
+	  retval(0) = tree_constant (log (d));
 	else
 	  {
 	    Complex dtmp (d);
-	    retval[0] = tree_constant (log (dtmp));
+	    retval(0) = tree_constant (log (dtmp));
 	  }
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval[0] = tree_constant (log (c));
+	retval(0) = tree_constant (log (c));
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
-tree_constant *
+Octave_object
 matrix_sqrt (const tree_constant& a)
 {
-  tree_constant *retval = new tree_constant [2];
+  Octave_object retval (1);
 
   tree_constant tmp = a.make_numeric ();;
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("sqrtm", 0);
 	  Matrix m;
-	  retval = new tree_constant [2];
-	  retval[0] = tree_constant (m);
+	  retval(0) = tree_constant (m);
 	  return retval;
 	}
       else
 	gripe_empty_arg ("sqrtm", 1);
     }
 
   switch (tmp.const_type ())
     {
@@ -640,17 +638,17 @@ matrix_sqrt (const tree_constant& a)
 		  lambda.elem (i) = sqrt (real (elt));
 		else
 		  lambda.elem (i) = sqrt (elt);
 	      }
 
 	    ComplexDiagMatrix D (lambda);
 	    ComplexMatrix result = Q * D * Q.inverse ();
 
-	    retval[0] = tree_constant (result);
+	    retval(0) = tree_constant (result);
 	  }
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
 
 	int nr = m.rows ();
@@ -671,370 +669,370 @@ matrix_sqrt (const tree_constant& a)
 		  lambda.elem (i) = sqrt (real (elt));
 		else
 		  lambda.elem (i) = sqrt (elt);
 	      }
 
 	    ComplexDiagMatrix D (lambda);
 	    ComplexMatrix result = Q * D * Q.inverse ();
 
-	    retval[0] = tree_constant (result);
+	    retval(0) = tree_constant (result);
 	  }
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
 	if (d > 0.0)
-	  retval[0] = tree_constant (sqrt (d));
+	  retval(0) = tree_constant (sqrt (d));
 	else
 	  {
 	    Complex dtmp (d);
-	    retval[0] = tree_constant (sqrt (dtmp));
+	    retval(0) = tree_constant (sqrt (dtmp));
 	  }
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval[0] = tree_constant (log (c));
+	retval(0) = tree_constant (log (c));
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
-tree_constant *
-column_max (const tree_constant *args, int nargin, int nargout)
+Octave_object
+column_max (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   tree_constant arg1;
   tree_constant arg2;
   tree_constant_rep::constant_type arg1_type =
     tree_constant_rep::unknown_constant;
   tree_constant_rep::constant_type arg2_type =
     tree_constant_rep::unknown_constant;
 
   switch (nargin)
     {
     case 3:
-      arg2 = args[2].make_numeric ();
+      arg2 = args(2).make_numeric ();
       arg2_type = arg2.const_type ();
 // Fall through...
     case 2:
-      arg1 = args[1].make_numeric ();
+      arg1 = args(1).make_numeric ();
       arg1_type = arg1.const_type ();
       break;
     default:
       panic_impossible ();
       break;
     }
 
-  if (nargin == 2 && nargout == 1)
+  if (nargin == 2 && (nargout == 1 || nargout == 0))
     {
-      retval = new tree_constant [2];
+      retval.resize (1);
       switch (arg1_type)
 	{
         case tree_constant_rep::scalar_constant:
-	  retval[0] = tree_constant (arg1.double_value ());
+	  retval(0) = tree_constant (arg1.double_value ());
           break;
         case tree_constant_rep::complex_scalar_constant:
-          retval[0] = tree_constant (arg1.complex_value ());
+          retval(0) = tree_constant (arg1.complex_value ());
           break;
         case tree_constant_rep::matrix_constant:
           {
   	    Matrix m = arg1.matrix_value ();
 	    if (m.rows () == 1)
-	      retval[0] = tree_constant (m.row_max ());
+	      retval(0) = tree_constant (m.row_max ());
 	    else
-	      retval[0] = tree_constant (m.column_max (), 0);
+	      retval(0) = tree_constant (m.column_max (), 0);
  	  }
           break;
         case tree_constant_rep::complex_matrix_constant:
           {
             ComplexMatrix m = arg1.complex_matrix_value ();
             if (m.rows () == 1)
-              retval[0] = tree_constant (m.row_max ());
+              retval(0) = tree_constant (m.row_max ());
             else
-              retval[0] = tree_constant (m.column_max (), 0);
+              retval(0) = tree_constant (m.column_max (), 0);
           }
 	  break;
 	default:
 	  panic_impossible ();
 	  break;
 	}
     }
   else if (nargin == 2 && nargout == 2)
     {
-      retval = new tree_constant [2];
+      retval.resize (2);
       switch (arg1_type)
         {
 	case tree_constant_rep::scalar_constant:
 	  {
-	    retval[0] = tree_constant (arg1.double_value ());
-	    retval[1] = tree_constant (1);
+	    retval(0) = tree_constant (arg1.double_value ());
+	    retval(1) = tree_constant (1);
 	  }
           break;
 	case tree_constant_rep::complex_scalar_constant:
 	  {
-	    retval[0] = tree_constant (arg1.complex_value ());
-	    retval[1] = tree_constant (1);
+	    retval(0) = tree_constant (arg1.complex_value ());
+	    retval(1) = tree_constant (1);
 	  }
           break;
 	case tree_constant_rep::matrix_constant:
 	  {
 	    Matrix m = arg1.matrix_value ();
 	    if (m.rows () == 1)
 	      {
-		retval[0] = tree_constant (m.row_max ());
-		retval[1] = tree_constant (m.row_max_loc ());
+		retval(0) = tree_constant (m.row_max ());
+		retval(1) = tree_constant (m.row_max_loc ());
 	      }
 	    else
 	      {
-		retval[0] = tree_constant (m.column_max (), 0);
-		retval[1] = tree_constant (m.column_max_loc (), 0);
+		retval(0) = tree_constant (m.column_max (), 0);
+		retval(1) = tree_constant (m.column_max_loc (), 0);
 	      }
 	  }
           break;
 	case tree_constant_rep::complex_matrix_constant:
 	  {
 	    ComplexMatrix m = arg1.complex_matrix_value ();
 	    if (m.rows () == 1)
 	      {
-		retval[0] = tree_constant (m.row_max ());
-		retval[1] = tree_constant (m.row_max_loc ());
+		retval(0) = tree_constant (m.row_max ());
+		retval(1) = tree_constant (m.row_max_loc ());
 	      }
 	    else
 	      {
-		retval[0] = tree_constant (m.column_max (), 0);
-		retval[1] = tree_constant (m.column_max_loc (), 0);
+		retval(0) = tree_constant (m.column_max (), 0);
+		retval(1) = tree_constant (m.column_max_loc (), 0);
 	      }
 	  }
           break;
 	default:
 	  panic_impossible ();
 	  break;
         }
     }
   else if (nargin == 3)
     {
       if (arg1.rows () == arg2.rows ()
 	  && arg1.columns () == arg2.columns ())
 	{
-	  retval = new tree_constant [2];
+	  retval.resize (1);
           switch (arg1_type)
             {
 	    case tree_constant_rep::scalar_constant:
 	      {
 		double result;
 		double a_elem = arg1.double_value ();
 		double b_elem = arg2.double_value ();
 		result = MAX (a_elem, b_elem);
-		retval[0] = tree_constant (result);
+		retval(0) = tree_constant (result);
 	      }
               break;
 	    case tree_constant_rep::complex_scalar_constant:
 	      {
 		Complex result;
 		Complex a_elem = arg1.complex_value ();
 		Complex b_elem = arg2.complex_value ();
 		if (abs (a_elem) > abs (b_elem))
 		  result = a_elem;
 		else
 		  result = b_elem;
-		retval[0] = tree_constant (result);
+		retval(0) = tree_constant (result);
 	      }
               break;
 	    case tree_constant_rep::matrix_constant:
 	      {
 		Matrix result;
 		result = max (arg1.matrix_value (), arg2.matrix_value ());
-		retval[0] = tree_constant (result);
+		retval(0) = tree_constant (result);
 	      }
               break;
 	    case tree_constant_rep::complex_matrix_constant:
 	      {
 		ComplexMatrix result;
 		result = max (arg1.complex_matrix_value (),
 			      arg2.complex_matrix_value ());
-		retval[0] = tree_constant (result);
+		retval(0) = tree_constant (result);
 	      }
 	      break;
 	    default:
 	      panic_impossible ();
 	      break;
 	    }
 	}
       else
 	error ("max: nonconformant matrices");
     }
   else
     panic_impossible ();
 
   return retval;
 }
 
-tree_constant *
-column_min (const tree_constant *args, int nargin, int nargout)
+Octave_object
+column_min (const Octave_object& args, int nargin, int nargout)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   tree_constant arg1;
   tree_constant arg2;
   tree_constant_rep::constant_type arg1_type =
     tree_constant_rep::unknown_constant;
   tree_constant_rep::constant_type arg2_type =
     tree_constant_rep::unknown_constant;
 
   switch (nargin)
     {
     case 3:
-      arg2 = args[2].make_numeric ();
+      arg2 = args(2).make_numeric ();
       arg2_type = arg2.const_type ();
 // Fall through...
     case 2:
-      arg1 = args[1].make_numeric ();
+      arg1 = args(1).make_numeric ();
       arg1_type = arg1.const_type ();
       break;
     default:
       panic_impossible ();
       break;
     }
 
-  if (nargin == 2 && nargout == 1)
+  if (nargin == 2 && (nargout == 1 || nargout == 0))
     {
-      retval = new tree_constant [2];
+      retval.resize (1);
       switch (arg1_type)
 	{
         case tree_constant_rep::scalar_constant:
-	  retval[0] = tree_constant (arg1.double_value ());
+	  retval(0) = tree_constant (arg1.double_value ());
           break;
         case tree_constant_rep::complex_scalar_constant:
-          retval[0] = tree_constant (arg1.complex_value ());
+          retval(0) = tree_constant (arg1.complex_value ());
           break;
         case tree_constant_rep::matrix_constant:
           {
   	    Matrix m = arg1.matrix_value ();
 	    if (m.rows () == 1)
-	      retval[0] = tree_constant (m.row_min ());
+	      retval(0) = tree_constant (m.row_min ());
 	    else
-	      retval[0] = tree_constant (m.column_min (), 0);
+	      retval(0) = tree_constant (m.column_min (), 0);
  	  }
           break;
         case tree_constant_rep::complex_matrix_constant:
           {
             ComplexMatrix m = arg1.complex_matrix_value ();
             if (m.rows () == 1)
-              retval[0] = tree_constant (m.row_min ());
+              retval(0) = tree_constant (m.row_min ());
             else
-              retval[0] = tree_constant (m.column_min (), 0);
+              retval(0) = tree_constant (m.column_min (), 0);
           }
 	  break;
 	default:
 	  panic_impossible ();
 	  break;
 	}
     }
   else if (nargin == 2 && nargout == 2)
     {
-      retval = new tree_constant [2];
+      retval.resize (2);
       switch (arg1_type)
         {
 	case tree_constant_rep::scalar_constant:
 	  {
-	    retval[0] = tree_constant (arg1.double_value ());
-	    retval[1] = tree_constant (1);
+	    retval(0) = tree_constant (arg1.double_value ());
+	    retval(1) = tree_constant (1);
 	  }
           break;
 	case tree_constant_rep::complex_scalar_constant:
 	  {
-	    retval[0] = tree_constant (arg1.complex_value ());
-	    retval[1] = tree_constant (1);
+	    retval(0) = tree_constant (arg1.complex_value ());
+	    retval(1) = tree_constant (1);
 	  }
           break;
 	case tree_constant_rep::matrix_constant:
 	  {
 	    Matrix m = arg1.matrix_value ();
 	    if (m.rows () == 1)
 	      {
-		retval[0] = tree_constant (m.row_min ());
-		retval[1] = tree_constant (m.row_min_loc ());
+		retval(0) = tree_constant (m.row_min ());
+		retval(1) = tree_constant (m.row_min_loc ());
 	      }
 	    else
 	      {
-		retval[0] = tree_constant (m.column_min (), 0);
-		retval[1] = tree_constant (m.column_min_loc (), 0);
+		retval(0) = tree_constant (m.column_min (), 0);
+		retval(1) = tree_constant (m.column_min_loc (), 0);
 	      }
 	  }
           break;
 	case tree_constant_rep::complex_matrix_constant:
 	  {
 	    ComplexMatrix m = arg1.complex_matrix_value ();
 	    if (m.rows () == 1)
 	      {
-		retval[0] = tree_constant (m.row_min ());
-		retval[1] = tree_constant (m.row_min_loc ());
+		retval(0) = tree_constant (m.row_min ());
+		retval(1) = tree_constant (m.row_min_loc ());
 	      }
 	    else
 	      {
-		retval[0] = tree_constant (m.column_min (), 0);
-		retval[1] = tree_constant (m.column_min_loc (), 0);
+		retval(0) = tree_constant (m.column_min (), 0);
+		retval(1) = tree_constant (m.column_min_loc (), 0);
 	      }
 	  }
           break;
 	default:
 	  panic_impossible ();
 	  break;
         }
     }
   else if (nargin == 3)
     {
       if (arg1.rows () == arg2.rows ()
 	  && arg1.columns () == arg2.columns ())
 	{
-	  retval = new tree_constant [2];
+	  retval.resize (1);
           switch (arg1_type)
             {
 	    case tree_constant_rep::scalar_constant:
 	      {
 		double result;
 		double a_elem = arg1.double_value ();
 		double b_elem = arg2.double_value ();
 		result = MIN (a_elem, b_elem);
-		retval[0] = tree_constant (result);
+		retval(0) = tree_constant (result);
 	      }
               break;
 	    case tree_constant_rep::complex_scalar_constant:
 	      {
 		Complex result;
 		Complex a_elem = arg1.complex_value ();
 		Complex b_elem = arg2.complex_value ();
 		if (abs (a_elem) < abs (b_elem))
 		  result = a_elem;
 		else
 		  result = b_elem;
-		retval[0] = tree_constant (result);
+		retval(0) = tree_constant (result);
 	      }
               break;
 	    case tree_constant_rep::matrix_constant:
 	      {
 		Matrix result;
 		result = min (arg1.matrix_value (), arg2.matrix_value ());
-		retval[0] = tree_constant (result);
+		retval(0) = tree_constant (result);
 	      }
               break;
 	    case tree_constant_rep::complex_matrix_constant:
 	      {
 		ComplexMatrix result;
 		result = min (arg1.complex_matrix_value (),
 			      arg2.complex_matrix_value ());
-		retval[0] = tree_constant (result);
+		retval(0) = tree_constant (result);
 	      }
 	      break;
 	    default:
 	      panic_impossible ();
 	      break;
 	    }
 	}
       else
@@ -1175,124 +1173,125 @@ mx_sort (ComplexRowVector& cv, RowVector
 	    {
 	      double tmp = idx.elem (k);
 	      idx.elem (k) = idx.elem (k+gap);
 	      idx.elem (k+gap) = tmp;
 	    }
 	}
 }
 
-tree_constant *
-sort (const tree_constant *args, int nargin, int nargout)
+Octave_object
+sort (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   int return_idx = nargout > 1;
   if (return_idx)
-    retval = new tree_constant [3];
+    retval.resize (2);
   else
-    retval = new tree_constant [2];
+    retval.resize (1);
 
-  switch (args[1].const_type ())
+  switch (args(1).const_type ())
     {
     case tree_constant_rep::scalar_constant:
       {
-	retval [0] = tree_constant (args[1].double_value ());
+	retval(0) = tree_constant (args(1).double_value ());
 	if (return_idx)
-	  retval [1] = tree_constant (1.0);
+	  retval(1) = tree_constant (1.0);
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
-	retval [0] = tree_constant (args[1].complex_value ());
+	retval(0) = tree_constant (args(1).complex_value ());
 	if (return_idx)
-	  retval [1] = tree_constant (1.0);
+	  retval(1) = tree_constant (1.0);
       }
       break;
     case tree_constant_rep::string_constant:
     case tree_constant_rep::range_constant:
     case tree_constant_rep::matrix_constant:
       {
-	Matrix m = args[1].to_matrix ();
+	Matrix m = args(1).to_matrix ();
 	if (m.rows () == 1)
 	  {
 	    int nc = m.columns ();
 	    RowVector v (nc);
 	    for (int i = 0; i < nc; i++)
 	      v.elem (i) = m.elem (0, i);
 	    RowVector idx;
 	    mx_sort (v, idx, return_idx);
 
-	    retval [0] = tree_constant (v, 0);
+	    retval(0) = tree_constant (v, 0);
 	    if (return_idx)
-	      retval [1] = tree_constant (idx, 0);
+	      retval(1) = tree_constant (idx, 0);
 	  }
 	else
 	  {
 // Sorts m in place, optionally computes index Matrix.
 	    Matrix idx;
 	    mx_sort (m, idx, return_idx);
 
-	    retval [0] = tree_constant (m);
+	    retval(0) = tree_constant (m);
 	    if (return_idx)
-	      retval [1] = tree_constant (idx);
+	      retval(1) = tree_constant (idx);
 	  }
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
-	ComplexMatrix cm = args[1].complex_matrix_value ();
+	ComplexMatrix cm = args(1).complex_matrix_value ();
 	if (cm.rows () == 1)
 	  {
 	    int nc = cm.columns ();
 	    ComplexRowVector cv (nc);
 	    for (int i = 0; i < nc; i++)
 	      cv.elem (i) = cm.elem (0, i);
 	    RowVector idx;
 	    mx_sort (cv, idx, return_idx);
 
-	    retval [0] = tree_constant (cv, 0);
+	    retval(0) = tree_constant (cv, 0);
 	    if (return_idx)
-	      retval [1] = tree_constant (idx, 0);
+	      retval(1) = tree_constant (idx, 0);
 	  }
 	else
 	  {
 // Sorts cm in place, optionally computes index Matrix.
 	    Matrix idx;
 	    mx_sort (cm, idx, return_idx);
 
-	    retval [0] = tree_constant (cm);
+	    retval(0) = tree_constant (cm);
 	    if (return_idx)
-	      retval [1] = tree_constant (idx);
+	      retval(1) = tree_constant (idx);
 	  }
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
-tree_constant *
-feval (const tree_constant *args, int nargin, int nargout)
+Octave_object
+feval (const Octave_object& args, int nargin, int nargout)
 {
 // Assumes that we have been given the correct number of arguments.
 
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
-  tree_fvc *fcn = is_valid_function (args[1], "feval", 1);
+  tree_fvc *fcn = is_valid_function (args(1), "feval", 1);
   if (fcn != (tree_fvc *) NULL)
     {
-      args++;
-      nargin--;
-      retval = fcn->eval (0, nargout, args, nargin);
+      Octave_object tmp_args (--nargin);
+      for (int i = 0; i < nargin; i++)
+	tmp_args(i) = args(i+1);
+      retval = fcn->eval (0, nargout, tmp_args, nargin);
     }
 
   return retval;
 }
 
 tree_constant
 eval_string (const char *string, int print, int ans_assign,
 	     int& parse_status)
@@ -1367,39 +1366,39 @@ match_sans_spaces (const char *standard,
     ep--;
 
   int len = ep - tp + 1;
 
   return (strncmp (standard, tp, len) == 0);
 }
 
 tree_constant
-get_user_input (const tree_constant *args, int nargin, int nargout,
+get_user_input (const Octave_object& args, int nargin, int nargout,
 		int debug = 0)
 {
   tree_constant retval;
 
   int read_as_string = 0;
   if (nargin == 3)
     {
-      if (args[2].is_string_type ()
-	  && strcmp ("s", args[2].string_value ()) == 0)
+      if (args(2).is_string_type ()
+	  && strcmp ("s", args(2).string_value ()) == 0)
 	read_as_string++;
       else
 	{
 	  error ("input: unrecognized second argument");
 	  return retval;
 	}
     }
 
   char *prompt = "debug> ";
   if (nargin > 1)
    {
-      if (args[1].is_string_type ())
-	prompt = args[1].string_value ();
+      if (args(1).is_string_type ())
+	prompt = args(1).string_value ();
       else
 	{
 	  error ("input: unrecognized argument");
 	  return retval;
 	}
     }
 
  again:
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -25,23 +25,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #define octave_tree_const_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <stdlib.h>
 
+#include "Array.h"
+#include "mx-base.h"
+#include "Range.h"
+
 #include "builtins.h"
 #include "tree-base.h"
 #include "tree-expr.h"
 #include "tc-rep.h"
-
-#include "mx-base.h"
-#include "Range.h"
+#include "oct-obj.h"
 
 class idx_vector;
 
 /*
  * Constants.
  */
 class
 tree_constant : public tree_fvc
@@ -166,17 +168,18 @@ public:
       if (is_numeric_type ()
 	  || rep->type_tag == tree_constant_rep::magic_colon
 	  || rep->type_tag == tree_constant_rep::range_constant)
 	return *this;
       else
 	return rep->make_numeric ();
     }
 
-  tree_constant assign (tree_constant& rhs, tree_constant *args, int nargs)
+  tree_constant assign (tree_constant& rhs, const Octave_object& args,
+			int nargs)
     {
       if (rep->count > 1)
 	{
 	  --rep->count;
 	  rep = new tree_constant_rep (*rep);
 	  rep->count = 1;
 	}
       rep->assign (rhs, args, nargs);
@@ -260,74 +263,73 @@ public:
   tree_constant eval (int print)
     {
       rep->maybe_mutate ();
       if (print)
 	rep->print ();
       return *this;
     }
 
-  tree_constant *eval (int print, int nargout,
-		       const tree_constant *args = NULL_TREE_CONST,
-		       int nargin = 0)
+  Octave_object eval (int print, int nargout, const Octave_object& args,
+		      int nargin)
     {
-      tree_constant *retval = new tree_constant [2];
+      Octave_object retval (1);
 
-      if (args != NULL_TREE_CONST && nargin > 0)
-	retval[0] = rep->do_index (args, nargin);
+      if (args.length () > 0 && nargin > 0)
+	retval(0) = rep->do_index (args, nargin);
       else
-	retval[0] = *this;
+	retval(0) = *this;
 
-      if (retval[0].is_defined ())
-	retval[0].eval (print);
+      if (retval(0).is_defined ())
+	retval(0).eval (print);
       return retval;
     }
 
 private:
   tree_constant_rep *rep;
 };
 
 /*
  * Here are some extra functions that are related to the tree_constant
  * class but that don't need to be class members or friends.
  */
 
-extern tree_constant *vector_of_empties (int nargout, const char *fcn_name);
+extern Octave_object vector_of_empties (int nargout, const char *fcn_name);
 
 extern tree_constant fill_matrix (const tree_constant& a,
 				  double d, const char *warn_for);
 extern tree_constant fill_matrix (const tree_constant& a,
 				  const tree_constant& b,
 				  double d, const char *warn_for);
 
 extern tree_constant identity_matrix (const tree_constant& a);
 extern tree_constant identity_matrix (const tree_constant& a,
 				      const tree_constant& b);
 
 extern tree_constant find_nonzero_elem_idx (const tree_constant& a);
 
-extern tree_constant *matrix_log (const tree_constant& a);
-extern tree_constant *matrix_sqrt (const tree_constant& a);
+extern Octave_object matrix_log (const tree_constant& a);
+extern Octave_object matrix_sqrt (const tree_constant& a);
 
-extern tree_constant *column_max (const tree_constant *args, int nargin,
-				  int nargout);
+extern Octave_object column_max (const Octave_object& args, int nargin,
+				 int nargout);
 
-extern tree_constant *column_min (const tree_constant *args, int nargin,
-				  int nargout);
+extern Octave_object column_min (const Octave_object& args, int nargin,
+				 int nargout);
   
-extern tree_constant *sort (const tree_constant *args, int nargin,
-			    int nargout);
+extern Octave_object sort (const Octave_object& args, int nargin,
+			   int nargout);
  
-extern tree_constant *feval (const tree_constant *args, int nargin,
-			     int nargout);
+extern Octave_object feval (const Octave_object& args, int nargin,
+			    int nargout);
 
 extern tree_constant eval_string (const tree_constant& arg, int&
 				  parse_status);
 
-extern tree_constant get_user_input (const tree_constant *args,
+extern tree_constant get_user_input (const Octave_object& args,
 				     int nargin, int nargout,
 				     int debug = 0);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -103,35 +103,35 @@ print_as_scalar (const tree_constant& va
 		  || nr == 0
 		  || nc == 0)));
 }
 
 /*
  * Make sure that all arguments have values.
  */
 static int
-all_args_defined (tree_constant *args, int nargs)
+all_args_defined (const Octave_object& args, int nargs)
 {
   while (--nargs > 0)
     {
-      if (args[nargs].is_undefined ())
+      if (args(nargs).is_undefined ())
 	return 0;
     }
   return 1;
 }
 
 /*
  * Are any of the arguments `:'?
  */
 static int
-any_arg_is_magic_colon (const tree_constant *args, int nargs)
+any_arg_is_magic_colon (const Octave_object& args, int nargs)
 {
   while (--nargs > 0)
     {
-      if (args[nargs].const_type () == tree_constant_rep::magic_colon)
+      if (args(nargs).const_type () == tree_constant_rep::magic_colon)
 	return 1;
     }
   return 0;
 }
 
 // NOTE: functions for the tree_constant_rep and tree_constant classes
 // are now defined in tree-const.cc.  This should help speed up
 // compilation when working only on the tree_constant class.
@@ -568,17 +568,17 @@ tree_matrix::eval (int print)
 
  done:
   delete [] list;
 
   return retval;
 }
 
 tree_constant
-tree_fvc::assign (tree_constant& t, tree_constant *args, int nargs)
+tree_fvc::assign (tree_constant& t, const Octave_object& args, int nargs)
 {
   panic_impossible ();
   return tree_constant ();
 }
 
 /*
  * Builtin functions.
  */
@@ -645,57 +645,53 @@ tree_builtin::eval (int print)
 
   if (error_state)
     return retval;
 
   if (text_fcn != (Text_fcn) NULL)
     {
       char **argv = new char * [1];
       argv[0] = strsave (my_name);
-      tree_constant *tmp = (*text_fcn) (1, argv, 1);
-      if (tmp != NULL_TREE)
-	retval = tmp[0];
-      delete [] tmp;
+      Octave_object tmp = (*text_fcn) (1, argv, 1);
+      if (tmp.length () > 0)
+	retval = tmp(0);
       delete [] argv;
     }
   else if (general_fcn != (General_fcn) NULL)
     {
-      tree_constant *args = new tree_constant [1];
-      args[0] = tree_constant (my_name);
-      tree_constant *tmp = (*general_fcn) (args, 1, 1);
-      delete [] args;
-      if (tmp != NULL_TREE_CONST)
-	retval = tmp[0];
-      delete [] tmp;
+      Octave_object args (1);
+      args(0) = tree_constant (my_name);
+      Octave_object tmp = (*general_fcn) (args, 1, 1);
+      if (tmp.length () > 0)
+	retval = tmp(0);
     }
   else // Assume mapper function
     ::error ("%s: argument expected", my_name);
 
   return retval;
 }
 
-tree_constant *
-tree_builtin::eval (int print, int nargout,
-		    const tree_constant *args = NULL_TREE_CONST,
-		    int nargin = 0)
+Octave_object
+tree_builtin::eval (int print, int nargout, const Octave_object& args,
+		    int nargin)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (text_fcn != (Text_fcn) NULL)
     {
 // XXX FIXME XXX -- what if some arg is not a string?
 
       int argc = nargin;
       char **argv = new char * [argc + 1];
       argv[0] = strsave (my_name);
       for (int i = 1; i < argc; i++)
-	argv[i] = strsave (args[i].string_value ());
+	argv[i] = strsave (args(i).string_value ());
       argv[argc] = (char *) NULL;
 
       retval = (*text_fcn) (argc, argv, nargout);
 
       for (i = 0; i < argc; i++)
 	delete [] argv[i];
       delete [] argv;
     }
@@ -705,22 +701,21 @@ tree_builtin::eval (int print, int nargo
 	::error ("invalid use of colon in function argument list");
       else
 	retval = (*general_fcn) (args, nargin, nargout);
     }
   else
     {
       if (nargin > nargin_max)
 	::error ("%s: too many arguments", my_name);
-      else if (nargin > 0 && args != NULL_TREE_CONST && args[1].is_defined ())
+      else if (nargin > 0 && args.length () > 0 && args(1).is_defined ())
 	{
-	  tree_constant tmp = args[1].mapper (mapper_fcn, 0);
-	  retval = new tree_constant [2];
-	  retval[0] = tmp;
-	  retval[1] = tree_constant ();
+	  tree_constant tmp = args(1).mapper (mapper_fcn, 0);
+	  retval.resize (1);
+	  retval(0) = tmp;
 	}	
     }
 
   return retval;
 }
 
 char *
 tree_builtin::name (void) const
@@ -836,17 +831,18 @@ tree_identifier::assign (tree_constant& 
 
   if (status)
     return rhs;
   else
     return tree_constant ();
 }
 
 tree_constant
-tree_identifier::assign (tree_constant& rhs, tree_constant *args, int nargs)
+tree_identifier::assign (tree_constant& rhs, const Octave_object& args,
+			 int nargs)
 {
   tree_constant retval;
 
   if (rhs.is_defined ())
     {
       if (! sym->is_defined ())
 	{
 	  if (! (sym->is_formal_parameter ()
@@ -881,16 +877,22 @@ tree_identifier::assign (tree_constant& 
 	  if (retval.is_defined ())
 	    sym->define (tmp);
 	}
     }
 
   return retval;
 }
 
+int
+tree_identifier::is_defined (void)
+{
+  return (sym != (symbol_record *) NULL && sym->is_defined ());
+}
+
 void
 tree_identifier::bump_value (tree::expression_type etype)
 {
   if (sym != (symbol_record *) NULL)
     {
       tree_fvc *tmp = sym->def ();
       if (tmp != NULL_TREE)
 	tmp->bump_value (etype);
@@ -1144,22 +1146,21 @@ tree_identifier::eval (int print)
   if (! script_file_executed)
     {
       if (ans == (tree_fvc *) NULL)
 	eval_undefined_error ();
       else
 	{
 	  int nargout = maybe_do_ans_assign ? 0 : 1;
 
-	  tree_constant *tmp = ans->eval (0, nargout);
-
-	  if (tmp != NULL_TREE_CONST)
-	    retval = tmp[0];
-
-	  delete [] tmp;
+	  Octave_object tmp_args;
+	  Octave_object tmp = ans->eval (0, nargout, tmp_args, 0);
+
+	  if (tmp.length () > 0)
+	    retval = tmp(0);
 	}
     }
 
   if (! error_state && retval.is_defined ())
     {
       if (maybe_do_ans_assign && ! ans->is_constant ())
 	{
 	  symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
@@ -1209,22 +1210,21 @@ tree_identifier::eval (int print)
 		  maybe_page_output (output_buf);
 		}
 	    }
 	}
     }
   return retval;
 }
 
-tree_constant *
-tree_identifier::eval (int print, int nargout,
-		       const tree_constant *args = NULL_TREE_CONST,
-		       int nargin = 0)
+Octave_object
+tree_identifier::eval (int print, int nargout, const Octave_object& args,
+		       int nargin)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (error_state)
     return retval;
 
   int script_file_executed = 0;
 
   tree_fvc *ans = do_lookup (script_file_executed);
 
@@ -1238,25 +1238,25 @@ tree_identifier::eval (int print, int na
 	    {
 
 // Don't count the output arguments that we create automatically.
 
 	      nargout = 0;
 
 	      retval = ans->eval (0, nargout, args, nargin);
 
-	      if (retval != NULL_TREE_CONST && retval[0].is_defined ())
+	      if (retval.length () > 0 && retval(0).is_defined ())
 		{
 		  symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
 		  assert (sr != (symbol_record *) NULL);
       
 		  tree_identifier *ans_id = new tree_identifier (sr);
 
-		  tree_constant *tmp = new tree_constant (retval[0]);
+		  tree_constant *tmp = new tree_constant (retval(0));
 
 		  tree_simple_assignment_expression tmp_ass (ans_id, tmp);
 
 		  tmp_ass.eval (print);
 
 		  delete ans_id;  // XXX FIXME XXX
 		}
 	    }
@@ -1279,17 +1279,16 @@ tree_function::tree_function (void)
   sym_tab = (symbol_table *) NULL;
   cmd_list = NULL_TREE;
   file_name = (char *) NULL;
   fcn_name = (char *) NULL;
   t_parsed = 0;
   system_fcn_file = 0;
   varargs_ok = 0;
   num_named_args = 0;
-  args_passed = NULL_TREE_CONST;
   num_args_passed = 0;
   curr_arg_number = 0;
 }
 
 tree_function::tree_function (tree *cl, symbol_table *st)
 {
   call_depth = 0;
   param_list = (tree_parameter_list *) NULL;
@@ -1297,17 +1296,16 @@ tree_function::tree_function (tree *cl, 
   sym_tab = st;
   cmd_list = cl;
   file_name = (char *) NULL;
   fcn_name = (char *) NULL;
   t_parsed = 0;
   system_fcn_file = 0;
   varargs_ok = 0;
   num_named_args = 0;
-  args_passed = NULL_TREE_CONST;
   num_args_passed = 0;
   curr_arg_number = 0;
 }
 
 tree_function::~tree_function (void)
 {
 }
 
@@ -1409,17 +1407,17 @@ tree_function::octave_va_start (void)
 
 tree_constant
 tree_function::octave_va_arg (void)
 {
   tree_constant retval;
 
   if (curr_arg_number < num_args_passed)
     {
-      retval = args_passed[curr_arg_number];
+      retval = args_passed(curr_arg_number);
       curr_arg_number++;
     }
   else
     ::error ("error getting arg number %d -- only %d provided",
 	     curr_arg_number, num_args_passed-1);
 
   return retval;
 }
@@ -1440,21 +1438,21 @@ tree_function::function_name (void)
 tree_constant
 tree_function::eval (int print)
 {
   tree_constant retval;
 
   if (error_state || cmd_list == NULL_TREE)
     return retval;
 
-  tree_constant *tmp = eval (print, 1);
-
-  if (! error_state && tmp != NULL_TREE_CONST)
-    retval = tmp[0];
-  delete [] tmp;
+  Octave_object tmp_args;
+  Octave_object tmp = eval (print, 1, tmp_args, 0);
+
+  if (! error_state && tmp.length () > 0)
+    retval = tmp(0);
 
   return retval;
 }
 
 // For unwind protect.
 
 static void
 pop_symbol_table_context (void *table)
@@ -1465,22 +1463,21 @@ pop_symbol_table_context (void *table)
 
 static void
 clear_symbol_table (void *table)
 {
   symbol_table *tmp = (symbol_table *) table;
   tmp->clear ();
 }
 
-tree_constant *
-tree_function::eval (int print, int nargout,
-		     const tree_constant *args = NULL_TREE_CONST,
-		     int nargin = 0)
+Octave_object
+tree_function::eval (int print, int nargout, const Octave_object& args,
+		     int nargin)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (cmd_list == NULL_TREE)
     return retval;
 
   begin_unwind_frame ("func_eval");
@@ -1501,17 +1498,17 @@ tree_function::eval (int print, int narg
 // Save old and set current symbol table context, for eval_undefined_error().
 
   unwind_protect_ptr (curr_sym_tab);
   curr_sym_tab = sym_tab;
 
   unwind_protect_ptr (curr_function);
   curr_function = this;
 
-  unwind_protect_ptr (args_passed);
+//  unwind_protect_ptr (args_passed);
   args_passed = args;
 
   unwind_protect_int (num_args_passed);
   num_args_passed = nargin;
 
   unwind_protect_int (num_named_args);
   unwind_protect_int (curr_arg_number);
 
@@ -1548,19 +1545,18 @@ tree_function::eval (int print, int narg
 // Copy return values out.
 
     if (ret_list != (tree_parameter_list *) NULL)
       {
 	retval = ret_list->convert_to_const_vector ();
       }
     else if (user_pref.return_last_computed_value)
       {
-	retval = new tree_constant [2];
-	retval[0] = last_computed_value;
-	retval[1] = tree_constant ();
+	retval.resize (1);
+	retval(0) = last_computed_value;
       }
   }
 
  abort:
   run_unwind_frame ("func_eval");
 
   return retval;
 }
@@ -1615,16 +1611,24 @@ tree_expression::~tree_expression (void)
 
 tree_constant
 tree_expression::eval (int print)
 {
   panic ("invalid evaluation of generic expression");
   return tree_constant ();
 }
 
+Octave_object
+tree_expression::eval (int print, int nargout, const Octave_object& args,
+		       int nargin)
+{
+  panic_impossible ();
+  return Octave_object ();
+}
+
 /*
  * Prefix expressions.
  */
 tree_prefix_expression::tree_prefix_expression (int l = -1, int c = -1)
 {
   id = (tree_identifier *) NULL;
   etype = unknown;
   line_num = l;
@@ -2118,28 +2122,26 @@ tree_simple_assignment_expression::eval 
 	  ans = lhs->assign (rhs_val);
 	  if (error_state)
 	    eval_error ();
 	}
       else
 	{
 // Extract the arguments into a simple vector.
 	  int nargs = 0;
-	  tree_constant *args = index->convert_to_const_vector (nargs);
+	  Octave_object args = index->convert_to_const_vector (nargs);
 
 	  if (error_state)
 	    eval_error ();
 	  else if (nargs > 1)
 	    {
 	      ans = lhs->assign (rhs_val, args, nargs);
 	      if (error_state)
 		eval_error ();
 	    }
-
-	  delete [] args;
 	}
     }
 
   if (! error_state && ans.is_defined ())
     {
       int pad_after = 0;
       if (print && user_pref.print_answer_id_name)
 	{
@@ -2218,116 +2220,108 @@ tree_multi_assignment_expression::~tree_
 tree_constant
 tree_multi_assignment_expression::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  tree_constant *result = eval (print, 1);
-
-  if (result != NULL_TREE_CONST)
-    {
-      retval = result[0];
-      delete [] result;
-    }
+  Octave_object tmp_args;
+  Octave_object result = eval (print, 1, tmp_args, 0);
+
+  if (result.length () > 0)
+    retval = result(0);
 
   return retval;
 }
 
-tree_constant *
+Octave_object
 tree_multi_assignment_expression::eval (int print, int nargout,
-					const tree_constant *args =
-					NULL_TREE_CONST,
-					int nargin = 0)
+					const Octave_object& args,
+					int nargin)
 {
   assert (etype == tree::multi_assignment);
 
   if (error_state || rhs == (tree_expression *) NULL)
-    return NULL_TREE_CONST;
+    return Octave_object ();
 
   nargout = lhs->length ();
-  tree_constant *results = rhs->eval (0, nargout);
+  Octave_object tmp_args;
+  Octave_object results = rhs->eval (0, nargout, tmp_args, 0);
 
   if (error_state)
     eval_error ();
 
   int ma_line = line ();
   int ma_column = column ();
 
-  if (results != NULL_TREE_CONST)
+  if (results.length () > 0)
     {
       tree_return_list *elem;
       int i = 0;
       int pad_after = 0;
       int last_was_scalar_type = 0;
       for (elem = lhs; elem != (tree_return_list *) NULL;
 	   elem = elem->next_elem ())
 	{
 	  tree_index_expression *lhs_expr = elem->idx_expr ();
 	  if (i < nargout)
 	    {
-	      if (results[i].is_undefined ())
+// XXX FIXME? XXX -- this is apparently the way Matlab works, but
+// maybe we should have the option of skipping the assignment instead.
+
+	      tree_constant *tmp = NULL_TREE_CONST;
+	      if (results(i).is_undefined ())
 		{
-		  tree_simple_assignment_expression tmp_expr
-		    (lhs_expr, NULL_TREE_CONST, ma_line, ma_column);
-
-		  results[i] = tmp_expr.eval (0); // Should stay undefined!
-
-		  if (error_state)
-		    break;
-
-		  if (last_was_scalar_type && i == 1)
-		    pad_after = 0;
-
-		  break;
+		  Matrix m;
+		  tmp = new tree_constant (m);
 		}
 	      else
+		tmp = new tree_constant (results(i));
+
+	      tree_simple_assignment_expression tmp_expr
+		(lhs_expr, tmp, ma_line, ma_column);
+
+	      results(i) = tmp_expr.eval (0); // May change
+
+	      if (error_state)
+		break;
+
+	      if (print && pad_after)
 		{
-		  tree_constant *tmp = new tree_constant (results[i]);
-
-		  tree_simple_assignment_expression tmp_expr
-		    (lhs_expr, tmp, ma_line, ma_column);
-
-		  results[i] = tmp_expr.eval (0); // May change
-
-		  if (error_state)
-		    break;
-
-		  if (print && pad_after)
+		  ostrstream output_buf;
+		  output_buf << "\n" << '\0';
+		  maybe_page_output (output_buf);
+		}
+
+	      if (print && user_pref.print_answer_id_name)
+		{
+		  tree_identifier *tmp_id = lhs_expr->ident ();
+		  char *tmp_nm = tmp_id->name ();
+		  
+		  if (print_as_scalar (results(i)))
 		    {
 		      ostrstream output_buf;
-		      output_buf << "\n" << '\0';
+		      output_buf << tmp_nm << " = " << '\0';
 		      maybe_page_output (output_buf);
+		      last_was_scalar_type = 1;
 		    }
-
-		  if (print && user_pref.print_answer_id_name)
+		  else
 		    {
-		      tree_identifier *tmp_id = lhs_expr->ident ();
-		      char *tmp_nm = tmp_id->name ();
-
-		      if (print_as_scalar (results[i]))
-			{
-			  ostrstream output_buf;
-			  output_buf << tmp_nm << " = " << '\0';
-			  maybe_page_output (output_buf);
-			  last_was_scalar_type = 1;
-			}
-		      else
-			{
-			  ostrstream output_buf;
-			  output_buf << tmp_nm << " =\n\n" << '\0';
-			  maybe_page_output (output_buf);
-			  last_was_scalar_type = 0;
-			}
+		      ostrstream output_buf;
+		      output_buf << tmp_nm << " =\n\n" << '\0';
+		      maybe_page_output (output_buf);
+		      last_was_scalar_type = 0;
 		    }
-		  results[i].eval (print);
-		  pad_after++;
 		}
+
+	      results(i).eval (print);
+
+	      pad_after++;
 	      i++;
 	    }
 	  else
 	    {
 	      tree_simple_assignment_expression tmp_expr
 		(lhs_expr, NULL_TREE_CONST, ma_line, ma_column);
 
 	      tmp_expr.eval (0);
@@ -2567,69 +2561,64 @@ tree_index_expression::eval (int print)
       retval = id->eval (print);
       if (error_state)
 	eval_error ();
     }
   else
     {
 // Extract the arguments into a simple vector.
       int nargin = 0;
-      tree_constant *args = list->convert_to_const_vector (nargin);
+      Octave_object args = list->convert_to_const_vector (nargin);
 // Don't pass null arguments.
       if (error_state)
 	eval_error ();
       else if (nargin > 1 && all_args_defined (args, nargin))
 	{
-	  tree_constant *tmp = id->eval (print, 1, args, nargin);
+	  Octave_object tmp = id->eval (print, 1, args, nargin);
 
 	  if (error_state)
 	    eval_error ();
 
-	  if (tmp != NULL_TREE_CONST)
-	    retval = tmp[0];
-
-	  delete [] tmp;
+	  if (tmp.length () > 0)
+	    retval = tmp(0);
 	}
-      delete [] args;
     }
   return retval;
 }
 
-tree_constant *
+Octave_object
 tree_index_expression::eval (int print, int nargout,
-			     const tree_constant *args = NULL_TREE_CONST,
-			     int nargin = 0)
+			     const Octave_object& args, int nargin)
 {
-  tree_constant *retval = NULL_TREE_CONST;
+  Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (list == (tree_argument_list *) NULL)
     {
-      retval = id->eval (print, nargout);
+      Octave_object tmp_args;
+      retval = id->eval (print, nargout, tmp_args, 0);
       if (error_state)
 	eval_error ();
     }
   else
     {
 // Extract the arguments into a simple vector.
       int nargin = 0;
-      tree_constant *args = list->convert_to_const_vector (nargin);
+      Octave_object args = list->convert_to_const_vector (nargin);
 // Don't pass null arguments.
       if (error_state)
 	eval_error ();
       else if (nargin > 1 && all_args_defined (args, nargin))
 	{
 	  retval = id->eval (print, nargout, args, nargin);
 	  if (error_state)
 	    eval_error ();
 	}
-
-      delete [] args;
     }
   return retval;
 }
 
 void
 tree_index_expression::eval_error (void)
 {
   if (error_state > 0)
@@ -2720,41 +2709,41 @@ tree_argument_list::next_elem (void)
 {
   return next;
 }
 
 /*
  * Convert a linked list of trees to a vector of pointers to trees,
  * evaluating them along the way.
  */
-tree_constant *
+Octave_object
 tree_argument_list::convert_to_const_vector (int& len)
 {
   len = length () + 1;
 
-  tree_constant *args = new tree_constant [len];
+  Octave_object args (len);
 
 // args[0] may eventually hold something useful, like the function
 // name.
   tree_argument_list *tmp_list = this;
   for (int k = 1; k < len; k++)
     {
       if (tmp_list != (tree_argument_list *) NULL)
 	{
-	  args[k] = tmp_list->eval (0);
+	  args(k) = tmp_list->eval (0);
 	  if (error_state)
 	    {
 	      ::error ("evaluating argument list element number %d", k);
 	      break;
 	    }
 	  tmp_list = tmp_list->next;
 	}
       else
 	{
-	  args[k] = tree_constant ();
+	  args(k) = tree_constant ();
 	  break;
 	}
     }
   return args;
 }
 
 tree_constant
 tree_argument_list::eval (int print)
@@ -2854,68 +2843,73 @@ tree_parameter_list::takes_varargs (void
 
 tree_identifier *
 tree_parameter_list::define (tree_constant *t)
 {
   return param->define (t);
 }
 
 void
-tree_parameter_list::define_from_arg_vector (const tree_constant *args,
+tree_parameter_list::define_from_arg_vector (const Octave_object& args,
 					     int nargin)
 {
-  if (args == NULL_TREE_CONST)
+  if (args.length () <= 0)
     return;
 
   int expected_nargin = length () + 1;
 
   tree_parameter_list *ptr = this;
 
   for (int i = 1; i < expected_nargin; i++)
     {
       tree_constant *tmp = NULL_TREE_CONST;
 
       if (i < nargin)
 	{
-	  if (args[i].is_defined ()
-	      && (args[i].const_type () == tree_constant_rep::magic_colon))
+	  if (args(i).is_defined ()
+	      && (args(i).const_type () == tree_constant_rep::magic_colon))
 	    {
 	      ::error ("invalid use of colon in function argument list");
 	      return;
 	    }
-	  tmp = new tree_constant (args[i]);
+	  tmp = new tree_constant (args(i));
 	}
 
       ptr->define (tmp);
       ptr = ptr->next;
     }
 }
 
-// XXX FIXME XXX -- need a way to prevent this from setting
-// error_state and printing an error message if the elements are not
-// defined.
-tree_constant *
+Octave_object
 tree_parameter_list::convert_to_const_vector (void)
 {
   int nout = length ();
 
-  tree_constant *retval = new tree_constant [nout+1];
+  Octave_object retval (nout);
 
   int i = 0;
 
   tree_parameter_list *elem = this;
 
-  for ( ; elem != (tree_parameter_list *) NULL;	elem = elem->next) 
-    retval[i++] = elem->eval (0);
-
-  retval [nout] = tree_constant ();
+  for ( ; elem != (tree_parameter_list *) NULL;	elem = elem->next)
+    {
+      if (elem->is_defined ())
+	retval(i) = elem->eval (0);
+      i++;
+    }
 
   return retval;
 }
 
+int
+tree_parameter_list::is_defined (void)
+{
+  return (param != (tree_identifier *) NULL && param->is_defined ());
+}
+
 tree_parameter_list *
 tree_parameter_list::next_elem (void)
 {
   return next;
 }
 
 tree_constant
 tree_parameter_list::eval (int print)
diff --git a/src/pt-exp-base.h b/src/pt-exp-base.h
--- a/src/pt-exp-base.h
+++ b/src/pt-exp-base.h
@@ -25,38 +25,28 @@ Software Foundation, 675 Mass Ave, Cambr
 #define octave_tree_expr_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <stdio.h>
 
+#include "Array.h"
+
 #include "builtins.h"
 #include "error.h"
+#include "oct-obj.h"
 
 class tree_constant;
 class symbol_record;
 class symbol_table;
 
-#ifndef TREE_FCN_TYPEDEFS
-#define TREE_FCN_TYPEDEFS 1
-
-typedef tree_constant* (*Text_fcn)(int, char **, int);
-typedef tree_constant* (*General_fcn)(const tree_constant *, int, int);
-
-#endif
-
-#ifndef NULL_TREE
-#define NULL_TREE (tree *) NULL
-#endif
-
-#ifndef NULL_TREE_CONST
-#define NULL_TREE_CONST (tree_constant *) NULL
-#endif
+typedef Octave_object (*Text_fcn)(int, char **, int);
+typedef Octave_object (*General_fcn)(const Octave_object&, int, int);
 
 class tree_matrix;
 class tree_builtin;
 class tree_identifier;
 class tree_function;
 class tree_expression;
 class tree_prefix_expression;
 class tree_postfix_expression;
@@ -94,20 +84,18 @@ public:
     { return 0; }
 
   virtual int is_prefix_expression (void) const
     { return 0; }
 
   virtual void mark_for_possible_ans_assign (void)
     { panic_impossible (); }
 
-  virtual tree_constant *eval (int print, int nargout,
-			       const tree_constant *args = NULL_TREE_CONST,
-			       int nargin = 0)
-    { panic_impossible (); return NULL_TREE_CONST; }
+  virtual Octave_object eval (int print, int nargout,
+			      const Octave_object& args, int nargin);
 
 protected:
   expression_type etype;
 };
 
 /*
  * General matrices.  This allows us to construct matrices from
  * other matrices, variables, and functions.
@@ -277,19 +265,18 @@ tree_multi_assignment_expression : publi
   tree_multi_assignment_expression (tree_return_list *lst,
 				    tree_expression *r,
 				    int l = -1, int c = -1);
 
   ~tree_multi_assignment_expression (void);
 
   tree_constant eval (int print);
 
-  tree_constant *eval (int print, int nargout,
-		       const tree_constant *args = NULL_TREE_CONST,
-		       int nargin = 0);
+  Octave_object eval (int print, int nargout, const Octave_object& args,
+		      int nargin);
 
   void eval_error (void);
 
  private:
   tree_return_list *lhs;
   tree_expression *rhs;
 };
 
@@ -337,19 +324,18 @@ tree_index_expression : public tree_expr
   tree_identifier *ident (void);
 
   tree_argument_list *arg_list (void);
 
   void mark_for_possible_ans_assign (void);
 
   tree_constant eval (int print);
 
-  tree_constant *eval (int print, int nargout,
-		       const tree_constant *args = NULL_TREE_CONST,
-		       int nargin = 0);
+  Octave_object eval (int print, int nargout, const Octave_object& args,
+		      int nargin);
 
   void eval_error (void);
 
  private:
   tree_identifier *id;
   tree_argument_list *list;
 };
 
@@ -361,17 +347,17 @@ tree_fvc : public tree_expression
 {
 public:
   virtual int is_constant (void) const
     { return 0; }
 
 //  virtual int is_builtin (void) const
 //    { return 0; }
 
-  virtual tree_constant assign (tree_constant& t, tree_constant *args,
+  virtual tree_constant assign (tree_constant& t, const Octave_object& args,
 				int nargs);
 
   virtual char *name (void) const
     { panic_impossible (); return (char *) NULL; }
 
   virtual void bump_value (tree::expression_type)
     { panic_impossible (); }
 
@@ -411,19 +397,18 @@ public:
 		const char *nm = (char *) NULL);
 
   ~tree_builtin (void);
 
 //  int is_builtin (void) const;
 
   tree_constant eval (int print);
 
-  tree_constant *eval (int print, int nargout,
-		       const tree_constant *args = NULL_TREE_CONST,
-		       int nargin = 0);
+  Octave_object eval (int print, int nargout, const Octave_object& args,
+		      int nargin);
 
   char *name (void) const;
 
   int max_expected_args (void);
 
 private:
   int nargin_max;
   int nargout_max;
@@ -453,35 +438,37 @@ public:
   void rename (const char *n);
 
   tree_identifier *define (tree_constant *t);
   tree_identifier *define (tree_function *t);
 
   void document (char *s);
 
   tree_constant assign (tree_constant& t);
-  tree_constant assign (tree_constant& t, tree_constant *args, int nargs);
+  tree_constant assign (tree_constant& t, const Octave_object& args,
+			int nargs);
+
+  int is_defined (void);
 
   void bump_value (tree::expression_type);
 
   int parse_fcn_file (int exec_script = 1);
   int parse_fcn_file (char *ff, int exec_script = 1);
   void parse_fcn_file (FILE *ffile, char *ff);
 
   tree_fvc *do_lookup (int& script_file_executed);
 
   void mark_as_formal_parameter (void);
 
   void mark_for_possible_ans_assign (void);
 
   tree_constant eval (int print);
 
-  tree_constant *eval (int print, int nargout,
-		       const tree_constant *args = NULL_TREE_CONST,
-		       int nargin = 0);
+  Octave_object eval (int print, int nargout, const Octave_object& args,
+		      int nargin);
 
   void eval_undefined_error (void);
 
 private:
   symbol_record *sym;
   int maybe_do_ans_assign;
 };
 
@@ -514,19 +501,18 @@ public:
   void octave_va_start (void);
   tree_constant octave_va_arg (void);
 
   void stash_function_name (char *s);
   char *function_name (void);
 
   tree_constant eval (int print);
 
-  tree_constant *eval (int print, int nargout,
-		       const tree_constant *args = NULL_TREE_CONST,
-		       int nargin = 0);
+  Octave_object eval (int print, int nargout, const Octave_object& args,
+		      int nargin);
 
   int max_expected_args (void);
 
   void traceback_error (void);
 
 private:
   int call_depth;
   tree_parameter_list *param_list;
@@ -534,17 +520,17 @@ private:
   symbol_table *sym_tab;
   tree *cmd_list;
   char *file_name;
   char *fcn_name;
   time_t t_parsed;
   int system_fcn_file;
   int varargs_ok;
   int num_named_args;
-  const tree_constant *args_passed;
+  Octave_object args_passed;
   int num_args_passed;
   int curr_arg_number;
 };
 
 /*
  * Argument lists.
  */
 class
@@ -557,17 +543,17 @@ tree_argument_list : public tree
   ~tree_argument_list (void);
 
   tree_argument_list *chain (tree *t);
   tree_argument_list *reverse (void);
   int length (void);
 
   tree_argument_list *next_elem (void);
 
-  tree_constant *convert_to_const_vector (int& nargs);
+  Octave_object convert_to_const_vector (int& nargs);
 
   tree_constant eval (int print);
 
  private:
   tree *arg;
   tree_argument_list *next;
 };
 
@@ -593,19 +579,21 @@ tree_parameter_list : public tree
 
   void mark_as_formal_parameters (void);
 
   void mark_varargs (void);
   int takes_varargs (void) const;
 
   tree_identifier *define (tree_constant *t);
 
-  void define_from_arg_vector (const tree_constant *args, int nargin);
+  void define_from_arg_vector (const Octave_object& args, int nargin);
 
-  tree_constant *convert_to_const_vector (void);
+  int is_defined (void);
+
+  Octave_object convert_to_const_vector (void);
 
   tree_parameter_list *next_elem (void);
 
   tree_constant eval (int print);
 
  private:
   int marked_for_varargs;
   tree_identifier *param;
diff --git a/src/tc-inlines.h b/src/tc-inlines.h
--- a/src/tc-inlines.h
+++ b/src/tc-inlines.h
@@ -1,12 +1,12 @@
 // tc-inlines.cc                                          -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993 John W. Eaton
+Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -135,22 +135,22 @@ fortran_column (int i, int nr)
   int c;
   int r;
   r = fortran_row (i, nr);
   c = (i - r) / nr + 1;
   return c;
 }
 
 static inline int
-valid_scalar_indices (const tree_constant *args, int nargs)
+valid_scalar_indices (const Octave_object& args, int nargs)
 {
-  int valid = args != NULL_TREE_CONST
-    && ((nargs == 3 && args[2].valid_as_scalar_index ()
-	 && args[1].valid_as_scalar_index ())
-	|| (nargs == 2 && args[1].valid_as_scalar_index ()));
+  int valid = (args.length () > 0)
+    && ((nargs == 3 && args(2).valid_as_scalar_index ()
+	 && args(1).valid_as_scalar_index ())
+	|| (nargs == 2 && args(1).valid_as_scalar_index ()));
 
   return valid;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/tc-rep.cc b/src/tc-rep.cc
--- a/src/tc-rep.cc
+++ b/src/tc-rep.cc
@@ -1310,17 +1310,17 @@ tree_constant_rep::print (void)
 	}
 
       output_buf << ends;
       maybe_page_output (output_buf);
     }
 }
 
 tree_constant
-tree_constant_rep::do_index (const tree_constant *args, int nargin)
+tree_constant_rep::do_index (const Octave_object& args, int nargin)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (rows () == 0 || columns () == 0)
     {
@@ -2650,17 +2650,18 @@ tree_constant_rep::mapper (Mapper_fcn& m
 }
 
 /*
  * Top-level tree-constant function that handles assignments.  Only
  * decide if the left-hand side is currently a scalar or a matrix and
  * hand off to other functions to do the real work.
  */
 void
-tree_constant_rep::assign (tree_constant& rhs, tree_constant *args, int nargs)
+tree_constant_rep::assign (tree_constant& rhs,
+			   const Octave_object& args, int nargs)
 {
   tree_constant rhs_tmp = rhs.make_numeric ();
 
 // This is easier than actually handling assignments to strings.
 // An assignment to a range will normally require a conversion to a
 // vector since it will normally destroy the equally-spaced property
 // of the range elements.
 
@@ -2690,17 +2691,17 @@ tree_constant_rep::assign (tree_constant
 }
 
 /*
  * Assignments to scalars.  If resize_on_range_error is true,
  * this can convert the left-hand side to a matrix.
  */
 void
 tree_constant_rep::do_scalar_assignment (tree_constant& rhs,
-					 tree_constant *args, int nargs)
+					 const Octave_object& args, int nargs)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == scalar_constant
 	  || type_tag == complex_scalar_constant);
 
   if ((rhs.is_scalar_type () || rhs.is_zero_by_zero ())
       && valid_scalar_indices (args, nargs))
     {
@@ -2795,17 +2796,17 @@ tree_constant_rep::do_scalar_assignment 
 /*
  * Assignments to matrices (and vectors).
  *
  * For compatibility with Matlab, we allow assignment of an empty
  * matrix to an expression with empty indices to do nothing.
  */
 void
 tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
-					 tree_constant *args, int nargs)
+					 const Octave_object& args, int nargs)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == matrix_constant
 	  || type_tag == complex_matrix_constant);
 
   if (type_tag == matrix_constant && rhs.is_complex_type ())
     {
       Matrix *old_matrix = matrix;
@@ -2827,43 +2828,43 @@ tree_constant_rep::do_matrix_assignment 
 	}
     }
 
 // The do_matrix_assignment functions can't handle empty matrices, so
 // don't let any pass through here.
   switch (nargs)
     {
     case 2:
-      if (! args)
+      if (args.length () <= 0)
 	::error ("matrix index is null");
-      else if (args[1].is_undefined ())
+      else if (args(1).is_undefined ())
 	::error ("matrix index is undefined");
       else
-	do_matrix_assignment (rhs, args[1]);
+	do_matrix_assignment (rhs, args(1));
       break;
     case 3:
-      if (! args)
+      if (args.length () <= 0)
 	::error ("matrix indices are null");
-      else if (args[1].is_undefined ())
+      else if (args(1).is_undefined ())
 	::error ("first matrix index is undefined");
-      else if (args[2].is_undefined ())
+      else if (args(2).is_undefined ())
 	::error ("second matrix index is undefined");
-      else if (args[1].is_empty () || args[2].is_empty ())
+      else if (args(1).is_empty () || args(2).is_empty ())
 	{
 	  if (! rhs.is_empty ())
 	    {
 	      ::error ("in assignment expression, a matrix index is empty");
 	      ::error ("but hte right hand side is not an empty matrix");
 	    }
 // XXX FIXME XXX -- to really be correct here, we should probably
 // check to see if the assignment conforms, but that seems like more
 // work than it's worth right now...
 	}
       else
-	do_matrix_assignment (rhs, args[1], args[2]);
+	do_matrix_assignment (rhs, args(1), args(2));
       break;
     default:
       ::error ("too many indices for matrix expression");
       break;
     }
 }
 
 /*
@@ -4994,17 +4995,17 @@ tree_constant_rep::valid_as_scalar_index
     || (type_tag == scalar_constant && NINT (scalar) == 1)
     || (type_tag == range_constant
 	&& range->nelem () == 1 && NINT (range->base ()) == 1);
 
   return valid;
 }
 
 tree_constant
-tree_constant_rep::do_scalar_index (const tree_constant *args,
+tree_constant_rep::do_scalar_index (const Octave_object& args,
 				    int nargs) const
 {
   if (valid_scalar_indices (args, nargs))
     {
       if (type_tag == scalar_constant)
 	return tree_constant (scalar);
       else if (type_tag == complex_scalar_constant)
 	return tree_constant (*complex_scalar);
@@ -5015,60 +5016,60 @@ tree_constant_rep::do_scalar_index (cons
     {
       int rows = 0;
       int cols = 0;
 
       switch (nargs)
 	{
 	case 3:
 	  {
-	    if (args[2].is_matrix_type ())
+	    if (args(2).is_matrix_type ())
 	      {
-		Matrix mj = args[2].matrix_value ();
+		Matrix mj = args(2).matrix_value ();
 
 		idx_vector j (mj, user_pref.do_fortran_indexing, "");
 		if (! j)
 		  return tree_constant ();
 
 		int len = j.length ();
 		if (len == j.ones_count ())
 		  cols = len;
 	      }
-	    else if (args[2].const_type () == magic_colon
-		     || (args[2].is_scalar_type ()
-			 && NINT (args[2].double_value ()) == 1))
+	    else if (args(2).const_type () == magic_colon
+		     || (args(2).is_scalar_type ()
+			 && NINT (args(2).double_value ()) == 1))
 	      {
 		cols = 1;
 	      }
 	    else
 	      break;
 	  }
 // Fall through...
 	case 2:
 	  {
-	    if (args[1].is_matrix_type ())
+	    if (args(1).is_matrix_type ())
 	      {
-		Matrix mi = args[1].matrix_value ();
+		Matrix mi = args(1).matrix_value ();
 
 		idx_vector i (mi, user_pref.do_fortran_indexing, "");
 		if (! i)
 		  return tree_constant ();
 
 		int len = i.length ();
 		if (len == i.ones_count ())
 		  rows = len;
 	      }
-	    else if (args[1].const_type () == magic_colon
-		     || (args[1].is_scalar_type ()
-			 && NINT (args[1].double_value ()) == 1))
+	    else if (args(1).const_type () == magic_colon
+		     || (args(1).is_scalar_type ()
+			 && NINT (args(1).double_value ()) == 1))
 	      {
 		rows = 1;
 	      }
-	    else if (args[1].is_scalar_type ()
-		     && NINT (args[1].double_value ()) == 0)
+	    else if (args(1).is_scalar_type ()
+		     && NINT (args(1).double_value ()) == 0)
 	      {
 		Matrix m (0, 0);
 		return tree_constant (m);
 	      }
 	    else
 	      break;
 
 	    if (cols == 0)
@@ -5103,40 +5104,40 @@ tree_constant_rep::do_scalar_index (cons
 	}
     }
 
   ::error ("index invalid or out of range for scalar type");
   return tree_constant ();
 }
 
 tree_constant
-tree_constant_rep::do_matrix_index (const tree_constant *args,
+tree_constant_rep::do_matrix_index (const Octave_object& args,
 				    int nargin) const
 {
   tree_constant retval;
 
   switch (nargin)
     {
     case 2:
-      if (! args)
+      if (args.length () <= 0)
 	::error ("matrix index is null");
-      else if (args[1].is_undefined ())
+      else if (args(1).is_undefined ())
 	::error ("matrix index is a null expression");
       else
-	retval = do_matrix_index (args[1]);
+	retval = do_matrix_index (args(1));
       break;
     case 3:
-      if (! args)
+      if (args.length () <= 0)
 	::error ("matrix indices are null");
-      else if (args[1].is_undefined ())
+      else if (args(1).is_undefined ())
 	::error ("first matrix index is a null expression");
-      else if (args[2].is_undefined ())
+      else if (args(2).is_undefined ())
 	::error ("second matrix index is a null expression");
       else
-	retval = do_matrix_index (args[1], args[2]);
+	retval = do_matrix_index (args(1), args(2));
       break;
     default:
       ::error ("too many indices for matrix expression");
       break;
     }
 
   return  retval;
 }
diff --git a/src/tc-rep.h b/src/tc-rep.h
--- a/src/tc-rep.h
+++ b/src/tc-rep.h
@@ -151,23 +151,23 @@ public:
 
   double to_scalar (void) const;
   ColumnVector to_vector (void) const;
   Matrix to_matrix (void) const;
 
   tree_constant_rep::constant_type force_numeric (int force_str_conv = 0);
   tree_constant make_numeric (int force_str_conv = 0) const;
 
-  void assign (tree_constant& rhs, tree_constant *args, int nargs);
+  void assign (tree_constant& rhs, const Octave_object& args, int nargs);
 
   void do_scalar_assignment
-    (tree_constant& rhs, tree_constant *args, int nargin);
+    (tree_constant& rhs, const Octave_object& args, int nargin);
 
   void do_matrix_assignment
-    (tree_constant& rhs, tree_constant *args, int nargin);
+    (tree_constant& rhs, const Octave_object& args, int nargin);
 
   void do_matrix_assignment
     (tree_constant& rhs, tree_constant& i_arg);
 
   void do_matrix_assignment
     (tree_constant& rhs, tree_constant& i_arg, tree_constant& j_arg);
 
   void fortran_style_matrix_assignment (tree_constant& rhs,
@@ -227,22 +227,21 @@ public:
   void delete_columns (idx_vector& j);
   void delete_columns (Range& j);
 
   void bump_value (tree::expression_type);
 
   void maybe_mutate (void);
   void print (void);
 
-  tree_constant do_index (const tree_constant *args, int nargin);
+  tree_constant do_index (const Octave_object& args, int nargin);
 
-  tree_constant do_scalar_index (const tree_constant *args,
-				 int nargin) const;
+  tree_constant do_scalar_index (const Octave_object& args, int nargin) const;
 
-  tree_constant do_matrix_index (const tree_constant *args, int nargin) const;
+  tree_constant do_matrix_index (const Octave_object& args, int nargin) const;
 
   tree_constant do_matrix_index (const tree_constant& i_arg) const;
 
   tree_constant do_matrix_index (const tree_constant& i_arg,
 				 const tree_constant& j_arg) const; 
 
   tree_constant do_matrix_index (constant_type i) const;
 
