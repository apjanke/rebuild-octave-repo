# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1380829969 14400
#      Thu Oct 03 15:52:49 2013 -0400
# Node ID 0946b0e06544478fc8706bea576d05e00c64a653
# Parent  f0d21e7d4653a0837566018c32e2be45898b637a
move url_transfer classes to liboctave

* liboctave/util/url-transfer.h, liboctave/util/url-transfer.cc:
New files, extracted from libinterp/dldfcn/urlwrite.cc.
* libinterp/corefcn/urlwrite.cc: Move here from
libinterp/dldfcn/urlwrite.cc.
* libinterp/corefcn/module.mk, libinterp/dldfcn/module-files,
liboctave/link-deps.mk liboctave/util/module.mk: Update for new and
renamed files.

diff --git a/libinterp/corefcn/module.mk b/libinterp/corefcn/module.mk
--- a/libinterp/corefcn/module.mk
+++ b/libinterp/corefcn/module.mk
@@ -249,16 +249,17 @@ COREFCN_SRC = \
   corefcn/syscalls.cc \
   corefcn/sysdep.cc \
   corefcn/time.cc \
   corefcn/toplev.cc \
   corefcn/tril.cc \
   corefcn/txt-eng.cc \
   corefcn/txt-eng-ft.cc \
   corefcn/typecast.cc \
+  corefcn/urlwrite.cc \
   corefcn/utils.cc \
   corefcn/variables.cc \
   corefcn/xdiv.cc \
   corefcn/xnorm.cc \
   corefcn/xpow.cc \
   corefcn/zfstream.cc \
   $(JIT_SRC) \
   $(C_COREFCN_SRC)
diff --git a/libinterp/dldfcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
rename from libinterp/dldfcn/urlwrite.cc
rename to libinterp/corefcn/urlwrite.cc
--- a/libinterp/dldfcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -36,973 +36,33 @@ along with Octave; see the file COPYING.
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-handle.h"
 #include "glob-match.h"
 #include "singleton-cleanup.h"
+#include "url-transfer.h"
 
-#include "defun-dld.h"
+#include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "oct-map.h"
 #include "oct-refcount.h"
 #include "unwind-prot.h"
 
 static void
 delete_file (const std::string& file)
 {
   octave_unlink (file);
 }
 
-class base_url_transfer
-{
-private:
-
-  static void reset_path (const base_url_transfer *curl_xfer)
-  {
-    curl_xfer->cwd ("..");
-  }
-
-public:
-
-  friend class url_transfer;
-
-  base_url_transfer (void)
-    : count (1), host (), userpwd (), valid (false), ascii_mode (false),
-      ok (true), errmsg () { }
-
-  base_url_transfer (const std::string& host_arg,
-                     const std::string& /* user_arg */,
-                     const std::string& /* passwd */)
-    : count (1), host (host_arg), userpwd (), valid (false),
-      ascii_mode (false), ok (true), errmsg () { }
-
-  base_url_transfer (const std::string& /* url */,
-                     const std::string& /* method */,
-                     const Array<std::string>& /* param */,
-                     std::ostream& /* os */)
-    : count (1), host (), userpwd (), valid (false), ascii_mode (false),
-      ok (true), errmsg () { }
-
-  virtual ~base_url_transfer (void) { }
-
-  bool is_valid (void) const { return valid; }
-
-  bool good (void) const { return valid && ok; }
-
-  virtual void perform (void) const { }
-
-  virtual std::string lasterror (void) const { return errmsg; }
-
-  virtual void set_ostream (std::ostream& /* os */) const { }
-
-  virtual void set_istream (std::istream& /* is */) const { }
-
-  virtual void ascii (void) { }
-
-  virtual void binary (void) { }
-
-  bool is_ascii (void) const { return ascii_mode; }
-
-  bool is_binary (void) const { return !ascii_mode; }
-
-  virtual void cwd (const std::string& /* path */) const { } 
-
-  virtual void del (const std::string& /* file */) const { }
-
-  virtual void rmdir (const std::string& /* path */) const { }
-
-  virtual void mkdir (const std::string& /* path */) const { }
-
-  virtual void rename (const std::string& /* oldname */,
-                       const std::string& /* newname */) const { }
-
-  virtual void put (const std::string& /* file */,
-                    std::istream& /* is */) const { }
-
-  virtual void get (const std::string& /* file */,
-                    std::ostream& /* os */) const { }
-
-  void mget_directory (const std::string& directory,
-                       const std::string& target) const
-  {
-    std::string sep = file_ops::dir_sep_str ();
-    file_stat fs (directory);
-
-    if (!fs || !fs.is_dir ())
-      {
-        std::string msg;
-        int status = octave_mkdir (directory, 0777, msg);
-
-        if (status < 0)
-          {
-            ok = false;
-            errmsg = "__ftp_mget__: can not create directory '"
-              + target + sep + directory + "': " + msg;
-            return;
-          }
-      }
-
-    cwd (directory);
-
-    if (good ())
-      {
-        unwind_protect_safe frame;
-
-        frame.add_fcn (reset_path, this);
-
-        string_vector sv = list ();
-
-        for (octave_idx_type i = 0; i < sv.length (); i++)
-          {
-            time_t ftime;
-            bool fisdir;
-            double fsize;
-
-            get_fileinfo (sv(i), fsize, ftime, fisdir);
-
-            if (fisdir)
-              mget_directory (sv(i), target + directory + sep);
-            else
-              {
-                std::string realfile = target + directory + sep + sv(i);
-
-                std::ofstream ofile (realfile.c_str (),
-                                     std::ios::out | std::ios::binary);
-
-                if (! ofile.is_open ())
-                  {
-                    ok = false;
-                    errmsg = "__ftp_mget__: unable to open file";
-                    break;
-                  }
-
-                unwind_protect_safe frame2;
-
-                frame2.add_fcn (delete_file, realfile);
-
-                get (sv(i), ofile);
-
-                ofile.close ();
-
-                if (good ())
-                  frame2.discard ();
-              }
-
-            if (! good ())
-              break;
-          }
-      }
-  }
-
-  string_vector mput_directory (const std::string& base,
-                                const std::string& directory) const
-  {
-    string_vector file_list;
-
-    std::string realdir
-      = (base.length () == 0
-         ? directory : base + file_ops::dir_sep_str () + directory);
-
-    mkdir (directory);
-
-    if (! good ())
-      return file_list;
-
-    cwd (directory);
-
-    if (good ())
-      {
-        unwind_protect_safe frame;
-
-        frame.add_fcn (reset_path, this);
-
-        dir_entry dirlist (realdir);
-
-        if (dirlist)
-          {
-            string_vector files = dirlist.read ();
-
-            for (octave_idx_type i = 0; i < files.length (); i++)
-              {
-                std::string file = files (i);
-
-                if (file == "." || file == "..")
-                  continue;
-
-                std::string realfile = realdir + file_ops::dir_sep_str () + file;
-                file_stat fs (realfile);
-
-                if (! fs.exists ())
-                  {
-                    ok = false;
-                    errmsg = "__ftp__mput: file '" + realfile
-                      + "' does not exist";
-                    break;
-                  }
-
-                if (fs.is_dir ())
-                  {
-                    file_list.append (mput_directory (realdir, file));
-
-                    if (! good ())
-                      break;
-                  }
-                else
-                  {
-                    // FIXME Does ascii mode need to be flagged here?
-                    std::ifstream ifile (realfile.c_str (), std::ios::in |
-                                         std::ios::binary);
-
-                    if (! ifile.is_open ())
-                      {
-                        ok = false;
-                        errmsg = "__ftp_mput__: unable to open file '"
-                          + realfile + "'";
-                        break;
-                      }
-
-                    put (file, ifile);
-
-                    ifile.close ();
-
-                    if (! good ())
-                      break;
-
-                    file_list.append (realfile);
-                  }
-              }
-          }
-        else
-          {
-            ok = false;
-            errmsg = "__ftp_mput__: can not read the directory '"
-              + realdir + "'";
-          }
-      }
-  }
-
-  virtual void dir (void) const { }
-
-  virtual string_vector list (void) const { return string_vector (); }
-
-  virtual void get_fileinfo (const std::string& /* filename */,
-                             double& /* filesize */,
-                             time_t& /* filetime */,
-                             bool& /* fileisdir */) const { }
-
-  virtual std::string pwd (void) const { return std::string (); }
-
-protected:
-
-  octave_refcount<size_t> count;
-  std::string host;
-  std::string userpwd;
-  bool valid;
-  bool ascii_mode;
-  mutable bool ok;
-  mutable std::string errmsg;
-
-private:
-
-  // No copying!
-
-  base_url_transfer (const base_url_transfer&);
-
-  base_url_transfer& operator = (const base_url_transfer&);
-};
-
-#ifdef HAVE_CURL
-
-#include <curl/curl.h>
-#include <curl/curlver.h>
-#include <curl/easy.h>
-
-static int
-write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
-{
-  std::ostream& stream = *(static_cast<std::ostream*> (streamp));
-  stream.write (static_cast<const char*> (buffer), size*nmemb);
-  return (stream.fail () ? 0 : size * nmemb);
-}
-
-static int
-read_data (void *buffer, size_t size, size_t nmemb, void *streamp)
-{
-  std::istream& stream = *(static_cast<std::istream*> (streamp));
-  stream.read (static_cast<char*> (buffer), size*nmemb);
-  if (stream.eof ())
-    return stream.gcount ();
-  else
-    return (stream.fail () ? 0 : size * nmemb);
-}
-
-static size_t
-throw_away (void *, size_t size, size_t nmemb, void *)
-{
-  return static_cast<size_t>(size * nmemb);
-}
-
-// I'd love to rewrite this as a private method of the url_transfer
-// class, but you can't pass the va_list from the wrapper SETOPT to
-// the curl_easy_setopt function.
-#define SETOPT(option, parameter) \
-  do \
-    { \
-      CURLcode res = curl_easy_setopt (curl, option, parameter); \
-      if (res != CURLE_OK) \
-        { \
-          ok = false; \
-          errmsg = curl_easy_strerror (res); \
-          return; \
-        } \
-    } \
-  while (0)
-
-// Same as above but with a return value.
-#define SETOPTR(option, parameter) \
-  do \
-    { \
-      CURLcode res = curl_easy_setopt (curl, option, parameter); \
-      if (res != CURLE_OK) \
-        { \
-          ok = false; \
-          errmsg = curl_easy_strerror (res); \
-          return retval; \
-        } \
-    } \
-  while (0)
-
-class curl_transfer : public base_url_transfer
-{
-public:
-
-  curl_transfer (void)
-    : base_url_transfer (), curl (curl_easy_init ()), errnum ()
-  {
-    if (curl)
-      valid = true;
-    else
-      errmsg = "can not create curl object";
-  }
-
-  curl_transfer (const std::string& host_arg, const std::string& user_arg,
-                 const std::string& passwd)
-    : base_url_transfer (host_arg, user_arg, passwd),
-      curl (curl_easy_init ()), errnum ()
-  {
-    if (curl)
-      valid = true;
-    else
-      {
-        errmsg = "can not create curl object";
-        return;
-      }
-
-    init (user_arg, passwd, std::cin, octave_stdout);
-
-    std::string url ("ftp://" + host_arg);
-    SETOPT (CURLOPT_URL, url.c_str ());
-
-    // Setup the link, with no transfer.
-    perform ();
-  }
-
-  curl_transfer (const std::string& url, const std::string& method,
-                 const Array<std::string>& param, std::ostream& os)
-    : base_url_transfer (url, method, param, os),
-      curl (curl_easy_init ()), errnum ()
-  {
-    if (curl)
-      valid = true;
-    else
-      {
-        errmsg = "can not create curl object";
-        return;
-      }
-
-    init ("", "", std::cin, os);
-
-    SETOPT (CURLOPT_NOBODY, 0);
-
-    // Restore the default HTTP request method to GET after setting
-    // NOBODY to true and back to false.  This is needed for backward
-    // compatibility with versions of libcurl < 7.18.2.
-    SETOPT (CURLOPT_HTTPGET, 1);
-
-    // Don't need to store the parameters here as we can't change
-    // the URL after the object is created
-    std::string query_string = form_query_string (param);
-
-    if (method == "get")
-      {
-        query_string = url + "?" + query_string;
-        SETOPT (CURLOPT_URL, query_string.c_str ());
-      }
-    else if (method == "post")
-      {
-        SETOPT (CURLOPT_URL, url.c_str ());
-        SETOPT (CURLOPT_POSTFIELDS, query_string.c_str ());
-      }
-    else
-      SETOPT (CURLOPT_URL, url.c_str ());
-
-    perform ();
-  }
-
-  ~curl_transfer (void)
-  {
-    if (curl)
-      curl_easy_cleanup (curl);
-  }
-
-  void perform (void) const
-  {
-    BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-
-    errnum = curl_easy_perform (curl);
-
-    if (errnum != CURLE_OK)
-      {
-        ok = false;
-        errmsg = curl_easy_strerror (errnum);
-      }
-
-    END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-  }
-
-  std::string lasterror (void) const
-  {
-    return std::string (curl_easy_strerror (errnum));
-  }
-
-  void set_ostream (std::ostream& os) const
-  {
-    SETOPT (CURLOPT_WRITEDATA, static_cast<void*> (&os));
-  }
-
-  void set_istream (std::istream& is) const
-  {
-    SETOPT (CURLOPT_READDATA, static_cast<void*> (&is));
-  }
-
-  void ascii (void)
-  {
-    ascii_mode = true;
-    SETOPT (CURLOPT_TRANSFERTEXT, 1);
-  }
-
-  void binary (void)
-  {
-    ascii_mode = false;
-    SETOPT (CURLOPT_TRANSFERTEXT, 0);
-  }
-
-  void cwd (const std::string& path) const
-  {
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    std::string cmd = "cwd " + path;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    SETOPT (CURLOPT_POSTQUOTE, slist);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
-  }
-
-  void del (const std::string& file) const
-  {
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    std::string cmd = "dele " + file;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    SETOPT (CURLOPT_POSTQUOTE, slist);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
-  }
-
-  void rmdir (const std::string& path) const
-  {
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    std::string cmd = "rmd " + path;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    SETOPT (CURLOPT_POSTQUOTE, slist);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
-  }
-
-  void mkdir (const std::string& path) const
-  {
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    std::string cmd = "mkd " + path;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    SETOPT (CURLOPT_POSTQUOTE, slist);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
-  }
-
-  void rename (const std::string& oldname, const std::string& newname) const
-  {
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    std::string cmd = "rnfr " + oldname;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    cmd = "rnto " + newname;
-    slist = curl_slist_append (slist, cmd.c_str ());
-    SETOPT (CURLOPT_POSTQUOTE, slist);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
-  }
-
-  void put (const std::string& file, std::istream& is) const
-  {
-    std::string url = "ftp://" + host + "/" + file;
-    SETOPT (CURLOPT_URL, url.c_str ());
-    SETOPT (CURLOPT_UPLOAD, 1);
-    SETOPT (CURLOPT_NOBODY, 0);
-    set_istream (is);
-
-    perform ();
-    if (! good ())
-      return;
-
-    set_istream (std::cin);
-    SETOPT (CURLOPT_NOBODY, 1);
-    SETOPT (CURLOPT_UPLOAD, 0);
-    url = "ftp://" + host;
-    SETOPT (CURLOPT_URL, url.c_str ());
-  }
-
-  void get (const std::string& file, std::ostream& os) const
-  {
-    std::string url = "ftp://" + host + "/" + file;
-    SETOPT (CURLOPT_URL, url.c_str ());
-    SETOPT (CURLOPT_NOBODY, 0);
-    set_ostream (os);
-
-    perform ();
-    if (! good ())
-      return;
-
-    set_ostream (octave_stdout);
-    SETOPT (CURLOPT_NOBODY, 1);
-    url = "ftp://" + host;
-    SETOPT (CURLOPT_URL, url.c_str ());
-  }
-
-  void dir (void) const
-  {
-    std::string url = "ftp://" + host + "/";
-    SETOPT (CURLOPT_URL, url.c_str ());
-    SETOPT (CURLOPT_NOBODY, 0);
-
-    perform ();
-    if (! good ())
-      return;
-
-    SETOPT (CURLOPT_NOBODY, 1);
-    url = "ftp://" + host;
-    SETOPT (CURLOPT_URL, url.c_str ());
-  }
-
-  string_vector list (void) const
-  {
-    string_vector retval;
-
-    std::ostringstream buf;
-    std::string url = "ftp://" + host + "/";
-    SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
-    SETOPTR (CURLOPT_URL, url.c_str ());
-    SETOPTR (CURLOPT_DIRLISTONLY, 1);
-    SETOPTR (CURLOPT_NOBODY, 0);
-
-    perform ();
-    if (! good ())
-      return retval;
-
-    SETOPTR (CURLOPT_NOBODY, 1);
-    url = "ftp://" + host;
-    SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (&octave_stdout));
-    SETOPTR (CURLOPT_DIRLISTONLY, 0);
-    SETOPTR (CURLOPT_URL, url.c_str ());
-
-    // Count number of directory entries
-    std::string str = buf.str ();
-    octave_idx_type n = 0;
-    size_t pos = 0;
-    while (true)
-      {
-        pos = str.find_first_of ('\n', pos);
-        if (pos == std::string::npos)
-          break;
-        pos++;
-        n++;
-      }
-    retval.resize (n);
-    pos = 0;
-    for (octave_idx_type i = 0; i < n; i++)
-      {
-        size_t newpos = str.find_first_of ('\n', pos);
-        if (newpos == std::string::npos)
-          break;
-
-        retval(i) = str.substr(pos, newpos - pos);
-        pos = newpos + 1;
-      }
-
-    return retval;
-  }
-
-  void get_fileinfo (const std::string& filename, double& filesize,
-                     time_t& filetime, bool& fileisdir) const
-  {
-    std::string path = pwd ();
-
-    std::string url = "ftp://" + host + "/" + path + "/" + filename;
-    SETOPT (CURLOPT_URL, url.c_str ());
-    SETOPT (CURLOPT_FILETIME, 1);
-    SETOPT (CURLOPT_HEADERFUNCTION, throw_away);
-    SETOPT (CURLOPT_WRITEFUNCTION, throw_away);
-
-    // FIXME
-    // The MDTM command fails for a directory on the servers I tested
-    // so this is a means of testing for directories. It also means
-    // I can't get the date of directories!
-
-    perform ();
-    if (! good ())
-      {
-        fileisdir = true;
-        filetime = -1;
-        filesize = 0;
-
-        return;
-      }
-
-    fileisdir = false;
-    time_t ft;
-    curl_easy_getinfo (curl, CURLINFO_FILETIME, &ft);
-    filetime = ft;
-    double fs;
-    curl_easy_getinfo (curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
-    filesize = fs;
-
-    SETOPT (CURLOPT_WRITEFUNCTION, write_data);
-    SETOPT (CURLOPT_HEADERFUNCTION, 0);
-    SETOPT (CURLOPT_FILETIME, 0);
-    url = "ftp://" + host;
-    SETOPT (CURLOPT_URL, url.c_str ());
-
-    // The MDTM command seems to reset the path to the root with the
-    // servers I tested with, so cd again into the correct path. Make
-    // the path absolute so that this will work even with servers that
-    // don't end up in the root after an MDTM command.
-    cwd ("/" + path);
-  }
-
-  std::string pwd (void) const
-  {
-    std::string retval;
-
-    struct curl_slist *slist = 0;
-
-    unwind_protect frame;
-    frame.add_fcn (curl_slist_free_all, slist);
-
-    slist = curl_slist_append (slist, "pwd");
-    SETOPTR (CURLOPT_POSTQUOTE, slist);
-    SETOPTR (CURLOPT_HEADERFUNCTION, write_data);
-
-    std::ostringstream buf;
-    SETOPTR (CURLOPT_WRITEHEADER, static_cast<void *>(&buf));
-
-    perform ();
-    if (! good ())
-      return retval;
-
-    retval = buf.str ();
-
-    // Can I assume that the path is alway in "" on the last line
-    size_t pos2 = retval.rfind ('"');
-    size_t pos1 = retval.rfind ('"', pos2 - 1);
-    retval = retval.substr (pos1 + 1, pos2 - pos1 - 1);
-
-    SETOPTR (CURLOPT_HEADERFUNCTION, 0);
-    SETOPTR (CURLOPT_WRITEHEADER, 0);
-    SETOPTR (CURLOPT_POSTQUOTE, 0);
-
-    return retval;
-  }
-
-private:
-
-  CURL *curl;
-  mutable CURLcode errnum;
-
-  // No copying!
-
-  curl_transfer (const curl_transfer&);
-
-  curl_transfer& operator = (const curl_transfer&);
-
-  void init (const std::string& user, const std::string& passwd,
-             std::istream& is, std::ostream& os)
-  {
-    // No data transfer by default
-    SETOPT (CURLOPT_NOBODY, 1);
-
-    // Set the username and password
-    userpwd = user;
-    if (! passwd.empty ())
-      userpwd += ":" + passwd;
-    if (! userpwd.empty ())
-      SETOPT (CURLOPT_USERPWD, userpwd.c_str ());
-
-    // Define our callback to get called when there's data to be written.
-    SETOPT (CURLOPT_WRITEFUNCTION, write_data);
-
-    // Set a pointer to our struct to pass to the callback.
-    SETOPT (CURLOPT_WRITEDATA, static_cast<void*> (&os));
-
-    // Define our callback to get called when there's data to be read
-    SETOPT (CURLOPT_READFUNCTION, read_data);
-
-    // Set a pointer to our struct to pass to the callback.
-    SETOPT (CURLOPT_READDATA, static_cast<void*> (&is));
-
-    // Follow redirects.
-    SETOPT (CURLOPT_FOLLOWLOCATION, true);
-
-    // Don't use EPSV since connecting to sites that don't support it
-    // will hang for some time (3 minutes?) before moving on to try PASV
-    // instead.
-    SETOPT (CURLOPT_FTP_USE_EPSV, false);
-
-    SETOPT (CURLOPT_NOPROGRESS, true);
-    SETOPT (CURLOPT_FAILONERROR, true);
-
-    SETOPT (CURLOPT_POSTQUOTE, 0);
-    SETOPT (CURLOPT_QUOTE, 0);
-  }
-
-  std::string form_query_string (const Array<std::string>& param)
-  {
-    std::ostringstream query;
-
-    for (int i = 0; i < param.numel (); i += 2)
-      {
-        std::string name = param(i);
-        std::string text = param(i+1);
-
-        // Encode strings.
-        char *enc_name = curl_easy_escape (curl, name.c_str (),
-                                           name.length ());
-        char *enc_text = curl_easy_escape (curl, text.c_str (),
-                                           text.length ());
-
-        query << enc_name << "=" << enc_text;
-
-        curl_free (enc_name);
-        curl_free (enc_text);
-
-        if (i < param.numel ()-1)
-          query << "&";
-      }
-
-    query.flush ();
-
-    return query.str ();
-  }
-};
-
-#undef SETOPT
-
-#endif
-
-#if ! defined (HAVE_CURL)
-static void
-disabled_error (void)
-{
-  error ("support for url transfers was disabled when Octave was built");
-}
-#endif
-
-class url_transfer
-{
-public:
-
-#if defined (HAVE_CURL)
-# define REP_CLASS curl_transfer
-#else
-# define REP_CLASS base_url_transfer
-#endif
-
-  url_transfer (void) : rep (new REP_CLASS ())
-  {
-#if !defined (HAVE_CURL)
-    disabled_error ();
-#endif
-  }
-
-  url_transfer (const std::string& host, const std::string& user,
-                const std::string& passwd)
-    : rep (new REP_CLASS (host, user, passwd))
-  {
-#if !defined (HAVE_CURL)
-    disabled_error ();
-#endif
-  }
-
-  url_transfer (const std::string& url, const std::string& method,
-                const Array<std::string>& param, std::ostream& os)
-    : rep (new REP_CLASS (url, method, param, os))
-  {
-#if !defined (HAVE_CURL)
-    disabled_error ();
-#endif
-  }
-
-#undef REP_CLASS
-
-  url_transfer (const url_transfer& h) : rep (h.rep)
-  {
-    rep->count++;
-  }
-
-  ~url_transfer (void)
-  {
-    if (--rep->count == 0)
-      delete rep;
-  }
-
-  url_transfer& operator = (const url_transfer& h)
-  {
-    if (this != &h)
-      {
-        if (--rep->count == 0)
-          delete rep;
-
-        rep = h.rep;
-        rep->count++;
-      }
-
-    return *this;
-  }
-
-  bool is_valid (void) const { return rep->is_valid (); }
-
-  bool good (void) const { return rep->good (); }
-
-  std::string lasterror (void) const { return rep->lasterror (); }
-
-  void set_ostream (std::ostream& os) const { rep->set_ostream (os); }
-
-  void set_istream (std::istream& is) const { rep->set_istream (is); }
-
-  void ascii (void) const { rep->ascii (); }
-
-  void binary (void) const { rep->binary (); }
-
-  bool is_ascii (void) const { return rep->is_ascii (); }
-
-  bool is_binary (void) const { return rep->is_binary (); }
-
-  void cwd (const std::string& path) const { rep->cwd (path); }
-
-  void del (const std::string& file) const { rep->del (file); }
-
-  void rmdir (const std::string& path) const { rep->rmdir (path); }
-
-  void mkdir (const std::string& path) const { rep->mkdir (path); }
-
-  void rename (const std::string& oldname, const std::string& newname) const
-  {
-    rep->rename (oldname, newname);
-  }
-
-  void put (const std::string& file, std::istream& is) const
-  {
-    rep->put (file, is);
-  }
-
-  void get (const std::string& file, std::ostream& os) const
-  {
-    rep->get (file, os);
-  }
-
-  void mget_directory (const std::string& directory,
-                       const std::string& target) const
-  {
-    rep->mget_directory (directory, target);
-  }
-
-  string_vector mput_directory (const std::string& base,
-                                const std::string& directory) const
-  {
-    return rep->mput_directory (base, directory);
-  }
-
-  void dir (void) const { rep->dir (); }
-
-  string_vector list (void) const { return rep->list (); }
-
-  void get_fileinfo (const std::string& filename, double& filesize,
-                     time_t& filetime, bool& fileisdir) const
-  {
-    rep->get_fileinfo (filename, filesize, filetime, fileisdir);
-  }
-
-  std::string pwd (void) const { return rep->pwd (); }
-
-private:
-
-  base_url_transfer *rep;
-};
-
 typedef octave_handle curl_handle;
 
 class OCTINTERP_API ch_manager
 {
 protected:
 
   ch_manager (void)
     : handle_map (), handle_free_list (),
@@ -1120,17 +180,17 @@ private:
   }
 
   curl_handle do_make_curl_handle (const std::string& host,
                                    const std::string& user,
                                    const std::string& passwd)
   {
     curl_handle h = get_handle ();
 
-    url_transfer obj (host, user, passwd);
+    url_transfer obj (host, user, passwd, octave_stdout);
 
     if (! error_state)
       handle_map[h] = obj;
     else
       h = curl_handle ();
 
     return h;
   }
@@ -1215,17 +275,17 @@ ch_manager::do_free (const curl_handle& 
         }
       else
         error ("ch_manager::free: invalid object %g", h.value ());
     }
 }
 
 ch_manager *ch_manager::instance = 0;
 
-DEFUN_DLD (urlwrite, args, nargout,
+DEFUN (urlwrite, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {@var{f} =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}] =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}, @var{message}] =} urlwrite (@var{url}, @var{localfile})\n\
 Download a remote file specified by its @var{url} and save it as\n\
 @var{localfile}.  For example:\n\
 \n\
@@ -1372,17 +432,17 @@ urlwrite (\"http://www.google.com/search
     }
 
   if (nargout < 2 && ! curl.good ())
     error ("urlwrite: %s", curl.lasterror ().c_str ());
 
   return retval;
 }
 
-DEFUN_DLD (urlread, args, nargout,
+DEFUN (urlread, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{s} =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}] =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}, @var{message}] =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} urlread (@var{url}, @var{method}, @var{param})\n\
 Download a remote file specified by its @var{url} and return its content\n\
 in string @var{s}.  For example:\n\
 \n\
@@ -1487,17 +547,17 @@ s = urlread (\"http://www.google.com/sea
     }
 
   if (nargout < 2 && ! curl.good ())
     error ("urlread: %s", curl.lasterror().c_str());
 
   return retval;
 }
 
-DEFUN_DLD (__ftp__, args, ,
+DEFUN (__ftp__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{handle} =} __ftp__ (@var{host})\n\
 @deftypefnx {Loadable Function} {@var{handle} =} __ftp__ (@var{host}, @var{username}, @var{password})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -1518,69 +578,70 @@ Undocumented internal function\n\
       if (nargin > 1)
         user = args(1).string_value ();
 
       if (nargin > 2)
         passwd = args(2).string_value ();
 
       if (! error_state)
         {
-          curl_handle ch = ch_manager::make_curl_handle (host, user, passwd);
+          curl_handle ch
+            = ch_manager::make_curl_handle (host, user, passwd, octave_stdout);
 
           if (! error_state)
             retval = ch.value ();
         }
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_pwd__, args, ,
+DEFUN (__ftp_pwd__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_pwd__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_pwd__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         retval = curl.pwd ();
       else
         error ("__ftp_pwd__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_cwd__, args, ,
+DEFUN (__ftp_cwd__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_cwd__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
     error ("__ftp_cwd__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         {
           std::string path = "";
 
@@ -1594,31 +655,31 @@ Undocumented internal function\n\
         }
       else
         error ("__ftp_cwd__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_dir__, args, nargout,
+DEFUN (__ftp_dir__, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_dir__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_dir__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         {
           if (nargout == 0)
             curl.dir ();
@@ -1675,73 +736,73 @@ Undocumented internal function\n\
         }
       else
         error ("__ftp_dir__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_ascii__, args, ,
+DEFUN (__ftp_ascii__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_ascii__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_ascii__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         curl.ascii ();
       else
         error ("__ftp_ascii__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_binary__, args, ,
+DEFUN (__ftp_binary__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_binary__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_binary__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         curl.binary ();
       else
         error ("__ftp_binary__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_close__, args, ,
+DEFUN (__ftp_close__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_close__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -1759,59 +820,59 @@ Undocumented internal function\n\
         ch_manager::free (h);
       else
         error ("__ftp_close__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_mode__, args, ,
+DEFUN (__ftp_mode__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mode__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     error ("__ftp_mode__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         retval = (curl.is_ascii () ? "ascii" : "binary");
       else
         error ("__ftp_binary__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_delete__, args, ,
+DEFUN (__ftp_delete__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_delete__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_delete__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         {
           std::string file = args(1).string_value ();
 
@@ -1822,31 +883,31 @@ Undocumented internal function\n\
         }
       else
         error ("__ftp_delete__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_rmdir__, args, ,
+DEFUN (__ftp_rmdir__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_rmdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_rmdir__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         {
           std::string dir = args(1).string_value ();
 
@@ -1857,31 +918,31 @@ Undocumented internal function\n\
         }
       else
         error ("__ftp_rmdir__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_mkdir__, args, ,
+DEFUN (__ftp_mkdir__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mkdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_mkdir__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         {
           std::string dir = args(1).string_value ();
 
@@ -1892,31 +953,31 @@ Undocumented internal function\n\
         }
       else
         error ("__ftp_mkdir__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_rename__, args, ,
+DEFUN (__ftp_rename__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_rename__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 3)
     error ("__ftp_rename__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         {
           std::string oldname = args(1).string_value ();
           std::string newname = args(2).string_value ();
@@ -1928,31 +989,31 @@ Undocumented internal function\n\
         }
       else
         error ("__ftp_rename__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_mput__, args, nargout,
+DEFUN (__ftp_mput__, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mput__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 2)
     error ("__ftp_mput__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         {
           std::string pat = args(1).string_value ();
 
@@ -2019,31 +1080,31 @@ Undocumented internal function\n\
         }
       else
         error ("__ftp_mput__: invalid ftp handle");
     }
 
   return retval;
 }
 
-DEFUN_DLD (__ftp_mget__, args, ,
+DEFUN (__ftp_mget__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mget__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 && nargin != 3)
     error ("__ftp_mget__: incorrect number of arguments");
   else
     {
-      const url_transfer curl = ch_manager::get_object (args(0));
+      url_transfer curl = ch_manager::get_object (args(0));
 
       if (error_state)
         return retval;
 
       if (curl.is_valid ())
         {
           std::string file = args(1).string_value ();
           std::string target;
diff --git a/libinterp/dldfcn/module-files b/libinterp/dldfcn/module-files
--- a/libinterp/dldfcn/module-files
+++ b/libinterp/dldfcn/module-files
@@ -14,9 +14,8 @@ chol.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLD
 colamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 convhulln.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 dmperm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 fftw.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 qr.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
 symbfact.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 symrcm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 tsearch.cc
-urlwrite.cc|$(CURL_CPPFLAGS)|$(CURL_LDFLAGS)|$(CURL_LIBS)
diff --git a/liboctave/link-deps.mk b/liboctave/link-deps.mk
--- a/liboctave/link-deps.mk
+++ b/liboctave/link-deps.mk
@@ -10,28 +10,30 @@ GNULIB_LINK_DEPS = \
   $(LTLIBINTL)\
   $(ROUNDF_LIBM)\
   $(ROUND_LIBM)\
   $(TRUNCF_LIBM)\
   $(TRUNC_LIBM)
 
 LIBOCTAVE_LINK_DEPS = \
   $(GNULIB_LINK_DEPS) \
+  $(CURL_LIBS) \
   $(SPARSE_XLIBS) \
   $(ARPACK_LIBS) \
   $(QRUPDATE_LIBS) \
   $(FFTW_XLIBS) \
   $(LAPACK_LIBS) \
   $(BLAS_LIBS) \
   $(READLINE_LIBS) \
   $(TERM_LIBS) \
   $(LIBGLOB) \
   $(REGEX_LIBS) \
   $(DL_LIBS) \
   $(PTHREAD_LIBS) \
   $(FLIBS) \
   $(LIBS)
 
 LIBOCTAVE_LINK_OPTS = \
+  $(CURL_LDFLAGS) \
   $(SPARSE_XLDFLAGS) \
   $(ARPACK_LDFLAGS) \
   $(QRUPDATE_LDFLAGS) \
   $(FFTW_XLDFLAGS)
diff --git a/liboctave/util/module.mk b/liboctave/util/module.mk
--- a/liboctave/util/module.mk
+++ b/liboctave/util/module.mk
@@ -37,17 +37,18 @@ UTIL_INC = \
   util/pathsearch.h \
   util/lo-regexp.h \
   util/singleton-cleanup.h \
   util/sparse-sort.h \
   util/sparse-util.h \
   util/statdefs.h \
   util/str-vec.h \
   util/sun-utils.h \
-  util/unwind-prot.cc
+  util/unwind-prot.h \
+  util/url-transfer.h
 
 UTIL_C_SRC = \
   util/f2c-main.c \
   util/lo-cieee.c \
   util/lo-cutils.c \
   util/oct-rl-edit.c \
   util/oct-rl-hist.c 
 
@@ -69,16 +70,17 @@ UTIL_SRC = \
   util/oct-shlib.cc \
   util/pathsearch.cc \
   util/lo-regexp.cc \
   util/singleton-cleanup.cc \
   util/sparse-sort.cc \
   util/sparse-util.cc \
   util/str-vec.cc \
   util/unwind-prot.cc \
+  util/url-transfer.cc \
   $(UTIL_C_SRC)
 
 TEMPLATE_SRC += \
   util/oct-sort.cc
 
 OTHER_INC += \
   util/kpse.cc
 
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/util/url-transfer.cc
@@ -0,0 +1,793 @@
+/*
+
+Copyright (C) 2013 John W. Eaton
+Copyright (C) 2006-2012 Alexander Barth
+Copyright (C) 2009 David Bateman
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// Author: Alexander Barth <abarth@marine.usf.edu>
+// Author: jwe
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <fstream>
+#include <iomanip>
+#include <iostream>
+
+#include "dir-ops.h"
+#include "file-ops.h"
+#include "file-stat.h"
+#include "unwind-prot.h"
+#include "url-transfer.h"
+
+#ifdef HAVE_CURL
+#include <curl/curl.h>
+#include <curl/curlver.h>
+#include <curl/easy.h>
+#endif
+
+void
+base_url_transfer::mget_directory (const std::string& directory,
+                                   const std::string& target)
+{
+  std::string sep = file_ops::dir_sep_str ();
+  file_stat fs (directory);
+
+  if (!fs || !fs.is_dir ())
+    {
+      std::string msg;
+      int status = octave_mkdir (directory, 0777, msg);
+
+      if (status < 0)
+        {
+          ok = false;
+          errmsg = "__ftp_mget__: can not create directory '"
+            + target + sep + directory + "': " + msg;
+          return;
+        }
+    }
+
+  cwd (directory);
+
+  if (good ())
+    {
+      unwind_protect_safe frame;
+
+      frame.add_fcn (reset_path, this);
+
+      string_vector sv = list ();
+
+      for (octave_idx_type i = 0; i < sv.length (); i++)
+        {
+          time_t ftime;
+          bool fisdir;
+          double fsize;
+
+          get_fileinfo (sv(i), fsize, ftime, fisdir);
+
+          if (fisdir)
+            mget_directory (sv(i), target + directory + sep);
+          else
+            {
+              std::string realfile = target + directory + sep + sv(i);
+
+              std::ofstream ofile (realfile.c_str (),
+                                   std::ios::out | std::ios::binary);
+
+              if (! ofile.is_open ())
+                {
+                  ok = false;
+                  errmsg = "__ftp_mget__: unable to open file";
+                  break;
+                }
+
+              unwind_protect_safe frame2;
+
+              frame2.add_fcn (delete_file, realfile);
+
+              get (sv(i), ofile);
+
+              ofile.close ();
+
+              if (good ())
+                frame2.discard ();
+            }
+
+          if (! good ())
+            break;
+        }
+    }
+}
+
+string_vector
+base_url_transfer::mput_directory (const std::string& base,
+                                   const std::string& directory)
+{
+  string_vector file_list;
+
+  std::string realdir
+    = (base.length () == 0
+       ? directory : base + file_ops::dir_sep_str () + directory);
+
+  mkdir (directory);
+
+  if (! good ())
+    return file_list;
+
+  cwd (directory);
+
+  if (good ())
+    {
+      unwind_protect_safe frame;
+
+      frame.add_fcn (reset_path, this);
+
+      dir_entry dirlist (realdir);
+
+      if (dirlist)
+        {
+          string_vector files = dirlist.read ();
+
+          for (octave_idx_type i = 0; i < files.length (); i++)
+            {
+              std::string file = files (i);
+
+              if (file == "." || file == "..")
+                continue;
+
+              std::string realfile = realdir + file_ops::dir_sep_str () + file;
+              file_stat fs (realfile);
+
+              if (! fs.exists ())
+                {
+                  ok = false;
+                  errmsg = "__ftp__mput: file '" + realfile
+                    + "' does not exist";
+                  break;
+                }
+
+              if (fs.is_dir ())
+                {
+                  file_list.append (mput_directory (realdir, file));
+
+                  if (! good ())
+                    break;
+                }
+              else
+                {
+                  // FIXME Does ascii mode need to be flagged here?
+                  std::ifstream ifile (realfile.c_str (), std::ios::in |
+                                       std::ios::binary);
+
+                  if (! ifile.is_open ())
+                    {
+                      ok = false;
+                      errmsg = "__ftp_mput__: unable to open file '"
+                        + realfile + "'";
+                      break;
+                    }
+
+                  put (file, ifile);
+
+                  ifile.close ();
+
+                  if (! good ())
+                    break;
+
+                  file_list.append (realfile);
+                }
+            }
+        }
+      else
+        {
+          ok = false;
+          errmsg = "__ftp_mput__: can not read the directory '"
+            + realdir + "'";
+        }
+    }
+}
+
+#if defined (HAVE_CURL)
+
+static int
+write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
+{
+  std::ostream& stream = *(static_cast<std::ostream*> (streamp));
+  stream.write (static_cast<const char*> (buffer), size*nmemb);
+  return (stream.fail () ? 0 : size * nmemb);
+}
+
+static int
+read_data (void *buffer, size_t size, size_t nmemb, void *streamp)
+{
+  std::istream& stream = *(static_cast<std::istream*> (streamp));
+  stream.read (static_cast<char*> (buffer), size*nmemb);
+  if (stream.eof ())
+    return stream.gcount ();
+  else
+    return (stream.fail () ? 0 : size * nmemb);
+}
+
+static size_t
+throw_away (void *, size_t size, size_t nmemb, void *)
+{
+  return static_cast<size_t>(size * nmemb);
+}
+
+// I'd love to rewrite this as a private method of the url_transfer
+// class, but you can't pass the va_list from the wrapper SETOPT to
+// the curl_easy_setopt function.
+#define SETOPT(option, parameter) \
+  do \
+    { \
+      CURLcode res = curl_easy_setopt (curl, option, parameter); \
+      if (res != CURLE_OK) \
+        { \
+          ok = false; \
+          errmsg = curl_easy_strerror (res); \
+          return; \
+        } \
+    } \
+  while (0)
+
+// Same as above but with a return value.
+#define SETOPTR(option, parameter) \
+  do \
+    { \
+      CURLcode res = curl_easy_setopt (curl, option, parameter); \
+      if (res != CURLE_OK) \
+        { \
+          ok = false; \
+          errmsg = curl_easy_strerror (res); \
+          return retval; \
+        } \
+    } \
+  while (0)
+
+class curl_transfer : public base_url_transfer
+{
+public:
+
+  curl_transfer (void)
+    : base_url_transfer (), curl (curl_easy_init ()), errnum ()
+  {
+    if (curl)
+      valid = true;
+    else
+      errmsg = "can not create curl object";
+  }
+
+  curl_transfer (const std::string& host_arg, const std::string& user_arg,
+                 const std::string& passwd, std::ostream& os)
+    : base_url_transfer (host_arg, user_arg, passwd, os),
+      curl (curl_easy_init ()), errnum ()
+  {
+    if (curl)
+      valid = true;
+    else
+      {
+        errmsg = "can not create curl object";
+        return;
+      }
+
+    init (user_arg, passwd, std::cin, os);
+
+    std::string url ("ftp://" + host_arg);
+    SETOPT (CURLOPT_URL, url.c_str ());
+
+    // Setup the link, with no transfer.
+    perform ();
+  }
+
+  curl_transfer (const std::string& url, const std::string& method,
+                 const Array<std::string>& param, std::ostream& os)
+    : base_url_transfer (url, method, param, os),
+      curl (curl_easy_init ()), errnum ()
+  {
+    if (curl)
+      valid = true;
+    else
+      {
+        errmsg = "can not create curl object";
+        return;
+      }
+
+    init ("", "", std::cin, os);
+
+    SETOPT (CURLOPT_NOBODY, 0);
+
+    // Restore the default HTTP request method to GET after setting
+    // NOBODY to true and back to false.  This is needed for backward
+    // compatibility with versions of libcurl < 7.18.2.
+    SETOPT (CURLOPT_HTTPGET, 1);
+
+    // Don't need to store the parameters here as we can't change
+    // the URL after the object is created
+    std::string query_string = form_query_string (param);
+
+    if (method == "get")
+      {
+        query_string = url + "?" + query_string;
+        SETOPT (CURLOPT_URL, query_string.c_str ());
+      }
+    else if (method == "post")
+      {
+        SETOPT (CURLOPT_URL, url.c_str ());
+        SETOPT (CURLOPT_POSTFIELDS, query_string.c_str ());
+      }
+    else
+      SETOPT (CURLOPT_URL, url.c_str ());
+
+    perform ();
+  }
+
+  ~curl_transfer (void)
+  {
+    if (curl)
+      curl_easy_cleanup (curl);
+  }
+
+  void perform (void)
+  {
+    BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
+    errnum = curl_easy_perform (curl);
+
+    if (errnum != CURLE_OK)
+      {
+        ok = false;
+        errmsg = curl_easy_strerror (errnum);
+      }
+
+    END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+  }
+
+  std::string lasterror (void) const
+  {
+    return std::string (curl_easy_strerror (errnum));
+  }
+
+  std::ostream& set_ostream (std::ostream& os)
+  {
+    std::ostream& retval = *curr_ostream;
+    curr_ostream = &os;
+    SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (curr_ostream));
+    return retval;
+  }
+
+  std::istream& set_istream (std::istream& is)
+  {
+    std::istream& retval = *curr_istream;
+    curr_istream = &is;
+    SETOPTR (CURLOPT_READDATA, static_cast<void*> (curr_istream));
+    return retval;
+  }
+
+  void ascii (void)
+  {
+    ascii_mode = true;
+    SETOPT (CURLOPT_TRANSFERTEXT, 1);
+  }
+
+  void binary (void)
+  {
+    ascii_mode = false;
+    SETOPT (CURLOPT_TRANSFERTEXT, 0);
+  }
+
+  void cwd (const std::string& path)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "cwd " + path;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void del (const std::string& file)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "dele " + file;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void rmdir (const std::string& path)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "rmd " + path;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void mkdir (const std::string& path)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "mkd " + path;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void rename (const std::string& oldname, const std::string& newname)
+  {
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    std::string cmd = "rnfr " + oldname;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    cmd = "rnto " + newname;
+    slist = curl_slist_append (slist, cmd.c_str ());
+    SETOPT (CURLOPT_POSTQUOTE, slist);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+  }
+
+  void put (const std::string& file, std::istream& is)
+  {
+    std::string url = "ftp://" + host + "/" + file;
+    SETOPT (CURLOPT_URL, url.c_str ());
+    SETOPT (CURLOPT_UPLOAD, 1);
+    SETOPT (CURLOPT_NOBODY, 0);
+    std::istream& old_is = set_istream (is);
+
+    perform ();
+    if (! good ())
+      return;
+
+    set_istream (old_is);
+    SETOPT (CURLOPT_NOBODY, 1);
+    SETOPT (CURLOPT_UPLOAD, 0);
+    url = "ftp://" + host;
+    SETOPT (CURLOPT_URL, url.c_str ());
+  }
+
+  void get (const std::string& file, std::ostream& os)
+  {
+    std::string url = "ftp://" + host + "/" + file;
+    SETOPT (CURLOPT_URL, url.c_str ());
+    SETOPT (CURLOPT_NOBODY, 0);
+    std::ostream& old_os = set_ostream (os);
+
+    perform ();
+    if (! good ())
+      return;
+
+    set_ostream (old_os);
+    SETOPT (CURLOPT_NOBODY, 1);
+    url = "ftp://" + host;
+    SETOPT (CURLOPT_URL, url.c_str ());
+  }
+
+  void dir (void)
+  {
+    std::string url = "ftp://" + host + "/";
+    SETOPT (CURLOPT_URL, url.c_str ());
+    SETOPT (CURLOPT_NOBODY, 0);
+
+    perform ();
+    if (! good ())
+      return;
+
+    SETOPT (CURLOPT_NOBODY, 1);
+    url = "ftp://" + host;
+    SETOPT (CURLOPT_URL, url.c_str ());
+  }
+
+  string_vector list (void)
+  {
+    string_vector retval;
+
+    std::ostringstream buf;
+    std::string url = "ftp://" + host + "/";
+    SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
+    SETOPTR (CURLOPT_URL, url.c_str ());
+    SETOPTR (CURLOPT_DIRLISTONLY, 1);
+    SETOPTR (CURLOPT_NOBODY, 0);
+
+    perform ();
+    if (! good ())
+      return retval;
+
+    SETOPTR (CURLOPT_NOBODY, 1);
+    url = "ftp://" + host;
+    SETOPTR (CURLOPT_WRITEDATA, static_cast<void*> (curr_ostream));
+    SETOPTR (CURLOPT_DIRLISTONLY, 0);
+    SETOPTR (CURLOPT_URL, url.c_str ());
+
+    // Count number of directory entries
+    std::string str = buf.str ();
+    octave_idx_type n = 0;
+    size_t pos = 0;
+    while (true)
+      {
+        pos = str.find_first_of ('\n', pos);
+        if (pos == std::string::npos)
+          break;
+        pos++;
+        n++;
+      }
+    retval.resize (n);
+    pos = 0;
+    for (octave_idx_type i = 0; i < n; i++)
+      {
+        size_t newpos = str.find_first_of ('\n', pos);
+        if (newpos == std::string::npos)
+          break;
+
+        retval(i) = str.substr(pos, newpos - pos);
+        pos = newpos + 1;
+      }
+
+    return retval;
+  }
+
+  void get_fileinfo (const std::string& filename, double& filesize,
+                     time_t& filetime, bool& fileisdir)
+  {
+    std::string path = pwd ();
+
+    std::string url = "ftp://" + host + "/" + path + "/" + filename;
+    SETOPT (CURLOPT_URL, url.c_str ());
+    SETOPT (CURLOPT_FILETIME, 1);
+    SETOPT (CURLOPT_HEADERFUNCTION, throw_away);
+    SETOPT (CURLOPT_WRITEFUNCTION, throw_away);
+
+    // FIXME
+    // The MDTM command fails for a directory on the servers I tested
+    // so this is a means of testing for directories. It also means
+    // I can't get the date of directories!
+
+    perform ();
+    if (! good ())
+      {
+        fileisdir = true;
+        filetime = -1;
+        filesize = 0;
+
+        return;
+      }
+
+    fileisdir = false;
+    time_t ft;
+    curl_easy_getinfo (curl, CURLINFO_FILETIME, &ft);
+    filetime = ft;
+    double fs;
+    curl_easy_getinfo (curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
+    filesize = fs;
+
+    SETOPT (CURLOPT_WRITEFUNCTION, write_data);
+    SETOPT (CURLOPT_HEADERFUNCTION, 0);
+    SETOPT (CURLOPT_FILETIME, 0);
+    url = "ftp://" + host;
+    SETOPT (CURLOPT_URL, url.c_str ());
+
+    // The MDTM command seems to reset the path to the root with the
+    // servers I tested with, so cd again into the correct path. Make
+    // the path absolute so that this will work even with servers that
+    // don't end up in the root after an MDTM command.
+    cwd ("/" + path);
+  }
+
+  std::string pwd (void)
+  {
+    std::string retval;
+
+    struct curl_slist *slist = 0;
+
+    unwind_protect frame;
+    frame.add_fcn (curl_slist_free_all, slist);
+
+    slist = curl_slist_append (slist, "pwd");
+    SETOPTR (CURLOPT_POSTQUOTE, slist);
+    SETOPTR (CURLOPT_HEADERFUNCTION, write_data);
+
+    std::ostringstream buf;
+    SETOPTR (CURLOPT_WRITEHEADER, static_cast<void *>(&buf));
+
+    perform ();
+    if (! good ())
+      return retval;
+
+    retval = buf.str ();
+
+    // Can I assume that the path is alway in "" on the last line
+    size_t pos2 = retval.rfind ('"');
+    size_t pos1 = retval.rfind ('"', pos2 - 1);
+    retval = retval.substr (pos1 + 1, pos2 - pos1 - 1);
+
+    SETOPTR (CURLOPT_HEADERFUNCTION, 0);
+    SETOPTR (CURLOPT_WRITEHEADER, 0);
+    SETOPTR (CURLOPT_POSTQUOTE, 0);
+
+    return retval;
+  }
+
+private:
+
+  CURL *curl;
+  CURLcode errnum;
+
+  // No copying!
+
+  curl_transfer (const curl_transfer&);
+
+  curl_transfer& operator = (const curl_transfer&);
+
+  void init (const std::string& user, const std::string& passwd,
+             std::istream& is, std::ostream& os)
+  {
+    // No data transfer by default
+    SETOPT (CURLOPT_NOBODY, 1);
+
+    // Set the username and password
+    userpwd = user;
+    if (! passwd.empty ())
+      userpwd += ":" + passwd;
+    if (! userpwd.empty ())
+      SETOPT (CURLOPT_USERPWD, userpwd.c_str ());
+
+    // Define our callback to get called when there's data to be written.
+    SETOPT (CURLOPT_WRITEFUNCTION, write_data);
+
+    // Set a pointer to our struct to pass to the callback.
+    SETOPT (CURLOPT_WRITEDATA, static_cast<void*> (&os));
+
+    // Define our callback to get called when there's data to be read
+    SETOPT (CURLOPT_READFUNCTION, read_data);
+
+    // Set a pointer to our struct to pass to the callback.
+    SETOPT (CURLOPT_READDATA, static_cast<void*> (&is));
+
+    // Follow redirects.
+    SETOPT (CURLOPT_FOLLOWLOCATION, true);
+
+    // Don't use EPSV since connecting to sites that don't support it
+    // will hang for some time (3 minutes?) before moving on to try PASV
+    // instead.
+    SETOPT (CURLOPT_FTP_USE_EPSV, false);
+
+    SETOPT (CURLOPT_NOPROGRESS, true);
+    SETOPT (CURLOPT_FAILONERROR, true);
+
+    SETOPT (CURLOPT_POSTQUOTE, 0);
+    SETOPT (CURLOPT_QUOTE, 0);
+  }
+
+  std::string form_query_string (const Array<std::string>& param)
+  {
+    std::ostringstream query;
+
+    for (int i = 0; i < param.numel (); i += 2)
+      {
+        std::string name = param(i);
+        std::string text = param(i+1);
+
+        // Encode strings.
+        char *enc_name = curl_easy_escape (curl, name.c_str (),
+                                           name.length ());
+        char *enc_text = curl_easy_escape (curl, text.c_str (),
+                                           text.length ());
+
+        query << enc_name << "=" << enc_text;
+
+        curl_free (enc_name);
+        curl_free (enc_text);
+
+        if (i < param.numel ()-1)
+          query << "&";
+      }
+
+    query.flush ();
+
+    return query.str ();
+  }
+};
+
+#undef SETOPT
+
+#else
+
+static void
+disabled_error (void)
+{
+  error ("support for url transfers was disabled when Octave was built");
+}
+
+#endif
+
+#if defined (HAVE_CURL)
+# define REP_CLASS curl_transfer
+#else
+# define REP_CLASS base_url_transfer
+#endif
+
+url_transfer::url_transfer (void) : rep (new REP_CLASS ())
+{
+#if !defined (HAVE_CURL)
+  disabled_error ();
+#endif
+}
+
+url_transfer::url_transfer (const std::string& host, const std::string& user,
+                            const std::string& passwd, std::ostream& os)
+  : rep (new REP_CLASS (host, user, passwd, os))
+{
+#if !defined (HAVE_CURL)
+  disabled_error ();
+#endif
+}
+
+url_transfer::url_transfer (const std::string& url, const std::string& method,
+                            const Array<std::string>& param, std::ostream& os)
+  : rep (new REP_CLASS (url, method, param, os))
+{
+#if !defined (HAVE_CURL)
+  disabled_error ();
+#endif
+}
+
+#undef REP_CLASS
diff --git a/liboctave/util/url-transfer.h b/liboctave/util/url-transfer.h
new file mode 100644
--- /dev/null
+++ b/liboctave/util/url-transfer.h
@@ -0,0 +1,269 @@
+/*
+
+Copyright (C) 2013 John W. Eaton
+Copyright (C) 2006-2012 Alexander Barth
+Copyright (C) 2009 David Bateman
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// Author: Alexander Barth <abarth@marine.usf.edu>
+// Author: jwe
+
+#if !defined (octave_url_transfer_h)
+#define octave_url_transfer_h 1
+
+#include <iosfwd>
+#include <string>
+
+class base_url_transfer
+{
+private:
+
+  static void
+  delete_file (const std::string& file)
+  {
+    octave_unlink (file);
+  }
+
+  static void reset_path (base_url_transfer *curl_xfer)
+  {
+    curl_xfer->cwd ("..");
+  }
+
+public:
+
+  friend class url_transfer;
+
+  base_url_transfer (void)
+    : count (1), host (), userpwd (), valid (false), ascii_mode (false),
+      ok (true), errmsg (), curr_istream (&std::cin), curr_ostream (&std::cout)
+  { }
+
+  base_url_transfer (const std::string& host_arg,
+                     const std::string& /* user_arg */,
+                     const std::string& /* passwd */,
+                     std::ostream& os)
+    : count (1), host (host_arg), userpwd (), valid (false),
+      ascii_mode (false), ok (true), errmsg (), curr_istream (&std::cin),
+      curr_ostream (&os) { }
+
+  base_url_transfer (const std::string& /* url */,
+                     const std::string& /* method */,
+                     const Array<std::string>& /* param */,
+                     std::ostream& os)
+    : count (1), host (), userpwd (), valid (false), ascii_mode (false),
+      ok (true), errmsg (), curr_istream (&std::cin), curr_ostream (&os) { }
+
+  virtual ~base_url_transfer (void) { }
+
+  bool is_valid (void) const { return valid; }
+
+  bool good (void) const { return valid && ok; }
+
+  virtual void perform (void) { }
+
+  virtual std::string lasterror (void) const { return errmsg; }
+
+  virtual std::ostream& set_ostream (std::ostream& /* os */)
+  {
+    return *curr_ostream;
+  }
+
+  virtual std::istream& set_istream (std::istream& /* is */)
+  {
+    return *curr_istream;
+  }
+
+  virtual void ascii (void) { }
+
+  virtual void binary (void) { }
+
+  bool is_ascii (void) const { return ascii_mode; }
+
+  bool is_binary (void) const { return !ascii_mode; }
+
+  virtual void cwd (const std::string& /* path */) { } 
+
+  virtual void del (const std::string& /* file */) { }
+
+  virtual void rmdir (const std::string& /* path */) { }
+
+  virtual void mkdir (const std::string& /* path */) { }
+
+  virtual void rename (const std::string& /* oldname */,
+                       const std::string& /* newname */) { }
+
+  virtual void put (const std::string& /* file */,
+                    std::istream& /* is */) { }
+
+  virtual void get (const std::string& /* file */,
+                    std::ostream& /* os */) { }
+
+  void mget_directory (const std::string& directory,
+                       const std::string& target);
+
+  string_vector mput_directory (const std::string& base,
+                                const std::string& directory);
+
+  virtual void dir (void) { }
+
+  virtual string_vector list (void) { return string_vector (); }
+
+  virtual void get_fileinfo (const std::string& /* filename */,
+                             double& /* filesize */,
+                             time_t& /* filetime */,
+                             bool& /* fileisdir */) { }
+
+  virtual std::string pwd (void) { return std::string (); }
+
+protected:
+
+  octave_refcount<size_t> count;
+  std::string host;
+  std::string userpwd;
+  bool valid;
+  bool ascii_mode;
+  bool ok;
+  std::string errmsg;
+  std::istream *curr_istream;
+  std::ostream *curr_ostream;
+
+private:
+
+  // No copying!
+
+  base_url_transfer (const base_url_transfer&);
+
+  base_url_transfer& operator = (const base_url_transfer&);
+};
+
+class url_transfer
+{
+public:
+
+  url_transfer (void);
+
+  url_transfer (const std::string& host, const std::string& user,
+                const std::string& passwd, std::ostream& os);
+
+  url_transfer (const std::string& url, const std::string& method,
+                const Array<std::string>& param, std::ostream& os);
+
+  url_transfer (const url_transfer& h) : rep (h.rep)
+  {
+    rep->count++;
+  }
+
+  ~url_transfer (void)
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
+
+  url_transfer& operator = (const url_transfer& h)
+  {
+    if (this != &h)
+      {
+        if (--rep->count == 0)
+          delete rep;
+
+        rep = h.rep;
+        rep->count++;
+      }
+
+    return *this;
+  }
+
+  bool is_valid (void) const { return rep->is_valid (); }
+
+  bool good (void) const { return rep->good (); }
+
+  std::string lasterror (void) const { return rep->lasterror (); }
+
+  std::ostream& set_ostream (std::ostream& os)
+  {
+    return rep->set_ostream (os);
+  }
+
+  std::istream& set_istream (std::istream& is)
+  {
+    return rep->set_istream (is);
+  }
+
+  void ascii (void) { rep->ascii (); }
+
+  void binary (void) { rep->binary (); }
+
+  bool is_ascii (void) const { return rep->is_ascii (); }
+
+  bool is_binary (void) const { return rep->is_binary (); }
+
+  void cwd (const std::string& path) { rep->cwd (path); }
+
+  void del (const std::string& file) { rep->del (file); }
+
+  void rmdir (const std::string& path) { rep->rmdir (path); }
+
+  void mkdir (const std::string& path) { rep->mkdir (path); }
+
+  void rename (const std::string& oldname, const std::string& newname)
+  {
+    rep->rename (oldname, newname);
+  }
+
+  void put (const std::string& file, std::istream& is)
+  {
+    rep->put (file, is);
+  }
+
+  void get (const std::string& file, std::ostream& os)
+  {
+    rep->get (file, os);
+  }
+
+  void mget_directory (const std::string& directory,
+                       const std::string& target)
+  {
+    rep->mget_directory (directory, target);
+  }
+
+  string_vector mput_directory (const std::string& base,
+                                const std::string& directory)
+  {
+    return rep->mput_directory (base, directory);
+  }
+
+  void dir (void) { rep->dir (); }
+
+  string_vector list (void) { return rep->list (); }
+
+  void get_fileinfo (const std::string& filename, double& filesize,
+                     time_t& filetime, bool& fileisdir)
+  {
+    rep->get_fileinfo (filename, filesize, filetime, fileisdir);
+  }
+
+  std::string pwd (void) { return rep->pwd (); }
+
+private:
+
+  base_url_transfer *rep;
+};
+
+#endif
