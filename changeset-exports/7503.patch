# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1203499370 18000
#      Wed Feb 20 04:22:50 2008 -0500
# Node ID 8c32f95c263944b9399deff0d53e23e5f8caa976
# Parent  2ce6b4258e9633f6148f788406c31e8d3ebbac46
convert mapper functions to new format

diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -27,18 +27,18 @@ along with Octave; see the file COPYING.
 
 #include <cassert>
 #include <cstddef>
 
 #include <iostream>
 
 #include "dim-vector.h"
 #include "lo-utils.h"
-
 #include "oct-sort.h"
+#include "quit.h"
 
 class idx_vector;
 
 // One dimensional array class.  Handles the reference counting for
 // all the derived classes.
 
 template <class T>
 T
@@ -544,16 +544,37 @@ public:
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return const_cast<T *> (data ()); }
 
   Array<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
   Array<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		 sortmode mode = ASCENDING) const;
+
+  template <class U, class F>
+  Array<U>
+  map (F fcn) const
+  {
+    octave_idx_type len = length ();
+
+    const T *m = data ();
+
+    Array<U> result (dims ());
+    U *p = result.fortran_vec ();
+
+    for (octave_idx_type i = 0; i < len; i++)
+      {
+	OCTAVE_QUIT;
+
+	p[i] = fcn (m[i]);
+      }
+
+    return result;
+  }
 };
 
 // NOTE: these functions should be friends of the Array<T> class and
 // Array<T>::dimensions should be protected, not public, but we can't
 // do that because of bugs in gcc prior to 3.3.
 
 template <class LT, class RT>
 /* friend */ int
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -70,16 +70,23 @@ public:
 	Array<T>::fill (val); 
     }
 
   Array2 (const Array2<T>& a) : Array<T> (a, a.dims ()) { }
 
   Array2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
     : Array<T> (a, dim_vector (r, c)) { }
 
+  template <class U>
+  Array2 (const Array<U>& a) : Array<T> (a) { }
+
+  template <class U>
+  Array2 (const Array<U>& a, const dim_vector& dv)
+    : Array<T> (a, dv) { }
+
   ~Array2 (void) { }
 
   Array2<T>& operator = (const Array2<T>& a)
     {
       if (this != &a)
 	Array<T>::operator = (a);
 
       return *this;
@@ -123,16 +130,22 @@ public:
     }
 
   Array2<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		 sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (sidx, dim, mode);
       return Array2<T> (tmp, tmp.rows (), tmp.columns ());
     }
+
+  template <class U, class F>
+  Array2<U> map (F fcn) const
+  {
+    return Array<T>::template map<U> (fcn);
+  }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -143,16 +143,22 @@ public:
     }
 
   ArrayN<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		 sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (sidx, dim, mode);
       return ArrayN<T> (tmp, tmp.dims ());
     }
+
+  template <class U, class F>
+  ArrayN<U> map (F fcn) const
+  {
+    return Array<T>::template map<U> (fcn);
+  }
 };
 
 template <class T>
 std::ostream&
 operator << (std::ostream&, const ArrayN<T>&);
 
 #endif
 
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "Array-util.h"
 #include "f77-fcn.h"
+#include "functor.h"
 #include "lo-error.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
@@ -451,49 +452,26 @@ operator * (const ComplexDiagMatrix& m, 
   for (octave_idx_type i = a_len; i < nr; i++)
     result.elem (i) = 0.0;
 
   return result;
 }
 
 // other operations
 
-ComplexColumnVector
-ComplexColumnVector::map (c_c_Mapper f) const
+ColumnVector
+ComplexColumnVector::map (dmapper fcn) const
 {
-  ComplexColumnVector b (*this);
-  return b.apply (f);
+  return MArray<Complex>::map<double> (func_ptr (fcn));
 }
 
-ColumnVector
-ComplexColumnVector::map (d_c_Mapper f) const
+ComplexColumnVector
+ComplexColumnVector::map (cmapper fcn) const
 {
-  const Complex *d = data ();
-
-  octave_idx_type len = length ();
-
-  ColumnVector retval (len);
-
-  double *r = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    r[i] = f (d[i]);
-
-  return retval;
-}
-
-ComplexColumnVector&
-ComplexColumnVector::apply (c_c_Mapper f)
-{
-  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
-
-  for (octave_idx_type i = 0; i < length (); i++)
-    d[i] = f (d[i]);
-
-  return *this;
+  return MArray<Complex>::map<Complex> (func_ptr (fcn));
 }
 
 Complex
 ComplexColumnVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -109,20 +109,21 @@ public:
   friend ComplexColumnVector operator * (const ComplexDiagMatrix& a,
 					 const ColumnVector& b);
 
   friend ComplexColumnVector operator * (const ComplexDiagMatrix& a,
 					 const ComplexColumnVector& b);
 
   // other operations
 
-  ComplexColumnVector map (c_c_Mapper f) const;
-  ColumnVector map (d_c_Mapper f) const;
+  typedef double (*dmapper) (const Complex&);
+  typedef Complex (*cmapper) (const Complex&);
 
-  ComplexColumnVector& apply (c_c_Mapper f);
+  ColumnVector map (dmapper fcn) const;
+  ComplexColumnVector map (cmapper fcn) const;
 
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "CMatrix.h"
 #include "CmplxAEPBAL.h"
 #include "CmplxDET.h"
 #include "CmplxSCHUR.h"
 #include "CmplxSVD.h"
 #include "CmplxCHOL.h"
 #include "f77-fcn.h"
+#include "functor.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "mx-cm-dm.h"
 #include "mx-dm-cm.h"
 #include "mx-cm-s.h"
@@ -3092,62 +3093,32 @@ ComplexMatrix::operator ! (void) const
     for (octave_idx_type i = 0; i < nr; i++)
       b.elem (i, j) = elem (i, j) == 0.0;
 
   return b;
 }
 
 // other operations
 
-ComplexMatrix
-ComplexMatrix::map (c_c_Mapper f) const
-{
-  ComplexMatrix b (*this);
-  return b.apply (f);
-}
-
 Matrix
-ComplexMatrix::map (d_c_Mapper f) const
+ComplexMatrix::map (dmapper fcn) const
 {
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  Matrix retval (nr, nc);
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (elem(i,j));
-
-  return retval;
+  return MArray2<Complex>::map<double> (func_ptr (fcn));
+}
+
+ComplexMatrix
+ComplexMatrix::map (cmapper fcn) const
+{
+  return MArray2<Complex>::map<Complex> (func_ptr (fcn));
 }
 
 boolMatrix
-ComplexMatrix::map (b_c_Mapper f) const
+ComplexMatrix::map (bmapper fcn) const
 {
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  boolMatrix retval (nr, nc);
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (elem(i,j));
-
-  return retval;
-}
-
-ComplexMatrix&
-ComplexMatrix::apply (c_c_Mapper f)
-{
-  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
-
-  for (octave_idx_type i = 0; i < length (); i++)
-    d[i] = f (d[i]);
-
-  return *this;
+  return MArray2<Complex>::map<bool> (func_ptr (fcn));
 }
 
 bool
 ComplexMatrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -306,21 +306,23 @@ public:
   ComplexMatrix& operator -= (const Matrix& a);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
-  ComplexMatrix map (c_c_Mapper f) const;
-  Matrix map (d_c_Mapper f) const;
-  boolMatrix map (b_c_Mapper f) const;
+  typedef double (*dmapper) (const Complex&);
+  typedef Complex (*cmapper) (const Complex&);
+  typedef bool (*bmapper) (const Complex&);
 
-  ComplexMatrix& apply (c_c_Mapper f);
+  Matrix map (dmapper fcn) const;
+  ComplexMatrix map (cmapper fcn) const;
+  boolMatrix map (bmapper fcn) const;
 
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_real (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
 
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 #include <cfloat>
 
 #include <vector>
 
 #include "Array-util.h"
 #include "CNDArray.h"
 #include "mx-base.h"
 #include "f77-fcn.h"
+#include "functor.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
 #else
 extern "C"
 {
@@ -979,16 +980,33 @@ ComplexNDArray::increment_index (Array<o
 
 octave_idx_type 
 ComplexNDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
+NDArray
+ComplexNDArray::map (dmapper fcn) const
+{
+  return MArrayN<Complex>::map<double> (func_ptr (fcn));
+}
+
+ComplexNDArray
+ComplexNDArray::map (cmapper fcn) const
+{
+  return MArrayN<Complex>::map<Complex> (func_ptr (fcn));
+}
+
+boolNDArray
+ComplexNDArray::map (bmapper fcn) const
+{
+  return MArrayN<Complex>::map<bool> (func_ptr (fcn));
+}
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const ComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -111,16 +111,24 @@ public:
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexNDArray& a);
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
+  typedef double (*dmapper) (const Complex&);
+  typedef Complex (*cmapper) (const Complex&);
+  typedef bool (*bmapper) (const Complex&);
+
+  NDArray map (dmapper fcn) const;
+  ComplexNDArray map (cmapper fcn) const;
+  boolNDArray map (bmapper fcn) const;
+
 private:
 
   ComplexNDArray (Complex *d, const dim_vector& dv)
     : MArrayN<Complex> (d, dv) { }
 };
 
 extern OCTAVE_API ComplexNDArray min (const Complex& c, const ComplexNDArray& m);
 extern OCTAVE_API ComplexNDArray min (const ComplexNDArray& m, const Complex& c);
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "Array-util.h"
 #include "f77-fcn.h"
+#include "functor.h"
 #include "lo-error.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
@@ -361,49 +362,26 @@ ComplexRowVector
 operator * (const RowVector& v, const ComplexMatrix& a)
 {
   ComplexRowVector tmp (v);
   return tmp * a;
 }
 
 // other operations
 
-ComplexRowVector
-ComplexRowVector::map (c_c_Mapper f) const
+RowVector
+ComplexRowVector::map (dmapper fcn) const
 {
-  ComplexRowVector b (*this);
-  return b.apply (f);
+  return MArray<Complex>::map<double> (func_ptr (fcn));
 }
 
-RowVector
-ComplexRowVector::map (d_c_Mapper f) const
+ComplexRowVector
+ComplexRowVector::map (cmapper fcn) const
 {
-  const Complex *d = data ();
-
-  octave_idx_type len = length ();
-
-  RowVector retval (len);
-
-  double *r = retval.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    r[i] = f (d[i]);
-
-  return retval;
-}
-
-ComplexRowVector&
-ComplexRowVector::apply (c_c_Mapper f)
-{
-  Complex *d = fortran_vec (); // Ensures only one reference to my privates!
-
-  for (octave_idx_type i = 0; i < length (); i++)
-    d[i] = f (d[i]);
-
-  return *this;
+  return MArray<Complex>::map<Complex> (func_ptr (fcn));
 }
 
 Complex
 ComplexRowVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return Complex (0.0);
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -91,20 +91,21 @@ public:
   friend ComplexRowVector operator * (const ComplexRowVector& a,
 				      const ComplexMatrix& b);
 
   friend ComplexRowVector operator * (const RowVector& a,
 				      const ComplexMatrix& b);
 
   // other operations
 
-  ComplexRowVector map (c_c_Mapper f) const;
-  RowVector map (d_c_Mapper f) const;
+  typedef double (*dmapper) (const Complex&);
+  typedef Complex (*cmapper) (const Complex&);
 
-  ComplexRowVector& apply (c_c_Mapper f);
+  RowVector map (dmapper fcn) const;
+  ComplexRowVector map (cmapper fcn) const;
 
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexRowVector& a);
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -7172,173 +7172,16 @@ SparseComplexMatrix::permute (const Arra
 SparseComplexMatrix
 SparseComplexMatrix::ipermute (const Array<octave_idx_type>& vec) const
 {
   return MSparse<Complex>::ipermute (vec);
 }
 
 // other operations
 
-SparseComplexMatrix
-SparseComplexMatrix::map (c_c_Mapper f) const
-{
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
-  bool f_zero = (f(0.0) == 0.0);
-
-  // Count number of non-zero elements
-  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
-  for (octave_idx_type i = 0; i < nz; i++)
-    if (f (data(i)) != 0.0)
-      nel++;
-
-  SparseComplexMatrix retval (nr, nc, nel);
-
-  if (f_zero)
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      Complex tmp = f (elem (i, j));
-	      if (tmp != 0.0)
-		{
-		  retval.data(ii) = tmp;
-		  retval.ridx(ii++) = i;
-		}
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-  else
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      retval.data(ii) = f (elem(i));
-	      retval.ridx(ii++) = ridx(i);
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-
-  return retval;
-}
-
-SparseMatrix
-SparseComplexMatrix::map (d_c_Mapper f) const
-{
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
-  bool f_zero = (f(0.0) == 0.0);
-
-  // Count number of non-zero elements
-  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
-  for (octave_idx_type i = 0; i < nz; i++)
-    if (f (data(i)) != 0.0)
-      nel++;
-
-  SparseMatrix retval (nr, nc, nel);
-
-  if (f_zero)
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      double tmp = f (elem (i, j));
-	      if (tmp != 0.0)
-		{
-		  retval.data(ii) = tmp;
-		  retval.ridx(ii++) = i;
-		}
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-  else
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      retval.data(ii) = f (elem(i));
-	      retval.ridx(ii++) = ridx(i);
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-
-  return retval;
-}
-
-SparseBoolMatrix
-SparseComplexMatrix::map (b_c_Mapper f) const
-{
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
-  bool f_zero = f(0.0);
-
-  // Count number of non-zero elements
-  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
-  for (octave_idx_type i = 0; i < nz; i++)
-    if (f (data(i)) != 0.0)
-      nel++;
-
-  SparseBoolMatrix retval (nr, nc, nel);
-
-  if (f_zero)
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      bool tmp = f (elem (i, j));
-	      if (tmp)
-		{
-		  retval.data(ii) = tmp;
-		  retval.ridx(ii++) = i;
-		}
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-  else
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      retval.data(ii) = f (elem(i));
-	      retval.ridx(ii++) = ridx(i);
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-
-  return retval;
-}
-
-SparseComplexMatrix&
-SparseComplexMatrix::apply (c_c_Mapper f)
-{
-  *this = map (f);
-  return *this;
-}
-
 bool
 SparseComplexMatrix::any_element_is_inf_or_nan (void) const
 {
   octave_idx_type nel = nnz ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
@@ -7594,16 +7437,179 @@ SparseComplexMatrix::diag (octave_idx_ty
     }
   else
     (*current_liboctave_error_handler) 
       ("diag: requested diagonal out of range");
 
   return d;
 }
 
+SparseMatrix
+SparseComplexMatrix::map (dmapper fcn) const
+{
+  SparseMatrix result;
+  double f_zero = fcn (0.);
+
+  if (f_zero != 0.)
+    {
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+      
+      result = SparseMatrix (nr, nc, f_zero);
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	  {
+	    OCTAVE_QUIT;
+	    /* Use data instead of elem for better performance.  */
+	    result.data (ridx (i) + j * nr) = fcn (data(i));
+	  }
+
+      result.maybe_compress (true);
+    }
+  else
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+
+      result = SparseMatrix (nr, nc, nz);
+      octave_idx_type ii = 0;
+      result.cidx (ii) = 0;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	{
+	  for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	    {
+	      double val = fcn (data (i));
+	      if (val != 0.0)
+		{
+		  result.data (ii) = val;
+		  result.ridx (ii++) = ridx (i);
+		}
+	      OCTAVE_QUIT;
+	    }
+	  result.cidx (j+1) = ii;
+	}
+
+      result.maybe_compress (false);
+    }
+
+  return result;
+}
+
+SparseComplexMatrix
+SparseComplexMatrix::map (cmapper fcn) const
+{
+  SparseComplexMatrix result;
+  Complex f_zero = fcn (0.);
+
+  if (f_zero != 0.)
+    {
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+      
+      result = SparseComplexMatrix (nr, nc, f_zero);
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	  {
+	    OCTAVE_QUIT;
+	    /* Use data instead of elem for better performance.  */
+	    result.data (ridx (i) + j * nr) = fcn (data(i));
+	  }
+
+      result.maybe_compress (true);
+    }
+  else
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+
+      result = SparseComplexMatrix (nr, nc, nz);
+      Complex zero = Complex (0.0, 0.0);
+      octave_idx_type ii = 0;
+      result.cidx (ii) = 0;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	{
+	  for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	    {
+	      Complex val = fcn (data (i));
+	      if (val != zero)
+		{
+		  result.data (ii) = val;
+		  result.ridx (ii++) = ridx (i);
+		}
+	      OCTAVE_QUIT;
+	    }
+	  result.cidx (j+1) = ii;
+	}
+
+      result.maybe_compress (false);
+    }
+
+  return result;
+}
+
+SparseBoolMatrix
+SparseComplexMatrix::map (bmapper fcn) const
+{
+  SparseBoolMatrix result;
+  bool f_zero = fcn (0.);
+
+  if (f_zero)
+    {
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+      
+      result = SparseBoolMatrix (nr, nc, f_zero);
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	  {
+	    OCTAVE_QUIT;
+	    /* Use data instead of elem for better performance.  */
+	    result.data (ridx (i) + j * nr) = fcn (data(i));
+	  }
+
+      result.maybe_compress (true);
+    }
+  else
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+
+      result = SparseBoolMatrix (nr, nc, nz);
+      octave_idx_type ii = 0;
+      result.cidx (ii) = 0;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	{
+	  for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	    {
+	      bool val = fcn (data (i));
+	      if (val)
+		{
+		  result.data (ii) = val;
+		  result.ridx (ii++) = ridx (i);
+		}
+	      OCTAVE_QUIT;
+	    }
+	  result.cidx (j+1) = ii;
+	}
+
+      result.maybe_compress (false);
+    }
+
+  return result;
+}
+
 std::ostream&
 operator << (std::ostream& os, const SparseComplexMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  {
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -397,22 +397,16 @@ public:
 
   SparseComplexMatrix reshape (const dim_vector& new_dims) const;
 
   SparseComplexMatrix permute (const Array<octave_idx_type>& vec, 
 			       bool inv = false) const;
 
   SparseComplexMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
-  SparseComplexMatrix map (c_c_Mapper f) const;
-  SparseMatrix map (d_c_Mapper f) const;
-  SparseBoolMatrix map (b_c_Mapper f) const;
-
-  SparseComplexMatrix& apply (c_c_Mapper f);
-
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_real (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
 
   SparseBoolMatrix operator ! (void) const;
 
   SparseBoolMatrix all (int dim = -1) const;
@@ -427,16 +421,23 @@ public:
 
   SparseComplexMatrix diag (octave_idx_type k = 0) const;
 
   // i/o
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, 
 				    const SparseComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, 
 				    SparseComplexMatrix& a);
+
+  typedef double (*dmapper) (const Complex&);
+  typedef Complex (*cmapper) (const Complex&);
+  typedef bool (*bmapper) (const Complex&);
+  SparseMatrix map (dmapper fcn) const;
+  SparseComplexMatrix map (cmapper fcn) const;
+  SparseBoolMatrix map (bmapper fcn) const;
 };
 
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&,        
 				       const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, 
 				       const SparseMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, 
 				       const SparseComplexMatrix&);
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,64 @@
+2008-02-20  John W. Eaton  <jwe@octave.org>
+
+	* boolNDArray.h (boolNDArray (const Array2<bool>&)): Delete.
+
+	* Marray2.h (MArray2 (const Array2<U>&),
+	MArray2 (const MArray2<U>&)): New templated constructors.
+
+	* Array2.h (Array2 (const Array<U>&),
+	Array2 (const Array<U>&, const dim_vector&)):
+	New templated constructors.
+
+	* CColVector.cc (ComplexColumnVector::map): Forward to MArray::map.
+	* dColVector.cc (ColumnVector::map): ditto.
+	* CRowVector.cc (ComplexRowVector::map): ditto.
+	* dRowVector.cc (RowVector::map): ditto.
+	* CMatrix.cc (ComplexMatrix::map): Forward to MArray2::map.
+	* dMatrix.cc (Matrix::map): ditto.
+
+	* dNDArray.cc (NDArray::map): New functions.
+	* dNDArray.h: Provide decls.
+
+	* CNDArray.cc (ComplexNDArray::map): New functions.
+	* CNDArray.h: Provide decls.
+
+	* MArray2.h (MArray2<T>::map): New function.
+	* Array2.h (Array2<T>::map): New function.
+	* MArrayN.h (MArrayN<T>::map): New function.
+	* ArrayN.h (ArrayN<T>::map): New function.
+	* Array.h (Array<T>::map): New function.
+
+	* functor.h: New file.
+	* Makefile.in (INCLUDES): Add it to the list.
+
+2008-02-20  David Bateman  <dbateman@free.fr>
+
+	* CColVector.h, CColVector.cc (ComplexColumnVector::apply): Remove.
+	* dColVector.h, dColVector.cc (ColumnVector::apply): ditto.
+	* CRowVector.h, CRowVector.cc (ComplexRowVector::apply): ditto.
+	* dRowVector.h, dRowVector.cc (RowVector::apply): ditto.
+	* CMatrix.h, CMatrix.cc (ComplexMatrix::apply): ditto.
+	* dMatrix.h, dMatrix.cc (Matrix::apply): ditto.
+
+	* CSparse.cc (apply): Remove.
+	(map): Replace old mapper code with code taken from ov-mapepr.cc
+	* CSparse.h (map): Reeclare them.
+	(dmapper, cmapper, bmapper): typedefs for mapper functions.
+	* dSparse.cc (apply): Remove.
+	(map): Replace old mapper code with code taken from ov-mapepr.cc
+	* dSparse.h (map): Reeclare them.
+	(dmapper, cmapper, bmapper): typedefs for mapper functions.
+
+	* intNDArray.cc (abs, signum): Two new mapper functions.
+	* intNDArray.h (abs, signum): Declare them.
+	* oct-inttypes.h (abs, signum): Mapper functions on scalar integer
+	base type.
+
 2008-02-15  John W. Eaton  <jwe@octave.org>
 
 	* dMatrix.cc (Matrix::lssolve): Check n > mnthr, not n > m when
 	deciding whether to calculate workspace size, with mnthr from ILAENV.
 	* CMatrix.cc (ComplexMatrix::lssolve): Likewise.
 
 2008-02-14  John W. Eaton  <jwe@octave.org>
 
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -77,16 +77,22 @@ public:
 	    retval++;
 	}
 
       return retval;
     }
 
   double norm (double p) const;
 
+  template <class U, class F>
+  MArray<U> map (F fcn) const
+  {
+    return Array<T>::template map<U> (fcn);
+  }
+
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
   // MARRAY_OPS_FRIEND_DECLS (MArray)
 };
 
 #endif
 
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -54,32 +54,44 @@ public:
   MArray2 (const dim_vector& dv) : Array2<T> (dv) { }
 
   MArray2 (const dim_vector& dv, const T& val) : Array2<T> (dv, val) { }
 
   MArray2 (const MArray2<T>& a) : Array2<T> (a) { }
 
   MArray2 (const Array2<T>& a) : Array2<T> (a) { }
 
+  template <class U>
+  MArray2 (const Array2<U>& a) : Array2<T> (a) { }
+
+  template <class U>
+  MArray2 (const MArray2<U>& a) : Array2<T> (a) { }
+
   ~MArray2 (void) { }
 
   MArray2<T>& operator = (const MArray2<T>& a)
     {
       Array2<T>::operator = (a);
       return *this;
     }
 
   MArray2<T>& insert (const Array2<T>& a, octave_idx_type r, octave_idx_type c)
   {
     Array2<T>::insert (a, r, c);
     return *this;
   }
 
   MArray2<T> transpose (void) const { return Array2<T>::transpose (); }
 
+  template <class U, class F>
+  MArray2<U> map (F fcn) const
+  {
+    return Array2<T>::template map<U> (fcn);
+  }
+
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
   // MARRAY_OPS_FRIEND_DECLS (MArray2)
 };
 
 #endif
 
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -92,16 +92,22 @@ public:
   MArrayN<T> permute (const Array<octave_idx_type>& vec, 
 		      bool inv = false) const
     { return ArrayN<T>::permute (vec, inv); }
 
   MArrayN<T> ipermute (const Array<octave_idx_type>& vec) const
     { return ArrayN<T>::ipermute (vec); }
 
   MArrayN squeeze (void) const { return ArrayN<T>::squeeze (); }
+
+  template <class U, class F>
+  MArrayN<U> map (F fcn) const
+  {
+    return ArrayN<T>::template map<U> (fcn);
+  }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -71,17 +71,17 @@ OPT_IN := $(addsuffix .in, $(OPT_BASE))
 OPT_INC := $(addsuffix .h, $(OPT_BASE))
 
 INCLUDES := Bounds.h CollocWt.h DAE.h DAEFunc.h DAERT.h \
 	DAERTFunc.h DASPK.h DASRT.h DASSL.h FEGrid.h \
 	LinConst.h LP.h LSODE.h NLConst.h NLEqn.h \
 	NLFunc.h NLP.h ODE.h ODEFunc.h ODES.h ODESFunc.h \
 	Objective.h QP.h Quad.h Range.h base-dae.h \
 	base-de.h base-min.h byte-swap.h cmd-edit.h cmd-hist.h \
-	data-conv.h dir-ops.h file-ops.h file-stat.h getopt.h \
+	data-conv.h dir-ops.h file-ops.h file-stat.h functor.h getopt.h \
 	glob-match.h idx-vector.h kpse-xfns.h \
 	lo-ieee.h lo-mappers.h lo-math.h lo-specfun.h \
 	lo-sysdep.h lo-utils.h mach-info.h md5.h oct-alloc.h oct-cmplx.h \
 	oct-env.h oct-fftw.h oct-getopt.h oct-group.h oct-inttypes.h \
 	oct-md5.h oct-passwd.h oct-rand.h oct-rl-edit.h oct-rl-hist.h \
 	oct-shlib.h oct-sort.h oct-spparms.h oct-syscalls.h \
 	oct-sparse.h oct-time.h oct-uname.h \
 	pathlen.h pathsearch.h prog-args.h \
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -42,18 +42,16 @@ public:
 
   boolNDArray (const dim_vector& dv, const bool& val)
     : ArrayN<bool> (dv, val) { }
   
   boolNDArray (const boolNDArray& a) : ArrayN<bool> (a) { }
 
   boolNDArray (const boolMatrix& a) : ArrayN<bool> (a) { }
 
-  boolNDArray (const Array2<bool>& a) : ArrayN<bool> (a) { }
-
   boolNDArray (const ArrayN<bool>& a) : ArrayN<bool> (a) { }
 
   boolNDArray& operator = (const boolNDArray& a)
     {
       ArrayN<bool>::operator = (a);
       return *this;
     }
 
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -140,16 +140,70 @@ charNDArray::increment_index (Array<octa
 
 octave_idx_type 
 charNDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
+boolNDArray
+charNDArray::bmap (mapper fcn) const
+{
+  octave_idx_type len = length ();
+  const char *m = fortran_vec();
+  boolNDArray result (dims ());
+  bool *p = result.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < len; i++)
+    {
+      OCTAVE_QUIT;
+
+      p[i] = bool (fcn (m[i]));
+    }
+
+  return result;
+}
+
+NDArray
+charNDArray::dmap (mapper fcn) const
+{
+  octave_idx_type len = length ();
+  const char *m = fortran_vec();
+  NDArray result (dims ());
+  double *p = result.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < len; i++)
+    {
+      OCTAVE_QUIT;
+
+      p[i] = fcn (m[i]);
+    }
+
+  return result;
+}
+
+charNDArray
+charNDArray::smap (mapper fcn) const
+{
+  octave_idx_type len = length ();
+  const char *m = fortran_vec();
+  charNDArray result (dims ());
+  char *p = result.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < len; i++)
+    {
+      OCTAVE_QUIT;
+
+      p[i] = fcn (m[i]);
+    }
+
+  return result;
+}
+
 NDS_CMP_OPS(charNDArray, , char, )
 NDS_BOOL_OPS(charNDArray, char, 0)
 
 SND_CMP_OPS(char, , charNDArray, )
 SND_BOOL_OPS(char, charNDArray, 0)
 
 NDND_CMP_OPS(charNDArray, , charNDArray, )
 NDND_BOOL_OPS(charNDArray, charNDArray, 0)
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -84,16 +84,21 @@ public:
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
   static char resize_fill_value (void) { return '\0'; }
 
+  typedef int (*mapper) (int);
+  boolNDArray bmap (mapper fcn) const;
+  NDArray dmap (mapper fcn) const;
+  charNDArray smap (mapper fcn) const;
+
 private:
 
   charNDArray (char *d, dim_vector& dv) : MArrayN<char> (d, dv) { }
 };
 
 NDS_CMP_OP_DECLS (charNDArray, char, OCTAVE_API)
 NDS_BOOL_OP_DECLS (charNDArray, char, OCTAVE_API)
 
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "Array-util.h"
 #include "f77-fcn.h"
+#include "functor.h"
 #include "lo-error.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
@@ -258,31 +259,25 @@ operator * (const DiagMatrix& m, const C
     }
 
   return retval;
 }
 
 // other operations
 
 ColumnVector
-ColumnVector::map (d_d_Mapper f) const
+ColumnVector::map (dmapper fcn) const
 {
-  ColumnVector b (*this);
-  return b.apply (f);
+  return MArray<double>::map<double> (func_ptr (fcn));
 }
 
-ColumnVector&
-ColumnVector::apply (d_d_Mapper f)
+ComplexColumnVector
+ColumnVector::map (cmapper fcn) const
 {
-  double *d = fortran_vec (); // Ensures only one reference to my privates!
-
-  for (octave_idx_type i = 0; i < length (); i++)
-    d[i] = f (d[i]);
-
-  return *this;
+  return MArray<double>::map<Complex> (func_ptr (fcn));
 }
 
 double
 ColumnVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -78,19 +78,21 @@ public:
   friend OCTAVE_API ColumnVector operator * (const Matrix& a, const ColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
   friend OCTAVE_API ColumnVector operator * (const DiagMatrix& a, const ColumnVector& b);
 
   // other operations
 
-  ColumnVector map (d_d_Mapper f) const;
+  typedef double (*dmapper) (double);
+  typedef Complex (*cmapper) (const Complex&);
 
-  ColumnVector& apply (d_d_Mapper f);
+  ColumnVector map (dmapper fcn) const;
+  ComplexColumnVector map (cmapper fcn) const;
 
   double min (void) const;
   double max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ColumnVector& a);
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -35,16 +35,17 @@ along with Octave; see the file COPYING.
 #include "byte-swap.h"
 #include "dMatrix.h"
 #include "dbleAEPBAL.h"
 #include "dbleDET.h"
 #include "dbleSCHUR.h"
 #include "dbleSVD.h"
 #include "dbleCHOL.h"
 #include "f77-fcn.h"
+#include "functor.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "mx-m-dm.h"
 #include "mx-dm-m.h"
 #include "mx-inlines.cc"
@@ -2618,46 +2619,31 @@ operator * (const ColumnVector& v, const
     }
 
   return retval;
 }
 
 // other operations.
 
 Matrix
-Matrix::map (d_d_Mapper f) const
+Matrix::map (dmapper fcn) const
 {
-  Matrix b (*this);
-  return b.apply (f);
+  return MArray2<double>::map<double> (func_ptr (fcn));
+}
+
+ComplexMatrix
+Matrix::map (cmapper fcn) const
+{
+  return MArray2<double>::map<Complex> (func_ptr (fcn));
 }
 
 boolMatrix
-Matrix::map (b_d_Mapper f) const
+Matrix::map (bmapper fcn) const
 {
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-
-  boolMatrix retval (nr, nc);
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = f (elem(i,j));
-
-  return retval;
-}
-
-Matrix&
-Matrix::apply (d_d_Mapper f)
-{
-  double *d = fortran_vec (); // Ensures only one reference to my privates!
-
-  for (octave_idx_type i = 0; i < length (); i++)
-    d[i] = f (d[i]);
-
-  return *this;
+  return MArray2<double>::map<bool> (func_ptr (fcn));
 }
 
 bool
 Matrix::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nelem ();
 
   if (neg_zero)
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -261,20 +261,23 @@ public:
   Matrix& operator -= (const DiagMatrix& a);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
-  Matrix map (d_d_Mapper f) const;
-  boolMatrix map (b_d_Mapper f) const;
+  typedef double (*dmapper) (double);
+  typedef Complex (*cmapper) (const Complex&);
+  typedef bool (*bmapper) (double);
 
-  Matrix& apply (d_d_Mapper f);
+  Matrix map (dmapper fcn) const;
+  ComplexMatrix map (cmapper fcn) const;
+  boolMatrix map (bmapper fcn) const;
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
  
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <cfloat>
 
 #include <vector>
 
 #include "Array-util.h"
 #include "dNDArray.h"
+#include "functor.h"
 #include "mx-base.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
@@ -955,16 +956,34 @@ NDArray::increment_index (Array<octave_i
 
 octave_idx_type
 NDArray::compute_index (Array<octave_idx_type>& ra_idx,
 			const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
+NDArray
+NDArray::map (dmapper fcn) const
+{
+  return MArrayN<double>::map<double> (func_ptr (fcn));
+}
+
+ComplexNDArray
+NDArray::map (cmapper fcn) const
+{
+  return MArrayN<double>::map<Complex> (func_ptr (fcn));
+}
+
+boolNDArray
+NDArray::map (bmapper fcn) const
+{
+  return MArrayN<double>::map<bool> (func_ptr (fcn));
+}
+
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const NDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -119,16 +119,24 @@ public:
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const NDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, NDArray& a);
 
   static double resize_fill_value (void) { return 0; }
 
+  typedef double (*dmapper) (double);
+  typedef Complex (*cmapper) (const Complex&);
+  typedef bool (*bmapper) (double);
+
+  NDArray map (dmapper fcn) const;
+  ComplexNDArray map (cmapper fcn) const;
+  boolNDArray map (bmapper fcn) const;
+
 private:
 
   NDArray (double *d, const dim_vector& dv) : MArrayN<double> (d, dv) { }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API NDArray real (const ComplexNDArray& a);
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "Array-util.h"
 #include "f77-fcn.h"
+#include "functor.h"
 #include "lo-error.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
 #include "oct-cmplx.h"
 
 // Fortran functions we call.
 
 extern "C"
@@ -227,31 +228,25 @@ operator * (const RowVector& v, const Ma
     }
 
   return retval;
 }
 
 // other operations
 
 RowVector
-RowVector::map (d_d_Mapper f) const
+RowVector::map (dmapper fcn) const
 {
-  RowVector b (*this);
-  return b.apply (f);
+  return MArray<double>::map<double> (func_ptr (fcn));
 }
 
-RowVector&
-RowVector::apply (d_d_Mapper f)
+ComplexRowVector
+RowVector::map (cmapper fcn) const
 {
-  double *d = fortran_vec (); // Ensures only one reference to my privates!
-
-  for (octave_idx_type i = 0; i < length (); i++)
-    d[i] = f (d[i]);
-
-  return *this;
+  return MArray<double>::map<Complex> (func_ptr (fcn));
 }
 
 double
 RowVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return 0;
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -74,19 +74,21 @@ public:
   RowVector extract_n (octave_idx_type c1, octave_idx_type n) const;
 
   // row vector by matrix -> row vector
 
   friend OCTAVE_API RowVector operator * (const RowVector& a, const Matrix& b);
 
   // other operations
 
-  RowVector map (d_d_Mapper f) const;
+  typedef double (*dmapper) (double);
+  typedef Complex (*cmapper) (const Complex&);
 
-  RowVector& apply (d_d_Mapper f);
+  RowVector map (dmapper fcn) const;
+  ComplexRowVector map (cmapper fcn) const;
 
   double min (void) const;
   double max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const RowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, RowVector& a);
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -7209,123 +7209,16 @@ SparseMatrix::solve (const ComplexColumn
 	       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 // other operations.
 
-SparseMatrix
-SparseMatrix::map (d_d_Mapper f) const
-{
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
-  bool f_zero = (f(0.0) == 0.0);
-
-  // Count number of non-zero elements
-  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
-  for (octave_idx_type i = 0; i < nz; i++)
-    if (f (data(i)) != 0.0)
-      nel++;
-
-  SparseMatrix retval (nr, nc, nel);
-
-  if (f_zero)
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      double tmp = f (elem (i, j));
-	      if (tmp != 0.0)
-		{
-		  retval.data(ii) = tmp;
-		  retval.ridx(ii++) = i;
-		}
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-  else
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      retval.data(ii) = f (elem(i));
-	      retval.ridx(ii++) = ridx(i);
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-
-  return retval;
-}
-
-SparseBoolMatrix
-SparseMatrix::map (b_d_Mapper f) const
-{
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
-  bool f_zero = f(0.0);
-
-  // Count number of non-zero elements
-  octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
-  for (octave_idx_type i = 0; i < nz; i++)
-    if (f (data(i)) != 0.0)
-      nel++;
-
-  SparseBoolMatrix retval (nr, nc, nel);
-
-  if (f_zero)
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = 0; i < nr; i++)
-	    {
-	      bool tmp = f (elem (i, j));
-	      if (tmp)
-		{
-		  retval.data(ii) = tmp;
-		  retval.ridx(ii++) = i;
-		}
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-  else
-    {
-      octave_idx_type ii = 0;
-      for (octave_idx_type j = 0; j < nc; j++)
-	{
-	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
-	    {
-	      retval.data(ii) = f (elem(i));
-	      retval.ridx(ii++) = ridx(i);
-	    }
-	  retval.cidx(j+1) = ii;
-	}
-    }
-
-  return retval;
-}
-
-SparseMatrix&
-SparseMatrix::apply (d_d_Mapper f)
-{
-  *this = map (f);
-  return *this;
-}
-
 bool
 SparseMatrix::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nnz ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
@@ -7636,16 +7529,179 @@ SparseMatrix::matrix_value (void) const
   Matrix retval (nr, nc, 0.0);
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
       retval.elem (ridx(i), j) = data (i);
 
   return retval;
 }
 
+SparseMatrix
+SparseMatrix::map (dmapper fcn) const
+{
+  SparseMatrix result;
+  double f_zero = fcn (0.);
+
+  if (f_zero != 0.)
+    {
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+      
+      result = SparseMatrix (nr, nc, f_zero);
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	  {
+	    OCTAVE_QUIT;
+	    /* Use data instead of elem for better performance.  */
+	    result.data (ridx (i) + j * nr) = fcn (data(i));
+	  }
+
+      result.maybe_compress (true);
+    }
+  else
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+
+      result = SparseMatrix (nr, nc, nz);
+      octave_idx_type ii = 0;
+      result.cidx (ii) = 0;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	{
+	  for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	    {
+	      double val = fcn (data (i));
+	      if (val != 0.0)
+		{
+		  result.data (ii) = val;
+		  result.ridx (ii++) = ridx (i);
+		}
+	      OCTAVE_QUIT;
+	    }
+	  result.cidx (j+1) = ii;
+	}
+
+      result.maybe_compress (false);
+    }
+
+  return result;
+}
+
+SparseComplexMatrix
+SparseMatrix::map (cmapper fcn) const
+{
+  SparseComplexMatrix result;
+  Complex f_zero = fcn (0.);
+
+  if (f_zero != 0.)
+    {
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+      
+      result = SparseComplexMatrix (nr, nc, f_zero);
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	  {
+	    OCTAVE_QUIT;
+	    /* Use data instead of elem for better performance.  */
+	    result.data (ridx (i) + j * nr) = fcn (Complex (data(i), 0.0));
+	  }
+
+      result.maybe_compress (true);
+    }
+  else
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+
+      result = SparseComplexMatrix (nr, nc, nz);
+      Complex zero = Complex (0.0, 0.0);
+      octave_idx_type ii = 0;
+      result.cidx (ii) = 0;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	{
+	  for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	    {
+	      Complex val = fcn (Complex (data (i), 0.0));
+	      if (val != zero)
+		{
+		  result.data (ii) = val;
+		  result.ridx (ii++) = ridx (i);
+		}
+	      OCTAVE_QUIT;
+	    }
+	  result.cidx (j+1) = ii;
+	}
+
+      result.maybe_compress (false);
+    }
+
+  return result;
+}
+
+SparseBoolMatrix
+SparseMatrix::map (bmapper fcn) const
+{
+  SparseBoolMatrix result;
+  bool f_zero = fcn (0.);
+
+  if (f_zero)
+    {
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+      
+      result = SparseBoolMatrix (nr, nc, f_zero);
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	  {
+	    OCTAVE_QUIT;
+	    /* Use data instead of elem for better performance.  */
+	    result.data (ridx (i) + j * nr) = fcn (data(i));
+	  }
+
+      result.maybe_compress (true);
+    }
+  else
+    {
+      octave_idx_type nz = nnz ();
+      octave_idx_type nr = rows ();
+      octave_idx_type nc = cols ();
+
+      result = SparseBoolMatrix (nr, nc, nz);
+      octave_idx_type ii = 0;
+      result.cidx (ii) = 0;
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	{
+	  for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
+	    {
+	      bool val = fcn (data (i));
+	      if (val)
+		{
+		  result.data (ii) = val;
+		  result.ridx (ii++) = ridx (i);
+		}
+	      OCTAVE_QUIT;
+	    }
+	  result.cidx (j+1) = ii;
+	}
+
+      result.maybe_compress (false);
+    }
+
+  return result;
+}
+
 std::ostream&
 operator << (std::ostream& os, const SparseMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  {
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -365,20 +365,16 @@ public:
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcond,
 			     solve_singularity_handler sing_handler) const;
 
   // other operations
-  SparseMatrix map (d_d_Mapper f) const;
-  SparseBoolMatrix map (b_d_Mapper f) const;
-
-  SparseMatrix& apply (d_d_Mapper f);
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_zero (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
  
@@ -411,16 +407,23 @@ public:
   SparseMatrix permute (const Array<octave_idx_type>& vec, bool inv = false) const;
 
   SparseMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const SparseMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, SparseMatrix& a);
+
+  typedef double (*dmapper) (double);
+  typedef Complex (*cmapper) (const Complex&);
+  typedef bool (*bmapper) (double);
+  SparseMatrix map (dmapper fcn) const;
+  SparseComplexMatrix map (cmapper fcn) const;
+  SparseBoolMatrix map (bmapper fcn) const;
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API SparseMatrix real (const SparseComplexMatrix& a);
 extern OCTAVE_API SparseMatrix imag (const SparseComplexMatrix& a);
 
 // Other operators.
diff --git a/liboctave/functor.h b/liboctave/functor.h
new file mode 100644
--- /dev/null
+++ b/liboctave/functor.h
@@ -0,0 +1,81 @@
+/*
+
+Copyright (C) 2008 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_functor_h)
+#define octave_functor_h 1
+
+template <typename RT, typename PT>
+class fcn_ptr
+{
+public:
+  typedef RT (*TYPE) (PT);
+};
+
+template <typename RT, typename PT>
+class functor
+{
+private:
+  typedef typename fcn_ptr<RT, PT>::TYPE fcn_ptr_type;
+  fcn_ptr_type fptr;
+
+public:
+
+  functor (fcn_ptr_type p) : fptr (p) { }
+
+  RT operator () (PT arg) { return fptr (arg); }
+};
+
+template <typename CT, typename RT, typename PT>
+class functor_with_conversion
+{
+private:
+  typedef typename fcn_ptr<RT, PT>::TYPE fcn_ptr_type;
+  fcn_ptr_type fptr;
+
+public:
+
+  functor_with_conversion (fcn_ptr_type p) : fptr (p) { }
+
+  CT operator () (PT arg) { return CT (fptr (arg)); }
+};
+
+template <typename RT, typename PT>
+functor<RT, PT>
+func_ptr (RT (*f) (PT))
+{
+  return functor<RT, PT> (f);
+}
+
+template <typename CT, typename RT, typename PT>
+functor_with_conversion<CT, RT, PT>
+func_ptr_with_conversion (RT (*f) (PT))
+{
+  return functor_with_conversion<CT, RT, PT> (f);
+}
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -217,16 +217,50 @@ operator >> (std::istream& is, intNDArra
 	}
     }
 
  done:
 
   return is;
 }
 
+// FIXME -- should abs and signum just be mapper functions?
+
+template <class T>
+intNDArray<T>
+intNDArray<T>::abs (void) const
+{
+  octave_idx_type nel = this->nelem ();
+  intNDArray<T> ret (*this);
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    {
+      T val = this->elem (i);
+      ret.xelem (i) = val.abs ();
+    }
+
+  return ret;
+}
+
+template <class T>
+intNDArray<T>
+intNDArray<T>::signum (void) const
+{
+  octave_idx_type nel = this->nelem ();
+  intNDArray<T> ret (*this);
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    {
+      T val = this->elem (i);
+      ret.xelem (i) = val.signum ();
+    }
+
+  return ret;
+}
+
 template <class T>
 intNDArray<T>
 intNDArray<T>::sum (int dim) const
 {
   MX_ND_REDUCTION (retval(result_idx) += intNDArray<T>::elem (iter_idx), 0, intNDArray<T>);
 }
 
 template <class T>
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -75,16 +75,19 @@ public:
 
   intNDArray max (int dim = 0) const;
   intNDArray max (ArrayN<octave_idx_type>& index, int dim = 0) const;
   intNDArray min (int dim = 0) const;
   intNDArray min (ArrayN<octave_idx_type>& index, int dim = 0) const;
   
   intNDArray sum (int dim) const;
 
+  intNDArray abs (void) const;
+  intNDArray signum (void) const;
+
   intNDArray squeeze (void) const
     { return intNDArray<T> (MArrayN<T>::squeeze ()); }
 
   intNDArray transpose (void) const
     { return intNDArray<T> (MArrayN<T>::transpose ()); }
 
   intNDArray concat (const intNDArray<T>& rb, const Array<octave_idx_type>& ra_idx);
 
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -311,16 +311,34 @@ public:
   {
     if (ival < 0)
       ival = - (((-ival) >> x) & std::numeric_limits<T>::max());
     else
       ival = ival >> x;
     return *this;
   }
 
+  octave_int<T> abs (void) const 
+  { 
+    T val = value (); 
+    if (val < static_cast <T> (0))
+      val = - val;
+    return val;
+  }
+
+  octave_int<T> signum (void) const 
+  { 
+    T val = value (); 
+    if (val < static_cast <T> (0))
+      val = - static_cast <T> (1);
+    else if (val > static_cast <T> (0))
+      val = static_cast <T> (1);
+    return val;
+  }
+
   octave_int<T> min (void) const { return std::numeric_limits<T>::min (); }
   octave_int<T> max (void) const { return std::numeric_limits<T>::max (); }
 
   static int nbits (void) { return sizeof (T) * CHAR_BIT; }
 
   static int byte_size (void) { return sizeof(T); }
 
   // Unsafe.  This function exists to support the MEX interface.
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,141 @@
+2008-02-20  John W. Eaton  <jwe@octave.org>
+
+	* ov-bool-mat.h (octave_bool_matrix (const Array2<bool>&)): Delete.
+
+2008-02-20  David Bateman  <dbateman@free.fr>
+
+	* Makefile.in (OV_SRC): Remove ov-mapper.cc.
+	(OV_INCLUDES): Remove ov-mapper.h.
+	(DEFUN_PATTERN): No longer accept DEFUN_MAPPER as valid.
+	* ov-mapper.cc, ov-mapepr.h: Delete, remove all includes of
+	ov-mapper.h from all files.
+
+	* op-b-sbm.cc, op-bm-sbm.cc, op-smb-b.cc, op-sbm-bm.cc: Include 
+	ov-bool-sparse.h.
+
+	* defun-int.h (DEFUN_MAPPER_INTERNAL, install_builtin_mapper):
+	Remove.
+	* defun.cc (install_builtin_mapper): Ditto.
+	* defun.h (DEFUN_MAPPER): Remove.
+
+	* mappers.cc: Rewrite all mapper function using DEFUN and newly
+	introduced octave_value mapper functions.
+	(dummyp, xabs, xisalnum, xisascii, xiscntrl, xisdigit,
+	xisgraph, xislower, xisprint, xispunct, xisspace, xisupper,
+	xtoascii, xtolower, xtoupper, xconj, ximag, xreal): Remove
+	static wrapper functions.
+
+	* mkbuiltins (XDEFUN_MAPPER_INTERNAL, install_builtin_functions): 
+	Remove.
+	* mkgendoc (XDEFUN_MAPPER_INTERNAL): Remove.
+
+	* ov.cc (octave_mapper::register_type): Remove.
+	
+	* ov.h (abs, acos, acosh, angle, arg, asin, asinh, atan, atanh,
+	ceil, conj, cos, cosh, erf, erfc, exp, finite, fix, floor, gamma,
+	imag, isinf, isna, isnan, lgamma, log, log10, real, round, signum,
+	sin, sinh, sqrt, tan, tanh, isalnum, isalpha, isascii, iscntrl,
+	isdigit, isgraph, islower, isprint, ispunct, isspace, isupper,
+	isxdigit, toascii, tolower, toupper):
+	New octave_value mapper	functions.
+
+	* ov-base.h (abs, acos, acosh, angle, arg, asin, asinh, atan,
+	atanh, ceil, conj, cos, cosh, erf, erfc, exp, finite, fix, floor,
+	gamma, imag, isinf, isna, isnan, lgamma, log, log10, real, round,
+	signum, sin, sinh, sqrt, tan, tanh, isalnum, isalpha, isascii,
+	iscntrl, isdigit, isgraph, slower, isprint, ispunct, isspace,
+	isupper, isxdigit, toascii, tolower, toupper):
+	New virtual mapper functions.
+	* ov-base.cc (abs, acos, acosh, angle, arg, asin, asinh, atan,
+	atanh, ceil, conj, cos, cosh, erf, erfc, exp, finite, fix, floor,
+	gamma, imag, isinf, isna, isnan, lgamma, log, log10, real, round,
+	signum, sin, sinh, sqrt, tan, tanh, isalnum, isalpha, isascii,
+	iscntrl, isdigit, isgraph, slower, isprint, ispunct, isspace,
+	isupper, isxdigit, toascii, tolower, toupper):
+	Base versions of mapper functions.
+
+	* ov-bool-mat.h (abs, acos, acosh, angle, arg, asin, asinh, atan,
+	atanh, ceil, conj, cos, cosh, erf, erfc, exp, finite, fix, floor,
+	gamma, imag, isinf, isna, isnan, lgamma, log, log10, real, round,
+	signum, sin, sinh, sqrt, tan, tanh):
+	Mapper function recast boolen matrix as double.
+	* ov-bool.h (abs, acos, acosh, angle, arg, asin, asinh, atan,
+	atanh, ceil, conj, cos, cosh, erf, erfc, exp, finite, fix, floor,
+	gamma, imag, isinf, isna, isnan, lgamma, log, log10, real, round,
+	signum, sin, sinh, sqrt, tan, tanh): Ditto.
+	* ov-bool-sparse.h (abs, acos, acosh, angle, arg, asin, asinh,
+	atan, atanh, ceil, conj, cos, cosh, erf, erfc, exp, finite, fix,
+	floor, gamma, imag, isinf, isna, isnan, lgamma, log, log10, real,
+	round, signum, sin, sinh, sqrt, tan, tanh): Ditto.
+	(char_array_value): New method to convert to charNDArray.
+	* ov-bool-sparse.cc (char_array_value): New method to convert to
+	charNDArray.
+	* ov-complex.cc (char_array_value): ditto.
+	(xabs, ximag, xreal): Static wrapper functions.
+	(abs, acos, acosh, angle, arg, asin, asinh, atan, atanh, ceil,
+	conj, cos, cosh, exp, finite, fix, floor, imag, isinf, isna,
+	isnan, log, log10, real, round, signum, sin, sinh, sqrt, tan,
+	tanh): New mapper methods.
+	* ov-complex.h: Provide decls.
+
+	* ov-cx-mat.cc (char_array_value): New method to convert to
+	charNDArray.
+	(xabs, ximag, xreal): Static wrapper functions.
+	(abs, acos, acosh, angle, arg, asin, asinh, atan, atanh, ceil,
+	conj, cos, cosh, exp, finite, fix, floor, imag, isinf, isna,
+	isnan, log, log10, real, round, signum, sin, sinh, sqrt, tan,
+	tanh): New mapper methods.
+	* ov-cx-mat.h: Provide decls.
+	
+	* ov-cx-sparse.cc (char_array_value): New method to convert to
+	charNDArray.
+	(xabs, ximag, xreal): Static wrapper functions.
+	(abs, acos, acosh, angle, arg, asin, asinh, atan, atanh, ceil,
+	conj, cos, cosh, exp, finite, fix, floor, imag, isinf, isna,
+	isnan, log, log10, real, round, signum, sin, sinh, sqrt, tan,
+	tanh): New mapper methods.
+	* ov-cx-sparse.h: Provide decls.
+
+	* ov-intx.h (abs, signum, imag, ceil, conj, fix, floor, real,
+	round, finite, isinf, isna, isnan): Define for both matrix and
+	scalar classes.
+	
+	* ov-range.h (abs, acos, acosh, angle, arg, asin, asinh, atan,
+	atanh, ceil, conj, cos, cosh, erf, erfc, exp, finite, fix, floor,
+	gamma, imag, isinf, isna, isnan, lgamma, log, log10, real, round,
+	signum, sin, sinh, sqrt, tan, tanh): New mapper functions.
+
+	* ov-re-mat.cc (any_element_less_than): Static function to check if
+	any elemet was less than a value,
+	(any_element_greater_than): Ditto with greater than.
+	(abs, acos, acosh, angle, arg, asin, asinh, atan, atanh, ceil,
+	conj, cos, cosh, erf, erfc, exp, finite, fix, floor, gamma, imag,
+	isinf, isna, isnan, lgamma, log, log10, real, round, signum, sin,
+	sinh, sqrt, tan, tanh): New mapper functions.
+	* ov-re-mat.h: Provide decls.
+	
+	* ov-scalar.cc (any_element_less_than): Static function to check if
+	any elemet was less than a value,
+	(any_element_greater_than): ditto with greater than.
+	(abs acos acosh angle arg asin asinh atan atanh 
+	ceil conj cos cosh erf erfc exp finite fix floor gamma imag 
+	isinf isna isnan lgamma log log10 real round signum sin sinh 
+	sqrt tan tanh): New mapper functions.
+	* ov-scalar.h: Provide decls.
+
+	* ov-str-mat.cc (xisalnum, xisascii, xiscntrl, xisdigit,
+	xisgraph, xislower, xisprint, xispunct, xisspace, xisupper,
+	xtoascii, xtolower, xtoupper): New static wrapper functions.
+	(isalnum, isalpha, isascii, iscntrl, isdigit, isgraph, islower,
+	isprint, ispunct, isspace, isupper, isxdigit, toascii, tolower,
+	toupper): New mapper methods.
+	* ov-str-mat.h: Provide decls.
+
 2008-02-18  David Bateman  <dbateman@free.fr>
 
 	* data.cc (Fatan2): Reject arguments that are integer types.
 
 2008-02-19  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/qr.cc: Doc fix.
 
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -96,17 +96,17 @@ OV_INTTYPE_INC := ov-base-int.h ov-int-t
 	ov-int8.h ov-int16.h ov-int32.h ov-int64.h \
 	ov-uint8.h ov-uint16.h ov-uint32.h ov-uint64.h
 
 OV_INCLUDES := ov-re-mat.h ov-cx-mat.h ov-ch-mat.h ov-cs-list.h ov-list.h \
 	ov-struct.h ov-scalar.h ov-range.h ov-complex.h \
 	ov-colon.h ov-base.h ov-base-mat.h ov-base-scalar.h \
 	ov-streamoff.h ov-str-mat.h ov-bool-mat.h ov-bool.h \
 	ov-cell.h ov.h ov-fcn.h ov-builtin.h ov-dld-fcn.h \
-	ov-mapper.h ov-mex-fcn.h ov-usr-fcn.h ov-fcn-handle.h \
+	ov-mex-fcn.h ov-usr-fcn.h ov-fcn-handle.h \
 	ov-fcn-inline.h ov-class.h ov-typeinfo.h ov-type-conv.h \
 	$(OV_INTTYPE_INC)
 
 OV_SPARSE_INCLUDES := \
 	ov-base-sparse.h ov-bool-sparse.h ov-cx-sparse.h ov-re-sparse.h
 
 PT_INCLUDES := pt.h pt-all.h pt-arg-list.h pt-assign.h pt-binop.h \
         pt-bp.h	pt-cell.h pt-check.h pt-cmd.h pt-colon.h pt-const.h \
@@ -167,17 +167,17 @@ OV_INTTYPE_SRC := \
 OV_SPARSE_SRC := \
 	ov-base-sparse.cc ov-bool-sparse.cc ov-cx-sparse.cc ov-re-sparse.cc
 
 OV_SRC := ov-base.cc ov-ch-mat.cc \
 	ov-cs-list.cc ov-list.cc ov-re-mat.cc ov-cx-mat.cc \
 	ov-range.cc ov-scalar.cc ov-complex.cc ov-str-mat.cc \
 	ov-streamoff.cc ov-struct.cc \
 	ov-colon.cc ov-bool-mat.cc ov-bool.cc ov-cell.cc \
-	ov.cc ov-fcn.cc ov-builtin.cc ov-dld-fcn.cc ov-mapper.cc \
+	ov.cc ov-fcn.cc ov-builtin.cc ov-dld-fcn.cc \
 	ov-mex-fcn.cc ov-usr-fcn.cc ov-fcn-handle.cc ov-fcn-inline.cc \
 	ov-class.cc ov-typeinfo.cc \
 	$(OV_INTTYPE_SRC) \
 	$(OV_SPARSE_SRC)
 
 PT_SRC := pt.cc pt-arg-list.cc pt-assign.cc pt-bp.cc pt-binop.cc \
 	pt-cell.cc pt-check.cc pt-cmd.cc pt-colon.cc pt-const.cc \
 	pt-decl.cc pt-except.cc pt-exp.cc pt-fcn-handle.cc pt-id.cc \
@@ -232,17 +232,17 @@ DEP_3 := $(patsubst %.l, %.cc, $(DEP_4))
 DEP_2 := $(patsubst %.y, %.cc, $(DEP_3))
 DEP_1 := $(patsubst %.c, %.d, $(DEP_2))
 MAKEDEPS := $(patsubst %.cc, %.d, $(DEP_1))
 
 # Some stupid egreps don't like empty elements in alternation patterns,
 # so we have to repeat ourselves because some stupid egreps don't like
 # empty elements in alternation patterns.
 
-DEFUN_PATTERN = "^[ \t]*DEF(CONSTFUN|CMD|UN|UN_DLD|UNX_DLD|UN_TEXT|UN_MAPPER)[ \t]*\\("
+DEFUN_PATTERN = "^[ \t]*DEF(CONSTFUN|CMD|UN|UN_DLD|UNX_DLD|UN_TEXT)[ \t]*\\("
 
 DLD_DEF_FILES_1 := $(patsubst %.l, %.df, $(DLD_XSRC))
 DLD_DEF_FILES := $(patsubst %.cc, %.df, $(DLD_DEF_FILES_1))
 
 DEF_4 := $(addprefix $(srcdir)/, $(SOURCES))
 DEF_3 := $(notdir $(shell egrep -l $(DEFUN_PATTERN) $(DEF_4)))
 DEF_2 := $(patsubst %.y, %.df, $(DEF_3))
 DEF_1 := $(patsubst %.l, %.df, $(DEF_2))
diff --git a/src/OPERATORS/op-b-sbm.cc b/src/OPERATORS/op-b-sbm.cc
--- a/src/OPERATORS/op-b-sbm.cc
+++ b/src/OPERATORS/op-b-sbm.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-scalar.h"
 #include "ops.h"
 
 #include "ov-re-sparse.h"
+#include "ov-bool-sparse.h"
 
 // bool by sparse bool matrix ops.
 
 DEFBINOP_FN (ne, bool, sparse_bool_matrix, mx_el_ne)
 DEFBINOP_FN (eq, bool, sparse_bool_matrix, mx_el_eq)
 
 DEFBINOP_FN (el_and, bool, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or, bool, sparse_bool_matrix, mx_el_or)
diff --git a/src/OPERATORS/op-bm-sbm.cc b/src/OPERATORS/op-bm-sbm.cc
--- a/src/OPERATORS/op-bm-sbm.cc
+++ b/src/OPERATORS/op-bm-sbm.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-bool-mat.h"
 #include "boolMatrix.h"
 #include "ov-scalar.h"
 #include "ops.h"
 
 #include "ov-re-sparse.h"
+#include "ov-bool-sparse.h"
 #include "smx-bm-sbm.h"
 #include "smx-sbm-bm.h"
 
 // bool matrix by sparse bool matrix ops.
 
 DEFBINOP_FN (eq, bool_matrix, sparse_bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, bool_matrix, sparse_bool_matrix, mx_el_ne)
 
diff --git a/src/OPERATORS/op-sbm-b.cc b/src/OPERATORS/op-sbm-b.cc
--- a/src/OPERATORS/op-sbm-b.cc
+++ b/src/OPERATORS/op-sbm-b.cc
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-bool.h"
 #include "ov-scalar.h"
 #include "ops.h"
 
 #include "ov-re-sparse.h"
+#include "ov-bool-sparse.h"
 
 // sparse bool matrix by bool ops.
 
 DEFBINOP_FN (ne, sparse_bool_matrix, bool, mx_el_ne)
 DEFBINOP_FN (eq, sparse_bool_matrix, bool, mx_el_eq)
 
 DEFBINOP_FN (el_and, sparse_bool_matrix, bool, mx_el_and)
 DEFBINOP_FN (el_or, sparse_bool_matrix, bool, mx_el_or)
diff --git a/src/OPERATORS/op-sbm-bm.cc b/src/OPERATORS/op-sbm-bm.cc
--- a/src/OPERATORS/op-sbm-bm.cc
+++ b/src/OPERATORS/op-sbm-bm.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-bool-mat.h"
 #include "boolMatrix.h"
 #include "ov-scalar.h"
 #include "ops.h"
 
 #include "ov-re-sparse.h"
+#include "ov-bool-sparse.h"
 #include "smx-bm-sbm.h"
 #include "smx-sbm-bm.h"
 
 // sparse bool matrix by bool matrix ops.
 
 DEFBINOP_FN (eq, sparse_bool_matrix, bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, sparse_bool_matrix, bool_matrix, mx_el_ne)
 
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -23,31 +23,27 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_defun_int_h)
 #define octave_defun_int_h 1
 
 #include <string>
 
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
-#include "ov-mapper.h"
 #include "symtab.h"
 #include "version.h"
 
 class octave_value;
 
 extern OCTINTERP_API void print_usage (void);
 extern OCTINTERP_API void print_usage (const std::string&) GCC_ATTR_DEPRECATED;
 
 extern OCTINTERP_API void check_version (const std::string& version, const std::string& fcn);
 
 extern OCTINTERP_API void
-install_builtin_mapper (octave_mapper *mf, const std::string& name);
-
-extern OCTINTERP_API void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
 			  const std::string& doc, bool is_text_fcn = false,
 			  bool can_hide_function = true);
 
 extern OCTINTERP_API void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
 		      const octave_shlib& shl,
 		      const std::string& doc, bool is_text_fcn = false,
@@ -174,25 +170,16 @@ typedef octave_function * (*octave_dld_f
 
 // Generate code for making another name for an existing function.
 
 #define DEFALIAS_INTERNAL(alias, name) \
   BEGIN_INSTALL_BUILTIN \
     XDEFALIAS_INTERNAL(alias, name) \
   END_INSTALL_BUILTIN
 
-#define DEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
-			      d_c_map, c_c_map, lo, hi, \
-			      ch_map_flag, can_ret_cmplx_for_real, doc) \
-  BEGIN_INSTALL_BUILTIN \
-    XDEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
-		           d_c_map, c_c_map, lo, hi, \
-			   ch_map_flag, can_ret_cmplx_for_real, doc) \
-  END_INSTALL_BUILTIN
-
 #else /* ! MAKE_BUILTINS */
 
 // Generate the first line of the function definition.  This ensures
 // that the internal functions all have the same signature.
 
 #define DEFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
   DECLARE_FUN (name, args_name, nargout_name)
 
@@ -202,30 +189,16 @@ typedef octave_function * (*octave_dld_f
 #define DEFUNX_INTERNAL(name, fname, args_name, nargout_name, \
 			is_text_fcn, doc) \
   DECLARE_FUNX (fname, args_name, nargout_name)
 
 // No definition is required for an alias.
 
 #define DEFALIAS_INTERNAL(alias, name)
 
-// How mapper functions are actually installed.
-
-// FIXME -- Really want to avoid the following casts, since
-// (as always with casts) it may mask some real errors...
-
-#define DEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
-			      d_c_map, c_c_map, lo, hi, \
-			      ch_map_flag, can_ret_cmplx_for_real, doc) \
-  install_builtin_mapper \
-    (new octave_mapper \
-       (ch_map, d_b_map, c_b_map, d_d_map, d_c_map, c_c_map, \
-        lo, hi, ch_map_flag, can_ret_cmplx_for_real, #name, doc), \
-     #name)
-
 #endif /* ! MAKE_BUILTINS */
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -32,17 +32,16 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "help.h"
 #include "ov.h"
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-fcn.h"
-#include "ov-mapper.h"
 #include "ov-mex-fcn.h"
 #include "ov-usr-fcn.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "symtab.h"
 #include "toplev.h"
 #include "variables.h"
 
@@ -124,22 +123,16 @@ check_version (const std::string& versio
 	     "       you can fix this problem by recompiling this .oct file",
 	     version.c_str (), fcn.c_str (), OCTAVE_API_VERSION);
     }
 }
 
 // Install variables and functions in the symbol tables.
 
 void
-install_builtin_mapper (octave_mapper *mf, const std::string& name)
-{
-  symbol_table::install_built_in_function (name, octave_value (mf));
-}
-
-void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
 			  const std::string& doc, bool is_text_fcn,
 			  bool /* can_hide_function -- not yet implemented */)
 {
   octave_value fcn (new octave_builtin (f, name, doc));
 
   symbol_table::install_built_in_function (name, fcn);
 
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -65,64 +65,16 @@ along with Octave; see the file COPYING.
 // For backward compatibility.
 
 #define DEFUN_TEXT DEFCMD
 
 // This is a function with a name that can't be hidden by a variable.
 #define DEFCONSTFUN(name, args_name, nargout_name, doc) \
   DEFCONSTFUN_INTERNAL (name, args_name, nargout_name, true, doc)
 
-// Define a mapper function.
-//
-//   name is the name of the function, unquoqted.
-//
-//   ch_map is a pointer to a function that should be called for
-//     integer arguments that are expected to create integer results.
-//     (It's a kluge to handle character mappers like isalpha.)
-//
-//   d_b_map is a pointer to a function that should be called for real
-//     arguments that are expected to create bool results.
-//
-//   c_b_map is a pointer to a function that should be called for
-//     complex arguments that are expected to create bool results.
-//
-//   d_d_map is a pointer to a function that should be called for real
-//     arguments that are expected to create real results.
-//
-//   c_d_map is a pointer to a function that should be called for
-//     complex arguments that are expected to create real results.
-//
-//   c_c_map is a pointer to a function that should be called for
-//     complex arguments that are expected to create complex results.
-//
-//   lo is the lower bound of the range for which real arguments
-//     return real results (e.g., lo == 0 for sqrt).
-//
-//   hi is the upper bound of the range for which real arguments
-//     return real results (e.g., hi == Inf for sqrt).
-//
-//   ch_map_flag has the following meanings for the ch_map function:
-//
-//     0  =>  this function returns a matrix of ones and zeros
-//     1  =>  this function returns a numeric matrix (any values)
-//     2  =>  this function returns a std::string array
-//
-//   can_ret_cmplx_for_real is a flag that says whether this function
-//     can create a complex number given a real-valued  argument
-//     (e.g., sqrt (-1)).
-//
-//   doc is the simple help text for the function.
-
-#define DEFUN_MAPPER(name, ch_map, d_b_map, c_b_map, d_d_map, \
-		     c_d_map, c_c_map, lo, hi, ch_map_flag, \
-		     can_ret_cmplx_for_real, doc) \
-  DEFUN_MAPPER_INTERNAL (name, ch_map, d_b_map, c_b_map, d_d_map, \
-			 c_d_map, c_c_map, lo, hi, ch_map_flag, \
-			 can_ret_cmplx_for_real, doc)
-
 // Make alias another name for the existing function name.  This macro
 // must be used in the same file where name is defined, after the
 // definition for name.
 
 #define DEFALIAS(alias, name) \
   DEFALIAS_INTERNAL (alias, name)
 
 #endif
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -29,158 +29,19 @@ along with Octave; see the file COPYING.
 #include <cfloat>
 
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
-#include "ov-mapper.h"
 #include "variables.h"
 
-// FIXME -- perhaps this could be avoided by determining
-// whether the is* functions are actually functions or just macros.
-
-static int
-xabs (int c)
-{
-  return static_cast<unsigned char> (c);
-}
-
-static int
-xisalnum (int c)
-{
-  return isalnum (c);
-}
-
-static int
-xisalpha (int c)
-{
-  return isalpha (c);
-}
-
-static int
-xisascii (int c)
-{
-  return isascii (c);
-}
-
-static int
-xiscntrl (int c)
-{
-  return iscntrl (c);
-}
-
-static int
-xisdigit (int c)
-{
-  return isdigit (c);
-}
-
-static int
-xisgraph (int c)
-{
-  return isgraph (c);
-}
-
-static int
-xislower (int c)
-{
-  return islower (c);
-}
-
-static int
-xisprint (int c)
-{
-  return isprint (c);
-}
-
-static int
-xispunct (int c)
-{
-  return ispunct (c);
-}
-
-static int
-xisspace (int c)
-{
-  return isspace (c);
-}
-
-static int
-xisupper (int c)
-{
-  return isupper (c);
-}
-
-static int
-xisxdigit (int c)
-{
-  return isxdigit (c);
-}
-
-static int
-xtoascii (int c)
-{
-  return toascii (c);
-}
-
-static int
-xtolower (int c)
-{
-  return tolower (c);
-}
-
-static int
-xtoupper (int c)
-{
-  return toupper (c);
-}
-
-static double
-xabs (const Complex& x)
-{
-  return (xisinf (x.real ()) || xisinf (x.imag ())) ? octave_Inf : abs (x);
-}
-
-static Complex
-xconj (const Complex& x)
-{
-  return conj (x);
-}
-
-static double
-xconj (double x)
-{
-  return x;
-}
-
-static double
-ximag (const Complex& x)
-{
-  return x.imag ();
-}
-
-static double
-xreal (const Complex& x)
-{
-  return x.real ();
-}
-
-static int
-dummyp (int)
-{
-  return 0;
-}
-
-void
-install_mapper_functions (void)
-{
-  DEFUN_MAPPER (abs, xabs, 0, 0, fabs, xabs, 0, 0.0, 0.0, 1, 0,
+DEFUN (abs, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} abs (@var{z})\n\
 Compute the magnitude of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $|z| = \\sqrt{x^2 + y^2}$.\n\
 @end tex\n\
 @end iftex\n\
@@ -191,37 +52,74 @@ Compute the magnitude of @var{z}, define
 For example,\n\
 \n\
 @example\n\
 @group\n\
 abs (3 + 4i)\n\
      @result{} 5\n\
 @end group\n\
 @end example\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).abs ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (acos, 0, 0, 0, acos, 0, acos, -1.0, 1.0, 0, 1,
+  return retval;
+}
+
+DEFUN (acos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acos (@var{x})\n\
 Compute the inverse cosine of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).acos ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (acosh, 0, 0, 0, acosh, 0, acosh, 1.0, octave_Inf, 0, 1,
+  return retval;
+}
+
+
+DEFUN (acosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).acosh ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (angle, 0, 0, 0, arg, std::arg, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (angle, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} angle (@var{z})\n\
 See arg.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).arg ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (arg, 0, 0, 0, arg, std::arg, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (arg, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} arg (@var{z})\n\
 @deftypefnx {Mapping Function} {} angle (@var{z})\n\
 Compute the argument of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $\\theta = \\tan^{-1}(y/x)$.\n\
 @end tex\n\
@@ -235,88 +133,169 @@ in radians. \n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 arg (3 + 4i)\n\
      @result{} 0.92730\n\
 @end group\n\
 @end example\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).arg ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (asin, 0, 0, 0, asin, 0, asin, -1.0, 1.0, 0, 1,
+  return retval;
+}
+
+DEFUN (asin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
 Compute the inverse sine of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).asin ();
+  else
+    print_usage ();
+
+  return retval;
+}
 
 /*
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [0, pi/6, pi/4, pi/3, pi/2, pi/3, pi/4, pi/6, 0];
 %! x = [0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0];
 %! assert(all (abs (asin (x) - v) < sqrt (eps)));
 %!error asin ();
 %!error asin (1, 2);
 */
 
-  DEFUN_MAPPER (asinh, 0, 0, 0, asinh, 0, asinh, 0.0, 0.0, 0, 0,
+DEFUN (asinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asinh (@var{x})\n\
 Compute the inverse hyperbolic sine of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).asinh ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (atan, 0, 0, 0, atan, 0, atan, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (atan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
 Compute the inverse tangent of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).atan ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (atanh, 0, 0, 0, atanh, 0, atanh, -1.0, 1.0, 0, 1,
+  return retval;
+}
+
+DEFUN (atanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tangent of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).atanh ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (ceil, 0, 0, 0, ceil, 0, ceil, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (ceil, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).ceil ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (conj, 0, 0, 0, xconj, 0, xconj, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (conj, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} conj (@var{z})\n\
 Return the complex conjugate of @var{z}, defined as\n\
 @iftex\n\
 @tex\n\
 $\\bar{z} = x - iy$.\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
 @end ifinfo\n\
 @seealso{real, imag}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).conj ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (cos, 0, 0, 0, cos, 0, std::cos, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (cos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cos (@var{x})\n\
 Compute the cosine of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).cos ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (cosh, 0, 0, 0, cosh, 0, std::cosh, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (cosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).cosh ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (erf, 0, 0, 0, erf, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (erf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erf (@var{z})\n\
 Computes the error function,\n\
 @iftex\n\
 @tex\n\
 $$\n\
  {\\rm erf} (z) = {2 \\over \\sqrt{\\pi}}\\int_0^z e^{-t^2} dt\n\
 $$\n\
@@ -328,69 +307,124 @@ Computes the error function,\n\
                          z\n\
                         /\n\
 erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
                         /\n\
                      t=0\n\
 @end smallexample\n\
 @end ifinfo\n\
 @seealso{erfc, erfinv}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).erf ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (erfc, 0, 0, 0, erfc, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (erfc, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Computes the complementary error function,\n\
 @iftex\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
 @code{1 - erf (@var{z})}.\n\
 @end ifinfo\n\
 @seealso{erf, erfinv}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).erfc ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (exp, 0, 0, 0, exp, 0, std::exp, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (exp, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} exp (@var{x})\n\
 Compute the exponential of @var{x}.  To compute the matrix exponential,\n\
 see @ref{Linear Algebra}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).exp ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (finite, dummyp, xfinite, xfinite, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (finite, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} finite (@var{x})\n\
 Return 1 for elements of @var{x} that are finite values and zero\n\
 otherwise. For example,\n\
 \n\
 @example\n\
 @group\n\
 finite ([13, Inf, NA, NaN])\n\
      @result{} [ 1, 0, 0, 0 ]\n\
 @end group\n\
 @end example\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).finite ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (fix, 0, 0, 0, fix, 0, fix, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (fix, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
 Truncate @var{x} toward zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).fix ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (floor, 0, 0, 0, floor, 0, floor, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+
+DEFUN (floor, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} floor (@var{x})\n\
 Return the largest integer not greater than @var{x}.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).floor ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (gamma, 0, 0, 0, xgamma, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (gamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} gamma (@var{z})\n\
 Computes the Gamma function,\n\
 @iftex\n\
 @tex\n\
 $$\n\
  \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
 $$\n\
@@ -402,187 +436,385 @@ Computes the Gamma function,\n\
             infinity\n\
             /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
             /\n\
          t=0\n\
 @end example\n\
 @end ifinfo\n\
 @seealso{gammai, lgamma}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).gamma ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (imag, 0, 0, 0, imag, ximag, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (imag, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
 @seealso{real, conj}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).imag ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isalnum, xisalnum, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isalnum, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
 Return 1 for characters that are letters or digits (@code{isalpha\n\
 (@var{s})} or @code{isdigit (@var{s})} is true).\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isalnum ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isalpha, xisalpha, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isalpha, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalpha (@var{s})\n\
 @deftypefnx {Mapping Function} {} isletter (@var{s})\n\
 Return true for characters that are letters (@code{isupper (@var{s})}\n\
 or @code{islower (@var{s})} is true).\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isalpha ();
+  else
+    print_usage ();
+
+  return retval;
+}
 
 #ifdef isascii
 #undef isascii
 #endif
 
-  DEFUN_MAPPER (isascii, xisascii, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+DEFUN (isascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isascii (@var{s})\n\
 Return 1 for characters that are ASCII (in the range 0 to 127 decimal).\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isascii ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (iscntrl, xiscntrl, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (iscntrl, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} iscntrl (@var{s})\n\
 Return 1 for control characters.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).iscntrl ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isdigit, xisdigit, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isdigit (@var{s})\n\
 Return 1 for characters that are decimal digits.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isdigit ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isinf, dummyp, xisinf, xisinf, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isinf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isinf (@var{x})\n\
 Return 1 for elements of @var{x} that are infinite and zero\n\
 otherwise. For example,\n\
 \n\
 @example\n\
 @group\n\
 isinf ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isinf ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isgraph, xisgraph, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isgraph, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isgraph (@var{s})\n\
 Return 1 for printable characters (but not the space character).\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isgraph ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (islower, xislower, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (islower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} islower (@var{s})\n\
 Return 1 for characters that are lower case letters.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).islower ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isna, dummyp, octave_is_NA, octave_is_NA, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isna, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isna (@var{x})\n\
 Return 1 for elements of @var{x} that are NA (missing) values and zero\n\
 otherwise.  For example,\n\
 \n\
 @example\n\
 @group\n\
 isna ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 0, 1, 0 ]\n\
 @end group\n\
 @end example\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isna ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isnan, dummyp, xisnan, xisnan, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isnan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isnan (@var{x})\n\
 Return 1 for elements of @var{x} that are NaN values and zero\n\
 otherwise.  NA values are also considered NaN values.  For example,\n\
 \n\
 @example\n\
 @group\n\
 isnan ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 0, 1, 1 ]\n\
 @end group\n\
 @end example\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isnan ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isprint, xisprint, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isprint, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isprint (@var{s})\n\
 Return 1 for printable characters (including the space character).\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isprint ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (ispunct, xispunct, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (ispunct, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ispunct (@var{s})\n\
 Return 1 for punctuation characters.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).ispunct ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isspace, xisspace, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isspace, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isspace (@var{s})\n\
 Return 1 for whitespace characters (space, formfeed, newline,\n\
 carriage return, tab, and vertical tab).\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isspace ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isupper, xisupper, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isupper (@var{s})\n\
 Return 1 for upper case letters.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isupper ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (isxdigit, xisxdigit, 0, 0, 0, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (isxdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isxdigit (@var{s})\n\
 Return 1 for characters that are hexadecimal digits.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).isxdigit ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (lgamma, 0, 0, 0, xlgamma, 0, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (lgamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} lgamma (@var{x})\n\
 @deftypefnx {Mapping Function} {} gammaln (@var{x})\n\
 Return the natural logarithm of the absolute value of the gamma\n\
 function of @var{x}.\n\
 @seealso{gamma, gammai}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).lgamma ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (log, 0, 0, 0, log, 0, std::log, 0.0, octave_Inf, 0, 1,
+  return retval;
+}
+
+DEFUN (log, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log (@var{x})\n\
 Compute the natural logarithm for each element of @var{x}.  To compute the\n\
 matrix logarithm, see @ref{Linear Algebra}.\n\
 @seealso{log2, log10, logspace, exp}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).log ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (log10, 0, 0, 0, log10, 0, std::log10, 0.0, octave_Inf, 0, 1,
+  return retval;
+}
+
+DEFUN (log10, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm for each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).log10 ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (real, 0, 0, 0, real, xreal, 0, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (real, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
 @seealso{imag, conj}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).real ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (round, 0, 0, 0, xround, 0, xround, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (round, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.\n\
 @seealso{rem}\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).round ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (sign, 0, 0, 0, signum, 0, signum, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (sign, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sign (@var{x})\n\
 Compute the @dfn{signum} function, which is defined as\n\
 @iftex\n\
 @tex\n\
 $$\n\
 {\\rm sign} (@var{x}) = \\cases{1,&$x>0$;\\cr 0,&$x=0$;\\cr -1,&$x<0$.\\cr}\n\
 $$\n\
@@ -593,100 +825,178 @@ Compute the @dfn{signum} function, which
 @example\n\
            -1, x < 0;\n\
 sign (x) =  0, x = 0;\n\
             1, x > 0.\n\
 @end example\n\
 @end ifinfo\n\
 \n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).signum ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (sin, 0, 0, 0, sin, 0, std::sin, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (sin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
 Compute the sine of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).sin ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (sinh, 0, 0, 0, sinh, 0, std::sinh, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (sinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
 Compute the hyperbolic sine of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).sinh ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (sqrt, 0, 0, 0, sqrt, 0, std::sqrt, 0.0, octave_Inf, 0, 1,
+  return retval;
+}
+
+DEFUN (sqrt, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sqrt (@var{x})\n\
 Compute the square root of @var{x}.  If @var{x} is negative, a complex\n\
 result is returned.  To compute the matrix square root, see\n\
 @ref{Linear Algebra}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).sqrt ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (tan, 0, 0, 0, tan, 0, std::tan, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (tan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
 Compute tangent of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).tan ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (tanh, 0, 0, 0, tanh, 0, std::tanh, 0.0, 0.0, 0, 0,
+  return retval;
+}
+
+DEFUN (tanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
 Compute hyperbolic tangent of each element of @var{x}.\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).tanh ();
+  else
+    print_usage ();
+
+  return retval;
+}
 
 #ifdef toascii
 #undef toascii
 #endif
 
-  DEFUN_MAPPER (toascii, xtoascii, 0, 0, 0, 0, 0, 0.0, 0.0, 1, 0,
+DEFUN (toascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} toascii (@var{s})\n\
 Return ASCII representation of @var{s} in a matrix.  For example,\n\
 \n\
 @example\n\
 @group\n\
 toascii (\"ASCII\")\n\
      @result{} [ 65, 83, 67, 73, 73 ]\n\
 @end group\n\
 \n\
 @end example\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).toascii ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (tolower, xtolower, 0, 0, 0, 0, 0, 0.0, 0.0, 2, 0,
+  return retval;
+}
+
+DEFUN (tolower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tolower (@var{s})\n\
 Return a copy of the string @var{s}, with each upper-case character\n\
 replaced by the corresponding lower-case one; nonalphabetic characters\n\
 are left unchanged.  For example,\n\
 \n\
 @example\n\
 tolower (\"MiXeD cAsE 123\")\n\
      @result{} \"mixed case 123\"\n\
 @end example\n\
-@end deftypefn");
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).tolower ();
+  else
+    print_usage ();
 
-  DEFUN_MAPPER (toupper, xtoupper, 0, 0, 0, 0, 0, 0.0, 0.0, 2, 0,
+  return retval;
+}
+
+DEFUN (toupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} toupper (@var{s})\n\
 Return a copy of the string @var{s}, with each  lower-case character\n\
 replaced by the corresponding upper-case one; nonalphabetic characters\n\
 are left unchanged.  For example,\n\
 \n\
 @example\n\
 @group\n\
 toupper (\"MiXeD cAsE 123\")\n\
      @result{} \"MIXED CASE 123\"\n\
 @end group\n\
 @end example\n\
-@end deftypefn");
-
-  DEFALIAS (gammaln, lgamma);
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).toupper ();
+  else
+    print_usage ();
 
-  DEFALIAS (isfinite, finite);
+  return retval;
+}
 
-  // Leave the previous new line, mkgendoc needs it!
-}
+DEFALIAS (gammaln, lgamma);
+
+DEFALIAS (isfinite, finite);
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/mkbuiltins b/src/mkbuiltins
--- a/src/mkbuiltins
+++ b/src/mkbuiltins
@@ -81,50 +81,38 @@ cat << \EOF
   extern DECLARE_FUNX (fname, args_name, nargout_name); \
   install_builtin_function (fname, name, doc, is_text_fcn); \
 
 #define XDEFALIAS_INTERNAL(alias, name) \
   alias_builtin (#alias, #name);
 
 #define XDEFCONST_INTERNAL(name, defn, doc)
 
-#define XDEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
-			       d_c_map, c_c_map, lo, hi, \
-			       ch_map_flag, can_ret_cmplx_for_real, doc)
-
 EOF
 
 for file in $DEF_FILES; do
   fcn=`echo $file | $SED 's,^\./,,; s/\.df//; s/-/_/g'`
   echo "static void"
   echo "install_${fcn}_fcns (void)"
   echo "{"
   cat $file
   echo "}"
   echo ""
 done
 
 cat << \EOF
 
-static void
-install_builtin_functions (void)
+void
+install_builtins (void)
 {
 EOF
 
 for file in $DEF_FILES; do
   fcn=`echo $file | $SED 's,^\./,,; s/\.df//; s/-/_/g'`
   echo "  install_${fcn}_fcns ();"
 done
 
 cat << \EOF
 }
 
-extern void install_mapper_functions (void);
-
-void
-install_builtins (void)
-{
-  install_mapper_functions ();
-  install_builtin_functions ();
-}
 EOF
 
 exit 0
diff --git a/src/mkgendoc b/src/mkgendoc
--- a/src/mkgendoc
+++ b/src/mkgendoc
@@ -63,21 +63,16 @@ cat << \EOF
 #define XDEFALIAS_INTERNAL(alias, name)
 
 #define XDEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
   print_doc_string (#name, doc);
 
 #define XDEFCONST_INTERNAL(name, defn, doc) \
   print_doc_string (#name, doc);
 
-#define XDEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
-			       d_c_map, c_c_map, lo, hi, \
-			       ch_map_flag, can_ret_cmplx_for_real, doc) \
-  print_doc_string (#name, doc);
-
 static void
 print_doc_string (const std::string& name, const std::string& doc)
 {
   std::cout << "";
 
   size_t len = name.length ();
 
   if (name[0] == '"' && name[len-1] == '"')
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -372,17 +372,17 @@ octave_base_value::print_info (std::ostr
       { \
 	if (require_int && D_NINT (d) != d) \
 	  error ("conversion of %g to " #T " value failed", d); \
 	else if (d < MIN_LIMIT) \
 	  retval = MIN_LIMIT; \
 	else if (d > MAX_LIMIT) \
 	  retval = MAX_LIMIT; \
 	else \
-	  retval = static_cast<T> (fix (d)); \
+	  retval = static_cast<T> (::fix (d));	\
       } \
     else \
       gripe_wrong_type_arg ("octave_base_value::" #F "_value ()", \
 			    type_name ()); \
  \
     return retval; \
   }
 
@@ -405,17 +405,17 @@ octave_base_value::nint_value (bool frc_
   if (! error_state)
     {
       if (xisnan (d))
 	{
 	  error ("conversion of NaN to integer value failed");
 	  return retval;
 	}
 
-      retval = static_cast<int> (fix (d));
+      retval = static_cast<int> (::fix (d));
     }
   else
     gripe_wrong_type_arg ("octave_base_value::nint_value ()", type_name ());
 
   return retval;
 }
 
 double
@@ -890,16 +890,412 @@ octave_value
 octave_base_value::sort (Array<octave_idx_type> &, 
 			 octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
   return octave_value();
 }
 
+octave_value
+octave_base_value::abs (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::abs ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::acos (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::acos ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::acosh (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::acosh ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::angle (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::angle ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::arg (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::arg ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::asin (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::asin ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::asinh (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::asinh ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::atan (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::atan ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::atanh (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::atanh ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::ceil (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::ceil ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::conj (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::conj ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::cos (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::cos ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::cosh (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::cosh ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::erf (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::erf ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::erfc (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::erfc ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::exp (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::exp ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::finite (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::finite ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::fix (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::fix ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::floor (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::floor ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::gamma (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::gamma ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::imag (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::imag ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::isinf (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::isinf ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::isna (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::isna ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::isnan (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::isnan ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::lgamma (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::lgamma ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::log (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::log ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::log10 (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::log10 ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::real (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::real ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::round (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::round ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::signum (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::signum ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::sin (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::sin ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::sinh (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::sinh ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::sqrt (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::sqrt ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::tan (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::tan ()", type_name ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::tanh (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::tanh ()", type_name ());
+  return octave_value ();
+}
+
+// String mapper functions, convert to a string
+octave_value
+octave_base_value::isalnum (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.isalnum ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::isalpha (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.isalpha ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::isascii (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.isascii ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::iscntrl (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.iscntrl ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::isdigit (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.isdigit ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::isgraph (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.isgraph ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::islower (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.islower ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::isprint (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.isprint ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::ispunct (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.ispunct ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::isspace (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.isspace ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::isupper (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.isupper ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::isxdigit (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.isxdigit ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::toascii (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.toascii ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::tolower (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.tolower ();
+  else
+    return octave_value ();
+}
+
+octave_value
+octave_base_value::toupper (void) const
+{
+  octave_value tmp = octave_value (char_array_value (true), true);
+  if (! error_state)
+    return tmp.toupper ();
+  else
+    return octave_value ();
+}
+
 void
 octave_base_value::lock (void)
 {
   gripe_wrong_type_arg ("octave_base_value::lock ()", type_name ());
 }
 
 void
 octave_base_value::unlock (void)
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -463,16 +463,67 @@ public:
 			     sortmode mode = ASCENDING) const;
 
   virtual void lock (void);
 
   virtual void unlock (void);
 
   virtual bool islocked (void) const { return false; }
 
+  virtual octave_value abs (void) const;
+  virtual octave_value acos (void) const;
+  virtual octave_value acosh (void) const;
+  virtual octave_value angle (void) const;
+  virtual octave_value arg (void) const;
+  virtual octave_value asin (void) const;
+  virtual octave_value asinh (void) const;
+  virtual octave_value atan (void) const;
+  virtual octave_value atanh (void) const;
+  virtual octave_value ceil (void) const;
+  virtual octave_value conj (void) const;
+  virtual octave_value cos (void) const;
+  virtual octave_value cosh (void) const;
+  virtual octave_value erf (void) const;
+  virtual octave_value erfc (void) const;
+  virtual octave_value exp (void) const;
+  virtual octave_value finite (void) const;
+  virtual octave_value fix (void) const;
+  virtual octave_value floor (void) const;
+  virtual octave_value gamma (void) const;
+  virtual octave_value imag (void) const;
+  virtual octave_value isinf (void) const;
+  virtual octave_value isna (void) const;
+  virtual octave_value isnan (void) const;
+  virtual octave_value lgamma (void) const;
+  virtual octave_value log (void) const;
+  virtual octave_value log10 (void) const;
+  virtual octave_value real (void) const;
+  virtual octave_value round (void) const;
+  virtual octave_value signum (void) const;
+  virtual octave_value sin (void) const;
+  virtual octave_value sinh (void) const;
+  virtual octave_value sqrt (void) const;
+  virtual octave_value tan (void) const;
+  virtual octave_value tanh (void) const;
+  virtual octave_value isalnum (void) const;
+  virtual octave_value isalpha (void) const;
+  virtual octave_value isascii (void) const;
+  virtual octave_value iscntrl (void) const;
+  virtual octave_value isdigit (void) const;
+  virtual octave_value isgraph (void) const;
+  virtual octave_value islower (void) const;
+  virtual octave_value isprint (void) const;
+  virtual octave_value ispunct (void) const;
+  virtual octave_value isspace (void) const;
+  virtual octave_value isupper (void) const;
+  virtual octave_value isxdigit (void) const;
+  virtual octave_value toascii (void) const;
+  virtual octave_value tolower (void) const;
+  virtual octave_value toupper (void) const;
+
 protected:
 
   // This should only be called for derived types.
 
   octave_value numeric_assign (const std::string& type,
 			       const std::list<octave_value_list>& idx,
 			       const octave_value& rhs);
 
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -31,16 +31,17 @@ along with Octave; see the file COPYING.
 
 #include "mx-base.h"
 #include "oct-alloc.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
+#include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 
 #include "MatrixType.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
@@ -59,19 +60,16 @@ public:
     : octave_base_matrix<boolNDArray> (bnda) { }
 
   octave_bool_matrix (const boolMatrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
   octave_bool_matrix (const boolMatrix& bm, const MatrixType& t)
     : octave_base_matrix<boolNDArray> (bm, t) { }
 
-  octave_bool_matrix (const Array2<bool>& a)
-    : octave_base_matrix<boolNDArray> (a) { }
-
   octave_bool_matrix (const octave_bool_matrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
   ~octave_bool_matrix (void) { }
 
   octave_base_value *clone (void) const { return new octave_bool_matrix (*this); }
   octave_base_value *empty_clone (void) const { return new octave_bool_matrix (); }
 
@@ -181,16 +179,62 @@ public:
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   mxArray *as_mxArray (void) const;
 
+  // Mapper functions are converted to double for treatment
+#define BOOL_MAT_MAPPER(MAP) \
+  octave_value MAP (void) const \
+    { \
+      octave_matrix m (array_value ()); \
+      return m.MAP (); \
+    }
+
+  BOOL_MAT_MAPPER (abs)
+  BOOL_MAT_MAPPER (acos)
+  BOOL_MAT_MAPPER (acosh)
+  BOOL_MAT_MAPPER (angle)
+  BOOL_MAT_MAPPER (arg)
+  BOOL_MAT_MAPPER (asin)
+  BOOL_MAT_MAPPER (asinh)
+  BOOL_MAT_MAPPER (atan)
+  BOOL_MAT_MAPPER (atanh)
+  BOOL_MAT_MAPPER (ceil)
+  BOOL_MAT_MAPPER (conj)
+  BOOL_MAT_MAPPER (cos)
+  BOOL_MAT_MAPPER (cosh)
+  BOOL_MAT_MAPPER (erf)
+  BOOL_MAT_MAPPER (erfc)
+  BOOL_MAT_MAPPER (exp)
+  BOOL_MAT_MAPPER (finite)
+  BOOL_MAT_MAPPER (fix)
+  BOOL_MAT_MAPPER (floor)
+  BOOL_MAT_MAPPER (gamma)
+  BOOL_MAT_MAPPER (imag)
+  BOOL_MAT_MAPPER (isinf)
+  BOOL_MAT_MAPPER (isna)
+  BOOL_MAT_MAPPER (isnan)
+  BOOL_MAT_MAPPER (lgamma)
+  BOOL_MAT_MAPPER (log)
+  BOOL_MAT_MAPPER (log10)
+  BOOL_MAT_MAPPER (real)
+  BOOL_MAT_MAPPER (round)
+  BOOL_MAT_MAPPER (signum)
+  BOOL_MAT_MAPPER (sin)
+  BOOL_MAT_MAPPER (sinh)
+  BOOL_MAT_MAPPER (sqrt)
+  BOOL_MAT_MAPPER (tan)
+  BOOL_MAT_MAPPER (tanh)
+
+#undef BOOL_MAT_MAPPER
+
 protected:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -166,16 +166,30 @@ octave_sparse_bool_matrix::complex_array
 }
 
 NDArray 
 octave_sparse_bool_matrix::array_value (bool) const
 {
   return NDArray (Matrix(matrix.matrix_value ()));
 }
 
+charNDArray
+octave_sparse_bool_matrix::char_array_value (bool) const
+{
+  charNDArray retval (dims (), 0);
+  octave_idx_type nc = matrix.cols ();
+  octave_idx_type nr = matrix.rows ();
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
+      retval(matrix.ridx(i) + nr * j) = static_cast<char>(matrix.data (i));
+
+  return retval;
+}
+
 boolMatrix 
 octave_sparse_bool_matrix::bool_matrix_value (bool) const
 { 
   return matrix.matrix_value (); 
 }
 
 boolNDArray 
 octave_sparse_bool_matrix::bool_array_value (bool) const
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -107,16 +107,18 @@ public:
   NDArray array_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
 
+  charNDArray char_array_value (bool = false) const;
+
   boolMatrix bool_matrix_value (bool = false) const;
 
   boolNDArray bool_array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
@@ -133,16 +135,62 @@ public:
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
   mxArray *as_mxArray (void) const;
 
+  // Mapper functions are converted to double for treatment
+#define BOOL_SPARSE_MAPPER(MAP) \
+  octave_value MAP (void) const \
+    { \
+      octave_sparse_matrix m (sparse_matrix_value ()); \
+      return m.MAP (); \
+    }
+
+  BOOL_SPARSE_MAPPER (abs)
+  BOOL_SPARSE_MAPPER (acos)
+  BOOL_SPARSE_MAPPER (acosh)
+  BOOL_SPARSE_MAPPER (angle)
+  BOOL_SPARSE_MAPPER (arg)
+  BOOL_SPARSE_MAPPER (asin)
+  BOOL_SPARSE_MAPPER (asinh)
+  BOOL_SPARSE_MAPPER (atan)
+  BOOL_SPARSE_MAPPER (atanh)
+  BOOL_SPARSE_MAPPER (ceil)
+  BOOL_SPARSE_MAPPER (conj)
+  BOOL_SPARSE_MAPPER (cos)
+  BOOL_SPARSE_MAPPER (cosh)
+  BOOL_SPARSE_MAPPER (erf)
+  BOOL_SPARSE_MAPPER (erfc)
+  BOOL_SPARSE_MAPPER (exp)
+  BOOL_SPARSE_MAPPER (finite)
+  BOOL_SPARSE_MAPPER (fix)
+  BOOL_SPARSE_MAPPER (floor)
+  BOOL_SPARSE_MAPPER (gamma)
+  BOOL_SPARSE_MAPPER (imag)
+  BOOL_SPARSE_MAPPER (isinf)
+  BOOL_SPARSE_MAPPER (isna)
+  BOOL_SPARSE_MAPPER (isnan)
+  BOOL_SPARSE_MAPPER (lgamma)
+  BOOL_SPARSE_MAPPER (log)
+  BOOL_SPARSE_MAPPER (log10)
+  BOOL_SPARSE_MAPPER (real)
+  BOOL_SPARSE_MAPPER (round)
+  BOOL_SPARSE_MAPPER (signum)
+  BOOL_SPARSE_MAPPER (sin)
+  BOOL_SPARSE_MAPPER (sinh)
+  BOOL_SPARSE_MAPPER (sqrt)
+  BOOL_SPARSE_MAPPER (tan)
+  BOOL_SPARSE_MAPPER (tanh)
+
+#undef BOOL_SPARSE_MAPPER
+
 protected:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
+#include "ov-scalar.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 // Real scalar values.
@@ -186,16 +187,62 @@ public:
 	     oct_mach_info::float_format flt_fmt) const
     {
       return os.write (bool_array_value (), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
+  // Mapper functions are converted to double for treatment
+#define BOOL_MAPPER(MAP) \
+  octave_value MAP (void) const \
+    { \
+      octave_scalar s (static_cast<double> (scalar)); \
+      return s.MAP (); \
+    }
+
+  BOOL_MAPPER (abs)
+  BOOL_MAPPER (acos)
+  BOOL_MAPPER (acosh)
+  BOOL_MAPPER (angle)
+  BOOL_MAPPER (arg)
+  BOOL_MAPPER (asin)
+  BOOL_MAPPER (asinh)
+  BOOL_MAPPER (atan)
+  BOOL_MAPPER (atanh)
+  BOOL_MAPPER (ceil)
+  BOOL_MAPPER (conj)
+  BOOL_MAPPER (cos)
+  BOOL_MAPPER (cosh)
+  BOOL_MAPPER (erf)
+  BOOL_MAPPER (erfc)
+  BOOL_MAPPER (exp)
+  BOOL_MAPPER (finite)
+  BOOL_MAPPER (fix)
+  BOOL_MAPPER (floor)
+  BOOL_MAPPER (gamma)
+  BOOL_MAPPER (imag)
+  BOOL_MAPPER (isinf)
+  BOOL_MAPPER (isna)
+  BOOL_MAPPER (isnan)
+  BOOL_MAPPER (lgamma)
+  BOOL_MAPPER (log)
+  BOOL_MAPPER (log10)
+  BOOL_MAPPER (real)
+  BOOL_MAPPER (round)
+  BOOL_MAPPER (signum)
+  BOOL_MAPPER (sin)
+  BOOL_MAPPER (sinh)
+  BOOL_MAPPER (sqrt)
+  BOOL_MAPPER (tan)
+  BOOL_MAPPER (tanh)
+
+#undef BOOL_MAPPER
+
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -824,17 +824,17 @@ octave_cell::save_hdf5 (hid_t loc_id, co
 
   Cell tmp = cell_value ();
 
   octave_idx_type nel = dv.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       std::ostringstream buf;
-      int digits = static_cast<int> (floor (log10 (static_cast<double> (nel)) + 1.0));
+      int digits = static_cast<int> (::floor (::log10 (static_cast<double> (nel)) + 1.0));
       buf << "_" << std::setw (digits) << std::setfill ('0') << i;
       std::string s = buf.str ();
 
       if (! add_hdf5_data (data_hid, tmp.elem (i), s.c_str (), "", false,
 			   save_as_floats))
 	{
 	  H5Gclose (data_hid);
 	  return false;
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -23,16 +23,18 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "lo-ieee.h"
+#include "lo-specfun.h"
+#include "lo-mappers.h"
 
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-complex.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
@@ -54,17 +56,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 octave_base_value *
 octave_complex::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   double im = std::imag (scalar);
 
   if (im == 0.0 && ! lo_ieee_signbit (im))
-    retval = new octave_scalar (real (scalar));
+    retval = new octave_scalar (std::real (scalar));
 
   return retval;
 }
 
 octave_value
 octave_complex::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
   octave_value retval;
@@ -320,19 +322,76 @@ octave_complex::load_hdf5 (hid_t loc_id,
 mxArray *
 octave_complex::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, 1, 1, mxCOMPLEX);
 
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
 
-  pr[0] = real (scalar);
-  pi[0] = imag (scalar);
+  pr[0] = std::real (scalar);
+  pi[0] = std::imag (scalar);
 
   return retval;
 }
 
+static double
+xabs (const Complex& x)
+{
+  return (xisinf (x.real ()) || xisinf (x.imag ())) ? octave_Inf : abs (x);
+}
+
+static double
+ximag (const Complex& x)
+{
+  return x.imag ();
+}
+
+static double
+xreal (const Complex& x)
+{
+  return x.real ();
+}
+
+#define COMPLEX_MAPPER(MAP, FCN)	\
+  octave_value \
+  octave_complex::MAP (void) const \
+  { \
+    return octave_value (FCN (scalar)); \
+  }
+
+COMPLEX_MAPPER (abs, xabs)
+COMPLEX_MAPPER (acos, ::acos)
+COMPLEX_MAPPER (acosh, ::acosh)
+COMPLEX_MAPPER (angle, std::arg)
+COMPLEX_MAPPER (arg, std::arg)
+COMPLEX_MAPPER (asin, ::asin)
+COMPLEX_MAPPER (asinh, ::asinh)
+COMPLEX_MAPPER (atan, ::atan)
+COMPLEX_MAPPER (atanh, ::atanh)
+COMPLEX_MAPPER (ceil, ::ceil)
+COMPLEX_MAPPER (conj, std::conj)
+COMPLEX_MAPPER (cos, std::cos)
+COMPLEX_MAPPER (cosh, std::cosh)
+COMPLEX_MAPPER (exp, std::exp)
+COMPLEX_MAPPER (fix, ::fix)
+COMPLEX_MAPPER (floor, ::floor)
+COMPLEX_MAPPER (imag, ximag)
+COMPLEX_MAPPER (log, std::log)
+COMPLEX_MAPPER (log10, std::log10)
+COMPLEX_MAPPER (real, xreal)
+COMPLEX_MAPPER (round, xround)
+COMPLEX_MAPPER (signum, ::signum)
+COMPLEX_MAPPER (sin, std::sin)
+COMPLEX_MAPPER (sinh, std::sinh)
+COMPLEX_MAPPER (sqrt, std::sqrt)
+COMPLEX_MAPPER (tan, std::tan)
+COMPLEX_MAPPER (tanh, std::tanh)
+COMPLEX_MAPPER (finite, xfinite)
+COMPLEX_MAPPER (isinf, xisinf)
+COMPLEX_MAPPER (isna, octave_is_NA)
+COMPLEX_MAPPER (isnan, xisnan)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -143,16 +143,48 @@ public:
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (array_value (true), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
+  octave_value abs (void) const;
+  octave_value acos (void) const;
+  octave_value acosh (void) const;
+  octave_value angle (void) const;
+  octave_value arg (void) const;
+  octave_value asin (void) const;
+  octave_value asinh (void) const;
+  octave_value atan (void) const;
+  octave_value atanh (void) const;
+  octave_value ceil (void) const;
+  octave_value conj (void) const;
+  octave_value cos (void) const;
+  octave_value cosh (void) const;
+  octave_value exp (void) const;
+  octave_value fix (void) const;
+  octave_value floor (void) const;
+  octave_value imag (void) const;
+  octave_value log (void) const;
+  octave_value log10 (void) const;
+  octave_value real (void) const;
+  octave_value round (void) const;
+  octave_value signum (void) const;
+  octave_value sin (void) const;
+  octave_value sinh (void) const;
+  octave_value sqrt (void) const;
+  octave_value tan (void) const;
+  octave_value tanh (void) const;
+  octave_value finite (void) const;
+  octave_value isinf (void) const;
+  octave_value isna (void) const;
+  octave_value isnan (void) const;
+
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 typedef octave_complex octave_complex_scalar;
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -25,16 +25,18 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <iostream>
 #include <vector>
 
 #include "data-conv.h"
 #include "lo-ieee.h"
+#include "lo-specfun.h"
+#include "lo-mappers.h"
 #include "mx-base.h"
 #include "mach-info.h"
 
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
@@ -175,16 +177,36 @@ octave_complex_matrix::complex_value (bo
 }
 
 ComplexMatrix
 octave_complex_matrix::complex_matrix_value (bool) const
 {
   return matrix.matrix_value ();
 }
 
+charNDArray
+octave_complex_matrix::char_array_value (bool frc_str_conv) const
+{
+  charNDArray retval;
+
+  if (! frc_str_conv)
+    gripe_implicit_conversion ("Octave:num-to-str",
+			       "complex matrix", "string");
+  else
+    {
+      retval = charNDArray (dims ());
+      octave_idx_type nel = numel ();
+  
+      for (octave_idx_type i = 0; i < nel; i++)
+	retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
+    }
+
+  return retval;
+}  
+
 SparseMatrix
 octave_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
 			       "complex matrix", "real matrix");
@@ -618,20 +640,78 @@ octave_complex_matrix::as_mxArray (void)
   double *pi = static_cast<double *> (retval->get_imag_data ());
 
   mwSize nel = numel ();
 
   const Complex *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     {
-      pr[i] = real (p[i]);
-      pi[i] = imag (p[i]);
+      pr[i] = std::real (p[i]);
+      pi[i] = std::imag (p[i]);
     }
 
   return retval;
 }
 
+static double
+xabs (const Complex& x)
+{
+  return (xisinf (x.real ()) || xisinf (x.imag ())) ? octave_Inf : abs (x);
+}
+
+static double
+ximag (const Complex& x)
+{
+  return x.imag ();
+}
+
+static double
+xreal (const Complex& x)
+{
+  return x.real ();
+}
+
+#define ARRAY_MAPPER(MAP, AMAP, FCN) \
+  octave_value \
+  octave_complex_matrix::MAP (void) const \
+  { \
+    static AMAP cmap = FCN; \
+    return matrix.map (cmap); \
+  }
+
+ARRAY_MAPPER (abs, ComplexNDArray::dmapper, xabs)
+ARRAY_MAPPER (acos, ComplexNDArray::cmapper, ::acos)
+ARRAY_MAPPER (acosh, ComplexNDArray::cmapper, ::acosh)
+ARRAY_MAPPER (angle, ComplexNDArray::dmapper, std::arg)
+ARRAY_MAPPER (arg, ComplexNDArray::dmapper, std::arg)
+ARRAY_MAPPER (asin, ComplexNDArray::cmapper, ::asin)
+ARRAY_MAPPER (asinh, ComplexNDArray::cmapper, ::asinh)
+ARRAY_MAPPER (atan, ComplexNDArray::cmapper, ::atan)
+ARRAY_MAPPER (atanh, ComplexNDArray::cmapper, ::atanh)
+ARRAY_MAPPER (ceil, ComplexNDArray::cmapper, ::ceil)
+ARRAY_MAPPER (conj, ComplexNDArray::cmapper, std::conj)
+ARRAY_MAPPER (cos, ComplexNDArray::cmapper, std::cos)
+ARRAY_MAPPER (cosh, ComplexNDArray::cmapper, std::cosh)
+ARRAY_MAPPER (exp, ComplexNDArray::cmapper, std::exp)
+ARRAY_MAPPER (fix, ComplexNDArray::cmapper, ::fix)
+ARRAY_MAPPER (floor, ComplexNDArray::cmapper, ::floor)
+ARRAY_MAPPER (imag, ComplexNDArray::dmapper, ximag)
+ARRAY_MAPPER (log, ComplexNDArray::cmapper, std::log)
+ARRAY_MAPPER (log10, ComplexNDArray::cmapper, std::log10)
+ARRAY_MAPPER (real, ComplexNDArray::dmapper, xreal)
+ARRAY_MAPPER (round, ComplexNDArray::cmapper, xround)
+ARRAY_MAPPER (signum, ComplexNDArray::cmapper, ::signum)
+ARRAY_MAPPER (sin, ComplexNDArray::cmapper, std::sin)
+ARRAY_MAPPER (sinh, ComplexNDArray::cmapper, std::sinh)
+ARRAY_MAPPER (sqrt, ComplexNDArray::cmapper, std::sqrt)
+ARRAY_MAPPER (tan, ComplexNDArray::cmapper, std::tan)
+ARRAY_MAPPER (tanh, ComplexNDArray::cmapper, std::tanh)
+ARRAY_MAPPER (finite, ComplexNDArray::bmapper, xfinite)
+ARRAY_MAPPER (isinf, ComplexNDArray::bmapper, xisinf)
+ARRAY_MAPPER (isna, ComplexNDArray::bmapper, octave_is_NA)
+ARRAY_MAPPER (isnan, ComplexNDArray::bmapper, xisnan)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -108,16 +108,18 @@ public:
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const { return matrix; }
 
+  charNDArray char_array_value (bool frc_str_conv = false) const;
+  
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   void increment (void) { matrix += Complex (1.0); }
 
   void decrement (void) { matrix -= Complex (1.0); }
 
@@ -144,16 +146,48 @@ public:
       return os.write (matrix_value (true), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
+  octave_value abs (void) const;
+  octave_value acos (void) const;
+  octave_value acosh (void) const;
+  octave_value angle (void) const;
+  octave_value arg (void) const;
+  octave_value asin (void) const;
+  octave_value asinh (void) const;
+  octave_value atan (void) const;
+  octave_value atanh (void) const;
+  octave_value ceil (void) const;
+  octave_value conj (void) const;
+  octave_value cos (void) const;
+  octave_value cosh (void) const;
+  octave_value exp (void) const;
+  octave_value fix (void) const;
+  octave_value floor (void) const;
+  octave_value imag (void) const;
+  octave_value log (void) const;
+  octave_value log10 (void) const;
+  octave_value real (void) const;
+  octave_value round (void) const;
+  octave_value signum (void) const;
+  octave_value sin (void) const;
+  octave_value sinh (void) const;
+  octave_value sqrt (void) const;
+  octave_value tan (void) const;
+  octave_value tanh (void) const;
+  octave_value finite (void) const;
+  octave_value isinf (void) const;
+  octave_value isna (void) const;
+  octave_value isnan (void) const;
+
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -25,16 +25,19 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <climits>
 
 #include <iostream>
 #include <vector>
 
+#include "lo-specfun.h"
+#include "lo-mappers.h"
+
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "ov-complex.h"
 #include "gripes.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
@@ -64,17 +67,17 @@ octave_sparse_complex_matrix::try_narrow
       // since they involves a cast to double to avoid issues of overflow
       if (matrix.rows () == 1 && matrix.cols () == 1)
 	{
 	  // Const copy of the matrix, so the right version of () operator used
 	  const SparseComplexMatrix tmp (matrix);
 
 	  Complex c = tmp (0, 0);
 
-	  if (imag (c) == 0.0)
+	  if (std::imag (c) == 0.0)
 	    retval = new octave_scalar (std::real (c));
 	  else
 	    retval = new octave_complex (c);
 	}
       else if (nr == 0 || nc == 0)
 	retval = new octave_matrix (Matrix (nr, nc));
       else if (matrix.all_elements_are_real ())
 	if (matrix.cols () > 0 && matrix.rows () > 0 && 
@@ -190,16 +193,39 @@ octave_sparse_complex_matrix::complex_ma
 }
 
 ComplexNDArray 
 octave_sparse_complex_matrix::complex_array_value (bool) const
 {
   return ComplexNDArray (matrix.matrix_value ());
 }
 
+charNDArray
+octave_sparse_complex_matrix::char_array_value (bool frc_str_conv) const
+{
+  charNDArray retval;
+
+  if (! frc_str_conv)
+    gripe_implicit_conversion ("Octave:num-to-str",
+			       "sparse complex matrix", "string");
+  else
+    {
+      retval = charNDArray (dims (), 0);
+      octave_idx_type nc = matrix.cols ();
+      octave_idx_type nr = matrix.rows ();
+
+      for (octave_idx_type j = 0; j < nc; j++)
+	for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
+	  retval(matrix.ridx(i) + nr * j) = 
+	    static_cast<char>(std::real (matrix.data (i)));
+    }
+
+  return retval;
+}
+
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
 			       "complex sparse matrix", 
@@ -779,24 +805,82 @@ octave_sparse_complex_matrix::as_mxArray
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
       Complex val = matrix.data(i);
-      pr[i] = real (val);
-      pi[i] = imag (val);
+      pr[i] = std::real (val);
+      pi[i] = std::imag (val);
       ir[i] = matrix.ridx(i);
     }
 
   for (mwIndex i = 0; i < columns() + 1; i++)
     jc[i] = matrix.cidx(i);
 
   return retval;
 }
 
+static double
+xabs (const Complex& x)
+{
+  return (xisinf (x.real ()) || xisinf (x.imag ())) ? octave_Inf : abs (x);
+}
+
+static double
+ximag (const Complex& x)
+{
+  return x.imag ();
+}
+
+static double
+xreal (const Complex& x)
+{
+  return x.real ();
+}
+
+#define SPARSE_MAPPER(MAP, AMAP, FCN) \
+  octave_value \
+  octave_sparse_complex_matrix::MAP (void) const \
+  { \
+    static AMAP cmap = FCN; \
+    return matrix.map (cmap); \
+  }
+
+SPARSE_MAPPER (abs, SparseComplexMatrix::dmapper, xabs)
+SPARSE_MAPPER (acos, SparseComplexMatrix::cmapper, ::acos)
+SPARSE_MAPPER (acosh, SparseComplexMatrix::cmapper, ::acosh)
+SPARSE_MAPPER (angle, SparseComplexMatrix::dmapper, std::arg)
+SPARSE_MAPPER (arg, SparseComplexMatrix::dmapper, std::arg)
+SPARSE_MAPPER (asin, SparseComplexMatrix::cmapper, ::asin)
+SPARSE_MAPPER (asinh, SparseComplexMatrix::cmapper, ::asinh)
+SPARSE_MAPPER (atan, SparseComplexMatrix::cmapper, ::atan)
+SPARSE_MAPPER (atanh, SparseComplexMatrix::cmapper, ::atanh)
+SPARSE_MAPPER (ceil, SparseComplexMatrix::cmapper, ::ceil)
+SPARSE_MAPPER (conj, SparseComplexMatrix::cmapper, std::conj)
+SPARSE_MAPPER (cos, SparseComplexMatrix::cmapper, std::cos)
+SPARSE_MAPPER (cosh, SparseComplexMatrix::cmapper, std::cosh)
+SPARSE_MAPPER (exp, SparseComplexMatrix::cmapper, std::exp)
+SPARSE_MAPPER (fix, SparseComplexMatrix::cmapper, ::fix)
+SPARSE_MAPPER (floor, SparseComplexMatrix::cmapper, ::floor)
+SPARSE_MAPPER (imag, SparseComplexMatrix::dmapper, ximag)
+SPARSE_MAPPER (log, SparseComplexMatrix::cmapper, std::log)
+SPARSE_MAPPER (log10, SparseComplexMatrix::cmapper, std::log10)
+SPARSE_MAPPER (real, SparseComplexMatrix::dmapper, xreal)
+SPARSE_MAPPER (round, SparseComplexMatrix::cmapper, xround)
+SPARSE_MAPPER (signum, SparseComplexMatrix::cmapper, ::signum)
+SPARSE_MAPPER (sin, SparseComplexMatrix::cmapper, std::sin)
+SPARSE_MAPPER (sinh, SparseComplexMatrix::cmapper, std::sinh)
+SPARSE_MAPPER (sqrt, SparseComplexMatrix::cmapper, std::sqrt)
+SPARSE_MAPPER (tan, SparseComplexMatrix::cmapper, std::tan)
+SPARSE_MAPPER (tanh, SparseComplexMatrix::cmapper, std::tanh)
+SPARSE_MAPPER (finite, SparseComplexMatrix::bmapper, xfinite)
+SPARSE_MAPPER (isinf, SparseComplexMatrix::bmapper, xisinf)
+SPARSE_MAPPER (isna, SparseComplexMatrix::bmapper, octave_is_NA)
+SPARSE_MAPPER (isnan, SparseComplexMatrix::bmapper, xisnan)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-cx-sparse.h b/src/ov-cx-sparse.h
--- a/src/ov-cx-sparse.h
+++ b/src/ov-cx-sparse.h
@@ -37,17 +37,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 #include "CSparse.h"
 #include "ov-base-sparse.h"
 #include "ov-re-sparse.h"
-#include "ov-bool-sparse.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 class
 OCTINTERP_API
@@ -115,16 +114,18 @@ public:
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
 
+  charNDArray char_array_value (bool frc_str_conv = false) const;
+
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
     { return matrix; }
 
 #if 0
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
@@ -144,16 +145,48 @@ public:
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
   mxArray *as_mxArray (void) const;
 
+  octave_value abs (void) const;
+  octave_value acos (void) const;
+  octave_value acosh (void) const;
+  octave_value angle (void) const;
+  octave_value arg (void) const;
+  octave_value asin (void) const;
+  octave_value asinh (void) const;
+  octave_value atan (void) const;
+  octave_value atanh (void) const;
+  octave_value ceil (void) const;
+  octave_value conj (void) const;
+  octave_value cos (void) const;
+  octave_value cosh (void) const;
+  octave_value exp (void) const;
+  octave_value fix (void) const;
+  octave_value floor (void) const;
+  octave_value imag (void) const;
+  octave_value log (void) const;
+  octave_value log10 (void) const;
+  octave_value real (void) const;
+  octave_value round (void) const;
+  octave_value signum (void) const;
+  octave_value sin (void) const;
+  octave_value sinh (void) const;
+  octave_value sqrt (void) const;
+  octave_value tan (void) const;
+  octave_value tanh (void) const;
+  octave_value finite (void) const;
+  octave_value isinf (void) const;
+  octave_value isna (void) const;
+  octave_value isnan (void) const;
+
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -32,16 +32,19 @@ along with Octave; see the file COPYING.
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-base-int.h"
 #include "ov-typeinfo.h"
 #include "gripes.h"
 
+#include "ov-re-mat.h"
+#include "ov-scalar.h"
+
 class
 OCTINTERP_API
 OCTAVE_VALUE_INT_MATRIX_T
   : public octave_base_int_matrix<OCTAVE_INT_NDARRAY_T>
 {
 public:
 
   OCTAVE_VALUE_INT_MATRIX_T (void)
@@ -221,16 +224,52 @@ public:
     const OCTAVE_INT_T *p = matrix.data ();
 
     for (mwIndex i = 0; i < nel; i++)
       pr[i] = p[i].value ();
 
     return retval;
   }
 
+#define MAT_MAPPER(FCN) \
+  octave_value FCN (void) const { return matrix.FCN (); }
+
+  MAT_MAPPER (abs)
+  MAT_MAPPER (signum)
+
+#undef MAT_MAPPER
+
+  octave_value imag (void) const
+  {
+    return OCTAVE_INT_NDARRAY_T (matrix.dims (),
+				 static_cast<OCTAVE_INT_T>(0));
+  }
+
+#define NO_OP_MAPPER(FCN) \
+  octave_value FCN (void) const { return octave_value (matrix); }
+
+  NO_OP_MAPPER (ceil)
+  NO_OP_MAPPER (conj)
+  NO_OP_MAPPER (fix)
+  NO_OP_MAPPER (floor)
+  NO_OP_MAPPER (real)
+  NO_OP_MAPPER (round)
+
+#undef NO_OP_MAPPER
+
+#define BOOL_MAPPER(FCN, VAL) \
+  octave_value FCN (void) const { return boolNDArray (matrix.dims (), VAL); }
+
+  BOOL_MAPPER (finite, true)
+  BOOL_MAPPER (isinf, false)
+  BOOL_MAPPER (isna, false)
+  BOOL_MAPPER (isnan, false)
+
+#undef BOOL_MAPPER
+
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 class
@@ -443,16 +482,47 @@ public:
 
     OCTAVE_INT_T::val_type *pr = static_cast<OCTAVE_INT_T::val_type *> (retval->get_data ());
 
     pr[0] = scalar.value ();
 
     return retval;
   }
 
+#define SCALAR_MAPPER(FCN) \
+  octave_value FCN (void) const { return scalar.FCN (); }
+
+  SCALAR_MAPPER (abs)
+  SCALAR_MAPPER (signum)
+
+#undef SCALAR_MAPPER
+
+  octave_value imag (void) const { return static_cast<OCTAVE_INT_T>(0); }
+
+#define NO_OP_MAPPER(FCN) \
+  octave_value FCN (void) const { return octave_value (scalar); }
+
+  NO_OP_MAPPER (ceil)
+  NO_OP_MAPPER (conj)
+  NO_OP_MAPPER (fix)
+  NO_OP_MAPPER (floor)
+  NO_OP_MAPPER (real)
+  NO_OP_MAPPER (round)
+
+#undef NO_OP_MAPPER
+
+#define BOOL_MAPPER(FCN, VAL) octave_value FCN (void) const { return VAL; }
+
+  BOOL_MAPPER (finite, true)
+  BOOL_MAPPER (isinf, false)
+  BOOL_MAPPER (isna, false)
+  BOOL_MAPPER (isnan, false)
+
+#undef BOOL_MAPPER
+
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 /*
diff --git a/src/ov-mapper.cc b/src/ov-mapper.cc
deleted file mode 100644
--- a/src/ov-mapper.cc
+++ /dev/null
@@ -1,489 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005,
-              2006, 2007, 2008 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "quit.h"
-
-#include "error.h"
-#include "gripes.h"
-#include "oct-obj.h"
-#include "ov-mapper.h"
-#include "ov.h"
-#include "toplev.h"
-#include "unwind-prot.h"
-
-DEFINE_OCTAVE_ALLOCATOR (octave_mapper);
-
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_mapper,
-				     "built-in mapper function",
-				     "built-in mapper function");
-
-static bool
-any_element_less_than (const NDArray& a, double val)
-{
-  octave_idx_type len = a.length ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (a(i) < val)
-	return true;
-    }
-
-  return false;
-}
-
-static bool
-any_element_less_than (const SparseMatrix& a, double val)
-{
-  octave_idx_type len = a.nnz ();
-
-  if (val > 0. && len != a.numel ())
-    return true;
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (a.data(i) < val)
-	return true;
-    }
-
-  return false;
-}
-
-static bool
-any_element_greater_than (const NDArray& a, double val)
-{
-  octave_idx_type len = a.length ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (a(i) > val)
-	return true;
-    }
-
-  return false;
-}
-
-static bool
-any_element_greater_than (const SparseMatrix& a, double val)
-{
-  octave_idx_type len = a.nnz ();
-
-  if (val < 0. && len != a.numel ())
-    return true;
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (a.data(i) > val)
-	return true;
-    }
-
-  return false;
-}
-
-// In most cases, we could use the map member function from the NDArray
-// classes, but as currently implemented, they don't allow us to
-// detect errors and abort properly.  So use these macros to do the
-// looping here instead.
-
-#define MAPPER_LOOP_2(T, F, M, CONV, R) \
-  do \
-    { \
-      octave_idx_type len = M.length (); \
- \
-      T result (M.dims ()); \
- \
-      for (octave_idx_type i = 0; i < len; i++) \
-	{ \
-          OCTAVE_QUIT; \
- \
-	  result(i) = CONV (F (M(i))); \
- \
-	  if (error_state) \
-	    return retval; \
-	} \
- \
-      retval = R; \
-    } \
-  while (0)
-
-#define MAPPER_LOOP_1(T, F, M, CONV) \
-  MAPPER_LOOP_2 (T, F, M, CONV, result)
-
-#define MAPPER_LOOP(T, F, M) \
-  MAPPER_LOOP_1 (T, F, M, )
-
-#define SPARSE_MAPPER_LOOP_2(T, ET, F, M, CONV, R) \
-  do \
-    { \
-      ET f_zero = CONV (F (0.)); \
-      \
-      if (f_zero != 0.) \
-	{ \
-	  octave_idx_type nr = M.rows (); \
-	  octave_idx_type nc = M.cols (); \
-	  \
-	  T result (nr, nc, f_zero); \
-	  \
-	  for (octave_idx_type j = 0; j < nc; j++) \
-	    for (octave_idx_type i = M.cidx(j); i < M.cidx (j+1); i++) \
-	      { \
-		OCTAVE_QUIT; \
-		/* Use data instead of elem for better performance.  */ \
-		result.data (M.ridx (i) + j * nr) = CONV (F (M.data(i))); \
-		\
-		if (error_state) \
-		  return retval; \
-	      } \
-	  \
-	  result.maybe_compress (true);	\
-          retval = R; \
-	} \
-      else \
-	{ \
-	  octave_idx_type nz = M.nnz (); \
-	  octave_idx_type nr = M.rows (); \
-	  octave_idx_type nc = M.cols (); \
-	  \
-	  T result (nr, nc, nz); \
-	  ET zero = ET (0.); \
-	  octave_idx_type ii = 0; \
-	  result.cidx (ii) = 0; \
-	  \
-	  for (octave_idx_type j = 0; j < nc; j++) \
-	    { \
-	      for (octave_idx_type i = M.cidx(j); i < M.cidx (j+1); i++) \
-		{ \
-		  ET val = CONV (F (M.data (i))); \
-		  if (val != zero) \
-		    { \
-		      result.data (ii) = val; \
-		      result.ridx (ii++) = M.ridx (i); \
-		    } \
-		  OCTAVE_QUIT; \
-		  \
-		  if (error_state) \
-		    return retval; \
-		} \
-	      result.cidx (j+1) = ii; \
-	    } \
-	  \
-	  result.maybe_compress (false); \
-          retval = R; \
-	} \
-    } \
-  while (0)
-
-#define SPARSE_MAPPER_LOOP_1(T, ET, F, M, CONV)	\
-  SPARSE_MAPPER_LOOP_2 (T, ET, F, M, CONV, result)
-
-#define SPARSE_MAPPER_LOOP(T, ET, F, M) \
-  SPARSE_MAPPER_LOOP_1 (T, ET, F, M, )
-
-octave_value
-octave_mapper::apply (const octave_value& arg) const
-{
-  octave_value retval;
-
-  // FIXME -- is_real_type can return true.  Should it really
-  // work that way?
-
-  if (arg.is_real_type ()
-      && (c_c_map_fcn || d_d_map_fcn || d_b_map_fcn)
-      && ! (arg.is_string () && ch_map_fcn))
-    {
-      if (arg.is_scalar_type ())
-	{
-	  double d = arg.double_value ();
-
-	  if (can_ret_cmplx_for_real && (d < lower_limit || d > upper_limit))
-	    {
-	      if (c_c_map_fcn)
-		retval = c_c_map_fcn (Complex (d));
-	      else
-		error ("%s: unable to handle real arguments",
-		       name().c_str ());
-	    }
-	  else if (d_d_map_fcn)
-	    retval = d_d_map_fcn (d);
-	  else if (d_b_map_fcn)
-	    retval = d_b_map_fcn (d);
-	  else
-	    error ("%s: unable to handle real arguments",
-		   name().c_str ());
-	}
-      else if (arg.is_sparse_type ())
-	{
-	  const SparseMatrix m = arg.sparse_matrix_value ();
-
-	  if (error_state)
-	    return retval;
-
-	  if (can_ret_cmplx_for_real
-	      && (any_element_less_than (m, lower_limit)
-		  || any_element_greater_than (m, upper_limit)))
-	    {
-	      if (c_c_map_fcn)
-		SPARSE_MAPPER_LOOP (SparseComplexMatrix, Complex, 
-				    c_c_map_fcn, m);
-	      else
-		error ("%s: unable to handle real arguments",
-		       name().c_str ());
-	    }
-	  else if (d_d_map_fcn)
-	    SPARSE_MAPPER_LOOP (SparseMatrix, double, d_d_map_fcn, m);
-	  else if (d_b_map_fcn)
-	    SPARSE_MAPPER_LOOP (SparseBoolMatrix, bool, d_b_map_fcn, m);
-	  else
-	    error ("%s: unable to handle real arguments",
-		   name().c_str ());
-	}
-      else
-	{
-	  NDArray m = arg.array_value ();
-
-	  if (error_state)
-	    return retval;
-
-	  if (can_ret_cmplx_for_real
-	      && (any_element_less_than (m, lower_limit)
-		  || any_element_greater_than (m, upper_limit)))
-	    {
-	      if (c_c_map_fcn)
-		MAPPER_LOOP (ComplexNDArray, c_c_map_fcn, m);
-	      else
-		error ("%s: unable to handle real arguments",
-		       name().c_str ());
-	    }
-	  else if (d_d_map_fcn)
-	    MAPPER_LOOP (NDArray, d_d_map_fcn, m);
-	  else if (d_b_map_fcn)
-	    MAPPER_LOOP (boolNDArray, d_b_map_fcn, m);
-	  else
-	    error ("%s: unable to handle real arguments",
-		   name().c_str ());
-	}
-    }
-  else if (arg.is_complex_type ())
-    {
-      // In the following, we use d_d_map_fcn to handle the case of
-      // imag (z) == 0.  This can happen when a complex value is not
-      // narrowed to a real value automatically, possibly due to some
-      // imaginary parts being -0.
-
-      if (arg.is_scalar_type ())
-	{
-	  Complex c = arg.complex_value ();
-
-	  if (c_d_map_fcn)
-	    retval = c_d_map_fcn (c);
-	  else if (c_c_map_fcn)
-	    retval = c_c_map_fcn (c);
-	  else if (c_b_map_fcn)
-	    retval = c_b_map_fcn (c);
-	  else if (d_d_map_fcn && imag (c) == 0)
-	    retval = d_d_map_fcn (real (c));
-	  else
-	    error ("%s: unable to handle complex arguments",
-		   name().c_str ());
-	}
-      else if (arg.is_sparse_type ())
-	{
-	  SparseComplexMatrix cm = arg.sparse_complex_matrix_value ();
-
-	  if (error_state)
-	    return retval;
-
-	  if (c_d_map_fcn)
-	    SPARSE_MAPPER_LOOP (SparseMatrix, double, c_d_map_fcn, cm);
-	  else if (c_c_map_fcn)
-	    SPARSE_MAPPER_LOOP (SparseComplexMatrix, Complex, 
-				c_c_map_fcn, cm);
-	  else if (c_b_map_fcn)
-	    SPARSE_MAPPER_LOOP (SparseBoolMatrix, bool, 
-				c_b_map_fcn, cm);
-	  else
-	    {
-	      SparseMatrix im = imag (cm);
-
-	      if (d_d_map_fcn && im.all_elements_are_zero ())
-		SPARSE_MAPPER_LOOP (SparseMatrix, double, d_d_map_fcn, real (cm));
-	      else
-		error ("%s: unable to handle complex arguments",
-		       name().c_str ());
-	    }
-	}
-      else
-	{
-	  ComplexNDArray cm = arg.complex_array_value ();
-
-	  if (error_state)
-	    return retval;
-
-	  if (c_d_map_fcn)
-	    MAPPER_LOOP (NDArray, c_d_map_fcn, cm);
-	  else if (c_c_map_fcn)
-	    MAPPER_LOOP (ComplexNDArray, c_c_map_fcn, cm);
-	  else if (c_b_map_fcn)
-	    MAPPER_LOOP (boolNDArray, c_b_map_fcn, cm);
-	  else
-	    {
-	      NDArray im = imag (cm);
-
-	      if (d_d_map_fcn && im.all_elements_are_zero ())
-		MAPPER_LOOP (NDArray, d_d_map_fcn, real (cm));
-	      else
-		error ("%s: unable to handle complex arguments",
-		       name().c_str ());
-	    }
-	}
-    }
-  else if (ch_map_fcn)
-    {
-      // FIXME -- this could be done in a better way...
-
-      octave_value tmp = arg.convert_to_str ();
-
-      if (! error_state)
-	{
-	  charNDArray chm = tmp.char_array_value ();
-
-	  if (! error_state)
-	    {
-	      switch (ch_map_flag)
-		{
-		case 0:
-		  MAPPER_LOOP_1 (boolNDArray, ch_map_fcn, chm, bool);
-		  break;
-
-		case 1:
-		  MAPPER_LOOP (NDArray, ch_map_fcn, chm);
-		  break;
-
-		case 2:
-		  MAPPER_LOOP_2 (charNDArray, ch_map_fcn, chm, ,
-				 octave_value (result, true));
-		  break;
-
-		default:
-		  panic_impossible ();
-		  break;
-		}
-	    }
-	}
-    }
-  else
-    gripe_wrong_type_arg ("mapper", arg);
-
-  return retval;
-}
-
-octave_value_list
-octave_mapper::subsref (const std::string& type,
-			const std::list<octave_value_list>& idx,
-			int nargout)
-{
-  octave_value_list retval;
-
-  switch (type[0])
-    {
-    case '(':
-      {
-	int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
-
-	retval = do_multi_index_op (tmp_nargout, idx.front ());
-      }
-      break;
-
-    case '{':
-    case '.':
-      {
-	std::string nm = type_name ();
-	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-      }
-      break;
-
-    default:
-      panic_impossible ();
-    }
-
-  // FIXME -- perhaps there should be an
-  // octave_value_list::next_subsref member function?  See also
-  // and octave_builtin::subsref.
-
-  if (idx.size () > 1)
-    retval = retval(0).next_subsref (nargout, type, idx);
-
-  return retval;
-}
-
-octave_value_list
-octave_mapper::do_multi_index_op (int, const octave_value_list& args)
-{
-  octave_value retval;
-
-  if (error_state)
-    return retval;
-
-  int nargin = args.length ();
-
-  if (nargin > 1)
-    ::error ("%s: too many arguments", name().c_str ());
-  else if (nargin < 1)
-    ::error ("%s: too few arguments", name().c_str ());
-  else
-    {
-      if (args(0).is_defined ())
-	{
-	  unwind_protect::begin_frame ("mapper_func_eval");
-
-	  octave_call_stack::push (this);
-
-	  unwind_protect::add (octave_call_stack::unwind_pop, 0);
-
-	  retval = apply (args(0));
-
-	  unwind_protect::run_frame ("mapper_func_eval");
-	}
-      else
-	::error ("%s: argument undefined", name().c_str ());
-    }
-
-  return retval;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/ov-mapper.h b/src/ov-mapper.h
deleted file mode 100644
--- a/src/ov-mapper.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005,
-              2007 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if !defined (octave_mapper_h)
-#define octave_mapper_h 1
-
-#include <string>
-
-#include "oct-obj.h"
-#include "ov-fcn.h"
-#include "ov-typeinfo.h"
-
-class octave_value;
-class octave_value_list;
-
-// Builtin mapper functions.
-
-class
-octave_mapper : public octave_function
-{
-public:
-
-  octave_mapper (void) { }
-
-  typedef int (*ch_mapper) (int);
-  typedef bool (*d_b_mapper) (double);
-  typedef bool (*c_b_mapper) (const Complex&);
-  typedef double (*d_d_mapper) (double);
-  typedef double (*c_d_mapper) (const Complex&);
-  typedef Complex (*c_c_mapper) (const Complex&);
-
-  octave_mapper (ch_mapper ch, d_b_mapper db, c_b_mapper cb,
-		 d_d_mapper dd, c_d_mapper dc,
-		 c_c_mapper cc, double ll, double ul,
-		 int cmf, bool crcfr,
-		 const std::string& nm = std::string (),
-		 const std::string& ds = std::string ())
-    : octave_function (nm, ds), ch_map_fcn (ch),
-      d_b_map_fcn (db), c_b_map_fcn (cb),
-      d_d_map_fcn (dd), c_d_map_fcn (dc), c_c_map_fcn (cc),
-      lower_limit (ll), upper_limit (ul), ch_map_flag (cmf),
-      can_ret_cmplx_for_real (crcfr) { }
-
-  ~octave_mapper (void) { }
-
-  octave_function *function_value (bool = false) { return this; }
-
-  octave_value subsref (const std::string&,
-			const std::list<octave_value_list>&)
-    {
-      panic_impossible ();
-      return octave_value ();
-    }
-
-  octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
-			     int nargout);
-
-  octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& args);
-
-private:
-
-  octave_value apply (const octave_value& arg) const;
-
-  // ch_map_fcn is a kluge.
-
-  ch_mapper ch_map_fcn;
-  d_b_mapper d_b_map_fcn;
-  c_b_mapper c_b_map_fcn;
-  d_d_mapper d_d_map_fcn;
-  c_d_mapper c_d_map_fcn;
-  c_c_mapper c_c_map_fcn;
-
-  // If flag is nonzero and we are not calling ch_map_fcn, lower_limit
-  // and  upper_limit specify the range of values for which a real arg
-  // returns a real value.  Outside that range, we have to convert args
-  // to complex, and call the complex valued function.
-
-  double lower_limit;
-  double upper_limit;
-
-  // ch_map_flag has the following meanings:
-  //
-  //   0  =>  this function returns a matrix of ones and zeros
-  //   1  =>  this function returns a numeric matrix (any values)
-  //   2  =>  this function returns a std::string array
-
-  int ch_map_flag;
-
-  // can_ret_cmplx_for_real is a flag that says whether this function
-  // can create a complex number given a real-valued  argument
-  // (e.g., sqrt (-1)).
-
-  bool can_ret_cmplx_for_real;
-
-  // No copying!
-
-  octave_mapper (const octave_mapper& om);
-
-  octave_mapper& operator = (const octave_mapper& om);
-
-  DECLARE_OCTAVE_ALLOCATOR
-
-  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
-};
-
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -257,16 +257,60 @@ public:
       // special case of the octave_stream::write method for ranges.
 
       return os.write (matrix_value (), block_size, output_type, skip,
 		       flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
+  // Mapper functions are converted to double for treatment
+#define RANGE_MAPPER(MAP) \
+  octave_value MAP (void) const \
+    { \
+      octave_matrix m (array_value ()); \
+      return m.MAP (); \
+    }
+
+  RANGE_MAPPER (abs)
+  RANGE_MAPPER (acos)
+  RANGE_MAPPER (acosh)
+  RANGE_MAPPER (angle)
+  RANGE_MAPPER (arg)
+  RANGE_MAPPER (asin)
+  RANGE_MAPPER (asinh)
+  RANGE_MAPPER (atan)
+  RANGE_MAPPER (atanh)
+  RANGE_MAPPER (ceil)
+  RANGE_MAPPER (conj)
+  RANGE_MAPPER (cos)
+  RANGE_MAPPER (cosh)
+  RANGE_MAPPER (erf)
+  RANGE_MAPPER (erfc)
+  RANGE_MAPPER (exp)
+  RANGE_MAPPER (finite)
+  RANGE_MAPPER (fix)
+  RANGE_MAPPER (floor)
+  RANGE_MAPPER (gamma)
+  RANGE_MAPPER (imag)
+  RANGE_MAPPER (isinf)
+  RANGE_MAPPER (isna)
+  RANGE_MAPPER (isnan)
+  RANGE_MAPPER (lgamma)
+  RANGE_MAPPER (log)
+  RANGE_MAPPER (log10)
+  RANGE_MAPPER (real)
+  RANGE_MAPPER (round)
+  RANGE_MAPPER (signum)
+  RANGE_MAPPER (sin)
+  RANGE_MAPPER (sinh)
+  RANGE_MAPPER (sqrt)
+  RANGE_MAPPER (tan)
+  RANGE_MAPPER (tanh)
+
 private:
 
   Range range;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -28,16 +28,18 @@ along with Octave; see the file COPYING.
 #include <climits>
 
 #include <iostream>
 #include <vector>
 
 #include "data-conv.h"
 #include "lo-ieee.h"
 #include "lo-utils.h"
+#include "lo-specfun.h"
+#include "lo-mappers.h"
 #include "mach-info.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
@@ -643,16 +645,114 @@ octave_matrix::as_mxArray (void) const
   const double *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
+static bool
+any_element_less_than (const NDArray& a, double val)
+{
+  octave_idx_type len = a.length ();
+  const double *m = a.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < len; i++)
+    {
+      OCTAVE_QUIT;
+
+      if (m[i] < val)
+	return true;
+    }
+
+  return false;
+}
+
+static bool
+any_element_greater_than (const NDArray& a, double val)
+{
+  octave_idx_type len = a.length ();
+  const double *m = a.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < len; i++)
+    {
+      OCTAVE_QUIT;
+
+      if (m[i] > val)
+	return true;
+    }
+
+  return false;
+}
+
+#define ARRAY_MAPPER(MAP, AMAP, FCN) \
+  octave_value \
+  octave_matrix::MAP (void) const \
+  { \
+    static AMAP dmap = FCN; \
+    return matrix.map (dmap); \
+  }
+
+#define CD_ARRAY_MAPPER(MAP, RFCN, CFCN, L1, L2) \
+  octave_value \
+  octave_matrix::MAP (void) const \
+  { \
+    static NDArray::dmapper dmap = RFCN; \
+    static NDArray::cmapper cmap = CFCN; \
+ \
+    return (any_element_less_than (matrix, L1) \
+            ? octave_value (matrix.map (cmap)) \
+	    : (any_element_greater_than (matrix, L2) \
+	       ? octave_value (matrix.map (cmap)) \
+	       : octave_value (matrix.map (dmap)))); \
+  }
+
+static double
+xconj (double x)
+{
+  return x;
+}
+
+ARRAY_MAPPER (erf, NDArray::dmapper, ::erf)
+ARRAY_MAPPER (erfc, NDArray::dmapper, ::erfc)
+ARRAY_MAPPER (gamma, NDArray::dmapper, xgamma)
+ARRAY_MAPPER (lgamma, NDArray::dmapper, xlgamma)
+ARRAY_MAPPER (abs, NDArray::dmapper, ::fabs)
+ARRAY_MAPPER (acos, NDArray::dmapper, ::acos)
+CD_ARRAY_MAPPER (acosh, ::acosh, ::acosh, 1.0, octave_Inf)
+ARRAY_MAPPER (angle, NDArray::dmapper, ::arg)
+ARRAY_MAPPER (arg, NDArray::dmapper, ::arg)
+CD_ARRAY_MAPPER (asin, ::asin, ::asin, -1.0, 1.0)
+ARRAY_MAPPER (asinh, NDArray::dmapper,::asinh)
+ARRAY_MAPPER (atan, NDArray::dmapper, ::atan)
+CD_ARRAY_MAPPER (atanh, ::atanh, ::atanh, -1.0, 1.0)
+ARRAY_MAPPER (ceil, NDArray::dmapper, ::ceil)
+ARRAY_MAPPER (conj, NDArray::dmapper, xconj)
+ARRAY_MAPPER (cos, NDArray::dmapper, ::cos)
+ARRAY_MAPPER (cosh, NDArray::dmapper, ::cosh)
+ARRAY_MAPPER (exp, NDArray::dmapper, ::exp)
+ARRAY_MAPPER (fix, NDArray::dmapper, ::fix)
+ARRAY_MAPPER (floor, NDArray::dmapper, ::floor)
+ARRAY_MAPPER (imag, NDArray::dmapper, ::imag)
+CD_ARRAY_MAPPER (log, ::log, std::log, 0.0, octave_Inf)
+CD_ARRAY_MAPPER (log10, ::log10, std::log10, 0.0, octave_Inf)
+ARRAY_MAPPER (real, NDArray::dmapper, ::real)
+ARRAY_MAPPER (round, NDArray::dmapper, xround)
+ARRAY_MAPPER (signum, NDArray::dmapper, ::signum)
+ARRAY_MAPPER (sin, NDArray::dmapper, ::sin)
+ARRAY_MAPPER (sinh, NDArray::dmapper, ::sinh)
+CD_ARRAY_MAPPER (sqrt, ::sqrt, std::sqrt, 0.0, octave_Inf)
+ARRAY_MAPPER (tan, NDArray::dmapper, ::tan)
+ARRAY_MAPPER (tanh, NDArray::dmapper, ::tanh)
+ARRAY_MAPPER (finite, NDArray::bmapper, xfinite)
+ARRAY_MAPPER (isinf, NDArray::bmapper, xisinf)
+ARRAY_MAPPER (isna, NDArray::bmapper, octave_is_NA)
+ARRAY_MAPPER (isnan, NDArray::bmapper, xisnan)
+
 DEFUN (double, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} double (@var{x})\n\
 Convert @var{x} to double precision type.\n\
 @end deftypefn")
 {
   // The OCTAVE_TYPE_CONV_BODY3 macro declares retval, so they go
   // inside their own scopes, and we don't declare retval here to
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -173,18 +173,53 @@ public:
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   mxArray *as_mxArray (void) const;
 
+  octave_value erf (void) const;
+  octave_value erfc (void) const;
+  octave_value gamma (void) const;
+  octave_value lgamma (void) const;
+  octave_value abs (void) const;
+  octave_value acos (void) const;
+  octave_value acosh (void) const;
+  octave_value angle (void) const;
+  octave_value arg (void) const;
+  octave_value asin (void) const;
+  octave_value asinh (void) const;
+  octave_value atan (void) const;
+  octave_value atanh (void) const;
+  octave_value ceil (void) const;
+  octave_value conj (void) const;
+  octave_value cos (void) const;
+  octave_value cosh (void) const;
+  octave_value exp (void) const;
+  octave_value fix (void) const;
+  octave_value floor (void) const;
+  octave_value imag (void) const;
+  octave_value log (void) const;
+  octave_value log10 (void) const;
+  octave_value real (void) const;
+  octave_value round (void) const;
+  octave_value signum (void) const;
+  octave_value sin (void) const;
+  octave_value sinh (void) const;
+  octave_value sqrt (void) const;
+  octave_value tan (void) const;
+  octave_value tanh (void) const;
+  octave_value finite (void) const;
+  octave_value isinf (void) const;
+  octave_value isna (void) const;
+  octave_value isnan (void) const;
+
 private:
-
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -25,16 +25,19 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <climits>
 
 #include <iostream>
 #include <vector>
 
+#include "lo-specfun.h"
+#include "lo-mappers.h"
+
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "gripes.h"
 
 #include "ls-hdf5.h"
 
 #include "ov-re-sparse.h"
 
@@ -148,16 +151,30 @@ octave_sparse_matrix::bool_array_value (
   NDArray m = matrix.matrix_value ();
 
   if (warn && m.any_element_not_one_or_zero ())
     gripe_logical_conversion ();
 
   return boolNDArray (m);
 }
 
+charNDArray
+octave_sparse_matrix::char_array_value (bool) const
+{
+  charNDArray retval (dims (), 0);
+  octave_idx_type nc = matrix.cols ();
+  octave_idx_type nr = matrix.rows ();
+
+  for (octave_idx_type j = 0; j < nc; j++)
+    for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
+      retval(matrix.ridx(i) + nr * j) = static_cast<char>(matrix.data (i));
+
+  return retval;
+}
+  
 ComplexMatrix
 octave_sparse_matrix::complex_matrix_value (bool) const
 {
   return ComplexMatrix (matrix.matrix_value ());
 }
 
 ComplexNDArray
 octave_sparse_matrix::complex_array_value (bool) const
@@ -814,13 +831,115 @@ octave_sparse_matrix::as_mxArray (void) 
     }
 
   for (mwIndex i = 0; i < nc + 1; i++)
     jc[i] = matrix.cidx(i);
 
   return retval;
 }
 
+static bool
+any_element_less_than (const SparseMatrix& a, double val)
+{
+  octave_idx_type len = a.nnz ();
+
+  if (val > 0. && len != a.numel ())
+    return true;
+
+  for (octave_idx_type i = 0; i < len; i++)
+    {
+      OCTAVE_QUIT;
+
+      if (a.data(i) < val)
+	return true;
+    }
+
+  return false;
+}
+
+static bool
+any_element_greater_than (const SparseMatrix& a, double val)
+{
+  octave_idx_type len = a.nnz ();
+
+  if (val < 0. && len != a.numel ())
+    return true;
+
+  for (octave_idx_type i = 0; i < len; i++)
+    {
+      OCTAVE_QUIT;
+
+      if (a.data(i) > val)
+	return true;
+    }
+
+  return false;
+}
+
+#define SPARSE_MAPPER(MAP, AMAP, FCN) \
+  octave_value \
+  octave_sparse_matrix::MAP (void) const \
+  { \
+    static AMAP dmap = FCN; \
+    return matrix.map (dmap); \
+  }
+
+#define CD_SPARSE_MAPPER(MAP, RFCN, CFCN, L1, L2) \
+  octave_value \
+  octave_sparse_matrix::MAP (void) const \
+  { \
+    static NDArray::dmapper dmap = RFCN; \
+    static NDArray::cmapper cmap = CFCN; \
+ \
+    return (any_element_less_than (matrix, L1) \
+            ? octave_value (matrix.map (cmap)) \
+            : (any_element_greater_than (matrix, L2) \
+               ? octave_value (matrix.map (cmap)) \
+	       : octave_value (matrix.map (dmap)))); \
+  }
+
+static double
+xconj (double x)
+{
+  return x;
+}
+
+SPARSE_MAPPER (erf, SparseMatrix::dmapper, ::erf)
+SPARSE_MAPPER (erfc, SparseMatrix::dmapper, ::erfc)
+SPARSE_MAPPER (gamma, SparseMatrix::dmapper, xgamma)
+SPARSE_MAPPER (lgamma, SparseMatrix::dmapper, xlgamma)
+SPARSE_MAPPER (abs, SparseMatrix::dmapper, ::fabs)
+SPARSE_MAPPER (acos, SparseMatrix::dmapper, ::acos)
+CD_SPARSE_MAPPER (acosh, ::acosh, ::acosh, 1.0, octave_Inf)
+SPARSE_MAPPER (angle, SparseMatrix::dmapper, ::arg)
+SPARSE_MAPPER (arg, SparseMatrix::dmapper, ::arg)
+CD_SPARSE_MAPPER (asin, ::asin, ::asin, -1.0, 1.0)
+SPARSE_MAPPER (asinh, SparseMatrix::dmapper, ::asinh)
+SPARSE_MAPPER (atan, SparseMatrix::dmapper, ::atan)
+CD_SPARSE_MAPPER (atanh, ::atanh, ::atanh, -1.0, 1.0)
+SPARSE_MAPPER (ceil, SparseMatrix::dmapper, ::ceil)
+SPARSE_MAPPER (conj, SparseMatrix::dmapper, xconj)
+SPARSE_MAPPER (cos, SparseMatrix::dmapper, ::cos)
+SPARSE_MAPPER (cosh, SparseMatrix::dmapper, ::cosh)
+SPARSE_MAPPER (exp, SparseMatrix::dmapper, ::exp)
+SPARSE_MAPPER (fix, SparseMatrix::dmapper, ::fix)
+SPARSE_MAPPER (floor, SparseMatrix::dmapper, ::floor)
+SPARSE_MAPPER (imag, SparseMatrix::dmapper, ::imag)
+CD_SPARSE_MAPPER (log, ::log, std::log, 0.0, octave_Inf)
+CD_SPARSE_MAPPER (log10, ::log10, std::log10, 0.0, octave_Inf)
+SPARSE_MAPPER (real, SparseMatrix::dmapper, ::real)
+SPARSE_MAPPER (round, SparseMatrix::dmapper, xround)
+SPARSE_MAPPER (signum, SparseMatrix::dmapper, ::signum)
+SPARSE_MAPPER (sin, SparseMatrix::dmapper, ::sin)
+SPARSE_MAPPER (sinh, SparseMatrix::dmapper, ::sinh)
+CD_SPARSE_MAPPER (sqrt, ::sqrt, std::sqrt, 0.0, octave_Inf)
+SPARSE_MAPPER (tan, SparseMatrix::dmapper, ::tan)
+SPARSE_MAPPER (tanh, SparseMatrix::dmapper, ::tanh)
+SPARSE_MAPPER (finite, SparseMatrix::bmapper, xfinite)
+SPARSE_MAPPER (isinf, SparseMatrix::bmapper, xisinf)
+SPARSE_MAPPER (isna, SparseMatrix::bmapper, octave_is_NA)
+SPARSE_MAPPER (isnan, SparseMatrix::bmapper, xisnan)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -37,17 +37,16 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-stream.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 #include "dSparse.h"
 #include "MatrixType.h"
 #include "ov-base-sparse.h"
-#include "ov-bool-sparse.h"
 #include "ov-cx-sparse.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
 class
@@ -109,16 +108,18 @@ public:
     { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   boolNDArray bool_array_value (bool warn = false) const;
 
+  charNDArray char_array_value (bool = false) const;
+
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
    
   NDArray array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const
     { return matrix; }
@@ -145,17 +146,54 @@ public:
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
   mxArray *as_mxArray (void) const;
 
+  octave_value erf (void) const;
+  octave_value erfc (void) const;
+  octave_value gamma (void) const;
+  octave_value lgamma (void) const;
+  octave_value abs (void) const;
+  octave_value acos (void) const;
+  octave_value acosh (void) const;
+  octave_value angle (void) const;
+  octave_value arg (void) const;
+  octave_value asin (void) const;
+  octave_value asinh (void) const;
+  octave_value atan (void) const;
+  octave_value atanh (void) const;
+  octave_value ceil (void) const;
+  octave_value conj (void) const;
+  octave_value cos (void) const;
+  octave_value cosh (void) const;
+  octave_value exp (void) const;
+  octave_value fix (void) const;
+  octave_value floor (void) const;
+  octave_value imag (void) const;
+  octave_value log (void) const;
+  octave_value log10 (void) const;
+  octave_value real (void) const;
+  octave_value round (void) const;
+  octave_value signum (void) const;
+  octave_value sin (void) const;
+  octave_value sinh (void) const;
+  octave_value sqrt (void) const;
+  octave_value tan (void) const;
+  octave_value tanh (void) const;
+  octave_value finite (void) const;
+  octave_value isinf (void) const;
+  octave_value isna (void) const;
+  octave_value isnan (void) const;
+
 private:
+  octave_value map (double (*fcn) (double)) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "data-conv.h"
 #include "mach-info.h"
+#include "lo-specfun.h"
+#include "lo-mappers.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "ov-scalar.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
@@ -278,13 +280,71 @@ octave_scalar::as_mxArray (void) const
 
   double *pr = static_cast<double *> (retval->get_data ());
 
   pr[0] = scalar;
 
   return retval;
 }
 
+#define SCALAR_MAPPER(MAP, FCN) \
+  octave_value \
+  octave_scalar::MAP (void) const \
+  { \
+    return octave_value (FCN (scalar)); \
+  }
+
+#define CD_SCALAR_MAPPER(MAP, RFCN, CFCN, L1, L2) \
+  octave_value \
+  octave_scalar::MAP (void) const \
+  { \
+    return (scalar < L1 || scalar > L2 \
+            ? octave_value (CFCN (Complex (scalar))) \
+	    : octave_value (RFCN (scalar))); \
+  }
+
+static double
+xconj (double x)
+{
+  return x;
+}
+
+SCALAR_MAPPER (erf, ::erf)
+SCALAR_MAPPER (erfc, ::erfc)
+SCALAR_MAPPER (gamma, xgamma)
+SCALAR_MAPPER (lgamma, xlgamma)
+SCALAR_MAPPER (abs, ::fabs)
+SCALAR_MAPPER (acos, ::acos)
+CD_SCALAR_MAPPER (acosh, ::acosh, ::acosh, 1.0, octave_Inf)
+SCALAR_MAPPER (angle, ::arg)
+SCALAR_MAPPER (arg, ::arg)
+CD_SCALAR_MAPPER (asin, ::asin, ::asin, -1.0, 1.0)
+SCALAR_MAPPER (asinh, ::asinh)
+SCALAR_MAPPER (atan, ::atan)
+CD_SCALAR_MAPPER (atanh, ::atanh, ::atanh, -1.0, 1.0)
+SCALAR_MAPPER (ceil, ::ceil)
+SCALAR_MAPPER (conj, xconj)
+SCALAR_MAPPER (cos, ::cos)
+SCALAR_MAPPER (cosh, ::cosh)
+SCALAR_MAPPER (exp, ::exp)
+SCALAR_MAPPER (fix, ::fix)
+SCALAR_MAPPER (floor, ::floor)
+SCALAR_MAPPER (imag, ::imag)
+CD_SCALAR_MAPPER (log, ::log, std::log, 0.0, octave_Inf)
+CD_SCALAR_MAPPER (log10, ::log10, std::log10, 0.0, octave_Inf)
+SCALAR_MAPPER (real, ::real)
+SCALAR_MAPPER (round, ::round)
+SCALAR_MAPPER (signum, ::signum)
+SCALAR_MAPPER (sin, ::sin)
+SCALAR_MAPPER (sinh, ::sinh)
+CD_SCALAR_MAPPER (sqrt, ::sqrt, std::sqrt, 0.0, octave_Inf)
+SCALAR_MAPPER (tan, ::tan)
+SCALAR_MAPPER (tanh, ::tanh)
+SCALAR_MAPPER (finite, xfinite)
+SCALAR_MAPPER (isinf, xisinf)
+SCALAR_MAPPER (isna, octave_is_NA)
+SCALAR_MAPPER (isnan, xisnan)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -214,17 +214,54 @@ public:
 	     oct_mach_info::float_format flt_fmt) const
     {
       return os.write (array_value (), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
+  octave_value erf (void) const;
+  octave_value erfc (void) const;
+  octave_value gamma (void) const;
+  octave_value lgamma (void) const;
+  octave_value abs (void) const;
+  octave_value acos (void) const;
+  octave_value acosh (void) const;
+  octave_value angle (void) const;
+  octave_value arg (void) const;
+  octave_value asin (void) const;
+  octave_value asinh (void) const;
+  octave_value atan (void) const;
+  octave_value atanh (void) const;
+  octave_value ceil (void) const;
+  octave_value conj (void) const;
+  octave_value cos (void) const;
+  octave_value cosh (void) const;
+  octave_value exp (void) const;
+  octave_value fix (void) const;
+  octave_value floor (void) const;
+  octave_value imag (void) const;
+  octave_value log (void) const;
+  octave_value log10 (void) const;
+  octave_value real (void) const;
+  octave_value round (void) const;
+  octave_value signum (void) const;
+  octave_value sin (void) const;
+  octave_value sinh (void) const;
+  octave_value sqrt (void) const;
+  octave_value tan (void) const;
+  octave_value tanh (void) const;
+  octave_value finite (void) const;
+  octave_value isinf (void) const;
+  octave_value isna (void) const;
+  octave_value isnan (void) const;
+
 private:
+  octave_value map (double (*fcn) (double)) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -767,13 +767,52 @@ octave_char_matrix_str::load_hdf5 (hid_t
 	}
     }
 
   return retval;
 }
 
 #endif
 
+#define MACRO_WRAPPER(FCN) \
+  static int x ## FCN (int c) { return FCN (c); }
+
+#define STRING_MAPPER(MAP, AMAP, FCN) \
+  MACRO_WRAPPER (FCN) \
+  octave_value \
+  octave_char_matrix_str::MAP (void) const \
+  { \
+    static charNDArray::mapper smap = x ## FCN; \
+    return matrix.AMAP (smap);  \
+  }
+
+#define TOSTRING_MAPPER(MAP, AMAP, FCN) \
+  MACRO_WRAPPER (FCN) \
+ \
+  octave_value \
+  octave_char_matrix_str::MAP (void) const \
+  { \
+    static charNDArray::mapper smap = x ## FCN; \
+    return (is_sq_string () ? octave_value (matrix.AMAP (smap), true, '\'') : \
+	    octave_value (matrix.AMAP (smap), true)); \
+  }
+
+STRING_MAPPER (isalnum, bmap, isalnum)
+STRING_MAPPER (isalpha, bmap, isalpha)
+STRING_MAPPER (isascii, bmap, isascii)
+STRING_MAPPER (iscntrl, bmap, iscntrl)
+STRING_MAPPER (isdigit, bmap, isdigit)
+STRING_MAPPER (isgraph, bmap, isgraph)
+STRING_MAPPER (islower, bmap, islower)
+STRING_MAPPER (isprint, bmap, isprint)
+STRING_MAPPER (ispunct, bmap, ispunct)
+STRING_MAPPER (isspace, bmap, isspace)
+STRING_MAPPER (isupper, bmap, isupper)
+STRING_MAPPER (isxdigit, bmap, isxdigit)
+STRING_MAPPER (toascii, dmap, toascii)
+TOSTRING_MAPPER (tolower, smap, tolower)
+TOSTRING_MAPPER (toupper, smap, toupper)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ov.h"
+#include "ov-re-mat.h"
 #include "ov-ch-mat.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
@@ -122,20 +123,21 @@ public:
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   string_vector all_strings (bool pad = false) const;
 
   std::string string_value (bool force = false) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-  { return octave_value (matrix.sort (dim, mode), true); }
+    { return octave_value (matrix.sort (dim, mode), true); }
+
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		     sortmode mode = ASCENDING) const
-  { return octave_value (matrix.sort (sidx, dim, mode), true); }
+    { return octave_value (matrix.sort (sidx, dim, mode), true); }
 
   bool print_as_scalar (void) const { return (rows () <= 1); }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
@@ -151,16 +153,66 @@ public:
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
+  octave_value isalnum (void) const;
+  octave_value isalpha (void) const;
+  octave_value isascii (void) const;
+  octave_value iscntrl (void) const;
+  octave_value isdigit (void) const;
+  octave_value isgraph (void) const;
+  octave_value islower (void) const;
+  octave_value isprint (void) const;
+  octave_value ispunct (void) const;
+  octave_value isspace (void) const;
+  octave_value isupper (void) const;
+  octave_value isxdigit (void) const;
+  octave_value toascii (void) const;
+  octave_value tolower (void) const;
+  octave_value toupper (void) const;
+
+#define MAT_MAPPER(MAP) \
+  octave_value MAP (void) const \
+    { \
+      octave_matrix m (array_value (true)); \
+      return m.MAP (); \
+    }
+
+  MAT_MAPPER (abs)
+  MAT_MAPPER (angle)
+  MAT_MAPPER (arg)
+  MAT_MAPPER (ceil)
+  MAT_MAPPER (conj)
+  MAT_MAPPER (fix)
+  MAT_MAPPER (floor)
+  MAT_MAPPER (imag)
+  MAT_MAPPER (real)
+  MAT_MAPPER (round)
+  MAT_MAPPER (signum)
+
+#undef MAT_MAPPER
+
+#define BOOL_MAT_MAPPER(MAP, VAL)	\
+  octave_value MAP (void) const \
+    { \
+      return boolNDArray (matrix.dims (), VAL); \
+    }
+
+  BOOL_MAT_MAPPER (finite, true)
+  BOOL_MAT_MAPPER (isinf, false)
+  BOOL_MAT_MAPPER (isna, false)
+  BOOL_MAT_MAPPER (isnan, false)
+
+#undef BOOL_MAT_MAPPER
+
 protected:
 
   octave_value do_index_op_internal (const octave_value_list& idx,
 				     bool resize_ok, char type = '"');
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
@@ -223,20 +275,21 @@ public:
   bool is_sq_string (void) const { return true; }
 
   octave_value do_index_op (const octave_value_list& idx,
 			    bool resize_ok = false)
     { return do_index_op_internal (idx, resize_ok, '\''); }
 
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-  { return octave_value (matrix.sort (dim, mode), true, '\''); }
+    { return octave_value (matrix.sort (dim, mode), true, '\''); }
+
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
 		     sortmode mode = ASCENDING) const
-  { return octave_value (matrix.sort (sidx, dim, mode), true, '\''); }
+    { return octave_value (matrix.sort (sidx, dim, mode), true, '\''); }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -56,17 +56,16 @@ along with Octave; see the file COPYING.
 #include "ov-range.h"
 #include "ov-struct.h"
 #include "ov-class.h"
 #include "ov-streamoff.h"
 #include "ov-list.h"
 #include "ov-cs-list.h"
 #include "ov-colon.h"
 #include "ov-builtin.h"
-#include "ov-mapper.h"
 #include "ov-dld-fcn.h"
 #include "ov-usr-fcn.h"
 #include "ov-fcn-handle.h"
 #include "ov-fcn-inline.h"
 #include "ov-typeinfo.h"
 
 #include "defun.h"
 #include "error.h"
@@ -2164,17 +2163,16 @@ install_types (void)
   octave_sparse_matrix::register_type ();
   octave_sparse_complex_matrix::register_type ();
   octave_struct::register_type ();
   octave_class::register_type ();
   octave_list::register_type ();
   octave_cs_list::register_type ();
   octave_magic_colon::register_type ();
   octave_builtin::register_type ();
-  octave_mapper::register_type ();
   octave_user_function::register_type ();
   octave_dld_function::register_type ();
   octave_fcn_handle::register_type ();
   octave_fcn_inline::register_type ();
   octave_streamoff::register_type ();
 }
 
 #if 0
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -872,16 +872,72 @@ public:
     { return rep->sort (sidx, dim, mode); } 
 
   void lock (void) { rep->lock (); }
 
   void unlock (void) { rep->unlock (); }
 
   bool islocked (void) const { return rep->islocked (); }
 
+#define MAPPER_FORWARD(F) \
+  octave_value F (void) const { return rep->F (); }
+
+  MAPPER_FORWARD (abs)
+  MAPPER_FORWARD (acos)
+  MAPPER_FORWARD (acosh)
+  MAPPER_FORWARD (angle)
+  MAPPER_FORWARD (arg)
+  MAPPER_FORWARD (asin)
+  MAPPER_FORWARD (asinh)
+  MAPPER_FORWARD (atan)
+  MAPPER_FORWARD (atanh)
+  MAPPER_FORWARD (ceil)
+  MAPPER_FORWARD (conj)
+  MAPPER_FORWARD (cos)
+  MAPPER_FORWARD (cosh)
+  MAPPER_FORWARD (erf)
+  MAPPER_FORWARD (erfc)
+  MAPPER_FORWARD (exp)
+  MAPPER_FORWARD (finite)
+  MAPPER_FORWARD (fix)
+  MAPPER_FORWARD (floor)
+  MAPPER_FORWARD (gamma)
+  MAPPER_FORWARD (imag)
+  MAPPER_FORWARD (isinf)
+  MAPPER_FORWARD (isna)
+  MAPPER_FORWARD (isnan)
+  MAPPER_FORWARD (lgamma)
+  MAPPER_FORWARD (log)
+  MAPPER_FORWARD (log10)
+  MAPPER_FORWARD (real)
+  MAPPER_FORWARD (round)
+  MAPPER_FORWARD (signum)
+  MAPPER_FORWARD (sin)
+  MAPPER_FORWARD (sinh)
+  MAPPER_FORWARD (sqrt)
+  MAPPER_FORWARD (tan)
+  MAPPER_FORWARD (tanh)
+  MAPPER_FORWARD (isalnum)
+  MAPPER_FORWARD (isalpha)
+  MAPPER_FORWARD (isascii)
+  MAPPER_FORWARD (iscntrl)
+  MAPPER_FORWARD (isdigit)
+  MAPPER_FORWARD (isgraph)
+  MAPPER_FORWARD (islower)
+  MAPPER_FORWARD (isprint)
+  MAPPER_FORWARD (ispunct)
+  MAPPER_FORWARD (isspace)
+  MAPPER_FORWARD (isupper)
+  MAPPER_FORWARD (isxdigit)
+  MAPPER_FORWARD (toascii)
+  MAPPER_FORWARD (tolower)
+  MAPPER_FORWARD (toupper)
+
+#undef MAPPER_FORWARD
+
 protected:
 
   // The real representation.
   octave_base_value *rep;
 
 private:
 
   assign_op unary_op_to_assign_op (unary_op op);
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -26,17 +26,16 @@ along with Octave; see the file COPYING.
 
 class octave_function;
 class octave_user_function;
 
 class tree_identifier;
 class octave_value;
 class octave_value_list;
 class octave_builtin;
-class octave_mapper;
 class string_vector;
 
 #include <climits>
 #include <cfloat>
 
 #include <string>
 
 #include "ov.h"
