# HG changeset patch
# User Jacob Dawid <jacob.dawid@gmail.com>
# Date 1342471406 14400
#      Mon Jul 16 16:43:26 2012 -0400
# Branch gui
# Node ID 3a05cb67dea5204b66509f5e477931d118dbf068
# Parent  3ff18e21c7427e53a8aa11c4f1c6349dd8fc4408
# Parent  bbdc822be2b90bad536dc1e11424574ae0ef705b
maint: merge of default on gui.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -74,19 +74,20 @@ Summary of important user-visible change
     It now accepts string inputs in the following numerical formats: 12, 21,
     22, 26, 29, 31.  This is undocumented, but verifiable, Matlab behavior.
     In addition, the default for formats which do not specify a date is
     January 1st of the current year.  The previous default was the current day,
     month, and year.  This may produce changes in existing scripts.
 
  ** Other new functions added in 3.8.0:
 
-      colorcube   lines         splinefit
-      erfcinv     rgbplot       tetramesh
-      findfigs    shrinkfaces
+      betaincinv  lines         tetramesh
+      colorcube   rgbplot
+      erfcinv     shrinkfaces
+      findfigs    splinefit
       
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.4 and have been
     removed from Octave 3.8.
                                            
       autocor    dispatch              is_global    strerror
       autocov    fstat                 krylovb      values  
diff --git a/doc/faq/OctaveFAQ.texi b/doc/faq/OctaveFAQ.texi
--- a/doc/faq/OctaveFAQ.texi
+++ b/doc/faq/OctaveFAQ.texi
@@ -449,17 +449,17 @@ function defined in a @file{.m} file is 
 @node Coherent syntax
 @section Coherent syntax
 
 Indexing other things than variables is possible, as in:
 @example
 @group
 octave:1> [3 1 4 1 5 9](3)
 ans = 4
-octave:2> cos([0 pi pi/4 7])(3)
+octave:2> cos ([0 pi pi/4 7])(3)
 ans = 0.70711
 @end group
 @end example
 
 @node Exclamation mark as not operator
 @section Exclamation mark as not operator
 
 The exclamation mark @samp{!} (aka ``Bang!'') is a negation operator, just
@@ -866,30 +866,30 @@ The major differences between Octave 3.4
 @itemize @bullet
 @item Nested Functions
 
 Octave has limited support for nested functions. That is
 
 @example
 @group
 function y = foo (x)
-  y = bar(x)
+  y = bar (x)
   function y = bar (x)
     y = @dots{};
   end
 end
 @end group
 @end example
 
 is equivalent to
 
 @example
 @group
 function y = foo (x)
-   y = bar(x)
+   y = bar (x)
 end
 function y = bar (x)
    y = @dots{};
 end
 @end group
 @end example
 
 The main difference with @sc{Matlab} is a matter of scope. While nested
@@ -1060,17 +1060,17 @@ are different in @sc{Matlab}. This is re
 there is too much code out there that relies on this behaviour to change
 it. Prefer the || and && operators in if statements if possible. If you
 need to use code written for @sc{Matlab} that depends on this buggy
 behaviour, you can enable it since Octave 3.4.0 with the following
 command:
 
 @example
 @group
-  do_braindead_shortcircuit_evaluation(1)
+  do_braindead_shortcircuit_evaluation (1)
 @end group
 @end example
 
 Note that the difference with @sc{Matlab} is also significant when
 either argument is a function with side effects or if the first argument
 is a scalar and the second argument is an empty matrix. For example,
 note the difference between
 
@@ -1097,17 +1097,17 @@ Another case that is documented in the @
 @end example
 
 Also @sc{Matlab} requires the operands of && and || to be scalar values
 but Octave does not (it just applies the rule that for an operand to be
 considered true, every element of the object must be nonzero or
 logically true).
 
 Finally, note the inconsistence of thinking of the condition of an if
-statement as being equivalent to @code{all(X(:))} when @var{X} is a
+statement as being equivalent to @code{all (X(:))} when @var{X} is a
 matrix.  This is true for all cases EXCEPT empty matrices:
 
 @example
 @group
   if ([0, 1]) == if (all ([0, 1]))   ==>  i.e., condition is false.
   if ([1, 1]) == if (all ([1, 1]))   ==>  i.e., condition is true.
 @end group
 @end example
@@ -1142,57 +1142,57 @@ result for these cases.
 
 In the case of under- or over-determined matrices, Octave continues to
 use a minimum norm solution, whereas @sc{Matlab} uses an approach that
 is equivalent to
 
 @example
 @group
 function x = mldivide (A, b)
-  [Q, R, E] = qr(A);
+  [Q, R, E] = qr (A);
   x = [A \ b, E(:, 1:m) * (R(:, 1:m) \ (Q' * b))]
 end
 @end group
 @end example
 
 @noindent
 While this approach is certainly faster and uses less memory than
 Octave's minimum norm approach, this approach seems to be inferior in
 other ways.
 
 A numerical question arises: how big can the null space component
 become, relative to the minimum-norm solution? Can it be nicely bounded,
 or can it be arbitrarily big? Consider this example:
-
+OctaveFAQ.texi
 @example
 @group
 m = 10;
 n = 10000;
-A = ones(m, n) + 1e-6 * randn(m,n);
-b = ones(m, 1) + 1e-6 * randn(m,1);
-norm(A \ b)
+A = ones (m, n) + 1e-6 * randn (m,n);
+b = ones (m, 1) + 1e-6 * randn (m,1);
+norm (A \ b)
 @end group
 @end example
 
 @noindent
 while Octave's minimum-norm values are around 3e-2, @sc{Matlab}'s
 results are 50-times larger. For another issue, try this code:
 
 @example
 @group
 m = 5;
 n = 100;
-j = floor(m * rand(1, n)) + 1;
-b = ones(m, 1);
-A = zeros(m, n);
-A(sub2ind(size(A),j,1:n)) = 1;
+j = floor (m * rand (1, n)) + 1;
+b = ones (m, 1);
+A = zeros (m, n);
+A(sub2ind (size (A),j,1:n)) = 1;
 x = A \ b;
-[dummy,p] = sort(rand(1,n));
-y = A(:,p)\b;
-norm(x(p)-y)
+[dummy,p] = sort (rand (1,n));
+y = A(:,p) \ b;
+norm (x(p)-y)
 @end group
 @end example
 
 @noindent
 It shows that unlike in Octave, mldivide in @sc{Matlab} is not invariant
 with respect to column permutations. If there are multiple columns of
 the same norm, permuting columns of the matrix gets you different
 result than permuting the solution vector. This will surprise many
@@ -1277,20 +1277,20 @@ compared to
 @end example
 
 Typing Ctrl-C in the first case returns the user directly to the
 prompt, and the variable "a" is not reset to the saved value. In the
 second case the variable "a" is reset correctly.  Therefore @sc{Matlab}
 gives no safe way of temporarily changing global variables.
 
 @item
-Indexing can be applied to all objects in Octave and not just
+Indexing can be applied to all objects in Octave and not just a
 variable. Therefore @code{sin(x)(1:10);} for example is perfectly valid
 in Octave but not @sc{Matlab}. To do the same in @sc{Matlab} you must do
-@code{y = sin(x); y = y([1:10]);}
+@code{y = sin (x); y = y([1:10]);}
 
 @item
 Octave has the operators "++", "--", "-=", "+=", "*=", etc.  As
 @sc{Matlab} doesn't, if you are sharing code these should be avoided.
 
 @item
 Character strings in Octave can be denoted with double or single
 quotes. There is a subtle difference between the two in that escaped
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -250,16 +250,18 @@ cos (pi/2)
 @DOCSTRING(airy)
 
 @DOCSTRING(besselj)
 
 @DOCSTRING(beta)
 
 @DOCSTRING(betainc)
 
+@DOCSTRING(betaincinv)
+
 @DOCSTRING(betaln)
 
 @DOCSTRING(bincoeff)
 
 @DOCSTRING(commutation_matrix)
 
 @DOCSTRING(duplication_matrix)
 
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -1018,20 +1018,20 @@ character, @samp{#}, or the percent symb
 end of the line.  Any text following the sharp sign or percent symbol is
 ignored by the Octave interpreter and not executed.  The following example
 shows whole line and partial line comments.
 
 @example
 @group
 function countdown
   # Count down for main rocket engines 
-  disp(3);
-  disp(2);
-  disp(1);
-  disp("Blast Off!");  # Rocket leaves pad
+  disp (3);
+  disp (2);
+  disp (1);
+  disp ("Blast Off!");  # Rocket leaves pad
 endfunction
 @end group
 @end example
 
 @node Block Comments
 @subsection Block Comments
 @cindex block comments
 @cindex multi-line comments
@@ -1041,29 +1041,29 @@ endfunction
 Entire blocks of code can be commented by enclosing the code between 
 matching @samp{#@{} and @samp{#@}} or @samp{%@{} and @samp{%@}} markers.  
 For example,
 
 @example
 @group
 function quick_countdown
   # Count down for main rocket engines 
-  disp(3);
+  disp (3);
  #@{
-  disp(2);
-  disp(1);
+  disp (2);
+  disp (1);
  #@}
-  disp("Blast Off!");  # Rocket leaves pad
+  disp ("Blast Off!");  # Rocket leaves pad
 endfunction
 @end group
 @end example
 
 @noindent
 will produce a very quick countdown from '3' to 'Blast Off' as the
-lines "@code{disp(2);}" and "@code{disp(1);}" won't be executed.
+lines "@code{disp (2);}" and "@code{disp (1);}" won't be executed.
 
 The block comment markers must appear alone as the only characters on a line
 (excepting whitespace) in order to be parsed correctly.
 
 @node Comments and the Help System
 @subsection Comments and the Help System
 @cindex documenting functions
 @cindex documenting user scripts
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -303,46 +303,46 @@ x.a
 @end group
 @end example
 
 Here is another example, using this comma separated list on the
 left-hand side of an assignment:
 
 @example
 @group
-[x.a] = deal("new string1", "new string2");
+[x.a] = deal ("new string1", "new string2");
  x(1).a
      @result{} ans = new string1
  x(2).a
      @result{} ans = new string2
 @end group
 @end example
 
 Just as for numerical arrays, it is possible to use vectors as indices
 (@pxref{Index Expressions}):
 
 @example
 @group
 x(3:4) = x(1:2);
-[x([1,3]).a] = deal("other string1", "other string2");
+[x([1,3]).a] = deal ("other string1", "other string2");
 x.a
      @result{}
         ans = other string1
         ans = new string2
         ans = other string2
         ans = new string2
 @end group
 @end example
 
 The function @code{size} will return the size of the structure.  For
 the example above
 
 @example
 @group
-size(x)
+size (x)
      @result{} ans =
 
           1   4
 @end group
 @end example
 
 Elements can be deleted from a structure array in a similar manner to a
 numerical array, by assigning the elements to an empty matrix.  For
@@ -600,20 +600,20 @@ function.
 
 @DOCSTRING(celldisp)
 
 To test if an object is a cell array, use the @code{iscell}
 function.  For example:
 
 @example
 @group
-iscell(c)
+iscell (c)
      @result{} ans = 1
 
-iscell(3)
+iscell (3)
      @result{} ans = 0
 
 @end group
 @end example
 
 @DOCSTRING(iscell)
 
 @node Creating Cell Arrays
@@ -626,17 +626,17 @@ then fill it with data.
 
 The @code{cell} function returns a cell array of a given size, containing
 empty matrices.  This function is similar to the @code{zeros}
 function for creating new numerical arrays.  The following example creates
 a 2-by-2 cell array containing empty matrices
 
 @example
 @group
-c = cell(2,2)
+c = cell (2,2)
      @result{} c =
          
          @{
            [1,1] = [](0x0)
            [2,1] = [](0x0)
            [1,2] = [](0x0)
            [2,2] = [](0x0)
          @}
@@ -647,19 +647,19 @@ Just like numerical arrays, cell arrays 
 @code{cell} function accepts any number of positive integers to describe
 the size of the returned cell array.  It is also possible to set the size
 of the cell array through a vector of positive integers.  In the
 following example two cell arrays of equal size are created, and the size
 of the first one is displayed
 
 @example
 @group
-c1 = cell(3, 4, 5);
-c2 = cell( [3, 4, 5] );
-size(c1)
+c1 = cell (3, 4, 5);
+c2 = cell ( [3, 4, 5] );
+size (c1)
      @result{} ans =
          3   4   5
 @end group
 @end example
 
 @noindent
 As can be seen, the @ref{doc-size, @code{size}} function also works
 for cell arrays.  As do other functions describing the size of an
@@ -761,17 +761,17 @@ c([1, 2], :) = c([2, 1], :)
 Accessing multiple elements of a cell array with the @samp{@{} and
 @samp{@}} operators will result in a comma-separated list of all the
 requested elements (@pxref{Comma Separated Lists}).  Using the
 @samp{@{} and @samp{@}} operators the first two rows in the above
 example can be swapped back like this:
 
 @example
 @group
-[c@{[1,2], :@}] = deal(c@{[2, 1], :@})
+[c@{[1,2], :@}] = deal (c@{[2, 1], :@})
      @result{} = 
         @{
           [1,1] =  1
           [2,1] =  4
           [1,2] =  2
           [2,2] =  5
           [1,3] =  3
           [2,3] =  6
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -61,57 +61,67 @@ gnulib sources that Octave depends on ar
 @end table
 
 Once you have the required tools installed, you can build Octave by
 doing
 
 @itemize @bullet
 @item
 Check out a copy of the Octave sources:
+
 @example
 hg clone http://hg.savannah.gnu.org/hgweb/octave
 @end example
 
 @item
 Change to the top-level directory of the newly checked out sources:
+
 @example
 cd octave
 @end example
 
 @item
 Generate the necessary configuration files:
+
 @example
 ./autogen.sh
 @end example
 
 @item
 Create a build directory and change to it:
+
 @example
+@group
 mkdir build
 cd build
+@end group
 @end example
+
 By using a separate build directory, you will keep the source directory
 clean and it will be easy to completely remove all files generated by
 the build.  You can also have parallel build trees for different
 purposes that all share the same sources.  For example, one build tree
 may be configured to disable compiler optimization in order to allow for
 easier debugging while another may be configured to test building with
 other specialized compiler flags.
 
 @item
 Run Octave's configure script from the build directory:
+
 @example
 ../configure
 @end example
 
 @item
 Run make in the build directory:
+
 @example
 make
 @end example
+
 @end itemize
 
 Once the build is finished, you will see a message like the following:
 
 @example
 @group
 Octave successfully built.  Now choose from the following:
 
@@ -316,17 +326,17 @@ Always use a specific end-of-block state
 @code{endswitch}) rather than generic @code{end}.
 
 Enclose the @code{if}, @code{while}, @code{until} and @code{switch}
 conditions in parentheses, like in C:
 
 @example
 @group
 if (isvector (a))
-  s = sum(a);
+  s = sum (a);
 endif
 @end group
 @end example
 
 @noindent
 Do not do this, however, with the iteration counter portion of a
 @code{for} statement.  Write:
 
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -88,17 +88,17 @@ Example:
 @result{}
 Diagonal Matrix
 
    1   0   0   0
    0   2   0   0
    0   0   3   0
    0   0   0   4
 
-  diag(1:3,5,3)
+  diag (1:3,5,3)
 
 @result{}
 Diagonal Matrix
 
    1   0   0
    0   2   0
    0   0   3
    0   0   0
@@ -506,16 +506,17 @@ or divided by @code{NaN}.
 The reason for this behavior is that the numerical multiplication is not
 actually performed anywhere by the underlying algorithm; the result is
 just assumed to be zero.  Equivalently, one can say that the part of the
 computation involving assumed zeros is performed symbolically, not numerically.
 
 This behavior not only facilitates the most straightforward and efficient
 implementation of algorithms, but also preserves certain useful invariants,
 like:
+
 @itemize
 @item scalar * diagonal matrix is a diagonal matrix
 
 @item sparse matrix / scalar preserves the sparsity pattern
 
 @item permutation matrix * matrix is equivalent to permuting rows
 @end itemize
 all of these natural mathematical truths would be invalidated by treating
@@ -548,23 +549,23 @@ Inf * full (eye (3))
    Inf   NaN   NaN
    NaN   Inf   NaN
    NaN   NaN   Inf
 
 @end example
 
 @example
 @group
-diag(1:3) * [NaN; 1; 1]
+diag (1:3) * [NaN; 1; 1]
 @result{}
    NaN
      2
      3
 
-sparse(1:3,1:3,1:3) * [NaN; 1; 1]
+sparse (1:3,1:3,1:3) * [NaN; 1; 1]
 @result{}
    NaN
      2
      3
 [1,0,0;0,2,0;0,0,3] * [NaN; 1; 1]
 @result{}
    NaN
    NaN
diff --git a/doc/interpreter/diffeq.txi b/doc/interpreter/diffeq.txi
--- a/doc/interpreter/diffeq.txi
+++ b/doc/interpreter/diffeq.txi
@@ -95,18 +95,18 @@ y = lsode ("f", x0, t);
 @end example
 
 If you try this, you will see that the value of the result changes
 dramatically between @var{t} = 0 and 5, and again around @var{t} = 305.
 A more efficient set of output points might be
 
 @example
 @group
-t = [0, logspace (-1, log10(303), 150), \
-        logspace (log10(304), log10(500), 150)];
+t = [0, logspace(-1, log10(303), 150), \
+        logspace(log10(304), log10(500), 150)];
 @end group
 @end example
 
 See Alan C. Hindmarsh, @cite{ODEPACK, A Systematized Collection of ODE
 Solvers}, in Scientific Computing, R. S. Stepleman, editor, (1983) for
 more information about the inner workings of @code{lsode}.
 
 @node Differential-Algebraic Equations
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -135,16 +135,17 @@ cmd
 cmember
 cntrl
 cof
 coffset
 colamd
 collectoutput
 colorbar
 colormap
+colormaps
 ColorOrder
 colperm
 Comint
 Commandline
 commentstyle
 ComplexEqn
 cond
 condest
@@ -334,16 +335,17 @@ geoinv
 geopdf
 geornd
 GEP
 geq
 gesdd
 gesvd
 gfortan
 Ghostscript
+Ghostscript's
 gif
 GIF
 glibc
 globbing
 glpk
 GLS
 gnulib
 gnuplot
@@ -354,16 +356,17 @@ Gonnet
 goto
 Goto
 gotos
 GPL
 GPLK
 gplot
 grabdemo
 GradObj
+GraphicsAlphaBits
 GraphicsMagick
 Graymap
 grayscale
 Graz
 griddata
 gswin
 GUIs
 gunzipped
@@ -859,16 +862,17 @@ stepsize
 STFT
 STL
 stochastically
 strcmp
 stringanchors
 strncmp
 strncmpi
 strread
+strread's
 struct
 structs
 subarrays
 subdirectories
 subdirectory
 subexpressions
 subfunction
 Subfunction
@@ -915,16 +919,17 @@ symamd
 symbfact
 symrcm
 tcdf
 Tcv
 terminal's
 tex
 texinfo
 Texinfo
+TextAlphaBits
 textscan
 th
 ths
 tif
 Tikhonov
 TikZ
 tinv
 Tisseur
@@ -981,16 +986,17 @@ unifpdf
 unifrnd
 unimodal
 Uninstall
 uninstalled
 univariate
 unnormalized
 unpadded
 unpivoted
+unregister
 unshare
 unsymmetric
 untabified
 uparrow
 Uparrow
 uplus
 userdata
 Username
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -546,17 +546,17 @@ int nel = sm.nelem ();
 @end example
 
 @noindent
 returns the number of non-zero elements.  If the user really requires the
 number of elements in the matrix, including the non-zero elements, they
 should use @code{numel} rather than @code{nelem}.  Note that for very
 large matrices, where the product of the two dimensions is larger than
 the representation of an unsigned int, then @code{numel} can overflow.
-An example is @code{speye(1e6)} which will create a matrix with a million
+An example is @code{speye (1e6)} which will create a matrix with a million
 rows and columns, but only a million non-zero elements.  Therefore the
 number of rows by the number of columns in this case is more than two
 hundred times the maximum value that can be represented by an unsigned int.
 The use of @code{numel} should therefore be avoided useless it is known
 it won't overflow.
 
 Extreme care must be take with the elem method and the "()" operator,
 which perform basically the same function.  The reason is that if a
@@ -896,19 +896,19 @@ passing a function to an oct-file.
 
 The first argument to this demonstration is the user supplied function
 and the following arguments are all passed to the user function.
 
 @example
 @group
 funcdemo (@@sin,1)
 @result{} 0.84147
-funcdemo (@@(x) sin(x), 1)
+funcdemo (@@(x) sin (x), 1)
 @result{} 0.84147
-funcdemo (inline ("sin(x)"), 1)
+funcdemo (inline ("sin (x)"), 1)
 @result{} 0.84147
 funcdemo ("sin",1)
 @result{} 0.84147
 funcdemo (@@atan2, 1, 1)
 @result{} 0.78540
 @end group
 @end example
 
@@ -1003,17 +1003,17 @@ external Fortran function, including pas
 as exception handling.  An example of the behavior of this function is
 
 @example
 @group
 [b, s] = fortdemo (1:3)
 @result{}
   b = 1.00000   0.50000   0.33333
   s = There are   3 values in the input vector
-[b, s] = fortdemo(0:3)
+[b, s] = fortdemo (0:3)
 error: fortsub:divide by zero
 error: exception encountered in Fortran subroutine fortsub_
 error: fortdemo: error in Fortran
 @end group
 @end example
 
 @node Allocating Local Memory in Oct-Files
 @subsection Allocating Local Memory in Oct-Files
@@ -1081,17 +1081,17 @@ methods are automatically released when 
 writing an oct-file, to allow Octave to treat the user typing @kbd{Control-C},
 the @w{@code{OCTAVE_QUIT}} macro is supplied.  For example:
 
 @example
 @group
 for (octave_idx_type i = 0; i < a.nelem (); i++)
   @{
     OCTAVE_QUIT;
-    b.elem(i) = 2. * a.elem(i);
+    b.elem (i) = 2. * a.elem (i);
   @}
 @end group
 @end example
 
 The presence of the @w{@code{OCTAVE_QUIT}} macro in the inner loop allows
 Octave to treat the user request with the @kbd{Control-C}.  Without this macro,
 the user must either wait for the function to return before the interrupt is
 processed, or press @kbd{Control-C} three times to force Octave to exit.
@@ -1190,19 +1190,19 @@ the compiler.  Finally, the Octave test 
 access to the source code of the oct-file and not just the compiled code
 as the tests are stripped from the compiled code.  An example in an
 oct-file might be
 
 @example
 @group
 /*
 
-%!error (sin())
-%!error (sin(1,1))
-%!assert (sin([1,2]),[sin(1),sin(2)])
+%!error (sin ())
+%!error (sin (1,1))
+%!assert (sin ([1,2]),[sin(1),sin(2)])
 
 */
 @end group
 @end example
 
 @c @node Application Programming Interface for Oct-Files
 @c @subsection Application Programming Interface for Oct-Files
 @c 
@@ -1274,17 +1274,17 @@ mkoctfile --mex firstmexdemo.c
 @end example
 
 @noindent
 which creates a file @file{firstmexdemo.mex}.  The function can then be run
 from Octave as
 
 @example
 @group
-firstmexdemo()
+firstmexdemo ()
 @result{} 1.2346
 @end group
 @end example
 
 It should be noted that the mex-file contains no help string for the
 functions it contains.  To document mex-files, there should exist an
 m-file in the same directory as the mex-file itself.  Taking the above as
 an example, we would therefore have a file @file{firstmexdemo.m} that might
@@ -1319,20 +1319,20 @@ mkoctfile --mex myfunc.c
 ln -s myfunc.mex myfunc2.mex
 @end group
 @end example
 
 Then as can be seen by
 
 @example
 @group
-myfunc()
+myfunc ()
 @result{} You called function: myfunc
     This is the principal function
-myfunc2()
+myfunc2 ()
 @result{} You called function: myfunc2
 @end group
 @end example
 
 @noindent
 the behavior of the mex-file can be altered depending on the functions
 name.
 
@@ -1366,17 +1366,17 @@ exists the generic function @code{mxGetD
 that perform the same operation on all matrix types.  For example:
 
 @example
 @group
 mxArray *m;
 mwSize *dims;
 UINT32_T *pr;
 
-dims = (mwSize *) mxMalloc (2 * sizeof(mwSize));
+dims = (mwSize *) mxMalloc (2 * sizeof (mwSize));
 dims[0] = 2;
 dims[1] = 2;
 m = mxCreateNumericArray (2, dims, mxUINT32_CLASS, mxREAL);
 pr =  = (UINT32_T *) mxGetData (m);
 @end group
 @end example
 
 There are also the functions @code{mxSetPr}, etc., that perform the
@@ -1398,18 +1398,18 @@ below.
 @EXAMPLEFILE(mypow2.c)
 @end example
 
 @noindent
 with an example of its use
 
 @example
 @group
-b = randn(4,1) + 1i * randn(4,1);
-all(b.^2 == mypow2(b))
+b = randn (4,1) + 1i * randn (4,1);
+all (b.^2 == mypow2 (b))
 @result{} 1
 @end group
 @end example
 
 
 The example above uses the functions @code{mxGetDimensions},
 @code{mxGetNumberOfElements}, and @code{mxGetNumberOfDimensions} to work
 with the dimensions of multi-dimensional arrays.  The functions
@@ -1429,17 +1429,17 @@ file @file{mystring.c}, as seen below.
 @EXAMPLEFILE(mystring.c)
 @end example
 
 @noindent
 An example of its expected output is
 
 @example
 @group
-mystring(["First String"; "Second String"])
+mystring (["First String"; "Second String"])
 @result{} s1 = Second String
         First String
 @end group
 @end example
 
 Other functions in the mex interface for handling character strings are
 @code{mxCreateString}, @code{mxArrayToString}, and
 @code{mxCreateCharMatrixFromStrings}.  In a mex-file, a character string
@@ -1544,17 +1544,17 @@ found in the file @file{mystruct.c}, as 
 @EXAMPLEFILE(mystruct.c)
 @end example
 
 An example of the behavior of this function within Octave is then
 
 @example
 a(1).f1 = "f11"; a(1).f2 = "f12"; 
 a(2).f1 = "f21"; a(2).f2 = "f22";
-b = mystruct(a)
+b = mystruct (a)
 @result{} field f1(0) = f11
     field f1(1) = f21
     field f2(0) = f12
     field f2(1) = f22
     b =
     @{
       this =
     
@@ -1646,18 +1646,18 @@ using @code{mexCallMATLAB}.  An example 
 @EXAMPLEFILE(myfeval.c)
 @end example
 
 If this code is in the file @file{myfeval.c}, and is compiled to
 @file{myfeval.mex}, then an example of its use is
 
 @example
 @group
-myfeval("sin", 1)
-a = myfeval("sin", 1)
+myfeval ("sin", 1)
+a = myfeval ("sin", 1)
 @result{} Hello, World!
     I have 2 inputs and 1 outputs
     I'm going to call the interpreter function sin
     a =  0.84147
 @end group
 @end example
 
 Note that it is not possible to use function handles or inline functions
diff --git a/doc/interpreter/emacs.txi b/doc/interpreter/emacs.txi
--- a/doc/interpreter/emacs.txi
+++ b/doc/interpreter/emacs.txi
@@ -324,16 +324,17 @@ Normally @samp{\}.
 
 @item octave-mode-startup-message
 If @code{t} (default), a startup message is displayed when Octave mode
 is called.
 
 @end table
 
 If Font Lock mode is enabled, Octave mode will display
+
 @itemize @bullet
 @item
 strings in @code{font-lock-string-face}
 
 @item
 comments in @code{font-lock-comment-face}
 
 @item
@@ -431,16 +432,17 @@ Delete all windows that display the infe
 
 @item C-c i k
 Kill the inferior Octave process and its buffer
 (@code{octave-kill-process}).
 @end table
 
 The effect of the commands which send code to the Octave process can be
 customized by the following variables.
+
 @table @code
 @item octave-send-echo-input
 Non-@code{nil} means echo input sent to the inferior Octave process.
 Default is @code{t}.
 
 @item octave-send-show-buffer
 Non-@code{nil} means display the buffer running the Octave process after
 sending a command (but without selecting it).
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -58,17 +58,17 @@ described in @ref{The @code{try} Stateme
 The most common use of errors is for checking input arguments to
 functions.  The following example calls the @code{error} function if
 the function @code{f} is called without any input arguments.
 
 @example
 @group
 function f (arg1)
   if (nargin == 0)
-    error("not enough input arguments");
+    error ("not enough input arguments");
   endif
 endfunction
 @end group
 @end example
 
 When the @code{error} function is called, it prints the given message
 and returns to the Octave prompt.  This means that no code following
 a call to @code{error} will be executed.
diff --git a/doc/interpreter/eval.txi b/doc/interpreter/eval.txi
--- a/doc/interpreter/eval.txi
+++ b/doc/interpreter/eval.txi
@@ -122,18 +122,18 @@ endfunction
 @end example
 
 With @code{evalin}, you could write @code{save} as follows:
 
 @example
 @group
 function save (file, name1, name2)
   f = open_save_file (file);
-  save_var(f, name1, evalin ("caller", name1));
-  save_var(f, name2, evalin ("caller", name2));
+  save_var (f, name1, evalin ("caller", name1));
+  save_var (f, name2, evalin ("caller", name2));
 endfunction
 @end group
 @end example
 
 @noindent
 Here, @samp{caller} is the @code{create_data} function and @code{name1}
 is the string @code{"x"}, which evaluates simply as the value of @code{x}.
 
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -253,17 +253,17 @@ operation and judicious use of it can re
 looping over individual array elements which is a slow operation.
 
 Consider the following example which creates a 10-element row vector
 @math{a} containing the values
 @tex
 $a_i = \sqrt{i}$.
 @end tex
 @ifnottex
-a(i) = sqrt(i).
+a(i) = sqrt (i).
 @end ifnottex
 
 @example
 @group
 for i = 1:10
   a(i) = sqrt (i);
 endfor
 @end group
@@ -767,18 +767,18 @@ True if @var{x} is not equal to @var{y}.
 @end table
 
 For complex numbers, the following ordering is defined:
 @var{z1} < @var{z2}
 iff
 
 @example
 @group
-  abs(@var{z1}) < abs(@var{z2}) 
-  || (abs(@var{z1}) == abs(@var{z2}) && arg(@var{z1}) < arg(@var{z2}))
+  abs (@var{z1}) < abs (@var{z2}) 
+  || (abs (@var{z1}) == abs (@var{z2}) && arg (@var{z1}) < arg (@var{z2}))
 @end group
 @end example
 
 This is consistent with the ordering used by @dfn{max}, @dfn{min} and
 @dfn{sort}, but is not consistent with @sc{matlab}, which only compares the real
 parts.
 
 String comparisons may also be performed with the @code{strcmp}
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -39,37 +39,45 @@ like built-in functions.
 * Default Arguments::   
 * Function Files::              
 * Script Files::                
 * Function Handles Inline Functions and Anonymous Functions::
 * Commands::
 * Organization of Functions::   
 @end menu
 
-@node  Introduction to Function and Script Files
-@section  Introduction to Function and Script Files
+@node Introduction to Function and Script Files
+@section Introduction to Function and Script Files
 
-There are six different things covered in this section.
+There are seven different things covered in this section.
 @enumerate
 @item
 Typing in a function at the command prompt.
+
 @item
-Storing a group of commands in a file - called a script file.
+Storing a group of commands in a file --- called a script file.
+
 @item
-Storing a function in a file - called a function file.
+Storing a function in a file---called a function file.
+
 @item
-Sub-functions in function files.
+Subfunctions in function files.
+
 @item
 Multiple functions in one script file.
+
 @item
 Private functions.
+
+@item
+Nested functions.
 @end enumerate
 
 Both function files and script files end with an extension of .m, for
-@sc{Matlab} compatibility. If you want more than one independent
+@sc{matlab} compatibility.  If you want more than one independent
 functions in a file, it must be a script file (@pxref{Script Files}),
 and to use these functions you must execute the script file before you
 can use the functions that are in the script file.
 
 @node Defining Functions
 @section Defining Functions
 @cindex @code{function} statement
 @cindex @code{endfunction} statement
@@ -738,16 +746,17 @@ ignore the time stamps for all function 
 @DOCSTRING(mfilename)
 
 @DOCSTRING(ignore_function_time_stamp)
 
 @menu
 * Manipulating the Load Path::
 * Subfunctions::
 * Private Functions::
+* Nested Functions::
 * Overloading and Autoloading::
 * Function Locking::
 * Function Precedence::
 @end menu
 
 @node Manipulating the Load Path
 @subsection Manipulating the Load Path
 
@@ -758,17 +767,17 @@ a list of directories distributed with O
 working directory.  To see your current load path call the @code{path}
 function without any input or output arguments.
 
 It is possible to add or remove directories to or from the load path
 using @code{addpath} and @code{rmpath}.  As an example, the following
 code adds @samp{~/Octave} to the load path.
 
 @example
-addpath("~/Octave")
+addpath ("~/Octave")
 @end example
 
 @noindent
 After this the directory @samp{~/Octave} will be searched for functions.
  
 @DOCSTRING(addpath)
 
 @DOCSTRING(genpath)
@@ -846,16 +855,167 @@ endfunction
 @end example
 
 @noindent
 Then if the path to @code{func1} is @code{<directory>/func1.m}, and if
 @code{func2} is found in the directory @code{<directory>/private/func2.m}, 
 then @code{func2} is only available for use of the functions, like 
 @code{func1}, that are found in @code{<directory>}.
 
+@node Nested Functions
+@subsection Nested Functions
+
+Nested functions are similar to subfunctions in that only the main function is
+visible outside the file.  However, they also allow for child functions to
+access the local variables in their parent function.  This shared access mimics
+using a global variable to share information --- but a global variable which is
+not visible to the rest of Octave.  As a programming strategy, sharing data
+this way can create code which is difficult to maintain.  It is recommended to
+use subfunctions in place of nested functions when possible.
+
+As a simple example, consider a parent function @code{foo}, that calls a nested
+child function @code{bar}, with a shared variable @var{x}.
+
+@example
+@group
+function y = foo ()
+  x = 10;
+  bar ();
+  y = x;
+
+  function bar ()
+    x = 20;
+  endfunction
+endfunction
+
+foo ()
+ @result{} 20
+@end group
+@end example
+
+@noindent
+Notice that there is no special syntax for sharing @var{x}.  This can lead to
+problems with accidental variable sharing between a parent function and its
+child.  While normally variables are inherited, child function parameters and
+return values are local to the child function.
+
+Now consider the function @code{foobar} that uses variables @var{x} and
+@var{y}.  @code{foobar} calls a nested function @code{foo} which takes
+@var{x} as a parameter and returns @var{y}.  @code{foo} then calls @code{bat}
+which does some computation.
+
+@example
+@group
+function z = foobar ()
+  x = 0;
+  y = 0;
+  z = foo (5);
+  z += x + y;
+
+  function y = foo (x)
+    y = x + bat ();
+
+    function z = bat ()
+      z = x;
+    endfunction
+  endfunction
+endfunction
+
+foobar ()
+    @result{} 10
+@end group
+@end example
+
+@noindent
+It is important to note that the @var{x} and @var{y} in @code{foobar} remain
+zero, as in @code{foo} they are a return value and parameter respectively.  The
+@var{x} in @code{bat} refers to the @var{x} in @code{foo}.
+
+Variable inheritance leads to a problem for @code{eval} and scripts.  If a
+new variable is created in a parent function, it is not clear what should happen
+in nested child functions.  For example, consider a parent function @code{foo}
+with a nested child function @code{bar}:
+
+@example
+@group
+function y = foo (to_eval)
+  bar ();
+  eval (to_eval);
+
+  function bar ()
+    eval ("x = 100;");
+    eval ("y = x;");
+  endfunction
+endfunction
+
+foo ("x = 5;")
+    @result{} error: can not add variable "x" to a static workspace
+
+foo ("y = 10;")
+    @result{} 10
+
+foo ("")
+    @result{} 100
+@end group
+@end example
+
+@noindent
+The parent function @code{foo} is unable to create a new variable
+@var{x}, but the child function @code{bar} was successful.  Furthermore, even
+in an @code{eval} statement @var{y} in @code{bar} is the same @var{y} as in its
+parent function @code{foo}.  The use of @code{eval} in conjunction with nested
+functions is best avoided.
+
+As with subfunctions, only the first nested function in a file may be called
+from the outside.  Inside a function the rules are more complicated.  In
+general a nested function may call:
+
+@enumerate 0
+@item
+Globally visible functions
+
+@item
+Any function that the nested function's parent can call
+
+@item
+Sibling functions (functions that have the same parents)
+
+@item
+Direct children
+
+@end enumerate
+
+As a complex example consider a parent function @code{ex_top} with two
+child functions, @code{ex_a} and @code{ex_b}.  In addition, @code{ex_a} has two
+more child functions, @code{ex_aa} and @code{ex_ab}.  For example:
+
+@example
+function ex_top ()
+  ## Can call: ex_top, ex_a, and ex_b
+  ## Can NOT call: ex_aa and ex_ab
+
+  function ex_a ()
+    ## Call call everything
+
+    function ex_aa ()
+      ## Can call everything
+    endfunction
+
+    function ex_ab ()
+      ## Can call everything
+    endfunction
+  endfunction
+
+  function ex_b ()
+    ## Can call: ex_top, ex_a, and ex_b
+    ## Can NOT call: ex_aa and ex_ab
+  endfunction
+endfunction
+@end example
+
 @node Overloading and Autoloading
 @subsection Overloading and Autoloading
 
 Functions can be overloaded to work with different input arguments.  For
 example, the operator '+' has been overloaded in Octave to work with single,
 double, uint8, int32, and many other arguments.  The preferred way to overload
 functions is through classes and object oriented programming 
 (@pxref{Function Overloading}).  Occasionally, however, one needs to undo
@@ -912,17 +1072,17 @@ mislocked ("my_function")
 @end group
 @end example
 
 A common use of @code{mlock} is to prevent persistent variables from
 being removed from memory, as the following example shows:
 
 @example
 @group
-function count_calls()
+function count_calls ()
   persistent calls = 0;
   printf ("'count_calls' has been called %d times\n",
           ++calls);
 endfunction
 mlock ("count_calls");
 
 count_calls ();
 @print{} 'count_calls' has been called 1 times
@@ -1235,17 +1395,17 @@ environment.
 @node Inline Functions
 @subsection Inline Functions
 
 An inline function is created from a string containing the function
 body using the @code{inline} function.  The following code defines the
 function @math{f(x) = x^2 + 2}.
 
 @example
-f = inline("x^2 + 2");
+f = inline ("x^2 + 2");
 @end example
 
 @noindent
 After this it is possible to evaluate @math{f} at any @math{x} by
 writing @code{f(x)}.
 
 @DOCSTRING(inline)
 
@@ -1265,17 +1425,17 @@ it can also be called without the parent
 @example
 my_command hello world
 @end example
 
 @noindent
 is equivalent to 
 
 @example
-my_command("hello", "world")
+my_command ("hello", "world")
 @end example
 
 @noindent
 The general form of a command call is
 
 @example
 @var{cmdname} @var{arg1} @var{arg2} @dots{}
 @end example
diff --git a/doc/interpreter/geometry.txi b/doc/interpreter/geometry.txi
--- a/doc/interpreter/geometry.txi
+++ b/doc/interpreter/geometry.txi
@@ -67,17 +67,17 @@ An example of a Delaunay triangulation o
 @group
 rand ("state", 2);
 x = rand (10, 1);
 y = rand (10, 1);
 T = delaunay (x, y);
 X = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
 Y = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
 axis ([0, 1, 0, 1]);
-plot(X, Y, "b", x, y, "r*");
+plot (X, Y, "b", x, y, "r*");
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:delaunay}.
 
 @float Figure,fig:delaunay
@@ -167,28 +167,28 @@ sum (@var{beta}(1:@var{N}+1)) == 1
 @end example
 
 @noindent
 is imposed, and we can therefore write the above as
 
 @example
 @group
 @var{p} - @var{t}(end, :) = @var{beta}(1:end-1) * (@var{t}(1:end-1, :)
-      - ones(@var{N}, 1) * @var{t}(end, :)
+      - ones (@var{N}, 1) * @var{t}(end, :)
 @end group
 @end example
 
 @noindent
 Solving for @var{beta} we can then write
 
 @example
 @group
 @var{beta}(1:end-1) = (@var{p} - @var{t}(end, :)) / (@var{t}(1:end-1, :)
-      - ones(@var{N}, 1) * @var{t}(end, :))
-@var{beta}(end) = sum(@var{beta}(1:end-1))
+      - ones (@var{N}, 1) * @var{t}(end, :))
+@var{beta}(end) = sum (@var{beta}(1:end-1))
 @end group
 @end example
 
 @noindent
 which gives the formula for the conversion of the Cartesian coordinates
 of the point @var{p} to the Barycentric coordinates @var{beta}.  An
 important property of the Barycentric coordinates is that for all points
 in the N-simplex
@@ -293,19 +293,19 @@ simplices of the Delaunay tessellation.
 @DOCSTRING(voronoi)
 
 @DOCSTRING(voronoin)
 
 An example of the use of @code{voronoi} is
 
 @example
 @group
-rand("state",9);
-x = rand(10,1);
-y = rand(10,1);
+rand ("state",9);
+x = rand (10,1);
+y = rand (10,1);
 tri = delaunay (x, y);
 [vx, vy] = voronoi (x, y, tri);
 triplot (tri, x, y, "b");
 hold on;
 plot (vx, vy, "r");
 @end group
 @end example
 
@@ -331,17 +331,17 @@ with the @code{polyarea} and @code{inpol
 An example of the use of @code{polyarea} might be 
 
 @example
 @group
 rand ("state", 2);
 x = rand (10, 1);
 y = rand (10, 1);
 [c, f] = voronoin ([x, y]);
-af = zeros (size(f));
+af = zeros (size (f));
 for i = 1 : length (f)
   af(i) = polyarea (c (f @{i, :@}, 1), c (f @{i, :@}, 2));
 endfor
 @end group
 @end example
 
 Facets of the Voronoi diagram with a vertex at infinity have infinity
 area.  A simplified version of @code{polyarea} for rectangles is
@@ -356,17 +356,17 @@ An example of the use of @code{inpolygon
 @example
 @group
 randn ("state", 2);
 x = randn (100, 1);
 y = randn (100, 1);
 vx = cos (pi * [-1 : 0.1: 1]);
 vy = sin (pi * [-1 : 0.1 : 1]);
 in = inpolygon (x, y, vx, vy);
-plot(vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
+plot (vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
 axis ([-2, 2, -2, 2]);
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:inpolygon}.
 
@@ -429,22 +429,22 @@ interpolation are @code{griddata}, @code
 @DOCSTRING(griddata3)
 
 @DOCSTRING(griddatan)
 
 An example of the use of the @code{griddata} function is
 
 @example
 @group
-rand("state",1);
-x=2*rand(1000,1)-1;
-y=2*rand(size(x))-1;
-z=sin(2*(x.^2+y.^2));
-[xx,yy]=meshgrid(linspace(-1,1,32));
-griddata(x,y,z,xx,yy);
+rand ("state", 1);
+x = 2*rand (1000,1) - 1;
+y = 2*rand (size (x)) - 1;
+z = sin (2*(x.^2+y.^2));
+[xx,yy] = meshgrid (linspace (-1,1,32));
+griddata (x,y,z,xx,yy);
 @end group
 @end example
 
 @noindent
 that interpolates from a random scattering of points, to a uniform
 grid. 
 @ifnotinfo
 The output of the above can be seen in @ref{fig:griddata}.
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -69,17 +69,17 @@ yourself.
 * Build Tools::
 * External Packages::
 @end menu
 
 @node Obtaining the Dependencies Automatically
 @subsection Obtaining the Dependencies Automatically
 
 On some systems you can obtain many of Octave's build dependencies
-automatically. The commands for doing this vary by system. Similarly,
+automatically.  The commands for doing this vary by system.  Similarly,
 the names of pre-compiled packages vary by system and do not always
 match exactly the names listed in @ref{Build Tools} and @ref{External
 Packages}.
 
 You will usually need the development version of an external dependency
 so that you get the libraries and header files for building software,
 not just for running already compiled programs.  These packages
 typically have names that end with the suffix @code{-dev} or @code{-devel}.
@@ -177,18 +177,20 @@ Automake.
 The following external packages are required:
 
 @table @asis
 @item BLAS
 Basic Linear Algebra Subroutine library
 (@url{http://www.netlib.org/blas}).  Accelerated BLAS libraries such as
 ATLAS (@url{http://math-atlas.sourceforge.net}) are recommeded for
 better performance.
+
 @item LAPACK
 Linear Algebra Package (@url{http://www.netlib.org/lapack}).
+
 @item PCRE
 The Perl Compatible Regular Expression library (http://www.pcre.org).
 @end table
 
 The following external package is optional but strongly recommended:
 
 @table @asis
 @item GNU Readline
@@ -244,17 +246,17 @@ GraphicsMagick++ is used to provide the 
 functions.
 
 @item HDF5
 Library for manipulating portable data files
 (@url{http://www.hdfgroup.org/HDF5}).  HDF5 is required for Octave's
 @code{load} and @code{save} commands to read and write HDF data files.
 
 @item OpenGL
-API for portable 2D and 3D graphics (@url{http://www.opengl.org}).  An
+API for portable 2-D and 3-D graphics (@url{http://www.opengl.org}).  An
 OpenGL implementation is required to provide Octave's OpenGL-based
 graphics functions.  Octave's OpenGL-based graphics functions usually
 outperform the gnuplot-based graphics functions because plot data can be
 rendered directly instead of sending data and commands to gnuplot for
 interpretation and rendering.
 
 @item Qhull
 Computational geometry library (@url{http://www.qhull.org}).  Qhull is
@@ -272,17 +274,17 @@ provide improved performance for the fun
 Sparse matrix factorization library
 (@url{http://www.cise.ufl.edu/research/sparse/SuiteSparse}).
 SuiteSparse is required to provide sparse matrix factorizations and
 solution of linear equations for sparse systems.
 
 @item zlib
 Data compression library (@url{http://zlib.net}).  The zlib library is
 required for Octave's @code{load} and @code{save} commands to handle
-compressed data, including @sc{Matlab} v5 MAT files.
+compressed data, including @sc{matlab} v5 MAT files.
 @end table
 
 @node Running Configure and Make
 @section Running Configure and Make
 
 @itemize @bullet
 @item
 Run the shell script @file{configure}.  This will determine the features
diff --git a/doc/interpreter/interp.txi b/doc/interpreter/interp.txi
--- a/doc/interpreter/interp.txi
+++ b/doc/interpreter/interp.txi
@@ -45,27 +45,27 @@ discontinuous, then 'pchip' interpolatio
 This can be demonstrated by the code
 
 @example
 @group
 t = -2:2;
 dt = 1;
 ti =-2:0.025:2;
 dti = 0.025;
-y = sign(t);
-ys = interp1(t,y,ti,'spline');
-yp = interp1(t,y,ti,'pchip');
-ddys = diff(diff(ys)./dti)./dti;
-ddyp = diff(diff(yp)./dti)./dti;
-figure(1);
-plot (ti, ys,'r-', ti, yp,'g-');
-legend('spline','pchip',4);
-figure(2);
-plot (ti, ddys,'r+', ti, ddyp,'g*');
-legend('spline','pchip');
+y = sign (t);
+ys = interp1 (t,y,ti,'spline');
+yp = interp1 (t,y,ti,'pchip');
+ddys = diff (diff (ys)./dti) ./ dti;
+ddyp = diff (diff (yp)./dti) ./ dti;
+figure (1);
+plot (ti,ys,'r-', ti,yp,'g-');
+legend ('spline', 'pchip', 4);
+figure (2);
+plot (ti,ddys,'r+', ti,ddyp,'g*');
+legend ('spline', 'pchip');
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:interpderiv1} and
 @ref{fig:interpderiv2}.
 
@@ -102,19 +102,19 @@ points.  An example of the use of @code{
 
 @example
 @group
 t = 0 : 0.3 : pi; dt = t(2)-t(1);
 n = length (t); k = 100;
 ti = t(1) + [0 : k-1]*dt*n/k;
 y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
-plot (ti, yp, 'g', ti, interp1(t, y, ti, 'spline'), 'b', ...
+plot (ti, yp, 'g', ti, interp1 (t, y, ti, 'spline'), 'b', ...
       ti, interpft (y, k), 'c', t, y, 'r+');
-legend ('sin(4t+0.3)cos(3t-0.1','spline','interpft','data');
+legend ('sin(4t+0.3)cos(3t-0.1', 'spline', 'interpft', 'data');
 @end group
 @end example
 
 @noindent
 @ifinfo
 which demonstrates the poor behavior of Fourier interpolation for non-periodic
 functions.
 @end ifinfo
@@ -159,19 +159,19 @@ Consider the example,
 @example
 @group
 x = y = z = -1:1;
 f = @@(x,y,z) x.^2 - y - z.^2;
 [xx, yy, zz] = meshgrid (x, y, z);
 v = f (xx,yy,zz);
 xi = yi = zi = -1:0.1:1;
 [xxi, yyi, zzi] = meshgrid (xi, yi, zi);
-vi = interp3(x, y, z, v, xxi, yyi, zzi, 'spline');
+vi = interp3 (x, y, z, v, xxi, yyi, zzi, 'spline');
 [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-vi2 = interpn(x, y, z, v, xxi, yyi, zzi, 'spline');
+vi2 = interpn (x, y, z, v, xxi, yyi, zzi, 'spline');
 mesh (zi, yi, squeeze (vi2(1,:,:)));
 @end group
 @end example
 
 @noindent
 where @code{vi} and @code{vi2} are identical.  The reversal of the
 dimensions is treated in the @code{meshgrid} and @code{ndgrid} functions
 respectively.
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -99,17 +99,17 @@ e     = -1
 @end display
 @end ifnottex
 
 @noindent
 type the following which will evaluate to @code{-1} within the
 tolerance of the calculation. 
 
 @example
-octave:1> exp(i*pi)
+octave:1> exp (i*pi)
 @end example
 
 @subsection Creating a Matrix
 
 Vectors and matrices are the basic building blocks for numerical analysis.  
 To create a new matrix and store it in a variable so that you can
 refer to it later, type the command
 
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -565,17 +565,17 @@ can't be represented using the chosen in
 not possible to represent the result of @math{10 - 20} when using
 unsigned integers.  Octave makes sure that the result of integer
 computations is the integer that is closest to the true result.  So, the
 result of @math{10 - 20} when using unsigned integers is zero.
 
 When doing integer division Octave will round the result to the nearest
 integer.  This is different from most programming languages, where the
 result is often floored to the nearest integer.  So, the result of
-@code{int32(5) ./ int32(8)} is @code{1}.
+@code{int32 (5) ./ int32 (8)} is @code{1}.
 
 @DOCSTRING(idivide)
 
 @node Bit Manipulations
 @section Bit Manipulations
 
 Octave provides a number of functions for the manipulation of numeric
 values on a bit by bit basis.  The basic functions to set and obtain the
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -179,17 +179,17 @@ An example of a display method for the p
 @example
 @group
 @EXAMPLEFILE(@polynomial/display.m)
 @end group
 @end example
 
 @noindent
 Note that in the display method, it makes sense to start the method
-with the line @code{fprintf("%s =", inputname(1))} to be consistent
+with the line @code{fprintf ("%s =", inputname (1))} to be consistent
 with the rest of Octave and print the variable name to be displayed
 when displaying the class. 
 
 To be consistent with the Octave graphic handle classes, a class
 should also define the @code{get} and @code{set} methods.  The
 @code{get} method should accept one or two arguments, and given one
 argument of the appropriate class it should return a structure with
 all of the properties of the class.  For example:
@@ -312,17 +312,17 @@ look like
 
 @noindent
 which is a fairly generic @code{end} method that has a behavior similar to
 the @code{end} keyword for Octave Array classes.  It can then be used as 
 follows:
 
 @example
 @group
-p = polynomial([1,2,3,4]);
+p = polynomial ([1,2,3,4]);
 p(end-1)
   @result{} 3
 @end group
 @end example
 
 Objects can also be used as the index in a subscripted expression themselves
 and this is controlled with the @code{subsindex} function.
 
@@ -349,17 +349,17 @@ a call to subsasgn:
 
 @noindent
 and the corresponding method looking like this:
 
 @example
 @group
   function x = subsasgn (x, ss, val)
     @dots{}
-    x.myfield(ss.subs@{1@}) = val;
+    x.myfield (ss.subs@{1@}) = val;
   endfunction
 @end group
 @end example
 
 The problem is that on entry to the subsasgn method, @code{x} is still
 referenced from the caller's scope, which means that the method will 
 first need to unshare (copy) @code{x} and @code{x.myfield} before performing
 the assignment.  Upon completing the call, unless an error occurs,
@@ -581,17 +581,17 @@ width 0.6pt \tabskip=0pt\cr
 @item @tab a .^ b @tab power (a, b) @tab Element-wise power operator @tab
 @item @tab a ^ b @tab mpower (a, b) @tab Matrix power operator @tab
 @item @tab a < b @tab lt (a, b) @tab Less than operator @tab
 @item @tab a <= b @tab le (a, b) @tab Less than or equal to operator @tab
 @item @tab a > b @tab gt (a, b) @tab Greater than operator @tab
 @item @tab a >= b @tab ge (a, b) @tab Greater than or equal to operator @tab
 @item @tab a == b @tab eq (a, b) @tab Equal to operator @tab
 @item @tab a != b @tab ne (a, b) @tab Not equal to operator @tab
-@item @tab a \& b @tab and (a, b) @tab Logical and operator @tab
+@item @tab a & b @tab and (a, b) @tab Logical and operator @tab
 @item @tab a | b @tab or (a, b) @tab Logical or operator @tab
 @item @tab ! b @tab not (a) @tab Logical not operator @tab
 @item @tab a' @tab ctranspose (a) @tab Complex conjugate transpose operator @tab
 @item @tab a.' @tab transpose (a) @tab Transpose operator @tab
 @item @tab a : b @tab colon (a, b) @tab Two element range operator @tab
 @item @tab a : b : c @tab colon (a, b, c) @tab Three element range operator @tab
 @item @tab [a, b] @tab horzcat (a, b) @tab Horizontal concatenation operator @tab
 @item @tab [a; b] @tab vertcat (a, b) @tab Vertical concatenation operator @tab
@@ -721,25 +721,25 @@ Note that we have used the polynomial fi
 the filter coefficients.
 
 Once we have the class constructor and display method, we may create
 an object by calling the class constructor.  We may also check the
 class type and examine the underlying structure.
 
 @example
 @group
-octave:1> f=FIRfilter(polynomial([1 1 1]/3))
+octave:1> f = FIRfilter (polynomial ([1 1 1]/3))
 f.polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
-octave:2> class(f)
+octave:2> class (f)
 ans = FIRfilter
-octave:3> isa(f,"FIRfilter")
+octave:3> isa (f,"FIRfilter")
 ans =  1
-octave:4> isa(f,"polynomial")
+octave:4> isa (f,"polynomial")
 ans =  1
-octave:5> struct(f)
+octave:5> struct (f)
 ans = 
 @{
 polynomial = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 @}
 @end group
 @end example
 
 We only need to define a method to actually process data with our
@@ -754,34 +754,34 @@ to access the fields.  The @code{subsref
 @end group
 @end example
 
 The "()" case allows us to filter data using the polynomial provided
 to the constructor.
 
 @example
 @group
-octave:2> f=FIRfilter(polynomial([1 1 1]/3));
-octave:3> x=ones(5,1);
-octave:4> y=f(x)
+octave:2> f = FIRfilter (polynomial ([1 1 1]/3));
+octave:3> x = ones (5,1);
+octave:4> y = f(x)
 y =
 
    0.33333
    0.66667
    1.00000
    1.00000
    1.00000
 @end group
 @end example
 
 The "." case allows us to view the contents of the polynomial field.
 
 @example
 @group
-octave:1> f=FIRfilter(polynomial([1 1 1]/3));
+octave:1> f = FIRfilter (polynomial ([1 1 1]/3));
 octave:2> f.polynomial
 ans = 0.333333 + 0.333333 * X + 0.333333 * X ^ 2
 @end group
 @end example
 
 In order to change the contents of the object, we need to define a
 @code{subsasgn} method.  For example, we may make the polynomial field
 publicly writable.
@@ -791,23 +791,22 @@ publicly writable.
 @EXAMPLEFILE(@FIRfilter/subsasgn.m)
 @end group
 @end example
 
 So that
 
 @example
 @group
-octave:6> f=FIRfilter();
-octave:7> f.polynomial = polynomial([1 2 3]);
+octave:6> f = FIRfilter ();
+octave:7> f.polynomial = polynomial ([1 2 3]);
 f.polynomial = 1 + 2 * X + 3 * X ^ 2
 @end group
 @end example
 
-
 Defining the FIRfilter class as a child of the polynomial class
 implies that and FIRfilter object may be used any place that a
 polynomial may be used.  This is not a normal use of a filter, so that
 aggregation may be a more sensible design approach.  In this case, the
 polynomial is simply a field in the class structure.  A class
 constructor for this case might be
 
 @example
diff --git a/doc/interpreter/package.txi b/doc/interpreter/package.txi
--- a/doc/interpreter/package.txi
+++ b/doc/interpreter/package.txi
@@ -1,9 +1,9 @@
-@c Copyright (C) 2007-2012 Sren Hauberg
+@c Copyright (C) 2007-2012 Sren Hauberg
 @c
 @c This file is part of Octave.
 @c
 @c Octave is free software; you can redistribute it and/or modify it
 @c under the terms of the GNU General Public License as published by the
 @c Free Software Foundation; either version 3 of the License, or (at
 @c your option) any later version.
 @c 
@@ -176,17 +176,16 @@ called without a new path, the current p
 @node Creating Packages
 @section Creating Packages
 
 Internally a package is simply a gzipped tar file that contains a
 top level directory of any given name.  This directory will in the
 following be referred to as @code{package} and may contain the
 following files:
 
-@noindent
 @table @code
 @item package/COPYING
 This is a required file containing the license of the package.  No
 restrictions is made on the license in general.  If however the
 package contains dynamically linked functions the license must be
 compatible with the GNU General Public License.
 
 @item package/DESCRIPTION
@@ -255,17 +254,16 @@ package.
 @item package/on_uninstall.m
 This is an optional script that is run prior to the removal of a
 package. 
 @end table
 
 Besides the above mentioned files, a package can also contain on or
 more of the following directories:
 
-@noindent
 @table @code
 @item package/inst
 An optional directory containing any files that are directly installed
 by the package.  Typically this will include any @code{m}-files. 
 
 @item package/src
 An optional directory containing code that must be built prior to the
 packages installation.  The Octave package manager will execute
@@ -300,17 +298,16 @@ external scripts, etc., called by functi
 
 @node The DESCRIPTION File
 @subsection The DESCRIPTION File
 
 The @file{DESCRIPTION} file contains various information about the
 package, such as its name, author, and version.  This file has a very
 simple format
 
-@noindent
 @itemize
 @item
 Lines starting with @samp{#} are comments.
 
 @item
 Lines starting with a blank character are continuations from the 
 previous line.
 
@@ -335,17 +332,16 @@ Description: A short description of the 
  on the next by adding a space to the beginning of the
  following lines.
 License: GPL version 3 or later
 @end group
 @end example
 
 The package manager currently recognizes the following keywords
 
-@noindent
 @table @code
 @item Name
 Name of the package.
 
 @item Version
 Version of the package.  A package version must be 3 numbers separated
 by a dot.
 
@@ -436,17 +432,16 @@ RPMs are built on a Mandriva distributio
 name will be used instead. 
 
 @node The INDEX File
 @subsection The INDEX File
 
 The optional @file{INDEX} file provides a categorical view of the
 functions in the package.  This file has a very simple format
 
-@noindent
 @itemize
 @item Lines beginning with @samp{#} are comments.
 
 @item The first non-comment line should look like this
 
 @example
 toolbox >> Toolbox name
 @end example
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -806,21 +806,21 @@ width 0.6pt \tabskip=0pt\cr
 @caption{Available special characters in @TeX{} mode}
 @end float
 
 A complete example showing the capabilities of the extended text is
 
 @example
 @group
 x = 0:0.01:3;
-plot(x,erf(x));
+plot (x, erf (x));
 hold on;
-plot(x,x,"r");
-axis([0, 3, 0, 1]);
-text(0.65, 0.6175, strcat('\leftarrow x = @{2/\surd\pi',
+plot (x,x,"r");
+axis ([0, 3, 0, 1]);
+text (0.65, 0.6175, strcat ('\leftarrow x = @{2/\surd\pi',
 ' @{\fontsize@{16@}\int_@{\fontsize@{8@}0@}^@{\fontsize@{8@}x@}@}',
 ' e^@{-t^2@} dt@} = 0.6175'))
 @end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:extendedtext}
@@ -839,17 +839,17 @@ The result of which can be seen in @ref{
 The @code{print} command allows you to send plots to you printer and
 to save plots in a variety of formats.  For example,
 
 @example
 print -dpsc
 @end example
 
 @noindent
-prints the current figure to a color PostScript printer. And,
+prints the current figure to a color PostScript printer.  And,
 
 @example
 print -deps foo.eps
 @end example
 
 @noindent
 saves the current figure to an encapsulated PostScript file called
 @file{foo.eps}.
@@ -1175,16 +1175,17 @@ In this Section the object properties ar
 with the root figure properties and continuing through the graphics object
 hierarchy.
 
 @node Root Figure Properties
 @subsubsection Root Figure Properties
 @cindex root figure properties
 
 The @code{root figure} properties are:
+
 @table @code
 @item __modified__  
 --- Values: "on," "off"
 
 @item __myhandle__
 
 @item beingdeleted  
 --- Values: "on," "off"
@@ -1247,16 +1248,17 @@ The @code{root figure} properties are:
 @item visible
 @end table
 
 @node Figure Properties
 @subsubsection Figure Properties
 @cindex figure properties
 
 The @code{figure} properties are:
+
 @table @code
 @item __graphics_toolkit__  
 --- The graphics toolkit currently in use.
 
 @item __enhanced__
 
 @item __modified__
 
@@ -1330,16 +1332,17 @@ mouse pointer is when the function gets 
 see @code{"keypressfcn"}
 
 @item keyreleasefcn
 With @code{"keypressfcn"}, The keyboard callback functions.  These
 callback functions get called when a key is pressed/released
 respectively.  The functions are called with two input arguments.  The
 first argument holds the handle of the calling figure.  The second
 argument holds the event structure which has the following members:
+
 @table @code
 @item Character
 The ASCII value of the key
 
 @item Key
 lowercase value of the key
 
 @item Modifier
@@ -1351,16 +1354,17 @@ the key.  Possible values are @code{"shi
 @item menubar
 
 @item mincolormap
 
 @item name
 
 @item nextplot
 May be one of
+
 @table @code
 @item "new"
 
 @item "add"
 
 @item "replace"
 
 @item "replacechildren"
@@ -1446,16 +1450,17 @@ holds the current coordinates of the cur
 @item xvisualmode
 @end table
 
 @node Axes Properties
 @subsubsection Axes Properties
 @cindex axes properties
 
 The @code{axes} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item activepositionproperty
 
 @item alim
@@ -1575,16 +1580,17 @@ Octave.
 @item linestyleorder
 
 @item linewidth
 
 @item minorgridlinestyle
 
 @item nextplot
 May be one of
+
 @table @code
 @item "new"
 
 @item "add"
 
 @item "replace"
 
 @item "replacechildren"
@@ -1791,16 +1797,17 @@ Either @code{"manual"} or @code{"auto"}.
 
 @end table
 
 @node Line Properties
 @subsubsection Line Properties
 @cindex line properties
 
 The @code{line} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item beingdeleted
 
 @item busyaction
@@ -1902,16 +1909,17 @@ The data to be plotted.
 @item zliminclude
 @end table
 
 @node Text Properties
 @subsubsection Text Properties
 @cindex text properties
 
 The @code{text} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item backgroundcolor
 
 @item beingdeleted
@@ -2019,16 +2027,17 @@ May be @code{"normalized"} or @code{"gra
 
 @end table
 
 @node Image Properties
 @subsubsection Image Properties
 @cindex image properties
 
 The @code{image} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item beingdeleted
 
 @item busyaction
@@ -2095,16 +2104,17 @@ the image.
 @item yliminclude
 @end table
 
 @node Patch Properties
 @subsubsection Patch Properties
 @cindex patch properties
 
 The @code{patch} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item alim
 
 @item aliminclude
@@ -2243,16 +2253,17 @@ Data defining the patch object.
 
 @end table
 
 @node Surface Properties
 @subsubsection Surface Properties
 @cindex surface properties
 
 The @code{surface} properties are:
+
 @table @code
 @item __modified__
 
 @item __myhandle__
 
 @item alim
 
 @item aliminclude
@@ -2518,16 +2529,17 @@ one, or by name.  Recognized color names
 @cindex line styles, graphics
 @cindex graphics line styles
 
 Line styles are specified by the following properties:
 
 @table @code
 @item linestyle
 May be one of
+
 @table @code
 @item "-"
 Solid line.  [default]
 
 @item "--"
 Dashed line.
 
 @item ":"
@@ -2546,16 +2558,17 @@ of 2 is twice as wide as the default, et
 @end table
 
 @node Marker Styles
 @subsection Marker Styles
 @cindex graphics marker styles
 @cindex marker styles, graphics
 
 Marker styles are specified by the following properties:
+
 @table @code
 @item marker
 A character indicating a plot marker to be place at each data point, or
 @code{"none"}, meaning no markers should be displayed.
 
 @itemx markeredgecolor
 The color of the edge around the marker, or @code{"auto"}, meaning that
 the edge color is the same as the face color.  @xref{Colors}.
@@ -2592,17 +2605,17 @@ endfunction
 
 @noindent
 where @code{src} gives a handle to the source of the callback, and
 @code{code} gives some event specific data.  This can then be associated
 with an object either at the objects creation or later with the
 @code{set} function.  For example,
 
 @example
-plot (x, "DeleteFcn", @@(s, e) disp("Window Deleted"))
+plot (x, "DeleteFcn", @@(s, e) disp ("Window Deleted"))
 @end example
 
 @noindent
 where at the moment that the plot is deleted, the message "Window
 Deleted" will be displayed.
 
 Additional user arguments can be passed to callback functions, and will
 be passed after the 2 default arguments.  For example:
diff --git a/doc/interpreter/poly.txi b/doc/interpreter/poly.txi
--- a/doc/interpreter/poly.txi
+++ b/doc/interpreter/poly.txi
@@ -49,18 +49,18 @@ p(x) = @var{c}(1) x^@var{N} + @dots{} + 
 @node Evaluating Polynomials
 @section Evaluating Polynomials
 
 The value of a polynomial represented by the vector @var{c} can be evaluated
 at the point @var{x} very easily, as the following example shows:
 
 @example
 @group
-N = length(c)-1;
-val = dot( x.^(N:-1:0), c );
+N = length (c) - 1;
+val = dot (x.^(N:-1:0), c);
 @end group
 @end example
 
 @noindent
 While the above example shows how easy it is to compute the value of a
 polynomial, it isn't the most stable algorithm.  With larger polynomials
 you should use more elegant algorithms, such as Horner's Method, which
 is exactly what the Octave function @code{polyval} does.
@@ -109,18 +109,18 @@ for a definition), and then finding its 
 Octave comes with functions for computing the derivative and the integral
 of a polynomial.  The functions @code{polyder} and @code{polyint}
 both return new polynomials describing the result.  As an example we'll
 compute the definite integral of @math{p(x) = x^2 + 1} from 0 to 3.
 
 @example
 @group
 c = [1, 0, 1];
-integral = polyint(c);
-area = polyval(integral, 3) - polyval(integral, 0)
+integral = polyint (c);
+area = polyval (integral, 3) - polyval (integral, 0)
 @result{} 12
 @end group
 @end example
 
 @DOCSTRING(polyder)
 
 @DOCSTRING(polyint)
 
@@ -144,17 +144,17 @@ In situations where a single polynomial 
 is to use several polynomials pieced together.  The function
 @code{splinefit} fits a peicewise polynomial (spline) to a set of
 data.
 
 @DOCSTRING(splinefit)
 
 The number of @var{breaks} (or knots) used to construct the piecewise
 polynomial is a significant factor in suppressing the noise present in
-the input data, @var{x} and @var{y}. This is demostrated by the example
+the input data, @var{x} and @var{y}.  This is demonstrated by the example
 below.
 
 @example
 @group
 x = 2 * pi * rand (1, 200);
 y = sin (x) + sin (2 * x) + 0.2 * randn (size (x));
 ## Uniform breaks
 breaks = linspace (0, 2 * pi, 41); % 41 breaks, 40 pieces
@@ -174,28 +174,27 @@ legend (@{"data", "41 breaks, 40 pieces"
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:splinefit1}.
 
 @float Figure,fig:splinefit1
 @center @image{splinefit1,4in}
 @caption{Comparison of a fitting a piecewise polynomial with 41 breaks to one
-with 11 breaks. The fit with the large number of breaks exhibits a fast ripple
+with 11 breaks.  The fit with the large number of breaks exhibits a fast ripple
 that is not present in the underlying function.}
 @end float
 @end ifnotinfo
 
-The piece-wise polynomial fit, provided by @code{splinefit}, has
-continuous derivatives up to the @var{order}-1. For example, a cubic fit
-has continuous first and second derivatives.   This is demonstrated by
+The piecewise polynomial fit, provided by @code{splinefit}, has
+continuous derivatives up to the @var{order}-1.  For example, a cubic fit
+has continuous first and second derivatives.  This is demonstrated by
 the code
 
 @example
-@group
 ## Data (200 points)
 x = 2 * pi * rand (1, 200);
 y = sin (x) + sin (2 * x) + 0.1 * randn (size (x));
 ## Piecewise constant
 pp1 = splinefit (x, y, 8, "order", 0);
 ## Piecewise linear
 pp2 = splinefit (x, y, 8, "order", 1);
 ## Piecewise quadratic
@@ -210,27 +209,26 @@ y1 = ppval (pp1, xx);
 y2 = ppval (pp2, xx);
 y3 = ppval (pp3, xx);
 y4 = ppval (pp4, xx);
 y5 = ppval (pp5, xx);
 plot (x, y, ".", xx, [y1; y2; y3; y4; y5])
 axis tight
 ylim auto
 legend (@{"data", "order 0", "order 1", "order 2", "order 3", "order 4"@})
-@end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:splinefit2}.
 
 @float Figure,fig:splinefit2
 @center @image{splinefit2,4in}
 @caption{Comparison of a piecewise constant, linear, quadratic, cubic, and
-quartic polynomials with 8 breaks to noisy data. The higher order solutions
+quartic polynomials with 8 breaks to noisy data.  The higher order solutions
 more accurately represent the underlying function, but come with the
 expense of computational complexity.}
 @end float
 @end ifnotinfo
 
 When the underlying function to provide a fit to is periodic, @code{splinefit}
 is able to apply the boundary conditions needed to manifest a periodic fit.
 This is demonstrated by the code below.
@@ -261,22 +259,21 @@ The result of which can be seen in @ref{
 
 @float Figure,fig:splinefit3
 @center @image{splinefit3,4in}
 @caption{Comparison of piecewise polynomial fits to a noisy periodic
 function with, and without, periodic boundary conditions.}
 @end float
 @end ifnotinfo
 
-More complex constraints may be added as well. For example, the code below
-illustrates a periodic fit with values that have been clamped at the end points,
-and a second periodic fit which is hinged at the end points.
+More complex constraints may be added as well.  For example, the code below
+illustrates a periodic fit with values that have been clamped at the endpoints,
+and a second periodic fit which is hinged at the endpoints.
 
 @example
-@group
 ## Data (200 points)
 x = 2 * pi * rand (1, 200);
 y = sin (2 * x) + 0.1 * randn (size (x));
 ## Breaks
 breaks = linspace (0, 2 * pi, 10);
 ## Clamped endpoints, y = y' = 0
 xc = [0, 0, 2*pi, 2*pi];
 cc = [(eye (2)), (eye (2))];
@@ -288,38 +285,36 @@ pp2 = splinefit (x, y, breaks, "constrai
 ## Plot
 xx = linspace (0, 2 * pi, 400);
 y1 = ppval (pp1, xx);
 y2 = ppval (pp2, xx);
 plot (x, y, ".", xx, [y1; y2])
 axis tight
 ylim auto
 legend (@{"data", "clamped", "hinged periodic"@})
-@end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:splinefit4}.
 
 @float Figure,fig:splinefit4
 @center @image{splinefit4,4in}
 @caption{Comparison of two periodic piecewise cubic fits to a noisy periodic
-signal. One fit has its end points clamped and the second has its end points
+signal.  One fit has its endpoints clamped and the second has its endpoints
 hinged.}
 @end float
 @end ifnotinfo
 
 The @code{splinefit} function also provides the convenience of a @var{robust}
 fitting, where the effect of outlying data is reduced.  In the example below,
 three different fits are provided.  Two with differing levels of outlier
 suppression and a third illustrating the non-robust solution.
 
 @example
-@group
 ## Data
 x = linspace (0, 2*pi, 200);
 y = sin (x) + sin (2 * x) + 0.05 * randn (size (x));
 ## Add outliers
 x = [x, linspace(0,2*pi,60)];
 y = [y, -ones(1,60)];
 ## Fit splines with hinged conditions
 con = struct ("xc", [0, 2*pi]);
@@ -334,26 +329,25 @@ xx = linspace (0, 2*pi, 400);
 y1 = ppval (pp1, xx);
 y2 = ppval (pp2, xx);
 y3 = ppval (pp3, xx);
 plot (x, y, ".", xx, [y1; y2; y3])
 legend (@{"data with outliers","robust, beta = 0.25", ...
          "robust, beta = 0.75", "no robust fitting"@})
 axis tight
 ylim auto
-@end group
 @end example
 
 @ifnotinfo
 @noindent
 The result of which can be seen in @ref{fig:splinefit6}.
 
 @float Figure,fig:splinefit6
 @center @image{splinefit6,4in}
-@caption{Comparison of two different levels of robust fitting (@var{beta} = 0.25 and 0.75) to noisy data combined with outlying data. A conventional fit, without
+@caption{Comparison of two different levels of robust fitting (@var{beta} = 0.25 and 0.75) to noisy data combined with outlying data.  A conventional fit, without
 robust fitting (@var{beta} = 0) is also included.}
 @end float
 @end ifnotinfo
 
 The function, @code{ppval}, evaluates the piecewise polynomials, created
 by @code{mkpp} or other means, and @code{unmkpp} returns detailed
 information about the piecewise polynomial.
 
@@ -362,20 +356,20 @@ quadratic into one function.  Each of th
 on adjoined intervals.
 
 @example
 @group
 x = [-2, -1, 1, 2];
 p = [ 0,  1, 0;
       1, -2, 1;
       0, -1, 1 ];
-pp = mkpp(x, p);
-xi = linspace(-2, 2, 50);
-yi = ppval(pp, xi);
-plot(xi, yi);
+pp = mkpp (x, p);
+xi = linspace (-2, 2, 50);
+yi = ppval (pp, xi);
+plot (xi, yi);
 @end group
 @end example
 
 @DOCSTRING(mkpp)
 
 @DOCSTRING(unmkpp)
 
 @DOCSTRING(ppval)
diff --git a/doc/interpreter/quad.txi b/doc/interpreter/quad.txi
--- a/doc/interpreter/quad.txi
+++ b/doc/interpreter/quad.txi
@@ -333,17 +333,17 @@ using @math{n} points by
 @tex
 $$
  \int_0^1 \int_0^1 f(x,y) d x d y \approx \sum_{i=1}^n \sum_{j=1}^n q_i q_j f(r_i, r_j),
 $$
 @end tex
 @ifnottex
 the sum over @code{i=1:n} and @code{j=1:n} of @code{q(i)*q(j)*f(r(i),r(j))},
 @end ifnottex
-where @math{q} and @math{r} is as returned by @code{colloc(n)}.  The
+where @math{q} and @math{r} is as returned by @code{colloc (n)}.  The
 generalization to more than two variables is straight forward.  The
 following code computes the studied integral using @math{n=8} points.
 
 @example
 @group
 f = @@(x,y) sin (pi*x*y') .* sqrt (x*y');
 n = 8;
 [t, ~, ~, q] = colloc (n);
diff --git a/doc/interpreter/set.txi b/doc/interpreter/set.txi
--- a/doc/interpreter/set.txi
+++ b/doc/interpreter/set.txi
@@ -35,17 +35,17 @@ represented as a vector of numbers.
 Octave supports the basic set operations.  That is, Octave can compute
 the union, intersection, and difference of two sets.
 Octave also supports the @emph{Exclusive Or} set operation, and
 membership determination.  The functions for set operations all work in
 pretty much the same way.  As an example, assume that @code{x} and
 @code{y} contains two sets, then
 
 @example
-union(x, y)
+union (x, y)
 @end example
 
 @noindent
 computes the union of the two sets.
 
 @DOCSTRING(ismember)
 
 @DOCSTRING(union)
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -101,17 +101,17 @@ In fact, the column index contains one m
 columns, with the first element always being zero.  The advantage of
 this is a simplification in the code, in that there is no special case
 for the first or last columns.  A short example, demonstrating this in
 C is.
 
 @example
 @group
   for (j = 0; j < nc; j++)
-    for (i = cidx (j); i < cidx(j+1); i++)
+    for (i = cidx(j); i < cidx(j+1); i++)
        printf ("non-zero element (%i,%i) is %d\n", 
            ridx(i), j, data(i));
 @end group
 @end example
 
 A clear understanding might be had by considering an example of how the
 above applies to an example matrix.  Consider the matrix
 
@@ -207,17 +207,17 @@ creates an @var{r}-by-@var{c} sparse mat
 elements of @var{d}.
 
 Other functions of interest that directly create sparse matrices, are
 @dfn{diag} or its generalization @dfn{spdiags}, that can take the
 definition of the diagonals of the matrix and create the sparse matrix 
 that corresponds to this.  For example,
 
 @example
-s = diag (sparse(randn(1,n)), -1);
+s = diag (sparse (randn (1,n)), -1);
 @end example
 
 @noindent
 creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
 diagonal defined.
 
 @DOCSTRING(spdiags)
 
@@ -343,32 +343,32 @@ determines the means to solve the equati
 matrix as discussed in @ref{Sparse Linear Algebra}.  Octave probes the
 matrix type when the div (/) or ldiv (\) operator is first used with
 the matrix and then caches the type.  However the @dfn{matrix_type}
 function can be used to determine the type of the sparse matrix prior
 to use of the div or ldiv operators.  For example,
 
 @example
 @group
-a = tril (sprandn(1024, 1024, 0.02), -1) ...
-    + speye(1024); 
+a = tril (sprandn (1024, 1024, 0.02), -1) ...
+    + speye (1024); 
 matrix_type (a);
 ans = Lower
 @end group
 @end example
 
 @noindent
 shows that Octave correctly determines the matrix type for lower
 triangular matrices.  @dfn{matrix_type} can also be used to force
 the type of a matrix to be a particular type.  For example:
 
 @example
 @group
 a = matrix_type (tril (sprandn (1024, ...
-   1024, 0.02), -1) + speye(1024), 'Lower');
+   1024, 0.02), -1) + speye (1024), "Lower");
 @end group
 @end example
 
 This allows the cost of determining the matrix type to be
 avoided.  However, incorrectly defining the matrix type will result in
 incorrect results from solutions of linear equations, and so it is
 entirely the responsibility of the user to correctly identify the
 matrix type
@@ -393,20 +393,20 @@ ji-th node) of the sparse adjacency matr
 is then associated with a set of coordinates, then the @dfn{gplot}
 command can be used to graphically display the interconnections
 between nodes.
 
 As a trivial example of the use of @dfn{gplot} consider the example,
 
 @example
 @group
-A = sparse([2,6,1,3,2,4,3,5,4,6,1,5],
+A = sparse ([2,6,1,3,2,4,3,5,4,6,1,5],
     [1,1,2,2,3,3,4,4,5,5,6,6],1,6,6);
 xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
-gplot(A,xy)
+gplot (A,xy)
 @end group
 @end example
 
 @noindent
 which creates an adjacency matrix @code{A} where node 1 is connected
 to nodes 2 and 6, node 2 with nodes 1 and 3, etc.  The coordinates of
 the nodes are given in the n-by-2 matrix @code{xy}.
 @ifset htmltex 
@@ -417,18 +417,18 @@ the nodes are given in the n-by-2 matrix
 @caption{Simple use of the @dfn{gplot} command.}
 @end float
 @end ifset
 
 The dependencies between the nodes of a Cholesky@tie{}factorization can be
 calculated in linear time without explicitly needing to calculate the
 Cholesky@tie{}factorization by the @code{etree} command.  This command
 returns the elimination tree of the matrix and can be displayed
-graphically by the command @code{treeplot(etree(A))} if @code{A} is
-symmetric or @code{treeplot(etree(A+A'))} otherwise.
+graphically by the command @code{treeplot (etree (A))} if @code{A} is
+symmetric or @code{treeplot (etree (A+A'))} otherwise.
 
 @DOCSTRING(spy)
 
 @DOCSTRING(etree)
 
 @DOCSTRING(etreeplot)
 
 @DOCSTRING(gplot)
@@ -514,17 +514,17 @@ Therefore, there is a certain density of
 where it no longer makes sense to store it as a sparse matrix, but rather
 as a full matrix.  For this reason operators and functions that have a 
 high probability of returning a full matrix will always return one.  For
 example adding a scalar constant to a sparse matrix will almost always
 make it a full matrix, and so the example,
 
 @example
 @group
-speye(3) + 0
+speye (3) + 0
 @result{}   1  0  0
   0  1  0
   0  0  1
 @end group
 @end example
 
 @noindent
 returns a full matrix as can be seen. 
@@ -536,27 +536,27 @@ amount of storage used is larger than th
 equivalent.  Therefore @code{speye (2) * 1} will return a full matrix as
 the memory used is smaller for the full version than the sparse version.
 
 As all of the mixed operators and functions between full and sparse 
 matrices exist, in general this does not cause any problems.  However,
 one area where it does cause a problem is where a sparse matrix is
 promoted to a full matrix, where subsequent operations would resparsify
 the matrix.  Such cases are rare, but can be artificially created, for
-example @code{(fliplr(speye(3)) + speye(3)) - speye(3)} gives a full
+example @code{(fliplr (speye (3)) + speye (3)) - speye (3)} gives a full
 matrix when it should give a sparse one.  In general, where such cases 
 occur, they impose only a small memory penalty.
 
 There is however one known case where this behavior of Octave's
 sparse matrices will cause a problem.  That is in the handling of the
 @dfn{diag} function.  Whether @dfn{diag} returns a sparse or full matrix
 depending on the type of its input arguments.  So 
 
 @example
- a = diag (sparse([1,2,3]), -1);
+ a = diag (sparse ([1,2,3]), -1);
 @end example
 
 @noindent
 should return a sparse matrix.  To ensure this actually happens, the
 @dfn{sparse} function, and other functions based on it like @dfn{speye}, 
 always returns a sparse matrix, even if the memory used will be larger 
 than its full representation.
 
@@ -650,17 +650,17 @@ positive definite matrix.
 @float Figure,fig:simplematrix
 @center @image{spmatrix,4in}
 @caption{Structure of simple sparse matrix.}
 @end float
 
 The standard Cholesky@tie{}factorization of this matrix can be
 obtained by the same command that would be used for a full
 matrix.  This can be visualized with the command 
-@code{r = chol(A); spy(r);}.
+@code{r = chol (A); spy (r);}.
 @xref{fig:simplechol}.
 The original matrix had 
 @ifinfo
 @ifnothtml
 43
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
@@ -677,47 +677,47 @@ 10200,
 @end ifset
 with only half of the symmetric matrix being stored.  This
 is a significant level of fill in, and although not an issue
 for such a small test case, can represents a large overhead 
 in working with other sparse matrices.
 
 The appropriate sparsity preserving permutation of the original
 matrix is given by @dfn{symamd} and the factorization using this
-reordering can be visualized using the command @code{q = symamd(A);
-r = chol(A(q,q)); spy(r)}.  This gives 
+reordering can be visualized using the command @code{q = symamd (A);
+r = chol (A(q,q)); spy (r)}.  This gives 
 @ifinfo
 @ifnothtml
 29
 @end ifnothtml
 @end ifinfo
 @ifset htmltex
 399
 @end ifset
 non-zero terms which is a significant improvement.
 
 The Cholesky@tie{}factorization itself can be used to determine the
 appropriate sparsity preserving reordering of the matrix during the
 factorization, In that case this might be obtained with three return
-arguments as r@code{[r, p, q] = chol(A); spy(r)}.
+arguments as @code{[r, p, q] = chol (A); spy (r)}.
 
 @float Figure,fig:simplechol
 @center @image{spchol,4in}
 @caption{Structure of the un-permuted Cholesky@tie{}factorization of the above matrix.}
 @end float
 
 @float Figure,fig:simplecholperm
 @center @image{spcholperm,4in}
 @caption{Structure of the permuted Cholesky@tie{}factorization of the above matrix.}
 @end float
 
 In the case of an asymmetric matrix, the appropriate sparsity
 preserving permutation is @dfn{colamd} and the factorization using
 this reordering can be visualized using the command
-@code{q = colamd(A); [l, u, p] = lu(A(:,q)); spy(l+u)}.
+@code{q = colamd (A); [l, u, p] = lu (A(:,q)); spy (l+u)}.
 
 Finally, Octave implicitly reorders the matrix when using the div (/)
 and ldiv (\) operators, and so no the user does not need to explicitly
 reorder the matrix to maximize performance.
 
 @DOCSTRING(amd)
 
 @DOCSTRING(ccolamd)
@@ -943,33 +943,33 @@ vertices @code{nodes} and simplices @cod
 
 The following example creates a simple rectangular 2-D electrically
 conductive medium with 10 V and 20 V imposed on opposite sides 
 (Dirichlet boundary conditions).  All other edges are electrically
 isolated.
 
 @example
 @group
-   node_y= [1;1.2;1.5;1.8;2]*ones(1,11);
-   node_x= ones(5,1)*[1,1.05,1.1,1.2, ...
+   node_y = [1;1.2;1.5;1.8;2]*ones(1,11);
+   node_x = ones(5,1)*[1,1.05,1.1,1.2, ...
              1.3,1.5,1.7,1.8,1.9,1.95,2];
-   nodes= [node_x(:), node_y(:)];
+   nodes = [node_x(:), node_y(:)];
 
-   [h,w]= size(node_x);
-   elems= [];
-   for idx= 1:w-1
-     widx= (idx-1)*h;
-     elems= [elems; ...
+   [h,w] = size (node_x);
+   elems = [];
+   for idx = 1:w-1
+     widx = (idx-1)*h;
+     elems = [elems; ...
        widx+[(1:h-1);(2:h);h+(1:h-1)]'; ...
        widx+[(2:h);h+(2:h);h+(1:h-1)]' ]; 
    endfor
 
-   E= size(elems,1); # No. of simplices
-   N= size(nodes,1); # No. of vertices
-   D= size(elems,2); # dimensions+1
+   E = size (elems,1); # No. of simplices
+   N = size (nodes,1); # No. of vertices
+   D = size (elems,2); # dimensions+1
 @end group
 @end example
 
 This creates a N-by-2 matrix @code{nodes} and a E-by-3 matrix
 @code{elems} with values, which define finite element triangles:
 
 @example
 @group
@@ -996,42 +996,42 @@ as constant on each simplex (represented
 Based on the finite element geometry, we first calculate a system (or
 stiffness) matrix for each simplex (represented as 3-by-3 elements on the
 diagonal of the element-wise system matrix @code{SE}.  Based on @code{SE} 
 and a N-by-DE connectivity matrix @code{C}, representing the connections 
 between simplices and vertices, the global connectivity matrix @code{S} is
 calculated.
 
 @example
-  # Element conductivity
-  conductivity= [1*ones(1,16), ...
+  ## Element conductivity
+  conductivity = [1*ones(1,16), ...
          2*ones(1,48), 1*ones(1,16)];
 
-  # Connectivity matrix
+  ## Connectivity matrix
   C = sparse ((1:D*E), reshape (elems', ...
          D*E, 1), 1, D*E, N);
 
-  # Calculate system matrix
+  ## Calculate system matrix
   Siidx = floor ([0:D*E-1]'/D) * D * ...
          ones(1,D) + ones(D*E,1)*(1:D) ;
-  Sjidx = [1:D*E]'*ones(1,D);
-  Sdata = zeros(D*E,D);
-  dfact = factorial(D-1);
-  for j=1:E
-     a = inv([ones(D,1), ... 
+  Sjidx = [1:D*E]'*ones (1,D);
+  Sdata = zeros (D*E,D);
+  dfact = factorial (D-1);
+  for j = 1:E
+     a = inv ([ones(D,1), ... 
          nodes(elems(j,:), :)]);
      const = conductivity(j) * 2 / ...
-         dfact / abs(det(a));
+         dfact / abs (det (a));
      Sdata(D*(j-1)+(1:D),:) = const * ...
          a(2:D,:)' * a(2:D,:);
   endfor
-  # Element-wise system matrix
-  SE= sparse(Siidx,Sjidx,Sdata);
-  # Global system matrix
-  S= C'* SE *C;
+  ## Element-wise system matrix
+  SE = sparse(Siidx,Sjidx,Sdata);
+  ## Global system matrix
+  S = C'* SE *C;
 @end example
 
 The system matrix acts like the conductivity 
 @tex
 $S$ 
 @end tex
 @ifnottex
 @code{S}
@@ -1042,33 +1042,33 @@ in Ohm's law
 @end tex
 @ifnottex
 @code{S * V = I}.
 @end ifnottex
 Based on the Dirichlet and Neumann boundary conditions, we are able to 
 solve for the voltages at each vertex @code{V}. 
 
 @example
-  # Dirichlet boundary conditions
-  D_nodes=[1:5, 51:55]; 
-  D_value=[10*ones(1,5), 20*ones(1,5)]; 
+  ## Dirichlet boundary conditions
+  D_nodes = [1:5, 51:55]; 
+  D_value = [10*ones(1,5), 20*ones(1,5)]; 
 
-  V= zeros(N,1);
+  V = zeros (N,1);
   V(D_nodes) = D_value;
   idx = 1:N; # vertices without Dirichlet 
              # boundary condns
   idx(D_nodes) = [];
 
-  # Neumann boundary conditions.  Note that
-  # N_value must be normalized by the
-  # boundary length and element conductivity
-  N_nodes=[];
-  N_value=[];
+  ## Neumann boundary conditions.  Note that
+  ## N_value must be normalized by the
+  ## boundary length and element conductivity
+  N_nodes = [];
+  N_value = [];
 
-  Q = zeros(N,1);
+  Q = zeros (N,1);
   Q(N_nodes) = N_value;
 
   V(idx) = S(idx,idx) \ ( Q(idx) - ...
             S(idx,D_nodes) * V(D_nodes));
 @end example
 
 Finally, in order to display the solution, we show each solved voltage 
 value in the z-axis for each simplex vertex.
@@ -1077,18 +1077,18 @@ value in the z-axis for each simplex ver
 @end ifset
 
 @example
 @group
   elemx = elems(:,[1,2,3,1])';
   xelems = reshape (nodes(elemx, 1), 4, E);
   yelems = reshape (nodes(elemx, 2), 4, E);
   velems = reshape (V(elemx), 4, E);
-  plot3 (xelems,yelems,velems,'k'); 
-  print ('grid.eps');
+  plot3 (xelems,yelems,velems,"k"); 
+  print "grid.eps";
 @end group
 @end example
 
 
 @ifset htmltex
 @float Figure,fig:femmodel
 @center @image{grid,4in}
 @caption{Example finite element model the showing triangular elements. 
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -555,47 +555,47 @@ next value in the range is assigned to t
 loop body is executed again.  This process continues until there are no
 more elements to assign.
 
 Within Octave is it also possible to iterate over matrices or cell arrays
 using the @code{for} statement.  For example consider
 
 @example
 @group
-disp("Loop over a matrix")
+disp ("Loop over a matrix")
 for i = [1,3;2,4]
   i
 endfor
-disp("Loop over a cell array")
+disp ("Loop over a cell array")
 for i = @{1,"two";"three",4@}
   i
 endfor
 @end group 
 @end example
 
 @noindent
 In this case the variable @code{i} takes on the value of the columns of
 the matrix or cell matrix.  So the first loop iterates twice, producing
 two column vectors @code{[1;2]}, followed by @code{[3;4]}, and likewise
 for the loop over the cell array.  This can be extended to loops over
 multi-dimensional arrays.  For example:
 
 @example
 @group
-a = [1,3;2,4]; c = cat(3, a, 2*a);
+a = [1,3;2,4]; c = cat (3, a, 2*a);
 for i = c
   i
 endfor
 @end group 
 @end example
 
 @noindent
 In the above case, the multi-dimensional matrix @var{c} is reshaped to a
-two-dimensional matrix as @code{reshape (c, rows(c),
-prod(size(c)(2:end)))} and then the same behavior as a loop over a two
+two-dimensional matrix as @code{reshape (c, rows (c),
+prod (size (c)(2:end)))} and then the same behavior as a loop over a two
 dimensional matrix is produced.
 
 Although it is possible to rewrite all @code{for} loops as @code{while}
 loops, the Octave language has both statements because often a
 @code{for} loop is both less work to type and more natural to think of.
 Counting the number of iterations is very common in loops and it can be
 easier to think of this counting as part of looping rather than as
 something to do inside the loop.
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -67,17 +67,17 @@ produces a correct value.  A real test m
 @example
 @group
 %!test
 %! @var{a} = [1, 2, 3; 4, 5, 6]; B = [1; 2];
 %! expect = [ @var{a} ; 2*@var{a} ];
 %! get = kron (@var{b}, @var{a});
 %! if (any (size (expect) != size (get)))
 %!   error ("wrong size: expected %d,%d but got %d,%d",
-%!          size(expect), size(get));
+%!          size (expect), size (get));
 %! elseif (any (any (expect != get)))
 %!   error ("didn't get what was expected.");
 %! endif
 @end group
 @end example
 
 To make the process easier, use the @code{assert} function.  For example,
 with @code{assert} the previous test is reduced to:
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -267,31 +267,31 @@ is saved on disk, we get the following b
 for i = 1:2
   count_calls ();
 endfor
 @print{} 'count_calls' has been called 1 times
 @print{} 'count_calls' has been called 2 times
 
 clear
 for i = 1:2
-  count_calls();
+  count_calls ();
 endfor
 @print{} 'count_calls' has been called 3 times
 @print{} 'count_calls' has been called 4 times
 
 clear all
 for i = 1:2
-  count_calls();
+  count_calls ();
 endfor
 @print{} 'count_calls' has been called 1 times
 @print{} 'count_calls' has been called 2 times
 
 clear count_calls
 for i = 1:2
-  count_calls();
+  count_calls ();
 endfor
 @print{} 'count_calls' has been called 1 times
 @print{} 'count_calls' has been called 2 times
 @end example
 
 @noindent
 That is, the persistent variable is only removed from memory when the
 function containing the variable is removed.  Note that if the function
diff --git a/doc/interpreter/vectorize.txi b/doc/interpreter/vectorize.txi
--- a/doc/interpreter/vectorize.txi
+++ b/doc/interpreter/vectorize.txi
@@ -186,26 +186,28 @@ unique
 lookup
 
 @item
 ifelse / merge
 @end itemize
 
 @item
 Repetition
+
 @itemize
 @item
 repmat
 
 @item
 repelems
 @end itemize
 
 @item
 Vectorized arithmetic
+
 @itemize
 @item
 sum
 
 @item
 prod
 
 @item
@@ -227,16 +229,17 @@ dot
 cummax
 
 @item
 cummin
 @end itemize
 
 @item
 Shape of higher dimensional arrays
+
 @itemize
 @item
 reshape
 
 @item
 resize
 
 @item
@@ -337,18 +340,18 @@ y - y'
 @end example
 
 @noindent
 Here the vectors of size @code{[1 3]} and @code{[3 1]} both get
 broadcast into matrices of size @code{[3 3]} before ordinary matrix
 subtraction takes place.
 
 A special case of broadcasting that may be familiar is when all
-dimensions of the array being broadcast are 1, i.e. the array is a
-scalar. Thus for example, operations like @code{x - 42} and @code{max
+dimensions of the array being broadcast are 1, i.e., the array is a
+scalar.  Thus for example, operations like @code{x - 42} and @code{max
 (x, 2)} are basic examples of broadcasting.
 
 For a higher-dimensional example, suppose @code{img} is an RGB image of
 size @code{[m n 3]} and we wish to multiply each color by a different
 scalar.  The following code accomplishes this with broadcasting,
 
 @example
 img .*= permute ([0.8, 0.9, 1.2], [1, 3, 2]);
@@ -652,17 +655,17 @@ users of Octave and their solutions.
 @itemize @bullet
 @item
 For a vector @code{A}, the following loop
 
 @example
 @group
 n = length (A);
 B = zeros (n, 2);
-for i = 1:length(A)
+for i = 1:length (A)
   ## this will be two columns, the first is the difference and
   ## the second the mean of the two elements used for the diff.
   B(i,:) = [A(i+1)-A(i), (A(i+1) + A(i))/2)];
 endfor
 @end group
 @end example
 
 @noindent
diff --git a/doc/refcard/refcard.tex b/doc/refcard/refcard.tex
--- a/doc/refcard/refcard.tex
+++ b/doc/refcard/refcard.tex
@@ -674,27 +674,27 @@ realmin&minimum representable value\cr
 \char'136\ \ .\char'136&exponentiation\cr
 \endsec
 
 \vfill\eject
 
 \sec Paths and Packages;
 path&display the current Octave function path.\cr
 pathdef&display the default path.\cr
-addpath({\it dir})&add a directory to the path.\cr
+addpath ({\it dir})&add a directory to the path.\cr
 EXEC\_PATH&manipulate the Octave executable path.\cr
 pkg list&display installed packages.\cr
 pkg load {\it pack}&Load an installed package.\cr
 \endsec
 
 \sec Cells and Structures;
 {\it{var}}.{\it{field}} = ...&set a field of a structure.\cr
 {\it{var}}$\{${\it{idx}}$\}$ = ...&set an element of a cell array.\cr
-cellfun({\it f}, {\it c})&apply a function to elements of cell array.\cr
-fieldnames({\it s})&returns the fields of a structure.\cr
+cellfun ({\it f}, {\it c})&apply a function to elements of cell array.\cr
+fieldnames ({\it s})&returns the fields of a structure.\cr
 \endsec
 
 \widesec Statements;
 for {\it identifier} = {\it expr} {\it stmt-list} endfor\cr
 \hfill\vbox{\hsize=\idnwid\rm\vskip0.25ex
   Execute {\it stmt-list} once for each column of {\it expr}.  The
   variable {\it identifier} is set to the value of the current column
   during each iteration.}\cr\cr
@@ -798,20 +798,20 @@ logspace ({\it b}, {\it l}, {\it n})&cre
   elements\cr
 eye ({\it n}, {\it m})&create {\it n\/} by {\it m\/} identity matrix\cr
 ones ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of ones\cr
 zeros ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of zeros\cr
 rand ({\it n}, {\it m})&create {\it n\/} by {\it m\/} matrix of random
   values\cr 
 \endsec
 
-% sin({\it a}) cos({\it a}) tan({\it a})&trigonometric functions\cr
-% asin({\it a}) acos({\it a}) atan({\it a})&inverse trigonometric functions\cr
-% sinh({\it a}) cosh({\it a}) tanh({\it a})&hyperbolic trig functions\cr
-% asinh({\it a}) acosh({\it a}) atanh({\it a})&inverse hyperbolic trig
+% sin ({\it a}) cos({\it a}) tan({\it a})&trigonometric functions\cr
+% asin ({\it a}) acos({\it a}) atan({\it a})&inverse trigonometric functions\cr
+% sinh ({\it a}) cosh({\it a}) tanh({\it a})&hyperbolic trig functions\cr
+% asinh ({\it a}) acosh({\it a}) atanh({\it a})&inverse hyperbolic trig
 % functions\cr\cr 
 
 \sec Linear Algebra;
 chol ({\it a})&Cholesky factorization\cr
 det ({\it a})&compute the determinant of a matrix\cr
 eig ({\it a})&eigenvalues and eigenvectors\cr
 expm ({\it a})&compute the exponential of a matrix\cr
 hess ({\it a})&compute Hessenberg decomposition\cr
diff --git a/etc/OLD-ChangeLogs/ChangeLog b/etc/OLD-ChangeLogs/ChangeLog
--- a/etc/OLD-ChangeLogs/ChangeLog
+++ b/etc/OLD-ChangeLogs/ChangeLog
@@ -1877,17 +1877,17 @@ 2009-03-09  John W. Eaton  <jwe@octave.o
 	* run-octave.in: Use doc-cache instead of DOC for doc cache file.
 	* configure.in: Likewise.
 
 	* configure.in (--enable-extra-warning-flags): New option to
 	control extra compiler warning flags.
 	(--enable-strict-warning-flags): Rename from --enable-picky-flags.
 	(GXX_STRICT_FLAGS): Remove -Wenum-clash from the list.
 
-2009-03-08  Sren Hauberg  <hauberg@gmail.com>
+2009-03-08  Sren Hauberg  <hauberg@gmail.com>
 
 	* NEWS: Mention 'histc'.
 
 2009-03-07  John W. Eaton  <jwe@octave.org>
 
 	* config.guess, config.sub: Update from FSF sources.
 
 2009-02-25  John W. Eaton  <jwe@octave.org>
@@ -2647,17 +2647,17 @@ 2007-08-23  John W. Eaton  <jwe@octave.o
 	* aclocal.m4 (OCTAVE_PROG_SED): Don't clobber value from environment.
 	From: Christian Cornelssen <ccorn@cs.tu-berlin.de>.
 
 2007-08-23  Thomas Weber  <thomas.weber.mail@gmail.com>
 
 	* aclocal.m4 (OCTAVE_PROG_GNUPLOT): Drop check for multiple plot
 	windows.
 
-2007-08-10  Sren Hauberg  <hauberg@gmail.com>
+2007-08-10  Sren Hauberg  <hauberg@gmail.com>
 
 	* ROADMAP: Update for current sources.
 
 2007-07-26  John W. Eaton  <jwe@octave.org>
 
 	* configure.in: Also look for glpk/glpk.h.
 
 2007-07-25  David Bateman  <dbateman@free.fr>
@@ -2968,17 +2968,17 @@ 2006-11-13  Rafael Laboissiere  <rafael@
 2006-11-11  John W. Eaton  <jwe@octave.org>
 
 	* examples/Makefile.in (octave.desktop):
 	Use $(simple-move-if-change-rule) here.
 
 	* Makeconf.in (simple-move-if-change-rule,
 	(builddir-move-if-change-rule): New macros.
 
-2006-11-11  Sren Hauberg  <hauberg@gmail.com>
+2006-11-11  Sren Hauberg  <hauberg@gmail.com>
 
 	* examples/Makefile.in (uninstall): Add missing semicolon.
 
 2006-11-09  John W. Eaton  <jwe@octave.org>
 
 	* examples/Makefile.in (uninstall): New target.
 
 2006-11-09  Michael Goffioul  <michael.goffioul@swing.be>
@@ -3178,17 +3178,17 @@ 2006-10-03  John W. Eaton  <jwe@octave.o
 2006-10-03  David Bateman  <dbateman@free.fr>
 
 	* configure.in: Check for libcamd.
 	* Makeconf.in (CAMD_LIBS): New variable.
 
 2006-09-27  John W. Eaton  <jwe@octave.org>
 
 	* mkoctfile.in [--mex]: Include -I. in incflags.
-	From Sren Hauberg <hauberg@gmail.com>.
+	From Sren Hauberg <hauberg@gmail.com>.
 
 2006-09-26  John W. Eaton  <jwe@octave.org>
 
 	* configure.in (AC_CONFIG_FILES):
 	Remove doc/interpreter/images/Makefile from the list.
 
 2006-09-16  John W. Eaton  <jwe@octave.org>
 
@@ -3560,17 +3560,17 @@ 2005-09-23  John W. Eaton  <jwe@octave.o
 	(IMAGE_FILES, IMAGE_FILES_NO_DIR): New macros.
 	(DISTFILES): Include IMAGE_FILES in list.
 	(install install-strip): Install image file.
 
 	* aclocal.m4 (OCTAVE_PROG_DESKTOP_FILE_INSTALL): New macro
 	* configure.in: Use it.
 	* Makeconf.in: Substitute DESKTOP_FILE_INSTALL.
 
-	* octave.desktop.in: New file.  From Sren Hauberg <hauberg@gmail.com>.
+	* octave.desktop.in: New file.  From Sren Hauberg <hauberg@gmail.com>.
 	* examples/Makefile.in (SOURCES): Add it to the list.
 	(octave.desktop): New target.
 	(all): Depend on octave.desktop.
 
 2005-09-22  John W. Eaton  <jwe@octave.org>
 
 	* aclocal.m4 (OCTAVE_PROG_PERL): New macro.
 	* configure.in: Use it.
diff --git a/etc/OLD-ChangeLogs/doc-ChangeLog b/etc/OLD-ChangeLogs/doc-ChangeLog
--- a/etc/OLD-ChangeLogs/doc-ChangeLog
+++ b/etc/OLD-ChangeLogs/doc-ChangeLog
@@ -1306,21 +1306,21 @@ 2009-06-03  Jaroslav Hajek  <highegg@gma
 
 	* Makefile.in: Omit conf.texi in DISTFILES.
 
 2009-06-02  Jaroslav Hajek  <highegg@gmail.com>
 
 	* interpreter/oop.txi: Update docs of polynomial class, mention
 	chained indexing.
 
-2009-05-27  Sren Hauberg  <hauberg@gmail.com>
+2009-05-27  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/errors.txi: fix 'print_usage' output.
 
-2009-05-27  Sren Hauberg  <hauberg@gmail.com>
+2009-05-27  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/bugs.txi: fix call to 'page_screen_output'.
 
 2009-05-25  Rik  <rdrider0-list@yahoo.com>
 
 	* interpreter/Makefile.in: Add texmf.cnf to list of distributed files
 	(DIST_FILES) so that pdfs will build.
 
@@ -1451,17 +1451,17 @@ 2009-03-25  John W. Eaton  <jwe@octave.o
 	* interpreter/munge-texi.cc (process_texi_input_file):
 	Copy leading comment with file name info to output.
 
 2009-03-09  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/Makefile.in (DISTFILES): Use doc-cache instead of
 	DOC for doc cache file.
 
-2009-03-08  Sren Hauberg  <hauberg@gmail.com>
+2009-03-08  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/stats.txi (Basic Statistical Functions):
 	Add the 'histc' function.
 
 2009-03-07  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/basics.txi (Command Line Options):
 	Document --doc-cache-file command-line option.
@@ -1537,37 +1537,37 @@ 2009-02-11  John W. Eaton  <jwe@octave.o
 	list of directories to make.
 
 2009-02-10  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/Makefile.in (DOC): New target.
 	(DISTFILES): Add DOC nad mk_doc_cache.m to the list.
 	* mk_doc_cache.m: New file.
 
-2009-02-01  Sren Hauberg  <hauberg@gmail.com>
+2009-02-01  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/nonlin.txi: Remove reference to 'fsolve_options'.
 
-2009-02-01  Sren Hauberg  <hauberg@gmail.com>
+2009-02-01  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/system.txi: Remove reference to 'eomdate'.
 
 2009-01-24  Thorsten Meyer  <thorsten@hexe>
 
 	* interpreter/container.txi (Data Structures): Update examples for
 	structure arrays.
 
 2009-01-22  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/io.txi (Terminal Output): Remove @DOCSTRING(ans).
 
 	* vr-idx.txi: Delete.
 	* interpreter/Makefile.in (SUB_SOURCE): Remove it from the list.
 
-2009-01-22  Sren Hauberg  <hauberg@gmail.com>
+2009-01-22  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/func.txi: Put varargin and varargout in concept index.
 	* interpreter/var.txi: Put ans in concept index.
 	* interpreter/octave.texi: Don't include vr-idx.texi.
 
 	* interpreter/var.txi: Remove sections on built-in variables.
 
 2009-01-20  John W. Eaton  <jwe@octave.org>
@@ -1679,22 +1679,22 @@ 2008-10-03  Thorsten Meyer  <thorsten.me
 
 	* interpreter/contrib.txi: added example for mercurial queues
 
 08-10-03  Thorsten Meyer  <thorsten.meyier@gmx.de>
 
 	* interpreter/contrib.txi: correction of the mercurial example
 	* interpreter/container.txi: minor correction of the text
 
-2008-09-25  Sren Hauberg  <hauberg@gmail.com>
+2008-09-25  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/image.txi: Update for imread and imwrite instead of
 	loadimge and saveimage.
 
-2008-09-24  Sren Hauberg  <hauberg@gmail.com>
+2008-09-24  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/image.txi: Document imfinfo.
 
 2008-09-23  Francesco Potorti`  <Potorti@isti.cnr.it>.
 
 	* interpreter/container.txi: Fix cross reference in struct docs.
 
 2008-09-23  Brian Gough  <bjg@network-theory.co.uk>
@@ -1733,17 +1733,17 @@ 2008-08-26  Jaroslav Hajek  <highegg@gma
 2008-08-21  David Bateman  <dbateman@free.fr>
 
 	* interpreter/plot.txi: Document ezplot.
 
 2008-08-19  David Bateman  <dbateman@free.fr>
 
 	* interpreter/numbers.txi: Document intwarning.
 
-2008-08-06  Sren Hauberg  <hauberg@gmail.com>
+2008-08-06  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/basics.txi, interpreter/errors.txi,
 	interpreter/expr.txi, interpreter/func.txi,
 	interpreter/numbers.txi: Update format of error messages in examples.
 
 2008-07-29  David Bateman  <dbateman@free.fr>
 
 	* interpreter/numbers.txi, interpreter/plot.txi,
@@ -1950,17 +1950,17 @@ 2007-10-26  Michael Goffioul  <michael.g
 2007-10-22  Kim Hansen  <kimhanse@gmail.com>
 
 	* interpreter/munge-texi.cc: Include <cstdlib> and <cstring>.
 
 2007-10-19  David Bateman  <dbateman@free.fr>
 
 	* refcard/refcard.tex: Update for 3.0.
 
-2007-10-15  Sren Hauberg  <hauberg@gmail.com>
+2007-10-15  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/preface.txi, interpreter/basics.txi,
 	interpreter/strings.txi, interpreter/container.txi,
 	interpreter/var.txi, interpreter/expr.txi, interpreter/errors.txi,
 	interpreter/io.txi, interpreter/func.txi, interpreter/package.txi:
 	Make text fit on pages when using smallbook.
 
 2007-10-12  John W. Eaton  <jwe@octave.org>
@@ -1982,17 +1982,17 @@ 2007-10-10  Olli Saarela  <Olli.Saarela@
 	interpreter/geometry.txi, interpreter/intro.txi,
 	interpreter/numbers.txi, interpreter/plot.txi,
 	interpreter/poly.txi, interpreter/set.txi, interpreter/sparse.txi,
 	interpreter/stmt.txi, interpreter/strings.txi,
 	interpreter/testfun.txi, interpreter/tips.txi: Spelling fixes.
 
 2007-10-06  John W. Eaton  <jwe@octave.org>
 
-	* interpreter/octave.texi: Add David Bateman and Sren Hauberg as
+	* interpreter/octave.texi: Add David Bateman and Sren Hauberg as
 	authors.
 
 2006-09-28  Henry Mollet  mollet@pacbell.net
 
 	* interpreter/func.txi: Correct results of a couple of examples.
 
 2007-09-14  John W. Eaton  <jwe@octave.org>
 
@@ -2014,17 +2014,17 @@ 2007-09-01  David Bateman  <dbateman@fre
 	* interpreter/Makefile.in: Remove stray character from
 	INTERIMAGES_PNG target.
 	* conf.texi.in: Substitute for the variable TEXINFO_QHULL
 	* interpreter/geometryimages.m: Check for the HAVE_QHULL build
 	flag before creating certain figures.
 	* interpreter/geometry.txi: Check whether TEXINFO_QHULL is set
 	before including certain figures.
 
-2007-08-31  Sren Hauberg  <hauberg@gmail.com>
+2007-08-31  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/nonlin.txi: Extended the example.
 
 	* interpreter/poly.txi: Sectioning and documentation.
 	* interpreter/octave.texi: Adapt to changes in poly.txi.
 
 2007-08-30  David Bateman  <dbateman@free.fr>
 
@@ -2097,17 +2097,17 @@ 2007-06-25  John W. Eaton  <jwe@octave.o
 
 2007-06-18  David Bateman  <dbateman@free.fr>
 
 	* interpreter/interpimages.m: Simpler images to demonstrate
 	the continuity of the second derivative of splines.
 	* interpreter/interp.txi: Also change figures here.
 	* interpreter/Makefile.in: and here.
 
-2007-06-18  Sren Hauberg  <hauberg@gmail.com>
+2007-06-18  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/optim.txi: Added some introductory text to each
 	section.
 
 	* interpreter/set.txi: Added some introductory text.
 	* interpreter/octave.texi: Updated to reflect changes in set.txi.
 
 2007-06-15  David Bateman  <dbateman@free.fr>
@@ -2143,17 +2143,17 @@ 2007-06-12  David Bateman  <dbateman@fre
 	between interpn and interp3.
 	* hashing.txi: Remove.
 	* system.txi: Move it here as a subsection. Include explanation
 	and example.
 	* interpreter/octave.texi: Add sections for the Interpolation
 	chapter. Remove references to Hashing chapter and hashing.texi,
 	and subsections for hashing to system utilities chapter.
 
-2007-06-12  2007-06-10  Sren Hauberg  <hauberg@gmail.com>
+2007-06-12  2007-06-10  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/diffeq.txi: Note that x-dot is the derivative of x.
 
 2007-06-03  David Bateman  <dbatemna@free.fr>
 
 	* interpreter/dynamic.txi: Use "mwSize" and "mwIndex" rather than
 	"int" for indexing in mex-files and document them.
 
@@ -2171,25 +2171,25 @@ 2007-05-30  G. D. McBain  <gdmcbain@free
 
 	* interpreter/expr.txi (Assignment Ops): Doc fix.
 
 2007-05-29  Steven Mestdagh  <steven.mestdagh@esat.kuleuven.be>
 
 	* interpreter/Makefile.in ($(HTML_IMAGES_PNG)): Use cp instead of
 	INSTALL_DATA to copy files to the HTML directory.
 
-2007-05-28  Sren Hauberg  <hauberg@gmail.com>
+2007-05-28  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/errors.txi: Add new sections and some more detailed
 	descriptions on errors and warnings.
 	* interpreter/octave.texi, interpreter/stmt.txi,
 	interpreter/var.txi: Add references to the new sections in
 	errors.txi.
 
-2007-05-28  Sren Hauberg  <hauberg@gmail.com>
+2007-05-28  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/io.txi: Rearrange some sections, and add
 	a few examples.
 
 2007-05-28  G. D. McBain  <geordie_mcbain@yahoo.com.au>
 
 	* interpreter/struct.txi: Doc fix.
 
@@ -2213,17 +2213,17 @@ 2007-05-22  Thomas Weber  <thomas.weber.
 2007-05-22  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/Makefile.in (DISTFILES): Add mkcontrib.awk to the list.
 
 2007-05-21  David Bateman  <dbatemna@free.fr>
 
 	* interpreter/debug.txi, io.txi, octave.txi: Doc fixes.
 
-2007-05-21  Sren Hauberg  <hauberg@gmail.com>
+2007-05-21  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/expr.txi: Describe +=, -=, *=, and /= operators.
 	Add new example.
 
 	* interpreter/eval.txi: Partition the chapter into sections.
 	Describe evalin and assignin functions using text from Paul
 	Kienzle.  Change "See See" to "See".  Use @ref instead of @xref to
 	avoid "See" to be written with a capital letter in the middle of a
@@ -2235,27 +2235,27 @@ 2007-05-21  Sren Hauberg  <hauberg@gmail.com>
 	* interpreter/stmt.txi: Describe cell array cases for the switch
 	statement.  Minor layout changes.
 
 2007-05-19  David Bateman  <dbatemna@free.fr>
 
 	* interpreter/func.txi: Additional documentation for function
 	locking, dispatch and autoloading.
 
-2007-05-16  Sren Hauberg  <hauberg@gmail.com>
+2007-05-16  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/expr.txi: Improve docs.
 
 2007-05-14  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/basics.txi, interpreter/data.txi,
 	interpreter/intro.txi, interpreter/numbers.txi,
 	interpreter/octave.texi, interpreter/preface.txi: Doc fixes.
 
-2007-04-18  Sren Hauberg  <hauberg@gmail.com>
+2007-04-18  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/package.texi: Document "*" flag for loaded packages.
 
 	* interpreter.var.txi: Improve explanation of clear, exist, and who.
 
 	* interpreter/intro.txi: Change @unnumberedsubsec to @subsection.
 
 	* interpreter/container.txi: Doc fix.
@@ -2328,17 +2328,17 @@ 2007-04-24  David Bateman  <dbateman@fre
 	interpreter/fortdemo.cc, interpreter/funcdemo.cc,
 	interpreter/globaldemo.cc, interpreter/helloworld.cc,
 	interpreter/stringdemo.cc, interpreter/structdemo.cc,
 	interpreter/unwinddemo.cc, interpreter/fortsub.f,
 	interpreter/dynamic.txi: New files.
 
 	* Makefile.in (SUB_SOURCE): Include dynamic.txi in the list.
 
-2007-04-18  Sren Hauberg  <hauberg@gmail.com>
+2007-04-18  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/package.texi: New file.
 	* octave/texi: @include it, add it to the menus.
 
 2007-04-18  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/contributors.in: New file.
 	* interpreter/Makefile.in (contributors.texi): New target.
@@ -2353,37 +2353,37 @@ 2007-04-17  David Bateman  <dbateman@fre
 	* interpreter/octave.texi: Include it in menu.
 	* interpreter/sparse.txi: Delete discusion of matrix_type.
 
 2007-04-16  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/stream.txi: Delete.
 	* interpreter/Makefile.in (SUB_SOURCE): Remove it from the list.
 
-2007-04-16  Sren Hauberg  <hauberg@gmail.com>
+2007-04-16  Sren Hauberg  <hauberg@gmail.com>
 
 	* intrepreter/stmt.txi: Improve documentation of switch statement.
 
 	* interpreter/tips.txi: Update description of how copyright
 	statements are recognized.
 
 	* interpreter/octave.texi: Don't include stream.texi.
 	Remove menu entry for I/O streams.
 
 	* interpreter/image.txi: Update docs.
 
-2007-04-11  Sren Hauberg  <hauberg@gmail.com>
+2007-04-11  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/container.txi: Document indexing with ().
 
-2007-04-11  Sren Hauberg  <hauberg@gmail.com>
+2007-04-11  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/container.txi: Improve cell array documentation.
 
-2007-04-09  Sren Hauberg  <hauberg@gmail.com>
+2007-04-09  Sren Hauberg  <hauberg@gmail.com>
 
 	* interpreter/func.txi: Document varargin, varargout, and default
 	argument values.
 
 2007-04-03  Rafael Laboissiere  <rafael@debian.org>
 
 	* interpreter/basics.txi: Clarified some limitations of the #!
 	script mechanism, in particular related to the parsing of the
diff --git a/etc/OLD-ChangeLogs/liboctave-ChangeLog b/etc/OLD-ChangeLogs/liboctave-ChangeLog
--- a/etc/OLD-ChangeLogs/liboctave-ChangeLog
+++ b/etc/OLD-ChangeLogs/liboctave-ChangeLog
@@ -1475,17 +1475,17 @@ 2010-03-09  Jaroslav Hajek  <highegg@gma
 	octave_int_base::fnan, octave_int_base::get_trunc_flag,
 	octave_int_base::get_nan_flag,
 	octave_int_base::get_non_int_flag,
 	octave_int_base::get_math_trunc_flag,
 	octave_int_base::clear_conv_flags): Remove.
 	Remove occurences of ftrunc, fnon_int and fnan eveywhere.
 	* oct-inttypes.cc: Ditto last sentence. Remove warning tests.
 
-2010-03-07  Soren Hauberg  <hauberg@gmail.com>
+2010-03-07  Sren Hauberg  <hauberg@gmail.com>
 
 	* dim-vector.h: New constructor accepting a C array of dimensions.
 
 2010-03-05  Jaroslav Hajek  <highegg@gmail.com>
 
 	* MArray.cc (MArray<T>::idx_add_nd): New method.
 	* MArray.h: Declare it.
 
diff --git a/etc/OLD-ChangeLogs/scripts-ChangeLog b/etc/OLD-ChangeLogs/scripts-ChangeLog
--- a/etc/OLD-ChangeLogs/scripts-ChangeLog
+++ b/etc/OLD-ChangeLogs/scripts-ChangeLog
@@ -1580,17 +1580,17 @@ 2010-12-26  Michael Godfrey <godfrey@isl
 2010-12-24  Rik  <octave@nomad.inbox5.com>
 
 	* testfun/test.m: Use 'Command' for deftype in docstring.
 
 2010-12-24  Rik  <octave@nomad.inbox5.com>
 
 	* audio/setaudio.m: Re-write docstring.
 
-2010-12-23  Soren Hauberg  <hauberg@gmail.com>
+2010-12-23  Sren Hauberg  <hauberg@gmail.com>
 
 	* signal/detrend.m: Also accept polynomial order as a string
 	("constant" or "linear") for compatibility with Matlab.
 
 2010-12-22  Konstantinos Poulios  <logari81@gmail.com>
 
 	* plot/private/__axis_label__.m: Trigger fltk graphics redraw
 	immediately after setting an axis label.
@@ -2858,17 +2858,17 @@ 2010-07-26  Rik  <octave@nomad.inbox5.co
 	Add newlines between @items for readability.
 
 2010-07-26  Ben Abbott  <bpabbott@mac.com>
 
 	* general/interp1.m: When absent set X equal to the inices of Y.
 	* general/interpn.m: Convert interpolation vectors of non-equal
 	length to nd-arrays.
 
-2010-07-26  Soren Hauberg  <hauberg@gmail.com>
+2010-07-26  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/image.m: Replace parenthesis with curly bracket in Texinfo.
 
 2010-07-25  Rik  <octave@nomad.inbox5.com>
 
 	* image/image.m: Always reverse 'ydir' property when displaying images.
 
 2010-07-19  Rik  <octave@nomad.inbox5.com>
@@ -3060,17 +3060,17 @@ 2010-07-07  David Bateman  <dbateman@fre
 	* __next_line_color__.m: Allow conditional initialisation of the
 	color_rotation variable.
 	* __next_line_style__.m: Allow conditional initialisation of the
 	style_rotation variable.
 	* hold.m: Support "hold all".
 	* newplot.m: Conditionally initialisation the line style and color
 	based on the __hold_all__ axes property.
 
-2010-07-04  Soren Hauberg  <hauberg@gmail.com>
+2010-07-04  Sren Hauberg  <hauberg@gmail.com>
 
 	* polynomial/deconv.m: ensure that the orientation of the third
 	input to 'filter' matches the orientation of 'y'.
 
 2010-07-02  Rik  <octave@nomad.inbox5.com>
 
 	* audio/wavread.m: Correctly handle non-word aligned data chunks.
 	(bug #30309).
@@ -3728,27 +3728,27 @@ 2010-03-24  Jaroslav Hajek  <highegg@gma
 2010-03-24  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/cell2mat.m: Support cells of cells.
 
 2010-03-23  John W. Eaton  <jwe@octave.org>
 
 	* plot/refreshdata.m: Don't use cell2mat on cell array of cell arrays.
 
-2010-03-22  Soren Hauberg  <hauberg@gmail.com>
+2010-03-22  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/gmap40.m, image/hot.m, image/hsv2rgb.m, image/image.m,
 	image/image_viewer.m, image/imfinfo.m, image/imread.m, image/imshow.m,
 	image/saveimage: Detabify.
 
-2010-03-21  Soren Hauberg  <hauberg@gmail.com>
+2010-03-21  Sren Hauberg  <hauberg@gmail.com>
 
 	* general/quadv.m: Replace 'quadl' with 'quadv' in help text.
 
-2010-03-20  Soren Hauberg  <hauberg@gmail.com>
+2010-03-20  Sren Hauberg  <hauberg@gmail.com>
 
 	* general/interp2.m: For nearest neighbour interpolation ceil
 	(instead of floor) at the center of the data intervals to be
 	compatible with Matlab.  Add test.
 	* general/interpn.m: Ditto.
 
 2010-03-19  Jaroslav Hajek  <highegg@gmail.com>
 
@@ -3777,22 +3777,22 @@ 2010-03-16  Jaroslav Hajek  <highegg@gma
 2010-03-11  Jaroslav Hajek  <highegg@gmail.com>
 
 	* strings/index.m: Make it a wrapper for strfind.
 
 2010-03-11  Jaroslav Hajek  <highegg@gmail.com>
 
 	* strings/strchr.m: Optimize.
 
-2010-03-05  Soren Hauberg  <hauberg@gmail.com>
+2010-03-05  Sren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m (write_index): include classes in autogenerated
 	INDEX files.
 
-2010-03-05  Soren Hauberg  <hauberg@gmail.com>
+2010-03-05  Sren Hauberg  <hauberg@gmail.com>
 
 	* plot/fplot.m: Ensure that 'limits' is a 2 or 4 vector, and
 	that 'fn' is a function.
 
 2010-03-05  Jaroslav Hajek  <highegg@gmail.com>
 
 	* testfun/test.m: Support catching warnings and errors by IDs.
 
@@ -4733,40 +4733,40 @@ 2009-11-02  Jaroslav Hajek  <highegg@gma
 	* polynomial/spline.m: Update.
 	* general/__splinen__.m: Update.
 
 2009-10-23  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/tril.m, general/triu.m: Remove sources.
 	* general/Makefile.in: Update.
 
-2009-10-20  Soren Hauberg  <hauberg@gmail.com>
+2009-10-20  Sren Hauberg  <hauberg@gmail.com>
 
 	* general/interp2.m: improved error checking and support for bicubic
 	interpolation when X and Y are meshgrid format.
 
 2009-10-22  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/interp1.m: Perform optimizations, improve code (use switch
 	instead of multiple ifs).
 	* polynomial/pchip.m: Employ more optimized formulas (from SLATEC).
 
-2009-10-22  Soren Hauberg  <hauberg@gmail.com>
+2009-10-22  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/autumn.m, image/bone.m, image/cool.m, image/copper.m,
 	image/flag.m, image/gmap40.m, image/gray.m, image/hot.m,
 	image/hsv.m, image/jet.m, image/ocean.m, image/pink.m,
 	image/prism.m, image/rainbow.m, image/spring.m, image/summer.m,
 	image/white.m, image/winter.m: Add demos.
 
-2009-10-20  Soren Hauberg  <hauberg@gmail.com>
+2009-10-20  Sren Hauberg  <hauberg@gmail.com>
 
  	* general/interp2.m: improved error checking and support for bicubic
 
-2009-10-19  Soren Hauberg  <hauberg@gmail.com>
+2009-10-19  Sren Hauberg  <hauberg@gmail.com>
 
 	* io/strread.m, io/textread.m: New functions.
 
 2009-10-20  Jaroslav Hajek  <highegg@gmail.com>
 
 	* statistics/base/center.m: Rewrite using bsxfun.
 
 2009-10-15  David Bateman  <dbateman@free.fr>
@@ -5237,25 +5237,25 @@ 2009-05-27  John W. Eaton  <jwe@octave.o
 	* image/imshow.m: In demo, convert image to rgb before scaling
 	components.  Use imread instead of loadimage.
 
 2009-05-26  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/__go_draw_axes__.m: Fix rendering of overlaping images and
 	line objects.  Add demos as well.
 
-2009-05-27 Sren Hauberg  <hauberg@gmail.com>
+2009-05-27 Sren Hauberg  <hauberg@gmail.com>
 
 	* geometry/delaunay.m: Support cellstr's as options.
 
 2009-05-27  Jaroslav Hajek  <highegg@gmail.com>
 
 	* plot/imshow.m: Fix handling of indexed images.
 
-2009-05-26 Sren Hauberg  <hauberg@gmail.com>
+2009-05-26 Sren Hauberg  <hauberg@gmail.com>
 
 	* help/__makeinfo__.m: Support several @seealso's in one text.
 
 2009-05-26  John W. Eaton  <jwe@octave.org>
 
 	* plot/colorbar.m: Downcase location argument.
 
 2009-05-26 Carlo de Falco  <kingcrimson@tiscali.it>
@@ -5616,17 +5616,17 @@ 2009-03-09  John W. Eaton  <jwe@octave.o
 	Use doc-cache instead of DOC for doc cache file.
 
 2009-03-09  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/accumarray.m: Reorder tests. Call either "sparse" or
 	__accumarray_sum__ for the default summation case.
 	* statistics/base/histc.m: Reimplement using lookup & accumarray.
 
-2009-03-08  Sren Hauberg  <hauberg@gmail.com>
+2009-03-08  Sren Hauberg  <hauberg@gmail.com>
 
 	* statistics/base/histc.m: New function.
 
 2009-03-06  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/__go_draw_axes__.m: Preserve the order of axes' children
 	when pruning the handles for the {x,y,z}labels and title.
 	* plot/legend.m: Change demo to add colors to lines. This change
@@ -5954,22 +5954,22 @@ 2009-02-15  Ben Abbott  <bpabbott@mac.co
 2009-02-13 Ben Abbott  <bpabott@mac.com>
 
 	* plot/__go_draw_axes__.m: Respect axes ticklength property.
 
 2009-02-12  John W. Eaton  <jwe@octave.org>
 
 	* general/sortrows.m: Call __sort_rows_idx__, not __sortrows_idx__.
 
-2009-02-12  Soren Hauberg  <hauberg@gmail.com>
+2009-02-12  Sren Hauberg  <hauberg@gmail.com>
 
 	* help/gen_doc_cache.m: Change API so we only handle one directory per
 	call to this function.
 
-2009-02-12  Soren Hauberg  <hauberg@gmail.com>
+2009-02-12  Sren Hauberg  <hauberg@gmail.com>
 
 	* help/lookfor.m: Adapt to new cache scheme.
 
 2009-02-11  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/sortrows.m: Employ __sortrows_idx__ when applicable,
 	gripe for sparse matrices.
 
@@ -6007,17 +6007,17 @@ 2009-02-05  Thomas D. Dean  <tomdean@spe
 
 	* polynomial/polyout.m: Replace com2str with num2str, and minor
 	style changes.
 
 2009-02-04  John W. Eaton  <jwe@octave.org>
 
 	* help/which.m: Still print something sensible if type is empty.
 
-2009-02-04  Soren Hauberg  <hauberg@gmail.com>
+2009-02-04  Sren Hauberg  <hauberg@gmail.com>
 	    Thomas Treichl  <Thomas.Treichl@gmx.net>
 
 	* miscellaneous/Makefile.in (SOURCES): Add bzip2.m to the list.
 
 2009-02-04  Frederick Umminger  <Frederick_Umminger@playstation.sony.com>
 
 	* signal/freqz.m: Ensure causal phase response.
 	Handle long input correctly.
@@ -6102,17 +6102,17 @@ 2009-01-30  Ben Abbott  <bpabbott@mac.co
 2009-01-29  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/fileparts.m: Match all possible file separators.
 
 2009-01-29  Kai Habel  <kai.habel@gmx.de>
 
 	* plot/__go_draw_axes__.m: Add support for transparent patches.
 
-2009-01-29  Sren Hauberg  <hauberg@gmail.com>
+2009-01-29  Sren Hauberg  <hauberg@gmail.com>
 
 	* help/help.m, help/print_usage.m, help/get_first_help_sentence.m:
 	print sensible error message when function is found but not documented.
 
 	* help/help.m: Allow displaying 'Contents.m' files.
 
 2009-01-29  Kai Habel  <kai.habel@gmx.de>
 
@@ -6155,17 +6155,17 @@ 2009-01-27  Jason Riedy  <jason@acm.org>
 
 	* miscellaneous/orderfields.m: Really fix the indexing for struct
 	arrays.
 
 2009-01-27  Carlo de Falco  <kingcrimson@tsicali.it>
 
 	* polynomial/spline.m: Doc fix.
 
-2009-01-27  Sren Hauberg  <hauberg@gmail.com>
+2009-01-27  Sren Hauberg  <hauberg@gmail.com>
 
 	* general/gradient.m: Handle computing the gradient of a function
 	handle.
 
 2009-01-27  Jaroslav Hajek  <highegg@gmail.com>
 
 	* optimization/lsqnonneg.m: Reimplement using QR updating for
 	square and overdetermined systems.
@@ -6201,31 +6201,31 @@ 2009-01-17  Jaroslav Hajek  <highegg@gma
 2008-12-24 Ben Abbott  <bpabbott@mac.com>
 
 	* path/savepath.m: Respect cmd-line and env paths.
 
 2009-01-24 Ben Abbott  <bpabbott@mac.com>
 
 	* sparse/svds.m: svds.m: skip tests if ARPACK is missing.
 
-2009-01-23  Sren Hauberg  <hauberg@gmail.com>
+2009-01-23  Sren Hauberg  <hauberg@gmail.com>
 
 	* help/type.m: Make 'type X' work, when X is the name of a variable.
 
 2009-01-22  John W. Eaton  <jwe@octave.org>
 
 	* help/which.m: New function.
 	* help/Makefile.in (SOURCES): Add it to the list.
 
 	* help/help.m: Also display location of the file before the help text.
 	* help/print_usage: Also display additional help text.
 	* help/__additional_help_message__.m: Return message instead of
 	displaying it.
 
-2009-01-22  Sren Hauberg  <hauberg@gmail.com>
+2009-01-22  Sren Hauberg  <hauberg@gmail.com>
 
 	* help: New directory.
 	* configure.in (AC_CONFIG_FILES): Add help/Makefile to the list.
 	* Makefile.in (SUBDIRS): Add it to the list.
 	* help/__additional_help_message__.m, help/__strip_html_tags__.m,
 	help/gen_doc_cache.m, help/get_first_help_sentence.m, help/help.m,
 	help/lookfor.m, help/makeinfo.m, help/print_usage.m, help/type.m:
 	New functions.
@@ -6306,17 +6306,17 @@ 2008-01-15  Rafael Laboissiere  <rafael@
 
 	* gethelp.cc: Include <cstdio>.
 
 2009-01-14  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/__go_draw_axes__.m (ticklabel_to_cell): New function.
 	Use it to handle non-cell ticklabels.
 
-2009-01-14  Sren Hauberg  <hauberg@gmail.com>
+2009-01-14  Sren Hauberg  <hauberg@gmail.com>
 
 	* general/diff.m, general/logspace.m, general/nextpow2.m,
 	linear-algebra/commutation_matrix.m,
 	linear-algebra/duplication_matrix.m, linear-algebra/expm.m,
 	miscellaneous/bincoeff.m, miscellaneous/list_primes.m,
 	optimization/fsolve.m, plot/subplot.m, polynomial/pchip.m,
 	polynomial/polyout.m, polynomial/residue.m, polynomial/spline.m,
 	signal/freqz.m, signal/sinc.m, specfun/beta.m, specfun/betaln.m,
@@ -6690,17 +6690,17 @@ 2008-10-29  John W. Eaton  <jwe@octave.o
 
 	* plot/cla.m: In test, set visible off when creating figure.
 
 2008-10-28  Gabriele Pannocchia  <g.pannocchia@ing.unipi.it>
 
 	* optimization/qp.m: Convert bounds of the form b <= x <= b and
 	constraints of the form b <= A*x <= b to equality constraints.
 
-2008-10-27  Sren Hauberg  <hauberg@gmail.com>
+2008-10-27  Sren Hauberg  <hauberg@gmail.com>
 
 	* plot/ellipsoid.m: Check nargin == 6, not nargin == 5.
 
 2008-10-22  Ben Abbott  <bpabbott@mac.com>
 
 	* plot/cla.m: Fix error when no children to clear.
 
 	* plot/findobj.m: Allow handle to be empty.
@@ -6967,25 +6967,25 @@ 2008-09-26  David Bateman  <dbateman@fre
 	* general/subsindex.m: Dummy subsindex function for help string
 	and to throw error for use outside of a class
 	* general/Makefile.in (SOURCES): Include it here.
 
 2008-09-26  John W. Eaton  <jwe@octave.org>
 
 	* image/imfinfo.m: Delete temporary file.
 
-2008-09-25  Sren Hauberg  <hauberg@gmail.com>
+2008-09-25  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/imread.m, image/imwrite.m: Doc fix.
 
 2008-09-24  John W. Eaton  <jwe@octave.org>
 
 	* plot/fplot.m: Call axis after calling plot.
 
-2008-09-24  Sren Hauberg  <hauberg@gmail.com>
+2008-09-24  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/imfinfo.m: New function.
 	* image/Makefile.in (SOURCES): Add it to the list.
 
 2008-09-24  Ben Abbott  <bpabbott@mac.com>
 
 	* strings/strcat.m: Improve Matlab compatibility for non-character
 	data.
@@ -7445,17 +7445,17 @@ 2008-04-25  John W. Eaton  <jwe@octave.o
 	* miscellaneous/Makefile.in (SOURCES): Add it to the list.
 
 2008-04-21  David Bateman  <dbateman@free.fr>
 
 	* plot/__go_draw_axes__.m (gnuplot_position_colorbox): New arg, obj.
 	Change caller.  Improve sizing and position of colorbox for subplots.
 	* plot/colorbar.m: New demos.
 
-2008-04-16  Sren Hauberg  <hauberg@gmail.com>
+2008-04-16  Sren Hauberg  <hauberg@gmail.com>
 
 	* plot/__gnuplot_version__.m: Display error if gnuplot is not found.
 
 2008-04-15  John W. Eaton  <jwe@octave.org>
 
 	* plot/view.m: Get values from current axes if nargin == 0.
 
 2008-04-15  David Bateman  <dbateman@free.fr>
@@ -7735,17 +7735,17 @@ 2008-03-28  Jaroslav Hajek  <highegg@gma
 
 	* general/del2.m: Missing semicolon.
 
 2008-03-28  Julian Schnidder  <j.schnidder@gmx.de>
 
 	* miscellaneous/info.m: New function.
 	* miscellaneous/Makefile.in (SOURCES): Add it to the list.
 
-2008-03-27  Sren Hauberg  <hauberg@gmail.com>
+2008-03-27  Sren Hauberg  <hauberg@gmail.com>
 
 	* plot/xlim.m, plot/ylim.m, plot/zlim.m, strings/strtrim.m:
 	Doc fixes.
 
 2008-03-27  David Bateman  <dbateman@free.fr>
 
 	* plot/__plt2__.m: Test if args are empty first so that
 	plot(zeros(1,0),zeros(1,0)) works as expected.
@@ -7793,29 +7793,29 @@ 2008-03-26  John W. Eaton  <jwe@octave.o
 	plot/patch.m, plot/ribbon.m, plot/surface.m, polynomial/mkpp.m,
 	polynomial/pchip.m, polynomial/spline.m, set/unique.m:
 	Texinfo fixes.
 
 2008-03-26  Jaroslav Hajek  <highegg@gmail.com>
 
 	* linear-algebra/dmult.m: Handle scaling along arbitrary dimension.
 
-2008-03-26  Sren Hauberg  <hauberg@gmail.com>
+2008-03-26  Sren Hauberg  <hauberg@gmail.com>
 
 	* polynomial/convn.m: New tests.
 
 2008-03-20  Ben Abbott  <bpabbott@mac.com>
 
 	* statistics/base/statistics.m: Calculate median and quantiles in
 	a manner consistent with method #7 used by GNU R.
 	* statistics/base/__quantile__.m, statistics/base/quantile.m,
 	statistics/base/prctile.m: New functions.
 	* statistics/base/Makefile.in (SOURCES): Add them to the list.
 
-2008-03-25  Sren Hauberg  <hauberg@gmail.com>
+2008-03-25  Sren Hauberg  <hauberg@gmail.com>
 
 	* polynomial/convn.m: New function.
 	* polynomial/Makefile.in (SOURCES): Add it to the list.
 
 2008-03-25  David Bateman  <dbateman@free.fr>
 
 	* image/contrast.m: New function.
 	* image/Makefile.in (SOURCES): Add it to the list.
@@ -8322,17 +8322,17 @@ 2008-01-15  Ben Abbott  <bpabbott@mac.co
 	* linear-algebra/__norm__.m: Avoid divide by zero error for
 	Frobenius norm if matrix is all zeros.  Use transpose instead of
 	hermitian operator.
 
 2008-01-14  Bill Denney  <bill@denney.ws>
 
 	* plot/axis.m: Correctly handle "tight" and "image" options.
 
-2008-01-14  Sren Hauberg  <hauberg@gmail.com>
+2008-01-14  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/hsv2rgb.m, image/ntsc2rgb.m, image/rgb2hsv.m,
 	image/rgb2ntsc.m: Also accept images as input.
 
 	* image/gray2ind.m: Handle image type other than double.
 	Improve error checking and documentation.
 
 2008-01-14  John W. Eaton  <jwe@octave.org>
@@ -8383,17 +8383,17 @@ 2008-01-07  John W. Eaton  <jwe@octave.o
 2008-01-04  Thomas Treichl  <Thomas.Treichl@gmx.net>
 
 	* strings/strtrim.m: Doc fix.
 
 2008-01-04  Muthiah Annamalai  <muthuspost@gmail.com>
 
 	* general/sub2ind.m, general/ind2sub.m: Doc fix.
 
-2008-01-04  Sren Hauberg   <hauberg@gmail.com>
+2008-01-04  Sren Hauberg   <hauberg@gmail.com>
 
 	* set/create_set.m, set/union.m: Accept "rows" argument.
 
 2008-01-02  John W. Eaton  <jwe@octave.org>
 
 	* plot/print.m: Correctly handle pbm terminal.
 
 2007-12-28  John W. Eaton  <jwe@octave.org>
@@ -8411,25 +8411,25 @@ 2007-12-28  Kai Habel  <kai.habel@gmx.de
 
 	* plot/pcolor.m: Swap 1st and 2nd argument in call to meshgrid.
 	Remove unnecessary call of size function.
 
 2007-12-21  John W. Eaton  <jwe@octave.org>
 
 	Version 3.0.0 released.
 
-2007-12-21  Sren Hauberg  <hauberg@gmail.com>
+2007-12-21  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/imshow.m: Accept empty value for display_range.
 
 2007-12-20  Michael Goffioul  <michael.goffioul@gmail.com>
 
 	* pkg/pkg.m: Add .lib as architecture-dependent suffix.
 
-2007-12-19  Sren Hauberg  <hauberg@gmail.com>
+2007-12-19  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/imshow.m: Store uint8 images as doubles.  Handle default
 	display ranges correctly.
 
 2007-12-19  Alexander Barth  <barth.alexander@gmail.com>
 	    Peter A. Gustafson  <petegus@umich.edu>
 
 	* plot/contourc.m: Allow usage of irregular spaced x, y data.
@@ -9222,17 +9222,17 @@ 2007-10-19  David Bateman  <dbateman@fre
 
 	* plot/__bar__.m, plot/fill.m: Call newplot as needed.
 
 2007-10-17  Carlo de Falco  <kingcrimson@tiscali.it>
 
 	* plot/print.m: Handle -textspecial and -textnormal flags for fig
 	output.
 
-2007-10-15  Sren Hauberg  <hauberg@gmail.com>
+2007-10-15  Sren Hauberg  <hauberg@gmail.com>
 
 	* general/rat.m, sparse/pcg.m, sparse/pcr.m, optimization/sqp.m,
 	statistics/models/logistic_regression.m, polynomial/polygcd.m,
 	control/system/ss.m, signal/arch_rnd.m, control/system/ss2sys.m,
 	control/system/syssetsignals.m, control/base/lqg.m,
 	strings/str2double.m, control/system/sysscale.m,
 	control/hinf/hinfdemo.m, general/cplxpair.m:
 	Make help text fit on pages when using smallbook.
@@ -9407,17 +9407,17 @@ 2007-10-08  John Swensen  <jpswensen@com
 	* general/num2str.m: Eliminate extra whitespace in output.
 	* strings/strtrim.m: New function.
 	* strings/Makefile.in (SOURCES): Add it to the list.
 
 2007-10-06  John W. Eaton  <jwe@octave.org>
 
 	* polynomial/residue.m: New test from test/test_poly.m.
 
-2007-10-06  Sren Hauberg  <hauberg@gmail.com>
+2007-10-06  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/saveimage.m: Handle saving color images without a colormap.
 	* image/__img_via_file__.m: Add missing semicolon.
 
 2007-10-06  Bill Denney  <wsloand@gmail.com>
 
 	* general/__splinen__.m, general/isscalar.m, general/rat.m,
 	strings/dec2base.m: Use numel(x) instead of prod(size(x)).
@@ -9650,17 +9650,17 @@ 2007-08-31  Michael goffioul  <michael.g
 
 	* plot/axes.m: Allow parent to be specified when creating axes
 	objects.  Support non-figure parents.
 
 2007-08-31  John W. Eaton  <jwe@octave.org>
 
 	* plot/ancestor.m: New function, adapted from Octave Forge.
 
-2007-08-31  Sren Hauberg  <hauberg@gmail.com>
+2007-08-31  Sren Hauberg  <hauberg@gmail.com>
 
 	* polynomial/polygcd.m: Better layout of example.
 	* polynomial/compan.m: Remove unnecessary check.
 	* polynomial/roots.m: Added example to help text.
 	* polynomial/polyderiv.m: Change 'polyder' to 'polyderiv' in help text.
 	* polynomial/poly.m: Added example to help text.
 
 2007-08-30  John W. Eaton  <jwe@octave.org>
@@ -9884,25 +9884,25 @@ 2007-06-27  Michael Goffioul  <michael.g
 	* image/colormap.m: Only return colormap if nargout > 0.
 	Mark as command.
 
 2007-06-25  John W. Eaton  <jwe@octave.org>
 
 	* plot/drawnow.m, plot/__go_draw_axes__.m: Use strcmpi instead of
 	strcmp for selected property comparisons.
 
-2007-06-25  Sren Hauberg  <hauberg@gmail.com>
+2007-06-25  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/imshow.m: Fix check for colormap arguments.
 
 2007-06-25  Joel Keay  <keay@nhn.ou.edu>
 
 	* plot/drawnow.m: Handle GNUTERM=aqua if DISPLAY is not set.
 
-2007-06-25  Sren Hauberg  <hauberg@gmail.com>
+2007-06-25  Sren Hauberg  <hauberg@gmail.com>
 
 	* statistics/base/median.m: Update help text to mention 'dim'
 	argument, and note that the data should be sorted for the
 	definition of the median to be correct.
 
 	* statistics/base/std.m: Add missing square to definition of
 	standard deviation.
 
@@ -9985,29 +9985,29 @@ 2007-06-19  David Bateman  <dbateman@fre
 	* sparse/gplot.m: ditto.
 	* sparse/treeplot.m: ditto.
 
 2007-06-19  John W. Eaton  <jwe@octave.org>
 
 	* plot/__go_draw_axes__.m (do_tics, do_tics_1): New functions.
 	(__go_draw_axes__): Call do_tics to handle tic marks.
 
-2007-06-18  Sren Hauberg  <hauberg@gmail.com>
+2007-06-18  Sren Hauberg  <hauberg@gmail.com>
 
 	* general/interp1.m, general/interp2.m, general/interp3.m,
 	general/interpn.m: Replace, NaN with NA.  Use isna instead of ==
 	to check for NA.
 
-2007-06-18  Sren Hauberg  <hauberg@gmail.com>
+2007-06-18  Sren Hauberg  <hauberg@gmail.com>
 
 	* optimization/glpk.m: TeXified the help text.
 	* optimization/qp.m: TeXified the help text.
 	* optimization/sqp.m: TeXified the help text.
 
-2007-06-16  Sren Hauberg  <hauberg@gmail.com>
+2007-06-16  Sren Hauberg  <hauberg@gmail.com>
 
 	* plot/legend.m: Replace 'vargin' with 'varargin'.
 
 2007-06-15  John W. Eaton  <jwe@octave.org>
 
 	* plot/__go_draw_axes__.m: Only attempt label rotation if
 	have_newer_gnuplot is true.
 
@@ -10089,17 +10089,17 @@ 2007-06-12  David Bateman  <dbateman@fre
 	* general/interp3.m: New function for 3-dimensional, linear, nearest
 	and spline interpolation.
 	* polynomial/spline.m: Change examples to use new graphics interface.
 
 2007-06-12  Steve M. Robbins  <steve@sumost.ca>
 
 	* statistics/tests/wilcoxon_test.m: Error if N <= 25.
 
-2007-06-12  Sren Hauberg  <soren@hauberg.org>
+2007-06-12  Sren Hauberg  <soren@hauberg.org>
 
 	* plot/fplot.m: If function is inline, vectorize it.
 
 2007-06-10  David Bateman  <dbateman@free.fr>
 
 	* pkg/pkg.m (pkg:installed_packages): truncate start of package
 	directory if need to, so that it fits on a line.
 
@@ -10116,17 +10116,17 @@ 2007-06-07  David Bateman  <dbateman@fre
 	(pkg:save_order): New function to sort package list with dependent
 	packages first.
 	(pkg:load_packages_and_dependencies): New function to load both a
 	list of packages and their dependencies.
 	(pkg:load_package_dirs): New function that returns a vector of the
 	indexes into the installed package list indicating the packages to
 	load and the order to load them in to respect the dependencies.
 
-2007-06-03  Sren Hauberg  <soren@hauberg.org>
+2007-06-03  Sren Hauberg  <soren@hauberg.org>
 
 	* plot/axes.m: Eliminate redundant else clause.
 
 2007-06-03  David Bateman  <dbateman@free.fr>
 
 	* polynomial/spline.m: Add a small tolerance to spline tests.
 	* pkg/pkg.m: Protect against multiple actions being define.
 
@@ -10228,17 +10228,17 @@ 2007-05-18  David Bateman  <dbateman@fre
 	it exists to address issues with autoload/mfilename.
 	(write_INDEX): Check in archiecture dependent directories as well.
 
 2007-05-17  David Bateman  <dbateman@free.fr>
 
 	* plot/hbar.m: Remove.
 	* plot/barh.m: and move it here.
 
-2007-05-16  Sren Hauberg  <soren@hauberg.org>
+2007-05-16  Sren Hauberg  <soren@hauberg.org>
 
 	* general/sub2ind.m, general/ind2sub.m: Doc fix.
 
 2007-05-16  John W. Eaton  <jwe@octave.org>
 
 	* general/logspace.m: Return second arg if fewer than two values
 	are requested.
 
@@ -10259,17 +10259,17 @@ 2007-05-14  Tarmigan Casebolt  <tarmigan
 	* deprecated/normal_cdf.m, deprecated/normal_inv.m,
 	deprecated/normal_pdf.m, deprecated/normal_rnd.m: Preserve
 	backward compatibility.
 
 2007-05-14  David Bateman  <dbateman@free.fr>
 
 	* pkg/pkg.m: Mark loaded packages with "*".
 
-2007-05-13  Sren Hauberg  <soren@hauberg.org>
+2007-05-13  Sren Hauberg  <soren@hauberg.org>
 
 	* miscellaneous/single.m: Doc fix.
 	Convert to double instead of returning argument unchanged.
 
 	* miscellaneous/doc.m: Doc fix.
 
 	* miscellaneous/ver.m: Doc fix.
 	Don't display information about Octave Forge.
@@ -10344,17 +10344,17 @@ 2007-04-25  John W. Eaton  <jwe@octave.o
 	* plot/__go_draw_axes__.m: For images, set titlespec{data_idx} to
 	"title \"\"", not "".
 
 	* plot/legend.m: Initialize WARNED to false.
 
 2007-04-24  John W. Eaton  <jwe@octave.org>
 
 	* io/beep.m: Fix cut and paste error.
-	From Sren Hauberg  <soren@hauberg.org>.
+	From Sren Hauberg  <soren@hauberg.org>.
 
 2007-04-23  John W. Eaton  <jwe@octave.org>
 
 	* plot/box.m: Delete extra endfunction keyword.
 
 2007-04-23  David Bateman  <dbateman@free.fr>
 
 	* plot/plot3.m: Call newplot.
@@ -10395,17 +10395,17 @@ 2007-04-17  Paul Kienzle  <pkienzle@user
 
 	* specfun/factorial.m: Use gamma function instead of cumprod.
 	Add tests.
 
 2007-04-16  John W. Eaton  <jwe@octave.org>
 
 	* gethelp.cc (looks_like_octave_copyright): Use same logic as in
 	looks_like_copyright in src/help.cc.
-	From Sren Hauberg <soren@hauberg.org>.
+	From Sren Hauberg <soren@hauberg.org>.
 
 	* plot/__go_draw_axes__.m: For log plots, omit zero values too.
 
 2007-04-13  John W. Eaton  <jwe@octave.org>
 
 	* optimization/sqp.m: Initialize info to 0.
 
 	* optimization/qp.m: Undo previous change.
@@ -10760,17 +10760,17 @@ 2007-03-14  John W. Eaton  <jwe@octave.o
 	* miscellaneous/delete.m: Call __go_delete__, not
 	__uiobject_delete__.  Check that arg is a graphics handle before
 	calling __go_delete__.
 
 2007-03-13  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/cast.m: Use feval and strcmp with cell to check
 	arg instead of switch statement.
-	From Sren Hauberg <soren@hauberg.org>.
+	From Sren Hauberg <soren@hauberg.org>.
 
 2007-03-12  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/cast.m: New function.
 
 	* miscellaneous/delete.m: Call __go_delete__, not __uiobject_delete__.
 
 2007-03-08  John W. Eaton  <jwe@octave.org>
@@ -11433,17 +11433,17 @@ 2007-01-23  Luis F. Ortiz  <lortiz@inter
 2007-01-22  Bob Weigel  <rweigel@gmu.edu>
 
 	* testfun/test.m: Check for all files in path, use first found.
 
 2007-01-22  David Bateman  <dbateman@free.fr>
 
 	* polynomial/spline.m: Make DG a column instead of a row vector.
 
-2007-01-18  Sren Hauberg  <hauberg@gmail.com>
+2007-01-18  Sren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m (copy_files): Call write_INDEX with correct target
 	file name.
 
 	* image/ind2rgb.m: Better input checking.  Return 3-d array if
 	nargout is 1.  Handle colormaps that have too few colors.
 
 	* pkg/pkg.m (create_pkgadddel): Call fullfile with nm, not "nm".
@@ -11455,58 +11455,58 @@ 2007-01-10  Baylis Shanks  <bshanks3@hot
 
 2007-01-10  David Bateman  <dbateman@free.fr>
 
 	* elfun/acosd.m, elfun/acotd.m, elfun/acscd.m, elfun/asecd.m,
 	elfun/asind.m, elfun/atand.m, elfun/cosd.m, elfun/cotd.m,
 	elfun/cscd.m, elfun/secd.m, elfun/sind.m, elfun/tand.m:
 	New files.
 
-2007-01-09  Sren Hauberg  <hauberg@gmail.com>
+2007-01-09  Sren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m: Allow filenames to contain glob patterns.
 
-2007-01-08  Sren Hauberg  <hauberg@gmail.com>
+2007-01-08  Sren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m: Use copyfile instead of calling system.  Use fullfile
 	instead of concatenating with "/".  Use mlock to ensure that
 	persistent variables are not clobbered if user types clear all.
 
 2007-01-08  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/copyfile.m, miscellaneous/movefile.m:
 	Improve handling of file names containing globbing characters.
-	From Sren Hauberg <hauberg@gmail.com>.
+	From Sren Hauberg <hauberg@gmail.com>.
 
 2007-01-05  John W. Eaton  <jwe@octave.org>
 
 	* optimization/optimset.m, optimization/__fsolve_defopts__.m:
 	New files.
 
 2006-12-30  John W. Eaton  <jwe@octave.org>
 
 	* sparse/spfun.m: Check for "function_handle" not "function handle".
 	* plot/fplot.m: Likewise.  Use isa instead of strcmp + class.
 
-2006-12-27  Sren Hauberg  <hauberg@gmail.com>
+2006-12-27  Sren Hauberg  <hauberg@gmail.com>
 
 	* image/imshow.m: Strip NaNs from image.
 
 2006-12-08  David Bateman  <dbateman@free.fr>
 
 	* sparse/normest.m: New file.
 
 2006-12-06  Michael Goffioul  <michael.goffioul@swing.be>
 
 	* miscellaneous/copyfile.m, miscellaneous/movefile.m:
 	Work on Windows systems without cp or mv.
 
 	* startup/inputrc: Include sequences for Windows.
 
-2006-12-06  Sren Hauberg  <hauberg@gmail.com>
+2006-12-06  Sren Hauberg  <hauberg@gmail.com>
 
 	* pkg/pkg.m (unload_packages): New function.
 	(pkg): Handle unload action.
 
 	* __errplot__.m: Add missing semicolon.
 
 2006-11-30  John W. Eaton  <jwe@octave.org>
 
@@ -11573,17 +11573,17 @@ 2006-11-14  John W. Eaton  <jwe@octave.o
 	* plot/bottom_title.m, plot/top_title.m: Delete.
 
 	* image/image_viewer.m: Set default values here.
 	* image/image.m: Not here.
 
 	* image/image_viewer.m: Always return old values.  Check arguments.
 	* image/__img_gnuplot__.m: Rename from __img__m.
 
-2006-11-14  Sren Hauberg  <soren@hauberg.org>
+2006-11-14  Sren Hauberg  <soren@hauberg.org>
 
 	* image/image_viewer.m: New function.
 	* image/__img_via_file__.m: New function.
 	* image/image.m: Use image_viewer to determine which program to
 	use for image viewing.
 	* image/__img__.m: Silently accept more than 3 args.
 
 2006-11-14  John W. Eaton  <jwe@octave.org>
@@ -11603,35 +11603,35 @@ 2006-11-13  John W. Eaton  <jwe@octave.o
 	* miscellaneous/substruct.m: New function.
 
 	* testfun/assert.m: Force orientation to match when comparing
 	struct elements.
 
 	* general/__isequal__.m: Avoid assignment of comma-separated lists
 	when comparing structs.
 
-2006-11-13  Sren Hauberg  <hauberg@gmail.com>
+2006-11-13  Sren Hauberg  <hauberg@gmail.com>
 
 	* general/bicubic.m, general/cart2pol.m, general/cart2sph.m,
 	plot/contour.m, linear-algebra/cross.m, general/cumtrapz.m,
 	linear-algebra/dot.m, image/imshow.m, general/interp2.m,
 	general/mod.m, plot/plot3.m, plot/__plr2__.m, plot/__plr__.m,
 	general/pol2cart.m, general/polyarea.m, polynomial/polyfit.m,
 	general/rem.m, image/rgb2ind.m, general/sph2cart.m,
 	general/trapz.m, miscellaneous/xor.m: Use size_equal.
 
 2006-11-13  John W. Eaton  <jwe@octave.org>
 
 	* plot/mesh.m: Use size_equal to compare dimensions.
 
-2006-11-13  Sren Hauberg  <soren@hauberg.org>
+2006-11-13  Sren Hauberg  <soren@hauberg.org>
 
 	* plot/mesh.m: Simplify.  Set hidden3d for the plot.
 
-2006-11-11  Sren Hauberg  <soren@hauberg.org>
+2006-11-11  Sren Hauberg  <soren@hauberg.org>
 
 	* miscellaneous/copyfile.m: Fix docs to match function.
 
 2006-11-08  John W. Eaton  <jwe@octave.org>
 
 	* plot/legend.m: New function, adapted from Octave Forge.
 
 	* plot/__do_legend__.m: New function.
@@ -11669,17 +11669,17 @@ 2006-11-08  John W. Eaton  <jwe@octave.o
 
 	* strings/strcat.m: Disable Octave:empty-list-elements warning
 	whle concatenating args.
 
 2006-11-07  John W. Eaton  <jwe@octave.org>
 
 	* startup/main-rcfile: Conditionally set PAGER_FLAGS.
 
-2006-11-06  Sren Hauberg  <soren@hauberg.org>
+2006-11-06  Sren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m (extract_pkg): No need to pass "dotexceptnewline"
 	option to regexp.
 
 	* image/__img__.m: Send "set size ratio -1" before plotting.
 
 2006-11-03  Bill Denney  <denney@seas.upenn.edu>
 
@@ -11715,17 +11715,17 @@ 2006-10-25  Quentin Spencer  <qspencer@i
 	Daniel J Sebald <daniel.sebald@ieee.org>.
 
 2006-10-25  John W. Eaton  <jwe@octave.org>
 
 	* plot/__gnuplot_version__.m: New function, originally from
 	Daniel J Sebald <daniel.sebald@ieee.org> by way of
 	Quentin Spencer <qspencer@ieee.org>.
 
-2006-10-25  Sren Hauberg  <soren@hauberg.org>
+2006-10-25  Sren Hauberg  <soren@hauberg.org>
 
 	* plot/__pltopt__.m: Update symbol marker id numbers for gnuplot 4.
 
 2006-10-24  Bill Denney  <denney@seas.upenn.edu>
 
 	* miscellaneous/unpack.m, miscellaneous/bunzip2.m,
 	miscellaneous/gunzip.m: New files.
 	* miscellaneous/untar.m, miscellaneous/unzip.m:
@@ -12029,30 +12029,30 @@ 2006-10-09  Bill Denney  <denney@seas.up
 
 	* miscellaneous/untar.m: Check more rigorously to see if the tar
 	file exists.
 
 2006-10-04  John W. Eaton  <jwe@octave.org>
 
 	* pkg/pkg.m: Use fullfile to concatenate directory and file names.
 
-2006-10-04  Sren Hauberg  <soren@hauberg.org>
+2006-10-04  Sren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m: Update docs.  Handle prefix option.
 	Handle dependencies for load option.
 
 2006-10-04  John W. Eaton  <jwe@octave.org>
 
 	* deprecated/clearplot.m, deprecated/clg.m: New functions.
 
 	* plot/clg.m: Delete.
 	* plot/__init_plot_vars__.m: New function.
 	* plot/__setup_plot__.m: Use __init_plot_vars__.
 
-2006-10-03  Sren Hauberg  <soren@hauberg.org>
+2006-10-03  Sren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m: Avoid calling addpath with no args.
 
 2006-10-03  Bill Denney  <denney@seas.upenn.edu>
 
  	* audio/loadaudio.m, control/base/nyquist.m,
  	control/system/__zp2ssg2__.m, linear-algebra/cross.m,
  	linear-algebra/krylov.m, statistics/base/center.m,
@@ -12098,17 +12098,17 @@ 2006-09-26  David Bateman  <dbateman@fre
 	* mesh.m: ditto.
 	* plot3.m: Error checking, setting of parametric state and
 	formation of matrix to plot moved from old __plt3__.
 
 2006-09-22  Michael Creel  <michael.creel@uab.es>
 
 	* deprecated/chisquare_pdf.m: Typo in documentation.
 
-2006-09-22  Sren Hauberg  <soren@hauberg.org>
+2006-09-22  Sren Hauberg  <soren@hauberg.org>
 
 	* signal/filter2.m: Correct texinfo doc.
 
 2006-09-22  David Bateman  <dbateman@free.fr>
 
 	* miscellaneous/parseparams.m: Correct texinfo doc.
 
 2006-09-15  David Bateman  <dbateman@free.fr>
@@ -12177,17 +12177,17 @@ 2006-08-25  David Bateman  <dbateman@fre
 	(copy_files): Install both bin/ and doc/ directories, adding the
 	bin/ to the EXEC_PATH when the package is loaded.
 
 2006-08-24  John W. Eaton  <jwe@octave.org>
 
 	* image/saveimage.m: Use logical indexing instead of
 	indices computed by calling find on the logical index.
 
-2006-08-24  Sren Hauberg  <soren@hauberg.org>
+2006-08-24  Sren Hauberg  <soren@hauberg.org>
 
 	* miscellaneous/bincoeff.m, specfun/factorial.m:
 	Use logical indexing instead of indices computed by calling find
 	on the logical index.
 
 	* linear-algebra/krylov.m: Delete unused local var nzidx.
 
 2006-08-23  Quentin Spencer  <qspencer@ieee.org>
@@ -12205,17 +12205,17 @@ 2006-08-23  A S Hodel  <hodelas@auburn.e
 
 2006-08-22  David Bateman  <dbateman@free.fr>
 
 	* pkg/pkg.m (extract_pkgadd, create_pkgadd): New functions to
 	Search inst/*.m and src/*.m files in the package for
 	PKG_ADD directives and append user supplied PKG_ADD.
 	(pkg): Call create_pkgadd after copying files.
 
-2006-08-21  Sren Hauberg  <soren@hauberg.org>
+2006-08-21  Sren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m: Handle multiple packages in a single file.
 	Insert directory separator between OCTAVE_HOME and rest of package
 	installation directory.
 
 2006-08-21  John W. Eaton  <jwe@octave.org>
 
 	* general/num2str.m: Early return if arg is empty.
@@ -12224,34 +12224,34 @@ 2006-08-21  John W. Eaton  <jwe@octave.o
 2006-08-21  David Bateman  <dbateman@free.fr>
 
 	* strings/mat2str.m: Compute NC before using.
 
 2006-08-17  John W. Eaton  <jwe@octave.org>
 
 	* audio/wavread.m: Fix calculation of sample count.
 
-2006-08-14  Sren Hauberg  <soren@hauberg.org>
+2006-08-14  Sren Hauberg  <soren@hauberg.org>
 
 	* image/imshow.m: New Matlab-compatible version.
 
 2006-08-15  John W. Eaton  <jwe@octave.org>
 
 	* deprecated/is_global.m: Delete.
 
 2006-08-14  John W. Eaton  <jwe@octave.org>
 
 	* pkg/Makefile.in (script_sub_dir): Change from plot to pkg.
 
 2006-08-14  Dmitri A. Sergatskov  <dasergatskov@gmail.com>
 
 	* sparse/spy.m, control/base/bode.m, control/base/__stepimp__.m,
 	signal/freqz_plot.m: Adapt to new automatic_replot definition.
 
-2006-08-14  Sren Hauberg  <soren@hauberg.org>
+2006-08-14  Sren Hauberg  <soren@hauberg.org>
 
 	* pkg/pkg.m: Don't pass function name to print_usage.
 	Use addpath and rmpath instead of manipulating LOADPATH.
 	Handle changes to system function.
 	(rm_rf): New subfunction.  Use it to avoid confirmation dialog for
 	recursive directory removal.
 
 	* strings/bin2dec.m: Ignore spaces in input for compatibility.
@@ -12372,17 +12372,17 @@ 2006-05-11  John W. Eaton  <jwe@octave.o
 	* configure.in (AC_CONFIG_FILES): Add pkg/Makefile to the list.
 	* Makefile.in (SUBDIRS): Add pkg to the list.
 
 2006-05-10  John W. Eaton  <jwe@octave.org>
 
 	* tar.m, untar.m, unzip.m: Adapt to Octave coding style.
 	* tar.m, untar.m: Only tar; don't compress or uncompress.
 
-2006-05-10  Sren Hauberg  <hauberg@gmail.com>
+2006-05-10  Sren Hauberg  <hauberg@gmail.com>
 
 	* tar.m, untar.m, unzip.m: New files.
 
 2006-05-10  John W. Eaton  <jwe@octave.org>
 
 	* path/addpath.m, path/rmpath.m: Improve compatibility.
 	* path/setpath.m: Delete.
 
@@ -12589,17 +12589,17 @@ 2006-03-15  William Poetra Yoga Hadisoes
 	* strings/strncmpi.m: Import from octave-forge, simplify.
 	* strings/strtrunc.m: New file.
 
 	* strings/lower.m, strings/upper.m: Handle cellstr arguments.
 
 2006-03-15  John W. Eaton  <jwe@octave.org>
 
 	* miscellaneous/doc.m: New file.
-	From Sren Hauberg <soren@hauberg.org>.
+	From Sren Hauberg <soren@hauberg.org>.
 
 2006-03-15  Keith Goodman  <kwgoodman@gmail.com>
 
 	* miscellaneous/mkoctfile.m: New file.
 
 2006-03-15  John W. Eaton  <jwe@octave.org>
 
 	* polynomial/residue.m: Use & instead of && to generate arg for find.
@@ -13377,17 +13377,17 @@ 2005-03-22  John W. Eaton  <jwe@octave.o
 	Avoid looping when checking character classes.
 
 	* optimization: New directory.
 	* Makefile.in (SUBDIRS): Add it to the list.
 	* optimization/Makefile.in: New file.
 	* optimization/glpk.m, optimization/glpkparams.m,
 	optimization/glpktest1, optimization/glpktest2: New files.
 
-2005-03-16  Sren Hauberg  <soren@hauberg.org>
+2005-03-16  Sren Hauberg  <soren@hauberg.org>
 
 	* strings/split.m: Quick return for empty second arg.
 	Improve warning for multi-line strings.
 	Speed up by avoiding sprintf in loop and eval.
 
 2005-03-16  Paul Kienzle  <pkienzle@users.sf.net>
 
 	* polynomial/polyderiv.m : Accept a*b, a/b.  Auto-reduce common terms.
diff --git a/etc/OLD-ChangeLogs/src-ChangeLog b/etc/OLD-ChangeLogs/src-ChangeLog
--- a/etc/OLD-ChangeLogs/src-ChangeLog
+++ b/etc/OLD-ChangeLogs/src-ChangeLog
@@ -3022,17 +3022,17 @@ 2010-07-06  David Bateman  <dbateman@fre
 	of digits in a value.
 	(static void pr_any_float (const float_format *, std::ostream&,
 	double, int)): Print engineering formats.
 	(static void init_format_state (void)): Set default state of print_eng.
 	(static void set_format_style (int, const string_vector&)): Parse
 	the "eng" argument.
 	(Fformat): Document the new engineering format.
 
-2010-07-04  Soren Hauberg  <hauberg@gmail.com>
+2010-07-04  Sren Hauberg  <hauberg@gmail.com>
 
 	* DLD_FUNCTIONS/__magick_read__.cc: restore locale after
 	GraphicsMagick initialisation.
 
 2010-07-02  Jaroslav Hajek  <highegg@gmail.com>
 
 	* toplev.cc (octave_call_stack::do_backtrace): Use static
 	octave_fields struct.
@@ -4221,17 +4221,17 @@ 2010-02-18  Thorsten Meyer  <thorsten.me
 
 	* dirfns.cc (Fglob): Document globbing patterns, add test.
 
 2010-02-18  Jaroslav Hajek  <highegg@gmail.com>
 
 	* load-path.cc (in_path_list): New helper function.
 	(add_to_fcn_map): Use it here.
 
-2010-02-18  Sren Hauberg  <hauberg@gmail.com>
+2010-02-18  Sren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__magick_read__.cc (__magick_finfo__):
 	Handle multiple frames in a single image file.
 
 2010-02-18  John W. Eaton  <jwe@octave.org>
 
 	* oct-map.h (Octave_map::Octave_map): Allow dimension to also be
 	specified in string_vector constructor.
@@ -7559,17 +7559,17 @@ 2009-07-23  Shai Ayal  <shaiay@users.sou
 
 	* DLD-FUNCTIONS/fltk_backend.cc (plot_window::pixel2axes_or_ca):
 	Replace plot_window::pixel2axes and use algorithm from octavede.
 	(plot_window::handle): Zooming now works on the axes below the
 	mouse pointer instead of the current axes. Combine old and new
 	zooming methods.
 	(help_text): Update to reflect new mouse/key bindings.
 
-2009-07-23  Soren Hauberg  <hauberg@gmail.com>
+2009-07-23  Sren Hauberg  <hauberg@gmail.com>
 
 	* graphics.cc (axes::properties::zoom_about_point,
 	axes::properties::translate_view): New functions.
 	(axes::properties::zoom): make zoom_stack usage optional.
 	* DLD-FUNCTIONS/fltk_backend.cc (plot_window::handle): Use new
 	zoom API.
 
 2009-07-23  John W. Eaton  <jwe@octave.org>
@@ -10241,22 +10241,22 @@ 2008-12-25 Ben Abbott  <bpabbott@mac.com
 	* load-path.cc (Fcommandlinepath): New function.
 	* load-path.h (load_path::get_command_line_path,
 	load_path::do_get_command_line_path): New functions.
 
 2009-01-24 Ben Abbott  <bpabbott@mac.com>
 
 	* DLD-FUNCTIONS/eigs.cc: eigs.cc: skip tests if ARPACK is missing.
 
-2009-01-25  Sren Hauberg  <hauberg@gmail.com>
+2009-01-25  Sren Hauberg  <hauberg@gmail.com>
 
 	* help.cc (do_get_help_text, raw_help_from_symbol_table): new output to
 	flag the a function is found but not documented.
 
-2009-01-25  Sren Hauberg  <hauberg@gmail.com>
+2009-01-25  Sren Hauberg  <hauberg@gmail.com>
 
 	* help.cc (raw_help_from_file): No longer search for files called
 	'Contents.m', as this is moved to 'script/help.m'.
 
 
 2009-01-23  John W. Eaton  <jwe@octave.org>
 
 	* toplev.cc (octave_call_stack::do_goto_caller_frame):
@@ -10297,17 +10297,17 @@ 2009-01-22  John W. Eaton  <jwe@octave.o
 
 	* help.cc (do_which (std::ostream&, const std::string&), Fwhich):
 	Delete.
 	(do_which (const std::string&, std::string&), F__which__):
 	New functions.
 	* do_which (const std::string&):
 	Call do_which (const std::string&, std::string&) to do the work.
 
-2009-01-22  Sren Hauberg  <hauberg@gmail.com>
+2009-01-22  Sren Hauberg  <hauberg@gmail.com>
 
 	* defun-int.h (print_usage): No longer mark as deprecated.
 	* defun.cc (print_usage): Simply call feval to execute print_usage.m.
 	* help.cc (additional_help_message, display_names_from_help_list,
 	display_symtab_names, simple_help, try_info, help_from_info,
 	display_help_text, display_usage_text, raw_help_from_list,
 	help_from_list, help_from_symbol_table, help_from_file,
 	builtin_help, Fhelp, display_file, do_type, Ftype,
@@ -10447,22 +10447,22 @@ 2009-01-14  Jaroslav Hajek  <highegg@gma
 	* oct-obj.cc (octave_value_list::normalize_null_values):
 	Rename to make_storable_values, use make_storable_value.
 	* oct-obj.h: Ditto.
 	* ov-builtin.cc: non_null_value -> storable_value.
 	* ov-cell.cc: Ditto.
 	* ov-struct.cc: Ditto.
 	* pt-decl.h: Ditto.
 
-2009-01-15  Sren Hauberg  <hauberg@gmail.com>
+2009-01-15  Sren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__magick_read__.cc (encode_uint_image):
 	Initialize bitdepth.
 
-2009-01-14  Sren Hauberg  <hauberg@gmail.com>
+2009-01-14  Sren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/betainc.cc, DLD-FUNCTIONS/chol.cc,
 	DLD-FUNCTIONS/daspk.cc, DLD-FUNCTIONS/dasrt.cc,
 	DLD-FUNCTIONS/dassl.cc, DLD-FUNCTIONS/filter.cc,
 	DLD-FUNCTIONS/gammainc.cc, DLD-FUNCTIONS/gcd.cc,
 	DLD-FUNCTIONS/givens.cc, DLD-FUNCTIONS/hess.cc,
 	DLD-FUNCTIONS/lsode.cc, DLD-FUNCTIONS/qr.cc, DLD-FUNCTIONS/qz.cc,
 	DLD-FUNCTIONS/schur.cc, DLD-FUNCTIONS/svd.cc,
@@ -11424,17 +11424,17 @@ 2008-09-25  David Bateman  <dbateman@fre
 	concatenate is a class object, dispatch to the appropriate
 	vertcat/horzcat function.
 
 2008-09-25  John W. Eaton  <jwe@octave.org>
 
 	* symtab.cc (symbol_table::do_find): Don't set evaluated_args and
 	args_evaluated here, prior to call to symbol_table::fcn_info::find.
 
-2008-09-24  Sren Hauberg  <hauberg@gmail.com>
+2008-09-24  Sren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__magick_read__.cc (magick_to_octave_value): New
 	template function with specializations for various
 	GraphicsMagick++ types.
 	(F__magick_finfo__): New function.
 
 2008-09-24  John W. Eaton  <jwe@octave.org>
 
@@ -11868,17 +11868,17 @@ 2008-08-07  John W. Eaton  <jwe@octave.o
 	* ov.cc (octave_value::idx_type_value): Move definition here.
 	* ov.h: From here.
 
 	* DLD-FUNCTIONS/fsolve.cc (override_options): Don't fail if
 	options_map does not contain an expected keyword.
 	Fix typo in warning identifier.
 	(make_unimplemented_options): Use CamelCase names here.
 
-2008-08-06  Sren Hauberg  <hauberg@gmail.com>
+2008-08-06  Sren Hauberg  <hauberg@gmail.com>
 
 	* error.cc (Ferror): Update format of error messages in exmple.
 	* parse.y: (Feval): Likewise.
 
 2008-08-06  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/fsolve.cc (hybrd_info_to_fsolve_info):
 	Update INFO values to be compatible with Matlab's current fsolve.
@@ -14460,17 +14460,17 @@ 2008-03-28  David Bateman  <dbateman@fre
 2008-03-27  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/max.cc: Rename from minmax.cc.
 	* Makefile.in (DLD_XSRC): Rename minmax.cc to max.cc.
 
 	* DLD-FUNCTIONS/__convn__.cc (convn): Use traits class and
 	typedefs to allow all types to be deduced from argument types.
 
-2008-03-27  Sren Hauberg  <hauberg@gmail.com>
+2008-03-27  Sren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__convn__.cc (Fconvn): Allow convolving real data with
 	complex data.
 
 2008-03-26  John W. Eaton  <jwe@octave.org>
 
 	* ov-range.h (octave_range::subsref (const std::string&,
 	const std::list<octave_value_list>&, int)):
@@ -14510,27 +14510,27 @@ 2008-03-26  John W. Eaton  <jwe@octave.o
 	is_constant method to decide which type of subsref method to call.
 	(octave_value::assign): Always call simple subref method here.
 
 	* DLD-FUNCTIONS/chol.cc, DLD-FUNCTIONS/det.cc,
 	DLD-FUNCTIONS/getpwent.cc, DLD-FUNCTIONS/inv.cc,
 	DLD-FUNCTIONS/qr.cc, DLD-FUNCTIONS/symrcm.cc, file-io.cc):
 	Texinfo fixes.
 
-2008-03-26  Sren Hauberg  <hauberg@gmail.com>
+2008-03-26  Sren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__convn__.cc (Fconvn):
 	Call complex_array_value to extract N-d array.
 
 2008-03-26  John W. Eaton  <jwe@octave.org>
 
 	* ov-base-sparse.cc (octave_base_sparse<T>::print_raw):
 	Also display percentage of elements that are nonzero.
 
-2008-03-25  Sren Hauberg  <hauberg@gmail.com>
+2008-03-25  Sren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__convn__.cc: New file.
 	* Makefile.in: Add __convn__.cc
 
 2008-03-25  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/hex2num.cc: New function
 	* Makefile.in (DLD_XSRC): Add hex2num.cc.
@@ -16800,17 +16800,17 @@ 2007-10-19  Olli Saarela  <Olli.Saarela@
 2007-10-17  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/spchol.cc (Fsymbfact): Delete special code for METIS.
 
 2007-10-17  Gabriele Pannocchia  <g.pannocchia@ing.unipi.it>
 
 	* DLD-FUNCTIONS/__qp__.cc (qp): Fix check for Wact(j).
 
-2007-10-15  Sren Hauberg  <hauberg@gmail.com>
+2007-10-15  Sren Hauberg  <hauberg@gmail.com>
 
 	* error.cc (Ferror): Make text fit on pages when using smallbook.
 	* load-save.cc (Fsave_header_format_string): Ditto.
 	* ov-struct.cc (Fcell2struct): Ditto.
 	* DLD-FUNCTIONS/besselj.cc (Fairy): Ditto.
 	* DLD-FUNCTIONS/urlwrite.cc (Furlwrite, Furlread): Ditto.
 
 2007-10-15  David Bateman  <dbateman@free.fr>
@@ -17528,17 +17528,17 @@ 2007-06-25  Olaf Till  <i7tiol@t-online.
 	octave_steam_list::do_open_file_numbers,
 	octave_steam_list::do_get_file_number):
  	Use new octave_stream_list::list type.
 	(octave_stream_list::do_insert): Insert octave_stream with key
 	corresponding to file-descriptor.
 	(octave_stream_list::do_insert, octave_steam_list::insert):
 	Remove const qualifier of argument.
 
-2007-06-18  Sren Hauberg  <hauberg@gmail.com>
+2007-06-18  Sren Hauberg  <hauberg@gmail.com>
 
 	* DLD-FUNCTIONS/__lin_interpn__.cc: Replace octave_NaN with octave_NA.
 
 2007-06-15  Shai Ayal  <shaiay@users.sourceforge.net>
 
 	* graphics.h (OCTAVE_GRAPHICS_PROPERTY_INTERNAL,
 	OCTAVE_GRAPHICS_PROPERTY, OCTAVE_GRAPHICS_MUTABLE_PROPERTY):
 	New macros. Use them to declare individual properties and define
@@ -17743,17 +17743,17 @@ 2007-05-22  John W. Eaton  <jwe@octave.o
 	(OCTAVE_RELEASE_DATE): Now 2007-05-22.
 
 2007-05-21  David Bateman  <dbateman@free.fr>
 
 	* debug.cc (Fdbstop): handle integer, vector and multiple line
 	arguments.
 	(Fdbclar): ditto. Eliminate extraneous debugging messages.
 
-2007-05-21  Sren Hauberg  <hauberg@gmail.com>
+2007-05-21  Sren Hauberg  <hauberg@gmail.com>
 
 	* load-path.cc (Fpath, Frehash): Replace "LOADPATH" with "load
 	path" in doc strings.
 
 	* parse.y (Feval): Add example.
 
 2007-05-21  David Bateman  <dbateman@free.fr>
 
@@ -17764,26 +17764,26 @@ 2007-05-21  David Bateman  <dbateman@fre
 2007-05-21  John W. Eaton  <jwe@octave.org>
 
 	* oct-map.h (Octave_map::numel): Return number of array elements,
 	not number of map elements.
 	(Octave_map::nfields): Rename from length.
 	(Octave_map::empty): Delete.
 	Change all uses of empty to check nfields () == 0 instead.
 
-2007-05-21  Sren Hauberg  <soren@hauberg.org>
+2007-05-21  Sren Hauberg  <soren@hauberg.org>
 
 	* help.cc (Fautoload): Doc fix.
 	* variables.cc (Fiscommand): Doc fix.
 
 2007-05-19  David Bateman  <dbatemna@free.fr>
 
 	* ov-fcn-inline.cc (Fvectorize): Doc fix.
 
-2007-05-16  Sren Hauberg  <soren@hauberg.org>
+2007-05-16  Sren Hauberg  <soren@hauberg.org>
 
 	* ov.cc (Fsubsref, Fsubsasgn): Doc fix.
 
 2007-05-16  John W. Eaton  <jwe@octave.org>
 
 	* load-path.h (load_path::sys_path): New static data member.
 	(load_path::system_path): New static function.
 	(load_path::do_system_path): New function.
@@ -17841,24 +17841,24 @@ 2007-05-16  David Bateman  <dbateman@fre
 2007-05-14  Bob Weigel  <rweigel@gmu.edu>
 
 	* DLD-FUNCTIONS/svd.cc: Doc fix.
 
 2007-05-14  Thomas Weber  <thomas.weber.mail@gmail.com>
 
 	* DLD-FUNCTIONS/fft.cc (do_fft): Handle empty matrices.  New tests.
 
-2007-05-14  Sren Hauberg  <soren@hauberg.org>
+2007-05-14  Sren Hauberg  <soren@hauberg.org>
 
 	* toplev.cc (Fatexit): Simplify example in doc string.
 	* help.cc (Flookfor): Doc fix.
 	* DLD-FUNCTIONS/cellfun.cc (Fcellfun):
 	Reformat to avoid long lines in doc string example.
 
-2007-05-13  Sren Hauberg  <soren@hauberg.org>
+2007-05-13  Sren Hauberg  <soren@hauberg.org>
 
 	* toplev.cc (Fquit): Doc fix.
 	* help.cc (Fhelp): Doc fix.
 	* oct-hist.cc (Fsaving_history): Doc fix.
 
 2007-05-11  John W. Eaton  <jwe@octave.org>
 
 	* variables.cc (symbol_out_of_date):
@@ -17929,17 +17929,17 @@ 2007-04-27  David Bateman  <dbateman@fre
 	and mexSet.
 	* Makefile.in (INCLUDES): Add graphics.h
 
 2007-04-26  John W. Eaton  <jwe@octave.org>
 
 	* ov-usr-fcn.cc (octave_user_function::do_multi_index_op):
 	Only deal with varargout if ret_list->takes_varargs () is true.
 
-2007-04-26  Sren Hauberg  <soren@hauberg.org>
+2007-04-26  Sren Hauberg  <soren@hauberg.org>
 
 	* DLD-FUNCTIONS/urlwrite.cc: Doc fix.
 
 2007-04-26  David Bateman  <dbateman@free.fr>
 
 	* pt-loop.cc (tree_simple_for_command::eval (void)): Correct
 	reshaping of dim_vector in for loop for multi-dimensional array.
 
@@ -17958,17 +17958,17 @@ 2007-04-23  Shai Ayal  <shaiay@users.sou
 	New arg A for alpha channel.  Set rgba instead of red, green, blue.
 	(color_property::color_property (char)): New constructor.
 	(color_propery::rgba): New data member.
 	(color_property::red, color_property::green, color_property::blue):
 	Delete.
 	(color_property::validate): Use rgba.
 	(color_property::c2rgba): New function.
 
-2007-04-23  Sren Hauberg  <soren@hauberg.org>
+2007-04-23  Sren Hauberg  <soren@hauberg.org>
 
 	* data.cc (Fsize_equal): Allow more than two arguments.
 
 2007-04-20  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/__gnuplot_raw__.l (deftypefn):
 	(Vautomatic_replot): Delete static variable.
 	(Fautomatic_replot): Delete function.
@@ -19361,17 +19361,17 @@ 2006-09-15  John W. Eaton  <jwe@octave.o
 	* OPERATORS/op-double-conv.cc: Declare and install sq_string
 	conversions too.
 
 	* ov-base-int.cc (octave_base_int_scalar<T>::convert_to_str_internal,
 	octave_base_int_matrix<T>::convert_to_str_internal):
 	New functions.
 	* ov-base-int.h: Provide decls.
 
-2006-09-15  Sren Hauberg  <soren@hauberg.org>.
+2006-09-15  Sren Hauberg  <soren@hauberg.org>.
 
 	* data.cc (Fsize): If nargout > ndims, fill with 1.
 
 2006-09-15  John W. Eaton  <jwe@octave.org>
 
 	* octave.cc: Fix xerbla decl.
 
 2006-09-13  John W. Eaton  <jwe@octave.org>
@@ -21467,17 +21467,17 @@ 2006-03-15  William Poetra Yoga Hadisoes
 
 2006-03-15  John W. Eaton  <jwe@octave.org>
 
 	* pager.cc (Fterminal_size): New function.
 
 	* help.cc (help_from_info): Simplify.
 	(try_info): Use feval to call doc instead of executing info program.
 	(additional_help_message): Point users to doc instead of help -i.
-	From Sren Hauberg <soren@hauberg.org>.
+	From Sren Hauberg <soren@hauberg.org>.
 
 	* toplev.cc (Fsystem): Return output if nargout > 1, not 0.
 
 2006-03-14  Keith Goodman  <kwgoodman@gmail.com>
 
 	* help.cc (Fhelp, Fwhich, Flookfor): Doc string fix.
 
 2006-03-14  John W. Eaton  <jwe@octave.org>
@@ -22314,17 +22314,17 @@ 2005-08-25  David Bateman  <dbateman@fre
 
 	* OPERATORS/op-sm-m.cc, OPERATORS/op-sm-cm.cc, OPERATORS/op-scm-m.cc,
 	OPERATORS/op-scm-cm.cc, OPERATORS/op-m-sm.cc, OPERATORS/op-m-scm.cc,
 	OPERATORS/op-cm-sm.cc, OPERATORS/op-cm-scm.cc: Use mixed matrix/sparse
 	multiply operator rather than casting sparse to matrix.
 
 2005-07-18  John W. Eaton  <jwe@octave.org>
 
-	* strfns.cc (Fstrcmp): New function from Sren Hauberg
+	* strfns.cc (Fstrcmp): New function from Sren Hauberg
 	<soren@hauberg.org> and Tom Holroyd <tomh@kurage.nimh.nih.gov>.
 	Adapt to Octave conventions.
 
 2005-07-11  David Bateman  <dbateman@free.fr>
 
 	* ov-fc-inline.cc (Fvectorize): Allow string arguments
 
 2005-07-08  John W. Eaton  <jwe@octave.org>
diff --git a/etc/OLD-ChangeLogs/test-ChangeLog b/etc/OLD-ChangeLogs/test-ChangeLog
--- a/etc/OLD-ChangeLogs/test-ChangeLog
+++ b/etc/OLD-ChangeLogs/test-ChangeLog
@@ -280,17 +280,17 @@ 2009-02-09  John W. Eaton  <jwe@octave.o
 2009-01-29  John W. Eaton  <jwe@octave.org>
 
 	* test_system.m: Use isfield instead of struct_contains.
 
 2009-01-25  Thorsten Meyer  <thorsten@hexe>
 
 	* test_struct.m: Add struct array tests.
 
-2009-01-23  Sren Hauberg  <hauberg@gmail.com>
+2009-01-23  Sren Hauberg  <hauberg@gmail.com>
 
 	* test_prefer.m: Update to match new API of the 'type' function.
 
 2008-12-24  John W. Eaton  <jwe@octave.org>
 
 	* fntests.m (hastests): Use fread instead of fscanf to preserve
 	whitespace.
 
diff --git a/examples/@FIRfilter/display.m b/examples/@FIRfilter/display.m
--- a/examples/@FIRfilter/display.m
+++ b/examples/@FIRfilter/display.m
@@ -1,6 +1,6 @@
 function display (f)
 
-  display(f.polynomial);
+  display (f.polynomial);
 
 endfunction
 
diff --git a/examples/@FIRfilter/subsref.m b/examples/@FIRfilter/subsref.m
--- a/examples/@FIRfilter/subsref.m
+++ b/examples/@FIRfilter/subsref.m
@@ -1,13 +1,13 @@
 function out = subsref (f, x)
   switch x.type
     case "()"
       n = f.polynomial;
-      out = filter(n.poly, 1, x.subs{1});
+      out = filter (n.poly, 1, x.subs{1});
     case "."
       fld = x.subs;
       if (strcmp (fld, "polynomial"))
         out = f.polynomial;
       else
         error ("@FIRfilter/subsref: invalid property \"%s\"", fld);
       endif
     otherwise
diff --git a/examples/@polynomial/display.m b/examples/@polynomial/display.m
--- a/examples/@polynomial/display.m
+++ b/examples/@polynomial/display.m
@@ -1,12 +1,12 @@
 function display (p)
   a = p.poly;
   first = true;
-  fprintf("%s =", inputname(1));
+  fprintf ("%s =", inputname (1));
   for i = 1 : length (a);
     if (a(i) != 0)
       if (first)
         first = false;
       elseif (a(i) > 0)
         fprintf (" +");
       endif
       if (a(i) < 0)
@@ -21,12 +21,12 @@ function display (p)
         fprintf (" X");
       endif
       if (i > 2)
         fprintf (" ^ %d", i - 1);
       endif
     endif
   endfor
   if (first)
-    fprintf(" 0");
+    fprintf (" 0");
   endif
-  fprintf("\n");
+  fprintf ("\n");
 endfunction
diff --git a/examples/@polynomial/mtimes.m b/examples/@polynomial/mtimes.m
--- a/examples/@polynomial/mtimes.m
+++ b/examples/@polynomial/mtimes.m
@@ -1,3 +1,3 @@
 function y = mtimes (a, b)
-  y = polynomial (conv (double(a),double(b)));
-endfunction
\ No newline at end of file
+  y = polynomial (conv (double (a), double (b)));
+endfunction
diff --git a/examples/@polynomial/plot.m b/examples/@polynomial/plot.m
--- a/examples/@polynomial/plot.m
+++ b/examples/@polynomial/plot.m
@@ -1,10 +1,10 @@
-function h = plot(p, varargin)
+function h = plot (p, varargin)
   n = 128;
   rmax = max (abs (roots (p.poly)));
   x = [0 : (n - 1)] / (n - 1) * 2.2 * rmax - 1.1 * rmax;
   if (nargout > 0)
-    h = plot(x, p(x), varargin{:});
+    h = plot (x, p(x), varargin{:});
   else
-    plot(x, p(x), varargin{:});
+    plot (x, p(x), varargin{:});
   endif
-endfunction
\ No newline at end of file
+endfunction
diff --git a/examples/@polynomial/polyval.m b/examples/@polynomial/polyval.m
--- a/examples/@polynomial/polyval.m
+++ b/examples/@polynomial/polyval.m
@@ -1,7 +1,7 @@
 function [y, dy] = polyval (p, varargin)
   if (nargout == 2)
-    [y, dy] = polyval (fliplr(p.poly), varargin{:});
+    [y, dy] = polyval (fliplr (p.poly), varargin{:});
   else
-    y = polyval (fliplr(p.poly), varargin{:});
+    y = polyval (fliplr (p.poly), varargin{:});
   endif
 endfunction
diff --git a/examples/embedded.cc b/examples/embedded.cc
--- a/examples/embedded.cc
+++ b/examples/embedded.cc
@@ -5,40 +5,31 @@
 
 int
 main (void)
 {
   string_vector argv (2);
   argv(0) = "embedded";
   argv(1) = "-q";
 
-  octave_main (2, argv.c_str_vec(), 1);
+  octave_main (2, argv.c_str_vec (), 1);
 
   octave_idx_type n = 2;
-  Matrix a_matrix = Matrix (1, 2);
+  octave_value_list in;
 
-  std::cout << "GCD of [";
-  for (octave_idx_type i = 0; i < n; i++)
-    {
-      a_matrix (i) = 5 * (i + 1);
-      if (i != 0)
-        std::cout << ", " << 5 * (i + 2);
-      else
-        std::cout << 5 * (i + 2);
-    }
-  std::cout << "] is ";
-
-  octave_value_list in = octave_value (a_matrix);
+  for (octave_idx_type i = 0; i < n; i++)  
+    in(i) = octave_value (5 * (i + 1));
+  
   octave_value_list out = feval ("gcd", in, 1);
 
+  
   if (!error_state && out.length () > 0)
-    {
-      a_matrix = out(0).matrix_value ();
-      if (a_matrix.numel () == 1)
-        std::cout << a_matrix(0) << "\n";
-      else
-        std::cout << "invalid\n";
-    }
+    std::cout << "GCD of [" 
+              << in(0).int_value () 
+              << ", " 
+              << in(1).int_value ()
+              << "] is " << out(0).int_value () 
+              << std::endl;
   else
     std::cout << "invalid\n";
 
   return 0;
 }
diff --git a/examples/fortdemo.cc b/examples/fortdemo.cc
--- a/examples/fortdemo.cc
+++ b/examples/fortdemo.cc
@@ -7,17 +7,17 @@ extern "C"
   F77_FUNC (fortsub, FORTSUB)
         (const int&, double*, F77_CHAR_ARG_DECL
          F77_CHAR_ARG_LEN_DECL);
 }
 
 DEFUN_DLD (fortdemo , args , , "Fortran Demo.")
 {
   octave_value_list retval;
-  int nargin = args.length();
+  int nargin = args.length ();
   if (nargin != 1)
     print_usage ();
   else
     {
       NDArray a = args(0).array_value ();
       if (! error_state)
         {
           double *av = a.fortran_vec ();
diff --git a/examples/funcdemo.cc b/examples/funcdemo.cc
--- a/examples/funcdemo.cc
+++ b/examples/funcdemo.cc
@@ -1,14 +1,14 @@
 #include <octave/oct.h>
 #include <octave/parse.h>
 
 DEFUN_DLD (funcdemo, args, nargout, "Function Demo")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin < 2)
     print_usage ();
   else
     {
       octave_value_list newargs;
       for (octave_idx_type i = nargin - 1; i > 0; i--)
diff --git a/examples/hello.cc b/examples/hello.cc
--- a/examples/hello.cc
+++ b/examples/hello.cc
@@ -84,15 +84,15 @@ Returns all arguments in reverse order."
 
   // The octave_value_list class is a zero-based array of octave_value
   // objects.  The declaration for the octave_value class is in the
   // file ov.h.  The print() method will send its output to
   // octave_stdout, so it will also end up going through the pager.
 
   for (int i = 0; i < nargin; i++)
     {
-      octave_value tmp = args (i);
+      octave_value tmp = args(i);
       tmp.print (octave_stdout);
-      retval (nargin-i-1) = tmp;
+      retval(nargin-i-1) = tmp;
     }
 
   return retval;
 }
diff --git a/examples/myprop.c b/examples/myprop.c
--- a/examples/myprop.c
+++ b/examples/myprop.c
@@ -3,17 +3,17 @@
 void
 mexFunction (int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])
 {
   double handle;
   char property[256];
 
   if (nrhs < 2 || nrhs > 3)
     mexErrMsgTxt ("incorrect number of arguments");
-  if (!mxIsDouble(prhs[0]))
+  if (!mxIsDouble (prhs[0]))
     mexErrMsgTxt ("handle expected to be a double scalar");
   if (!mxIsChar (prhs[1]))
     mexErrMsgTxt ("expected property to be a string");
   
   handle = mxGetScalar (prhs[0]);
   mxGetString (prhs[1], property, 256);
   plhs[0] = mxDuplicateArray (mexGet (handle, property));
   
diff --git a/examples/paramdemo.cc b/examples/paramdemo.cc
--- a/examples/paramdemo.cc
+++ b/examples/paramdemo.cc
@@ -2,33 +2,33 @@
 
 DEFUN_DLD (paramdemo, args, nargout,
            "Parameter Check Demo.")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin != 1)
-    print_usage();
+    print_usage ();
   else if (nargout != 0)
     error ("paramdemo: function has no output arguments");
   else
     {
-      NDArray m = args(0).array_value();
+      NDArray m = args(0).array_value ();
       double min_val = -10.0;
       double max_val = 10.0;
       octave_stdout << "Properties of input array:\n";
       if (m.any_element_is_negative ())
         octave_stdout << "  includes negative values\n";
-      if (m.any_element_is_inf_or_nan())
+      if (m.any_element_is_inf_or_nan ())
         octave_stdout << "  includes Inf or NaN values\n";
-      if (m.any_element_not_one_or_zero())
+      if (m.any_element_not_one_or_zero ())
         octave_stdout <<
           "  includes other values than 1 and 0\n";
-      if (m.all_elements_are_int_or_inf_or_nan())
+      if (m.all_elements_are_int_or_inf_or_nan ())
         octave_stdout <<
           "  includes only int, Inf or NaN values\n";
       if (m.all_integers (min_val, max_val))
         octave_stdout <<
           "  includes only integers in [-10,10]\n";
     }
   return retval;
 }
diff --git a/examples/stringdemo.cc b/examples/stringdemo.cc
--- a/examples/stringdemo.cc
+++ b/examples/stringdemo.cc
@@ -1,33 +1,33 @@
 #include <octave/oct.h>
 
 DEFUN_DLD (stringdemo, args, , "String Demo")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 1)
     print_usage ();
   else
     {
       charMatrix ch = args(0).char_matrix_value ();
 
       if (! error_state)
         {
           if (args(0).is_sq_string ())
             retval(1) = octave_value (ch, true);
           else
             retval(1) = octave_value (ch, true, '\'');
 
-          octave_idx_type nr = ch.rows();
+          octave_idx_type nr = ch.rows ();
           for (octave_idx_type i = 0; i < nr / 2; i++)
             {
               std::string tmp = ch.row_as_string (i);
-              ch.insert (ch.row_as_string(nr-i-1).c_str(),
+              ch.insert (ch.row_as_string (nr-i-1).c_str (),
                          i, 0);
-              ch.insert (tmp.c_str(), nr-i-1, 0);
+              ch.insert (tmp.c_str (), nr-i-1, 0);
             }
           retval(0) = octave_value (ch, true);
         }
     }
   return retval;
 }
diff --git a/examples/unwinddemo.cc b/examples/unwinddemo.cc
--- a/examples/unwinddemo.cc
+++ b/examples/unwinddemo.cc
@@ -4,28 +4,28 @@
 void
 err_hand (const char *fmt, ...)
 {
   // Do nothing!!
 }
 
 DEFUN_DLD (unwinddemo, args, nargout, "Unwind Demo")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value retval;
   if (nargin < 2)
     print_usage ();
   else
     {
       NDArray a = args(0).array_value ();
       NDArray b = args(1).array_value ();
 
       if (! error_state)
         {
           unwind_protect::begin_frame ("Funwinddemo");
           unwind_protect_ptr (current_liboctave_warning_handler);
-          set_liboctave_warning_handler(err_hand);
+          set_liboctave_warning_handler (err_hand);
           retval = octave_value (quotient (a, b));
           unwind_protect::run_frame ("Funwinddemo");
         }
     }
   return retval;
 }
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -231,28 +231,28 @@ compute_index (const Array<octave_idx_ty
 }
 
 Array<octave_idx_type>
 conv_to_int_array (const Array<idx_vector>& a)
 {
   Array<octave_idx_type> retval (a.dims ());
 
   for (octave_idx_type i = 0; i < a.length (); i++)
-    retval (i) = a(i).elem (0);
+    retval(i) = a(i).elem (0);
 
   return retval;
 }
 
 Array<idx_vector>
 conv_to_array (const idx_vector *tmp, const octave_idx_type len)
 {
   Array<idx_vector> retval (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
-      retval (i) = tmp[i];
+      retval(i) = tmp[i];
 
   return retval;
 }
 
 dim_vector
 freeze (Array<idx_vector>& ra_idx, const dim_vector& dimensions, int resize_ok)
 {
   dim_vector retval;
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -2683,17 +2683,17 @@ bool Array<T>::optimize_dimensions (cons
   return retval;
 }
 
 template <class T>
 void Array<T>::instantiation_guard ()
 {
   // This guards against accidental implicit instantiations.
   // Array<T> instances should always be explicit and use INSTANTIATE_ARRAY.
-  T::__xXxXx__();
+  T::__xXxXx__ ();
 }
 
 #define INSTANTIATE_ARRAY(T, API) \
   template <> void Array<T>::instantiation_guard () { } \
   template class API Array<T>
 
 // FIXME: is this used?
 
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -322,23 +322,23 @@ public:
   octave_idx_type compute_index_unchecked (const Array<octave_idx_type>& ra_idx) const
     { return dimensions.compute_index (ra_idx.data (), ra_idx.length ()); }
 
   // No checking, even for multiple references, ever.
 
   T& xelem (octave_idx_type n) { return slice_data [n]; }
   crefT xelem (octave_idx_type n) const { return slice_data [n]; }
 
-  T& xelem (octave_idx_type i, octave_idx_type j) { return xelem (dim1()*j+i); }
-  crefT xelem (octave_idx_type i, octave_idx_type j) const { return xelem (dim1()*j+i); }
+  T& xelem (octave_idx_type i, octave_idx_type j) { return xelem (dim1 ()*j+i); }
+  crefT xelem (octave_idx_type i, octave_idx_type j) const { return xelem (dim1 ()*j+i); }
 
   T& xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
-    { return xelem (i, dim2()*k+j); }
+    { return xelem (i, dim2 ()*k+j); }
   crefT xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
-    { return xelem (i, dim2()*k+j); }
+    { return xelem (i, dim2 ()*k+j); }
 
   T& xelem (const Array<octave_idx_type>& ra_idx)
     { return xelem (compute_index_unchecked (ra_idx)); }
 
   crefT xelem (const Array<octave_idx_type>& ra_idx) const
     { return xelem (compute_index_unchecked (ra_idx)); }
 
   // FIXME -- would be nice to fix this so that we don't
@@ -351,19 +351,19 @@ public:
   T& checkelem (const Array<octave_idx_type>& ra_idx);
 
   T& elem (octave_idx_type n)
     {
       make_unique ();
       return xelem (n);
     }
 
-  T& elem (octave_idx_type i, octave_idx_type j) { return elem (dim1()*j+i); }
+  T& elem (octave_idx_type i, octave_idx_type j) { return elem (dim1 ()*j+i); }
 
-  T& elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return elem (i, dim2()*k+j); }
+  T& elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return elem (i, dim2 ()*k+j); }
 
   T& elem (const Array<octave_idx_type>& ra_idx)
     { return Array<T>::elem (compute_index_unchecked (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
   T& operator () (octave_idx_type n) { return checkelem (n); }
   T& operator () (octave_idx_type i, octave_idx_type j) { return checkelem (i, j); }
   T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return checkelem (i, j, k); }
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -510,17 +510,17 @@ operator << (std::ostream& os, const Com
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexColumnVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -85,17 +85,17 @@ public:
   ComplexDiagMatrix& fill (const RowVector& a);
   ComplexDiagMatrix& fill (const ComplexRowVector& a);
   ComplexDiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const ComplexColumnVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const RowVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const ComplexRowVector& a, octave_idx_type beg);
 
   ComplexDiagMatrix hermitian (void) const { return MDiagArray2<Complex>::hermitian (std::conj); }
-  ComplexDiagMatrix transpose (void) const { return MDiagArray2<Complex>::transpose(); }
+  ComplexDiagMatrix transpose (void) const { return MDiagArray2<Complex>::transpose (); }
   DiagMatrix abs (void) const;
 
   friend OCTAVE_API ComplexDiagMatrix conj (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1084,17 +1084,17 @@ ComplexMatrix::finverse (MatrixType &mat
       z.resize (dim_vector (lwork, 1));
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
-        anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm  = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1122,17 +1122,17 @@ ComplexMatrix::finverse (MatrixType &mat
           F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, zgetri_info));
 
           if (zgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
-        mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                         double& rcon, int force, int calc_cond) const
@@ -1148,17 +1148,17 @@ ComplexMatrix::inverse (MatrixType &matt
   else
     {
       if (mattype.is_hermitian ())
         {
           ComplexCHOL chol (*this, info, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
-                rcon = chol.rcond();
+                rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
@@ -1788,18 +1788,18 @@ ComplexMatrix::rcond (MatrixType &mattyp
           double anorm = -1.0;
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+              anorm = atmp.abs ().sum ().
+                row(static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1828,18 +1828,18 @@ ComplexMatrix::rcond (MatrixType &mattyp
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
-                anorm = atmp.abs().sum().
-                  row(static_cast<octave_idx_type>(0)).max();
+                anorm = atmp.abs ().sum ().
+                  row(static_cast<octave_idx_type>(0)).max ();
 
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2095,17 +2095,17 @@ ComplexMatrix::fsolve (MatrixType &matty
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -2151,17 +2151,17 @@ ComplexMatrix::fsolve (MatrixType &matty
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (zpotrs, ZPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows(), info
+                                             result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -2179,17 +2179,17 @@ ComplexMatrix::fsolve (MatrixType &matty
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2237,17 +2237,17 @@ ComplexMatrix::fsolve (MatrixType &matty
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows(), info
+                                             pipvt, result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
     }
 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -114,45 +114,45 @@ ComplexNDArray::ifourier (int dim) const
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
@@ -240,17 +240,17 @@ ComplexNDArray::fourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+            retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
@@ -287,17 +287,17 @@ ComplexNDArray::ifourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+            retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<double> (npts);
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -328,35 +328,35 @@ ComplexNDArray::fourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
@@ -376,22 +376,22 @@ ComplexNDArray::ifourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<double> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -424,22 +424,22 @@ ComplexNDArray::fourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -471,22 +471,22 @@ ComplexNDArray::ifourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<double> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -406,17 +406,17 @@ operator << (std::ostream& os, const Com
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexRowVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       Complex tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -738,22 +738,22 @@ SparseComplexMatrix::dinverse (MatrixTyp
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           if (typ == MatrixType::Permuted_Diagonal)
-            retval = transpose();
+            retval = transpose ();
           else
             retval = *this;
 
           // Force make_unique to be called
-          Complex *v = retval.data();
+          Complex *v = retval.data ();
 
           if (calccond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   double tmp = std::abs(v[i]);
                   if (tmp > dmax)
@@ -924,17 +924,17 @@ SparseComplexMatrix::tinverse (MatrixTyp
               octave_idx_type nz = nnz ();
               octave_idx_type cx = 0;
               octave_idx_type nz2 = nz;
               retval = SparseComplexMatrix (nr, nc, nz2);
 
               OCTAVE_LOCAL_BUFFER (Complex, work, nr);
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
-              octave_idx_type *perm = mattyp.triangular_perm();
+              octave_idx_type *perm = mattyp.triangular_perm ();
               if (typ == MatrixType::Permuted_Upper)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     rperm[perm[i]] = i;
                 }
               else
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
@@ -1044,77 +1044,77 @@ SparseComplexMatrix::tinverse (MatrixTyp
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
  inverse_singular:
-  return SparseComplexMatrix();
+  return SparseComplexMatrix ();
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info,
                               double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     ret = dinverse (mattype, info, rcond, true, calc_cond);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    ret = tinverse (mattype, info, rcond, true, calc_cond).transpose();
+    ret = tinverse (mattype, info, rcond, true, calc_cond).transpose ();
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     {
-      MatrixType newtype = mattype.transpose();
-      ret = transpose().tinverse (newtype, info, rcond, true, calc_cond);
+      MatrixType newtype = mattype.transpose ();
+      ret = transpose ().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
-      if (mattype.is_hermitian())
+      if (mattype.is_hermitian ())
         {
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexCHOL fact (*this, info, false);
-          rcond = fact.rcond();
+          rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
-              SparseMatrix Q = fact.Q();
-              SparseComplexMatrix InvL = fact.L().transpose().
+              SparseMatrix Q = fact.Q ();
+              SparseComplexMatrix InvL = fact.L ().transpose ().
                 tinverse(tmp_typ, info, rcond2, true, false);
-              ret = Q * InvL.hermitian() * InvL * Q.transpose();
+              ret = Q * InvL.hermitian () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
         }
 
-      if (!mattype.is_hermitian())
+      if (!mattype.is_hermitian ())
         {
-          octave_idx_type n = rows();
+          octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexLU fact (*this, Qinit, Matrix (), false, false);
-          rcond = fact.rcond();
+          rcond = fact.rcond ();
           double rcond2;
-          SparseComplexMatrix InvL = fact.L().transpose().
+          SparseComplexMatrix InvL = fact.L ().transpose ().
             tinverse(tmp_typ, info, rcond2, true, false);
-          SparseComplexMatrix InvU = fact.U().
-            tinverse(tmp_typ, info, rcond2, true, false).transpose();
-          ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
+          SparseComplexMatrix InvU = fact.U ().
+            tinverse(tmp_typ, info, rcond2, true, false).transpose ();
+          ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
 ComplexDET
 SparseComplexMatrix::determinant (void) const
@@ -1274,23 +1274,23 @@ SparseComplexMatrix::dsolve (MatrixType 
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols(), Complex(0.,0.));
+          retval.resize (nc, b.cols (), Complex(0.,0.));
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
@@ -1342,29 +1342,29 @@ SparseComplexMatrix::dsolve (MatrixType 
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
           retval.xcidx(0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
                   {
                     if (b.ridx(i) >= nm)
                       break;
                     retval.xridx (ii) = b.ridx(i);
                     retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
                   }
                 retval.xcidx(j+1) = ii;
               }
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
                   for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
                       for (k = b.cidx(j); k < b.cidx(j+1); k++)
                         if (ridx(i) == b.ridx(k))
@@ -1426,23 +1426,23 @@ SparseComplexMatrix::dsolve (MatrixType 
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols(), Complex(0.,0.));
+          retval.resize (nc, b.cols (), Complex(0.,0.));
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
@@ -1494,29 +1494,29 @@ SparseComplexMatrix::dsolve (MatrixType 
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
           retval.xcidx(0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
                   {
                     if (b.ridx(i) >= nm)
                       break;
                     retval.xridx (ii) = b.ridx(i);
                     retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
                   }
                 retval.xcidx(j+1) = ii;
               }
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
                   for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
                       for (k = b.cidx(j); k < b.cidx(j+1); k++)
                         if (ridx(i) == b.ridx(k))
@@ -1634,17 +1634,17 @@ SparseComplexMatrix::utsolve (MatrixType
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (perm[i], j) = work[i];
+                    retval(perm[i], j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
@@ -2157,17 +2157,17 @@ SparseComplexMatrix::utsolve (MatrixType
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (perm[i], j) = work[i];
+                    retval(perm[i], j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
@@ -2690,17 +2690,17 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                               octave_idx_type iidx = perm[ridx(i)];
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (i, j) = work[i];
+                    retval(i, j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
@@ -3254,17 +3254,17 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                               octave_idx_type iidx = perm[ridx(i)];
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (i, j) = work[i];
+                    retval(i, j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
@@ -3791,22 +3791,22 @@ SparseComplexMatrix::trisolve (MatrixTyp
                   {
                     if (ridx(i) == j)
                       D[j] = std::real(data(i));
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
-                                   b.rows(), err));
+                                   b.rows (), err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
           else
@@ -3848,22 +3848,22 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
-                                   b.rows(), err));
+                                   b.rows (), err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4090,17 +4090,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                     if (ridx(i) == j)
                       D[j] = std::real (data(i));
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
                                    b_nr, err));
 
@@ -4147,18 +4147,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
-          octave_idx_type b_nr = b.rows();
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nr = b.rows ();
+          octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
                                    b_nr, err));
 
@@ -4388,17 +4388,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4452,17 +4452,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
-                             ldm, result, b.rows(), err
+                             ldm, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
@@ -4574,17 +4574,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, n_upper, b_nc, tmp_data,
-                             ldm, pipvt, result, b.rows(), err
+                             ldm, pipvt, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -4637,17 +4637,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4955,17 +4955,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5201,17 +5201,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5650,49 +5650,49 @@ SparseComplexMatrix::fsolve (MatrixType 
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_dense Bstore;
           cholmod_dense *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
           B->d = B->nrow;
           B->nzmax = B->nrow * B->ncol;
           B->dtype = CHOLMOD_DOUBLE;
           B->xtype = CHOLMOD_REAL;
-          if (nc < 1 || b.cols() < 1)
+          if (nc < 1 || b.cols () < 1)
             B->x = &dummy;
           else
             // We won't alter it, honest :-)
-            B->x = const_cast<double *>(b.fortran_vec());
+            B->x = const_cast<double *>(b.fortran_vec ());
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -5726,21 +5726,21 @@ SparseComplexMatrix::fsolve (MatrixType 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval.resize (b.rows (), b.cols());
-              for (octave_idx_type j = 0; j < b.cols(); j++)
-                {
-                  octave_idx_type jr = j * b.rows();
-                  for (octave_idx_type i = 0; i < b.rows(); i++)
+              retval.resize (b.rows (), b.cols ());
+              for (octave_idx_type j = 0; j < b.cols (); j++)
+                {
+                  octave_idx_type jr = j * b.rows ();
+                  for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
@@ -5893,59 +5893,59 @@ SparseComplexMatrix::fsolve (MatrixType 
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_sparse Bstore;
           cholmod_sparse *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
-          B->p = b.cidx();
-          B->i = b.ridx();
-          B->nzmax = b.nnz();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
+          B->p = b.cidx ();
+          B->i = b.ridx ();
+          B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
           B->nz = 0;
 #ifdef IDX_TYPE_LONG
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_REAL;
 
-          if (b.rows() < 1 || b.cols() < 1)
+          if (b.rows () < 1 || b.cols () < 1)
             B->x = &dummy;
           else
-            B->x = b.data();
+            B->x = b.data ();
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -6184,49 +6184,49 @@ SparseComplexMatrix::fsolve (MatrixType 
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_dense Bstore;
           cholmod_dense *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
           B->d = B->nrow;
           B->nzmax = B->nrow * B->ncol;
           B->dtype = CHOLMOD_DOUBLE;
           B->xtype = CHOLMOD_COMPLEX;
-          if (nc < 1 || b.cols() < 1)
+          if (nc < 1 || b.cols () < 1)
             B->x = &dummy;
           else
             // We won't alter it, honest :-)
-            B->x = const_cast<Complex *>(b.fortran_vec());
+            B->x = const_cast<Complex *>(b.fortran_vec ());
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -6260,21 +6260,21 @@ SparseComplexMatrix::fsolve (MatrixType 
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval.resize (b.rows (), b.cols());
-              for (octave_idx_type j = 0; j < b.cols(); j++)
-                {
-                  octave_idx_type jr = j * b.rows();
-                  for (octave_idx_type i = 0; i < b.rows(); i++)
+              retval.resize (b.rows (), b.cols ());
+              for (octave_idx_type j = 0; j < b.cols (); j++)
+                {
+                  octave_idx_type jr = j * b.rows ();
+                  for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
@@ -6406,59 +6406,59 @@ SparseComplexMatrix::fsolve (MatrixType 
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_sparse Bstore;
           cholmod_sparse *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
-          B->p = b.cidx();
-          B->i = b.ridx();
-          B->nzmax = b.nnz();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
+          B->p = b.cidx ();
+          B->i = b.ridx ();
+          B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
           B->nz = 0;
 #ifdef IDX_TYPE_LONG
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_COMPLEX;
 
-          if (b.rows() < 1 || b.cols() < 1)
+          if (b.rows () < 1 || b.cols () < 1)
             B->x = &dummy;
           else
-            B->x = b.data();
+            B->x = b.data ();
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -7343,18 +7343,18 @@ SparseComplexMatrix
 SparseComplexMatrix::cumsum (int dim) const
 {
   SPARSE_CUMSUM (SparseComplexMatrix, Complex, cumsum);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::prod (int dim) const
 {
-  if ((rows() == 1 && dim == -1) || dim == 1)
-    return transpose (). prod (0). transpose();
+  if ((rows () == 1 && dim == -1) || dim == 1)
+    return transpose (). prod (0). transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=,
                            (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseComplexMatrix
@@ -7381,17 +7381,17 @@ SparseComplexMatrix::sumsq (int dim) con
 #undef COL_EXPR
 }
 
 SparseMatrix SparseComplexMatrix::abs (void) const
 {
   octave_idx_type nz = nnz ();
   octave_idx_type nc = cols ();
 
-  SparseMatrix retval (rows(), nc, nz);
+  SparseMatrix retval (rows (), nc, nz);
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     retval.cidx (i) = cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       retval.data (i) = std::abs (data (i));
       retval.ridx (i) = ridx (i);
@@ -7660,17 +7660,17 @@ min (const SparseComplexMatrix& m, const
   return min (c, m);
 }
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   SparseComplexMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
+  if ((a.rows () == b.rows ()) && (a.cols () == b.cols ()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0 || a.nnz () == 0 || b.nnz () == 0)
@@ -7780,17 +7780,17 @@ max (const SparseComplexMatrix& m, const
   return max (c, m);
 }
 
 SparseComplexMatrix
 max (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   SparseComplexMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
+  if ((a.rows () == b.rows ()) && (a.cols () == b.cols ()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0)
diff --git a/liboctave/CmplxGEPBAL.cc b/liboctave/CmplxGEPBAL.cc
--- a/liboctave/CmplxGEPBAL.cc
+++ b/liboctave/CmplxGEPBAL.cc
@@ -65,17 +65,17 @@ ComplexGEPBALANCE::init (const ComplexMa
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("ComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
-  if (a.dims() != b.dims ())
+  if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -686,17 +686,17 @@ EIG::init (const ComplexMatrix& a, const
       (*current_liboctave_error_handler)
         ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
-  if (n != a.cols () || nb != b.cols())
+  if (n != a.cols () || nb != b.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
   if (n != nb)
     {
       (*current_liboctave_error_handler) ("EIG requires same size matrices");
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -412,34 +412,34 @@ product (const MSparse<T>& a, const MSpa
 
   if (a_nr == 1 && a_nc == 1)
     {
       if (a.elem(0,0) == 0.)
         r = MSparse<T> (b_nr, b_nc);
       else
         {
           r = MSparse<T> (b);
-          octave_idx_type b_nnz = b.nnz();
+          octave_idx_type b_nnz = b.nnz ();
 
           for (octave_idx_type i = 0 ; i < b_nnz ; i++)
             {
               octave_quit ();
               r.data (i) = a.data(0) * r.data(i);
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
       if (b.elem(0,0) == 0.)
         r = MSparse<T> (a_nr, a_nc);
       else
         {
           r = MSparse<T> (a);
-          octave_idx_type a_nnz = a.nnz();
+          octave_idx_type a_nnz = a.nnz ();
 
           for (octave_idx_type i = 0 ; i < a_nnz ; i++)
             {
               octave_quit ();
               r.data (i) = r.data(i) * b.data(0);
             }
           r.maybe_compress ();
         }
@@ -507,20 +507,20 @@ quotient (const MSparse<T>& a, const MSp
   octave_idx_type a_nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nr == 1 && a_nc == 1)
     {
       T val = a.elem (0,0);
-      T fill = val / T();
-      if (fill == T())
+      T fill = val / T ();
+      if (fill == T ())
         {
-          octave_idx_type b_nnz = b.nnz();
+          octave_idx_type b_nnz = b.nnz ();
           r = MSparse<T> (b);
           for (octave_idx_type i = 0 ; i < b_nnz ; i++)
             r.data (i) = val / r.data(i);
           r.maybe_compress ();
         }
       else
         {
           r = MSparse<T> (b_nr, b_nc, fill);
@@ -535,20 +535,20 @@ quotient (const MSparse<T>& a, const MSp
                 }
             }
           r.maybe_compress ();
         }
     }
   else if (b_nr == 1 && b_nc == 1)
     {
       T val = b.elem (0,0);
-      T fill = T() / val;
-      if (fill == T())
+      T fill = T () / val;
+      if (fill == T ())
         {
-          octave_idx_type a_nnz = a.nnz();
+          octave_idx_type a_nnz = a.nnz ();
           r = MSparse<T> (a);
           for (octave_idx_type i = 0 ; i < a_nnz ; i++)
             r.data (i) = r.data(i) / val;
           r.maybe_compress ();
         }
       else
         {
           r = MSparse<T> (a_nr, a_nc, fill);
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "CSparse.h"
 #include "oct-spparms.h"
 #include "oct-locbuf.h"
 
 // FIXME There is a large code duplication here
 
 MatrixType::MatrixType (void)
   : typ (MatrixType::Unknown),
-    sp_bandden (octave_sparse_params::get_bandden()),
+    sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0),
     lower_band (0), dense (false), full (false), nperm (0), perm (0) { }
 
 MatrixType::MatrixType (const MatrixType &a)
   : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden),
     upper_band (a.upper_band), lower_band (a.lower_band),
     dense (a.dense), full (a.full), nperm (a.nperm), perm (0)
 {
@@ -135,18 +135,18 @@ matrix_complex_probe (const MArray<std::
       OCTAVE_LOCAL_BUFFER(T, diag, ncols);
 
       for (octave_idx_type j = 0;
            j < ncols && upper; j++)
         {
           std::complex<T> d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
-          hermitian = hermitian && (d.real() > zero && d.imag() == zero);
-          diag[j] = d.real();
+          hermitian = hermitian && (d.real () > zero && d.imag () == zero);
+          diag[j] = d.real ();
         }
 
       for (octave_idx_type j = 0;
            j < ncols && (upper || lower || hermitian); j++)
         {
           for (octave_idx_type i = 0; i < j; i++)
             {
               std::complex<T> aij = a.elem (i,j), aji = a.elem (j,i);
@@ -215,17 +215,17 @@ MatrixType::MatrixType (const SparseMatr
   octave_idx_type ncols = a.cols ();
   octave_idx_type nm = (ncols < nrows ? ncols : nrows);
   octave_idx_type nnz = a.nnz ();
 
   if (octave_sparse_params::get_key ("spumoni") != 0.)
     (*current_liboctave_warning_handler)
       ("Calculating Sparse Matrix Type");
 
-  sp_bandden = octave_sparse_params::get_bandden();
+  sp_bandden = octave_sparse_params::get_bandden ();
   bool maybe_hermitian = false;
   typ = MatrixType::Full;
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
@@ -536,17 +536,17 @@ MatrixType::MatrixType (const SparseComp
   octave_idx_type ncols = a.cols ();
   octave_idx_type nm = (ncols < nrows ? ncols : nrows);
   octave_idx_type nnz = a.nnz ();
 
   if (octave_sparse_params::get_key ("spumoni") != 0.)
     (*current_liboctave_warning_handler)
       ("Calculating Sparse Matrix Type");
 
-  sp_bandden = octave_sparse_params::get_bandden();
+  sp_bandden = octave_sparse_params::get_bandden ();
   bool maybe_hermitian = false;
   typ = MatrixType::Full;
 
   if (nnz == nm)
     {
       matrix_type tmp_typ = MatrixType::Diagonal;
       octave_idx_type i;
       // Maybe the matrix is diagonal
@@ -799,18 +799,18 @@ MatrixType::MatrixType (const SparseComp
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             {
               is_herm = false;
               for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
                 {
                   if (a.ridx(i) == j)
                     {
                       Complex d = a.data(i);
-                      is_herm = d.real() > 0. && d.imag() == 0.;
-                      diag(j) = d.real();
+                      is_herm = d.real () > 0. && d.imag () == 0.;
+                      diag(j) = d.real ();
                       break;
                     }
                 }
             }
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
@@ -845,34 +845,34 @@ MatrixType::MatrixType (const SparseComp
               else
                 typ = MatrixType::Tridiagonal_Hermitian;
             }
         }
     }
 }
 MatrixType::MatrixType (const matrix_type t, bool _full)
   : typ (MatrixType::Unknown),
-    sp_bandden (octave_sparse_params::get_bandden()),
+    sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if (t == MatrixType::Unknown || t == MatrixType::Full
       || t == MatrixType::Diagonal || t == MatrixType::Permuted_Diagonal
       || t == MatrixType::Upper || t == MatrixType::Lower
       || t == MatrixType::Tridiagonal || t == MatrixType::Tridiagonal_Hermitian
       || t == MatrixType::Rectangular)
     typ = t;
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type np,
                         const octave_idx_type *p, bool _full)
   : typ (MatrixType::Unknown),
-    sp_bandden (octave_sparse_params::get_bandden()),
+    sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if ((t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower) &&
       np > 0 && p != 0)
     {
       typ = t;
       nperm = np;
@@ -882,17 +882,17 @@ MatrixType::MatrixType (const matrix_typ
     }
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type ku,
                         const octave_idx_type kl, bool _full)
   : typ (MatrixType::Unknown),
-    sp_bandden (octave_sparse_params::get_bandden()),
+    sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
   if (t == MatrixType::Banded || t == MatrixType::Banded_Hermitian)
     {
       typ = t;
       upper_band = ku;
       lower_band = kl;
@@ -939,17 +939,17 @@ MatrixType::operator = (const MatrixType
 
   return *this;
 }
 
 int
 MatrixType::type (bool quiet)
 {
   if (typ != MatrixType::Unknown && (full ||
-      sp_bandden == octave_sparse_params::get_bandden()))
+      sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (!quiet &&
           octave_sparse_params::get_key ("spumoni") != 0.)
         (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
 
       return typ;
     }
@@ -963,17 +963,17 @@ MatrixType::type (bool quiet)
 
   return typ;
 }
 
 int
 MatrixType::type (const SparseMatrix &a)
 {
   if (typ != MatrixType::Unknown && (full ||
-      sp_bandden == octave_sparse_params::get_bandden()))
+      sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
 
       return typ;
     }
 
@@ -996,17 +996,17 @@ MatrixType::type (const SparseMatrix &a)
 
   return typ;
 }
 
 int
 MatrixType::type (const SparseComplexMatrix &a)
 {
   if (typ != MatrixType::Unknown && (full ||
-      sp_bandden == octave_sparse_params::get_bandden()))
+      sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
 
       return typ;
     }
 
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -514,34 +514,34 @@ along with Octave; see the file COPYING.
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
         if (m1.elem(0,0) == 0.) \
           r = R (m2_nr, m2_nc); \
         else \
           { \
             r = R (m2); \
-            octave_idx_type m2_nnz = m2.nnz(); \
+            octave_idx_type m2_nnz = m2.nnz (); \
             \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
               { \
                 octave_quit (); \
                 r.data (i) = m1.data(0) OP r.data(i); \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
         if (m2.elem(0,0) == 0.) \
           r = R (m1_nr, m1_nc); \
         else \
           { \
             r = R (m1); \
-            octave_idx_type m1_nnz = m1.nnz(); \
+            octave_idx_type m1_nnz = m1.nnz (); \
             \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
               { \
                 octave_quit (); \
                 r.data (i) = r.data(i) OP m2.data(0); \
               } \
             r.maybe_compress (); \
           } \
@@ -607,19 +607,19 @@ along with Octave; see the file COPYING.
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr == 1 && m1_nc == 1) \
       { \
-        if ((m1.elem (0,0) OP Complex()) == Complex()) \
+        if ((m1.elem (0,0) OP Complex ()) == Complex ()) \
           { \
-            octave_idx_type m2_nnz = m2.nnz(); \
+            octave_idx_type m2_nnz = m2.nnz (); \
             r = R (m2); \
             for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
               r.data (i) = m1.elem(0,0) OP r.data(i); \
             r.maybe_compress (); \
           } \
         else \
           { \
             r = R (m2_nr, m2_nc, m1.elem(0,0) OP Complex ()); \
@@ -633,27 +633,27 @@ along with Octave; see the file COPYING.
                     r.data(idxj + m2.ridx(i)) = m1.elem(0,0) OP m2.data(i); \
                   } \
               } \
             r.maybe_compress (); \
           } \
       } \
     else if (m2_nr == 1 && m2_nc == 1) \
       { \
-        if ((Complex() OP m1.elem (0,0)) == Complex()) \
+        if ((Complex () OP m1.elem (0,0)) == Complex ()) \
           { \
-            octave_idx_type m1_nnz = m1.nnz(); \
+            octave_idx_type m1_nnz = m1.nnz (); \
             r = R (m1); \
             for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
               r.data (i) = r.data(i) OP m2.elem(0,0); \
             r.maybe_compress (); \
           } \
         else \
           { \
-            r = R (m1_nr, m1_nc, Complex() OP m2.elem(0,0)); \
+            r = R (m1_nr, m1_nc, Complex () OP m2.elem(0,0)); \
             for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
               { \
                 octave_quit (); \
                 octave_idx_type idxj = j * m1_nr; \
                 for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
                   { \
                     octave_quit (); \
                     r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.elem(0,0); \
@@ -1825,18 +1825,18 @@ along with Octave; see the file COPYING.
 
 #define SPARSE_ANY_ALL_OP(DIM, INIT_VAL, MT_RESULT, TEST_OP, TEST_TRUE_VAL) \
   SPARSE_BASE_REDUCTION_OP (SparseBoolMatrix, char, \
                         SPARSE_ANY_ALL_OP_ROW_CODE (TEST_OP, TEST_TRUE_VAL), \
                         SPARSE_ANY_ALL_OP_COL_CODE (TEST_OP, TEST_TRUE_VAL), \
                         INIT_VAL, MT_RESULT)
 
 #define SPARSE_ALL_OP(DIM) \
-  if ((rows() == 1 && dim == -1) || dim == 1) \
-    return transpose (). all (0). transpose(); \
+  if ((rows () == 1 && dim == -1) || dim == 1) \
+    return transpose (). all (0). transpose (); \
   else \
     { \
       SPARSE_ANY_ALL_OP (DIM, (cidx(j+1) - cidx(j) < nr ? false : true), \
                          true, ==, false); \
     }
 
 #define SPARSE_ANY_OP(DIM) SPARSE_ANY_ALL_OP (DIM, false, false, !=, true)
 
@@ -1845,17 +1845,17 @@ along with Octave; see the file COPYING.
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
   if (nr == 1 && nc == 1) \
    { \
      RET_EL_TYPE s = m.elem(0,0); \
-     octave_idx_type nz = a.nnz(); \
+     octave_idx_type nz = a.nnz (); \
      RET_TYPE r (a_nr, a_nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
          r.data(i) = s * a.data(i); \
          r.ridx(i) = a.ridx(i); \
        } \
@@ -1866,17 +1866,17 @@ along with Octave; see the file COPYING.
        } \
      \
      r.maybe_compress (true); \
      return r; \
    } \
   else if (a_nr == 1 && a_nc == 1) \
    { \
      RET_EL_TYPE s = a.elem(0,0); \
-     octave_idx_type nz = m.nnz(); \
+     octave_idx_type nz = m.nnz (); \
      RET_TYPE r (nr, nc, nz); \
      \
      for (octave_idx_type i = 0; i < nz; i++) \
        { \
          octave_quit (); \
          r.data(i) = m.data(i) * s; \
          r.ridx(i) = m.ridx(i); \
        } \
@@ -1941,17 +1941,17 @@ along with Octave; see the file COPYING.
           /* it was found that the breakpoints were */ \
           /*   nr: 500  1000  2000  5000 10000 */ \
           /*   nz:   6    25    97   585  2202 */ \
           /* The below is a simplication of the 'polyfit'-ed parameters */ \
           /* to these breakpoints */ \
           octave_idx_type n_per_col = (a_nc > 43000 ? 43000 : \
                                         (a_nc * a_nc) / 43000); \
           octave_idx_type ii = 0; \
-          octave_idx_type *ri = retval.xridx(); \
+          octave_idx_type *ri = retval.xridx (); \
           octave_sort<octave_idx_type> sort; \
           \
           for (octave_idx_type i = 0; i < a_nc ; i++) \
             { \
               if (retval.xcidx(i+1) - retval.xcidx(i) > n_per_col) \
                 { \
                   for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++) \
                     { \
diff --git a/liboctave/Sparse-perm-op-defs.h b/liboctave/Sparse-perm-op-defs.h
--- a/liboctave/Sparse-perm-op-defs.h
+++ b/liboctave/Sparse-perm-op-defs.h
@@ -44,17 +44,17 @@ SM octinternal_do_mul_colpm_sm (const oc
       octave_quit ();
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, sidx, r.xcidx(j+1) - r.xcidx(j));
       for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
         {
           sidx[ii++]=i;
           r.xridx (i) = pcol[a.ridx (i)];
         }
-      sort.sort (r.xridx() + r.xcidx(j), sidx, r.xcidx(j+1) - r.xcidx(j));
+      sort.sort (r.xridx () + r.xcidx(j), sidx, r.xcidx(j+1) - r.xcidx(j));
       for (octave_idx_type i = r.xcidx(j), ii = 0; i < r.xcidx(j+1); i++)
         r.xdata(i) = a.data (sidx[ii++]);
     }
 
   return r;
 }
 
 template <typename SM>
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 #include "oct-spparms.h"
 #include "mx-inlines.cc"
 
 #include "PermMatrix.h"
 
 template <class T>
 Sparse<T>::Sparse (const PermMatrix& a)
   : rep (new typename Sparse<T>::SparseRep (a.rows (), a.cols (), a.rows ())),
-         dimensions (dim_vector (a.rows (), a.cols()))
+         dimensions (dim_vector (a.rows (), a.cols ()))
 {
   octave_idx_type n = a.rows ();
   for (octave_idx_type i = 0; i <= n; i++)
     cidx (i) = i;
 
   const Array<octave_idx_type> pv = a.pvec ();
 
   if (a.is_row_perm ())
@@ -144,17 +144,17 @@ Sparse<T>::SparseRep::maybe_compress (bo
 {
   if (remove_zeros)
     {
       octave_idx_type i = 0, k = 0;
       for (octave_idx_type j = 1; j <= ncols; j++)
         {
           octave_idx_type u = c[j];
           for (i = i; i < u; i++)
-            if (d[i] != T())
+            if (d[i] != T ())
               {
                 d[k] = d[i];
                 r[k++] = r[i];
               }
           c[j] = k;
         }
     }
 
@@ -226,17 +226,17 @@ Sparse<T>::Sparse (octave_idx_type nr, o
         xcidx(j) = 0;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
-  if (dv.length() != 2)
+  if (dv.length () != 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const dim_vector&): dimension mismatch");
   else
     rep = new typename Sparse<T>::SparseRep (dv(0), dv(1), 0);
 }
 
 template <class T>
 Sparse<T>::Sparse (const Sparse<T>& a, const dim_vector& dv)
@@ -249,17 +249,17 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
   unsigned long long dv_nel = static_cast<unsigned long long>(dv (0)) *
     static_cast<unsigned long long>(dv (1));
 
   if (a_nel != dv_nel)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Sparse&, const dim_vector&): dimension mismatch");
   else
     {
-      dim_vector old_dims = a.dims();
+      dim_vector old_dims = a.dims ();
       octave_idx_type new_nzmx = a.nnz ();
       octave_idx_type new_nr = dv (0);
       octave_idx_type new_nc = dv (1);
       octave_idx_type old_nr = old_dims (0);
       octave_idx_type old_nc = old_dims (1);
 
       rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
 
@@ -329,17 +329,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
           for (octave_idx_type j = 0; j < nc; j++)
             xcidx(j+1) = j >= c(0);
         }
     }
   else if (a_scalar)
     {
       // This is completely specialized, because the sorts can be simplified.
       T a0 = a(0);
-      if (a0 == T())
+      if (a0 == T ())
         {
           // Do nothing, it's an empty matrix.
         }
       else if (cl == 1)
         {
           // Sparse column vector. Sort row indices.
           idx_vector rs = r.sorted ();
 
@@ -810,17 +810,17 @@ Sparse<T>::reshape (const dim_vector& ne
   Sparse<T> retval;
   dim_vector dims2 = new_dims;
 
   if (dims2.length () > 2)
     {
       (*current_liboctave_warning_handler)
         ("reshape: sparse reshape to N-d array smashes dims");
 
-      for (octave_idx_type i = 2; i < dims2.length(); i++)
+      for (octave_idx_type i = 2; i < dims2.length (); i++)
         dims2(1) *= dims2(i);
 
       dims2.resize (2);
     }
 
   if (dimensions != dims2)
     {
       if (dimensions.numel () == dims2.numel ())
@@ -1235,55 +1235,87 @@ Sparse<T>::delete_elements (const idx_ve
   if (idx_i.is_colon ())
     {
       // Deleting columns.
       octave_idx_type lb, ub;
       if (idx_j.extent (nc) > nc)
         gripe_del_index_out_of_range (false, idx_j.extent (nc), nc);
       else if (idx_j.is_cont_range (nc, lb, ub))
         {
-          const Sparse<T> tmp = *this;
-          octave_idx_type lbi = tmp.cidx(lb), ubi = tmp.cidx(ub), new_nz = nz - (ubi - lbi);
-          *this = Sparse<T> (nr, nc - (ub - lb), new_nz);
-          copy_or_memcpy (lbi, tmp.data (), data ());
-          copy_or_memcpy (lbi, tmp.ridx (), ridx ());
-          copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
-          copy_or_memcpy (nz - ubi, tmp.ridx () + ubi, xridx () + lbi);
-          copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
-          mx_inline_sub (nc - ub, xcidx () + 1, tmp.cidx () + ub + 1, ubi - lbi);
+          if (lb == 0 && ub == nc)
+            {
+              // Delete all rows and columns.
+              *this = Sparse<T> (nr, 0);
+            }
+          else if (nz == 0)
+            {
+              // No elements to preserve; adjust dimensions.
+              *this = Sparse<T> (nr, nc - (ub - lb));
+            }
+          else
+            {
+              const Sparse<T> tmp = *this;
+              octave_idx_type lbi = tmp.cidx(lb), ubi = tmp.cidx(ub),
+                new_nz = nz - (ubi - lbi);
+
+              *this = Sparse<T> (nr, nc - (ub - lb), new_nz);
+              copy_or_memcpy (lbi, tmp.data (), data ());
+              copy_or_memcpy (lbi, tmp.ridx (), ridx ());
+              copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
+              copy_or_memcpy (nz - ubi, tmp.ridx () + ubi, xridx () + lbi);
+              copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
+              mx_inline_sub (nc - ub, xcidx () + lb + 1,
+                             tmp.cidx () + ub + 1, ubi - lbi);
+            }
         }
       else
         *this = index (idx_i, idx_j.complement (nc));
     }
   else if (idx_j.is_colon ())
     {
       // Deleting rows.
       octave_idx_type lb, ub;
       if (idx_i.extent (nr) > nr)
         gripe_del_index_out_of_range (false, idx_i.extent (nr), nr);
       else if (idx_i.is_cont_range (nr, lb, ub))
         {
-          // This is more memory-efficient than the approach below.
-          const Sparse<T> tmpl = index (idx_vector (0, lb), idx_j);
-          const Sparse<T> tmpu = index (idx_vector (ub, nr), idx_j);
-          *this = Sparse<T> (nr - (ub - lb), nc, tmpl.nnz () + tmpu.nnz ());
-          for (octave_idx_type j = 0, k = 0; j < nc; j++)
+          if (lb == 0 && ub == nr)
+            {
+              // Delete all rows and columns.
+              *this = Sparse<T> (0, nc);
+            }
+          else if (nz == 0)
             {
-              for (octave_idx_type i = tmpl.cidx(j); i < tmpl.cidx(j+1); i++)
+              // No elements to preserve; adjust dimensions.
+              *this = Sparse<T> (nr - (ub - lb), nc);
+            }
+          else
+            {
+              // This is more memory-efficient than the approach below.
+              const Sparse<T> tmpl = index (idx_vector (0, lb), idx_j);
+              const Sparse<T> tmpu = index (idx_vector (ub, nr), idx_j);
+              *this = Sparse<T> (nr - (ub - lb), nc,
+                                 tmpl.nnz () + tmpu.nnz ());
+              for (octave_idx_type j = 0, k = 0; j < nc; j++)
                 {
-                  xdata(k) = tmpl.data(i);
-                  xridx(k++) = tmpl.ridx(i);
+                  for (octave_idx_type i = tmpl.cidx(j); i < tmpl.cidx(j+1);
+                       i++)
+                    {
+                      xdata(k) = tmpl.data(i);
+                      xridx(k++) = tmpl.ridx(i);
+                    }
+                  for (octave_idx_type i = tmpu.cidx(j); i < tmpu.cidx(j+1);
+                       i++)
+                    {
+                      xdata(k) = tmpu.data(i);
+                      xridx(k++) = tmpu.ridx(i) + lb;
+                    }
+
+                  xcidx(j+1) = k;
                 }
-              for (octave_idx_type i = tmpu.cidx(j); i < tmpu.cidx(j+1); i++)
-                {
-                  xdata(k) = tmpu.data(i);
-                  xridx(k++) = tmpu.ridx(i) + lb;
-                }
-
-              xcidx(j+1) = k;
             }
         }
       else
         {
           // This is done by transposing, deleting columns, then transposing
           // again.
           Sparse<T> tmp = transpose ();
           tmp.delete_elements (idx_j, idx_i);
@@ -1578,16 +1610,20 @@ Sparse<T>::index (const idx_vector& idx_
               copy_or_memcpy (nzj, ridx () + ljj, retval.ridx () + lj);
             }
         }
     }
   else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
     {
       // It's actually vector indexing. The 1D index is specialized for that.
       retval = index (idx_i);
+
+      // If nr == 1 then the vector indexing will return a column vector!!
+      if (nr == 1)
+        retval.transpose ();
     }
   else if (idx_i.is_scalar ())
     {
       octave_idx_type ii = idx_i(0);
       retval = Sparse<T> (1, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ij, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
@@ -1825,17 +1861,17 @@ Sparse<T>::assign (const idx_vector& idx
             {
               // Elements are being zeroed.
               octave_idx_type *ri = ridx ();
               for (octave_idx_type i = 0; i < rhl; i++)
                 {
                   octave_idx_type iidx = idx(i);
                   octave_idx_type li = lblookup (ri, nz, iidx);
                   if (li != nz && ri[li] == iidx)
-                    xdata(li) = T();
+                    xdata(li) = T ();
                 }
 
               maybe_compress (true);
             }
           else
             {
               const Sparse<T> tmp = *this;
               octave_idx_type new_nz = nz + rhl;
@@ -2548,31 +2584,31 @@ Sparse<T>::cat (int dim, octave_idx_type
 
   return retval;
 }
 
 template <class T>
 Array<T>
 Sparse<T>::array_value () const
 {
-  NoAlias< Array<T> > retval (dims (), T());
+  NoAlias< Array<T> > retval (dims (), T ());
   if (rows () == 1)
     {
       octave_idx_type i = 0;
       for (octave_idx_type j = 0, nc = cols (); j < nc; j++)
         {
           if (cidx(j+1) > i)
             retval(j) = data (i++);
         }
     }
   else
     {
       for (octave_idx_type j = 0, nc = cols (); j < nc; j++)
         for (octave_idx_type i = cidx(j), iu = cidx(j+1); i < iu; i++)
-          retval (ridx(i), j) = data (i);
+          retval(ridx(i), j) = data (i);
     }
 
   return retval;
 }
 
 /*
  * Tests
  *
@@ -2731,16 +2767,28 @@ Sparse<T>::array_value () const
 %!test test_sparse_slice ([2 2], 22, [2,2]);
 %!test test_sparse_slice ([2 2], 22, 3);
 %!test test_sparse_slice ([2 2], 22, 4);
 
 bug #35570:
 
 %!assert (speye (3,1)(3:-1:1), sparse ([0; 0; 1]))
 
+## Test removing columns (bug #36656)
+
+%!test
+%! s = sparse (magic (5));
+%! s(:,2:4) = [];
+%! assert (s, sparse (magic (5)(:, [1,5])));
+
+%!test
+%! s = sparse([], [], [], 1, 1);
+%! s(1,:) = [];
+%! assert (s, sparse ([], [], [], 0, 1));
+
 */
 
 template <class T>
 void
 Sparse<T>::print_info (std::ostream& os, const std::string& prefix) const
 {
   os << prefix << "rep address: " << rep << "\n"
      << prefix << "rep->nzmx:   " << rep->nzmx  << "\n"
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -66,43 +66,44 @@ protected:
     T *d;
     octave_idx_type *r;
     octave_idx_type *c;
     octave_idx_type nzmx;
     octave_idx_type nrows;
     octave_idx_type ncols;
     octave_refcount<int> count;
 
-    SparseRep (void) : d (0), r (0), c (new octave_idx_type [1]), nzmx (0), nrows (0),
-                       ncols (0), count (1) { c[0] = 0; }
+    SparseRep (void)
+      : d (0), r (0), c (new octave_idx_type [1]), nzmx (0), nrows (0),
+      ncols (0), count (1)
+      {
+        c[0] = 0;
+      }
 
-    SparseRep (octave_idx_type n) : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
+    SparseRep (octave_idx_type n)
+      : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
       ncols (n), count (1)
       {
         for (octave_idx_type i = 0; i < n + 1; i++)
           c[i] = 0;
       }
 
-    SparseRep (octave_idx_type nr, octave_idx_type nc) : d (0), r (0), c (new octave_idx_type [nc+1]), nzmx (0),
-      nrows (nr), ncols (nc), count (1)
-      {
-        for (octave_idx_type i = 0; i < nc + 1; i++)
-          c[i] = 0;
-      }
-
-    SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz) : d (new T [nz]),
-      r (new octave_idx_type [nz]), c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr),
+    SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz = 0)
+      : d (new T [nz]), r (new octave_idx_type [nz]),
+      c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr),
       ncols (nc), count (1)
       {
-        for (octave_idx_type i = 0; i < nc + 1; i++)
+        c[nc] = nz;
+        for (octave_idx_type i = 0; i < nc; i++)
           c[i] = 0;
       }
 
     SparseRep (const SparseRep& a)
-      : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]), c (new octave_idx_type [a.ncols + 1]),
+      : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]),
+      c (new octave_idx_type [a.ncols + 1]),
       nzmx (a.nzmx), nrows (a.nrows), ncols (a.ncols), count (1)
       {
         octave_idx_type nz = a.nnz ();
         copy_or_memcpy (nz, a.d, d);
         copy_or_memcpy (nz, a.r, r);
         copy_or_memcpy (ncols + 1, a.c, c);
       }
 
@@ -139,93 +140,93 @@ protected:
     // No assignment!
 
     SparseRep& operator = (const SparseRep& a);
   };
 
   //--------------------------------------------------------------------
 
   void make_unique (void)
-    {
-      if (rep->count > 1)
-        {
-          SparseRep *r = new SparseRep (*rep);
+  {
+    if (rep->count > 1)
+      {
+        SparseRep *r = new SparseRep (*rep);
 
-          if (--rep->count == 0)
-            delete rep;
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = r;
-        }
-    }
+        rep = r;
+      }
+  }
 
 public:
 
   // !!! WARNING !!! -- these should be protected, not public.  You
   // should not access these data members directly!
 
   typename Sparse<T>::SparseRep *rep;
 
   dim_vector dimensions;
 
 private:
 
   typename Sparse<T>::SparseRep *nil_rep (void) const
-    {
-      static typename Sparse<T>::SparseRep nr;
-      return &nr;
-    }
+  {
+    static typename Sparse<T>::SparseRep nr;
+    return &nr;
+  }
 
 public:
 
   Sparse (void)
     : rep (nil_rep ()), dimensions (dim_vector(0,0))
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
   explicit Sparse (octave_idx_type n)
     : rep (new typename Sparse<T>::SparseRep (n)),
       dimensions (dim_vector (n, n)) { }
 
   explicit Sparse (octave_idx_type nr, octave_idx_type nc)
     : rep (new typename Sparse<T>::SparseRep (nr, nc)),
       dimensions (dim_vector (nr, nc)) { }
 
   explicit Sparse (octave_idx_type nr, octave_idx_type nc, T val);
 
   Sparse (const dim_vector& dv, octave_idx_type nz)
     : rep (new typename Sparse<T>::SparseRep (dv(0), dv(1), nz)),
-    dimensions (dv) { }
+      dimensions (dv) { }
 
   Sparse (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz)
     : rep (new typename Sparse<T>::SparseRep (nr, nc, nz)),
       dimensions (dim_vector (nr, nc)) { }
 
   // Both SparseMatrix and SparseBoolMatrix need this ctor, and this
   // is their only common ancestor.
   explicit Sparse (const PermMatrix& a);
 
   // Type conversion case. Preserves capacity ().
   template <class U>
   Sparse (const Sparse<U>& a)
     : rep (new typename Sparse<T>::SparseRep (a.rep->nrows, a.rep->ncols, a.rep->nzmx)),
-    dimensions (a.dimensions)
-    {
-      octave_idx_type nz = a.nnz ();
-      std::copy (a.rep->d, a.rep->d + nz, rep->d);
-      copy_or_memcpy (nz, a.rep->r, rep->r);
-      copy_or_memcpy (rep->ncols + 1, a.rep->c, rep->c);
-    }
+      dimensions (a.dimensions)
+  {
+    octave_idx_type nz = a.nnz ();
+    std::copy (a.rep->d, a.rep->d + nz, rep->d);
+    copy_or_memcpy (nz, a.rep->r, rep->r);
+    copy_or_memcpy (rep->ncols + 1, a.rep->c, rep->c);
+  }
 
   // No type conversion case.
   Sparse (const Sparse<T>& a)
     : rep (a.rep), dimensions (a.dimensions)
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
 public:
 
   Sparse (const dim_vector& dv);
 
   Sparse (const Sparse<T>& a, const dim_vector& dv);
 
   Sparse (const Array<T>& a, const idx_vector& r, const idx_vector& c,
@@ -244,44 +245,45 @@ public:
   // terms.
   octave_idx_type nzmax (void) const { return rep->length (); }
   octave_idx_type capacity (void) const { return nzmax (); }
   octave_idx_type nnz (void) const { return rep->nnz (); }
 
   // Querying the number of elements (incl. zeros) may overflow the index type,
   // so don't do it unless you really need it.
   octave_idx_type numel (void) const
-    {
-      return dimensions.safe_numel ();
-    }
+  {
+    return dimensions.safe_numel ();
+  }
 
   octave_idx_type nelem (void) const { return capacity (); }
   octave_idx_type length (void) const { return numel (); }
 
   octave_idx_type dim1 (void) const { return dimensions(0); }
   octave_idx_type dim2 (void) const { return dimensions(1); }
 
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
   octave_idx_type get_row_index (octave_idx_type k) { return ridx (k); }
   octave_idx_type get_col_index (octave_idx_type k)
-    {
-      octave_idx_type ret = 0;
-      while (cidx(ret+1) < k)
-        ret++;
-      return ret;
-    }
+  {
+    octave_idx_type ret = 0;
+    while (cidx(ret+1) < k)
+      ret++;
+    return ret;
+  }
 
   size_t byte_size (void) const
-    {
-      return (static_cast<size_t>(cols () + 1) * sizeof (octave_idx_type)
-              + static_cast<size_t> (capacity ()) * (sizeof (T) + sizeof (octave_idx_type)));
-    }
+  {
+    return (static_cast<size_t>(cols () + 1) * sizeof (octave_idx_type)
+            + static_cast<size_t> (capacity ())
+            * (sizeof (T) + sizeof (octave_idx_type)));
+  }
 
   dim_vector dims (void) const { return dimensions; }
 
   Sparse<T> squeeze (void) const { return *this; }
 
   octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx) const;
 
   T range_error (const char *fcn, octave_idx_type n) const;
@@ -291,168 +293,212 @@ public:
   T& range_error (const char *fcn, octave_idx_type i, octave_idx_type j);
 
   T range_error (const char *fcn, const Array<octave_idx_type>& ra_idx) const;
   T& range_error (const char *fcn, const Array<octave_idx_type>& ra_idx);
 
   // No checking, even for multiple references, ever.
 
   T& xelem (octave_idx_type n)
-    {
-      octave_idx_type i = n % rows (), j = n / rows();
-      return xelem (i, j);
-    }
+  {
+    octave_idx_type i = n % rows (), j = n / rows ();
+    return xelem (i, j);
+  }
 
   T xelem (octave_idx_type n) const
-    {
-      octave_idx_type i = n % rows (), j = n / rows();
-      return xelem (i, j);
-    }
+  {
+    octave_idx_type i = n % rows (), j = n / rows ();
+    return xelem (i, j);
+  }
 
   T& xelem (octave_idx_type i, octave_idx_type j) { return rep->elem (i, j); }
-  T xelem (octave_idx_type i, octave_idx_type j) const { return rep->celem (i, j); }
+  T xelem (octave_idx_type i, octave_idx_type j) const
+  {
+    return rep->celem (i, j);
+  }
 
   T& xelem (const Array<octave_idx_type>& ra_idx)
-    { return xelem (compute_index (ra_idx)); }
+  { return xelem (compute_index (ra_idx)); }
 
   T xelem (const Array<octave_idx_type>& ra_idx) const
-    { return xelem (compute_index (ra_idx)); }
+  { return xelem (compute_index (ra_idx)); }
 
   // FIXME -- would be nice to fix this so that we don't
   // unnecessarily force a copy, but that is not so easy, and I see no
   // clean way to do it.
 
   T& checkelem (octave_idx_type n)
-    {
-      if (n < 0 || n >= numel ())
-        return range_error ("T& Sparse<T>::checkelem", n);
-      else
-        {
-          make_unique ();
-          return xelem (n);
-        }
-    }
+  {
+    if (n < 0 || n >= numel ())
+      return range_error ("T& Sparse<T>::checkelem", n);
+    else
+      {
+        make_unique ();
+        return xelem (n);
+      }
+  }
 
   T& checkelem (octave_idx_type i, octave_idx_type j)
-    {
-      if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
-        return range_error ("T& Sparse<T>::checkelem", i, j);
-      else
-        {
-          make_unique ();
-          return xelem (i, j);
-        }
-    }
+  {
+    if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
+      return range_error ("T& Sparse<T>::checkelem", i, j);
+    else
+      {
+        make_unique ();
+        return xelem (i, j);
+      }
+  }
 
   T& checkelem (const Array<octave_idx_type>& ra_idx)
-    {
-      octave_idx_type i = compute_index (ra_idx);
+  {
+    octave_idx_type i = compute_index (ra_idx);
 
-      if (i < 0)
-        return range_error ("T& Sparse<T>::checkelem", ra_idx);
-      else
-        return elem (i);
-    }
+    if (i < 0)
+      return range_error ("T& Sparse<T>::checkelem", ra_idx);
+    else
+      return elem (i);
+  }
 
   T& elem (octave_idx_type n)
-    {
-      make_unique ();
-      return xelem (n);
-    }
+  {
+    make_unique ();
+    return xelem (n);
+  }
 
   T& elem (octave_idx_type i, octave_idx_type j)
-    {
-      make_unique ();
-      return xelem (i, j);
-    }
+  {
+    make_unique ();
+    return xelem (i, j);
+  }
 
   T& elem (const Array<octave_idx_type>& ra_idx)
-    { return Sparse<T>::elem (compute_index (ra_idx)); }
+  { return Sparse<T>::elem (compute_index (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
-  T& operator () (octave_idx_type n) { return checkelem (n); }
-  T& operator () (octave_idx_type i, octave_idx_type j) { return checkelem (i, j); }
-  T& operator () (const Array<octave_idx_type>& ra_idx) { return checkelem (ra_idx); }
+  T& operator () (octave_idx_type n)
+  {
+    return checkelem (n);
+  }
+
+  T& operator () (octave_idx_type i, octave_idx_type j)
+  {
+    return checkelem (i, j);
+  }
+
+  T& operator () (const Array<octave_idx_type>& ra_idx)
+  {
+    return checkelem (ra_idx);
+  }
+
 #else
-  T& operator () (octave_idx_type n) { return elem (n); }
-  T& operator () (octave_idx_type i, octave_idx_type j) { return elem (i, j); }
-  T& operator () (const Array<octave_idx_type>& ra_idx) { return elem (ra_idx); }
+  T& operator () (octave_idx_type n)
+  {
+    return elem (n);
+  }
+
+  T& operator () (octave_idx_type i, octave_idx_type j)
+  {
+    return elem (i, j);
+  }
+
+  T& operator () (const Array<octave_idx_type>& ra_idx)
+  {
+    return elem (ra_idx);
+  }
+
 #endif
 
   T checkelem (octave_idx_type n) const
-    {
-      if (n < 0 || n >= numel ())
-        return range_error ("T Sparse<T>::checkelem", n);
-      else
-        return xelem (n);
-    }
+  {
+    if (n < 0 || n >= numel ())
+      return range_error ("T Sparse<T>::checkelem", n);
+    else
+      return xelem (n);
+  }
 
   T checkelem (octave_idx_type i, octave_idx_type j) const
-    {
-      if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
-        return range_error ("T Sparse<T>::checkelem", i, j);
-      else
-        return xelem (i, j);
-    }
+  {
+    if (i < 0 || j < 0 || i >= dim1 () || j >= dim2 ())
+      return range_error ("T Sparse<T>::checkelem", i, j);
+    else
+      return xelem (i, j);
+  }
 
   T checkelem (const Array<octave_idx_type>& ra_idx) const
-    {
-      octave_idx_type i = compute_index (ra_idx);
+  {
+    octave_idx_type i = compute_index (ra_idx);
 
-      if (i < 0)
-        return range_error ("T Sparse<T>::checkelem", ra_idx);
-      else
-        return Sparse<T>::elem (i);
-    }
+    if (i < 0)
+      return range_error ("T Sparse<T>::checkelem", ra_idx);
+    else
+      return Sparse<T>::elem (i);
+  }
 
   T elem (octave_idx_type n) const { return xelem (n); }
 
   T elem (octave_idx_type i, octave_idx_type j) const { return xelem (i, j); }
 
   T elem (const Array<octave_idx_type>& ra_idx) const
-    { return Sparse<T>::elem (compute_index (ra_idx)); }
+  { return Sparse<T>::elem (compute_index (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
   T operator () (octave_idx_type n) const { return checkelem (n); }
-  T operator () (octave_idx_type i, octave_idx_type j) const { return checkelem (i, j); }
-  T operator () (const Array<octave_idx_type>& ra_idx) const { return checkelem (ra_idx); }
+  T operator () (octave_idx_type i, octave_idx_type j) const
+  {
+    return checkelem (i, j);
+  }
+
+  T operator () (const Array<octave_idx_type>& ra_idx) const
+  {
+    return checkelem (ra_idx);
+  }
+
 #else
   T operator () (octave_idx_type n) const { return elem (n); }
-  T operator () (octave_idx_type i, octave_idx_type j) const { return elem (i, j); }
-  T operator () (const Array<octave_idx_type>& ra_idx) const { return elem (ra_idx); }
+  T operator () (octave_idx_type i, octave_idx_type j) const
+  {
+    return elem (i, j);
+  }
+
+  T operator () (const Array<octave_idx_type>& ra_idx) const
+  {
+    return elem (ra_idx);
+  }
 #endif
 
   Sparse<T> maybe_compress (bool remove_zeros = false)
-    {
-      if (remove_zeros)
-        make_unique (); // Needs to unshare because elements are removed.
+  {
+    if (remove_zeros)
+      make_unique (); // Needs to unshare because elements are removed.
 
-      rep->maybe_compress (remove_zeros);
-      return (*this);
-    }
+    rep->maybe_compress (remove_zeros);
+    return (*this);
+  }
 
   Sparse<T> reshape (const dim_vector& new_dims) const;
 
   Sparse<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const;
 
   Sparse<T> ipermute (const Array<octave_idx_type>& vec) const
-    { return permute (vec, true); }
+  {
+    return permute (vec, true);
+  }
 
   void resize1 (octave_idx_type n);
 
   void resize (octave_idx_type r, octave_idx_type c);
 
   void resize (const dim_vector& dv);
 
   void change_capacity (octave_idx_type nz)
-    {
-      if (nz < nnz ())
-        make_unique (); // Unshare now because elements will be truncated.
-      rep->change_length (nz);
-    }
+  {
+    if (nz < nnz ())
+      make_unique (); // Unshare now because elements will be truncated.
+    rep->change_length (nz);
+  }
 
   Sparse<T>& insert (const Sparse<T>& a, octave_idx_type r, octave_idx_type c);
   Sparse<T>& insert (const Sparse<T>& a, const Array<octave_idx_type>& idx);
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
 
   bool is_empty (void) const { return (rows () < 1 && cols () < 1); }
 
@@ -463,26 +509,34 @@ public:
   T* xdata (void) { return rep->d; }
   T& xdata (octave_idx_type i) { return rep->data (i); }
 
   T data (octave_idx_type i) const { return rep->data (i); }
   // FIXME -- shouldn't this be returning const T*?
   T* data (void) const { return rep->d; }
 
   octave_idx_type* ridx (void) { make_unique (); return rep->r; }
-  octave_idx_type& ridx (octave_idx_type i) { make_unique (); return rep->ridx (i); }
+  octave_idx_type& ridx (octave_idx_type i)
+  {
+    make_unique (); return rep->ridx (i);
+  }
+
   octave_idx_type* xridx (void) { return rep->r; }
   octave_idx_type& xridx (octave_idx_type i) { return rep->ridx (i); }
 
   octave_idx_type ridx (octave_idx_type i) const { return rep->cridx (i); }
   // FIXME -- shouldn't this be returning const octave_idx_type*?
   octave_idx_type* ridx (void) const { return rep->r; }
 
   octave_idx_type* cidx (void) { make_unique (); return rep->c; }
-  octave_idx_type& cidx (octave_idx_type i) { make_unique (); return rep->cidx (i); }
+  octave_idx_type& cidx (octave_idx_type i)
+  {
+    make_unique (); return rep->cidx (i);
+  }
+
   octave_idx_type* xcidx (void) { return rep->c; }
   octave_idx_type& xcidx (octave_idx_type i) { return rep->cidx (i); }
 
   octave_idx_type cidx (octave_idx_type i) const { return rep->ccidx (i); }
   // FIXME -- shouldn't this be returning const octave_idx_type*?
   octave_idx_type* cidx (void) const { return rep->c; }
 
   octave_idx_type ndims (void) const { return dimensions.length (); }
@@ -490,35 +544,42 @@ public:
   void delete_elements (const idx_vector& i);
 
   void delete_elements (int dim, const idx_vector& i);
 
   void delete_elements (const idx_vector& i, const idx_vector& j);
 
   Sparse<T> index (const idx_vector& i, bool resize_ok = false) const;
 
-  Sparse<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok = false) const;
+  Sparse<T> index (const idx_vector& i, const idx_vector& j,
+                   bool resize_ok = false) const;
 
   void assign (const idx_vector& i, const Sparse<T>& rhs);
 
   void assign (const idx_vector& i, const idx_vector& j, const Sparse<T>& rhs);
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   // Unsafe.  These functions exist to support the MEX interface.
   // You should not use them anywhere else.
   void *mex_get_data (void) const { return const_cast<T *> (data ()); }
 
-  octave_idx_type *mex_get_ir (void) const { return const_cast<octave_idx_type *> (ridx ()); }
+  octave_idx_type *mex_get_ir (void) const
+  {
+    return const_cast<octave_idx_type *> (ridx ());
+  }
 
-  octave_idx_type *mex_get_jc (void) const { return const_cast<octave_idx_type *> (cidx ()); }
+  octave_idx_type *mex_get_jc (void) const
+  {
+    return const_cast<octave_idx_type *> (cidx ());
+  }
 
   Sparse<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
   Sparse<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-                 sortmode mode = ASCENDING) const;
+                  sortmode mode = ASCENDING) const;
 
   Sparse<T> diag (octave_idx_type k = 0) const;
 
   // dim = -1 and dim = -2 are special; see Array<T>::cat description.
   static Sparse<T>
   cat (int dim, octave_idx_type n, const Sparse<T> *sparse_list);
 
   Array<T> array_value (void) const;
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/SparseCmplxCHOL.cc
--- a/liboctave/SparseCmplxCHOL.cc
+++ b/liboctave/SparseCmplxCHOL.cc
@@ -47,22 +47,22 @@ chol2inv (const SparseComplexMatrix& r)
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseComplexMatrix rinv;
 
       if (typ == MatrixType::Upper)
         {
           rinv = r.inverse(mattype, info, rcond, true, false);
-          retval = rinv.transpose() * rinv;
+          retval = rinv.transpose () * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
-          rinv = r.transpose().inverse(mattype, info, rcond, true, false);
-          retval = rinv.transpose() * rinv;
+          rinv = r.transpose ().inverse(mattype, info, rcond, true, false);
+          retval = rinv.transpose () * rinv;
         }
       else
         (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
 
diff --git a/liboctave/SparseCmplxCHOL.h b/liboctave/SparseCmplxCHOL.h
--- a/liboctave/SparseCmplxCHOL.h
+++ b/liboctave/SparseCmplxCHOL.h
@@ -56,17 +56,17 @@ public:
     {
       if (this != &a)
         sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix> ::
           operator = (a);
 
       return *this;
     }
 
-  SparseComplexMatrix chol_matrix (void) const { return R(); }
+  SparseComplexMatrix chol_matrix (void) const { return R (); }
 
   SparseComplexMatrix L (void) const
     { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: L (); }
 
   SparseComplexMatrix R (void) const
     { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: R (); }
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -52,17 +52,17 @@ SparseComplexLU::SparseComplexLU (const 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_ZNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
-  if (piv_thres.nelem() == 2)
+  if (piv_thres.nelem () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
       if (!xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
       if (!xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
@@ -218,22 +218,22 @@ SparseComplexLU::SparseComplexLU (const 
                   Lfact = Lfact.transpose ();
 
                   if (do_recip)
                     for (octave_idx_type i = 0; i < nr; i++)
                       Rx[i] = 1.0 / Rx[i];
 
                   UMFPACK_ZNAME (report_matrix) (nr, n_inner,
                                             Lfact.cidx (), Lfact.ridx (),
-                                            reinterpret_cast<double *> (Lfact.data()),
+                                            reinterpret_cast<double *> (Lfact.data ()),
                                             0, 1, control);
 
                   UMFPACK_ZNAME (report_matrix) (n_inner, nc,
                                             Ufact.cidx (), Ufact.ridx (),
-                                            reinterpret_cast<double *> (Ufact.data()),
+                                            reinterpret_cast<double *> (Ufact.data ()),
                                             0, 1, control);
                   UMFPACK_ZNAME (report_perm) (nr, p, control);
                   UMFPACK_ZNAME (report_perm) (nc, q, control);
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
             }
         }
@@ -261,17 +261,17 @@ SparseComplexLU::SparseComplexLU (const 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_ZNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
-      if (piv_thres.nelem() == 2)
+      if (piv_thres.nelem () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
           if (!xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
           if (!xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
@@ -447,23 +447,23 @@ SparseComplexLU::SparseComplexLU (const 
 
                       if (do_recip)
                         for (octave_idx_type i = 0; i < nr; i++)
                           Rx[i] = 1.0 / Rx[i];
 
                       UMFPACK_ZNAME (report_matrix) (nr, n_inner,
                                                 Lfact.cidx (),
                                                 Lfact.ridx (),
-                                                reinterpret_cast<double *> (Lfact.data()),
+                                                reinterpret_cast<double *> (Lfact.data ()),
                                                 0, 1, control);
 
                       UMFPACK_ZNAME (report_matrix) (n_inner, nc,
                                                 Ufact.cidx (),
                                                 Ufact.ridx (),
-                                                reinterpret_cast<double *> (Ufact.data()),
+                                                reinterpret_cast<double *> (Ufact.data ()),
                                                 0, 1, control);
                       UMFPACK_ZNAME (report_perm) (nr, p, control);
                       UMFPACK_ZNAME (report_perm) (nc, q, control);
                     }
 
                   UMFPACK_ZNAME (report_info) (control, info);
                 }
             }
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -187,24 +187,24 @@ SparseComplexQR::SparseComplexQR_rep::R 
   return SparseComplexMatrix ();
 #endif
 }
 
 ComplexMatrix
 SparseComplexQR::SparseComplexQR_rep::C (const ComplexMatrix &b) const
 {
 #ifdef HAVE_CXSPARSE
-  octave_idx_type b_nr = b.rows();
-  octave_idx_type b_nc = b.cols();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   const cs_complex_t *bvec =
-    reinterpret_cast<const cs_complex_t *>(b.fortran_vec());
+    reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
   ComplexMatrix ret(b_nr, b_nc);
-  Complex *vec = ret.fortran_vec();
+  Complex *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
@@ -240,17 +240,17 @@ SparseComplexQR::SparseComplexQR_rep::C 
 
 ComplexMatrix
 SparseComplexQR::SparseComplexQR_rep::Q (void) const
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   ComplexMatrix ret(nr, nr);
-  Complex *vec = ret.fortran_vec();
+  Complex *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0)
     ret = ComplexMatrix (nc, nr, Complex (0.0, 0.0));
   else
     {
       OCTAVE_C99_COMPLEX (bvec, nr);
       for (octave_idx_type i = 0; i < nr; i++)
@@ -289,127 +289,127 @@ SparseComplexQR::SparseComplexQR_rep::Q 
 #endif
 }
 
 ComplexMatrix
 qrsolve(const SparseComplexMatrix&a, const Matrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec());
-      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
+        (x.fortran_vec ());
+      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
-          CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
+          CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
-      SparseComplexMatrix at = a.hermitian();
+      SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec());
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+        (x.fortran_vec ());
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N()->B [i];
+        B[i] = q.N ()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
-                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
-          CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+          CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
@@ -417,70 +417,70 @@ qrsolve(const SparseComplexMatrix&a, con
 #endif
 }
 
 SparseComplexMatrix
 qrsolve(const SparseComplexMatrix&a, const SparseMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+            (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
+            (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -497,73 +497,73 @@ qrsolve(const SparseComplexMatrix&a, con
                 }
             }
           x.xcidx(i+1) = ii;
         }
       info = 0;
     }
   else
     {
-      SparseComplexMatrix at = a.hermitian();
+      SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
 
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N()->B [i];
+        B[i] = q.N ()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
-                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+            (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
+            (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -591,120 +591,120 @@ qrsolve(const SparseComplexMatrix&a, con
 #endif
 }
 
 ComplexMatrix
 qrsolve(const SparseComplexMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   const cs_complex_t *bvec =
-    reinterpret_cast<const cs_complex_t *>(b.fortran_vec());
+    reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec());
-      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
+        (x.fortran_vec ());
+      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
+          CXSPARSE_ZNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
 #else
-          CXSPARSE_ZNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
+          CXSPARSE_ZNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
-          CXSPARSE_ZNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
+          CXSPARSE_ZNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
-      SparseComplexMatrix at = a.hermitian();
+      SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec());
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+        (x.fortran_vec ());
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N()->B [i];
+        B[i] = q.N ()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
+          CXSPARSE_ZNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
 #else
-          CXSPARSE_ZNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
+          CXSPARSE_ZNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
 #endif
-          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
-                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
+          CXSPARSE_ZNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
-          CXSPARSE_ZNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+          CXSPARSE_ZNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
@@ -712,70 +712,70 @@ qrsolve(const SparseComplexMatrix&a, con
 #endif
 }
 
 SparseComplexMatrix
 qrsolve(const SparseComplexMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_C99_COMPLEX (buf, q.S()->m2);
+      OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec)
-            (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+            (q.S ()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_ipvec)
-            (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
+            (nc, q.S ()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -792,72 +792,72 @@ qrsolve(const SparseComplexMatrix&a, con
                 }
             }
           x.xcidx(i+1) = ii;
         }
       info = 0;
     }
   else
     {
-      SparseComplexMatrix at = a.hermitian();
+      SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_C99_COMPLEX (buf, nbuf);
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = q.N()->B [i];
+        B[i] = q.N ()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
-        B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
+        B[i] = conj (reinterpret_cast<Complex *>(q.N ()->B) [i]);
 #endif
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
+            (q.S ()->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nr, q.S()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
+            (nr, q.S ()->Q, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
-          CXSPARSE_ZNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_ZNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
-              CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
+              CXSPARSE_ZNAME (_happly) (q.N ()->L, j, B[j], buf);
 #else
               CXSPARSE_ZNAME (_happly)
-                (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
+                (q.N ()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec)
-            (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
+            (q.S ()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
           CXSPARSE_ZNAME (_pvec)
-            (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
+            (nc, q.S ()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
                 {
diff --git a/liboctave/SparseCmplxQR.h b/liboctave/SparseCmplxQR.h
--- a/liboctave/SparseCmplxQR.h
+++ b/liboctave/SparseCmplxQR.h
@@ -82,17 +82,17 @@ protected:
     SparseComplexQR_rep operator = (const SparseComplexQR_rep&);
 
   };
 private:
   SparseComplexQR_rep *rep;
 
 public:
   SparseComplexQR (void) :
-    rep (new SparseComplexQR_rep (SparseComplexMatrix(), 0)) { }
+    rep (new SparseComplexQR_rep (SparseComplexMatrix (), 0)) { }
 
   SparseComplexQR (const SparseComplexMatrix& a, int order = 0) :
     rep (new SparseComplexQR_rep (a, order)) { }
 
   SparseComplexQR (const SparseComplexQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseComplexQR (void)
     {
@@ -108,30 +108,30 @@ public:
             delete rep;
 
           rep = a.rep;
           rep->count++;
         }
       return *this;
     }
 
-  bool ok (void) const { return rep->ok(); }
+  bool ok (void) const { return rep->ok (); }
 
-  SparseComplexMatrix V (void) const { return rep->V(); }
+  SparseComplexMatrix V (void) const { return rep->V (); }
 
-  ColumnVector Pinv (void) const { return rep->P(); }
+  ColumnVector Pinv (void) const { return rep->P (); }
 
-  ColumnVector P (void) const { return rep->P(); }
+  ColumnVector P (void) const { return rep->P (); }
 
   SparseComplexMatrix R (const bool econ = false) const
     { return rep->R(econ); }
 
   ComplexMatrix C (const ComplexMatrix &b) const { return rep->C(b); }
 
-  ComplexMatrix Q (void) const { return rep->Q(); }
+  ComplexMatrix Q (void) const { return rep->Q (); }
 
   friend ComplexMatrix qrsolve (const SparseComplexMatrix &a, const Matrix &b,
                                 octave_idx_type &info);
 
   friend SparseComplexMatrix qrsolve (const SparseComplexMatrix &a,
                                       const SparseMatrix &b,
                                       octave_idx_type &info);
 
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -169,23 +169,23 @@ SparseQR::SparseQR_rep::R (const bool ec
   return SparseMatrix ();
 #endif
 }
 
 Matrix
 SparseQR::SparseQR_rep::C (const Matrix &b) const
 {
 #ifdef HAVE_CXSPARSE
-  octave_idx_type b_nr = b.rows();
-  octave_idx_type b_nc = b.cols();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
-  const double *bvec = b.fortran_vec();
+  const double *bvec = b.fortran_vec ();
   Matrix ret (b_nr, b_nc);
-  double *vec = ret.fortran_vec();
+  double *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     ret = Matrix (nc, b_nc, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
@@ -221,17 +221,17 @@ SparseQR::SparseQR_rep::C (const Matrix 
 
 Matrix
 SparseQR::SparseQR_rep::Q (void) const
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   Matrix ret (nr, nr);
-  double *vec = ret.fortran_vec();
+  double *vec = ret.fortran_vec ();
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0)
     ret = Matrix (nc, nr, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, bvec, nr + 1);
       for (octave_idx_type i = 0; i < nr; i++)
@@ -270,103 +270,103 @@ SparseQR::SparseQR_rep::Q (void) const
 #endif
 }
 
 Matrix
 qrsolve(const SparseMatrix&a, const Matrix &b, octave_idx_type& info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
-  const double *bvec = b.fortran_vec();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  const double *bvec = b.fortran_vec ();
   Matrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = Matrix (nc, b_nc, 0.0);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
-        return Matrix();
+        return Matrix ();
       x.resize(nc, b_nc);
-      double *vec = x.fortran_vec();
-      OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
+      double *vec = x.fortran_vec ();
+      OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, bvec + bidx, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, bvec + bidx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, bvec + bidx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, vec + idx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, vec + idx, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, vec + idx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
   else
     {
-      SparseMatrix at = a.hermitian();
+      SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
-        return Matrix();
+        return Matrix ();
       x.resize(nc, b_nc);
-      double *vec = x.fortran_vec();
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      double *vec = x.fortran_vec ();
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, bvec + bidx, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, bvec + bidx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, bvec + bidx, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, vec + idx, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, vec + idx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, vec + idx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
       info = 0;
     }
 
   return x;
 #else
@@ -374,66 +374,66 @@ qrsolve(const SparseMatrix&a, const Matr
 #endif
 }
 
 SparseMatrix
 qrsolve(const SparseMatrix&a, const SparseMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nr = b.rows();
-  octave_idx_type b_nc = b.cols();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
   SparseMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
-        return SparseMatrix();
-      x = SparseMatrix (nc, b_nc, b.nnz());
+        return SparseMatrix ();
+      x = SparseMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               double tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -450,54 +450,54 @@ qrsolve(const SparseMatrix&a, const Spar
                 }
             }
           x.xcidx(i+1) = ii;
         }
       info = 0;
     }
   else
     {
-      SparseMatrix at = a.hermitian();
+      SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
-        return SparseMatrix();
-      x = SparseMatrix (nc, b_nc, b.nnz());
+        return SparseMatrix ();
+      x = SparseMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               double tmp = Xx[j];
               if (tmp != 0.0)
                 {
@@ -525,164 +525,164 @@ qrsolve(const SparseMatrix&a, const Spar
 #endif
 }
 
 ComplexMatrix
 qrsolve(const SparseMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nc = b.cols();
-  octave_idx_type b_nr = b.rows();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
-      Complex *vec = x.fortran_vec();
+      Complex *vec = x.fortran_vec ();
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
       info = 0;
     }
   else
     {
-      SparseMatrix at = a.hermitian();
+      SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
-        return ComplexMatrix();
+        return ComplexMatrix ();
       x.resize(nc, b_nc);
-      Complex *vec = x.fortran_vec();
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      Complex *vec = x.fortran_vec ();
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = 0; j < nc; j++)
             vec[j+idx] = Complex (Xx[j], Xz[j]);
         }
       info = 0;
     }
 
@@ -692,95 +692,95 @@ qrsolve(const SparseMatrix&a, const Comp
 #endif
 }
 
 SparseComplexMatrix
 qrsolve(const SparseMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
-  octave_idx_type nr = a.rows();
-  octave_idx_type nc = a.cols();
-  octave_idx_type b_nr = b.rows();
-  octave_idx_type b_nc = b.cols();
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
   SparseComplexMatrix x;
   volatile octave_idx_type ii, x_nz;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
-      OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
+      OCTAVE_LOCAL_BUFFER (double, buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xx, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xx, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xx, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xx, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xx);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          for (octave_idx_type j = nr; j < q.S()->m2; j++)
+          for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->pinv, Xz, buf, nr);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->pinv, Xz, buf, nr);
 #else
-          CXSPARSE_DNAME (_ipvec) (nr, q.S()->Pinv, Xz, buf);
+          CXSPARSE_DNAME (_ipvec) (nr, q.S ()->Pinv, Xz, buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CXSPARSE_DNAME (_usolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_usolve) (q.N ()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_ipvec) (q.S()->q, buf, Xz, nc);
+          CXSPARSE_DNAME (_ipvec) (q.S ()->q, buf, Xz, nc);
 #else
-          CXSPARSE_DNAME (_ipvec) (nc, q.S()->Q, buf, Xz);
+          CXSPARSE_DNAME (_ipvec) (nc, q.S ()->Q, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Complex (Xx[j], Xz[j]);
               if (tmp != 0.0)
                 {
@@ -797,83 +797,83 @@ qrsolve(const SparseMatrix&a, const Spar
                 }
             }
           x.xcidx(i+1) = ii;
         }
       info = 0;
     }
   else
     {
-      SparseMatrix at = a.hermitian();
+      SparseMatrix at = a.hermitian ();
       SparseQR q (at, 3);
       if (! q.ok ())
-        return SparseComplexMatrix();
-      x = SparseComplexMatrix (nc, b_nc, b.nnz());
+        return SparseComplexMatrix ();
+      x = SparseComplexMatrix (nc, b_nc, b.nnz ());
       x.xcidx(0) = 0;
-      x_nz = b.nnz();
+      x_nz = b.nnz ();
       ii = 0;
-      volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
+      volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             {
               Complex c = b.xelem (j,i);
               Xx[j] = std::real (c);
               Xz[j] = std::imag (c);
             }
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xx, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xx, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xx, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xx, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xx, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xx, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xx);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xx);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->q, Xz, buf, nr);
+          CXSPARSE_DNAME (_pvec) (q.S ()->q, Xz, buf, nr);
 #else
-          CXSPARSE_DNAME (_pvec) (nr, q.S()->Q, Xz, buf);
+          CXSPARSE_DNAME (_pvec) (nr, q.S ()->Q, Xz, buf);
 #endif
-          CXSPARSE_DNAME (_utsolve) (q.N()->U, buf);
+          CXSPARSE_DNAME (_utsolve) (q.N ()->U, buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_DNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
+              CXSPARSE_DNAME (_happly) (q.N ()->L, j, q.N ()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_DNAME (_pvec) (q.S()->pinv, buf, Xz, nc);
+          CXSPARSE_DNAME (_pvec) (q.S ()->pinv, buf, Xz, nc);
 #else
-          CXSPARSE_DNAME (_pvec) (nc, q.S()->Pinv, buf, Xz);
+          CXSPARSE_DNAME (_pvec) (nc, q.S ()->Pinv, buf, Xz);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Complex (Xx[j], Xz[j]);
               if (tmp != 0.0)
                 {
diff --git a/liboctave/SparseQR.h b/liboctave/SparseQR.h
--- a/liboctave/SparseQR.h
+++ b/liboctave/SparseQR.h
@@ -84,17 +84,17 @@ protected:
   };
 
 private:
 
   SparseQR_rep *rep;
 
 public:
 
-  SparseQR (void) : rep (new SparseQR_rep (SparseMatrix(), 0)) { }
+  SparseQR (void) : rep (new SparseQR_rep (SparseMatrix (), 0)) { }
 
   SparseQR (const SparseMatrix& a, int order = 0) :
     rep (new SparseQR_rep (a, order)) { }
 
   SparseQR (const SparseQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseQR (void)
     {
@@ -110,29 +110,29 @@ public:
             delete rep;
 
           rep = a.rep;
           rep->count++;
         }
       return *this;
     }
 
-  bool ok (void) const { return rep->ok(); }
+  bool ok (void) const { return rep->ok (); }
 
-  SparseMatrix V (void) const { return rep->V(); }
+  SparseMatrix V (void) const { return rep->V (); }
 
-  ColumnVector Pinv (void) const { return rep->P(); }
+  ColumnVector Pinv (void) const { return rep->P (); }
 
-  ColumnVector P (void) const { return rep->P(); }
+  ColumnVector P (void) const { return rep->P (); }
 
   SparseMatrix R (const bool econ = false) const { return rep->R(econ); }
 
   Matrix C (const Matrix &b) const { return rep->C(b); }
 
-  Matrix Q (void) const { return rep->Q(); }
+  Matrix Q (void) const { return rep->Q (); }
 
   friend Matrix qrsolve (const SparseMatrix &a, const Matrix &b,
                          octave_idx_type &info);
 
   friend SparseMatrix qrsolve (const SparseMatrix &a, const SparseMatrix &b,
                          octave_idx_type &info);
 
   friend ComplexMatrix qrsolve (const SparseMatrix &a, const ComplexMatrix &b,
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/SparsedbleCHOL.cc
--- a/liboctave/SparsedbleCHOL.cc
+++ b/liboctave/SparsedbleCHOL.cc
@@ -47,22 +47,22 @@ chol2inv (const SparseMatrix& r)
       int typ = mattype.type (false);
       double rcond;
       octave_idx_type info;
       SparseMatrix rinv;
 
       if (typ == MatrixType::Upper)
         {
           rinv = r.inverse(mattype, info, rcond, true, false);
-          retval = rinv.transpose() * rinv;
+          retval = rinv.transpose () * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
-          rinv = r.transpose().inverse(mattype, info, rcond, true, false);
-          retval = rinv.transpose() * rinv;
+          rinv = r.transpose ().inverse(mattype, info, rcond, true, false);
+          retval = rinv.transpose () * rinv;
         }
       else
         (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
 
diff --git a/liboctave/SparsedbleCHOL.h b/liboctave/SparsedbleCHOL.h
--- a/liboctave/SparsedbleCHOL.h
+++ b/liboctave/SparsedbleCHOL.h
@@ -50,17 +50,17 @@ public:
   SparseCHOL& operator = (const SparseCHOL& a)
     {
       if (this != &a)
         sparse_base_chol <SparseMatrix, double, SparseMatrix> :: operator = (a);
 
       return *this;
     }
 
-  SparseMatrix chol_matrix (void) const { return R(); }
+  SparseMatrix chol_matrix (void) const { return R (); }
 
   SparseMatrix L (void) const
   { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: L (); }
 
   SparseMatrix R (void) const
     { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: R (); }
 
   octave_idx_type P (void) const
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -52,17 +52,17 @@ SparseLU::SparseLU (const SparseMatrix& 
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_DNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
 
-  if (piv_thres.nelem() == 2)
+  if (piv_thres.nelem () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
       if (!xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
       if (!xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
@@ -248,17 +248,17 @@ SparseLU::SparseLU (const SparseMatrix& 
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_DNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
-      if (piv_thres.nelem() == 2)
+      if (piv_thres.nelem () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
           if (!xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
           if (!xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
diff --git a/liboctave/SparsedbleLU.h b/liboctave/SparsedbleLU.h
--- a/liboctave/SparsedbleLU.h
+++ b/liboctave/SparsedbleLU.h
@@ -31,21 +31,21 @@ class
 OCTAVE_API
 SparseLU : public sparse_base_lu <SparseMatrix, double, SparseMatrix, double>
 {
 public:
 
   SparseLU (void)
     : sparse_base_lu <SparseMatrix, double, SparseMatrix, double> () { }
 
-  SparseLU (const SparseMatrix& a, const Matrix& piv_thres = Matrix(),
+  SparseLU (const SparseMatrix& a, const Matrix& piv_thres = Matrix (),
             bool scale = false);
 
   SparseLU (const SparseMatrix& a, const ColumnVector& Qinit,
-            const Matrix& piv_thres = Matrix(), bool scale = false,
+            const Matrix& piv_thres = Matrix (), bool scale = false,
             bool FixedQ = false, double droptol = -1.,
             bool milu = false, bool udiag = false);
 
   SparseLU (const SparseLU& a)
     : sparse_base_lu <SparseMatrix, double, SparseMatrix, double> (a) { }
 
   SparseLU& operator = (const SparseLU& a)
     {
diff --git a/liboctave/base-lu.cc b/liboctave/base-lu.cc
--- a/liboctave/base-lu.cc
+++ b/liboctave/base-lu.cc
@@ -106,34 +106,34 @@ base_lu <lu_type> :: U (void) const
     return a_fact;
 }
 
 template <class lu_type>
 lu_type
 base_lu <lu_type> :: Y (void) const
 {
   if (! packed ())
-    (*current_liboctave_error_handler) ("lu: Y() not implemented for unpacked form");
+    (*current_liboctave_error_handler) ("lu: Y () not implemented for unpacked form");
   return a_fact;
 }
 
 template <class lu_type>
 Array<octave_idx_type>
 base_lu <lu_type> :: getp (void) const
 {
   if (packed ())
     {
       octave_idx_type a_nr = a_fact.rows ();
 
       Array<octave_idx_type> pvt (dim_vector (a_nr, 1));
 
       for (octave_idx_type i = 0; i < a_nr; i++)
         pvt.xelem (i) = i;
 
-      for (octave_idx_type i = 0; i < ipvt.length(); i++)
+      for (octave_idx_type i = 0; i < ipvt.length (); i++)
         {
           octave_idx_type k = ipvt.xelem (i);
 
           if (k != i)
             {
               octave_idx_type tmp = pvt.xelem (k);
               pvt.xelem (k) = pvt.xelem (i);
               pvt.xelem (i) = tmp;
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -160,25 +160,25 @@ gnu_history::do_histcontrol (void) const
 
   std::string retval;
 
   if (history_control & HC_IGNSPACE)
     retval.append ("ignorespace");
 
   if (history_control & HC_IGNDUPS)
     {
-      if (retval.length() > 0)
+      if (retval.length () > 0)
         retval.append (":");
 
       retval.append ("ignoredups");
     }
 
   if (history_control & HC_ERASEDUPS)
     {
-      if (retval.length() > 0)
+      if (retval.length () > 0)
         retval.append (":");
 
       retval.append ("erasedups");
     }
 
   return retval;
 }
 
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -138,17 +138,17 @@ ColumnVector::stack (const ColumnVector&
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 RowVector
 ColumnVector::transpose (void) const
 {
-  return MArray<double>::transpose();
+  return MArray<double>::transpose ();
 }
 
 ColumnVector
 ColumnVector::abs (void) const
 {
   return do_mx_unary_map<double, double, std::abs> (*this);
 }
 
@@ -303,17 +303,17 @@ operator << (std::ostream& os, const Col
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ColumnVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -69,17 +69,17 @@ public:
 
   DiagMatrix& fill (double val);
   DiagMatrix& fill (double val, octave_idx_type beg, octave_idx_type end);
   DiagMatrix& fill (const ColumnVector& a);
   DiagMatrix& fill (const RowVector& a);
   DiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
   DiagMatrix& fill (const RowVector& a, octave_idx_type beg);
 
-  DiagMatrix transpose (void) const { return MDiagArray2<double>::transpose(); }
+  DiagMatrix transpose (void) const { return MDiagArray2<double>::transpose (); }
   DiagMatrix abs (void) const;
 
   friend OCTAVE_API DiagMatrix real (const ComplexDiagMatrix& a);
   friend OCTAVE_API DiagMatrix imag (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   Matrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -758,17 +758,17 @@ Matrix::finverse (MatrixType &mattype, o
       z.resize (dim_vector (lwork, 1));
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond)
-        anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -797,17 +797,17 @@ Matrix::finverse (MatrixType &mattype, o
           F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, dgetri_info));
 
           if (dgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
-        mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 Matrix
 Matrix::inverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                  int force, int calc_cond) const
@@ -1456,18 +1456,18 @@ Matrix::rcond (MatrixType &mattype) cons
           double anorm = -1.0;
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+              anorm = atmp.abs ().sum ().
+                row(static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1494,18 +1494,18 @@ Matrix::rcond (MatrixType &mattype) cons
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
-                anorm = atmp.abs().sum().
-                  row(static_cast<octave_idx_type>(0)).max();
+                anorm = atmp.abs ().sum ().
+                  row(static_cast<octave_idx_type>(0)).max ();
 
               Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1757,17 +1757,17 @@ Matrix::fsolve (MatrixType &mattype, con
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1813,17 +1813,17 @@ Matrix::fsolve (MatrixType &mattype, con
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (dpotrs, DPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows(), info
+                                             result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -1834,17 +1834,17 @@ Matrix::fsolve (MatrixType &mattype, con
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
           if(anorm < 0.)
-            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           Array<double> z (dim_vector (4 * nc, 1));
           double *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1897,17 +1897,17 @@ Matrix::fsolve (MatrixType &mattype, con
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows(), info
+                                             pipvt, result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -155,44 +155,44 @@ NDArray::ifourier (int dim) const
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const double *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   ComplexNDArray retval (*this);
   Complex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (out + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
@@ -281,17 +281,17 @@ NDArray::fourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+            retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
@@ -328,28 +328,28 @@ NDArray::ifourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+            retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<double> (npts);
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
@@ -369,35 +369,35 @@ NDArray::fourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
@@ -417,22 +417,22 @@ NDArray::ifourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<double> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -465,22 +465,22 @@ NDArray::fourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -512,22 +512,22 @@ NDArray::ifourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<double> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -141,17 +141,17 @@ RowVector::append (const RowVector& a) c
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 ColumnVector
 RowVector::transpose (void) const
 {
-  return MArray<double>::transpose();
+  return MArray<double>::transpose ();
 }
 
 RowVector
 real (const ComplexRowVector& a)
 {
   return do_mx_unary_op<double, Complex> (a, mx_inline_real);
 }
 
@@ -266,17 +266,17 @@ operator << (std::ostream& os, const Row
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, RowVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -714,17 +714,17 @@ atan2 (const SparseMatrix& x, const doub
     return retval;
 }
 
 SparseMatrix
 atan2 (const SparseMatrix& x, const SparseMatrix& y)
 {
   SparseMatrix r;
 
-  if ((x.rows() == y.rows()) && (x.cols() == y.cols()))
+  if ((x.rows () == y.rows ()) && (x.cols () == y.cols ()))
     {
       octave_idx_type x_nr = x.rows ();
       octave_idx_type x_nc = x.cols ();
 
       octave_idx_type y_nr = y.rows ();
       octave_idx_type y_nc = y.cols ();
 
       if (x_nr != y_nr || x_nc != y_nc)
@@ -832,22 +832,22 @@ SparseMatrix::dinverse (MatrixType &matt
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           if (typ == MatrixType::Permuted_Diagonal)
-            retval = transpose();
+            retval = transpose ();
           else
             retval = *this;
 
           // Force make_unique to be called
-          double *v = retval.data();
+          double *v = retval.data ();
 
           if (calccond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   double tmp = fabs(v[i]);
                   if (tmp > dmax)
@@ -1017,17 +1017,17 @@ SparseMatrix::tinverse (MatrixType &matt
               octave_idx_type nz = nnz ();
               octave_idx_type cx = 0;
               octave_idx_type nz2 = nz;
               retval = SparseMatrix (nr, nc, nz2);
 
               OCTAVE_LOCAL_BUFFER (double, work, nr);
               OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
-              octave_idx_type *perm = mattyp.triangular_perm();
+              octave_idx_type *perm = mattyp.triangular_perm ();
               if (typ == MatrixType::Permuted_Upper)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     rperm[perm[i]] = i;
                 }
               else
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
@@ -1137,77 +1137,77 @@ SparseMatrix::tinverse (MatrixType &matt
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
  inverse_singular:
-  return SparseMatrix();
+  return SparseMatrix ();
 }
 
 SparseMatrix
 SparseMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                        double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     ret = dinverse (mattype, info, rcond, true, calc_cond);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    ret = tinverse (mattype, info, rcond, true, calc_cond).transpose();
+    ret = tinverse (mattype, info, rcond, true, calc_cond).transpose ();
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     {
-      MatrixType newtype = mattype.transpose();
-      ret = transpose().tinverse (newtype, info, rcond, true, calc_cond);
+      MatrixType newtype = mattype.transpose ();
+      ret = transpose ().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
-      if (mattype.is_hermitian())
+      if (mattype.is_hermitian ())
         {
           MatrixType tmp_typ (MatrixType::Upper);
           SparseCHOL fact (*this, info, false);
-          rcond = fact.rcond();
+          rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
-              SparseMatrix Q = fact.Q();
-              SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ,
+              SparseMatrix Q = fact.Q ();
+              SparseMatrix InvL = fact.L ().transpose ().tinverse(tmp_typ,
                                            info, rcond2, true, false);
-              ret = Q * InvL.transpose() * InvL * Q.transpose();
+              ret = Q * InvL.transpose () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
         }
 
-      if (!mattype.is_hermitian())
+      if (!mattype.is_hermitian ())
         {
-          octave_idx_type n = rows();
+          octave_idx_type n = rows ();
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
-          SparseLU fact (*this, Qinit, Matrix(), false, false);
-          rcond = fact.rcond();
+          SparseLU fact (*this, Qinit, Matrix (), false, false);
+          rcond = fact.rcond ();
           double rcond2;
-          SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ,
+          SparseMatrix InvL = fact.L ().transpose ().tinverse(tmp_typ,
                                            info, rcond2, true, false);
-          SparseMatrix InvU = fact.U().tinverse(tmp_typ, info, rcond2,
-                                           true, false).transpose();
-          ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
+          SparseMatrix InvU = fact.U ().tinverse(tmp_typ, info, rcond2,
+                                           true, false).transpose ();
+          ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
 DET
 SparseMatrix::determinant (void) const
@@ -1361,23 +1361,23 @@ SparseMatrix::dsolve (MatrixType &mattyp
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols(), 0.);
+          retval.resize (nc, b.cols (), 0.);
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
@@ -1511,23 +1511,23 @@ SparseMatrix::dsolve (MatrixType &mattyp
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
-          retval.resize (nc, b.cols(), 0);
+          retval.resize (nc, b.cols (), 0);
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
 
           if (calc_cond)
             {
               double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
@@ -1578,29 +1578,29 @@ SparseMatrix::dsolve (MatrixType &mattyp
         {
           octave_idx_type b_nc = b.cols ();
           octave_idx_type b_nz = b.nnz ();
           retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
           retval.xcidx(0) = 0;
           octave_idx_type ii = 0;
           if (typ == MatrixType::Diagonal)
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
                   {
                     if (b.ridx(i) >= nm)
                       break;
                     retval.xridx (ii) = b.ridx(i);
                     retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
                   }
                 retval.xcidx(j+1) = ii;
               }
           else
-            for (octave_idx_type j = 0; j < b.cols(); j++)
+            for (octave_idx_type j = 0; j < b.cols (); j++)
               {
                 for (octave_idx_type l = 0; l < nc; l++)
                   for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
                     {
                       bool found = false;
                       octave_idx_type k;
                       for (k = b.cidx(j); k < b.cidx(j+1); k++)
                         if (ridx(i) == b.ridx(k))
@@ -2778,17 +2778,17 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                               octave_idx_type iidx = perm[ridx(i)];
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (i, j) = work[i];
+                    retval(i, j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
@@ -3344,17 +3344,17 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                               octave_idx_type iidx = perm[ridx(i)];
                               cwork[iidx] = cwork[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (i, j) = cwork[i];
+                    retval(i, j) = cwork[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
@@ -3884,22 +3884,22 @@ SparseMatrix::trisolve (MatrixType &matt
                   {
                     if (ridx(i) == j)
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result,
-                                   b.rows(), err));
+                                   b.rows (), err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
           else
@@ -3941,22 +3941,22 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result,
-                                   b.rows(), err));
+                                   b.rows (), err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4183,17 +4183,17 @@ SparseMatrix::trisolve (MatrixType &matt
                     if (ridx(i) == j)
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
 
           octave_idx_type b_nr = b.rows ();
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
                                    b_nr, err));
 
@@ -4240,18 +4240,18 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
-          octave_idx_type b_nr = b.rows();
-          octave_idx_type b_nc = b.cols();
+          octave_idx_type b_nr = b.rows ();
+          octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
           F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
                                    b_nr, err));
 
@@ -4501,17 +4501,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -4565,17 +4565,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (dpbtrs, DPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
-                             ldm, result, b.rows(), err
+                             ldm, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
@@ -4688,17 +4688,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (dgbtrs, DGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, n_upper, b_nc, tmp_data,
-                             ldm, pipvt, result, b.rows(), err
+                             ldm, pipvt, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -4751,17 +4751,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5069,17 +5069,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5159,29 +5159,29 @@ SparseMatrix::bsolve (MatrixType &mattyp
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
-                                 ldm, Bz, b.rows(), err
+                                 ldm, Bz, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
-                        retval (i, j) = Complex (Bx[i], Bz[i]);
+                        retval(i, j) = Complex (Bx[i], Bz[i]);
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
@@ -5305,17 +5305,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bz, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       for (octave_idx_type i = 0; i < nr; i++)
-                        retval (i, j) = Complex (Bx[i], Bz[i]);
+                        retval(i, j) = Complex (Bx[i], Bz[i]);
                     }
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -5368,17 +5368,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 octave_idx_type ri = ridx (i);
                 if (ri >= j)
                   m_band(ri - j, j) = data(i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
-            anorm = m_band.abs().sum().row(0).max();
+            anorm = m_band.abs ().sum ().row(0).max ();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
@@ -5848,49 +5848,49 @@ SparseMatrix::fsolve (MatrixType &mattyp
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_dense Bstore;
           cholmod_dense *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
           B->d = B->nrow;
           B->nzmax = B->nrow * B->ncol;
           B->dtype = CHOLMOD_DOUBLE;
           B->xtype = CHOLMOD_REAL;
-          if (nc < 1 || b.cols() < 1)
+          if (nc < 1 || b.cols () < 1)
             B->x = &dummy;
           else
             // We won't alter it, honest :-)
-            B->x = const_cast<double *>(b.fortran_vec());
+            B->x = const_cast<double *>(b.fortran_vec ());
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -5925,21 +5925,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval.resize (b.rows (), b.cols());
-              for (octave_idx_type j = 0; j < b.cols(); j++)
-                {
-                  octave_idx_type jr = j * b.rows();
-                  for (octave_idx_type i = 0; i < b.rows(); i++)
+              retval.resize (b.rows (), b.cols ());
+              for (octave_idx_type j = 0; j < b.cols (); j++)
+                {
+                  octave_idx_type jr = j * b.rows ();
+                  for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem(i,j) = static_cast<double *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
@@ -5960,17 +5960,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
 #ifdef HAVE_UMFPACK
           Matrix Control, Info;
           void *Numeric =
             factorize (err, rcond, Control, Info, sing_handler, calc_cond);
 
           if (err == 0)
             {
               const double *Bx = b.fortran_vec ();
-              retval.resize (b.rows (), b.cols());
+              retval.resize (b.rows (), b.cols ());
               double *result = retval.fortran_vec ();
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               int status = 0;
               double *control = Control.fortran_vec ();
               double *info = Info.fortran_vec ();
               const octave_idx_type *Ap = cidx ();
               const octave_idx_type *Ai = ridx ();
@@ -6064,59 +6064,59 @@ SparseMatrix::fsolve (MatrixType &mattyp
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_sparse Bstore;
           cholmod_sparse *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
-          B->p = b.cidx();
-          B->i = b.ridx();
-          B->nzmax = b.nnz();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
+          B->p = b.cidx ();
+          B->i = b.ridx ();
+          B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
           B->nz = 0;
 #ifdef IDX_TYPE_LONG
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_REAL;
 
-          if (b.rows() < 1 || b.cols() < 1)
+          if (b.rows () < 1 || b.cols () < 1)
             B->x = &dummy;
           else
-            B->x = b.data();
+            B->x = b.data ();
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -6326,49 +6326,49 @@ SparseMatrix::fsolve (MatrixType &mattyp
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_dense Bstore;
           cholmod_dense *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
           B->d = B->nrow;
           B->nzmax = B->nrow * B->ncol;
           B->dtype = CHOLMOD_DOUBLE;
           B->xtype = CHOLMOD_COMPLEX;
-          if (nc < 1 || b.cols() < 1)
+          if (nc < 1 || b.cols () < 1)
             B->x = &dummy;
           else
             // We won't alter it, honest :-)
-            B->x = const_cast<Complex *>(b.fortran_vec());
+            B->x = const_cast<Complex *>(b.fortran_vec ());
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -6402,21 +6402,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval.resize (b.rows (), b.cols());
-              for (octave_idx_type j = 0; j < b.cols(); j++)
-                {
-                  octave_idx_type jr = j * b.rows();
-                  for (octave_idx_type i = 0; i < b.rows(); i++)
+              retval.resize (b.rows (), b.cols ());
+              for (octave_idx_type j = 0; j < b.cols (); j++)
+                {
+                  octave_idx_type jr = j * b.rows ();
+                  for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem(i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
               static char tmp[] = " ";
@@ -6482,17 +6482,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                       UMFPACK_DNAME (report_status) (control, status);
 
                       err = -1;
 
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
-                    retval (i, j) = Complex (Xx[i], Xz[i]);
+                    retval(i, j) = Complex (Xx[i], Xz[i]);
                 }
 
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
@@ -6560,59 +6560,59 @@ SparseMatrix::fsolve (MatrixType &mattyp
           cm->final_ll = true;
 
           cholmod_sparse Astore;
           cholmod_sparse *A = &Astore;
           double dummy;
           A->nrow = nr;
           A->ncol = nc;
 
-          A->p = cidx();
-          A->i = ridx();
-          A->nzmax = nnz();
+          A->p = cidx ();
+          A->i = ridx ();
+          A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
           A->nz = 0;
 #ifdef IDX_TYPE_LONG
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
 
           if (nr < 1)
             A->x = &dummy;
           else
-            A->x = data();
+            A->x = data ();
 
           cholmod_sparse Bstore;
           cholmod_sparse *B = &Bstore;
-          B->nrow = b.rows();
-          B->ncol = b.cols();
-          B->p = b.cidx();
-          B->i = b.ridx();
-          B->nzmax = b.nnz();
+          B->nrow = b.rows ();
+          B->ncol = b.cols ();
+          B->p = b.cidx ();
+          B->i = b.ridx ();
+          B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
           B->nz = 0;
 #ifdef IDX_TYPE_LONG
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_COMPLEX;
 
-          if (b.rows() < 1 || b.cols() < 1)
+          if (b.rows () < 1 || b.cols () < 1)
             B->x = &dummy;
           else
-            B->x = b.data();
+            B->x = b.data ();
 
           cholmod_factor *L;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           L = CHOLMOD_NAME(analyze) (A, cm);
           CHOLMOD_NAME(factorize) (A, L, cm);
           if (calc_cond)
             rcond = CHOLMOD_NAME(rcond)(L, cm);
           else
@@ -7490,18 +7490,18 @@ SparseMatrix
 SparseMatrix::cumsum (int dim) const
 {
   SPARSE_CUMSUM (SparseMatrix, double, cumsum);
 }
 
 SparseMatrix
 SparseMatrix::prod (int dim) const
 {
-  if ((rows() == 1 && dim == -1) || dim == 1)
-    return transpose (). prod (0). transpose();
+  if ((rows () == 1 && dim == -1) || dim == 1)
+    return transpose (). prod (0). transpose ();
   else
     {
       SPARSE_REDUCTION_OP (SparseMatrix, double, *=,
                            (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseMatrix
@@ -7760,17 +7760,17 @@ min (const SparseMatrix& m, double d)
   return min (d, m);
 }
 
 SparseMatrix
 min (const SparseMatrix& a, const SparseMatrix& b)
 {
   SparseMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
+  if ((a.rows () == b.rows ()) && (a.cols () == b.cols ()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
@@ -7910,17 +7910,17 @@ max (const SparseMatrix& m, double d)
   return max (d, m);
 }
 
 SparseMatrix
 max (const SparseMatrix& a, const SparseMatrix& b)
 {
   SparseMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
+  if ((a.rows () == b.rows ()) && (a.cols () == b.cols ()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -152,17 +152,17 @@ chol2inv_internal (const Matrix& r)
   octave_idx_type r_nc = r.cols ();
 
   if (r_nr == r_nc)
     {
       octave_idx_type n = r_nc;
       octave_idx_type info = 0;
 
       Matrix tmp = r;
-      double *v = tmp.fortran_vec();
+      double *v = tmp.fortran_vec ();
 
       if (info == 0)
         {
           F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
                                      v, n, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // If someone thinks of a more graceful way of doing this (or
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -65,17 +65,17 @@ GEPBALANCE::init (const Matrix& a, const
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
       return -1;
     }
 
-  if (a.dims() != b.dims ())
+  if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
diff --git a/liboctave/dim-vector.cc b/liboctave/dim-vector.cc
--- a/liboctave/dim-vector.cc
+++ b/liboctave/dim-vector.cc
@@ -40,17 +40,17 @@ dim_vector::dim_max (void)
 }
 
 void
 dim_vector::chop_all_singletons (void)
 {
   make_unique ();
 
   int j = 0;
-  int l = ndims();
+  int l = ndims ();
 
   for (int i = 0; i < l; i++)
     {
       if (rep[i] != 1)
         rep[j++] = rep[i];
     }
 
   if (j == 1)
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -221,24 +221,24 @@ lusolve (const SM& L, const SM& U, M& m)
 
   return err;
 }
 
 template <class SM, class M>
 static M
 ltsolve (const SM& L, const ColumnVector& Q, const M& m)
 {
-  octave_idx_type n = L.cols();
-  octave_idx_type b_nc = m.cols();
+  octave_idx_type n = L.cols ();
+  octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType ltyp (MatrixType::Lower);
   M tmp = L.solve (ltyp, m, err, rcond, 0);
   M retval;
-  const double* qv = Q.fortran_vec();
+  const double* qv = Q.fortran_vec ();
 
   if (!err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
         {
           for (octave_idx_type i = 0; i < n; i++)
             retval.elem(static_cast<octave_idx_type>(qv[i]), j)  =
@@ -248,24 +248,24 @@ ltsolve (const SM& L, const ColumnVector
 
   return retval;
 }
 
 template <class SM, class M>
 static M
 utsolve (const SM& U, const ColumnVector& Q, const M& m)
 {
-  octave_idx_type n = U.cols();
-  octave_idx_type b_nc = m.cols();
+  octave_idx_type n = U.cols ();
+  octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType utyp (MatrixType::Upper);
 
   M retval (n, b_nc);
-  const double* qv = Q.fortran_vec();
+  const double* qv = Q.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = 0; i < n; i++)
         retval.elem(i,j) = m.elem(static_cast<octave_idx_type>(qv[i]), j);
     }
   return U.solve (utyp, retval, err, rcond, 0);
 }
 
@@ -342,120 +342,120 @@ vector_product (const ComplexMatrix& m, 
     return true;
 }
 
 static bool
 make_cholb (Matrix& b, Matrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
   CHOL fact (b, info);
-  octave_idx_type n = b.cols();
+  octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
-      b =  bt.transpose();
+      b =  bt.transpose ();
       permB = ColumnVector(n);
       for (octave_idx_type i = 0; i < n; i++)
         permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseMatrix& b, SparseMatrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
   SparseCHOL fact (b, info, false);
 
-  if (fact.P() != 0)
+  if (fact.P () != 0)
     return false;
   else
     {
-      b = fact.L();
-      bt = b.transpose();
-      permB = fact.perm() - 1.0;
+      b = fact.L ();
+      bt = b.transpose ();
+      permB = fact.perm () - 1.0;
       return true;
     }
 }
 
 static bool
 make_cholb (ComplexMatrix& b, ComplexMatrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
   ComplexCHOL fact (b, info);
-  octave_idx_type n = b.cols();
+  octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
-      b =  bt.hermitian();
+      b =  bt.hermitian ();
       permB = ColumnVector(n);
       for (octave_idx_type i = 0; i < n; i++)
         permB(i) = i;
       return true;
     }
 }
 
 static bool
 make_cholb (SparseComplexMatrix& b, SparseComplexMatrix& bt,
             ColumnVector& permB)
 {
   octave_idx_type info;
   SparseComplexCHOL fact (b, info, false);
 
-  if (fact.P() != 0)
+  if (fact.P () != 0)
     return false;
   else
     {
-      b = fact.L();
-      bt = b.hermitian();
-      permB = fact.perm() - 1.0;
+      b = fact.L ();
+      bt = b.hermitian ();
+      permB = fact.perm () - 1.0;
       return true;
     }
 }
 
 static bool
 LuAminusSigmaB (const SparseMatrix &m, const SparseMatrix &b,
                 bool cholB, const ColumnVector& permB, double sigma,
                 SparseMatrix &L, SparseMatrix &U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
-  octave_idx_type n = m.rows();
+  octave_idx_type n = m.rows ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          if (permB.length())
+          if (permB.length ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx(i) = i;
                   tmp.xridx(i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata(i) = 1;
                 }
               tmp.xcidx(n) = n;
 
               AminusSigmaB = AminusSigmaB - sigma * tmp *
-                b.transpose() * b * tmp.transpose();
+                b.transpose () * b * tmp.transpose ();
             }
           else
             AminusSigmaB = AminusSigmaB - sigma *
-              b.transpose() * b;
+              b.transpose () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseMatrix sigmat (n, n, n);
 
@@ -517,55 +517,55 @@ LuAminusSigmaB (const SparseMatrix &m, c
 
 static bool
 LuAminusSigmaB (const Matrix &m, const Matrix &b,
                 bool cholB, const ColumnVector& permB, double sigma,
                 Matrix &L, Matrix &U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
-  octave_idx_type n = m.cols();
+  octave_idx_type n = m.cols ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   Matrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          Matrix tmp = sigma * b.transpose() * b;
-          const double *pB = permB.fortran_vec();
-          double *p = AminusSigmaB.fortran_vec();
-
-          if (permB.length())
+          Matrix tmp = sigma * b.transpose () * b;
+          const double *pB = permB.fortran_vec ();
+          double *p = AminusSigmaB.fortran_vec ();
+
+          if (permB.length ())
             {
               for (octave_idx_type j = 0;
-                   j < b.cols(); j++)
+                   j < b.cols (); j++)
                 for (octave_idx_type i = 0;
-                     i < b.rows(); i++)
+                     i < b.rows (); i++)
                   *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
                                       static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
-      double *p = AminusSigmaB.fortran_vec();
+      double *p = AminusSigmaB.fortran_vec ();
 
       for (octave_idx_type i = 0; i < n; i++)
         p[i*(n+1)] -= sigma;
     }
 
   LU fact (AminusSigmaB);
 
-  L = fact.P().transpose() * fact.L ();
+  L = fact.P ().transpose () * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
@@ -594,42 +594,42 @@ LuAminusSigmaB (const Matrix &m, const M
 
 static bool
 LuAminusSigmaB (const SparseComplexMatrix &m, const SparseComplexMatrix &b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
                 SparseComplexMatrix &L, SparseComplexMatrix &U,
                 octave_idx_type *P, octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
-  octave_idx_type n = m.rows();
+  octave_idx_type n = m.rows ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseComplexMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          if (permB.length())
+          if (permB.length ())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx(i) = i;
                   tmp.xridx(i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata(i) = 1;
                 }
               tmp.xcidx(n) = n;
 
-              AminusSigmaB = AminusSigmaB - tmp * b.hermitian() * b *
-                tmp.transpose() * sigma;
+              AminusSigmaB = AminusSigmaB - tmp * b.hermitian () * b *
+                tmp.transpose () * sigma;
             }
           else
-            AminusSigmaB = AminusSigmaB - sigma * b.hermitian() * b;
+            AminusSigmaB = AminusSigmaB - sigma * b.hermitian () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseComplexMatrix sigmat (n, n, n);
 
@@ -691,55 +691,55 @@ LuAminusSigmaB (const SparseComplexMatri
 
 static bool
 LuAminusSigmaB (const ComplexMatrix &m, const ComplexMatrix &b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
                 ComplexMatrix &L, ComplexMatrix &U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
-  octave_idx_type n = m.cols();
+  octave_idx_type n = m.cols ();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   ComplexMatrix AminusSigmaB (m);
 
   if (have_b)
     {
       if (cholB)
         {
-          ComplexMatrix tmp = sigma * b.hermitian() * b;
-          const double *pB = permB.fortran_vec();
-          Complex *p = AminusSigmaB.fortran_vec();
-
-          if (permB.length())
+          ComplexMatrix tmp = sigma * b.hermitian () * b;
+          const double *pB = permB.fortran_vec ();
+          Complex *p = AminusSigmaB.fortran_vec ();
+
+          if (permB.length ())
             {
               for (octave_idx_type j = 0;
-                   j < b.cols(); j++)
+                   j < b.cols (); j++)
                 for (octave_idx_type i = 0;
-                     i < b.rows(); i++)
+                     i < b.rows (); i++)
                   *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
                                       static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
-      Complex *p = AminusSigmaB.fortran_vec();
+      Complex *p = AminusSigmaB.fortran_vec ();
 
       for (octave_idx_type i = 0; i < n; i++)
         p[i*(n+1)] -= sigma;
     }
 
   ComplexLU fact (AminusSigmaB);
 
-  L = fact.P().transpose() * fact.L ();
+  L = fact.P ().transpose () * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
@@ -774,37 +774,37 @@ EigsRealSymmetricMatrix (const M& m, con
                          ColumnVector &eig_val, const M& _b,
                          ColumnVector &permB, ColumnVector &resid,
                          std::ostream& os, double tol, bool rvec,
                          bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigma = 0.;
   M bt;
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -833,20 +833,20 @@ EigsRealSymmetricMatrix (const M& m, con
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
@@ -883,18 +883,18 @@ EigsRealSymmetricMatrix (const M& m, con
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
-          b = b.transpose();
-          if (permB.length() == 0)
+          b = b.transpose ();
+          if (permB.length () == 0)
             {
               permB = ColumnVector(n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -934,17 +934,17 @@ EigsRealSymmetricMatrix (const M& m, con
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
@@ -1095,40 +1095,40 @@ EigsRealSymmetricMatrixShift (const M& m
                               ColumnVector &eig_val, const M& _b,
                               ColumnVector &permB, ColumnVector &resid,
                               std::ostream& os, double tol, bool rvec,
                               bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsRealSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                _b, permB, resid, os, tol, rvec, cholB,
   //                                disp, maxit);
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -1157,20 +1157,20 @@ EigsRealSymmetricMatrixShift (const M& m
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
@@ -1210,34 +1210,34 @@ EigsRealSymmetricMatrixShift (const M& m
 
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
   if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
@@ -1425,19 +1425,19 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
                        bool /* cholB */, int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -1528,17 +1528,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
@@ -1687,38 +1687,38 @@ EigsRealNonSymmetricMatrix (const M& m, 
                             ComplexColumnVector &eig_val, const M& _b,
                             ColumnVector &permB, ColumnVector &resid,
                             std::ostream& os, double tol, bool rvec,
                             bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigmar = 0.;
   double sigmai = 0.;
   M bt;
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -1747,20 +1747,20 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
@@ -1797,18 +1797,18 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
-          b = b.transpose();
-          if (permB.length() == 0)
+          b = b.transpose ();
+          if (permB.length () == 0)
             {
               permB = ColumnVector(n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -1848,17 +1848,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dnaupd");
@@ -2057,41 +2057,41 @@ EigsRealNonSymmetricMatrixShift (const M
                                  ComplexColumnVector &eig_val, const M& _b,
                                  ColumnVector &permB, ColumnVector &resid,
                                  std::ostream& os, double tol, bool rvec,
                                  bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   std::string typ = "LM";
   double sigmai = 0.;
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigmar))
   //  return EigsRealNonSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                   _b, permB, resid, os, tol, rvec, cholB,
   //                                   disp, maxit);
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -2120,20 +2120,20 @@ EigsRealNonSymmetricMatrixShift (const M
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check that we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
@@ -2173,34 +2173,34 @@ EigsRealNonSymmetricMatrixShift (const M
 
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
   if (! LuAminusSigmaB(m, b, cholB, permB, sigmar, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
@@ -2442,19 +2442,19 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
 {
   std::string typ (_typ);
   bool have_sigma = (sigmar ? true : false);
   char bmat = 'I';
   double sigmai = 0.;
   octave_idx_type mode = 1;
   int err = 0;
 
-  if (resid.is_empty())
+  if (resid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       resid = ColumnVector (octave_rand::vector(n));
       octave_rand::distribution(rand_dist);
     }
 
   if (n < 3)
     {
       (*current_liboctave_error_handler)
@@ -2546,17 +2546,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dnaupd");
@@ -2752,37 +2752,37 @@ EigsComplexNonSymmetricMatrix (const M& 
                                ColumnVector &permB,
                                ComplexColumnVector &cresid,
                                std::ostream& os, double tol, bool rvec,
                                bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   Complex sigma = 0.;
   M bt;
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
-  if (cresid.is_empty())
+  if (cresid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       Array<double> rr (octave_rand::vector(n));
       Array<double> ri (octave_rand::vector(n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         cresid(i) = Complex(rr(i),ri(i));
       octave_rand::distribution(rand_dist);
     }
@@ -2815,20 +2815,20 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check the we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
@@ -2865,18 +2865,18 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
       if (cholB)
         {
           bt = b;
-          b = b.hermitian();
-          if (permB.length() == 0)
+          b = b.hermitian ();
+          if (permB.length () == 0)
             {
               permB = ColumnVector(n);
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
@@ -2917,17 +2917,17 @@ EigsComplexNonSymmetricMatrix (const M& 
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
@@ -3074,40 +3074,40 @@ EigsComplexNonSymmetricMatrixShift (cons
                                     ColumnVector &permB,
                                     ComplexColumnVector &cresid,
                                     std::ostream& os, double tol, bool rvec,
                                     bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
-  bool have_b = ! b.is_empty();
+  bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
-  if (m.rows() != m.cols())
+  if (m.rows () != m.cols ())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
-  if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
+  if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     {
       (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsComplexNonSymmetricMatrix (m, "SM", k, p, info, eig_vec,
   //                                      eig_val, _b, permB, cresid, os, tol,
   //                                      rvec, cholB, disp, maxit);
 
-  if (cresid.is_empty())
+  if (cresid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       Array<double> rr (octave_rand::vector(n));
       Array<double> ri (octave_rand::vector(n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         cresid(i) = Complex(rr(i),ri(i));
       octave_rand::distribution(rand_dist);
     }
@@ -3140,20 +3140,20 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0)
+  if (have_b && cholB && permB.length () != 0)
     {
       // Check that we really have a permutation vector
-      if (permB.length() != n)
+      if (permB.length () != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
@@ -3193,35 +3193,35 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   M L, U;
 
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
-  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows () : m.rows ()));
+  OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols () : m.cols ()));
 
   if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (3 * p + 5);
 
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
@@ -3412,19 +3412,19 @@ EigsComplexNonSymmetricFunc (EigsComplex
                              int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (std::abs(sigma) ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
 
-  if (cresid.is_empty())
+  if (cresid.is_empty ())
     {
-      std::string rand_dist = octave_rand::distribution();
+      std::string rand_dist = octave_rand::distribution ();
       octave_rand::distribution("uniform");
       Array<double> rr (octave_rand::vector(n));
       Array<double> ri (octave_rand::vector(n));
       cresid = ComplexColumnVector (n);
       for (octave_idx_type i = 0; i < n; i++)
         cresid(i) = Complex(rr(i),ri(i));
       octave_rand::distribution(rand_dist);
     }
@@ -3520,17 +3520,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
-         F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
+         F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
           (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
diff --git a/liboctave/f2c-main.c b/liboctave/f2c-main.c
--- a/liboctave/f2c-main.c
+++ b/liboctave/f2c-main.c
@@ -26,10 +26,10 @@ along with Octave; see the file COPYING.
 /* Dummy Fortran main declaration, needed in order to link to some
    Fortran libraries.  See the AC_F77_DUMMY_MAIN macro documentation.
    This function should never be called. */
 
 #ifdef F77_DUMMY_MAIN
 #  ifdef __cplusplus
 extern "C"
 #  endif
-int F77_DUMMY_MAIN() { assert(0); return 1; }
+int F77_DUMMY_MAIN () { assert(0); return 1; }
 #endif
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -509,17 +509,17 @@ operator << (std::ostream& os, const Flo
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexColumnVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/fCDiagMatrix.h b/liboctave/fCDiagMatrix.h
--- a/liboctave/fCDiagMatrix.h
+++ b/liboctave/fCDiagMatrix.h
@@ -85,17 +85,17 @@ public:
   FloatComplexDiagMatrix& fill (const FloatRowVector& a);
   FloatComplexDiagMatrix& fill (const FloatComplexRowVector& a);
   FloatComplexDiagMatrix& fill (const FloatColumnVector& a, octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatComplexColumnVector& a, octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatRowVector& a, octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatComplexRowVector& a, octave_idx_type beg);
 
   FloatComplexDiagMatrix hermitian (void) const { return MDiagArray2<FloatComplex>::hermitian (std::conj); }
-  FloatComplexDiagMatrix transpose (void) const { return MDiagArray2<FloatComplex>::transpose(); }
+  FloatComplexDiagMatrix transpose (void) const { return MDiagArray2<FloatComplex>::transpose (); }
   FloatDiagMatrix abs (void) const;
 
   friend OCTAVE_API FloatComplexDiagMatrix conj (const FloatComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   FloatComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1086,17 +1086,17 @@ FloatComplexMatrix::finverse (MatrixType
       z.resize (dim_vector (lwork, 1));
       FloatComplex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm;
       if (calc_cond)
-        anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm  = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1124,17 +1124,17 @@ FloatComplexMatrix::finverse (MatrixType
           F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, zgetri_info));
 
           if (zgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
-        mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                         float& rcon, int force, int calc_cond) const
@@ -1150,17 +1150,17 @@ FloatComplexMatrix::inverse (MatrixType 
   else
     {
       if (mattype.is_hermitian ())
         {
           FloatComplexCHOL chol (*this, info, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
-                rcon = chol.rcond();
+                rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
           else
             mattype.mark_as_unsymmetric ();
         }
 
@@ -1784,18 +1784,18 @@ FloatComplexMatrix::rcond (MatrixType &m
           float anorm = -1.0;
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+              anorm = atmp.abs ().sum ().
+                row(static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1824,18 +1824,18 @@ FloatComplexMatrix::rcond (MatrixType &m
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
-                anorm = atmp.abs().sum().
-                  row(static_cast<octave_idx_type>(0)).max();
+                anorm = atmp.abs ().sum ().
+                  row(static_cast<octave_idx_type>(0)).max ();
 
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2091,17 +2091,17 @@ FloatComplexMatrix::fsolve (MatrixType &
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -2147,17 +2147,17 @@ FloatComplexMatrix::fsolve (MatrixType &
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (cpotrs, CPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows(), info
+                                             result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -2175,17 +2175,17 @@ FloatComplexMatrix::fsolve (MatrixType &
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2233,17 +2233,17 @@ FloatComplexMatrix::fsolve (MatrixType &
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (cgetrs, CGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows(), info
+                                             pipvt, result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
     }
 
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -114,45 +114,45 @@ FloatComplexNDArray::ifourier (int dim) 
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const FloatComplex *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const FloatComplex *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
@@ -237,17 +237,17 @@ FloatComplexNDArray::fourier (int dim) c
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+            retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier (int dim) const
@@ -284,17 +284,17 @@ FloatComplexNDArray::ifourier (int dim) 
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+            retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<float> (npts);
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -325,35 +325,35 @@ FloatComplexNDArray::fourier2d (void) co
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
@@ -373,22 +373,22 @@ FloatComplexNDArray::ifourier2d (void) c
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<float> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -421,22 +421,22 @@ FloatComplexNDArray::fourierNd (void) co
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -468,22 +468,22 @@ FloatComplexNDArray::ifourierNd (void) c
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<float> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -406,17 +406,17 @@ operator << (std::ostream& os, const Flo
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexRowVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       FloatComplex tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/fCmplxGEPBAL.cc b/liboctave/fCmplxGEPBAL.cc
--- a/liboctave/fCmplxGEPBAL.cc
+++ b/liboctave/fCmplxGEPBAL.cc
@@ -64,17 +64,17 @@ FloatComplexGEPBALANCE::init (const Floa
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("FloatComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
-  if (a.dims() != b.dims ())
+  if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
diff --git a/liboctave/fColVector.cc b/liboctave/fColVector.cc
--- a/liboctave/fColVector.cc
+++ b/liboctave/fColVector.cc
@@ -137,17 +137,17 @@ FloatColumnVector::stack (const FloatCol
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
 FloatRowVector
 FloatColumnVector::transpose (void) const
 {
-  return MArray<float>::transpose();
+  return MArray<float>::transpose ();
 }
 
 FloatColumnVector
 FloatColumnVector::abs (void) const
 {
   return do_mx_unary_map<float, float, std::abs> (*this);
 }
 
@@ -302,17 +302,17 @@ operator << (std::ostream& os, const Flo
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatColumnVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/fDiagMatrix.h b/liboctave/fDiagMatrix.h
--- a/liboctave/fDiagMatrix.h
+++ b/liboctave/fDiagMatrix.h
@@ -69,17 +69,17 @@ public:
 
   FloatDiagMatrix& fill (float val);
   FloatDiagMatrix& fill (float val, octave_idx_type beg, octave_idx_type end);
   FloatDiagMatrix& fill (const FloatColumnVector& a);
   FloatDiagMatrix& fill (const FloatRowVector& a);
   FloatDiagMatrix& fill (const FloatColumnVector& a, octave_idx_type beg);
   FloatDiagMatrix& fill (const FloatRowVector& a, octave_idx_type beg);
 
-  FloatDiagMatrix transpose (void) const { return MDiagArray2<float>::transpose(); }
+  FloatDiagMatrix transpose (void) const { return MDiagArray2<float>::transpose (); }
   FloatDiagMatrix abs (void) const;
 
   friend OCTAVE_API FloatDiagMatrix real (const FloatComplexDiagMatrix& a);
   friend OCTAVE_API FloatDiagMatrix imag (const FloatComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   FloatMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -681,17 +681,17 @@ FloatEIG::init (const FloatComplexMatrix
       (*current_liboctave_error_handler)
         ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
-  if (n != a.cols () || nb != b.cols())
+  if (n != a.cols () || nb != b.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
     }
 
   if (n != nb)
     {
       (*current_liboctave_error_handler) ("EIG requires same size matrices");
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -758,17 +758,17 @@ FloatMatrix::finverse (MatrixType &matty
       z.resize (dim_vector (lwork, 1));
       float *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond)
-        anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+        anorm = retval.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
       F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -797,17 +797,17 @@ FloatMatrix::finverse (MatrixType &matty
           F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, dgetri_info));
 
           if (dgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
-        mattype.mark_as_rectangular();
+        mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                  int force, int calc_cond) const
@@ -1456,18 +1456,18 @@ FloatMatrix::rcond (MatrixType &mattype)
           float anorm = -1.0;
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
-              anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+              anorm = atmp.abs ().sum ().
+                row(static_cast<octave_idx_type>(0)).max ();
 
               F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1494,18 +1494,18 @@ FloatMatrix::rcond (MatrixType &mattype)
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if(anorm < 0.)
-                anorm = atmp.abs().sum().
-                  row(static_cast<octave_idx_type>(0)).max();
+                anorm = atmp.abs ().sum ().
+                  row(static_cast<octave_idx_type>(0)).max ();
 
               Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1757,17 +1757,17 @@ FloatMatrix::fsolve (MatrixType &mattype
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
-          anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+          anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
@@ -1813,17 +1813,17 @@ FloatMatrix::fsolve (MatrixType &mattype
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (spotrs, SPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             result, b.rows(), info
+                                             result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -1834,17 +1834,17 @@ FloatMatrix::fsolve (MatrixType &mattype
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
           if(anorm < 0.)
-            anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
+            anorm = atmp.abs ().sum ().row(static_cast<octave_idx_type>(0)).max ();
 
           Array<float> z (dim_vector (4 * nc, 1));
           float *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1897,17 +1897,17 @@ FloatMatrix::fsolve (MatrixType &mattype
                   retval = b;
                   float *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (sgetrs, SGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows(), info
+                                             pipvt, result, b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -113,44 +113,44 @@ FloatNDArray::ifourier (int dim) const
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   const float *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::fftNd (in + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   if (dv.length () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2(dv(0), dv(1));
   FloatComplexNDArray retval (*this);
   FloatComplex *out = retval.fortran_vec ();
-  octave_idx_type howmany = numel() / dv(0) / dv(1);
+  octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
   for (octave_idx_type i=0; i < howmany; i++)
     octave_fftw::ifftNd (out + i*dist, out + i*dist, 2, dv2);
 
   return retval;
 }
 
@@ -241,17 +241,17 @@ FloatNDArray::fourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+            retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier (int dim) const
@@ -288,28 +288,28 @@ FloatNDArray::ifourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+            retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<float> (npts);
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
@@ -329,35 +329,35 @@ FloatNDArray::fourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier2d (void) const
 {
-  dim_vector dv = dims();
+  dim_vector dv = dims ();
   dim_vector dv2 (dv(0), dv(1));
   int rank = 2;
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv2(i);
@@ -377,22 +377,22 @@ FloatNDArray::ifourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<float> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -425,22 +425,22 @@ FloatNDArray::fourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -472,22 +472,22 @@ FloatNDArray::ifourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<float> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
diff --git a/liboctave/fRowVector.cc b/liboctave/fRowVector.cc
--- a/liboctave/fRowVector.cc
+++ b/liboctave/fRowVector.cc
@@ -141,17 +141,17 @@ FloatRowVector::append (const FloatRowVe
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
 FloatColumnVector
 FloatRowVector::transpose (void) const
 {
-  return MArray<float>::transpose();
+  return MArray<float>::transpose ();
 }
 
 FloatRowVector
 real (const FloatComplexRowVector& a)
 {
   return do_mx_unary_op<float, FloatComplex> (a, mx_inline_real);
 }
 
@@ -266,17 +266,17 @@ operator << (std::ostream& os, const Flo
   for (octave_idx_type i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatRowVector& a)
 {
-  octave_idx_type len = a.length();
+  octave_idx_type len = a.length ();
 
   if (len > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -351,17 +351,17 @@ file_ops::tilde_expand (const string_vec
   return retval;
 }
 
 std::string
 file_ops::concat (const std::string& dir, const std::string& file)
 {
   return dir.empty ()
     ? file
-    : (is_dir_sep (dir[dir.length()-1])
+    : (is_dir_sep (dir[dir.length ()-1])
        ? dir + file
        : dir + dir_sep_char () + file);
 }
 
 
 int
 octave_mkdir (const std::string& nm, mode_t md)
 {
diff --git a/liboctave/file-stat.cc b/liboctave/file-stat.cc
--- a/liboctave/file-stat.cc
+++ b/liboctave/file-stat.cc
@@ -184,17 +184,17 @@ file_stat::update_internal (bool force)
       fail = false;
 
       std::string full_file_name = file_ops::tilde_expand (file_name);
 
 #if defined (__WIN32__)
       // Remove trailing slash.
       if (file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
           && full_file_name.length () != 1
-          && ! (full_file_name.length() == 3 && full_file_name[1] == ':'))
+          && ! (full_file_name.length () == 3 && full_file_name[1] == ':'))
         full_file_name.resize (full_file_name.length () - 1);
 #endif
 
       const char *cname = full_file_name.c_str ();
 
       struct stat buf;
 
       int status = follow_links
diff --git a/liboctave/floatCHOL.cc b/liboctave/floatCHOL.cc
--- a/liboctave/floatCHOL.cc
+++ b/liboctave/floatCHOL.cc
@@ -152,17 +152,17 @@ chol2inv_internal (const FloatMatrix& r)
   octave_idx_type r_nc = r.cols ();
 
   if (r_nr == r_nc)
     {
       octave_idx_type n = r_nc;
       octave_idx_type info = 0;
 
       FloatMatrix tmp = r;
-      float *v = tmp.fortran_vec();
+      float *v = tmp.fortran_vec ();
 
       if (info == 0)
         {
           F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
                                      v, n, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // If someone thinks of a more graceful way of doing this (or
diff --git a/liboctave/floatGEPBAL.cc b/liboctave/floatGEPBAL.cc
--- a/liboctave/floatGEPBAL.cc
+++ b/liboctave/floatGEPBAL.cc
@@ -65,17 +65,17 @@ FloatGEPBALANCE::init (const FloatMatrix
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("FloatGEPBALANCE requires square matrix");
       return -1;
     }
 
-  if (a.dims() != b.dims ())
+  if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -599,17 +599,17 @@ public:
 
   octave_idx_type orig_rows (void) const
     { return orig_dimensions () (0); }
 
   octave_idx_type orig_columns (void) const
     { return orig_dimensions () (1); }
 
   int orig_empty (void) const
-    { return (! is_colon () && orig_dimensions().any_zero ()); }
+    { return (! is_colon () && orig_dimensions ().any_zero ()); }
 
   // i/o
 
   std::ostream& print (std::ostream& os) const { return rep->print (os); }
 
   friend std::ostream& operator << (std::ostream& os, const idx_vector& a)
     { return a.print (os); }
 
diff --git a/liboctave/lo-ieee.h b/liboctave/lo-ieee.h
--- a/liboctave/lo-ieee.h
+++ b/liboctave/lo-ieee.h
@@ -113,9 +113,31 @@ extern OCTAVE_API int __lo_ieee_float_si
 
 #define lo_ieee_is_NA(x) (sizeof (x) == sizeof (float) ? \
                           __lo_ieee_float_is_NA (x) : __lo_ieee_is_NA (x))
 #define lo_ieee_is_NaN_or_NA(x) (sizeof (x) == sizeof (float) ? \
                           __lo_ieee_float_is_NaN_or_NA (x) : __lo_ieee_is_NaN_or_NA (x))
 #define lo_ieee_signbit(x) (sizeof (x) == sizeof (float) ? \
                           __lo_ieee_float_signbit (x) : __lo_ieee_signbit (x))
 
+#ifdef __cplusplus
+
+template <typename T>
+struct octave_numeric_limits
+{
+  static T NA (void) { return static_cast<T> (0); }
+};
+
+template <>
+struct octave_numeric_limits<double>
+{
+  static double NA (void) { return octave_NA; }
+};
+
+template <>
+struct octave_numeric_limits<float>
+{
+  static float NA (void) { return octave_Float_NA; }
+};
+
 #endif
+
+#endif
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -455,17 +455,17 @@ expm1 (double x)
 
 Complex
 expm1(const Complex& x)
 {
   Complex retval;
 
   if (std:: abs (x) < 1)
     {
-      double im = x.imag();
+      double im = x.imag ();
       double u = expm1 (x.real ());
       double v = sin (im/2);
       v = -2*v*v;
       retval = Complex (u*v + u + v, (u+1) * sin (im));
     }
   else
     retval = std::exp (x) - Complex (1);
 
@@ -510,17 +510,17 @@ expm1f (float x)
 
 FloatComplex
 expm1(const FloatComplex& x)
 {
   FloatComplex retval;
 
   if (std:: abs (x) < 1)
     {
-      float im = x.imag();
+      float im = x.imag ();
       float u = expm1 (x.real ());
       float v = sin (im/2);
       v = -2*v*v;
       retval = FloatComplex (u*v + u + v, (u+1) * sin (im));
     }
   else
     retval = std::exp (x) - FloatComplex (1);
 
@@ -551,17 +551,17 @@ log1p (double x)
 }
 #endif
 
 Complex
 log1p (const Complex& x)
 {
   Complex retval;
 
-  double r = x.real (), i = x.imag();
+  double r = x.real (), i = x.imag ();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       double u = 2*r + r*r + i*i;
       retval = Complex (log1p (u / (1+sqrt (u+1))),
                         atan2 (1 + r, i));
     }
   else
@@ -610,17 +610,17 @@ log1pf (float x)
 }
 #endif
 
 FloatComplex
 log1p (const FloatComplex& x)
 {
   FloatComplex retval;
 
-  float r = x.real (), i = x.imag();
+  float r = x.real (), i = x.imag ();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       float u = 2*r + r*r + i*i;
       retval = FloatComplex (log1p (u / (1+sqrt (u+1))),
                         atan2 (1 + r, i));
     }
   else
@@ -868,17 +868,17 @@ zbesi (const Complex& z, double alpha, i
       if (ierr == 0 || ierr == 3)
         {
           Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
             * zbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
-              tmp2 *= exp(-z - std::abs(z.real()));
+              tmp2 *= exp(-z - std::abs(z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = Complex (octave_NaN, octave_NaN);
@@ -1478,17 +1478,17 @@ cbesi (const FloatComplex& z, float alph
       if (ierr == 0 || ierr == 3)
         {
           FloatComplex tmp2 = static_cast<float> (2.0 / M_PI) * sinf (static_cast<float> (M_PI) * alpha)
             * cbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
-              tmp2 *= exp(-z - std::abs(z.real()));
+              tmp2 *= exp(-z - std::abs(z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
@@ -1981,32 +1981,32 @@ airy (const ComplexNDArray& z, bool deri
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = airy (z(i), deriv, scaled, ierr(i));
+    retval(i) = airy (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 ComplexNDArray
 biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = biry (z(i), deriv, scaled, ierr(i));
+    retval(i) = biry (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 FloatComplex
 airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
 {
   float ar = 0.0;
@@ -2111,32 +2111,32 @@ airy (const FloatComplexNDArray& z, bool
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = airy (z(i), deriv, scaled, ierr(i));
+    retval(i) = airy (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 FloatComplexNDArray
 biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = biry (z(i), deriv, scaled, ierr(i));
+    retval(i) = biry (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 static void
 gripe_betainc_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2, octave_idx_type r3,
                              octave_idx_type c3)
 {
@@ -2153,575 +2153,327 @@ gripe_betainc_nonconformant (const dim_v
   std::string d2_str = d2.str ();
   std::string d3_str = d3.str ();
 
   (*current_liboctave_error_handler)
   ("betainc: nonconformant arguments (x is %s, a is %s, b is %s)",
    d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
 }
 
+static void
+gripe_betaincinv_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2, octave_idx_type r3,
+                                octave_idx_type c3)
+{
+  (*current_liboctave_error_handler)
+   ("betaincinv: nonconformant arguments (x is %dx%d, a is %dx%d, b is %dx%d)",
+     r1, c1, r2, c2, r3, c3);
+}
+
+static void
+gripe_betaincinv_nonconformant (const dim_vector& d1, const dim_vector& d2,
+                                const dim_vector& d3)
+{
+  std::string d1_str = d1.str ();
+  std::string d2_str = d2.str ();
+  std::string d3_str = d3.str ();
+
+  (*current_liboctave_error_handler)
+  ("betaincinv: nonconformant arguments (x is %s, a is %s, b is %s)",
+   d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
+}
+
 double
 betainc (double x, double a, double b)
 {
   double retval;
   F77_XFCN (xdbetai, XDBETAI, (x, a, b, retval));
   return retval;
 }
 
-Matrix
-betainc (double x, double a, const Matrix& b)
+Array<double>
+betainc (double x, double a, const Array<double>& b)
 {
-  octave_idx_type nr = b.rows ();
-  octave_idx_type nc = b.cols ();
-
-  Matrix retval (nr, nc);
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = betainc (x, a, b(i,j));
-
-  return retval;
-}
-
-Matrix
-betainc (double x, const Matrix& a, double b)
-{
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-
-  Matrix retval (nr, nc);
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = betainc (x, a(i,j), b);
+  dim_vector dv = b.dims ();
+  octave_idx_type nel = dv.numel ();
+
+  Array<double> retval (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x, a, b(i));
 
   return retval;
 }
 
-Matrix
-betainc (double x, const Matrix& a, const Matrix& b)
+Array<double>
+betainc (double x, const Array<double>& a, double b)
 {
-  Matrix retval;
-
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  octave_idx_type b_nr = b.rows ();
-  octave_idx_type b_nc = b.cols ();
-
-  if (a_nr == b_nr && a_nc == b_nc)
-    {
-      retval.resize (a_nr, a_nc);
-
-      for (octave_idx_type j = 0; j < a_nc; j++)
-        for (octave_idx_type i = 0; i < a_nr; i++)
-          retval(i,j) = betainc (x, a(i,j), b(i,j));
-    }
-  else
-    gripe_betainc_nonconformant (1, 1, a_nr, a_nc, b_nr, b_nc);
+  dim_vector dv = a.dims ();
+  octave_idx_type nel = dv.numel ();
+
+  Array<double> retval (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x, a(i), b);
 
   return retval;
 }
 
-NDArray
-betainc (double x, double a, const NDArray& b)
+Array<double>
+betainc (double x, const Array<double>& a, const Array<double>& b)
 {
-  dim_vector dv = b.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  NDArray retval (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = betainc (x, a, b(i));
-
-  return retval;
-}
-
-NDArray
-betainc (double x, const NDArray& a, double b)
-{
-  dim_vector dv = a.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  NDArray retval (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = betainc (x, a(i), b);
-
-  return retval;
-}
-
-NDArray
-betainc (double x, const NDArray& a, const NDArray& b)
-{
-  NDArray retval;
+  Array<double> retval;
   dim_vector dv = a.dims ();
 
   if (dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
+      double *pretval = retval.fortran_vec ();
+
       for (octave_idx_type i = 0; i < nel; i++)
-        retval (i) = betainc (x, a(i), b(i));
+        *pretval++ = betainc (x, a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
 
   return retval;
 }
 
-
-Matrix
-betainc (const Matrix& x, double a, double b)
-{
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  Matrix retval (nr, nc);
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = betainc (x(i,j), a, b);
-
-  return retval;
-}
-
-Matrix
-betainc (const Matrix& x, double a, const Matrix& b)
+Array<double>
+betainc (const Array<double>& x, double a, double b)
 {
-  Matrix retval;
-
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  octave_idx_type b_nr = b.rows ();
-  octave_idx_type b_nc = b.cols ();
-
-  if (nr == b_nr && nc == b_nc)
-    {
-      retval.resize (nr, nc);
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          retval(i,j) = betainc (x(i,j), a, b(i,j));
-    }
-  else
-    gripe_betainc_nonconformant (nr, nc, 1, 1, b_nr, b_nc);
+  dim_vector dv = x.dims ();
+  octave_idx_type nel = dv.numel ();
+
+  Array<double> retval (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x(i), a, b);
 
   return retval;
 }
 
-Matrix
-betainc (const Matrix& x, const Matrix& a, double b)
-{
-  Matrix retval;
-
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (nr == a_nr && nc == a_nc)
-    {
-      retval.resize (nr, nc);
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          retval(i,j) = betainc (x(i,j), a(i,j), b);
-    }
-  else
-    gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, 1, 1);
-
-  return retval;
-}
-
-Matrix
-betainc (const Matrix& x, const Matrix& a, const Matrix& b)
+Array<double>
+betainc (const Array<double>& x, double a, const Array<double>& b)
 {
-  Matrix retval;
-
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  octave_idx_type b_nr = b.rows ();
-  octave_idx_type b_nc = b.cols ();
-
-  if (nr == a_nr && nr == b_nr && nc == a_nc && nc == b_nc)
-    {
-      retval.resize (nr, nc);
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          retval(i,j) = betainc (x(i,j), a(i,j), b(i,j));
-    }
-  else
-    gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, b_nr, b_nc);
-
-  return retval;
-}
-
-NDArray
-betainc (const NDArray& x, double a, double b)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  NDArray retval (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = betainc (x(i), a, b);
-
-  return retval;
-}
-
-NDArray
-betainc (const NDArray& x, double a, const NDArray& b)
-{
-  NDArray retval;
+  Array<double> retval;
   dim_vector dv = x.dims ();
 
   if (dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
+      double *pretval = retval.fortran_vec ();
+
       for (octave_idx_type i = 0; i < nel; i++)
-        retval (i) = betainc (x(i), a, b(i));
+        *pretval++ = betainc (x(i), a, b(i));
     }
   else
     gripe_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
 
   return retval;
 }
 
-NDArray
-betainc (const NDArray& x, const NDArray& a, double b)
+Array<double>
+betainc (const Array<double>& x, const Array<double>& a, double b)
 {
-  NDArray retval;
+  Array<double> retval;
   dim_vector dv = x.dims ();
 
   if (dv == a.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
+      double *pretval = retval.fortran_vec ();
+
       for (octave_idx_type i = 0; i < nel; i++)
-        retval (i) = betainc (x(i), a(i), b);
+        *pretval++ = betainc (x(i), a(i), b);
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
 
   return retval;
 }
 
-NDArray
-betainc (const NDArray& x, const NDArray& a, const NDArray& b)
+Array<double>
+betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b)
 {
-  NDArray retval;
+  Array<double> retval;
   dim_vector dv = x.dims ();
 
   if (dv == a.dims () && dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
+      double *pretval = retval.fortran_vec ();
+
       for (octave_idx_type i = 0; i < nel; i++)
-        retval (i) = betainc (x(i), a(i), b(i));
+        *pretval++ = betainc (x(i), a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
 
 float
 betainc (float x, float a, float b)
 {
   float retval;
   F77_XFCN (xbetai, XBETAI, (x, a, b, retval));
   return retval;
 }
 
-FloatMatrix
-betainc (float x, float a, const FloatMatrix& b)
+Array<float>
+betainc (float x, float a, const Array<float>& b)
 {
-  octave_idx_type nr = b.rows ();
-  octave_idx_type nc = b.cols ();
-
-  FloatMatrix retval (nr, nc);
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = betainc (x, a, b(i,j));
-
-  return retval;
-}
-
-FloatMatrix
-betainc (float x, const FloatMatrix& a, float b)
-{
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-
-  FloatMatrix retval (nr, nc);
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = betainc (x, a(i,j), b);
+  dim_vector dv = b.dims ();
+  octave_idx_type nel = dv.numel ();
+
+  Array<float> retval (dv);
+
+  float *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x, a, b(i));
 
   return retval;
 }
 
-FloatMatrix
-betainc (float x, const FloatMatrix& a, const FloatMatrix& b)
+Array<float>
+betainc (float x, const Array<float>& a, float b)
 {
-  FloatMatrix retval;
-
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  octave_idx_type b_nr = b.rows ();
-  octave_idx_type b_nc = b.cols ();
-
-  if (a_nr == b_nr && a_nc == b_nc)
-    {
-      retval.resize (a_nr, a_nc);
-
-      for (octave_idx_type j = 0; j < a_nc; j++)
-        for (octave_idx_type i = 0; i < a_nr; i++)
-          retval(i,j) = betainc (x, a(i,j), b(i,j));
-    }
-  else
-    gripe_betainc_nonconformant (1, 1, a_nr, a_nc, b_nr, b_nc);
+  dim_vector dv = a.dims ();
+  octave_idx_type nel = dv.numel ();
+
+  Array<float> retval (dv);
+
+  float *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x, a(i), b);
 
   return retval;
 }
 
-FloatNDArray
-betainc (float x, float a, const FloatNDArray& b)
+Array<float>
+betainc (float x, const Array<float>& a, const Array<float>& b)
 {
-  dim_vector dv = b.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  FloatNDArray retval (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = betainc (x, a, b(i));
-
-  return retval;
-}
-
-FloatNDArray
-betainc (float x, const FloatNDArray& a, float b)
-{
-  dim_vector dv = a.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  FloatNDArray retval (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = betainc (x, a(i), b);
-
-  return retval;
-}
-
-FloatNDArray
-betainc (float x, const FloatNDArray& a, const FloatNDArray& b)
-{
-  FloatNDArray retval;
+  Array<float> retval;
   dim_vector dv = a.dims ();
 
   if (dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
+      float *pretval = retval.fortran_vec ();
+
       for (octave_idx_type i = 0; i < nel; i++)
-        retval (i) = betainc (x, a(i), b(i));
+        *pretval++ = betainc (x, a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
 
   return retval;
 }
 
-
-FloatMatrix
-betainc (const FloatMatrix& x, float a, float b)
-{
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  FloatMatrix retval (nr, nc);
-
-  for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = 0; i < nr; i++)
-      retval(i,j) = betainc (x(i,j), a, b);
-
-  return retval;
-}
-
-FloatMatrix
-betainc (const FloatMatrix& x, float a, const FloatMatrix& b)
+Array<float>
+betainc (const Array<float>& x, float a, float b)
 {
-  FloatMatrix retval;
-
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  octave_idx_type b_nr = b.rows ();
-  octave_idx_type b_nc = b.cols ();
-
-  if (nr == b_nr && nc == b_nc)
-    {
-      retval.resize (nr, nc);
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          retval(i,j) = betainc (x(i,j), a, b(i,j));
-    }
-  else
-    gripe_betainc_nonconformant (nr, nc, 1, 1, b_nr, b_nc);
+  dim_vector dv = x.dims ();
+  octave_idx_type nel = dv.numel ();
+
+  Array<float> retval (dv);
+
+  float *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x(i), a, b);
 
   return retval;
 }
 
-FloatMatrix
-betainc (const FloatMatrix& x, const FloatMatrix& a, float b)
-{
-  FloatMatrix retval;
-
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (nr == a_nr && nc == a_nc)
-    {
-      retval.resize (nr, nc);
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          retval(i,j) = betainc (x(i,j), a(i,j), b);
-    }
-  else
-    gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, 1, 1);
-
-  return retval;
-}
-
-FloatMatrix
-betainc (const FloatMatrix& x, const FloatMatrix& a, const FloatMatrix& b)
+Array<float>
+betainc (const Array<float>& x, float a, const Array<float>& b)
 {
-  FloatMatrix retval;
-
-  octave_idx_type nr = x.rows ();
-  octave_idx_type nc = x.cols ();
-
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  octave_idx_type b_nr = b.rows ();
-  octave_idx_type b_nc = b.cols ();
-
-  if (nr == a_nr && nr == b_nr && nc == a_nc && nc == b_nc)
-    {
-      retval.resize (nr, nc);
-
-      for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = 0; i < nr; i++)
-          retval(i,j) = betainc (x(i,j), a(i,j), b(i,j));
-    }
-  else
-    gripe_betainc_nonconformant (nr, nc, a_nr, a_nc, b_nr, b_nc);
-
-  return retval;
-}
-
-FloatNDArray
-betainc (const FloatNDArray& x, float a, float b)
-{
-  dim_vector dv = x.dims ();
-  octave_idx_type nel = dv.numel ();
-
-  FloatNDArray retval (dv);
-
-  for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = betainc (x(i), a, b);
-
-  return retval;
-}
-
-FloatNDArray
-betainc (const FloatNDArray& x, float a, const FloatNDArray& b)
-{
-  FloatNDArray retval;
+  Array<float> retval;
   dim_vector dv = x.dims ();
 
   if (dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
+      float *pretval = retval.fortran_vec ();
+
       for (octave_idx_type i = 0; i < nel; i++)
-        retval (i) = betainc (x(i), a, b(i));
+        *pretval++ = betainc (x(i), a, b(i));
     }
   else
     gripe_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
 
   return retval;
 }
 
-FloatNDArray
-betainc (const FloatNDArray& x, const FloatNDArray& a, float b)
+Array<float>
+betainc (const Array<float>& x, const Array<float>& a, float b)
 {
-  FloatNDArray retval;
+  Array<float> retval;
   dim_vector dv = x.dims ();
 
   if (dv == a.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
+      float *pretval = retval.fortran_vec ();
+
       for (octave_idx_type i = 0; i < nel; i++)
-        retval (i) = betainc (x(i), a(i), b);
+        *pretval++ = betainc (x(i), a(i), b);
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
 
   return retval;
 }
 
-FloatNDArray
-betainc (const FloatNDArray& x, const FloatNDArray& a, const FloatNDArray& b)
+Array<float>
+betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b)
 {
-  FloatNDArray retval;
+  Array<float> retval;
   dim_vector dv = x.dims ();
 
   if (dv == a.dims () && dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
       retval.resize (dv);
 
+      float *pretval = retval.fortran_vec ();
+
       for (octave_idx_type i = 0; i < nel; i++)
-        retval (i) = betainc (x(i), a(i), b(i));
+        *pretval++ = betainc (x(i), a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
 
 // FIXME -- there is still room for improvement here...
@@ -3123,17 +2875,17 @@ gammainc (const FloatNDArray& x, const F
     }
   else
     {
       std::string x_str = dv.str ();
       std::string a_str = a.dims ().str ();
 
       (*current_liboctave_error_handler)
         ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
-         x_str.c_str (), a_str. c_str ());
+         x_str.c_str (), a_str.c_str ());
     }
 
  done:
 
   return retval;
 }
 
 
@@ -3147,17 +2899,17 @@ FloatComplex rc_log1p (float x)
 {
   const float pi = 3.14159265358979323846f;
   return x < -1.0f ? FloatComplex (logf (-(1.0f + x)), pi) : FloatComplex (log1pf (x));
 }
 
 // This algorithm is due to P. J. Acklam.
 // See http://home.online.no/~pjacklam/notes/invnorm/
 // The rational approximation has relative accuracy 1.15e-9 in the whole region.
-// For doubles, it is refined by a single step of Higham's 3rd order method.
+// For doubles, it is refined by a single step of Halley's 3rd order method.
 // For single precision, the accuracy is already OK, so we skip it to get
 // faster evaluation.
 
 static double do_erfinv (double x, bool refine)
 {
   // Coefficients of rational approximation.
   static const double a[] =
     { -2.806989788730439e+01,  1.562324844726888e+02,
@@ -3170,17 +2922,17 @@ static double do_erfinv (double x, bool 
   static const double c[] =
     { -5.504751339936943e-03, -2.279687217114118e-01,
       -1.697592457770869e+00, -1.802933168781950e+00,
        3.093354679843505e+00,  2.077595676404383e+00 };
   static const double d[] =
     {  7.784695709041462e-03,  3.224671290700398e-01,
        2.445134137142996e+00,  3.754408661907416e+00 };
 
-  static const double spi2 =  8.862269254527579e-01; // sqrt(pi)/2.
+  static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
   static const double pbreak = 0.95150;
   double ax = fabs (x), y;
 
   // Select case.
   if (ax <= pbreak)
     {
       // Middle region.
       const double q = 0.5 * x, r = q*q;
@@ -3199,33 +2951,37 @@ static double do_erfinv (double x, bool 
   else if (ax == 1.0)
     return octave_Inf * signum (x);
   else
     return octave_NaN;
 
   if (refine)
     {
       // One iteration of Halley's method gives full precision.
-      double u = (erf(y) - x) * spi2 * exp (y*y);
+      double u = (erf (y) - x) * spi2 * exp (y*y);
       y -= u / (1 + y*u);
     }
 
   return y;
 }
 
 double erfinv (double x)
 {
   return do_erfinv (x, true);
 }
 
 float erfinv (float x)
 {
   return do_erfinv (x, false);
 }
 
+// The algorthim for erfcinv is an adaptation of the erfinv algorithm above
+// from P. J. Acklam.  It has been modified to run over the different input
+// domain of erfcinv.  See the notes for erfinv for an explanation.
+
 static double do_erfcinv (double x, bool refine)
 {
   // Coefficients of rational approximation.
   static const double a[] =
     { -2.806989788730439e+01,  1.562324844726888e+02,
       -1.951109208597547e+02,  9.783370457507161e+01,
       -2.168328665628878e+01,  1.772453852905383e+00 };
   static const double b[] =
@@ -3236,38 +2992,38 @@ static double do_erfcinv (double x, bool
     { -5.504751339936943e-03, -2.279687217114118e-01,
       -1.697592457770869e+00, -1.802933168781950e+00,
        3.093354679843505e+00,  2.077595676404383e+00 };
   static const double d[] =
     {  7.784695709041462e-03,  3.224671290700398e-01,
        2.445134137142996e+00,  3.754408661907416e+00 };
 
   static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
-  static const double pi = 3.14159265358979323846;
-  static const double pbreak = 0.95150;
+  static const double pbreak_lo = 0.04850;  // 1-pbreak
+  static const double pbreak_hi = 1.95150;  // 1+pbreak
   double y;
 
   // Select case.
-  if (x <= 1+pbreak && x >= 1-pbreak)
+  if (x >= pbreak_lo && x <= pbreak_hi)
     {
       // Middle region.
       const double q = 0.5*(1-x), r = q*q;
       const double yn = (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5])*q;
       const double yd = ((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1.0;
       y = yn / yd;
     }
-  else if (x < 2.0 && x > 0.0)
+  else if (x > 0.0 && x < 2.0)
     {
       // Tail region.
       const double q = x < 1 ? sqrt (-2*log (0.5*x)) : sqrt (-2*log (0.5*(2-x)));
       const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
       const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
       y = yn / yd;
-      if (x < 1-pbreak)
-        y *= -1;
+      if (x < pbreak_lo)
+        y = -y;
     }
   else if (x == 0.0)
     return octave_Inf;
   else if (x == 2.0)
     return -octave_Inf;
   else
     return octave_NaN;
 
@@ -3385,8 +3141,473 @@ double erfcx (double x)
 {
   return erfcx_impl (x);
 }
 
 float erfcx (float x)
 {
   return erfcx_impl (x);
 }
+
+//
+//  Incomplete Beta function ratio
+//
+//  Algorithm based on the one by John Burkardt.
+//  See http://people.sc.fsu.edu/~jburkardt/cpp_src/asa109/asa109.html
+//
+//  The original code is distributed under the GNU LGPL v3 license.
+//
+//  Reference:
+//
+//    KL Majumder, GP Bhattacharjee,
+//    Algorithm AS 63:
+//    The incomplete Beta Integral,
+//    Applied Statistics,
+//    Volume 22, Number 3, 1973, pages 409-411.
+//
+double
+betain (double x, double p, double q, double beta, bool& err)
+{
+  double acu = 0.1E-14, ai, cx;
+  bool indx;
+  int ns;
+  double pp, psq, qq, rx, temp, term, value, xx;
+
+  value = x;
+  err = false;
+
+  //  Check the input arguments.
+
+  if ((p <= 0.0 || q <= 0.0) || (x < 0.0 || 1.0 < x))
+    {
+      err = true;
+      return value;
+    }
+
+  //  Special cases.
+
+  if (x == 0.0 || x == 1.0)
+    {
+      return value;
+    }
+
+  //  Change tail if necessary and determine S.
+
+  psq = p + q;
+  cx = 1.0 - x;
+
+  if (p < psq * x)
+    {
+      xx = cx;
+      cx = x;
+      pp = q;
+      qq = p;
+      indx = true;
+    }
+  else
+    {
+      xx = x;
+      pp = p;
+      qq = q;
+      indx = false;
+    }
+
+  term = 1.0;
+  ai = 1.0;
+  value = 1.0;
+  ns = (int) (qq + cx * psq);
+
+  //  Use the Soper reduction formula.
+
+  rx = xx / cx;
+  temp = qq - ai;
+  if (ns == 0)
+    {
+      rx = xx;
+    }
+
+  for ( ; ; )
+    {
+      term = term * temp * rx / (pp + ai);
+      value = value + term;
+      temp = fabs (term);
+
+      if (temp <= acu && temp <= acu * value)
+        {
+          value = value * exp (pp * log (xx)
+          + (qq - 1.0) * log (cx) - beta) / pp;
+
+          if (indx)
+            {
+              value = 1.0 - value;
+            }
+          break;
+        }
+
+      ai = ai + 1.0;
+      ns = ns - 1;
+
+      if (0 <= ns)
+        {
+          temp = qq - ai;
+          if (ns == 0)
+            {
+              rx = xx;
+            }
+        }
+      else
+        {
+          temp = psq;
+          psq = psq + 1.0;
+        }
+    }
+
+  return value;
+}
+
+//
+//  Inverse of the incomplete Beta function
+//
+//  Algorithm based on the one by John Burkardt.
+//  See http://people.sc.fsu.edu/~jburkardt/cpp_src/asa109/asa109.html
+//
+//  The original code is distributed under the GNU LGPL v3 license.
+//
+//  Reference:
+//
+//    GW Cran, KJ Martin, GE Thomas,
+//    Remark AS R19 and Algorithm AS 109:
+//    A Remark on Algorithms AS 63: The Incomplete Beta Integral
+//    and AS 64: Inverse of the Incomplete Beta Integeral,
+//    Applied Statistics,
+//    Volume 26, Number 1, 1977, pages 111-114.
+//
+double
+betaincinv (double y, double p, double q) {
+  double a, acu, adj, fpu, g, h;
+  int iex;
+  bool indx;
+  double pp, prev, qq, r, s, sae = -37.0, sq, t, tx, value, w, xin, ycur, yprev;
+
+  double beta = xlgamma (p) + xlgamma (q) - xlgamma (p + q);
+  bool err = false;
+  fpu = pow (10.0, sae);
+  value = y;
+
+  //  Test for admissibility of parameters.
+
+  if (p <= 0.0 || q <= 0.0)
+    {
+      (*current_liboctave_error_handler)
+        ("betaincinv: wrong parameters");
+    }
+
+  if (y < 0.0 || 1.0 < y)
+    {
+      (*current_liboctave_error_handler)
+        ("betaincinv: wrong parameter Y");
+    }
+
+  if (y == 0.0 || y == 1.0)
+    {
+      return value;
+    }
+
+  //  Change tail if necessary.
+
+  if (0.5 < y)
+    {
+      a = 1.0 - y;
+      pp = q;
+      qq = p;
+      indx = true;
+    }
+  else
+    {
+      a = y;
+      pp = p;
+      qq = q;
+      indx = false;
+    }
+
+  //  Calculate the initial approximation.
+
+  r = sqrt (- log (a * a));
+
+  ycur = r - (2.30753 + 0.27061 * r) / (1.0 + (0.99229 + 0.04481 * r) * r);
+
+  if (1.0 < pp && 1.0 < qq)
+    {
+      r = (ycur * ycur - 3.0) / 6.0;
+      s = 1.0 / (pp + pp - 1.0);
+      t = 1.0 / (qq + qq - 1.0);
+      h = 2.0 / (s + t);
+      w = ycur * sqrt (h + r) / h - (t - s) * (r + 5.0 / 6.0 - 2.0 / (3.0 * h));
+      value = pp / (pp + qq * exp (w + w));
+    }
+  else
+    {
+      r = qq + qq;
+      t = 1.0 / (9.0 * qq);
+      t = r * pow (1.0 - t + ycur * sqrt (t), 3);
+
+      if (t <= 0.0)
+        {
+          value = 1.0 - exp ((log ((1.0 - a) * qq) + beta) / qq);
+        }
+      else
+        {
+          t = (4.0 * pp + r - 2.0) / t;
+
+          if (t <= 1.0)
+            {
+              value = exp ((log (a * pp) + beta) / pp);
+            }
+          else
+            {
+              value = 1.0 - 2.0 / (t + 1.0);
+            }
+        }
+    }
+
+  //  Solve for X by a modified Newton-Raphson method,
+  //  using the function BETAIN.
+
+  r = 1.0 - pp;
+  t = 1.0 - qq;
+  yprev = 0.0;
+  sq = 1.0;
+  prev = 1.0;
+
+  if (value < 0.0001)
+    {
+      value = 0.0001;
+    }
+
+  if (0.9999 < value)
+    {
+      value = 0.9999;
+    }
+
+  iex = std::max (- 5.0 / pp / pp - 1.0 / pow (a, 0.2) - 13.0, sae);
+
+  acu = pow (10.0, iex);
+
+  for ( ; ; )
+    {
+      ycur = betain (value, pp, qq, beta, err);
+
+      if (err)
+        {
+          return value;
+        }
+
+      xin = value;
+      ycur = (ycur - a) * exp (beta + r * log (xin) + t * log (1.0 - xin));
+
+      if (ycur * yprev <= 0.0)
+        {
+          prev = std::max (sq, fpu);
+        }
+
+      g = 1.0;
+
+      for ( ; ; )
+        {
+          for ( ; ; )
+            {
+              adj = g * ycur;
+              sq = adj * adj;
+
+              if (sq < prev)
+                {
+                  tx = value - adj;
+
+                  if (0.0 <= tx && tx <= 1.0)
+                    {
+                      break;
+                    }
+                }
+              g = g / 3.0;
+            }
+
+          if (prev <= acu)
+            {
+              if (indx)
+                {
+                  value = 1.0 - value;
+                }
+              return value;
+            }
+
+          if (ycur * ycur <= acu)
+            {
+              if (indx)
+                {
+                  value = 1.0 - value;
+                }
+              return value;
+            }
+
+          if (tx != 0.0 && tx != 1.0)
+            {
+              break;
+            }
+
+          g = g / 3.0;
+        }
+
+      if (tx == value)
+        {
+          break;
+        }
+
+      value = tx;
+      yprev = ycur;
+    }
+
+  if (indx)
+    {
+      value = 1.0 - value;
+    }
+
+  return value;
+}
+
+Array<double>
+betaincinv (double x, double a, const Array<double>& b)
+{
+  dim_vector dv = b.dims ();
+  octave_idx_type nel = dv.numel ();
+
+  Array<double> retval (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betaincinv (x, a, b(i));
+
+  return retval;
+}
+
+Array<double>
+betaincinv (double x, const Array<double>& a, double b)
+{
+  dim_vector dv = a.dims ();
+  octave_idx_type nel = dv.numel ();
+
+  Array<double> retval (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betaincinv (x, a(i), b);
+
+  return retval;
+}
+
+Array<double>
+betaincinv (double x, const Array<double>& a, const Array<double>& b)
+{
+  Array<double> retval;
+  dim_vector dv = a.dims ();
+
+  if (dv == b.dims ())
+    {
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x, a(i), b(i));
+    }
+  else
+    gripe_betaincinv_nonconformant (dim_vector (0, 0), dv, b.dims ());
+
+  return retval;
+}
+
+Array<double>
+betaincinv (const Array<double>& x, double a, double b)
+{
+  dim_vector dv = x.dims ();
+  octave_idx_type nel = dv.numel ();
+
+  Array<double> retval (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betaincinv (x(i), a, b);
+
+  return retval;
+}
+
+Array<double>
+betaincinv (const Array<double>& x, double a, const Array<double>& b)
+{
+  Array<double> retval;
+  dim_vector dv = x.dims ();
+
+  if (dv == b.dims ())
+    {
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x(i), a, b(i));
+    }
+  else
+    gripe_betaincinv_nonconformant (dv, dim_vector (0, 0), b.dims ());
+
+  return retval;
+}
+
+Array<double>
+betaincinv (const Array<double>& x, const Array<double>& a, double b)
+{
+  Array<double> retval;
+  dim_vector dv = x.dims ();
+
+  if (dv == a.dims ())
+    {
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x(i), a(i), b);
+    }
+  else
+    gripe_betaincinv_nonconformant (dv, a.dims (), dim_vector (0, 0));
+
+  return retval;
+}
+
+Array<double>
+betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b)
+{
+  Array<double> retval;
+  dim_vector dv = x.dims ();
+
+  if (dv == a.dims () && dv == b.dims ())
+    {
+      octave_idx_type nel = dv.numel ();
+
+      retval.resize (dv);
+
+      double *pretval = retval.fortran_vec ();
+
+      for (octave_idx_type i = 0; i < nel; i++)
+        *pretval++ = betaincinv (x(i), a(i), b(i));
+    }
+  else
+    gripe_betaincinv_nonconformant (dv, a.dims (), b.dims ());
+
+  return retval;
+}
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -515,52 +515,34 @@ biry (const FloatComplexMatrix& z, bool 
 
 extern OCTAVE_API FloatComplexNDArray
 airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API double betainc (double x, double a, double b);
-extern OCTAVE_API Matrix betainc (double x, double a, const Matrix& b);
-extern OCTAVE_API Matrix betainc (double x, const Matrix& a, double b);
-extern OCTAVE_API Matrix betainc (double x, const Matrix& a, const Matrix& b);
-
-extern OCTAVE_API NDArray betainc (double x, double a, const NDArray& b);
-extern OCTAVE_API NDArray betainc (double x, const NDArray& a, double b);
-extern OCTAVE_API NDArray betainc (double x, const NDArray& a, const NDArray& b);
-
-extern OCTAVE_API Matrix betainc (const Matrix& x, double a, double b);
-extern OCTAVE_API Matrix betainc (const Matrix& x, double a, const Matrix& b);
-extern OCTAVE_API Matrix betainc (const Matrix& x, const Matrix& a, double b);
-extern OCTAVE_API Matrix betainc (const Matrix& x, const Matrix& a, const Matrix& b);
-
-extern OCTAVE_API NDArray betainc (const NDArray& x, double a, double b);
-extern OCTAVE_API NDArray betainc (const NDArray& x, double a, const NDArray& b);
-extern OCTAVE_API NDArray betainc (const NDArray& x, const NDArray& a, double b);
-extern OCTAVE_API NDArray betainc (const NDArray& x, const NDArray& a, const NDArray& b);
+extern OCTAVE_API Array<double> betainc (double x, double a, const Array<double>& b);
+extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, double b);
+extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, const Array<double>& b);
+extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, double b);
+extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, double b);
+extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, const Array<double>& b);
+extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, double b);
+extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b);
 
 extern OCTAVE_API float betainc (float x, float a, float b);
-extern OCTAVE_API FloatMatrix betainc (float x, float a, const FloatMatrix& b);
-extern OCTAVE_API FloatMatrix betainc (float x, const FloatMatrix& a, float b);
-extern OCTAVE_API FloatMatrix betainc (float x, const FloatMatrix& a, const FloatMatrix& b);
-
-extern OCTAVE_API FloatNDArray betainc (float x, float a, const FloatNDArray& b);
-extern OCTAVE_API FloatNDArray betainc (float x, const FloatNDArray& a, float b);
-extern OCTAVE_API FloatNDArray betainc (float x, const FloatNDArray& a, const FloatNDArray& b);
-
-extern OCTAVE_API FloatMatrix betainc (const FloatMatrix& x, float a, float b);
-extern OCTAVE_API FloatMatrix betainc (const FloatMatrix& x, float a, const FloatMatrix& b);
-extern OCTAVE_API FloatMatrix betainc (const FloatMatrix& x, const FloatMatrix& a, float b);
-extern OCTAVE_API FloatMatrix betainc (const FloatMatrix& x, const FloatMatrix& a, const FloatMatrix& b);
-
-extern OCTAVE_API FloatNDArray betainc (const FloatNDArray& x, float a, float b);
-extern OCTAVE_API FloatNDArray betainc (const FloatNDArray& x, float a, const FloatNDArray& b);
-extern OCTAVE_API FloatNDArray betainc (const FloatNDArray& x, const FloatNDArray& a, float b);
-extern OCTAVE_API FloatNDArray betainc (const FloatNDArray& x, const FloatNDArray& a, const FloatNDArray& b);
+extern OCTAVE_API Array<float> betainc (float x, float a, const Array<float>& b);
+extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, float b);
+extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, const Array<float>& b);
+extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, float b);
+extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, float b);
+extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, const Array<float>& b);
+extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, float b);
+extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b);
 
 extern OCTAVE_API double gammainc (double x, double a, bool& err);
 extern OCTAVE_API Matrix gammainc (double x, const Matrix& a);
 extern OCTAVE_API Matrix gammainc (const Matrix& x, double a);
 extern OCTAVE_API Matrix gammainc (const Matrix& x, const Matrix& a);
 
 extern OCTAVE_API NDArray gammainc (double x, const NDArray& a);
 extern OCTAVE_API NDArray gammainc (const NDArray& x, double a);
@@ -594,9 +576,19 @@ extern OCTAVE_API double erfinv (double 
 extern OCTAVE_API float erfinv (float x);
 
 extern OCTAVE_API double erfcinv (double x);
 extern OCTAVE_API float erfcinv (float x);
 
 extern OCTAVE_API double erfcx (double x);
 extern OCTAVE_API float erfcx (float x);
 
+extern OCTAVE_API double betaincinv (double x, double a, double b);
+extern OCTAVE_API Array<double> betaincinv (double x, double a, const Array<double>& b);
+extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, double b);
+extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, const Array<double>& b);
+extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
+extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
+extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, const Array<double>& b);
+extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, double b);
+extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b);
+
 #endif
diff --git a/liboctave/lo-sysdep.cc b/liboctave/lo-sysdep.cc
--- a/liboctave/lo-sysdep.cc
+++ b/liboctave/lo-sysdep.cc
@@ -68,34 +68,34 @@ octave_getcwd (void)
 }
 
 int
 octave_chdir (const std::string& path_arg)
 {
   std::string path = file_ops::tilde_expand (path_arg);
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
-  if (path.length() == 2 && path[1] == ':')
+  if (path.length () == 2 && path[1] == ':')
     path += "\\";
 #endif
 
   return gnulib::chdir (path.c_str ());
 }
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 
 pid_t
 octave_popen2 (const std::string& cmd, const string_vector& args, bool sync_mode,
     int *fildes, std::string& msg)
 {
   pid_t pid;
   PROCESS_INFORMATION pi;
   STARTUPINFO si;
   std::string command = "\"" + cmd + "\"";
-  HANDLE hProcess = GetCurrentProcess(), childRead, childWrite, parentRead, parentWrite;
+  HANDLE hProcess = GetCurrentProcess (), childRead, childWrite, parentRead, parentWrite;
   DWORD pipeMode;
 
   ZeroMemory (&pi, sizeof (pi));
   ZeroMemory (&si, sizeof (si));
   si.cb = sizeof (si);
 
   if (! CreatePipe (&childRead, &parentWrite, 0, 0) ||
       ! DuplicateHandle (hProcess, childRead, hProcess, &childRead, 0, TRUE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
@@ -116,17 +116,17 @@ octave_popen2 (const std::string& cmd, c
     }
   fildes[1] = _open_osfhandle (reinterpret_cast<long> (parentRead), _O_RDONLY | _O_BINARY);
   fildes[0] = _open_osfhandle (reinterpret_cast<long> (parentWrite), _O_WRONLY | _O_BINARY);
   si.dwFlags |= STARTF_USESTDHANDLES;
   si.hStdInput = childRead;
   si.hStdOutput = childWrite;
 
   // Ignore first arg as it is the command
-  for (int k=1; k<args.length(); k++)
+  for (int k=1; k<args.length (); k++)
     command += " \"" + args[k] + "\"";
   OCTAVE_LOCAL_BUFFER (char, c_command, command.length () + 1);
   strcpy (c_command, command.c_str ());
   if (! CreateProcess (0, c_command, 0, 0, TRUE, 0, 0, 0, &si, &pi))
     {
       msg = "popen2: process creation failed";
       return -1;
     }
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -190,340 +190,190 @@ octave_fgetl (FILE *f, bool& eof)
   size_t len = retval.length ();
 
   if (retval[len-1] == '\n')
     retval.resize (len-1);
 
   return retval;
 }
 
-static inline double
-read_inf_nan_na (std::istream& is, char c0, char sign = '+')
+// Note that the caller is responsible for repositioning the stream on
+// failure.
+
+template <typename T>
+T
+read_inf_nan_na (std::istream& is, char c0)
 {
-  double d = 0.0;
+  T val = 0.0;
 
   switch (c0)
     {
     case 'i': case 'I':
       {
         char c1 = is.get ();
         if (c1 == 'n' || c1 == 'N')
           {
             char c2 = is.get ();
             if (c2 == 'f' || c2 == 'F')
-              d = sign == '-' ? -octave_Inf : octave_Inf;
+              val = std::numeric_limits<T>::infinity ();
             else
-              {
-                is.putback (c2);
-                is.putback (c1);
-                is.putback (c0);
-                is.setstate (std::ios::failbit);
-              }
+              is.setstate (std::ios::failbit);
           }
         else
-          {
-            is.putback (c1);
-            is.putback (c0);
-            is.setstate (std::ios::failbit);
-          }
+          is.setstate (std::ios::failbit);
       }
       break;
 
     case 'n': case 'N':
       {
         char c1 = is.get ();
         if (c1 == 'a' || c1 == 'A')
           {
             char c2 = is.get ();
             if (c2 == 'n' || c2 == 'N')
-              d = octave_NaN;
+              val = std::numeric_limits<T>::quiet_NaN ();
             else
-              {
-                is.putback (c2);
-                d = octave_NA;
-              }
+              val = octave_numeric_limits<T>::NA ();
           }
         else
-          {
-            is.putback (c1);
-            is.putback (c0);
-            is.setstate (std::ios::failbit);
-          }
+          is.setstate (std::ios::failbit);
       }
       break;
 
     default:
       abort ();
     }
 
-  return d;
+  return val;
 }
 
 // Read a double value.  Discard any sign on NaN and NA.
 
-template <>
+template <typename T>
 double
-octave_read_value (std::istream& is)
+octave_read_fp_value (std::istream& is)
 {
-  double d = 0.0;
+  T val = 0.0;
+
+  // FIXME -- resetting stream position is likely to fail unless we are
+  // reading from a file.
+  std::ios::streampos pos = is.tellg ();
 
   char c1 = ' ';
 
   while (isspace (c1))
     c1 = is.get ();
 
+  bool neg = false;
+
   switch (c1)
     {
     case '-':
-      {
-        char c2 = 0;
-        c2 = is.get ();
-        if (c2 == 'i' || c2 == 'I' || c2 == 'n' || c2 == 'N')
-          d = read_inf_nan_na (is, c2, c1);
-        else
-          {
-            is.putback (c2);
-            is.putback (c1);
-            is >> d;
-          }
-      }
-      break;
+      neg = true;
+      // fall through...
 
     case '+':
       {
         char c2 = 0;
         c2 = is.get ();
         if (c2 == 'i' || c2 == 'I' || c2 == 'n' || c2 == 'N')
-          d = read_inf_nan_na (is, c2, c1);
+          val = read_inf_nan_na<T> (is, c2);
         else
           {
             is.putback (c2);
-            is.putback (c1);
-            is >> d;
+            is >> val;
           }
+
+        if (neg && ! is.fail ())
+          val = -val;
       }
       break;
 
     case 'i': case 'I':
     case 'n': case 'N':
-      d = read_inf_nan_na (is, c1);
+      val = read_inf_nan_na<T> (is, c1);
       break;
 
     default:
       is.putback (c1);
-      is >> d;
+      is >> val;
+      break;
     }
 
-  return d;
+  std::ios::iostate status = is.rdstate ();
+  if (status & std::ios::failbit)
+    {
+      is.clear ();
+      is.seekg (pos);
+      is.setstate (status);
+    }
+
+  return val;
 }
 
-template <>
-Complex
-octave_read_value (std::istream& is)
+template <typename T>
+std::complex<T>
+octave_read_cx_fp_value (std::istream& is)
 {
-  double re = 0.0, im = 0.0;
+  T re = 0.0, im = 0.0;
 
-  Complex cx = 0.0;
+  std::complex<T> cx = 0.0;
 
   char ch = ' ';
 
   while (isspace (ch))
     ch = is.get ();
 
   if (ch == '(')
     {
-      re = octave_read_value<double> (is);
+      re = octave_read_value<T> (is);
       ch = is.get ();
 
       if (ch == ',')
         {
-          im = octave_read_value<double> (is);
+          im = octave_read_value<T> (is);
           ch = is.get ();
 
           if (ch == ')')
-            cx = Complex (re, im);
+            cx = std::complex<T> (re, im);
           else
             is.setstate (std::ios::failbit);
         }
       else if (ch == ')')
         cx = re;
       else
         is.setstate (std::ios::failbit);
     }
   else
     {
       is.putback (ch);
       cx = octave_read_value<double> (is);
     }
 
   return cx;
-
 }
 
-static inline float
-read_float_inf_nan_na (std::istream& is, char c0, char sign = '+')
+template <> OCTAVE_API double octave_read_value (std::istream& is)
 {
-  float d = 0.0;
-
-  switch (c0)
-    {
-    case 'i': case 'I':
-      {
-        char c1 = is.get ();
-        if (c1 == 'n' || c1 == 'N')
-          {
-            char c2 = is.get ();
-            if (c2 == 'f' || c2 == 'F')
-              d = sign == '-' ? -octave_Float_Inf : octave_Float_Inf;
-            else
-              {
-                is.putback (c2);
-                is.putback (c1);
-                is.putback (c0);
-                is.setstate (std::ios::failbit);
-              }
-          }
-        else
-          {
-            is.putback (c1);
-            is.putback (c0);
-            is.setstate (std::ios::failbit);
-          }
-      }
-      break;
-
-    case 'n': case 'N':
-      {
-        char c1 = is.get ();
-        if (c1 == 'a' || c1 == 'A')
-          {
-            char c2 = is.get ();
-            if (c2 == 'n' || c2 == 'N')
-              d = octave_Float_NaN;
-            else
-              {
-                is.putback (c2);
-                d = octave_Float_NA;
-              }
-          }
-        else
-          {
-            is.putback (c1);
-            is.putback (c0);
-            is.setstate (std::ios::failbit);
-          }
-      }
-      break;
-
-    default:
-      abort ();
-    }
-
-  return d;
+  return octave_read_fp_value<double> (is);
 }
 
-// Read a float value.  Discard any sign on NaN and NA.
-
-template <>
-float
-octave_read_value (std::istream& is)
+template <> OCTAVE_API Complex octave_read_value (std::istream& is)
 {
-  float d = 0.0;
-
-  char c1 = ' ';
-
-  while (isspace (c1))
-    c1 = is.get ();
-
-  switch (c1)
-    {
-    case '-':
-      {
-        char c2 = 0;
-        c2 = is.get ();
-        if (c2 == 'i' || c2 == 'I' || c2 == 'n' || c2 == 'N')
-          d = read_float_inf_nan_na (is, c2, c1);
-        else
-          {
-            is.putback (c2);
-            is.putback (c1);
-            is >> d;
-          }
-      }
-      break;
-
-    case '+':
-      {
-        char c2 = 0;
-        c2 = is.get ();
-        if (c2 == 'i' || c2 == 'I' || c2 == 'n' || c2 == 'N')
-          d = read_float_inf_nan_na (is, c2, c1);
-        else
-          {
-            is.putback (c2);
-            is.putback (c1);
-            is >> d;
-          }
-      }
-      break;
-
-    case 'i': case 'I':
-    case 'n': case 'N':
-      d = read_float_inf_nan_na (is, c1);
-      break;
-
-    default:
-      is.putback (c1);
-      is >> d;
-    }
-
-  return d;
+  return octave_read_cx_fp_value<double> (is);
 }
 
-template <>
-FloatComplex
-octave_read_value (std::istream& is)
+template <> OCTAVE_API float octave_read_value (std::istream& is)
 {
-  float re = 0.0, im = 0.0;
-
-  FloatComplex cx = 0.0;
-
-  char ch = ' ';
-
-  while (isspace (ch))
-    ch = is.get ();
-
-  if (ch == '(')
-    {
-      re = octave_read_value<float> (is);
-      ch = is.get ();
+  return octave_read_fp_value<float> (is);
+}
 
-      if (ch == ',')
-        {
-          im = octave_read_value<float> (is);
-          ch = is.get ();
-
-          if (ch == ')')
-            cx = FloatComplex (re, im);
-          else
-            is.setstate (std::ios::failbit);
-        }
-      else if (ch == ')')
-        cx = re;
-      else
-        is.setstate (std::ios::failbit);
-    }
-  else
-    {
-      is.putback (ch);
-      cx = octave_read_value<float> (is);
-    }
-
-  return cx;
-
+template <> OCTAVE_API FloatComplex octave_read_value (std::istream& is)
+{
+  return octave_read_cx_fp_value<float> (is);
 }
 
 void
 octave_write_double (std::ostream& os, double d)
 {
   if (lo_ieee_is_NA (d))
     os << "NA";
   else if (lo_ieee_isnan (d))
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -57,17 +57,17 @@ template <class R> \
 inline void F (size_t n, R *r) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = OP r[i]; }
 
 DEFMXUNOPEQ (mx_inline_uminus2, -)
 
 #define DEFMXUNBOOLOP(F, OP) \
 template <class X> \
 inline void F (size_t n, bool *r, const X *x) throw () \
-{ const X zero = X(); for (size_t i = 0; i < n; i++) r[i] = x[i] OP zero; }
+{ const X zero = X (); for (size_t i = 0; i < n; i++) r[i] = x[i] OP zero; }
 
 DEFMXUNBOOLOP (mx_inline_iszero, ==)
 DEFMXUNBOOLOP (mx_inline_notzero, !=)
 
 #define DEFMXBINOP(F, OP) \
 template <class R, class X, class Y> \
 inline void F (size_t n, R *r, const X *x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = x[i] OP y[i]; } \
diff --git a/liboctave/oct-binmap.h b/liboctave/oct-binmap.h
--- a/liboctave/oct-binmap.h
+++ b/liboctave/oct-binmap.h
@@ -260,17 +260,17 @@ binmap (const Sparse<T>& xs, const Spars
     return binmap<U, T, R, F> (xs, ys(0,0), fcn);
   else if (xs.dims () != ys.dims ())
     gripe_nonconformant (name, xs.dims (), ys.dims ());
 
   T xzero = T ();
   R yzero = R ();
 
   U fz = fcn (xzero, yzero);
-  if (fz == U())
+  if (fz == U ())
     {
       // Sparsity-preserving function. Do it efficiently.
       octave_idx_type nr = xs.rows (), nc = xs.cols ();
       Sparse<T> retval (nr, nc);
 
       octave_idx_type nz = 0;
       // Count nonzeros.
       for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/oct-convn.cc b/liboctave/oct-convn.cc
--- a/liboctave/oct-convn.cc
+++ b/liboctave/oct-convn.cc
@@ -120,17 +120,17 @@ convolve (const MArray<T>& a, const MArr
       if (ct == convn_valid)
         cdims(i) = std::max (adims(i) - bdims(i) + 1,
                              static_cast<octave_idx_type> (0));
       else
         cdims(i) = std::max (adims(i) + bdims(i) - 1,
                              static_cast<octave_idx_type> (0));
     }
 
-  MArray<T> c (cdims, T());
+  MArray<T> c (cdims, T ());
 
   convolve_nd<T, R> (a.fortran_vec (), adims, adims.cumulative (),
                      b.fortran_vec (), bdims, bdims.cumulative (),
                      c.fortran_vec (), cdims.cumulative (), nd, ct == convn_valid);
 
   if (ct == convn_same)
     {
       // Pick the relevant part.
diff --git a/liboctave/oct-md5.cc b/liboctave/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/oct-md5.cc
@@ -74,12 +74,12 @@ oct_md5_file (const std::string file)
 
       if (! errflag)
         retval = oct_md5_result_to_str (buf);
       else
         (*current_liboctave_error_handler) ("internal error in md5_stream");
     }
   else
     (*current_liboctave_error_handler) ("unable to open file `%s' for reading",
-                                        file.c_str());
+                                        file.c_str ());
 
   return retval;
 }
diff --git a/liboctave/oct-mem.h b/liboctave/oct-mem.h
--- a/liboctave/oct-mem.h
+++ b/liboctave/oct-mem.h
@@ -87,17 +87,17 @@ template <class T>
 inline bool helper_is_zero_mem (const std::complex<T>& value)
 {
   return (helper_is_zero_mem (value.real ())
           && helper_is_zero_mem (value.imag ()));
 }
 
 template <class T>
 inline bool helper_is_zero_mem (const octave_int<T>& value)
-{ return value.value () == T(); }
+{ return value.value () == T (); }
 
 #define DEFINE_POD_FILL(T) \
 inline void fill_or_memset (size_t n, const T& value, T *dest) \
 { \
   if (helper_is_zero_mem (value)) \
     std::memset (dest, 0, n * sizeof (T)); \
   else \
     std::fill_n (dest, n, value); \
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -508,66 +508,66 @@ Array<double>
 octave_rand::do_vector (octave_idx_type n, double a)
 {
   Array<double> retval;
 
   if (n > 0)
     {
       retval.clear (n, 1);
 
-      fill (retval.capacity(), retval.fortran_vec(), a);
+      fill (retval.capacity (), retval.fortran_vec (), a);
     }
   else if (n < 0)
     (*current_liboctave_error_handler) ("rand: invalid negative argument");
 
   return retval;
 }
 
 Array<float>
 octave_rand::do_float_vector (octave_idx_type n, float a)
 {
   Array<float> retval;
 
   if (n > 0)
     {
       retval.clear (n, 1);
 
-      fill (retval.capacity(), retval.fortran_vec(), a);
+      fill (retval.capacity (), retval.fortran_vec (), a);
     }
   else if (n < 0)
     (*current_liboctave_error_handler) ("rand: invalid negative argument");
 
   return retval;
 }
 
 NDArray
 octave_rand::do_nd_array (const dim_vector& dims, double a)
 {
   NDArray retval;
 
   if (! dims.all_zero ())
     {
       retval.clear (dims);
 
-      fill (retval.capacity(), retval.fortran_vec(), a);
+      fill (retval.capacity (), retval.fortran_vec (), a);
     }
 
   return retval;
 }
 
 FloatNDArray
 octave_rand::do_float_nd_array (const dim_vector& dims, float a)
 {
   FloatNDArray retval;
 
   if (! dims.all_zero ())
     {
       retval.clear (dims);
 
-      fill (retval.capacity(), retval.fortran_vec(), a);
+      fill (retval.capacity (), retval.fortran_vec (), a);
     }
 
   return retval;
 }
 
 // Make the random number generator give us a different sequence every
 // time we start octave unless we specifically set the seed.  The
 // technique used below will cycle monthly, but it it does seem to
@@ -575,21 +575,21 @@ octave_rand::do_float_nd_array (const di
 
 void
 octave_rand::initialize_ranlib_generators (void)
 {
   octave_localtime tm;
   int stored_distribution = current_distribution;
   F77_FUNC (setcgn, SETCGN) (uniform_dist);
 
-  int hour = tm.hour() + 1;
-  int minute = tm.min() + 1;
-  int second = tm.sec() + 1;
+  int hour = tm.hour () + 1;
+  int minute = tm.min () + 1;
+  int second = tm.sec () + 1;
 
-  int32_t s0 = tm.mday() * hour * minute * second;
+  int32_t s0 = tm.mday () * hour * minute * second;
   int32_t s1 = hour * minute * second;
 
   s0 = force_to_fit_range (s0, 1, 2147483563);
   s1 = force_to_fit_range (s1, 1, 2147483399);
 
   F77_FUNC (setall, SETALL) (s0, s1);
   F77_FUNC (setcgn, SETCGN) (stored_distribution);
 }
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -351,17 +351,17 @@ octave_syscalls::popen2 (const std::stri
                         child_msg = "popen2 (child): unable to start process -- " + child_msg;
                     }
                   else
                     child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
                 }
               else
                 child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
 
-              (*current_liboctave_error_handler)(child_msg.c_str());
+              (*current_liboctave_error_handler)(child_msg.c_str ());
 
               exit(0);
             }
           else
             {
               // Parent process
               gnulib::close (child_stdin[0]);
               gnulib::close (child_stdout[1]);
diff --git a/liboctave/randgamma.c b/liboctave/randgamma.c
--- a/liboctave/randgamma.c
+++ b/liboctave/randgamma.c
@@ -53,17 +53,17 @@ gamma(a,b) for a>0, b>0 (from R)
 beta(a,b) for a>0, b>0
   r1 = randg(a,1)
   r = r1 / (r1 + randg(b,1))
 Erlang(a,n)
   r = a*randg(n)
 chisq(df) for df>0
   r = 2*randg(df/2)
 t(df) for 0<df<inf (use randn if df is infinite)
-  r = randn() / sqrt(2*randg(df/2)/df)
+  r = randn () / sqrt(2*randg(df/2)/df)
 F(n1,n2) for 0<n1, 0<n2
   r1 = 2*randg(n1/2)/n1 or 1 if n1 is infinite
   r2 = 2*randg(n2/2)/n2 or 1 if n2 is infinite
   r = r1 / r2
 negative binonial (n, p) for n>0, 0<p<=1
   r = randp((1-p)/p * randg(n))
   (from R, citing Devroye(1986), Non-Uniform Random Variate Generation)
 non-central chisq(df,L), for df>=0 and L>0 (use chisq if L=0)
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -272,17 +272,17 @@ oct_init_by_entropy (void)
           }
         fclose(urandom);
       }
 
     /* If there isn't enough entropy, gather some from various sources */
     if (n < MT_N)
       entropy[n++] = time(NULL); /* Current time in seconds */
     if (n < MT_N)
-      entropy[n++] = clock();    /* CPU time used (usec) */
+      entropy[n++] = clock ();    /* CPU time used (usec) */
 #ifdef HAVE_GETTIMEOFDAY
     if (n < MT_N)
       {
         struct timeval tv;
         if (gettimeofday(&tv, NULL) != -1)
           entropy[n++] = tv.tv_usec;   /* Fractional part of current time */
       }
 #endif
@@ -315,17 +315,17 @@ next_state (void)
   uint32_t *p = state;
   int j;
 
   /* if init_by_int() has not been called, */
   /* a default initial seed is used         */
   /* if (initf==0) init_by_int(5489UL); */
   /* Or better yet, a random seed! */
   if (initf == 0)
-    oct_init_by_entropy();
+    oct_init_by_entropy ();
 
   left = MT_N;
   next = state;
 
   for (j = MT_N - MT_M + 1; --j; p++)
     *p = p[MT_M] ^ TWIST(p[0], p[1]);
 
   for (j = MT_M; --j; p++)
@@ -336,17 +336,17 @@ next_state (void)
 
 /* generates a random number on [0,0xffffffff]-interval */
 static uint32_t
 randmt (void)
 {
   register uint32_t y;
 
   if (--left == 0)
-    next_state();
+    next_state ();
   y = *next++;
 
   /* Tempering */
   y ^= (y >> 11);
   y ^= (y << 7) & 0x9d2c5680UL;
   y ^= (y << 15) & 0xefc60000UL;
   return (y ^ (y >> 18));
 }
@@ -354,59 +354,59 @@ randmt (void)
 /* ===== Uniform generators ===== */
 
 /* Select which 32 bit generator to use */
 #define randi32 randmt
 
 static uint64_t
 randi53 (void)
 {
-  const uint32_t lo = randi32();
-  const uint32_t hi = randi32()&0x1FFFFF;
+  const uint32_t lo = randi32 ();
+  const uint32_t hi = randi32 ()&0x1FFFFF;
 #if HAVE_X86_32
   uint64_t u;
   uint32_t *p = (uint32_t *)&u;
   p[0] = lo;
   p[1] = hi;
   return u;
 #else
   return (((uint64_t)hi<<32)|lo);
 #endif
 }
 
 static uint64_t
 randi54 (void)
 {
-  const uint32_t lo = randi32();
-  const uint32_t hi = randi32()&0x3FFFFF;
+  const uint32_t lo = randi32 ();
+  const uint32_t hi = randi32 ()&0x3FFFFF;
 #if HAVE_X86_32
   uint64_t u;
   uint32_t *p = (uint32_t *)&u;
   p[0] = lo;
   p[1] = hi;
   return u;
 #else
   return (((uint64_t)hi<<32)|lo);
 #endif
 }
 
 /* generates a random number on (0,1)-real-interval */
 static float
 randu32 (void)
 {
-  return ((float)randi32() + 0.5) * (1.0/4294967296.0);
+  return ((float)randi32 () + 0.5) * (1.0/4294967296.0);
   /* divided by 2^32 */
 }
 
 /* generates a random number on (0,1) with 53-bit resolution */
 static double
 randu53 (void)
 {
-  const uint32_t a=randi32()>>5;
-  const uint32_t b=randi32()>>6;
+  const uint32_t a=randi32 ()>>5;
+  const uint32_t b=randi32 ()>>6;
   return (a*67108864.0+b+0.4) * (1.0/9007199254740992.0);
 }
 
 /* Determine mantissa for uniform doubles */
 double
 oct_randu (void)
 {
   return randu53 ();
@@ -559,17 +559,17 @@ create_ziggurat_tables (void)
  * Where f is the functional form of the distribution, which for a normal
  * distribution is exp(-0.5*x*x)
  */
 
 double
 oct_randn (void)
 {
   if (initt)
-    create_ziggurat_tables();
+    create_ziggurat_tables ();
 
   while (1)
     {
       /* The following code is specialized for 32-bit mantissa.
        * Compared to the arbitrary mantissa code, there is a performance
        * gain for 32-bits:  PPC: 2%, MIPS: 8%, x86: 40%
        * There is a bigger performance gain compared to using a full
        * 53-bit mantissa:  PPC: 60%, MIPS: 65%, x86: 240%
@@ -578,19 +578,19 @@ oct_randn (void)
        */
 # if HAVE_X86_32
       /* 53-bit mantissa, 1-bit sign, x86 32-bit architecture */
       double x;
       int si,idx;
       register uint32_t lo, hi;
       int64_t rabs;
       uint32_t *p = (uint32_t *)&rabs;
-      lo = randi32();
+      lo = randi32 ();
       idx = lo&0xFF;
-      hi = randi32();
+      hi = randi32 ();
       si = hi&UMASK;
       p[0] = lo;
       p[1] = hi&0x1FFFFF;
       x = ( si ? -rabs : rabs ) * wi[idx];
 # else /* !HAVE_X86_32 */
       /* arbitrary mantissa (selected by NRANDI, with 1 bit for sign) */
       const uint64_t r = NRANDI;
       const int64_t rabs=r>>1;
@@ -624,17 +624,17 @@ oct_randn (void)
         return x;
     }
 }
 
 double
 oct_rande (void)
 {
   if (initt)
-    create_ziggurat_tables();
+    create_ziggurat_tables ();
 
   while (1)
     {
       ZIGINT ri = ERANDI;
       const int idx = (int)(ri & 0xFF);
       const double x = ri * we[idx];
       if (ri < ke[idx])
         return x;               // 98.9% of the time we return here 1st try
@@ -750,22 +750,22 @@ create_ziggurat_float_tables (void)
  * Where f is the functional form of the distribution, which for a normal
  * distribution is exp(-0.5*x*x)
  */
 
 float
 oct_float_randn (void)
 {
   if (inittf)
-    create_ziggurat_float_tables();
+    create_ziggurat_float_tables ();
 
   while (1)
     {
       /* 32-bit mantissa */
-      const uint32_t r = randi32();
+      const uint32_t r = randi32 ();
       const uint32_t rabs = r&LMASK;
       const int idx = (int)(r&0xFF);
       const float x = ((int32_t)r) * fwi[idx];
       if (rabs < fki[idx])
         return x;        /* 99.3% of the time we return here 1st try */
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
@@ -791,17 +791,17 @@ oct_float_randn (void)
         return x;
     }
 }
 
 float
 oct_float_rande (void)
 {
   if (inittf)
-    create_ziggurat_float_tables();
+    create_ziggurat_float_tables ();
 
   while (1)
     {
       ZIGINT ri = ERANDI;
       const int idx = (int)(ri & 0xFF);
       const float x = ri * fwe[idx];
       if (ri < fke[idx])
         return x;               // 98.9% of the time we return here 1st try
@@ -820,50 +820,50 @@ oct_float_rande (void)
 }
 
 /* Array generators */
 void
 oct_fill_randu (octave_idx_type n, double *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_randu();
+    p[i] = oct_randu ();
 }
 
 void
 oct_fill_randn (octave_idx_type n, double *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_randn();
+    p[i] = oct_randn ();
 }
 
 void
 oct_fill_rande (octave_idx_type n, double *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_rande();
+    p[i] = oct_rande ();
 }
 
 void
 oct_fill_float_randu (octave_idx_type n, float *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_float_randu();
+    p[i] = oct_float_randu ();
 }
 
 void
 oct_fill_float_randn (octave_idx_type n, float *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_float_randn();
+    p[i] = oct_float_randn ();
 }
 
 void
 oct_fill_float_rande (octave_idx_type n, float *p)
 {
   octave_idx_type i;
   for (i = 0; i < n; i++)
-    p[i] = oct_float_rande();
+    p[i] = oct_float_rande ();
 }
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -124,19 +124,19 @@ sparse_base_chol<chol_type, chol_elt, p_
   cm->final_resymbol = false;
 
   cholmod_sparse A;
   cholmod_sparse *ac = &A;
   double dummy;
   ac->nrow = a_nr;
   ac->ncol = a_nc;
 
-  ac->p = a.cidx();
-  ac->i = a.ridx();
-  ac->nzmax = a.nnz();
+  ac->p = a.cidx ();
+  ac->i = a.ridx ();
+  ac->nzmax = a.nnz ();
   ac->packed = true;
   ac->sorted = true;
   ac->nz = 0;
 #ifdef IDX_TYPE_LONG
   ac->itype = CHOLMOD_LONG;
 #else
   ac->itype = CHOLMOD_INT;
 #endif
@@ -146,17 +146,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   ac->xtype = OCTAVE_CHOLMOD_TYPE;
 #else
   ac->xtype = CHOLMOD_REAL;
 #endif
 
   if (a_nr < 1)
     ac->x = &dummy;
   else
-    ac->x = a.data();
+    ac->x = a.data ();
 
   // use natural ordering if no q output parameter
   if (natural)
     {
       cm->nmethods = 1 ;
       cm->method [0].ordering = CHOLMOD_NATURAL ;
       cm->postorder = false ;
     }
@@ -219,30 +219,30 @@ sparse_base_chol<chol_type, chol_elt, p_
   return info;
 }
 
 template <class chol_type, class chol_elt, class p_type>
 chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::L (void) const
 {
 #ifdef HAVE_CHOLMOD
-  cholmod_sparse *m = rep->L();
+  cholmod_sparse *m = rep->L ();
   octave_idx_type nc = m->ncol;
   octave_idx_type nnz = m->nzmax;
   chol_type ret (m->nrow, nc, nnz);
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx(j) = static_cast<octave_idx_type *>(m->p)[j];
   for (octave_idx_type i = 0; i < nnz; i++)
     {
       ret.xridx(i) = static_cast<octave_idx_type *>(m->i)[i];
       ret.xdata(i) = static_cast<chol_elt *>(m->x)[i];
     }
   return ret;
 #else
-  return chol_type();
+  return chol_type ();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
 p_type
 sparse_base_chol<chol_type, chol_elt, p_type>::
 sparse_base_chol_rep::Q (void) const
 {
@@ -255,37 +255,37 @@ sparse_base_chol_rep::Q (void) const
       p.xcidx(i) = i;
       p.xridx(i) = static_cast<octave_idx_type>(perms(i));
       p.xdata(i) = 1;
     }
   p.xcidx(n) = n;
 
   return p;
 #else
-  return p_type();
+  return p_type ();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
 chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::inverse (void) const
 {
   chol_type retval;
 #ifdef HAVE_CHOLMOD
-  cholmod_sparse *m = rep->L();
+  cholmod_sparse *m = rep->L ();
   octave_idx_type n = m->ncol;
-  ColumnVector perms = rep->perm();
+  ColumnVector perms = rep->perm ();
   chol_type ret;
   double rcond2;
   octave_idx_type info;
   MatrixType mattype (MatrixType::Upper);
-  chol_type linv = L().hermitian().inverse(mattype, info, rcond2, 1, 0);
+  chol_type linv = L ().hermitian ().inverse(mattype, info, rcond2, 1, 0);
 
-  if (perms.length() == n)
+  if (perms.length () == n)
     {
-      p_type Qc = Q();
-      retval = Qc * linv * linv.hermitian() * Qc.transpose();
+      p_type Qc = Q ();
+      retval = Qc * linv * linv.hermitian () * Qc.transpose ();
     }
   else
     retval = linv * linv.hermitian ();
 #endif
   return retval;
 }
diff --git a/liboctave/sparse-base-chol.h b/liboctave/sparse-base-chol.h
--- a/liboctave/sparse-base-chol.h
+++ b/liboctave/sparse-base-chol.h
@@ -193,25 +193,25 @@ public:
           rep->count++;
         }
 
       return *this;
     }
 
   chol_type L (void) const;
 
-  chol_type R (void) const { return L().hermitian (); }
+  chol_type R (void) const { return L ().hermitian (); }
 
-  octave_idx_type P (void) const { return rep->P(); }
+  octave_idx_type P (void) const { return rep->P (); }
 
-  ColumnVector perm (void) const { return rep->perm(); }
+  ColumnVector perm (void) const { return rep->perm (); }
 
-  p_type Q (void) const { return rep->Q(); }
+  p_type Q (void) const { return rep->Q (); }
 
   bool is_positive_definite (void) const
-    { return rep->is_positive_definite(); }
+    { return rep->is_positive_definite (); }
 
-  double rcond (void) const { return rep->rcond(); }
+  double rcond (void) const { return rep->rcond (); }
 
   chol_type inverse (void) const;
 };
 
 #endif
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/sparse-base-lu.cc
--- a/liboctave/sparse-base-lu.cc
+++ b/liboctave/sparse-base-lu.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 lu_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Y (void) const
 {
   octave_idx_type nr = Lfact.rows ();
   octave_idx_type nc = Ufact.rows ();
   octave_idx_type rcmin = (nr > nc ? nr : nc);
 
-  lu_type Yout (nr, nc, Lfact.nnz() + Ufact.nnz());
+  lu_type Yout (nr, nc, Lfact.nnz () + Ufact.nnz ());
   octave_idx_type ii = 0;
   Yout.xcidx(0) = 0;
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx(j + 1); i++)
         {
           Yout.xridx (ii) = Ufact.ridx(i);
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -68,17 +68,17 @@ dmsolve_extract (const MSparse<T> &A, co
             }
         }
       B.xcidx (cend - cst) = nz ;
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, X, rend - rst);
       octave_sort<octave_idx_type> sort;
-      octave_idx_type *ri = B.xridx();
+      octave_idx_type *ri = B.xridx ();
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
           octave_idx_type qq = (Q ? Q [j] : j);
           B.xcidx (j - cst) = nz;
           for (octave_idx_type p = A.cidx(qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
@@ -153,21 +153,21 @@ dmsolve_extract (const MArray<Complex> &
                  octave_idx_type c2)
 #endif
 
 template <class T>
 static void
 dmsolve_insert (MArray<T> &a, const MArray<T> &b, const octave_idx_type *Q,
                octave_idx_type r, octave_idx_type c)
 {
-  T *ax = a.fortran_vec();
-  const T *bx = b.fortran_vec();
-  octave_idx_type anr = a.rows();
-  octave_idx_type nr = b.rows();
-  octave_idx_type nc = b.cols();
+  T *ax = a.fortran_vec ();
+  const T *bx = b.fortran_vec ();
+  octave_idx_type anr = a.rows ();
+  octave_idx_type nr = b.rows ();
+  octave_idx_type nc = b.cols ();
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type aoff = (c + j) * anr;
       octave_idx_type boff = j * nr;
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
           ax [Q [r + i] + aoff] = bx [i + boff];
@@ -209,17 +209,17 @@ dmsolve_insert (MSparse<T> &a, const MSp
     for (octave_idx_type j = a.xcidx(i); j < a.xcidx(i+1); j++)
       if (Qinv [a.xridx(j)] < r || Qinv [a.xridx(j)] >= r + b_rows)
         nel++;
 
   OCTAVE_LOCAL_BUFFER (T, X, nr);
   octave_sort<octave_idx_type> sort;
   MSparse<T> tmp (a);
   a = MSparse<T> (nr, nc, nel);
-  octave_idx_type *ri = a.xridx();
+  octave_idx_type *ri = a.xridx ();
 
   for (octave_idx_type i = 0; i < tmp.cidx(c); i++)
     {
       a.xdata(i) = tmp.xdata(i);
       a.xridx(i) = tmp.xridx(i);
     }
   for (octave_idx_type i = 0; i < c + 1; i++)
     a.xcidx(i) = tmp.xcidx(i);
@@ -273,19 +273,19 @@ dmsolve_insert (MSparse<Complex> &a, con
 #endif
 
 template <class T, class RT>
 static void
 dmsolve_permute (MArray<RT> &a, const MArray<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
-  const T *Bx = b.fortran_vec();
+  const T *Bx = b.fortran_vec ();
   a.resize (dim_vector (b_nr, b_nc));
-  RT *Btx = a.fortran_vec();
+  RT *Btx = a.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       octave_idx_type off = j * b_nr;
       for (octave_idx_type i = 0; i < b_nr; i++)
         {
           octave_quit ();
           Btx [p [i] + off] = Bx [ i + off];
         }
@@ -311,17 +311,17 @@ static void
 dmsolve_permute (MSparse<RT> &a, const MSparse<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nz = b.nnz ();
   octave_idx_type nz = 0;
   a = MSparse<RT> (b_nr, b_nc, b_nz);
   octave_sort<octave_idx_type> sort;
-  octave_idx_type *ri = a.xridx();
+  octave_idx_type *ri = a.xridx ();
   OCTAVE_LOCAL_BUFFER (RT, X, b_nr);
   a.xcidx(0) = 0;
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
         {
           octave_quit ();
           octave_idx_type r = p [b.ridx (i)];
@@ -406,39 +406,39 @@ dmsolve (const ST &a, const T &b, octave
       info = 0;
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
       if (dm->rr [2] < nr && dm->cc [3] < nc)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr [2], nr, dm->cc [3], nc,
                                   nnz_remaining, true);
-          nnz_remaining -= m.nnz();
+          nnz_remaining -= m.nnz ();
           RT mtmp =
             qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
                                          b_nc), info);
           dmsolve_insert (retval, mtmp, q, dm->cc [3], 0);
           if (dm->rr [2] > 0 && !info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr [2],
                                    dm->cc [3], nc, nnz_remaining, true);
-              nnz_remaining -= m.nnz();
+              nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[2], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Structurally non-singular blocks
       // FIXME Should use fine Dulmange-Mendelsohn decomposition here.
       if (dm->rr [1] < dm->rr [2] && dm->cc [2] < dm->cc [3] && !info)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2],
                                   dm->cc [2], dm->cc [3], nnz_remaining, false);
-          nnz_remaining -= m.nnz();
+          nnz_remaining -= m.nnz ();
           RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr [1], dm->rr [2],
                                       0, b_nc);
           double rcond = 0.0;
           MatrixType mtyp (MatrixType::Full);
           RT mtmp = m.solve (mtyp, btmp2, info, rcond,
                              solve_singularity_warning, false);
           if (info != 0)
             {
@@ -446,17 +446,17 @@ dmsolve (const ST &a, const T &b, octave
               mtmp = qrsolve (m, btmp2, info);
             }
 
           dmsolve_insert (retval, mtmp, q, dm->cc [2], 0);
           if (dm->rr [1] > 0 && !info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], dm->cc [2],
                                    dm->cc [3], nnz_remaining, true);
-              nnz_remaining -= m.nnz();
+              nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[1], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Trailing under-determined block
       if (dm->rr [1] > 0 && dm->cc [2] > 0 && !info)
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -207,17 +207,18 @@ string_vector::delete_c_str_vec (const c
     delete [] *p++;
 
   delete [] v;
 }
 
 // Format a list in neat columns.
 
 std::ostream&
-string_vector::list_in_columns (std::ostream& os, int width) const
+string_vector::list_in_columns (std::ostream& os, int width,
+                                const std::string& prefix) const
 {
   // Compute the maximum name length.
 
   octave_idx_type max_name_length = 0;
   octave_idx_type total_names = length ();
 
   if (total_names == 0)
     {
@@ -236,17 +237,18 @@ string_vector::list_in_columns (std::ost
 
   // Allow at least two spaces between names.
 
   max_name_length += 2;
 
   // Calculate the maximum number of columns that will fit.
 
   octave_idx_type line_length
-    = (width <= 0) ? command_editor::terminal_cols () : width;
+    = ((width <= 0 ? command_editor::terminal_cols () : width)
+       - prefix.length ());
 
   octave_idx_type nc = line_length / max_name_length;
   if (nc == 0)
     nc = 1;
 
   // Calculate the number of rows that will be in each column except
   // possibly  for a short column on the right.
 
@@ -259,16 +261,18 @@ string_vector::list_in_columns (std::ost
   octave_idx_type count;
   for (octave_idx_type row = 0; row < nr; row++)
     {
       count = row;
       octave_idx_type pos = 0;
 
       // Print the next row.
 
+      os << prefix;
+
       while (1)
         {
           std::string nm = elem (count);
 
           os << nm;
           octave_idx_type name_length = nm.length ();
 
           count += nr;
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -106,12 +106,14 @@ public:
   string_vector& append (const string_vector& sv);
 
   std::string join (const std::string& sep = std::string ()) const;
 
   char **c_str_vec (void) const;
 
   static void delete_c_str_vec (const char * const*);
 
-  std::ostream& list_in_columns (std::ostream&, int width = 0) const;
+  std::ostream&
+  list_in_columns (std::ostream&, int width = 0,
+                   const std::string& prefix = std::string ()) const;
 };
 
 #endif
diff --git a/liboctave/tempname.c b/liboctave/tempname.c
--- a/liboctave/tempname.c
+++ b/liboctave/tempname.c
@@ -102,17 +102,17 @@ char *
                       FILE **streamptr)
 {
   int saverrno = errno;
   static const char tmpdir[] = P_tmpdir;
   static size_t indices[2];
   size_t *idx;
   static char buf[FILENAME_MAX];
   static pid_t oldpid = (pid_t) 0;
-  pid_t pid = getpid();
+  pid_t pid = getpid ();
   register size_t len, plen, dlen;
 
   if (dir_search)
     {
       register const char *d = getenv("TMPDIR");
       if (d != NULL && !diraccess(d))
         d = NULL;
       if (d == NULL && dir != NULL && diraccess(dir))
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -66,17 +66,17 @@ function varargout = curl (varargin)
     dx = varargin{1}(1,:);
     dy = varargin{2}(:,1);
   elseif (nargin == 6)
     fidx = 4;
     dx = varargin{1}(1,:,1)(:);
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
-    print_usage();
+    print_usage ();
   endif
 
   if ((nargin == 4) || (nargin == 2))
     if (!size_equal (varargin{fidx}, varargin{fidx + 1}))
       error ("curl: size of X and Y must match");
     elseif (ndims (varargin{fidx}) != 2)
       error ("curl: expected two-dimensional matrices X and Y");
     elseif ((length (dx) != columns (varargin{fidx}))
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -64,17 +64,17 @@ function retval = divergence (varargin)
     dx = varargin{1}(1,:);
     dy = varargin{2}(:,1);
   elseif (nargin == 6)
     fidx = 4;
     dx = varargin{1}(1,:,1)(:);
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
-    print_usage();
+    print_usage ();
   endif
 
   if ((nargin == 4) || (nargin == 2))
     if (!size_equal (varargin{fidx},varargin{fidx + 1}))
       error ("divergence: size of X and Y must match");
     elseif (ndims (varargin{fidx}) != 2)
       error ("divergence: expected two-dimensional matrices X and Y");
     elseif ((length (dx) != columns (varargin{fidx})) || (length (dy) != rows (varargin{fidx})))
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -52,17 +52,17 @@
 ## @seealso{rand}
 ## @end deftypefn
 
 ## Author: Rik Wehbring
 
 function ri = randi (bounds, varargin)
 
   if (nargin < 1)
-    print_usage();
+    print_usage ();
   endif
 
   if (! (isnumeric (bounds) && isreal (bounds)))
     error ("randi: IMIN and IMAX must be real numeric bounds");
   endif
 
   if (isscalar (bounds))
     imin = 1;
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -93,17 +93,16 @@ function list = missing_functions ()
   "auread",
   "auwrite",
   "avifile",
   "aviinfo",
   "aviread",
   "bar3",
   "bar3h",
   "bench",
-  "betaincinv",
   "bicgstabl",
   "brush",
   "builddocsearchdb",
   "bvp4c",
   "bvp5c",
   "bvpget",
   "bvpinit",
   "bvpset",
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -141,17 +141,17 @@ function dlmwrite (file, M, varargin)
     else
       if (i == 1)
         delim = varargin{i};
       elseif (i == 2)
         r = varargin{i};
       elseif (i == 3)
         c = varargin{i};
       else
-        print_usage();
+        print_usage ();
       endif
     endif
   endwhile
 
   if (ischar (file))
     [fid, msg] = fopen (file, opentype);
   elseif (isscalar (file) && isnumeric (file))
     [fid, msg] = deal (file, "invalid file number");
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -149,16 +149,30 @@
 ## trimmed; the string defining whitespace must be enclosed in double
 ## quotes for proper processing of special characters like \t.
 ## The default value for whitespace = " \b\r\n\t" (note the space).
 ## Unless whitespace is set to '' (empty) AND at least one "%s" format
 ## conversion specifier is supplied, a space is always part of whitespace.
 ##
 ## @end table
 ##
+## When the number of words in @var{str} doesn't match an exact multiple
+## of the number of format conversion specifiers, strread's behavior
+## depends on the last character of @var{str}:
+##
+## @table @asis
+## @item last character = "\n"
+## Data columns are padded with empty fields or Nan so that all columns
+## have equal length 
+##
+## @item last character is not "\n"
+## Data columns are not padded; strread returns columns of unequal length
+##
+## @end table
+##
 ## @seealso{textscan, textread, load, dlmread, fscanf}
 ## @end deftypefn
 
 function varargout = strread (str, format = "%f", varargin)
 
   ## Check input
   if (nargin < 1)
     print_usage ();
@@ -207,17 +221,17 @@ function varargout = strread (str, forma
   err_action = 0;
   mult_dlms_s1 = false;
   numeric_fill_value = NaN;
   white_spaces = " \b\r\n\t";
   for n = 1:2:length (varargin)
     switch (lower (varargin{n}))
       case "bufsize"
         ## We could synthesize this, but that just seems weird...
-        warning ('strread: property "bufsize" is not implemented');
+        warning ("strread: property 'bufsize' is not implemented");
       case "commentstyle"
         comment_flag = true;
         switch (lower (varargin{n+1}))
           case "c"
             [comment_start, comment_end] = deal ("/*", "*/");
           case "c++"
             [comment_start, comment_end] = deal ("//", "eol_char");
           case "shell"
@@ -240,17 +254,17 @@ function varargout = strread (str, forma
       case "delimiter"
         delimiter_str = varargin{n+1};
         if (strcmp (typeinfo (delimiter_str), "sq_string"))
           delimiter_str = do_string_escapes (delimiter_str);
         endif
       case "emptyvalue"
         numeric_fill_value = varargin{n+1};
       case "expchars"
-        warning ('strread: property "expchars" is not implemented');
+        warning ("strread: property 'expchars' is not implemented");
       case "whitespace"
         white_spaces = varargin{n+1};
         if (strcmp (typeinfo (white_spaces), "sq_string"))
           white_spaces = do_string_escapes (white_spaces);
         endif
       ## The following parameters are specific to textscan and textread
       case "endofline"
         eol_char = varargin{n+1};
@@ -262,42 +276,52 @@ function varargout = strread (str, forma
       case "multipledelimsasone"
         mult_dlms_s1 = varargin{n+1};
       case "treatasempty"
         if (iscellstr (varargin{n+1}))
           empty_str = varargin{n+1};
         elseif (ischar (varargin{n+1}))
           empty_str = varargin(n+1);
         else
-          error ('strread: "treatasempty" value must be string or cellstr');
+          error ("strread: 'treatasempty' value must be string or cellstr");
         endif
       otherwise
-        warning ('strread: unknown property "%s"', varargin{n});
+        warning ("strread: unknown property '%s'", varargin{n});
     endswitch
   endfor
 
   ## First parse of FORMAT
   if (strcmpi (strtrim (format), "%f"))
     ## Default format specified.  Expand it (to desired nargout)
     fmt_words = cell (nargout, 1);
     fmt_words (1:nargout) = format;
   else
     ## Determine the number of words per line as a first guess.  Forms
     ## like %f<literal>) (w/o delimiter in between) are fixed further on
     format = strrep (format, "%", " %");
-    fmt_words = regexp (format, '[^ ]+', 'match');
+    fmt_words = regexp (format, '[^ ]+', "match");
+    
+    ## Find position of conversion specifiers (they start with %)
+    idy2 = find (! cellfun ("isempty", regexp (fmt_words, '^%')));
+
+    ## Check for unsupported format specifiers
+    errpat = '(\[.*\]|[cq]|[nfdu]8|[nfdu]16|[nfdu]32|[nfdu]64)';
+    if (! all (cellfun ("isempty", regexp (fmt_words(idy2), errpat))))
+      error ("strread: %q, %c, %[] or bit width format specifiers are not supported yet.");
+    endif
+
     ## Format conversion specifiers following literals w/o space/delim
     ## in between are separate now.  Separate those w trailing literals
-    idy2 = find (! cellfun ("isempty", strfind (fmt_words, "%")));
     a = strfind (fmt_words(idy2), "%");
-    b = regexp (fmt_words(idy2), '[nfdus]', 'end');
+    b = regexp (fmt_words(idy2), '[nfdus]', "end");
     for jj = 1:numel (a)
+      ## From right to left to avoid losing track
       ii = numel (a) - jj + 1;
       if (! (length (fmt_words{idy2(ii)}) == b{ii}(1)))
-        ## Fix format_words
+        ## Split fmt_words(ii) into % conv specifier and trailing literal
         fmt_words(idy2(ii)+1 : end+1) = fmt_words(idy2(ii) : end);
         fmt_words{idy2(ii)} = fmt_words{idy2(ii)}(a{ii} : b{ii}(1));
         fmt_words{idy2(ii)+1} = fmt_words{idy2(ii)+1}(b{ii}+1:end);
       endif
     endfor
   endif
   num_words_per_line = numel (fmt_words);
 
@@ -307,17 +331,17 @@ function varargout = strread (str, forma
     str = strrep (str, "\r\n", "\n");
     ## CR serves no further purpose in function
     eol_char = "\n";
   endif
 
   ## Remove comments in str
   if (comment_flag)
     ## Expand 'eol_char' here, after option processing which may have set value
-    comment_end = regexprep (comment_end, 'eol_char', eol_char);
+    comment_end = regexprep (comment_end, "eol_char", eol_char);
     cstart = strfind (str, comment_start);
     cstop  = strfind (str, comment_end);
     ## Treat end of string as additional comment stop
     if (isempty (cstop) || cstop(end) != length (str))
       cstop(end+1) = length (str);
     endif
     if (! isempty (cstart))
       ## Ignore nested openers.
@@ -337,17 +361,18 @@ function varargout = strread (str, forma
     endif
     len = length (str);
     c2len = length (comment_end);
     str = cellslices (str, [1, cstop + c2len], [cstart - 1, len]);
     str = [str{:}];
   endif
 
   if (! isempty (white_spaces))
-    ## For numeric fields, whitespace is always a delimiter, but not for text fields
+    ## For numeric fields, whitespace is always a delimiter, but not for text
+    ## fields
     if (isempty (strfind (format, "%s")))
       ## Add whitespace to delimiter set
       delimiter_str = unique ([white_spaces delimiter_str]);
     else
       ## Remove any delimiter chars from white_spaces list
       white_spaces = setdiff (white_spaces, delimiter_str);
     endif
   endif
@@ -373,86 +398,90 @@ function varargout = strread (str, forma
     ## FIXME: this will also fold repeated whitespace in a char field
     rxp_wsp = sprintf ("[%s]+", white_spaces);
     str = regexprep (str, rxp_wsp, ' ');
     ## Remove possible leading space at string
     if (str(1) == 32)
        str = str(2:end);
     endif
     ## Check for single delimiter followed/preceded by whitespace
-    ## FIXME: Double strrep on str is enormously expensive of CPU time.
-    ## Can this be eliminated
     if (! isempty (delimiter_str))
       dlmstr = setdiff (delimiter_str, " ");
       rxp_dlmwsp = sprintf ("( [%s]|[%s] )", dlmstr, dlmstr);
       str = regexprep (str, rxp_dlmwsp, delimiter_str(1));
     endif
+    ## Wipe leading and trailing whitespace on each line (it may be
+    ## delimiter too)
     ## FIXME: Double strrep on str is enormously expensive of CPU time.
     ## Can this be eliminated
-    ## Wipe leading and trailing whitespace on each line (it may be delimiter too)
     if (! isempty (eol_char))
       str = strrep (str, [eol_char " "], eol_char);
       str = strrep (str, [" " eol_char], eol_char);
     endif
   endif
 
   ## Split 'str' into words
   words = split_by (str, delimiter_str, mult_dlms_s1, eol_char);
   if (! isempty (white_spaces))
-    ## Trim leading and trailing white_spaces
-    ## FIXME: Is this correct?  strtrim clears what matches isspace(), not
-    ## necessarily what is in white_spaces.
+    ## Trim leading and trailing 'white_spaces'. All whitespace has
+    ## been converted to space above
     words = strtrim (words);
   endif
   num_words = numel (words);
-  ## First guess at number of lines in file (ignoring leading/trailing literals)
+  ## First guess at nr. of lines in file (ignoring leading/trailing literals)
   num_lines = ceil (num_words / num_words_per_line);
 
   ## Replace TreatAsEmpty char sequences by empty strings
   if (! isempty (empty_str))
     for ii = 1:numel (empty_str)
       idz = strncmp (empty_str{ii}, words, length (empty_str{ii}));
       words(idz) = {""};
     endfor
   endif
 
   ## fmt_words has been split properly now, but words{} has only been split on
-  ## delimiter positions. 
-  ## As numeric fields can also be separated by whitespace, more splits may be
-  ## needed.
+  ## delimiter positions. As numeric fields can also be separated by
+  ## whitespace, more splits may be needed.
   ## We also don't know the number of lines (as EndOfLine may have been set to
   ## "" (empty) by the caller).
   ##
   ## We also may have to cope with 3 cases as far as literals go:
   ## A: Trailing literals (%f<literal>) w/o delimiter in between.
   ## B: Leading literals (<literal>%f) w/o delimiter in between.
   ## C. Skipping leftover parts of specified skip fields (%*N )
   ## Some words columns may have to be split further to fix these.
+  ## To find out, we'll match fmt_words to the words array to see what
+  ## needs to be done. fwptr tracks which {fmt_words}# starts in what {words}#
 
   ## Find indices and pointers to possible literals in fmt_words
   idf = cellfun ("isempty", strfind (fmt_words, "%"));
   ## Find indices and pointers to conversion specifiers with fixed width
   idg = ! cellfun ("isempty", regexp (fmt_words, '%\*?\d'));
   idy = find (idf | idg);
   ## Find indices to numeric conversion specifiers
-  idn = ! cellfun ("isempty", regexp (fmt_words, "%[dnfu]"));
+  idn = ! cellfun ("isempty", regexp (fmt_words, '%[dnfu]'));
 
   ## If needed, split up columns in three steps:
   if (! isempty (idy))
     ## Try-catch because complexity of strings to read can be infinite
     try
 
       ## 1. Assess "period" in the split-up words array ( < num_words_per_line).
       ## Could be done using EndOfLine but that prohibits EndOfLine = "" option.
       ## Alternative below goes by simply parsing a first grab of words
-      ## and counting words until the fmt_words array is exhausted:
-      iwrd = 1; iwrdp = 0; iwrdl = length (words{iwrd});
-      for ii = 1:numel (fmt_words)
+      ## and matching fmt_words to words until the fmt_words array is exhausted.
+      ## iwrd: ptr to current analyzed word; iwrdp: ptr to pos before analyzed char
+      iwrd = 1; iwrdp = 0; iwrdl = length (words{1});
+      fwptr = zeros (1, numel (fmt_words));
+      ii = 1;
+      while ii <= numel (fmt_words)
 
         nxt_wrd = 0;
+        ## Keep track of which words nr. every fmt_words{} is (starts) in.
+        fwptr(ii) = iwrd;
 
         if (idf(ii))
           ## Literal expected
           if (isempty (strfind (fmt_words{ii}, words(iwrd))))
             ## Not found in current word; supposed to be in next word
             nxt_wrd = 1;
           else
             ## Found it in current word.  Subtract literal length
@@ -466,18 +495,19 @@ function varargout = strread (str, forma
             elseif (iwrdp == iwrdl)
               ## Word completely "used up". Next word
               nxt_wrd = 1;
             endif
           endif
 
         elseif (idg(ii))
           ## Fixed width specifier (%N or %*N): read just a part of word
-          iwrdp += floor ...
-           (str2double (fmt_words{ii}(regexp(fmt_words{ii}, '\d') : end-1)));
+          sw = regexp (fmt_words{ii}, '\d', "once");
+          ew = regexp (fmt_words{ii}, '[nfuds]') - 1;
+          iwrdp += floor (str2double (fmt_words{ii}(sw:ew)));
           if (iwrdp > iwrdl)
             ## Match error. Field extends beyond word boundary.
             warning  ...
             ("strread: field width '%s' (fmt spec # %d) extends beyond actual word limit", ...
                fmt_words{ii}, ii);
             ## Assume word to be completely "used up".  Next word
             nxt_wrd = 1;
           elseif (iwrdp == iwrdl)
@@ -502,33 +532,37 @@ function varargout = strread (str, forma
             ## No bordering literal to the right => field occupies (rest of) word
             nxt_wrd = 1;
           endif
 
         endif
 
         if (nxt_wrd)
           ++iwrd; iwrdp = 0;
-          if (ii < numel (fmt_words))
+          if (iwrd > numel (words))
+            ## Apparently EOF; assume incomplete row already at L.1 of data
+            ii = numel (fmt_words);
+          elseif (ii < numel (fmt_words) && iwrd <= numel (words))
             iwrdl = length (words{iwrd});
           endif
         endif
 
-      endfor
+        ++ii;
+
+      endwhile
       ## Done
       words_period = max (iwrd - 1, 1);
       num_lines = ceil (num_words / words_period);
 
       ## 2. Pad words array so that it can be reshaped
-      tmp_lines = ceil (num_words / words_period);
-      num_words_padded = tmp_lines * words_period - num_words;
+      num_words_padded = num_lines * words_period - num_words;
       if (num_words_padded)
         words = [words'; cell(num_words_padded, 1)];
       endif
-      words = reshape (words, words_period, tmp_lines);
+      words = reshape (words, words_period, num_lines);
 
       ## 3. Do the column splitting on rectangular words array
       icol = 1; ii = 1;    # icol = current column, ii = current fmt_word
       while (ii <= num_words_per_line)
 
         ## Check if fmt_words(ii) contains a literal or fixed-width
         if ((idf(ii) || idg(ii)) && (rows(words) < num_words_per_line))
           if (idf(ii))
@@ -551,54 +585,62 @@ function varargout = strread (str, forma
               ## Apply only to those cells that do have something beyond literal
               jptr = find (cellfun("length", words(icol+1, jptr), ...
                             "UniformOutput", false) > e(1));
               words(icol+1, :) = {""};
               words(icol+1, jptr) = cellfun ...
                 (@(x) substr(x, e(1)+1, length(x)-e(1)), words(icol, jptr), ...
                 "UniformOutput", false);
               words(icol, jptr) = fmt_words{ii};
+              fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
 
             else
               if (! idg(ii) && ! isempty (strfind (fmt_words{ii-1}, "%s")))
                 ## Trailing literal.  If preceding format == '%s' this is an error
                 warning ("Ambiguous '%s' specifier next to literal in column %d", icol);
               elseif (idg(ii))
                 ## Current field = fixed width. Strip into icol, rest in icol+1
-                wdth = floor (str2double (fmt_words{ii}(regexp(fmt_words{ii}, ...
-                              '\d') : end-1)));
+                sw = regexp (fmt_words{ii}, '\d', "once");
+                ew = regexp (fmt_words{ii}, '[nfuds]') - 1;
+                wdth = floor (str2double (fmt_words{ii}(sw:ew)));
                 words(icol+1, jptr) = cellfun (@(x) x(wdth+1:end),
                      words(icol,jptr), "UniformOutput", false);
-                words(icol, jptr) = strtrunc (words(icol, jptr), wdth);
+                if (isempty ([words(icol+1, :){:}]))
+                  ## Apparently split wasn't needed as turns out to cover
+                  ## entire column. So delete column again
+                  words(icol+1, :) = [];
+                else
+                  words(icol, jptr) = strtrunc (words(icol, jptr), wdth);
+                  fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
+                endif
               else
                 ## FIXME: this assumes char(254)/char(255) won't occur in input!
                 clear wrds;
                 wrds(1:2:2*numel (words(icol, jptr))) = ...
                      strrep (words(icol, jptr), fmt_words{ii}, ...
                      [char(255) char(254)]);
                 wrds(2:2:2*numel (words(icol, jptr))-1) = char(255);
                 wrds = strsplit ([wrds{:}], char(255));
                 words(icol, jptr) = ...
                   wrds(find (cellfun ("isempty", strfind (wrds, char(254)))));
                 wrds(find (cellfun ("isempty", strfind (wrds, char(254))))) ...
                    = char(255);
                 words(icol+1, jptr) = strsplit (strrep ([wrds{2:end}], ...
                    char(254), fmt_words{ii}), char(255));
                 ## Former trailing literal may now be leading for next specifier
                 --ii;
+                fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
               endif
             endif
           endif
 
         else
           ## Conv. specifier.  Peek if next fmt_word needs split from current column
           if (ii < num_words_per_line)
-            if (idf(ii+1) && (! isempty (strfind (words{icol, 1}, fmt_words{ii+1}))))
-              --icol;
-            elseif (idg(ii+1))
+            if (fwptr(ii) == fwptr(ii+1))
               --icol;
             endif
           endif
         endif
         ## Next fmt_word, next column
         ++ii; ++icol;
       endwhile
 
@@ -647,20 +689,22 @@ function varargout = strread (str, forma
           endif
           data(n) = numeric_fill_value;
           if (pad_out)
             data(end+1:num_lines) = numeric_fill_value;
           endif
           varargout{k} = data.';
           k++;
         case {"%0", "%1", "%2", "%3", "%4", "%5", "%6", "%7", "%8", "%9"}
-          nfmt = strsplit (fmt_words{m}(2:end-1), '.');
+          sw = regexp (fmt_words{m}, '\d', "once");
+          ew = regexp (fmt_words{m}, '[nfudsq]') - 1;
+          nfmt = strsplit (fmt_words{m}(2:ew), ".");
           swidth = str2double (nfmt{1});
-          switch fmt_words{m}(end)
-            case {"d", "u", "f", "n%"}
+          switch fmt_words{m}(ew+1)
+            case {"d", "u", "f", "n"}
               n = cellfun ("isempty", data);
               ### FIXME - erroneously formatted data lead to NaN, not an error
               ###         => ReturnOnError can't be implemented for numeric data
               data = str2double (strtrunc (data, swidth));
               data(n) = numeric_fill_value;
               if (pad_out)
                 data(end+1:num_lines) = numeric_fill_value;
               endif
@@ -743,40 +787,40 @@ endfunction
 %! assert (a, 1);
 %! assert (b, 2);
 
 %!test
 %! str = "";
 %! a = rand (10, 1);
 %! b = char (randi ([65, 85], 10, 1));
 %! for k = 1:10
-%!   str = sprintf ('%s %.6f %s\n', str, a(k), b(k));
+%!   str = sprintf ("%s %.6f %s\n", str, a(k), b(k));
 %! endfor
 %! [aa, bb] = strread (str, "%f %s");
 %! assert (a, aa, 1e-6);
 %! assert (cellstr (b), bb);
 
 %!test
 %! str = "";
 %! a = rand (10, 1);
 %! b = char (randi ([65, 85], 10, 1));
 %! for k = 1:10
-%!   str = sprintf ('%s %.6f %s\n', str, a(k), b(k));
+%!   str = sprintf ("%s %.6f %s\n", str, a(k), b(k));
 %! endfor
 %! aa = strread (str, "%f %*s");
 %! assert (a, aa, 1e-6);
 
 %!test
-%! str = sprintf ('/* this is\nacomment*/ 1 2 3');
+%! str = sprintf ("/* this is\nacomment*/ 1 2 3");
 %! a = strread (str, "%f", "commentstyle", "c");
 %! assert (a, [1; 2; 3]);
 
 %!test
 %! str = "# comment\n# comment\n1 2 3";
-%! [a, b] = strread (str, '%n %s', 'commentstyle', 'shell', 'endofline', "\n");
+%! [a, b] = strread (str, "%n %s", "commentstyle", "shell", "endofline", "\n");
 %! assert (a, [1; 3]);
 %! assert (b, {"2"});
 
 %!test
 %! str = sprintf ("Tom 100 miles/hr\nDick 90 miles/hr\nHarry 80 miles/hr");
 %! fmt = "%s %f miles/hr";
 %! c = cell (1, 2);
 %! [c{:}] = strread (str, fmt);
@@ -891,14 +935,40 @@ endfunction
 %! fmt = "%f %f %f";
 %! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
 %! [a, b, c] = strread (str, fmt, args {:});
 %! assert (a, [0.31; 0.60], 0.01)
 %! assert (b, [0.86; 0.72], 0.01)
 %! assert (c, [0.94; 0.87], 0.01)
 
 %!test
+%! [a, b] = strread (["Empty 1" char(10)], "Empty%s %f");
+%! assert (a{1}, '1');
+%! assert (b, NaN);
+
+%!test
+%! [a, b] = strread (["Empty" char(10)], "Empty%f %f");
+%! assert (a, NaN);
+%! assert (b, NaN);
+
+%!test
 %! # Bug #35999
 %! [a, b, c] = strread ("", "%f");
 %! assert (isempty (a));
 %! assert (isempty (b));
 %! assert (isempty (c));
 
+%% Unsupported format specifiers
+%!test
+%!error <format specifiers are not supported> strread ("a", "%c")
+%!error <format specifiers are not supported> strread ("a", "%*c %d")
+%!error <format specifiers are not supported> strread ("a", "%q")
+%!error <format specifiers are not supported> strread ("a", "%*q %d")
+%!error <format specifiers are not supported> strread ("a", "%[a]")
+%!error <format specifiers are not supported> strread ("a", "%*[a] %d")
+%!error <format specifiers are not supported> strread ("a", "%[^a]")
+%!error <format specifiers are not supported> strread ("a", "%*[^a] %d")
+%!error <format specifiers are not supported> strread ("a", "%d8")
+%!error <format specifiers are not supported> strread ("a", "%*d8 %s")
+%!error <format specifiers are not supported> strread ("a", "%f64")
+%!error <format specifiers are not supported> strread ("a", "%*f64 %s")
+%!error <format specifiers are not supported> strread ("a", "%u32")
+%!error <format specifiers are not supported> strread ("a", "%*u32 %d")
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -20,23 +20,23 @@
 ## @deftypefn  {Function File} {@var{C} =} textscan (@var{fid}, @var{format})
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @var{n})
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @var{param}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{fid}, @var{format}, @var{n}, @var{param}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {@var{C} =} textscan (@var{str}, @dots{})
 ## @deftypefnx {Function File} {[@var{C}, @var{position}] =} textscan (@var{fid}, @dots{})
 ## Read data from a text file or string.
 ##
-## The file associated with @var{fid} is read and parsed according to
-## @var{format}.  The function behaves like @code{strread} except it works by
-## parsing a file instead of a string.  See the documentation of
-## @code{strread} for details.
+## The string @var{str} or file associated with @var{fid} is read from and
+## parsed according to @var{format}.  The function behaves like @code{strread}
+## except it can also read from file instead of a string.  See the documentation
+## of @code{strread} for details.
 ##
-## In addition to the options supported by
-## @code{strread}, this function supports a few more:
+## In addition to the options supported by @code{strread}, this function
+## supports a few more:
 ##
 ## @itemize
 ## @item "collectoutput":
 ## A value of 1 or true instructs textscan to concatenate consecutive columns
 ## of the same class in the output cell array.  A value of 0 or false (default)
 ## leaves output in distinct columns.
 ##
 ## @item "endofline":
@@ -45,26 +45,29 @@
 ## ignored as delimiters and added to whitespace.
 ##
 ## @item "headerlines":
 ## The first @var{value} number of lines of @var{fid} are skipped.
 ##
 ## @item "returnonerror":
 ## If set to numerical 1 or true (default), return normally when read errors
 ## have been encountered.  If set to 0 or false, return an error and no data.
+## As the string or file is read by columns rather than by rows, and because
+## textscan is fairly forgiving as regards read errors, setting this option
+## may have little or no actual effect.
 ## @end itemize
 ##
 ## When reading from a character string, optional input argument @var{n}
 ## specifies the number of times @var{format} should be used (i.e., to limit
 ## the amount of data read).
-## When reading fro file, @var{n} specifies the number of data lines to read;
+## When reading from file, @var{n} specifies the number of data lines to read;
 ## in this sense it differs slightly from the format repeat count in strread.
 ##
-## The output @var{C} is a cell array whose length is given by the number
-## of format specifiers.
+## The output @var{C} is a cell array whose second dimension is determined
+## by the number of format specifiers.
 ##
 ## The second output, @var{position}, provides the position, in characters,
 ## from the beginning of the file.
 ##
 ## @seealso{dlmread, fscanf, load, strread, textread}
 ## @end deftypefn
 
 function [C, position] = textscan (fid, format = "%f", varargin)
@@ -75,33 +78,36 @@ function [C, position] = textscan (fid, 
   if (nargin < 1)
     print_usage ();
   endif
 
   if (isempty (format))
     format = "%f";
   endif
 
+  if (! ischar (format))
+    error ("textscan: FORMAT must be a string");
+  endif
+
+  ## Determine the number of data fields & initialize output array
+  num_fields = numel (strfind (format, "%")) - numel (strfind (format, "%*"));
+  C = cell (1, num_fields);
+
   if (! (isa (fid, "double") && fid > 0) && ! ischar (fid))
     error ("textscan: first argument must be a file id or character string");
   endif
 
-  if (! ischar (format))
-    error ("textscan: FORMAT must be a string");
-  endif
-
   args = varargin;
   if (nargin > 2 && isnumeric (args{1}))
     nlines = args{1};
   else
     nlines = Inf;
   endif
   if (nlines < 1)
     printf ("textscan: N = 0, no data read\n");
-    C = [];
     return
   endif
 
   if (! any (strcmpi (args, "emptyvalue")))
     ## Matlab returns NaNs for missing values
     args(end+1:end+2) = {'emptyvalue', NaN};
   endif
 
@@ -169,17 +175,16 @@ function [C, position] = textscan (fid, 
     endif
     ## Read a first file chunk. Rest follows after endofline processing
     [str, count] = fscanf (fid, "%c", BUFLENGTH);
   endif
 
   ## Check for empty result
   if (isempty (str))
     warning ("textscan: no data read");
-    C = [];
     return;
   endif
 
   ## Check value of 'endofline'.  String or file doesn't seem to matter
   endofline = find (strcmpi (args, "endofline"), 1);
   if (! isempty (endofline))
     if (ischar (args{endofline + 1}))
       eol_char = args{endofline + 1};
@@ -244,20 +249,28 @@ function [C, position] = textscan (fid, 
       fseek (fid, st_pos, "bof");
       str = fread (fid, "char=>char").';
     endif
   endif
 
   ## Determine the number of data fields
   num_fields = numel (strfind (format, "%")) - numel (strfind (format, "%*"));
 
-  ## Strip trailing EOL to avoid returning stray missing values (f. strread)
-  if (strcmp (str(end-length (eol_char) + 1 : end), eol_char));
-    str(end-length (eol_char) + 1 : end) = "";
-  endif
+  ## Strip trailing EOL to avoid returning stray missing values (f. strread).
+  ## However, in case of CollectOutput request, presence of EOL is required
+  eol_at_end = strcmp (str(end-length (eol_char) + 1 : end), eol_char);
+  if (collop)
+    if (! eol_at_end)
+      str(end+1 : end+length (eol_char)) = eol_char;
+    endif
+  elseif (eol_at_end)
+     str(end-length (eol_char) + 1 : end) = "";
+    ## A corner case: str may now be empty....
+    if (isempty (str)); return; endif
+   endif
 
   ## Call strread to make it do the real work
   C = cell (1, num_fields);
   [C{:}] = strread (str, format, args{:});
 
   ## If requested, collect output columns of same class
   if (collop)
     C = colloutp (C);
@@ -311,24 +324,24 @@ endfunction
 %! b = [10:10:100];
 %! b = [b; 8*b/5];
 %! str = sprintf ("%g miles/hr = %g kilometers/hr\n", b);
 %! fmt = "%f miles/hr = %f kilometers/hr";
 %! c = textscan (str, fmt);
 %! assert (b(1,:)', c{1}, 1e-5);
 %! assert (b(2,:)', c{2}, 1e-5);
 
-#%!test
-#%! str = "13, 72, NA, str1, 25\r\n// Middle line\r\n36, na, 05, str3, 6";
-#%! a = textscan (str, "%d %n %f %s %n", "delimiter", ",","treatAsEmpty", {"NA", "na"},"commentStyle", "//");
-#%! assert (a{1}, int32([13; 36]));
-#%! assert (a{2}, [72; NaN]);
-#%! assert (a{3}, [NaN; 5]);
-#%! assert (a{4}, {"str1"; "str3"});
-#%! assert (a{5}, [25; 6]);
+%!test
+%! str = "13, 72, NA, str1, 25\r\n// Middle line\r\n36, na, 05, str3, 6";
+%! a = textscan (str, "%d %n %f %s %n", "delimiter", ",","treatAsEmpty", {"NA", "na"},"commentStyle", "//");
+%! assert (a{1}, int32([13; 36]));
+%! assert (a{2}, [72; NaN]);
+%! assert (a{3}, [NaN; 5]);
+%! assert (a{4}, {"str1"; "str3"});
+%! assert (a{5}, [25; 6]);
 
 %!test
 %! str = "Km:10 = hhhBjjj miles16hour\r\n";
 %! str = [str "Km:15 = hhhJjjj miles241hour\r\n"];
 %! str = [str "Km:2 = hhhRjjj miles3hour\r\n"];
 %! str = [str "Km:25 = hhhZ\r\n"];
 %! fmt = "Km:%d = hhh%1sjjj miles%dhour";
 %! a = textscan (str, fmt, "delimiter", " ");
@@ -357,16 +370,35 @@ endfunction
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
 %! str = sprintf ("%g miles/hr = %g (%g) kilometers (meters)/hr\n", b);
 %! fmt = "%f miles%s %s %f (%f) kilometers %*s";
 %! c = textscan (str, fmt, "collectoutput", 1);
 %! assert (size(c{3}), [10, 2]);
 %! assert (size(c{2}), [10, 2]);
 
+%!test
+%% CollectOutput test with uneven column length files
+%! b = [10:10:100];
+%! b = [b; 8*b/5; 8*b*1000/5];
+%! str = sprintf ("%g miles/hr = %g (%g) kilometers (meters)/hr\n", b);
+%! str = [str "110 miles/hr"];
+%! fmt = "%f miles%s %s %f (%f) kilometers %*s";
+%! c = textscan (str, fmt, "collectoutput", 1);
+%! assert (size(c{1}), [11, 1]);
+%! assert (size(c{3}), [11, 2]);
+%! assert (size(c{2}), [11, 2]);
+%! assert (c{3}(end), NaN);
+%! assert (c{2}{11, 1}, "/hr");
+%! assert (isempty (c{2}{11, 2}), true);
+
 %% Test input validation
 %!error textscan ()
 %!error textscan (single (4))
 %!error textscan ({4})
 %!error <must be a string> textscan ("Hello World", 2)
 %!error <cannot provide position information> [C, pos] = textscan ("Hello World")
 %!error <character value required> textscan ("Hello World", '%s', 'EndOfLine', 3)
 
+%! Test incomplete first data line
+%! R = textscan (['Empty1' char(10)], 'Empty%d %f');
+%! assert (R{1}, int32(1));
+%! assert (isempty(R{2}), true);
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -424,17 +424,17 @@ SUCH DAMAGE.\
         code = cstrcat ("\\ ", strrep (type (name){1}, "\n", "\n// "));
       else
         code = " ";
       endif
       body = cstrcat ("#include <octave/oct.h>\n\n",
                      "DEFUN_DLD(", name, ",args,nargout,\"\\\n",
                      name, "\\n\\\n\")\n{\n",
                      "  octave_value_list retval;\n",
-                     "  int nargin = args.length();\n\n",
+                     "  int nargin = args.length ();\n\n",
                      code, "\n  return retval;\n}\n");
 
       text = cstrcat (comment, body);
     case "m"
       ## If we are editing a function defined on the fly, paste the
       ## code.
       if (any (exists == [2, 103]))
         body = type (name){1};
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -27,17 +27,17 @@
 ## Created: 2010-07-15
 
 function val = getappdata (h, name)
 
   if (all (ishandle (h)) && nargin == 2 && ischar (name))
     ## FIXME - Is there a better way to handle non-existent appdata
     ## and missing fields?
     val = cell (numel (h), 1);
-    appdata = struct();
+    appdata = struct ();
     for nh = 1:numel(h)
       try
         appdata = get (h(nh), "__appdata__");
       end_try_catch
       if (! isfield (appdata, name))
         appdata.(name) = [];
       endif
       val(nh) = {appdata.(name)};
diff --git a/scripts/miscellaneous/list_primes.m b/scripts/miscellaneous/list_primes.m
--- a/scripts/miscellaneous/list_primes.m
+++ b/scripts/miscellaneous/list_primes.m
@@ -46,18 +46,18 @@ function retval = list_primes (n)
   endif
 
   if (n == 2)
     retval = [2; 3];
     return;
   endif
 
   retval = zeros (1, n);
-  retval (1) = 2;
-  retval (2) = 3;
+  retval(1) = 2;
+  retval(2) = 3;
 
   n = n - 2;
   i = 3;
   p = 5;
   while (n > 0)
 
     is_prime = 1;
     is_unknown = 1;
@@ -70,17 +70,17 @@ function retval = list_primes (n)
       if (a * d == p)
         is_prime = 0;
         is_unknown = 0;
       endif
       d = d + 2;
     endwhile
 
     if (is_prime)
-      retval (i++) = p;
+      retval(i++) = p;
       n--;
     endif
     p = p + 2;
 
   endwhile
 
 endfunction
 
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -12,33 +12,39 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{output}, @var{status}] =} perl (@var{scriptfile})
-## @deftypefnx {Function File} {[@var{output}, @var{status}] =} perl (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
-## Invoke Perl script @var{scriptfile} with possibly a list of
-## command line arguments.
-## Returns output in @var{output} and status
-## in @var{status}.
-## @seealso{system}
+## @deftypefn  {Function File} {@var{output} =} perl (@var{scriptfile})
+## @deftypefnx {Function File} {@var{output} =} perl (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
+## @deftypefnx {Function File} {[@var{output}, @var{status}] =} perl (@dots{})
+## Invoke Perl script @var{scriptfile}, possibly with a list of command line
+## arguments.  Return output in @var{output} and optional status in
+## @var{status}.  If @var{scriptfile} is not an absolute file name it is
+## is searched for in the current directory and then in the Octave loadpath.
+## @seealso{system, python}
 ## @end deftypefn
 
 function [output, status] = perl (scriptfile = "-e ''", varargin)
 
   ## VARARGIN is intialized to {}(1x0) if no additional arguments are
   ## supplied, so there is no need to check for it, or provide an
   ## initial value in the argument list of the function definition.
 
   if (ischar (scriptfile)
-      && ((nargin != 1 && iscellstr (varargin))
-          || (nargin == 1 && ! isempty (scriptfile))))
+      && (   (nargin == 1 && ! isempty (scriptfile))
+          || (nargin != 1 && iscellstr (varargin))))
+    if (! strcmp (scriptfile(1:2), "-e"))
+      ## Attempt to find file in loadpath.  No effect for absolute filenames.
+      scriptfile = file_in_loadpath (scriptfile);
+    endif
+
     [status, output] = system (cstrcat ("perl ", scriptfile,
                                         sprintf (" %s", varargin{:})));
   else
     error ("perl: invalid arguments");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/python.m b/scripts/miscellaneous/python.m
--- a/scripts/miscellaneous/python.m
+++ b/scripts/miscellaneous/python.m
@@ -13,35 +13,37 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{output}, @var{status}] =} python (@var{scriptfile})
-## @deftypefnx {Function File} {[@var{output}, @var{status}] =} python (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
-## Invoke python script @var{scriptfile} with possibly a list of
-## command line arguments.
-## Returns output in @var{output} and status
-## in @var{status}.
-## @seealso{system}
+## @deftypefn  {Function File} {@var{output} =} python (@var{scriptfile})
+## @deftypefnx {Function File} {@var{output} =} python (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
+## @deftypefnx {Function File} {[@var{output}, @var{status}] =} python (@dots{})
+## Invoke Python script @var{scriptfile}, possibly with a list of command line
+## arguments.  Return output in @var{output} and optional status in
+## @var{status}.  If @var{scriptfile} is not an absolute file name it is
+## is searched for in the current directory and then in the Octave loadpath.
+## @seealso{system, perl}
 ## @end deftypefn
 
 ## Author: Carn Draug <carandraug+dev@gmail.com>
 
 function [output, status] = python (scriptfile = "-c ''", varargin)
 
-  ## VARARGIN is intialized to {}(1x0) if no additional arguments are
-  ## supplied, so there is no need to check for it, or provide an
-  ## initial value in the argument list of the function definition.
+  if (ischar (scriptfile)
+      && (   (nargin == 1 && ! isempty (scriptfile))
+          || (nargin != 1 && iscellstr (varargin))))
+    if (! strcmp (scriptfile(1:2), "-c"))
+      ## Attempt to find file in loadpath.  No effect for absolute filenames.
+      scriptfile = file_in_loadpath (scriptfile);
+    endif
 
-  if (ischar (scriptfile)
-      && ((nargin != 1 && iscellstr (varargin))
-          || (nargin == 1 && ! isempty (scriptfile))))
     [status, output] = system (cstrcat ("python ", scriptfile,
                                         sprintf (" %s", varargin{:})));
   else
     error ("python: invalid arguments");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 function ret = what (d)
 
   if (nargin == 0)
     d = pwd ();
   elseif (isempty (strfind (d, filesep ())))
     ## Find the appropriate directory on the path.
-    p = strtrim (strsplit (path (), pathsep()));
+    p = strtrim (strsplit (path (), pathsep ()));
     d = p{find (cellfun (@(x) ! isempty (strfind (x, d)), p))(end)};
   else
     [status, msg, msgid] = fileattrib (d);
     if (status != 1)
       error ("what: could not find the file or path %s", d);
     else
       d = msg.Name;
     endif
@@ -86,17 +86,17 @@ function ret = what (d)
   endif
 endfunction
 
 function __display_filenames__ (msg, p, f)
   if (length (f) > 0)
     printf ("%s %s:\n\n", msg, p);
 
     maxlen = max (cellfun ("length", f));
-    ncols = max (1, floor (terminal_size()(2) / (maxlen + 3)));
+    ncols = max (1, floor (terminal_size ()(2) / (maxlen + 3)));
     fmt = "";
     for i = 1: ncols
       fmt = sprintf ("%s   %%-%ds", fmt, maxlen);
     endfor
     fmt = [fmt, "\n"];
 
     nrows = ceil (length (f) / ncols);
     for i = 1 : nrows
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -16,24 +16,28 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d})
 ## @deftypefnx {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d}, @var{x0})
+## @deftypefnx {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}, @var{lambda}] =} lsqnonneg (@dots{})
 ## Minimize @code{norm (@var{c}*@var{x} - d)} subject to
 ## @code{@var{x} >= 0}.  @var{c} and @var{d} must be real.  @var{x0} is an
 ## optional initial guess for @var{x}.
+## Currently, @code{lsqnonneg}
+## recognizes these options: @code{"MaxIter"}, @code{"TolX"}.
+## For a description of these options, see @ref{doc-optimset,,optimset}.
 ##
 ## Outputs:
 ##
 ## @itemize @bullet
 ## @item resnorm
 ##
 ## The squared 2-norm of the residual: norm(@var{c}*@var{x}-@var{d})^2
 ##
@@ -142,17 +146,18 @@ function [x, resnorm, residual, exitflag
           [q, r] = qrdelete (q, r, idx);
         endif
       endif
     endwhile
 
     ## compute the gradient.
     w = c'*(d - c*x);
     w(p) = [];
-    if (! any (w > 0))
+    tolx = optimget (options, "TolX", 10*eps*norm (c, 1)*length (c));
+    if (! any (w > tolx))
       if (useqr)
         ## verify the solution achieved using qr updating.
         ## in the best case, this should only take a single step.
         useqr = false;
         continue;
       else
         ## we're finished.
         break;
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -416,25 +416,38 @@ function [local_packages, global_package
       if (length (files) == 0 && nargout == 0)
         printf ("Installation prefix:             %s\n", prefix);
         printf ("Architecture dependent prefix:   %s\n", archprefix);
       elseif (length (files) == 0 && nargout >= 1)
         local_packages = prefix;
         global_packages = archprefix;
       elseif (length (files) >= 1 && nargout <= 2 && ischar (files{1}))
         prefix = files{1};
+        try
+          prefix = absolute_pathname (prefix);
+        catch
+          [status, msg, msgid] = mkdir (prefix);
+          if (status == 0)
+            error("cannot create prefix %s: %s", prefix, msg);
+          endif
+          warning ("creating the directory %s\n", prefix);
+          prefix = absolute_pathname (prefix);
+        end_try_catch
         prefix = absolute_pathname (prefix);
         local_packages = prefix;
         user_prefix = true;
         if (length (files) >= 2 && ischar (files{2}))
           archprefix = files{2};
           try
             archprefix = absolute_pathname (archprefix);
           catch
-            mkdir (archprefix);
+            [status, msg, msgid] = mkdir (archprefix);
+            if (status == 0)
+              error("cannot create archprefix %s: %s", archprefix, msg);
+            endif
             warning ("creating the directory %s\n", archprefix);
             archprefix = absolute_pathname (archprefix);
           end_try_catch
           global_packages = archprefix;
         endif
       else
         error ("you must specify a prefix directory, or request an output argument");
       endif
diff --git a/scripts/pkg/private/getarchdir.m b/scripts/pkg/private/getarchdir.m
--- a/scripts/pkg/private/getarchdir.m
+++ b/scripts/pkg/private/getarchdir.m
@@ -18,11 +18,11 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{archdir} =} getarchdir (@var{desc})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function archdir = getarchdir (desc)
-  archdir = fullfile (desc.archprefix, getarch());
+  archdir = fullfile (desc.archprefix, getarch ());
 endfunction
 
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -96,17 +96,17 @@ function install (files, handle_deps, au
         dirlist = {".", "..", tgz};
       endif
 
       if (exist (tgz, "file") || exist (tgz, "dir"))
         ## The two first entries of dirlist are "." and "..".
         if (exist (tgz, "file"))
           packdir = fullfile (tmpdir, dirlist{3});
         else
-          packdir = fullfile (pwd(), dirlist{3});
+          packdir = fullfile (pwd (), dirlist{3});
         endif
         packdirs{end+1} = packdir;
 
         ## Make sure the package contains necessary files.
         verify_directory (packdir);
 
         ## Read the DESCRIPTION file.
         filename = fullfile (packdir, "DESCRIPTION");
diff --git a/scripts/pkg/private/installed_packages.m b/scripts/pkg/private/installed_packages.m
--- a/scripts/pkg/private/installed_packages.m
+++ b/scripts/pkg/private/installed_packages.m
@@ -52,17 +52,17 @@ function [out1, out2] = installed_packag
       endif
     endfor
   endfor
   if (! isempty(dup))
     installed_pkgs_lst(dup) = [];
   endif
 
   ## Now check if the package is loaded.
-  tmppath = strrep (path(), "\\", "/");
+  tmppath = strrep (path (), "\\", "/");
   for i = 1:length (installed_pkgs_lst)
     if (strfind (tmppath, strrep (installed_pkgs_lst{i}.dir, '\', '/')))
       installed_pkgs_lst{i}.loaded = true;
     else
       installed_pkgs_lst{i}.loaded = false;
     endif
   endfor
   for i = 1:length (local_packages)
@@ -106,17 +106,17 @@ function [out1, out2] = installed_packag
   names = cell (num_packages, 1);
   for i = 1:num_packages
     max_name_length = max (max_name_length,
                            length (installed_pkgs_lst{i}.name));
     max_version_length = max (max_version_length,
                               length (installed_pkgs_lst{i}.version));
     names{i} = installed_pkgs_lst{i}.name;
   endfor
-  max_dir_length = terminal_size()(2) - max_name_length - ...
+  max_dir_length = terminal_size ()(2) - max_name_length - ...
                                              max_version_length - 7;
   if (max_dir_length < 20)
      max_dir_length = Inf;
   endif
 
   h1 = postpad (h1, max_name_length + 1, " ");
   h2 = postpad (h2, max_version_length, " ");;
 
@@ -133,17 +133,17 @@ function [out1, out2] = installed_packag
                     max_version_length);
   [dummy, idx] = sort (names);
   for i = 1:num_packages
     cur_name = installed_pkgs_lst{idx(i)}.name;
     cur_version = installed_pkgs_lst{idx(i)}.version;
     cur_dir = installed_pkgs_lst{idx(i)}.dir;
     if (length (cur_dir) > max_dir_length)
       first_char = length (cur_dir) - max_dir_length + 4;
-      first_filesep = strfind (cur_dir(first_char:end), filesep());
+      first_filesep = strfind (cur_dir(first_char:end), filesep ());
       if (! isempty (first_filesep))
         cur_dir = cstrcat ("...",
                           cur_dir((first_char + first_filesep(1) - 1):end));
       else
         cur_dir = cstrcat ("...", cur_dir(first_char:end));
       endif
     endif
     if (installed_pkgs_lst{idx(i)}.loaded)
diff --git a/scripts/pkg/private/repackage.m b/scripts/pkg/private/repackage.m
--- a/scripts/pkg/private/repackage.m
+++ b/scripts/pkg/private/repackage.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} repackage (@var{builddir}, @var{buildlist})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function repackage (builddir, buildlist)
   packages = installed_packages (buildlist, buildlist);
 
-  wd = pwd();
+  wd = pwd ();
   for i = 1 : length(packages)
     pack = packages{i};
     unwind_protect
       cd (builddir);
       mkdir (pack.name);
       mkdir (fullfile (pack.name, "inst"));
       copyfile (fullfile (pack.dir, "*"), fullfile (pack.name, "inst"));
       movefile (fullfile (pack.name, "inst","packinfo", "*"), pack.name);
diff --git a/scripts/pkg/private/unload_packages.m b/scripts/pkg/private/unload_packages.m
--- a/scripts/pkg/private/unload_packages.m
+++ b/scripts/pkg/private/unload_packages.m
@@ -30,17 +30,17 @@ function unload_packages (files, handle_
   pnames = pdirs = cell (1, num_packages);
   for i = 1:num_packages
     pnames{i} = installed_pkgs_lst{i}.name;
     pdirs{i} = installed_pkgs_lst{i}.dir;
     pdeps{i} = installed_pkgs_lst{i}.depends;
   endfor
 
   ## Get the current octave path.
-  p = strtrim (strsplit (path(), pathsep ()));
+  p = strtrim (strsplit (path (), pathsep ()));
 
   if (length (files) == 1 && strcmp (files{1}, "all"))
     ## Unload all.
     dirs = pdirs;
     desc = installed_pkgs_lst;
   else
     ## Unload package_name1 ...
     dirs = {};
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -177,17 +177,17 @@ function h = colorbar (varargin)
     h = cax;
   endif
 endfunction
 
 function deletecolorbar (h, d, hc, orig_props)
   ## Don't delete the colorbar and reset the axis size if the
   ## parent figure is being deleted.
   if (ishandle (hc) && strcmp (get (hc, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
     if (strcmp (get (hc, "beingdeleted"), "off"))
       delete (hc);
     endif
     if (!isempty (ancestor (h, "axes"))
         && strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
       set (ancestor (h, "axes"), "position", orig_props.position, ...
                             "outerposition", orig_props.outerposition, ...
                     "activepositionproperty", orig_props.activepositionproperty);
@@ -204,17 +204,17 @@ function resetaxis (cax, d, ax, orig_pro
              "outerposition", orig_props.outerposition, ...
              "activepositionproperty", orig_props.activepositionproperty);
     set (ax, "units", units)
   endif
 endfunction
 
 function update_colorbar_clim (h, d, hi, vert)
   if (ishandle (h) && strcmp (get (h, "type"), "image")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
     clen = rows (get (get (h, "parent"), "colormap"));
     cext = get (h, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
     if (vert)
       set (hi, "ydata", [cmin, cmax]);
@@ -224,17 +224,17 @@ function update_colorbar_clim (h, d, hi,
       set (get (hi, "parent"), "xlim", cext);
     endif
   endif
 endfunction
 
 function update_colorbar_axis (h, d, cax, orig_props)
 
   if (ishandle (cax) && strcmp (get (cax, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off")))
     loc = get (cax, "location");
     obj = get (h);
     obj.__my_handle__ = h;
     obj.position = orig_props.position;
     obj.outerposition = orig_props.outerposition;
     [pos, cpos, vertical, mirror] =  ...
         __position_colorbox__ (loc, obj, ancestor (h, "figure"));
 
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -54,17 +54,17 @@ function h = figure (varargin)
     else
       error ("figure: expecting figure handle or figure number");
     endif
   endif
 
   ## Check to see if we already have a figure on the screen.  If we do,
   ## then update it if it is different from the figure we are creating
   ## or switching to.
-  cf = get (0, "currentfigure");   # Can't use gcf() because it calls figure()
+  cf = get (0, "currentfigure");   # Can't use gcf () because it calls figure ()
   if (! isempty (cf) && cf != 0)
     if (isnan (f) || cf != f)
       drawnow ();
     endif
   endif
 
   if (rem (nargs, 2) == 0)
     if (isnan (f) || init_new_figure)
diff --git a/scripts/plot/gco.m b/scripts/plot/gco.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/gco.m
@@ -0,0 +1,45 @@
+## Copyright (C) 2012 Michael Goffioul
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{h} =} gco ()
+## @deftypefnx {Function File} {@var{h} =} gco (@var{fig})
+## Return a handle to the current object of the current figure, or a handle
+## to the current object of the figure with handle @var{fig}. The current
+## object of a figure is the object that was last clicked on. It is stored
+## in the CurrentObject property of the target figure.
+##
+## If the last mouse click didn't occur on any child object of the figure,
+## the current object is the figure itself.
+##
+## If no mouse click occured in the target figure, this function returns and
+## empty matrix.
+##
+## Note that the value returned by this function is not necessarily the same
+## as the one returned by gcbo during callback execution. An executing
+## callback can be interrupted by another callback and the current object
+## can be modified.
+##
+##@seealso{gcbo, gcf}
+##@end deftypefn
+
+function h = gco ()
+
+  h = get (gcf (), "currentobject");
+
+endfunction
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -12,27 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{name} =} graphics_toolkit ()
-## Returns the default graphics toolkit. The default graphics toolkit value
+## @deftypefn {Function File} {@var{name} =} graphics_toolkit ()
+## Return the default graphics toolkit.  The default graphics toolkit value
 ## is assigned to new figures.
 ## @deftypefnx {Function File} {@var{name} =} graphics_toolkit (@var{hlist})
-## Returns the graphics toolkits for the figures with handles @var{hlist}.
+## Return the graphics toolkits for the figures with handles @var{hlist}.
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{name})
-## Sets the default graphics toolkit to @var{name}.  If the toolkit is not
+## Set the default graphics toolkit to @var{name}.  If the toolkit is not
 ## already loaded, it is initialized by calling the function
 ## @code{__init_@var{name}__}.
 ## @deftypefnx {Function File} {} graphics_toolkit (@var{hlist}, @var{name})
-## Sets the graphics toolkit for the figues with handles @var{hlist} to
+## Set the graphics toolkit for the figures with handles @var{hlist} to
 ## @var{name}.
 ## @seealso{available_graphics_toolkits}
 ## @end deftypefn
 
 function retval = graphics_toolkit (name, hlist = [])
 
   if (nargin > 2)
     print_usage ();
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -169,17 +169,17 @@ function varargout = isosurface(varargin
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
                     "FaceVertexCData", fvc.facevertexcdata,
                     "FaceColor", "flat", "EdgeColor", "none");
       else
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
                     "FaceColor", "g", "EdgeColor", "k");
       endif
       if (! ishold ())
-        set (gca(), "view", [-37.5, 30],
+        set (gca (), "view", [-37.5, 30],
              "xgrid", "on", "ygrid", "on", "zgrid", "on");
       endif
     case 1
       varargout = {fvc};
     case 2
       varargout = {fvc.faces, fvc.vertices};
     case 3
       varargout = {fvc.faces, fvc.vertices, fvc.facevertexcdata};
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -851,17 +851,17 @@ function hideshowlegend (h, d, ca, pos1,
         isvisible = true;
         break;
       endif
     endfor
   endif
 
   for i = 1 : numel (ca)
     if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes")
-        && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+        && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
         && strcmp (get (ca(i), "beingdeleted"), "off"))
       units = get (ca(i), "units");
       unwind_protect
         set (ca(i), "units", "points");
         if (isvisible)
           set (ca(i), "position", pos2);
         else
           set (ca(i), "position", pos1);
@@ -870,26 +870,26 @@ function hideshowlegend (h, d, ca, pos1,
         set (ca(i), "units", units);
       end_unwind_protect
     endif
   endfor
 endfunction
 
 function deletelegend1 (h, d, ca)
   if (ishandle (ca) && strcmp (get (ca, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
       && strcmp (get (ca, "beingdeleted"), "off"))
     delete (ca);
   endif
 endfunction
 
 function deletelegend2 (h, d, ca, pos, outpos, t1, hplots)
   for i = 1 : numel (ca)
     if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes")
-        && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+        && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
         && strcmp (get (ca(i), "beingdeleted"), "off"))
       if (!isempty (pos) && !isempty(outpos))
         units = get (ca(i), "units");
         unwind_protect
           set (ca(i), "units", "points");
           set (ca(i), "position", pos, "deletefcn", "");
         unwind_protect_cleanup
           set (ca(i), "units", units);
diff --git a/scripts/plot/line.m b/scripts/plot/line.m
--- a/scripts/plot/line.m
+++ b/scripts/plot/line.m
@@ -43,23 +43,23 @@ function h = line (varargin)
 
 endfunction
 
 %!demo
 %! clf
 %! x = 0:0.3:10;
 %! y1 = cos (x);
 %! y2 = sin (x);
-%! subplot (3, 1, 1)
+%! subplot (3,1,1);
 %! args = {"color", "b", "marker", "s"};
 %! line ([x(:), x(:)], [y1(:), y2(:)], args{:})
 %! title ("Test broadcasting for line()")
-%! subplot (3, 1, 2)
+%! subplot (3,1,2);
 %! line (x(:), [y1(:), y2(:)], args{:})
-%! subplot (3, 1, 3)
+%! subplot (3,1,3);
 %! line ([x(:), x(:)+pi/2], y1(:), args{:})
 %! xlim ([0 10])
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = line;
 %!   assert (findobj (hf, "type", "line"), h);
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -33,17 +33,17 @@
 
 ## Author: jwe
 
 function retval = loglog (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("loglog", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "xscale", "log", "yscale", "log");
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -100,16 +100,17 @@ plot_FCN_FILES = \
   plot/findall.m \
   plot/findfigs.m \
   plot/findobj.m \
   plot/fplot.m \
   plot/gca.m \
   plot/gcbf.m \
   plot/gcbo.m \
   plot/gcf.m \
+  plot/gco.m \
   plot/ginput.m \
   plot/graphics_toolkit.m \
   plot/grid.m \
   plot/gtext.m \
   plot/guidata.m \
   plot/guihandles.m \
   plot/hggroup.m \
   plot/hidden.m \
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -181,17 +181,17 @@
 
 ## Author: jwe
 
 function retval = plot (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("plot", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
     tmp = __plt__ ("plot", h, varargin{:});
   unwind_protect_cleanup
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -322,17 +322,17 @@ function retval = plot3 (varargin)
       if (! isempty (key))
         hlgnd = [hlgnd, tmp(idx)];
         tlgnd = {tlgnd{:}, key};
       endif
     endfor
   endif
 
   if (!isempty (hlgnd))
-    legend (gca(), hlgnd, tlgnd);
+    legend (gca (), hlgnd, tlgnd);
   endif
 
   set (gca (), "view", [-37.5, 30]);
 
   if (nargout > 0 && idx > 0)
     retval = tmp;
   endif
 
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -86,16 +86,17 @@ function [Ax, H1, H2] = plotyy (varargin
     endif
     if (length (ax) > 2)
       for i = 3 : length (ax)
         delete (ax (i));
       endfor
       ax = ax(1:2);
     elseif (length (ax) == 1)
       ax(2) = axes ();
+      set (ax(2), "nextplot", get (ax(1), "nextplot"))
     elseif (isempty (ax))
       ax(1) = axes ();
       ax(2) = axes ();
       ca = ax(2);
     endif
     if (nargin < 2)
       varargin = {};
     endif
@@ -151,33 +152,33 @@ function [ax, h1, h2] = __plotyy__ (ax, 
 
   cf = gcf ();
   set (cf, "nextplot", "add");
 
   if (ishandle(ax(2)) && strcmp (get (ax(2), "type"), "axes"))
     axes (ax(2));
   else
     ax(2) = axes ();
+    set (ax(2), "nextplot", get (ax(1), "nextplot"))
   endif
   newplot ();
 
   colors = get (ax(1), "colororder");
   set (ax(2), "colororder", [colors(2:end,:); colors(1,:)]);
 
   if (strcmp (get (ax(1), "autopos_tag"), "subplot"))
     set (ax(2), "autopos_tag", "subplot");
   else
     set (ax, "activepositionproperty", "position");
   endif
 
   h2 = feval (fun2, x2, y2);
   set (ax(2), "yaxislocation", "right");
   set (ax(2), "ycolor", getcolor (h2(1)));
 
-
   if (strcmp (get(ax(1), "activepositionproperty"), "position"))
     set (ax(2), "position", get (ax(1), "position"));
   else
     set (ax(2), "outerposition", get (ax(1), "outerposition"));
     set (ax(2), "looseinset", get (ax(1), "looseinset"));
   endif
 
   set (ax(2), "xlim", xlim);
@@ -203,16 +204,18 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   addlistener (ax(1), "looseinset", {@update_position, ax(2)});
   addlistener (ax(2), "looseinset", {@update_position, ax(1)});
   addlistener (ax(1), "view", {@update_position, ax(2)});
   addlistener (ax(2), "view", {@update_position, ax(1)});
   addlistener (ax(1), "plotboxaspectratio", {@update_position, ax(2)});
   addlistener (ax(2), "plotboxaspectratio", {@update_position, ax(1)});
   addlistener (ax(1), "plotboxaspectratiomode", {@update_position, ax(2)});
   addlistener (ax(2), "plotboxaspectratiomode", {@update_position, ax(1)});
+  addlistener (ax(1), "nextplot", {@update_nextplot, ax(2)});
+  addlistener (ax(2), "nextplot", {@update_nextplot, ax(1)});
 
   ## Store the axes handles for the sister axes.
   if (ishandle (ax(1)) && ! isprop (ax(1), "__plotyy_axes__"))
     addproperty ("__plotyy_axes__", ax(1), "data", ax);
   elseif (ishandle (ax(1)))
     set (ax(1), "__plotyy_axes__", ax);
   else
     error ("plotyy.m: This shouldn't happen. File a bug report.")
@@ -256,29 +259,56 @@ endfunction
 %! subplot (2,2,4);
 %!  plotyy (x,10*sin(2*pi*x), x,cos(2*pi*x));
 %! axis square;
 
 %!demo
 %! clf;
 %! x = linspace (-1, 1, 201);
 %! hax = plotyy (x, sin (pi*x), x, cos (pi*x));
-%! ylabel ('Blue on the Left');
+%! ylabel (hax(1), 'Blue on the Left');
 %! ylabel (hax(2), 'Green on the Right');
 %! xlabel ('xlabel');
 
+%!demo
+%! clf
+%! hold on
+%! t = (0:0.1:9);
+%! x = sin (t);
+%! y = 5 * cos (t);
+%! [hax, h1, h2] = plotyy (t, x, t, y);
+%! [~, h3, h4] = plotyy (t+1, x, t+1, y);
+%! set ([h3, h4], "linestyle", "--")
+%! xlabel (hax(1), 'xlabel')
+%! title (hax(2), 'title')
+%! ylabel (hax(1), 'Left axis is Blue')
+%! ylabel (hax(2), 'Right axis is Green')
+
 function deleteplotyy (h, d, ax2, t2)
   if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes")
-      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+      && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"),"off"))
       && strcmp (get (ax2, "beingdeleted"), "off"))
     set (t2, "deletefcn", []);
     delete (ax2);
   endif
 endfunction
 
+function update_nextplot (h, d, ax2)
+  persistent recursion = false;
+  prop = "nextplot";
+  if (! recursion)
+    unwind_protect
+      recursion = true;
+      set (ax2, prop, get (h, prop));
+    unwind_protect_cleanup
+      recursion = false;
+    end_unwind_protect
+  endif
+endfunction
+
 function update_position (h, d, ax2)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       view = get (h, "view");
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -33,17 +33,17 @@
 
 ## Author: jwe
 
 function retval = polar (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("polar", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     if (nargs == 3)
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -72,19 +72,19 @@
 ## non-printed output the aspect ratio of the output corresponds to
 ## the plot area defined by the "paperposition" property in the
 ## orientation specified.  This options is equivalent to changing
 ## the figure's "paperorientation" property.
 ##
 ## @item -TextAlphaBits=@var{n}
 ## @itemx -GraphicsAlphaBits=@var{n}
 ##   Octave is able to produce output for various printers, bitmaps, and
-## vector formats by using ghostscript.
-## For bitmap and printer output antialiasing is applied using
-## ghostscript's TextAlphaBits and GraphicsAlphaBits options.
+## vector formats by using Ghostscript.
+## For bitmap and printer output anti-aliasing is applied using
+## Ghostscript's TextAlphaBits and GraphicsAlphaBits options.
 ## The default number of bits for each is 4.
 ## Allowed values, for @var{N}, are 1, 2, or 4.
 ##
 ## @item -d@var{device}
 ##   The available output format is specified by the option @var{device},
 ##   and is one of:
 ##
 ##   @table @code
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -191,17 +191,17 @@ function h = __errplot__ (fstr, p, varar
 
     update_data (hg, [], hl);
 
   endfor
 
   ## Process legend key
   if (! isempty (fmt.key))    
     hlegend = [];
-    fkids = get (gcf(), "children");
+    fkids = get (gcf (), "children");
     for i = 1 : numel (fkids)
       if (ishandle (fkids(i)) && strcmp (get (fkids(i), "type"), "axes")
           && (strcmp (get (fkids(i), "tag"), "legend")))
         udata = get (fkids(i), "userdata");
         if (! isempty (intersect (udata.handle, gca ())))
           hlegend = fkids (i);
           break;
         endif
@@ -213,17 +213,17 @@ function h = __errplot__ (fstr, p, varar
       tlgnd = {};
     else
       [hlgnd, tlgnd] = __getlegenddata__ (hlegend);
     endif
  
     hlgnd(end+1) = hg;
     tlgnd(end+1) = fmt.key;
 
-    legend (gca(), hlgnd, tlgnd);
+    legend (gca (), hlgnd, tlgnd);
   endif
 
 endfunction
 
 function [xdata, ydata] = errorbar_data (xdata, ydata, ldata, udata,
                                          xldata, xudata, ifmt,
                                          xscale, yscale)
   if (strcmp (xscale, "linear"))
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -113,23 +113,23 @@ function [gs_cmd, cleanup_cmd] = __ghost
       cleanup_cmd = "";
     else
       offsetfile = strcat (tmpnam (), ".ps");
       cleanup_cmd = sprintf ("rm %s", offsetfile);
     endif
     unwind_protect
       fid = fopen (offsetfile, "w");
       if (fid == -1)
-        error ("print:fopenfailed", "__ghostscript__.m: fopen() failed");
+        error ("print:fopenfailed", "__ghostscript__.m: fopen () failed");
       endif
       fprintf (fid, "%s\n", offset_ps{:});
     unwind_protect_cleanup
       status = fclose (fid);
       if (status == -1)
-        error ("print:fclosefailed", "__ghostscript__.m: fclose() failed");
+        error ("print:fclosefailed", "__ghostscript__.m: fclose () failed");
       endif
     end_unwind_protect
     if (opts.debug)
       fprintf ("---- begin %s ----\n", offsetfile);
       fprintf ("%s\n", offset_ps{:});
       fprintf ("----- end %s -----\n", offsetfile);
     endif
   endif
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/private/__marching_cube__.m
@@ -230,17 +230,17 @@ function p = vertex_interp(isolevel,p1x,
       p1y(nid) + mu(nid) .* (p2y(nid) - p1y(nid)), ...
       p1z(nid) + mu(nid) .* (p2z(nid) - p1z(nid))];
     if (nargin == 11)
       p(nid, 4) = col1(nid) + mu(nid) .* (col2(nid) - col1(nid));
     endif
   endif
 endfunction
 
-function [edge_table, tri_table] = init_mc()
+function [edge_table, tri_table] = init_mc ()
   edge_table = [
   0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, ...
   0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, ...
   0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, ...
   0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, ...
   0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c, ...
   0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, ...
   0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac, ...
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/private/__plt__.m
@@ -32,17 +32,17 @@ function retval = __plt__ (caller, h, va
     k = 1;
 
     x_set = false;
     y_set = false;
     property_set = false;
     properties = {};
 
     hlegend = [];
-    fkids = get (gcf(), "children");
+    fkids = get (gcf (), "children");
     for i = 1 : numel(fkids)
       if (ishandle (fkids (i)) && strcmp (get (fkids (i), "type"), "axes")
           && (strcmp (get (fkids (i), "tag"), "legend")))
         udata = get (fkids (i), "userdata");
         if (! isempty (intersect (udata.handle, gca ())))
           hlegend = fkids (i);
           break;
         endif
@@ -127,17 +127,17 @@ function retval = __plt__ (caller, h, va
       else
         x = next_arg;
         x_set = true;
       endif
 
     endwhile
 
     if (setlgnd)
-      legend (gca(), hlgnd, tlgnd);
+      legend (gca (), hlgnd, tlgnd);
     endif
   else
     error ("__plt__: invalid number of arguments");
   endif
 
 endfunction
 
 function [hlgnd, tlgnd, setlgnd] = __plt_key__ (h, options, hlgnd, tlgnd, setlgnd)
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -106,17 +106,17 @@ function hg = __scatter__ (varargin)
       newargs{end+1} = arg;
       if (iarg <= nargin)
         newargs{end+1} = varargin{iarg++};
       endif
     endif
   endwhile
 
   if (isempty (c))
-    c = __next_line_color__();
+    c = __next_line_color__ ();
   endif
 
   hg = hggroup ();
   newargs = __add_datasource__ (fcn, hg, {"x", "y", "z", "c", "size"},
                              newargs{:});
 
   addproperty ("xdata", hg, "data", x);
   addproperty ("ydata", hg, "data", y);
@@ -263,17 +263,18 @@ function h = render_size_color(hg, vert,
   if (isscalar (s))
     x = vert(:,1);
     y = vert(:,2);
     z = vert(:,3:end);
     toolkit = get (ancestor (hg, "figure"), "__graphics_toolkit__");
     ## Does gnuplot only support triangles with different vertex colors ?
     ## TODO - Verify gnuplot can only support one color. If RGB triplets
     ##        can be assigned to each vertex, then fix __go_draw_axe__.m
-    gnuplot_hack = numel (x) > 1 && strcmp (toolkit, "gnuplot");
+    gnuplot_hack = (numel (x) > 1 && columns (c) == 3
+                    && strcmp (toolkit, "gnuplot"));
     if (ischar (c) || ! isflat || gnuplot_hack)
       if (filled)
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1:numel(x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker,
                           "markeredgecolor", "none",
                           "markerfacecolor", c(1,:),
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -87,16 +87,24 @@ endfunction
 %! y = randn (100, 1);
 %! scatter (x, y, 'r');
 %! title ('Scatter plot with red bubbles');
 
 %!demo
 %! clf;
 %! x = randn (100, 1);
 %! y = randn (100, 1);
+%! c = x .* y;
+%! scatter (x, y, 20, c, 'filled');
+%! title ('Scatter with colors');
+
+%!demo
+%! clf;
+%! x = randn (100, 1);
+%! y = randn (100, 1);
 %! scatter (x, y, [], sqrt (x.^2 + y.^2));
 %! title ('Scatter plot with bubble color determined by distance from origin');
 
 %!demo
 %! clf;
 %! rand_10x1_data1 = [0.171577, 0.404796, 0.025469, 0.335309, 0.047814, 0.898480, 0.639599, 0.700247, 0.497798, 0.737940];
 %! rand_10x1_data2 = [0.75495, 0.83991, 0.80850, 0.73603, 0.19360, 0.72573, 0.69371, 0.74388, 0.13837, 0.54143];
 %! x = rand_10x1_data1;
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -33,17 +33,17 @@
 
 ## Author: jwe
 
 function retval = semilogx (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogx", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "xscale", "log");
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -33,17 +33,17 @@
 
 ## Author: jwe
 
 function retval = semilogy (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogy", varargin{:});
 
   if (nargs < 1)
-    print_usage();
+    print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "yscale", "log");
diff --git a/scripts/plot/trimesh.m b/scripts/plot/trimesh.m
--- a/scripts/plot/trimesh.m
+++ b/scripts/plot/trimesh.m
@@ -36,20 +36,20 @@ function h = trimesh (tri, x, y, z, vara
 
   if (nargin == 3)
     triplot (tri, x, y);
   elseif (ischar (z))
     triplot (tri, x, y, z, varargin{:});
   else
     newplot ();
     handle = patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri,
-                    "FaceColor", "none", "EdgeColor", __next_line_color__(),
+                    "FaceColor", "none", "EdgeColor", __next_line_color__ (),
                     varargin{:});
     if (! ishold ())
-      set (gca(), "view", [-37.5, 30],
+      set (gca (), "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
     if (nargout > 0)
       h = handle;
     endif
   endif
 
 endfunction
diff --git a/scripts/plot/trisurf.m b/scripts/plot/trisurf.m
--- a/scripts/plot/trisurf.m
+++ b/scripts/plot/trisurf.m
@@ -59,17 +59,17 @@ function h = trisurf (tri, x, y, z, vara
     handle = patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],
                     "FaceVertexCData", reshape (c, numel (c), 1),
                     varargin{:});
     if (nargout > 0)
       h = handle;
     endif
 
     if (! ishold ())
-      set (gca(), "view", [-37.5, 30],
+      set (gca (), "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   endif
 
 endfunction
 
 
 %!demo
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -63,17 +63,17 @@ function yi = ppval (pp, xi)
   else
     Pidx = reshape (Pidx, [sxi, k, d]);
     Pidx = shiftdim (Pidx, length (sxi));
     dimvec = [d, sxi];
   endif
   ndv = length (dimvec);
 
   ## Offsets.
-  dx = (xi - x(idx));
+  dx = (xi - x(idx))(:)';
   dx = repmat (dx, [prod(d), 1]);
   dx = reshape (dx, dimvec);
   dx = shiftdim (dx, ndv - 1);
 
   ## Use Horner scheme.
   yi = Pidx;
   if (k > 1)
     yi = shiftdim (reshape (Pidx(1,:), dimvec), ndv - 1);
@@ -114,9 +114,16 @@ endfunction
 %!assert (ppval (pp, 2.1), 1.1, abserr)
 %!assert (ppval (pp, xi), [1.1 1.3 1.9 1.1], abserr)
 %!assert (ppval (pp, xi.'), [1.1 1.3 1.9 1.1].', abserr)
 %!assert (ppval (pp2, 1.1), [1.1;1.1], abserr)
 %!assert (ppval (pp2, 2.1), [1.1;1.1], abserr)
 %!assert (ppval (pp2, xi), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
 %!assert (ppval (pp2, xi'), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
 %!assert (size (ppval (pp2, [xi;xi])), [2 2 4])
-
+%!test
+%! breaks = [0, 1, 2, 3];
+%! coefs = rand (6, 4);
+%! pp = mkpp (breaks, coefs, 2);
+%! ret = zeros (2, 4, 2);
+%! ret(:,:,1) = ppval (pp, breaks');
+%! ret(:,:,2) = ppval (pp, breaks');
+%! assert (ppval (pp, [breaks',breaks']), ret)
diff --git a/scripts/signal/private/rectangle_lw.m b/scripts/signal/private/rectangle_lw.m
--- a/scripts/signal/private/rectangle_lw.m
+++ b/scripts/signal/private/rectangle_lw.m
@@ -29,11 +29,11 @@ function retval = rectangle_lw (n, b)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   retval = zeros (n, 1);
   t = floor (1 / b);
 
-  retval (1:t, 1) = ones (t, 1);
+  retval(1:t, 1) = ones (t, 1);
 
 endfunction
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -53,16 +53,16 @@ function retval = sinetone (freq, rate, 
   endif
 
   n = length (freq);
   ns = round (rate * sec);
 
   retval = zeros (ns, n);
 
   for k = 1:n
-    retval (:, k) = ampl(k) * sin (2 * pi * (1:ns) / rate * freq(k))';
+    retval(:, k) = ampl(k) * sin (2 * pi * (1:ns) / rate * freq(k))';
   endfor
 
 endfunction
 
 
 %!assert (size (sinetone (18e6, 150e6, 19550/150e6, 1)), [19550, 1])
 
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -41,16 +41,17 @@
 ## a function handle or inline function @code{g} such that
 ## @code{g(x, "notransp") = M1 \ x} or @code{g(x, "notransp") = M2 \ x} and
 ## @code{g(x, "transp") = M1' \ x} or @code{g(x, "transp") = M2' \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
+##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
 ##
 ## @item 3: the algorithm reached stagnation
 ## @end itemize
 ## (the value 2 is unused but skipped for compatibility).
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -43,16 +43,17 @@
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
 ## handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
 ## @code{g(x) = M2 \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
+##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
 ##
 ## @item 3: the algorithm reached stagnation
 ## @end itemize
 ## (the value 2 is unused but skipped for compatibility).
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -43,16 +43,17 @@
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as a function
 ## handle or inline function @code{g} such that @code{g(x) = M1 \ x} or
 ## @code{g(x) = M2 \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
+##
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
 ## @item 1: the maximum number of iterations was reached before convergence
 ##
 ## @item 3: the algorithm reached stagnation
 ## @end itemize
 ## (the value 2 is unused but skipped for compatibility).
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -169,35 +169,34 @@ function [x, flag, relres, it, resvec] =
 
     little_res = B(1:restart_it+1) - ...
         H(1:restart_it+1, 1:restart_it) * Y(1:restart_it);
 
     presn = norm (little_res, 2);
 
     x = x_old + V(:, 1:restart_it) * Y(1:restart_it);
 
-    resvec(iter) = presn;
+    resvec(iter+1) = presn;
     if (norm (x - x_old, inf) <= eps)
       flag = 3;  # Stagnation: no change between iterations
       break;
     endif
 
     restart_it++ ;
     iter++;
   endwhile
 
   if (nargout > 1)
     ## Calculate extra outputs as requested
     relres = presn / prec_b_norm;
     if (relres <= rtol)
       flag = 0;  # Converged to solution within tolerance
     endif
 
-    resvec = resvec(1:iter-1);
-    it = [ceil(iter / restart), rem(iter, restart)];
+    it = [floor(iter/restart), restart_it-1];
   endif
 
 endfunction
 
 
 %!demo
 %! dim = 20;
 %! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -26,16 +26,17 @@
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
 ## @end example
 ##
 ## @end ifnottex
+## @seealso{betaln, betainc}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 13 June 1993
 ## Adapted-By: jwe
 
 function retval = beta (a, b)
 
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -18,21 +18,45 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strcat (@var{s1}, @var{s2}, @dots{})
 ## Return a string containing all the arguments concatenated
 ## horizontally.  If the arguments are cells strings,  @code{strcat}
 ## returns a cell string with the individual cells concatenated.
 ## For numerical input, each element is converted to the
-## corresponding ASCII character.  Trailing white space is eliminated.
+## corresponding ASCII character.  Trailing white space for each of
+## the inputs (@var{s1}, @var{S2}, @dots{}) is eliminated before they
+## are concatenated.
+##
 ## For example:
 ##
 ## @example
 ## @group
+## strcat ("|", " leading space is preserved", "|")
+##     @result{} | leading space is perserved|
+## @end group
+## @end example
+##
+## @example
+## @group
+## strcat ("|", "trailing space is eliminated ", "|")
+##     @result{} |trailing space is eliminated|
+## @end group
+## @end example
+##
+## @example
+## @group
+## strcat ("homogeneous space |", "  ", "| is also eliminated")
+##     @result{} homogeneous space || is also eliminated
+## @end group
+## @end example
+##
+## @example
+## @group
 ## s = [ "ab"; "cde" ];
 ## strcat (s, s, s)
 ##     @result{}
 ##         "ab ab ab "
 ##         "cdecdecde"
 ## @end group
 ## @end example
 ##
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -123,17 +123,17 @@ function demo (name, n)
     ## Process each demo without failing
     try
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       ## FIXME: need to check for embedded test functions, which cause
       ## segfaults, until issues with subfunctions in functions are resolved.
       embed_func = regexp (block, '^\s*function ', 'once', 'lineanchors');
       if (isempty (embed_func))
         ## Use an environment without variables
-        eval (cstrcat ("function __demo__()\n", block, "\nendfunction"));
+        eval (cstrcat ("function __demo__ ()\n", block, "\nendfunction"));
         ## Display the code that will be executed before executing it
         printf ("%s example %d:%s\n\n", name, doidx(i), block);
         __demo__;
       else
         error (["Functions embedded in %!demo blocks are not allowed.\n", ...
                 "Use the %!function/%!endfunction syntax instead to define shared functions for testing.\n"]);
       endif
     catch
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -276,17 +276,17 @@ function [__ret1, __ret2, __ret3, __ret4
         else
           __demo_code = cstrcat(__demo_code, __code);
           __demo_idx = [__demo_idx, length(__demo_code)+1];
         endif
 
       elseif (__rundemo && __isdemo)
         try
           ## process the code in an environment without variables
-          eval (sprintf ("function __test__()\n%s\nendfunction", __code));
+          eval (sprintf ("function __test__ ()\n%s\nendfunction", __code));
           __test__;
           input ("Press <enter> to continue: ", "s");
         catch
           __success = 0;
           __msg = sprintf ("%sdemo failed\n%s",  __signal_fail, lasterr ());
         end_try_catch
         clear __test__;
 
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -130,17 +130,17 @@ function __datetick__ (varargin)
     endif
   endif
 
   if (keepticks)
     ticks = get (gca (), strcat (ax, "tick"));
   else
     ## Need to do our own axis tick position calculation as
     ## year, etc, don't fallback on nice datenum values.
-    objs = findall (gca());
+    objs = findall (gca ());
     xmax = NaN;
     xmin = NaN;
     for i = 1 : length (objs)
       fld = get (objs (i));
       if (isfield (fld, strcat (ax, "data")))
         xdata = getfield (fld, strcat (ax, "data"))(:);
         xmin = min (xmin, min (xdata));
         xmax = max (xmax, max (xdata));
@@ -239,26 +239,26 @@ function __datetick__ (varargin)
       sticks = datestr (ticks, form);
     endif
   endif
 
   sticks = mat2cell (sticks, ones (rows (sticks), 1), columns (sticks));
 
   if (keepticks)
     if (keeplimits)
-      set (gca(), strcat (ax, "ticklabel"), sticks);
+      set (gca (), strcat (ax, "ticklabel"), sticks);
     else
-      set (gca(), strcat (ax, "ticklabel"), sticks, strcat (ax, "lim"),
+      set (gca (), strcat (ax, "ticklabel"), sticks, strcat (ax, "lim"),
       [min(ticks), max(ticks)]);
     endif
   else
     if (keeplimits)
-      set (gca(), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks);
+      set (gca (), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks);
     else
-      set (gca(), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks,
+      set (gca (), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks,
       strcat (ax, "lim"), [min(ticks), max(ticks)]);
     endif
   endif
 endfunction
 
 function [a, b] = __magform__ (x)
   if (x == 0)
     a = 0;
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -26,17 +26,17 @@
 ## @code{datestr}) into a date vector.
 ##
 ## A date vector is a row vector with six members, representing the year,
 ## month, day, hour, minute, and seconds respectively.
 ##
 ## @var{f} is the format string used to interpret date strings
 ## (see @code{datestr}).  If @var{date} is a string, but no format is
 ## specified, then a relatively slow search is performed through various
-## formats.  It is always preferable to specifiy the format string @var{f}
+## formats.  It is always preferable to specify the format string @var{f}
 ## if it is known.  Formats which do not specify a particular time component
 ## will have the value set to zero.  Formats which do not specify a date will
 ## default to January 1st of the current year.
 ##
 ## @var{p} is the year at the start of the century to which two-digit years
 ## will be referenced.  If not specified, it defaults to the current year
 ## minus 50.
 ## @seealso{datenum, datestr, clock, now, date}
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -119,17 +119,17 @@ Undocumented internal function.\n\
 
   if (n > dim + 1)
     {
       p = p.transpose ();
       double *pt_array = p.fortran_vec ();
       boolT ismalloc = false;
 
       // Qhull flags argument is not const char*
-      OCTAVE_LOCAL_BUFFER (char, flags, 9 + options.length());
+      OCTAVE_LOCAL_BUFFER (char, flags, 9 + options.length ());
 
       sprintf (flags, "qhull d %s", options.c_str ());
 
       unwind_protect frame;
 
       // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
       FILE *outfile = gnulib::fopen ("NUL", "w");
diff --git a/src/DLD-FUNCTIONS/__dsearchn__.cc b/src/DLD-FUNCTIONS/__dsearchn__.cc
--- a/src/DLD-FUNCTIONS/__dsearchn__.cc
+++ b/src/DLD-FUNCTIONS/__dsearchn__.cc
@@ -35,37 +35,37 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 
 DEFUN_DLD (__dsearchn__, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{idx}, @var{d}] =} dsearch (@var{x}, @var{xi})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 2)
     {
       print_usage ();
       return retval;
     }
 
-  Matrix x = args(0).matrix_value().transpose ();
-  Matrix xi = args(1).matrix_value().transpose ();
+  Matrix x = args(0).matrix_value ().transpose ();
+  Matrix xi = args(1).matrix_value ().transpose ();
 
   if (! error_state)
     {
-      if (x.rows() != xi.rows() || x.columns() < 1)
+      if (x.rows () != xi.rows () || x.columns () < 1)
         error ("__dsearch__: number of rows of X and XI must match");
       else
         {
-          octave_idx_type n = x.rows();
-          octave_idx_type nx = x.columns();
-          octave_idx_type nxi = xi.columns();
+          octave_idx_type n = x.rows ();
+          octave_idx_type nx = x.columns ();
+          octave_idx_type nxi = xi.columns ();
 
           ColumnVector idx (nxi);
           double *pidx = idx.fortran_vec ();
           ColumnVector dist (nxi);
           double *pdist = dist.fortran_vec ();
 
 #define DIST(dd, y, yi, m) \
   dd = 0.; \
diff --git a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
--- a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
+++ b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
@@ -53,25 +53,25 @@ Undocumented internal function.\n\
   //   args(0) ... FileFilter in fltk format
   //   args(1) ... Title
   //   args(2) ... Default Filename
   //   args(3) ... PostionValue [x,y]
   //   args(4) ... SelectValue "on"/"off"/"dir"/"create"
 
   octave_value_list retval (3, octave_value (0));
 
-  std::string file_filter = args(0).string_value();
-  std::string title = args(1).string_value();
-  std::string default_name = args(2).string_value();
-  Matrix pos = args(3).matrix_value();
+  std::string file_filter = args(0).string_value ();
+  std::string title = args(1).string_value ();
+  std::string default_name = args(2).string_value ();
+  Matrix pos = args(3).matrix_value ();
 
   int multi_type = Fl_File_Chooser::SINGLE;
   std::string flabel = "Filename:";
 
-  std::string multi = args(4).string_value();
+  std::string multi = args(4).string_value ();
   if (multi == "on")
     multi_type = Fl_File_Chooser::MULTI;
   else if (multi == "dir")
     {
       multi_type = Fl_File_Chooser::DIRECTORY;
       flabel = "Directory:";
     }
   else if (multi == "create")
@@ -87,34 +87,34 @@ Undocumented internal function.\n\
   if (multi_type == Fl_File_Chooser::CREATE)
     fc.ok_label ("Save");
 
   fc.show ();
 
   while (fc.shown ())
     Fl::wait ();
 
-  if (fc.value())
+  if (fc.value ())
     {
       int file_count = fc.count ();
       std::string fname;
 
       //fltk uses forward slash even for windows
       std::string sep = "/";
       std::size_t idx;
 
       if (file_count == 1 && multi_type != Fl_File_Chooser::DIRECTORY)
         {
           fname = fc.value ();
           idx = fname.find_last_of (sep);
           retval(0) = fname.substr (idx + 1);
         }
       else
         {
-          Cell file_cell = Cell(file_count, 1);
+          Cell file_cell = Cell (file_count, 1);
           for (octave_idx_type n = 1; n <= file_count; n++)
             {
               fname = fc.value (n);
               idx = fname.find_last_of (sep);
               file_cell(n - 1) = fname.substr (idx + 1);
             }
           retval(0) = file_cell;
         }
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -163,17 +163,17 @@ glpk (int sense, int n, int m, double *c
       int *freeUB, double *ub, int *vartype, int isMIP, int lpsolver,
       int save_pb, double *xmin, double *fmin, double *status,
       double *lambda, double *redcosts, double *time, double *mem)
 {
   int errnum;
   int typx = 0;
   int method;
 
-  clock_t t_start = clock();
+  clock_t t_start = clock ();
 
 #if 0
 #ifdef GLPK_PRE_4_14
   lib_set_fault_hook (0, glpk_fault_hook);
 #else
   _glp_lib_fault_hook (glpk_fault_hook, 0);
 #endif
 
@@ -277,26 +277,26 @@ glpk (int sense, int n, int m, double *c
       if (lpx_write_cpxlp (lp, tmp) != 0)
         {
           error ("__glpk__: unable to write problem");
           longjmp (mark, -1);
         }
     }
 
   //-- scale the problem data (if required)
-  //-- if (scale && (!presol || method == 1)) lpx_scale_prob(lp);
+  //-- if (scale && (!presol || method == 1)) lpx_scale_prob (lp);
   //-- LPX_K_SCALE=IParam[1]  LPX_K_PRESOL=IParam[16]
   if (lpxIntParam[1] && (! lpxIntParam[16] || lpsolver != 1))
     lpx_scale_prob (lp);
 
   //-- build advanced initial basis (if required)
   if (lpsolver == 1 && ! lpxIntParam[16])
     lpx_adv_basis (lp);
 
-  for(int i = 0; i < NIntP; i++)
+  for (int i = 0; i < NIntP; i++)
     lpx_set_int_parm (lp, IParam[i], lpxIntParam[i]);
 
   for (int i = 0; i < NRealP; i++)
     lpx_set_real_parm (lp, RParam[i], lpxRealParam[i]);
 
   if (lpsolver == 1)
     method = 'S';
   else
@@ -308,22 +308,22 @@ glpk (int sense, int n, int m, double *c
       {
         if (isMIP)
           {
             method = 'I';
             errnum = lpx_simplex (lp);
             errnum = lpx_integer (lp);
           }
         else
-          errnum = lpx_simplex(lp);
+          errnum = lpx_simplex (lp);
       }
      break;
 
     case 'T':
-      errnum = lpx_interior(lp);
+      errnum = lpx_interior (lp);
       break;
 
     default:
       break;
 #if 0
 #ifdef GLPK_PRE_4_14
       insist (method != method);
 #else
@@ -483,17 +483,17 @@ Undocumented internal function.\n\
   if (nrhs != 9)
     {
       print_usage ();
       return retval;
     }
 
   //-- 1nd Input. A column array containing the objective function
   //--            coefficients.
-  volatile int mrowsc = args(0).rows();
+  volatile int mrowsc = args(0).rows ();
 
   Matrix C (args(0).matrix_value ());
 
   if (error_state)
     {
       error ("__glpk__: invalid value of C");
       return retval;
     }
@@ -526,20 +526,20 @@ Undocumented internal function.\n\
 
       if (Anc != mrowsc)
         {
           error ("__glpk__: invalid value of A");
           return retval;
         }
 
       for (octave_idx_type j = 0; j < Anc; j++)
-        for (octave_idx_type i = A.cidx(j); i < A.cidx(j+1); i++)
+        for (octave_idx_type i = A.cidx (j); i < A.cidx (j+1); i++)
           {
             nz++;
-            rn(nz) = A.ridx(i) + 1;
+            rn(nz) = A.ridx (i) + 1;
             cn(nz) = j + 1;
             a(nz) = A.data(i);
           }
     }
   else
     {
       Matrix A (args(1).matrix_value ()); // get the matrix
 
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -252,29 +252,29 @@ private:
   }
 };
 
 // Parameter controlling how fast we zoom when using the scrool wheel.
 static double wheel_zoom_speed = 0.05;
 // Parameter controlling the GUI mode.
 static enum { pan_zoom, rotate_zoom, none } gui_mode;
 
-void script_cb(Fl_Widget*, void* data)
+void script_cb (Fl_Widget*, void* data)
   {
     static_cast<uimenu::properties*> (data)->execute_callback ();
   }
 
 
 class fltk_uimenu
 {
 public:
   fltk_uimenu (int xx, int yy, int ww, int hh)
     {
       menubar = new
-        Fl_Menu_Bar(xx, yy, ww, hh);
+        Fl_Menu_Bar (xx, yy, ww, hh);
     }
 
   int items_to_show (void)
     {
       //returns the number of visible menu items
       int len = menubar->size ();
       int n = 0;
       for (int t = 0; t < len; t++ )
@@ -680,17 +680,17 @@ public:
     {
 
       canvas = new OpenGL_fltk (0, 0, ww, hh - status_h, number ());
 
       uimenu = new fltk_uimenu (0, 0, ww, menu_h);
       uimenu->hide ();
 
       bottom = new Fl_Box (0, hh - status_h, ww, status_h);
-      bottom->box(FL_FLAT_BOX);
+      bottom->box (FL_FLAT_BOX);
 
       ndim = calc_dimensions (gh_manager::get_object (fp.get___myhandle__ ()));
 
       autoscale = new Fl_Button (0, hh - status_h, status_h, status_h, "A");
       autoscale->callback (button_callback, static_cast<void*> (this));
       autoscale->tooltip ("Autoscale");
 
       togglegrid = new Fl_Button (status_h, hh - status_h, status_h,
@@ -733,17 +733,17 @@ public:
           // FIXME: This code should be removed when Octave drops support
           // for FLTK 1.1.  Search for default_xclass in this file to find
           // code that should be uncommented to take its place.
           //
           // Set WM_CLASS which allows window managers to properly group
           // related windows.  Otherwise, the class is just "FLTK"
           xclass ("Octave");
           show ();
-          if (fp.get_currentaxes ().ok())
+          if (fp.get_currentaxes ().ok ())
             show_canvas ();
           else
             hide_canvas ();
         }
     }
     end ();
 
     status->show ();
@@ -875,17 +875,17 @@ public:
             break;
           }
 
         if (uimenu->items_to_show ())
           show_menubar ();
         else
           hide_menubar ();
 
-        mark_modified();
+        mark_modified ();
       }
   }
 
   void show_canvas (void)
   {
     if (fp.is_visible ())
       {
         canvas->show ();
@@ -1919,18 +1919,18 @@ public:
               }
           }
       }
     else if (go.isa ("uimenu"))
       {
         if (id == uimenu::properties::ID_LABEL)
           uimenu_set_fltk_label (go);
 
-        graphics_object fig = go.get_ancestor("figure");
-        figure_manager::uimenu_update(fig.get_handle (), go.get_handle (), id);
+        graphics_object fig = go.get_ancestor ("figure");
+        figure_manager::uimenu_update (fig.get_handle (), go.get_handle (), id);
       }
   }
 
   void redraw_figure (const graphics_object& go) const
   {
     figure_manager::mark_modified (go.get_handle ());
 
     __fltk_redraw__ ();
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/DLD-FUNCTIONS/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/DLD-FUNCTIONS/__lin_interpn__.cc
@@ -190,17 +190,17 @@ lin_interpn (int n, M *X, const M V, M *
   M Vi = M (Y[0].dims ());
 
   OCTAVE_LOCAL_BUFFER (const T *, y, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, size, n);
 
   for (int i = 0; i < n; i++)
     {
       y[i] = Y[i].data ();
-      size[i] =  V.dims()(i);
+      size[i] =  V.dims ()(i);
     }
 
   OCTAVE_LOCAL_BUFFER (const T *, x, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, scale, n);
 
   const T *v = V.data ();
   T *vi = Vi.fortran_vec ();
   octave_idx_type Ni = Vi.numel ();
@@ -281,17 +281,17 @@ Undocumented internal function.\n\
     {
       print_usage ();
       return retval;
     }
 
   // dimension of the problem
   int n = (nargin-1)/2;
 
-  if (args(n).is_single_type())
+  if (args(n).is_single_type ())
     {
       OCTAVE_LOCAL_BUFFER (FloatNDArray, X, n);
       OCTAVE_LOCAL_BUFFER (FloatNDArray, Y, n);
 
       const FloatNDArray V = args(n).float_array_value ();
 
       if (error_state)
         {
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -398,19 +398,19 @@ maybe_initialize_magick (void)
 
       initialized = true;
     }
 #endif
 }
 
 DEFUN_DLD (__magick_read__, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Function File} {@var{m} =} __magick_read__(@var{fname}, @var{index})\n\
-@deftypefnx {Function File} {[@var{m}, @var{colormap}] =} __magick_read__(@var{fname}, @var{index})\n\
-@deftypefnx {Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__(@var{fname}, @var{index})\n\
+@deftypefn  {Function File} {@var{m} =} __magick_read__ (@var{fname}, @var{index})\n\
+@deftypefnx {Function File} {[@var{m}, @var{colormap}] =} __magick_read__ (@var{fname}, @var{index})\n\
+@deftypefnx {Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{index})\n\
 Read images with ImageMagick++.  In general you should not be using this\n\
 function.  Instead use @code{imread}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list output;
 
 #ifdef HAVE_MAGICK
@@ -423,24 +423,24 @@ function.  Instead use @code{imread}.\n\
       print_usage ();
       return output;
     }
 
   Array<int> frameidx;
   bool all_frames = false;
 
   if (args.length () == 2 && args(1).is_real_type ())
-    frameidx = args(1).int_vector_value();
+    frameidx = args(1).int_vector_value ();
   else if (args.length () == 3 && args(1).is_string ()
-           && args(1).string_value() == "frames")
+           && args(1).string_value () == "frames")
     {
-      if (args(2).is_string () && args(2).string_value() == "all")
+      if (args(2).is_string () && args(2).string_value () == "all")
         all_frames = true;
       else if (args(2).is_real_type ())
-        frameidx = args(2).int_vector_value();
+        frameidx = args(2).int_vector_value ();
     }
   else
     {
       frameidx = Array<int> (dim_vector (1, 1));
       frameidx(0) = 1;
     }
 
   std::vector<Magick::Image> imvec;
@@ -599,17 +599,17 @@ encode_bool_image (std::vector<Magick::I
 
   Array<octave_idx_type> idx (dim_vector (dsizes.length (), 1));
 
   octave_idx_type rows = m.rows ();
   octave_idx_type columns = m.columns ();
 
   for (unsigned int ii = 0; ii < nframes; ii++)
     {
-      Magick::Image im(Magick::Geometry (columns, rows), "black");
+      Magick::Image im (Magick::Geometry (columns, rows), "black");
       im.classType (Magick::DirectClass);
       im.depth (1);
 
       for (int y = 0; y < columns; y++)
         {
           idx(1) = y;
 
           for (int x = 0; x < rows; x++)
@@ -866,18 +866,18 @@ write_image (const std::string& filename
       error ("Magick++ exception: %s", e.what ());
     }
 }
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img})\n\
-@deftypefnx {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
+@deftypefn  {Function File} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img})\n\
+@deftypefnx {Function File} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
 Write images with ImageMagick++.  In general you should not be using this\n\
 function.  Instead use @code{imwrite}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_MAGICK
@@ -896,17 +896,17 @@ function.  Instead use @code{imwrite}.\n
           if (! error_state)
             {
               if (nargin > 4)
                 write_image (filename, fmt, args(2), args(3), args(4));
               else if (nargin > 3)
                 if (args(3).is_real_type ())
                   write_image (filename, fmt, args(2), args(3));
                 else
-                  write_image (filename, fmt, args(2), octave_value(), args(3));
+                  write_image (filename, fmt, args(2), octave_value (), args(3));
               else
                 write_image (filename, fmt, args(2));
             }
           else
             error ("__magick_write__: FMT must be string");
         }
       else
         error ("__magick_write__: FNAME must be a string");
@@ -1002,17 +1002,17 @@ magick_to_octave_value (const Magick::Im
   catch (Magick::Warning& w) \
     { \
     }
 
 #endif
 
 DEFUN_DLD (__magick_finfo__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __magick_finfo__(@var{fname})\n\
+@deftypefn {Loadable Function} {} __magick_finfo__ (@var{fname})\n\
 Read image information with GraphicsMagick++.  In general you should\n\
 not be using this function.  Instead use @code{imfinfo}.\n\
 @seealso{imfinfo, imread}\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_MAGICK
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
@@ -54,17 +54,17 @@ DEFUN_DLD (__pchip_deriv__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   const int nargin = args.length ();
 
-  bool rows = (nargin == 3 && args (2).uint_value() == 2);
+  bool rows = (nargin == 3 && args (2).uint_value () == 2);
 
   if (nargin >= 2)
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           FloatColumnVector xvec (args(0).float_vector_value ());
           FloatMatrix ymat (args(1).float_matrix_value ());
 
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -185,17 +185,17 @@ The author of the code itself is Timothy
                   {
                     if (nargout > 1)
                       retval(1) = xinfo;
 
                     Matrix Pout (1, n_col);
                     for (octave_idx_type i = 0; i < n_col; i++)
                       Pout.xelem (i) = P[i] + 1;
 
-                    retval (0) = Pout;
+                    retval(0) = Pout;
                   }
                 }
             }
         }
     }
 #else
 
   error ("amd: not available in this version of Octave");
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -99,24 +99,24 @@ Generalized eigenvalue problem balancing
     }
 
   // determine if it's AEP or GEP
   bool AEPcase = nargin == 1 || args(1).is_string ();
 
   // problem dimension
   octave_idx_type nn = args(0).rows ();
 
-  if (nn != args(0).columns())
+  if (nn != args(0).columns ())
     {
       gripe_square_matrix_required ("balance");
       return retval;
     }
 
   bool isfloat = args(0).is_single_type () ||
-    (! AEPcase && args(1).is_single_type());
+    (! AEPcase && args(1).is_single_type ());
 
   bool complex_case = (args(0).is_complex_type () ||
                        (! AEPcase && args(1).is_complex_type ()));
 
   // Extract argument 1 parameter for both AEP and GEP.
   Matrix aa;
   ComplexMatrix caa;
   FloatMatrix faa;
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -383,31 +383,31 @@ DEFUN_DLD (besselj, args, nargout,
 @deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
 @item besselj\n\
 Bessel functions of the first kind.  If the argument @var{opt} is supplied,\n\
-the result is multiplied by @code{exp(-abs(imag(@var{x})))}.\n\
+the result is multiplied by @code{exp (-abs (imag (@var{x})))}.\n\
 \n\
 @item bessely\n\
 Bessel functions of the second kind.  If the argument @var{opt} is supplied,\n\
-the result is multiplied by @code{exp(-abs(imag(@var{x})))}.\n\
+the result is multiplied by @code{exp (-abs (imag (@var{x})))}.\n\
 \n\
 @item besseli\n\
 \n\
 Modified Bessel functions of the first kind.  If the argument @var{opt} is\n\
-supplied, the result is multiplied by @code{exp(-abs(real(@var{x})))}.\n\
+supplied, the result is multiplied by @code{exp (-abs (real (@var{x})))}.\n\
 \n\
 @item besselk\n\
 \n\
 Modified Bessel functions of the second kind.  If the argument @var{opt} is\n\
-supplied, the result is multiplied by @code{exp(@var{x})}.\n\
+supplied, the result is multiplied by @code{exp (@var{x})}.\n\
 \n\
 @item besselh\n\
 Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}\n\
 = 2) kind.  If the argument @var{opt} is supplied, the result is multiplied\n\
 by @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for\n\
 @var{k} = 2.\n\
 @end table\n\
 \n\
@@ -528,18 +528,18 @@ Compute Airy functions of the first and 
 derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if 'opt' is supplied)\n\
 ---  --------   ---------------------------------------\n\
  0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
  1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))\n\
- 2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
- 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
+ 2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))\n\
+ 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))\n\
 @end group\n\
 @end example\n\
 \n\
 The function call @code{airy (@var{z})} is equivalent to\n\
 @code{airy (0, @var{z})}.\n\
 \n\
 The result is the same size as @var{z}.\n\
 \n\
@@ -1068,18 +1068,18 @@ Table 9.8 - I and K for integer orders 0
 %!         [ 0.2700464416   0.2065846495   0.2042345837   0.7595486903   0.9001744239   0.759126289  ];
 %!         [ 0.1835408126   0.1639722669   0.7002245988   0.5478075643   0.6002738588   0.132723593  ];
 %!         [ 0.1483158301   0.1380412115   0.111504840    0.4505236991   0.4796689336   0.57843541   ];
 %!         [ 0.1278333372   0.1212626814   0.103580801    0.3916319344   0.4107665704   0.47378525   ];
 %!         [ 0.1038995314   0.1003741751   0.090516308    0.3210023535   0.3315348950   0.36520701   ];
 %!         [ 0.0897803119   0.0875062222   0.081029690    0.2785448768   0.2854254970   0.30708743   ]];
 %!
 %! tbl = [besseli(n,z1,1), besselk(n,z1,1)];
-%! tbl(:,3) = tbl(:,3) .* (exp(z1).*z1.^(-2));
-%! tbl(:,6) = tbl(:,6) .* (exp(-z1).*z1.^(2));
+%! tbl(:,3) = tbl(:,3) .* (exp (z1) .* z1.^(-2));
+%! tbl(:,6) = tbl(:,6) .* (exp (-z1) .* z1.^(2));
 %! tbl = [tbl;[besseli(n,z2,1),besselk(n,z2,1)]];
 %!
 %! assert (tbl, rtbl, -2e-8);
 
 Table 9.9 - I and K for orders 3-9.
 
 %!test
 %! It = [[  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00];
@@ -1106,17 +1106,17 @@ Table 9.9 - I and K for orders 3-9.
 %!      [  3.7411e-01  4.5162e-01  5.7483e-01  7.7097e-01  1.0888e+00  1.6178e+00  2.5269e+00];
 %!      [  3.4684e-01  4.1114e-01  5.1130e-01  6.6679e-01  9.1137e-01  1.3048e+00  1.9552e+00]];
 %!
 %! n = (3:9);
 %! z = (0:2:20).';
 %! I = besseli (n,z,1);
 %! K = besselk (n,z,1);
 %!
-%! assert (abs (I(1,:)), zeros (1, columns(I)));
+%! assert (abs (I(1,:)), zeros (1, columns (I)));
 %! assert (I(2:end,:), It(2:end,:), -5e-5);
 %! assert (Kt(1,:), K(1,:));
 %! assert (K(2:end,:), Kt(2:end,:), -5e-5);
 
 Table 9.11 - I and K for various integer orders and arguments.
 
 %!test
 %! It = [[   1.266065878e+00    2.279585302e+00    2.723987182e+01    2.815716628e+03     2.93255378e+20     1.07375171e+42 ];
@@ -1149,17 +1149,17 @@ Table 9.11 - I and K for various integer
 The next section checks that negative integer orders and positive
 integer orders are appropriately related.
 
 %!test
 %! n = (0:2:20);
 %! assert (besselj (n,1), besselj (-n,1), 1e-8);
 %! assert (-besselj (n+1,1), besselj (-n-1,1), 1e-8);
 
-besseli(n,z) = besseli(-n,z);
+besseli (n,z) = besseli (-n,z);
 
 %!test
 %! n = (0:2:20);
 %! assert (besseli (n,1), besseli (-n,1), 1e-8);
 
 Table 10.1 - j and y for integer orders 0, 1, 2.
 Compare against excerpts of Table 10.1, Abramowitz and Stegun.
 
@@ -1174,32 +1174,32 @@ Compare against excerpts of Table 10.1, 
 %!       [   -5.4402e-02      7.8467e-02     7.7942e-02 ]];
 %!
 %! yt = [[-9.9500417e+00  -1.0049875e+02 -3.0050125e+03 ];
 %!       [ 3.2045745e-01  -1.1120588e-01 -4.5390450e-01 ];
 %!       [-5.6732437e-02   1.8043837e-01  1.6499546e-01 ];
 %!       [   -4.6218e-02     -1.3123e-01    -6.2736e-03 ];
 %!       [    8.3907e-02      6.2793e-02    -6.5069e-02 ]];
 %!
-%! j = sqrt((pi/2)./z).*besselj(n+1/2,z);
-%! y = sqrt((pi/2)./z).*bessely(n+1/2,z);
-%! assert(jt, j, -5e-5);
-%! assert(yt, y, -5e-5);
+%! j = sqrt ((pi/2)./z) .* besselj (n+1/2,z);
+%! y = sqrt ((pi/2)./z) .* bessely (n+1/2,z);
+%! assert (jt, j, -5e-5);
+%! assert (yt, y, -5e-5);
 
 Table 10.2 - j and y for orders 3-8.
 Compare against excerpts of Table 10.2, Abramowitzh and Stegun.
 
  Important note: In A&S, y_4(0.1) = -1.0507e+7, but Octave returns
- y_4(0.1) = -1.0508e+07 (-10507503.75). If I compute the same term using
+ y_4(0.1) = -1.0508e+07 (-10507503.75).  If I compute the same term using
  a series, the difference is in the eighth significant digit so I left
  the Octave results in place.
 
 %!test
 %! n = (3:8);
-%! z = (0:2.5:10).';  z(1)=0.1;
+%! z = (0:2.5:10).';  z(1) = 0.1;
 %!
 %! jt = [[ 9.5185e-06  1.0577e-07  9.6163e-10  7.3975e-12  4.9319e-14  2.9012e-16];
 %!       [ 1.0392e-01  3.0911e-02  7.3576e-03  1.4630e-03  2.5009e-04  3.7516e-05];
 %!       [ 2.2982e-01  1.8702e-01  1.0681e-01  4.7967e-02  1.7903e-02  5.7414e-03];
 %!       [-6.1713e-02  7.9285e-02  1.5685e-01  1.5077e-01  1.0448e-01  5.8188e-02];
 %!       [-3.9496e-02 -1.0559e-01 -5.5535e-02  4.4501e-02  1.1339e-01  1.2558e-01]];
 %!
 %! yt = [[-1.5015e+05 -1.0508e+07 -9.4553e+08 -1.0400e+11 -1.3519e+13 -2.0277e+15];
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -27,16 +27,19 @@ along with Octave; see the file COPYING.
 #include "lo-specfun.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
+// FIXME: These functions do not need to be dynamically loaded.  They should
+//        be placed elsewhere in the Octave code hierarchy.
+
 DEFUN_DLD (betainc, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} betainc (@var{x}, @var{a}, @var{b})\n\
 Return the regularized incomplete Beta function,\n\
 @tex\n\
 $$\n\
  I (x, a, b) = {1 \\over {B (a, b)}} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
@@ -54,16 +57,17 @@ betainc (x, a, b) = -----------   | t^(a
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
 If @var{x} has more than one component, both @var{a} and @var{b} must be\n\
 scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of\n\
 compatible dimensions.\n\
+@seealso{betaincinv, beta, betaln}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
@@ -89,88 +93,88 @@ compatible dimensions.\n\
                         {
                           float b = b_arg.float_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                       else
                         {
-                          FloatNDArray b = b_arg.float_array_value ();
+                          Array<float> b = b_arg.float_array_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                     }
                 }
               else
                 {
-                  FloatNDArray a = a_arg.float_array_value ();
+                  Array<float> a = a_arg.float_array_value ();
 
                   if (! error_state)
                     {
                       if (b_arg.is_scalar_type ())
                         {
                           float b = b_arg.float_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                       else
                         {
-                          FloatNDArray b = b_arg.float_array_value ();
+                          Array<float> b = b_arg.float_array_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                     }
                 }
             }
           else
             {
-              FloatNDArray x = x_arg.float_array_value ();
+              Array<float> x = x_arg.float_array_value ();
 
               if (a_arg.is_scalar_type ())
                 {
                   float a = a_arg.float_value ();
 
                   if (! error_state)
                     {
                       if (b_arg.is_scalar_type ())
                         {
                           float b = b_arg.float_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                       else
                         {
-                          FloatNDArray b = b_arg.float_array_value ();
+                          Array<float> b = b_arg.float_array_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                     }
                 }
               else
                 {
-                  FloatNDArray a = a_arg.float_array_value ();
+                  Array<float> a = a_arg.float_array_value ();
 
                   if (! error_state)
                     {
                       if (b_arg.is_scalar_type ())
                         {
                           float b = b_arg.float_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                       else
                         {
-                          FloatNDArray b = b_arg.float_array_value ();
+                          Array<float> b = b_arg.float_array_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                     }
                 }
             }
         }
@@ -190,141 +194,298 @@ compatible dimensions.\n\
                         {
                           double b = b_arg.double_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                       else
                         {
-                          NDArray b = b_arg.array_value ();
+                          Array<double> b = b_arg.array_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                     }
                 }
               else
                 {
-                  NDArray a = a_arg.array_value ();
+                  Array<double> a = a_arg.array_value ();
 
                   if (! error_state)
                     {
                       if (b_arg.is_scalar_type ())
                         {
                           double b = b_arg.double_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                       else
                         {
-                          NDArray b = b_arg.array_value ();
+                          Array<double> b = b_arg.array_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                     }
                 }
             }
           else
             {
-              NDArray x = x_arg.array_value ();
+              Array<double> x = x_arg.array_value ();
 
               if (a_arg.is_scalar_type ())
                 {
                   double a = a_arg.double_value ();
 
                   if (! error_state)
                     {
                       if (b_arg.is_scalar_type ())
                         {
                           double b = b_arg.double_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                       else
                         {
-                          NDArray b = b_arg.array_value ();
+                          Array<double> b = b_arg.array_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                     }
                 }
               else
                 {
-                  NDArray a = a_arg.array_value ();
+                  Array<double> a = a_arg.array_value ();
 
                   if (! error_state)
                     {
                       if (b_arg.is_scalar_type ())
                         {
                           double b = b_arg.double_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                       else
                         {
-                          NDArray b = b_arg.array_value ();
+                          Array<double> b = b_arg.array_value ();
 
                           if (! error_state)
                             retval = betainc (x, a, b);
                         }
                     }
                 }
             }
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%% test/octave.test/arith/betainc-1.m
+## Double precision
 %!test
 %! a = [1, 1.5, 2, 3];
 %! b = [4, 3, 2, 1];
 %! v1 = betainc (1,a,b);
 %! v2 = [1,1,1,1];
 %! x = [.2, .4, .6, .8];
 %! v3 = betainc (x, a, b);
 %! v4 = 1 - betainc (1.-x, b, a);
 %! assert (v1, v2, sqrt (eps));
 %! assert (v3, v4, sqrt (eps));
 
-%% Single precision
+## Single precision
 %!test
 %! a = single ([1, 1.5, 2, 3]);
 %! b = single ([4, 3, 2, 1]);
 %! v1 = betainc (1,a,b);
 %! v2 = single ([1,1,1,1]);
 %! x = single ([.2, .4, .6, .8]);
 %! v3 = betainc (x, a, b);
 %! v4 = 1 - betainc (1.-x, b, a);
 %! assert (v1, v2, sqrt (eps ("single")));
 %! assert (v3, v4, sqrt (eps ("single")));
 
-%% Mixed double/single precision
+## Mixed double/single precision
 %!test
 %! a = single ([1, 1.5, 2, 3]);
 %! b = [4, 3, 2, 1];
 %! v1 = betainc (1,a,b);
 %! v2 = single ([1,1,1,1]);
 %! x = [.2, .4, .6, .8];
 %! v3 = betainc (x, a, b);
 %! v4 = 1-betainc (1.-x, b, a);
-%! assert (v1, v2, sqrt (eps ('single')));
-%! assert (v3, v4, sqrt (eps ('single')));
+%! assert (v1, v2, sqrt (eps ("single")));
+%! assert (v3, v4, sqrt (eps ("single")));
+
+%!error betainc ()
+%!error betainc (1)
+%!error betainc (1,2)
+%!error betainc (1,2,3,4)
+*/
+
+DEFUN_DLD (betaincinv, args, ,
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} betaincinv (@var{y}, @var{a}, @var{b})\n\
+Compute the inverse of the incomplete Beta function, i.e., @var{x} such that\n\
+\n\
+@example\n\
+@var{y} == betainc (@var{x}, @var{a}, @var{b}) \n\
+@end example\n\
+@seealso{betainc, beta, betaln}\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 3)
+    {
+      octave_value x_arg = args(0);
+      octave_value a_arg = args(1);
+      octave_value b_arg = args(2);
+
+      if (x_arg.is_scalar_type ())
+        {
+          double x = x_arg.double_value ();
+
+          if (a_arg.is_scalar_type ())
+            {
+              double a = a_arg.double_value ();
 
-%% test/octave.test/arith/betainc-2.m
-%!error betainc ()
+              if (! error_state)
+                {
+                  if (b_arg.is_scalar_type ())
+                    {
+                      double b = b_arg.double_value ();
+
+                      if (! error_state)
+                        retval = betaincinv (x, a, b);
+                    }
+                  else
+                    {
+                      Array<double> b = b_arg.array_value ();
+
+                      if (! error_state)
+                        retval = betaincinv (x, a, b);
+                    }
+                }
+            }
+          else
+            {
+              Array<double> a = a_arg.array_value ();
+
+              if (! error_state)
+                {
+                  if (b_arg.is_scalar_type ())
+                    {
+                      double b = b_arg.double_value ();
+
+                      if (! error_state)
+                        retval = betaincinv (x, a, b);
+                    }
+                  else
+                    {
+                      Array<double> b = b_arg.array_value ();
+
+                      if (! error_state)
+                        retval = betaincinv (x, a, b);
+                    }
+                }
+            }
+        }
+      else
+        {
+          Array<double> x = x_arg.array_value ();
 
-%% test/octave.test/arith/betainc-3.m
-%!error betainc> betainc (1)
+          if (a_arg.is_scalar_type ())
+            {
+              double a = a_arg.double_value ();
+
+              if (! error_state)
+                {
+                  if (b_arg.is_scalar_type ())
+                    {
+                      double b = b_arg.double_value ();
+
+                      if (! error_state)
+                        retval = betaincinv (x, a, b);
+                    }
+                  else
+                    {
+                      Array<double> b = b_arg.array_value ();
+
+                      if (! error_state)
+                        retval = betaincinv (x, a, b);
+                    }
+                }
+            }
+          else
+            {
+              Array<double> a = a_arg.array_value ();
+
+              if (! error_state)
+                {
+                  if (b_arg.is_scalar_type ())
+                    {
+                      double b = b_arg.double_value ();
+
+                      if (! error_state)
+                        retval = betaincinv (x, a, b);
+                    }
+                  else
+                    {
+                      Array<double> b = b_arg.array_value ();
 
-%% test/octave.test/arith/betainc-4.m
-%!error betainc> betainc (1,2)
+                      if (! error_state)
+                        retval = betaincinv (x, a, b);
+                    }
+                }
+            }
+        }
+
+      // FIXME: It would be better to have an algorithm for betaincinv which
+      // accepted float inputs and returned float outputs.  As it is, we do
+      // extra work to calculate betaincinv to double precision and then throw
+      // that precision away.
+      if (x_arg.is_single_type () || a_arg.is_single_type () ||
+          b_arg.is_single_type ())
+        {
+          retval = Array<float> (retval.array_value ());
+        }
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+%!assert (betaincinv ([0.875 0.6875], [1 2], 3), [0.5 0.5], sqrt (eps))
+%!assert (betaincinv (0.5, 3, 3), 0.5, sqrt (eps))
+%!assert (betaincinv (0.34375, 4, 3), 0.5, sqrt (eps))
+%!assert (betaincinv (0.2265625, 5, 3), 0.5, sqrt (eps))
+%!assert (betaincinv (0.14453125, 6, 3), 0.5, sqrt (eps))
+%!assert (betaincinv (0.08984375, 7, 3), 0.5, sqrt (eps))
+%!assert (betaincinv (0.0546875, 8, 3), 0.5, sqrt (eps))
+%!assert (betaincinv (0.03271484375, 9, 3), 0.5, sqrt (eps))
+%!assert (betaincinv (0.019287109375, 10, 3), 0.5, sqrt (eps))
+
+## Test class single as well
+%!assert (betaincinv ([0.875 0.6875], [1 2], single (3)), [0.5 0.5], sqrt (eps ("single")))
+%!assert (betaincinv (0.5, 3, single (3)), 0.5, sqrt (eps ("single")))
+%!assert (betaincinv (0.34375, 4, single (3)), 0.5, sqrt (eps ("single")))
+
+## Extreme values
+%!assert (betaincinv (0, 42, 42), 0, sqrt (eps))
+%!assert (betaincinv (1, 42, 42), 1, sqrt (eps))
+
+%!error betaincinv ()
+%!error betaincinv (1, 2)
 */
+
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -228,19 +228,19 @@ maybe_update_column (octave_value& Ac, c
   octave_idx_type nd = dva.length ();
 
   if (i == 0)
     {
       idx(0) = octave_value (':');
       for (octave_idx_type j = 1; j < nd; j++)
         {
           if (dva (j) == 1)
-            idx (j) = octave_value (1);
+            idx(j) = octave_value (1);
           else
-            idx (j) = octave_value ((i % dvc(j)) + 1);
+            idx(j) = octave_value ((i % dvc(j)) + 1);
 
           i = i / dvc (j);
         }
 
       Ac = A;
       Ac = Ac.single_subsref ("(", idx);
       return true;
     }
@@ -437,17 +437,17 @@ dimensionality as the other array.\n\
                   BSXDEF(uint64NDArray);
 
                   octave_value Ac ;
                   octave_value_list idxA;
                   octave_value Bc;
                   octave_value_list idxB;
                   octave_value C;
                   octave_value_list inputs;
-                  Array<int> ra_idx (dim_vector (dvc.length(), 1), 0);
+                  Array<int> ra_idx (dim_vector (dvc.length (), 1), 0);
 
 
                   for (octave_idx_type i = 0; i < ncount; i++)
                     {
                       if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
                         inputs (0) = Ac;
 
                       if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
@@ -544,60 +544,60 @@ dimensionality as the other array.\n\
                               else if (tmp(0).is_double_type ())
                                 {
                                   if (tmp(0).is_complex_type () &&
                                       have_FloatNDArray)
                                     {
                                       result_ComplexNDArray =
                                         ComplexNDArray (result_FloatNDArray);
                                       result_ComplexNDArray.insert
-                                        (tmp(0).complex_array_value(), ra_idx);
+                                        (tmp(0).complex_array_value (), ra_idx);
                                       have_FloatComplexNDArray = false;
                                       have_ComplexNDArray = true;
                                     }
                                   else
                                     {
                                       result_NDArray =
                                         NDArray (result_FloatNDArray);
                                       result_NDArray.insert
-                                        (tmp(0).array_value(), ra_idx);
+                                        (tmp(0).array_value (), ra_idx);
                                       have_FloatNDArray = false;
                                       have_NDArray = true;
                                     }
                                 }
                               else if (tmp(0).is_real_type ())
                                 result_FloatNDArray.insert
-                                  (tmp(0).float_array_value(), ra_idx);
+                                  (tmp(0).float_array_value (), ra_idx);
                               else
                                 {
                                   result_FloatComplexNDArray =
                                     FloatComplexNDArray (result_FloatNDArray);
                                   result_FloatComplexNDArray.insert
-                                    (tmp(0).float_complex_array_value(), ra_idx);
+                                    (tmp(0).float_complex_array_value (), ra_idx);
                                   have_FloatNDArray = false;
                                   have_FloatComplexNDArray = true;
                                 }
                             }
                           else if (have_NDArray)
                             {
                               if (! tmp(0).is_float_type ())
                                 {
                                   have_NDArray = false;
                                   C = result_NDArray;
                                   C = do_cat_op (C, tmp(0), ra_idx);
                                 }
                               else if (tmp(0).is_real_type ())
-                                result_NDArray.insert (tmp(0).array_value(),
+                                result_NDArray.insert (tmp(0).array_value (),
                                                        ra_idx);
                               else
                                 {
                                   result_ComplexNDArray =
                                     ComplexNDArray (result_NDArray);
                                   result_ComplexNDArray.insert
-                                    (tmp(0).complex_array_value(), ra_idx);
+                                    (tmp(0).complex_array_value (), ra_idx);
                                   have_NDArray = false;
                                   have_ComplexNDArray = true;
                                 }
                             }
 
 #define BSXLOOP(T, CLS, EXTRACTOR) \
                         (have_ ## T) \
                           { \
@@ -625,17 +625,17 @@ dimensionality as the other array.\n\
                           else if BSXLOOP(uint64NDArray, "uint64", uint64)
                           else
                             C = do_cat_op (C, tmp(0), ra_idx);
                         }
                     }
 
 #define BSXEND(T) \
                   (have_ ## T) \
-                    retval (0) = result_ ## T;
+                    retval(0) = result_ ## T;
 
                   if BSXEND(NDArray)
                   else if BSXEND(ComplexNDArray)
                   else if BSXEND(FloatNDArray)
                   else if BSXEND(FloatComplexNDArray)
                   else if BSXEND(boolNDArray)
                   else if BSXEND(int8NDArray)
                   else if BSXEND(int16NDArray)
@@ -780,18 +780,18 @@ dimensionality as the other array.\n\
 %! float_types = {@single, @double};
 %! int_types = {@int8, @int16, @int32, @int64, \
 %!              @uint8, @uint16, @uint32, @uint64};
 %!
 %! x = rand (3) * 10-5;
 %! y = rand (3,1) * 10-5;
 %!
 %! for i=1:length (funs)
-%!   for j = 1:length(float_types)
-%!     for k = 1:length(int_types)
+%!   for j = 1:length (float_types)
+%!     for k = 1:length (int_types)
 %!
 %!       fun = funs{i};
 %!       f_type = float_types{j};
 %!       i_type = int_types{k};
 %!
 %!         assert (bsxfun (fun, f_type (x), i_type (y)), \
 %!                 fun (f_type(x), i_type (y)));
 %!         assert (bsxfun (fun, f_type (y), i_type (x)), \
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -98,17 +98,17 @@ if nonzero, statistics and knobs are pri
 @end table\n\
 \n\
 @var{cmember} is an optional vector of length @math{n}.  It defines the\n\
 constraints on the column ordering.  If @code{@var{cmember}(j) = @var{c}},\n\
 then column @var{j} is in constraint set @var{c} (@var{c} must be in the\n\
 range 1 to\n\
 n).  In the output permutation @var{p}, all columns in set 1 appear\n\
 first, followed by all columns in set 2, and so on.  @code{@var{cmember} =\n\
-ones(1,n)} if not present or empty.\n\
+ones (1,n)} if not present or empty.\n\
 @code{ccolamd (@var{S}, [], 1 : n)} returns @code{1 : n}\n\
 \n\
 @code{@var{p} = ccolamd (@var{S})} is about the same as\n\
 @code{@var{p} = colamd (@var{S})}.  @var{knobs} and its default values\n\
 differ.  @code{colamd} always does aggressive absorption, and it finds an\n\
 ordering suitable for both @code{lu (@var{S}(:, @var{p}))} and @code{chol\n\
 (@var{S}(:, @var{p})' * @var{S}(:, @var{p}))}; it cannot optimize its\n\
 ordering for @code{lu (@var{S}(:, @var{p}))} to the extent that\n\
@@ -176,33 +176,33 @@ colamd, symamd, and other related orderi
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE
                             << ":\nknobs(1): " << User_knobs (0) << ", order for ";
               if ( knobs [CCOLAMD_LU] != 0)
-                octave_stdout << "lu(A)\n";
+                octave_stdout << "lu (A)\n";
               else
-                octave_stdout << "chol(A'*A)\n";
+                octave_stdout << "chol (A'*A)\n";
 
               if (knobs [CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
-                              << ", rows with > max(16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << ", rows with > max (16,"
+                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", no dense rows removed\n";
 
               if (knobs [CCOLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(3): " << User_knobs (2)
-                              << ", cols with > max(16,"
-                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt(size(A)))"
+                              << ", cols with > max (16,"
+                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(3): " << User_knobs (2)
                               << ", no dense columns removed\n";
 
               if (knobs [CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: yes";
@@ -265,18 +265,18 @@ colamd, symamd, and other related orderi
       OCTAVE_LOCAL_BUFFER (octave_idx_type, A, Alen);
       for (octave_idx_type i = 0; i < nnz; i++)
         A[i] = ridx [i];
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
-          NDArray in_cmember = args(2).array_value();
-          octave_idx_type cslen = in_cmember.length();
+          NDArray in_cmember = args(2).array_value ();
+          octave_idx_type cslen = in_cmember.length ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
           if (cslen != n_col)
             error ("ccolamd: CMEMBER must be of length equal to #cols of A");
           else
@@ -297,19 +297,19 @@ colamd, symamd, and other related orderi
               error ("ccolamd: internal error!");
               return retval;
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p [i] + 1;
+        out_perm(i) = p[i] + 1;
 
-      retval (0) = out_perm;
+      retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         CCOLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
@@ -367,21 +367,21 @@ If nonzero, aggressive absorption is per
 If nonzero, statistics and knobs are printed.\n\
 \n\
 @end table\n\
 \n\
 @var{cmember} is an optional vector of length n. It defines the constraints\n\
 on the ordering.  If @code{@var{cmember}(j) = @var{S}}, then row/column j is\n\
 in constraint set @var{c} (@var{c} must be in the range 1 to n).  In the\n\
 output permutation @var{p}, rows/columns in set 1 appear first, followed\n\
-by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones(1,n)}\n\
-if not present or empty.  @code{csymamd(@var{S},[],1:n)} returns @code{1:n}.\n\
+by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones (1,n)}\n\
+if not present or empty.  @code{csymamd (@var{S},[],1:n)} returns @code{1:n}.\n\
 \n\
-@code{@var{p} = csymamd(@var{S})} is about the same as @code{@var{p} =\n\
-symamd(@var{S})}.  @var{knobs} and its default values differ.\n\
+@code{@var{p} = csymamd (@var{S})} is about the same as @code{@var{p} =\n\
+symamd (@var{S})}.  @var{knobs} and its default values differ.\n\
 \n\
 @code{@var{stats}(4:7)} provide information if CCOLAMD was able to\n\
 continue.  The matrix is OK if @code{@var{stats}(4)} is zero, or 1 if\n\
 invalid.  @code{@var{stats}(5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats}(6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats}(5)}, or zero if no\n\
 such row index exists.  @code{@var{stats}(7)} is the number of duplicate\n\
@@ -428,18 +428,18 @@ colamd, symamd, and other related orderi
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
 
               if (knobs [CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
-                              << ", rows/cols with > max(16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << ", rows/cols with > max (16,"
+                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", no dense rows/cols removed\n";
 
               if (knobs [CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: yes";
@@ -497,18 +497,18 @@ colamd, symamd, and other related orderi
         }
 
       // Allocate workspace for symamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
         {
-          NDArray in_cmember = args(2).array_value();
-          octave_idx_type cslen = in_cmember.length();
+          NDArray in_cmember = args(2).array_value ();
+          octave_idx_type cslen = in_cmember.length ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
           if (cslen != n_col)
             error ("csymamd: CMEMBER must be of length equal to #cols of A");
           else
@@ -529,19 +529,19 @@ colamd, symamd, and other related orderi
               error ("csymamd: internal error!") ;
               return retval;
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm [i] + 1;
+        out_perm(i) = perm[i] + 1;
 
-      retval (0) = out_perm;
+      retval(0) = out_perm;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
             out_stats (i) = stats [i] ;
           retval(1) = out_stats;
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -111,88 +111,88 @@ try_cellfun_internal_ops (const octave_v
   const Cell f_args = args(1).cell_value ();
 
   octave_idx_type k = f_args.numel ();
 
   if (name == "isempty")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = f_args.elem(count).is_empty ();
+        result(count) = f_args.elem (count).is_empty ();
       retval(0) = result;
     }
   else if (name == "islogical")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
-        result(count) = f_args.elem(count).is_bool_type ();
+        result(count) = f_args.elem (count).is_bool_type ();
       retval(0) = result;
     }
   else if (name == "isreal")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
-        result(count) = f_args.elem(count).is_real_type ();
+        result(count) = f_args.elem (count).is_real_type ();
       retval(0) = result;
     }
   else if (name == "length")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
-        result(count) = static_cast<double> (f_args.elem(count).length ());
+        result(count) = static_cast<double> (f_args.elem (count).length ());
       retval(0) = result;
     }
   else if (name == "ndims")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = static_cast<double> (f_args.elem(count).ndims ());
+        result(count) = static_cast<double> (f_args.elem (count).ndims ());
       retval(0) = result;
     }
   else if (name == "prodofsize" || name == "numel")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = static_cast<double> (f_args.elem(count).numel ());
+        result(count) = static_cast<double> (f_args.elem (count).numel ());
       retval(0) = result;
     }
   else if (name == "size")
     {
       if (nargin == 3)
         {
           int d = args(2).nint_value () - 1;
 
           if (d < 0)
             error ("cellfun: K must be a positive integer");
 
           if (! error_state)
             {
               NDArray result (f_args.dims ());
               for (octave_idx_type count = 0; count < k; count++)
                 {
-                  dim_vector dv = f_args.elem(count).dims ();
+                  dim_vector dv = f_args.elem (count).dims ();
                   if (d < dv.length ())
                     result(count) = static_cast<double> (dv(d));
                   else
                     result(count) = 1.0;
                 }
               retval(0) = result;
             }
         }
       else
         error ("cellfun: not enough arguments for \"size\"");
     }
   else if (name == "isclass")
     {
       if (nargin == 3)
         {
-          std::string class_name = args(2).string_value();
+          std::string class_name = args(2).string_value ();
           boolNDArray result (f_args.dims ());
           for (octave_idx_type count = 0; count < k; count++)
-            result(count) = (f_args.elem(count).class_name() == class_name);
+            result(count) = (f_args.elem (count).class_name () == class_name);
 
           retval(0) = result;
         }
       else
         error ("cellfun: not enough arguments for \"isclass\"");
     }
 
   return retval;
@@ -204,17 +204,17 @@ get_mapper_fun_options (const octave_val
 {
   while (nargin > 3 && args(nargin-2).is_string ())
     {
       caseless_str arg = args(nargin-2).string_value ();
 
       size_t compare_len = std::max (arg.length (), static_cast<size_t> (2));
 
       if (arg.compare ("uniformoutput", compare_len))
-        uniform_output = args(nargin-1).bool_value();
+        uniform_output = args(nargin-1).bool_value ();
       else if (arg.compare ("errorhandler", compare_len))
         {
           if (args(nargin-1).is_function_handle ()
               || args(nargin-1).is_inline_function ())
             {
               error_handler = args(nargin-1);
             }
           else if (args(nargin-1).is_string ())
@@ -234,17 +234,17 @@ get_mapper_fun_options (const octave_val
             {
               error ("cellfun: invalid value for 'ErrorHandler' function");
               break;
             }
         }
       else
         {
           error ("cellfun: unrecognized parameter %s",
-                 arg.c_str());
+                 arg.c_str ());
           break;
         }
 
       nargin -= 2;
     }
 
   nargin -= 1;
 }
@@ -312,17 +312,17 @@ arguments of the function.  The outputs 
 into the output arguments of @code{cellfun} like this:\n\
 \n\
 @example\n\
 @group\n\
 function [a, b] = twoouts (x)\n\
   a = x;\n\
   b = x*x;\n\
 endfunction\n\
-[aa, bb] = cellfun(@@twoouts, @{1, 2, 3@})\n\
+[aa, bb] = cellfun (@@twoouts, @{1, 2, 3@})\n\
      @result{}\n\
         aa =\n\
            1 2 3\n\
         bb =\n\
            1 4 9\n\
 @end group\n\
 @end example\n\
 \n\
@@ -370,17 +370,17 @@ useful tool for avoiding loops.  It is o
 function handles; however, calling an anonymous function involves an\n\
 overhead quite comparable to the overhead of an m-file function.\n\
 Passing a handle to a built-in function is faster, because the\n\
 interpreter is not involved in the internal loop.  For example:\n\
 \n\
 @example\n\
 @group\n\
 a = @{@dots{}@}\n\
-v = cellfun (@@(x) det(x), a); # compute determinants\n\
+v = cellfun (@@(x) det (x), a); # compute determinants\n\
 v = cellfun (@@det, a); # faster\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{arrayfun, structfun, spfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -762,17 +762,17 @@ v = cellfun (@@det, a); # faster\n\
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (inline ("islogical (x)", "x"), {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (@islogical, {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
-%! A = cellfun (@(x) islogical(x), {true, 0.1, false, i*2});
+%! A = cellfun (@(x) islogical (x), {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 
 %% First input argument can be the special string "isreal",
 %% "isempty", "islogical", "length", "ndims" or "prodofsize"
 %!test
 %! A = cellfun ("isreal", {true, 0.1, {}, i*2, [], "abc"});
 %! assert (A, [true, true, false, false, true, true]);
 %!test
@@ -859,26 +859,26 @@ v = cellfun (@@det, a); # faster\n\
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!              "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -887,25 +887,25 @@ v = cellfun (@@det, a); # faster\n\
 %! A = cellfun (@(x,y) x>y, {"ad", "c", "ghi"}, {"cc", "d", "fgh"});
 %!test
 %! A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Structures cannot be handled by cellfun
@@ -921,25 +921,25 @@ v = cellfun (@@det, a); # faster\n\
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, \
 %!              "UniformOutput", true);
 %! assert (A, [1; 0], 1e-16);
 %!test
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!              "UniformOutput", false);
 %! assert (A, {true, false});
 %!test
-%! A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell array of structure arrays
@@ -1484,17 +1484,17 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (inline ("(x == y)", "x", "y"), [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (@isequal, [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
-%! A = arrayfun (@(x,y) isequal(x,y), [false, true], [true, true]);
+%! A = arrayfun (@(x,y) isequal (x,y), [false, true], [true, true]);
 %! assert (A, [false, true]);
 
 %% Number of input and output arguments may be greater than one
 %#!test
 %! A = arrayfun (@(x) islogical (x), false);
 %! assert (A, true);
 %!test
 %! A = arrayfun (@(x,y,z) x + y + z, [1, 1, 1], [2, 2, 2], [3, 4, 5]);
@@ -1556,26 +1556,26 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -1585,17 +1585,17 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (A, [false, true, false, true, true, true]);
 %!test
 %! A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], \
+%! A = arrayfun (@(x,y) cell2str (x,y), ["a", "d"], ["c", "f"], \
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
 %! assert (B, true);
 
 %% Input arguments can be of type structure
 %!test
 %! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
 %! A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
@@ -1637,17 +1637,17 @@ arrayfun (@@str2num, [1234],\n\
 %!test
 %! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test
-%! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, \
+%! A = arrayfun (@(x,y) num2str (x,y), {1.1, 4.2}, {3.1, 2}, \
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 */
 
@@ -1785,17 +1785,17 @@ do_object2cell (const octave_value& obj,
           octave_value_list idx (1);
 
           for (octave_idx_type i = 0; i < dv.numel (); i++)
             {
               octave_quit ();
 
               idx(0) = double (i+1);
 
-              retval.xelem(i) = array.single_subsref ("(", idx);
+              retval.xelem (i) = array.single_subsref ("(", idx);
 
               if (error_state)
                 break;
             }
         }
     }
   else
     {
@@ -1834,17 +1834,17 @@ num2cell ([1,2;3,4],1)\n\
            4\n\
       @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{mat2cell}\n\
 @end deftypefn")
 {
-  int nargin =  args.length();
+  int nargin =  args.length ();
   octave_value retval;
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
       octave_value array = args(0);
       Array<int> dimv;
@@ -2172,17 +2172,17 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
      15\n\
 \n\
    [2,2] = 16\n\
 @}\n\
 @end example\n\
 @seealso{num2cell, cell2mat}\n\
 @end deftypefn")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value retval;
 
   if (nargin < 2)
     print_usage ();
   else
     {
       // Prepare indices.
       OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, d, nargin-1);
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -199,26 +199,26 @@ sparse matrices.\n\
                 {
                   octave_idx_type info;
                   SparseCHOL fact (m, info, natural);
                   if (nargout == 3)
                     {
                       if (vecout)
                         retval(2) = fact.perm ();
                       else
-                        retval(2) = fact.Q();
+                        retval(2) = fact.Q ();
                     }
 
                   if (nargout > 1 || info == 0)
                     {
-                      retval(1) = fact.P();
+                      retval(1) = fact.P ();
                       if (LLt)
-                        retval(0) = fact.L();
+                        retval(0) = fact.L ();
                       else
-                        retval(0) = fact.R();
+                        retval(0) = fact.R ();
                     }
                   else
                     error ("chol: input matrix must be positive definite");
                 }
             }
           else if (arg.is_complex_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
@@ -228,26 +228,26 @@ sparse matrices.\n\
                   octave_idx_type info;
                   SparseComplexCHOL fact (m, info, natural);
 
                   if (nargout == 3)
                     {
                       if (vecout)
                         retval(2) = fact.perm ();
                       else
-                        retval(2) = fact.Q();
+                        retval(2) = fact.Q ();
                     }
 
                   if (nargout > 1 || info == 0)
                     {
-                      retval(1) = fact.P();
+                      retval(1) = fact.P ();
                       if (LLt)
-                        retval(0) = fact.L();
+                        retval(0) = fact.L ();
                       else
-                        retval(0) = fact.R();
+                        retval(0) = fact.R ();
                     }
                   else
                     error ("chol: input matrix must be positive definite");
                 }
             }
           else
             gripe_wrong_type_arg ("chol", arg);
         }
@@ -367,21 +367,21 @@ sparse matrices.\n\
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps))
-%!assert (chol (single([2, 1; 1, 1])), single([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
+%!assert (chol (single ([2, 1; 1, 1])), single ([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
 
+%!error chol ()
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
-%!error chol ()
 %!error <unexpected second or third input> chol (1, 2)
 */
 
 DEFUN_DLD (cholinv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cholinv (@var{A})\n\
 Use the Cholesky@tie{}factorization to compute the inverse of the\n\
 symmetric positive definite matrix @var{A}.\n\
@@ -984,17 +984,17 @@ If @var{info} is not present, an error m
 
 %!test
 %! u2 = single ([  0.35080 ;
 %!                 0.63930 ;
 %!                 3.31057 ;
 %!                -0.13825 ;
 %!                 0.45266 ]);
 %!
-%! R = chol(single(A));
+%! R = chol (single (A));
 %!
 %! j = 3;  p = [1:j-1, j+1:5];
 %! R1 = cholinsert (R, j, u2);
 %! A1 = R1'*R1;
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (A1(p,p) - A, Inf) < 1e1*eps ("single"));
 
@@ -1178,17 +1178,17 @@ triangular, return the Cholesky@tie{}fac
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! R = chol(A);
+%! R = chol (A);
 %!
 %! j = 3;  p = [1:j-1,j+1:4];
 %! R1 = choldelete (R, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
 %! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 
 %!test
@@ -1205,20 +1205,20 @@ triangular, return the Cholesky@tie{}fac
 %!
 %! j = 3;  p = [1:j-1,j+1:4];
 %! R1 = choldelete (R, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1'*R1 - single (A(p,p)), Inf) < 1e1*eps ("single"));
 
 %!test
-%! R = chol(single(Ac));
+%! R = chol (single (Ac));
 %!
 %! j = 3;  p = [1:j-1,j+1:4];
-%! R1 = choldelete(R,j);
+%! R1 = choldelete (R,j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 */
 
 DEFUN_DLD (cholshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
@@ -1330,18 +1330,18 @@ triangular, return the Cholesky@tie{}fac
 %! R1 = cholshift (R, i, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
 %! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 %!
 %! j = 1;  i = 3;  p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift (R, i, j);
 %!
-%! assert (norm(triu(R1)-R1, Inf), 0);
-%! assert (norm(R1'*R1 - A(p,p), Inf) < 1e1*eps);
+%! assert (norm (triu (R1) - R1, Inf), 0);
+%! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 
 %!test
 %! R = chol (Ac);
 %!
 %! i = 1;  j = 3;  p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift (R, i, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -221,17 +221,17 @@ degree permutation vector for the sparse
 non-symmetric matrix @var{S}, @code{@var{S}(:,@var{p})} tends to have\n\
 sparser LU@tie{}factors than @var{S}.  The Cholesky@tie{}factorization of\n\
 @code{@var{S}(:,@var{p})' * @var{S}(:,@var{p})} also tends to be sparser\n\
 than that of @code{@var{S}' * @var{S}}.\n\
 \n\
 @var{knobs} is an optional one- to three-element input vector.  If @var{S} is\n\
 m-by-n, then rows with more than @code{max(16,@var{knobs}(1)*sqrt(n))}\n\
 entries are ignored.  Columns with more than\n\
-@code{max(16,@var{knobs}(2)*sqrt(min(m,n)))} entries are removed prior to\n\
+@code{max (16,@var{knobs}(2)*sqrt(min(m,n)))} entries are removed prior to\n\
 ordering, and ordered last in the output permutation @var{p}.  Only\n\
 completely dense rows or columns are removed if @code{@var{knobs}(1)} and\n\
 @code{@var{knobs}(2)} are < 0, respectively.  If @code{@var{knobs}(3)} is\n\
 nonzero, @var{stats} and @var{knobs} are printed.  The default is\n\
 @code{@var{knobs} = [10 10 0]}.  Note that @var{knobs} differs from earlier\n\
 versions of colamd.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
@@ -309,27 +309,27 @@ Ng, Oak Ridge National Laboratory.  (see
           if (spumoni)
             {
 
               octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
                             <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
 
               if (knobs [COLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
-                              << ", rows with > max(16,"
-                              << knobs [COLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << ", rows with > max (16,"
+                              << knobs [COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", only completely dense rows removed\n";
 
               if (knobs [COLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
-                              << ", cols with > max(16,"
-                              << knobs [COLAMD_DENSE_COL] << "*sqrt(size(A)))"
+                              << ", cols with > max (16,"
+                              << knobs [COLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", only completely dense columns removed\n";
 
               octave_stdout << "knobs(3): " << User_knobs (2)
                             << ", statistics and knobs printed\n";
 
@@ -410,17 +410,17 @@ Ng, Oak Ridge National Laboratory.  (see
       coletree (ridx, colbeg, colend, etree, n_row, n_col);
 
       // Calculate the tree post-ordering
       tree_postorder (n_col, etree, colbeg);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p [colbeg [i]] + 1;
+        out_perm(i) = p[colbeg [i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         COLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
@@ -459,17 +459,17 @@ For a symmetric positive definite matrix
 vector p such that @code{@var{S}(@var{p}, @var{p})} tends to have a\n\
 sparser Cholesky@tie{}factor than @var{S}.  Sometimes @code{symamd} works\n\
 well for symmetric indefinite matrices too.  The matrix @var{S} is assumed\n\
 to be symmetric; only the strictly lower triangular part is referenced.\n\
 @var{S} must be square.\n\
 \n\
 @var{knobs} is an optional one- to two-element input vector.  If @var{S} is\n\
 n-by-n, then rows and columns with more than\n\
-@code{max(16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
+@code{max (16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
 and ordered last in the output permutation @var{p}.  No rows/columns are\n\
 removed if @code{@var{knobs}(1) < 0}.  If @code{@var{knobs} (2)} is nonzero,\n\
 @code{stats} and @var{knobs} are printed.  The default is @code{@var{knobs}\n\
 = [10 0]}.  Note that @var{knobs} differs from earlier versions of symamd.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
 about the ordering and the validity of the input matrix @var{S}.  Ordering\n\
 statistics are in @code{@var{stats}(1:3)}.  @code{@var{stats}(1) =\n\
@@ -603,17 +603,17 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Calculate the tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
       tree_postorder (n_col, etree, post);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm [post [i]] + 1;
+        out_perm(i) = perm[post [i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         SYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -292,19 +292,19 @@ parameters for @code{daspk}.\n\
       daspk_fcn = 0;
       daspk_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
         {
           Cell c = f_arg.cell_value ();
-          if (c.length() == 1)
+          if (c.length () == 1)
             f_arg = c(0);
-          else if (c.length() == 2)
+          else if (c.length () == 2)
             {
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 daspk_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__daspk_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
@@ -316,35 +316,35 @@ parameters for @code{daspk}.\n\
               if (daspk_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     daspk_jac = c(1).function_value ();
                   else
                     {
                       jac_name = unique_symbol_name ("__daspk_jac__");
                       jname = "function jac = ";
-                      jname.append(jac_name);
+                      jname.append (jac_name);
                       jname.append (" (x, xdot, t, cj) jac = ");
                       daspk_jac = extract_function
                         (c(1), "daspk", jac_name, jname, "; endfunction");
 
                       if (!daspk_jac)
                         {
-                          if (fcn_name.length())
+                          if (fcn_name.length ())
                             clear_function (fcn_name);
                           daspk_fcn = 0;
                         }
                     }
                 }
             }
           else
             DASPK_ABORT1 ("incorrect number of elements in cell array");
         }
 
-      if (!daspk_fcn && ! f_arg.is_cell())
+      if (!daspk_fcn && ! f_arg.is_cell ())
         {
           if (f_arg.is_function_handle () || f_arg.is_inline_function ())
             daspk_fcn = f_arg.function_value ();
           else
             {
               switch (f_arg.rows ())
                 {
                 case 1:
@@ -372,25 +372,25 @@ parameters for @code{daspk}.\n\
                         fname.append (" (x, xdot, t) y = ");
                         daspk_fcn = extract_function
                           (tmp(0), "daspk", fcn_name, fname, "; endfunction");
 
                         if (daspk_fcn)
                           {
                             jac_name = unique_symbol_name ("__daspk_jac__");
                             jname = "function jac = ";
-                            jname.append(jac_name);
+                            jname.append (jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
                             daspk_jac = extract_function
                               (tmp(1), "daspk", jac_name, jname,
                                "; endfunction");
 
                             if (!daspk_jac)
                               {
-                                if (fcn_name.length())
+                                if (fcn_name.length ())
                                   clear_function (fcn_name);
                                 daspk_fcn = 0;
                               }
                           }
                       }
                   }
                 }
             }
@@ -441,19 +441,19 @@ parameters for @code{daspk}.\n\
       Matrix output;
       Matrix deriv_output;
 
       if (crit_times_set)
         output = dae.integrate (out_times, deriv_output, crit_times);
       else
         output = dae.integrate (out_times, deriv_output);
 
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
-      if (jac_name.length())
+      if (jac_name.length ())
         clear_function (jac_name);
 
       if (! error_state)
         {
           std::string msg = dae.error_message ();
 
           retval(3) = msg;
           retval(2) = static_cast<double> (dae.integration_state ());
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -380,19 +380,19 @@ parameters for @code{dasrt}.\n\
 
   // Here's where I take care of f and j in one shot:
 
   octave_value f_arg = args(0);
 
   if (f_arg.is_cell ())
     {
       Cell c = f_arg.cell_value ();
-      if (c.length() == 1)
+      if (c.length () == 1)
         f_arg = c(0);
-      else if (c.length() == 2)
+      else if (c.length () == 2)
         {
           if (c(0).is_function_handle () || c(0).is_inline_function ())
             dasrt_f = c(0).function_value ();
           else
             {
               fcn_name = unique_symbol_name ("__dasrt_fcn__");
               fname = "function y = ";
               fname.append (fcn_name);
@@ -404,35 +404,35 @@ parameters for @code{dasrt}.\n\
           if (dasrt_f)
             {
               if (c(1).is_function_handle () || c(1).is_inline_function ())
                 dasrt_j = c(1).function_value ();
               else
                 {
                   jac_name = unique_symbol_name ("__dasrt_jac__");
                   jname = "function jac = ";
-                  jname.append(jac_name);
+                  jname.append (jac_name);
                   jname.append (" (x, xdot, t, cj) jac = ");
                   dasrt_j = extract_function
                     (c(1), "dasrt", jac_name, jname, "; endfunction");
 
                   if (!dasrt_j)
                     {
-                      if (fcn_name.length())
+                      if (fcn_name.length ())
                         clear_function (fcn_name);
                       dasrt_f = 0;
                     }
                 }
             }
         }
       else
         DASRT_ABORT1 ("incorrect number of elements in cell array");
     }
 
-  if (!dasrt_f && ! f_arg.is_cell())
+  if (!dasrt_f && ! f_arg.is_cell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         dasrt_f = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
@@ -456,17 +456,17 @@ parameters for @code{dasrt}.\n\
                     fname.append (" (x, xdot, t) y = ");
                     dasrt_f = extract_function
                       (tmp(0), "dasrt", fcn_name, fname, "; endfunction");
 
                     if (dasrt_f)
                       {
                         jac_name = unique_symbol_name ("__dasrt_jac__");
                         jname = "function jac = ";
-                        jname.append(jac_name);
+                        jname.append (jac_name);
                         jname.append (" (x, xdot, t, cj) jac = ");
                         dasrt_j = extract_function
                           (tmp(1), "dasrt", jac_name, jname, "; endfunction");
 
                         if (! dasrt_j)
                           dasrt_f = 0;
                       }
                   }
@@ -482,19 +482,19 @@ parameters for @code{dasrt}.\n\
 
   if (error_state || (! dasrt_f))
     DASRT_ABORT;
 
   DAERTFunc func (dasrt_user_f);
 
   argp++;
 
-  if (args(1).is_function_handle() || args(1).is_inline_function())
+  if (args(1).is_function_handle () || args(1).is_inline_function ())
     {
-      dasrt_cf = args(1).function_value();
+      dasrt_cf = args(1).function_value ();
 
       if (! dasrt_cf)
         DASRT_ABORT1 ("expecting function name as argument 2");
 
       argp++;
 
       func.set_constraint_function (dasrt_user_cf);
     }
@@ -552,19 +552,19 @@ parameters for @code{dasrt}.\n\
 
   dae.set_options (dasrt_opts);
 
   if (crit_times_set)
     output = dae.integrate (out_times, crit_times);
   else
     output = dae.integrate (out_times);
 
-  if (fcn_name.length())
+  if (fcn_name.length ())
     clear_function (fcn_name);
-  if (jac_name.length())
+  if (jac_name.length ())
     clear_function (jac_name);
 
   if (! error_state)
     {
       std::string msg = dae.error_message ();
 
       retval(4) = msg;
       retval(3) = static_cast<double> (dae.integration_state ());
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -293,19 +293,19 @@ parameters for @code{dassl}.\n\
       dassl_fcn = 0;
       dassl_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
         {
           Cell c = f_arg.cell_value ();
-          if (c.length() == 1)
+          if (c.length () == 1)
             f_arg = c(0);
-          else if (c.length() == 2)
+          else if (c.length () == 2)
             {
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 dassl_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__dassl_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
@@ -317,35 +317,35 @@ parameters for @code{dassl}.\n\
               if (dassl_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     dassl_jac = c(1).function_value ();
                   else
                     {
                         jac_name = unique_symbol_name ("__dassl_jac__");
                         jname = "function jac = ";
-                        jname.append(jac_name);
+                        jname.append (jac_name);
                         jname.append (" (x, xdot, t, cj) jac = ");
                         dassl_jac = extract_function
                           (c(1), "dassl", jac_name, jname, "; endfunction");
 
                         if (!dassl_jac)
                           {
-                            if (fcn_name.length())
+                            if (fcn_name.length ())
                               clear_function (fcn_name);
                             dassl_fcn = 0;
                           }
                     }
                 }
             }
           else
             DASSL_ABORT1 ("incorrect number of elements in cell array");
         }
 
-      if (!dassl_fcn && ! f_arg.is_cell())
+      if (!dassl_fcn && ! f_arg.is_cell ())
         {
           if (f_arg.is_function_handle () || f_arg.is_inline_function ())
             dassl_fcn = f_arg.function_value ();
           else
             {
               switch (f_arg.rows ())
                 {
                 case 1:
@@ -373,25 +373,25 @@ parameters for @code{dassl}.\n\
                         fname.append (" (x, xdot, t) y = ");
                         dassl_fcn = extract_function
                           (tmp(0), "dassl", fcn_name, fname, "; endfunction");
 
                         if (dassl_fcn)
                           {
                             jac_name = unique_symbol_name ("__dassl_jac__");
                             jname = "function jac = ";
-                            jname.append(jac_name);
+                            jname.append (jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
                             dassl_jac = extract_function
                               (tmp(1), "dassl", jac_name, jname,
                                "; endfunction");
 
                             if (!dassl_jac)
                               {
-                                if (fcn_name.length())
+                                if (fcn_name.length ())
                                   clear_function (fcn_name);
                                 dassl_fcn = 0;
                               }
                           }
                       }
                   }
                 }
             }
@@ -443,19 +443,19 @@ parameters for @code{dassl}.\n\
       Matrix output;
       Matrix deriv_output;
 
       if (crit_times_set)
         output = dae.integrate (out_times, deriv_output, crit_times);
       else
         output = dae.integrate (out_times, deriv_output);
 
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
-      if (jac_name.length())
+      if (jac_name.length ())
         clear_function (jac_name);
 
       if (! error_state)
         {
           std::string msg = dae.error_message ();
 
           retval(3) = msg;
           retval(2) = static_cast<double> (dae.integration_state ());
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #define CXSPARSE_NAME(name) cs_di ## name
 #endif
 
 static RowVector
 put_int (octave_idx_type *p, octave_idx_type n)
 {
   RowVector ret (n);
   for (octave_idx_type i = 0; i < n; i++)
-    ret.xelem(i) = p[i] + 1;
+    ret.xelem (i) = p[i] + 1;
   return ret;
 }
 
 #if HAVE_CXSPARSE
 static octave_value_list
 dmperm_internal (bool rank, const octave_value arg, int nargout)
 {
   octave_value_list retval;
@@ -65,24 +65,24 @@ dmperm_internal (bool rank, const octave
   csm.m = nr;
   csm.n = nc;
   csm.x = 0;
   csm.nz = -1;
 
   if (arg.is_real_type ())
     {
       m = arg.sparse_matrix_value ();
-      csm.nzmax = m.nnz();
+      csm.nzmax = m.nnz ();
       csm.p = m.xcidx ();
       csm.i = m.xridx ();
     }
   else
     {
       cm = arg.sparse_complex_matrix_value ();
-      csm.nzmax = cm.nnz();
+      csm.nzmax = cm.nnz ();
       csm.p = cm.xcidx ();
       csm.i = cm.xridx ();
     }
 
   if (!error_state)
     {
       if (nargout <= 1 || rank)
         {
@@ -148,17 +148,17 @@ triangular form.  The values of @var{r} 
 of the blocks.  If @var{S} is square then @code{@var{r} == @var{S}}.\n\
 \n\
 The method used is described in: A. Pothen & C.-J. Fan. @cite{Computing the\n\
 Block Triangular Form of a Sparse Matrix}. ACM Trans. Math. Software,\n\
 16(4):303-324, 1990.\n\
 @seealso{colamd, ccolamd}\n\
 @end deftypefn")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
@@ -196,17 +196,17 @@ Calculate the structural rank of the spa
 only the structure of the matrix is used in this calculation based on\n\
 a Dulmage-Mendelsohn permutation to block triangular form.  As such the\n\
 numerical rank of the matrix @var{S} is bounded by\n\
 @code{sprank (@var{S}) >= rank (@var{S})}.  Ignoring floating point errors\n\
 @code{sprank (@var{S}) == rank (@var{S})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
-  int nargin = args.length();
+  int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -88,17 +88,17 @@ The eigenvalues returned by @code{eig} a
       nc_b = arg_b.columns ();
 
       arg_is_empty = empty_arg ("eig", nr_b, nc_b);
       if (arg_is_empty < 0)
         return retval;
       else if (arg_is_empty > 0)
         return octave_value_list (2, Matrix ());
 
-      if (!(arg_b.is_single_type() || arg_b.is_double_type ()))
+      if (!(arg_b.is_single_type () || arg_b.is_double_type ()))
         {
           gripe_wrong_type_arg ("eig", arg_b);
           return retval;
         }
     }
 
   if (nr_a != nc_a)
     {
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -341,17 +341,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     {
       error ("eigs: invalid recursive call");
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
       return retval;
     }
 
   if (nargin == 0)
     print_usage ();
   else if (args(0).is_function_handle () || args(0).is_inline_function ()
            || args(0).is_string ())
@@ -388,35 +388,35 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
         }
     }
   else
     {
       if (args(0).is_complex_type ())
         {
           if (args(0).is_sparse_type ())
             {
-              ascm = (args(0).sparse_complex_matrix_value());
+              ascm = (args(0).sparse_complex_matrix_value ());
               a_is_sparse = true;
             }
           else
-            acm = (args(0).complex_matrix_value());
+            acm = (args(0).complex_matrix_value ());
           a_is_complex = true;
           symmetric = false; // ARPACK doesn't special case complex symmetric
           sym_tested = true;
         }
       else
         {
           if (args(0).is_sparse_type ())
             {
-              asmm = (args(0).sparse_matrix_value());
+              asmm = (args(0).sparse_matrix_value ());
               a_is_sparse = true;
             }
           else
             {
-              amm = (args(0).matrix_value());
+              amm = (args(0).matrix_value ());
             }
         }
 
     }
 
   // Note hold off reading B till later to avoid issues of double
   // copies of the matrix if B is full/real while A is complex.
   if (!error_state && nargin > 1 + arg_offset &&
@@ -542,19 +542,19 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
       error ("eigs: incorrect number of arguments");
       return retval;
     }
 
   // Test undeclared (no issym) matrix inputs for symmetry
   if (!sym_tested && !have_a_fun)
     {
       if (a_is_sparse)
-        symmetric = asmm.is_symmetric();
+        symmetric = asmm.is_symmetric ();
       else
-        symmetric = amm.is_symmetric();
+        symmetric = amm.is_symmetric ();
     }
 
   if (have_b)
     {
       if (a_is_complex || b_is_complex)
         {
           if (a_is_sparse)
             bscm = args(b_arg).sparse_complex_matrix_value ();
@@ -608,17 +608,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
                    octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
               else
                 nconv = EigsComplexNonSymmetricMatrix
                   (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB, cresid,
                    octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
             }
 
           if (nargout < 2)
-            retval (0) = eig_val;
+            retval(0) = eig_val;
           else
             {
               retval(2) = double (info);
               retval(1) = ComplexDiagMatrix (eig_val);
               retval(0) = eig_vec;
             }
         }
       else if (sigmai != 0.)
@@ -641,17 +641,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
               else
                 nconv = EigsComplexNonSymmetricMatrixShift
                   (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
                    eig_val, ComplexMatrix (bmm), permB, cresid,
                    octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
             }
 
           if (nargout < 2)
-            retval (0) = eig_val;
+            retval(0) = eig_val;
           else
             {
               retval(2) = double (info);
               retval(1) = ComplexDiagMatrix (eig_val);
               retval(0) = eig_vec;
             }
         }
       else
@@ -689,17 +689,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
                   else
                     nconv = EigsRealSymmetricMatrix
                       (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                 }
 
               if (nargout < 2)
-                retval (0) = eig_val;
+                retval(0) = eig_val;
               else
                 {
                   retval(2) = double (info);
                   retval(1) = DiagMatrix (eig_val);
                   retval(0) = eig_vec;
                 }
             }
           else
@@ -735,17 +735,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
                   else
                     nconv = EigsRealNonSymmetricMatrix
                       (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                 }
 
               if (nargout < 2)
-                retval (0) = eig_val;
+                retval(0) = eig_val;
               else
                 {
                   retval(2) = double (info);
                   retval(1) = ComplexDiagMatrix (eig_val);
                   retval(0) = eig_vec;
                 }
             }
         }
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -275,17 +275,17 @@ dimension of the matrix along which the 
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! N = 64;
 %! n = 7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos (n*t);
 %!
-%! S = zeros (size(t));
+%! S = zeros (size (t));
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
 %!
 %! assert (ifft (S), s, 4*N*eps);
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -110,17 +110,17 @@ Note that calculated wisdom will be lost
 the wisdom data can be reloaded if it is saved to a file as described\n\
 above.  Saved wisdom files should not be used on different platforms since\n\
 they will not be efficient and the point of calculating the wisdom is lost.\n\
 @seealso{fft, ifft, fft2, ifft2, fftn, ifftn}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length();
+  int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
 #if defined (HAVE_FFTW)
@@ -191,33 +191,33 @@ they will not be efficient and the point
                           else
                             retval = octave_value ("estimate");
                         }
                     }
                   else if (arg0 == "dwisdom")
                     {
                       char *str = fftw_export_wisdom_to_string ();
 
-                      if (arg1.length() < 1)
+                      if (arg1.length () < 1)
                         fftw_forget_wisdom ();
-                      else if (! fftw_import_wisdom_from_string (arg1.c_str()))
+                      else if (! fftw_import_wisdom_from_string (arg1.c_str ()))
                         error ("could not import supplied WISDOM");
 
                       if (!error_state)
                         retval = octave_value (std::string (str));
 
                       free (str);
                     }
                   else if (arg0 == "swisdom")
                     {
                       char *str = fftwf_export_wisdom_to_string ();
 
-                      if (arg1.length() < 1)
+                      if (arg1.length () < 1)
                         fftwf_forget_wisdom ();
-                      else if (! fftwf_import_wisdom_from_string (arg1.c_str()))
+                      else if (! fftwf_import_wisdom_from_string (arg1.c_str ()))
                         error ("could not import supplied WISDOM");
 
                       if (!error_state)
                         retval = octave_value (std::string (str));
 
                       free (str);
                     }
                   else
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -247,17 +247,17 @@ extern MArray<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&,
         MArray<FloatComplex>&, int dim);
 #endif
 
 template <class T>
 MArray<T>
 filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, int dim = -1)
 {
-  dim_vector x_dims = x.dims();
+  dim_vector x_dims = x.dims ();
 
   if (dim < 0)
     {
       // Find first non-singleton dimension
       while (dim < x_dims.length () && x_dims(dim) <= 1)
         dim++;
 
       // All dimensions singleton, pick first dimension
@@ -310,23 +310,25 @@ k=0                 k=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
 @ifnottex\n\
- N=length(a)-1 and M=length(b)-1.\n\
+N=length(a)-1 and M=length(b)-1.\n\
 @end ifnottex\n\
 @tex\n\
- $a \\in \\Re^{N-1}$, $b \\in \\Re^{M-1}$, and $x \\in \\Re^P$.\n\
+$a \\in \\Re^{N-1}$, $b \\in \\Re^{M-1}$, and $x \\in \\Re^P$.\n\
 @end tex\n\
-over the first non-singleton dimension of @var{x} or over @var{dim} if\n\
-supplied.  An equivalent form of this equation is:\n\
+The result is calculated over the first non-singleton dimension of @var{x}\n\
+or over @var{dim} if supplied.\n\
+\n\
+An equivalent form of the equation is:\n\
 @tex\n\
 $$\n\
 y_n = -\\sum_{k=1}^N c_{k+1} y_{n-k} + \\sum_{k=0}^M d_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 @c Set example in small font to prevent overfull line\n\
@@ -396,17 +398,17 @@ H(z) = ---------------------\n\
 
   const char *errmsg = "filter: arguments a and b must be vectors";
 
   int dim;
   dim_vector x_dims = args(2).dims ();
 
   if (nargin == 5)
     {
-      dim = args(4).nint_value() - 1;
+      dim = args(4).nint_value () - 1;
       if (dim < 0 || dim >= x_dims.length ())
         {
           error ("filter: DIM must be a valid dimension");
           return retval;
         }
     }
   else
     {
@@ -709,19 +711,19 @@ filter (MArray<FloatComplex>&, MArray<Fl
 %!test
 %! a = [1,1];
 %! b=[1,1];
 %! x = zeros (4,4,2);  x(1,1:4,1) = +1;  x(1,1:4,2) = -1;
 %! y0 = zeros (4,4,2);  y0(1:2,1:4,1) = +1;  y0(1:2,1:4,2) = -1;
 %! y = filter (b, [1], x);
 %! assert (y, y0);
 
-%!assert (filter (1, ones(10,1)/10, []), [])
-%!assert (filter (1, ones(10,1)/10, zeros(0,10)), zeros(0,10))
-%!assert (filter (1, ones(10,1)/10, single (1:5)), repmat (single (10), 1, 5))
+%!assert (filter (1, ones (10,1) / 10, []), [])
+%!assert (filter (1, ones (10,1) / 10, zeros (0,10)), zeros (0,10))
+%!assert (filter (1, ones (10,1) / 10, single (1:5)), repmat (single (10), 1, 5))
 
 %% Test using initial conditions
 %!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]), [2 2])
 %!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]'), [2 2])
 %!assert (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]), [5 7; 6 10; 14 18])
 %!error (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]'))
 %!assert (filter ([1, 3, 2], [1], [1 2; 3 4; 5 6], [1 0 0; 1 0 0], 2), [2 6; 3 13; 5 21])
 
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -84,19 +84,19 @@ find_nonzero_elem_idx (const Array<T>& n
 template <typename T>
 octave_value_list
 find_nonzero_elem_idx (const Sparse<T>& v, int nargout,
                        octave_idx_type n_to_find, int direction)
 {
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
 
-  octave_idx_type nc = v.cols();
-  octave_idx_type nr = v.rows();
-  octave_idx_type nz = v.nnz();
+  octave_idx_type nc = v.cols ();
+  octave_idx_type nr = v.rows ();
+  octave_idx_type nz = v.nnz ();
 
   // Search in the default range.
   octave_idx_type start_nc = -1;
   octave_idx_type end_nc = -1;
   octave_idx_type count;
 
   // Search for the range to search
   if (n_to_find < 0)
@@ -106,42 +106,42 @@ find_nonzero_elem_idx (const Sparse<T>& 
       n_to_find = nz;
       count = nz;
     }
   else if (direction > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
         {
           OCTAVE_QUIT;
-          if (v.cidx(j) == 0 && v.cidx(j+1) != 0)
+          if (v.cidx (j) == 0 && v.cidx (j+1) != 0)
             start_nc = j;
-          if (v.cidx(j+1) >= n_to_find)
+          if (v.cidx (j+1) >= n_to_find)
             {
               end_nc = j + 1;
               break;
             }
         }
     }
   else
     {
       for (octave_idx_type j = nc; j > 0; j--)
         {
           OCTAVE_QUIT;
-          if (v.cidx(j) == nz && v.cidx(j-1) != nz)
+          if (v.cidx (j) == nz && v.cidx (j-1) != nz)
             end_nc = j;
-          if (nz - v.cidx(j-1) >= n_to_find)
+          if (nz - v.cidx (j-1) >= n_to_find)
             {
               start_nc = j - 1;
               break;
             }
         }
     }
 
-  count = (n_to_find > v.cidx(end_nc) - v.cidx(start_nc) ?
-           v.cidx(end_nc) - v.cidx(start_nc) : n_to_find);
+  count = (n_to_find > v.cidx (end_nc) - v.cidx (start_nc) ?
+           v.cidx (end_nc) - v.cidx (start_nc) : n_to_find);
 
   // If the original argument was a row vector, force a row vector of
   // the overall indices to be returned.  But see below for scalar
   // case...
 
   octave_idx_type result_nr = count;
   octave_idx_type result_nc = 1;
 
@@ -163,24 +163,24 @@ find_nonzero_elem_idx (const Sparse<T>& 
   Array<T> val (dim_vector (result_nr, result_nc));
 
   if (count > 0)
     {
       // Search for elements to return.  Only search the region where
       // there are elements to be found using the count that we want
       // to find.
       for (octave_idx_type j = start_nc, cx = 0; j < end_nc; j++)
-        for (octave_idx_type i = v.cidx(j); i < v.cidx(j+1); i++ )
+        for (octave_idx_type i = v.cidx (j); i < v.cidx (j+1); i++ )
           {
             OCTAVE_QUIT;
             if (direction < 0 && i < nz - count)
               continue;
-            i_idx(cx) = static_cast<double> (v.ridx(i) + 1);
+            i_idx(cx) = static_cast<double> (v.ridx (i) + 1);
             j_idx(cx) = static_cast<double> (j + 1);
-            idx(cx) = j * nr + v.ridx(i) + 1;
+            idx(cx) = j * nr + v.ridx (i) + 1;
             val(cx) = v.data(i);
             cx++;
             if (cx == count)
               break;
           }
     }
   else if (scalar_arg)
     {
@@ -226,17 +226,17 @@ find_nonzero_elem_idx (const Sparse<T>& 
 
 octave_value_list
 find_nonzero_elem_idx (const PermMatrix& v, int nargout,
                        octave_idx_type n_to_find, int direction)
 {
   // There are far fewer special cases to handle for a PermMatrix.
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
-  octave_idx_type nc = v.cols();
+  octave_idx_type nc = v.cols ();
   octave_idx_type start_nc, count;
 
   // Determine the range to search.
   if (n_to_find < 0 || n_to_find >= nc)
     {
       start_nc = 0;
       n_to_find = nc;
       count = nc;
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -71,18 +71,18 @@ divide (const std::complex<FP>& a, const
 
   r = a - q*b;
 }
 
 template <typename FP>
 static std::complex<FP>
 simple_gcd (const std::complex<FP>& a, const std::complex<FP>& b)
 {
-  if (! xisinteger (a.real ()) || ! xisinteger(a.imag ())
-      || ! xisinteger (b.real ()) || ! xisinteger(b.imag ()))
+  if (! xisinteger (a.real ()) || ! xisinteger (a.imag ())
+      || ! xisinteger (b.real ()) || ! xisinteger (b.imag ()))
     (*current_liboctave_error_handler)
       ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a;
   std::complex<FP> bb = b;
 
   if (abs (aa) < abs (bb))
     std::swap (aa, bb);
@@ -151,18 +151,18 @@ extended_gcd (double a, double b, double
   return aa;
 }
 
 template <typename FP>
 static std::complex<FP>
 extended_gcd (const std::complex<FP>& a, const std::complex<FP>& b,
               std::complex<FP>& x, std::complex<FP>& y)
 {
-  if (! xisinteger (a.real ()) || ! xisinteger(a.imag ())
-      || ! xisinteger (b.real ()) || ! xisinteger(b.imag ()))
+  if (! xisinteger (a.real ()) || ! xisinteger (a.imag ())
+      || ! xisinteger (b.real ()) || ! xisinteger (b.imag ()))
     (*current_liboctave_error_handler)
       ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a, bb = b;
   bool swapped = false;
   if (abs (aa) < abs (bb))
     {
       std::swap (aa, bb);
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -77,23 +77,23 @@ template <class R, class T>
 static MArray<T>
 kron (const MDiagArray2<R>& a, const MArray<T>& b)
 {
   assert (b.ndims () == 2);
 
   octave_idx_type nra = a.rows (), nrb = b.rows (), dla = a.diag_length ();
   octave_idx_type nca = a.cols (), ncb = b.cols ();
 
-  MArray<T> c (dim_vector (nra*nrb, nca*ncb), T());
+  MArray<T> c (dim_vector (nra*nrb, nca*ncb), T ());
 
   for (octave_idx_type ja = 0; ja < dla; ja++)
     for (octave_idx_type jb = 0; jb < ncb; jb++)
       {
         octave_quit ();
-        mx_inline_mul (nrb, &c.xelem(ja*nrb, ja*ncb + jb), a.dgelem (ja), b.data () + nrb*jb);
+        mx_inline_mul (nrb, &c.xelem (ja*nrb, ja*ncb + jb), a.dgelem (ja), b.data () + nrb*jb);
       }
 
   return c;
 }
 
 template <class T>
 static MSparse<T>
 kron (const MSparse<T>& A, const MSparse<T>& B)
@@ -105,17 +105,17 @@ kron (const MSparse<T>& A, const MSparse
   C.cidx (0) = 0;
 
   for (octave_idx_type Aj = 0; Aj < A.columns (); Aj++)
     for (octave_idx_type Bj = 0; Bj < B.columns (); Bj++)
       {
         octave_quit ();
         for (octave_idx_type Ai = A.cidx (Aj); Ai < A.cidx (Aj+1); Ai++)
           {
-            octave_idx_type Ci = A.ridx(Ai) * B.rows ();
+            octave_idx_type Ci = A.ridx (Ai) * B.rows ();
             const T v = A.data (Ai);
 
             for (octave_idx_type Bi = B.cidx (Bj); Bi < B.cidx (Bj+1); Bi++)
               {
                 C.data (idx) = v * B.data (Bi);
                 C.ridx (idx++) = Ci + B.ridx (Bi);
               }
           }
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -65,26 +65,26 @@ struct icmp_char_gt : public std::binary
 // FIXME -- are they even needed now?
 // case-insensitive ascending comparator
 #if 0
 static bool
 stri_comp_lt (const std::string& a, const std::string& b)
 {
   return std::lexicographical_compare (a.begin (), a.end (),
                                        b.begin (), b.end (),
-                                       icmp_char_lt());
+                                       icmp_char_lt ());
 }
 
 // case-insensitive descending comparator
 static bool
 stri_comp_gt (const std::string& a, const std::string& b)
 {
   return std::lexicographical_compare (a.begin (), a.end (),
                                        b.begin (), b.end (),
-                                       icmp_char_gt());
+                                       icmp_char_gt ());
 }
 #endif
 
 template <class T>
 inline sortmode
 get_sort_mode (const Array<T>& array,
                typename octave_sort<T>::compare_fcn_type desc_comp
                = octave_sort<T>::descending_compare)
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -166,17 +166,17 @@ Solve the set of differential equations\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 dx\n\
--- = f(x, t)\n\
+-- = f (x, t)\n\
 dt\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 with\n\
 \n\
 @example\n\
@@ -293,19 +293,19 @@ parameters for @code{lsode}.\n\
       lsode_fcn = 0;
       lsode_jac = 0;
 
       octave_value f_arg = args(0);
 
       if (f_arg.is_cell ())
         {
           Cell c = f_arg.cell_value ();
-          if (c.length() == 1)
+          if (c.length () == 1)
             f_arg = c(0);
-          else if (c.length() == 2)
+          else if (c.length () == 2)
             {
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 lsode_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__lsode_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
@@ -317,35 +317,35 @@ parameters for @code{lsode}.\n\
               if (lsode_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     lsode_jac = c(1).function_value ();
                   else
                     {
                         jac_name = unique_symbol_name ("__lsode_jac__");
                         jname = "function jac = ";
-                        jname.append(jac_name);
+                        jname.append (jac_name);
                         jname.append (" (x, t) jac = ");
                         lsode_jac = extract_function
                           (c(1), "lsode", jac_name, jname, "; endfunction");
 
                       if (!lsode_jac)
                         {
-                          if (fcn_name.length())
+                          if (fcn_name.length ())
                             clear_function (fcn_name);
                           lsode_fcn = 0;
                         }
                     }
                 }
             }
           else
             LSODE_ABORT1 ("incorrect number of elements in cell array");
         }
 
-      if (!lsode_fcn && ! f_arg.is_cell())
+      if (!lsode_fcn && ! f_arg.is_cell ())
         {
           if (f_arg.is_function_handle () || f_arg.is_inline_function ())
             lsode_fcn = f_arg.function_value ();
           else
             {
               switch (f_arg.rows ())
                 {
                 case 1:
@@ -373,25 +373,25 @@ parameters for @code{lsode}.\n\
                         fname.append (" (x, t) y = ");
                         lsode_fcn = extract_function
                           (tmp(0), "lsode", fcn_name, fname, "; endfunction");
 
                         if (lsode_fcn)
                           {
                             jac_name = unique_symbol_name ("__lsode_jac__");
                             jname = "function jac = ";
-                            jname.append(jac_name);
+                            jname.append (jac_name);
                             jname.append (" (x, t) jac = ");
                             lsode_jac = extract_function
                               (tmp(1), "lsode", jac_name, jname,
                               "; endfunction");
 
                             if (!lsode_jac)
                               {
-                                if (fcn_name.length())
+                                if (fcn_name.length ())
                                   clear_function (fcn_name);
                                 lsode_fcn = 0;
                               }
                           }
                       }
                   }
                   break;
 
@@ -439,19 +439,19 @@ parameters for @code{lsode}.\n\
       ode.set_options (lsode_opts);
 
       Matrix output;
       if (crit_times_set)
         output = ode.integrate (out_times, crit_times);
       else
         output = ode.integrate (out_times);
 
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
-      if (jac_name.length())
+      if (jac_name.length ())
         clear_function (jac_name);
 
       if (! error_state)
         {
           std::string msg = ode.error_message ();
 
           retval(2) = msg;
           retval(1) = static_cast<double> (ode.integration_state ());
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -174,17 +174,17 @@ information.\n\
           Matrix tmp = args(n++).matrix_value ();
 
           if (! error_state )
             {
               if (!issparse)
                 error ("lu: can not define pivoting threshold THRES for full matrices");
               else if (tmp.nelem () == 1)
                 {
-                  thres.resize(1,2);
+                  thres.resize (1,2);
                   thres(0) = tmp(0);
                   thres(1) = tmp(0);
                 }
               else if (tmp.nelem () == 2)
                 thres = tmp;
               else
                 error ("lu: expecting 2-element vector for THRES");
             }
@@ -221,17 +221,17 @@ information.\n\
             {
             case 0:
             case 1:
             case 2:
               {
                 SparseLU fact (m, Qinit, thres, false, true);
 
                 if (nargout < 2)
-                  retval (0) = fact.Y ();
+                  retval(0) = fact.Y ();
                 else
                   {
                     PermMatrix P = fact.Pr_mat ();
                     SparseMatrix L = P.transpose () * fact.L ();
                     retval(1) = octave_value (fact.U (),
                                               MatrixType (MatrixType::Upper));
 
                     retval(0) = octave_value (L,
@@ -241,17 +241,17 @@ information.\n\
               }
               break;
 
             case 3:
               {
                 SparseLU fact (m, Qinit, thres, false, true);
 
                 if (vecout)
-                  retval (2) = fact.Pr_vec ();
+                  retval(2) = fact.Pr_vec ();
                 else
                   retval(2) = fact.Pr_mat ();
 
                 retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
                 retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
               }
@@ -291,17 +291,17 @@ information.\n\
             {
             case 0:
             case 1:
             case 2:
               {
                 SparseComplexLU fact (m, Qinit, thres, false, true);
 
                 if (nargout < 2)
-                  retval (0) = fact.Y ();
+                  retval(0) = fact.Y ();
                 else
                   {
                     PermMatrix P = fact.Pr_mat ();
                     SparseComplexMatrix L = P.transpose () * fact.L ();
                     retval(1) = octave_value (fact.U (),
                                               MatrixType (MatrixType::Upper));
 
                     retval(0) = octave_value (L,
@@ -311,17 +311,17 @@ information.\n\
               }
               break;
 
             case 3:
               {
                 SparseComplexLU fact (m, Qinit, thres, false, true);
 
                 if (vecout)
-                  retval (2) = fact.Pr_vec ();
+                  retval(2) = fact.Pr_vec ();
                 else
                   retval(2) = fact.Pr_mat ();
 
                 retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
                 retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
               }
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -149,17 +149,17 @@ Given the string argument \"vector\", @c
 
               tmp = map.getfield ("thresh");
               if (tmp.is_defined ())
                 {
                   thresh = tmp.matrix_value ();
 
                   if (thresh.nelem () == 1)
                     {
-                      thresh.resize(1,2);
+                      thresh.resize (1,2);
                       thresh(1) = thresh(0);
                     }
                   else if (thresh.nelem () != 2)
                     {
                       error ("luinc: expecting 2-element vector for thresh");
                       return retval;
                     }
                 }
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -124,17 +124,17 @@ LU@tie{}factorization.  Once the matrix 
     {
       bool autocomp = true;
       if (nargin == 2 && args(1).is_string () && args(1).string_value () == "nocompute")
         {
           nargin = 1;
           autocomp = false;
         }
 
-      if (args(0).is_scalar_type())
+      if (args(0).is_scalar_type ())
         {
           if (nargin == 1)
             retval = octave_value ("Diagonal");
           else
             retval = args(0);
         }
       else if (args(0).is_sparse_type ())
         {
@@ -193,17 +193,17 @@ LU@tie{}factorization.  Once the matrix 
               else if (typ == MatrixType::Tridiagonal)
                 retval = octave_value ("Tridiagonal");
               else if (typ == MatrixType::Tridiagonal_Hermitian)
                 retval = octave_value ("Tridiagonal Positive Definite");
               else if (typ == MatrixType::Hermitian)
                 retval = octave_value ("Positive Definite");
               else if (typ == MatrixType::Rectangular)
                 {
-                  if (args(0).rows() == args(0).columns())
+                  if (args(0).rows () == args(0).columns ())
                     retval = octave_value ("Singular");
                   else
                     retval = octave_value ("Rectangular");
                 }
               else if (typ == MatrixType::Full)
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
@@ -265,17 +265,17 @@ LU@tie{}factorization.  Once the matrix 
                     }
                   else if (str_typ == "singular")
                     mattyp.mark_as_rectangular ();
                   else if (str_typ == "full")
                     mattyp.mark_as_full ();
                   else if (str_typ == "unknown")
                     mattyp.invalidate_type ();
                   else
-                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
+                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
                   if (! error_state)
                     {
                       if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
                         {
                           const ColumnVector perm =
                             ColumnVector (args (2).vector_value ());
 
@@ -389,17 +389,17 @@ LU@tie{}factorization.  Once the matrix 
               else if (typ == MatrixType::Lower)
                 retval = octave_value ("Lower");
               else if (typ == MatrixType::Permuted_Lower)
                 retval = octave_value ("Permuted Lower");
               else if (typ == MatrixType::Hermitian)
                 retval = octave_value ("Positive Definite");
               else if (typ == MatrixType::Rectangular)
                 {
-                  if (args(0).rows() == args(0).columns())
+                  if (args(0).rows () == args(0).columns ())
                     retval = octave_value ("Singular");
                   else
                     retval = octave_value ("Rectangular");
                 }
               else if (typ == MatrixType::Full)
                 retval = octave_value ("Full");
               else
                 retval = octave_value ("Unknown");
@@ -431,17 +431,17 @@ LU@tie{}factorization.  Once the matrix 
                     }
                   else if (str_typ == "singular")
                     mattyp.mark_as_rectangular ();
                   else if (str_typ == "full")
                     mattyp.mark_as_full ();
                   else if (str_typ == "unknown")
                     mattyp.invalidate_type ();
                   else
-                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
+                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
                   if (! error_state)
                     {
                       if (nargin == 3 && (str_typ == "upper"
                                           || str_typ == "lower"))
                         {
                           const ColumnVector perm =
                             ColumnVector (args (2).vector_value ());
@@ -472,28 +472,28 @@ LU@tie{}factorization.  Once the matrix 
                       else if (nargin != 2)
                         error ("matrix_type: Invalid number of arguments");
 
                       if (! error_state)
                         {
                           // Set the matrix type
                           if (args(0).is_single_type ())
                             {
-                              if (args(0).is_complex_type())
+                              if (args(0).is_complex_type ())
                                 retval = octave_value
                                   (args(0).float_complex_matrix_value (),
                                    mattyp);
                               else
                                 retval = octave_value
                                   (args(0).float_matrix_value (),
                                    mattyp);
                             }
                           else
                             {
-                              if (args(0).is_complex_type())
+                              if (args(0).is_complex_type ())
                                 retval = octave_value
                                   (args(0).complex_matrix_value (),
                                    mattyp);
                               else
                                 retval = octave_value
                                   (args(0).matrix_value (),
                                    mattyp);
                             }
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/DLD-FUNCTIONS/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/DLD-FUNCTIONS/md5sum.cc
@@ -44,24 +44,24 @@ Calculate the MD5 sum of the file @var{f
 @var{opt} exists and is true, then calculate the MD5 sum of the\n\
 string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
-    print_usage();
+    print_usage ();
   else
     {
       bool have_str = false;
-      std::string str = args(0).string_value();
+      std::string str = args(0).string_value ();
 
       if (nargin == 2)
-        have_str = args(1).bool_value();
+        have_str = args(1).bool_value ();
 
       if (!error_state)
         {
           if (have_str)
             retval = oct_md5 (str);
           else
             {
               file_stat fs (str);
diff --git a/src/DLD-FUNCTIONS/mgorth.cc b/src/DLD-FUNCTIONS/mgorth.cc
--- a/src/DLD-FUNCTIONS/mgorth.cc
+++ b/src/DLD-FUNCTIONS/mgorth.cc
@@ -62,17 +62,17 @@ On exit, @var{y} is a unit vector such t
   @var{x} = @var{h}*[@var{v}, @var{y}]\n\
 @end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length();
+  int nargin = args.length ();
 
   if (nargin != 2 || nargout > 2)
   {
     print_usage ();
     return retval;
   }
 
   octave_value arg_x = args(0);
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -195,17 +195,17 @@ x = @var{R} \\ @var{C}\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin < 1 || nargin > (args(0).is_sparse_type() ? 3 : 2))
+  if (nargin < 1 || nargin > (args(0).is_sparse_type () ? 3 : 2))
     {
       print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("qr", arg.rows (), arg.columns ());
@@ -245,17 +245,17 @@ x = @var{R} \\ @var{C}\n\
             {
               SparseComplexQR q (arg.sparse_complex_matrix_value ());
               if (!error_state)
                 {
                   if (have_b > 0)
                     {
                       retval(1) = q.R (economy);
                       retval(0) = q.C (args(have_b).complex_matrix_value ());
-                      if (arg.rows() < arg.columns())
+                      if (arg.rows () < arg.columns ())
                         warning ("qr: non minimum norm solution for under-determined problem");
                     }
                   else if (nargout > 1)
                     {
                       retval(1) = q.R (economy);
                       retval(0) = q.Q ();
                     }
                   else
@@ -266,17 +266,17 @@ x = @var{R} \\ @var{C}\n\
             {
               SparseQR q (arg.sparse_matrix_value ());
               if (!error_state)
                 {
                   if (have_b > 0)
                     {
                       retval(1) = q.R (economy);
                       retval(0) = q.C (args(have_b).matrix_value ());
-                      if (args(0).rows() < args(0).columns())
+                      if (args(0).rows () < args(0).columns ())
                         warning ("qr: non minimum norm solution for under-determined problem");
                     }
                   else if (nargout > 1)
                     {
                       retval(1) = q.R (economy);
                       retval(0) = q.Q ();
                     }
                   else
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -145,17 +145,17 @@ quad_float_user_function (float x)
     }
 
   return retval;
 }
 
 #define QUAD_ABORT() \
   do \
     { \
-      if (fcn_name.length()) \
+      if (fcn_name.length ()) \
         clear_function (fcn_name); \
       return retval; \
     } \
   while (0)
 
 #define QUAD_ABORT1(msg) \
   do \
     { \
@@ -187,17 +187,17 @@ evaluate.  The function must have the fo
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both may be infinite.\n\
 \n\
 The optional argument @var{tol} is a vector that specifies the desired\n\
 accuracy of the result.  The first element of the vector is the desired\n\
 absolute tolerance, and the second element is the desired relative\n\
 tolerance.  To choose a relative test only, set the absolute\n\
 tolerance to zero.  To choose an absolute test only, set the relative\n\
-tolerance to zero.  Both tolerances default to @code{sqrt(eps)} or\n\
+tolerance to zero.  Both tolerances default to @code{sqrt (eps)} or\n\
 approximately @math{1.5e^{-8}}.\n\
 \n\
 The optional argument @var{sing} is a vector of values at which the\n\
 integrand is known to be singular.\n\
 \n\
 The result of the integration is returned in @var{q}.  @var{ier}\n\
 contains an integer error code (0 indicates a successful integration).\n\
 @var{nfun} indicates the number of function evaluations that were\n\
@@ -458,17 +458,17 @@ variable by routines @code{dblquad} and 
             }
 
           retval(3) = abserr;
           retval(2) = nfun;
           retval(1) = ier;
           retval(0) = val;
         }
 
-      if (fcn_name.length())
+      if (fcn_name.length ())
         clear_function (fcn_name);
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -1488,17 +1488,17 @@ values if given a vector of input values
 f = @@(x) x .* sin (1./x) .* sqrt (abs (1 - x));\n\
 @end example\n\
 \n\
 @noindent\n\
 which uses the element-by-element `dot' form for all operators.\n\
 \n\
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both limits may be infinite.  @code{quadcc} handles an inifinite limit\n\
-by substituting the variable of integration with @code{x=tan(pi/2*u)}.\n\
+by substituting the variable of integration with @code{x = tan (pi/2*u)}.\n\
 \n\
 The optional argument @var{tol} defines the relative tolerance used to stop\n\
 the integration procedure.  The default value is @math{1e^{-6}}.\n\
 \n\
 The optional argument @var{sing} contains a list of points where the\n\
 integrand has known singularities, or discontinuities\n\
 in any of its derivatives, inside the integration interval.\n\
 For the example above, which has a discontinuity at x=1, the call to\n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -1191,29 +1191,29 @@ compatibility with @sc{matlab}.\n\
             retval(2) = QQ.transpose ();
         }
 
     case 2:
       {
         if (complex_case)
           {
 #ifdef DEBUG
-            std::cout << "qz: retval (1) = cbb = " << std::endl;
+            std::cout << "qz: retval(1) = cbb = " << std::endl;
             octave_print_internal (std::cout, cbb, 0);
             std::cout << std::endl << "qz: retval(0) = caa = " <<std::endl;
             octave_print_internal (std::cout, caa, 0);
             std::cout << std::endl;
 #endif
             retval(1) = cbb;
             retval(0) = caa;
           }
       else
         {
 #ifdef DEBUG
-          std::cout << "qz: retval (1) = bb = " << std::endl;
+          std::cout << "qz: retval(1) = bb = " << std::endl;
           octave_print_internal (std::cout, bb, 0);
           std::cout << std::endl << "qz: retval(0) = aa = " <<std::endl;
           octave_print_internal (std::cout, aa, 0);
           std::cout << std::endl;
 #endif
           retval(1) = bb;
           retval(0) = aa;
         }
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -65,17 +65,17 @@ do_rand (const octave_value_list& args, 
 
   unwind_protect frame;
   // Restore current distribution on any exit.
   frame.add_fcn (octave_rand::distribution,
                  octave_rand::distribution ());
 
   octave_rand::distribution (distribution);
 
-  if (nargin > 0 && args(nargin-1).is_string())
+  if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string s_arg = args(nargin-1).string_value ();
 
       if (s_arg == "single")
         {
           is_single = true;
           nargin--;
         }
@@ -85,17 +85,17 @@ do_rand (const octave_value_list& args, 
 
   if (additional_arg)
     {
       if (nargin == 0)
         {
           error ("%s: expecting at least one argument", fcn);
           goto done;
         }
-      else if (args(0).is_string())
+      else if (args(0).is_string ())
         additional_arg = false;
       else
         {
           a = args(0).array_value ();
           if (error_state)
             {
               error ("%s: expecting scalar or matrix arguments", fcn);
               goto done;
@@ -256,25 +256,25 @@ do_rand (const octave_value_list& args, 
                 if (args(idx+1).is_real_scalar ())
                   {
                     double d = args(idx+1).double_value ();
 
                     if (! error_state)
                       octave_rand::seed (d);
                   }
                 else if (args(idx+1).is_string ()
-                         && args(idx+1).string_value() == "reset")
+                         && args(idx+1).string_value () == "reset")
                   octave_rand::reset ();
                 else
                   error ("%s: seed must be a real scalar", fcn);
               }
             else if (ts == "state" || ts == "twister")
               {
                 if (args(idx+1).is_string ()
-                    && args(idx+1).string_value() == "reset")
+                    && args(idx+1).string_value () == "reset")
                   octave_rand::reset (fcn);
                 else
                   {
                     ColumnVector s =
                       ColumnVector (args(idx+1).vector_value(false, true));
 
                     if (! error_state)
                       octave_rand::state (s, fcn);
@@ -312,21 +312,21 @@ do_rand (const octave_value_list& args, 
  gen_matrix:
 
   dims.chop_trailing_singletons ();
 
   if (is_single)
     {
       if (additional_arg)
         {
-          if (a.length() == 1)
+          if (a.length () == 1)
             return octave_rand::float_nd_array (dims, a(0));
           else
             {
-              if (a.dims() != dims)
+              if (a.dims () != dims)
                 {
                   error ("%s: mismatch in argument size", fcn);
                   return retval;
                 }
               octave_idx_type len = a.length ();
               FloatNDArray m (dims);
               float *v = m.fortran_vec ();
               for (octave_idx_type i = 0; i < len; i++)
@@ -336,21 +336,21 @@ do_rand (const octave_value_list& args, 
         }
       else
         return octave_rand::float_nd_array (dims);
     }
   else
     {
       if (additional_arg)
         {
-          if (a.length() == 1)
+          if (a.length () == 1)
             return octave_rand::nd_array (dims, a(0));
           else
             {
-              if (a.dims() != dims)
+              if (a.dims () != dims)
                 {
                   error ("%s: mismatch in argument size", fcn);
                   return retval;
                 }
               octave_idx_type len = a.length ();
               NDArray m (dims);
               double *v = m.fortran_vec ();
               for (octave_idx_type i = 0; i < len; i++)
@@ -443,17 +443,17 @@ However, it should be noted that queryin
 @code{rand} to use the old generators, only setting the seed will.\n\
 To cause @code{rand} to once again use the new generators, the\n\
 keyword \"state\" should be used to reset the state of the @code{rand}.\n\
 \n\
 The state or seed of the generator can be reset to a new random value\n\
 using the \"reset\" keyword.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 @seealso{randn, rande, randg, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   retval = do_rand (args, nargin, "rand", "uniform");
@@ -551,17 +551,17 @@ DEFUN_DLD (randn, args, ,
 Return a matrix with normally distributed random\n\
 elements having zero mean and variance one.  The arguments are\n\
 handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to a normal distribution.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 \n\
 Reference: G. Marsaglia and W.W. Tsang,\n\
 @cite{Ziggurat Method for Generating Random Variables},\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 \n\
 @seealso{rand, rande, randg, randp}\n\
 @end deftypefn")
@@ -621,17 +621,17 @@ DEFUN_DLD (rande, args, ,
 @deftypefnx {Loadable Function} {} rande (@dots{}, \"double\")\n\
 Return a matrix with exponentially distributed random elements.  The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to an exponential distribution.\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 \n\
 Reference: G. Marsaglia and W.W. Tsang,\n\
 @cite{Ziggurat Method for Generating Random Variables},\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 \n\
 @seealso{rand, randn, randg, randp}\n\
 @end deftypefn")
@@ -686,17 +686,17 @@ DEFUN_DLD (randg, args, ,
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"state\")\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"seed\")\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", \"reset\")\n\
 @deftypefnx {Loadable Function} {} randg (@dots{}, \"single\")\n\
 @deftypefnx {Loadable Function} {} randg (@dots{}, \"double\")\n\
-Return a matrix with @code{gamma(@var{a},1)} distributed random elements.\n\
+Return a matrix with @code{gamma (@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
 except for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
 \n\
 @table @asis\n\
 @item @code{gamma (a, b)} for @code{a > -1}, @code{b > 0}\n\
 \n\
@@ -767,17 +767,17 @@ r(df > 0) += 2 * randg (df(df > 0)/2)\n\
 r = (randg (a1), @dots{}, randg (ak))\n\
 r = r / sum (r)\n\
 @end group\n\
 @end example\n\
 \n\
 @end table\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 @seealso{rand, randn, rande, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
@@ -989,17 +989,17 @@ unimodal distributions}, Doctoral Disser
 University Graz, Austria, 1994.\n\
 \n\
 @item For @var{l} > 1e8, use normal approximation.\n\
 L. Montanet, et al., @cite{Review of Particle Properties}, Physical Review\n\
 D 50 p1284, 1994.\n\
 @end table\n\
 \n\
 The class of the value returned can be controlled by a trailing \"double\"\n\
-or \"single\" argument. These are the only valid classes.\n\
+or \"single\" argument.  These are the only valid classes.\n\
 @seealso{rand, randn, rande, randg}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
@@ -1100,17 +1100,17 @@ DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} unique entries, sampled without\n\
 replacement from @code{1:@var{n}}.  The complexity is O(@var{n}) in\n\
 memory and O(@var{m}) in time, unless @var{m} < @var{n}/5, in which case\n\
 O(@var{m}) memory is used as well.  The randomization is performed using\n\
-rand(). All permutations are equally likely.\n\
+rand().  All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
 {
 
 #ifdef USE_UNORDERED_MAP_WITH_TR1
 using std::tr1::unordered_map;
 #else
 using std::unordered_map;
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -226,17 +226,17 @@ octregexp (const octave_value_list &args
 
       octave_idx_type i = 0;
       octave_scalar_map nmap;
 
       retval.resize (7);
 
       if (sz == 1)
         {
-          string_vector named_tokens = rx_lst.begin()->named_tokens ();
+          string_vector named_tokens = rx_lst.begin ()->named_tokens ();
 
           for (int j = 0; j < named_pats.length (); j++)
             nmap.assign (named_pats(j), named_tokens(j));
 
           retval(5) = nmap;
         }
       else
         {
@@ -503,17 +503,17 @@ octcellregexp (const octave_value_list &
     }
   else if (args(1).is_cell ())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellpat = args(1).cell_value ();
 
       for (int j = 0; j < nargout; j++)
-        newretval[j].resize(cellpat.dims ());
+        newretval[j].resize (cellpat.dims ());
 
       for (octave_idx_type i = 0; i < cellpat.numel (); i++)
         {
           new_args(1) = cellpat(i);
           octave_value_list tmp = octregexp (new_args, nargout, who,
                                              case_insensitive);
 
           if (error_state)
@@ -1306,19 +1306,19 @@ This option is present for compatibility
       if (!error_state)
         {
           Cell ret (dv0);
           octave_value_list new_args = args;
 
           for (octave_idx_type i = 0; i < dv0.numel (); i++)
             {
               new_args(0) = str(i);
-              if (pat.numel() == 1)
+              if (pat.numel () == 1)
                 new_args(1) = pat(0);
-              if (rep.numel() == 1)
+              if (rep.numel () == 1)
                 new_args(2) = rep(0);
 
               for (octave_idx_type j = 0; j < dv1.numel (); j++)
                 {
                   if (pat.numel () != 1)
                     new_args(1) = pat(j);
                   if (rep.numel () != 1)
                     new_args(2) = rep(j);
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -281,17 +281,17 @@ Riccati equations in control (see @code{
 %! assert (u' * a * u, s, sqrt (eps));
 
 %!test
 %! a = single ([1, 2, 3; 4, 5, 9; 7, 8, 6]);
 %! [u, s] = schur (a);
 %! assert (u' * a * u, s, sqrt (eps ("single")));
 
 %!test
-%! fail("schur ([1, 2; 3, 4], 2)", "warning");
+%! fail ("schur ([1, 2; 3, 4], 2)", "warning");
 
 %!error schur ()
 %!error <argument must be a square matrix> schur ([1, 2, 3; 4, 5, 6])
 */
 
 DEFUN_DLD (rsf2csf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -108,18 +108,18 @@ running time.\n\
   if (nargin == 0)
     {
       if (nargout == 0)
         octave_sparse_params::print_info (octave_stdout, "");
       else if (nargout == 1)
         retval(0) =  octave_sparse_params::get_vals ();
       else if (nargout == 2)
         {
-          retval (1) = octave_sparse_params::get_vals ();
-          retval (0) = octave_sparse_params::get_keys ();
+          retval(1) = octave_sparse_params::get_vals ();
+          retval(0) = octave_sparse_params::get_keys ();
         }
       else
         error ("spparms: too many output arguments");
     }
   else if (nargin == 1)
     {
       if (args(0).is_string ())
         {
@@ -133,17 +133,17 @@ running time.\n\
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
               if (xisnan (val))
                 error ("spparms: KEY not recognized");
               else
-                retval (0) = val;
+                retval(0) = val;
             }
         }
       else
         {
           NDArray vals = args(0).array_value ();
 
           if (error_state)
             error ("spparms: input must be a string or a vector");
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -397,10 +397,10 @@ risk of using @code{eval} on unknown dat
 %!assert (str2double ("-Inf"), -Inf)
 %!assert (str2double ("Inf*i"), complex (0, Inf))
 %!assert (str2double ("iNF*i"), complex (0, Inf))
 %!assert (str2double ("NaN + Inf*i"), complex (NaN, Inf))
 %!assert (str2double ("Inf - Inf*i"), complex (Inf, -Inf))
 %!assert (str2double ("-i*NaN - Inf"), complex (-Inf, -NaN))
 %!assert (str2double ({"abc", "4i"}), [NaN + 0i, 4i])
 %!assert (str2double ({2, "4i"}), [NaN + 0i, 4i])
-%!assert (str2double (zeros(3,1,2)), NaN (3,1,2))
+%!assert (str2double (zeros (3,1,2)), NaN (3,1,2))
 */
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -138,51 +138,51 @@ factorization as determined by @var{typ}
   A->itype = CHOLMOD_INT;
 #endif
   A->dtype = CHOLMOD_DOUBLE;
   A->stype = 1;
   A->x = &dummy;
 
   if (args(0).is_real_type ())
     {
-      const SparseMatrix a = args(0).sparse_matrix_value();
-      A->nrow = a.rows();
-      A->ncol = a.cols();
-      A->p = a.cidx();
-      A->i = a.ridx();
-      A->nzmax = a.nnz();
+      const SparseMatrix a = args(0).sparse_matrix_value ();
+      A->nrow = a.rows ();
+      A->ncol = a.cols ();
+      A->p = a.cidx ();
+      A->i = a.ridx ();
+      A->nzmax = a.nnz ();
       A->xtype = CHOLMOD_REAL;
 
-      if (a.rows() > 0 && a.cols() > 0)
-        A->x = a.data();
+      if (a.rows () > 0 && a.cols () > 0)
+        A->x = a.data ();
     }
   else if (args(0).is_complex_type ())
     {
-      const SparseComplexMatrix a = args(0).sparse_complex_matrix_value();
-      A->nrow = a.rows();
-      A->ncol = a.cols();
-      A->p = a.cidx();
-      A->i = a.ridx();
-      A->nzmax = a.nnz();
+      const SparseComplexMatrix a = args(0).sparse_complex_matrix_value ();
+      A->nrow = a.rows ();
+      A->ncol = a.cols ();
+      A->p = a.cidx ();
+      A->i = a.ridx ();
+      A->nzmax = a.nnz ();
       A->xtype = CHOLMOD_COMPLEX;
 
-      if (a.rows() > 0 && a.cols() > 0)
-        A->x = a.data();
+      if (a.rows () > 0 && a.cols () > 0)
+        A->x = a.data ();
     }
   else
     gripe_wrong_type_arg ("symbfact", args(0));
 
   octave_idx_type coletree = false;
   octave_idx_type n = A->nrow;
 
   if (nargin > 1)
     {
       char ch;
-      std::string str = args(1).string_value();
-      ch = tolower (str.c_str()[0]);
+      std::string str = args(1).string_value ();
+      ch = tolower (str.c_str ()[0]);
       if (ch == 'r')
         A->stype = 0;
       else if (ch == 'c')
         {
           n = A->ncol;
           coletree = true;
           A->stype = 0;
         }
@@ -218,32 +218,32 @@ factorization as determined by @var{typ}
           Aup = F ;
           Alo = A ;
         }
 
       CHOLMOD_NAME(etree) (Aup, Parent, cm);
 
       if (cm->status < CHOLMOD_OK)
         {
-          error("matrix corrupted");
+          error ("matrix corrupted");
           goto symbfact_error;
         }
 
       if (CHOLMOD_NAME(postorder) (Parent, n, 0, Post, cm) != n)
         {
-          error("postorder failed");
+          error ("postorder failed");
           goto symbfact_error;
         }
 
       CHOLMOD_NAME(rowcolcounts) (Alo, 0, 0, Parent, Post, 0,
                                   ColCount, First, Level, cm);
 
       if (cm->status < CHOLMOD_OK)
         {
-          error("matrix corrupted");
+          error ("matrix corrupted");
           goto symbfact_error;
         }
 
       if (nargout > 4)
         {
           cholmod_sparse *A1, *A2;
 
           if (A->stype == 1)
@@ -284,17 +284,17 @@ factorization as determined by @var{typ}
               lnz += ColCount [j];
             }
           L.xcidx(n) = lnz;
 
 
           /* create a copy of the column pointers */
           octave_idx_type *W = First;
           for (octave_idx_type j = 0 ; j < n ; j++)
-            W [j] = L.xcidx(j);
+            W[j] = L.xcidx (j);
 
           // get workspace for computing one row of L
           cholmod_sparse *R = cholmod_allocate_sparse (n, 1, n, false, true,
                                                        0, CHOLMOD_PATTERN, cm);
           octave_idx_type *Rp = static_cast<octave_idx_type *>(R->p);
           octave_idx_type *Ri = static_cast<octave_idx_type *>(R->i);
 
           // compute L one row at a time
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -130,19 +130,17 @@ H_heapify_min (CMK_Node *A, octave_idx_t
       else
         smallest = j;
 
       if (r < size && A[r].deg < A[smallest].deg)
         smallest = r;
 
       if (smallest != j)
         {
-          CMK_Node tmp = A[j];
-          A[j] = A[smallest];
-          A[smallest] = tmp;
+          std::swap (A[j], A[smallest]);
           j = smallest;
         }
       else
         break;
     }
 }
 
 // Heap operation insert. Running time is O(log(n))
@@ -156,19 +154,17 @@ H_insert (CMK_Node *H, octave_idx_type& 
 
   if (i == 0)
     return;
   do
     {
       octave_idx_type p = PARENT(i);
       if (H[i].deg < H[p].deg)
         {
-          CMK_Node tmp = H[i];
-          H[i] = H[p];
-          H[p] = tmp;
+          std::swap (H[i], H[p]);
 
           i = p;
         }
       else
         break;
     }
   while (i > 0);
 }
@@ -177,17 +173,17 @@ H_insert (CMK_Node *H, octave_idx_type& 
 // reorganizes the heap optionally in O(log(n))
 
 inline static CMK_Node
 H_remove_min (CMK_Node *H, octave_idx_type& h, int reorg/*=1*/)
 {
   CMK_Node r = H[0];
   H[0] = H[--h];
   if (reorg)
-    H_heapify_min(H, 0, h);
+    H_heapify_min (H, 0, h);
   return r;
 }
 
 // Predicate (heap empty)
 #define H_empty(H, h)   ((h) == 0)
 
 // Helper function for the Cuthill-McKee algorithm. Tries to determine a
 // pseudo-peripheral node of the graph as starting node.
@@ -596,72 +592,72 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
                 {
                   octave_idx_type r2 = ridx2[j2++];
                   if (! visit[r2])
                     {
                       // the distance of node j is dist(i)+1
                       w.id = r2;
                       w.deg = D[r2];
                       w.dist = v.dist+1;
-                      H_insert(S, s, w);
+                      H_insert (S, s, w);
                       visit[r2] = true;
                     }
                 }
               else if (j2 == cidx2[i+1])
                 {
                   octave_idx_type r1 = ridx[j1++];
                   if (! visit[r1])
                     {
                       w.id = r1;
                       w.deg = D[r1];
                       w.dist = v.dist+1;
-                      H_insert(S, s, w);
+                      H_insert (S, s, w);
                       visit[r1] = true;
                     }
                 }
               else
                 {
                   octave_idx_type r1 = ridx[j1];
                   octave_idx_type r2 = ridx2[j2];
                   if (r1 <= r2)
                     {
                       if (! visit[r1])
                         {
                           w.id = r1;
                           w.deg = D[r1];
                           w.dist = v.dist+1;
-                          H_insert(S, s, w);
+                          H_insert (S, s, w);
                           visit[r1] = true;
                         }
                       j1++;
                       if (r1 == r2)
                         j2++;
                     }
                   else
                     {
                       if (! visit[r2])
                         {
                           w.id = r2;
                           w.deg = D[r2];
                           w.dist = v.dist+1;
-                          H_insert(S, s, w);
+                          H_insert (S, s, w);
                           visit[r2] = true;
                         }
                       j2++;
                     }
                 }
             }
 
           // add the neighbors to the queue (sorted by node degree)
           while (! H_empty (S, s))
             {
               OCTAVE_QUIT;
 
               // locate a neighbor of i with minimal degree in O(log(N))
-              v = H_remove_min(S, s, 1);
+              v = H_remove_min (S, s, 1);
 
               // entered the BFS a new level?
               if (v.dist > level)
                 {
                   // adjustment of bandwith:
                   // "[...] the minimum bandwidth that
                   // can be obtained [...] is the
                   //  maximum number of nodes per level"
@@ -694,17 +690,13 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
         B = Bsub;
     }
   // are there any nodes left?
   while (c+1 < N);
 
   // compute the reverse-ordering
   s = N / 2 - 1;
   for (octave_idx_type i = 0, j = N - 1; i <= s; i++, j--)
-    {
-      double tmp = P.elem(i);
-      P.elem(i) = P.elem(j);
-      P.elem(j) = tmp;
-    }
+    std::swap (P.elem (i), P.elem (j));
 
   // increment all indices, since Octave is not C
   return octave_value (P+1);
 }
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -64,17 +64,17 @@ do_tril (const Array<T>& a, octave_idx_t
     }
   else
     {
       Array<T> r (a.dims ());
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j - k), nr);
-          std::fill (rvec, rvec + ii, T());
+          std::fill (rvec, rvec + ii, T ());
           std::copy (avec + ii, avec + nr, rvec + ii);
           avec += nr;
           rvec += nr;
         }
 
       return r;
     }
 }
@@ -106,17 +106,17 @@ do_triu (const Array<T>& a, octave_idx_t
   else
     {
       NoAlias<Array<T> > r (a.dims ());
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j + 1 - k), nr);
           std::copy (avec, avec + ii, rvec);
-          std::fill (rvec + ii, rvec + nr, T());
+          std::fill (rvec + ii, rvec + nr, T ());
           avec += nr;
           rvec += nr;
         }
 
       return r;
     }
 }
 
@@ -129,21 +129,21 @@ do_tril (const Sparse<T>& a, octave_idx_
 {
   if (pack) // FIXME
     {
       error ("tril: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
   Sparse<T> m = a;
-  octave_idx_type nc = m.cols();
+  octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      if (m.ridx(i) < j-k)
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      if (m.ridx (i) < j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
 }
 
 template <class T>
 static Sparse<T>
@@ -151,21 +151,21 @@ do_triu (const Sparse<T>& a, octave_idx_
 {
   if (pack) // FIXME
     {
       error ("triu: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
   Sparse<T> m = a;
-  octave_idx_type nc = m.cols();
+  octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      if (m.ridx(i) > j-k)
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      if (m.ridx (i) > j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
 }
 
 // Convenience dispatchers.
 template <class T>
@@ -285,32 +285,32 @@ do_trilu (const std::string& name,
 
                 octave_value_list ov_idx;
                 std::list<octave_value_list> idx_tmp;
                 ov_idx(1) = static_cast<double> (nc+1);
                 ov_idx(0) = Range (1, nr);
                 idx_tmp.push_back (ov_idx);
                 ov_idx(1) = static_cast<double> (nc);
                 tmp = tmp.resize (dim_vector (0,0));
-                tmp = tmp.subsasgn("(",idx_tmp, arg.do_index_op (ov_idx));
-                tmp = tmp.resize(dims);
+                tmp = tmp.subsasgn ("(",idx_tmp, arg.do_index_op (ov_idx));
+                tmp = tmp.resize (dims);
 
                 if (lower)
                   {
                     octave_idx_type st = nc < nr + k ? nc : nr + k;
 
                     for (octave_idx_type j = 1; j <= st; j++)
                       {
                         octave_idx_type nr_limit = 1 > j - k ? 1 : j - k;
                         ov_idx(1) = static_cast<double> (j);
                         ov_idx(0) = Range (nr_limit, nr);
                         std::list<octave_value_list> idx;
                         idx.push_back (ov_idx);
 
-                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op(ov_idx));
+                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
 
                         if (error_state)
                           return retval;
                       }
                   }
                 else
                   {
                     octave_idx_type st = k + 1 > 1 ? k + 1 : 1;
@@ -318,17 +318,17 @@ do_trilu (const std::string& name,
                     for (octave_idx_type j = st; j <= nc; j++)
                       {
                         octave_idx_type nr_limit = nr < j - k ? nr : j - k;
                         ov_idx(1) = static_cast<double> (j);
                         ov_idx(0) = Range (1, nr_limit);
                         std::list<octave_value_list> idx;
                         idx.push_back (ov_idx);
 
-                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op(ov_idx));
+                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
 
                         if (error_state)
                           return retval;
                       }
                   }
 
                 retval = tmp;
               }
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -183,17 +183,17 @@ public:
   curl_handle (const std::string& _host, const std::string& user,
                const std::string& passwd) :
     rep (new curl_handle_rep ())
     {
       rep->host = _host;
       init (user, passwd, std::cin, octave_stdout);
 
       std::string url = "ftp://" + _host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
 
       // Setup the link, with no transfer
       if (!error_state)
         perform ();
     }
 
   curl_handle (const std::string& url, const std::string& method,
                const Cell& param, std::ostream& os, bool& retval) :
@@ -215,17 +215,17 @@ public:
           setopt (CURLOPT_URL, query_string.c_str ());
         }
       else if (method == "post")
         {
           setopt (CURLOPT_URL, url.c_str ());
           setopt (CURLOPT_POSTFIELDS, query_string.c_str ());
         }
       else
-        setopt (CURLOPT_URL, url.c_str());
+        setopt (CURLOPT_URL, url.c_str ());
 
       if (!error_state)
         retval = perform (false);
     }
 
   curl_handle (const curl_handle& h) : rep (h.rep)
     {
       rep->count++;
@@ -291,167 +291,167 @@ public:
     {
       return rep->is_binary ();
     }
 
   void cwd (const std::string& path) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "cwd " + path;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void del (const std::string& file) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "dele " + file;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void rmdir (const std::string& path) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "rmd " + path;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   bool mkdir (const std::string& path, bool curlerror = true) const
     {
       bool retval = false;
       struct curl_slist *slist = 0;
       std::string cmd = "mkd " + path;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         retval = perform (curlerror);
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
       return retval;
     }
 
   void rename (const std::string& oldname, const std::string& newname) const
     {
       struct curl_slist *slist = 0;
       std::string cmd = "rnfr " + oldname;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       cmd = "rnto " + newname;
-      slist = curl_slist_append (slist, cmd.c_str());
+      slist = curl_slist_append (slist, cmd.c_str ());
       setopt (CURLOPT_POSTQUOTE, slist);
       if (! error_state)
         perform ();
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
     }
 
   void put (const std::string& file, std::istream& is) const
     {
       std::string url = "ftp://" + rep->host + "/" + file;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_UPLOAD, 1);
       setopt (CURLOPT_NOBODY, 0);
       set_istream (is);
       if (! error_state)
         perform ();
       set_istream (std::cin);
       setopt (CURLOPT_NOBODY, 1);
       setopt (CURLOPT_UPLOAD, 0);
       url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
     }
 
   void get (const std::string& file, std::ostream& os) const
     {
       std::string url = "ftp://" + rep->host + "/" + file;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_NOBODY, 0);
       set_ostream (os);
       if (! error_state)
         perform ();
       set_ostream (octave_stdout);
       setopt (CURLOPT_NOBODY, 1);
       url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
     }
 
   void dir (void) const
     {
       std::string url = "ftp://" + rep->host + "/";
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_NOBODY, 0);
       if (! error_state)
         perform ();
       setopt (CURLOPT_NOBODY, 1);
       url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
     }
 
   string_vector list (void) const
     {
       std::ostringstream buf;
       std::string url = "ftp://" + rep->host + "/";
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&buf));
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_DIRLISTONLY, 1);
       setopt (CURLOPT_NOBODY, 0);
       if (! error_state)
         perform ();
       setopt (CURLOPT_NOBODY, 1);
       url = "ftp://" + rep->host;
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&octave_stdout));
       setopt (CURLOPT_DIRLISTONLY, 0);
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
 
       // Count number of directory entries
       std::string str = buf.str ();
       octave_idx_type n = 0;
       size_t pos = 0;
       while (true)
         {
-          pos = str.find_first_of('\n', pos);
+          pos = str.find_first_of ('\n', pos);
           if (pos == std::string::npos)
             break;
           pos++;
           n++;
         }
       string_vector retval (n);
       pos = 0;
       for (octave_idx_type i = 0; i < n; i++)
         {
-          size_t newpos = str.find_first_of('\n', pos);
+          size_t newpos = str.find_first_of ('\n', pos);
           if (newpos == std::string::npos)
             break;
 
           retval(i) = str.substr(pos, newpos - pos);
           pos = newpos + 1;
         }
       return retval;
     }
 
   void get_fileinfo (const std::string& filename, double& filesize,
                      time_t& filetime, bool& fileisdir) const
     {
-      std::string path = pwd();
+      std::string path = pwd ();
 
       std::string url = "ftp://" + rep->host + "/" + path + "/" + filename;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
       setopt (CURLOPT_FILETIME, 1);
       setopt (CURLOPT_HEADERFUNCTION, throw_away);
       setopt (CURLOPT_WRITEFUNCTION, throw_away);
 
       // FIXME
       // The MDTM command fails for a directory on the servers I tested
       // so this is a means of testing for directories. It also means
       // I can't get the date of directories!
@@ -462,30 +462,30 @@ public:
               fileisdir = true;
               filetime = -1;
               filesize = 0;
             }
           else
             {
               fileisdir = false;
               time_t ft;
-              curl_easy_getinfo(rep->handle (), CURLINFO_FILETIME, &ft);
+              curl_easy_getinfo (rep->handle (), CURLINFO_FILETIME, &ft);
               filetime = ft;
               double fs;
-              curl_easy_getinfo(rep->handle (),
-                                CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
+              curl_easy_getinfo (rep->handle (),
+                                 CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
               filesize = fs;
             }
         }
 
       setopt (CURLOPT_WRITEFUNCTION, write_data);
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_FILETIME, 0);
       url = "ftp://" + rep->host;
-      setopt (CURLOPT_URL, url.c_str());
+      setopt (CURLOPT_URL, url.c_str ());
 
       // The MDTM command seems to reset the path to the root with the
       // servers I tested with, so cd again into the correct path. Make
       // the path absolute so that this will work even with servers that
       // don't end up in the root after an MDTM command.
       cwd ("/" + path);
     }
 
@@ -498,22 +498,22 @@ public:
       slist = curl_slist_append (slist, "pwd");
       setopt (CURLOPT_POSTQUOTE, slist);
       setopt (CURLOPT_HEADERFUNCTION, write_data);
       setopt (CURLOPT_WRITEHEADER, static_cast<void *>(&buf));
 
       if (! error_state)
         {
           perform ();
-          retval = buf.str();
+          retval = buf.str ();
 
           // Can I assume that the path is alway in "" on the last line
           size_t pos2 = retval.rfind ('"');
           size_t pos1 = retval.rfind ('"', pos2 - 1);
-          retval = retval.substr(pos1 + 1, pos2 - pos1 - 1);
+          retval = retval.substr (pos1 + 1, pos2 - pos1 - 1);
         }
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_WRITEHEADER, 0);
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
 
       return retval;
     }
@@ -531,27 +531,27 @@ private:
       std::ostringstream query;
 
       for (int i = 0; i < param.numel (); i += 2)
         {
           std::string name = param(i).string_value ();
           std::string text = param(i+1).string_value ();
 
           // Encode strings.
-          char *enc_name = curl_easy_escape (rep->handle(), name.c_str (),
+          char *enc_name = curl_easy_escape (rep->handle (), name.c_str (),
                                              name.length ());
-          char *enc_text = curl_easy_escape (rep->handle(), text.c_str (),
+          char *enc_text = curl_easy_escape (rep->handle (), text.c_str (),
                                              text.length ());
 
           query << enc_name << "=" << enc_text;
 
           curl_free (enc_name);
           curl_free (enc_text);
 
-          if (i < param.numel()-1)
+          if (i < param.numel ()-1)
             query << "&";
         }
 
       query.flush ();
 
       return query.str ();
     }
 
@@ -603,24 +603,24 @@ curl_handles
 {
 public:
 
   typedef std::map<std::string, curl_handle>::iterator iterator;
   typedef std::map<std::string, curl_handle>::const_iterator const_iterator;
 
   curl_handles (void) : map ()
    {
-     curl_global_init(CURL_GLOBAL_DEFAULT);
+     curl_global_init (CURL_GLOBAL_DEFAULT);
    }
 
   ~curl_handles (void)
     {
       // Remove the elements of the map explicitly as they should
       // be deleted before the call to curl_global_cleanup
-      map.erase (begin(), end());
+      map.erase (begin (), end ());
 
       curl_global_cleanup ();
     }
 
   iterator begin (void) { return iterator (map.begin ()); }
   const_iterator begin (void) const { return const_iterator (map.begin ()); }
 
   iterator end (void) { return iterator (map.end ()); }
@@ -736,53 +736,53 @@ urlwrite (\"http://www.google.com/search
 
   // verify arguments
   if (nargin != 2 && nargin != 4)
     {
       print_usage ();
       return retval;
     }
 
-  std::string url = args(0).string_value();
+  std::string url = args(0).string_value ();
 
   if (error_state)
     {
       error ("urlwrite: URL must be a character string");
       return retval;
     }
 
   // name to store the file if download is succesful
-  std::string filename = args(1).string_value();
+  std::string filename = args(1).string_value ();
 
   if (error_state)
     {
       error ("urlwrite: LOCALFILE must be a character string");
       return retval;
     }
 
   std::string method;
   Cell param; // empty cell array
 
   if (nargin == 4)
     {
-      method = args(2).string_value();
+      method = args(2).string_value ();
 
       if (error_state)
         {
           error ("urlwrite: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       if (method != "get" && method != "post")
         {
           error ("urlwrite: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
-      param = args(3).cell_value();
+      param = args(3).cell_value ();
 
       if (error_state)
         {
           error ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell");
           return retval;
         }
 
 
@@ -794,17 +794,17 @@ urlwrite (\"http://www.google.com/search
     }
 
   // The file should only be deleted if it doesn't initially exist, we
   // create it, and the download fails.  We use unwind_protect to do
   // it so that the deletion happens no matter how we exit the function.
 
   file_stat fs (filename);
 
-  std::ofstream ofile (filename.c_str(), std::ios::out | std::ios::binary);
+  std::ofstream ofile (filename.c_str (), std::ios::out | std::ios::binary);
 
   if (! ofile.is_open ())
     {
       error ("urlwrite: unable to open file");
       return retval;
     }
 
   unwind_protect_safe frame;
@@ -896,44 +896,44 @@ s = urlread (\"http://www.google.com/sea
 
   // verify arguments
   if (nargin != 1  && nargin != 3)
     {
       print_usage ();
       return retval;
     }
 
-  std::string url = args(0).string_value();
+  std::string url = args(0).string_value ();
 
   if (error_state)
     {
       error ("urlread: URL must be a character string");
       return retval;
     }
 
   std::string method;
   Cell param; // empty cell array
 
   if (nargin == 3)
     {
-      method = args(1).string_value();
+      method = args(1).string_value ();
 
       if (error_state)
         {
           error ("urlread: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       if (method != "get" && method != "post")
         {
           error ("urlread: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
-      param = args(2).cell_value();
+      param = args(2).cell_value ();
 
       if (error_state)
         {
           error ("urlread: parameters (PARAM) for get and post requests must be given as a cell");
           return retval;
         }
 
       if (param.numel () % 2 == 1 )
@@ -1263,17 +1263,17 @@ DEFUN_DLD (__ftp_mode__, args, ,
        std::string handle = args(0).string_value ();
 
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
 
           if (curl.is_valid ())
-            retval = (curl.is_ascii() ? "ascii" : "binary");
+            retval = (curl.is_ascii () ? "ascii" : "binary");
           else
             error ("__ftp_binary__: invalid ftp handle");
         }
      }
  #else
    error ("__ftp_mode__: not available in this version of Octave");
  #endif
 
@@ -1417,28 +1417,28 @@ Undocumented internal function\n\
 static string_vector
 mput_directory (const curl_handle& curl, const std::string& base,
                 const std::string& dir)
 {
   string_vector retval;
 
   if (! curl.mkdir (dir, false))
     warning ("__ftp_mput__: can not create the remote directory ""%s""",
-             (base.length() == 0 ? dir : base +
+             (base.length () == 0 ? dir : base +
               file_ops::dir_sep_str () + dir).c_str ());
 
   curl.cwd (dir);
 
   if (! error_state)
     {
       unwind_protect_safe frame;
 
       frame.add_fcn (reset_path, curl);
 
-      std::string realdir = base.length() == 0 ? dir : base +
+      std::string realdir = base.length () == 0 ? dir : base +
                          file_ops::dir_sep_str () + dir;
 
       dir_entry dirlist (realdir);
 
       if (dirlist)
         {
           string_vector files = dirlist.read ();
 
@@ -1464,17 +1464,17 @@ mput_directory (const curl_handle& curl,
                   retval.append (mput_directory (curl, realdir, file));
 
                   if (error_state)
                     break;
                 }
               else
                 {
                   // FIXME Does ascii mode need to be flagged here?
-                  std::ifstream ifile (realfile.c_str(), std::ios::in |
+                  std::ifstream ifile (realfile.c_str (), std::ios::in |
                                        std::ios::binary);
 
                   if (! ifile.is_open ())
                     {
                       error ("__ftp_mput__: unable to open file ""%s""",
                              realfile.c_str ());
                       break;
                     }
@@ -1487,17 +1487,17 @@ mput_directory (const curl_handle& curl,
                     break;
 
                   retval.append (realfile);
                 }
             }
         }
       else
         error ("__ftp_mput__: can not read the directory ""%s""",
-               realdir.c_str());
+               realdir.c_str ());
     }
 
   return retval;
 }
 #endif
 
 DEFUN_DLD (__ftp_mput__, args, nargout,
   "-*- texinfo -*-\n\
@@ -1542,17 +1542,17 @@ Undocumented internal function\n\
                     {
                       retval.append (mput_directory (curl, "", file));
                       if (error_state)
                         break;
                     }
                   else
                     {
                       // FIXME Does ascii mode need to be flagged here?
-                      std::ifstream ifile (file.c_str(), std::ios::in |
+                      std::ifstream ifile (file.c_str (), std::ios::in |
                                            std::ios::binary);
 
                       if (! ifile.is_open ())
                         {
                           error ("__ftp_mput__: unable to open file");
                           break;
                         }
 
@@ -1588,17 +1588,17 @@ getallfiles (const curl_handle& curl, co
 
   if (!fs || !fs.is_dir ())
     {
       std::string msg;
       int status = octave_mkdir (dir, 0777, msg);
 
       if (status < 0)
         error ("__ftp_mget__: can't create directory %s%s%s. %s",
-               target.c_str(), sep.c_str(), dir.c_str(), msg.c_str());
+               target.c_str (), sep.c_str (), dir.c_str (), msg.c_str ());
     }
 
   if (! error_state)
     {
       curl.cwd (dir);
 
       if (! error_state)
         {
@@ -1616,17 +1616,17 @@ getallfiles (const curl_handle& curl, co
 
               curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
               if (fisdir)
                 getallfiles (curl, sv(i), target + dir + sep);
               else
                 {
                   std::string realfile = target + dir + sep + sv(i);
-                  std::ofstream ofile (realfile.c_str(),
+                  std::ofstream ofile (realfile.c_str (),
                                        std::ios::out |
                                        std::ios::binary);
 
                   if (! ofile.is_open ())
                     {
                       error ("__ftp_mget__: unable to open file");
                       break;
                     }
@@ -1694,17 +1694,17 @@ Undocumented internal function\n\
                       double fsize;
 
                       curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
                       if (fisdir)
                         getallfiles (curl, sv(i), target);
                       else
                         {
-                          std::ofstream ofile ((target + sv(i)).c_str(),
+                          std::ofstream ofile ((target + sv(i)).c_str (),
                                                std::ios::out |
                                                std::ios::binary);
 
                           if (! ofile.is_open ())
                             {
                               error ("__ftp_mget__: unable to open file");
                               break;
                             }
diff --git a/src/OPERATORS/op-bm-bm.cc b/src/OPERATORS/op-bm-bm.cc
--- a/src/OPERATORS/op-bm-bm.cc
+++ b/src/OPERATORS/op-bm-bm.cc
@@ -61,17 +61,17 @@ DEFUNOP (transpose, bool_matrix)
   CAST_UNOP_ARG (const octave_bool_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.bool_matrix_value().transpose ());
+    return octave_value (v.bool_matrix_value ().transpose ());
 }
 
 // bool matrix by bool matrix ops.
 
 DEFNDBINOP_FN (eq, bool_matrix, bool_matrix, bool_array, bool_array, mx_el_eq)
 DEFNDBINOP_FN (ne, bool_matrix, bool_matrix, bool_array, bool_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_and, bool_matrix, bool_matrix, bool_array, bool_array,
diff --git a/src/OPERATORS/op-cdm-cdm.cc b/src/OPERATORS/op-cdm-cdm.cc
--- a/src/OPERATORS/op-cdm-cdm.cc
+++ b/src/OPERATORS/op-cdm-cdm.cc
@@ -38,23 +38,23 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, complex_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, complex_diag_matrix, -)
 
 DEFUNOP (transpose, complex_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_complex_diag_matrix&);
-  return octave_value (v.complex_diag_matrix_value().transpose ());
+  return octave_value (v.complex_diag_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, complex_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_complex_diag_matrix&);
-  return octave_value (v.complex_diag_matrix_value().hermitian ());
+  return octave_value (v.complex_diag_matrix_value ().hermitian ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, complex_diag_matrix, complex_diag_matrix, +)
 DEFBINOP_OP (sub, complex_diag_matrix, complex_diag_matrix, -)
 DEFBINOP_OP (mul, complex_diag_matrix, complex_diag_matrix, *)
 
diff --git a/src/OPERATORS/op-cell.cc b/src/OPERATORS/op-cell.cc
--- a/src/OPERATORS/op-cell.cc
+++ b/src/OPERATORS/op-cell.cc
@@ -41,17 +41,17 @@ DEFUNOP (transpose, cell)
   CAST_UNOP_ARG (const octave_cell&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (Cell (v.cell_value().transpose ()));
+    return octave_value (Cell (v.cell_value ().transpose ()));
 }
 
 DEFCATOP_FN (c_c, cell, cell, concat)
 
 DEFASSIGNANYOP_FN (assign, cell, assign);
 
 DEFNULLASSIGNOP_FN (null_assign, cell, delete_elements)
 
diff --git a/src/OPERATORS/op-chm.cc b/src/OPERATORS/op-chm.cc
--- a/src/OPERATORS/op-chm.cc
+++ b/src/OPERATORS/op-chm.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 
 // char matrix unary ops.
 
 DEFUNOP (transpose, char_matrix)
 {
   CAST_UNOP_ARG (const octave_char_matrix&);
 
-  return octave_value (v.matrix_value().transpose ());
+  return octave_value (v.matrix_value ().transpose ());
 }
 
 DEFNDCATOP_FN (chm_chm, char_matrix, char_matrix, char_array, char_array,
                concat)
 
 DEFCATOP (chm_s, char_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_scalar&);
diff --git a/src/OPERATORS/op-cm-cm.cc b/src/OPERATORS/op-cm-cm.cc
--- a/src/OPERATORS/op-cm-cm.cc
+++ b/src/OPERATORS/op-cm-cm.cc
@@ -46,30 +46,30 @@ DEFUNOP (transpose, complex_matrix)
   CAST_UNOP_ARG (const octave_complex_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.complex_matrix_value().transpose ());
+    return octave_value (v.complex_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, complex_matrix)
 {
   CAST_UNOP_ARG (const octave_complex_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("complex-conjugate transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.complex_matrix_value().hermitian ());
+    return octave_value (v.complex_matrix_value ().hermitian ());
 }
 
 DEFNCUNOP_METHOD (incr, complex_matrix, increment)
 DEFNCUNOP_METHOD (decr, complex_matrix, decrement)
 DEFNCUNOP_METHOD (changesign, complex_matrix, changesign)
 
 // complex matrix by complex matrix ops.
 
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -46,17 +46,17 @@ DEFBINOP_OP (sub, complex_matrix, sparse
 
 DEFBINOP_OP (mul, complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -45,17 +45,17 @@ DEFBINOP_OP (add, complex_matrix, sparse
 DEFBINOP_OP (sub, complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, complex, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
     }
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -45,17 +45,17 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, complex, sparse_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_matrix, *)
 
 DEFBINOP (div, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
     }
diff --git a/src/OPERATORS/op-dm-dm.cc b/src/OPERATORS/op-dm-dm.cc
--- a/src/OPERATORS/op-dm-dm.cc
+++ b/src/OPERATORS/op-dm-dm.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, diag_matrix, -)
 
 DEFUNOP (transpose, diag_matrix)
 {
   CAST_UNOP_ARG (const octave_diag_matrix&);
-  return octave_value (v.diag_matrix_value().transpose ());
+  return octave_value (v.diag_matrix_value ().transpose ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, diag_matrix, diag_matrix, +)
 DEFBINOP_OP (sub, diag_matrix, diag_matrix, -)
 DEFBINOP_OP (mul, diag_matrix, diag_matrix, *)
 
diff --git a/src/OPERATORS/op-dm-scm.cc b/src/OPERATORS/op-dm-scm.cc
--- a/src/OPERATORS/op-dm-scm.cc
+++ b/src/OPERATORS/op-dm-scm.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 #include "sparse-xdiv.h"
 
 // diagonal matrix by sparse matrix ops
 
 DEFBINOP (mul_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.diag_matrix_value () * d);
     }
   else
@@ -61,17 +61,17 @@ DEFBINOP (mul_dm_scm, diag_matrix, spars
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.scalar_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
     }
   else
@@ -84,17 +84,17 @@ DEFBINOP (mul_cdm_sm, complex_diag_matri
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
     }
   else
@@ -137,97 +137,97 @@ DEFBINOP (ldiv_cdm_scm, complex_diag_mat
   return xleftdiv (v1.complex_diag_matrix_value (), v2.sparse_complex_matrix_value (),
                    typ);
 }
 
 DEFBINOP (add_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (add_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (add_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + (-d));
     }
   else
     return v1.diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
     }
   else
     return v1.complex_diag_matrix_value () - v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
     }
   else
@@ -235,17 +235,17 @@ DEFBINOP (sub_cdm_scm, complex_diag_matr
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_dm, sparse_complex_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.diag_matrix_value ());
     }
   else
@@ -258,17 +258,17 @@ DEFBINOP (mul_scm_dm, sparse_complex_mat
       return out;
     }
 }
 
 DEFBINOP (mul_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
     }
   else
@@ -281,25 +281,25 @@ DEFBINOP (mul_sm_cdm, sparse_matrix, com
       return out;
     }
 }
 
 DEFBINOP (mul_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
     }
-  else if (v2.rows() == 1 && v2.columns() == 1)
+  else if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, don't bother with further dispatching.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () * d);
     }
   else
     {
@@ -311,17 +311,17 @@ DEFBINOP (mul_scm_cdm, sparse_complex_ma
       return out;
     }
 }
 
 DEFBINOP (div_scm_dm, sparse_complex_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
@@ -331,17 +331,17 @@ DEFBINOP (div_scm_dm, sparse_complex_mat
       return xdiv (v1.sparse_complex_matrix_value (), v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
@@ -351,17 +351,17 @@ DEFBINOP (div_sm_cdm, sparse_matrix, com
       return xdiv (v1.sparse_matrix_value (), v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
@@ -371,97 +371,97 @@ DEFBINOP (div_scm_cdm, sparse_complex_ma
       return xdiv (v1.sparse_complex_matrix_value (), v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (add_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + d);
     }
   else
     return v1.sparse_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_dm, sparse_complex_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + (-d));
     }
   else
     return v1.sparse_matrix_value () - v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_dm, sparse_complex_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
     }
   else
     return v1.sparse_complex_matrix_value () - v2.diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
     }
   else
diff --git a/src/OPERATORS/op-dm-sm.cc b/src/OPERATORS/op-dm-sm.cc
--- a/src/OPERATORS/op-dm-sm.cc
+++ b/src/OPERATORS/op-dm-sm.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "sparse-xdiv.h"
 
 // diagonal matrix by sparse matrix ops
 
 DEFBINOP (mul_dm_sm, diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.diag_matrix_value () * d);
     }
   else
@@ -67,33 +67,33 @@ DEFBINOP (ldiv_dm_sm, diag_matrix, spars
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.diag_matrix_value (), v2.sparse_matrix_value (), typ);
 }
 
 DEFBINOP (add_dm_sm, diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_dm_sm, diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.matrix_value () - d);
     }
   else
@@ -101,17 +101,17 @@ DEFBINOP (sub_dm_sm, diag_matrix, sparse
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_sm_dm, sparse_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
       return octave_value (d * v2.diag_matrix_value ());
     }
   else
@@ -124,17 +124,17 @@ DEFBINOP (mul_sm_dm, sparse_matrix, diag
       return out;
     }
 }
 
 DEFBINOP (div_sm_dm, sparse_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
@@ -144,33 +144,33 @@ DEFBINOP (div_sm_dm, sparse_matrix, diag
       return xdiv (v1.sparse_matrix_value (), v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (add_sm_dm, sparse_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
       return octave_value (d + v2.matrix_value ());
     }
   else
     return v1.sparse_matrix_value () + v2.diag_matrix_value ();
 }
 
 DEFBINOP (sub_sm_dm, sparse_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
       return octave_value (d - v2.matrix_value ());
     }
   else
diff --git a/src/OPERATORS/op-fcdm-fcdm.cc b/src/OPERATORS/op-fcdm-fcdm.cc
--- a/src/OPERATORS/op-fcdm-fcdm.cc
+++ b/src/OPERATORS/op-fcdm-fcdm.cc
@@ -38,23 +38,23 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, float_complex_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, float_complex_diag_matrix, -)
 
 DEFUNOP (transpose, float_complex_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_float_complex_diag_matrix&);
-  return octave_value (v.float_complex_diag_matrix_value().transpose ());
+  return octave_value (v.float_complex_diag_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, float_complex_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_float_complex_diag_matrix&);
-  return octave_value (v.float_complex_diag_matrix_value().hermitian ());
+  return octave_value (v.float_complex_diag_matrix_value ().hermitian ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_complex_diag_matrix, float_complex_diag_matrix, +)
 DEFBINOP_OP (sub, float_complex_diag_matrix, float_complex_diag_matrix, -)
 DEFBINOP_OP (mul, float_complex_diag_matrix, float_complex_diag_matrix, *)
 
diff --git a/src/OPERATORS/op-fcm-fcm.cc b/src/OPERATORS/op-fcm-fcm.cc
--- a/src/OPERATORS/op-fcm-fcm.cc
+++ b/src/OPERATORS/op-fcm-fcm.cc
@@ -46,30 +46,30 @@ DEFUNOP (transpose, float_complex_matrix
   CAST_UNOP_ARG (const octave_float_complex_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.float_complex_matrix_value().transpose ());
+    return octave_value (v.float_complex_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, float_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_float_complex_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("complex-conjugate transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.float_complex_matrix_value().hermitian ());
+    return octave_value (v.float_complex_matrix_value ().hermitian ());
 }
 
 DEFNCUNOP_METHOD (incr, float_complex_matrix, increment)
 DEFNCUNOP_METHOD (decr, float_complex_matrix, decrement)
 DEFNCUNOP_METHOD (changesign, float_complex_matrix, changesign)
 
 // complex matrix by complex matrix ops.
 
diff --git a/src/OPERATORS/op-fdm-fdm.cc b/src/OPERATORS/op-fdm-fdm.cc
--- a/src/OPERATORS/op-fdm-fdm.cc
+++ b/src/OPERATORS/op-fdm-fdm.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, float_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, float_diag_matrix, -)
 
 DEFUNOP (transpose, float_diag_matrix)
 {
   CAST_UNOP_ARG (const octave_float_diag_matrix&);
-  return octave_value (v.float_diag_matrix_value().transpose ());
+  return octave_value (v.float_diag_matrix_value ().transpose ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_diag_matrix, float_diag_matrix, +)
 DEFBINOP_OP (sub, float_diag_matrix, float_diag_matrix, -)
 DEFBINOP_OP (mul, float_diag_matrix, float_diag_matrix, *)
 
diff --git a/src/OPERATORS/op-fm-fm.cc b/src/OPERATORS/op-fm-fm.cc
--- a/src/OPERATORS/op-fm-fm.cc
+++ b/src/OPERATORS/op-fm-fm.cc
@@ -46,17 +46,17 @@ DEFUNOP (transpose, float_matrix)
   CAST_UNOP_ARG (const octave_float_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.float_matrix_value().transpose ());
+    return octave_value (v.float_matrix_value ().transpose ());
 }
 
 DEFNCUNOP_METHOD (incr, float_matrix, increment)
 DEFNCUNOP_METHOD (decr, float_matrix, decrement)
 DEFNCUNOP_METHOD (changesign, float_matrix, changesign)
 
 // matrix by matrix ops.
 
diff --git a/src/OPERATORS/op-int.h b/src/OPERATORS/op-int.h
--- a/src/OPERATORS/op-int.h
+++ b/src/OPERATORS/op-int.h
@@ -628,17 +628,17 @@ octave_value elem_xpow (FloatNDArray a, 
     CAST_UNOP_ARG (const octave_ ## TYPE ## _matrix&); \
  \
     if (v.ndims () > 2) \
       { \
         error ("transpose not defined for N-d objects"); \
         return octave_value (); \
       } \
     else \
-      return octave_value (v.TYPE ## _array_value().transpose ()); \
+      return octave_value (v.TYPE ## _array_value ().transpose ()); \
   } \
  \
   DEFNCUNOP_METHOD (m_incr, TYPE ## _matrix, increment) \
   DEFNCUNOP_METHOD (m_decr, TYPE ## _matrix, decrement) \
   DEFNCUNOP_METHOD (m_changesign, TYPE ## _matrix, changesign)
 
 #define OCTAVE_MM_INT_ARITH_OPS(PFX, T1, T2, T3)        \
   /* matrix by matrix ops. */ \
diff --git a/src/OPERATORS/op-m-m.cc b/src/OPERATORS/op-m-m.cc
--- a/src/OPERATORS/op-m-m.cc
+++ b/src/OPERATORS/op-m-m.cc
@@ -46,17 +46,17 @@ DEFUNOP (transpose, matrix)
   CAST_UNOP_ARG (const octave_matrix&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.matrix_value().transpose ());
+    return octave_value (v.matrix_value ().transpose ());
 }
 
 DEFNCUNOP_METHOD (incr, matrix, increment)
 DEFNCUNOP_METHOD (decr, matrix, decrement)
 DEFNCUNOP_METHOD (changesign, matrix, changesign)
 
 // matrix by matrix ops.
 
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -46,17 +46,17 @@ DEFBINOP_OP (add, matrix, sparse_complex
 DEFBINOP_OP (sub, matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.array_value () / d);
     }
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -45,17 +45,17 @@ DEFBINOP_OP (add, matrix, sparse_matrix,
 DEFBINOP_OP (sub, matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_matrix, *)
 
 DEFBINOP (div, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.array_value () / d);
     }
diff --git a/src/OPERATORS/op-pm-pm.cc b/src/OPERATORS/op-pm-pm.cc
--- a/src/OPERATORS/op-pm-pm.cc
+++ b/src/OPERATORS/op-pm-pm.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xpow.h"
 
 DEFUNOP (transpose, perm_matrix)
 {
   CAST_UNOP_ARG (const octave_perm_matrix&);
-  return octave_value (v.perm_matrix_value().transpose ());
+  return octave_value (v.perm_matrix_value ().transpose ());
 }
 
 DEFBINOP_OP (mul, perm_matrix, perm_matrix, *)
 
 DEFBINOP (div, perm_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
 
diff --git a/src/OPERATORS/op-pm-scm.cc b/src/OPERATORS/op-pm-scm.cc
--- a/src/OPERATORS/op-pm-scm.cc
+++ b/src/OPERATORS/op-pm-scm.cc
@@ -34,23 +34,23 @@ along with Octave; see the file COPYING.
 #include "ov-cx-sparse.h"
 
 // permutation matrix by sparse matrix ops
 
 DEFBINOP (mul_pm_scm, perm_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () * d);
     }
-  else if (v1.rows() == 1 && v1.columns() == 1)
+  else if (v1.rows () == 1 && v1.columns () == 1)
     return octave_value (v2.sparse_complex_matrix_value ());
   else
     return v1.perm_matrix_value  () * v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_scm, perm_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_complex_matrix&);
@@ -59,23 +59,23 @@ DEFBINOP (ldiv_pm_scm, perm_matrix, spar
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_pm, sparse_complex_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_perm_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       std::complex<double> d = v1.scalar_value ();
 
       return octave_value (d * v2.sparse_matrix_value ());
     }
-  else if (v2.rows() == 1 && v2.columns() == 1)
+  else if (v2.rows () == 1 && v2.columns () == 1)
     return octave_value (v1.sparse_complex_matrix_value ());
   else
     return v1.sparse_complex_matrix_value  () * v2.perm_matrix_value ();
 }
 
 DEFBINOP (div_scm_pm, sparse_complex_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_perm_matrix&);
diff --git a/src/OPERATORS/op-pm-sm.cc b/src/OPERATORS/op-pm-sm.cc
--- a/src/OPERATORS/op-pm-sm.cc
+++ b/src/OPERATORS/op-pm-sm.cc
@@ -77,23 +77,23 @@ DEFBINOP (el_or_pm,  perm_matrix, perm_m
 }
 
 // permutation matrix by sparse matrix ops
 
 DEFBINOP (mul_pm_sm, perm_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_matrix_value () * d);
     }
-  else if (v1.rows() == 1 && v1.columns() == 1)
+  else if (v1.rows () == 1 && v1.columns () == 1)
     return octave_value (v2.sparse_matrix_value ());
   else
     return v1.perm_matrix_value  () * v2.sparse_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_sm, perm_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_matrix&);
@@ -102,23 +102,23 @@ DEFBINOP (ldiv_pm_sm, perm_matrix, spars
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_sm_pm, sparse_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_perm_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       return octave_value (d * v2.sparse_matrix_value ());
     }
-  else if (v2.rows() == 1 && v2.columns() == 1)
+  else if (v2.rows () == 1 && v2.columns () == 1)
     return octave_value (v1.sparse_matrix_value ());
   else
     return v1.sparse_matrix_value  () * v2.perm_matrix_value ();
 }
 
 DEFBINOP (div_sm_pm, sparse_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_perm_matrix&);
diff --git a/src/OPERATORS/op-range.cc b/src/OPERATORS/op-range.cc
--- a/src/OPERATORS/op-range.cc
+++ b/src/OPERATORS/op-range.cc
@@ -42,27 +42,27 @@ along with Octave; see the file COPYING.
 #include "xpow.h"
 
 // range unary ops.
 
 DEFUNOP (not, range)
 {
   CAST_UNOP_ARG (const octave_range&);
 
-  return octave_value (! v.matrix_value());
+  return octave_value (! v.matrix_value ());
 }
 
 DEFUNOP_OP (uplus, range, /* no-op */)
 DEFUNOP_OP (uminus, range, -)
 
 DEFUNOP (transpose, range)
 {
   CAST_UNOP_ARG (const octave_range&);
 
-  return octave_value (v.matrix_value().transpose ());
+  return octave_value (v.matrix_value ().transpose ());
 }
 
 DEFBINOP_OP (addrs, range, scalar, +)
 DEFBINOP_OP (addsr, scalar, range, +)
 DEFBINOP_OP (subrs, range, scalar, -)
 DEFBINOP_OP (subsr, scalar, range, -)
 DEFBINOP_OP (mulrs, range, scalar, *)
 DEFBINOP_OP (mulsr, scalar, range, *)
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -46,17 +46,17 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, scalar, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_complex_matrix, *)
 
 DEFBINOP (div, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v1.scalar_value () / d));
     }
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, scalar, sparse_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_matrix, *)
 
 DEFBINOP (div, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseMatrix (1, 1, v1.scalar_value () / d));
     }
diff --git a/src/OPERATORS/op-sbm-sbm.cc b/src/OPERATORS/op-sbm-sbm.cc
--- a/src/OPERATORS/op-sbm-sbm.cc
+++ b/src/OPERATORS/op-sbm-sbm.cc
@@ -50,17 +50,17 @@ DEFUNOP (uminus, sparse_bool_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
   return octave_value ( - v.sparse_matrix_value ());
 }
 
 DEFUNOP (transpose, sparse_bool_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
-  return octave_value (v.sparse_bool_matrix_value().transpose ());
+  return octave_value (v.sparse_bool_matrix_value ().transpose ());
 }
 
 // sparse bool matrix by sparse bool matrix ops.
 
 DEFBINOP_FN (eq, sparse_bool_matrix, sparse_bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, sparse_bool_matrix, sparse_bool_matrix, mx_el_ne)
 DEFBINOP_FN (el_and, sparse_bool_matrix, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_bool_matrix, sparse_bool_matrix, mx_el_or)
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -64,17 +64,17 @@ DEFBINOPX (pow, sparse_complex_matrix, c
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -66,17 +66,17 @@ DEFBINOP (pow, sparse_complex_matrix, co
                    const octave_complex&);
   return xpow (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
     }
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -65,17 +65,17 @@ DEFBINOPX (pow, sparse_complex_matrix, m
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -74,17 +74,17 @@ DEFBINOP (pow, sparse_complex_matrix, sc
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.scalar_value () / d));
     }
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -55,25 +55,25 @@ along with Octave; see the file COPYING.
 DEFUNOP_OP (not, sparse_complex_matrix, !)
 DEFUNOP_OP (uplus, sparse_complex_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_complex_matrix, -)
 
 DEFUNOP (transpose, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
   return octave_value
-    (v.sparse_complex_matrix_value().transpose (),
+    (v.sparse_complex_matrix_value ().transpose (),
      v.matrix_type ().transpose ());
 }
 
 DEFUNOP (hermitian, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
   return octave_value
-    (v.sparse_complex_matrix_value().hermitian (),
+    (v.sparse_complex_matrix_value ().hermitian (),
      v.matrix_type ().transpose ());
 }
 
 #if 0
 DEFUNOP (incr, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
 
@@ -95,17 +95,17 @@ DEFBINOP_OP (sub, sparse_complex_matrix,
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
@@ -126,17 +126,17 @@ DEFBINOPX (pow, sparse_complex_matrix, s
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -44,17 +44,17 @@ DEFBINOP_OP (add, sparse_complex_matrix,
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
@@ -74,17 +74,17 @@ DEFBINOPX (pow, sparse_complex_matrix, s
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -64,17 +64,17 @@ DEFBINOPX (pow, sparse_matrix, complex_m
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -66,17 +66,17 @@ DEFBINOP (pow, sparse_matrix, complex)
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
   return xpow (v1.matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
     }
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -62,17 +62,17 @@ DEFBINOPX (pow, sparse_matrix, matrix)
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -68,17 +68,17 @@ DEFBINOP (pow, sparse_matrix, scalar)
   else
     return xpow (v1.matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (SparseMatrix(1, 1, v2.scalar_value () / d));
     }
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -44,17 +44,17 @@ DEFBINOP_OP (add, sparse_matrix, sparse_
 DEFBINOP_OP (sub, sparse_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
@@ -74,17 +74,17 @@ DEFBINOPX (pow, sparse_matrix, sparse_co
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 
 DEFUNOP_OP (not, sparse_matrix, !)
 DEFUNOP_OP (uplus, sparse_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_matrix, -)
 
 DEFUNOP (transpose, sparse_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_matrix&);
-  return octave_value (v.sparse_matrix_value().transpose (),
+  return octave_value (v.sparse_matrix_value ().transpose (),
                        v.matrix_type ().transpose ());
 }
 
 // sparse matrix by sparse matrix ops.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_matrix, +)
 
 // DEFBINOP_OP (sub, sparse_matrix, sparse_matrix, -)
@@ -67,17 +67,17 @@ DEFBINOP_OP (add, sparse_matrix, sparse_
   }
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
-  if (v2.rows() == 1 && v2.columns() == 1)
+  if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
@@ -97,17 +97,17 @@ DEFBINOPX (pow, sparse_matrix, sparse_ma
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
-  if (v1.rows() == 1 && v1.columns() == 1)
+  if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.double_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
diff --git a/src/OPERATORS/op-str-str.cc b/src/OPERATORS/op-str-str.cc
--- a/src/OPERATORS/op-str-str.cc
+++ b/src/OPERATORS/op-str-str.cc
@@ -39,17 +39,17 @@ DEFUNOP (transpose, char_matrix_str)
   CAST_UNOP_ARG (const octave_char_matrix_str&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.char_matrix_value().transpose (),
+    return octave_value (v.char_matrix_value ().transpose (),
                          a.is_sq_string () ? '\'' : '"');
 }
 
 // string by string ops.
 
 #define DEFCHARNDBINOP_FN(name, op, t1, t2, e1, e2, f)  \
   BINOPDECL (name, a1, a2) \
   { \
diff --git a/src/OPERATORS/op-struct.cc b/src/OPERATORS/op-struct.cc
--- a/src/OPERATORS/op-struct.cc
+++ b/src/OPERATORS/op-struct.cc
@@ -39,17 +39,17 @@ DEFUNOP (transpose, struct)
   CAST_UNOP_ARG (const octave_struct&);
 
   if (v.ndims () > 2)
     {
       error ("transpose not defined for N-d objects");
       return octave_value ();
     }
   else
-    return octave_value (v.map_value().transpose ());
+    return octave_value (v.map_value ().transpose ());
 }
 
 DEFUNOP (scalar_transpose, scalar_struct)
 {
   CAST_UNOP_ARG (const octave_scalar_struct&);
 
   return octave_value (v.scalar_map_value ());
 }
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -67,18 +67,18 @@ namespace std
   public: 
     T operator() (const T & op1, const T & op2) const { return (op1 ^ op2); }
   };
 }
 #endif
 
 template <typename OP, typename T>
 octave_value
-bitopxx(const OP& op, const std::string& fname,
-        const Array<T>& x, const Array<T>& y)
+bitopxx (const OP& op, const std::string& fname,
+         const Array<T>& x, const Array<T>& y)
 {
   int nelx = x.numel ();
   int nely = y.numel ();
 
   bool is_scalar_op = (nelx == 1 || nely == 1);
 
   dim_vector dvx = x.dims ();
   dim_vector dvy = y.dims ();
@@ -93,48 +93,48 @@ bitopxx(const OP& op, const std::string&
       if (nelx != 1)
         result.resize (dvx);
       else
         result.resize (dvy);
 
       for (int i = 0; i < nelx; i++)
         if (is_scalar_op)
           for (int k = 0; k < nely; k++)
-            result(i+k) = op(x(i), y(k));
+            result(i+k) = op (x(i), y(k));
         else
-          result(i) = op(x(i), y(i));
+          result(i) = op (x(i), y(i));
 
       retval = result;
     }
   else
     error ("%s: size of X and Y must match, or one operand must be a scalar",
-           fname.c_str());
+           fname.c_str ());
 
   return retval;
 }
 
 // Trampoline function, instantiates the proper template above, with
 // reflective information hardwired. We can't hardwire this information
 // in Fbitxxx DEFUNs below, because at that moment, we still don't have
 // information about which integer types we need to instantiate.
 template<typename T>
 octave_value
-bitopx(const std::string& fname, const Array<T>& x, const Array<T>& y)
+bitopx (const std::string& fname, const Array<T>& x, const Array<T>& y)
 {
   if (fname == "bitand")
     return bitopxx (std::bit_and<T>(), fname, x, y);
   if (fname == "bitor")
     return bitopxx (std::bit_or<T>(), fname, x, y);
 
   //else (fname == "bitxor")
   return bitopxx (std::bit_xor<T>(), fname, x, y);
 }
 
 octave_value
-bitop(const std::string& fname, const octave_value_list& args)
+bitop (const std::string& fname, const octave_value_list& args)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       if ((args(0).class_name () == octave_scalar::static_class_name ())
@@ -151,17 +151,17 @@ bitop(const std::string& fname, const oc
                               args(1).class_name () !=
                               octave_bool::static_class_name ());
 
           if (! (arg0_is_int || arg1_is_int))
             {
               uint64NDArray x (args(0).array_value ());
               uint64NDArray y (args(1).array_value ());
               if (! error_state)
-                retval = bitopx (fname, x, y).array_value();
+                retval = bitopx (fname, x, y).array_value ();
             }
           else
             {
               int p = (arg0_is_int ? 1 : 0);
               int q = (arg0_is_int ? 0 : 1);
 
               NDArray dx = args(p).array_value ();
 
@@ -225,17 +225,17 @@ bitop(const std::string& fname, const oc
                        || args(q).type_id () == octave_int8_scalar::static_type_id ())
                 {
                   int8NDArray x (dx);
                   int8NDArray y = args(q).int8_array_value ();
                   if (! error_state)
                     retval = bitopx (fname, x, y);
                 }
               else
-                error ("%s: invalid operand type", fname.c_str());
+                error ("%s: invalid operand type", fname.c_str ());
             }
         }
       else if (args(0).class_name () == args(1).class_name ())
         {
           if (args(0).type_id () == octave_uint64_matrix::static_type_id ()
               || args(0).type_id () == octave_uint64_scalar::static_type_id ())
             {
               uint64NDArray x = args(0).uint64_array_value ();
@@ -295,20 +295,20 @@ bitop(const std::string& fname, const oc
                    || args(0).type_id () == octave_int8_scalar::static_type_id ())
             {
               int8NDArray x = args(0).int8_array_value ();
               int8NDArray y = args(1).int8_array_value ();
               if (! error_state)
                 retval = bitopx (fname, x, y);
             }
           else
-            error ("%s: invalid operand type", fname.c_str());
+            error ("%s: invalid operand type", fname.c_str ());
         }
       else
-        error ("%s: must have matching operand types", fname.c_str());
+        error ("%s: must have matching operand types", fname.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (bitand, args, ,
@@ -710,17 +710,17 @@ The default for @var{type} is @code{uint
     {
       print_usage ();
       return retval;
     }
 
   if (cname == "uint8")
     retval = octave_uint8 (std::numeric_limits<uint8_t>::min ());
   else if (cname == "uint16")
-    retval = octave_uint16 (std::numeric_limits<uint16_t>::min());
+    retval = octave_uint16 (std::numeric_limits<uint16_t>::min ());
   else if (cname == "uint32")
     retval = octave_uint32 (std::numeric_limits<uint32_t>::min ());
   else if (cname == "uint64")
     retval = octave_uint64 (std::numeric_limits<uint64_t>::min ());
   else if (cname == "int8")
     retval = octave_int8 (std::numeric_limits<int8_t>::min ());
   else if (cname == "int16")
     retval = octave_int16 (std::numeric_limits<int16_t>::min ());
diff --git a/src/comment-list.cc b/src/comment-list.cc
--- a/src/comment-list.cc
+++ b/src/comment-list.cc
@@ -83,17 +83,17 @@ octave_comment_buffer::get_comment (void
 {
   return (instance_ok ()) ? instance->do_get_comment () : 0;
 }
 
 void
 octave_comment_buffer::do_append (const std::string& s,
                                   octave_comment_elt::comment_type t)
 {
-  comment_list->append(s, t);
+  comment_list->append (s, t);
 }
 
 octave_comment_list *
 octave_comment_buffer::do_get_comment (void)
 {
   octave_comment_list *retval = 0;
 
   if (comment_list && comment_list->length () > 0)
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -444,49 +444,49 @@ and @var{e} is an integer.  If\n\
         {
           if (args(0).is_real_type ())
             {
               FloatNDArray f;
               FloatNDArray x = args(0).float_array_value ();
               // FIXME -- should E be an int value?
               FloatMatrix e;
               map_2_xlog2 (x, f, e);
-              retval (1) = e;
-              retval (0) = f;
+              retval(1) = e;
+              retval(0) = f;
             }
           else if (args(0).is_complex_type ())
             {
               FloatComplexNDArray f;
               FloatComplexNDArray x = args(0).float_complex_array_value ();
               // FIXME -- should E be an int value?
               FloatNDArray e;
               map_2_xlog2 (x, f, e);
-              retval (1) = e;
-              retval (0) = f;
+              retval(1) = e;
+              retval(0) = f;
             }
         }
       else if (args(0).is_real_type ())
         {
           NDArray f;
           NDArray x = args(0).array_value ();
           // FIXME -- should E be an int value?
           Matrix e;
           map_2_xlog2 (x, f, e);
-          retval (1) = e;
-          retval (0) = f;
+          retval(1) = e;
+          retval(0) = f;
         }
       else if (args(0).is_complex_type ())
         {
           ComplexNDArray f;
           ComplexNDArray x = args(0).complex_array_value ();
           // FIXME -- should E be an int value?
           NDArray e;
           map_2_xlog2 (x, f, e);
-          retval (1) = e;
-          retval (0) = f;
+          retval(1) = e;
+          retval(0) = f;
         }
       else
         gripe_wrong_type_arg ("log2", args(0));
     }
   else
     print_usage ();
 
   return retval;
@@ -1263,25 +1263,25 @@ Given a matrix argument, instead of a ve
 @var{k}-th diagonal of the matrix.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
-    retval = args(0).diag();
+    retval = args(0).diag ();
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
       octave_idx_type k = args(1).int_value ();
 
       if (error_state)
         error ("diag: invalid argument K");
       else
-        retval = args(0).diag(k);
+        retval = args(0).diag (k);
     }
   else if (nargin == 3)
     {
       octave_value arg0 = args(0);
 
       if (arg0.ndims () == 2 && (arg0.rows () == 1 || arg0.columns () == 1))
         {
           octave_idx_type m = args(1).int_value ();
@@ -1298,50 +1298,50 @@ Given a matrix argument, instead of a ve
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%!assert(full (diag ([1; 2; 3])), [1, 0, 0; 0, 2, 0; 0, 0, 3])
-%!assert(diag ([1; 2; 3], 1), [0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0])
-%!assert(diag ([1; 2; 3], 2), [0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0])
-%!assert(diag ([1; 2; 3],-1), [0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0])
-%!assert(diag ([1; 2; 3],-2), [0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0])
-
-%!assert(diag ([1, 0, 0; 0, 2, 0; 0, 0, 3]), [1; 2; 3])
-%!assert(diag ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0], 1), [1; 2; 3])
-%!assert(diag ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0], -1), [1; 2; 3])
-%!assert(diag (ones(1, 0), 2), zeros (2))
-%!assert(diag (1:3, 4, 2), [1, 0; 0, 2; 0, 0; 0, 0])
-
-%!assert(full (diag (single([1; 2; 3]))), single([1, 0, 0; 0, 2, 0; 0, 0, 3]))
-%!assert(diag (single([1; 2; 3]), 1), single([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]))
-%!assert(diag (single([1; 2; 3]), 2), single([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
-%!assert(diag (single([1; 2; 3]),-1), single([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
-%!assert(diag (single([1; 2; 3]),-2), single([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
-
-%!assert(diag (single([1, 0, 0; 0, 2, 0; 0, 0, 3])), single([1; 2; 3]))
-%!assert(diag (single([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), single([1; 2; 3]))
-%!assert(diag (single([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), single([1; 2; 3]))
-
-%!assert(diag (int8([1; 2; 3])), int8([1, 0, 0; 0, 2, 0; 0, 0, 3]))
-%!assert(diag (int8([1; 2; 3]), 1), int8([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]))
-%!assert(diag (int8([1; 2; 3]), 2), int8([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
-%!assert(diag (int8([1; 2; 3]),-1), int8([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
-%!assert(diag (int8([1; 2; 3]),-2), int8([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
-
-%!assert(diag (int8([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8([1; 2; 3]))
-%!assert(diag (int8([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8([1; 2; 3]))
-%!assert(diag (int8([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8([1; 2; 3]))
+%!assert (full (diag ([1; 2; 3])), [1, 0, 0; 0, 2, 0; 0, 0, 3])
+%!assert (diag ([1; 2; 3], 1), [0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0])
+%!assert (diag ([1; 2; 3], 2), [0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0])
+%!assert (diag ([1; 2; 3],-1), [0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0])
+%!assert (diag ([1; 2; 3],-2), [0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0])
+
+%!assert (diag ([1, 0, 0; 0, 2, 0; 0, 0, 3]), [1; 2; 3])
+%!assert (diag ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0], 1), [1; 2; 3])
+%!assert (diag ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0], -1), [1; 2; 3])
+%!assert (diag (ones (1, 0), 2), zeros (2))
+%!assert (diag (1:3, 4, 2), [1, 0; 0, 2; 0, 0; 0, 0])
+
+%!assert (full (diag (single ([1; 2; 3]))), single ([1, 0, 0; 0, 2, 0; 0, 0, 3]))
+%!assert (diag (single ([1; 2; 3]), 1), single ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]))
+%!assert (diag (single ([1; 2; 3]), 2), single ([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
+%!assert (diag (single ([1; 2; 3]),-1), single ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
+%!assert (diag (single ([1; 2; 3]),-2), single ([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
+
+%!assert (diag (single ([1, 0, 0; 0, 2, 0; 0, 0, 3])), single ([1; 2; 3]))
+%!assert (diag (single ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), single ([1; 2; 3]))
+%!assert (diag (single ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), single ([1; 2; 3]))
+
+%!assert (diag (int8 ([1; 2; 3])), int8 ([1, 0, 0; 0, 2, 0; 0, 0, 3]))
+%!assert (diag (int8 ([1; 2; 3]), 1), int8 ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]))
+%!assert (diag (int8 ([1; 2; 3]), 2), int8 ([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
+%!assert (diag (int8 ([1; 2; 3]),-1), int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
+%!assert (diag (int8 ([1; 2; 3]),-2), int8 ([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
+
+%!assert (diag (int8 ([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8 ([1; 2; 3]))
+%!assert (diag (int8 ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8 ([1; 2; 3]))
+%!assert (diag (int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8 ([1; 2; 3]))
 
 ## Test non-square size
-%!assert(diag ([1,2,3], 6, 3), [1 0 0; 0 2 0; 0 0 3; 0 0 0; 0 0 0; 0 0 0])
+%!assert (diag ([1,2,3], 6, 3), [1 0 0; 0 2 0; 0 0 3; 0 0 0; 0 0 0; 0 0 0])
 %!assert (diag (1, 2, 3), [1,0,0; 0,0,0]);
 %!assert (diag ({1}, 2, 3), {1,[],[]; [],[],[]});
 %!assert (diag ({1,2}, 3, 4), {1,[],[],[]; [],2,[],[]; [],[],[],[]});
 
 %% Test input validation
 %!error <Invalid call to diag> diag ()
 %!error <Invalid call to diag> diag (1,2,3,4)
 %!error diag (ones (2), 3, 3)
@@ -1829,17 +1829,17 @@ do_cat (const octave_value_list& xargs, 
             return retval;
 
           int dv_len = dv.length ();
           Array<octave_idx_type> ra_idx (dim_vector (dv_len, 1), 0);
 
           for (int j = 0; j < n_args; j++)
             {
               // Can't fast return here to skip empty matrices as something
-              // like cat(1,[],single([])) must return an empty matrix of
+              // like cat (1,[],single ([])) must return an empty matrix of
               // the right type.
               tmp = do_cat_op (tmp, args (j), ra_idx);
 
               if (error_state)
                 return retval;
 
               dim_vector dv_tmp = args (j).dims ();
 
@@ -2161,17 +2161,17 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!function ret = __testcat (t1, t2, tr, cmplx)
-%!  assert (cat (1, cast ([], t1), cast([], t2)), cast ([], tr));
+%!  assert (cat (1, cast ([], t1), cast ([], t2)), cast ([], tr));
 %! 
 %!  assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
 %!  assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
 %!  assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
 %!  assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
 %!  assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
 %!  assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
 %!  assert (cat (2, cast ([1, 2], t1), cast (3, t2)), cast ([1, 2, 3], tr));
@@ -2335,17 +2335,17 @@ do_permute (const octave_value_list& arg
   return retval;
 }
 
 DEFUN (permute, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} permute (@var{A}, @var{perm})\n\
 Return the generalized transpose for an N-D array object @var{A}.\n\
 The permutation vector @var{perm} must contain the elements\n\
-@code{1:ndims(A)} (in any order, but each element must appear only once).\n\
+@code{1:ndims (A)} (in any order, but each element must appear only once).\n\
 @seealso{ipermute}\n\
 @end deftypefn")
 {
   return do_permute (args, false);
 }
 
 DEFUN (ipermute, args, ,
   "-*- texinfo -*-\n\
@@ -2604,17 +2604,17 @@ Note that Octave tends to crop unused me
 for sparse objects.  There are some cases of user created sparse objects\n\
 where the value returned by @dfn{nzmax} will not be the same as @dfn{nnz},\n\
 but in general they will give the same result.\n\
 @seealso{sparse, spalloc}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length() == 1)
+  if (args.length () == 1)
     retval = args(0).nzmax ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (rows, args, ,
@@ -3085,64 +3085,64 @@ complex ([1, 2], [3, 4])\n\
           const SparseMatrix im_val = im.sparse_matrix_value ();
 
           if (!error_state)
             {
               if (re.numel () == 1)
                 {
                   SparseComplexMatrix result;
                   if (re_val.nnz () == 0)
-                    result = Complex(0, 1) * SparseComplexMatrix (im_val);
+                    result = Complex (0, 1) * SparseComplexMatrix (im_val);
                   else
                     {
                       result = SparseComplexMatrix (im_val.dims (), re_val (0));
                       octave_idx_type nr = im_val.rows ();
                       octave_idx_type nc = im_val.cols ();
 
                       for (octave_idx_type j = 0; j < nc; j++)
                         {
                           octave_idx_type off = j * nr;
-                          for (octave_idx_type i = im_val.cidx(j);
-                               i < im_val.cidx(j + 1); i++)
-                            result.data (im_val.ridx(i) + off) =
-                              result.data (im_val.ridx(i) + off) +
+                          for (octave_idx_type i = im_val.cidx (j);
+                               i < im_val.cidx (j + 1); i++)
+                            result.data (im_val.ridx (i) + off) =
+                              result.data (im_val.ridx (i) + off) +
                               Complex (0, im_val.data (i));
                         }
                     }
                   retval = octave_value (new octave_sparse_complex_matrix (result));
                 }
               else if (im.numel () == 1)
                 {
                   SparseComplexMatrix result;
                   if (im_val.nnz () == 0)
                     result = SparseComplexMatrix (re_val);
                   else
                     {
-                      result = SparseComplexMatrix (re_val.rows(), re_val.cols(), Complex(0, im_val (0)));
+                      result = SparseComplexMatrix (re_val.rows (), re_val.cols (), Complex (0, im_val (0)));
                       octave_idx_type nr = re_val.rows ();
                       octave_idx_type nc = re_val.cols ();
 
                       for (octave_idx_type j = 0; j < nc; j++)
                         {
                           octave_idx_type off = j * nr;
-                          for (octave_idx_type i = re_val.cidx(j);
-                               i < re_val.cidx(j + 1); i++)
-                            result.data (re_val.ridx(i) + off) =
-                              result.data (re_val.ridx(i) + off) +
+                          for (octave_idx_type i = re_val.cidx (j);
+                               i < re_val.cidx (j + 1); i++)
+                            result.data (re_val.ridx (i) + off) =
+                              result.data (re_val.ridx (i) + off) +
                               re_val.data (i);
                         }
                     }
                   retval = octave_value (new octave_sparse_complex_matrix (result));
                 }
               else
                 {
                   if (re_val.dims () == im_val.dims ())
                     {
-                      SparseComplexMatrix result = SparseComplexMatrix(re_val)
-                        + Complex(0, 1) * SparseComplexMatrix (im_val);
+                      SparseComplexMatrix result = SparseComplexMatrix (re_val)
+                        + Complex (0, 1) * SparseComplexMatrix (im_val);
                       retval = octave_value (new octave_sparse_complex_matrix (result));
                     }
                   else
                     error ("complex: dimension mismatch");
                 }
             }
         }
       else if (re.is_single_type () || im.is_single_type ())
@@ -4082,17 +4082,17 @@ floating point arithmetic, @code{eps} is
 $2.2204\\times10^{-16}$ for double precision and $1.1921\\times10^{-7}$\n\
 @end tex\n\
 @ifnottex\n\
 2.2204e-16 for double precision and 1.1921e-07\n\
 @end ifnottex\n\
 for single precision.\n\
 \n\
 When called with no arguments, return a scalar with the value\n\
-@code{eps(1.0)}.\n\
+@code{eps (1.0)}.\n\
 Given a single argument @var{x}, return the distance between @var{x} and\n\
 the next largest value.\n\
 When called with more than one argument the first two arguments are taken as\n\
 the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
 @end deftypefn")
@@ -4103,17 +4103,17 @@ either \"double\" or \"single\".\n\
   if (nargin == 1 && ! args(0).is_string ())
     {
       if (args(0).is_single_type ())
         {
           float val = args(0).float_value ();
 
           if (! error_state)
             {
-              val  = ::fabsf(val);
+              val = ::fabsf (val);
               if (xisnan (val) || xisinf (val))
                 retval = fill_matrix (octave_value ("single"),
                                       lo_ieee_nan_value (),
                                       lo_ieee_float_nan_value (), "eps");
               else if (val < FLT_MIN)
                 retval = fill_matrix (octave_value ("single"), 0e0,
                                       powf (2.0, -149e0), "eps");
               else
@@ -4128,17 +4128,17 @@ either \"double\" or \"single\".\n\
             }
         }
       else
         {
           double val = args(0).double_value ();
 
           if (! error_state)
             {
-              val  = ::fabs(val);
+              val = ::fabs (val);
               if (xisnan (val) || xisinf (val))
                 retval = fill_matrix (octave_value_list (),
                                       lo_ieee_nan_value (),
                                       lo_ieee_float_nan_value (), "eps");
               else if (val < DBL_MIN)
                 retval = fill_matrix (octave_value_list (),
                                       pow (2.0, -1074e0), 0e0, "eps");
               else
@@ -4236,17 +4236,17 @@ floating point arithmetic, @code{realmax
 $1.7977\\times10^{308}$ for double precision and $3.4028\\times10^{38}$\n\
 @end tex\n\
 @ifnottex\n\
 1.7977e+308 for double precision and 3.4028e+38\n\
 @end ifnottex\n\
 for single precision.\n\
 \n\
 When called with no arguments, return a scalar with the value\n\
-@code{realmax(\"double\")}.\n\
+@code{realmax (\"double\")}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
 @seealso{realmin, intmax, bitmax}\n\
 @end deftypefn")
@@ -4269,17 +4269,17 @@ IEEE floating point arithmetic, @code{re
 $2.2251\\times10^{-308}$ for double precision and $1.1755\\times10^{-38}$\n\
 @end tex\n\
 @ifnottex\n\
 2.2251e-308 for double precision and 1.1755e-38\n\
 @end ifnottex\n\
 for single precision.\n\
 \n\
 When called with no arguments, return a scalar with the value\n\
-@code{realmin(\"double\")}.\n\
+@code{realmin (\"double\")}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
 @seealso{realmax, intmin}\n\
 @end deftypefn")
@@ -5643,17 +5643,17 @@ At least one argument is required.\n\
                                      octave_value::op_el_or_eq, args);
 }
 
 static double tic_toc_timestamp = -1.0;
 
 DEFUN (tic, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} tic ()\n\
-@deftypefnx  {Built-in Function} {@var{id} =} tic ()\n\
+@deftypefnx {Built-in Function} {@var{id} =} tic ()\n\
 @deftypefnx {Built-in Function} {} toc ()\n\
 @deftypefnx {Built-in Function} {} toc (@var{id})\n\
 @deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
 Set or check a wall-clock timer.  Calling @code{tic} without an\n\
 output argument sets the internal timer state.  Subsequent calls\n\
 to @code{toc} return the number of seconds since the timer was set.\n\
 For example,\n\
 \n\
@@ -5710,19 +5710,19 @@ doing nothing at all.\n\
   else
     tic_toc_timestamp = tmp;
 
   return retval;
 }
 
 DEFUN (toc, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} toc ()\n\
+@deftypefn  {Built-in Function} {} toc ()\n\
 @deftypefnx {Built-in Function} {} toc (@var{id})\n\
-@deftypefnx {Built-in Function} {@var{val} = } toc (@dots{})\n\
+@deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
 See tic.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   double start_time = tic_toc_timestamp;
@@ -5769,18 +5769,18 @@ See tic.\n\
     }
 
   return retval;
 }
 
 /*
 %!shared id
 %! id = tic ();
-%!assert (isa (id, "uint64"));
-%!assert (isa (toc (id), "double"));
+%!assert (isa (id, "uint64"))
+%!assert (isa (toc (id), "double"))
 */
 
 DEFUN (cputime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{total}, @var{user}, @var{system}] =} cputime ();\n\
 Return the CPU time used by your Octave session.  The first output is\n\
 the total time spent executing your process and is equal to the sum of\n\
 second and third outputs, which are the number of CPU seconds spent\n\
@@ -5833,19 +5833,19 @@ CPU time used is nonzero.\n\
   fraction = ticks % CLOCKS_PER_SEC;
   seconds = ticks / CLOCKS_PER_SEC;
 
   sys = static_cast<double> (seconds) + static_cast<double>(fraction) /
     static_cast<double>(CLOCKS_PER_SEC);
 
 #endif
 
-  retval (2) = sys;
-  retval (1) = usr;
-  retval (0) = sys + usr;
+  retval(2) = sys;
+  retval(1) = usr;
+  retval(0) = sys + usr;
 
   return retval;
 }
 
 DEFUN (sort, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
@@ -5927,17 +5927,17 @@ ordered lists.\n\
 
   octave_value arg = args(0);
 
   int dim = 0;
   if (nargin > 1)
     {
       if (args(1).is_string ())
         {
-          std::string mode = args(1).string_value();
+          std::string mode = args(1).string_value ();
           if (mode == "ascend")
             smode = ASCENDING;
           else if (mode == "descend")
             smode = DESCENDING;
           else
             {
               error ("sort: MODE must be either \"ascend\" or \"descend\"");
               return retval;
@@ -5955,17 +5955,17 @@ ordered lists.\n\
           return retval;
         }
 
       if (! args(2).is_string ())
         {
           error ("sort: MODE must be a string");
           return retval;
         }
-      std::string mode = args(2).string_value();
+      std::string mode = args(2).string_value ();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
         {
           error ("sort: MODE must be either \"ascend\" or \"descend\"");
           return retval;
@@ -5988,18 +5988,18 @@ ordered lists.\n\
     }
 
   if (return_idx)
     {
       retval.resize (2);
 
       Array<octave_idx_type> sidx;
 
-      retval (0) = arg.sort (sidx, dim, smode);
-      retval (1) = idx_vector (sidx, dv(dim)); // No checking, the extent is known.
+      retval(0) = arg.sort (sidx, dim, smode);
+      retval(1) = idx_vector (sidx, dv(dim)); // No checking, the extent is known.
     }
   else
     retval(0) = arg.sort (dim, smode);
 
   return retval;
 }
 
 /*
@@ -6197,17 +6197,17 @@ Undocumented internal function.\n\
   if (nargin < 1 || nargin > 2 || (nargin == 2 && ! args(1).is_string ()))
     {
       print_usage ();
       return retval;
     }
 
   if (nargin > 1)
     {
-      std::string mode = args(1).string_value();
+      std::string mode = args(1).string_value ();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
         {
           error ("__sort_rows_idx__: MODE must be either \"ascend\" or \"descend\"");
           return retval;
@@ -6456,17 +6456,17 @@ do_accumarray_sum (const idx_vector& idx
                    octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
     error ("accumarray: index out of range");
 
-  NDT retval (dim_vector (n, 1), T());
+  NDT retval (dim_vector (n, 1), T ());
 
   if (vals.numel () == 1)
     retval.idx_add (idx, vals (0));
   else if (vals.numel () == idx.length (n))
     retval.idx_add (idx, vals);
   else
     error ("accumarray: dimensions mismatch");
 
@@ -6649,17 +6649,17 @@ do_accumdim_sum (const idx_vector& idx, 
 
   if (dim < 0)
     dim = vals.dims ().first_non_singleton ();
   else if (dim >= rdv.length ())
     rdv.resize (dim+1, 1);
 
   rdv(dim) = n;
 
-  NDT retval (rdv, T());
+  NDT retval (rdv, T ());
 
   if (idx.length () != vals_dim(dim))
     error ("accumdim: dimension mismatch");
 
   retval.idx_add_nd (idx, vals, dim);
 
   return retval;
 }
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -204,31 +204,31 @@ parse_dbfunction_params (const char *who
       idx = 0;
       symbol_name = get_user_code ()->name ();
     }
   else if (args(0).is_map ())
     {
       // Problem because parse_dbfunction_params() can only pass out a
       // single function
     }
-  else if (args(0).is_string())
+  else if (args(0).is_string ())
     {
       symbol_name = args(0).string_value ();
       if (error_state)
         return;
       idx = 1;
     }
   else
     error ("%s: invalid parameter specified", who);
 
   for (int i = idx; i < nargin; i++ )
     {
       if (args(i).is_string ())
         {
-          int line = atoi (args(i).string_value().c_str ());
+          int line = atoi (args(i).string_value ().c_str ());
           if (error_state)
             break;
           lines[list_idx++] = line;
         }
       else if (args(i).is_map ())
         octave_stdout << who << ": accepting a struct" << std::endl;
       else
         {
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -189,12 +189,12 @@ void defun_isargout (int nargout, int no
                 isargout[k++] = true;
             }
         }
     }
   else
     for (int i = 0; i < nout; i++)
       isargout[i] = true;
 
-  for (int i = std::max(nargout, 1); i < nout; i++)
+  for (int i = std::max (nargout, 1); i < nout; i++)
     isargout[i] = false;
 }
 
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -337,17 +337,17 @@ do_clear_function (const std::string& fc
 
 static void
 clear (octave_shlib& oct_file)
 {
   if (oct_file.number_of_functions_loaded () > 1)
     {
       warning_with_id ("Octave:reload-forces-clear",
                        "reloading %s clears the following functions:",
-                       oct_file.file_name().c_str ());
+                       oct_file.file_name ().c_str ());
 
       octave_shlib_list::remove (oct_file, do_clear_function);
     }
   else
     octave_shlib_list::remove (oct_file, symbol_table::clear_dld_function);
 }
 
 octave_function *
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -833,56 +833,56 @@ Reissue a previous error as defined by @
 that must contain at least the 'message' and 'identifier' fields.  @var{err}\n\
 can also contain a field 'stack' that gives information on the assumed\n\
 location of the error.  Typically @var{err} is returned from\n\
 @code{lasterror}.\n\
 @seealso{lasterror, lasterr, error}\n\
 @end deftypefn")
 {
   octave_value retval;
-  int nargin = args.length();
+  int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
   else
     {
       const octave_scalar_map err = args(0).scalar_map_value ();
 
       if (! error_state)
         {
           if (err.contains ("message") && err.contains ("identifier"))
             {
-              std::string msg = err.contents("message").string_value ();
-              std::string id = err.contents("identifier").string_value ();
-              int len = msg.length();
+              std::string msg = err.contents ("message").string_value ();
+              std::string id = err.contents ("identifier").string_value ();
+              int len = msg.length ();
 
               std::string file;
               std::string nm;
               int l = -1;
               int c = -1;
 
               octave_map err_stack = initialize_last_error_stack ();
 
               if (err.contains ("stack"))
                 {
-                  err_stack = err.contents("stack").map_value ();
+                  err_stack = err.contents ("stack").map_value ();
 
                   if (err_stack.numel () > 0)
                     {
                       if (err_stack.contains ("file"))
-                        file = err_stack.contents("file")(0).string_value ();
+                        file = err_stack.contents ("file")(0).string_value ();
 
                       if (err_stack.contains ("name"))
-                        nm = err_stack.contents("name")(0).string_value ();
+                        nm = err_stack.contents ("name")(0).string_value ();
 
                       if (err_stack.contains ("line"))
-                        l = err_stack.contents("line")(0).nint_value ();
+                        l = err_stack.contents ("line")(0).nint_value ();
 
                       if (err_stack.contains ("column"))
-                        c = err_stack.contents("column")(0).nint_value ();
+                        c = err_stack.contents ("column")(0).nint_value ();
                     }
                 }
 
               // Ugh.
               char *tmp_msg = strsave (msg.c_str ());
               if (tmp_msg[len-1] == '\n')
                 {
                   if (len > 1)
@@ -987,17 +987,17 @@ maybe_extract_message_id (const std::str
           // For compatibility with Matlab, an identifier must contain
           // ':', but not at the beginning or the end, and it must not
           // contain '%' (even if it is not a valid conversion
           // operator) or whitespace.
 
           if (arg1.find_first_of ("% \f\n\r\t\v") == std::string::npos
               && arg1.find (':') != std::string::npos
               && arg1[0] != ':'
-              && arg1[arg1.length()-1] != ':')
+              && arg1[arg1.length ()-1] != ':')
             {
               if (nargin > 1)
                 {
                   id = arg1;
 
                   nargs.resize (nargin-1);
 
                   for (int i = 1; i < nargin; i++)
@@ -1552,17 +1552,17 @@ as input.  Any fields of @var{err} that 
 unspecified fields are initialized with default values.\n\
 \n\
 If @code{lasterror} is called with the argument \"reset\", all fields are\n\
 set to their default values.\n\
 @seealso{lasterr}\n\
 @end deftypefn")
 {
   octave_value retval;
-  int nargin = args.length();
+  int nargin = args.length ();
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   error_state = 0;
 
   if (nargin < 2)
     {
@@ -1570,82 +1570,82 @@ set to their default values.\n\
 
       err.assign ("message", Vlast_error_message);
       err.assign ("identifier", Vlast_error_id);
 
       err.assign ("stack", octave_value (Vlast_error_stack));
 
       if (nargin == 1)
         {
-          if (args(0).is_string())
+          if (args(0).is_string ())
             {
               if (args(0).string_value () == "reset")
                 {
-                  Vlast_error_message = std::string();
-                  Vlast_error_id = std::string();
+                  Vlast_error_message = std::string ();
+                  Vlast_error_id = std::string ();
 
                   Vlast_error_stack = initialize_last_error_stack ();
                 }
               else
-                error("lasterror: unrecognized string argument");
+                error ("lasterror: unrecognized string argument");
             }
           else if (args(0).is_map ())
             {
               octave_scalar_map new_err = args(0).scalar_map_value ();
               std::string new_error_message;
               std::string new_error_id;
               std::string new_error_file;
               std::string new_error_name;
               int new_error_line = -1;
               int new_error_column = -1;
 
               if (! error_state && new_err.contains ("message"))
                 {
                   const std::string tmp =
-                    new_err.getfield("message").string_value ();
+                    new_err.getfield ("message").string_value ();
                   new_error_message = tmp;
                 }
 
               if (! error_state && new_err.contains ("identifier"))
                 {
                   const std::string tmp =
-                    new_err.getfield("identifier").string_value ();
+                    new_err.getfield ("identifier").string_value ();
                   new_error_id = tmp;
                 }
 
               if (! error_state && new_err.contains ("stack"))
                 {
                   octave_scalar_map new_err_stack =
-                    new_err.getfield("stack").scalar_map_value ();
+                    new_err.getfield ("stack").scalar_map_value ();
 
                   if (! error_state && new_err_stack.contains ("file"))
                     {
                       const std::string tmp =
-                        new_err_stack.getfield("file").string_value ();
+                        new_err_stack.getfield ("file").string_value ();
                       new_error_file = tmp;
                     }
 
                   if (! error_state && new_err_stack.contains ("name"))
                     {
                       const std::string tmp =
-                        new_err_stack.getfield("name").string_value ();
+                        new_err_stack.getfield ("name").string_value ();
                       new_error_name = tmp;
                     }
 
                   if (! error_state && new_err_stack.contains ("line"))
                     {
                       const int tmp =
-                        new_err_stack.getfield("line").nint_value ();
+                        new_err_stack.getfield ("line").nint_value ();
                       new_error_line = tmp;
                     }
 
                   if (! error_state && new_err_stack.contains ("column"))
                     {
                       const int tmp =
-                        new_err_stack.getfield("column").nint_value ();
+                        new_err_stack.getfield ("column").nint_value ();
                       new_error_column = tmp;
                     }
                 }
 
               if (! error_state)
                 {
                   Vlast_error_message = new_error_message;
                   Vlast_error_id = new_error_id;
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -231,17 +231,17 @@ public:
 #if defined (HAVE_FRAMEWORK_OPENGL) && defined (HAVE_GLUTESSCALLBACK_THREEDOTS)
   typedef GLvoid (CALLBACK *fcn) (...);
 #else
   typedef void (CALLBACK *fcn) (void);
 #endif
 
 public:
 
-  opengl_tesselator (void) : glu_tess (0), fill() { init (); }
+  opengl_tesselator (void) : glu_tess (0), fill () { init (); }
 
   virtual ~opengl_tesselator (void)
     { if (glu_tess) gluDeleteTess (glu_tess); }
 
   void begin_polygon (bool filled = true)
     {
       gluTessProperty (glu_tess, GLU_TESS_BOUNDARY_ONLY,
                        (filled ? GL_FALSE : GL_TRUE));
@@ -411,42 +411,42 @@ public:
       : opengl_tesselator (), renderer (r),
         color_mode (cmode), light_mode (lmode), index (idx),
         first (true), tmp_vdata ()
   { }
 
 protected:
   void begin (GLenum type)
     {
-      //printf("patch_tesselator::begin (%d)\n", type);
+      //printf ("patch_tesselator::begin (%d)\n", type);
       first = true;
 
       if (color_mode == 2 || light_mode == 2)
         glShadeModel (GL_SMOOTH);
       else
         glShadeModel (GL_FLAT);
 
       if (is_filled ())
         renderer->set_polygon_offset (true, 1+index);
 
       glBegin (type);
     }
 
   void end (void)
     {
-      //printf("patch_tesselator::end\n");
+      //printf ("patch_tesselator::end\n");
       glEnd ();
       renderer->set_polygon_offset (false);
     }
 
   void vertex (void *data)
     {
       vertex_data::vertex_data_rep *v
           = reinterpret_cast<vertex_data::vertex_data_rep *> (data);
-      //printf("patch_tesselator::vertex (%g, %g, %g)\n", v->coords(0), v->coords(1), v->coords(2));
+      //printf ("patch_tesselator::vertex (%g, %g, %g)\n", v->coords(0), v->coords(1), v->coords(2));
 
       // FIXME: why did I need to keep the first vertex of the face
       // in JHandles? I think it's related to the fact that the
       // tessellation process might re-order the vertices, such that
       // the first one you get here might not be the first one of the face;
       // but I can't figure out the actual reason.
       if (color_mode > 0 && (first || color_mode == 2))
         {
@@ -476,17 +476,17 @@ protected:
       glVertex3dv (v->coords.data ());
 
       first = false;
     }
 
   void combine (GLdouble xyz[3], void *data[4], GLfloat w[4],
                 void **out_data)
     {
-      //printf("patch_tesselator::combine\n");
+      //printf ("patch_tesselator::combine\n");
 
       vertex_data::vertex_data_rep *v[4];
       int vmax = 4;
 
       for (int i = 0; i < 4; i++)
         {
           v[i] = reinterpret_cast<vertex_data::vertex_data_rep *> (data[i]);
 
@@ -503,24 +503,24 @@ protected:
       vv(1) = xyz[1];
       vv(2) = xyz[2];
 
       if (v[0]->color.numel ())
         {
           cc.resize (1, 3, 0.0);
           for (int ic = 0; ic < 3; ic++)
             for (int iv = 0; iv < vmax; iv++)
-              cc(ic) += (w[iv] * v[iv]->color(ic));
+              cc(ic) += (w[iv] * v[iv]->color (ic));
         }
 
       if (v[0]->normal.numel () > 0)
         {
           for (int in = 0; in < 3; in++)
             for (int iv = 0; iv < vmax; iv++)
-              nn(in) += (w[iv] * v[iv]->normal(in));
+              nn(in) += (w[iv] * v[iv]->normal (in));
         }
 
       for (int iv = 0; iv < vmax; iv++)
         aa += (w[iv] * v[iv]->alpha);
 
       vertex_data new_v (vv, cc, nn, aa, v[0]->ambient, v[0]->diffuse,
                          v[0]->specular, v[0]->specular_exp);
       tmp_vdata.push_back (new_v);
@@ -547,16 +547,19 @@ private:
 void
 opengl_renderer::draw (const graphics_object& go, bool toplevel)
 {
   if (! go.valid_object ())
     return;
 
   const base_properties& props = go.get_properties ();
 
+  if (! toolkit)
+    toolkit = props.get_toolkit ();
+
   if (go.isa ("figure"))
     draw_figure (dynamic_cast<const figure::properties&> (props));
   else if (go.isa ("axes"))
     draw_axes (dynamic_cast<const axes::properties&> (props));
   else if (go.isa ("line"))
     draw_line (dynamic_cast<const line::properties&> (props));
   else if (go.isa ("surface"))
     draw_surface (dynamic_cast<const surface::properties&> (props));
@@ -582,18 +585,16 @@ opengl_renderer::draw (const graphics_ob
       warning ("opengl_renderer: cannot render object of type `%s'",
                props.graphics_object_name ().c_str ());
     }
 }
 
 void
 opengl_renderer::draw_figure (const figure::properties& props)
 {
-  toolkit = props.get_toolkit ();
-
   // Initialize OpenGL context
 
   init_gl_context (props.is___enhanced__ (), props.get_color_rgb ());
 
   // Draw children
 
   draw (props.get_all_children (), false);
 }
@@ -601,18 +602,16 @@ opengl_renderer::draw_figure (const figu
 void
 opengl_renderer::draw_uipanel (const uipanel::properties& props,
                                const graphics_object& go)
 {
   graphics_object fig = go.get_ancestor ("figure");
   const figure::properties& figProps =
     dynamic_cast<const figure::properties&> (fig.get_properties ());
 
-  toolkit = figProps.get_toolkit ();
-
   // Initialize OpenGL context 
 
   init_gl_context (figProps.is___enhanced__ (),
                    props.get_backgroundcolor_rgb ());
 
   // Draw children
 
   draw (props.get_all_children (), false);
@@ -637,17 +636,17 @@ opengl_renderer::init_gl_context (bool e
   else
     {
       glDisable (GL_BLEND);
       glDisable (GL_LINE_SMOOTH);
     }
 
   // Clear background
 
-  if (c.length() >= 3)
+  if (c.length () >= 3)
     {
       glClearColor (c(0), c(1), c(2), 1);
       glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
     }
 }
 
 void
 opengl_renderer::render_grid (const std::string& gridstyle,
@@ -803,17 +802,17 @@ opengl_renderer::setup_opengl_transforma
 #else
   int vw[4];
 #endif
 
   glGetIntegerv (GL_VIEWPORT, vw);
 
   glMatrixMode (GL_MODELVIEW);
   glLoadIdentity ();
-  glScaled(1, 1, -1);
+  glScaled (1, 1, -1);
   glMultMatrixd (x_mat1.data ());
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
   glOrtho (0, vw[2], vw[3], 0, xZ1, xZ2);
   glMultMatrixd (x_mat2.data ());
   glMatrixMode (GL_MODELVIEW);
 
   glClear (GL_DEPTH_BUFFER_BIT);
@@ -1012,61 +1011,61 @@ opengl_renderer::draw_axes_x_grid (const
                      yPlane, yPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 0, (zstate != AXE_DEPTH_DIR));
 
       // tick marks
       if (tick_along_z)
         {
           render_tickmarks (xticks, x_min, x_max, ypTick, ypTick,
                             zpTick, zpTickN, 0., 0.,
-                            signum(zpTick-zpTickN)*fz*xticklen,
+                            signum (zpTick-zpTickN)*fz*xticklen,
                             0, mirror);
         }
       else
         {
           render_tickmarks (xticks, x_min, x_max, ypTick, ypTickN,
                             zpTick, zpTick, 0.,
-                            signum(ypTick-ypTickN)*fy*xticklen,
+                            signum (ypTick-ypTickN)*fy*xticklen,
                             0., 0, mirror);
         }
 
       // tick texts
       if (xticklabels.numel () > 0)
         {
           int halign = (xstate == AXE_HORZ_DIR ? 1 : (xyzSym ? 0 : 2));
           int valign = (xstate == AXE_VERT_DIR ? 1 : (x2Dtop ? 0 : 2));
 
           if (tick_along_z)
             render_ticktexts (xticks, xticklabels, x_min, x_max, ypTick,
-                              zpTick+signum(zpTick-zpTickN)*fz*xtickoffset,
+                              zpTick+signum (zpTick-zpTickN)*fz*xtickoffset,
                               0, halign, valign, wmax, hmax);
           else
             render_ticktexts (xticks, xticklabels, x_min, x_max,
-                              ypTick+signum(ypTick-ypTickN)*fy*xtickoffset,
+                              ypTick+signum (ypTick-ypTickN)*fy*xtickoffset,
                               zpTick, 0, halign, valign, wmax, hmax);
         }
 
       // minor grid lines
       if (do_xminorgrid)
         render_grid (minorgridstyle, xmticks, x_min, x_max,
                      yPlane, yPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 0, (zstate != AXE_DEPTH_DIR));
 
       // minor tick marks
       if (do_xminortick)
         {
           if (tick_along_z)
             render_tickmarks (xmticks, x_min, x_max, ypTick, ypTick,
                               zpTick, zpTickN, 0., 0.,
-                              signum(zpTick-zpTickN)*fz*xticklen/2,
+                              signum (zpTick-zpTickN)*fz*xticklen/2,
                               0, mirror);
           else
             render_tickmarks (xmticks, x_min, x_max, ypTick, ypTickN,
                               zpTick, zpTick, 0.,
-                              signum(ypTick-ypTickN)*fy*xticklen/2,
+                              signum (ypTick-ypTickN)*fy*xticklen/2,
                               0., 0, mirror);
         }
 
       gh_manager::get_object (props.get_xlabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_xlabel ()).set ("visible", "off");
 }
@@ -1119,59 +1118,59 @@ opengl_renderer::draw_axes_y_grid (const
         render_grid (gridstyle, yticks, y_min, y_max,
                      xPlane, xPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 1, (zstate != AXE_DEPTH_DIR));
 
       // tick marks
       if (tick_along_z)
         render_tickmarks (yticks, y_min, y_max, xpTick, xpTick,
                           zpTick, zpTickN, 0., 0.,
-                          signum(zpTick-zpTickN)*fz*yticklen,
+                          signum (zpTick-zpTickN)*fz*yticklen,
                           1, mirror);
       else
         render_tickmarks (yticks, y_min, y_max, xpTick, xpTickN,
                           zpTick, zpTick,
-                          signum(xPlaneN-xPlane)*fx*yticklen,
+                          signum (xPlaneN-xPlane)*fx*yticklen,
                           0., 0., 1, mirror);
 
       // tick texts
       if (yticklabels.numel () > 0)
         {
           int halign = (ystate == AXE_HORZ_DIR
                         ? 1 : (!xyzSym || y2Dright ? 0 : 2));
           int valign = (ystate == AXE_VERT_DIR ? 1 : 2);
 
           if (tick_along_z)
             render_ticktexts (yticks, yticklabels, y_min, y_max, xpTick,
-                              zpTick+signum(zpTick-zpTickN)*fz*ytickoffset,
+                              zpTick+signum (zpTick-zpTickN)*fz*ytickoffset,
                               1, halign, valign, wmax, hmax);
           else
             render_ticktexts (yticks, yticklabels, y_min, y_max,
-                              xpTick+signum(xpTick-xpTickN)*fx*ytickoffset,
+                              xpTick+signum (xpTick-xpTickN)*fx*ytickoffset,
                               zpTick, 1, halign, valign, wmax, hmax);
         }
 
       // minor grid lines
       if (do_yminorgrid)
         render_grid (minorgridstyle, ymticks, y_min, y_max,
                      xPlane, xPlaneN, layer2Dtop ? zPlaneN : zPlane,
                      zPlaneN, 1, (zstate != AXE_DEPTH_DIR));
 
       // minor tick marks
       if (do_yminortick)
         {
           if (tick_along_z)
             render_tickmarks (ymticks, y_min, y_max, xpTick, xpTick,
                               zpTick, zpTickN, 0., 0.,
-                              signum(zpTick-zpTickN)*fz*yticklen/2,
+                              signum (zpTick-zpTickN)*fz*yticklen/2,
                               1, mirror);
           else
             render_tickmarks (ymticks, y_min, y_max, xpTick, xpTickN,
                               zpTick, zpTick,
-                              signum(xpTick-xpTickN)*fx*yticklen/2,
+                              signum (xpTick-xpTickN)*fx*yticklen/2,
                               0., 0., 1, mirror);
         }
 
       gh_manager::get_object (props.get_ylabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_ylabel ()).set ("visible", "off");
 }
@@ -1216,64 +1215,64 @@ opengl_renderer::draw_axes_z_grid (const
                      xPlane, xPlaneN, yPlane, yPlaneN, 2, true);
 
       // tick marks
       if (xySym)
         {
           if (xisinf (fy))
             render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlane,
                               yPlane, yPlane,
-                              signum(xPlaneN-xPlane)*fx*zticklen,
+                              signum (xPlaneN-xPlane)*fx*zticklen,
                               0., 0., 2, mirror);
           else
             render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlaneN,
                               yPlane, yPlane, 0.,
-                              signum(yPlane-yPlaneN)*fy*zticklen,
+                              signum (yPlane-yPlaneN)*fy*zticklen,
                               0., 2, false);
         }
       else
         {
           if (xisinf (fx))
             render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlane,
                               yPlaneN, yPlane, 0.,
-                              signum(yPlaneN-yPlane)*fy*zticklen,
+                              signum (yPlaneN-yPlane)*fy*zticklen,
                               0., 2, mirror);
           else
             render_tickmarks (zticks, z_min, z_max, xPlane, xPlane,
                               yPlaneN, yPlane,
-                              signum(xPlane-xPlaneN)*fx*zticklen,
+                              signum (xPlane-xPlaneN)*fx*zticklen,
                               0., 0., 2, false);
         }
 
       // FIXME: tick texts
       if (zticklabels.numel () > 0)
         {
           int halign = 2;
           int valign = (zstate == AXE_VERT_DIR ? 1 : (zSign ? 3 : 2));
 
           if (xySym)
             {
               if (xisinf (fy))
                 render_ticktexts (zticks, zticklabels, z_min, z_max,
-                                  xPlaneN+signum(xPlaneN-xPlane)*fx*ztickoffset,
+                                  xPlaneN+signum (xPlaneN-xPlane)*fx*ztickoffset,
                                   yPlane, 2, halign, valign, wmax, hmax);
               else
                 render_ticktexts (zticks, zticklabels, z_min, z_max, xPlaneN,
-                                  yPlane+signum(yPlane-yPlaneN)*fy*ztickoffset,
+                                  yPlane+signum (yPlane-yPlaneN)*fy*ztickoffset,
                                   2, halign, valign, wmax, hmax);
             }
           else
             {
               if (xisinf (fx))
                 render_ticktexts (zticks, zticklabels, z_min, z_max, xPlane,
-                                  yPlaneN+signum(yPlaneN-yPlane)*fy*ztickoffset,
+                                  yPlaneN+signum (yPlaneN-yPlane)*fy*ztickoffset,
                                   2, halign, valign, wmax, hmax);
               else
                 render_ticktexts (zticks, zticklabels, z_min, z_max,
-                                  xPlane+signum(xPlane-xPlaneN)*fx*ztickoffset,
+                                  xPlane+signum (xPlane-xPlaneN)*fx*ztickoffset,
                                   yPlaneN, 2, halign, valign, wmax, hmax);
             }
         }
 
       // minor grid lines
       if (do_zminorgrid)
         render_grid (minorgridstyle, zmticks, z_min, z_max,
                      xPlane, xPlaneN, yPlane, yPlaneN, 2, true);
@@ -1281,35 +1280,35 @@ opengl_renderer::draw_axes_z_grid (const
       // minor tick marks
       if (do_zminortick)
         {
           if (xySym)
             {
               if (xisinf (fy))
                 render_tickmarks (zmticks, z_min, z_max, xPlaneN, xPlane,
                                   yPlane, yPlane,
-                                  signum(xPlaneN-xPlane)*fx*zticklen/2,
+                                  signum (xPlaneN-xPlane)*fx*zticklen/2,
                                   0., 0., 2, mirror);
               else
                 render_tickmarks (zmticks, z_min, z_max, xPlaneN, xPlaneN,
                                   yPlane, yPlane, 0.,
-                                  signum(yPlane-yPlaneN)*fy*zticklen/2,
+                                  signum (yPlane-yPlaneN)*fy*zticklen/2,
                                   0., 2, false);
             }
           else
             {
               if (xisinf (fx))
                 render_tickmarks (zmticks, z_min, z_max, xPlane, xPlane,
                                   yPlaneN, yPlane, 0.,
-                                  signum(yPlaneN-yPlane)*fy*zticklen/2,
+                                  signum (yPlaneN-yPlane)*fy*zticklen/2,
                                   0., 2, mirror);
               else
                 render_tickmarks (zmticks, z_min, z_max, xPlane, xPlane,
                                   yPlaneN, yPlaneN,
-                                  signum(xPlane-xPlaneN)*fx*zticklen/2,
+                                  signum (xPlane-xPlaneN)*fx*zticklen/2,
                                   0., 0., 2, false);
             }
         }
 
       gh_manager::get_object (props.get_zlabel ()).set ("visible", "on");
     }
   else
     gh_manager::get_object (props.get_zlabel ()).set ("visible", "off");
@@ -2100,26 +2099,26 @@ opengl_renderer::draw_patch (const patch
   // int vmax = v.columns ();
   int nf = f.rows ();
   int fcmax = f.columns ();
 
   bool has_z = (v.columns () > 2);
   bool has_facecolor = false;
   bool has_facealpha = false;
 
-  int fc_mode = ((props.facecolor_is("none")
+  int fc_mode = ((props.facecolor_is ("none")
                   || props.facecolor_is_rgb ()) ? 0 :
-                 (props.facecolor_is("flat") ? 1 : 2));
+                 (props.facecolor_is ("flat") ? 1 : 2));
   int fl_mode = (props.facelighting_is ("none") ? 0 :
                  (props.facelighting_is ("flat") ? 1 : 2));
   int fa_mode = (props.facealpha_is_double () ? 0 :
                  (props.facealpha_is ("flat") ? 1 : 2));
-  int ec_mode = ((props.edgecolor_is("none")
+  int ec_mode = ((props.edgecolor_is ("none")
                   || props.edgecolor_is_rgb ()) ? 0 :
-                 (props.edgecolor_is("flat") ? 1 : 2));
+                 (props.edgecolor_is ("flat") ? 1 : 2));
   int el_mode = (props.edgelighting_is ("none") ? 0 :
                  (props.edgelighting_is ("flat") ? 1 : 2));
   int ea_mode = (props.edgealpha_is_double () ? 0 :
                  (props.edgealpha_is ("flat") ? 1 : 2));
 
   Matrix fcolor = props.get_facecolor_rgb ();
   Matrix ecolor = props.get_edgecolor_rgb ();
 
@@ -2465,17 +2464,17 @@ opengl_renderer::draw_text (const text::
   const Matrix bbox = props.get_extent_matrix ();
 
   // FIXME: handle margin and surrounding box
   bool blend = glIsEnabled (GL_BLEND);
 
   glEnable (GL_BLEND);
   glEnable (GL_ALPHA_TEST);
   glRasterPos3d (pos(0), pos(1), pos.numel () > 2 ? pos(2) : 0.0);
-  glBitmap(0, 0, 0, 0, bbox(0), bbox(1), 0);
+  glBitmap (0, 0, 0, 0, bbox(0), bbox(1), 0);
   glDrawPixels (bbox(2), bbox(3),
                 GL_RGBA, GL_UNSIGNED_BYTE, props.get_pixels ().data ());
   glDisable (GL_ALPHA_TEST);
   if (! blend)
     glDisable (GL_BLEND);
 
 }
 
@@ -2549,17 +2548,17 @@ opengl_renderer::draw_image (const image
       if (im_ymin < ymin)
         i0 += (ymin - im_ymin)/nor_dy + 1;
       if (im_ymax > ymax)
         i1 -= (im_ymax - ymax)/nor_dy;
     }
   else // clip to viewport
     {
       GLfloat vp[4];
-      glGetFloatv(GL_VIEWPORT, vp);
+      glGetFloatv (GL_VIEWPORT, vp);
       // FIXME -- actually add the code to do it!
 
     }
 
   if (i0 >= i1 || j0 >= j1)
     return;
 
   glPixelZoom (pix_dx, -pix_dy);
@@ -2858,17 +2857,17 @@ opengl_renderer::make_marker_list (const
       glBegin (GL_LINES);
       glVertex2f (-sz/2, 0);
       glVertex2f (sz/2, 0);
       glVertex2f (0, -sz/2);
       glVertex2f (0, sz/2);
       glEnd ();
       break;
     case 'x':
-      glBegin(GL_LINES);
+      glBegin (GL_LINES);
       glVertex2f (-sz/2, -sz/2);
       glVertex2f (sz/2, sz/2);
       glVertex2f (-sz/2, sz/2);
       glVertex2f (sz/2, -sz/2);
       glEnd ();
       break;
     case '*':
       glBegin (GL_LINES);
@@ -2883,45 +2882,45 @@ opengl_renderer::make_marker_list (const
       glEnd ();
       break;
     case '.':
       {
         double ang_step = M_PI / 5;
 
         glBegin (GL_POLYGON);
         for (double ang = 0; ang < (2*M_PI); ang += ang_step)
-          glVertex2d (sz*cos(ang)/3, sz*sin(ang)/3);
+          glVertex2d (sz*cos (ang)/3, sz*sin (ang)/3);
         glEnd ();
       }
       break;
     case 's':
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2d (-sz/2, -sz/2);
       glVertex2d (-sz/2, sz/2);
       glVertex2d (sz/2, sz/2);
       glVertex2d (sz/2, -sz/2);
-      glEnd();
+      glEnd ();
       break;
     case 'o':
       {
         double ang_step = M_PI / 5;
 
         glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
         for (double ang = 0; ang < (2*M_PI); ang += ang_step)
-          glVertex2d (sz*cos(ang)/2, sz*sin(ang)/2);
+          glVertex2d (sz*cos (ang)/2, sz*sin (ang)/2);
         glEnd ();
       }
       break;
     case 'd':
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2d (0, -sz/2);
       glVertex2d (sz/2, 0);
       glVertex2d (0, sz/2);
       glVertex2d (-sz/2, 0);
-      glEnd();
+      glEnd ();
       break;
     case 'v':
       glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
       glVertex2f (0, sz/2);
       glVertex2f (sz/2, -sz/2);
       glVertex2f (-sz/2, -sz/2);
       glEnd ();
       break;
@@ -2945,40 +2944,40 @@ opengl_renderer::make_marker_list (const
       glVertex2f (sz/2, -sz/2);
       glVertex2f (sz/2, sz/2);
       glEnd ();
       break;
     case 'p':
       {
         double ang;
         double r;
-        double dr = 1.0 - sin(M_PI/10)/sin(3*M_PI/10)*1.02;
+        double dr = 1.0 - sin (M_PI/10)/sin (3*M_PI/10)*1.02;
 
         glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
         for (int i = 0; i < 2*5; i++)
           {
             ang = (-0.5 + double(i+1)/5) * M_PI;
-            r = 1.0 - (dr * fmod(double(i+1), 2.0));
-            glVertex2d (sz*r*cos(ang)/2, sz*r*sin(ang)/2);
+            r = 1.0 - (dr * fmod (double(i+1), 2.0));
+            glVertex2d (sz*r*cos (ang)/2, sz*r*sin (ang)/2);
           }
         glEnd ();
       }
       break;
     case 'h':
       {
         double ang;
         double r;
-        double dr = 1.0 - 0.5/sin(M_PI/3)*1.02;
+        double dr = 1.0 - 0.5/sin (M_PI/3)*1.02;
 
         glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
         for (int i = 0; i < 2*6; i++)
           {
             ang = (0.5 + double(i+1)/6.0) * M_PI;
-            r = 1.0 - (dr * fmod(double(i+1), 2.0));
-            glVertex2d (sz*r*cos(ang)/2, sz*r*sin(ang)/2);
+            r = 1.0 - (dr * fmod (double(i+1), 2.0));
+            glVertex2d (sz*r*cos (ang)/2, sz*r*sin (ang)/2);
           }
         glEnd ();
       }
       break;
     default:
       warning ("opengl_renderer: unsupported marker `%s'",
                marker.c_str ());
       break;
diff --git a/src/gl-render.h b/src/gl-render.h
--- a/src/gl-render.h
+++ b/src/gl-render.h
@@ -85,16 +85,17 @@ protected:
   virtual void draw_patch (const patch::properties& props);
   virtual void draw_hggroup (const hggroup::properties& props);
   virtual void draw_text (const text::properties& props);
   virtual void draw_image (const image::properties& props);
   virtual void draw_uipanel (const uipanel::properties& props,
                              const graphics_object& go);
 
   virtual void init_gl_context (bool enhanced, const Matrix& backgroundColor);
+  virtual void setup_opengl_transformation (const axes::properties& props);
 
   virtual void set_color (const Matrix& c);
   virtual void set_polygon_offset (bool on, double offset = 0.0);
   virtual void set_linewidth (float w);
   virtual void set_linestyle (const std::string& s, bool stipple = false);
   virtual void set_clipbox (double x1, double x2, double y1, double y2,
                             double z1, double z2);
   virtual void set_clipping (bool on);
@@ -163,18 +164,16 @@ private:
               | (z < zmin ? 1 : 0) << 4
               | (z > zmax ? 1 : 0) << 5
               | (is_nan_or_inf (x, y, z) ? 0 : 1) << 6);
     }
 
   unsigned int make_marker_list (const std::string& m, double size,
                                  bool filled) const;
 
-  void setup_opengl_transformation (const axes::properties& props);
-
   void draw_axes_planes (const axes::properties& props);
   void draw_axes_boxes (const axes::properties& props);
 
   void draw_axes_x_grid (const axes::properties& props);
   void draw_axes_y_grid (const axes::properties& props);
   void draw_axes_z_grid (const axes::properties& props);
 
   void draw_axes_children (const axes::properties& props);
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1032,37 +1032,37 @@ radio_values::values_as_cell (void) cons
   return retval;
 }
 
 bool
 color_values::str2rgb (std::string str)
 {
   double tmp_rgb[3] = {0, 0, 0};
   bool retval = true;
-  unsigned int len = str.length();
+  unsigned int len = str.length ();
 
   std::transform (str.begin (), str.end (), str.begin (), tolower);
 
-  if (str.compare(0, len, "blue", 0, len) == 0)
+  if (str.compare (0, len, "blue", 0, len) == 0)
     tmp_rgb[2] = 1;
-  else if (str.compare(0, len, "black", 0, len) == 0
-           || str.compare(0, len, "k", 0, len) == 0)
+  else if (str.compare (0, len, "black", 0, len) == 0
+           || str.compare (0, len, "k", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = tmp_rgb[2] = 0;
-  else if (str.compare(0, len, "red", 0, len) == 0)
+  else if (str.compare (0, len, "red", 0, len) == 0)
     tmp_rgb[0] = 1;
-  else if (str.compare(0, len, "green", 0, len) == 0)
+  else if (str.compare (0, len, "green", 0, len) == 0)
     tmp_rgb[1] = 1;
-  else if (str.compare(0, len, "yellow", 0, len) == 0)
+  else if (str.compare (0, len, "yellow", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = 1;
-  else if (str.compare(0, len, "magenta", 0, len) == 0)
+  else if (str.compare (0, len, "magenta", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[2] = 1;
-  else if (str.compare(0, len, "cyan", 0, len) == 0)
+  else if (str.compare (0, len, "cyan", 0, len) == 0)
     tmp_rgb[1] = tmp_rgb[2] = 1;
-  else if (str.compare(0, len, "white", 0, len) == 0
-           || str.compare(0, len, "w", 0, len) == 0)
+  else if (str.compare (0, len, "white", 0, len) == 0
+           || str.compare (0, len, "w", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = tmp_rgb[2] = 1;
   else
     retval = false;
 
   if (retval)
     {
       for (int i = 0; i < 3; i++)
         xrgb(i) = tmp_rgb[i];
@@ -1118,17 +1118,17 @@ color_property::do_set (const octave_val
            get_name ().c_str ());
     }
   else if (val.is_numeric_type ())
     {
       Matrix m = val.matrix_value ();
 
       if (m.numel () == 3)
         {
-          color_values col (m (0), m (1), m(2));
+          color_values col (m(0), m(1), m(2));
           if (! error_state)
             {
               if (current_type != color_t || col != color_val)
                 {
                   color_val = col;
                   current_type = color_t;
                   return true;
                 }
@@ -1266,17 +1266,17 @@ array_property::is_equal (const octave_v
                   for (int i = 0; flag && i < data.numel (); i++) \
                     if (d1[i] != d2[i]) \
                       flag = false; \
                   \
                   return flag; \
                 } \
             }
 
-          if (data.is_double_type() || data.is_bool_type ())
+          if (data.is_double_type () || data.is_bool_type ())
             CHECK_ARRAY_EQUAL (double, , NDArray)
           else if (data.is_single_type ())
             CHECK_ARRAY_EQUAL (float, float_, FloatNDArray)
           else if (data.is_int8_type ())
             CHECK_ARRAY_EQUAL (octave_int8, int8_, int8NDArray)
           else if (data.is_int16_type ())
             CHECK_ARRAY_EQUAL (octave_int16, int16_, int16NDArray)
           else if (data.is_int32_type ())
@@ -1423,17 +1423,17 @@ callback_property::validate (const octav
   // case 5: empty matrix
 
   if (v.is_function_handle ())
     return true;
   else if (v.is_string ())
     // complete validation will be done at execution-time
     return true;
   else if (v.is_cell () && v.length () > 0
-           && (v.rows() == 1 || v.columns () == 1)
+           && (v.rows () == 1 || v.columns () == 1)
            && v.cell_value ()(0).is_function_handle ())
     return true;
   else if (v.is_empty ())
     return true;
 
   return false;
 }
 
@@ -1978,17 +1978,17 @@ graphics_object::set (const octave_value
 
 // Set properties given in two cell arrays containing names and values.
 void
 graphics_object::set (const Array<std::string>& names,
                       const Cell& values, octave_idx_type row)
 {
   if (names.numel () != values.columns ())
     {
-      error("set: number of names must match number of value columns (%d != %d)",
+      error ("set: number of names must match number of value columns (%d != %d)",
             names.numel (), values.columns ());
     }
 
   octave_idx_type k = names.columns ();
 
   for (octave_idx_type column = 0; column < k; column++)
     {
       caseless_str name = names(column);
@@ -3958,39 +3958,39 @@ axes::properties::sync_positions (void)
            std::vector<bool> l_aligned, b_aligned, r_aligned, t_aligned;
            for (octave_idx_type i = 0; i < kids.numel (); i++)
              {
                graphics_object go = gh_manager::get_object (kids(i));
                if (go.isa ("axes"))
                  {
                    axes::properties& props =
                      dynamic_cast<axes::properties&> (go.get_properties ());
-                   if (props.autopos_tag_is("subplot"))
+                   if (props.autopos_tag_is ("subplot"))
                      {
                        Matrix outpos = go.get ("outerposition").matrix_value ();
-                       bool l_align=(std::abs (outpos(0)-ref_outbox(0)) < 1e-15);
-                       bool b_align=(std::abs (outpos(1)-ref_outbox(1)) < 1e-15);
-                       bool r_align=(std::abs (outpos(0)+outpos(2)-ref_outbox(2)) < 1e-15);
-                       bool t_align=(std::abs (outpos(1)+outpos(3)-ref_outbox(3)) < 1e-15);
+                       bool l_align = (std::abs (outpos(0)-ref_outbox(0)) < 1e-15);
+                       bool b_align = (std::abs (outpos(1)-ref_outbox(1)) < 1e-15);
+                       bool r_align = (std::abs (outpos(0)+outpos(2)-ref_outbox(2)) < 1e-15);
+                       bool t_align = (std::abs (outpos(1)+outpos(3)-ref_outbox(3)) < 1e-15);
                        if (l_align || b_align || r_align || t_align)
                          {
-                           aligned.push_back(kids(i));
-                           l_aligned.push_back(l_align);
-                           b_aligned.push_back(b_align);
-                           r_aligned.push_back(r_align);
-                           t_aligned.push_back(t_align);
+                           aligned.push_back (kids(i));
+                           l_aligned.push_back (l_align);
+                           b_aligned.push_back (b_align);
+                           r_aligned.push_back (r_align);
+                           t_aligned.push_back (t_align);
                            // FIXME: the temporarily deleted tags should be
                            //        protected from interrupts
                            props.set_autopos_tag ("none");
                          }
                      }
                  }
              }
            // Determine a minimum box which aligns the subplots
-           Matrix ref_box(1, 4, 0.);
+           Matrix ref_box (1, 4, 0.);
            ref_box(2) = 1.;
            ref_box(3) = 1.;
            for (size_t i = 0; i < aligned.size (); i++)
              {
                graphics_object go = gh_manager::get_object (aligned[i]);
                axes::properties& props =
                  dynamic_cast<axes::properties&> (go.get_properties ());
                Matrix linset = props.get_looseinset ().matrix_value ();
@@ -4279,17 +4279,17 @@ axes::properties::set_defaults (base_gra
   ytickmode = "auto";
   ztickmode = "auto";
   xticklabel = "";
   yticklabel = "";
   zticklabel = "";
   xticklabelmode = "auto";
   yticklabelmode = "auto";
   zticklabelmode = "auto";
-  color = "none";
+  color = color_values ("white");
   xcolor = color_values ("black");
   ycolor = color_values ("black");
   zcolor = color_values ("black");
   xscale = "linear";
   yscale = "linear";
   zscale = "linear";
   xdir = "normal";
   ydir = "normal";
@@ -4535,17 +4535,17 @@ translate (ColumnVector& v, double x, do
   v(0) += x;
   v(1) += y;
   v(2) += z;
 }
 
 inline void
 normalize (ColumnVector& v)
 {
-  double fact = 1.0/sqrt(v(0)*v(0)+v(1)*v(1)+v(2)*v(2));
+  double fact = 1.0 / sqrt (v(0)*v(0)+v(1)*v(1)+v(2)*v(2));
   scale (v, fact, fact, fact);
 }
 
 inline double
 dot (const ColumnVector& v1, const ColumnVector& v2)
 {
   return (v1(0)*v2(0)+v1(1)*v2(1)+v1(2)*v2(2));
 }
@@ -4574,25 +4574,25 @@ unit_cube (void)
       1,0,0,1,
       0,1,0,1,
       0,0,1,1,
       1,1,0,1,
       1,0,1,1,
       0,1,1,1,
       1,1,1,1};
   Matrix m (4, 8);
-  memcpy (m.fortran_vec (), data, sizeof(double)*32);
+  memcpy (m.fortran_vec (), data, sizeof (double)*32);
   return m;
 }
 
 inline ColumnVector
 cam2xform (const Array<double>& m)
 {
   ColumnVector retval (4, 1.0);
-  memcpy (retval.fortran_vec (), m.fortran_vec (), sizeof(double)*3);
+  memcpy (retval.fortran_vec (), m.fortran_vec (), sizeof (double)*3);
   return retval;
 }
 
 inline RowVector
 xform2cam (const ColumnVector& v)
 {
   return v.extract_n (0, 3).transpose ();
 }
@@ -4613,17 +4613,17 @@ axes::properties::update_camera (void)
   double zo = zlimits(zd > 0 ? 0 : 1);
 
   Matrix pb  = get_plotboxaspectratio ().matrix_value ();
 
   bool autocam = (camerapositionmode_is ("auto")
                   && cameratargetmode_is ("auto")
                   && cameraupvectormode_is ("auto")
                   && cameraviewanglemode_is ("auto"));
-  bool dowarp = (autocam && dataaspectratiomode_is("auto")
+  bool dowarp = (autocam && dataaspectratiomode_is ("auto")
                  && plotboxaspectratiomode_is ("auto"));
 
   ColumnVector c_eye (xform_vector ());
   ColumnVector c_center (xform_vector ());
   ColumnVector c_upv (xform_vector ());
 
   if (cameratargetmode_is ("auto"))
     {
@@ -4635,27 +4635,27 @@ axes::properties::update_camera (void)
     }
   else
     c_center = cam2xform (get_cameratarget ().matrix_value ());
 
   if (camerapositionmode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0), el = tview(1);
-      double d = 5*sqrt(pb(0)*pb(0)+pb(1)*pb(1)+pb(2)*pb(2));
+      double d = 5 * sqrt (pb(0)*pb(0)+pb(1)*pb(1)+pb(2)*pb(2));
 
       if (el == 90 || el == -90)
-        c_eye(2) = d*signum(el);
+        c_eye(2) = d*signum (el);
       else
         {
           az *= M_PI/180.0;
           el *= M_PI/180.0;
-          c_eye(0) = d*cos(el)*sin(az);
-          c_eye(1) = -d*cos(el)*cos(az);
-          c_eye(2) = d*sin(el);
+          c_eye(0) = d * cos (el) * sin (az);
+          c_eye(1) = -d* cos (el) * cos (az);
+          c_eye(2) = d * sin (el);
         }
       c_eye(0) = c_eye(0)*(xlimits(1)-xlimits(0))/(xd*pb(0))+c_center(0);
       c_eye(1) = c_eye(1)*(ylimits(1)-ylimits(0))/(yd*pb(1))+c_center(1);
       c_eye(2) = c_eye(2)*(zlimits(1)-zlimits(0))/(zd*pb(2))+c_center(2);
 
       cameraposition = xform2cam (c_eye);
     }
   else
@@ -4664,19 +4664,19 @@ axes::properties::update_camera (void)
   if (cameraupvectormode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0), el = tview(1);
 
       if (el == 90 || el == -90)
         {
           c_upv(0) =
-            -signum(el)*sin(az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
+            -signum (el) *sin (az*M_PI/180.0)*(xlimits(1)-xlimits(0))/pb(0);
           c_upv(1) =
-            signum(el)*cos(az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
+            signum (el) * cos (az*M_PI/180.0)*(ylimits(1)-ylimits(0))/pb(1);
         }
       else
         c_upv(2) = 1;
 
       cameraupvector = xform2cam (c_upv);
     }
   else
     c_upv = cam2xform (get_cameraupvector ().matrix_value ());
@@ -4703,17 +4703,17 @@ axes::properties::update_camera (void)
   translate (c_center, -c_eye(0), -c_eye(1), -c_eye(2));
 
   ColumnVector F (c_center), f (F), UP (c_upv);
   normalize (f);
   normalize (UP);
 
   if (std::abs (dot (f, UP)) > 1e-15)
     {
-      double fa = 1/sqrt(1-f(2)*f(2));
+      double fa = 1 / sqrt(1-f(2)*f(2));
       scale (UP, fa, fa, fa);
     }
 
   ColumnVector s = cross (f, UP);
   ColumnVector u = cross (s, f);
 
   scale (x_view, 1, 1, -1);
   Matrix l = xform_matrix ();
@@ -4861,17 +4861,17 @@ axes::properties::update_axes_layout (vo
         xPlane = (dir(0) > 0 ? x_max : x_min);
       else
         xPlane = (dir(1) < 0 ? x_max : x_min);
     }
   else
     xPlane = (dir(2) < 0 ? x_min : x_max);
 
   xPlaneN = (xPlane == x_min ? x_max : x_min);
-  fx = (x_max-x_min)/sqrt(dir(0)*dir(0)+dir(1)*dir(1));
+  fx = (x_max-x_min) / sqrt (dir(0)*dir(0)+dir(1)*dir(1));
 
   p1 = xform.transform ((x_min+x_max)/2, y_min, (z_min+z_max)/2, false);
   p2 = xform.transform ((x_min+x_max)/2, y_max, (z_min+z_max)/2, false);
   dir(0) = xround (p2(0)-p1(0));
   dir(1) = xround (p2(1)-p1(1));
   dir(2) = (p2(2)-p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     ystate = AXE_DEPTH_DIR;
@@ -4889,21 +4889,21 @@ axes::properties::update_axes_layout (vo
         yPlane = (dir(0) > 0 ? y_max : y_min);
       else
         yPlane = (dir(1) < 0 ? y_max : y_min);
     }
   else
     yPlane = (dir(2) < 0 ? y_min : y_max);
 
   yPlaneN = (yPlane == y_min ? y_max : y_min);
-  fy = (y_max-y_min)/sqrt(dir(0)*dir(0)+dir(1)*dir(1));
-
-  p1 = xform.transform((x_min+x_max)/2, (y_min+y_max)/2, z_min, false);
-  p2 = xform.transform((x_min+x_max)/2, (y_min+y_max)/2, z_max, false);
-  dir(0) = xround(p2(0)-p1(0));
+  fy = (y_max-y_min) / sqrt (dir(0)*dir(0)+dir(1)*dir(1));
+
+  p1 = xform.transform ((x_min+x_max)/2, (y_min+y_max)/2, z_min, false);
+  p2 = xform.transform ((x_min+x_max)/2, (y_min+y_max)/2, z_max, false);
+  dir(0) = xround (p2(0)-p1(0));
   dir(1) = xround (p2(1)-p1(1));
   dir(2) = (p2(2)-p1(2));
   if (dir(0) == 0 && dir(1) == 0)
     zstate = AXE_DEPTH_DIR;
   else if (dir(2) == 0)
     {
       if (dir(0) == 0)
         zstate = AXE_VERT_DIR;
@@ -4917,17 +4917,17 @@ axes::properties::update_axes_layout (vo
         zPlane = (dir(0) > 0 ? z_min : z_max);
       else
         zPlane = (dir(1) < 0 ? z_min : z_max);
     }
   else
     zPlane = (dir(2) < 0 ? z_min : z_max);
 
   zPlaneN = (zPlane == z_min ? z_max : z_min);
-  fz = (z_max-z_min)/sqrt(dir(0)*dir(0)+dir(1)*dir(1));
+  fz = (z_max-z_min) / sqrt (dir(0)*dir(0)+dir(1)*dir(1));
 
   unwind_protect frame;
   frame.protect_var (updating_axes_layout);
   updating_axes_layout = true;
 
   xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
   zSign = (zd*(zPlane-zPlaneN) <= 0);
   xyzSym = zSign ? xySym : !xySym;
@@ -4967,17 +4967,17 @@ axes::properties::update_axes_layout (vo
         zpTick = zPlaneN;
         layer2Dtop = true;
       }
     else
       zpTick = zPlane;
   }
 
   Matrix viewmat = get_view ().matrix_value ();
-  nearhoriz = std::abs(viewmat(1)) <= 5;
+  nearhoriz = std::abs (viewmat(1)) <= 5;
 
   update_ticklength ();
 }
 
 void
 axes::properties::update_ticklength (void)
 {
   bool mode2d = (((xstate > AXE_DEPTH_DIR ? 1 : 0) +
@@ -5074,19 +5074,19 @@ axes::properties::update_xlabel_position
                                    get_xlim ().matrix_value ());
 
       double wmax = ext(0), hmax = ext(1), angle = 0;
       ColumnVector p =
         graphics_xform::xform_vector ((xpTickN+xpTick)/2, ypTick, zpTick);
 
       bool tick_along_z = nearhoriz || xisinf (fy);
       if (tick_along_z)
-        p(2) += (signum(zpTick-zpTickN)*fz*xtickoffset);
+        p(2) += (signum (zpTick-zpTickN)*fz*xtickoffset);
       else
-        p(1) += (signum(ypTick-ypTickN)*fy*xtickoffset);
+        p(1) += (signum (ypTick-ypTickN)*fy*xtickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (xstate)
         {
           case AXE_ANY_DIR:
             p(0) += (xyzSym ? wmax : -wmax);
             p(1) += hmax;
@@ -5165,19 +5165,19 @@ axes::properties::update_ylabel_position
                                    get_ylim ().matrix_value ());
 
       double wmax = ext(0), hmax = ext(1), angle = 0;
       ColumnVector p =
         graphics_xform::xform_vector (xpTick, (ypTickN+ypTick)/2, zpTick);
 
       bool tick_along_z = nearhoriz || xisinf (fx);
       if (tick_along_z)
-        p(2) += (signum(zpTick-zpTickN)*fz*ytickoffset);
+        p(2) += (signum (zpTick-zpTickN)*fz*ytickoffset);
       else
-        p(0) += (signum(xpTick-xpTickN)*fx*ytickoffset);
+        p(0) += (signum (xpTick-xpTickN)*fx*ytickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (ystate)
         {
           case AXE_ANY_DIR:
             p(0) += (!xyzSym ? wmax : -wmax);
             p(1) += hmax;
@@ -5259,28 +5259,28 @@ axes::properties::update_zlabel_position
       double wmax = ext(0), hmax = ext(1), angle = 0;
       ColumnVector p;
 
       if (xySym)
         {
           p = graphics_xform::xform_vector (xPlaneN, yPlane,
                                             (zpTickN+zpTick)/2);
           if (xisinf (fy))
-            p(0) += (signum(xPlaneN-xPlane)*fx*ztickoffset);
+            p(0) += (signum (xPlaneN-xPlane)*fx*ztickoffset);
           else
-            p(1) += (signum(yPlane-yPlaneN)*fy*ztickoffset);
+            p(1) += (signum (yPlane-yPlaneN)*fy*ztickoffset);
         }
       else
         {
           p = graphics_xform::xform_vector (xPlane, yPlaneN,
                                             (zpTickN+zpTick)/2);
           if (xisinf (fx))
-            p(1) += (signum(yPlaneN-yPlane)*fy*ztickoffset);
+            p(1) += (signum (yPlaneN-yPlane)*fy*ztickoffset);
           else
-            p(0) += (signum(xPlane-xPlaneN)*fx*ztickoffset);
+            p(0) += (signum (xPlane-xPlaneN)*fx*ztickoffset);
         }
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (zstate)
         {
           case AXE_ANY_DIR:
             if (camAuto)
@@ -5354,17 +5354,17 @@ axes::properties::update_title_position 
           ext = get_ticklabel_extents (get_xtick ().matrix_value (),
                                        get_xticklabel ().all_strings (),
                                        get_xlim ().matrix_value ());
           p(1) -= ext(1);
         }
 
       p = xform.untransform (p(0), p(1), p(2), true);
 
-      title_props.set_position (p.extract_n(0, 3).transpose ());
+      title_props.set_position (p.extract_n (0, 3).transpose ());
       title_props.set_positionmode ("auto");
     }
 }
 
 void
 axes::properties::update_autopos (const std::string& elem_type)
 {
   if (elem_type == "xlabel")
@@ -5624,17 +5624,17 @@ axes::properties::get_extent (bool with_
           else
             {
               Matrix text_ext = text_props.get_extent_matrix ();
 
               bool ignore_horizontal = false;
               bool ignore_vertical = false;
               if (only_text_height)
                 {
-                  double text_rotation = text_props.get_rotation();
+                  double text_rotation = text_props.get_rotation ();
                   if (text_rotation == 0. || text_rotation == 180.)
                       ignore_horizontal = true;
                   else if (text_rotation == 90. || text_rotation == 270.)
                       ignore_vertical = true;
                 }
 
               if (! ignore_horizontal)
                 {
@@ -5672,19 +5672,19 @@ axes::properties::set_units (const octav
 }
 
 void
 axes::properties::update_units (const caseless_str& old_units)
 {
   graphics_object obj = gh_manager::get_object (get_parent ());
   Matrix parent_bb = obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
   caseless_str new_units = get_units ();
-  position.set (octave_value (convert_position (get_position().matrix_value(), old_units, new_units, parent_bb)), false);
-  outerposition.set (octave_value (convert_position (get_outerposition().matrix_value(), old_units, new_units, parent_bb)), false);
-  tightinset.set (octave_value (convert_position (get_tightinset().matrix_value(), old_units, new_units, parent_bb)), false);
+  position.set (octave_value (convert_position (get_position ().matrix_value (), old_units, new_units, parent_bb)), false);
+  outerposition.set (octave_value (convert_position (get_outerposition ().matrix_value (), old_units, new_units, parent_bb)), false);
+  tightinset.set (octave_value (convert_position (get_tightinset ().matrix_value (), old_units, new_units, parent_bb)), false);
 }
 
 void
 axes::properties::set_fontunits (const octave_value& v)
 {
   if (! error_state)
     {
       caseless_str old_fontunits = get_fontunits ();
@@ -5710,17 +5710,17 @@ axes::properties::update_fontunits (cons
 
 double
 axes::properties::get_fontsize_points (double box_pix_height) const
 {
   double fs = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
-    parent_height = get_boundingbox (true).elem(3);
+    parent_height = get_boundingbox (true).elem (3);
 
   return convert_font_size (fs, get_fontunits (), "points", parent_height);
 }
 
 ColumnVector
 graphics_xform::xform_vector (double x, double y, double z)
 {
   return ::xform_vector (x, y, z);
@@ -6163,17 +6163,17 @@ axes::properties::get_ticklabel_extents 
       if (limits(0) <= val && val <= limits(1))
         {
 #ifdef HAVE_FREETYPE
           ext = text_renderer.get_extent (ticklabels(i));
           wmax = std::max (wmax, ext(0));
           hmax = std::max (hmax, ext(1));
 #else
           //FIXME: find a better approximation
-          int len = ticklabels(i).length();
+          int len = ticklabels(i).length ();
           wmax = std::max (wmax, 0.5*fontsize*len);
           hmax = fontsize;
 #endif
         }
     }
 
   ext(0) = wmax;
   ext(1) = hmax;
@@ -6281,34 +6281,34 @@ axes::update_axis_limits (const std::str
   double max_neg = -octave_Inf;
 
   char update_type = 0;
 
   Matrix limits;
   double val;
 
 #define FIX_LIMITS \
-  if (limits.numel() == 4) \
+  if (limits.numel () == 4) \
     { \
       val = limits(0); \
       if (! (xisinf (val) || xisnan (val))) \
         min_val = val; \
       val = limits(1); \
       if (! (xisinf (val) || xisnan (val))) \
         max_val = val; \
       val = limits(2); \
       if (! (xisinf (val) || xisnan (val))) \
         min_pos = val; \
       val = limits(3); \
       if (! (xisinf (val) || xisnan (val))) \
         max_neg = val; \
     } \
   else \
     { \
-      limits.resize(4, 1); \
+      limits.resize (4, 1); \
       limits(0) = min_val; \
       limits(1) = max_val; \
       limits(2) = min_pos; \
       limits(3) = max_neg; \
     }
 
   if (axis_type == "xdata" || axis_type == "xscale"
       || axis_type == "xlimmode" || axis_type == "xliminclude"
@@ -6826,27 +6826,27 @@ axes::properties::translate_view (double
   zoom (xlims, ylims, false);
 }
 
 void
 axes::properties::rotate_view (double delta_el, double delta_az)
 {
   Matrix v = get_view ().matrix_value ();
 
-  v (1) += delta_el;
+  v(1) += delta_el;
 
   if(v(1) > 90)
     v(1) = 90;
   if(v(1) < -90)
     v(1) = -90;
 
-  v (0) = fmod(v(0) - delta_az + 720,360);
-
-  set_view(v);
-  update_transform();
+  v(0) = fmod (v(0) - delta_az + 720,360);
+
+  set_view (v);
+  update_transform ();
 }
 
 void
 axes::properties::unzoom (void)
 {
   if (zoom_stack.size () >= 4)
     {
       ylim = zoom_stack.front ();
@@ -6992,17 +6992,17 @@ text::properties::update_text_extent (vo
 
   octave_value string_prop = get_string ();
 
   string_vector sv = string_prop.all_strings ();
 
   renderer.text_to_pixels (sv.join ("\n"), pixels, bbox,
                            halign, valign, get_rotation ());
   /* The bbox is relative to the text's position.
-     We'll leave it that way, because get_position() does not return
+     We'll leave it that way, because get_position () does not return
      valid results when the text is first constructed.
      Conversion to proper coordinates is performed in get_extent. */
   set_extent (bbox);
 
 #endif
 
   if (autopos_tag_is ("xlabel") || autopos_tag_is ("ylabel") ||
       autopos_tag_is ("zlabel") || autopos_tag_is ("title"))
@@ -7052,17 +7052,17 @@ text::properties::get_fontsize_points (d
   double fs = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
     {
       graphics_object go (gh_manager::get_object (get___myhandle__ ()));
       graphics_object ax (go.get_ancestor ("axes"));
 
-      parent_height = ax.get_properties ().get_boundingbox (true).elem(3);
+      parent_height = ax.get_properties ().get_boundingbox (true).elem (3);
     }
 
   return convert_font_size (fs, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
@@ -7072,17 +7072,17 @@ image::properties::get_color_data (void)
                         cdatamapping_is ("scaled"), 3);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 patch::properties::get_color_data (void) const
 {
-  octave_value fvc = get_facevertexcdata();
+  octave_value fvc = get_facevertexcdata ();
   if (fvc.is_undefined () || fvc.is_empty ())
     return Matrix ();
   else
     return convert_cdata (*this, fvc,cdatamapping_is ("scaled"), 2);
 }
 
 // ---------------------------------------------------------------------
 
@@ -7252,34 +7252,34 @@ hggroup::update_axis_limits (const std::
       update_type = 'c';
     }
   else if (axis_type == "alim" || axis_type == "aliminclude")
     {
       limits = xproperties.get_alim ().matrix_value ();
       update_type = 'a';
     }
 
-  if (limits.numel() == 4)
+  if (limits.numel () == 4)
     {
       val = limits(0);
       if (! (xisinf (val) || xisnan (val)))
         min_val = val;
       val = limits(1);
       if (! (xisinf (val) || xisnan (val)))
         max_val = val;
       val = limits(2);
       if (! (xisinf (val) || xisnan (val)))
         min_pos = val;
       val = limits(3);
       if (! (xisinf (val) || xisnan (val)))
         max_neg = val;
     }
   else
     {
-      limits.resize(4,1);
+      limits.resize (4,1);
       limits(0) = min_val;
       limits(1) = max_val;
       limits(2) = min_pos;
       limits(3) = max_neg;
     }
 
   get_children_limits (min_val, max_val, min_pos, max_neg, kids, update_type);
 
@@ -7475,17 +7475,17 @@ uicontrol::properties::update_units (voi
   set_position (pos);
 
   cached_units = get_units ();
 }
 
 void
 uicontrol::properties::set_style (const octave_value& st)
 {
-  if (get___object__ ().is_empty())
+  if (get___object__ ().is_empty ())
     style = st;
   else
     error ("set: cannot change the style of a uicontrol object after creation.");
 }
 
 Matrix
 uicontrol::properties::get_boundingbox (bool,
                                         const Matrix& parent_pix_size) const
@@ -7538,17 +7538,17 @@ uicontrol::properties::update_fontunits 
 
 double
 uicontrol::properties::get_fontsize_points (double box_pix_height) const
 {
   double fs = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
-    parent_height = get_boundingbox (false).elem(3);
+    parent_height = get_boundingbox (false).elem (3);
 
   return convert_font_size (fs, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 Matrix
 uipanel::properties::get_boundingbox (bool internal,
@@ -7674,17 +7674,17 @@ uipanel::properties::update_fontunits (c
 
 double
 uipanel::properties::get_fontsize_points (double box_pix_height) const
 {
   double fs = get_fontsize ();
   double parent_height = box_pix_height;
 
   if (fontunits_is ("normalized") && parent_height <= 0)
-    parent_height = get_boundingbox (false).elem(3);
+    parent_height = get_boundingbox (false).elem (3);
 
   return convert_font_size (fs, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
 uitoolbar::get_default (const caseless_str& name) const
@@ -8423,17 +8423,17 @@ the dimensions of @var{pv}.\n\
                         }
                       else if (hcv.length () == args(2).cell_value ().rows ())
                         {
                           obj.set (args(1).cellstr_value (),
                                    args(2).cell_value (), n);
                         }
                       else
                         {
-                          error("set: number of graphics handles must match number of value rows (%d != %d)",
+                          error ("set: number of graphics handles must match number of value rows (%d != %d)",
                                 hcv.length (), args(2).cell_value ().rows ());
                           break;
 
                         }
                     }
                   else if (nargin == 2 && args(1).is_map ())
                     {
                       obj.set (args(1).map_value ());
@@ -8510,17 +8510,17 @@ values or lists respectively.\n\
   Cell vals;
 
   int nargin = args.length ();
 
   bool use_cell_format = false;
 
   if (nargin == 1 || nargin == 2)
     {
-      if (args(0).is_empty())
+      if (args(0).is_empty ())
         {
           retval = Matrix ();
           return retval;
         }
 
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
@@ -8913,27 +8913,27 @@ calc_dimensions (const graphics_object& 
   int nd = 2;
 
   if (go.isa ("surface"))
     nd = 3;
 
   if ((go.isa ("line") || go.isa ("patch")) && ! go.get("zdata").is_empty ())
     nd = 3;
 
-  Matrix kids = go.get_properties().get_children ();
+  Matrix kids = go.get_properties ().get_children ();
 
   for (octave_idx_type i = 0; i < kids.length (); i++)
     {
       graphics_handle hnd = gh_manager::lookup (kids(i));
 
       if (hnd.ok ())
         {
-          const graphics_object& kid = gh_manager::get_object(hnd);
-
-          if (kid.valid_object())
+          const graphics_object& kid = gh_manager::get_object (hnd);
+
+          if (kid.valid_object ())
             nd = calc_dimensions (kid);
 
           if (nd == 3)
             break;
         }
     }
 
   return nd;
@@ -9852,17 +9852,17 @@ get_property_from_handle (double handle,
   gh_manager::auto_lock guard;
 
   graphics_object obj = gh_manager::get_object (handle);
   octave_value retval;
 
   if (obj)
     retval = obj.get (caseless_str (property));
   else
-    error ("%s: invalid handle (= %g)", func.c_str(), handle);
+    error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
   return retval;
 }
 
 bool
 set_property_in_handle (double handle, const std::string& property,
                         const octave_value& arg, const std::string& func)
 {
@@ -9874,17 +9874,17 @@ set_property_in_handle (double handle, c
   if (obj)
     {
       obj.set (caseless_str (property), arg);
 
       if (! error_state)
         ret = true;
     }
   else
-    error ("%s: invalid handle (= %g)", func.c_str(), handle);
+    error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
   return ret;
 }
 
 static bool
 compare_property_values (const octave_value& o1, const octave_value& o2)
 {
   octave_value_list args (2);
@@ -9942,21 +9942,21 @@ do_cleanup_waitfor_listener (const octav
                     }
                 }
             }
         }
     }
 }
 
 static void
-cleanup_waitfor_postset_listener(const octave_value& listener)
+cleanup_waitfor_postset_listener (const octave_value& listener)
 { do_cleanup_waitfor_listener (listener, POSTSET); }
 
 static void
-cleanup_waitfor_predelete_listener(const octave_value& listener)
+cleanup_waitfor_predelete_listener (const octave_value& listener)
 { do_cleanup_waitfor_listener (listener, PREDELETE); }
 
 static octave_value_list
 waitfor_listener (const octave_value_list& args, int)
 {
   if (args.length () > 3)
     {
       uint32_t id = args(2).uint32_scalar_value ().value ();
diff --git a/src/graphics.in.h b/src/graphics.in.h
--- a/src/graphics.in.h
+++ b/src/graphics.in.h
@@ -293,17 +293,17 @@ private:
     }
 };
 
 class scaler
 {
 public:
   scaler (void) : rep (new base_scaler ()) { }
 
-  scaler (const scaler& s) : rep (s.rep->clone()) { }
+  scaler (const scaler& s) : rep (s.rep->clone ()) { }
 
   scaler (const std::string& s)
     : rep (s == "log"
            ? new log_scaler ()
            : (s == "neglog" ? new neg_log_scaler ()
               : (s == "linear" ? new lin_scaler () : new base_scaler ())))
     { }
 
@@ -459,18 +459,18 @@ public:
               if (v.internal_rep () == l(i).internal_rep ())
                 {
                   found = true;
                   break;
                 }
             }
           if (found)
             {
-              for (int j = i; j < l.length() - 1; j++)
-                l(j) = l (j + 1);
+              for (int j = i; j < l.length () - 1; j++)
+                l(j) = l(j + 1);
 
               l.resize (l.length () - 1);
             }
         }
       else
         {
           if (mode == PERSISTENT)
             l.resize (0);
@@ -4408,19 +4408,19 @@ public:
     // properties declarations.
 
     BEGIN_PROPERTIES (image)
       row_vector_property xdata u , Matrix ()
       row_vector_property ydata u , Matrix ()
       array_property cdata u , Matrix ()
       radio_property cdatamapping al , "{scaled}|direct"
       // hidden properties for limit computation
-      row_vector_property xlim hlr , Matrix()
-      row_vector_property ylim hlr , Matrix()
-      row_vector_property clim hlr , Matrix()
+      row_vector_property xlim hlr , Matrix ()
+      row_vector_property ylim hlr , Matrix ()
+      row_vector_property clim hlr , Matrix ()
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       bool_property climinclude hlg , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
       {
@@ -4805,21 +4805,21 @@ public:
         update_limits (h);
       }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (hggroup)
       // hidden properties for limit computation
-      row_vector_property xlim hr , Matrix()
-      row_vector_property ylim hr , Matrix()
-      row_vector_property zlim hr , Matrix()
-      row_vector_property clim hr , Matrix()
-      row_vector_property alim hr , Matrix()
+      row_vector_property xlim hr , Matrix ()
+      row_vector_property ylim hr , Matrix ()
+      row_vector_property zlim hr , Matrix ()
+      row_vector_property clim hr , Matrix ()
+      row_vector_property alim hr , Matrix ()
       bool_property xliminclude h , "on"
       bool_property yliminclude h , "on"
       bool_property zliminclude h , "on"
       bool_property climinclude h , "on"
       bool_property aliminclude h , "on"
     END_PROPERTIES
 
   private:
@@ -4877,17 +4877,17 @@ public:
       }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (uimenu)
       any_property __object__ , Matrix ()
       string_property accelerator , ""
-      callback_property callback , Matrix()
+      callback_property callback , Matrix ()
       bool_property checked , "off"
       bool_property enable , "on"
       color_property foregroundcolor , color_values (0, 0, 0)
       string_property label , ""
       double_property position , 9
       bool_property separator , "off"
       string_property fltk_label h , ""
     END_PROPERTIES
@@ -4925,17 +4925,17 @@ public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (uicontextmenu)
       any_property __object__ , Matrix ()
-      callback_property callback , Matrix()
+      callback_property callback , Matrix ()
       array_property position , Matrix (1, 2, 0.0)
     END_PROPERTIES
 
   protected:
     void init (void)
       {
         position.add_constraint (dim_vector (1, 2));
         position.add_constraint (dim_vector (2, 1));
@@ -5218,17 +5218,17 @@ public:
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (uipushtool)
       any_property __object__ , Matrix ()
       array_property cdata , Matrix ()
-      callback_property clickedcallback , Matrix()
+      callback_property clickedcallback , Matrix ()
       bool_property enable , "on"
       bool_property separator , "off"
       string_property tooltipstring , ""
     END_PROPERTIES
 
   protected:
     void init (void)
       {
@@ -5268,20 +5268,20 @@ public:
   {
   public:
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (uitoggletool)
       any_property __object__ , Matrix ()
       array_property cdata , Matrix ()
-      callback_property clickedcallback , Matrix()
+      callback_property clickedcallback , Matrix ()
       bool_property enable , "on"
-      callback_property offcallback , Matrix()
-      callback_property oncallback , Matrix()
+      callback_property offcallback , Matrix ()
+      callback_property oncallback , Matrix ()
       bool_property separator , "off"
       bool_property state , "off"
       string_property tooltipstring , ""
     END_PROPERTIES
 
   protected:
     void init (void)
       {
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -1534,19 +1534,19 @@ Query or set the character used to separ
 the subfunction names contained within the file.  This can be used in\n\
 a generic manner to interact with subfunctions.  For example,\n\
 \n\
 @example\n\
 help ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
-returns the help string associated with the sub-function @code{mysubfunc}\n\
+returns the help string associated with the subfunction @code{mysubfunc}\n\
 of the function @code{myfunc}.  Another use of @code{filemarker} is when\n\
-debugging it allows easier placement of breakpoints within sub-functions.\n\
+debugging it allows easier placement of breakpoints within subfunctions.\n\
 For example,\n\
 \n\
 @example\n\
 dbstop ([\"myfunc\", filemarker, \"mysubfunc\"])\n\
 @end example\n\
 \n\
 @noindent\n\
 will set a breakpoint at the first line of the subfunction @code{mysubfunc}.\n\
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -521,35 +521,35 @@ load_path::do_initialize (bool set_initi
 
   do_set (xpath, false, true);
 }
 
 void
 load_path::do_clear (std::set<std::string>& new_elts)
 {
   bool warn_default_path_clobbered = false;
-  for (dir_info_list_iterator i = dir_info_list.begin();
-       i != dir_info_list.end();
+  for (dir_info_list_iterator i = dir_info_list.begin ();
+       i != dir_info_list.end ();
        /* conditionally advance iterator in loop body */)
     {
       //Don't remove it if it's gonna be added again, but remove it from
       //list of items to add, to avoid duplicates later on
-      std::set<std::string>::iterator j = new_elts.find(i->dir_name);
-      if (j != new_elts.end())
+      std::set<std::string>::iterator j = new_elts.find (i->dir_name);
+      if (j != new_elts.end ())
         {
-          new_elts.erase(j);
+          new_elts.erase (j);
           i++;
         }
       else
         {
           //Warn if removing a default directory and not immediately adding
           //it back again
-          if(i->is_init)
+          if (i->is_init)
             warn_default_path_clobbered = true;
-          i = dir_info_list.erase(i);
+          i = dir_info_list.erase (i);
         }
     }
 
   if (warn_default_path_clobbered)
     warning_with_id ("Octave:remove-init-dir",
                      "default load path altered.  Some built-in functions may "
                      "not be found.  Try restoredefaultpath() to recover it.");
 
@@ -590,17 +590,17 @@ split_path (const std::string& p)
 
   return retval;
 }
 
 void
 load_path::do_set (const std::string& p, bool warn, bool is_init)
 {
   std::list<std::string> elts_l = split_path (p);
-  std::set<std::string> elts(elts_l.begin(), elts_l.end());
+  std::set<std::string> elts(elts_l.begin (), elts_l.end ());
 
   // Temporarily disable add hook.
 
   unwind_protect frame;
   frame.protect_var (add_hook);
 
   add_hook = 0;
 
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -292,23 +292,23 @@ private:
     typedef method_file_map_type::const_iterator const_method_file_map_iterator;
     typedef method_file_map_type::iterator method_file_map_iterator;
 
     // This default constructor is only provided so we can create a
     // std::map of dir_info objects.  You should not use this
     // constructor for any other purpose.
     dir_info (void)
       : dir_name (), abs_dir_name (), is_relative (false),
-        is_init(false), dir_mtime (), dir_time_last_checked (),
+        is_init (false), dir_mtime (), dir_time_last_checked (),
         all_files (), fcn_files (), private_file_map (), method_file_map ()
       { }
 
     dir_info (const std::string& d)
       : dir_name (d), abs_dir_name (), is_relative (false),
-        is_init(false), dir_mtime (), dir_time_last_checked (),
+        is_init (false), dir_mtime (), dir_time_last_checked (),
         all_files (), fcn_files (), private_file_map (), method_file_map ()
     {
       initialize ();
     }
 
     dir_info (const dir_info& di)
       : dir_name (di.dir_name), abs_dir_name (di.abs_dir_name),
         is_relative (di.is_relative),
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -644,17 +644,17 @@ Force Octave to assume the file is in Oc
 
   if (error_state)
     return retval;
 
   int i = 1;
   std::string orig_fname = "";
 
   // Function called with Matlab-style ["filename", options] syntax
-  if (argc > 1 && ! argv[1].empty () && argv[1].at(0) != '-')
+  if (argc > 1 && ! argv[1].empty () && argv[1].at (0) != '-')
     {
       orig_fname = argv[1];
       i++;
     }
 
   // It isn't necessary to have the default load format stored in a
   // user preference variable since we can determine the type of file
   // as we are reading.
@@ -996,17 +996,17 @@ save_fields (std::ostream& os, const oct
   glob_match pat (pattern);
 
   size_t saved = 0;
 
   for (octave_scalar_map::const_iterator p = m.begin (); p != m.end (); p++)
     {
       std::string empty_str;
 
-      if (pat.match(m.key (p)))
+      if (pat.match (m.key (p)))
         {
           do_save (os, m.contents (p), m.key (p), empty_str,
                    0, fmt, save_as_floats);
 
           saved++;
         }
     }
 
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -744,17 +744,17 @@ save_hdf5_empty (hid_t loc_id, const cha
 
 // Load an empty matrix, if needed. Returns
 //    > 0  loaded empty matrix, dimensions returned
 //    = 0  Not an empty matrix; did nothing
 //    < 0  Error condition
 int
 load_hdf5_empty (hid_t loc_id, const char *name, dim_vector &d)
 {
-  if (!hdf5_check_attr(loc_id, "OCTAVE_EMPTY_MATRIX"))
+  if (! hdf5_check_attr (loc_id, "OCTAVE_EMPTY_MATRIX"))
     return 0;
 
   hsize_t hdims, maxdims;
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
@@ -835,17 +835,17 @@ add_hdf5_data (hid_t loc_id, const octav
   octave_value val = tc;
   // FIXME: diagonal & permutation matrices currently don't know how to save
   // themselves, so we convert them first to normal matrices using A = A(:,:).
   // This is a temporary hack.
   if (val.is_diag_matrix () || val.is_perm_matrix ()
       || val.type_id () == octave_lazy_index::static_type_id ())
     val = val.full_value ();
 
-  std::string t = val.type_name();
+  std::string t = val.type_name ();
 #if HAVE_HDF5_18
   data_id = H5Gcreate (loc_id, name.c_str (), H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_id = H5Gcreate (loc_id, name.c_str (), 0);
 #endif
   if (data_id < 0)
     goto error_cleanup;
 
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -339,28 +339,28 @@ read_mat_binary_data (std::istream& is, 
             Array<Complex> data (dim_vector (1, nr - 1));
             Array<octave_idx_type> c (dim_vector (1, nr - 1));
             Array<octave_idx_type> r (dim_vector (1, nr - 1));
             OCTAVE_LOCAL_BUFFER (double, dtmp, nr);
             OCTAVE_LOCAL_BUFFER (double, ctmp, nr);
 
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              r.xelem(i) = dtmp[i] - 1;
+              r.xelem (i) = dtmp[i] - 1;
             nr_new = dtmp[nr - 1];
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              c.xelem(i) = dtmp[i] - 1;
+              c.xelem (i) = dtmp[i] - 1;
             nc_new = dtmp[nr - 1];
             read_mat_binary_data (is, dtmp, prec, nr - 1, swap, flt_fmt);
             read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
             read_mat_binary_data (is, ctmp, prec, nr - 1, swap, flt_fmt);
 
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              data.xelem(i) = Complex (dtmp[i], ctmp[i]);
+              data.xelem (i) = Complex (dtmp[i], ctmp[i]);
             read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
 
             SparseComplexMatrix smc = SparseComplexMatrix (data, r, c,
                                                            nr_new, nc_new);
 
             tc = order ? smc.transpose () : smc;
           }
         else
@@ -368,21 +368,21 @@ read_mat_binary_data (std::istream& is, 
             octave_idx_type nr_new, nc_new;
             Array<double> data (dim_vector (1, nr - 1));
             Array<octave_idx_type> c (dim_vector (1, nr - 1));
             Array<octave_idx_type> r (dim_vector (1, nr - 1));
             OCTAVE_LOCAL_BUFFER (double, dtmp, nr);
 
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              r.xelem(i) = dtmp[i] - 1;
+              r.xelem (i) = dtmp[i] - 1;
             nr_new = dtmp[nr - 1];
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
-              c.xelem(i) = dtmp[i] - 1;
+              c.xelem (i) = dtmp[i] - 1;
             nc_new = dtmp[nr - 1];
             read_mat_binary_data (is, data.fortran_vec (), prec, nr - 1, swap, flt_fmt);
             read_mat_binary_data (is, dtmp, prec, 1, swap, flt_fmt);
 
             SparseMatrix sm = SparseMatrix (data, r, c, nr_new, nc_new);
 
             tc = order ? sm.transpose () : sm;
           }
@@ -504,17 +504,17 @@ save_mat_binary_data (std::ostream& os, 
       for (octave_idx_type i = 0; i < nrow; i++)
         {
           std::string tstr = chm.row_as_string (i);
           const char *s = tstr.data ();
 
           for (octave_idx_type j = 0; j < ncol; j++)
             buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
         }
-      os.write (reinterpret_cast<char *> (buf), nrow*ncol*sizeof(double));
+      os.write (reinterpret_cast<char *> (buf), nrow*ncol*sizeof (double));
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
       octave_idx_type nel = r.nelem ();
       for (octave_idx_type i = 0; i < nel; i++)
@@ -532,53 +532,53 @@ save_mat_binary_data (std::ostream& os, 
     {
       double ds;
       OCTAVE_LOCAL_BUFFER (double, dtmp, len);
       if (tc.is_complex_matrix ())
         {
           SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp [i] = m.ridx(i) + 1;
+            dtmp[i] = m.ridx (i) + 1;
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = nr;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           octave_idx_type ii = 0;
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+            for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
               dtmp[ii++] = j + 1;
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = nc;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp [i] = std::real (m.data(i));
+            dtmp[i] = std::real (m.data (i));
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = 0.;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp [i] = std::imag (m.data(i));
+            dtmp[i] = std::imag (m.data (i));
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           os.write (reinterpret_cast<const char *> (&ds), 8);
         }
       else
         {
           SparseMatrix m = tc.sparse_matrix_value ();
 
           for (octave_idx_type i = 0; i < len; i++)
-            dtmp [i] = m.ridx(i) + 1;
+            dtmp[i] = m.ridx (i) + 1;
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = nr;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           octave_idx_type ii = 0;
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
+            for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
               dtmp[ii++] = j + 1;
           os.write (reinterpret_cast<const char *> (dtmp), 8 * len);
           ds = nc;
           os.write (reinterpret_cast<const char *> (&ds), 8);
 
           os.write (reinterpret_cast<const char *> (m.data ()), 8 * len);
           ds = 0.;
           os.write (reinterpret_cast<const char *> (&ds), 8);
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -662,17 +662,17 @@ read_mat5_binary_element (std::istream& 
         }
 
       std::streampos tmp_pos = is.tellg ();
       is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (dim_len) - dim_len));
     }
   else
     {
       // Why did mathworks decide to not have dims for a workspace!!!
-      dims.resize(2);
+      dims.resize (2);
       dims(0) = 1;
       dims(1) = 1;
     }
 
   if (read_mat5_tag (is, swap, type, len) || type != miINT8)
     {
       error ("load: invalid array name subelement");
       goto early_read_error;
@@ -858,34 +858,34 @@ read_mat5_binary_element (std::istream& 
           = read_mat5_binary_element (is, filename, swap, global, tc2);
 
         if (! is || error_state)
           goto data_read_error;
 
         // Octave can handle both "/" and "\" as a directry seperator
         // and so can ignore the seperator field of m0. I think the
         // sentinel field is also save to ignore.
-        Octave_map m0 = tc2.map_value();
-        Octave_map m1 = m0.contents("function_handle")(0).map_value();
-        std::string ftype = m1.contents("type")(0).string_value();
-        std::string fname = m1.contents("function")(0).string_value();
-        std::string fpath = m1.contents("file")(0).string_value();
+        Octave_map m0 = tc2.map_value ();
+        Octave_map m1 = m0.contents ("function_handle")(0).map_value ();
+        std::string ftype = m1.contents ("type")(0).string_value ();
+        std::string fname = m1.contents ("function")(0).string_value ();
+        std::string fpath = m1.contents ("file")(0).string_value ();
 
         if (ftype == "simple" || ftype == "scopedfunction")
           {
-            if (fpath.length() == 0)
+            if (fpath.length () == 0)
               // We have a builtin function
               tc = make_fcn_handle (fname);
             else
               {
                 std::string mroot =
-                  m0.contents("matlabroot")(0).string_value();
+                  m0.contents ("matlabroot")(0).string_value ();
 
                 if ((fpath.length () >= mroot.length ()) &&
-                    fpath.substr(0, mroot.length()) == mroot &&
+                    fpath.substr (0, mroot.length ()) == mroot &&
                     OCTAVE_EXEC_PREFIX != mroot)
                   {
                     // If fpath starts with matlabroot, and matlabroot
                     // doesn't equal octave_config_info ("exec_prefix")
                     // then the function points to a version of Octave
                     // or Matlab other than the running version. In that
                     // case we replace with the same function in the
                     // running version of Octave?
@@ -937,17 +937,17 @@ read_mat5_binary_element (std::istream& 
                           {
                             octave_value tmp (fcn);
 
                             tc = octave_value (new octave_fcn_handle (tmp, fname));
                           }
                         else
                           {
                             warning ("load: can't find the file %s",
-                                     fpath.c_str());
+                                     fpath.c_str ());
                             goto skip_ahead;
                           }
                       }
                   }
                 else
                   {
                     size_t xpos
                       = fpath.find_last_of (file_ops::dir_sep_chars ());
@@ -961,59 +961,59 @@ read_mat5_binary_element (std::istream& 
                       {
                         octave_value tmp (fcn);
 
                         tc = octave_value (new octave_fcn_handle (tmp, fname));
                       }
                     else
                       {
                         warning ("load: can't find the file %s",
-                                 fpath.c_str());
+                                 fpath.c_str ());
                         goto skip_ahead;
                       }
                   }
               }
           }
         else if (ftype == "nested")
           {
             warning ("load: can't load nested function");
             goto skip_ahead;
           }
         else if (ftype == "anonymous")
           {
-            Octave_map m2 = m1.contents("workspace")(0).map_value();
-            uint32NDArray MCOS = m2.contents("MCOS")(0).uint32_array_value();
+            Octave_map m2 = m1.contents ("workspace")(0).map_value ();
+            uint32NDArray MCOS = m2.contents ("MCOS")(0).uint32_array_value ();
             octave_idx_type off = static_cast<octave_idx_type>(MCOS(4).double_value ());
-            m2 = subsys_ov.map_value();
-            m2 = m2.contents("MCOS")(0).map_value();
-            tc2 = m2.contents("MCOS")(0).cell_value()(1 + off).cell_value()(1);
-            m2 = tc2.map_value();
+            m2 = subsys_ov.map_value ();
+            m2 = m2.contents ("MCOS")(0).map_value ();
+            tc2 = m2.contents ("MCOS")(0).cell_value ()(1 + off).cell_value ()(1);
+            m2 = tc2.map_value ();
 
             unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
             symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
             frame.add_fcn (symbol_table::erase_scope, local_scope);
 
             symbol_table::set_scope (local_scope);
 
             octave_call_stack::push (local_scope, 0);
             frame.add_fcn (octave_call_stack::pop);
 
-            if (m2.nfields() > 0)
+            if (m2.nfields () > 0)
               {
                 octave_value tmp;
 
-                for (Octave_map::iterator p0 = m2.begin() ;
-                     p0 != m2.end(); p0++)
+                for (Octave_map::iterator p0 = m2.begin () ;
+                     p0 != m2.end (); p0++)
                   {
-                    std::string key = m2.key(p0);
-                    octave_value val = m2.contents(p0)(0);
+                    std::string key = m2.key (p0);
+                    octave_value val = m2.contents (p0)(0);
 
                     symbol_table::varref (key, local_scope, 0) = val;
                   }
               }
 
             int parse_status;
             octave_value anon_fcn_handle =
               eval_string (fname.substr (4), true, parse_status);
@@ -1214,34 +1214,34 @@ read_mat5_binary_element (std::istream& 
 
         if (isclass)
           {
             if (classname == "inline")
               {
                 // inline is not an object in Octave but rather an
                 // overload of a function handle. Special case.
                 tc =
-                  new octave_fcn_inline (m.contents("expr")(0).string_value(),
-                                         m.contents("args")(0).string_value());
+                  new octave_fcn_inline (m.contents ("expr")(0).string_value (),
+                                         m.contents ("args")(0).string_value ());
               }
             else
               {
                 octave_class* cls
                   = new octave_class (m, classname,
                                       std::list<std::string> ());
 
                 if (cls->reconstruct_exemplar ())
                   {
 
                     if (! cls->reconstruct_parents ())
                       warning ("load: unable to reconstruct object inheritance");
 
                     tc = cls;
                     if (load_path::find_method (classname, "loadobj") !=
-                        std::string())
+                        std::string ())
                       {
                         octave_value_list tmp = feval ("loadobj", tc, 1);
 
                         if (! error_state)
                           tc = tmp(0);
                         else
                           goto data_read_error;
                       }
@@ -1272,17 +1272,17 @@ read_mat5_binary_element (std::istream& 
 
         if (logicalvar)
           {
             uint8NDArray in = tc.uint8_array_value ();
             octave_idx_type nel = in.numel ();
             boolNDArray out (dims);
 
             for (octave_idx_type i = 0; i < nel; i++)
-              out (i) = in(i).bool_value ();
+              out(i) = in(i).bool_value ();
 
             tc = out;
           }
       }
       break;
 
     case MAT_FILE_INT16_CLASS:
       OCTAVE_MAT5_INTEGER_READ (int16NDArray);
@@ -1558,17 +1558,17 @@ read_mat5_binary_file_header (std::istre
       bool global;
       read_mat5_binary_element (is, filename, swap, global, tc);
 
       if (!is || error_state)
         return -1;
 
       if (tc.is_uint8_type ())
         {
-          const uint8NDArray itmp = tc.uint8_array_value();
+          const uint8NDArray itmp = tc.uint8_array_value ();
           octave_idx_type ilen = itmp.numel ();
 
           // Why should I have to initialize outbuf as just overwrite
           std::string outbuf (ilen - 7, ' ');
 
           // FIXME -- find a way to avoid casting away const here
           char *ctmp = const_cast<char *> (outbuf.c_str ());
           for (octave_idx_type j = 8; j < ilen; j++)
@@ -2615,21 +2615,21 @@ save_mat5_binary_element (std::ostream& 
       else
         {
           ComplexNDArray m_cmplx = tc.complex_array_value ();
 
           write_mat5_array (os, ::real (m_cmplx), save_as_floats);
           write_mat5_array (os, ::imag (m_cmplx), save_as_floats);
         }
     }
-  else if (tc.is_map () || tc.is_inline_function() || tc.is_object ())
+  else if (tc.is_map () || tc.is_inline_function () || tc.is_object ())
     {
       if (tc.is_inline_function () || tc.is_object ())
         {
-          std::string classname = tc.is_object() ? tc.class_name () : "inline";
+          std::string classname = tc.is_object () ? tc.class_name () : "inline";
           size_t namelen = classname.length ();
 
           if (namelen > max_namelen)
             namelen = max_namelen; // only 31 or 63 char names permitted
 
           int paddedlength = PAD (namelen);
 
           write_mat5_tag (os, miINT8, namelen);
@@ -2637,17 +2637,17 @@ save_mat5_binary_element (std::ostream& 
           memset (paddedname, 0, paddedlength);
           strncpy (paddedname, classname.c_str (), namelen);
           os.write (paddedname, paddedlength);
         }
 
       Octave_map m;
 
       if (tc.is_object () &&
-          load_path::find_method (tc.class_name (), "saveobj") != std::string())
+          load_path::find_method (tc.class_name (), "saveobj") != std::string ())
         {
           octave_value_list tmp = feval ("saveobj", tc, 1);
           if (! error_state)
             m = tmp(0).map_value ();
           else
             goto error_cleanup;
         }
       else
diff --git a/src/ls-mat5.h b/src/ls-mat5.h
--- a/src/ls-mat5.h
+++ b/src/ls-mat5.h
@@ -43,17 +43,17 @@ enum mat5_data_type
     miUTF8,                     // Unicode UTF-8 Encoded Character Data
     miUTF16,                    // Unicode UTF-16 Encoded Character Data
     miUTF32                     // Unicode UTF-32 Encoded Character Data
   };
 
 extern int
 read_mat5_binary_file_header (std::istream& is, bool& swap,
                               bool quiet = false,
-                              const std::string& filename = std::string());
+                              const std::string& filename = std::string ());
 extern std::string
 read_mat5_binary_element (std::istream& is, const std::string& filename,
                           bool swap, bool& global, octave_value& tc);
 extern bool
 save_mat5_binary_element (std::ostream& os,
                           const octave_value& tc, const std::string& name,
                           bool mark_as_global, bool mat7_format,
                           bool save_as_floats, bool compressing = false);
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -105,17 +105,17 @@ extract_keyword (std::istream& is, const
           bool match = (tmp.compare (0, strlen (keyword), keyword) == 0);
 
           if (match)
             {
               std::ostringstream value;
               while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
                 ; // Skip whitespace and the colon.
 
-              is.putback(c);
+              is.putback (c);
               retval = read_until_newline (is, false);
               break;
             }
           else if (next_only)
             break;
           else
             skip_until_newline (is, false);
         }
@@ -318,17 +318,17 @@ save_ascii_data (std::ostream& os, const
   if (! name.empty ())
     os << "# name: " << name << "\n";
 
   octave_value val = val_arg;
 
   if (mark_as_global)
     os << "# type: global " << val.type_name () << "\n";
   else
-    os << "# type: " << val.type_name() << "\n";
+    os << "# type: " << val.type_name () << "\n";
 
   if (! precision)
     precision = Vsave_precision;
 
   long old_precision = os.precision ();
   os.precision (precision);
 
   success = val.save_ascii (os);
diff --git a/src/ls-oct-ascii.h b/src/ls-oct-ascii.h
--- a/src/ls-oct-ascii.h
+++ b/src/ls-oct-ascii.h
@@ -69,17 +69,17 @@ save_three_d (std::ostream& os, const oc
 //  [%#][ \t]*keyword[ \t]*int-value.*\n
 
 template <class T>
 bool
 extract_keyword (std::istream& is, const char *keyword, T& value,
                  const bool next_only = false)
 {
   bool status = false;
-  value = T();
+  value = T ();
 
   char c;
   while (is.get (c))
     {
       if (c == '%' || c == '#')
         {
           std::ostringstream buf;
 
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -1172,23 +1172,23 @@ isinf ([13, Inf, NA, NaN])\n\
 
   return retval;
 }
 
 /*
 %!assert (isinf (Inf))
 %!assert (!isinf (NaN))
 %!assert (!isinf (NA))
-%!assert (isinf (rand(1,10)), false (1,10))
+%!assert (isinf (rand (1,10)), false (1,10))
 %!assert (isinf ([NaN -Inf -1 0 1 Inf NA]), [false, true, false, false, false, true, false])
 
 %!assert (isinf (single (Inf)))
 %!assert (!isinf (single (NaN)))
 %!assert (!isinf (single (NA)))
-%!assert (isinf (single (rand(1,10))), false (1,10))
+%!assert (isinf (single (rand (1,10))), false (1,10))
 %!assert (isinf (single ([NaN -Inf -1 0 1 Inf NA])), [false, true, false, false, false, true, false])
 
 %!error isinf ()
 %!error isinf (1, 2)
 */
 
 DEFUNX ("isgraph", Fisgraph, args, ,
     "-*- texinfo -*-\n\
@@ -1271,23 +1271,23 @@ isna ([13, Inf, NA, NaN])\n\
 
   return retval;
 }
 
 /*
 %!assert (!isna (Inf))
 %!assert (!isna (NaN))
 %!assert (isna (NA))
-%!assert (isna (rand(1,10)), false (1,10))
+%!assert (isna (rand (1,10)), false (1,10))
 %!assert (isna ([NaN -Inf -1 0 1 Inf NA]), [false, false, false, false, false, false, true])
 
 %!assert (!isna (single (Inf)))
 %!assert (!isna (single (NaN)))
 %!assert (isna (single (NA)))
-%!assert (isna (single (rand(1,10))), false (1,10))
+%!assert (isna (single (rand (1,10))), false (1,10))
 %!assert (isna (single ([NaN -Inf -1 0 1 Inf NA])), [false, false, false, false, false, false, true])
 
 %!error isna ()
 %!error isna (1, 2)
 */
 
 DEFUN (isnan, args, ,
     "-*- texinfo -*-\n\
@@ -1313,23 +1313,23 @@ isnan ([13, Inf, NA, NaN])\n\
 
   return retval;
 }
 
 /*
 %!assert (!isnan (Inf))
 %!assert (isnan (NaN))
 %!assert (isnan (NA))
-%!assert (isnan (rand(1,10)), false (1,10))
+%!assert (isnan (rand (1,10)), false (1,10))
 %!assert (isnan ([NaN -Inf -1 0 1 Inf NA]), [true, false, false, false, false, false, true])
 
 %!assert (!isnan (single (Inf)))
 %!assert (isnan (single (NaN)))
 %!assert (isnan (single (NA)))
-%!assert (isnan (single (rand(1,10))), false (1,10))
+%!assert (isnan (single (rand (1,10))), false (1,10))
 %!assert (isnan (single ([NaN -Inf -1 0 1 Inf NA])), [true, false, false, false, false, false, true])
 
 %!error isnan ()
 %!error isnan (1, 2)
 */
 
 DEFUNX ("isprint", Fisprint, args, ,
     "-*- texinfo -*-\n\
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -392,17 +392,17 @@ public:
 
   mwSize get_m (void) const { return val.rows (); }
 
   mwSize get_n (void) const
   {
     mwSize n = 1;
 
     // Force dims and ndims to be cached.
-    get_dimensions();
+    get_dimensions ();
 
     for (mwIndex i = ndims - 1; i > 0; i--)
       n *= dims[i];
 
     return n;
   }
 
   mwSize *get_dimensions (void) const
@@ -1509,17 +1509,17 @@ private:
 };
 
 // Matlab-style sparse arrays.
 
 class mxArray_sparse : public mxArray_matlab
 {
 public:
 
-  mxArray_sparse (mxClassID id_arg, int m, int n, int nzmax_arg,
+  mxArray_sparse (mxClassID id_arg, mwSize m, mwSize n, mwSize nzmax_arg,
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n), nzmax (nzmax_arg),
       pr (calloc (nzmax, get_element_size ())),
       pi (flag == mxCOMPLEX ? calloc (nzmax, get_element_size ()) : 0),
       ir (static_cast<mwIndex *> (calloc (nzmax, sizeof (mwIndex)))),
       jc (static_cast<mwIndex *> (calloc (n + 1, sizeof (mwIndex))))
     { }
 
@@ -1571,22 +1571,22 @@ protected:
         {
           bool *ppr = static_cast<bool *> (pr);
 
           SparseBoolMatrix val (get_m (), get_n (),
                                 static_cast<octave_idx_type> (nzmax));
 
           for (mwIndex i = 0; i < nzmax; i++)
             {
-              val.xdata(i) = ppr[i];
-              val.xridx(i) = ir[i];
+              val.xdata (i) = ppr[i];
+              val.xridx (i) = ir[i];
             }
 
           for (mwIndex i = 0; i < get_n () + 1; i++)
-            val.xcidx(i) = jc[i];
+            val.xcidx (i) = jc[i];
 
           retval = val;
         }
         break;
 
       case mxSINGLE_CLASS:
         error ("single precision sparse data type not supported");
         break;
@@ -1598,40 +1598,40 @@ protected:
               double *ppr = static_cast<double *> (pr);
               double *ppi = static_cast<double *> (pi);
 
               SparseComplexMatrix val (get_m (), get_n (),
                                        static_cast<octave_idx_type> (nzmax));
 
               for (mwIndex i = 0; i < nzmax; i++)
                 {
-                  val.xdata(i) = Complex (ppr[i], ppi[i]);
-                  val.xridx(i) = ir[i];
+                  val.xdata (i) = Complex (ppr[i], ppi[i]);
+                  val.xridx (i) = ir[i];
                 }
 
               for (mwIndex i = 0; i < get_n () + 1; i++)
-                val.xcidx(i) = jc[i];
+                val.xcidx (i) = jc[i];
 
               retval = val;
             }
           else
             {
               double *ppr = static_cast<double *> (pr);
 
               SparseMatrix val (get_m (), get_n (),
                                 static_cast<octave_idx_type> (nzmax));
 
               for (mwIndex i = 0; i < nzmax; i++)
                 {
-                  val.xdata(i) = ppr[i];
-                  val.xridx(i) = ir[i];
+                  val.xdata (i) = ppr[i];
+                  val.xridx (i) = ir[i];
                 }
 
               for (mwIndex i = 0; i < get_n () + 1; i++)
-                val.xcidx(i) = jc[i];
+                val.xcidx (i) = jc[i];
 
               retval = val;
             }
         }
         break;
 
       default:
         panic_impossible ();
@@ -3458,17 +3458,17 @@ mexAtExit (void (*f) (void))
 }
 
 const mxArray *
 mexGet (double handle, const char *property)
 {
   mxArray *m = 0;
   octave_value ret = get_property_from_handle (handle, property, "mexGet");
 
-  if (!error_state && ret.is_defined())
+  if (!error_state && ret.is_defined ())
     m = ret.as_mxArray ();
   return m;
 }
 
 int
 mexIsGlobal (const mxArray *ptr)
 {
   return mxIsFromGlobalWS (ptr);
diff --git a/src/mk-errno-list b/src/mk-errno-list
--- a/src/mk-errno-list
+++ b/src/mk-errno-list
@@ -36,17 +36,17 @@ if [ $1 = "--perl" ]; then
 elif [ $1 = "--python" ]; then
   PYTHON="$2";
   $PYTHON -c '
 from errno import errorcode
 from sys import stdin
 
 t = "#if defined (%s)\n    { \"%s\", %s, },\n#endif\n"
 errstr = ""
-for k in errorcode.keys():
+for k in errorcode.keys ():
     errstr += t % tuple(3*[errorcode[k]])
 
 for l in stdin:
     print l.replace("@SYSDEP_ERRNO_LIST@", errstr),
 '
 fi
 
 exit $?
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -147,17 +147,17 @@ octave_fields::equal_up_to_order (const 
 
 string_vector
 octave_fields::fieldnames (void) const
 {
   octave_idx_type n = nfields ();
   string_vector retval(n);
 
   for (iterator p = begin (); p != end (); p++)
-    retval.xelem(p->second) = p->first;
+    retval.xelem (p->second) = p->first;
 
   return retval;
 }
 
 octave_value
 octave_scalar_map::getfield (const std::string& k) const
 {
   octave_idx_type idx = xkeys.getfield (k);
@@ -192,17 +192,17 @@ octave_scalar_map::orderfields (void) co
 octave_scalar_map
 octave_scalar_map::orderfields (Array<octave_idx_type>& perm) const
 {
   octave_scalar_map retval (xkeys);
   retval.xkeys.orderfields (perm);
 
   octave_idx_type nf = nfields ();
   for (octave_idx_type i = 0; i < nf; i++)
-    retval.xvals[i] = xvals[perm.xelem(i)];
+    retval.xvals[i] = xvals[perm.xelem (i)];
 
   return retval;
 }
 
 octave_scalar_map
 octave_scalar_map::orderfields (const octave_scalar_map& other,
                                 Array<octave_idx_type>& perm) const
 {
@@ -210,17 +210,17 @@ octave_scalar_map::orderfields (const oc
     return *this;
   else
     {
       octave_scalar_map retval (other.xkeys);
       if (other.xkeys.equal_up_to_order (xkeys, perm))
         {
           octave_idx_type nf = nfields ();
           for (octave_idx_type i = 0; i < nf; i++)
-            retval.xvals[i] = xvals[perm.xelem(i)];
+            retval.xvals[i] = xvals[perm.xelem (i)];
         }
       else
         error ("orderfields: structs must have same fields up to order");
 
       return retval;
     }
 }
 
@@ -242,17 +242,17 @@ octave_scalar_map::contents (const std::
 octave_map::octave_map (const octave_scalar_map& m)
   : xkeys (m.xkeys), xvals (), dimensions (1, 1)
 {
   octave_idx_type nf = m.nfields ();
   xvals.reserve (nf);
   for (octave_idx_type i = 0; i < nf; i++)
     {
       xvals.push_back (Cell (dimensions));
-      xvals[i].xelem(0) = m.xvals[i];
+      xvals[i].xelem (0) = m.xvals[i];
     }
 }
 
 octave_map::octave_map (const Octave_map& m)
   : xkeys (m.keys ()), xvals (m.nfields ()), dimensions (m.dims ())
 {
   for (iterator p = begin (); p != end (); p++)
     contents(p) = m.contents (key (p));
@@ -303,17 +303,17 @@ octave_map::orderfields (void) const
 octave_map
 octave_map::orderfields (Array<octave_idx_type>& perm) const
 {
   octave_map retval (xkeys);
   retval.xkeys.orderfields (perm);
 
   octave_idx_type nf = nfields ();
   for (octave_idx_type i = 0; i < nf; i++)
-    retval.xvals[i] = xvals[perm.xelem(i)];
+    retval.xvals[i] = xvals[perm.xelem (i)];
 
   return retval;
 }
 
 octave_map
 octave_map::orderfields (const octave_map& other,
                          Array<octave_idx_type>& perm) const
 {
@@ -321,17 +321,17 @@ octave_map::orderfields (const octave_ma
     return *this;
   else
     {
       octave_map retval (other.xkeys);
       if (other.xkeys.equal_up_to_order (xkeys, perm))
         {
           octave_idx_type nf = nfields ();
           for (octave_idx_type i = 0; i < nf; i++)
-            retval.xvals[i] = xvals[perm.xelem(i)];
+            retval.xvals[i] = xvals[perm.xelem (i)];
         }
       else
         error ("orderfields: structs must have same fields up to order");
 
       return retval;
     }
 }
 
@@ -586,17 +586,17 @@ octave_map::do_cat (int dim, octave_idx_
   rd(0) = rd(1) = 1;
   rd(dim) = n;
 
   for (octave_idx_type j = 0; j < nf; j++)
     {
       retval.xvals.push_back (Cell (rd));
       assert (retval.xvals[j].numel () == n);
       for (octave_idx_type i = 0; i < n; i++)
-        retval.xvals[j].xelem(i) = map_list[i].xvals[j];
+        retval.xvals[j].xelem (i) = map_list[i].xvals[j];
     }
 }
 
 void
 octave_map::do_cat (int dim, octave_idx_type n, const octave_map *map_list,
                     octave_map& retval)
 {
   octave_idx_type nf = retval.nfields ();
@@ -1273,17 +1273,17 @@ octave_map::concat (const octave_map& rb
           const_iterator pb = rb.seek (key(pa));
 
           if (pb == rb.end ())
             {
               error ("field name mismatch in structure concatenation");
               break;
             }
 
-          contents(pa).insert (rb.contents(pb), ra_idx);
+          contents(pa).insert (rb.contents (pb), ra_idx);
         }
     }
   else
     {
       dim_vector dv = dims ();
 
       if (dv.all_zero ())
         *this = rb;
@@ -1554,18 +1554,18 @@ keys_ok (const Octave_map& a, const Octa
 
   if (a.nfields () == 0)
     {
       keys = b.keys ();
       retval = true;
     }
   else
     {
-      string_vector a_keys = a.keys().sort ();
-      string_vector b_keys = b.keys().sort ();
+      string_vector a_keys = a.keys ().sort ();
+      string_vector b_keys = b.keys ().sort ();
 
       octave_idx_type a_len = a_keys.length ();
       octave_idx_type b_len = b_keys.length ();
 
       if (a_len == b_len)
         {
           for (octave_idx_type i = 0; i < a_len; i++)
             {
@@ -1580,33 +1580,33 @@ keys_ok (const Octave_map& a, const Octa
 
  done:
   return retval;
 }
 
 Octave_map&
 Octave_map::maybe_delete_elements (const octave_value_list& idx)
 {
-  string_vector t_keys = keys();
+  string_vector t_keys = keys ();
   octave_idx_type len = t_keys.length ();
 
   if (len > 0)
     {
       for (octave_idx_type i = 0; i < len; i++)
         {
           std::string k = t_keys[i];
 
           contents(k).delete_elements (idx);
 
           if (error_state)
             break;
         }
 
       if (!error_state)
-        dimensions = contents(t_keys[0]).dims();
+        dimensions = contents(t_keys[0]).dims ();
     }
 
   return *this;
 }
 
 Octave_map&
 Octave_map::assign (const octave_value_list& idx, const Octave_map& rhs)
 {
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -152,17 +152,17 @@ octave_value_list::splice (octave_idx_ty
   retval.resize (new_len);
 
   octave_idx_type k = 0;
 
   for (octave_idx_type i = 0; i < offset; i++)
     retval(k++) = elem (i);
 
   for (octave_idx_type i = 0; i < lst_len; i++)
-    retval(k++) = lst(i);
+    retval(k++) = lst (i);
 
   for (octave_idx_type i = offset + rep_length; i < len; i++)
     retval(k++) = elem (i);
 
   return retval;
 }
 
 bool
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -121,17 +121,17 @@ public:
   bool all_strings_p (void) const;
 
   bool all_scalars (void) const;
 
   bool any_cell (void) const;
 
   bool has_magic_colon (void) const;
 
-  string_vector make_argv (const std::string& = std::string()) const;
+  string_vector make_argv (const std::string& = std::string ()) const;
 
   void stash_name_tags (const string_vector& nm) { names = nm; }
 
   string_vector name_tags (void) const { return names; }
 
   void make_storable_values (void);
 
   octave_value& xelem (octave_idx_type i)
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -2872,17 +2872,17 @@ frob_function (const std::string& fname,
       if (fcn_file_from_relative_lookup)
         fcn->mark_relative ();
 
       if (current_function_depth > 1 || parsing_subfunctions)
         {
           fcn->stash_parent_fcn_name (curr_fcn_file_name);
 
           if (current_function_depth > 1)
-            fcn->stash_parent_fcn_scope (function_scopes[function_scopes.size()-2]);
+            fcn->stash_parent_fcn_scope (function_scopes[function_scopes.size ()-2]);
           else
             fcn->stash_parent_fcn_scope (primary_fcn_scope);
         }
 
       if (lexer_flags.parsing_class_method)
         {
           if (current_class_name == id_name)
             fcn->mark_as_class_constructor ();
@@ -2953,17 +2953,17 @@ finish_function (tree_parameter_list *re
 
       if (current_function_depth > 1 || parsing_subfunctions)
         {
           fcn->mark_as_subfunction ();
 
           if (endfunction_found && function_scopes.size () > 1)
             {
               symbol_table::scope_id pscope
-                = function_scopes[function_scopes.size()-2];
+                = function_scopes[function_scopes.size ()-2];
 
               symbol_table::install_nestfunction (nm, octave_value (fcn),
                                                   pscope);
             }
           else
             symbol_table::install_subfunction (nm, octave_value (fcn),
                                                primary_fcn_scope);
         }
@@ -3199,17 +3199,17 @@ finish_cell (tree_cell *c)
   return finish_matrix (c);
 }
 
 static void
 maybe_warn_missing_semi (tree_statement_list *t)
 {
   if (current_function_depth > 0)
     {
-      tree_statement *tmp = t->back();
+      tree_statement *tmp = t->back ();
 
       if (tmp->is_expression ())
         warning_with_id
           ("Octave:missing-semicolon",
            "missing semicolon near line %d, column %d in file `%s'",
             tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
     }
 }
@@ -3603,17 +3603,17 @@ parse_fcn_file (const std::string& ff, c
           // interrupt.
 
           frame.add_fcn (cleanup_statement_list, &global_command);
 
           fcn_ptr = primary_fcn_ptr;
 
           if (status != 0)
             error ("parse error while reading %s file %s",
-                   file_type.c_str(), ff.c_str ());
+                   file_type.c_str (), ff.c_str ());
         }
       else
         {
           tree_statement *end_of_script
             = make_end ("endscript", input_line_number, current_input_column);
 
           make_script (0, end_of_script);
 
@@ -3687,17 +3687,17 @@ lookup_autoload (const std::string& nm)
     retval = load_path::find_file (p->second);
 
   return retval;
 }
 
 string_vector
 autoloaded_functions (void)
 {
-  string_vector names (autoload_map.size());
+  string_vector names (autoload_map.size ());
 
   octave_idx_type i = 0;
   typedef std::map<std::string, std::string>::const_iterator am_iter;
   for (am_iter p = autoload_map.begin (); p != autoload_map.end (); p++)
     names[i++] = p->first;
 
   return names;
 }
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -2133,17 +2133,17 @@ octave_base_stream::oscanf (const std::s
 
               quit = do_oscanf (elt, tmp, who);
 
               if (quit)
                 break;
               else
                 {
                   if (tmp.is_defined ())
-                    retval (num_values++) = tmp;
+                    retval(num_values++) = tmp;
 
                   if (! ok ())
                     break;
 
                   elt = fmt_list.next (nconv > 0);
                 }
             }
 
diff --git a/src/octave-config.in.cc b/src/octave-config.in.cc
--- a/src/octave-config.in.cc
+++ b/src/octave-config.in.cc
@@ -162,17 +162,17 @@ initialize (void)
   vars["LOCALVERFCNFILEDIR"] =substitute_prefix (%OCTAVE_LOCALVERFCNFILEDIR%, PREFIX, OCTAVE_HOME);
   vars["LOCALVEROCTFILEDIR"] =substitute_prefix (%OCTAVE_LOCALVEROCTFILEDIR%, PREFIX, OCTAVE_HOME);
   vars["MAN1DIR"] =substitute_prefix (%OCTAVE_MAN1DIR%, PREFIX, OCTAVE_HOME);
   vars["MAN1EXT"] = %OCTAVE_MAN1EXT%;
   vars["MANDIR"] =substitute_prefix (%OCTAVE_MANDIR%, PREFIX, OCTAVE_HOME);
   vars["OCTFILEDIR"] =substitute_prefix (%OCTAVE_OCTFILEDIR%, PREFIX, OCTAVE_HOME);
   vars["OCTINCLUDEDIR"] =substitute_prefix (%OCTAVE_OCTINCLUDEDIR%, PREFIX, OCTAVE_HOME);
   vars["OCTLIBDIR"] =substitute_prefix (%OCTAVE_OCTLIBDIR%, PREFIX, OCTAVE_HOME);
-  vars["PREFIX"] = (OCTAVE_HOME.empty() ? PREFIX : OCTAVE_HOME);
+  vars["PREFIX"] = (OCTAVE_HOME.empty () ? PREFIX : OCTAVE_HOME);
   vars["STARTUPFILEDIR"] =substitute_prefix (%OCTAVE_STARTUPFILEDIR%, PREFIX, OCTAVE_HOME);
   vars["VERSION"] = %OCTAVE_VERSION%;
 }
 
 int
 main (int argc, char **argv)
 {
   initialize ();
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -234,29 +234,29 @@ octave_base_int_matrix<T>::load_ascii (s
   return success;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i=0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
-  os.write (reinterpret_cast<const char *> (this->matrix.data()), this->byte_size());
+  os.write (reinterpret_cast<const char *> (this->matrix.data ()), this->byte_size ());
 
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_binary (std::istream& is, bool swap,
                                         oct_mach_info::float_format )
@@ -298,17 +298,17 @@ octave_base_int_matrix<T>::load_binary (
   T m (dv);
 
   if (! is.read (reinterpret_cast<char *> (m.fortran_vec ()), m.byte_size ()))
     return false;
 
   if (swap)
     {
       int nel = dv.numel ();
-      int bytes = nel / m.byte_size();
+      int bytes = nel / m.byte_size ();
       for (int i = 0; i < nel; i++)
         switch (bytes)
           {
           case 8:
             swap_bytes<8> (&m(i));
             break;
           case 4:
             swap_bytes<4> (&m(i));
@@ -359,34 +359,34 @@ octave_base_int_matrix<T>::save_hdf5 (hi
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   retval = H5Dwrite (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
-                     H5P_DEFAULT, this->matrix.data()) >= 0;
+                     H5P_DEFAULT, this->matrix.data ()) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   bool retval = false;
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    this->matrix.resize(dv);
+    this->matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
@@ -417,17 +417,17 @@ octave_base_int_matrix<T>::load_hdf5 (hi
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   T m (dv);
   if (H5Dread (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
-               H5P_DEFAULT, m.fortran_vec()) >= 0)
+               H5P_DEFAULT, m.fortran_vec ()) >= 0)
     {
       retval = true;
       this->matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
@@ -496,31 +496,31 @@ octave_base_int_scalar<T>::load_ascii (s
     }
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_scalar<T>::save_binary (std::ostream& os, bool&)
 {
-  os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size());
+  os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size ());
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_scalar<T>::load_binary (std::istream& is, bool swap,
                                         oct_mach_info::float_format)
 {
   T tmp;
-  if (! is.read (reinterpret_cast<char *> (&tmp), this->byte_size()))
+  if (! is.read (reinterpret_cast<char *> (&tmp), this->byte_size ()))
     return false;
 
   if (swap)
-    switch (this->byte_size())
+    switch (this->byte_size ())
       {
       case 8:
         swap_bytes<8> (&tmp);
         break;
       case 4:
         swap_bytes<4> (&tmp);
         break;
       case 2:
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -470,13 +470,13 @@ octave_base_matrix<MT>::fast_elem_insert
       typedef typename MT::element_type ET;
       const builtin_type_t btyp = class_to_btyp<ET>::btyp;
       if (btyp == btyp_unknown) // Dead branch?
         return false;
 
       // Set up the pointer to the proper place.
       void *here = reinterpret_cast<void *> (&matrix(n));
       // Ask x to store there if it can.
-      return x.get_rep().fast_elem_insert_self (here, btyp);
+      return x.get_rep ().fast_elem_insert_self (here, btyp);
     }
   else
     return false;
 }
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -48,17 +48,17 @@ octave_base_matrix : public octave_base_
 {
 public:
 
   octave_base_matrix (void)
     : octave_base_value (), matrix (), typ (), idx_cache () { }
 
   octave_base_matrix (const MT& m, const MatrixType& t = MatrixType ())
     : octave_base_value (), matrix (m),
-      typ (t.is_known () ? new MatrixType(t) : 0), idx_cache ()
+      typ (t.is_known () ? new MatrixType (t) : 0), idx_cache ()
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_matrix (const octave_base_matrix& m)
     : octave_base_value (), matrix (m.matrix),
       typ (m.typ ? new MatrixType (*m.typ) : 0),
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -365,23 +365,23 @@ octave_base_sparse<T>::print_raw (std::o
           octave_quit ();
 
           // FIXME -- is there an easy way to get the max row
           // and column indices so we can set the width appropriately
           // and line up the columns here?  Similarly, we should look
           // at all the nonzero values and display them with the same
           // formatting rules that apply to columns of a matrix.
 
-          for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
+          for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
             {
               os << "\n";
-              os << "  (" << matrix.ridx(i)+1 <<
+              os << "  (" << matrix.ridx (i)+1 <<
                 ", "  << j+1 << ") -> ";
 
-              octave_print_internal (os, matrix.data(i), pr_as_read_syntax);
+              octave_print_internal (os, matrix.data (i), pr_as_read_syntax);
             }
         }
     }
 }
 
 template <class T>
 bool
 octave_base_sparse<T>::save_ascii (std::ostream& os)
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1112,42 +1112,42 @@ octave_base_value::as_mxArray (void) con
   return 0;
 }
 
 octave_value
 octave_base_value::diag (octave_idx_type) const
 {
   gripe_wrong_type_arg ("octave_base_value::diag ()", type_name ());
 
-  return octave_value();
+  return octave_value ();
 }
 
 octave_value
 octave_base_value::diag (octave_idx_type, octave_idx_type) const
 {
   gripe_wrong_type_arg ("octave_base_value::diag ()", type_name ());
 
-  return octave_value();
+  return octave_value ();
 }
 
 octave_value
 octave_base_value::sort (octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
-  return octave_value();
+  return octave_value ();
 }
 
 octave_value
 octave_base_value::sort (Array<octave_idx_type> &,
                          octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
-  return octave_value();
+  return octave_value ();
 }
 
 sortmode
 octave_base_value::is_sorted (sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::is_sorted ()", type_name ());
 
   return UNSORTED;
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -324,21 +324,21 @@ octave_bool_matrix::load_ascii (std::ist
   return success;
 }
 
 bool
 octave_bool_matrix::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
 
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   boolNDArray m = bool_array_value ();
@@ -464,17 +464,17 @@ octave_bool_matrix::save_hdf5 (hid_t loc
 bool
 octave_bool_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -158,29 +158,29 @@ ComplexNDArray
 octave_sparse_bool_matrix::complex_array_value (bool) const
 {
   return ComplexNDArray (ComplexMatrix (matrix.matrix_value ()));
 }
 
 NDArray
 octave_sparse_bool_matrix::array_value (bool) const
 {
-  return NDArray (Matrix(matrix.matrix_value ()));
+  return NDArray (Matrix (matrix.matrix_value ()));
 }
 
 charNDArray
 octave_sparse_bool_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims (), 0);
   octave_idx_type nc = matrix.cols ();
   octave_idx_type nr = matrix.rows ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
-      retval(matrix.ridx(i) + nr * j) = static_cast<char>(matrix.data (i));
+    for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
+      retval(matrix.ridx (i) + nr * j) = static_cast<char>(matrix.data (i));
 
   return retval;
 }
 
 boolMatrix
 octave_sparse_bool_matrix::bool_matrix_value (bool) const
 {
   return matrix.matrix_value ();
@@ -204,17 +204,17 @@ octave_sparse_bool_matrix::sparse_comple
 {
   return SparseComplexMatrix (this->matrix);
 }
 
 bool
 octave_sparse_bool_matrix::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nnz ();
@@ -233,24 +233,24 @@ octave_sparse_bool_matrix::save_binary (
   itmp= nz;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
   for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
-      itmp = matrix.cidx(i);
+      itmp = matrix.cidx (i);
       os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
   for (int i = 0; i < nz; i++)
     {
       octave_quit ();
-      itmp = matrix.ridx(i);
+      itmp = matrix.ridx (i);
       os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   for (int i = 0; i < nz; i++)
     htmp[i] = (matrix.data (i) ? 1 : 0);
 
@@ -295,27 +295,27 @@ octave_sparse_bool_matrix::load_binary (
 
   for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.cidx(i) = tmp;
+      m.cidx (i) = tmp;
     }
 
   for (int i = 0; i < nz; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.ridx(i) = tmp;
+      m.ridx (i) = tmp;
     }
 
   if (error_state || ! is)
     return false;
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   if (! is.read (htmp, nz))
@@ -435,17 +435,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
-  hdims[0] = m.cols() + 1;
+  hdims[0] = m.cols () + 1;
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
@@ -546,17 +546,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
@@ -777,17 +777,17 @@ octave_sparse_bool_matrix::as_mxArray (v
   mxArray *retval = new mxArray (mxLOGICAL_CLASS, rows (), columns (),
                                  nz, mxREAL);
   bool *pr = static_cast<bool *> (retval->get_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
-      pr[i] = matrix.data(i);
-      ir[i] = matrix.ridx(i);
+      pr[i] = matrix.data (i);
+      ir[i] = matrix.ridx (i);
     }
 
   for (mwIndex i = 0; i < columns () + 1; i++)
-    jc[i] = matrix.cidx(i);
+    jc[i] = matrix.cidx (i);
 
   return retval;
 }
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -84,24 +84,24 @@ octave_bool::do_index_op (const octave_v
 }
 
 octave_value
 octave_bool::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       boolNDArray retval (dv, false);
-      if (dv.numel())
+      if (dv.numel ())
         retval(0) = scalar;
       return retval;
     }
   else
     {
       boolNDArray retval (dv);
-      if (dv.numel())
+      if (dv.numel ())
         retval(0) = scalar;
       return retval;
     }
 }
 
 octave_value
 octave_bool::convert_to_str_internal (bool, bool, char type) const
 {
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -939,17 +939,17 @@ octave_cell::load_ascii (std::istream& i
 bool
 octave_cell::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
   if (d.length () < 1)
     return false;
 
   // Use negative value for ndims
-  int32_t di = - d.length();
+  int32_t di = - d.length ();
   os.write (reinterpret_cast<char *> (&di), 4);
   for (int i = 0; i < d.length (); i++)
     {
       di = d(i);
       os.write (reinterpret_cast<char *> (&di), 4);
     }
 
   Cell tmp = cell_value ();
@@ -1150,17 +1150,17 @@ octave_cell::load_hdf5 (hid_t loc_id, co
 {
   clear_cellstr_cache ();
 
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t group_id = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t group_id = H5Gopen (loc_id, name);
 #endif
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -137,17 +137,17 @@ octave_class::octave_class (const octave
                       Cell c (parent_dims);
 
                       octave_map pmap = parent.map_value ();
 
                       std::list<std::string> plist
                         = parent.parent_class_name_list ();
 
                       for (octave_idx_type i = 0; i < p_nel; i++)
-                        c(i) = octave_value (pmap.index(i), pcnm, plist);
+                        c(i) = octave_value (pmap.index (i), pcnm, plist);
 
                       map.assign (pcnm, c);
                     }
                   else
                     error ("class: parent class dimension mismatch");
                 }
               else if (nel == 1 && p_nel == 1)
                 {
@@ -182,17 +182,17 @@ octave_class::octave_class (const octave
                       Cell c (parent.dims ());
 
                       octave_map pmap = parent.map_value ();
 
                       std::list<std::string> plist
                         = parent.parent_class_name_list ();
 
                       for (octave_idx_type i = 0; i < p_nel; i++)
-                        c(i) = octave_value (pmap.index(i), pcnm, plist);
+                        c(i) = octave_value (pmap.index (i), pcnm, plist);
 
                       map.assign (pcnm, c);
                     }
                   else
                     error ("class: parent class dimension mismatch");
                 }
             }
         }
@@ -516,17 +516,17 @@ octave_class::subsref (const std::string
             else
               retval(0) = octave_value (map.index (idx.front ()),
                                         c_name, parent_list);
           }
           break;
 
         case '.':
           {
-            if (map.numel() > 0)
+            if (map.numel () > 0)
               {
                 Cell t = dotref (idx.front ());
 
                 retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
               }
           }
           break;
 
@@ -700,17 +700,17 @@ octave_class::subsasgn_common (const oct
           else
             tmp = feval (meth.function_value (), args);
 
           // FIXME -- should the subsasgn method be able to return
           // more than one value?
 
           if (tmp.length () > 1)
             error ("expecting single return value from @%s/subsasgn",
-                   class_name().c_str ());
+                   class_name ().c_str ());
 
           else
             retval = tmp(0);
 
           return retval;
         }
     }
 
@@ -909,17 +909,17 @@ octave_class::subsasgn_common (const oct
                       }
                     else
                       error ("invalid class assignment");
                   }
                 else
                   {
                     if (t_rhs.is_empty ())
                       {
-                        map.delete_elements (idx.front());
+                        map.delete_elements (idx.front ());
 
                         if (! error_state)
                           {
                             count++;
                             retval = octave_value (this);
                           }
                         else
                           gripe_failed_assignment ();
@@ -994,30 +994,30 @@ octave_class::index_vector (void) const
     {
       octave_value_list args;
       args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
       octave_value_list tmp = feval (meth.function_value (), args, 1);
 
       if (!error_state && tmp.length () >= 1)
         {
-          if (tmp(0).is_object())
+          if (tmp(0).is_object ())
             error ("subsindex function must return a valid index vector");
           else
             // Index vector returned by subsindex is zero based
             // (why this inconsistency Mathworks?), and so we must
             // add one to the value returned as the index_vector method
             // expects it to be one based.
             retval = do_binary_op (octave_value::op_add, tmp (0),
                                    octave_value (1.0)).index_vector ();
         }
     }
   else
     error ("no subsindex method defined for class %s",
-           class_name().c_str ());
+           class_name ().c_str ());
 
   return retval;
 }
 
 size_t
 octave_class::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
@@ -1131,17 +1131,17 @@ octave_class::all_strings (bool pad) con
         {
           if (tmp(0).is_string ())
             retval = tmp(0).all_strings (pad);
           else
             error ("cname/char method did not return a character string");
         }
     }
   else
-    error ("no char method defined for class %s", class_name().c_str ());
+    error ("no char method defined for class %s", class_name ().c_str ());
 
   return retval;
 }
 
 
 void
 octave_class::print (std::ostream& os, bool) const
 {
@@ -1269,20 +1269,20 @@ octave_class::reconstruct_parents (void)
   bool retval = true, might_have_inheritance = false;
   std::string dbgstr = "dork";
 
   // First, check to see if there might be an issue with inheritance.
   for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
     {
       std::string  key = map.key (p);
       Cell         val = map.contents (p);
-      if ( val(0).is_object() )
+      if ( val(0).is_object () )
         {
           dbgstr = "blork";
-          if( key == val(0).class_name() )
+          if( key == val(0).class_name () )
             {
               might_have_inheritance = true;
               dbgstr = "cork";
               break;
             }
         }
     }
 
@@ -1439,17 +1439,17 @@ octave_class::load_ascii (std::istream& 
     }
 
   return success;
 }
 
 bool
 octave_class::save_binary (std::ostream& os, bool& save_as_floats)
 {
-  int32_t classname_len = class_name().length ();
+  int32_t classname_len = class_name ().length ();
 
   os.write (reinterpret_cast<char *> (&classname_len), 4);
   os << class_name ();
 
   octave_map m;
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
       octave_value in = new octave_class (*this);
@@ -1457,17 +1457,17 @@ octave_class::save_binary (std::ostream&
       if (! error_state)
         m = tmp(0).map_value ();
       else
         return false;
     }
   else
     m = map_value ();
 
-  int32_t len = m.nfields();
+  int32_t len = m.nfields ();
   os.write (reinterpret_cast<char *> (&len), 4);
 
   octave_map::iterator i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_binary_data (os, val, m.key (i), "", 0, save_as_floats);
@@ -2184,17 +2184,17 @@ This function may only be called from a 
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
 
   if (fcn && fcn->is_class_constructor ())
     {
-      for (int i = 0; i < args.length(); i++)
+      for (int i = 0; i < args.length (); i++)
         {
           std::string class_name = args(i).string_value ();
 
           if (! error_state)
             {
               if (! is_built_in_class (class_name))
                 {
                   std::string this_class_name = fcn->name ();
@@ -2236,17 +2236,17 @@ This function may only be called from a 
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
 
   if (fcn && fcn->is_class_constructor ())
     {
-      for (int i = 0; i < args.length(); i++)
+      for (int i = 0; i < args.length (); i++)
         {
           std::string class_name = args(i).string_value ();
 
           if (! error_state)
             {
               if (! is_built_in_class (class_name))
                 {
                   std::string this_class_name = fcn->name ();
diff --git a/src/ov-class.h b/src/ov-class.h
--- a/src/ov-class.h
+++ b/src/ov-class.h
@@ -131,17 +131,17 @@ public:
 
   octave_idx_type nfields (void) const { return map.nfields (); }
 
   size_t nparents (void) const { return parent_list.size (); }
 
   octave_value reshape (const dim_vector& new_dims) const
     {
       octave_class retval = octave_class (*this);
-      retval.map = retval.map_value().reshape (new_dims);
+      retval.map = retval.map_value ().reshape (new_dims);
       return octave_value (new octave_class (retval));
     }
 
   octave_value resize (const dim_vector& dv, bool = false) const
     {
       octave_class retval = octave_class (*this);
       retval.map.resize (dv);
       return octave_value (new octave_class (retval));
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -60,18 +60,18 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_float_complex (v.float_complex_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info(default_numeric_demotion_function,
-                                           octave_float_complex::static_type_id ());
+  return octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                            octave_float_complex::static_type_id ());
 }
 
 octave_base_value *
 octave_complex::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   double im = std::imag (scalar);
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -68,18 +68,18 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_complex_matrix&);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_matrix::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info(default_numeric_demotion_function,
-                                           octave_float_complex_matrix::static_type_id ());
+  return octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                            octave_float_complex_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_complex_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.numel () == 1)
@@ -432,21 +432,21 @@ octave_complex_matrix::load_ascii (std::
 
   return success;
 }
 
 bool
 octave_complex_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   ComplexNDArray m = complex_array_value ();
@@ -639,17 +639,17 @@ octave_complex_matrix::save_hdf5 (hid_t 
 bool
 octave_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -183,18 +183,18 @@ octave_sparse_complex_matrix::char_array
                                "sparse complex matrix", "string");
   else
     {
       retval = charNDArray (dims (), 0);
       octave_idx_type nc = matrix.cols ();
       octave_idx_type nr = matrix.rows ();
 
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
-          retval(matrix.ridx(i) + nr * j) =
+        for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
+          retval(matrix.ridx (i) + nr * j) =
             static_cast<char>(std::real (matrix.data (i)));
     }
 
   return retval;
 }
 
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
@@ -223,17 +223,17 @@ octave_sparse_complex_matrix::sparse_boo
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 bool
 octave_sparse_complex_matrix::save_binary (std::ostream& os,
                                            bool&save_as_floats)
 {
   dim_vector d = this->dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nnz ();
@@ -270,28 +270,28 @@ octave_sparse_complex_matrix::save_binar
         st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)
      {
        octave_quit ();
-       itmp = matrix.cidx(i);
+       itmp = matrix.cidx (i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    for (int i = 0; i < nz; i++)
      {
        octave_quit ();
-       itmp = matrix.ridx(i);
+       itmp = matrix.ridx (i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
-   write_doubles (os, reinterpret_cast<const double *> (matrix.data()), st, 2 * nz);
+   write_doubles (os, reinterpret_cast<const double *> (matrix.data ()), st, 2 * nz);
 
   return true;
 }
 
 bool
 octave_sparse_complex_matrix::load_binary (std::istream& is, bool swap,
                                    oct_mach_info::float_format fmt)
 {
@@ -329,27 +329,27 @@ octave_sparse_complex_matrix::load_binar
 
   for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.cidx(i) = tmp;
+      m.cidx (i) = tmp;
     }
 
   for (int i = 0; i < nz; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.ridx(i) = tmp;
+      m.ridx (i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
 
   read_doubles (is, reinterpret_cast<double *> (m.data ()),
                 static_cast<save_type> (ctmp), 2 * nz, swap, fmt);
 
@@ -471,17 +471,17 @@ octave_sparse_complex_matrix::save_hdf5 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
-  hdims[0] = m.cols() + 1;
+  hdims[0] = m.cols () + 1;
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
@@ -617,17 +617,17 @@ octave_sparse_complex_matrix::load_hdf5 
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
@@ -857,24 +857,24 @@ octave_sparse_complex_matrix::as_mxArray
                                  nz, mxCOMPLEX);
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
-      Complex val = matrix.data(i);
+      Complex val = matrix.data (i);
       pr[i] = std::real (val);
       pi[i] = std::imag (val);
-      ir[i] = matrix.ridx(i);
+      ir[i] = matrix.ridx (i);
     }
 
-  for (mwIndex i = 0; i < columns() + 1; i++)
-    jc[i] = matrix.cidx(i);
+  for (mwIndex i = 0; i < columns () + 1; i++)
+    jc[i] = matrix.cidx (i);
 
   return retval;
 }
 
 octave_value
 octave_sparse_complex_matrix::map (unary_mapper_t umap) const
 {
   switch (umap)
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -396,24 +396,24 @@ octave_fcn_handle::save_ascii (std::ostr
 
 bool
 octave_fcn_handle::load_ascii (std::istream& is)
 {
   bool success = true;
 
   std::streampos pos = is.tellg ();
   std::string octaveroot = extract_keyword (is, "octaveroot", true);
-  if (octaveroot.length() == 0)
+  if (octaveroot.length () == 0)
     {
       is.seekg (pos);
       is.clear ();
     }
   pos = is.tellg ();
   std::string fpath = extract_keyword (is, "path", true);
-  if (fpath.length() == 0)
+  if (fpath.length () == 0)
     {
       is.seekg (pos);
       is.clear ();
     }
 
   is >> nm;
 
   if (nm == anonymous)
@@ -528,17 +528,17 @@ octave_fcn_handle::save_binary (std::ost
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         nmbuf << nm << " " << varlen;
       else
         nmbuf << nm;
 
-      std::string buf_str = nmbuf.str();
+      std::string buf_str = nmbuf.str ();
       int32_t tmp = buf_str.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (buf_str.c_str (), buf_str.length ());
 
       std::ostringstream buf;
       print_raw (buf, true);
       std::string stmp = buf.str ();
       tmp = stmp.length ();
@@ -593,21 +593,21 @@ octave_fcn_handle::load_binary (std::ist
   ctmp1[tmp] = 0;
   nm = std::string (ctmp1);
 
   if (! is)
     return false;
 
   size_t anl = anonymous.length ();
 
-  if (nm.length() >= anl && nm.substr (0, anl) == anonymous)
+  if (nm.length () >= anl && nm.substr (0, anl) == anonymous)
     {
       octave_idx_type len = 0;
 
-      if (nm.length() > anl)
+      if (nm.length () > anl)
         {
           std::istringstream nm_is (nm.substr (anl));
           nm_is >> len;
           nm = nm.substr (0, anl);
         }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
@@ -1631,18 +1631,18 @@ Return a struct containing information a
               else
                 {
                   m.setfield ("function", fh_nm);
 
                   if (fcn->is_subfunction ())
                     {
                       m.setfield ("type", "subfunction");
                       Cell parentage (dim_vector (1, 2));
-                      parentage.elem(0) = fh_nm;
-                      parentage.elem(1) = fcn->parent_fcn_name ();
+                      parentage.elem (0) = fh_nm;
+                      parentage.elem (1) = fcn->parent_fcn_name ();
                       m.setfield ("parentage", octave_value (parentage));
                     }
                   else if (fcn->is_private_function ())
                     m.setfield ("type", "private");
                   else if (fh->is_overloaded ())
                     m.setfield ("type", "overloaded");
                   else
                     m.setfield ("type", "simple");
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -421,21 +421,21 @@ octave_float_complex_matrix::load_ascii 
 
   return success;
 }
 
 bool
 octave_float_complex_matrix::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   FloatComplexNDArray m = complex_array_value ();
@@ -606,17 +606,17 @@ octave_float_complex_matrix::save_hdf5 (
 bool
 octave_float_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -454,21 +454,21 @@ octave_float_matrix::load_ascii (std::is
   return success;
 }
 
 bool
 octave_float_matrix::save_binary (std::ostream& os, bool&)
 {
 
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   FloatNDArray m = float_array_value ();
@@ -619,17 +619,17 @@ octave_float_matrix::save_hdf5 (hid_t lo
 bool
 octave_float_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
@@ -855,18 +855,18 @@ Convert @var{x} to single precision type
     }
   else
     print_usage ();
 
   return octave_value ();
 }
 
 /*
-%!assert (class (single(1)), "single")
-%!assert (class (single(1 + i)), "single")
+%!assert (class (single (1)), "single")
+%!assert (class (single (1 + i)), "single")
 %!assert (class (single (int8 (1))), "single")
 %!assert (class (single (uint8 (1))), "single")
 %!assert (class (single (int16 (1))), "single")
 %!assert (class (single (uint16 (1))), "single")
 %!assert (class (single (int32 (1))), "single")
 %!assert (class (single (uint32 (1))), "single")
 %!assert (class (single (int64 (1))), "single")
 %!assert (class (single (uint64 (1))), "single")
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -140,17 +140,17 @@ public:
   float float_scalar_value (bool = false) const { return float_value (); }
 
   Matrix
   matrix_value (bool = false) const
     {
       Matrix retval;
       dim_vector dv = dims ();
       if (dv.length () > 2)
-        error ("invalid conversion of %s to Matrix", type_name().c_str ());
+        error ("invalid conversion of %s to Matrix", type_name ().c_str ());
       else
         {
           retval = Matrix (dv(0), dv(1));
           double *vec = retval.fortran_vec ();
           octave_idx_type nel = matrix.numel ();
           for (octave_idx_type i = 0; i < nel; i++)
             vec[i] = matrix(i).double_value ();
         }
@@ -158,53 +158,53 @@ public:
     }
 
   FloatMatrix
   float_matrix_value (bool = false) const
     {
       FloatMatrix retval;
       dim_vector dv = dims ();
       if (dv.length () > 2)
-        error ("invalid conversion of %s to FloatMatrix", type_name().c_str ());
+        error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
       else
         {
           retval = FloatMatrix (dv(0), dv(1));
           float *vec = retval.fortran_vec ();
           octave_idx_type nel = matrix.numel ();
           for (octave_idx_type i = 0; i < nel; i++)
             vec[i] = matrix(i).float_value ();
         }
       return retval;
     }
 
   ComplexMatrix
   complex_matrix_value (bool = false) const
     {
       ComplexMatrix retval;
-      dim_vector dv = dims();
+      dim_vector dv = dims ();
       if (dv.length () > 2)
-        error ("invalid conversion of %s to Matrix", type_name().c_str ());
+        error ("invalid conversion of %s to Matrix", type_name ().c_str ());
       else
         {
           retval = ComplexMatrix (dv(0), dv(1));
           Complex *vec = retval.fortran_vec ();
           octave_idx_type nel = matrix.numel ();
           for (octave_idx_type i = 0; i < nel; i++)
             vec[i] = Complex (matrix(i).double_value ());
         }
       return retval;
     }
 
   FloatComplexMatrix
   float_complex_matrix_value (bool = false) const
     {
       FloatComplexMatrix retval;
-      dim_vector dv = dims();
+      dim_vector dv = dims ();
       if (dv.length () > 2)
-        error ("invalid conversion of %s to FloatMatrix", type_name().c_str ());
+        error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
       else
         {
           retval = FloatComplexMatrix (dv(0), dv(1));
           FloatComplex *vec = retval.fortran_vec ();
           octave_idx_type nel = matrix.numel ();
           for (octave_idx_type i = 0; i < nel; i++)
             vec[i] = FloatComplex (matrix(i).float_value ());
         }
@@ -284,22 +284,22 @@ public:
       vec[i] = matrix(i).char_value ();
 
     return retval;
   }
 
   // Use matrix_ref here to clear index cache.
   void increment (void)
    {
-     matrix_ref() += OCTAVE_INT_T (1);
+     matrix_ref () += OCTAVE_INT_T (1);
    }
 
   void decrement (void)
    {
-     matrix_ref() -= OCTAVE_INT_T (1);
+     matrix_ref () -= OCTAVE_INT_T (1);
    }
 
   void changesign (void)
    {
      matrix_ref ().changesign ();
    }
 
   idx_vector index_vector (void) const
@@ -474,24 +474,24 @@ public:
   uint64_array_value (void) const
     { return uint64NDArray (dim_vector (1, 1), uint64_scalar_value ()); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
     {
       if (fill)
         {
           intNDArray<OCTAVE_INT_T> retval (dv, 0);
-          if (dv.numel())
+          if (dv.numel ())
             retval(0) = scalar;
           return retval;
         }
       else
         {
           intNDArray<OCTAVE_INT_T> retval (dv);
-          if (dv.numel())
+          if (dv.numel ())
             retval(0) = scalar;
           return retval;
         }
     }
 
   double double_value (bool = false) const { return scalar.double_value (); }
 
   float float_value (bool = false) const { return scalar.float_value (); }
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -113,20 +113,20 @@ public:
     }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
 
   size_t byte_size (void) const { return 3 * sizeof (double); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return NDArray (array_value().reshape (new_dims)); }
+    { return NDArray (array_value ().reshape (new_dims)); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return NDArray (array_value().permute (vec, inv)); }
+    { return NDArray (array_value ().permute (vec, inv)); }
 
   octave_value squeeze (void) const { return range; }
 
   octave_value full_value (void) const { return range.matrix_value (); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -84,18 +84,18 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_float_matrix (v.float_array_value ());
 }
 
 octave_base_value::type_conv_info
 octave_matrix::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info(default_numeric_demotion_function,
-                                           octave_float_matrix::static_type_id ());
+  return octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                            octave_float_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.nelem () == 1)
@@ -556,21 +556,21 @@ octave_matrix::load_ascii (std::istream&
   return success;
 }
 
 bool
 octave_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   NDArray m = array_value ();
@@ -742,17 +742,17 @@ octave_matrix::save_hdf5 (hid_t loc_id, 
 bool
 octave_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
       return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -155,18 +155,18 @@ octave_sparse_matrix::bool_array_value (
 charNDArray
 octave_sparse_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims (), 0);
   octave_idx_type nc = matrix.cols ();
   octave_idx_type nr = matrix.rows ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
-      retval(matrix.ridx(i) + nr * j) = static_cast<char>(matrix.data (i));
+    for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
+      retval(matrix.ridx (i) + nr * j) = static_cast<char>(matrix.data (i));
 
   return retval;
 }
 
 ComplexMatrix
 octave_sparse_matrix::complex_matrix_value (bool) const
 {
   return ComplexMatrix (matrix.matrix_value ());
@@ -211,18 +211,18 @@ octave_sparse_matrix::convert_to_str_int
     {
       octave_idx_type nr = matrix.rows ();
       octave_idx_type nc = matrix.cols ();
       charNDArray chm (dv, static_cast<char> (0));
 
       bool warned = false;
 
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = matrix.cidx(j);
-             i < matrix.cidx(j+1); i++)
+        for (octave_idx_type i = matrix.cidx (j);
+             i < matrix.cidx (j+1); i++)
           {
             octave_quit ();
 
             double d = matrix.data (i);
 
               if (xisnan (d))
                 {
                   gripe_nan_to_character_conversion ();
@@ -241,32 +241,32 @@ octave_sparse_matrix::convert_to_str_int
 
                       if (! warned)
                         {
                           ::warning ("range error for conversion to character value");
                           warned = true;
                         }
                     }
 
-                  chm (matrix.ridx(i) + j * nr) =
+                  chm (matrix.ridx (i) + j * nr) =
                     static_cast<char> (ival);
                 }
           }
 
       retval = octave_value (chm, type);
     }
 
   return retval;
 }
 
 bool
 octave_sparse_matrix::save_binary (std::ostream& os, bool&save_as_floats)
 {
   dim_vector d = this->dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nnz ();
@@ -303,28 +303,28 @@ octave_sparse_matrix::save_binary (std::
         st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
    for (int i = 0; i < nc+1; i++)
      {
        octave_quit ();
-       itmp = matrix.cidx(i);
+       itmp = matrix.cidx (i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    for (int i = 0; i < nz; i++)
      {
        octave_quit ();
-       itmp = matrix.ridx(i);
+       itmp = matrix.ridx (i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
-   write_doubles (os, matrix.data(), st, nz);
+   write_doubles (os, matrix.data (), st, nz);
 
   return true;
 }
 
 bool
 octave_sparse_matrix::load_binary (std::istream& is, bool swap,
                                    oct_mach_info::float_format fmt)
 {
@@ -362,27 +362,27 @@ octave_sparse_matrix::load_binary (std::
 
   for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.xcidx(i) = tmp;
+      m.xcidx (i) = tmp;
     }
 
   for (int i = 0; i < nz; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
-      m.xridx(i) = tmp;
+      m.xridx (i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
 
   read_doubles (is, m.xdata (), static_cast<save_type> (ctmp), nz, swap, fmt);
 
   if (error_state || ! is)
@@ -501,17 +501,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
 
-  hdims[0] = m.cols() + 1;
+  hdims[0] = m.cols () + 1;
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
@@ -632,17 +632,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
@@ -852,32 +852,32 @@ octave_sparse_matrix::load_hdf5 (hid_t l
   return retval;
 }
 
 #endif
 
 mxArray *
 octave_sparse_matrix::as_mxArray (void) const
 {
-  mwSize nz = nzmax();
-  mwSize nr = rows();
-  mwSize nc = columns();
+  mwSize nz = nzmax ();
+  mwSize nr = rows ();
+  mwSize nc = columns ();
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, nr, nc, nz, mxREAL);
   double *pr = static_cast<double *> (retval->get_data ());
-  mwIndex *ir = retval->get_ir();
-  mwIndex *jc = retval->get_jc();
+  mwIndex *ir = retval->get_ir ();
+  mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
-      pr[i] = matrix.data(i);
-      ir[i] = matrix.ridx(i);
+      pr[i] = matrix.data (i);
+      ir[i] = matrix.ridx (i);
     }
 
   for (mwIndex i = 0; i < nc + 1; i++)
-    jc[i] = matrix.cidx(i);
+    jc[i] = matrix.cidx (i);
 
   return retval;
 }
 
 octave_value
 octave_sparse_matrix::map (unary_mapper_t umap) const
 {
   switch (umap)
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -62,18 +62,18 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_float_scalar (v.float_value ());
 }
 
 octave_base_value::type_conv_info
 octave_scalar::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info(default_numeric_demotion_function,
-                                           octave_float_scalar::static_type_id ());
+  return octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                            octave_float_scalar::static_type_id ());
 }
 
 octave_value
 octave_scalar::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
   // FIXME -- this doesn't solve the problem of
   //
   //   a = 1; a([1,1], [1,1], [1,1])
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -247,17 +247,17 @@ octave_char_matrix_str::cellstr_value (v
   Array<std::string> retval;
 
   if (matrix.ndims () == 2)
     {
       const charMatrix chm = matrix.matrix_value ();
       octave_idx_type nr = chm.rows ();
       retval.clear (nr, 1);
       for (octave_idx_type i = 0; i < nr; i++)
-        retval.xelem(i) = chm.row_as_string (i);
+        retval.xelem (i) = chm.row_as_string (i);
     }
   else
     error ("cellstr: cannot convert multidimensional arrays");
 
   return retval;
 }
 
 void
@@ -460,21 +460,21 @@ octave_char_matrix_str::load_ascii (std:
   return success;
 }
 
 bool
 octave_char_matrix_str::save_binary (std::ostream& os,
                                      bool& /* save_as_floats */)
 {
   dim_vector d = dims ();
-  if (d.length() < 1)
+  if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length();
+  int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i=0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   charNDArray m = char_array_value ();
@@ -610,17 +610,17 @@ octave_char_matrix_str::save_hdf5 (hid_t
 bool
 octave_char_matrix_str::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
-    matrix.resize(dv);
+    matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -149,17 +149,17 @@ octave_struct::subsref (const std::strin
           }
         else
           retval(0) = do_index_op (idx.front ());
       }
       break;
 
     case '.':
       {
-        if (map.numel() > 0)
+        if (map.numel () > 0)
           {
             const Cell t = dotref (idx.front ());
 
             retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
           }
       }
       break;
 
@@ -215,17 +215,17 @@ octave_struct::subsref (const std::strin
           }
         else
           retval = do_index_op (idx.front (), auto_add);
       }
       break;
 
     case '.':
       {
-        if (map.numel() > 0)
+        if (map.numel () > 0)
           {
             const Cell t = dotref (idx.front (), auto_add);
 
             retval = (t.length () == 1) ? t(0) : octave_value (t, true);
           }
       }
       break;
 
@@ -476,17 +476,17 @@ octave_struct::subsasgn (const std::stri
                           gripe_nonbraced_cs_list_assignment ();
                       }
                   }
                 else
                   gripe_failed_assignment ();
               }
             else
               {
-                if (t_rhs.is_map() || t_rhs.is_object ())
+                if (t_rhs.is_map () || t_rhs.is_object ())
                   {
                     octave_map rhs_map = t_rhs.map_value ();
 
                     if (! error_state)
                       {
                         map.assign (idx.front (), rhs_map);
 
                         if (! error_state)
@@ -497,19 +497,19 @@ octave_struct::subsasgn (const std::stri
                         else
                           gripe_failed_assignment ();
                       }
                     else
                       error ("invalid structure assignment");
                   }
                 else
                   {
-                    if (t_rhs.is_null_value())
+                    if (t_rhs.is_null_value ())
                       {
-                        map.delete_elements (idx.front());
+                        map.delete_elements (idx.front ());
 
                         if (! error_state)
                           {
                             count++;
                             retval = octave_value (this);
                           }
                         else
                           gripe_failed_assignment ();
@@ -818,17 +818,17 @@ octave_struct::save_binary (std::ostream
 
   octave_idx_type nf = m.nfields ();
 
   dim_vector d = dims ();
   if (d.length () < 1)
     return false;
 
   // Use negative value for ndims
-  int32_t di = - d.length();
+  int32_t di = - d.length ();
   os.write (reinterpret_cast<char *> (&di), 4);
   for (int i = 0; i < d.length (); i++)
     {
       di = d(i);
       os.write (reinterpret_cast<char *> (&di), 4);
     }
 
   int32_t len = nf;
@@ -1074,17 +1074,17 @@ octave_struct::fast_elem_insert (octave_
   bool retval = false;
 
   if (n < map.numel ())
     {
       // To avoid copying the scalar struct, it just stores a pointer to
       // itself.
       const octave_scalar_map *sm_ptr;
       void *here = reinterpret_cast<void *>(&sm_ptr);
-      return (x.get_rep().fast_elem_insert_self (here, btyp_struct)
+      return (x.get_rep ().fast_elem_insert_self (here, btyp_struct)
               && map.fast_elem_insert (n, *sm_ptr));
     }
 
   return retval;
 }
 DEFINE_OCTAVE_ALLOCATOR(octave_scalar_struct);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_scalar_struct, "scalar struct", "struct");
@@ -1995,21 +1995,21 @@ Return the number of fields of the struc
   return retval;
 }
 
 /*
 ## test isfield
 %!test
 %! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;
 %! assert (isfield (x, "b"));
-%!assert (isfield (struct("a", "1"), "a"))
+%!assert (isfield (struct ("a", "1"), "a"))
 %!assert (isfield ({1}, "c"), false)
-%!assert (isfield (struct("a", "1"), 10), false)
-%!assert (isfield (struct("a", "b"), "a "), false)
-%!assert (isfield (struct("a", 1, "b", 2), {"a", "c"}), [true, false])
+%!assert (isfield (struct ("a", "1"), 10), false)
+%!assert (isfield (struct ("a", "b"), "a "), false)
+%!assert (isfield (struct ("a", 1, "b", 2), {"a", "c"}), [true, false])
 */
 
 DEFUN (cell2struct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
 Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
 must match the number of elements in @var{cell} along dimension @var{dim},\n\
 that is @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.\n\
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -183,17 +183,17 @@ octave_user_function::octave_user_functi
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
-    anonymous_function (false), nested_function(false),
+    anonymous_function (false), nested_function (false),
     class_constructor (false), class_method (false),
     parent_scope (-1), local_scope (sid),
     curr_unwind_protect_frame (0)
 {
   if (cmd_list)
     cmd_list->mark_as_function_body ();
 
   if (local_scope >= 0)
@@ -866,17 +866,17 @@ DEFUN (isargout, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isargout (@var{k})\n\
 Within a function, return a logical value indicating whether the argument\n\
 @var{k} will be assigned on output to a variable.  If the result is false,\n\
 the argument has been ignored during the function call through the use of\n\
 the tilde (~) special output argument.  Functions can use @code{isargout} to\n\
 avoid performing unnecessary calculations for outputs which are unwanted.\n\
 \n\
-If @var{k} is outside the range @code{1:max(nargout)}, the function returns\n\
+If @var{k} is outside the range @code{1:max (nargout)}, the function returns\n\
 false.  @var{k} can also be an array, in which case the function works\n\
 element-by-element and a logical array is returned.  At the top level,\n\
 @code{isargout} returns an error.\n\
 @seealso{nargout, nargin, varargin, varargout, nthargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -273,17 +273,17 @@ public:
 
   bool is_anonymous_function (void) const { return anonymous_function; }
 
   bool is_anonymous_function_of_class
     (const std::string& cname = std::string ()) const
   {
     return anonymous_function
       ? (cname.empty ()
-         ? (! dispatch_class().empty ())
+         ? (! dispatch_class ().empty ())
          : cname == dispatch_class ())
       : false;
   }
 
   bool is_nested_function (void) const { return nested_function; }
 
   void mark_as_nested_function (void) { nested_function = true; }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2746,17 +2746,17 @@ decode_subscripts (const char* name, con
               if (item == "{}")
                 type_string[k] = '{';
               else if (item == "()")
                 type_string[k] = '(';
               else if (item == ".")
                 type_string[k] = '.';
               else
                 {
-                  error("%s: invalid indexing type `%s'", name, item.c_str ());
+                  error ("%s: invalid indexing type `%s'", name, item.c_str ());
                   return;
                 }
             }
           else
             {
               error ("%s: expecting type(%d) to be a character string",
                      name, k+1);
               return;
@@ -2805,17 +2805,17 @@ are @samp{\"()\"}, @samp{\"@{@}\"}, and 
 The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
 of index values.\n\
 \n\
 The following example shows how to extract the two first columns of\n\
 a matrix\n\
 \n\
 @example\n\
 @group\n\
-val = magic(3)\n\
+val = magic (3)\n\
     @result{} val = [ 8   1   6\n\
                3   5   7\n\
                4   9   2 ]\n\
 idx.type = \"()\";\n\
 idx.subs = @{\":\", 1:2@};\n\
 subsref (val, idx)\n\
      @result{} [ 8   1\n\
           3   5\n\
@@ -2952,17 +2952,17 @@ and @samp{subs}, return @var{rhs}.\n\
 %! idx2 = substruct  ("()", {2:2:5, 2:2:5});
 %! idx3 = substruct  ("()", {":", [1,5]});
 %! idx2p = substruct ("{}", {2:2:5, 2:2:5});
 %! idx3p = substruct ("{}", {":", [1,5]});
 %! idx4 = struct ("type", {}, "subs", {});
 %! assert ({ subsref(c, idx1) }, {13});
 %! assert ({ subsref(c, idx2p) }, {7 9 17 19});
 %! assert ({ subsref(c, idx3p) }, num2cell ([1:5, 21:25]));
-%! assert (subsref(c, idx4), c);
+%! assert (subsref (c, idx4), c);
 %! c = subsasgn (c, idx1, 0);
 %! c = subsasgn (c, idx2, 0);
 %! c = subsasgn (c, idx3, 0);
 %!# c = subsasgn (c, idx4, 0);
 %! d = {0    6   11   16    0
 %!      0    0   12    0    0
 %!      0    8    0   18    0
 %!      0    0   14    0    0
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -189,45 +189,45 @@ public:
   octave_value (unsigned long long int i);
 #endif
 
   octave_value (octave_time t);
   octave_value (double d);
   octave_value (float d);
   octave_value (const Array<octave_value>& a, bool is_cs_list = false);
   octave_value (const Cell& c, bool is_cs_list = false);
-  octave_value (const Matrix& m, const MatrixType& t = MatrixType());
-  octave_value (const FloatMatrix& m, const MatrixType& t = MatrixType());
+  octave_value (const Matrix& m, const MatrixType& t = MatrixType ());
+  octave_value (const FloatMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const NDArray& nda);
   octave_value (const FloatNDArray& nda);
   octave_value (const Array<double>& m);
   octave_value (const Array<float>& m);
   octave_value (const DiagMatrix& d);
   octave_value (const FloatDiagMatrix& d);
   octave_value (const RowVector& v);
   octave_value (const FloatRowVector& v);
   octave_value (const ColumnVector& v);
   octave_value (const FloatColumnVector& v);
   octave_value (const Complex& C);
   octave_value (const FloatComplex& C);
-  octave_value (const ComplexMatrix& m, const MatrixType& t = MatrixType());
-  octave_value (const FloatComplexMatrix& m, const MatrixType& t = MatrixType());
+  octave_value (const ComplexMatrix& m, const MatrixType& t = MatrixType ());
+  octave_value (const FloatComplexMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const ComplexNDArray& cnda);
   octave_value (const FloatComplexNDArray& cnda);
   octave_value (const Array<Complex>& m);
   octave_value (const Array<FloatComplex>& m);
   octave_value (const ComplexDiagMatrix& d);
   octave_value (const FloatComplexDiagMatrix& d);
   octave_value (const ComplexRowVector& v);
   octave_value (const FloatComplexRowVector& v);
   octave_value (const ComplexColumnVector& v);
   octave_value (const FloatComplexColumnVector& v);
   octave_value (const PermMatrix& p);
   octave_value (bool b);
-  octave_value (const boolMatrix& bm, const MatrixType& t = MatrixType());
+  octave_value (const boolMatrix& bm, const MatrixType& t = MatrixType ());
   octave_value (const boolNDArray& bnda);
   octave_value (const Array<bool>& bnda);
   octave_value (char c, char type = '\'');
   octave_value (const char *s, char type = '\'');
   octave_value (const std::string& s, char type = '\'');
   octave_value (const string_vector& s, char type = '\'');
   octave_value (const charMatrix& chm,  char type = '\'');
   octave_value (const charNDArray& chnda, char type = '\'');
@@ -453,17 +453,17 @@ public:
   octave_idx_type rows (void) const { return rep->rows (); }
 
   octave_idx_type columns (void) const { return rep->columns (); }
 
   octave_idx_type length (void) const;
 
   int ndims (void) const { return rep->ndims (); }
 
-  bool all_zero_dims (void) const { return dims().all_zero (); }
+  bool all_zero_dims (void) const { return dims ().all_zero (); }
 
   octave_idx_type numel (void) const
     { return rep->numel (); }
 
   octave_idx_type capacity (void) const
     { return rep->capacity (); }
 
   size_t byte_size (void) const
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -298,18 +298,18 @@ operator << (std::ostream& os, const pr_
   if (ex < 0)
     {
       os << std::setw (0) << "e-";
       ex = -ex;
     }
   else
     os << std::setw (0) << "e+";
 
-  os << std::setw (pef.f.ex - 2) << std::setfill('0') << ex
-     << std::setfill(' ');
+  os << std::setw (pef.f.ex - 2) << std::setfill ('0') << ex
+     << std::setfill (' ');
 
   os.flags (oflags);
 
   return os;
 }
 
 class
 pr_formatted_float
@@ -355,32 +355,32 @@ rational_approx (double val, int len)
   if (xisinf (val))
     s = "1/0";
   else if (xisnan (val))
     s = "0/0";
   else if (val < INT_MIN || val > INT_MAX || D_NINT (val) == val)
     {
       std::ostringstream buf;
       buf.flags (std::ios::fixed);
-      buf << std::setprecision (0) << xround(val);
+      buf << std::setprecision (0) << xround (val);
       s = buf.str ();
     }
   else
     {
       double lastn = 1.;
       double lastd = 0.;
       double n = xround (val);
       double d = 1.;
       double frac = val - n;
       int m = 0;
 
       std::ostringstream buf2;
       buf2.flags (std::ios::fixed);
       buf2 << std::setprecision (0) << static_cast<int>(n);
-      s = buf2.str();
+      s = buf2.str ();
 
       while (1)
         {
           double flip = 1. / frac;
           double step = xround (flip);
           double nextn = n;
           double nextd = d;
 
@@ -402,37 +402,37 @@ rational_approx (double val, int len)
           buf.flags (std::ios::fixed);
           buf << std::setprecision (0) << static_cast<int>(n)
               << "/" << static_cast<int>(d);
           m++;
 
           if (n < 0 && d < 0)
             {
               // Double negative, string can be two characters longer..
-              if (buf.str().length() > static_cast<unsigned int>(len + 2) &&
+              if (buf.str ().length () > static_cast<unsigned int>(len + 2) &&
                   m > 1)
                 break;
             }
-          else if (buf.str().length() > static_cast<unsigned int>(len) &&
+          else if (buf.str ().length () > static_cast<unsigned int>(len) &&
                    m > 1)
             break;
 
-          s = buf.str();
+          s = buf.str ();
         }
 
       if (lastd < 0.)
         {
           // Move sign to the top
           lastd = - lastd;
           lastn = - lastn;
           std::ostringstream buf;
           buf.flags (std::ios::fixed);
           buf << std::setprecision (0) << static_cast<int>(lastn)
                << "/" << static_cast<int>(lastd);
-          s = buf.str();
+          s = buf.str ();
         }
     }
 
   return s;
 }
 
 class
 pr_rational_float
@@ -455,17 +455,17 @@ operator << (std::ostream& os, const pr_
 
   if (fw >= 0)
     os << std::setw (fw);
 
   std::ios::fmtflags oflags =
     os.flags (static_cast<std::ios::fmtflags>
               (prf.f.fmt | prf.f.up | prf.f.sp));
 
-  if (fw > 0 && s.length() > static_cast<unsigned int>(fw))
+  if (fw > 0 && s.length () > static_cast<unsigned int>(fw))
     os << "*";
   else
     os << s;
 
   os.flags (oflags);
 
   return os;
 }
@@ -1999,18 +1999,18 @@ octave_print_internal (std::ostream& os,
                     os << "\n";
                 }
             }
         }
     }
 }
 
 template <typename NDA_T, typename ELT_T, typename MAT_T>
-void print_nd_array(std::ostream& os, const NDA_T& nda,
-                    bool pr_as_read_syntax)
+void print_nd_array (std::ostream& os, const NDA_T& nda,
+                     bool pr_as_read_syntax)
 {
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else
     {
 
       int ndims = nda.ndims ();
@@ -2959,18 +2959,18 @@ PRINT_CONV (octave_int8, octave_int16);
 PRINT_CONV (octave_uint8, octave_uint16);
 
 #undef PRINT_CONV
 
 template <class T>
 /* static */ inline void
 pr_int (std::ostream& os, const T& d, int fw = 0)
 {
-  size_t sz = d.byte_size();
-  const unsigned char * tmpi = d.iptr();
+  size_t sz = d.byte_size ();
+  const unsigned char * tmpi = d.iptr ();
 
   // Unless explicitly asked for, always print in big-endian
   // format for hex and bit formats.
   //
   //   {bit,hex}_format == 1: print big-endian
   //   {bit,hex}_format == 2: print native
 
   if (hex_format)
@@ -3549,17 +3549,17 @@ Note that the output from @code{fdisp} a
 %! fclose (fd);
 
 %!test
 %! foo.real = pi * ones (3,20,3);
 %! foo.complex = pi * ones (3,20,3) + 1i;
 %! foo.char = repmat ("- Hello World -", [3, 20]);
 %! foo.cell = {foo.real, foo.complex, foo.char};
 %! fields = fieldnames (foo);
-%! for f = 1:numel(fields)
+%! for f = 1:numel (fields)
 %!   format loose;
 %!   loose = disp (foo.(fields{f}));
 %!   format compact;
 %!   compact = disp (foo.(fields{f}));
 %!   expected = strrep (loose, "\n\n", "\n");
 %!   assert (expected, compact);
 %! endfor
 */
diff --git a/src/procstream.h b/src/procstream.h
--- a/src/procstream.h
+++ b/src/procstream.h
@@ -103,20 +103,20 @@ OCTINTERP_API
 oprocstream : public std::ostream, public procstreambase
 // oprocstream : public procstreambase, public std::ostream
 {
 public:
 
   oprocstream (void) : std::ostream (0), procstreambase () { }
 
   oprocstream (const std::string& name, int mode = std::ios::out)
-    : std::ostream (0), procstreambase(name, mode) { }
+    : std::ostream (0), procstreambase (name, mode) { }
 
   oprocstream (const char *name, int mode = std::ios::out)
-    : std::ostream (0), procstreambase(name, mode) { }
+    : std::ostream (0), procstreambase (name, mode) { }
 
   ~oprocstream (void) { }
 
   void open (const std::string& name, int mode = std::ios::out)
     { procstreambase::open (name, mode); }
 
   void open (const char *name, int mode = std::ios::out)
     { procstreambase::open (name, mode); }
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -109,17 +109,17 @@ tree_identifier::rvalue1 (int nargout)
     retval = tmp(0);
 
   return retval;
 }
 
 octave_lvalue
 tree_identifier::lvalue (void)
 {
-  return octave_lvalue (&(xsym().varref ()));
+  return octave_lvalue (&(xsym ().varref ()));
 }
 
 tree_identifier *
 tree_identifier::dup (symbol_table::scope_id sc,
                       symbol_table::context_id) const
 {
   // The new tree_identifier object contains a symbol_record
   // entry from the duplicated scope.
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -58,19 +58,19 @@ public:
   bool has_magic_end (void) const { return (name () == "__end__"); }
 
   bool is_identifier (void) const { return true; }
 
   // The name doesn't change with scope, so use sym instead of
   // accessing it through sym so that this function may remain const.
   std::string name (void) const { return sym.name (); }
 
-  bool is_defined (void) { return xsym().is_defined (); }
+  bool is_defined (void) { return xsym ().is_defined (); }
 
-  virtual bool is_variable (void) { return xsym().is_variable (); }
+  virtual bool is_variable (void) { return xsym ().is_variable (); }
 
   virtual bool is_black_hole (void) { return false; }
 
   // Try to find a definition for an identifier.  Here's how:
   //
   //   * If the identifier is already defined and is a function defined
   //     in an function file that has been modified since the last time
   //     we parsed it, parse it again.
@@ -82,24 +82,24 @@ public:
   //     function file to parse.
   //
   //   * On systems that support dynamic linking, we prefer .oct files,
   //     then .mex files, then .m files.
 
   octave_value
   do_lookup (const octave_value_list& args = octave_value_list ())
   {
-    return xsym().find (args);
+    return xsym ().find (args);
   }
 
-  void mark_global (void) { xsym().mark_global (); }
+  void mark_global (void) { xsym ().mark_global (); }
 
-  void mark_as_static (void) { xsym().init_persistent (); }
+  void mark_as_static (void) { xsym ().init_persistent (); }
 
-  void mark_as_formal_parameter (void) { xsym().mark_formal (); }
+  void mark_as_formal_parameter (void) { xsym ().mark_formal (); }
 
   // We really need to know whether this symbol referst to a variable
   // or a function, but we may not know that yet.
 
   bool lvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1105,17 +1105,17 @@ tree_matrix::rvalue1 (int)
 
                       ctmp = *q;
 
                       if (! ctmp.all_zero_dims ())
                         goto found_non_empty;
                     }
                 }
 
-              ctmp = (*(tmp.begin() -> begin()));
+              ctmp = (*(tmp.begin () -> begin ()));
 
             found_non_empty:
 
               if (! all_empty_p)
                 ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
             }
 
           if (! error_state)
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -118,17 +118,17 @@ tree_switch_case::~tree_switch_case (voi
 }
 
 
 bool
 tree_switch_case::label_matches (const octave_value& val)
 {
   octave_value label_value = label->rvalue1 ();
 
-  if (! error_state && label_value.is_defined() )
+  if (! error_state && label_value.is_defined () )
     {
       if (label_value.is_cell ())
         {
           Cell cell (label_value.cell_value ());
 
           for (octave_idx_type i = 0; i < cell.rows (); i++)
             {
               for (octave_idx_type j = 0; j < cell.columns (); j++)
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -247,34 +247,34 @@ generic_sig_handler (int sig)
 #ifdef SIGCHLD
 static void
 sigchld_handler (int /* sig */)
 {
   octave_signal_caught = 1;
 
   octave_signals_caught[SIGCHLD] = true;
 }
-#endif /* defined(SIGCHLD) */
+#endif /* defined (SIGCHLD) */
 
 #ifdef SIGFPE
 #if defined (__alpha__)
 static void
 sigfpe_handler (int /* sig */)
 {
   if (can_interrupt && octave_interrupt_state >= 0)
     {
       octave_signal_caught = 1;
 
       octave_signals_caught[SIGFPE] = true;
 
       octave_interrupt_state++;
     }
 }
-#endif /* defined(__alpha__) */
-#endif /* defined(SIGFPE) */
+#endif /* defined (__alpha__) */
+#endif /* defined (SIGFPE) */
 
 #if defined (SIGHUP) || defined (SIGTERM)
 static void
 sig_hup_or_term_handler (int sig)
 {
   switch (sig)
     {
 #if defined (SIGHUP)
@@ -396,25 +396,25 @@ sigpipe_handler (int /* sig */)
 
   octave_signals_caught[SIGPIPE] = true;
 
   // Don't loop forever on account of this.
 
   if (pipe_handler_error_count++ > 100 && octave_interrupt_state >= 0)
     octave_interrupt_state++;
 }
-#endif /* defined(SIGPIPE) */
+#endif /* defined (SIGPIPE) */
 
 #ifdef USE_W32_SIGINT
 static BOOL CALLBACK
 w32_sigint_handler (DWORD sig)
 {
   const char *sig_name;
 
-  switch(sig)
+  switch (sig)
     {
       case CTRL_BREAK_EVENT:
         sig_name = "Ctrl-Break";
         break;
       case CTRL_C_EVENT:
         sig_name = "Ctrl-C";
         break;
       case CTRL_CLOSE_EVENT:
@@ -426,33 +426,33 @@ w32_sigint_handler (DWORD sig)
       case CTRL_SHUTDOWN_EVENT:
         sig_name = "shutdown";
         break;
       default:
         sig_name = "unknown console event";
         break;
     }
 
-  switch(sig)
+  switch (sig)
     {
       case CTRL_BREAK_EVENT:
       case CTRL_C_EVENT:
         w32_raise (SIGINT);
         break;
 
       case CTRL_CLOSE_EVENT:
         clean_up_and_exit (0);
         break;
       case CTRL_LOGOFF_EVENT:
       case CTRL_SHUTDOWN_EVENT:
       default:
         // We should do the following:
         //    clean_up_and_exit (0);
         // We can't because we aren't running in the normal Octave thread.
-        user_abort(sig_name, sig);
+        user_abort (sig_name, sig);
         break;
     }
 
   // Return TRUE if the event was handled, or FALSE if another handler
   // should be called.
   // FIXME check that windows terminates the thread.
   return TRUE;
 }
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -112,17 +112,17 @@ INSTANTIATE_MX_DIV_CONFORM (Matrix, Spar
 INSTANTIATE_MX_DIV_CONFORM (Matrix, SparseComplexMatrix);
 INSTANTIATE_MX_DIV_CONFORM (ComplexMatrix, SparseMatrix);
 INSTANTIATE_MX_DIV_CONFORM (ComplexMatrix, SparseComplexMatrix);
 INSTANTIATE_MX_DIV_CONFORM (SparseMatrix, DiagMatrix);
 INSTANTIATE_MX_DIV_CONFORM (SparseMatrix, ComplexDiagMatrix);
 INSTANTIATE_MX_DIV_CONFORM (SparseComplexMatrix, DiagMatrix);
 INSTANTIATE_MX_DIV_CONFORM (SparseComplexMatrix, ComplexDiagMatrix);
 
-// Right division functions.  X / Y = X * inv(Y) = (inv (Y') * X')'
+// Right division functions.  X / Y = X * inv (Y) = (inv (Y') * X')'
 //
 //                  Y / X:   m   cm   sm  scm
 //                   +--   +---+----+----+----+
 //   sparse matrix         | 1 |  3 |  5 |  7 |
 //                         +---+----+----+----+
 //   sparse complex_matrix | 2 |  4 |  6 |  8 |
 //                         +---+----+----+----+
 //   diagonal matrix                |  9 | 11 |
@@ -379,80 +379,80 @@ x_el_div (double a, const SparseMatrix& 
     result = Matrix (nr, nc, octave_NaN);
   else if (a > 0.)
     result = Matrix (nr, nc, octave_Inf);
   else
     result = Matrix (nr, nc, -octave_Inf);
 
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+    for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
-        result.elem (b.ridx(i), j) = a / b.data (i);
+        result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (double a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
-  ComplexMatrix  result (nr, nc, Complex(octave_NaN, octave_NaN));
+  ComplexMatrix  result (nr, nc, Complex (octave_NaN, octave_NaN));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+    for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
-        result.elem (b.ridx(i), j) = a / b.data (i);
+        result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+    for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
-        result.elem (b.ridx(i), j) = a / b.data (i);
+        result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
   return result;
 }
 
 ComplexMatrix
 x_el_div (const Complex a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   ComplexMatrix result (nr, nc, (a / 0.0));
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
+    for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
-        result.elem (b.ridx(i), j) = a / b.data (i);
+        result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
   return result;
 }
 
-// Left division functions.  X \ Y = inv(X) * Y
+// Left division functions.  X \ Y = inv (X) * Y
 //
 //               Y  \  X :   sm  scm  dm  dcm
 //                   +--   +---+----+
 //   matrix                | 1 |  5 |
 //                         +---+----+
 //   complex_matrix        | 2 |  6 |
 //                         +---+----+----+----+
 //   sparse matrix         | 3 |  7 |  9 | 11 |
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -245,32 +245,32 @@ elem_xpow (double a, const SparseMatrix&
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result (i, j) = std::pow (atmp, b(i,j));
+              result(i, j) = std::pow (atmp, b(i,j));
             }
         }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               octave_quit ();
-              result (i, j) = std::pow (a, b(i,j));
+              result(i, j) = std::pow (a, b(i,j));
             }
         }
 
       retval = result;
     }
 
   return retval;
 }
@@ -285,17 +285,17 @@ elem_xpow (double a, const SparseComplex
   Complex atmp (a);
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
-          result (i, j) = std::pow (atmp, b(i,j));
+          result(i, j) = std::pow (atmp, b(i,j));
         }
     }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
@@ -318,36 +318,36 @@ elem_xpow (const SparseMatrix& a, double
         {
           ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
 
           // FIXME -- avoid apparent GNU libm bug by
           // converting A and B to complex instead of just A.
           Complex btmp (b);
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
               {
                 octave_quit ();
 
                 Complex atmp (a.data (i));
 
-                result (a.ridx(i), j) = std::pow (atmp, btmp);
+                result(a.ridx (i), j) = std::pow (atmp, btmp);
               }
 
           retval = octave_value (result);
         }
       else
         {
           Matrix result (nr, nc, (std::pow (0.0, b)));
 
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
               {
                 octave_quit ();
-                result (a.ridx(i), j) = std::pow (a.data (i), b);
+                result(a.ridx (i), j) = std::pow (a.data (i), b);
               }
 
           retval = octave_value (result);
         }
     }
   else if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       SparseComplexMatrix result (a);
@@ -402,21 +402,21 @@ elem_xpow (const SparseMatrix& a, const 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+    for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
       {
         if (a.data(i) < 0.0)
           {
-            double btmp = b (a.ridx(i), j);
+            double btmp = b (a.ridx (i), j);
             if (static_cast<int> (btmp) != btmp)
               {
                 convert_to_complex = 1;
                 goto done;
               }
           }
       }
 
@@ -424,41 +424,41 @@ done:
 
   // This is a dumb operator for sparse matrices anyway, and there is
   // no sensible way to handle the 0.^0 versus the 0.^x cases. Therefore
   // allocate a full matrix filled for the 0.^0 case and shrink it later
   // as needed
 
   if (convert_to_complex)
     {
-      SparseComplexMatrix complex_result (nr, nc, Complex(1.0, 0.0));
+      SparseComplexMatrix complex_result (nr, nc, Complex (1.0, 0.0));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+          for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
             {
               octave_quit ();
-              complex_result.xelem(a.ridx(i), j) =
-                std::pow (Complex(a.data(i)), Complex(b(a.ridx(i), j)));
+              complex_result.xelem (a.ridx (i), j) =
+                std::pow (Complex (a.data (i)), Complex (b(a.ridx (i), j)));
             }
         }
       complex_result.maybe_compress (true);
       retval = complex_result;
     }
   else
     {
       SparseMatrix result (nr, nc, 1.0);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+          for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
             {
               octave_quit ();
-              result.xelem(a.ridx(i), j) = std::pow (a.data(i),
-                                                     b (a.ridx(i), j));
+              result.xelem (a.ridx (i), j) = std::pow (a.data (i),
+                                                       b(a.ridx (i), j));
             }
         }
       result.maybe_compress (true);
       retval = result;
     }
 
   return retval;
 }
@@ -502,23 +502,23 @@ elem_xpow (const SparseMatrix& a, const 
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
-  SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
+  SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+      for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
-          result.xelem(a.ridx(i), j) = std::pow (a.data(i), b (a.ridx(i), j));
+          result.xelem (a.ridx(i), j) = std::pow (a.data (i), b(a.ridx (i), j));
         }
     }
 
   result.maybe_compress (true);
 
   return result;
 }
 
@@ -576,30 +576,30 @@ elem_xpow (const SparseComplexMatrix& a,
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
 
       if (xisint (b))
         {
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
               {
                 octave_quit ();
-                result (a.ridx(i), j) =
+                result (a.ridx (i), j) =
                   std::pow (a.data (i), static_cast<int> (b));
               }
         }
       else
         {
           for (octave_idx_type j = 0; j < nc; j++)
-            for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+            for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
               {
                 octave_quit ();
-                result (a.ridx(i), j) = std::pow (a.data (i), b);
+                result (a.ridx (i), j) = std::pow (a.data (i), b);
               }
         }
 
       retval = result;
     }
   else
     {
       octave_idx_type nz = a.nnz ();
@@ -642,30 +642,30 @@ elem_xpow (const SparseComplexMatrix& a,
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
-  SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
+  SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+      for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
-          double btmp = b (a.ridx(i), j);
+          double btmp = b(a.ridx (i), j);
           Complex tmp;
 
           if (xisint (btmp))
-            result.xelem(a.ridx(i), j) = std::pow (a.data (i),
+            result.xelem (a.ridx (i), j) = std::pow (a.data (i),
                                               static_cast<int> (btmp));
           else
-            result.xelem(a.ridx(i), j) = std::pow (a.data (i), btmp);
+            result.xelem (a.ridx (i), j) = std::pow (a.data (i), btmp);
         }
     }
 
   result.maybe_compress (true);
 
   return result;
 }
 
@@ -710,21 +710,21 @@ elem_xpow (const SparseComplexMatrix& a,
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
-  SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
+  SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
-      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+      for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
-          result.xelem(a.ridx(i), j) = std::pow (a.data (i), b (a.ridx(i), j));
+          result.xelem (a.ridx (i), j) = std::pow (a.data (i), b(a.ridx (i), j));
         }
     }
   result.maybe_compress (true);
 
   return result;
 }
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 
 DEFUN (issparse, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} issparse (@var{x})\n\
 Return true if @var{x} is a sparse matrix.\n\
 @seealso{ismatrix}\n\
 @end deftypefn")
 {
-   if (args.length() != 1)
+   if (args.length () != 1)
      {
        print_usage ();
        return octave_value ();
      }
    else
      return octave_value (args(0).is_sparse_type ());
 }
 
@@ -89,17 +89,17 @@ s = sparse (i, j, s, m, n)\n\
 s = sparse (i, j, s, m, n, \"summation\")\n\
 s = sparse (i, j, s, m, n, \"sum\")\n\
 @end group\n\
 @end example\n\
 \n\
 Given the option \"unique\". if more than two values are specified for the\n\
 same @var{i}, @var{j} indices, the last specified value will be used.\n\
 \n\
-@code{sparse(@var{m}, @var{n})} is equivalent to\n\
+@code{sparse (@var{m}, @var{n})} is equivalent to\n\
 @code{sparse ([], [], [], @var{m}, @var{n}, 0)}\n\
 \n\
 If any of @var{sv}, @var{i} or @var{j} are scalars, they are expanded\n\
 to have a common size.\n\
 @seealso{full, accumarray}\n\
 @end deftypefn")
 {
    octave_value retval;
@@ -222,19 +222,19 @@ the simple forms\n\
 @item @code{@var{s}(:,I:J) = @var{x}}\n\
 \n\
 @item @code{@var{s}(K:L,I:J) = @var{x}}\n\
 @end itemize\n\
 \n\
 @b{and} that the following conditions are met:\n\
 \n\
 @itemize\n\
-@item the assignment does not decrease nnz(@var{S}).\n\
+@item the assignment does not decrease nnz (@var{S}).\n\
 \n\
-@item after the assignment, nnz(@var{S}) does not exceed @var{nz}.\n\
+@item after the assignment, nnz (@var{S}) does not exceed @var{nz}.\n\
 \n\
 @item no index is out of bounds.\n\
 @end itemize\n\
 \n\
 Partial movement of data may still occur, but in general the assignment will\n\
 be more memory and time-efficient under these circumstances.  In particular,\n\
 it is possible to efficiently build a pre-allocated sparse matrix from\n\
 contiguous block of columns.\n\
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -853,21 +853,23 @@ This is just the opposite of the corresp
 }
 
 /*
 %!assert (strncmpi ("abc123", "ABC456", 3), true)
 */
 
 DEFUN (list_in_columns, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} list_in_columns (@var{arg}, @var{width})\n\
+@deftypefn {Built-in Function} {} list_in_columns (@var{arg}, @var{width}, @var{prefix})\n\
 Return a string containing the elements of @var{arg} listed in\n\
-columns with an overall maximum width of @var{width}.  The argument\n\
-@var{arg} must be a cell array of character strings or a character array.\n\
-If @var{width} is not specified, the width of the terminal screen is used.\n\
+columns with an overall maximum width of @var{width} and optional\n\
+prefix @var{prefix}.  The argument @var{arg} must be a cell array\n\
+of character strings or a character array.  If @var{width} is not\n\
+specified or is an empty matrix, or less than or equal to zero,\n\
+the width of the terminal screen is used.\n\
 Newline characters are used to break the lines in the output string.\n\
 For example:\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
 list_in_columns (@{\"abc\", \"def\", \"ghijkl\", \"mnop\", \"qrs\", \"tuv\"@}, 20)\n\
      @result{} abc     mnop\n\
@@ -888,54 +890,84 @@ whos ans\n\
 \n\
 @seealso{terminal_size}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
+  if (nargin < 1 || nargin > 3)
     {
-      string_vector s = args(0).all_strings ();
+      print_usage ();
+      return retval;
+    }
+
+  string_vector s = args(0).all_strings ();
 
-      if (! error_state)
-        {
-          std::ostringstream buf;
+  if (error_state)
+    {
+      error ("list_in_columns: expecting cellstr or char array");
+      return retval;
+    }
+
+  int width = -1;
+
+  if (nargin > 1 && ! args(1).is_empty ())
+    {
+      width = args(1).int_value ();
 
-          if (nargin == 1)
-            // Let list_in_columns query terminal width.
-            s.list_in_columns (buf);
-          else
-            {
-              int width = args(1).int_value ();
+      if (error_state)
+        {
+          error ("list_in_columns: WIDTH must be an integer");
+          return retval;
+        }
+    }
+                
+  std::string prefix;
 
-              if (! error_state)
-                s.list_in_columns (buf, width);
-              else
-                error ("list_in_columns: WIDTH must be an integer");
+  if (nargin > 2)
+    {
+      if (args(2).is_string ())
+        {
+          prefix = args(2).string_value ();
+
+          if (error_state)
+            {
+              error ("list_in_columns: PREFIX must be a character string");
+              return retval;
             }
-
-          retval = buf.str ();
         }
       else
-        error ("list_in_columns: expecting cellstr or char array");
+        {
+          error ("list_in_columns: PREFIX must be a character string");
+          return retval;
+        }
     }
-  else
-    print_usage ();
+
+  std::ostringstream buf;
+
+  s.list_in_columns (buf, width, prefix);
+
+  retval = buf.str ();
 
   return retval;
 }
 
 /*
 %!test
 %! input  = {"abc", "def", "ghijkl", "mnop", "qrs", "tuv"};
 %! result = "abc     mnop\ndef     qrs\nghijkl  tuv\n";
 %! assert (list_in_columns (input, 20), result);
 %!test
 %! input  = ["abc"; "def"; "ghijkl"; "mnop"; "qrs"; "tuv"];
 %! result = "abc     mnop  \ndef     qrs   \nghijkl  tuv   \n";
 %! assert (list_in_columns (input, 20), result);
+%!test
+%! input  = ["abc"; "def"; "ghijkl"; "mnop"; "qrs"; "tuv"];
+%! result = "  abc     mnop  \n  def     qrs   \n  ghijkl  tuv   \n";
+%! assert (list_in_columns (input, 20, "  "), result);
 
 %!error list_in_columns ()
 %!error list_in_columns (["abc", "def"], 20, 2)
+%!error list_in_columns (["abc", "def"], 20, "  ", 3)
 %!error <invalid conversion from string to real scalar> list_in_columns (["abc", "def"], "a")
 */
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1136,19 +1136,19 @@ symbol_table::fcn_info::fcn_info_rep::du
 void
 symbol_table::install_nestfunction (const std::string& name,
                                     const octave_value& fcn,
                                     scope_id parent_scope)
 {
   install_subfunction (name, fcn, parent_scope);
 
   // Stash the nest_parent for resolving variables after parsing is done.
-  octave_function *fv = fcn.function_value();
+  octave_function *fv = fcn.function_value ();
 
-  symbol_table *fcn_table_loc = get_instance (fv->scope());
+  symbol_table *fcn_table_loc = get_instance (fv->scope ());
 
   symbol_table *parent_table = get_instance (parent_scope);
 
   parent_table->add_nest_child (*fcn_table_loc);
 }
 
 octave_value
 symbol_table::find (const std::string& name,
@@ -1196,17 +1196,17 @@ symbol_table::find_function (const std::
 
       if (pos == std::string::npos)
         retval = find (name, args, true, local_funcs);
       else
         {
           std::string fcn_scope = name.substr (0, pos);
           scope_id stored_scope = xcurrent_scope;
           xcurrent_scope = xtop_scope;
-          octave_value parent = find_function (name.substr(0, pos),
+          octave_value parent = find_function (name.substr (0, pos),
                                                octave_value_list (), false);
 
           if (parent.is_defined ())
             {
               octave_function *parent_fcn = parent.function_value ();
 
               if (parent_fcn)
                 {
@@ -1486,17 +1486,17 @@ symbol_table::do_update_nest (void)
                   ours.invalidate ();
                   ti->second = parents;
                 }
             }
           else
             ours.set_curr_fcn (curr_fcn);
         }
     }
-  else if (nest_children.size())
+  else if (nest_children.size ())
     for (table_iterator ti = table.begin (); ti != table.end (); ++ti)
       ti->second.set_curr_fcn (curr_fcn);
 
   for (std::vector<symbol_table*>::iterator iter = nest_children.begin ();
        iter != nest_children.end (); ++iter)
     (*iter)->do_update_nest ();
 }
 
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -2337,17 +2337,17 @@ private:
   }
 
   void do_clear_objects (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
         symbol_record& sr = p->second;
         octave_value& val = sr.varref ();
-        if (val.is_object())
+        if (val.is_object ())
           p->second.clear (my_scope);
       }
   }
 
  void do_unmark_forced_variables (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       p->second.unmark_forced ();
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -286,17 +286,17 @@ exit status, it will linger until Octave
   retval(2) = -1;
   retval(1) = Matrix ();
   retval(0) = Matrix ();
 
   int nargin = args.length ();
 
   if (nargin >= 1 && nargin <= 3)
     {
-      std::string exec_file = args(0).string_value();
+      std::string exec_file = args(0).string_value ();
 
       if (! error_state)
         {
           string_vector arg_list;
 
           if (nargin >= 2)
             {
               string_vector tmp = args(1).all_strings ();
@@ -319,17 +319,17 @@ exit status, it will linger until Octave
             {
               arg_list.resize (1);
 
               arg_list[0] = exec_file;
             }
 
           if (! error_state)
             {
-              bool sync_mode = (nargin == 3 ? args(2).bool_value() : false);
+              bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
 
               if (! error_state)
                 {
                   int fildes[2];
                   std::string msg;
                   pid_t pid;
 
                   pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode, fildes, msg, interactive);
@@ -398,19 +398,19 @@ exit status, it will linger until Octave
 %!       done = true;
 %!     endif
 %!   else
 %!     done = true;
 %!   endif
 %! until (done)
 %! fclose (out);
 %! if (isunix ())
-%!   assert(str, {"these\n","strings\n","some\n","are\n"});
+%!   assert (str, {"these\n","strings\n","some\n","are\n"});
 %! else
-%!   assert(str, {"these\r\n","strings\r\n","some\r\n","are\r\n"});
+%!   assert (str, {"these\r\n","strings\r\n","some\r\n","are\r\n"});
 %! endif
 */
 
 DEFUNX ("fcntl", Ffcntl, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})\n\
 Change the properties of the open file @var{fid}.  The following values\n\
 may be passed as @var{request}:\n\
@@ -1589,18 +1589,20 @@ child process was resumed by delivery of
   warning ("WIFCONTINUED always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
 DEFUNX ("canonicalize_file_name", Fcanonicalize_file_name, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{cname}, @var{status}, @var{msg}]} canonicalize_file_name (@var{name})\n\
-Return the canonical name of file @var{name}.\n\
+@deftypefn {Built-in Function} {[@var{cname}, @var{status}, @var{msg}] =} canonicalize_file_name (@var{fname})\n\
+Return the canonical name of file @var{fname}.  If the file does not exist\n\
+the empty string (\"\") is returned.\n\
+@seealso{make_absolute_filename, is_absolute_filename, is_rooted_relative_filename}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -250,17 +250,17 @@ same_file_internal (const std::string& f
           && fs_file1.dev () == fs_file2.dev ());
 
 #endif
 }
 
 void
 sysdep_init (void)
 {
-#if defined (__386BSD__) || defined (__FreeBSD__) || defined(__NetBSD__)
+#if defined (__386BSD__) || defined (__FreeBSD__) || defined (__NetBSD__)
   BSD_init ();
 #elif defined (__MINGW32__)
   MINGW_init ();
 #elif defined (_MSC_VER)
   MSVC_init ();
 #endif
 }
 
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -957,17 +957,17 @@ command shell that is started to run the
                 }
               else
                 retval(0) = pid;
 #elif defined (__WIN32__)
               STARTUPINFO si;
               PROCESS_INFORMATION pi;
               ZeroMemory (&si, sizeof (si));
               ZeroMemory (&pi, sizeof (pi));
-              OCTAVE_LOCAL_BUFFER (char, xcmd_str, cmd_str.length()+1);
+              OCTAVE_LOCAL_BUFFER (char, xcmd_str, cmd_str.length ()+1);
               strcpy (xcmd_str, cmd_str.c_str ());
 
               if (! CreateProcess (0, xcmd_str, 0, 0, FALSE, 0, 0, 0, &si, &pi))
                 error ("system: CreateProcess failed -- can't create child process");
               else
                 {
                   retval(0) = pi.dwProcessId;
                   CloseHandle (pi.hProcess);
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -235,17 +235,17 @@ private:
 
 ft_manager* ft_manager::instance = 0;
 
 // ---------------------------------------------------------------------------
 
 ft_render::ft_render (void)
     : text_processor (), face (0), bbox (1, 4, 0.0),
       xoffset (0), yoffset (0), multiline_halign (0),
-      multiline_align_xoffsets(), mode (MODE_BBOX),
+      multiline_align_xoffsets (), mode (MODE_BBOX),
       red (0), green (0), blue (0)
 {
 }
 
 ft_render::~ft_render (void)
 {
   if (face)
     FT_Done_Face (face);
@@ -309,17 +309,17 @@ ft_render::visit (text_element_string& e
   if (face)
     {
       int line_index = 0;
       FT_UInt box_line_width = 0;
       std::string str = e.string_value ();
       FT_UInt glyph_index, previous = 0;
 
       if (mode == MODE_BBOX)
-        multiline_align_xoffsets.clear();
+        multiline_align_xoffsets.clear ();
       else if (mode == MODE_RENDER)
         xoffset += multiline_align_xoffsets[line_index];
 
       for (size_t i = 0; i < str.length (); i++)
         {
           glyph_index = FT_Get_Char_Index (face, str[i]);
 
           if (str[i] != '\n'
@@ -328,17 +328,17 @@ ft_render::visit (text_element_string& e
             gripe_missing_glyph (str[i]);
           else
             {
               switch (mode)
                 {
                 case MODE_RENDER:
                   if (str[i] == '\n')
                     {
-                    glyph_index = FT_Get_Char_Index(face, ' ');
+                    glyph_index = FT_Get_Char_Index (face, ' ');
                     if (!glyph_index || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
                       {
                         gripe_missing_glyph (' ');
                       }
                     else
                       {
                         line_index++;
                         xoffset = multiline_align_xoffsets[line_index];
@@ -371,18 +371,18 @@ ft_render::visit (text_element_string& e
                       // the right amount of horizontal space in the bbox.
                       if (x0 < 0)
                         x0 = 0;
 
                       for (int r = 0; r < bitmap.rows; r++)
                         for (int c = 0; c < bitmap.width; c++)
                           {
                             unsigned char pix = bitmap.buffer[r*bitmap.width+c];
-                            if (x0+c < 0 || x0+c >= pixels.dim2()
-                                || y0-r < 0 || y0-r >= pixels.dim3())
+                            if (x0+c < 0 || x0+c >= pixels.dim2 ()
+                                || y0-r < 0 || y0-r >= pixels.dim3 ())
                               {
                                 //::error ("out-of-bound indexing!!");
                               }
                             else if (pixels(3, x0+c, y0-r).value () == 0)
                               {
                                 pixels(0, x0+c, y0-r) = red;
                                 pixels(1, x0+c, y0-r) = green;
                                 pixels(2, x0+c, y0-r) = blue;
@@ -392,25 +392,25 @@ ft_render::visit (text_element_string& e
 
                       xoffset += (face->glyph->advance.x >> 6);
                     }
                   break;
 
                 case MODE_BBOX:
                   if (str[i] == '\n')
                     {
-                      glyph_index = FT_Get_Char_Index(face, ' ');
+                      glyph_index = FT_Get_Char_Index (face, ' ');
                       if (! glyph_index
                           || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
                       {
                         gripe_missing_glyph (' ');
                       }
                     else
                       {
-                        multiline_align_xoffsets.push_back(box_line_width);
+                        multiline_align_xoffsets.push_back (box_line_width);
                         // Reset the pixel width for this newline, so we don't
                         // allocate a bounding box larger than the horizontal
                         // width of the multi-line
                         box_line_width = 0;
                         bbox(1) -= (face->size->metrics.height >> 6);
                       }
                     }
                   else
@@ -460,19 +460,19 @@ ft_render::visit (text_element_string& e
                   previous = 0;
                 else
                   previous = glyph_index;
             }
         }
       if (mode == MODE_BBOX)
         {
           /* Push last the width associated with the last line */
-          multiline_align_xoffsets.push_back(box_line_width);
+          multiline_align_xoffsets.push_back (box_line_width);
 
-          for (unsigned int i = 0; i < multiline_align_xoffsets.size(); i++)
+          for (unsigned int i = 0; i < multiline_align_xoffsets.size (); i++)
             {
             /* Center align */
             if (multiline_halign == 1)
               multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i])/2;
             /* Right align */
             else if (multiline_halign == 2)
               multiline_align_xoffsets[i] = (bbox(2) - multiline_align_xoffsets[i]);
             /* Left align */
@@ -524,42 +524,42 @@ ft_render::render (text_element* elt, Ma
               Array<octave_idx_type> perm (dim_vector (3, 1));
               perm(0) = 0;
               perm(1) = 2;
               perm(2) = 1;
               pixels = pixels.permute (perm);
 
               Array<idx_vector> idx (dim_vector (3, 1));
               idx(0) = idx_vector (':');
-              idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
+              idx(1) = idx_vector (pixels.dim2 ()-1, -1, -1);
               idx(2) = idx_vector (':');
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         case ROTATION_180:
             {
               Array<idx_vector> idx (dim_vector (3, 1));
               idx(0) = idx_vector (':');
-              idx(1) = idx_vector (pixels.dim2()-1, -1, -1);
-              idx(2)=  idx_vector (pixels.dim3()-1, -1, -1);
+              idx(1) = idx_vector (pixels.dim2 ()-1, -1, -1);
+              idx(2)=  idx_vector (pixels.dim3 ()-1, -1, -1);
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         case ROTATION_270:
             {
               Array<octave_idx_type> perm (dim_vector (3, 1));
               perm(0) = 0;
               perm(1) = 2;
               perm(2) = 1;
               pixels = pixels.permute (perm);
 
               Array<idx_vector> idx (dim_vector (3, 1));
               idx(0) = idx_vector (':');
               idx(1) = idx_vector (':');
-              idx(2) = idx_vector (pixels.dim3()-1, -1, -1);
+              idx(2) = idx_vector (pixels.dim3 ()-1, -1, -1);
               pixels = uint8NDArray (pixels.index (idx));
             }
           break;
         }
     }
 
   return pixels;
 }
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -857,18 +857,19 @@ Return true if @var{file} is a rooted-re
 
 %!error is_rooted_relative_filename ()
 %!error is_rooted_relative_filename ("foo", "bar")
 */
 
 DEFUN (make_absolute_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} make_absolute_filename (@var{file})\n\
-Return the full name of @var{file}, relative to the current directory.\n\
-@seealso{is_absolute_filename, is_rooted_relative_filename, isdir}\n\
+Return the full name of @var{file} beginning from the root of the file\n\
+system.  No check is done for the existence of @var{file}.\n\
+@seealso{canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = std::string ();
 
   if (args.length () == 1)
     {
       std::string nm = args(0).string_value ();
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1331,17 +1331,17 @@ public:
     param_names(pos_b) = "Bytes";
     param_names(pos_c) = "Class";
     param_names(pos_e) = "Elements";
     param_names(pos_n) = "Name";
     param_names(pos_s) = "Size";
     param_names(pos_t) = "Type";
 
     for (size_t i = 0; i < param_string.length (); i++)
-      param_length(i) = param_names(i) . length ();
+      param_length(i) = param_names(i).length ();
 
     // The attribute column needs size 5.
     param_length(pos_a) = 5;
 
     // Calculating necessary spacing for name column,
     // bytes column, elements column and class column
 
     for (std::list<symbol_info>::const_iterator p = lst.begin ();
@@ -1514,17 +1514,17 @@ public:
             text = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
             pos = text.find ('%');
             if (pos != std::string::npos)
               text = text.substr (0, pos);
 
             // Push parameter into list ...
             idx += text.length ();
             param.text=text;
-            param.line.assign (text.length(), ' ');
+            param.line.assign (text.length (), ' ');
             params.push_back (param);
           }
       }
 
     return params;
   }
 
 private:
@@ -1971,17 +1971,17 @@ DEFUN (munlock, args, ,
 @deftypefnx {Built-in Function} {} munlock (@var{fcn})\n\
 Unlock the named function @var{fcn}.  If no function is named\n\
 then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length() == 1)
+  if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         munlock (name);
       else
         error ("munlock: FCN must be a string");
     }
@@ -2007,17 +2007,17 @@ DEFUN (mislocked, args, ,
 @deftypefnx {Built-in Function} {} mislocked (@var{fcn})\n\
 Return true if the named function @var{fcn} is locked.  If no function is\n\
 named then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length() == 1)
+  if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         retval = mislocked (name);
       else
         error ("mislocked: FCN must be a string");
     }
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -47,436 +47,436 @@ along with Octave; see the file COPYING.
 // Internal buffer sizes (default and "unbuffered" versions)
 #define STASHED_CHARACTERS 16
 #define BIGBUFSIZE (256 * 1024 + STASHED_CHARACTERS)
 #define SMALLBUFSIZE 1
 
 /*****************************************************************************/
 
 // Default constructor
-gzfilebuf::gzfilebuf()
+gzfilebuf::gzfilebuf ()
 : file(0), io_mode(std::ios_base::openmode(0)), own_fd(false),
   buffer(0), buffer_size(BIGBUFSIZE), own_buffer(true)
 {
   // No buffers to start with
-  this->disable_buffer();
+  this->disable_buffer ();
 }
 
 // Destructor
-gzfilebuf::~gzfilebuf()
+gzfilebuf::~gzfilebuf ()
 {
   // Sync output buffer and close only if responsible for file
   // (i.e. attached streams should be left open at this stage)
-  this->sync();
+  this->sync ();
   if (own_fd)
-    this->close();
+    this->close ();
   // Make sure internal buffer is deallocated
-  this->disable_buffer();
+  this->disable_buffer ();
 }
 
 // Set compression level and strategy
 int
-gzfilebuf::setcompression(int comp_level,
-                          int comp_strategy)
+gzfilebuf::setcompression (int comp_level,
+                           int comp_strategy)
 {
-  return gzsetparams(file, comp_level, comp_strategy);
+  return gzsetparams (file, comp_level, comp_strategy);
 }
 
 // Open gzipped file
 gzfilebuf*
-gzfilebuf::open(const char *name,
-                std::ios_base::openmode mode)
+gzfilebuf::open (const char *name,
+                 std::ios_base::openmode mode)
 {
   // Fail if file already open
-  if (this->is_open())
+  if (this->is_open ())
     return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
     return 0;
 
   // Build mode string for gzopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
+  if (! this->open_mode (mode, char_mode))
     return 0;
 
   // Attempt to open file
-  if ((file = gzopen(name, char_mode)) == 0)
+  if ((file = gzopen (name, char_mode)) == 0)
     return 0;
 
   // On success, allocate internal buffer and set flags
-  this->enable_buffer();
+  this->enable_buffer ();
   io_mode = mode;
   own_fd = true;
   return this;
 }
 
 // Attach to gzipped file
 gzfilebuf*
-gzfilebuf::attach(int fd,
-                  std::ios_base::openmode mode)
+gzfilebuf::attach (int fd,
+                   std::ios_base::openmode mode)
 {
   // Fail if file already open
-  if (this->is_open())
+  if (this->is_open ())
     return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
     return 0;
 
   // Build mode string for gzdopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
+  if (! this->open_mode (mode, char_mode))
     return 0;
 
   // Attempt to attach to file
-  if ((file = gzdopen(fd, char_mode)) == 0)
+  if ((file = gzdopen (fd, char_mode)) == 0)
     return 0;
 
   // On success, allocate internal buffer and set flags
-  this->enable_buffer();
+  this->enable_buffer ();
   io_mode = mode;
   own_fd = false;
   return this;
 }
 
 // Close gzipped file
 gzfilebuf*
-gzfilebuf::close()
+gzfilebuf::close ()
 {
   // Fail immediately if no file is open
-  if (!this->is_open())
+  if (! this->is_open ())
     return 0;
   // Assume success
   gzfilebuf* retval = this;
   // Attempt to sync and close gzipped file
-  if (this->sync() == -1)
+  if (this->sync () == -1)
     retval = 0;
-  if (gzclose(file) < 0)
+  if (gzclose (file) < 0)
     retval = 0;
   // File is now gone anyway (postcondition [27.8.1.3.8])
   file = 0;
   own_fd = false;
   // Destroy internal buffer if it exists
-  this->disable_buffer();
+  this->disable_buffer ();
   return retval;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Convert int open mode to mode string
 bool
-gzfilebuf::open_mode(std::ios_base::openmode mode,
-                     char* c_mode) const
+gzfilebuf::open_mode (std::ios_base::openmode mode,
+                      char* c_mode) const
 {
   // FIXME -- do we need testb?
   // bool testb = mode & std::ios_base::binary;
   bool testi = mode & std::ios_base::in;
   bool testo = mode & std::ios_base::out;
   bool testt = mode & std::ios_base::trunc;
   bool testa = mode & std::ios_base::app;
 
   // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)
   // Original zfstream hardcoded the compression level to maximum here...
   // Double the time for less than 1% size improvement seems
   // excessive though - keeping it at the default level
   // To change back, just append "9" to the next three mode strings
   if (!testi && testo && !testt && !testa)
-    strcpy(c_mode, "w");
+    strcpy (c_mode, "w");
   if (!testi && testo && !testt && testa)
-    strcpy(c_mode, "a");
+    strcpy (c_mode, "a");
   if (!testi && testo && testt && !testa)
-    strcpy(c_mode, "w");
+    strcpy (c_mode, "w");
   if (testi && !testo && !testt && !testa)
-    strcpy(c_mode, "r");
+    strcpy (c_mode, "r");
   // No read/write mode yet
 //  if (testi && testo && !testt && !testa)
 //    strcpy(c_mode, "r+");
 //  if (testi && testo && testt && !testa)
 //    strcpy(c_mode, "w+");
 
   // Mode string should be empty for invalid combination of flags
-  if (strlen(c_mode) == 0)
+  if (strlen (c_mode) == 0)
     return false;
 
-  strcat(c_mode, "b");
+  strcat (c_mode, "b");
 
   return true;
 }
 
 // Determine number of characters in internal get buffer
 std::streamsize
-gzfilebuf::showmanyc()
+gzfilebuf::showmanyc ()
 {
   // Calls to underflow will fail if file not opened for reading
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
+  if (! this->is_open () || !(io_mode & std::ios_base::in))
     return -1;
   // Make sure get area is in use
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return std::streamsize(this->egptr() - this->gptr());
+  if (this->gptr () && (this->gptr () < this->egptr ()))
+    return std::streamsize (this->egptr () - this->gptr ());
   else
     return 0;
 }
 
 // Puts back a character to the stream in two cases. Firstly, when there
 // is no putback position available, and secondly when the character putback
 // differs from the one in the file. We can only support the first case
 // with gzipped files.
 gzfilebuf::int_type
 gzfilebuf::pbackfail (gzfilebuf::int_type c)
 {
-  if (this->is_open())
+  if (this->is_open ())
     {
-      if (gzseek (file, this->gptr() - this->egptr() - 1, SEEK_CUR) < 0)
-        return traits_type::eof();
+      if (gzseek (file, this->gptr () - this->egptr () - 1, SEEK_CUR) < 0)
+        return traits_type::eof ();
 
       // Invalidates contents of the buffer
       enable_buffer ();
 
       // Attempt to fill internal buffer from gzipped file
       // (buffer must be guaranteed to exist...)
-      int bytes_read = gzread(file, buffer, buffer_size);
+      int bytes_read = gzread (file, buffer, buffer_size);
       // Indicates error or EOF
       if (bytes_read <= 0)
         {
           // Reset get area
-          this->setg(buffer, buffer, buffer);
-          return traits_type::eof();
+          this->setg (buffer, buffer, buffer);
+          return traits_type::eof ();
         }
 
       // Make all bytes read from file available as get area
-      this->setg(buffer, buffer, buffer + bytes_read);
+      this->setg (buffer, buffer, buffer + bytes_read);
 
       // If next character in get area differs from putback character
       // flag a failure
-      gzfilebuf::int_type ret = traits_type::to_int_type(*(this->gptr()));
+      gzfilebuf::int_type ret = traits_type::to_int_type (*(this->gptr ()));
       if (ret != c)
-        return traits_type::eof();
+        return traits_type::eof ();
       else
         return ret;
     }
   else
-    return traits_type::eof();
+    return traits_type::eof ();
 }
 
 // Fill get area from gzipped file
 gzfilebuf::int_type
-gzfilebuf::underflow()
+gzfilebuf::underflow ()
 {
   // If something is left in the get area by chance, return it
   // (this shouldn't normally happen, as underflow is only supposed
   // to be called when gptr >= egptr, but it serves as error check)
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return traits_type::to_int_type(*(this->gptr()));
+  if (this->gptr () && (this->gptr () < this->egptr ()))
+    return traits_type::to_int_type (*(this->gptr ()));
 
   // If the file hasn't been opened for reading, produce error
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
-    return traits_type::eof();
+  if (! this->is_open () || !(io_mode & std::ios_base::in))
+    return traits_type::eof ();
 
   // Copy the final characters to the front of the buffer
   int stash = 0;
-  if (this->eback() && buffer && buffer_size > STASHED_CHARACTERS)
+  if (this->eback () && buffer && buffer_size > STASHED_CHARACTERS)
     {
       char_type *ptr1 = buffer;
-      char_type *ptr2 = this->egptr() - STASHED_CHARACTERS + 1;
-      if (ptr2 > this->eback())
+      char_type *ptr2 = this->egptr () - STASHED_CHARACTERS + 1;
+      if (ptr2 > this->eback ())
         while (stash++ <= STASHED_CHARACTERS)
           *ptr1++ = *ptr2++;
     }
 
   // Attempt to fill internal buffer from gzipped file
   // (buffer must be guaranteed to exist...)
-  int bytes_read = gzread(file, buffer + stash, buffer_size - stash);
+  int bytes_read = gzread (file, buffer + stash, buffer_size - stash);
 
   // Indicates error or EOF
   if (bytes_read <= 0)
   {
     // Reset get area
-    this->setg(buffer, buffer, buffer);
-    return traits_type::eof();
+    this->setg (buffer, buffer, buffer);
+    return traits_type::eof ();
   }
   // Make all bytes read from file plus the stash available as get area
-  this->setg(buffer, buffer + stash, buffer + bytes_read + stash);
+  this->setg (buffer, buffer + stash, buffer + bytes_read + stash);
 
   // Return next character in get area
-  return traits_type::to_int_type(*(this->gptr()));
+  return traits_type::to_int_type (*(this->gptr ()));
 }
 
 // Write put area to gzipped file
 gzfilebuf::int_type
-gzfilebuf::overflow(int_type c)
+gzfilebuf::overflow (int_type c)
 {
   // Determine whether put area is in use
-  if (this->pbase())
+  if (this->pbase ())
   {
     // Double-check pointer range
-    if (this->pptr() > this->epptr() || this->pptr() < this->pbase())
-      return traits_type::eof();
+    if (this->pptr () > this->epptr () || this->pptr () < this->pbase ())
+      return traits_type::eof ();
     // Add extra character to buffer if not EOF
-    if (!traits_type::eq_int_type(c, traits_type::eof()))
+    if (! traits_type::eq_int_type (c, traits_type::eof ()))
     {
-      *(this->pptr()) = traits_type::to_char_type(c);
-      this->pbump(1);
+      *(this->pptr ()) = traits_type::to_char_type (c);
+      this->pbump (1);
     }
     // Number of characters to write to file
-    int bytes_to_write = this->pptr() - this->pbase();
+    int bytes_to_write = this->pptr () - this->pbase ();
     // Overflow doesn't fail if nothing is to be written
     if (bytes_to_write > 0)
     {
       // If the file hasn't been opened for writing, produce error
-      if (!this->is_open() || !(io_mode & std::ios_base::out))
-        return traits_type::eof();
+      if (! this->is_open () || !(io_mode & std::ios_base::out))
+        return traits_type::eof ();
       // If gzipped file won't accept all bytes written to it, fail
-      if (gzwrite(file, this->pbase(), bytes_to_write) != bytes_to_write)
-        return traits_type::eof();
+      if (gzwrite (file, this->pbase (), bytes_to_write) != bytes_to_write)
+        return traits_type::eof ();
       // Reset next pointer to point to pbase on success
-      this->pbump(-bytes_to_write);
+      this->pbump (-bytes_to_write);
     }
   }
   // Write extra character to file if not EOF
-  else if (!traits_type::eq_int_type(c, traits_type::eof()))
+  else if (! traits_type::eq_int_type (c, traits_type::eof ()))
   {
     // If the file hasn't been opened for writing, produce error
-    if (!this->is_open() || !(io_mode & std::ios_base::out))
-      return traits_type::eof();
+    if (! this->is_open () || !(io_mode & std::ios_base::out))
+      return traits_type::eof ();
     // Impromptu char buffer (allows "unbuffered" output)
-    char_type last_char = traits_type::to_char_type(c);
+    char_type last_char = traits_type::to_char_type (c);
     // If gzipped file won't accept this character, fail
-    if (gzwrite(file, &last_char, 1) != 1)
-      return traits_type::eof();
+    if (gzwrite (file, &last_char, 1) != 1)
+      return traits_type::eof ();
   }
 
   // If you got here, you have succeeded (even if c was EOF)
   // The return value should therefore be non-EOF
-  if (traits_type::eq_int_type(c, traits_type::eof()))
-    return traits_type::not_eof(c);
+  if (traits_type::eq_int_type (c, traits_type::eof ()))
+    return traits_type::not_eof (c);
   else
     return c;
 }
 
 // Assign new buffer
 std::streambuf*
-gzfilebuf::setbuf(char_type* p,
-                  std::streamsize n)
+gzfilebuf::setbuf (char_type* p,
+                   std::streamsize n)
 {
   // First make sure stuff is sync'ed, for safety
-  if (this->sync() == -1)
+  if (this->sync () == -1)
     return 0;
   // If buffering is turned off on purpose via setbuf(0,0), still allocate one...
   // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
   // least a buffer of size 1 (very inefficient though, therefore make it bigger?)
   // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)
   if (!p || !n)
   {
     // Replace existing buffer (if any) with small internal buffer
-    this->disable_buffer();
+    this->disable_buffer ();
     buffer = 0;
     buffer_size = 0;
     own_buffer = true;
-    this->enable_buffer();
+    this->enable_buffer ();
   }
   else
   {
     // Replace existing buffer (if any) with external buffer
-    this->disable_buffer();
+    this->disable_buffer ();
     buffer = p;
     buffer_size = n;
     own_buffer = false;
-    this->enable_buffer();
+    this->enable_buffer ();
   }
   return this;
 }
 
 // Write put area to gzipped file (i.e. ensures that put area is empty)
 int
-gzfilebuf::sync()
+gzfilebuf::sync ()
 {
-  return traits_type::eq_int_type(this->overflow(), traits_type::eof()) ? -1 : 0;
+  return traits_type::eq_int_type (this->overflow (), traits_type::eof ()) ? -1 : 0;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Allocate internal buffer
 void
-gzfilebuf::enable_buffer()
+gzfilebuf::enable_buffer ()
 {
   // If internal buffer required, allocate one
   if (own_buffer && !buffer)
   {
     // Check for buffered vs. "unbuffered"
     if (buffer_size > 0)
     {
       // Allocate internal buffer
       buffer = new char_type[buffer_size];
       // Get area starts empty and will be expanded by underflow as need arises
-      this->setg(buffer, buffer, buffer);
+      this->setg (buffer, buffer, buffer);
       // Setup entire internal buffer as put area.
       // The one-past-end pointer actually points to the last element of the buffer,
       // so that overflow(c) can safely add the extra character c to the sequence.
       // These pointers remain in place for the duration of the buffer
-      this->setp(buffer, buffer + buffer_size - 1);
+      this->setp (buffer, buffer + buffer_size - 1);
     }
     else
     {
       // Even in "unbuffered" case, (small?) get buffer is still required
       buffer_size = SMALLBUFSIZE;
       buffer = new char_type[buffer_size];
-      this->setg(buffer, buffer, buffer);
+      this->setg (buffer, buffer, buffer);
       // "Unbuffered" means no put buffer
-      this->setp(0, 0);
+      this->setp (0, 0);
     }
   }
   else
   {
     // If buffer already allocated, reset buffer pointers just to make sure no
     // stale chars are lying around
-    this->setg(buffer, buffer, buffer);
-    this->setp(buffer, buffer + buffer_size - 1);
+    this->setg (buffer, buffer, buffer);
+    this->setp (buffer, buffer + buffer_size - 1);
   }
 }
 
 // Destroy internal buffer
 void
-gzfilebuf::disable_buffer()
+gzfilebuf::disable_buffer ()
 {
   // If internal buffer exists, deallocate it
   if (own_buffer && buffer)
   {
     // Preserve unbuffered status by zeroing size
-    if (!this->pbase())
+    if (! this->pbase ())
       buffer_size = 0;
     delete[] buffer;
     buffer = 0;
-    this->setg(0, 0, 0);
-    this->setp(0, 0);
+    this->setg (0, 0, 0);
+    this->setp (0, 0);
   }
   else
   {
     // Reset buffer pointers to initial state if external buffer exists
-    this->setg(buffer, buffer, buffer);
+    this->setg (buffer, buffer, buffer);
     if (buffer)
-      this->setp(buffer, buffer + buffer_size - 1);
+      this->setp (buffer, buffer + buffer_size - 1);
     else
-      this->setp(0, 0);
+      this->setp (0, 0);
   }
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Seek functions
 gzfilebuf::pos_type
-gzfilebuf::seekoff(off_type off, std::ios_base::seekdir way,
+gzfilebuf::seekoff (off_type off, std::ios_base::seekdir way,
                    std::ios_base::openmode)
 {
   pos_type ret = pos_type (off_type (-1));
 
-  if (this->is_open())
+  if (this->is_open ())
     {
       off_type computed_off = off;
 
       if ((io_mode & std::ios_base::in) && way == std::ios_base::cur)
-        computed_off += this->gptr() - this->egptr();
+        computed_off += this->gptr () - this->egptr ();
 
       if (way == std::ios_base::beg)
         ret = pos_type (gzseek (file, computed_off, SEEK_SET));
       else if (way == std::ios_base::cur)
         ret = pos_type (gzseek (file, computed_off, SEEK_CUR));
       else
         // Can't seek from end of a gzipped file, so this will give -1
         ret = pos_type (gzseek (file, computed_off, SEEK_END));
@@ -488,17 +488,17 @@ gzfilebuf::seekoff(off_type off, std::io
         // flush contents of buffer to file
         overflow ();
     }
 
   return ret;
 }
 
 gzfilebuf::pos_type
-gzfilebuf::seekpos(pos_type sp, std::ios_base::openmode)
+gzfilebuf::seekpos (pos_type sp, std::ios_base::openmode)
 {
   pos_type ret = pos_type (off_type (-1));
 
   if (this->is_open ())
     {
       ret = pos_type (gzseek (file, sp, SEEK_SET));
 
       if (io_mode & std::ios_base::in)
@@ -510,116 +510,116 @@ gzfilebuf::seekpos(pos_type sp, std::ios
     }
 
   return ret;
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
-gzifstream::gzifstream()
-: std::istream(0), sb()
-{ this->init(&sb); }
+gzifstream::gzifstream ()
+: std::istream (0), sb ()
+{ this->init (&sb); }
 
 // Initialize stream buffer and open file
-gzifstream::gzifstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::istream(0), sb()
+gzifstream::gzifstream (const char* name,
+                        std::ios_base::openmode mode)
+: std::istream (0), sb ()
 {
-  this->init(&sb);
-  this->open(name, mode);
+  this->init (&sb);
+  this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
-gzifstream::gzifstream(int fd,
-                       std::ios_base::openmode mode)
-: std::istream(0), sb()
+gzifstream::gzifstream (int fd,
+                        std::ios_base::openmode mode)
+: std::istream (0), sb ()
 {
-  this->init(&sb);
-  this->attach(fd, mode);
+  this->init (&sb);
+  this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
-gzifstream::open(const char* name,
-                 std::ios_base::openmode mode)
+gzifstream::open (const char* name,
+                  std::ios_base::openmode mode)
 {
-  if (!sb.open(name, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
+  if (! sb.open (name, mode | std::ios_base::in))
+    this->setstate (std::ios_base::failbit);
   else
-    this->clear();
+    this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
 void
-gzifstream::attach(int fd,
-                   std::ios_base::openmode mode)
+gzifstream::attach (int fd,
+                    std::ios_base::openmode mode)
 {
-  if (!sb.attach(fd, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
+  if (! sb.attach (fd, mode | std::ios_base::in))
+    this->setstate (std::ios_base::failbit);
   else
-    this->clear();
+    this->clear ();
 }
 
 // Close file
 void
-gzifstream::close()
+gzifstream::close ()
 {
-  if (!sb.close())
-    this->setstate(std::ios_base::failbit);
+  if (! sb.close ())
+    this->setstate (std::ios_base::failbit);
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
-gzofstream::gzofstream()
-: std::ostream(0), sb()
-{ this->init(&sb); }
+gzofstream::gzofstream ()
+: std::ostream (0), sb ()
+{ this->init (&sb); }
 
 // Initialize stream buffer and open file
-gzofstream::gzofstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::ostream(0), sb()
+gzofstream::gzofstream (const char* name,
+                        std::ios_base::openmode mode)
+: std::ostream (0), sb ()
 {
-  this->init(&sb);
-  this->open(name, mode);
+  this->init (&sb);
+  this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
-gzofstream::gzofstream(int fd,
-                       std::ios_base::openmode mode)
-: std::ostream(0), sb()
+gzofstream::gzofstream (int fd,
+                        std::ios_base::openmode mode)
+: std::ostream (0), sb ()
 {
-  this->init(&sb);
-  this->attach(fd, mode);
+  this->init (&sb);
+  this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
-gzofstream::open(const char* name,
-                 std::ios_base::openmode mode)
+gzofstream::open (const char* name,
+                  std::ios_base::openmode mode)
 {
-  if (!sb.open(name, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
+  if (! sb.open (name, mode | std::ios_base::out))
+    this->setstate (std::ios_base::failbit);
   else
-    this->clear();
+    this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
 void
-gzofstream::attach(int fd,
-                   std::ios_base::openmode mode)
+gzofstream::attach (int fd,
+                    std::ios_base::openmode mode)
 {
-  if (!sb.attach(fd, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
+  if (! sb.attach (fd, mode | std::ios_base::out))
+    this->setstate (std::ios_base::failbit);
   else
-    this->clear();
+    this->clear ();
 }
 
 // Close file
 void
-gzofstream::close()
+gzofstream::close ()
 {
-  if (!sb.close())
-    this->setstate(std::ios_base::failbit);
+  if (! sb.close ())
+    this->setstate (std::ios_base::failbit);
 }
 
 #endif // HAVE_ZLIB
diff --git a/src/zfstream.h b/src/zfstream.h
--- a/src/zfstream.h
+++ b/src/zfstream.h
@@ -48,154 +48,154 @@ along with Octave; see the file COPYING.
  *  seeking (allowed by zlib but slow/limited), putback and read/write access
  *  (tricky). Otherwise, it attempts to be a drop-in replacement for the standard
  *  file streambuf.
 */
 class gzfilebuf : public std::streambuf
 {
 public:
   //  Default constructor.
-  gzfilebuf();
+  gzfilebuf ();
 
   //  Destructor.
   virtual
-  ~gzfilebuf();
+  ~gzfilebuf ();
 
   /**
    *  @brief  Set compression level and strategy on the fly.
    *  @param  comp_level  Compression level (see zlib.h for allowed values)
    *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)
    *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.
    *
    *  Unfortunately, these parameters cannot be modified separately, as the
    *  previous zfstream version assumed. Since the strategy is seldom changed,
    *  it can default and setcompression(level) then becomes like the old
    *  setcompressionlevel(level).
   */
   int
-  setcompression(int comp_level,
-                 int comp_strategy = Z_DEFAULT_STRATEGY);
+  setcompression (int comp_level,
+                  int comp_strategy = Z_DEFAULT_STRATEGY);
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
-  is_open() const { return (file != 0); }
+  is_open () const { return (file != 0); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  File name.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
-  open(const char* name,
-       std::ios_base::openmode mode);
+  open (const char* name,
+        std::ios_base::openmode mode);
 
   /**
    *  @brief  Attach to already open gzipped file.
    *  @param  fd  File descriptor.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
-  attach(int fd,
-         std::ios_base::openmode mode);
+  attach (int fd,
+          std::ios_base::openmode mode);
 
   /**
    *  @brief  Close gzipped file.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
-  close();
+  close ();
 
 protected:
   /**
    *  @brief  Convert ios open mode int to mode string used by zlib.
    *  @return  True if valid mode flag combination.
   */
   bool
-  open_mode(std::ios_base::openmode mode,
-            char* c_mode) const;
+  open_mode (std::ios_base::openmode mode,
+             char* c_mode) const;
 
   /**
    *  @brief  Number of characters available in stream buffer.
    *  @return  Number of characters.
    *
    *  This indicates number of characters in get area of stream buffer.
    *  These characters can be read without accessing the gzipped file.
   */
   virtual std::streamsize
-  showmanyc();
+  showmanyc ();
 
   /**
    *  @brief  Fill get area from gzipped file.
    *  @return  First character in get area on success, EOF on error.
    *
    *  This actually reads characters from gzipped file to stream
    *  buffer. Always buffered.
   */
   virtual int_type
-  underflow();
+  underflow ();
 
   /**
    *  @brief  Write put area to gzipped file.
    *  @param  c  Extra character to add to buffer contents.
    *  @return  Non-EOF on success, EOF on error.
    *
    *  This actually writes characters in stream buffer to
    *  gzipped file. With unbuffered output this is done one
    *  character at a time.
   */
   virtual int_type
-  overflow(int_type c = traits_type::eof());
+  overflow (int_type c = traits_type::eof ());
 
   /**
    *  @brief  Installs external stream buffer.
    *  @param  p  Pointer to char buffer.
    *  @param  n  Size of external buffer.
    *  @return  @c this on success, NULL on failure.
    *
    *  Call setbuf(0,0) to enable unbuffered output.
   */
   virtual std::streambuf*
-  setbuf(char_type* p,
-         std::streamsize n);
+  setbuf (char_type* p,
+          std::streamsize n);
 
   /**
    *  @brief  Flush stream buffer to file.
    *  @return  0 on success, -1 on error.
    *
    *  This calls underflow(EOF) to do the job.
   */
   virtual int
-  sync();
+  sync ();
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
-  seekoff(off_type off, std::ios_base::seekdir way,
-          std::ios_base::openmode mode =
-          std::ios_base::in|std::ios_base::out);
+  seekoff (off_type off, std::ios_base::seekdir way,
+           std::ios_base::openmode mode =
+           std::ios_base::in|std::ios_base::out);
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
-  seekpos(pos_type sp, std::ios_base::openmode mode =
-          std::ios_base::in|std::ios_base::out);
+  seekpos (pos_type sp, std::ios_base::openmode mode =
+           std::ios_base::in|std::ios_base::out);
 
   virtual int_type
-  pbackfail (int_type c = traits_type::eof());
+  pbackfail (int_type c = traits_type::eof ());
 
 //
 // Some future enhancements
 //
 //  virtual int_type uflow();
 //  virtual int_type pbackfail(int_type c = traits_type::eof());
 
 private:
@@ -210,27 +210,27 @@ private:
    *  @brief  Allocate internal buffer.
    *
    *  This function is safe to call multiple times. It will ensure
    *  that a proper internal buffer exists if it is required. If the
    *  buffer already exists or is external, the buffer pointers will be
    *  reset to their original state.
   */
   void
-  enable_buffer();
+  enable_buffer ();
 
   /**
    *  @brief  Destroy internal buffer.
    *
    *  This function is safe to call multiple times. It will ensure
    *  that the internal buffer is deallocated if it exists. In any
    *  case, it will also reset the buffer pointers.
   */
   void
-  disable_buffer();
+  disable_buffer ();
 
   /**
    *  Underlying file pointer.
   */
   gzFile file;
 
   /**
    *  Mode in which file was opened.
@@ -277,85 +277,85 @@ private:
  *
  *  This class implements ifstream for gzipped files. Seeking and putback
  *  is not supported yet.
 */
 class gzifstream : public std::istream
 {
 public:
   //  Default constructor
-  gzifstream();
+  gzifstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::in).
   */
   explicit
-  gzifstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::in);
+  gzifstream (const char* name,
+              std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Construct stream on already open gzipped file.
    *  @param  fd    File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::in).
   */
   explicit
-  gzifstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::in);
+  gzifstream (int fd,
+              std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  Obtain underlying stream buffer.
   */
   gzfilebuf*
-  rdbuf() const
+  rdbuf () const
   { return const_cast<gzfilebuf*>(&sb); }
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
-  is_open() { return sb.is_open(); }
+  is_open () { return sb.is_open (); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::in).
    *
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail(). This differs from the behavior of
    *  ifstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
    *  you manually clear() the state. The choice is a matter of
    *  convenience.
   */
   void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::in);
+  open (const char* name,
+        std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Attach to already open gzipped file.
    *  @param  fd  File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::in).
    *
    *  Stream will be in state good() if attach succeeded; otherwise
    *  in state fail().
   */
   void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::in);
+  attach (int fd,
+          std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Close gzipped file.
    *
    *  Stream will be in state fail() if close failed.
   */
   void
-  close();
+  close ();
 
 private:
   /**
    *  Underlying stream buffer.
   */
   gzfilebuf sb;
 };
 
@@ -366,85 +366,85 @@ private:
  *
  *  This class implements ofstream for gzipped files. Seeking and putback
  *  is not supported yet.
 */
 class gzofstream : public std::ostream
 {
 public:
   //  Default constructor
-  gzofstream();
+  gzofstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::out).
   */
   explicit
-  gzofstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::out);
+  gzofstream (const char* name,
+              std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Construct stream on already open gzipped file.
    *  @param  fd    File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::out).
   */
   explicit
-  gzofstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::out);
+  gzofstream (int fd,
+              std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  Obtain underlying stream buffer.
   */
   gzfilebuf*
-  rdbuf() const
+  rdbuf () const
   { return const_cast<gzfilebuf*>(&sb); }
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
-  is_open() { return sb.is_open(); }
+  is_open () { return sb.is_open (); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  File name.
    *  @param  mode  Open mode flags (forced to contain ios::out).
    *
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail(). This differs from the behavior of
    *  ofstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
    *  you manually clear() the state. The choice is a matter of
    *  convenience.
   */
   void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::out);
+  open (const char* name,
+        std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Attach to already open gzipped file.
    *  @param  fd  File descriptor.
    *  @param  mode  Open mode flags (forced to contain ios::out).
    *
    *  Stream will be in state good() if attach succeeded; otherwise
    *  in state fail().
   */
   void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::out);
+  attach (int fd,
+          std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Close gzipped file.
    *
    *  Stream will be in state fail() if close failed.
   */
   void
-  close();
+  close ();
 
 private:
   /**
    *  Underlying stream buffer.
   */
   gzfilebuf sb;
 };
 
@@ -462,54 +462,54 @@ template<typename T1, typename T2>
   public:
     // Allows insertor to peek at internals
     template <typename Ta, typename Tb>
       friend gzofstream&
       operator<<(gzofstream&,
                  const gzomanip2<Ta,Tb>&);
 
     // Constructor
-    gzomanip2(gzofstream& (*f)(gzofstream&, T1, T2),
-              T1 v1,
-              T2 v2);
+    gzomanip2 (gzofstream& (*f)(gzofstream&, T1, T2),
+               T1 v1,
+               T2 v2);
   private:
     // Underlying manipulator function
     gzofstream&
     (*func)(gzofstream&, T1, T2);
 
     // Arguments for manipulator function
     T1 val1;
     T2 val2;
   };
 
 /*****************************************************************************/
 
 // Manipulator function thunks through to stream buffer
 inline gzofstream&
-setcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
+setcompression (gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
 {
-  (gzs.rdbuf())->setcompression(l, s);
+  (gzs.rdbuf ())->setcompression (l, s);
   return gzs;
 }
 
 // Manipulator constructor stores arguments
 template<typename T1, typename T2>
   inline
-  gzomanip2<T1,T2>::gzomanip2(gzofstream &(*f)(gzofstream &, T1, T2),
-                              T1 v1,
-                              T2 v2)
+  gzomanip2<T1,T2>::gzomanip2 (gzofstream &(*f)(gzofstream &, T1, T2),
+                               T1 v1,
+                               T2 v2)
   : func(f), val1(v1), val2(v2)
   { }
 
 // Insertor applies underlying manipulator function to stream
 template<typename T1, typename T2>
   inline gzofstream&
   operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)
   { return (*m.func)(s, m.val1, m.val2); }
 
 // Insert this onto stream to simplify setting of compression level
 inline gzomanip2<int,int>
-setcompression(int l, int s = Z_DEFAULT_STRATEGY)
+setcompression (int l, int s = Z_DEFAULT_STRATEGY)
 { return gzomanip2<int,int>(&setcompression, l, s); }
 
 #endif // HAVE_ZLIB
 
 #endif // ZFSTREAM_H
diff --git a/test/classes/@Dork/Dork.m b/test/classes/@Dork/Dork.m
--- a/test/classes/@Dork/Dork.m
+++ b/test/classes/@Dork/Dork.m
@@ -1,16 +1,16 @@
 function [ s ] = Dork( gick, gack )
 
   if (nargin==1) && isa(gick,'Dork')
     s = gick;
   else
     s.gack = 0;
     if nargin == 0
-      s0 = Snork();
+      s0 = Snork ();
     elseif nargin==1
       s0 = Snork(gick);
     else
       s0 = Snork(gick);
       s.gack = gack;
     end
     s = class(s,'Dork',s0);
    end 
diff --git a/test/classes/@Dork/getStash.m b/test/classes/@Dork/getStash.m
--- a/test/classes/@Dork/getStash.m
+++ b/test/classes/@Dork/getStash.m
@@ -1,5 +1,5 @@
 function [ out ] = getStash(cls)
 
-  out = myStash();
+  out = myStash ();
         
 end
diff --git a/test/classes/@Dork/private/myStash.m b/test/classes/@Dork/private/myStash.m
--- a/test/classes/@Dork/private/myStash.m
+++ b/test/classes/@Dork/private/myStash.m
@@ -1,5 +1,5 @@
-function [ out ] = myStash()
+function [ out ] = myStash ()
 
   out = 2;
 
 end
diff --git a/test/classes/@Gork/Gork.m b/test/classes/@Gork/Gork.m
--- a/test/classes/@Gork/Gork.m
+++ b/test/classes/@Gork/Gork.m
@@ -1,15 +1,15 @@
 function [ s ] = Gork( g )
   if (nargin==1) && isa(g,'Gork')
     s = sprk;
     return;
   end
 
-  drk  = Dork();
-  prk  = Pork();
-  blrk = Blork();
+  drk  = Dork ();
+  prk  = Pork ();
+  blrk = Blork ();
   s.Cork = Cork(17);  % Aggregation.
   s.gark = -2;
   s.gyrk = -3;
   s = class(s,'Gork',drk,prk,blrk);
    
 end
diff --git a/test/classes/@Pork/Pork.m b/test/classes/@Pork/Pork.m
--- a/test/classes/@Pork/Pork.m
+++ b/test/classes/@Pork/Pork.m
@@ -1,16 +1,16 @@
 function [ s ] = Pork( geek, gurk )
 
   if (nargin==1) && isa(geek,'Pork')
     s = geek;
   else
     s.gurk = 0;
     if nargin == 0
-      s0 = Spork();
+      s0 = Spork ();
     elseif nargin==1
       s0 = Spork(geek);
     else
       s0 = Spork(geek);
       s.gurk = gurk;
     end
     s = class(s,'Pork',s0);
    end 
diff --git a/test/classes/@Pork/private/myStash.m b/test/classes/@Pork/private/myStash.m
--- a/test/classes/@Pork/private/myStash.m
+++ b/test/classes/@Pork/private/myStash.m
@@ -1,5 +1,5 @@
-function [ out ] = myStash()
+function [ out ] = myStash ()
 
   out = 4;
 
 end
diff --git a/test/classes/@Snork/getStash.m b/test/classes/@Snork/getStash.m
--- a/test/classes/@Snork/getStash.m
+++ b/test/classes/@Snork/getStash.m
@@ -1,5 +1,5 @@
 function [ out ] = getStash(cls)
 
-  out = myStash();
+  out = myStash ();
         
 end
diff --git a/test/classes/@Snork/private/myStash.m b/test/classes/@Snork/private/myStash.m
--- a/test/classes/@Snork/private/myStash.m
+++ b/test/classes/@Snork/private/myStash.m
@@ -1,5 +1,5 @@
-function [ out ] = myStash()
+function [ out ] = myStash ()
 
   out = 1;
         
 end
diff --git a/test/classes/@Spork/getStash.m b/test/classes/@Spork/getStash.m
--- a/test/classes/@Spork/getStash.m
+++ b/test/classes/@Spork/getStash.m
@@ -1,5 +1,5 @@
 function [ out ] = getStash(cls)
 
-  out = myStash();
+  out = myStash ();
         
 end
diff --git a/test/classes/@Spork/private/myStash.m b/test/classes/@Spork/private/myStash.m
--- a/test/classes/@Spork/private/myStash.m
+++ b/test/classes/@Spork/private/myStash.m
@@ -1,5 +1,5 @@
-function [ out ] = myStash()
+function [ out ] = myStash ()
 
   out = 3;
         
 end
diff --git a/test/fntests.m b/test/fntests.m
--- a/test/fntests.m
+++ b/test/fntests.m
@@ -21,17 +21,17 @@ clear all;
 global files_with_no_tests = {};
 global files_with_tests = {};
 global topsrcdir;
 global topbuilddir;
 
 currdir = canonicalize_file_name (".");
 
 if (nargin == 1)
-  xdir = argv(){1};
+  xdir = argv (){1};
 else
   xdir = ".";
 endif
 
 srcdir = canonicalize_file_name (xdir);
 topsrcdir = canonicalize_file_name (fullfile (xdir, ".."));
 topbuilddir = canonicalize_file_name (fullfile (currdir, ".."));
 
