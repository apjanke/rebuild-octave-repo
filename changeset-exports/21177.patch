# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1454449981 18000
#      Tue Feb 02 16:53:01 2016 -0500
# Node ID a10f60e13243c231e07ae2970bbe4781331cca56
# Parent  791dcb32b657722923a0fa9d0466ca6de8e3626e
style fixes in liboctave/numeric directory

* base-qr.h, randgamma.h, randmtzig.h, randpoisson.h, sparse-chol.cc,
sparse-chol.h, sparse-dmsolve.cc, sparse-lu.cc, sparse-lu.h,
sparse-qr.cc, sparse-qr.h, oct-sparse.h: Style fixes.

diff --git a/liboctave/numeric/base-qr.h b/liboctave/numeric/base-qr.h
--- a/liboctave/numeric/base-qr.h
+++ b/liboctave/numeric/base-qr.h
@@ -50,16 +50,17 @@ public:
 
   base_qr& operator = (const base_qr& a)
   {
     if (this != &a)
       {
         q = a.q;
         r = a.r;
       }
+
     return *this;
   }
 
   virtual ~base_qr (void) { }
 
   qr_type Q (void) const { return q; }
 
   qr_type R (void) const { return r; }
@@ -69,13 +70,13 @@ public:
   bool regular (void) const;
 
 protected:
 
   qr_type q;
   qr_type r;
 };
 
-#ifndef HAVE_QRUPDATE
-void warn_qrupdate_once (void);
+#if ! defined (HAVE_QRUPDATE)
+extern void warn_qrupdate_once (void);
 #endif
 
 #endif
diff --git a/liboctave/numeric/randgamma.h b/liboctave/numeric/randgamma.h
--- a/liboctave/numeric/randgamma.h
+++ b/liboctave/numeric/randgamma.h
@@ -18,25 +18,27 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
-#ifndef _RANDGAMMA_H
+#if ! defined (octave_randgamma_h)
+#define octave_radgamma_h 1
 
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
 extern OCTAVE_API double oct_randg (double a);
 extern OCTAVE_API void oct_fill_randg (double a, octave_idx_type n, double *p);
 
 extern OCTAVE_API float oct_float_randg (float a);
 extern OCTAVE_API void oct_fill_float_randg (float a, octave_idx_type n,
                                              float *p);
 
 #ifdef  __cplusplus
 }
 #endif
+
 #endif
diff --git a/liboctave/numeric/randmtzig.h b/liboctave/numeric/randmtzig.h
--- a/liboctave/numeric/randmtzig.h
+++ b/liboctave/numeric/randmtzig.h
@@ -56,46 +56,47 @@ along with Octave; see the file COPYING.
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 */
 
-#ifndef _RANDMTZIG_H
-#define _RANDMTZIG_H
+#if !defined (octave_randmtzig_h)
+#define octave__randmtzig_h 1
 
 #define MT_N 624
 
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
-/* === Mersenne Twister === */
+/* Mersenne Twister.  */
 extern OCTAVE_API void oct_init_by_int (uint32_t s);
-extern OCTAVE_API void oct_init_by_array (uint32_t init_key[], int key_length);
+extern OCTAVE_API void oct_init_by_array (uint32_t *init_key, int key_length);
 extern OCTAVE_API void oct_init_by_entropy (void);
-extern OCTAVE_API void oct_set_state (uint32_t save[]);
-extern OCTAVE_API void oct_get_state (uint32_t save[]);
+extern OCTAVE_API void oct_set_state (uint32_t *save);
+extern OCTAVE_API void oct_get_state (uint32_t *save);
 
-/* === Array generators === */
+/* Array generators.  */
 extern OCTAVE_API double oct_randu (void);
 extern OCTAVE_API double oct_randn (void);
 extern OCTAVE_API double oct_rande (void);
 
 extern OCTAVE_API float oct_float_randu (void);
 extern OCTAVE_API float oct_float_randn (void);
 extern OCTAVE_API float oct_float_rande (void);
 
-/* === Array generators === */
+/* Array generators.  */
 extern OCTAVE_API void oct_fill_randu (octave_idx_type n, double *p);
 extern OCTAVE_API void oct_fill_randn (octave_idx_type n, double *p);
 extern OCTAVE_API void oct_fill_rande (octave_idx_type n, double *p);
 
 extern OCTAVE_API void oct_fill_float_randu (octave_idx_type n, float *p);
 extern OCTAVE_API void oct_fill_float_randn (octave_idx_type n, float *p);
 extern OCTAVE_API void oct_fill_float_rande (octave_idx_type n, float *p);
 
 #ifdef  __cplusplus
 }
 #endif
+
 #endif
diff --git a/liboctave/numeric/randpoisson.h b/liboctave/numeric/randpoisson.h
--- a/liboctave/numeric/randpoisson.h
+++ b/liboctave/numeric/randpoisson.h
@@ -18,25 +18,32 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
-#ifndef _RANDPOISSON_H
+#if ! defined (octave_randpoisson_h)
+#define octave_randpoisson_h 1
 
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
-extern OCTAVE_API double oct_randp (double L);
-extern OCTAVE_API void oct_fill_randp (double L, octave_idx_type n, double *p);
+extern OCTAVE_API double
+oct_randp (double L);
+
+extern OCTAVE_API void
+oct_fill_randp (double L, octave_idx_type n, double *p);
 
-extern OCTAVE_API float oct_float_randp (float L);
-extern OCTAVE_API void oct_fill_float_randp (float L, octave_idx_type n,
-                                             float *p);
+extern OCTAVE_API float
+oct_float_randp (float L);
+
+extern OCTAVE_API void
+oct_fill_float_randp (float L, octave_idx_type n, float *p);
 
 #ifdef  __cplusplus
 }
 #endif
+
 #endif
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -1,10 +1,11 @@
 /*
 
+Copyright (C) 2016 John W. Eaton
 Copyright (C) 2005-2015 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -132,49 +133,49 @@ private:
 
 // Can't use CHOLMOD_NAME(drop)(0.0, S, cm) because it doesn't treat
 // complex matrices.
 
 template <typename chol_type>
 void
 sparse_chol<chol_type>::sparse_chol_rep::drop_zeros (const cholmod_sparse *S)
 {
-  chol_elt sik;
-  octave_idx_type *Sp, *Si;
-  chol_elt *Sx;
-  octave_idx_type pdest, k, ncol, p, pend;
-
   if (! S)
     return;
 
-  Sp = static_cast<octave_idx_type *>(S->p);
-  Si = static_cast<octave_idx_type *>(S->i);
-  Sx = static_cast<chol_elt *>(S->x);
-  pdest = 0;
-  ncol = S->ncol;
+  octave_idx_type *Sp = static_cast<octave_idx_type *>(S->p);
+  octave_idx_type *Si = static_cast<octave_idx_type *>(S->i);
+  chol_elt *Sx = static_cast<chol_elt *>(S->x);
+
+  octave_idx_type pdest = 0;
+  octave_idx_type ncol = S->ncol;
 
-  for (k = 0; k < ncol; k++)
+  for (octave_idx_type k = 0; k < ncol; k++)
     {
-      p = Sp[k];
-      pend = Sp[k+1];
+      octave_idx_type p = Sp[k];
+      octave_idx_type pend = Sp[k+1];
       Sp[k] = pdest;
+
       for (; p < pend; p++)
         {
-          sik = Sx[p];
+          chol_elt sik = Sx[p];
+
           if (CHOLMOD_IS_NONZERO (sik))
             {
               if (p != pdest)
                 {
                   Si[pdest] = Si[p];
                   Sx[pdest] = sik;
                 }
+
               pdest++;
             }
         }
     }
+
   Sp[ncol] = pdest;
 }
 
 // Must provide a specialization for this function.
 template <typename T>
 int
 get_xtype (void);
 
@@ -197,54 +198,59 @@ get_xtype<Complex> (void)
 template <typename chol_type>
 octave_idx_type
 sparse_chol<chol_type>::sparse_chol_rep::init (const chol_type& a,
                                                bool natural, bool force)
 {
   volatile octave_idx_type info = 0;
 
 #ifdef HAVE_CHOLMOD
+
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     (*current_liboctave_error_handler) ("sparse_chol requires square matrix");
 
   cholmod_common *cm = &Common;
 
   // Setup initial parameters
+
   CHOLMOD_NAME(start) (cm);
   cm->prefer_zomplex = false;
 
   double spu = octave_sparse_params::get_key ("spumoni");
+
   if (spu == 0.)
     {
       cm->print = -1;
       SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
     }
   else
     {
       cm->print = static_cast<int> (spu) + 2;
       SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
     }
 
   cm->error_handler = &SparseCholError;
+
   SUITESPARSE_ASSIGN_FPTR2 (divcomplex_func, cm->complex_divide, divcomplex);
   SUITESPARSE_ASSIGN_FPTR2 (hypot_func, cm->hypotenuse, hypot);
 
   cm->final_asis = false;
   cm->final_super = false;
   cm->final_ll = true;
   cm->final_pack = true;
   cm->final_monotonic = true;
   cm->final_resymbol = false;
 
   cholmod_sparse A;
   cholmod_sparse *ac = &A;
   double dummy;
+
   ac->nrow = a_nr;
   ac->ncol = a_nc;
 
   ac->p = a.cidx ();
   ac->i = a.ridx ();
   ac->nzmax = a.nnz ();
   ac->packed = true;
   ac->sorted = true;
@@ -297,16 +303,17 @@ sparse_chol<chol_type>::sparse_chol_rep:
           size_t n1 = a_nr + 1;
           Lsparse->p = CHOLMOD_NAME(realloc) (minor_p+1,
                                               sizeof(octave_idx_type),
                                               Lsparse->p, &n1, cm);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CHOLMOD_NAME(reallocate_sparse)
             (static_cast<octave_idx_type *>(Lsparse->p)[minor_p], Lsparse, cm);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
           Lsparse->ncol = minor_p;
         }
 
       drop_zeros (Lsparse);
 
       if (! natural)
         {
           perms.resize (a_nr);
@@ -331,30 +338,35 @@ sparse_chol<chol_type>::sparse_chol_rep:
 #endif
 }
 
 template <typename chol_type>
 SparseMatrix
 sparse_chol<chol_type>::sparse_chol_rep::Q (void) const
 {
 #ifdef HAVE_CHOLMOD
+
   octave_idx_type n = Lsparse->nrow;
   SparseMatrix p (n, n, n);
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       p.xcidx (i) = i;
       p.xridx (i) = static_cast<octave_idx_type>(perms (i));
       p.xdata (i) = 1;
     }
+
   p.xcidx (n) = n;
 
   return p;
+
 #else
+
   return SparseMatrix ();
+
 #endif
 }
 
 template <typename chol_type>
 sparse_chol<chol_type>::sparse_chol (void)
   : rep (new typename sparse_chol<chol_type>::sparse_chol_rep ())
 { }
 
@@ -415,30 +427,39 @@ sparse_chol<chol_type>::operator = (cons
   return *this;
 }
 
 template <typename chol_type>
 chol_type
 sparse_chol<chol_type>::L (void) const
 {
 #ifdef HAVE_CHOLMOD
+
   cholmod_sparse *m = rep->L ();
+
   octave_idx_type nc = m->ncol;
   octave_idx_type nnz = m->nzmax;
+
   chol_type ret (m->nrow, nc, nnz);
+
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = static_cast<octave_idx_type *>(m->p)[j];
+
   for (octave_idx_type i = 0; i < nnz; i++)
     {
       ret.xridx (i) = static_cast<octave_idx_type *>(m->i)[i];
       ret.xdata (i) = static_cast<chol_elt *>(m->x)[i];
     }
+
   return ret;
+
 #else
+
   return chol_type ();
+
 #endif
 }
 
 template <typename chol_type>
 octave_idx_type
 sparse_chol<chol_type>::P (void) const
 {
   return rep->P ();
@@ -472,33 +493,38 @@ sparse_chol<chol_type>::rcond (void) con
   return rep->rcond ();
 }
 
 template <typename chol_type>
 chol_type
 sparse_chol<chol_type>::inverse (void) const
 {
   chol_type retval;
+
 #ifdef HAVE_CHOLMOD
+
   cholmod_sparse *m = rep->L ();
   octave_idx_type n = m->ncol;
   ColumnVector perms = rep->perm ();
   double rcond2;
   octave_idx_type info;
   MatrixType mattype (MatrixType::Upper);
   chol_type linv = L ().hermitian ().inverse (mattype, info, rcond2, 1, 0);
 
   if (perms.numel () == n)
     {
       SparseMatrix Qc = Q ();
+
       retval = Qc * linv * linv.hermitian () * Qc.transpose ();
     }
   else
     retval = linv * linv.hermitian ();
+
 #endif
+
   return retval;
 }
 
 template <typename chol_type>
 chol_type
 chol2inv (const chol_type& r)
 {
   octave_idx_type r_nr = r.rows ();
diff --git a/liboctave/numeric/sparse-chol.h b/liboctave/numeric/sparse-chol.h
--- a/liboctave/numeric/sparse-chol.h
+++ b/liboctave/numeric/sparse-chol.h
@@ -1,10 +1,11 @@
 /*
 
+Copyright (C) 2016 John W. Eaton
 Copyright (C) 2005-2015 David Bateman
 Copyright (C) 1998-2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -24,16 +25,21 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_sparse_chol_h)
 #define octave_sparse_chol_h 1
 
 #include "CSparse.h"
 #include "dColVector.h"
 #include "dSparse.h"
 #include "oct-sparse.h"
 
+// If the sparse matrix classes become templated on the element type
+// (i.e., sparse_matrix<double>), then it might be best to make the
+// template parameter of this class also be the element type instead
+// of the matrix type.
+
 template <typename chol_type>
 class
 sparse_chol
 {
 public:
 
   sparse_chol (void);
 
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -1,10 +1,11 @@
 /*
 
+Copyright (C) 2016 John W. Eaton
 Copyright (C) 2006-2015 David Bateman
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -39,212 +40,263 @@ static MSparse<T>
 dmsolve_extract (const MSparse<T> &A, const octave_idx_type *Pinv,
                  const octave_idx_type *Q, octave_idx_type rst,
                  octave_idx_type rend, octave_idx_type cst,
                  octave_idx_type cend, octave_idx_type maxnz = -1,
                  bool lazy = false)
 {
   octave_idx_type nr = rend - rst;
   octave_idx_type nc = cend - cst;
+
   maxnz = (maxnz < 0 ? A.nnz () : maxnz);
+
   octave_idx_type nz;
 
   // Cast to uint64 to handle overflow in this multiplication
   if (octave_uint64 (nr)*octave_uint64 (nc) < octave_uint64 (maxnz))
     nz = nr*nc;
   else
     nz = maxnz;
 
   MSparse<T> B (nr, nc, (nz < maxnz ? nz : maxnz));
+
   // Some sparse functions can support lazy indexing (where elements
   // in the row are in no particular order), even though octave in
   // general can't. For those functions that can using it is a big
   // win here in terms of speed.
+
   if (lazy)
     {
       nz = 0;
+
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
           octave_idx_type qq = (Q ? Q[j] : j);
+
           B.xcidx (j - cst) = nz;
+
           for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
+
               octave_idx_type r = (Pinv ? Pinv[A.ridx (p)] : A.ridx (p));
+
               if (r >= rst && r < rend)
                 {
                   B.xdata (nz) = A.data (p);
                   B.xridx (nz++) = r - rst ;
                 }
             }
         }
+
       B.xcidx (cend - cst) = nz ;
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, X, rend - rst);
+
       octave_sort<octave_idx_type> sort;
       octave_idx_type *ri = B.xridx ();
+
       nz = 0;
+
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
           octave_idx_type qq = (Q ? Q[j] : j);
+
           B.xcidx (j - cst) = nz;
+
           for (octave_idx_type p = A.cidx (qq) ; p < A.cidx (qq+1) ; p++)
             {
               octave_quit ();
+
               octave_idx_type r = (Pinv ? Pinv[A.ridx (p)] : A.ridx (p));
+
               if (r >= rst && r < rend)
                 {
                   X[r-rst] = A.data (p);
                   B.xridx (nz++) = r - rst ;
                 }
             }
+
           sort.sort (ri + B.xcidx (j - cst), nz - B.xcidx (j - cst));
+
           for (octave_idx_type p = B.cidx (j - cst); p < nz; p++)
             B.xdata (p) = X[B.xridx (p)];
         }
+
       B.xcidx (cend - cst) = nz ;
     }
 
   return B;
 }
 
 template <typename T>
 static MArray<T>
 dmsolve_extract (const MArray<T> &m, const octave_idx_type *,
                  const octave_idx_type *, octave_idx_type r1,
                  octave_idx_type r2, octave_idx_type c1,
                  octave_idx_type c2)
 {
   r2 -= 1;
   c2 -= 1;
-  if (r1 > r2) { std::swap (r1, r2); }
-  if (c1 > c2) { std::swap (c1, c2); }
+
+  if (r1 > r2)
+    std::swap (r1, r2);
+
+  if (c1 > c2)
+    std::swap (c1, c2);
 
   octave_idx_type new_r = r2 - r1 + 1;
   octave_idx_type new_c = c2 - c1 + 1;
 
   MArray<T> result (dim_vector (new_r, new_c));
 
   for (octave_idx_type j = 0; j < new_c; j++)
-    for (octave_idx_type i = 0; i < new_r; i++)
-      result.xelem (i, j) = m.elem (r1+i, c1+j);
+    {
+      for (octave_idx_type i = 0; i < new_r; i++)
+        result.xelem (i, j) = m.elem (r1+i, c1+j);
+    }
 
   return result;
 }
 
 template <typename T>
 static void
 dmsolve_insert (MArray<T> &a, const MArray<T> &b, const octave_idx_type *Q,
                 octave_idx_type r, octave_idx_type c)
 {
   T *ax = a.fortran_vec ();
+
   const T *bx = b.fortran_vec ();
+
   octave_idx_type anr = a.rows ();
+
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
+
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type aoff = (c + j) * anr;
       octave_idx_type boff = j * nr;
+
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_quit ();
           ax[Q[r + i] + aoff] = bx[i + boff];
         }
     }
 }
 
 template <typename T>
 static void
 dmsolve_insert (MSparse<T> &a, const MSparse<T> &b, const octave_idx_type *Q,
                 octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type b_rows = b.rows ();
   octave_idx_type b_cols = b.cols ();
+
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Qinv, nr);
+
   for (octave_idx_type i = 0; i < nr; i++)
     Qinv[Q[i]] = i;
 
   // First count the number of elements in the final array
   octave_idx_type nel = a.xcidx (c) + b.nnz ();
 
   if (c + b_cols < nc)
     nel += a.xcidx (nc) - a.xcidx (c + b_cols);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
-    for (octave_idx_type j = a.xcidx (i); j < a.xcidx (i+1); j++)
-      if (Qinv[a.xridx (j)] < r || Qinv[a.xridx (j)] >= r + b_rows)
-        nel++;
+    {
+      for (octave_idx_type j = a.xcidx (i); j < a.xcidx (i+1); j++)
+        {
+          if (Qinv[a.xridx (j)] < r || Qinv[a.xridx (j)] >= r + b_rows)
+            nel++;
+        }
+    }
 
   OCTAVE_LOCAL_BUFFER (T, X, nr);
+
   octave_sort<octave_idx_type> sort;
+
   MSparse<T> tmp (a);
+
   a = MSparse<T> (nr, nc, nel);
+
   octave_idx_type *ri = a.xridx ();
 
   for (octave_idx_type i = 0; i < tmp.cidx (c); i++)
     {
       a.xdata (i) = tmp.xdata (i);
       a.xridx (i) = tmp.xridx (i);
     }
+
   for (octave_idx_type i = 0; i < c + 1; i++)
     a.xcidx (i) = tmp.xcidx (i);
 
   octave_idx_type ii = a.xcidx (c);
 
   for (octave_idx_type i = c; i < c + b_cols; i++)
     {
       octave_quit ();
 
       for (octave_idx_type j = tmp.xcidx (i); j < tmp.xcidx (i+1); j++)
-        if (Qinv[tmp.xridx (j)] < r ||  Qinv[tmp.xridx (j)] >= r + b_rows)
-          {
-            X[tmp.xridx (j)] = tmp.xdata (j);
-            a.xridx (ii++) = tmp.xridx (j);
-          }
+        {
+          if (Qinv[tmp.xridx (j)] < r ||  Qinv[tmp.xridx (j)] >= r + b_rows)
+            {
+              X[tmp.xridx (j)] = tmp.xdata (j);
+              a.xridx (ii++) = tmp.xridx (j);
+            }
+        }
 
       octave_quit ();
 
       for (octave_idx_type j = b.cidx (i-c); j < b.cidx (i-c+1); j++)
         {
           X[Q[r + b.ridx (j)]] = b.data (j);
           a.xridx (ii++) = Q[r + b.ridx (j)];
         }
 
       sort.sort (ri + a.xcidx (i), ii - a.xcidx (i));
+
       for (octave_idx_type p = a.xcidx (i); p < ii; p++)
         a.xdata (p) = X[a.xridx (p)];
+
       a.xcidx (i+1) = ii;
     }
 
   for (octave_idx_type i = c + b_cols; i < nc; i++)
     {
       for (octave_idx_type j = tmp.xcidx (i); j < tmp.cidx (i+1); j++)
         {
           a.xdata (ii) = tmp.xdata (j);
           a.xridx (ii++) = tmp.xridx (j);
         }
+
       a.xcidx (i+1) = ii;
     }
 }
 
 template <typename T, typename RT>
 static void
 dmsolve_permute (MArray<RT> &a, const MArray<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
+
   const T *Bx = b.fortran_vec ();
+
   a.resize (dim_vector (b_nr, b_nc));
+
   RT *Btx = a.fortran_vec ();
+
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       octave_idx_type off = j * b_nr;
       for (octave_idx_type i = 0; i < b_nr; i++)
         {
           octave_quit ();
           Btx[p[i] + off] = Bx[ i + off];
         }
@@ -253,108 +305,124 @@ dmsolve_permute (MArray<RT> &a, const MA
 
 template <typename T, typename RT>
 static void
 dmsolve_permute (MSparse<RT> &a, const MSparse<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nz = b.nnz ();
+
   octave_idx_type nz = 0;
+
   a = MSparse<RT> (b_nr, b_nc, b_nz);
   octave_sort<octave_idx_type> sort;
   octave_idx_type *ri = a.xridx ();
+
   OCTAVE_LOCAL_BUFFER (RT, X, b_nr);
+
   a.xcidx (0) = 0;
+
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
         {
           octave_quit ();
           octave_idx_type r = p[b.ridx (i)];
           X[r] = b.data (i);
           a.xridx (nz++) = p[b.ridx (i)];
         }
+
       sort.sort (ri + a.xcidx (j), nz - a.xcidx (j));
+
       for (octave_idx_type i = a.cidx (j); i < nz; i++)
         {
           octave_quit ();
           a.xdata (i) = X[a.xridx (i)];
         }
+
       a.xcidx (j+1) = nz;
     }
 }
 
 static void
 solve_singularity_warning (double)
 {
   // Dummy singularity handler so that LU solver doesn't flag
   // an error for numerically rank defficient matrices
 }
 
 template <typename RT, typename ST, typename T>
 RT
 dmsolve (const ST &a, const T &b, octave_idx_type &info)
 {
 #ifdef HAVE_CXSPARSE
+
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
+
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
+
   RT retval;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = RT (nc, b_nc, 0.0);
   else
     {
       octave_idx_type nnz_remaining = a.nnz ();
+
       CXSPARSE_DNAME () csm;
+
       csm.m = nr;
       csm.n = nc;
       csm.x = 0;
       csm.nz = -1;
       csm.nzmax = a.nnz ();
+
       // Cast away const on A, with full knowledge that CSparse won't touch it.
       // Prevents the methods below making a copy of the data.
       csm.p = const_cast<octave_idx_type *>(a.cidx ());
       csm.i = const_cast<octave_idx_type *>(a.ridx ());
 
       CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm, 0);
       octave_idx_type *p = dm->p;
       octave_idx_type *q = dm->q;
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, pinv, nr);
+
       for (octave_idx_type i = 0; i < nr; i++)
         pinv[p[i]] = i;
+
       RT btmp;
       dmsolve_permute (btmp, b, pinv);
       info = 0;
+
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
       if (dm->rr[2] < nr && dm->cc[3] < nc)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr[2], nr, dm->cc[3], nc,
                                   nnz_remaining, true);
           nnz_remaining -= m.nnz ();
-          RT mtmp =
-            qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
-                                         b_nc), info);
+          RT mtmp = qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2],
+                                                 b_nr, 0, b_nc), info);
           dmsolve_insert (retval, mtmp, q, dm->cc[3], 0);
+
           if (dm->rr[2] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[2],
                                    dm->cc[3], nc, nnz_remaining, true);
               nnz_remaining -= m.nnz ();
-              RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
-                                         dm->rr[2], 0, b_nc);
+              RT ctmp = dmsolve_extract (btmp, 0, 0, 0, dm->rr[2], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Structurally non-singular blocks
       // FIXME: Should use fine Dulmange-Mendelsohn decomposition here.
       if (dm->rr[1] < dm->rr[2] && dm->cc[2] < dm->cc[3] && ! info)
         {
@@ -374,34 +442,35 @@ dmsolve (const ST &a, const T &b, octave
             }
 
           dmsolve_insert (retval, mtmp, q, dm->cc[2], 0);
           if (dm->rr[1] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], dm->cc[2],
                                    dm->cc[3], nnz_remaining, true);
               nnz_remaining -= m.nnz ();
-              RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
-                                         dm->rr[1], 0, b_nc);
+              RT ctmp = dmsolve_extract (btmp, 0, 0, 0, dm->rr[1], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Trailing under-determined block
       if (dm->rr[1] > 0 && dm->cc[2] > 0 && ! info)
         {
           ST m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], 0,
                                   dm->cc[2], nnz_remaining, true);
-          RT mtmp =
-            qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1] , 0,
-                                         b_nc), info);
+          RT mtmp = qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1],
+                                                 0, b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
+
   return retval;
 
 #else
+
   (*current_liboctave_error_handler)
     ("support for CXSparse was unavailable or disabled when liboctave was built");
+
 #endif
 }
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -1,10 +1,11 @@
 /*
 
+Copyright (C) 2016 John W. Eaton
 Copyright (C) 2004-2015 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -386,16 +387,17 @@ sparse_lu<lu_type>::sparse_lu (const lu_
   if (! xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
 
   if (piv_thres.numel () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
       if (! xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
+
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
       if (! xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
   else
     {
       tmp = octave_sparse_params::get_key ("piv_tol");
       if (! xisnan (tmp))
@@ -541,30 +543,33 @@ sparse_lu<lu_type>::sparse_lu (const lu_
                 }
 
               umfpack_report_info<lu_elt_type> (control, info);
             }
         }
     }
 
 #else
+
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
+
 #endif
 }
 
 template <typename lu_type>
 sparse_lu<lu_type>::sparse_lu (const lu_type& a,
                                const ColumnVector& Qinit,
                                const Matrix& piv_thres, bool scale,
                                bool FixedQ, double droptol,
                                bool milu, bool udiag)
   : Lfact (), Ufact (), Rfact (), cond (0), P (), Q ()
 {
 #ifdef HAVE_UMFPACK
+
   if (milu)
     (*current_liboctave_error_handler)
       ("Modified incomplete LU not implemented");
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
@@ -755,18 +760,20 @@ sparse_lu<lu_type>::sparse_lu (const lu_
         }
     }
 
   if (udiag)
     (*current_liboctave_error_handler)
       ("Option udiag of incomplete LU not implemented");
 
 #else
+
   (*current_liboctave_error_handler)
     ("support for UMFPACK was unavailable or disabled when liboctave was built");
+
 #endif
 }
 
 template <typename lu_type>
 lu_type
 sparse_lu<lu_type>::Y (void) const
 {
   octave_idx_type nr = Lfact.rows ();
@@ -779,57 +786,58 @@ sparse_lu<lu_type>::Y (void) const
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx (j + 1); i++)
         {
           Yout.xridx (ii) = Ufact.ridx (i);
           Yout.xdata (ii++) = Ufact.data (i);
         }
+
       if (j < nz)
         {
           // Note the +1 skips the 1.0 on the diagonal
           for (octave_idx_type i = Lfact.cidx (j) + 1;
                i < Lfact.cidx (j +1); i++)
             {
               Yout.xridx (ii) = Lfact.ridx (i);
               Yout.xdata (ii++) = Lfact.data (i);
             }
         }
+
       Yout.xcidx (j + 1) = ii;
     }
 
   return Yout;
 }
 
 template <typename lu_type>
 SparseMatrix
 sparse_lu<lu_type>::Pr (void) const
 {
-
   octave_idx_type nr = Lfact.rows ();
 
   SparseMatrix Pout (nr, nr, nr);
 
   for (octave_idx_type i = 0; i < nr; i++)
     {
       Pout.cidx (i) = i;
       Pout.ridx (P (i)) = i;
       Pout.data (i) = 1;
     }
+
   Pout.cidx (nr) = nr;
 
   return Pout;
 }
 
 template <typename lu_type>
 ColumnVector
 sparse_lu<lu_type>::Pr_vec (void) const
 {
-
   octave_idx_type nr = Lfact.rows ();
 
   ColumnVector Pout (nr);
 
   for (octave_idx_type i = 0; i < nr; i++)
     Pout.xelem (i) = static_cast<double> (P(i) + 1);
 
   return Pout;
@@ -851,26 +859,26 @@ sparse_lu<lu_type>::Pc (void) const
   SparseMatrix Pout (nc, nc, nc);
 
   for (octave_idx_type i = 0; i < nc; i++)
     {
       Pout.cidx (i) = i;
       Pout.ridx (i) = Q (i);
       Pout.data (i) = 1;
     }
+
   Pout.cidx (nc) = nc;
 
   return Pout;
 }
 
 template <typename lu_type>
 ColumnVector
 sparse_lu<lu_type>::Pc_vec (void) const
 {
-
   octave_idx_type nc = Ufact.cols ();
 
   ColumnVector Pout (nc);
 
   for (octave_idx_type i = 0; i < nc; i++)
     Pout.xelem (i) = static_cast<double> (Q(i) + 1);
 
   return Pout;
diff --git a/liboctave/numeric/sparse-lu.h b/liboctave/numeric/sparse-lu.h
--- a/liboctave/numeric/sparse-lu.h
+++ b/liboctave/numeric/sparse-lu.h
@@ -1,10 +1,11 @@
 /*
 
+Copyright (C) 2016 John W. Eaton
 Copyright (C) 2004-2015 David Bateman
 Copyright (C) 1998-2004 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -23,16 +24,21 @@ along with Octave; see the file COPYING.
 
 
 #if ! defined (octave_sparse_lu_h)
 #define octave_sparse_lu_h 1
 
 #include "MArray.h"
 #include "dSparse.h"
 
+// If the sparse matrix classes become templated on the element type
+// (i.e., sparse_matrix<double>), then it might be best to make the
+// template parameter of this class also be the element type instead
+// of the matrix type.
+
 template <typename lu_type>
 class
 sparse_lu
 {
 public:
 
   typedef typename lu_type::element_type lu_elt_type;
 
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -1,12 +1,12 @@
 /*
 
+Copyright (C) 2016 John W. Eaton
 Copyright (C) 2005-2015 David Bateman
-Copyright (C) 2016 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -38,45 +38,45 @@ public:
   typedef void numeric_type;
 };
 
 template <>
 class
 cxsparse_types<SparseMatrix>
 {
 public:
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
   typedef CXSPARSE_DNAME (s) symbolic_type;
   typedef CXSPARSE_DNAME (n) numeric_type;
 #endif
 };
 
 template <>
 class
 cxsparse_types<SparseComplexMatrix>
 {
 public:
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
   typedef CXSPARSE_ZNAME (s) symbolic_type;
   typedef CXSPARSE_ZNAME (n) numeric_type;
 #endif
 };
 
 template <typename SPARSE_T>
 class sparse_qr<SPARSE_T>::sparse_qr_rep
 {
 public:
 
   sparse_qr_rep (const SPARSE_T& a, int order);
 
   ~sparse_qr_rep (void);
 
   bool ok (void) const
   {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
     return (N && S);
 #else
     return false;
 #endif
   }
 
   SPARSE_T V (void) const;
 
@@ -116,283 +116,354 @@ private:
 
   sparse_qr_rep& operator = (const sparse_qr_rep&);
 };
 
 template <typename SPARSE_T>
 ColumnVector
 sparse_qr<SPARSE_T>::sparse_qr_rep::Pinv (void) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
+
   ColumnVector ret (N->L->m);
+
   for (octave_idx_type i = 0; i < N->L->m; i++)
     ret.xelem (i) = S->pinv[i];
+
   return ret;
+
 #else
+
   return ColumnVector ();
+
 #endif
 }
 
 template <typename SPARSE_T>
 ColumnVector
 sparse_qr<SPARSE_T>::sparse_qr_rep::P (void) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
+
   ColumnVector ret (N->L->m);
+
   for (octave_idx_type i = 0; i < N->L->m; i++)
     ret.xelem (S->pinv[i]) = i;
+
   return ret;
+
 #else
+
   return ColumnVector ();
+
 #endif
 }
 
 // Specializations.
 
 // Real-valued matrices.
 
 template <>
 sparse_qr<SparseMatrix>::sparse_qr_rep::sparse_qr_rep
   (const SparseMatrix& a, int order)
     : count (1), nrows (a.rows ()), ncols (a.columns ())
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
     , S (0), N (0)
 #endif
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
+
   CXSPARSE_DNAME () A;
+
   A.nzmax = a.nnz ();
   A.m = nrows;
   A.n = ncols;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<double *>(a.data ());
   A.nz = -1;
+
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   S = CXSPARSE_DNAME (_sqr) (order, &A, 1);
   N = CXSPARSE_DNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
   if (! N)
     (*current_liboctave_error_handler)
       ("sparse_qr: sparse matrix QR factorization filled");
 
   count = 1;
 
 #else
+
   (*current_liboctave_error_handler)
     ("sparse_qr: support for CXSparse was unavailable or disabled when liboctave was built");
+
 #endif
 }
 
 template <>
 sparse_qr<SparseMatrix>::sparse_qr_rep::~sparse_qr_rep (void)
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
   CXSPARSE_DNAME (_sfree) (S);
   CXSPARSE_DNAME (_nfree) (N);
 #endif
 }
 
 template <>
 SparseMatrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::V (void) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
+
   // Drop zeros from V and sort
   // FIXME: Is the double transpose to sort necessary?
+
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_DNAME (_dropzeros) (N->L);
   CXSPARSE_DNAME () *D = CXSPARSE_DNAME (_transpose) (N->L, 1);
   CXSPARSE_DNAME (_spfree) (N->L);
   N->L = CXSPARSE_DNAME (_transpose) (D, 1);
   CXSPARSE_DNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   octave_idx_type nc = N->L->n;
   octave_idx_type nz = N->L->nzmax;
   SparseMatrix ret (N->L->m, nc, nz);
+
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = N->L->p[j];
+
   for (octave_idx_type j = 0; j < nz; j++)
     {
       ret.xridx (j) = N->L->i[j];
       ret.xdata (j) = N->L->x[j];
     }
+
   return ret;
+
 #else
+
   return SparseMatrix ();
+
 #endif
 }
 
 template <>
 SparseMatrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::R (bool econ) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
+
   // Drop zeros from R and sort
   // FIXME: Is the double transpose to sort necessary?
+
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_DNAME (_dropzeros) (N->U);
   CXSPARSE_DNAME () *D = CXSPARSE_DNAME (_transpose) (N->U, 1);
   CXSPARSE_DNAME (_spfree) (N->U);
   N->U = CXSPARSE_DNAME (_transpose) (D, 1);
   CXSPARSE_DNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   octave_idx_type nc = N->U->n;
   octave_idx_type nz = N->U->nzmax;
 
   SparseMatrix ret ((econ ? (nc > nrows ? nrows : nc) : nrows), nc, nz);
 
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = N->U->p[j];
+
   for (octave_idx_type j = 0; j < nz; j++)
     {
       ret.xridx (j) = N->U->i[j];
       ret.xdata (j) = N->U->x[j];
     }
+
   return ret;
+
 #else
+
   return SparseMatrix ();
+
 #endif
 }
 
 template <>
 Matrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::C (const Matrix& b) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
+
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
+
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
+
   const double *bvec = b.fortran_vec ();
+
   Matrix ret (b_nr, b_nc);
   double *vec = ret.fortran_vec ();
+
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     ret = Matrix (nc, b_nc, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
+
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
+
           for (octave_idx_type i = nr; i < S->m2; i++)
             buf[i] = 0.;
+
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_ipvec) (S->pinv, bvec + idx, buf, b_nr);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
+
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
+
           for (octave_idx_type i = 0; i < b_nr; i++)
             vec[i+idx] = buf[i];
         }
     }
+
   return ret;
+
 #else
+
   return Matrix ();
+
 #endif
 }
 
 template <>
 Matrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::Q (void) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   Matrix ret (nr, nr);
   double *vec = ret.fortran_vec ();
+
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
 
   if (nr == 0 || nc == 0)
     ret = Matrix (nc, nr, 0.0);
   else
     {
       OCTAVE_LOCAL_BUFFER (double, bvec, nr + 1);
+
       for (octave_idx_type i = 0; i < nr; i++)
         bvec[i] = 0.;
+
       OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
+
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
         {
           octave_quit ();
+
           bvec[j] = 1.0;
           for (octave_idx_type i = nr; i < S->m2; i++)
             buf[i] = 0.;
+
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_ipvec) (S->pinv, bvec, buf, nr);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
+
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_DNAME (_happly) (N->L, i, N->B[i], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
+
           for (octave_idx_type i = 0; i < nr; i++)
             vec[i+idx] = buf[i];
+
           bvec[j] = 0.0;
         }
     }
+
   return ret.transpose ();
+
 #else
+
   return Matrix ();
+
 #endif
 }
 
 template <>
 template <>
 Matrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::tall_solve<MArray<double>, Matrix>
   (const MArray<double>& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   octave_idx_type nr = nrows;
   octave_idx_type nc = ncols;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
   const double *bvec = b.data ();
 
   Matrix x (nc, b_nc);
   double *vec = x.fortran_vec ();
+
   OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
+
   for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
        i++, idx+=nc, bidx+=b_nr)
     {
       octave_quit ();
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_ipvec) (S->pinv, bvec + bidx, buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_usolve) (N->U, buf);
       CXSPARSE_DNAME (_ipvec) (S->q, buf, vec + idx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
     }
 
   info = 0;
 
@@ -408,50 +479,58 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 template <>
 template <>
 Matrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::wide_solve<MArray<double>, Matrix>
   (const MArray<double>& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   // These are swapped because the original matrix was transposed in
   // sparse_qr<SparseMatrix>::solve.
 
   octave_idx_type nr = ncols;
   octave_idx_type nc = nrows;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
   const double *bvec = b.data ();
 
   Matrix x (nc, b_nc);
   double *vec = x.fortran_vec ();
+
   volatile octave_idx_type nbuf = (nc > S->m2 ? nc : S->m2);
+
   OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
+
   for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
        i++, idx+=nc, bidx+=b_nr)
     {
       octave_quit ();
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->q, bvec + bidx, buf, nr);
       CXSPARSE_DNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->pinv, buf, vec + idx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
     }
 
   info = 0;
 
   return x;
@@ -466,71 +545,81 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 template <>
 template <>
 SparseMatrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::tall_solve<SparseMatrix, SparseMatrix>
   (const SparseMatrix& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   octave_idx_type nr = nrows;
   octave_idx_type nc = ncols;
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
-  volatile octave_idx_type ii, x_nz;
-
   SparseMatrix x (nc, b_nc, b.nnz ());
   x.xcidx (0) = 0;
-  x_nz = b.nnz ();
-  ii = 0;
+
+  volatile octave_idx_type x_nz = b.nnz ();
+  volatile octave_idx_type ii = 0;
+
   OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         Xx[j] = b.xelem (j,i);
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_ipvec) (S->pinv, Xx, buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_usolve) (N->U, buf);
       CXSPARSE_DNAME (_ipvec) (S->q, buf, Xx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           double tmp = Xx[j];
+
           if (tmp != 0.0)
             {
               if (ii == x_nz)
                 {
                   // Resize the sparse matrix
                   octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                   sz = (sz > 10 ? sz : 10) + x_nz;
                   x.change_capacity (sz);
                   x_nz = sz;
                 }
+
               x.xdata (ii) = tmp;
               x.xridx (ii++) = j;
             }
         }
+
       x.xcidx (i+1) = ii;
     }
 
   info = 0;
 
   return x;
 
 #else
@@ -543,75 +632,85 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 template <>
 template <>
 SparseMatrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::wide_solve<SparseMatrix, SparseMatrix>
   (const SparseMatrix& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   // These are swapped because the original matrix was transposed in
   // sparse_qr<SparseMatrix>::solve.
 
   octave_idx_type nr = ncols;
   octave_idx_type nc = nrows;
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
-  volatile octave_idx_type ii, x_nz;
-
   SparseMatrix x (nc, b_nc, b.nnz ());
   x.xcidx (0) = 0;
-  x_nz = b.nnz ();
-  ii = 0;
+
+  volatile octave_idx_type x_nz = b.nnz ();
+  volatile octave_idx_type ii = 0;
   volatile octave_idx_type nbuf = (nc > S->m2 ? nc : S->m2);
+
   OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         Xx[j] = b.xelem (j,i);
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->q, Xx, buf, nr);
       CXSPARSE_DNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->pinv, buf, Xx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           double tmp = Xx[j];
+
           if (tmp != 0.0)
             {
               if (ii == x_nz)
                 {
                   // Resize the sparse matrix
                   octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                   sz = (sz > 10 ? sz : 10) + x_nz;
                   x.change_capacity (sz);
                   x_nz = sz;
                 }
+
               x.xdata (ii) = tmp;
               x.xridx (ii++) = j;
             }
         }
+
       x.xcidx (i+1) = ii;
     }
 
   info = 0;
 
   x.maybe_compress ();
 
   return x;
@@ -626,68 +725,82 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 template <>
 template <>
 ComplexMatrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::tall_solve<MArray<Complex>, ComplexMatrix>
   (const MArray<Complex>& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   octave_idx_type nr = nrows;
   octave_idx_type nc = ncols;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
   ComplexMatrix x (nc, b_nc);
   Complex *vec = x.fortran_vec ();
+
   OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         {
           Complex c = b.xelem (j,i);
           Xx[j] = std::real (c);
           Xz[j] = std::imag (c);
         }
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_ipvec) (S->pinv, Xx, buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_usolve) (N->U, buf);
       CXSPARSE_DNAME (_ipvec) (S->q, buf, Xx, nc);
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = 0.;
+
       CXSPARSE_DNAME (_ipvec) (S->pinv, Xz, buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_usolve) (N->U, buf);
       CXSPARSE_DNAME (_ipvec) (S->q, buf, Xz, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (octave_idx_type j = 0; j < nc; j++)
         vec[j+idx] = Complex (Xx[j], Xz[j]);
     }
 
   info = 0;
 
   return x;
 
@@ -701,74 +814,89 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 template <>
 template <>
 ComplexMatrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::wide_solve<MArray<Complex>, ComplexMatrix>
   (const MArray<Complex>& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   // These are swapped because the original matrix was transposed in
   // sparse_qr<SparseMatrix>::solve.
 
   octave_idx_type nr = ncols;
   octave_idx_type nc = nrows;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
   ComplexMatrix x (nc, b_nc);
   Complex *vec = x.fortran_vec ();
+
   volatile octave_idx_type nbuf = (nc > S->m2 ? nc : S->m2);
+
   OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         {
           Complex c = b.xelem (j,i);
           Xx[j] = std::real (c);
           Xz[j] = std::imag (c);
         }
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->q, Xx, buf, nr);
       CXSPARSE_DNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->pinv, buf, Xx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->q, Xz, buf, nr);
       CXSPARSE_DNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->pinv, buf, Xz, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (octave_idx_type j = 0; j < nc; j++)
         vec[j+idx] = Complex (Xx[j], Xz[j]);
     }
 
   info = 0;
 
   return x;
 
@@ -780,294 +908,356 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 }
 
 // Complex-valued matrices.
 
 template <>
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::sparse_qr_rep
   (const SparseComplexMatrix& a, int order)
     : count (1), nrows (a.rows ()), ncols (a.columns ())
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
     , S (0), N (0)
 #endif
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
+
   CXSPARSE_ZNAME () A;
+
   A.nzmax = a.nnz ();
   A.m = nrows;
   A.n = ncols;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<cs_complex_t *>(reinterpret_cast<const cs_complex_t *> (a.data ()));
   A.nz = -1;
+
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
   N = CXSPARSE_ZNAME (_qr) (&A, S);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
   if (! N)
     (*current_liboctave_error_handler)
       ("sparse_qr: sparse matrix QR factorization filled");
 
   count = 1;
 
 #else
+
   (*current_liboctave_error_handler)
     ("sparse_qr: support for CXSparse was unavailable or disabled when liboctave was built");
+
 #endif
 }
 
 template <>
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::~sparse_qr_rep (void)
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
   CXSPARSE_ZNAME (_sfree) (S);
   CXSPARSE_ZNAME (_nfree) (N);
 #endif
 }
 
 template <>
 SparseComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::V (void) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
   // Drop zeros from V and sort
   // FIXME: Is the double transpose to sort necessary?
+
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_ZNAME (_dropzeros) (N->L);
   CXSPARSE_ZNAME () *D = CXSPARSE_ZNAME (_transpose) (N->L, 1);
   CXSPARSE_ZNAME (_spfree) (N->L);
   N->L = CXSPARSE_ZNAME (_transpose) (D, 1);
   CXSPARSE_ZNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   octave_idx_type nc = N->L->n;
   octave_idx_type nz = N->L->nzmax;
   SparseComplexMatrix ret (N->L->m, nc, nz);
+
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = N->L->p[j];
+
   for (octave_idx_type j = 0; j < nz; j++)
     {
       ret.xridx (j) = N->L->i[j];
       ret.xdata (j) = reinterpret_cast<Complex *>(N->L->x)[j];
     }
+
   return ret;
+
 #else
+
   return SparseComplexMatrix ();
+
 #endif
 }
 
 template <>
 SparseComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::R (bool econ) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
   // Drop zeros from R and sort
   // FIXME: Is the double transpose to sort necessary?
+
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_ZNAME (_dropzeros) (N->U);
   CXSPARSE_ZNAME () *D = CXSPARSE_ZNAME (_transpose) (N->U, 1);
   CXSPARSE_ZNAME (_spfree) (N->U);
   N->U = CXSPARSE_ZNAME (_transpose) (D, 1);
   CXSPARSE_ZNAME (_spfree) (D);
   END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
   octave_idx_type nc = N->U->n;
   octave_idx_type nz = N->U->nzmax;
 
   SparseComplexMatrix ret ((econ ? (nc > nrows ? nrows : nc) : nrows), nc, nz);
 
+
   for (octave_idx_type j = 0; j < nc+1; j++)
     ret.xcidx (j) = N->U->p[j];
+
   for (octave_idx_type j = 0; j < nz; j++)
     {
       ret.xridx (j) = N->U->i[j];
       ret.xdata (j) = reinterpret_cast<Complex *>(N->U->x)[j];
     }
+
   return ret;
+
 #else
+
   return SparseComplexMatrix ();
+
 #endif
 }
 
 template <>
 ComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::C (const ComplexMatrix& b) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
   ComplexMatrix ret (b_nr, b_nc);
   Complex *vec = ret.fortran_vec ();
+
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
 
+
   if (nr == 0 || nc == 0 || b_nc == 0)
     ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
+
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
+
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_ipvec) (S->pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf), b_nr);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
+
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
+
           for (octave_idx_type i = 0; i < b_nr; i++)
             vec[i+idx] = buf[i];
         }
     }
+
   return ret;
+
 #else
+
   return ComplexMatrix ();
+
 #endif
 }
 
 template <>
 ComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::Q (void) const
 {
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
   ComplexMatrix ret (nr, nr);
   Complex *vec = ret.fortran_vec ();
+
   if (nr < 0 || nc < 0)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
 
   if (nr == 0 || nc == 0)
     ret = ComplexMatrix (nc, nr, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (cs_complex_t, bvec, nr);
+
       for (octave_idx_type i = 0; i < nr; i++)
         bvec[i] = cs_complex_t (0.0, 0.0);
+
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
+
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
         {
           octave_quit ();
+
           bvec[j] = cs_complex_t (1.0, 0.0);
+
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_ipvec) (S->pinv, bvec, reinterpret_cast<cs_complex_t *>(buf), nr);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
+
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
+
           for (octave_idx_type i = 0; i < nr; i++)
             vec[i+idx] = buf[i];
+
           bvec[j] = cs_complex_t (0.0, 0.0);
         }
     }
+
   return ret.hermitian ();
+
 #else
+
   return ComplexMatrix ();
+
 #endif
 }
 
 template <>
 template <>
 SparseComplexMatrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::tall_solve<SparseComplexMatrix, SparseComplexMatrix>
   (const SparseComplexMatrix& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   octave_idx_type nr = nrows;
   octave_idx_type nc = ncols;
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
-  volatile octave_idx_type ii, x_nz;
-
   SparseComplexMatrix x (nc, b_nc, b.nnz ());
   x.xcidx (0) = 0;
-  x_nz = b.nnz ();
-  ii = 0;
+
+  volatile octave_idx_type x_nz = b.nnz ();
+  volatile octave_idx_type ii = 0;
+
   OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         {
           Complex c = b.xelem (j,i);
           Xx[j] = std::real (c);
           Xz[j] = std::imag (c);
         }
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_ipvec) (S->pinv, Xx, buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_usolve) (N->U, buf);
       CXSPARSE_DNAME (_ipvec) (S->q, buf, Xx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_ipvec) (S->pinv, Xz, buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_usolve) (N->U, buf);
       CXSPARSE_DNAME (_ipvec) (S->q, buf, Xz, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp = Complex (Xx[j], Xz[j]);
+
           if (tmp != 0.0)
             {
               if (ii == x_nz)
                 {
                   // Resize the sparse matrix
                   octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                   sz = (sz > 10 ? sz : 10) + x_nz;
                   x.change_capacity (sz);
                   x_nz = sz;
                 }
+
               x.xdata (ii) = tmp;
               x.xridx (ii++) = j;
             }
         }
+
       x.xcidx (i+1) = ii;
     }
 
   info = 0;
 
   return x;
 
 #else
@@ -1080,96 +1270,111 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 template <>
 template <>
 SparseComplexMatrix
 sparse_qr<SparseMatrix>::sparse_qr_rep::wide_solve<SparseComplexMatrix, SparseComplexMatrix>
   (const SparseComplexMatrix& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   // These are swapped because the original matrix was transposed in
   // sparse_qr<SparseMatrix>::solve.
 
   octave_idx_type nr = ncols;
   octave_idx_type nc = nrows;
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
-  volatile octave_idx_type ii, x_nz;
-
   SparseComplexMatrix x (nc, b_nc, b.nnz ());
   x.xcidx (0) = 0;
-  x_nz = b.nnz ();
-  ii = 0;
+
+  volatile octave_idx_type x_nz = b.nnz ();
+  volatile octave_idx_type ii = 0;
   volatile octave_idx_type nbuf = (nc > S->m2 ? nc : S->m2);
+
   OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         {
           Complex c = b.xelem (j,i);
           Xx[j] = std::real (c);
           Xz[j] = std::imag (c);
         }
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->q, Xx, buf, nr);
       CXSPARSE_DNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->pinv, buf, Xx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = 0.;
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->q, Xz, buf, nr);
       CXSPARSE_DNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_DNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_DNAME (_pvec) (S->pinv, buf, Xz, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp = Complex (Xx[j], Xz[j]);
+
           if (tmp != 0.0)
             {
               if (ii == x_nz)
                 {
                   // Resize the sparse matrix
                   octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                   sz = (sz > 10 ? sz : 10) + x_nz;
                   x.change_capacity (sz);
                   x_nz = sz;
                 }
+
               x.xdata (ii) = tmp;
               x.xridx (ii++) = j;
             }
         }
+
       x.xcidx (i+1) = ii;
     }
 
   info = 0;
 
   x.maybe_compress ();
 
   return x;
@@ -1184,45 +1389,53 @@ sparse_qr<SparseMatrix>::sparse_qr_rep::
 template <>
 template <>
 ComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<MArray<double>, ComplexMatrix>
   (const MArray<double>& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   octave_idx_type nr = nrows;
   octave_idx_type nc = ncols;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
   ComplexMatrix x (nc, b_nc);
   cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
+
   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, S->m2);
   OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         Xx[j] = b.xelem (j,i);
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = cs_complex_t (0.0, 0.0);
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_ipvec) (S->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_usolve) (N->U, buf);
       CXSPARSE_ZNAME (_ipvec) (S->q, buf, vec + idx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
     }
 
   info = 0;
 
@@ -1238,54 +1451,63 @@ sparse_qr<SparseComplexMatrix>::sparse_q
 template <>
 template <>
 ComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<MArray<double>, ComplexMatrix>
   (const MArray<double>& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   // These are swapped because the original matrix was transposed in
   // sparse_qr<SparseComplexMatrix>::solve.
 
   octave_idx_type nr = ncols;
   octave_idx_type nc = nrows;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
   ComplexMatrix x (nc, b_nc);
   cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
 
   volatile octave_idx_type nbuf = (nc > S->m2 ? nc : S->m2);
+
   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, nbuf);
   OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
   OCTAVE_LOCAL_BUFFER (double, B, nr);
+
   for (octave_idx_type i = 0; i < nr; i++)
     B[i] = N->B[i];
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         Xx[j] = b.xelem (j,i);
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = cs_complex_t (0.0, 0.0);
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_pvec) (S->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
       CXSPARSE_ZNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_happly) (N->L, j, B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_pvec) (S->pinv, buf, vec + idx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
     }
 
   info = 0;
 
   return x;
@@ -1300,71 +1522,81 @@ sparse_qr<SparseComplexMatrix>::sparse_q
 template <>
 template <>
 SparseComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<SparseMatrix, SparseComplexMatrix>
   (const SparseMatrix& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   octave_idx_type nr = nrows;
   octave_idx_type nc = ncols;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
-  volatile octave_idx_type ii, x_nz;
-
   SparseComplexMatrix x (nc, b_nc, b.nnz ());
   x.xcidx (0) = 0;
-  x_nz = b.nnz ();
-  ii = 0;
+
+  volatile octave_idx_type x_nz = b.nnz ();
+  volatile octave_idx_type ii = 0;
+
   OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, S->m2);
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         Xx[j] = b.xelem (j,i);
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = cs_complex_t (0.0, 0.0);
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_ipvec) (S->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_usolve) (N->U, buf);
       CXSPARSE_ZNAME (_ipvec) (S->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp = Xx[j];
+
           if (tmp != 0.0)
             {
               if (ii == x_nz)
                 {
                   // Resize the sparse matrix
                   octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                   sz = (sz > 10 ? sz : 10) + x_nz;
                   x.change_capacity (sz);
                   x_nz = sz;
                 }
+
               x.xdata (ii) = tmp;
               x.xridx (ii++) = j;
             }
         }
+
       x.xcidx (i+1) = ii;
     }
 
   info = 0;
 
   x.maybe_compress ();
 
   return x;
@@ -1379,80 +1611,89 @@ sparse_qr<SparseComplexMatrix>::sparse_q
 template <>
 template <>
 SparseComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<SparseMatrix, SparseComplexMatrix>
   (const SparseMatrix& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   // These are swapped because the original matrix was transposed in
   // sparse_qr<SparseComplexMatrix>::solve.
 
   octave_idx_type nr = ncols;
   octave_idx_type nc = nrows;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
-  volatile octave_idx_type ii, x_nz;
-
   SparseComplexMatrix x (nc, b_nc, b.nnz ());
   x.xcidx (0) = 0;
-  x_nz = b.nnz ();
-  ii = 0;
+
+  volatile octave_idx_type x_nz = b.nnz ();
+  volatile octave_idx_type ii = 0;
   volatile octave_idx_type nbuf = (nc > S->m2 ? nc : S->m2);
+
   OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, nbuf);
-
   OCTAVE_LOCAL_BUFFER (double, B, nr);
+
   for (octave_idx_type i = 0; i < nr; i++)
     B[i] = N->B[i];
 
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         Xx[j] = b.xelem (j,i);
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = cs_complex_t (0.0, 0.0);
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_pvec) (S->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
       CXSPARSE_ZNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_happly) (N->L, j, B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_pvec) (S->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp = Xx[j];
+
           if (tmp != 0.0)
             {
               if (ii == x_nz)
                 {
                   // Resize the sparse matrix
                   octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                   sz = (sz > 10 ? sz : 10) + x_nz;
                   x.change_capacity (sz);
                   x_nz = sz;
                 }
+
               x.xdata (ii) = tmp;
               x.xridx (ii++) = j;
             }
         }
+
       x.xcidx (i+1) = ii;
     }
 
   info = 0;
 
   x.maybe_compress ();
 
   return x;
@@ -1467,46 +1708,53 @@ sparse_qr<SparseComplexMatrix>::sparse_q
 template <>
 template <>
 ComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<MArray<Complex>, ComplexMatrix>
   (const MArray<Complex>& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   octave_idx_type nr = nrows;
   octave_idx_type nc = ncols;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
   const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
 
   ComplexMatrix x (nc, b_nc);
   cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
     (x.fortran_vec ());
+
   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, S->m2);
+
   for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
        i++, idx+=nc, bidx+=b_nr)
     {
       octave_quit ();
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = cs_complex_t (0.0, 0.0);
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_ipvec) (S->pinv, bvec + bidx, buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_usolve) (N->U, buf);
       CXSPARSE_ZNAME (_ipvec) (S->q, buf, vec + idx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
     }
 
   info = 0;
 
@@ -1522,57 +1770,67 @@ sparse_qr<SparseComplexMatrix>::sparse_q
 template <>
 template <>
 ComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<MArray<Complex>, ComplexMatrix>
   (const MArray<Complex>& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   // These are swapped because the original matrix was transposed in
   // sparse_qr<SparseComplexMatrix>::solve.
 
   octave_idx_type nr = ncols;
   octave_idx_type nc = nrows;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
   const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *>(b.fortran_vec ());
 
   ComplexMatrix x (nc, b_nc);
   cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
+
   volatile octave_idx_type nbuf = (nc > S->m2 ? nc : S->m2);
+
   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, nbuf);
   OCTAVE_LOCAL_BUFFER (double, B, nr);
+
   for (octave_idx_type i = 0; i < nr; i++)
     B[i] = N->B[i];
+
   for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
        i++, idx+=nc, bidx+=b_nr)
     {
       octave_quit ();
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = cs_complex_t (0.0, 0.0);
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_pvec) (S->q, bvec + bidx, buf, nr);
       CXSPARSE_ZNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_happly) (N->L, j, B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_pvec) (S->pinv, buf, vec + idx, nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
     }
+
   info = 0;
 
   return x;
 
 #else
 
   return ComplexMatrix ();
 
@@ -1582,71 +1840,81 @@ sparse_qr<SparseComplexMatrix>::sparse_q
 template <>
 template <>
 SparseComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::tall_solve<SparseComplexMatrix, SparseComplexMatrix>
   (const SparseComplexMatrix& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   octave_idx_type nr = nrows;
   octave_idx_type nc = ncols;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
-  volatile octave_idx_type ii, x_nz;
-
   SparseComplexMatrix x (nc, b_nc, b.nnz ());
   x.xcidx (0) = 0;
-  x_nz = b.nnz ();
-  ii = 0;
+
+  volatile octave_idx_type x_nz = b.nnz ();
+  volatile octave_idx_type ii = 0;
+
   OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, S->m2);
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         Xx[j] = b.xelem (j,i);
+
       for (octave_idx_type j = nr; j < S->m2; j++)
         buf[j] = cs_complex_t (0.0, 0.0);
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_ipvec) (S->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_happly) (N->L, j, N->B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_usolve) (N->U, buf);
       CXSPARSE_ZNAME (_ipvec) (S->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp = Xx[j];
+
           if (tmp != 0.0)
             {
               if (ii == x_nz)
                 {
                   // Resize the sparse matrix
                   octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                   sz = (sz > 10 ? sz : 10) + x_nz;
                   x.change_capacity (sz);
                   x_nz = sz;
                 }
+
               x.xdata (ii) = tmp;
               x.xridx (ii++) = j;
             }
         }
+
       x.xcidx (i+1) = ii;
     }
 
   info = 0;
 
   x.maybe_compress ();
 
   return x;
@@ -1661,78 +1929,89 @@ sparse_qr<SparseComplexMatrix>::sparse_q
 template <>
 template <>
 SparseComplexMatrix
 sparse_qr<SparseComplexMatrix>::sparse_qr_rep::wide_solve<SparseComplexMatrix, SparseComplexMatrix>
   (const SparseComplexMatrix& b, octave_idx_type& info) const
 {
   info = -1;
 
-#ifdef HAVE_CXSPARSE
+#if defined (HAVE_CXSPARSE)
 
   // These are swapped because the original matrix was transposed in
   // sparse_qr<SparseComplexMatrix>::solve.
 
   octave_idx_type nr = ncols;
   octave_idx_type nc = nrows;
 
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
 
-  volatile octave_idx_type ii, x_nz;
-
   SparseComplexMatrix x (nc, b_nc, b.nnz ());
   x.xcidx (0) = 0;
-  x_nz = b.nnz ();
-  ii = 0;
+
+  volatile octave_idx_type x_nz = b.nnz ();
+  volatile octave_idx_type ii = 0;
   volatile octave_idx_type nbuf = (nc > S->m2 ? nc : S->m2);
+
   OCTAVE_LOCAL_BUFFER (Complex, Xx, (b_nr > nc ? b_nr : nc));
   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, nbuf);
   OCTAVE_LOCAL_BUFFER (double, B, nr);
+
   for (octave_idx_type i = 0; i < nr; i++)
     B[i] = N->B[i];
+
   for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
     {
       octave_quit ();
+
       for (octave_idx_type j = 0; j < b_nr; j++)
         Xx[j] = b.xelem (j,i);
+
       for (octave_idx_type j = nr; j < nbuf; j++)
         buf[j] = cs_complex_t (0.0, 0.0);
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_pvec) (S->q, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
       CXSPARSE_ZNAME (_utsolve) (N->U, buf);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
+
       for (volatile octave_idx_type j = nr-1; j >= 0; j--)
         {
           octave_quit ();
+
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_happly) (N->L, j, B[j], buf);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
         }
+
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CXSPARSE_ZNAME (_pvec) (S->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp = Xx[j];
+
           if (tmp != 0.0)
             {
               if (ii == x_nz)
                 {
                   // Resize the sparse matrix
                   octave_idx_type sz = x_nz * (b_nc - i) / b_nc;
                   sz = (sz > 10 ? sz : 10) + x_nz;
                   x.change_capacity (sz);
                   x_nz = sz;
                 }
+
               x.xdata (ii) = tmp;
               x.xridx (ii++) = j;
             }
         }
+
       x.xcidx (i+1) = ii;
     }
 
   info = 0;
 
   x.maybe_compress ();
 
   return x;
diff --git a/liboctave/numeric/sparse-qr.h b/liboctave/numeric/sparse-qr.h
--- a/liboctave/numeric/sparse-qr.h
+++ b/liboctave/numeric/sparse-qr.h
@@ -1,12 +1,12 @@
 /*
 
+Copyright (C) 2016 John W. Eaton
 Copyright (C) 2005-2015 David Bateman
-Copyright (C) 2016 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -25,16 +25,21 @@ along with Octave; see the file COPYING.
 #define octave_sparse_qr_h 1
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "dSparse.h"
 #include "CSparse.h"
 #include "oct-sparse.h"
 
+// If the sparse matrix classes become templated on the element type
+// (i.e., sparse_matrix<double>), then it might be best to make the
+// template parameter of this class also be the element type instead
+// of the matrix type.
+
 template <typename SPARSE_T>
 class
 sparse_qr
 {
 public:
 
   sparse_qr (void);
 
diff --git a/liboctave/util/oct-sparse.h b/liboctave/util/oct-sparse.h
--- a/liboctave/util/oct-sparse.h
+++ b/liboctave/util/oct-sparse.h
@@ -19,102 +19,102 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if ! defined (octave_oct_sparse_h)
 #define octave_oct_sparse_h 1
 
 #if defined (HAVE_SUITESPARSE_AMD_H)
-#include <suitesparse/amd.h>
+#  include <suitesparse/amd.h>
 #elif defined (HAVE_UFSPARSE_AMD_H)
-#include <ufsparse/amd.h>
+#  include <ufsparse/amd.h>
 #elif defined (HAVE_AMD_AMD_H)
-#include <amd/amd.h>
+#  include <amd/amd.h>
 #elif defined (HAVE_AMD_H)
-#include <amd.h>
+#  include <amd.h>
 #endif
 
 #if defined (HAVE_SUITESPARSE_UMFPACK_H)
-#include <suitesparse/umfpack.h>
+#  include <suitesparse/umfpack.h>
 #elif defined (HAVE_UFSPARSE_UMFPACK_H)
-#include <ufsparse/umfpack.h>
+#  include <ufsparse/umfpack.h>
 #elif defined (HAVE_UMFPACK_UMFPACK_H)
-#include <umfpack/umfpack.h>
+#  include <umfpack/umfpack.h>
 #elif defined (HAVE_UMFPACK_H)
-#include <umfpack.h>
+#  include <umfpack.h>
 #endif
 
 #if defined (HAVE_SUITESPARSE_COLAMD_H)
-#include <suitesparse/colamd.h>
+#  include <suitesparse/colamd.h>
 #elif defined (HAVE_UFSPARSE_COLAMD_H)
-#include <ufsparse/colamd.h>
+#  include <ufsparse/colamd.h>
 #elif defined (HAVE_COLAMD_COLAMD_H)
-#include <colamd/colamd.h>
+#  include <colamd/colamd.h>
 #elif defined (HAVE_COLAMD_H)
-#include <colamd.h>
+#  include <colamd.h>
 #endif
 
 #if defined (HAVE_SUITESPARSE_CCOLAMD_H)
-#include <suitesparse/ccolamd.h>
+#  include <suitesparse/ccolamd.h>
 #elif defined (HAVE_UFSPARSE_CCOLAMD_H)
-#include <ufsparse/ccolamd.h>
+#  include <ufsparse/ccolamd.h>
 #elif defined (HAVE_CCOLAMD_CCOLAMD_H)
-#include <ccolamd/ccolamd.h>
+#  include <ccolamd/ccolamd.h>
 #elif defined (HAVE_CCOLAMD_H)
-#include <ccolamd.h>
+#  include <ccolamd.h>
 #endif
 
 #if defined (HAVE_SUITESPARSE_CHOLMOD_H)
-#include <suitesparse/cholmod.h>
+#  include <suitesparse/cholmod.h>
 #elif defined (HAVE_UFSPARSE_CHOLMOD_H)
-#include <ufsparse/cholmod.h>
+#  include <ufsparse/cholmod.h>
 #elif defined (HAVE_CHOLMOD_CHOLMOD_H)
-#include <cholmod/cholmod.h>
+#  include <cholmod/cholmod.h>
 #elif defined (HAVE_CHOLMOD_H)
-#include <cholmod.h>
+#  include <cholmod.h>
 #endif
 
 #if defined (HAVE_SUITESPARSE_CS_H)
-#include <suitesparse/cs.h>
+#  include <suitesparse/cs.h>
 #elif defined (HAVE_UFSPARSE_CS_H)
-#include <ufsparse/cs.h>
+#  include <ufsparse/cs.h>
 #elif defined (HAVE_CXSPARSE_CS_H)
-#include <cxsparse/cs.h>
+#  include <cxsparse/cs.h>
 #elif defined (HAVE_CS_H)
-#include <cs.h>
+#  include <cs.h>
 #endif
 
 #if (defined (HAVE_SUITESPARSE_CHOLMOD_H) \
      || defined (HAVE_UFSPARSE_CHOLMOD_H) \
      || defined (HAVE_CHOLMOD_CHOLMOD_H) \
      || defined (HAVE_CHOLMOD_H))
-#if defined (ENABLE_64)
-#define CHOLMOD_NAME(name) cholmod_l_ ## name
-#else
-#define CHOLMOD_NAME(name) cholmod_ ## name
-#endif
+#  if defined (ENABLE_64)
+#    define CHOLMOD_NAME(name) cholmod_l_ ## name
+#  else
+#    define CHOLMOD_NAME(name) cholmod_ ## name
+#  endif
 #endif
 
 // Cope with new SuiteSparse versions
 
 #if defined (SUITESPARSE_VERSION)
-# if SUITESPARSE_VERSION >= SUITESPARSE_VER_CODE (4, 3)
-#  define SUITESPARSE_NAME(name) SuiteSparse_ ## name
-#  define SUITESPARSE_ASSIGN_FPTR(f_name, f_var, f_assign) (SuiteSparse_config.f_name = f_assign)
-#  define SUITESPARSE_ASSIGN_FPTR2(f_name, f_var, f_assign) (SuiteSparse_config.f_name = SUITESPARSE_NAME (f_assign))
-# else
-#  define SUITESPARSE_ASSIGN_FPTR(f_name, f_var, f_assign) (f_var = f_assign)
-#  define SUITESPARSE_ASSIGN_FPTR2(f_name, f_var, f_assign) (f_var = CHOLMOD_NAME (f_assign))
-# endif
+#  if SUITESPARSE_VERSION >= SUITESPARSE_VER_CODE (4, 3)
+#    define SUITESPARSE_NAME(name) SuiteSparse_ ## name
+#    define SUITESPARSE_ASSIGN_FPTR(f_name, f_var, f_assign) (SuiteSparse_config.f_name = f_assign)
+#    define SUITESPARSE_ASSIGN_FPTR2(f_name, f_var, f_assign) (SuiteSparse_config.f_name = SUITESPARSE_NAME (f_assign))
+#  else
+#    define SUITESPARSE_ASSIGN_FPTR(f_name, f_var, f_assign) (f_var = f_assign)
+#    define SUITESPARSE_ASSIGN_FPTR2(f_name, f_var, f_assign) (f_var = CHOLMOD_NAME (f_assign))
+#  endif
 #endif
 
 #if defined (HAVE_CXSPARSE)
-# if defined (ENABLE_64)
-#  define CXSPARSE_DNAME(name) cs_dl ## name
-#  define CXSPARSE_ZNAME(name) cs_cl ## name
-# else
-#  define CXSPARSE_DNAME(name) cs_di ## name
-#  define CXSPARSE_ZNAME(name) cs_ci ## name
-# endif
+#  if defined (ENABLE_64)
+#    define CXSPARSE_DNAME(name) cs_dl ## name
+#    define CXSPARSE_ZNAME(name) cs_cl ## name
+#  else
+#    define CXSPARSE_DNAME(name) cs_di ## name
+#    define CXSPARSE_ZNAME(name) cs_ci ## name
+#  endif
 #endif
 
 #endif
