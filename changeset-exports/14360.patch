# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1329147776 28800
#      Mon Feb 13 07:42:56 2012 -0800
# Node ID 97883071e8e4e8d358d9d5f5f81c3eafb07d5526
# Parent  7277fe922e99f3c32b3505da05a32f553f3104cc
doc: Correct off-by-1 spacings in all .cc docstrings

* __makeinfo__.m: Only remove space at beginning of new line for
docstrings from scripts/ directory where this is the convention.

* besselj.cc, betainc.cc, cellfun.cc, dot.cc, fftw.cc, filter.cc, find.cc,
gammainc.cc, gcd.cc, givens.cc, hex2num.cc, kron.cc, lu.cc, max.cc, qr.cc,
quadcc.cc, qz.cc, regexp.cc, strfind.cc, sub2ind.cc, syl.cc, time.cc,
typecast.cc, urlwrite.cc, data.cc, dirfns.cc, file-io.cc, help.cc,
load-path.cc, mappers.cc, oct-parse.yy, ov-base.cc, ov-cell.cc, ov-struct.cc,
ov.cc, pr-output.cc, pt-mat.cc, strfns.cc, syscalls.cc, variables.cc:
Improve appearance of docstring spacing of @example code.

diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -81,20 +81,23 @@ function [retval, status] = __makeinfo__
           ("\nSee also:", sprintf (" @ref{%s},", T{:})(1:end-1), "\n");
     endif
   endif
 
   if (! isa (fsee_also, "function_handle"))
     error ("__makeinfo__: third input argument must be a function handle");
   endif
 
-
-  ## It seems like makeinfo sometimes gets angry if the first character
-  ## on a line is a space, so we remove these.
-  text = strrep (text, "\n ", "\n");
+  ## Formatting in m-files has an extra space at the beginning of every line.
+  ## Remove these unwanted spaces if present.  First text char is "\n" delim.
+  if (text(2) == " ")
+    text = strrep (text, "\n ", "\n");
+  endif
+  ## Texinfo crashes if @end tex does not appear first on the line.
+  text = regexprep (text, '^ +@end tex', '@end tex', 'lineanchors');
 
   ## Handle @seealso macro
   see_also_pat = '@seealso *\{(.*)\}';
   args = regexp (text, see_also_pat, 'tokens');
   for ii = 1:numel (args)
     expanded = fsee_also (strtrim (strsplit (args{ii}{:}, ',', true)));
     text = regexprep (text, see_also_pat, expanded, 'once');
   endfor
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -526,20 +526,20 @@ DEFUN_DLD (airy, args, nargout,
 @deftypefn {Loadable Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their\n\
 derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if 'opt' is supplied)\n\
 ---  --------   ---------------------------------------\n\
- 0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
- 1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))\n\
- 2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
- 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
+ 0   Ai (Z)     exp (2/3 * Z * sqrt (Z))\n\
+ 1   dAi(Z)/dZ  exp (2/3 * Z * sqrt (Z))\n\
+ 2   Bi (Z)     exp (-abs (real (2/3 * Z *sqrt (Z))))\n\
+ 3   dBi(Z)/dZ  exp (-abs (real (2/3 * Z *sqrt (Z))))\n\
 @end group\n\
 @end example\n\
 \n\
 The function call @code{airy (@var{z})} is equivalent to\n\
 @code{airy (0, @var{z})}.\n\
 \n\
 The result is the same size as @var{z}.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -45,18 +45,18 @@ Return the regularized incomplete Beta f
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
 @c spacing appears odd here, but is correct after Makeinfo\n\
                                      x\n\
                           1         /\n\
 betainc (x, a, b) = -----------    | t^(a-1) (1-t)^(b-1) dt.\n\
-                     beta (a, b)    /\n\
-                                 t=0\n\
+                     beta (a, b)   /\n\
+                                t=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
 If @var{x} has more than one component, both @var{a} and @var{b} must be\n\
 scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of\n\
 compatible dimensions.\n\
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -298,17 +298,17 @@ function (in a character string).  In th
 argument, the function must accept a single argument named @var{x}, and\n\
 it must return a string value.  The function can take one or more arguments,\n\
 with the inputs arguments given by @var{C}, @var{D}, etc.  Equally the\n\
 function can return one or more output arguments.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"atan2\", @{1, 0@}, @{0, 1@})\n\
-     @result{}ans = [1.57080   0.00000]\n\
+     @result{} [ 1.57080   0.00000 ]\n\
 @end group\n\
 @end example\n\
 \n\
 The number of output arguments of @code{cellfun} matches the number of output\n\
 arguments of the function.  The outputs of the function will be collected\n\
 into the output arguments of @code{cellfun} like this:\n\
 \n\
 @example\n\
@@ -325,26 +325,26 @@ endfunction\n\
            1 4 9\n\
 @end group\n\
 @end example\n\
 \n\
 Note that per default the output argument(s) are arrays of the same size as\n\
 the input arguments.  Input arguments that are singleton (1x1) cells will be\n\
 automatically expanded to the size of the other arguments.\n\
 \n\
-If the parameter 'UniformOutput' is set to true (the default), then the\n\
+If the parameter \"UniformOutput\" is set to true (the default), then the\n\
 function must return scalars which will be concatenated into the return\n\
 array(s).  If 'UniformOutput' is false, the outputs are concatenated into a\n\
 cell array (or cell arrays).  For example:\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"tolower\", @{\"Foo\", \"Bar\", \"FooBar\"@},\n\
-         \"UniformOutput\",false)\n\
-@result{} ans = @{\"foo\", \"bar\", \"foobar\"@}\n\
+         \"UniformOutput\", false)\n\
+@result{} @{\"foo\", \"bar\", \"foobar\"@}\n\
 @end group\n\
 @end example\n\
 \n\
 Given the parameter 'ErrorHandler', then @var{errfunc} defines a function to\n\
 call in case @var{func} generates an error.  The form of the function is\n\
 \n\
 @example\n\
 function [@dots{}] = errfunc (@var{s}, @dots{})\n\
@@ -355,18 +355,18 @@ where there is an additional input argum
 @var{func}, given by @var{s}.  This is a structure with the elements\n\
 'identifier', 'message' and 'index', giving respectively the error\n\
 identifier, the error message, and the index into the input arguments\n\
 of the element that caused the error.  For example:\n\
 \n\
 @example\n\
 @group\n\
 function y = foo (s, x), y = NaN; endfunction\n\
-cellfun (\"factorial\", @{-1,2@}, 'ErrorHandler', @@foo)\n\
-@result{} ans = [NaN 2]\n\
+cellfun (\"factorial\", @{-1,2@}, \"ErrorHandler\", @@foo)\n\
+@result{} [NaN 2]\n\
 @end group\n\
 @end example\n\
 \n\
 Use @code{cellfun} intelligently.  The @code{cellfun} function is a\n\
 useful tool for avoiding loops.  It is often used with anonymous\n\
 function handles; however, calling an anonymous function involves an\n\
 overhead quite comparable to the overhead of an m-file function.\n\
 Passing a handle to a built-in function is faster, because the\n\
@@ -1037,61 +1037,61 @@ The named function can also take more th
 the input arguments given as third input argument @var{b}, fourth\n\
 input argument @var{c}, @dots{}  If given more than one array input\n\
 argument then all input arguments must have the same sizes, for\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 arrayfun (@@atan2, [1, 0], [0, 1])\n\
-@result{} ans = [1.5708   0.0000]\n\
+     @result{} [ 1.5708   0.0000 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If the parameter @var{val} after a further string input argument\n\
 \"UniformOutput\" is set @code{true} (the default), then the named\n\
 function @var{func} must return a single element which then will be\n\
 concatenated into the return value and is of type matrix.  Otherwise,\n\
 if that parameter is set to @code{false}, then the outputs are\n\
 concatenated in a cell array.  For example:\n\
 \n\
 @example\n\
 @group\n\
 arrayfun (@@(x,y) x:y, \"abc\", \"def\", \"UniformOutput\", false)\n\
-@result{} ans =\n\
-    @{\n\
-      [1,1] = abcd\n\
-      [1,2] = bcde\n\
-      [1,3] = cdef\n\
-    @}\n\
+@result{}\n\
+   @{\n\
+     [1,1] = abcd\n\
+     [1,2] = bcde\n\
+     [1,3] = cdef\n\
+   @}\n\
 @end group\n\
 @end example\n\
 \n\
 If more than one output arguments are given then the named function\n\
 must return the number of return values that also are expected, for\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 [A, B, C] = arrayfun (@@find, [10; 0], \"UniformOutput\", false)\n\
 @result{}\n\
 A =\n\
 @{\n\
-  [1,1] =  1\n\
-  [2,1] = [](0x0)\n\
+   [1,1] =  1\n\
+   [2,1] = [](0x0)\n\
 @}\n\
 B =\n\
 @{\n\
-  [1,1] =  1\n\
-  [2,1] = [](0x0)\n\
+   [1,1] =  1\n\
+   [2,1] = [](0x0)\n\
 @}\n\
 C =\n\
 @{\n\
-  [1,1] =  10\n\
-  [2,1] = [](0x0)\n\
+   [1,1] =  10\n\
+   [2,1] = [](0x0)\n\
 @}\n\
 @end group\n\
 @end example\n\
 \n\
 If the parameter @var{errfunc} after a further string input argument\n\
 \"ErrorHandler\" is another string, a function handle, an inline\n\
 function, or an anonymous function, then @var{errfunc} defines a\n\
 function to call in the case that @var{func} generates an error.\n\
@@ -1110,21 +1110,21 @@ the array elements that caused the error
 argument of @var{errfunc} must have the same size as the output\n\
 argument of @var{func}, otherwise a real error is thrown.  For\n\
 example:\n\
 \n\
 @example\n\
 @group\n\
 function y = ferr (s, x), y = \"MyString\"; endfunction\n\
 arrayfun (@@str2num, [1234],\n\
-           \"UniformOutput\", false, \"ErrorHandler\", @@ferr)\n\
-@result{} ans =\n\
-    @{\n\
+          \"UniformOutput\", false, \"ErrorHandler\", @@ferr)\n\
+@result{}\n\
+   @{\n\
      [1,1] = MyString\n\
-    @}\n\
+   @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{spfun, cellfun, structfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
@@ -1805,34 +1805,34 @@ DEFUN_DLD (num2cell, args, ,
 @deftypefn  {Loadable Function} {@var{C} =} num2cell (@var{A})\n\
 @deftypefnx {Loadable Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
 Convert the numeric matrix @var{A} to a cell array.  If @var{dim} is\n\
 defined, the value @var{C} is of dimension 1 in this dimension and the\n\
 elements of @var{A} are placed into @var{C} in slices.  For example:\n\
 \n\
 @example\n\
 @group\n\
-num2cell([1,2;3,4])\n\
-     @result{} ans =\n\
-        @{\n\
-          [1,1] =  1\n\
-          [2,1] =  3\n\
-          [1,2] =  2\n\
-          [2,2] =  4\n\
-        @}\n\
-num2cell([1,2;3,4],1)\n\
-     @result{} ans =\n\
-        @{\n\
-          [1,1] =\n\
-             1\n\
-             3\n\
-          [1,2] =\n\
-             2\n\
-             4\n\
-        @}\n\
+num2cell ([1,2;3,4])\n\
+   @result{}\n\
+      @{\n\
+        [1,1] =  1\n\
+        [2,1] =  3\n\
+        [1,2] =  2\n\
+        [2,2] =  4\n\
+      @}\n\
+num2cell ([1,2;3,4],1)\n\
+   @result{}\n\
+      @{\n\
+        [1,1] =\n\
+           1\n\
+           3\n\
+        [1,2] =\n\
+           2\n\
+           4\n\
+      @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{mat2cell}\n\
 @end deftypefn")
 {
   int nargin =  args.length();
   octave_value retval;
@@ -2144,35 +2144,36 @@ to the dimensions of @var{A}, then it is
 == size (@var{A}, i)}.\n\
 \n\
 Given a single dimensional argument @var{r}, the other dimensional\n\
 arguments are assumed to equal @code{size (@var{A},@var{i})}.\n\
 \n\
 An example of the use of mat2cell is\n\
 \n\
 @example\n\
-mat2cell (reshape(1:16,4,4),[3,1],[3,1])\n\
-@result{} @{\n\
-  [1,1] =\n\
+mat2cell (reshape (1:16,4,4), [3,1], [3,1])\n\
+@result{}\n\
+@{\n\
+   [1,1] =\n\
 \n\
-     1   5   9\n\
-     2   6  10\n\
-     3   7  11\n\
-\n\
-  [2,1] =\n\
+      1   5   9\n\
+      2   6  10\n\
+      3   7  11\n\
 \n\
-     4   8  12\n\
+   [2,1] =\n\
 \n\
-  [1,2] =\n\
+      4   8  12\n\
+\n\
+   [1,2] =\n\
 \n\
-    13\n\
-    14\n\
-    15\n\
+     13\n\
+     14\n\
+     15\n\
 \n\
-  [2,2] = 16\n\
+   [2,2] = 16\n\
 @}\n\
 @end example\n\
 @seealso{num2cell, cell2mat}\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value retval;
 
@@ -2425,20 +2426,20 @@ slicing is done along the first non-sing
 
 DEFUN_DLD (cellindexmat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
 Given a cell array of matrices @var{x}, this function computes\n\
 \n\
 @example\n\
 @group\n\
-  Y = cell (size (X));\n\
-  for i = 1:numel (X)\n\
-    Y@{i@} = X@{i@}(varargin@{:@});\n\
-  endfor\n\
+Y = cell (size (X));\n\
+for i = 1:numel (X)\n\
+  Y@{i@} = X@{i@}(varargin@{:@});\n\
+endfor\n\
 @end group\n\
 @end example\n\
 @seealso{cellslices, cellfun}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () >= 1)
     {
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -257,19 +257,19 @@ DEFUN_DLD (blkmm, args, ,
 Compute products of matrix blocks.  The blocks are given as\n\
 2-dimensional subarrays of the arrays @var{A}, @var{B}.\n\
 The size of @var{A} must have the form @code{[m,k,@dots{}]} and\n\
 size of @var{B} must be @code{[k,n,@dots{}]}.  The result is\n\
 then of size @code{[m,n,@dots{}]} and is computed as follows:\n\
 \n\
 @example\n\
 @group\n\
-  for i = 1:prod (size (@var{A})(3:end))\n\
-    @var{C}(:,:,i) = @var{A}(:,:,i) * @var{B}(:,:,i)\n\
-  endfor\n\
+for i = 1:prod (size (@var{A})(3:end))\n\
+  @var{C}(:,:,i) = @var{A}(:,:,i) * @var{B}(:,:,i)\n\
+endfor\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 2)
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -42,27 +42,27 @@ DEFUN_DLD (fftw, args, ,
 Manage @sc{fftw} wisdom data.  Wisdom data can be used to significantly\n\
 accelerate the calculation of the FFTs, but implies an initial cost\n\
 in its calculation.  When the @sc{fftw} libraries are initialized, they read\n\
 a system wide wisdom file (typically in @file{/etc/fftw/wisdom}), allowing\n\
 wisdom to be shared between applications other than Octave.  Alternatively,\n\
 the @code{fftw} function can be used to import wisdom.  For example,\n\
 \n\
 @example\n\
-@var{wisdom} = fftw ('dwisdom')\n\
+@var{wisdom} = fftw (\"dwisdom\")\n\
 @end example\n\
 \n\
 @noindent\n\
 will save the existing wisdom used by Octave to the string @var{wisdom}.\n\
 This string can then be saved to a file and restored using the @code{save}\n\
 and @code{load} commands respectively.  This existing wisdom can be\n\
 reimported as follows\n\
 \n\
 @example\n\
-fftw ('dwisdom', @var{wisdom})\n\
+fftw (\"dwisdom\", @var{wisdom})\n\
 @end example\n\
 \n\
 If @var{wisdom} is an empty matrix, then the wisdom used is cleared.\n\
 \n\
 During the calculation of Fourier transforms further wisdom is generated.\n\
 The fashion in which this wisdom is generated is also controlled by\n\
 the @code{fftw} function.  There are five different manners in which the\n\
 wisdom can be treated:\n\
@@ -91,24 +91,24 @@ As run-time measurement of the algorithm
 compromise where 'measure' is used for transforms up to the size of 8192\n\
 and beyond that the 'estimate' method is used.\n\
 @end table\n\
 \n\
 The default method is 'estimate'.  The current method can\n\
 be queried with\n\
 \n\
 @example\n\
-@var{method} = fftw ('planner')\n\
+@var{method} = fftw (\"planner\")\n\
 @end example\n\
 \n\
 @noindent\n\
 or set by using\n\
 \n\
 @example\n\
-fftw ('planner', @var{method})\n\
+fftw (\"planner\", @var{method})\n\
 @end example\n\
 \n\
 Note that calculated wisdom will be lost when restarting Octave.  However,\n\
 the wisdom data can be reloaded if it is saved to a file as described\n\
 above.  Saved wisdom files should not be used on different platforms since\n\
 they will not be efficient and the point of calculating the wisdom is lost.\n\
 @seealso{fft, ifft, fft2, ifft2, fftn, ifftn}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -299,19 +299,19 @@ equation:\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
-   N                   M\n\
-  SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)\n\
-  k=0                 k=0\n\
+ N                   M\n\
+SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1<=n<=length(x)\n\
+k=0                 k=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
 @ifnottex\n\
@@ -328,19 +328,19 @@ y_n = -\\sum_{k=1}^N c_{k+1} y_{n-k} + \
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
-            N                   M\n\
-  y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)\n\
-           k=1                 k=0\n\
+          N                   M\n\
+y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)\n\
+         k=1                 k=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
 @end ifnottex\n\
 \n\
 @noindent\n\
 where\n\
 @ifnottex\n\
@@ -365,23 +365,23 @@ system function:\n\
 H(z) = {\\displaystyle\\sum_{k=0}^M d_{k+1} z^{-k}\n\
         \\over 1 + \\displaystyle\\sum_{k+1}^N c_{k+1} z^{-k}}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
-             M\n\
-            SUM d(k+1) z^(-k)\n\
-            k=0\n\
-  H(z) = ----------------------\n\
-               N\n\
-          1 + SUM c(k+1) z^(-k)\n\
-              k=1\n\
+          M\n\
+         SUM d(k+1) z^(-k)\n\
+         k=0\n\
+H(z) = ---------------------\n\
+            N\n\
+       1 + SUM c(k+1) z^(-k)\n\
+           k=1\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{filter2, fftfilt, freqz}\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -342,40 +342,40 @@ DEFUN_DLD (find, args, nargout,
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
 @var{x} is a row vector or as a column otherwise.  To obtain a single index\n\
 for each matrix element, Octave pretends that the columns of a matrix form\n\
 one long vector (like Fortran arrays are stored).  For example:\n\
 \n\
 @example\n\
 @group\n\
 find (eye (2))\n\
-     @result{} [ 1; 4 ]\n\
+  @result{} [ 1; 4 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If two outputs are requested, @code{find} returns the row and column\n\
 indices of nonzero elements of a matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [i, j] = find (2 * eye (2))\n\
-     @result{} i = [ 1; 2 ]\n\
-     @result{} j = [ 1; 2 ]\n\
+    @result{} i = [ 1; 2 ]\n\
+    @result{} j = [ 1; 2 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If three outputs are requested, @code{find} also returns a vector\n\
 containing the nonzero values.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [i, j, v] = find (3 * eye (2))\n\
-     @result{} i = [ 1; 2 ]\n\
-     @result{} j = [ 1; 2 ]\n\
-     @result{} v = [ 3; 3 ]\n\
+       @result{} i = [ 1; 2 ]\n\
+       @result{} j = [ 1; 2 ]\n\
+       @result{} v = [ 3; 3 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If two inputs are given, @var{n} indicates the maximum number of\n\
 elements to find from the beginning of the matrix or vector.\n\
 \n\
 If three inputs are given, @var{direction} should be one of \"first\" or\n\
 \"last\", requesting only the first or last @var{n} indices, respectively.\n\
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -45,18 +45,18 @@ Compute the normalized incomplete gamma 
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
                                  x\n\
                        1        /\n\
 gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt\n\
-                   gamma (a)    /\n\
-                             t=0\n\
+                  gamma (a)    /\n\
+                            t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 with the limiting value of 1 as @var{x} approaches infinity.\n\
 The standard notation is @math{P(a,x)}, e.g., Abramowitz and Stegun (6.5.1).\n\
 \n\
 If @var{a} is scalar, then @code{gammainc (@var{x}, @var{a})} is returned\n\
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -438,25 +438,24 @@ DEFUN_DLD (gcd, args, nargout,
 @deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 \n\
 Compute the greatest common divisor of @var{a1}, @var{a2}, @dots{}.  If more\n\
 than one argument is given all arguments must be the same size or scalar.\n\
 In this case the greatest common divisor is calculated for each element\n\
 individually.  All elements must be ordinary or Gaussian (complex)\n\
 integers.  Note that for Gaussian integers, the gcd is not unique up to\n\
 units (multiplication by 1, -1, @var{i} or -@var{i}), so an arbitrary\n\
-greatest common divisor amongst four possible is returned.  For example,\n\
+greatest common divisor amongst four possible is returned.\n\
 \n\
-@noindent\n\
-and\n\
+Example code:\n\
 \n\
 @example\n\
 @group\n\
 gcd ([15, 9], [20, 18])\n\
-    @result{}  5  9\n\
+   @result{}  5  9\n\
 @end group\n\
 @end example\n\
 \n\
 Optional return arguments @var{v1}, etc., contain integer vectors such\n\
 that,\n\
 \n\
 @tex\n\
 $g = v_1 a_1 + v_2 a_2 + \\cdots$\n\
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -51,18 +51,18 @@ Return a 2 by 2 orthogonal matrix\n\
 @code{@var{g} [@var{x}; @var{y}] = [*; 0]} with @var{x} and @var{y} scalars.\n\
 @end ifnottex\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 givens (1, 1)\n\
-     @result{}   0.70711   0.70711\n\
-         -0.70711   0.70711\n\
+   @result{}   0.70711   0.70711\n\
+       -0.70711   0.70711\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -39,18 +39,18 @@ Typecast the 16 character hexadecimal ch
 double precision number.  If fewer than 16 characters are given the\n\
 strings are right padded with '0' characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate\n\
 number.\n\
 \n\
 @example\n\
 @group\n\
-hex2num ([\"4005bf0a8b145769\";\"4024000000000000\"])\n\
-@result{} [2.7183; 10.000]\n\
+hex2num ([\"4005bf0a8b145769\"; \"4024000000000000\"])\n\
+   @result{} [2.7183; 10.000]\n\
 @end group\n\
 @end example\n\
 @seealso{num2hex, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
@@ -125,17 +125,17 @@ hex2num ([\"4005bf0a8b145769\";\"4024000
 DEFUN_DLD (num2hex, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double precision number or vector to a 16 character hexadecimal\n\
 string of the IEEE 754 representation of the number.  For example:\n\
 \n\
 @example\n\
 @group\n\
-num2hex ([-1, 1, e, Inf, NaN, NA]);\n\
+num2hex ([-1, 1, e, Inf, NaN, NA])\n\
 @result{} \"bff0000000000000\n\
     3ff0000000000000\n\
     4005bf0a8b145769\n\
     7ff0000000000000\n\
     fff8000000000000\n\
     7ff00000000007a2\"\n\
 @end group\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -240,27 +240,27 @@ dispatch_kron (const octave_value& a, co
 
 DEFUN_DLD (kron, args, , "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} kron (@var{A}, @var{B})\n\
 @deftypefnx {Loadable Function} {} kron (@var{A1}, @var{A2}, @dots{})\n\
 Form the Kronecker product of two or more matrices, defined block by \n\
 block as\n\
 \n\
 @example\n\
-x = [a(i, j) b]\n\
+x = [ a(i,j)*b ]\n\
 @end example\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 kron (1:4, ones (3, 1))\n\
-      @result{}  1  2  3  4\n\
-          1  2  3  4\n\
-          1  2  3  4\n\
+     @result{}  1  2  3  4\n\
+         1  2  3  4\n\
+         1  2  3  4\n\
 @end group\n\
 @end example\n\
 \n\
 If there are more than two input arguments @var{A1}, @var{A2}, @dots{}, \n\
 @var{An} the Kronecker product is computed as\n\
 \n\
 @example\n\
 kron (kron (@var{A1}, @var{A2}), @dots{}, @var{An})\n\
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -607,32 +607,32 @@ column vectors (rank-1 update) or matric
 (rank-k update).\n\
 Optionally, row-pivoted updating can be used by supplying\n\
 a row permutation (pivoting) matrix @var{P};\n\
 in that case, an updated permutation matrix is returned.\n\
 Note that if @var{L}, @var{U}, @var{P} is a pivoted LU@tie{}factorization\n\
 as obtained by @code{lu}:\n\
 \n\
 @example\n\
-  [@var{L}, @var{U}, @var{P}] = lu (@var{A});\n\
+[@var{L}, @var{U}, @var{P}] = lu (@var{A});\n\
 @end example\n\
 \n\
 @noindent\n\
 then a factorization of @xcode{@var{A}+@var{x}*@var{y}.'} can be obtained\n\
 either as\n\
 \n\
 @example\n\
-  [@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})\n\
+[@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})\n\
 @end example\n\
 \n\
 @noindent\n\
 or\n\
 \n\
 @example\n\
-  [@var{L1}, @var{U1}, @var{P1}] = lu (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
+[@var{L1}, @var{U1}, @var{P1}] = lu (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 @end example\n\
 \n\
 The first form uses the unpivoted algorithm, which is faster, but less\n\
 stable.  The second form uses a slower pivoted algorithm, which is more\n\
 stable.\n\
 \n\
 The matrix case is done as a sequence of rank-1 updates;\n\
 thus, for large enough k, it will be both faster and more accurate to\n\
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -571,17 +571,17 @@ DEFUN_DLD (cummin, args, nargout,
 @deftypefnx {Loadable Function} {} cummin (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
 Return the cumulative minimum values along dimension @var{dim}.  If @var{dim}\n\
 is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummin ([5 4 6 2 3 1])\n\
-    @result{}  5  4  4  2  2  1\n\
+   @result{}  5  4  4  2  2  1\n\
 @end group\n\
 @end example\n\
 \n\
 \n\
 The call\n\
 \n\
 @example\n\
   [w, iw] = cummin (x)\n\
@@ -613,17 +613,17 @@ DEFUN_DLD (cummax, args, nargout,
 @deftypefnx {Loadable Function} {} cummax (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
 Return the cumulative maximum values along dimension @var{dim}.  If @var{dim}\n\
 is unspecified it defaults to column-wise operation.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cummax ([1 3 2 6 4 5])\n\
-    @result{}  1  3  3  6  6  6\n\
+   @result{}  1  3  3  6  6  6\n\
 @end group\n\
 @end example\n\
 \n\
 The call\n\
 \n\
 @example\n\
 [w, iw] = cummax (x, dim)\n\
 @end example\n\
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -108,17 +108,17 @@ squares problems\n\
 @tex\n\
 $$\n\
 \\min_x \\left\\Vert A x - b \\right\\Vert_2\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
-@code{min norm(A x - b)}\n\
+min norm(A x - b)\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 for overdetermined systems of equations (i.e.,\n\
 @tex\n\
 $A$\n\
 @end tex\n\
 @ifnottex\n\
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -1480,17 +1480,17 @@ using the doubly-adaptive Clenshaw-Curti
 in @cite{Increasing the Reliability of Adaptive Quadrature Using Explicit\n\
 Interpolants}.\n\
 @var{f} is a function handle, inline function, or string\n\
 containing the name of the function to evaluate.\n\
 The function @var{f} must be vectorized and must return a vector of output\n\
 values if given a vector of input values.  For example,\n\
 \n\
 @example\n\
-   f = @@(x) x .* sin (1./x) .* sqrt (abs (1 - x));\n\
+f = @@(x) x .* sin (1./x) .* sqrt (abs (1 - x));\n\
 @end example\n\
 \n\
 @noindent\n\
 which uses the element-by-element `dot' form for all operators.\n\
 \n\
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both limits may be infinite.  @code{quadcc} handles an inifinite limit\n\
 by substituting the variable of integration with @code{x=tan(pi/2*u)}.\n\
@@ -1500,17 +1500,17 @@ the integration procedure.  The default 
 \n\
 The optional argument @var{sing} contains a list of points where the\n\
 integrand has known singularities, or discontinuities\n\
 in any of its derivatives, inside the integration interval.\n\
 For the example above, which has a discontinuity at x=1, the call to\n\
 @code{quadcc} would be as follows\n\
 \n\
 @example\n\
-   int = quadcc (f, a, b, 1.0e-6, [ 1 ]);\n\
+int = quadcc (f, a, b, 1.0e-6, [ 1 ]);\n\
 @end example\n\
 \n\
 The result of the integration is returned in @var{q}.\n\
 @var{err} is an estimate of the absolute integration error and\n\
 @var{nr_points} is the number of points at which the integrand was evaluated.\n\
 If the adaptive integration did not converge, the value of\n\
 @var{err} will be larger than the requested tolerance.  Therefore, it is\n\
 recommended to verify this value for difficult integrands.\n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -317,19 +317,19 @@ generalized eigenvalues of @math{(A - s 
 $$ W^T A = { \\rm diag }(\\lambda)W^T B $$\n\
 $$ AA = Q^T AZ, BB = Q^T BZ $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 \n\
-    A * V = B * V * diag (@var{lambda})\n\
-    W' * A = diag (@var{lambda}) * W' * B\n\
-    AA = Q * A * Z, BB = Q * B * Z\n\
+A * V = B * V * diag (@var{lambda})\n\
+W' * A = diag (@var{lambda}) * W' * B\n\
+AA = Q * A * Z, BB = Q * B * Z\n\
 \n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 with @var{Q} and @var{Z} orthogonal (unitary)= @var{I}\n\
 \n\
 @item @code{[AA,BB,Z@{, @var{lambda}@}] = qz (@var{A}, @var{B}, @var{opt})}\n\
@@ -339,16 +339,17 @@ for (e.g.) solution of discrete time alg
 Form 3 is not available for complex matrices, and does not compute\n\
 the generalized eigenvectors @var{V}, @var{W}, nor the orthogonal matrix\n\
 @var{Q}.\n\
 \n\
 @table @var\n\
 @item opt\n\
 for ordering eigenvalues of the GEP pencil.  The leading block\n\
 of the revised pencil contains all eigenvalues that satisfy:\n\
+\n\
 @table @asis\n\
 @item \"N\"\n\
 = unordered (default)\n\
 \n\
 @item \"S\"\n\
 = small: leading block has all |lambda| @leq{} 1\n\
 \n\
 @item \"B\"\n\
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -1073,17 +1073,17 @@ Replace occurrences of pattern @var{pat}
 \n\
 The pattern is a regular expression as documented for @code{regexp}.\n\
 @xref{doc-regexp,,regexp}.\n\
 \n\
 The replacement string may contain @code{$i}, which substitutes\n\
 for the ith set of parentheses in the match string.  For example,\n\
 \n\
 @example\n\
-regexprep(\"Bill Dunn\",'(\\w+) (\\w+)','$2, $1')\n\
+regexprep (\"Bill Dunn\", '(\\w+) (\\w+)', '$2, $1')\n\
 @end example\n\
 \n\
 @noindent\n\
 returns \"Dunn, Bill\"\n\
 \n\
 Options in addition to those of @code{regexp} are\n\
 \n\
 @table @samp\n\
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -159,17 +159,17 @@ then @var{idx} is a cell array of vector
 above.  Examples:\n\
 \n\
 @example\n\
 @group\n\
 strfind (\"abababa\", \"aba\")\n\
      @result{} [1, 3, 5]\n\
 \n\
 strfind (@{\"abababa\", \"bebebe\", \"ab\"@}, \"aba\")\n\
-     @result{} ans =\n\
+     @result{}\n\
         @{\n\
           [1,1] =\n\
 \n\
              1   3   5\n\
 \n\
           [1,2] = [](1x0)\n\
           [1,3] = [](1x0)\n\
         @}\n\
@@ -326,17 +326,17 @@ DEFUN_DLD (strrep, args, ,
 @deftypefn  {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep})\n\
 @deftypefnx {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep}, \"overlaps\", @var{o})\n\
 Replace all occurrences of the substring @var{ptn} in the string @var{s}\n\
 with the string @var{rep} and return the result.  For example:\n\
 \n\
 @example\n\
 @group\n\
 strrep (\"This is a test string\", \"is\", \"&%$\")\n\
-     @result{} \"Th&%$ &%$ a test string\"\n\
+    @result{}  \"Th&%$ &%$ a test string\"\n\
 @end group\n\
 @end example\n\
 \n\
 @var{s} may also be a cell array of strings, in which case the replacement is\n\
 done for each element and a cell array is returned.\n\
 @seealso{regexprep, strfind, findstr}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -177,18 +177,18 @@ Convert a linear index to subscripts.\n\
 \n\
 The following example shows how to convert the linear index @code{8}\n\
 in a 3-by-3 matrix into a subscript.  The matrix is linearly indexed\n\
 moving from one column to next, filling up all rows in each column.\n\
 \n\
 @example\n\
 @group\n\
 [r, c] = ind2sub ([3, 3], 8)\n\
-@result{} r =  2\n\
-   c =  3\n\
+    @result{} r =  2\n\
+    @result{} c =  3\n\
 @end group\n\
 @end example\n\
 @seealso{sub2ind}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -48,17 +48,17 @@ A X + X B + C = 0\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 using standard @sc{lapack} subroutines.  For example:\n\
 \n\
 @example\n\
 @group\n\
 syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])\n\
-     @result{} [ -0.50000, -0.66667; -0.66667, -0.50000 ]\n\
+   @result{} [ -0.50000, -0.66667; -0.66667, -0.50000 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -144,17 +144,17 @@ gmtime (time ())\n\
            hour = 7\n\
            mday = 17\n\
            mon = 1\n\
            year = 97\n\
            wday = 1\n\
            yday = 47\n\
            isdst = 0\n\
            zone = CST\n\
-         @}\n\
+        @}\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, localtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -208,17 +208,17 @@ localtime (time ())\n\
            hour = 1\n\
            mday = 17\n\
            mon = 1\n\
            year = 97\n\
            wday = 1\n\
            yday = 47\n\
            isdst = 0\n\
            zone = CST\n\
-         @}\n\
+        @}\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -324,17 +324,17 @@ Padding is with zeros by default; for fi
 number, padding can be changed or inhibited by following the @samp{%}\n\
 with one of the modifiers described below.  Unknown field specifiers are\n\
 copied as normal characters.  All other characters are copied to the\n\
 output without change.  For example:\n\
 \n\
 @example\n\
 @group\n\
 strftime (\"%r (%Z) %A %e %B %Y\", localtime (time ()))\n\
-     @result{} \"01:15:06 AM (CST) Monday 17 February 1997\"\n\
+      @result{} \"01:15:06 AM (CST) Monday 17 February 1997\"\n\
 @end group\n\
 @end example\n\
 \n\
 Octave's @code{strftime} function supports a superset of the ANSI C\n\
 field specifiers.\n\
 \n\
 @noindent\n\
 Literal character fields:\n\
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -90,30 +90,30 @@ DEFUN_DLD (typecast, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} typecast (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting the data of\n\
 @var{x} in memory as data of the numeric class @var{class}.  Both the class\n\
 of @var{x} and @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
-  \"logical\"\n\
-  \"char\"\n\
-  \"int8\"\n\
-  \"int16\"\n\
-  \"int32\"\n\
-  \"int64\"\n\
-  \"uint8\"\n\
-  \"uint16\"\n\
-  \"uint32\"\n\
-  \"uint64\"\n\
-  \"double\"\n\
-  \"single\"\n\
-  \"double complex\"\n\
-  \"single complex\"\n\
+\"logical\"\n\
+\"char\"\n\
+\"int8\"\n\
+\"int16\"\n\
+\"int32\"\n\
+\"int64\"\n\
+\"uint8\"\n\
+\"uint16\"\n\
+\"uint32\"\n\
+\"uint64\"\n\
+\"double\"\n\
+\"single\"\n\
+\"double complex\"\n\
+\"single complex\"\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 the last two are reserved for @var{class}; they indicate that a\n\
 complex-valued result is requested.  Complex arrays are stored in memory as\n\
 consecutive pairs of real numbers.  The sizes of integer types are given by\n\
 their bit counts.  Both logical and char are typically one byte wide;\n\
@@ -124,18 +124,18 @@ the return value is a row vector, otherw
 bit length of @var{x} is not divisible by that of @var{class}, an error\n\
 occurs.\n\
 \n\
 An example of the use of typecast on a little-endian machine is\n\
 \n\
 @example\n\
 @group\n\
 @var{x} = uint16 ([1, 65535]);\n\
-typecast (@var{x}, 'uint8')\n\
-@result{} [   0,   1, 255, 255]\n\
+typecast (@var{x}, \"uint8\")\n\
+  @result{} [   0,   1, 255, 255]\n\
 @end group\n\
 @end example\n\
 @seealso{cast, bitunpack, bitpack, swapbytes}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
@@ -275,27 +275,27 @@ DEFUN_DLD (bitpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting an array\n\
 @var{x} as raw bit patterns for data of the numeric class @var{class}.\n\
 @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
-  \"char\"\n\
-  \"int8\"\n\
-  \"int16\"\n\
-  \"int32\"\n\
-  \"int64\"\n\
-  \"uint8\"\n\
-  \"uint16\"\n\
-  \"uint32\"\n\
-  \"uint64\"\n\
-  \"double\"\n\
-  \"single\"\n\
+\"char\"\n\
+\"int8\"\n\
+\"int16\"\n\
+\"int32\"\n\
+\"int64\"\n\
+\"uint8\"\n\
+\"uint16\"\n\
+\"uint32\"\n\
+\"uint64\"\n\
+\"double\"\n\
+\"single\"\n\
 @end group\n\
 @end example\n\
 \n\
 The number of elements of @var{x} should be divisible by the bit length of\n\
 @var{class}.  If it is not, excess bits are discarded.  Bits come in\n\
 increasing order of significance, i.e., @code{x(1)} is bit 0, @code{x(2)} is\n\
 bit 1, etc.  The result is a row vector if @var{x} is a row vector, otherwise\n\
 it is a column vector.\n\
@@ -383,27 +383,27 @@ do_bitunpack (const ArrayType& array)
 DEFUN_DLD (bitunpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitunpack (@var{x})\n\
 Return an array @var{y} corresponding to the raw bit patterns of\n\
 @var{x}.  @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
-  \"char\"\n\
-  \"int8\"\n\
-  \"int16\"\n\
-  \"int32\"\n\
-  \"int64\"\n\
-  \"uint8\"\n\
-  \"uint16\"\n\
-  \"uint32\"\n\
-  \"uint64\"\n\
-  \"double\"\n\
-  \"single\"\n\
+\"char\"\n\
+\"int8\"\n\
+\"int16\"\n\
+\"int32\"\n\
+\"int64\"\n\
+\"uint8\"\n\
+\"uint16\"\n\
+\"uint32\"\n\
+\"uint64\"\n\
+\"double\"\n\
+\"single\"\n\
 @end group\n\
 @end example\n\
 \n\
 The result is a row vector if @var{x} is a row vector; otherwise, it is a\n\
 column vector.\n\
 @seealso{bitpack, typecast}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -871,17 +871,17 @@ s = urlread (\"http://user:password@@exa
 GET and POST requests can be specified by @var{method} and @var{param}.\n\
 The parameter @var{method} is either @samp{get} or @samp{post}\n\
 and @var{param} is a cell array of parameter and value pairs.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 s = urlread (\"http://www.google.com/search\", \"get\",\n\
-             @{\"query\", \"octave\"@});\n\
+            @{\"query\", \"octave\"@});\n\
 @end group\n\
 @end example\n\
 @seealso{urlwrite}\n\
 @end deftypefn")
 {
   // Octave's return value
   octave_value_list retval;
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -114,17 +114,17 @@ are nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether all of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
 @group\n\
 all ([2, 3; 1, 0]))\n\
-     @result{} [ 1, 0 ]\n\
+    @result{} [ 1, 0 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If the optional argument @var{dim} is supplied, work along dimension\n\
 @var{dim}.\n\
 @seealso{any}\n\
 @end deftypefn")
 {
@@ -163,27 +163,27 @@ is nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether any of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4))\n\
-     @result{} [ 1, 1, 0, 0 ]\n\
+ @result{} [ 1, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 \n\
 If the optional argument @var{dim} is supplied, work along dimension\n\
 @var{dim}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 any (eye (2, 4), 2)\n\
-     @result{} [ 1; 1 ]\n\
+ @result{} [ 1; 1 ]\n\
 @end group\n\
 @end example\n\
 @seealso{all}\n\
 @end deftypefn")
 {
   ANY_ALL (any);
 }
 
@@ -360,18 +360,18 @@ Compute the element-by-element square ro
 @var{x} and @var{y}.  This is equivalent to\n\
 @code{sqrt (@var{x}.^2 + @var{y}.^2)}, but calculated in a manner that\n\
 avoids overflows for large values of @var{x} or @var{y}.\n\
 @code{hypot} can also be called with more than 2 arguments; in this case,\n\
 the arguments are accumulated from left to right:\n\
 \n\
 @example\n\
 @group\n\
-  hypot (hypot (@var{x}, @var{y}), @var{z})\n\
-  hypot (hypot (hypot (@var{x}, @var{y}), @var{z}), @var{w}), etc.\n\
+hypot (hypot (@var{x}, @var{y}), @var{z})\n\
+hypot (hypot (hypot (@var{x}, @var{y}), @var{z}), @var{w}), etc.\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -1251,20 +1251,20 @@ Return a diagonal matrix with vector @va
 second argument is optional.  If it is positive, the vector is placed on\n\
 the @var{k}-th super-diagonal.  If it is negative, it is placed on the\n\
 @var{-k}-th sub-diagonal.  The default value of @var{k} is 0, and the\n\
 vector is placed on the main diagonal.  For example:\n\
 \n\
 @example\n\
 @group\n\
 diag ([1, 2, 3], 1)\n\
-     @result{}  0  1  0  0\n\
-         0  0  2  0\n\
-         0  0  0  3\n\
-         0  0  0  0\n\
+   @result{}  0  1  0  0\n\
+       0  0  2  0\n\
+       0  0  0  3\n\
+       0  0  0  0\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 The 3-input form returns a diagonal matrix with vector @var{v} on the main\n\
 diagonal and the resulting matrix being of size @var{m} rows x @var{n}\n\
 columns.\n\
 \n\
@@ -1861,17 +1861,17 @@ DEFUN (horzcat, args, ,
 @deftypefn {Built-in Function} {} horzcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the horizontal concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 2.\n\
 \n\
 Arrays may also be concatenated horizontally using the syntax for creating\n\
 new matrices.  For example:\n\
 \n\
 @example\n\
-@var{hcat} = [ @var{array1}, @var{array2}, @dots{} ];\n\
+@var{hcat} = [ @var{array1}, @var{array2}, @dots{} ]\n\
 @end example\n\
 @seealso{cat, vertcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -2, "horzcat");
 }
 
 /*
@@ -2070,17 +2070,17 @@ DEFUN (vertcat, args, ,
 @deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the vertical concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.\n\
 \n\
 Arrays may also be concatenated vertically using the syntax for creating\n\
 new matrices.  For example:\n\
 \n\
 @example\n\
-@var{vcat} = [ @var{array1}; @var{array2}; @dots{} ];\n\
+@var{vcat} = [ @var{array1}; @var{array2}; @dots{} ]\n\
 @end example\n\
 @seealso{cat, horzcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -1, "vertcat");
 }
 
 /*
@@ -2095,47 +2095,46 @@ DEFUN (cat, args, ,
 Return the concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.\n\
 \n\
 @example\n\
 @group\n\
 A = ones (2, 2);\n\
 B = zeros (2, 2);\n\
 cat (2, A, B)\n\
-    @result{} 1 1 0 0\n\
-       1 1 0 0\n\
+  @result{} 1 1 0 0\n\
+     1 1 0 0\n\
 @end group\n\
 @end example\n\
 \n\
 Alternatively, we can concatenate @var{A} and @var{B} along the\n\
-second dimension the following way:\n\
+second dimension in the following way:\n\
 \n\
 @example\n\
 @group\n\
-[A, B].\n\
+[A, B]\n\
 @end group\n\
 @end example\n\
 \n\
 @var{dim} can be larger than the dimensions of the N-D array objects\n\
 and the result will thus have @var{dim} dimensions as the\n\
 following example shows:\n\
 \n\
 @example\n\
 @group\n\
 cat (4, ones (2, 2), zeros (2, 2))\n\
-    @result{} ans =\n\
-\n\
-       ans(:,:,1,1) =\n\
-\n\
-         1 1\n\
-         1 1\n\
-\n\
-       ans(:,:,1,2) =\n\
-         0 0\n\
-         0 0\n\
+  @result{} ans(:,:,1,1) =\n\
+\n\
+       1 1\n\
+       1 1\n\
+\n\
+     ans(:,:,1,2) =\n\
+\n\
+       0 0\n\
+       0 0\n\
 @end group\n\
 @end example\n\
 @seealso{horzcat, vertcat}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () > 0)
@@ -2381,18 +2380,18 @@ DEFUN (ndims, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ndims (@var{a})\n\
 Return the number of dimensions of @var{a}.\n\
 For any array, the result will always be larger than or equal to 2.\n\
 Trailing singleton dimensions are not counted.\n\
 \n\
 @example\n\
 @group\n\
-  ndims (ones (4, 1, 2, 1))\n\
-     @result{} 3\n\
+ndims (ones (4, 1, 2, 1))\n\
+    @result{} 3\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).ndims ();
@@ -2406,26 +2405,26 @@ DEFUN (numel, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} numel (@var{a})\n\
 @deftypefnx {Built-in Function} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
 Return the number of elements in the object @var{a}.\n\
 Optionally, if indices @var{idx1}, @var{idx2}, @dots{} are supplied,\n\
 return the number of elements that would result from the indexing\n\
 \n\
 @example\n\
-  @var{a}(@var{idx1}, @var{idx2}, @dots{})\n\
+@var{a}(@var{idx1}, @var{idx2}, @dots{})\n\
 @end example\n\
 \n\
 Note that the indices do not have to be numerical.  For example,\n\
 \n\
 @example\n\
 @group\n\
-  @var{a} = 1;\n\
-  @var{b} = ones (2, 3);\n\
-  numel (@var{a}, @var{b});\n\
+@var{a} = 1;\n\
+@var{b} = ones (2, 3);\n\
+numel (@var{a}, @var{b})\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 will return 6, as this is the number of ways to index with @var{b}.\n\
 \n\
 This method is also called when an object appears as lvalue with cs-list\n\
 indexing, i.e., @code{object@{@dots{}@}} or @code{object(@dots{}).field}.\n\
@@ -2458,31 +2457,31 @@ Return the number of rows and columns of
 With one input argument and one output argument, the result is returned\n\
 in a row vector.  If there are multiple output arguments, the number of\n\
 rows is assigned to the first, and the number of columns to the second,\n\
 etc.  For example:\n\
 \n\
 @example\n\
 @group\n\
 size ([1, 2; 3, 4; 5, 6])\n\
-     @result{} [ 3, 2 ]\n\
+   @result{} [ 3, 2 ]\n\
 \n\
 [nr, nc] = size ([1, 2; 3, 4; 5, 6])\n\
-     @result{} nr = 3\n\
-     @result{} nc = 2\n\
+    @result{} nr = 3\n\
+    @result{} nc = 2\n\
 @end group\n\
 @end example\n\
 \n\
 If given a second argument, @code{size} will return the size of the\n\
 corresponding dimension.  For example,\n\
 \n\
 @example\n\
 @group\n\
 size ([1, 2; 3, 4; 5, 6], 2)\n\
-     @result{} 2\n\
+    @result{} 2\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 returns the number of columns in the given matrix.\n\
 @seealso{numel}\n\
 @end deftypefn")
 {
@@ -2645,41 +2644,42 @@ Return the number of columns of @var{a}.
 
   return retval;
 }
 
 DEFUN (sum, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} sum (@var{x})\n\
 @deftypefnx {Built-in Function} {} sum (@var{x}, @var{dim})\n\
-@deftypefnx {Built-in Function} {} sum (@dots{}, 'native')\n\
-@deftypefnx {Built-in Function} {} sum (@dots{}, 'double')\n\
-@deftypefnx {Built-in Function} {} sum (@dots{}, 'extra')\n\
+@deftypefnx {Built-in Function} {} sum (@dots{}, \"native\")\n\
+@deftypefnx {Built-in Function} {} sum (@dots{}, \"double\")\n\
+@deftypefnx {Built-in Function} {} sum (@dots{}, \"extra\")\n\
 Sum of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to the first non-singleton dimension.\n\
 \n\
-If the optional argument 'native' is given, then the sum is performed\n\
+If the optional argument \"native\" is given, then the sum is performed\n\
 in the same type as the original argument, rather than in the default\n\
 double type.  For example:\n\
 \n\
 @example\n\
 @group\n\
 sum ([true, true])\n\
-  @result{} 2\n\
-sum ([true, true], 'native')\n\
-  @result{} true\n\
+   @result{} 2\n\
+sum ([true, true], \"native\")\n\
+   @result{} true\n\
 @end group\n\
 @end example\n\
 \n\
-On the contrary, if 'double' is given, the sum is performed in double\n\
+On the contrary, if \"double\" is given, the sum is performed in double\n\
 precision even for single precision inputs.\n\
 \n\
-For double precision inputs, 'extra' indicates that a more accurate algorithm\n\
-than straightforward summation is to be used.  For single precision inputs,\n\
-'extra' is the same as 'double'.  Otherwise, 'extra' has no effect.\n\
+For double precision inputs, \"extra\" indicates that a more accurate\n\
+algorithm than straightforward summation is to be used.  For single precision\n\
+inputs, \"extra\" is the same as \"double\".  Otherwise, \"extra\" has no\n\
+effect.\n\
 @seealso{cumsum, sumsq, prod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   bool isnative = false;
@@ -3005,18 +3005,17 @@ Return a complex result from real argume
 return the complex result @code{@var{x} + 0i}.  With 2 real arguments,\n\
 return the complex result @code{@var{re} + @var{im}}.  @code{complex} can\n\
 often be more convenient than expressions such as @code{a + i*b}.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 complex ([1, 2], [3, 4])\n\
-@result{}\n\
-   1 + 3i   2 + 4i\n\
+  @result{} [ 1 + 3i   2 + 4i ]\n\
 @end group\n\
 @end example\n\
 @seealso{real, imag, iscomplex}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -3939,19 +3938,18 @@ Return a scalar, matrix or N-dimensional
 to the IEEE representation for positive infinity.\n\
 \n\
 Infinity is produced when results are too large to be represented using the\n\
 the IEEE floating point format for numbers.  Two common examples which\n\
 produce infinity are division by zero and overflow.\n\
 \n\
 @example\n\
 @group\n\
-[1/0 e^800]\n\
-@result{}\n\
-Inf   Inf\n\
+[ 1/0 e^800 ]\n\
+@result{} Inf   Inf\n\
 @end group\n\
 @end example\n\
 \n\
 When called with no arguments, return a scalar with the value @samp{Inf}.\n\
 When called with a single argument, return a square matrix with the dimension\n\
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
@@ -4534,19 +4532,19 @@ return a square @nospell{NxN} identity m
 supplied two scalar arguments (@var{m}, @var{n}), @code{eye} takes them to be\n\
 the number of rows and columns.  If given a vector with two elements,\n\
 @code{eye} uses the values of the elements as the number of rows and columns,\n\
 respectively.  For example:\n\
 \n\
 @example\n\
 @group\n\
 eye (3)\n\
-     @result{}  1  0  0\n\
-         0  1  0\n\
-         0  0  1\n\
+ @result{}  1  0  0\n\
+     0  1  0\n\
+     0  0  1\n\
 @end group\n\
 @end example\n\
 \n\
 The following expressions all produce the same result:\n\
 \n\
 @example\n\
 @group\n\
 eye (2)\n\
@@ -4778,28 +4776,30 @@ Resize @var{x} cutting off elements as n
 \n\
 In the result, element with certain indices is equal to the corresponding\n\
 element of @var{x} if the indices are within the bounds of @var{x};\n\
 otherwise, the element is set to zero.\n\
 \n\
 In other words, the statement\n\
 \n\
 @example\n\
-  y = resize (x, dv);\n\
+y = resize (x, dv)\n\
 @end example\n\
 \n\
 @noindent\n\
 is equivalent to the following code:\n\
 \n\
 @example\n\
 @group\n\
-  y = zeros (dv, class (x));\n\
-  sz = min (dv, size (x));\n\
-  for i = 1:length (sz), idx@{i@} = 1:sz(i); endfor\n\
-  y(idx@{:@}) = x(idx@{:@});\n\
+y = zeros (dv, class (x));\n\
+sz = min (dv, size (x));\n\
+for i = 1:length (sz)\n\
+  idx@{i@} = 1:sz(i);\n\
+endfor\n\
+y(idx@{:@}) = x(idx@{:@});\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but is performed more efficiently.\n\
 \n\
 If only @var{m} is supplied, and it is a scalar, the dimension of the\n\
 result is @var{m}-by-@var{m}.\n\
@@ -4868,18 +4868,18 @@ whose elements are taken from the matrix
 matrix are accessed in column-major order (like Fortran arrays are stored).\n\
 \n\
 The following code demonstrates reshaping a 1x4 row vector into a 2x2 square\n\
 matrix.\n\
 \n\
 @example\n\
 @group\n\
 reshape ([1, 2, 3, 4], 2, 2)\n\
-     @result{}  1  3\n\
-         2  4\n\
+      @result{}  1  3\n\
+          2  4\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that the total number of elements in the original\n\
 matrix (@code{prod (size (@var{A}))}) must match the total number of elements\n\
 in the new matrix (@code{prod ([@var{m} @var{n} @dots{}])}).\n\
 \n\
@@ -5431,17 +5431,17 @@ DEFUN (plus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} plus (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} plus (@var{x1}, @var{x2}, @dots{})\n\
 This function and @w{@xcode{x + y}} are equivalent.\n\
 If more arguments are given, the summation is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 + x2) + x3) + @dots{})\n\
+(@dots{}((x1 + x2) + x3) + @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{minus}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_add,
                                      octave_value::op_add_eq, args);
@@ -5462,17 +5462,17 @@ DEFUN (mtimes, args, ,
 @deftypefn  {Built-in Function} {} mtimes (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} mtimes (@var{x1}, @var{x2}, @dots{})\n\
 Return the matrix multiplication product of inputs.\n\
 This function and @w{@xcode{x * y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 * x2) * x3) * @dots{})\n\
+(@dots{}((x1 * x2) * x3) * @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{times}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_mul,
                                      octave_value::op_mul_eq, args);
@@ -5574,17 +5574,17 @@ DEFUN (times, args, ,
 @deftypefn  {Built-in Function} {} times (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} times (@var{x1}, @var{x2}, @dots{})\n\
 Return the element-by-element multiplication product of inputs.\n\
 This function and @w{@xcode{x .* y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 .* x2) .* x3) .* @dots{})\n\
+(@dots{}((x1 .* x2) .* x3) .* @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{mtimes}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_mul,
                                      octave_value::op_el_mul_eq, args);
@@ -5633,17 +5633,17 @@ DEFUN (and, args, ,
 @deftypefn  {Built-in Function} {} and (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} and (@var{x1}, @var{x2}, @dots{})\n\
 Return the logical AND of @var{x} and @var{y}.\n\
 This function is equivalent to @w{@code{x & y}}.\n\
 If more arguments are given, the logical and is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 & x2) & x3) & @dots{})\n\
+(@dots{}((x1 & x2) & x3) & @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{or, not, xor}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_and,
                                      octave_value::op_el_and_eq, args);
@@ -5654,17 +5654,17 @@ DEFUN (or, args, ,
 @deftypefn  {Built-in Function} {} or (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} or (@var{x1}, @var{x2}, @dots{})\n\
 Return the logical OR of @var{x} and @var{y}.\n\
 This function is equivalent to @w{@code{x | y}}.\n\
 If more arguments are given, the logical or is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
-  (@dots{}((x1 | x2) | x3) | @dots{})\n\
+(@dots{}((x1 | x2) | x3) | @dots{})\n\
 @end example\n\
 \n\
 At least one argument is required.\n\
 @seealso{and, not, xor}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_or,
                                      octave_value::op_el_or_eq, args);
@@ -5693,17 +5693,17 @@ will set the variable @code{elapsed_time
 the most recent call to the function @code{tic}.\n\
 \n\
 If called with one output argument then this function returns a scalar\n\
 of type @code{uint64} and the wall-clock timer is not started.\n\
 \n\
 @example\n\
 @group\n\
 t = tic; sleep (5); (double (tic ()) - double (t)) * 1e-6\n\
-     @result{} 5\n\
+      @result{} 5\n\
 @end group\n\
 @end example\n\
 \n\
 Nested timing with @code{tic} and @code{toc} is not supported.\n\
 Therefore @code{toc} will always return the elapsed time from the most\n\
 recent call to @code{tic}.\n\
 \n\
 If you are more interested in the CPU time that your process used, you\n\
@@ -5855,55 +5855,55 @@ DEFUN (sort, args, nargout,
 Return a copy of @var{x} with the elements arranged in increasing\n\
 order.  For matrices, @code{sort} orders the elements within columns\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 sort ([1, 2; 2, 3; 3, 1])\n\
-     @result{}  1  1\n\
-         2  2\n\
-         3  3\n\
+   @result{}  1  1\n\
+       2  2\n\
+       3  3\n\
 @end group\n\
 @end example\n\
 \n\
 If the optional argument @var{dim} is given, then the matrix is sorted\n\
 along the dimension defined by @var{dim}.  The optional argument @code{mode}\n\
 defines the order in which the values will be sorted.  Valid values of\n\
 @code{mode} are `ascend' or `descend'.\n\
 \n\
 The @code{sort} function may also be used to produce a matrix\n\
 containing the original row indices of the elements in the sorted\n\
 matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 [s, i] = sort ([1, 2; 2, 3; 3, 1])\n\
-     @result{} s = 1  1\n\
-            2  2\n\
-            3  3\n\
-     @result{} i = 1  3\n\
-            2  1\n\
-            3  2\n\
+  @result{} s = 1  1\n\
+         2  2\n\
+         3  3\n\
+  @result{} i = 1  3\n\
+         2  1\n\
+         3  2\n\
 @end group\n\
 @end example\n\
 \n\
 For equal elements, the indices are such that equal elements are listed\n\
 in the order in which they appeared in the original list.\n\
 \n\
 Sorting of complex entries is done first by magnitude (@code{abs (@var{z})})\n\
 and for any ties by phase angle (@code{angle (z)}).  For example:\n\
 \n\
 @example\n\
 @group\n\
 sort ([1+i; 1; 1-i])\n\
-     @result{} 1 + 0i\n\
-        1 - 1i\n\
-        1 + 1i\n\
+    @result{} 1 + 0i\n\
+       1 - 1i\n\
+       1 + 1i\n\
 @end group\n\
 @end example\n\
 \n\
 NaN values are treated as being greater than any other value and are sorted\n\
 to the end of the list.\n\
 \n\
 The @code{sort} function may also be used to sort strings and cell arrays\n\
 of strings, in which case ASCII dictionary order (uppercase 'A' precedes\n\
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -565,35 +565,35 @@ matches any of the enclosed characters.\
 @end table\n\
 \n\
 Tilde expansion\n\
 is performed on each of the patterns before looking for matching file\n\
 names.  For example:\n\
 \n\
 @example\n\
 ls\n\
-     @result{}\n\
-        file1  file2  file3  myfile1 myfile1b\n\
+   @result{}\n\
+      file1  file2  file3  myfile1 myfile1b\n\
 glob (\"*file1\")\n\
-     @result{}\n\
-        @{\n\
-          [1,1] = file1\n\
-          [2,1] = myfile1\n\
-        @}\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = file1\n\
+        [2,1] = myfile1\n\
+      @}\n\
 glob (\"myfile?\")\n\
-     @result{}\n\
-        @{\n\
-          [1,1] = myfile1\n\
-        @}\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = myfile1\n\
+      @}\n\
 glob (\"file[12]\")\n\
-     @result{}\n\
-        @{\n\
-          [1,1] = file1\n\
-          [2,1] = file2\n\
-        @}\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = file1\n\
+        [2,1] = file2\n\
+      @}\n\
 @end example\n\
 @seealso{ls, dir, readdir}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1848,19 +1848,20 @@ open for writing.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 fid = popen (\"ls -ltr / | tail -3\", \"r\");\n\
 while (ischar (s = fgets (fid)))\n\
   fputs (stdout, s);\n\
 endwhile\n\
-     @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc\n\
-     @print{} drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib\n\
-     @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp\n\
+\n\
+   @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc\n\
+   @print{} drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib\n\
+   @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -582,17 +582,17 @@ parameters.\n\
   pair_type ("global",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} global\n\
 Declare variables to have global scope.\n\
 \n\
 @example\n\
 @group\n\
 global @var{x};\n\
-if isempty (@var{x})\n\
+if (isempty (@var{x}))\n\
   x = 1;\n\
 endif\n\
 @end group\n\
 @end example\n\
 @seealso{persistent}\n\
 @end deftypefn"),
 
   pair_type ("if",
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -2132,17 +2132,17 @@ Add @var{dir1}, @dots{} to the current f
 directory name to the current path.  If @var{option} is \"-end\"\n\
 or 1, append the directory name to the current path.\n\
 Directories added to the path must exist.\n\
 \n\
 In addition to accepting individual directory arguments, lists of\n\
 directory names separated by @code{pathsep} are also accepted.  For example:\n\
 \n\
 @example\n\
-addpath (\"dir1:/dir2:~/dir3\");\n\
+addpath (\"dir1:/dir2:~/dir3\")\n\
 @end example\n\
 @seealso{path, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   // Originally written by Bill Denney and Etienne Grossman.  Heavily
   // modified and translated to C++ by jwe.
@@ -2243,17 +2243,17 @@ DEFUN (rmpath, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rmpath (@var{dir1}, @dots{})\n\
 Remove @var{dir1}, @dots{} from the current function search path.\n\
 \n\
 In addition to accepting individual directory arguments, lists of\n\
 directory names separated by @code{pathsep} are also accepted.  For example:\n\
 \n\
 @example\n\
-rmpath (\"dir1:/dir2:~/dir3\");\n\
+rmpath (\"dir1:/dir2:~/dir3\")\n\
 @end example\n\
 @seealso{path, addpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   // Originally by Etienne Grossmann. Heavily modified and translated
   // to C++ by jwe.
 
   octave_value retval;
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -381,17 +381,17 @@ DEFUN (ceil, args, ,
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  This is equivalent to\n\
 rounding towards positive infinity.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 ceil ([-2.7, 2.7])\n\
-   @result{}  -2   3\n\
+    @result{} -2    3\n\
 @end group\n\
 @end example\n\
 @seealso{floor, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).ceil ();
@@ -537,18 +537,18 @@ Compute the error function,\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 @c spacing appears odd here, but is correct after Makeinfo\n\
                           z\n\
                          /\n\
 erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
-                         /\n\
-                      t=0\n\
+                        /\n\
+                     t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{erfc, erfcx, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -590,17 +590,17 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
 */
 
 DEFUN (erfinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
 Compute the inverse error function, i.e., @var{y} such that\n\
 \n\
 @example\n\
-  erf (@var{y}) == @var{x}\n\
+erf (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erf, erfc, erfcx}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfinv ();
   else
@@ -807,17 +807,17 @@ DEFUN (fix, args, ,
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
 Truncate fractional portion of @var{x} and return the integer portion.  This\n\
 is equivalent to rounding towards zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 fix ([-2.7, 2.7])\n\
-   @result{} -2   2\n\
+   @result{} -2    2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, round}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).fix ();
@@ -842,17 +842,17 @@ DEFUN (floor, args, ,
 @deftypefn {Mapping Function} {} floor (@var{x})\n\
 Return the largest integer not greater than @var{x}.  This is equivalent to\n\
 rounding towards negative infinity.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 floor ([-2.7, 2.7])\n\
-     @result{} -3   2\n\
+     @result{} -3    2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).floor ();
@@ -884,18 +884,18 @@ Compute the Gamma function,\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 @c spacing appears odd here, but is correct after Makeinfo\n\
               infinity\n\
              /\n\
 gamma (z) = | t^(z-1) exp (-t) dt.\n\
-             /\n\
-          t=0\n\
+            /\n\
+         t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 @seealso{gammainc, lgamma}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1117,17 +1117,17 @@ DEFUN (isinf, args, ,
 @deftypefn {Mapping Function} {} isinf (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 are infinite and false where they are not.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 isinf ([13, Inf, NA, NaN])\n\
-     @result{} [ 0, 1, 0, 0 ]\n\
+      @result{} [ 0, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isfinite, isnan, isna}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).isinf ();
@@ -1258,17 +1258,17 @@ DEFUN (isnan, args, ,
 @deftypefn {Mapping Function} {} isnan (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 NaN values and false where they are not.\n\
 NA values are also considered NaN values.  For example:\n\
 \n\
 @example\n\
 @group\n\
 isnan ([13, Inf, NA, NaN])\n\
-     @result{} [ 0, 0, 1, 1 ]\n\
+      @result{} [ 0, 0, 1, 1 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isna, isinf, isfinite}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).isnan ();
@@ -1614,17 +1614,17 @@ DEFUN (round, args, ,
 @deftypefn {Mapping Function} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.  If there\n\
 are two nearest integers, return the one further away from zero.\n\
 \n\
 @example\n\
 @group\n\
 round ([-2.7, 2.7])\n\
-     @result{} -3   3\n\
+     @result{} -3    3\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, fix, roundb}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).round ();
@@ -1951,17 +1951,17 @@ DEFUNX ("tolower", Ftolower, args, ,
 @deftypefnx {Mapping Function} {} lower (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each uppercase\n\
 character replaced by the corresponding lowercase one; non-alphabetic\n\
 characters are left unchanged.  For example:\n\
 \n\
 @example\n\
 @group\n\
 tolower (\"MiXeD cAsE 123\")\n\
-     @result{} \"mixed case 123\"\n\
+      @result{} \"mixed case 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{toupper}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).xtolower ();
@@ -2002,17 +2002,17 @@ DEFUNX ("toupper", Ftoupper, args, ,
 @deftypefnx {Mapping Function} {} upper (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each lowercase\n\
 character replaced by the corresponding uppercase one; non-alphabetic\n\
 characters are left unchanged.  For example:\n\
 \n\
 @example\n\
 @group\n\
 toupper (\"MiXeD cAsE 123\")\n\
-     @result{} \"MIXED CASE 123\"\n\
+      @result{} \"MIXED CASE 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{tolower}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).xtoupper ();
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -4214,19 +4214,19 @@ any sort (@pxref{Function Handles}).  Hi
 the only way to call user-supplied functions in strings, but\n\
 function handles are now preferred due to the cleaner syntax they\n\
 offer.  For example,\n\
 \n\
 @example\n\
 @group\n\
 @var{f} = @@exp;\n\
 feval (@var{f}, 1)\n\
-     @result{} 2.7183\n\
+    @result{} 2.7183\n\
 @var{f} (1)\n\
-     @result{} 2.7183\n\
+    @result{} 2.7183\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 are equivalent ways to call the function referred to by @var{f}.  If it\n\
 cannot be predicted beforehand that @var{f} is a function handle or the\n\
 function name in a string, @code{feval} can be used instead.\n\
 @end deftypefn")
@@ -4454,17 +4454,17 @@ Parse the string @var{try} and evaluate 
 program.  If that fails, evaluate the optional string @var{catch}.\n\
 The string @var{try} is evaluated in the current context,\n\
 so any results remain available after @code{eval} returns.\n\
 \n\
 The following example makes the variable @var{a} with the approximate\n\
 value 3.1416 available.\n\
 \n\
 @example\n\
-eval(\"a = acos(-1);\");\n\
+eval (\"a = acos(-1);\");\n\
 @end example\n\
 \n\
 If an error occurs during the evaluation of @var{try} the @var{catch}\n\
 string is evaluated, as the following example shows:\n\
 \n\
 @example\n\
 @group\n\
 eval ('error (\"This is a bad example\");',\n\
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1533,21 +1533,21 @@ DEFUN (sparse_auto_mutate, args, nargout
 @deftypefnx {Built-in Function} {} sparse_auto_mutate (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 automatically mutate sparse matrices to full matrices to save memory.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 s = speye (3);\n\
-sparse_auto_mutate (false)\n\
+sparse_auto_mutate (false);\n\
 s(:, 1) = 1;\n\
 typeinfo (s)\n\
 @result{} sparse matrix\n\
-sparse_auto_mutate (true)\n\
+sparse_auto_mutate (true);\n\
 s(1, :) = 1;\n\
 typeinfo (s)\n\
 @result{} matrix\n\
 @end group\n\
 @end example\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1390,34 +1390,34 @@ DEFUN (struct2cell, args, ,
 @deftypefn {Built-in Function} {} struct2cell (@var{S})\n\
 Create a new cell array from the objects stored in the struct object.\n\
 If @var{f} is the number of fields in the structure, the resulting\n\
 cell array will have a dimension vector corresponding to\n\
 @code{[@var{F} size(@var{S})]}.  For example:\n\
 \n\
 @example\n\
 @group\n\
-  s = struct('name', @{'Peter', 'Hannah', 'Robert'@},\n\
-             'age', @{23, 16, 3@});\n\
-  c = struct2cell(s)\n\
-     @result{} c = @{1x1x3 Cell Array@}\n\
-  c(1,1,:)(:)\n\
-     @result{} ans =\n\
-        @{\n\
-          [1,1] = Peter\n\
-          [2,1] = Hannah\n\
-          [3,1] = Robert\n\
-        @}\n\
-  c(2,1,:)(:)\n\
-     @result{} ans =\n\
-        @{\n\
-          [1,1] = 23\n\
-          [2,1] = 16\n\
-          [3,1] = 3\n\
-        @}\n\
+s = struct (\"name\", @{\"Peter\", \"Hannah\", \"Robert\"@},\n\
+           \"age\", @{23, 16, 3@});\n\
+c = struct2cell (s)\n\
+   @result{} c = @{1x1x3 Cell Array@}\n\
+c(1,1,:)(:)\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = Peter\n\
+        [2,1] = Hannah\n\
+        [3,1] = Robert\n\
+      @}\n\
+c(2,1,:)(:)\n\
+   @result{}\n\
+      @{\n\
+        [1,1] = 23\n\
+        [2,1] = 16\n\
+        [3,1] = 3\n\
+      @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{cell2struct, fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -2028,25 +2028,25 @@ DEFUN (cell2struct, args, ,
 @deftypefn {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
 Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
 must match the number of elements in @var{cell} along dimension @var{dim},\n\
 that is @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.\n\
 If @var{dim} is omitted, a value of 1 is assumed.\n\
 \n\
 @example\n\
 @group\n\
-A = cell2struct (@{'Peter', 'Hannah', 'Robert';\n\
+A = cell2struct (@{\"Peter\", \"Hannah\", \"Robert\";\n\
                    185, 170, 168@},\n\
-                 @{'Name','Height'@}, 1);\n\
+                 @{\"Name\",\"Height\"@}, 1);\n\
 A(1)\n\
-     @result{} ans =\n\
-        @{\n\
-          Name   = Peter\n\
-          Height = 185\n\
-        @}\n\
+   @result{}\n\
+      @{\n\
+        Name   = Peter\n\
+        Height = 185\n\
+      @}\n\
 \n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2806,22 +2806,22 @@ The @samp{subs} field may be either @sam
 of index values.\n\
 \n\
 The following example shows how to extract the two first columns of\n\
 a matrix\n\
 \n\
 @example\n\
 @group\n\
 val = magic(3)\n\
-     @result{} val = [ 8   1   6\n\
-                3   5   7\n\
-                4   9   2 ]\n\
+    @result{} val = [ 8   1   6\n\
+               3   5   7\n\
+               4   9   2 ]\n\
 idx.type = \"()\";\n\
 idx.subs = @{\":\", 1:2@};\n\
-subsref(val, idx)\n\
+subsref (val, idx)\n\
      @result{} [ 8   1\n\
           3   5\n\
           4   9 ]\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that this is the same as writing @code{val(:,1:2)}.\n\
@@ -2868,23 +2868,23 @@ are @samp{\"()\"}, @samp{\"@{@}\"}, and 
 The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
 of index values.\n\
 \n\
 The following example shows how to set the two first columns of a\n\
 3-by-3 matrix to zero.\n\
 \n\
 @example\n\
 @group\n\
-val = magic(3);\n\
+val = magic (3);\n\
 idx.type = \"()\";\n\
 idx.subs = @{\":\", 1:2@};\n\
 subsasgn (val, idx, 0)\n\
-     @result{} [ 0   0   6\n\
-          0   0   7\n\
-          0   0   2 ]\n\
+     @result{}  [ 0   0   6\n\
+           0   0   7\n\
+           0   0   2 ]\n\
 @end group\n\
 @end example\n\
 \n\
 Note that this is the same as writing @code{val(:,1:2) = 0}.\n\
 \n\
 If @var{idx} is an empty structure array with fields @samp{type}\n\
 and @samp{subs}, return @var{rhs}.\n\
 @seealso{subsref, substruct}\n\
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3371,18 +3371,18 @@ octave_print_internal (std::ostream&, co
 DEFUN (rats, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rats (@var{x}, @var{len})\n\
 Convert @var{x} into a rational approximation represented as a string.\n\
 You can convert the string back into a matrix as follows:\n\
 \n\
 @example\n\
 @group\n\
-   r = rats(hilb(4));\n\
-   x = str2num(r)\n\
+r = rats (hilb (4));\n\
+x = str2num (r)\n\
 @end group\n\
 @end example\n\
 \n\
 The optional second argument defines the maximum length of the string\n\
 representing the elements of @var{x}.  By default @var{len} is 9.\n\
 @seealso{format, rat}\n\
 @end deftypefn")
 {
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1395,19 +1395,19 @@ DEFUN (string_fill_char, args, nargout,
 Query or set the internal variable used to pad all rows of a character\n\
 matrix to the same length.  It must be a single character.  The default\n\
 value is @code{\" \"} (a single space).  For example:\n\
 \n\
 @example\n\
 @group\n\
 string_fill_char (\"X\");\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
-     @result{} \"theseXX\"\n\
-        \"areXXXX\"\n\
-        \"strings\"\n\
+     @result{}  \"theseXX\"\n\
+         \"areXXXX\"\n\
+         \"strings\"\n\
 @end group\n\
 @end example\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -59,23 +59,23 @@ is outside the ASCII range (0-255).\n\
 For cell arrays, each element is concatenated separately.  Cell arrays\n\
 converted through\n\
 @code{char} can mostly be converted back with @code{cellstr}.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 char ([97, 98, 99], \"\", @{\"98\", \"99\", 100@}, \"str1\", [\"ha\", \"lf\"])\n\
-     @result{} [\"abc    \"\n\
-         \"       \"\n\
-         \"98     \"\n\
-         \"99     \"\n\
-         \"d      \"\n\
-         \"str1   \"\n\
-         \"half   \"]\n\
+   @result{} [\"abc    \"\n\
+       \"       \"\n\
+       \"98     \"\n\
+       \"99     \"\n\
+       \"d      \"\n\
+       \"str1   \"\n\
+       \"half   \"]\n\
 @end group\n\
 @end example\n\
 @seealso{strvcat, cellstr}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -190,22 +190,22 @@ is outside the ASCII range (0-255).\n\
 For cell arrays, each element is concatenated separately.  Cell arrays\n\
 converted through\n\
 @code{strvcat} can mostly be converted back with @code{cellstr}.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 strvcat ([97, 98, 99], \"\", @{\"98\", \"99\", 100@}, \"str1\", [\"ha\", \"lf\"])\n\
-     @result{} [\"abc    \"\n\
-         \"98     \"\n\
-         \"99     \"\n\
-         \"d      \"\n\
-         \"str1   \"\n\
-         \"half   \"]\n\
+      @result{} [\"abc    \"\n\
+          \"98     \"\n\
+          \"99     \"\n\
+          \"d      \"\n\
+          \"str1   \"\n\
+          \"half   \"]\n\
 @end group\n\
 @end example\n\
 @seealso{char, strcat, cstrcat}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -660,17 +660,17 @@ DEFUN (strncmp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmp (@var{s1}, @var{s2}, @var{n})\n\
 Return 1 if the first @var{n} characters of strings @var{s1} and @var{s2} are\n\
 the same, and 0 otherwise.\n\
 \n\
 @example\n\
 @group\n\
 strncmp (\"abce\", \"abcd\", 3)\n\
-     @result{} 1\n\
+      @result{} 1\n\
 @end group\n\
 @end example\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
 or character string.\n\
@@ -862,19 +862,19 @@ columns with an overall maximum width of
 If @var{width} is not specified, the width of the terminal screen is used.\n\
 Newline characters are used to break the lines in the output string.\n\
 For example:\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
 @smallexample\n\
 @group\n\
 list_in_columns (@{\"abc\", \"def\", \"ghijkl\", \"mnop\", \"qrs\", \"tuv\"@}, 20)\n\
-     @result{} ans = abc     mnop\n\
-            def     qrs\n\
-            ghijkl  tuv\n\
+     @result{} abc     mnop\n\
+        def     qrs\n\
+        ghijkl  tuv\n\
 \n\
 whos ans\n\
      @result{}\n\
      Variables in the current scope:\n\
 \n\
        Attr Name        Size                     Bytes  Class\n\
        ==== ====        ====                     =====  =====\n\
             ans         1x37                        37  char\n\
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -264,20 +264,21 @@ do\n\
     sleep (0.1);\n\
     fclear (out);\n\
   else\n\
     done = true;\n\
   endif\n\
 until (done)\n\
 fclose (out);\n\
 waitpid (pid);\n\
-     @print{} these\n\
-     @print{} strings\n\
-     @print{} some\n\
-     @print{} are\n\
+\n\
+   @print{} these\n\
+   @print{} strings\n\
+   @print{} some\n\
+   @print{} are\n\
 @end example\n\
 \n\
 Note that @code{popen2}, unlike @code{popen}, will not \"reap\" the\n\
 child process.  If you don't use @code{waitpid} to check the child's\n\
 exit status, it will linger until Octave exits.\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -944,35 +945,35 @@ corresponding system error message.\n\
 If @var{file} is a symbolic link, @code{stat} will return information\n\
 about the actual file that is referenced by the link.  Use @code{lstat}\n\
 if you want information about the symbolic link itself.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 [s, err, msg] = stat (\"/vmlinuz\")\n\
-      @result{} s =\n\
-        @{\n\
-          atime = 855399756\n\
-          rdev = 0\n\
-          ctime = 847219094\n\
-          uid = 0\n\
-          size = 389218\n\
-          blksize = 4096\n\
-          mtime = 847219094\n\
-          gid = 6\n\
-          nlink = 1\n\
-          blocks = 768\n\
-          mode = -rw-r--r--\n\
-          modestr = -rw-r--r--\n\
-          ino = 9316\n\
-          dev = 2049\n\
-        @}\n\
-     @result{} err = 0\n\
-     @result{} msg =\n\
+  @result{} s =\n\
+     @{\n\
+       atime = 855399756\n\
+       rdev = 0\n\
+       ctime = 847219094\n\
+       uid = 0\n\
+       size = 389218\n\
+       blksize = 4096\n\
+       mtime = 847219094\n\
+       gid = 6\n\
+       nlink = 1\n\
+       blocks = 768\n\
+       mode = -rw-r--r--\n\
+       modestr = -rw-r--r--\n\
+       ino = 9316\n\
+       dev = 2049\n\
+     @}\n\
+  @result{} err = 0\n\
+  @result{} msg =\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       if (args(0).is_scalar_type ())
@@ -1198,23 +1199,23 @@ Return the hostname of the system where 
 DEFUN (uname, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{uts}, @var{err}, @var{msg}] =} uname ()\n\
 Return system information in the structure.  For example:\n\
 \n\
 @example\n\
 @group\n\
 uname ()\n\
-     @result{} @{\n\
-           sysname = x86_64\n\
-           nodename = segfault\n\
-           release = 2.6.15-1-amd64-k8-smp\n\
-           version = Linux\n\
-           machine = #2 SMP Thu Feb 23 04:57:49 UTC 2006\n\
-         @}\n\
+   @result{} @{\n\
+         sysname = x86_64\n\
+         nodename = segfault\n\
+         release = 2.6.15-1-amd64-k8-smp\n\
+         version = Linux\n\
+         machine = #2 SMP Thu Feb 23 04:57:49 UTC 2006\n\
+      @}\n\
 @end group\n\
 @end example\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -356,17 +356,17 @@ DEFUN (isglobal, args, ,
 @deftypefn {Built-in Function} {} isglobal (@var{name})\n\
 Return true if @var{name} is a globally visible variable.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 global x\n\
 isglobal (\"x\")\n\
-     @result{} 1\n\
+   @result{} 1\n\
 @end group\n\
 @end example\n\
 @seealso{isvarname, exist}\n\
 @end deftypefn")
 {
   return do_isglobal (args);
 }
 
