# HG changeset patch
# User Rik <rik@octave.org>
# Date 1462204398 25200
#      Mon May 02 08:53:18 2016 -0700
# Node ID 53728df3e4c95b60f53b4f1174cef02ae28946ee
# Parent  ff2347e1df0245f1fe0d6f1cd30c52b8287b0efa
maint: for clarity, call ndims() rather than length() on dimension vectors.

* ov-re-sparse.cc, QtHandlesUtils.cc, __lin_interpn__.cc, bsxfun.cc,
cellfun.cc, data.cc, dot.cc, ellipj.cc, fft.cc, fft2.cc, fftn.cc, filter.cc,
gl-render.cc, graphics.cc, mex.cc, oct-map.h, sub2ind.cc, symtab.cc, tril.cc,
typecast.cc, utils.cc, variables.cc, ov-base-diag.cc, ov-base-int.cc,
ov-base.cc, ov-base.h, ov-bool-mat.cc, ov-bool-sparse.cc, ov-cell.cc,
ov-class.cc, ov-cx-mat.cc, ov-cx-sparse.cc, ov-flt-cx-mat.cc, ov-flt-re-mat.cc,
ov-intx.h, ov-java.cc, ov-lazy-idx.cc, ov-re-mat.cc, ov-str-mat.cc,
ov-struct.cc, ov.cc, pt-arg-list.cc, pt-mat.cc, Array-util.cc, Array.cc,
Array.h, CNDArray.cc, CSparse.cc, Sparse.cc, Sparse.h, dNDArray.cc, dSparse.cc,
dim-vector.cc, dim-vector.h, fCNDArray.cc, fNDArray.cc, idx-vector.cc,
bsxfun.h, oct-fftw.cc, mx-inlines.cc, lo-array-errwarn.cc, lo-array-gripes.cc:
For clarity, call ndims() rather than length() on dimension vectors.

diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -272,17 +272,17 @@ fromHVAlign (const caseless_str& halign,
   return flags;
 }
 
 QImage
 makeImageFromCData (const octave_value& v, int width, int height)
 {
   dim_vector dv (v.dims ());
 
-  if (dv.length () == 3 && dv(2) == 3)
+  if (dv.ndims () == 3 && dv(2) == 3)
     {
       int w = qMin (dv(1), static_cast<octave_idx_type> (width));
       int h = qMin (dv(0), static_cast<octave_idx_type> (height));
 
       int x_off = (w < width ? (width - w) / 2 : 0);
       int y_off = (h < height ? (height - h) / 2 : 0);
 
       QImage img (width, height, QImage::Format_ARGB32);
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 
 // equivalent to isvector.m
 
 template <typename T>
 bool
 isvector (const T& array)
 {
   const dim_vector dv = array.dims ();
-  return dv.length () == 2 && (dv(0) == 1 || dv(1) == 1);
+  return dv.ndims () == 2 && (dv(0) == 1 || dv(1) == 1);
 }
 
 // lookup a value in a sorted table (lookup.m)
 template <typename T>
 octave_idx_type
 lookup (const T *x, octave_idx_type n, T y)
 {
   octave_idx_type j;
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -227,17 +227,17 @@ maybe_optimized_builtin (const std::stri
   return retval;
 }
 
 static bool
 maybe_update_column (octave_value& Ac, const octave_value& A,
                      const dim_vector& dva, const dim_vector& dvc,
                      octave_idx_type i, octave_value_list &idx)
 {
-  octave_idx_type nd = dva.length ();
+  octave_idx_type nd = dva.ndims ();
 
   if (i == 0)
     {
       idx(0) = octave_value (':');
       for (octave_idx_type j = 1; j < nd; j++)
         {
           if (dva(j) == 1)
             idx(j) = octave_value (1);
@@ -279,17 +279,17 @@ maybe_update_column (octave_value& Ac, c
     }
 }
 
 #if 0
 // FIXME: this function is not used; is it OK to delete it?
 static void
 update_index (octave_value_list& idx, const dim_vector& dv, octave_idx_type i)
 {
-  octave_idx_type nd = dv.length ();
+  octave_idx_type nd = dv.ndims ();
 
   if (i == 0)
     {
       for (octave_idx_type j = nd - 1; j > 0; j--)
         idx(j) = octave_value (1.0);
       idx(0) = octave_value (':');
     }
   else
@@ -301,17 +301,17 @@ update_index (octave_value_list& idx, co
         }
     }
 }
 #endif
 
 static void
 update_index (Array<int>& idx, const dim_vector& dv, octave_idx_type i)
 {
-  octave_idx_type nd = dv.length ();
+  octave_idx_type nd = dv.ndims ();
 
   idx(0) = 0;
   for (octave_idx_type j = 1; j < nd; j++)
     {
       idx(j) = i % dv(j);
       i /= dv(j);
     }
 }
@@ -368,19 +368,19 @@ dimensionality as the other array.\n\
           if (tmp.is_defined ())
             retval(0) = tmp;
         }
     }
 
   if (retval.empty ())
     {
       dim_vector dva = A.dims ();
-      octave_idx_type nda = dva.length ();
+      octave_idx_type nda = dva.ndims ();
       dim_vector dvb = B.dims ();
-      octave_idx_type ndb = dvb.length ();
+      octave_idx_type ndb = dvb.ndims ();
       octave_idx_type nd = nda;
 
       if (nda > ndb)
         dvb.resize (nda, 1);
       else if (nda < ndb)
         {
           dva.resize (ndb, 1);
           nd = ndb;
@@ -439,17 +439,17 @@ dimensionality as the other array.\n\
           BSXDEF(uint64NDArray);
 
           octave_value Ac;
           octave_value_list idxA;
           octave_value Bc;
           octave_value_list idxB;
           octave_value C;
           octave_value_list inputs (2);
-          Array<int> ra_idx (dim_vector (dvc.length (), 1), 0);
+          Array<int> ra_idx (dim_vector (dvc.ndims (), 1), 0);
 
 
           for (octave_idx_type i = 0; i < ncount; i++)
             {
               if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
                 inputs(0) = Ac;
 
               if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -189,17 +189,17 @@ try_cellfun_internal_ops (const octave_v
       if (d < 0)
         error ("cellfun: K must be a positive integer");
 
       NDA result (f_args.dims ());
 
       for (octave_idx_type count = 0; count < k; count++)
         {
           dim_vector dv = f_args.elem (count).dims ();
-          if (d < dv.length ())
+          if (d < dv.ndims ())
             result(count) = static_cast<double> (dv(d));
           else
             result(count) = 1.0;
         }
 
       retval(0) = result;
     }
   else if (name == "isclass")
@@ -1599,21 +1599,21 @@ arrayfun (@@str2num, [1234],\n\
 
 static void
 do_num2cell_helper (const dim_vector& dv,
                     const Array<int>& dimv,
                     dim_vector& celldv, dim_vector& arraydv,
                     Array<int>& perm)
 {
   int dvl = dimv.numel ();
-  int maxd = dv.length ();
+  int maxd = dv.ndims ();
   celldv = dv;
   for (int i = 0; i < dvl; i++)
     maxd = std::max (maxd, dimv(i));
-  if (maxd > dv.length ())
+  if (maxd > dv.ndims ())
     celldv.resize (maxd, 1);
   arraydv = celldv;
 
   OCTAVE_LOCAL_BUFFER_INIT (bool, sing, maxd, false);
 
   perm.clear (maxd, 1);
   for (int i = 0; i < dvl; i++)
     {
@@ -1847,17 +1847,17 @@ mat2cell_mismatch (const dim_vector& dv,
                    const Array<octave_idx_type> *d, int nd)
 {
   for (int i = 0; i < nd; i++)
     {
       octave_idx_type s = 0;
       for (octave_idx_type j = 0; j < d[i].numel (); j++)
         s += d[i](j);
 
-      octave_idx_type r = i < dv.length () ? dv(i) : 1;
+      octave_idx_type r = i < dv.ndims () ? dv(i) : 1;
 
       if (s != r)
         error ("mat2cell: mismatch on dimension %d (%d != %d)", i+1, r, s);
     }
 
   return false;
 }
 
@@ -2204,17 +2204,17 @@ do_cellslices_nda (const NDA& array,
                              || (dim == 1 && array.rows () == 1)))
     {
       for (octave_idx_type i = 0; i < n; i++)
         retval(i) = array.index (idx_vector (lb(i) - 1, ub(i)));
     }
   else
     {
       const dim_vector dv = array.dims ();
-      int ndims = dv.length ();
+      int ndims = dv.ndims ();
       if (dim < 0)
         dim = dv.first_non_singleton ();
       ndims = std::max (ndims, dim + 1);
 
       Array<idx_vector> idx (dim_vector (ndims, 1), idx_vector::colon);
 
       for (octave_idx_type i = 0; i < n; i++)
         {
@@ -2326,17 +2326,17 @@ slicing is done along the first non-sing
         }
     }
   else
     {
       // generic code.
       octave_idx_type n = lb.numel ();
       retcell = Cell (1, n);
       const dim_vector dv = x.dims ();
-      int ndims = dv.length ();
+      int ndims = dv.ndims ();
       if (dim < 0)
         dim = dv.first_non_singleton ();
       ndims = std::max (ndims, dim + 1);
       octave_value_list idx (ndims, octave_value::magic_colon_t);
       for (octave_idx_type i = 0; i < n; i++)
         {
           idx(dim) = Range (lb(i), ub(i));
           retcell(i) = x.do_index_op (idx);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -2090,17 +2090,17 @@ do_cat (const octave_value_list& xargs, 
           //   tmp = octave_value_typeinfo::lookup_type
           //                                (args(1).type_name());
           // and then directly resize. However, for some types there might
           // be some additional setup needed, and so this should be avoided.
 
           octave_value tmp = args(0);
           tmp = tmp.resize (dim_vector (0,0)).resize (dv);
 
-          int dv_len = dv.length ();
+          int dv_len = dv.ndims ();
           Array<octave_idx_type> ra_idx (dim_vector (dv_len, 1), 0);
 
           for (int j = 0; j < n_args; j++)
             {
               // Can't fast return here to skip empty matrices as something
               // like cat (1,[],single ([])) must return an empty matrix of
               // the right type.
               tmp = do_cat_op (tmp, args(j), ra_idx);
@@ -2110,17 +2110,17 @@ do_cat (const octave_value_list& xargs, 
               if (dim >= dv_len)
                 {
                   if (j > 1)
                     error ("%s: indexing error", fname.c_str ());
 
                   break;
                 }
               else
-                ra_idx(dim) += (dim < dv_tmp.length () ? dv_tmp(dim) : 1);
+                ra_idx(dim) += (dim < dv_tmp.ndims () ? dv_tmp(dim) : 1);
             }
           retval = tmp;
         }
     }
   else
     print_usage ();
 
   return retval;
@@ -2807,17 +2807,17 @@ returns the number of columns in the giv
         {
           const dim_vector rdims = dimensions.redim (nargout);
           retval.resize (nargout);
           for (int i = 0; i < nargout; i++)
             retval(i) = rdims(i);
         }
       else
         {
-          int ndims = dimensions.length ();
+          int ndims = dimensions.ndims ();
 
           NoAlias<Matrix> m (1, ndims);
 
           for (int i = 0; i < ndims; i++)
             m(i) = dimensions(i);
 
           retval(0) = m;
         }
@@ -2826,17 +2826,17 @@ returns the number of columns in the giv
     {
       octave_idx_type nd = args(1).xidx_type_value ("size: DIM must be an integer");
 
       const dim_vector dv = args(0).dims ();
 
       if (nd < 1)
         error ("size: requested dimension DIM (= %d) out of range", nd);
 
-      if (nd <= dv.length ())
+      if (nd <= dv.ndims ())
         retval(0) = dv(nd-1);
       else
         retval(0) = 1;
     }
   else
     print_usage ();
 
   return retval;
@@ -3671,17 +3671,17 @@ consequence a 1x1 array, or scalar, is a
 @seealso{isscalar, ismatrix, size, rows, columns, length}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return ovl (sz.length () == 2 && (sz(0) == 1 || sz(1) == 1));
+  return ovl (sz.ndims () == 2 && (sz(0) == 1 || sz(1) == 1));
 }
 
 /*
 %!assert (isvector (1), true)
 %!assert (isvector ([1; 2; 3]), true)
 %!assert (isvector ([1, 2, 3]), true)
 %!assert (isvector ([]), false)
 %!assert (isvector ([1, 2; 3, 4]), false)
@@ -3706,17 +3706,17 @@ Return true if @var{x} is a row vector 1
 @seealso{iscolumn, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return ovl (sz.length () == 2 && sz(0) == 1);
+  return ovl (sz.ndims () == 2 && sz(0) == 1);
 }
 
 /*
 %!assert (isrow ([1, 2, 3]))
 %!assert (isrow ([1; 2; 3]), false)
 %!assert (isrow (1))
 %!assert (isrow ([]), false)
 %!assert (isrow ([1, 2; 3, 4]), false)
@@ -3751,17 +3751,17 @@ Return true if @var{x} is a column vecto
 @seealso{isrow, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return ovl (sz.length () == 2 && sz(1) == 1);
+  return ovl (sz.ndims () == 2 && sz(1) == 1);
 }
 
 /*
 %!assert (iscolumn ([1, 2, 3]), false)
 %!assert (iscolumn ([1; 2; 3]), true)
 %!assert (iscolumn (1), true)
 %!assert (iscolumn ([]), false)
 %!assert (iscolumn ([1, 2; 3, 4]), false)
@@ -3795,17 +3795,17 @@ Return true if @var{a} is a 2-D array.\n
 @seealso{isscalar, isvector, iscell, isstruct, issparse, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return ovl (sz.length () == 2 && sz(0) >= 0 && sz(1) >= 0);
+  return ovl (sz.ndims () == 2 && sz(0) >= 0 && sz(1) >= 0);
 }
 
 /*
 %!assert (ismatrix ([]), true)
 %!assert (ismatrix (1), true)
 %!assert (ismatrix ([1, 2, 3]), true)
 %!assert (ismatrix ([1, 2; 3, 4]), true)
 
@@ -3838,17 +3838,17 @@ Return true if @var{x} is a square matri
 @seealso{isscalar, isvector, ismatrix, size}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return ovl (sz.length () == 2 && sz(0) == sz(1));
+  return ovl (sz.ndims () == 2 && sz(0) == sz(1));
 }
 
 /*
 %!assert (issquare ([]))
 %!assert (issquare (1))
 %!assert (! issquare ([1, 2]))
 %!assert (issquare ([1, 2; 3, 4]))
 %!assert (! issquare ([1, 2; 3, 4; 5, 6]))
@@ -3952,17 +3952,17 @@ fill_matrix (const octave_value_list& ar
       break;
 
     case oct_data_conv::dt_single:
       retval = FloatNDArray (dims, val);
       break;
 
     case oct_data_conv::dt_double:
       {
-        if (val == 1 && dims.length () == 2 && dims(0) == 1)
+        if (val == 1 && dims.ndims () == 2 && dims(0) == 1)
           retval = Range (1.0, 0.0, dims(1));  // packed form
         else
           retval = NDArray (dims, val);
       }
       break;
 
     case oct_data_conv::dt_logical:
       retval = boolNDArray (dims, val);
@@ -5156,19 +5156,19 @@ if fewer than two values are requested.\
         // Even if third arg is not an integer, it must be cast to int
         npoints = arg_3.idx_type_value ();
     }
 
   octave_value arg_1 = args(0);
   octave_value arg_2 = args(1);
 
   dim_vector sz1 = arg_1.dims ();
-  bool isvector1 = sz1.length () == 2 && (sz1(0) == 1 || sz1(1) == 1);
+  bool isvector1 = sz1.ndims () == 2 && (sz1(0) == 1 || sz1(1) == 1);
   dim_vector sz2 = arg_2.dims ();
-  bool isvector2 = sz2.length () == 2 && (sz2(0) == 1 || sz2(1) == 1);
+  bool isvector2 = sz2.ndims () == 2 && (sz2(0) == 1 || sz2(1) == 1);
 
   if (! isvector1 || ! isvector2)
     error ("linspace: A, B must be scalars or vectors");
 
   octave_value retval;
 
   if (arg_1.is_single_type () || arg_2.is_single_type ())
     {
@@ -7200,17 +7200,17 @@ do_accumdim_sum (const idx_vector& idx, 
   else if (idx.extent (n) > n)
     error ("accumdim: index out of range");
 
   dim_vector vals_dim = vals.dims ();
   dim_vector rdv = vals_dim;
 
   if (dim < 0)
     dim = vals.dims ().first_non_singleton ();
-  else if (dim >= rdv.length ())
+  else if (dim >= rdv.ndims ())
     rdv.resize (dim+1, 1);
 
   rdv(dim) = n;
 
   NDT retval (rdv, T ());
 
   if (idx.length () != vals_dim(dim))
     error ("accumdim: dimension mismatch");
@@ -7502,17 +7502,17 @@ do_diff (const octave_value& array, octa
         {
           if (dv(dim) == 1)
             retval = array.resize (dim_vector (0, 0));
           else
             {
               retval = array;
               while (order > 0)
                 {
-                  if (dim == dv.length ())
+                  if (dim == dv.ndims ())
                     {
                       retval = do_diff (array, order, dim - 1);
                       order = 0;
                     }
                   else if (dv(dim) == 1)
                     dim++;
                   else
                     {
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -74,18 +74,18 @@ extern "C"
                              FloatComplex*);
 }
 
 static void
 get_red_dims (const dim_vector& x, const dim_vector& y, int dim,
               dim_vector& z, octave_idx_type& m, octave_idx_type& n,
               octave_idx_type& k)
 {
-  int nd = x.length ();
-  assert (nd == y.length ());
+  int nd = x.ndims ();
+  assert (nd == y.ndims ());
   z = dim_vector::alloc (nd);
   m = 1, n = 1, k = 1;
   for (int i = 0; i < nd; i++)
     {
       if (i < dim)
         {
           z(i) = x(i);
           m *= x(i);
@@ -293,22 +293,22 @@ endfor\n\
   octave_value argx = args(0);
   octave_value argy = args(1);
 
   if (! argx.is_numeric_type () || ! argy.is_numeric_type ())
     error ("blkmm: A and B must be numeric");
 
   const dim_vector dimx = argx.dims ();
   const dim_vector dimy = argy.dims ();
-  int nd = dimx.length ();
+  int nd = dimx.ndims ();
   octave_idx_type m = dimx(0);
   octave_idx_type k = dimx(1);
   octave_idx_type n = dimy(1);
   octave_idx_type np = 1;
-  bool match = dimy(0) == k && nd == dimy.length ();
+  bool match = dimy(0) == k && nd == dimy.ndims ();
   dim_vector dimz = dim_vector::alloc (nd);
   dimz(0) = m;
   dimz(1) = n;
   for (int i = 2; match && i < nd; i++)
     {
       match = match && dimx(i) == dimy(i);
       dimz(i) = dimx(i);
       np *= dimz(i);
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -185,17 +185,17 @@ and 16.15), Dover, 1965.\n\
           // u is array, m is array
           if (u_arg.is_real_type ())
             {
               // u is real array, m is array
               NDArray u = u_arg.xarray_value ("ellipj: U must be a scalar or matrix");
 
               dim_vector sz_u = u.dims ();
 
-              if (sz_u.length () == 2 && sz_m.length () == 2
+              if (sz_u.ndims () == 2 && sz_m.ndims () == 2
                   && sz_u(1) == 1 && sz_m(0) == 1)
                 {
                   // u is real column vector, m is row vector
                   octave_idx_type ur = sz_u(0);
                   octave_idx_type mc = sz_m(1);
                   dim_vector sz_out (ur, mc);
 
                   NDArray sn (sz_out), cn (sz_out), dn (sz_out);
@@ -234,17 +234,17 @@ and 16.15), Dover, 1965.\n\
             }
           else
             {
               // u is complex array, m is array
               ComplexNDArray u = u_arg.xcomplex_array_value ("ellipj: U must be a scalar or matrix");
 
               dim_vector sz_u = u.dims ();
 
-              if (sz_u.length () == 2 && sz_m.length () == 2
+              if (sz_u.ndims () == 2 && sz_m.ndims () == 2
                   && sz_u(1) == 1 && sz_m(0) == 1)
                 {
                   // u is complex column vector, m is row vector
                   octave_idx_type ur = sz_u(0);
                   octave_idx_type mc = sz_m(1);
                   dim_vector sz_out (ur, mc);
 
                   ComplexNDArray sn (sz_out), cn (sz_out), dn (sz_out);
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -67,31 +67,31 @@ do_fft (const octave_value_list &args, c
         }
     }
 
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
         error ("%s: DIM cannot be NaN", fcn);
-      else if (dval < 1 || dval > dims.length ())
+      else if (dval < 1 || dval > dims.ndims ())
         error ("%s: DIM must be a valid dimension along which to perform FFT",
                fcn);
       else
         // to be safe, cast it back to int since dim is an int
         dim = NINT (dval) - 1;
     }
 
-  for (octave_idx_type i = 0; i < dims.length (); i++)
+  for (octave_idx_type i = 0; i < dims.ndims (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (dim < 0)
     {
-      for (octave_idx_type i = 0; i < dims.length (); i++)
+      for (octave_idx_type i = 0; i < dims.ndims (); i++)
         if (dims(i) > 1)
           {
             dim = i;
             break;
           }
 
       // And if the first argument is scalar?
       if (dim < 0)
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -72,17 +72,17 @@ do_fft2 (const octave_value_list &args, 
       if (xisnan (dval))
         error ("%s: number of columns (M) cannot be NaN", fcn);
 
       n_cols = NINTbig (dval);
       if (n_cols < 0)
         error ("%s: number of columns (M) must be greater than zero", fcn);
     }
 
-  for (int i = 0; i < dims.length (); i++)
+  for (int i = 0; i < dims.ndims (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (n_rows < 0)
     n_rows = dims(0);
   else
     dims(0) = n_rows;
 
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -47,31 +47,31 @@ do_fftn (const octave_value_list &args, 
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value retval;
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
 
-  for (int i = 0; i < dims.length (); i++)
+  for (int i = 0; i < dims.ndims (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (nargin > 1)
     {
       Matrix val = args(1).xmatrix_value ("%s: SIZE must be a vector of length dim", fcn);
 
       if (val.rows () > val.columns ())
         val = val.transpose ();
 
-      if (val.columns () != dims.length () || val.rows () != 1)
+      if (val.columns () != dims.ndims () || val.rows () != 1)
         error ("%s: SIZE must be a vector of length dim", fcn);
 
-      for (int i = 0; i < dims.length (); i++)
+      for (int i = 0; i < dims.ndims (); i++)
         {
           if (xisnan (val(i,0)))
             error ("%s: SIZE has invalid NaN entries", fcn);
           else if (NINTbig (val(i,0)) < 0)
             error ("%s: all dimensions in SIZE must be greater than zero", fcn);
           else
             dims(i) = NINTbig(val(i,0));
         }
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -59,36 +59,36 @@ filter (MArray<T>& b, MArray<T>& a, MArr
     a.resize (dim_vector (ab_len, 1), 0.0);
 
   T norm = a (0);
 
   if (norm == static_cast<T> (0.0))
     error ("filter: the first element of A must be nonzero");
 
   dim_vector x_dims = x.dims ();
-  if (dim < 0 || dim > x_dims.length ())
+  if (dim < 0 || dim > x_dims.ndims ())
     error ("filter: DIM must be a valid dimension");
 
   octave_idx_type x_len = x_dims(dim);
 
   dim_vector si_dims = si.dims ();
   octave_idx_type si_len = si_dims(0);
 
   if (si_len != ab_len - 1)
     error ("filter: first dimension of SI must be of length max (length (a), length (b)) - 1");
 
-  if (si_dims.length () != x_dims.length ())
+  if (si_dims.ndims () != x_dims.ndims ())
     error ("filter: dimensionality of SI and X must agree");
 
   for (octave_idx_type i = 1; i < dim; i++)
     {
       if (si_dims(i) != x_dims(i-1))
         error ("filter: dimensionality of SI and X must agree");
     }
-  for (octave_idx_type i = dim+1; i < x_dims.length (); i++)
+  for (octave_idx_type i = dim+1; i < x_dims.ndims (); i++)
     {
       if (si_dims(i) != x_dims(i))
         error ("filter: dimensionality of SI and X must agree");
     }
 
   if (x_len == 0)
     return x;
 
@@ -205,17 +205,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 template <typename T>
 MArray<T>
 filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, int dim = -1)
 {
   dim_vector x_dims = x.dims ();
 
   if (dim < 0)
     dim = x_dims.first_non_singleton ();
-  else if (dim > x_dims.length ())
+  else if (dim > x_dims.ndims ())
     error ("filter: DIM must be a valid dimension");
 
   octave_idx_type a_len = a.numel ();
   octave_idx_type b_len = b.numel ();
 
   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
   dim_vector si_dims = x.dims ();
   for (int i = dim; i > 0; i--)
@@ -336,17 +336,17 @@ H(z) = ---------------------\n\
     print_usage ();
 
   int dim;
   dim_vector x_dims = args(2).dims ();
 
   if (nargin == 5)
     {
       dim = args(4).nint_value () - 1;
-      if (dim < 0 || dim >= x_dims.length ())
+      if (dim < 0 || dim >= x_dims.ndims ())
         error ("filter: DIM must be a valid dimension");
     }
   else
     dim = x_dims.first_non_singleton ();
 
   octave_value_list retval;
 
   const char *a_b_errmsg = "filter: A and B must be vectors";
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -170,17 +170,17 @@ next_power_of_2 (int n)
 opengl_texture
 opengl_texture::create (const octave_value& data)
 {
   opengl_texture retval;
 
   dim_vector dv (data.dims ());
 
   // Expect RGB data
-  if (dv.length () == 3 && dv(2) == 3)
+  if (dv.ndims () == 3 && dv(2) == 3)
     {
       // FIXME: dim_vectors hold octave_idx_type values.
       //        Should we check for dimensions larger than intmax?
       int h, w, tw, th;
       h = dv(0), w = dv(1);
       GLuint id;
       bool ok = true;
 
@@ -2954,17 +2954,17 @@ opengl_renderer::draw_image (const image
 
   glPixelZoom (pix_dx, -pix_dy);
   glRasterPos3d (im_xmin + nor_dx*j0, im_ymin + nor_dy*i0, 0);
 
   // by default this is 4
   glPixelStorei (GL_UNPACK_ALIGNMENT, 1);
 
   // Expect RGB data
-  if (dv.length () == 3 && dv(2) == 3)
+  if (dv.ndims () == 3 && dv(2) == 3)
     {
       if (cdata.is_double_type ())
         {
           const NDArray xcdata = cdata.array_value ();
 
           OCTAVE_LOCAL_BUFFER (GLfloat, a, 3*(j1-j0)*(i1-i0));
 
           for (int i = i0; i < i1; i++)
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -883,17 +883,17 @@ convert_cdata_1 (bool is_scaled, bool is
 
 static octave_value
 convert_cdata (const base_properties& props, const octave_value& cdata,
                bool is_scaled, int cdim)
 {
   dim_vector dv (cdata.dims ());
 
   // TrueColor data doesn't require conversion
-  if (dv.length () == cdim && dv(cdim-1) == 3)
+  if (dv.ndims () == cdim && dv(cdim-1) == 3)
     return cdata;
 
   Matrix cmap (1, 3, 0.0);
   Matrix clim (1, 2, 0.0);
 
   graphics_object go = gh_manager::get_object (props.get___myhandle__ ());
   graphics_object fig = go.get_ancestor ("figure");
 
@@ -1406,27 +1406,27 @@ array_property::validate (const octave_v
     xok = v.is_numeric_type () || v.is_bool_scalar ();
 
   if (xok)
     {
       if (size_constraints.size () == 0)
         return true;
 
       dim_vector vdims = v.dims ();
-      int vlen = vdims.length ();
+      int vlen = vdims.ndims ();
 
       xok = false;
 
       // check dimensional size constraints until a match is found
       for (std::list<dim_vector>::const_iterator it = size_constraints.begin ();
            ! xok && it != size_constraints.end (); ++it)
         {
           dim_vector itdims = (*it);
 
-          if (itdims.length () == vlen)
+          if (itdims.ndims () == vlen)
             {
               xok = true;
 
               for (int i = 0; xok && i < vlen; i++)
                 {
                   if (itdims(i) > 0)
                     {
                       if (itdims(i) != vdims(i))
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -627,17 +627,17 @@ protected:
           ndims--;
         else
           break;
       }
   }
 
   mxArray_matlab (mxClassID id_arg, const dim_vector& dv)
     : mxArray_base (), class_name (0), id (id_arg),
-      ndims (dv.length ()),
+      ndims (dv.ndims ()),
       dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
   {
     for (mwIndex i = 0; i < ndims; i++)
       dims[i] = dv(i);
 
     for (mwIndex i = ndims - 1; i > 1; i--)
       {
         if (dims[i] == 1)
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -392,17 +392,17 @@ public:
   { return checkelem (ra_idx); }
 
   octave_map squeeze (void) const;
 
   octave_map permute (const Array<int>& vec, bool inv = false) const;
 
   dim_vector dims (void) const { return dimensions; }
 
-  int ndims (void) const { return dimensions.length (); }
+  int ndims (void) const { return dimensions.ndims (); }
 
   octave_map transpose (void) const;
 
   octave_map reshape (const dim_vector& dv) const;
 
   void resize (const dim_vector& dv, bool fill = false);
 
   static octave_map
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -180,17 +180,17 @@ moving from one column to next, filling 
   octave_value_list retval;
 
   dim_vector dv = get_dim_vector (args(0), "ind2sub");
 
   try
     {
       idx_vector idx = args(1).index_vector ();
 
-      if (nargout > dv.length ())
+      if (nargout > dv.ndims ())
         dv = dv.redim (nargout);
 
       retval = Array<octave_value> (ind2sub (dv, idx));
     }
   catch (const index_exception& e)
     {
       std::string idx = e.idx ();
       std::string msg = e.details ();
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1550,17 +1550,17 @@ symbol_table::do_workspace_info (void) c
 
           if (val.is_defined ())
             {
               // FIXME: fix size for objects, see kluge in variables.cc
               //dim_vector dv = val.dims ();
               octave_value tmp = val;
               Matrix sz = tmp.size ();
               dim_vector dv = dim_vector::alloc (sz.numel ());
-              for (octave_idx_type i = 0; i < dv.length (); i++)
+              for (octave_idx_type i = 0; i < dv.ndims (); i++)
                 dv(i) = sz(i);
 
               char storage = ' ';
               if (sr.is_global ())
                 storage = 'g';
               else if (sr.is_persistent ())
                 storage = 'p';
               else if (sr.is_automatic ())
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -200,17 +200,17 @@ do_trilu (const std::string& name,
 
   octave_idx_type k = 0;
   if (nargin == 2)
     k = args(1).idx_type_value (true);
 
   octave_value arg = args(0);
 
   dim_vector dims = arg.dims ();
-  if (dims.length () != 2)
+  if (dims.ndims () != 2)
     error ("%s: need a 2-D matrix", name.c_str ());
   else if (k < -dims(0) || k > dims(1))
     error ("%s: requested diagonal out of range", name.c_str ());
 
   octave_value retval;
 
   switch (arg.builtin_type ())
     {
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -33,19 +33,19 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "unwind-prot.h"
 
 static dim_vector
 get_vec_dims (const dim_vector& old_dims, octave_idx_type n)
 {
-  if (old_dims.length () == 2 && old_dims(0) == 1)
+  if (old_dims.ndims () == 2 && old_dims(0) == 1)
     return dim_vector (1, n);
-  else if (old_dims.length () == 2 && old_dims(0) == 0 && old_dims(1) == 0)
+  else if (old_dims.ndims () == 2 && old_dims(0) == 0 && old_dims(1) == 0)
     return dim_vector ();
   else
     return dim_vector (n, 1);
 }
 
 template <typename ArrayType>
 static void
 get_data_and_bytesize (const ArrayType& array,
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1096,17 +1096,17 @@ check_dimensions (octave_idx_type& nr, o
     }
 }
 
 void
 check_dimensions (dim_vector& dim, const char *warnfor)
 {
   bool neg = false;
 
-  for (int i = 0; i < dim.length (); i++)
+  for (int i = 0; i < dim.ndims (); i++)
     {
       if (dim(i) < 0)
         {
           dim(i) = 0;
           neg = true;
         }
     }
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1139,17 +1139,17 @@ std::string
 get_dims_str (const octave_value& val)
 {
   octave_value tmp = val;
 
   Matrix sz = tmp.size ();
 
   dim_vector dv = dim_vector::alloc (sz.numel ());
 
-  for (octave_idx_type i = 0; i < dv.length (); i++)
+  for (octave_idx_type i = 0; i < dv.ndims (); i++)
     dv(i) = sz(i);
 
   return dv.str ();
 }
 
 class
 symbol_info_list
 {
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -257,17 +257,17 @@ octave_base_diag<DMT, MT>::subsasgn (con
   return retval;
 }
 
 template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT, MT>::resize (const dim_vector& dv, bool fill) const
 {
   octave_value retval;
-  if (dv.length () == 2)
+  if (dv.ndims () == 2)
     {
       DMT rm (matrix);
       rm.resize (dv(0), dv(1));
       retval = rm;
     }
   else
     retval = to_dense ().resize (dv, fill);
   return retval;
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -183,22 +183,22 @@ octave_base_int_matrix<T>::convert_to_st
 
   return retval;
 }
 
 template <typename T>
 bool
 octave_base_int_matrix<T>::save_ascii (std::ostream& os)
 {
-  dim_vector d = this->dims ();
+  dim_vector dv = this->dims ();
 
-  os << "# ndims: " << d.length () << "\n";
+  os << "# ndims: " << dv.ndims () << "\n";
 
-  for (int i = 0; i < d.length (); i++)
-    os << " " << d(i);
+  for (int i = 0; i < dv.ndims (); i++)
+    os << " " << dv(i);
 
   os << "\n" << this->matrix;
 
   return true;
 }
 
 template <typename T>
 bool
@@ -229,26 +229,26 @@ octave_base_int_matrix<T>::load_ascii (s
 
   return true;
 }
 
 template <typename T>
 bool
 octave_base_int_matrix<T>::save_binary (std::ostream& os, bool&)
 {
-  dim_vector d = this->dims ();
-  if (d.length () < 1)
+  dim_vector dv = this->dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length ();
+  int32_t tmp = - dv.ndims ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
-  for (int i=0; i < d.length (); i++)
+  for (int i=0; i < dv.ndims (); i++)
     {
-      tmp = d(i);
+      tmp = dv(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   os.write (reinterpret_cast<const char *> (this->matrix.data ()),
             this->byte_size ());
 
   return true;
 }
@@ -332,17 +332,17 @@ octave_base_int_matrix<T>::save_hdf5 (oc
 #if defined (HAVE_HDF5)
 
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   dim_vector dv = this->dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -135,18 +135,18 @@ octave_base_value::full_value (void) con
 {
   err_wrong_type_arg ("full: invalid operation for %s type", type_name ());
 }
 
 Matrix
 octave_base_value::size (void)
 {
   const dim_vector dv = dims ();
-  Matrix mdv (1, dv.length ());
-  for (octave_idx_type i = 0; i < dv.length (); i++)
+  Matrix mdv (1, dv.ndims ());
+  for (octave_idx_type i = 0; i < dv.ndims (); i++)
     mdv(i) = dv(i);
   return mdv;
 }
 
 octave_idx_type
 octave_base_value::numel (const octave_value_list& idx)
 {
   return dims_to_numel (dims (), idx);
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -305,17 +305,17 @@ public:
   octave_idx_type columns (void) const
   {
     const dim_vector dv = dims ();
 
     return dv(1);
   }
 
   virtual int ndims (void) const
-  { return dims ().length (); }
+  { return dims ().ndims (); }
 
   virtual octave_idx_type numel (void) const { return dims ().numel (); }
 
   OCTAVE_DEPRECATED ("use 'numel' instead")
   virtual octave_idx_type capacity (void) const
   { return numel (); }
 
   virtual size_t byte_size (void) const { return 0; }
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -173,24 +173,24 @@ octave_bool_matrix::print_raw (std::ostr
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level ());
 }
 
 bool
 octave_bool_matrix::save_ascii (std::ostream& os)
 {
-  dim_vector d = dims ();
-  if (d.length () > 2)
+  dim_vector dv = dims ();
+  if (dv.ndims () > 2)
     {
       NDArray tmp = array_value ();
-      os << "# ndims: " << d.length () << "\n";
+      os << "# ndims: " << dv.ndims () << "\n";
 
-      for (int i = 0; i < d.length (); i++)
-        os << " " << d(i);
+      for (int i = 0; i < dv.ndims (); i++)
+        os << " " << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -284,26 +284,26 @@ octave_bool_matrix::load_ascii (std::ist
 
   return true;
 }
 
 bool
 octave_bool_matrix::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
 
-  dim_vector d = dims ();
-  if (d.length () < 1)
+  dim_vector dv = dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length ();
+  int32_t tmp = - dv.ndims ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
-  for (int i = 0; i < d.length (); i++)
+  for (int i = 0; i < dv.ndims (); i++)
     {
-      tmp = d(i);
+      tmp = dv(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   boolNDArray m = bool_array_value ();
   bool *mtmp = m.fortran_vec ();
   octave_idx_type nel = m.numel ();
   OCTAVE_LOCAL_BUFFER (char, htmp, nel);
 
@@ -377,17 +377,17 @@ octave_bool_matrix::save_hdf5 (octave_hd
 
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   boolNDArray m = bool_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -204,25 +204,25 @@ SparseComplexMatrix
 octave_sparse_bool_matrix::sparse_complex_matrix_value (bool) const
 {
   return SparseComplexMatrix (this->matrix);
 }
 
 bool
 octave_sparse_bool_matrix::save_binary (std::ostream& os, bool&)
 {
-  dim_vector d = this->dims ();
-  if (d.length () < 1)
+  dim_vector dv = this->dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
-  int nr = d(0);
-  int nc = d(1);
+  int nr = dv(0);
+  int nc = dv(1);
   int nz = nnz ();
 
   int32_t itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp = -2;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   itmp = nr;
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -699,28 +699,28 @@ octave_cell::short_disp (std::ostream& o
   os << (matrix.is_empty () ? "{}" : "...");
 }
 
 #define CELL_ELT_TAG "<cell-element>"
 
 bool
 octave_cell::save_ascii (std::ostream& os)
 {
-  dim_vector d = dims ();
-  if (d.length () > 2)
+  dim_vector dv = dims ();
+  if (dv.ndims () > 2)
     {
-      os << "# ndims: " << d.length () << "\n";
+      os << "# ndims: " << dv.ndims () << "\n";
 
-      for (int i = 0; i < d.length (); i++)
-        os << " " << d(i);
+      for (int i = 0; i < dv.ndims (); i++)
+        os << " " << dv(i);
       os << "\n";
 
       Cell tmp = cell_value ();
 
-      for (octave_idx_type i = 0; i < d.numel (); i++)
+      for (octave_idx_type i = 0; i < dv.numel (); i++)
         {
           octave_value o_val = tmp.elem (i);
 
           // Recurse to print sub-value.
           bool b = save_text_data (os, o_val, CELL_ELT_TAG, false, 0);
 
           if (! b)
             return ! os.fail ();
@@ -852,32 +852,32 @@ octave_cell::load_ascii (std::istream& i
     panic_impossible ();
 
   return true;
 }
 
 bool
 octave_cell::save_binary (std::ostream& os, bool& save_as_floats)
 {
-  dim_vector d = dims ();
-  if (d.length () < 1)
+  dim_vector dv = dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Use negative value for ndims
-  int32_t di = - d.length ();
+  int32_t di = - dv.ndims ();
   os.write (reinterpret_cast<char *> (&di), 4);
-  for (int i = 0; i < d.length (); i++)
+  for (int i = 0; i < dv.ndims (); i++)
     {
-      di = d(i);
+      di = dv(i);
       os.write (reinterpret_cast<char *> (&di), 4);
     }
 
   Cell tmp = cell_value ();
 
-  for (octave_idx_type i = 0; i < d.numel (); i++)
+  for (octave_idx_type i = 0; i < dv.numel (); i++)
     {
       octave_value o_val = tmp.elem (i);
 
       // Recurse to print sub-value.
       bool b = save_binary_data (os, o_val, CELL_ELT_TAG, "", 0,
                                  save_as_floats);
 
       if (! b)
@@ -967,17 +967,17 @@ octave_cell::save_hdf5 (octave_hdf5_id l
 {
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
-  hsize_t rank = dv.length ();
+  hsize_t rank = dv.ndims ();
   hid_t space_hid, data_hid, size_hid;
   space_hid = data_hid = size_hid = -1;
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Gcreate (loc_id, name, octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
@@ -1323,24 +1323,24 @@ c(2,1,:)(:)\n\
 
   octave_idx_type num_fields = m.nfields ();
 
   // The resulting dim_vector should have dimensions:
   // [numel(fields) size(struct)]
   // except if the struct is a column vector.
 
   dim_vector result_dv;
-  if (m_dv(m_dv.length () - 1) == 1)
-    result_dv.resize (m_dv.length ());
+  if (m_dv(m_dv.ndims () - 1) == 1)
+    result_dv.resize (m_dv.ndims ());
   else
-    result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
+    result_dv.resize (m_dv.ndims () + 1); // Add 1 for the fields.
 
   result_dv(0) = num_fields;
 
-  for (int i = 1; i < result_dv.length (); i++)
+  for (int i = 1; i < result_dv.ndims (); i++)
     result_dv(i) = m_dv(i-1);
 
   NoAlias<Cell> c (result_dv);
 
   octave_idx_type n_elts = m.numel ();
 
   // Fill c in one sweep.  Note that thanks to octave_map structure,
   // we don't need a key lookup at all.
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -303,17 +303,17 @@ octave_class::size (void)
         error ("@%s/size: invalid return value", class_name ().c_str ());
 
       retval = lv(0).matrix_value ();
     }
   else
     {
       dim_vector dv = dims ();
 
-      int nd = dv.length ();
+      int nd = dv.ndims ();
 
       retval.resize (1, nd);
 
       for (int i = 0; i < nd; i++)
         retval(i) = dv(i);
     }
 
   return retval;
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -310,25 +310,25 @@ octave_complex_matrix::diag (octave_idx_
   ComplexMatrix mat (matrix);
 
   return mat.diag (m, n);
 }
 
 bool
 octave_complex_matrix::save_ascii (std::ostream& os)
 {
-  dim_vector d = dims ();
-  if (d.length () > 2)
+  dim_vector dv = dims ();
+  if (dv.ndims () > 2)
     {
       ComplexNDArray tmp = complex_array_value ();
 
-      os << "# ndims: " << d.length () << "\n";
+      os << "# ndims: " << dv.ndims () << "\n";
 
-      for (int i = 0; i < d.length (); i++)
-        os << " " << d(i);
+      for (int i = 0; i < dv.ndims (); i++)
+        os << " " << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -405,52 +405,52 @@ octave_complex_matrix::load_ascii (std::
     panic_impossible ();
 
   return true;
 }
 
 bool
 octave_complex_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
-  dim_vector d = dims ();
-  if (d.length () < 1)
+  dim_vector dv = dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length ();
+  int32_t tmp = - dv.ndims ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
-  for (int i = 0; i < d.length (); i++)
+  for (int i = 0; i < dv.ndims (); i++)
     {
-      tmp = d(i);
+      tmp = dv(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   ComplexNDArray m = complex_array_value ();
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         st = LS_FLOAT;
     }
-  else if (d.numel () > 4096) // FIXME: make this configurable.
+  else if (dv.numel () > 4096) // FIXME: make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
 
   const Complex *mtmp = m.data ();
   write_doubles (os, reinterpret_cast<const double *> (mtmp), st,
-                 2 * d.numel ());
+                 2 * dv.numel ());
 
   return true;
 }
 
 bool
 octave_complex_matrix::load_binary (std::istream& is, bool swap,
                                     oct_mach_info::float_format fmt)
 {
@@ -531,17 +531,17 @@ octave_complex_matrix::save_hdf5 (octave
 {
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   hid_t space_hid, data_hid, type_hid;
   space_hid = data_hid = type_hid = -1;
   bool retval = true;
   ComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -218,27 +218,27 @@ octave_sparse_complex_matrix::sparse_boo
                || real (matrix).any_element_not_one_or_zero ()))
     warn_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
 
 bool
 octave_sparse_complex_matrix::save_binary (std::ostream& os,
-                                           bool&save_as_floats)
+                                           bool& save_as_floats)
 {
-  dim_vector d = this->dims ();
-  if (d.length () < 1)
+  dim_vector dv = this->dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
-  int nr = d(0);
-  int nc = d(1);
+  int nr = dv(0);
+  int nc = dv(1);
   int nz = nnz ();
 
   int32_t itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp = -2;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   itmp = nr;
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -284,25 +284,25 @@ octave_float_complex_matrix::diag (octav
   FloatComplexMatrix mat (matrix);
 
   return mat.diag (m, n);
 }
 
 bool
 octave_float_complex_matrix::save_ascii (std::ostream& os)
 {
-  dim_vector d = dims ();
-  if (d.length () > 2)
+  dim_vector dv = dims ();
+  if (dv.ndims () > 2)
     {
       FloatComplexNDArray tmp = complex_array_value ();
 
-      os << "# ndims: " << d.length () << "\n";
+      os << "# ndims: " << dv.ndims () << "\n";
 
-      for (int i = 0; i < d.length (); i++)
-        os << " " << d(i);
+      for (int i = 0; i < dv.ndims (); i++)
+        os << " " << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -379,40 +379,41 @@ octave_float_complex_matrix::load_ascii 
     panic_impossible ();
 
   return true;
 }
 
 bool
 octave_float_complex_matrix::save_binary (std::ostream& os, bool&)
 {
-  dim_vector d = dims ();
-  if (d.length () < 1)
+  dim_vector dv = dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length ();
+  int32_t tmp = - dv.ndims ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
-  for (int i = 0; i < d.length (); i++)
+  for (int i = 0; i < dv.ndims (); i++)
     {
-      tmp = d(i);
+      tmp = dv(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   FloatComplexNDArray m = complex_array_value ();
   save_type st = LS_FLOAT;
-  if (d.numel () > 4096) // FIXME: make this configurable.
+  if (dv.numel () > 4096) // FIXME: make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const FloatComplex *mtmp = m.data ();
-  write_floats (os, reinterpret_cast<const float *> (mtmp), st, 2 * d.numel ());
+  write_floats (os, reinterpret_cast<const float *> (mtmp), st,
+                2 * dv.numel ());
 
   return true;
 }
 
 bool
 octave_float_complex_matrix::load_binary (std::istream& is, bool swap,
                                           oct_mach_info::float_format fmt)
 {
@@ -494,17 +495,17 @@ octave_float_complex_matrix::save_hdf5 (
 
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   hid_t space_hid, data_hid, type_hid;
   space_hid = data_hid = type_hid = -1;
   FloatComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -305,26 +305,26 @@ octave_float_matrix::convert_to_str_inte
   retval = octave_value (chm, type);
 
   return retval;
 }
 
 bool
 octave_float_matrix::save_ascii (std::ostream& os)
 {
-  dim_vector d = dims ();
+  dim_vector dv = dims ();
 
-  if (d.length () > 2)
+  if (dv.ndims () > 2)
     {
       FloatNDArray tmp = float_array_value ();
 
-      os << "# ndims: " << d.length () << "\n";
+      os << "# ndims: " << dv.ndims () << "\n";
 
-      for (int i=0; i < d.length (); i++)
-        os << " " << d(i);
+      for (int i=0; i < dv.ndims (); i++)
+        os << " " << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -401,41 +401,40 @@ octave_float_matrix::load_ascii (std::is
     panic_impossible ();
 
   return true;
 }
 
 bool
 octave_float_matrix::save_binary (std::ostream& os, bool&)
 {
-
-  dim_vector d = dims ();
-  if (d.length () < 1)
+  dim_vector dv = dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length ();
+  int32_t tmp = - dv.ndims ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
-  for (int i = 0; i < d.length (); i++)
+  for (int i = 0; i < dv.ndims (); i++)
     {
-      tmp = d(i);
+      tmp = dv(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   FloatNDArray m = float_array_value ();
   save_type st = LS_FLOAT;
-  if (d.numel () > 8192) // FIXME: make this configurable.
+  if (dv.numel () > 8192) // FIXME: make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const float *mtmp = m.data ();
-  write_floats (os, mtmp, st, d.numel ());
+  write_floats (os, mtmp, st, dv.numel ());
 
   return true;
 }
 
 bool
 octave_float_matrix::load_binary (std::istream& is, bool swap,
                                   oct_mach_info::float_format fmt)
 {
@@ -516,17 +515,17 @@ octave_float_matrix::save_hdf5 (octave_h
 
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   FloatNDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -140,68 +140,68 @@ public:
 
   float float_scalar_value (bool = false) const { return float_value (); }
 
   Matrix
   matrix_value (bool = false) const
   {
     Matrix retval;
     dim_vector dv = dims ();
-    if (dv.length () > 2)
+    if (dv.ndims () > 2)
       error ("invalid conversion of %s to Matrix", type_name ().c_str ());
 
     retval = Matrix (dv(0), dv(1));
     double *vec = retval.fortran_vec ();
     octave_idx_type nel = matrix.numel ();
     for (octave_idx_type i = 0; i < nel; i++)
       vec[i] = matrix(i).double_value ();
 
     return retval;
   }
 
   FloatMatrix
   float_matrix_value (bool = false) const
   {
     FloatMatrix retval;
     dim_vector dv = dims ();
-    if (dv.length () > 2)
+    if (dv.ndims () > 2)
       error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
 
     retval = FloatMatrix (dv(0), dv(1));
     float *vec = retval.fortran_vec ();
     octave_idx_type nel = matrix.numel ();
     for (octave_idx_type i = 0; i < nel; i++)
       vec[i] = matrix(i).float_value ();
 
     return retval;
   }
 
   ComplexMatrix
   complex_matrix_value (bool = false) const
   {
     ComplexMatrix retval;
     dim_vector dv = dims ();
-    if (dv.length () > 2)
+    if (dv.ndims () > 2)
       error ("invalid conversion of %s to Matrix", type_name ().c_str ());
 
     retval = ComplexMatrix (dv(0), dv(1));
     Complex *vec = retval.fortran_vec ();
     octave_idx_type nel = matrix.numel ();
     for (octave_idx_type i = 0; i < nel; i++)
       vec[i] = Complex (matrix(i).double_value ());
 
     return retval;
   }
 
   FloatComplexMatrix
   float_complex_matrix_value (bool = false) const
   {
     FloatComplexMatrix retval;
     dim_vector dv = dims ();
-    if (dv.length () > 2)
+    if (dv.ndims () > 2)
       error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
 
     retval = FloatComplexMatrix (dv(0), dv(1));
     FloatComplex *vec = retval.fortran_vec ();
     octave_idx_type nel = matrix.numel ();
     for (octave_idx_type i = 0; i < nel; i++)
       vec[i] = FloatComplex (matrix(i).float_value ());
 
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -932,17 +932,17 @@ compute_array_dimensions (JNIEnv *jni_en
 
   dim_vector dv (1, 1);
   int idx = 0;
 
   jobj.detach ();
   while (jcls && jni_env->CallBooleanMethod (jcls, isArray_ID))
     {
       int len = (jobj ? jni_env->GetArrayLength (jobj) : 0);
-      if (idx >= dv.length ())
+      if (idx >= dv.ndims ())
         dv.resize (idx+1);
       dv(idx) = len;
       jcls = reinterpret_cast<jclass> (jni_env->CallObjectMethod (jcls, getComponentType_ID));
       jobj = (len > 0 ? reinterpret_cast<jobjectArray> (jni_env->GetObjectArrayElement (jobj, 0)) : 0);
       idx++;
     }
 
   restore_fpu_state ();
@@ -1214,17 +1214,17 @@ box (JNIEnv *jni_env, void *jobj_arg, vo
           if (jni_env->IsInstanceOf (jobj, cls))
             {
               jmethodID mID = jni_env->GetMethodID (cls, "getDims", "()[I");
               jintArray_ref iv (jni_env, reinterpret_cast<jintArray> (jni_env->CallObjectMethod (jobj, mID)));
               jint *iv_data = jni_env->GetIntArrayElements (jintArray (iv), 0);
               dim_vector dims;
               dims.resize (jni_env->GetArrayLength (jintArray (iv)));
 
-              for (int i = 0; i < dims.length (); i++)
+              for (int i = 0; i < dims.ndims (); i++)
                 dims(i) = iv_data[i];
 
               jni_env->ReleaseIntArrayElements (jintArray (iv), iv_data, 0);
               mID = jni_env->GetMethodID (cls, "getClassName", "()Ljava/lang/String;");
               jstring_ref js (jni_env, reinterpret_cast<jstring> (jni_env->CallObjectMethod (jobj, mID)));
 
               std::string s = jstring_to_string (jni_env, js);
 
@@ -1541,20 +1541,20 @@ unbox (JNIEnv *jni_env, const octave_val
       jobj = dv;
       jcls = jni_env->GetObjectClass (jobj);
     }
   else if (Vjava_matrix_autoconversion
            && (val.is_matrix_type () || val.is_range ()) && val.is_real_type ())
     {
       jclass_ref mcls (jni_env, find_octave_class (jni_env, "org/octave/Matrix"));
       dim_vector dims = val.dims ();
-      jintArray_ref iv (jni_env, jni_env->NewIntArray (dims.length ()));
+      jintArray_ref iv (jni_env, jni_env->NewIntArray (dims.ndims ()));
       jint *iv_data = jni_env->GetIntArrayElements (jintArray (iv), 0);
 
-      for (int i = 0; i < dims.length (); i++)
+      for (int i = 0; i < dims.ndims (); i++)
         iv_data[i] = dims(i);
 
       jni_env->ReleaseIntArrayElements (jintArray (iv), iv_data, 0);
 
       if (val.is_double_type ())
         {
           NDArray m = val.array_value ();
           jdoubleArray_ref dv (jni_env, jni_env->NewDoubleArray (m.numel ()));
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -100,31 +100,31 @@ octave_lazy_index::squeeze (void) const
                      index.extent (0));
 }
 
 octave_value
 octave_lazy_index::sort (octave_idx_type dim, sortmode mode) const
 {
   const dim_vector odims = index.orig_dimensions ();
   // index_vector can employ a more efficient sorting algorithm.
-  if (mode == ASCENDING && odims.length () == 2
+  if (mode == ASCENDING && odims.ndims () == 2
       && (dim >= 0 && dim <= 1) && odims(1-dim) == 1)
     return index_vector ().sorted ();
   else
     return idx_vector (index.as_array ().sort (dim, mode),
                        index.extent (0));
 }
 
 octave_value
 octave_lazy_index::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                          sortmode mode) const
 {
   const dim_vector odims = index.orig_dimensions ();
   // index_vector can employ a more efficient sorting algorithm.
-  if (mode == ASCENDING && odims.length () == 2
+  if (mode == ASCENDING && odims.ndims () == 2
       && (dim >= 0 && dim <= 1) && odims(1-dim) == 1)
     return index_vector ().sorted (sidx);
   else
     return idx_vector (index.as_array ().sort (sidx, dim, mode),
                        index.extent (0));
 }
 
 sortmode
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -407,26 +407,26 @@ octave_matrix::convert_to_str_internal (
   retval = octave_value (chm, type);
 
   return retval;
 }
 
 bool
 octave_matrix::save_ascii (std::ostream& os)
 {
-  dim_vector d = dims ();
+  dim_vector dv = dims ();
 
-  if (d.length () > 2)
+  if (dv.ndims () > 2)
     {
       NDArray tmp = array_value ();
 
-      os << "# ndims: " << d.length () << "\n";
+      os << "# ndims: " << dv.ndims () << "\n";
 
-      for (int i=0; i < d.length (); i++)
-        os << " " << d(i);
+      for (int i=0; i < dv.ndims (); i++)
+        os << " " << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
@@ -504,50 +504,50 @@ octave_matrix::load_ascii (std::istream&
 
   return true;
 }
 
 bool
 octave_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
-  dim_vector d = dims ();
-  if (d.length () < 1)
+  dim_vector dv = dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length ();
+  int32_t tmp = - dv.ndims ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
-  for (int i = 0; i < d.length (); i++)
+  for (int i = 0; i < dv.ndims (); i++)
     {
-      tmp = d(i);
+      tmp = dv(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   NDArray m = array_value ();
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         st = LS_FLOAT;
     }
-  else if (d.numel () > 8192) // FIXME: make this configurable.
+  else if (dv.numel () > 8192) // FIXME: make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const double *mtmp = m.data ();
-  write_doubles (os, mtmp, st, d.numel ());
+  write_doubles (os, mtmp, st, dv.numel ());
 
   return true;
 }
 
 bool
 octave_matrix::load_binary (std::istream& is, bool swap,
                             oct_mach_info::float_format fmt)
 {
@@ -628,17 +628,17 @@ octave_matrix::save_hdf5 (octave_hdf5_id
 
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   NDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -242,27 +242,27 @@ octave_sparse_matrix::convert_to_str_int
 
       retval = octave_value (chm, type);
     }
 
   return retval;
 }
 
 bool
-octave_sparse_matrix::save_binary (std::ostream& os, bool&save_as_floats)
+octave_sparse_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
-  dim_vector d = this->dims ();
-  if (d.length () < 1)
+  dim_vector dv = this->dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
-  int nr = d(0);
-  int nc = d(1);
+  int nr = dv(0);
+  int nc = dv(1);
   int nz = nnz ();
 
   int32_t itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp = -2;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   itmp = nr;
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -278,25 +278,25 @@ octave_char_matrix_str::short_disp (std:
 
       os << (tmp.length () > max_len ? tmp.substr (0, 100) : tmp);
     }
 }
 
 bool
 octave_char_matrix_str::save_ascii (std::ostream& os)
 {
-  dim_vector d = dims ();
-  if (d.length () > 2)
+  dim_vector dv = dims ();
+  if (dv.ndims () > 2)
     {
       charNDArray tmp = char_array_value ();
-      os << "# ndims: " << d.length () << "\n";
-      for (int i=0; i < d.length (); i++)
-        os << " " << d(i);
+      os << "# ndims: " << dv.ndims () << "\n";
+      for (int i=0; i < dv.ndims (); i++)
+        os << " " << dv(i);
       os << "\n";
-      os.write (tmp.fortran_vec (), d.numel ());
+      os.write (tmp.fortran_vec (), dv.numel ());
       os << "\n";
     }
   else
     {
       // Keep this case, rather than use generic code above for
       // backward compatibility.  Makes load_ascii much more complex!!
       charMatrix chm = char_matrix_value ();
       octave_idx_type elements = chm.rows ();
@@ -430,31 +430,31 @@ octave_char_matrix_str::load_ascii (std:
 
   return true;
 }
 
 bool
 octave_char_matrix_str::save_binary (std::ostream& os,
                                      bool& /* save_as_floats */)
 {
-  dim_vector d = dims ();
-  if (d.length () < 1)
+  dim_vector dv = dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  int32_t tmp = - d.length ();
+  int32_t tmp = - dv.ndims ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
-  for (int i=0; i < d.length (); i++)
+  for (int i=0; i < dv.ndims (); i++)
     {
-      tmp = d(i);
+      tmp = dv(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   charNDArray m = char_array_value ();
-  os.write (m.fortran_vec (), d.numel ());
+  os.write (m.fortran_vec (), dv.numel ());
   return true;
 }
 
 bool
 octave_char_matrix_str::load_binary (std::istream& is, bool swap,
                                      oct_mach_info::float_format /* fmt */)
 {
   int32_t elements;
@@ -535,17 +535,17 @@ octave_char_matrix_str::save_hdf5 (octav
 
 #if defined (HAVE_HDF5)
 
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   charNDArray m = char_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -643,32 +643,32 @@ octave_struct::print_name_tag (std::ostr
     }
 
   return retval;
 }
 
 static bool
 scalar (const dim_vector& dims)
 {
-  return dims.length () == 2 && dims(0) == 1 && dims(1) == 1;
+  return dims.ndims () == 2 && dims(0) == 1 && dims(1) == 1;
 }
 
 
 bool
 octave_struct::save_ascii (std::ostream& os)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
   const dim_vector dv = dims ();
 
-  os << "# ndims: " << dv.length () << "\n";
-
-  for (int i = 0; i < dv.length (); i++)
+  os << "# ndims: " << dv.ndims () << "\n";
+
+  for (int i = 0; i < dv.ndims (); i++)
     os << " " << dv(i);
   os << "\n";
 
   os << "# length: " << nf << "\n";
 
   // Iterating over the list of keys will preserve the order of the
   // fields.
   string_vector keys = m.fieldnames ();
@@ -759,26 +759,26 @@ octave_struct::load_ascii (std::istream&
 
 bool
 octave_struct::save_binary (std::ostream& os, bool& save_as_floats)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
-  dim_vector d = dims ();
-  if (d.length () < 1)
+  dim_vector dv = dims ();
+  if (dv.ndims () < 1)
     return false;
 
   // Use negative value for ndims
-  int32_t di = - d.length ();
+  int32_t di = - dv.ndims ();
   os.write (reinterpret_cast<char *> (&di), 4);
-  for (int i = 0; i < d.length (); i++)
+  for (int i = 0; i < dv.ndims (); i++)
     {
-      di = d(i);
+      di = dv(i);
       os.write (reinterpret_cast<char *> (&di), 4);
     }
 
   int32_t len = nf;
   os.write (reinterpret_cast<char *> (&len), 4);
 
   // Iterating over the list of keys will preserve the order of the
   // fields.
@@ -1321,19 +1321,19 @@ bool
 octave_scalar_struct::save_ascii (std::ostream& os)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
   const dim_vector dv = dims ();
 
-  os << "# ndims: " << dv.length () << "\n";
-
-  for (int i = 0; i < dv.length (); i++)
+  os << "# ndims: " << dv.ndims () << "\n";
+
+  for (int i = 0; i < dv.ndims (); i++)
     os << " " << dv(i);
   os << "\n";
 
   os << "# length: " << nf << "\n";
 
   // Iterating over the list of keys will preserve the order of the
   // fields.
   string_vector keys = m.fieldnames ();
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1378,17 +1378,17 @@ octave_value::assign (assign_op op, cons
 
 octave_idx_type
 octave_value::length (void) const
 {
   octave_idx_type retval = 0;
 
   const dim_vector dv = dims ();
 
-  for (int i = 0; i < dv.length (); i++)
+  for (int i = 0; i < dv.ndims (); i++)
     {
       if (dv(i) == 0)
         {
           retval = 0;
           break;
         }
 
       if (dv(i) > retval)
@@ -1493,17 +1493,17 @@ octave_value::list_value (void) const
 static dim_vector
 make_vector_dims (const dim_vector& dv, bool force_vector_conversion,
                   const std::string& my_type, const std::string& wanted_type)
 {
   dim_vector retval (dv);
   retval.chop_trailing_singletons ();
   octave_idx_type nel = dv.numel ();
 
-  if (retval.length () > 2 || (retval(0) != 1 && retval(1) != 1))
+  if (retval.ndims () > 2 || (retval(0) != 1 && retval(1) != 1))
     {
       if (! force_vector_conversion)
         warn_implicit_conversion ("Octave:array-to-vector",
                                   my_type.c_str (), wanted_type.c_str ());
       retval = dim_vector (nel, 1);
     }
 
   return retval;
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -165,17 +165,17 @@ Example:\n\
 
       octave_value meth = symbol_table::find_method ("end", class_name);
 
       if (meth.is_defined ())
         return feval (meth.function_value (), args, 1);
     }
 
   dim_vector dv = indexed_object->dims ();
-  int ndims = dv.length ();
+  int ndims = dv.ndims ();
 
   if (num_indices < ndims)
     {
       for (int i = num_indices; i < ndims; i++)
         dv(num_indices-1) *= dv(i);
 
       if (num_indices == 1)
         {
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -629,18 +629,18 @@ tm_const::init (const tree_matrix& tm)
       all_mt = false;
 
       if (first_elem)
         {
           first_elem = false;
 
           dv = this_elt_dv;
         }
-      else if (all_str && dv.length () == 2
-               && this_elt_dv.length () == 2)
+      else if (all_str && dv.ndims () == 2
+               && this_elt_dv.ndims () == 2)
         {
           // FIXME: this is Octave's specialty. Character matrices allow
           // rows of unequal length.
           if (this_elt_nc > cols ())
             dv(1) = this_elt_nc;
           dv(0) += this_elt_nr;
         }
       else if ((! any_class) && (! dv.hvcat (this_elt_dv, 0)))
@@ -1059,17 +1059,17 @@ tree_matrix::rvalue1 (int)
 
               if (! all_empty_p)
                 ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
             }
 
           // Now, extract the values from the individual elements and
           // insert them in the result matrix.
 
-          int dv_len = dv.length ();
+          int dv_len = dv.ndims ();
           octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
           Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
 
           for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
             {
               octave_quit ();
 
               tm_row_const row = *p;
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 bool
 index_in_bounds (const Array<octave_idx_type>& ra_idx,
                  const dim_vector& dimensions)
 {
   bool retval = true;
 
   int n = ra_idx.numel ();
 
-  if (n == dimensions.length ())
+  if (n == dimensions.ndims ())
     {
       for (int i = 0; i < n; i++)
         {
           if (ra_idx(i) < 0 || ra_idx(i) >= dimensions(i))
             {
               retval = false;
               break;
             }
@@ -57,17 +57,17 @@ index_in_bounds (const Array<octave_idx_
 
 void
 increment_index (Array<octave_idx_type>& ra_idx, const dim_vector& dimensions,
                  int start_dimension)
 {
   ra_idx(start_dimension)++;
 
   int n = ra_idx.numel () - 1;
-  int nda = dimensions.length ();
+  int nda = dimensions.ndims ();
 
   for (int i = start_dimension; i < n; i++)
     {
       if (ra_idx(i) < (i < nda ? dimensions(i) : 1))
         break;
       else
         {
           ra_idx(i) = 0;
@@ -111,22 +111,20 @@ num_ones (const Array<octave_idx_type>& 
   return retval;
 }
 
 bool
 is_scalar (const dim_vector& dim)
 {
   bool retval = true;
 
-  int n = dim.length ();
+  int n = dim.ndims ();
 
   if (n == 0)
-    {
-      retval = false;
-    }
+    retval = false;
   else
     {
       for (int i = 0; i < n; i++)
         {
           if (dim(i) != 1)
             {
               retval = false;
 
@@ -136,17 +134,17 @@ is_scalar (const dim_vector& dim)
     }
   return retval;
 }
 
 bool
 is_vector (const dim_vector& dim)
 {
   int m = 0;
-  int n = dim.length ();
+  int n = dim.ndims ();
 
   if (n == 0)
     m = 2;
   else
     {
       for (int i = 0; i < n; i++)
         if (dim(i) > 1)
           m++;
@@ -260,33 +258,33 @@ conv_to_array (const idx_vector *tmp, co
 
 dim_vector
 freeze (Array<idx_vector>& ra_idx, const dim_vector& dimensions, int resize_ok)
 {
   dim_vector retval;
 
   int n = ra_idx.numel ();
 
-  assert (n == dimensions.length ());
+  assert (n == dimensions.ndims ());
 
   retval.resize (n);
 
   static const char *tag[3] = { "row", "column", 0 };
 
   for (int i = 0; i < n; i++)
     retval(i) = ra_idx(i).freeze (dimensions(i), tag[i < 2 ? i : 2],
                                   resize_ok);
 
   return retval;
 }
 
 bool
 vector_equivalent (const dim_vector& dv)
 {
-  int n = dv.length ();
+  int n = dv.ndims ();
 
   bool found_first = false;
 
   for (int i = 0; i < n; i++)
     {
       if (dv(i) != 1)
         {
           if (! found_first)
@@ -340,17 +338,17 @@ any_orig_empty (const Array<idx_vector>&
 bool
 all_colon_equiv (const Array<idx_vector>& ra_idx,
                  const dim_vector& frozen_lengths)
 {
   bool retval = true;
 
   octave_idx_type idx_n = ra_idx.numel ();
 
-  int n = frozen_lengths.length ();
+  int n = frozen_lengths.ndims ();
 
   assert (idx_n == n);
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (! ra_idx(i).is_colon_equiv (frozen_lengths(i)))
         {
           retval = false;
@@ -392,17 +390,17 @@ get_elt_idx (const Array<idx_vector>& ra
   return retval;
 }
 
 Array<octave_idx_type>
 get_ra_idx (octave_idx_type idx, const dim_vector& dims)
 {
   Array<octave_idx_type> retval;
 
-  int n_dims = dims.length ();
+  int n_dims = dims.ndims ();
 
   retval.resize (dim_vector (n_dims, 1));
 
   for (int i = 0; i < n_dims; i++)
     retval(i) = 0;
 
   assert (idx > 0 || idx < dims.numel ());
 
@@ -425,17 +423,17 @@ get_ra_idx (octave_idx_type idx, const d
 
   return retval;
 }
 
 dim_vector
 zero_dims_inquire (const Array<idx_vector>& ia, const dim_vector& rhdv)
 {
   int ial = ia.numel ();
-  int rhdvl = rhdv.length ();
+  int rhdvl = rhdv.ndims ();
   dim_vector rdv = dim_vector::alloc (ial);
   bool *scalar = new bool [ial];
   bool *colon = new bool [ial];
   // Mark scalars and colons, count non-scalar indices.
   int nonsc = 0;
   bool all_colons = true;
   for (int i = 0; i < ial; i++)
     {
@@ -463,17 +461,17 @@ zero_dims_inquire (const Array<idx_vecto
             rdv(i) = rhdv(j);
           j++;
         }
     }
   else
     {
       dim_vector rhdv0 = rhdv;
       rhdv0.chop_all_singletons ();
-      int rhdv0l = rhdv0.length ();
+      int rhdv0l = rhdv0.ndims ();
       for (int i = 0, j = 0; i < ial; i++)
         {
           if (scalar[i]) continue;
           if (colon[i])
             rdv(i) = (j < rhdv0l) ? rhdv0(j++) : 1;
         }
     }
 
@@ -485,22 +483,22 @@ zero_dims_inquire (const Array<idx_vecto
 
 dim_vector
 zero_dims_inquire (const idx_vector& i, const idx_vector& j,
                    const dim_vector& rhdv)
 {
   bool icol = i.is_colon ();
   bool jcol = j.is_colon ();
   dim_vector rdv;
-  if (icol && jcol && rhdv.length () == 2)
+  if (icol && jcol && rhdv.ndims () == 2)
     {
       rdv(0) = rhdv(0);
       rdv(1) = rhdv(1);
     }
-  else if (rhdv.length () == 2
+  else if (rhdv.ndims () == 2
            && ! i.is_scalar () && ! j.is_scalar ())
     {
       rdv(0) = icol ? rhdv(0) : i.extent (0);
       rdv(1) = jcol ? rhdv(1) : j.extent (0);
     }
   else
     {
       dim_vector rhdv0 = rhdv;
@@ -616,17 +614,17 @@ sub2ind (const dim_vector& dv, const Arr
 
   return retval;
 }
 
 Array<idx_vector>
 ind2sub (const dim_vector& dv, const idx_vector& idx)
 {
   octave_idx_type len = idx.length (0);
-  octave_idx_type n = dv.length ();
+  octave_idx_type n = dv.ndims ();
   Array<idx_vector> retval (dim_vector (n, 1));
   octave_idx_type numel = dv.numel ();
 
   if (idx.extent (numel) > numel)
     (*current_liboctave_error_handler) ("ind2sub: index out of range");
 
   if (idx.is_scalar ())
     {
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -313,17 +313,17 @@ class rec_permute_helper
   int top;
   octave_idx_type *dim;
   octave_idx_type *stride;
   bool use_blk;
 
 public:
   rec_permute_helper (const dim_vector& dv, const Array<octave_idx_type>& perm)
 
-    : n (dv.length ()), top (0), dim (new octave_idx_type [2*n]),
+    : n (dv.ndims ()), top (0), dim (new octave_idx_type [2*n]),
       stride (dim + n), use_blk (false)
   {
     assert (n == perm.numel ());
 
     // Get cumulative dimensions.
     OCTAVE_LOCAL_BUFFER (octave_idx_type, cdim, n+1);
     cdim[0] = 1;
     for (int i = 1; i < n+1; i++) cdim[i] = cdim[i-1] * dv(i-1);
@@ -451,17 +451,17 @@ Array<T>::permute (const Array<octave_id
   Array<T> retval;
 
   Array<octave_idx_type> perm_vec = perm_vec_arg;
 
   dim_vector dv = dims ();
 
   int perm_vec_len = perm_vec_arg.numel ();
 
-  if (perm_vec_len < dv.length ())
+  if (perm_vec_len < dv.ndims ())
     (*current_liboctave_error_handler)
       ("%s: invalid permutation vector", inv ? "ipermute" : "permute");
 
   dim_vector dv_new = dim_vector::alloc (perm_vec_len);
 
   // Append singleton dimensions as needed.
   dv.resize (perm_vec_len, 1);
 
@@ -530,17 +530,17 @@ class rec_index_helper
   octave_idx_type *cdim;
   idx_vector *idx;
 
 public:
   rec_index_helper (const dim_vector& dv, const Array<idx_vector>& ia)
     : n (ia.numel ()), top (0), dim (new octave_idx_type [2*n]),
       cdim (dim + n), idx (new idx_vector [n])
   {
-    assert (n > 0 && (dv.length () == std::max (n, 2)));
+    assert (n > 0 && (dv.ndims () == std::max (n, 2)));
 
     dim[0] = dv(0);
     cdim[0] = 1;
     idx[0] = ia(0);
 
     for (int i = 1; i < n; i++)
       {
         // Try reduction...
@@ -646,18 +646,18 @@ class rec_resize_helper
   octave_idx_type *sext;
   octave_idx_type *dext;
   int n;
 
 public:
   rec_resize_helper (const dim_vector& ndv, const dim_vector& odv)
     : cext (0), sext (0), dext (0), n (0)
   {
-    int l = ndv.length ();
-    assert (odv.length () == l);
+    int l = ndv.ndims ();
+    assert (odv.ndims () == l);
     octave_idx_type ld = 1;
     int i = 0;
     for (; i < l-1 && ndv(i) == odv(i); i++) ld *= ndv(i);
     n = l - i;
     cext = new octave_idx_type [3*n];
     // Trick to avoid three allocations
     sext = cext + n;
     dext = sext + n;
@@ -1020,22 +1020,22 @@ Array<T>::resize2 (octave_idx_type r, oc
       *this = tmp;
     }
 }
 
 template <typename T>
 void
 Array<T>::resize (const dim_vector& dv, const T& rfv)
 {
-  int dvl = dv.length ();
+  int dvl = dv.ndims ();
   if (dvl == 2)
     resize2 (dv(0), dv(1), rfv);
   else if (dimensions != dv)
     {
-      if (dimensions.length () > dvl || dv.any_neg ())
+      if (dimensions.ndims () > dvl || dv.any_neg ())
         err_invalid_resize ();
 
       Array<T> tmp (dv);
       // Prepare for recursive resizing.
       rec_resize_helper rh (dv, dimensions.redim (dvl));
 
       // Do it.
       rh.resize_fill (data (), tmp.fortran_vec (), rfv);
@@ -1201,17 +1201,17 @@ Array<T>::assign (const idx_vector& i, c
       rdv(1) = j.extent (dv(1));
     }
 
   bool isfill = rhs.numel () == 1;
   octave_idx_type il = i.length (rdv(0));
   octave_idx_type jl = j.length (rdv(1));
   rhdv.chop_all_singletons ();
   bool match = (isfill
-                || (rhdv.length () == 2 && il == rhdv(0) && jl == rhdv(1)));
+                || (rhdv.ndims () == 2 && il == rhdv(0) && jl == rhdv(1)));
   match = match || (il == 1 && jl == rhdv(0) && rhdv(1) == 1);
 
   if (match)
     {
       bool all_colons = (i.is_colon_equiv (rdv(0))
                          && j.is_colon_equiv (rdv(1)));
       // Resize if requested.
       if (rdv != dv)
@@ -1317,17 +1317,17 @@ Array<T>::assign (const Array<idx_vector
 
       // Check whether LHS and RHS match, up to singleton dims.
       bool match = true;
       bool all_colons = true;
       bool isfill = rhs.numel () == 1;
 
       rhdv.chop_all_singletons ();
       int j = 0;
-      int rhdvl = rhdv.length ();
+      int rhdvl = rhdv.ndims ();
       for (int i = 0; i < ial; i++)
         {
           all_colons = all_colons && ia(i).is_colon_equiv (rdv(i));
           octave_idx_type l = ia(i).length (rdv(i));
           if (l == 1) continue;
           match = match && j < rhdvl && l == rhdv(j++);
         }
 
@@ -1779,17 +1779,17 @@ Array<T>::sort (int dim, sortmode mode) 
 
   Array<T> m (dims ());
 
   dim_vector dv = m.dims ();
 
   if (m.numel () < 1)
     return m;
 
-  if (dim >= dv.length ())
+  if (dim >= dv.ndims ())
     dv.resize (dim+1, 1);
 
   octave_idx_type ns = dv(dim);
   octave_idx_type iter = dv.numel () / ns;
   octave_idx_type stride = 1;
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
@@ -2326,26 +2326,26 @@ Array<T>::find (octave_idx_type n, bool 
 template <typename T>
 Array<T>
 Array<T>::nth_element (const idx_vector& n, int dim) const
 {
   if (dim < 0)
     (*current_liboctave_error_handler) ("nth_element: invalid dimension");
 
   dim_vector dv = dims ();
-  if (dim >= dv.length ())
+  if (dim >= dv.ndims ())
     dv.resize (dim+1, 1);
 
   octave_idx_type ns = dv(dim);
 
   octave_idx_type nn = n.length (ns);
 
   dv(dim) = std::min (nn, ns);
   dv.chop_trailing_singletons ();
-  dim = std::min (dv.length (), dim);
+  dim = std::min (dv.ndims (), dim);
 
   Array<T> m (dv);
 
   if (m.is_empty ())
     return m;
 
   sortmode mode = UNSORTED;
   octave_idx_type lo = 0;
@@ -2511,17 +2511,17 @@ template <> Array<T>  \
 Array<T>::nth_element (const idx_vector&, int) const { return Array<T> (); }
 
 
 template <typename T>
 Array<T>
 Array<T>::diag (octave_idx_type k) const
 {
   dim_vector dv = dims ();
-  octave_idx_type nd = dv.length ();
+  octave_idx_type nd = dv.ndims ();
   Array<T> d;
 
   if (nd > 2)
     (*current_liboctave_error_handler) ("Matrix must be 2-dimensional");
 
   octave_idx_type nnr = dv(0);
   octave_idx_type nnc = dv(1);
 
@@ -2678,17 +2678,17 @@ Array<T>::cat (int dim, octave_idx_type 
     if (! (dv.*concat_rule) (array_list[i].dims (), dim))
       (*current_liboctave_error_handler) ("cat: dimension mismatch");
 
   Array<T> retval (dv);
 
   if (retval.is_empty ())
     return retval;
 
-  int nidx = std::max (dv.length (), dim + 1);
+  int nidx = std::max (dv.ndims (), dim + 1);
   Array<idx_vector> idxa (dim_vector (nidx, 1), idx_vector::colon);
   octave_idx_type l = 0;
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       // NOTE: This takes some thinking, but no matter what the above rules
       // are, an empty array can always be skipped at this point, because
       // the result dimensions are already determined, and there is no way
@@ -2758,17 +2758,17 @@ void Array<T>::instantiation_guard ()
 // FIXME: is this used?
 
 template <typename T>
 std::ostream&
 operator << (std::ostream& os, const Array<T>& a)
 {
   dim_vector a_dims = a.dims ();
 
-  int n_dims = a_dims.length ();
+  int n_dims = a_dims.ndims ();
 
   os << n_dims << "-dimensional array";
 
   if (n_dims)
     os << " (" << a_dims.str () << ")";
 
   os <<"\n\n";
 
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -273,37 +273,37 @@ public:
   //! Number of elements in the array.
   octave_idx_type numel (void) const { return slice_len; }
   //@}
 
   //! Return the array as a column vector.
   Array<T> as_column (void) const
   {
     Array<T> retval (*this);
-    if (dimensions.length () != 2 || dimensions(1) != 1)
+    if (dimensions.ndims () != 2 || dimensions(1) != 1)
       retval.dimensions = dim_vector (numel (), 1);
 
     return retval;
   }
 
   //! Return the array as a row vector.
   Array<T> as_row (void) const
   {
     Array<T> retval (*this);
-    if (dimensions.length () != 2 || dimensions(0) != 1)
+    if (dimensions.ndims () != 2 || dimensions(0) != 1)
       retval.dimensions = dim_vector (1, numel ());
 
     return retval;
   }
 
   //! Return the array as a matrix.
   Array<T> as_matrix (void) const
   {
     Array<T> retval (*this);
-    if (dimensions.length () != 2)
+    if (dimensions.ndims () != 2)
       retval.dimensions = dimensions.redim (2);
 
     return retval;
   }
 
   //! @name First dimension
   //!
   //! Get the first dimension of the array (number of rows)
@@ -479,17 +479,17 @@ public:
   const T *data (void) const { return slice_data; }
 
   const T *fortran_vec (void) const { return data (); }
 
   T *fortran_vec (void);
 
   bool is_shared (void) { return rep->count > 1; }
 
-  int ndims (void) const { return dimensions.length (); }
+  int ndims (void) const { return dimensions.ndims (); }
 
   //@{
   //! Indexing without resizing.
   Array<T> index (const idx_vector& i) const;
 
   Array<T> index (const idx_vector& i, const idx_vector& j) const;
 
   Array<T> index (const Array<idx_vector>& ia) const;
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -54,17 +54,17 @@ ComplexNDArray::ComplexNDArray (const ch
 
 #if defined (HAVE_FFTW)
 
 ComplexNDArray
 ComplexNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return ComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
@@ -85,17 +85,17 @@ ComplexNDArray::fourier (int dim) const
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return ComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
@@ -115,17 +115,17 @@ ComplexNDArray::ifourier (int dim) const
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
-  if (dv.length () < 2)
+  if (dv.ndims () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2 (dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
@@ -135,17 +135,17 @@ ComplexNDArray::fourier2d (void) const
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier2d (void) const
 {
   dim_vector dv = dims ();
-  if (dv.length () < 2)
+  if (dv.ndims () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2 (dv(0), dv(1));
   const Complex *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
@@ -155,32 +155,32 @@ ComplexNDArray::ifourier2d (void) const
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   octave_fftw::fftNd (in, out, rank, dv);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   octave_fftw::ifftNd (in, out, rank, dv);
 
   return retval;
@@ -205,17 +205,17 @@ extern "C"
   F77_FUNC (zfftb, ZFFTB) (const octave_idx_type&, Complex*, Complex*);
 }
 
 ComplexNDArray
 ComplexNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -252,17 +252,17 @@ ComplexNDArray::fourier (int dim) const
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -396,17 +396,17 @@ ComplexNDArray::ifourier2d (void) const
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
@@ -443,17 +443,17 @@ ComplexNDArray::fourierNd (void) const
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
@@ -748,23 +748,23 @@ conj (const ComplexNDArray& a)
   return do_mx_unary_map<Complex, Complex, std::conj<double> > (a);
 }
 
 ComplexNDArray&
 ComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
 
-  int n = a_dv.length ();
+  int n = a_dv.ndims ();
 
-  if (n != dimensions.length ())
+  if (n != dimensions.ndims ())
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
 
-  Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
+  Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.ndims (), 1), 0);
 
   a_ra_idx.elem (0) = r;
   a_ra_idx.elem (1) = c;
 
   for (int i = 0; i < n; i++)
     {
       if (a_ra_idx(i) < 0 || (a_ra_idx(i) + a_dv(i)) > dimensions(i))
         (*current_liboctave_error_handler)
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -265,30 +265,30 @@ SparseComplexMatrix
 SparseComplexMatrix::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseComplexMatrix result;
   dim_vector dv = dims ();
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
 
-  if (dim >= dv.length ())
+  if (dim >= dv.ndims ())
     {
       idx_arg.resize (dim_vector (nr, nc), 0);
       return *this;
     }
 
   if (dim < 0)
     dim = dv.first_non_singleton ();
 
   if (dim == 0)
     {
       idx_arg.resize (dim_vector (nr == 0 ? 0 : 1, nc), 0);
 
-      if (nr == 0 || nc == 0 || dim >= dv.length ())
+      if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseComplexMatrix (nr == 0 ? 0 : 1, nc);
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp_max;
           double abs_max = octave_NaN;
           octave_idx_type idx_j = 0;
@@ -342,17 +342,17 @@ SparseComplexMatrix::max (Array<octave_i
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, nc == 0 ? 0 : 1), 0);
 
-      if (nr == 0 || nc == 0 || dim >= dv.length ())
+      if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseComplexMatrix (nr, nc == 0 ? 0 : 1);
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, found, nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         found[i] = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
@@ -422,30 +422,30 @@ SparseComplexMatrix::min (int dim) const
 SparseComplexMatrix
 SparseComplexMatrix::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseComplexMatrix result;
   dim_vector dv = dims ();
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
-  if (dim >= dv.length ())
+  if (dim >= dv.ndims ())
     {
       idx_arg.resize (dim_vector (nr, nc), 0);
       return *this;
     }
 
   if (dim < 0)
     dim = dv.first_non_singleton ();
 
   if (dim == 0)
     {
       idx_arg.resize (dim_vector (nr == 0 ? 0 : 1, nc), 0);
 
-      if (nr == 0 || nc == 0 || dim >= dv.length ())
+      if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseComplexMatrix (nr == 0 ? 0 : 1, nc);
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp_min;
           double abs_min = octave_NaN;
           octave_idx_type idx_j = 0;
@@ -499,17 +499,17 @@ SparseComplexMatrix::min (Array<octave_i
             }
           result.xcidx (j+1) = ii;
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, nc == 0 ? 0 : 1), 0);
 
-      if (nr == 0 || nc == 0 || dim >= dv.length ())
+      if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseComplexMatrix (nr, nc == 0 ? 0 : 1);
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, found, nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         found[i] = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -219,17 +219,17 @@ Sparse<T>::Sparse (octave_idx_type nr, o
         xcidx (j) = 0;
     }
 }
 
 template <typename T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
-  if (dv.length () != 2)
+  if (dv.ndims () != 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const dim_vector&): dimension mismatch");
 
   rep = new typename Sparse<T>::SparseRep (dv(0), dv(1), 0);
 }
 
 template <typename T>
 Sparse<T>::Sparse (const Sparse<T>& a, const dim_vector& dv)
@@ -632,17 +632,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
       maybe_compress (true);
     }
 }
 
 template <typename T>
 Sparse<T>::Sparse (const Array<T>& a)
   : rep (0), dimensions (a.dims ())
 {
-  if (dimensions.length () > 2)
+  if (dimensions.ndims () > 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Array<T>&): dimension mismatch");
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type len = a.numel ();
   octave_idx_type new_nzmx = 0;
 
@@ -691,17 +691,17 @@ Sparse<T>::operator = (const Sparse<T>& 
 
   return *this;
 }
 
 template <typename T>
 octave_idx_type
 Sparse<T>::compute_index (const Array<octave_idx_type>& ra_idx) const
 {
-  octave_idx_type n = dimensions.length ();
+  octave_idx_type n = dimensions.ndims ();
 
   if (n <= 0 || n != ra_idx.numel ())
     (*current_liboctave_error_handler)
       ("Sparse<T>::compute_index: invalid ra_idxing operation");
 
   octave_idx_type retval = -1;
 
   retval = ra_idx(--n);
@@ -793,23 +793,23 @@ Sparse<T>::range_error (const char *fcn,
 
 template <typename T>
 Sparse<T>
 Sparse<T>::reshape (const dim_vector& new_dims) const
 {
   Sparse<T> retval;
   dim_vector dims2 = new_dims;
 
-  if (dims2.length () > 2)
+  if (dims2.ndims () > 2)
     {
       (*current_liboctave_warning_with_id_handler)
         ("Octave:reshape-smashes-dims",
          "reshape: sparse reshape to N-D array smashes dims");
 
-      for (octave_idx_type i = 2; i < dims2.length (); i++)
+      for (octave_idx_type i = 2; i < dims2.ndims (); i++)
         dims2(1) *= dims2(i);
 
       dims2.resize (2);
     }
 
   if (dimensions != dims2)
     {
       if (dimensions.numel () == dims2.numel ())
@@ -917,17 +917,17 @@ Sparse<T>::resize1 (octave_idx_type n)
   else
     err_invalid_resize ();
 }
 
 template <typename T>
 void
 Sparse<T>::resize (const dim_vector& dv)
 {
-  octave_idx_type n = dv.length ();
+  octave_idx_type n = dv.ndims ();
 
   if (n != 2)
     (*current_liboctave_error_handler) ("sparse array must be 2-D");
 
   resize (dv(0), dv(1));
 }
 
 template <typename T>
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -546,17 +546,17 @@ public:
 
   octave_idx_type* xcidx (void) { return rep->c; }
   octave_idx_type& xcidx (octave_idx_type i) { return rep->cidx (i); }
 
   octave_idx_type cidx (octave_idx_type i) const { return rep->ccidx (i); }
   // FIXME: shouldn't this be returning const octave_idx_type*?
   octave_idx_type* cidx (void) const { return rep->c; }
 
-  octave_idx_type ndims (void) const { return dimensions.length (); }
+  octave_idx_type ndims (void) const { return dimensions.ndims (); }
 
   void delete_elements (const idx_vector& i);
 
   void delete_elements (int dim, const idx_vector& i);
 
   void delete_elements (const idx_vector& i, const idx_vector& j);
 
   Sparse<T> index (const idx_vector& i, bool resize_ok = false) const;
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -96,17 +96,17 @@ NDArray::NDArray (const charNDArray& a)
 
 #if defined (HAVE_FFTW)
 
 ComplexNDArray
 NDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return ComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
@@ -127,17 +127,17 @@ NDArray::fourier (int dim) const
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return ComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
@@ -156,17 +156,17 @@ NDArray::ifourier (int dim) const
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
-  if (dv.length () < 2)
+  if (dv.ndims () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2 (dv(0), dv(1));
   const double *in = fortran_vec ();
   ComplexNDArray retval (dv);
   Complex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
@@ -176,17 +176,17 @@ NDArray::fourier2d (void) const
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier2d (void) const
 {
   dim_vector dv = dims ();
-  if (dv.length () < 2)
+  if (dv.ndims () < 2)
     return ComplexNDArray ();
 
   dim_vector dv2 (dv(0), dv(1));
   ComplexNDArray retval (*this);
   Complex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
@@ -195,32 +195,32 @@ NDArray::ifourier2d (void) const
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
 
   const double *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   octave_fftw::fftNd (in, out, rank, dv);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
 
   ComplexNDArray tmp (*this);
   Complex *in (tmp.fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   octave_fftw::ifftNd (in, out, rank, dv);
 
@@ -246,17 +246,17 @@ extern "C"
   F77_FUNC (zfftb, ZFFTB) (const octave_idx_type&, Complex*, Complex*);
 }
 
 ComplexNDArray
 NDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -293,17 +293,17 @@ NDArray::fourier (int dim) const
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return ComplexNDArray ();
 
   ComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -437,17 +437,17 @@ NDArray::ifourier2d (void) const
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
@@ -484,17 +484,17 @@ NDArray::fourierNd (void) const
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   ComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -278,30 +278,30 @@ SparseMatrix::max (int dim) const
 SparseMatrix
 SparseMatrix::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseMatrix result;
   dim_vector dv = dims ();
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
-  if (dim >= dv.length ())
+  if (dim >= dv.ndims ())
     {
       idx_arg.resize (dim_vector (nr, nc), 0);
       return *this;
     }
 
   if (dim < 0)
     dim = dv.first_non_singleton ();
 
   if (dim == 0)
     {
       idx_arg.resize (dim_vector (nr == 0 ? 0 : 1, nc), 0);
 
-      if (nr == 0 || nc == 0 || dim >= dv.length ())
+      if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseMatrix (nr == 0 ? 0 : 1, nc);
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           double tmp_max = octave_NaN;
           octave_idx_type idx_j = 0;
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
@@ -349,17 +349,17 @@ SparseMatrix::max (Array<octave_idx_type
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, nc == 0 ? 0 : 1), 0);
 
-      if (nr == 0 || nc == 0 || dim >= dv.length ())
+      if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseMatrix (nr, nc == 0 ? 0 : 1);
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, found, nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         found[i] = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
@@ -429,30 +429,30 @@ SparseMatrix::min (int dim) const
 SparseMatrix
 SparseMatrix::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseMatrix result;
   dim_vector dv = dims ();
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
-  if (dim >= dv.length ())
+  if (dim >= dv.ndims ())
     {
       idx_arg.resize (dim_vector (nr, nc), 0);
       return *this;
     }
 
   if (dim < 0)
     dim = dv.first_non_singleton ();
 
   if (dim == 0)
     {
       idx_arg.resize (dim_vector (nr == 0 ? 0 : 1, nc), 0);
 
-      if (nr == 0 || nc == 0 || dim >= dv.length ())
+      if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseMatrix (nr == 0 ? 0 : 1, nc);
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           double tmp_min = octave_NaN;
           octave_idx_type idx_j = 0;
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
@@ -500,17 +500,17 @@ SparseMatrix::min (Array<octave_idx_type
           result.xcidx (j+1) = ii;
 
         }
     }
   else
     {
       idx_arg.resize (dim_vector (nr, nc == 0 ? 0 : 1), 0);
 
-      if (nr == 0 || nc == 0 || dim >= dv.length ())
+      if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseMatrix (nr, nc == 0 ? 0 : 1);
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, found, nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
         found[i] = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/array/dim-vector.cc b/liboctave/array/dim-vector.cc
--- a/liboctave/array/dim-vector.cc
+++ b/liboctave/array/dim-vector.cc
@@ -66,47 +66,47 @@ dim_vector::chop_all_singletons (void)
   ndims () = j > 2 ? j : 2;
 }
 
 std::string
 dim_vector::str (char sep) const
 {
   std::ostringstream buf;
 
-  for (int i = 0; i < length (); i++)
+  for (int i = 0; i < ndims (); i++)
     {
       buf << elem (i);
 
-      if (i < length () - 1)
+      if (i < ndims () - 1)
         buf << sep;
     }
 
   std::string retval = buf.str ();
 
   return retval;
 }
 
 int
 dim_vector::num_ones (void) const
 {
   int retval = 0;
 
-  for (int i = 0; i < length (); i++)
+  for (int i = 0; i < ndims (); i++)
     if (elem (i) == 1)
       retval++;
 
   return retval;
 }
 
 octave_idx_type
 dim_vector::safe_numel (void) const
 {
   octave_idx_type idx_max = dim_max ();
   octave_idx_type n = 1;
-  int n_dims = length ();
+  int n_dims = ndims ();
 
   for (int i = 0; i < n_dims; i++)
     {
       n *= rep[i];
       if (rep[i] != 0)
         idx_max /= rep[i];
       if (idx_max <= 0)
         throw std::bad_alloc ();
@@ -119,17 +119,17 @@ dim_vector
 dim_vector::squeeze (void) const
 {
   dim_vector new_dims = *this;
 
   bool dims_changed = 1;
 
   int k = 0;
 
-  for (int i = 0; i < length (); i++)
+  for (int i = 0; i < ndims (); i++)
     {
       if (elem (i) == 1)
         dims_changed = true;
       else
         new_dims(k++) = elem (i);
     }
 
   if (dims_changed)
@@ -244,17 +244,17 @@ dim_vector::concat (const dim_vector& dv
 // case the result is the other one except if both of them
 // are empty vectors, in which case the result is 0x0.
 
 bool
 dim_vector::hvcat (const dim_vector& dvb, int dim)
 {
   if (concat (dvb, dim))
     return true;
-  else if (length () == 2 && dvb.length () == 2)
+  else if (ndims () == 2 && dvb.ndims () == 2)
     {
       bool e2dv = rep[0] + rep[1] == 1;
       bool e2dvb = dvb(0) + dvb(1) == 1;
       if (e2dvb)
         {
           if (e2dv)
             *this = dim_vector ();
           return true;
@@ -267,17 +267,17 @@ dim_vector::hvcat (const dim_vector& dvb
     }
 
   return false;
 }
 
 dim_vector
 dim_vector::redim (int n) const
 {
-  int n_dims = length ();
+  int n_dims = ndims ();
 
   if (n_dims == n)
     return *this;
   else if (n_dims < n)
     {
       dim_vector retval = alloc (n);
 
       for (int i = 0; i < n_dims; i++)
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -334,17 +334,17 @@ public:
   int length (void) const { return ndims (); }
 
   octave_idx_type& operator () (int i) { return elem (i); }
 
   octave_idx_type operator () (int i) const { return elem (i); }
 
   void resize (int n, int fill_value = 0)
   {
-    int len = length ();
+    int len = ndims ();
 
     if (n != len)
       {
         octave_idx_type *r = resizerep (n, fill_value);
 
         if (OCTREFCOUNT_ATOMIC_DECREMENT (&(count())) == 0)
           freerep ();
 
@@ -353,72 +353,72 @@ public:
   }
 
   std::string str (char sep = 'x') const;
 
   bool all_zero (void) const
   {
     bool retval = true;
 
-    for (int i = 0; i < length (); i++)
+    for (int i = 0; i < ndims (); i++)
       {
         if (elem (i) != 0)
           {
             retval = false;
             break;
           }
       }
 
     return retval;
   }
 
   bool empty_2d (void) const
   {
-    return length () == 2 && (elem (0) == 0 || elem (1) == 0);
+    return ndims () == 2 && (elem (0) == 0 || elem (1) == 0);
   }
 
 
   bool zero_by_zero (void) const
   {
-    return length () == 2 && elem (0) == 0 && elem (1) == 0;
+    return ndims () == 2 && elem (0) == 0 && elem (1) == 0;
   }
 
   bool any_zero (void) const
   {
     bool retval = false;
 
-    for (int i = 0; i < length (); i++)
+    for (int i = 0; i < ndims (); i++)
       {
         if (elem (i) == 0)
           {
             retval = true;
             break;
           }
       }
 
     return retval;
   }
 
   int num_ones (void) const;
 
   bool all_ones (void) const
   {
-    return (num_ones () == length ());
+    return (num_ones () == ndims ());
   }
 
   //! Number of elements that a matrix with this dimensions would have.
   /*!
      Return the number of elements that a matrix with this dimension
      vector would have, NOT the number of dimensions (elements in the
      dimension vector).
   */
 
   octave_idx_type numel (int n = 0) const
   {
-    int n_dims = length ();
+    int n_dims = ndims ();
 
     octave_idx_type retval = 1;
 
     for (int i = n; i < n_dims; i++)
       retval *= elem (i);
 
     return retval;
   }
@@ -432,17 +432,17 @@ public:
      function that is iterating over an array using octave_idx_type
      indices.
   */
 
   octave_idx_type safe_numel (void) const;
 
   bool any_neg (void) const
   {
-    int n_dims = length ();
+    int n_dims = ndims ();
     int i;
 
     for (i = 0; i < n_dims; i++)
       if (elem (i) < 0)
         break;
 
     return i < n_dims;
   }
@@ -461,52 +461,52 @@ public:
       dimensions are set to 1, redundant are folded into the trailing
       one.  If n = 1, the result is 2d and the second dim is 1
       (dim_vectors are always at least 2D).
   */
   dim_vector redim (int n) const;
 
   dim_vector as_column (void) const
   {
-    if (length () == 2 && elem (1) == 1)
+    if (ndims () == 2 && elem (1) == 1)
       return *this;
     else
       return dim_vector (numel (), 1);
   }
 
   dim_vector as_row (void) const
   {
-    if (length () == 2 && elem (0) == 1)
+    if (ndims () == 2 && elem (0) == 1)
       return *this;
     else
       return dim_vector (1, numel ());
   }
 
   bool is_vector (void) const
   {
-    return (length () == 2 && (elem (0) == 1 || elem (1) == 1));
+    return (ndims () == 2 && (elem (0) == 1 || elem (1) == 1));
   }
 
   int first_non_singleton (int def = 0) const
   {
-    for (int i = 0; i < length (); i++)
+    for (int i = 0; i < ndims (); i++)
       {
         if (elem (i) != 1)
           return i;
       }
 
     return def;
   }
 
   //! Compute a linear index from an index tuple.
 
   octave_idx_type compute_index (const octave_idx_type *idx) const
   {
     octave_idx_type k = 0;
-    for (int i = length () - 1; i >= 0; i--)
+    for (int i = ndims () - 1; i >= 0; i--)
       k = rep[i] * k + idx[i];
 
     return k;
   }
 
   //! Ditto, but the tuple may be incomplete (nidx < length ()).
 
   octave_idx_type compute_index (const octave_idx_type *idx, int nidx) const
@@ -522,48 +522,48 @@ public:
       Increment a multi-dimensional index tuple, optionally starting
       from an offset position and return the index of the last index
       position that was changed, or length () if just cycled over.
   */
 
   int increment_index (octave_idx_type *idx, int start = 0) const
   {
     int i;
-    for (i = start; i < length (); i++)
+    for (i = start; i < ndims (); i++)
       {
         if (++(*idx) == rep[i])
           *idx++ = 0;
         else
           break;
       }
     return i;
   }
 
   //! Return cumulative dimensions.
 
   dim_vector cumulative (void) const
   {
-    int nd = length ();
+    int nd = ndims ();
     dim_vector retval = alloc (nd);
 
     octave_idx_type k = 1;
     for (int i = 0; i < nd; i++)
       retval.rep[i] = k *= rep[i];
 
     return retval;
   }
 
   //! Compute a linear index from an index tuple.  Dimensions are
   //! required to be cumulative.
 
   octave_idx_type cum_compute_index (const octave_idx_type *idx) const
   {
     octave_idx_type k = idx[0];
 
-    for (int i = 1; i < length (); i++)
+    for (int i = 1; i < ndims (); i++)
       k += rep[i-1] * idx[i];
 
     return k;
   }
 
 
   friend bool operator == (const dim_vector& a, const dim_vector& b);
 };
@@ -572,18 +572,18 @@ inline bool
 operator == (const dim_vector& a, const dim_vector& b)
 {
   // Fast case.
   if (a.rep == b.rep)
     return true;
 
   bool retval = true;
 
-  int a_len = a.length ();
-  int b_len = b.length ();
+  int a_len = a.ndims ();
+  int b_len = b.ndims ();
 
   if (a_len != b_len)
     retval = false;
   else
     {
       for (int i = 0; i < a_len; i++)
         {
           if (a(i) != b(i))
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -54,17 +54,17 @@ FloatComplexNDArray::FloatComplexNDArray
 
 #if defined (HAVE_FFTW)
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return FloatComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
@@ -85,17 +85,17 @@ FloatComplexNDArray::fourier (int dim) c
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return FloatComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
@@ -115,17 +115,17 @@ FloatComplexNDArray::ifourier (int dim) 
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
-  if (dv.length () < 2)
+  if (dv.ndims () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2 (dv(0), dv(1));
   const FloatComplex *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
@@ -135,17 +135,17 @@ FloatComplexNDArray::fourier2d (void) co
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier2d (void) const
 {
   dim_vector dv = dims ();
-  if (dv.length () < 2)
+  if (dv.ndims () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2 (dv(0), dv(1));
   const FloatComplex *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
@@ -155,32 +155,32 @@ FloatComplexNDArray::ifourier2d (void) c
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
 
   const FloatComplex *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   octave_fftw::fftNd (in, out, rank, dv);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
 
   const FloatComplex *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   octave_fftw::ifftNd (in, out, rank, dv);
 
   return retval;
@@ -202,17 +202,17 @@ extern "C"
                            FloatComplex*);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return FloatComplexNDArray ();
 
   FloatComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -249,17 +249,17 @@ FloatComplexNDArray::fourier (int dim) c
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return FloatComplexNDArray ();
 
   FloatComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -393,17 +393,17 @@ FloatComplexNDArray::ifourier2d (void) c
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
@@ -440,17 +440,17 @@ FloatComplexNDArray::fourierNd (void) co
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
@@ -759,21 +759,21 @@ conj (const FloatComplexNDArray& a)
 }
 
 FloatComplexNDArray&
 FloatComplexNDArray::insert (const NDArray& a,
                              octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
 
-  int n = a_dv.length ();
+  int n = a_dv.ndims ();
 
-  if (n == dimensions.length ())
+  if (n == dimensions.ndims ())
     {
-      Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
+      Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.ndims (), 1), 0);
 
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
 
       for (int i = 0; i < n; i++)
         {
           if (a_ra_idx(i) < 0 || (a_ra_idx(i) + a_dv(i)) > dimensions(i))
             (*current_liboctave_error_handler)
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -54,17 +54,17 @@ FloatNDArray::FloatNDArray (const charND
 
 #if defined (HAVE_FFTW)
 
 FloatComplexNDArray
 FloatNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return FloatComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
@@ -85,17 +85,17 @@ FloatNDArray::fourier (int dim) const
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return FloatComplexNDArray ();
 
   octave_idx_type stride = 1;
   octave_idx_type n = dv(dim);
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
@@ -114,17 +114,17 @@ FloatNDArray::ifourier (int dim) const
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
-  if (dv.length () < 2)
+  if (dv.ndims () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2 (dv(0), dv(1));
   const float *in = fortran_vec ();
   FloatComplexNDArray retval (dv);
   FloatComplex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
@@ -134,17 +134,17 @@ FloatNDArray::fourier2d (void) const
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier2d (void) const
 {
   dim_vector dv = dims ();
-  if (dv.length () < 2)
+  if (dv.ndims () < 2)
     return FloatComplexNDArray ();
 
   dim_vector dv2 (dv(0), dv(1));
   FloatComplexNDArray retval (*this);
   FloatComplex *out = retval.fortran_vec ();
   octave_idx_type howmany = numel () / dv(0) / dv(1);
   octave_idx_type dist = dv(0) * dv(1);
 
@@ -153,32 +153,32 @@ FloatNDArray::ifourier2d (void) const
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
 
   const float *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   octave_fftw::fftNd (in, out, rank, dv);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
 
   FloatComplexNDArray tmp (*this);
   FloatComplex *in (tmp.fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   octave_fftw::ifftNd (in, out, rank, dv);
 
@@ -206,17 +206,17 @@ extern "C"
                            FloatComplex*);
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return FloatComplexNDArray ();
 
   FloatComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -253,17 +253,17 @@ FloatNDArray::fourier (int dim) const
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier (int dim) const
 {
   dim_vector dv = dims ();
 
-  if (dim > dv.length () || dim < 0)
+  if (dim > dv.ndims () || dim < 0)
     return FloatComplexNDArray ();
 
   FloatComplexNDArray retval (dv);
   octave_idx_type npts = dv(dim);
   octave_idx_type nn = 4*npts+15;
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -397,17 +397,17 @@ FloatNDArray::ifourier2d (void) const
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
@@ -444,17 +444,17 @@ FloatNDArray::fourierNd (void) const
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourierNd (void) const
 {
   dim_vector dv = dims ();
-  int rank = dv.length ();
+  int rank = dv.ndims ();
   FloatComplexNDArray retval (*this);
   octave_idx_type stride = 1;
 
   for (int i = 0; i < rank; i++)
     {
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (dim_vector (nn, 1));
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -386,17 +386,17 @@ idx_vector::idx_vector_rep::idx_vector_r
   : data (0), len (nnz), ext (0), aowner (0), orig_dims ()
 {
   if (nnz < 0)
     len = bnda.nnz ();
 
   const dim_vector dv = bnda.dims ();
 
   if (! dv.all_zero ())
-    orig_dims = ((dv.length () == 2 && dv(0) == 1)
+    orig_dims = ((dv.ndims () == 2 && dv(0) == 1)
                  ? dim_vector (1, len) : dim_vector (len, 1));
 
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type ntot = bnda.numel ();
 
@@ -412,17 +412,17 @@ idx_vector::idx_vector_rep::idx_vector_r
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Sparse<bool>& bnda)
   : data (0), len (bnda.nnz ()), ext (0), aowner (0), orig_dims ()
 {
   const dim_vector dv = bnda.dims ();
 
   if (! dv.all_zero ())
-    orig_dims = ((dv.length () == 2 && dv(0) == 1)
+    orig_dims = ((dv.ndims () == 2 && dv(0) == 1)
                  ? dim_vector (1, len) : dim_vector (len, 1));
 
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type k = 0;
       octave_idx_type nc = bnda.cols ();
@@ -480,17 +480,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
       lsort.set_compare (ASCENDING);
       lsort.sort (new_data, len);
 
       if (uniq)
         {
           octave_idx_type new_len = std::unique (new_data, new_data + len)
                                     - new_data;
           new_rep->len = new_len;
-          if (new_rep->orig_dims.length () == 2 && new_rep->orig_dims(0) == 1)
+          if (new_rep->orig_dims.ndims () == 2 && new_rep->orig_dims(0) == 1)
             new_rep->orig_dims = dim_vector (1, new_len);
           else
             new_rep->orig_dims = dim_vector (new_len, 1);
         }
     }
   else if (uniq)
     {
       // Use two-pass bucket sort (only a mask array needed).
@@ -498,17 +498,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
       for (octave_idx_type i = 0; i < len; i++)
         has[data[i]] = true;
 
       octave_idx_type new_len = 0;
       for (octave_idx_type i = 0; i < ext; i++)
         new_len += has[i];
 
       new_rep->len = new_len;
-      if (new_rep->orig_dims.length () == 2 && new_rep->orig_dims(0) == 1)
+      if (new_rep->orig_dims.ndims () == 2 && new_rep->orig_dims(0) == 1)
         new_rep->orig_dims = dim_vector (1, new_len);
       else
         new_rep->orig_dims = dim_vector (new_len, 1);
 
       octave_idx_type *new_data = new octave_idx_type [new_len];
       new_rep->data = new_data;
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
@@ -656,17 +656,17 @@ idx_vector::idx_mask_rep::idx_mask_rep (
   // We truncate the extent as much as possible. For Matlab
   // compatibility, but maybe it's not a bad idea anyway.
   while (ext > 0 && ! bnda(ext-1))
     ext--;
 
   const dim_vector dv = bnda.dims ();
 
   if (! dv.all_zero ())
-    orig_dims = ((dv.length () == 2 && dv(0) == 1)
+    orig_dims = ((dv.ndims () == 2 && dv(0) == 1)
                  ? dim_vector (1, len) : dim_vector (len, 1));
 
   aowner = new Array<bool> (bnda);
   data = bnda.data ();
 }
 
 idx_vector::idx_mask_rep::~idx_mask_rep (void)
 {
diff --git a/liboctave/numeric/bsxfun.h b/liboctave/numeric/bsxfun.h
--- a/liboctave/numeric/bsxfun.h
+++ b/liboctave/numeric/bsxfun.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "dim-vector.h"
 #include "lo-error.h"
 
 inline
 bool
 is_valid_bsxfun (const std::string& name, const dim_vector& dx,
                  const dim_vector& dy)
 {
-  for (int i = 0; i < std::min (dx.length (), dy.length ()); i++)
+  for (int i = 0; i < std::min (dx.ndims (), dy.ndims ()); i++)
     {
       octave_idx_type xk = dx(i);
       octave_idx_type yk = dy(i);
       // Check the three conditions for valid bsxfun dims
       if (! ((xk == yk) || (xk == 1 && yk != 1) || (xk != 1 && yk == 1)))
         return false;
     }
 
@@ -57,18 +57,18 @@ is_valid_bsxfun (const std::string& name
 // since we can't change the size of the assigned-to matrix, we cannot
 // apply singleton expansion to it, so the conditions to check are
 // different here.
 inline
 bool
 is_valid_inplace_bsxfun (const std::string& name, const dim_vector& dr,
                          const dim_vector& dx)
 {
-  octave_idx_type drl = dr.length ();
-  octave_idx_type dxl = dx.length ();
+  octave_idx_type drl = dr.ndims ();
+  octave_idx_type dxl = dx.ndims ();
   if (drl < dxl)
     return false;
 
   for (int i = 0; i < drl; i++)
     {
       octave_idx_type rk = dr(i);
       octave_idx_type xk = dx(i);
 
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -793,17 +793,17 @@ convert_packcomplex_1d (T *out, size_t n
 }
 
 template <typename T>
 static inline void
 convert_packcomplex_Nd (T *out, const dim_vector &dv)
 {
   size_t nc = dv(0);
   size_t nr = dv(1);
-  size_t np = (dv.length () > 2 ? dv.numel () / nc / nr : 1);
+  size_t np = (dv.ndims () > 2 ? dv.numel () / nc / nr : 1);
   size_t nrp = nr * np;
   T *ptr1, *ptr2;
 
   octave_quit ();
 
   // Create space for the missing elements.
 
   for (size_t i = 0; i < nrp; i++)
@@ -831,17 +831,17 @@ convert_packcomplex_Nd (T *out, const di
   octave_quit ();
 
   // Now do the permutations needed for rank > 2 cases.
 
   size_t jstart = dv(0) * dv(1);
   size_t kstep = dv(0);
   size_t nel = dv.numel ();
 
-  for (int inner = 2; inner < dv.length (); inner++)
+  for (int inner = 2; inner < dv.ndims (); inner++)
     {
       size_t jmax = jstart * dv(inner);
       for (size_t i = 0; i < nel; i+=jmax)
         for (size_t j = jstart, jj = jmax-jstart; j < jj;
              j+=jstart, jj-=jstart)
           for (size_t k = 0; k < jstart; k+= kstep)
             for (size_t l = nc/2+1; l < nc; l++)
               {
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -1153,17 +1153,17 @@ mx_inline_diff (const T *v, T *r,
 
 // Assistant function
 
 inline void
 get_extent_triplet (const dim_vector& dims, int& dim,
                     octave_idx_type& l, octave_idx_type& n,
                     octave_idx_type& u)
 {
-  octave_idx_type ndims = dims.length ();
+  octave_idx_type ndims = dims.ndims ();
   if (dim >= ndims)
     {
       l = dims.numel ();
       n = 1;
       u = 1;
     }
   else
     {
@@ -1187,23 +1187,23 @@ template <typename R, typename T>
 inline Array<R>
 do_mx_red_op (const Array<T>& src, int dim,
               void (*mx_red_op) (const T *, R *, octave_idx_type,
                                  octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   // M*b inconsistency: sum ([]) = 0 etc.
-  if (dims.length () == 2 && dims(0) == 0 && dims(1) == 0)
+  if (dims.ndims () == 2 && dims(0) == 0 && dims(1) == 0)
     dims(1) = 1;
 
   get_extent_triplet (dims, dim, l, n, u);
 
   // Reduction operation reduces the array size.
-  if (dim < dims.length ()) dims(dim) = 1;
+  if (dim < dims.ndims ()) dims(dim) = 1;
   dims.chop_trailing_singletons ();
 
   Array<R> ret (dims);
   mx_red_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
@@ -1230,17 +1230,17 @@ do_mx_minmax_op (const Array<R>& src, in
                  void (*mx_minmax_op) (const R *, R *, octave_idx_type,
                                        octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
   // If the dimension is zero, we don't do anything.
-  if (dim < dims.length () && dims(dim) != 0) dims(dim) = 1;
+  if (dim < dims.ndims () && dims(dim) != 0) dims(dim) = 1;
   dims.chop_trailing_singletons ();
 
   Array<R> ret (dims);
   mx_minmax_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
@@ -1250,17 +1250,17 @@ do_mx_minmax_op (const Array<R>& src, Ar
                  void (*mx_minmax_op) (const R *, R *, octave_idx_type *,
                                        octave_idx_type, octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
   // If the dimension is zero, we don't do anything.
-  if (dim < dims.length () && dims(dim) != 0) dims(dim) = 1;
+  if (dim < dims.ndims () && dims(dim) != 0) dims(dim) = 1;
   dims.chop_trailing_singletons ();
 
   Array<R> ret (dims);
   if (idx.dims () != dims) idx = Array<octave_idx_type> (dims);
 
   mx_minmax_op (src.data (), ret.fortran_vec (), idx.fortran_vec (),
                 l, n, u);
 
@@ -1311,17 +1311,17 @@ do_mx_diff_op (const Array<R>& src, int 
 {
   octave_idx_type l, n, u;
   if (order <= 0)
     return src;
 
   dim_vector dims = src.dims ();
 
   get_extent_triplet (dims, dim, l, n, u);
-  if (dim >= dims.length ())
+  if (dim >= dims.ndims ())
     dims.resize (dim+1, 1);
 
   if (dims(dim) <= order)
     {
       dims(dim) = 0;
       return Array<R> (dims);
     }
   else
diff --git a/liboctave/util/lo-array-errwarn.cc b/liboctave/util/lo-array-errwarn.cc
--- a/liboctave/util/lo-array-errwarn.cc
+++ b/liboctave/util/lo-array-errwarn.cc
@@ -226,17 +226,17 @@ public:
                 octave_idx_type dim_in)
     : index_exception (value, nd_in, dim_in), extent (0)
   { }
 
   std::string details (void) const
   {
     std::string expl;
 
-    if (nd >= size.length ())   // if not an index slice
+    if (nd >= size.ndims ())   // if not an index slice
       {
         if (var != "")
           expl = "but " + var + " has size ";
         else
           expl = "but object has size ";
 
         expl = expl + size.str ('x');
       }
diff --git a/liboctave/util/lo-array-gripes.cc b/liboctave/util/lo-array-gripes.cc
--- a/liboctave/util/lo-array-gripes.cc
+++ b/liboctave/util/lo-array-gripes.cc
@@ -190,17 +190,17 @@ public:
                 octave_idx_type dim_in)
     : index_exception (value, nd_in, dim_in), extent (0)
   { }
 
   std::string details (void) const
   {
     std::string expl;
 
-    if (nd >= size.length ())   // if not an index slice
+    if (nd >= size.ndims ())   // if not an index slice
       {
         if (var != "")
           expl = "but " + var + " has size ";
         else
           expl = "but object has size ";
 
         expl = expl + size.str ('x');
       }
