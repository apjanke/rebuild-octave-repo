# HG changeset patch
# User Rik <rik@octave.org>
# Date 1497367482 25200
#      Tue Jun 13 08:24:42 2017 -0700
# Node ID b7747a2c88b2065d11188c0792b3bc32b95770b7
# Parent  0cc2011d800e8f3548150ce57207ab9cf87e3378
maint: Deprecate is_sparse_type and replace with issparse.

* ov.h (is_sparse_type): Use OCTAVE_DEPRECATED macro around function.
* ov.h (issparse): New function.

* __luinc__.cc, bsxfun.cc, cellfun.cc, data.cc, det.cc, find.cc, gcd.cc,
graphics.in.h, inv.cc, kron.cc, ls-mat4.cc, ls-mat5.cc, lu.cc, matrix_type.cc,
max.cc, mex.cc, rcond.cc, sparse.cc, tril.cc, variables.cc, xnorm.cc,
__eigs__.cc, __glpk__.cc, amd.cc, ccolamd.cc, chol.cc, colamd.cc, qr.cc,
ov-base-sparse.h, ov-base.h, ov-bool-mat.cc, pt-tm-const.cc:
Replace instances of is_sparse_type with issparse.

diff --git a/libinterp/corefcn/__luinc__.cc b/libinterp/corefcn/__luinc__.cc
--- a/libinterp/corefcn/__luinc__.cc
+++ b/libinterp/corefcn/__luinc__.cc
@@ -48,17 +48,17 @@ See documentation for @code{luinc}.
 @seealso{luinc}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
-  if (! args(0).is_sparse_type ())
+  if (! args(0).issparse ())
     error ("luinc: matrix A must be sparse");
 
   bool zero_level = false;
   bool milu = false;
   bool udiag = false;
   Matrix thresh;
   double droptol = -1.0;
   bool vecout = false;
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -461,17 +461,17 @@ dimensionality as the other array.
                 {                                                       \
                   have_ ## T = true;                                    \
                   result_ ## T = tmp(0). EXTRACTOR ## _array_value ();  \
                   result_ ## T .resize (dvc);                           \
                 }
 
               if (i == 0)
                 {
-                  if (! tmp(0).is_sparse_type ())
+                  if (! tmp(0).issparse ())
                     {
                       std::string result_type = tmp(0).class_name ();
                       if (result_type == "double")
                         {
                           if (tmp(0).isreal ())
                             {
                               have_NDArray = true;
                               result_NDArray = tmp(0).array_value ();
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -2108,17 +2108,17 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
 
   // Prepare indices.
   OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, d, nargin-1);
 
   for (int i = 1; i < nargin; i++)
     d[i-1] = args(i).octave_idx_type_vector_value (true);
 
   octave_value a = args(0);
-  bool sparse = a.is_sparse_type ();
+  bool sparse = a.issparse ();
   if (sparse && nargin > 3)
     error ("mat2cell: sparse arguments only support 2-D indexing");
 
   switch (a.builtin_type ())
     {
     case btyp_double:
       {
         if (sparse)
@@ -2263,17 +2263,17 @@ slicing is done along the first non-sing
       if (dim < 0)
         error ("cellslices: DIM must be a valid dimension");
     }
 
   if (lb.numel () != ub.numel ())
     error ("cellslices: the lengths of LB and UB must match");
 
   Cell retcell;
-  if (! x.is_sparse_type () && x.is_matrix_type ())
+  if (! x.issparse () && x.is_matrix_type ())
     {
       // specialize for some dense arrays.
       if (x.islogical ())
         retcell = do_cellslices_nda (x.bool_array_value (),
                                      lb, ub, dim);
       else if (x.is_char_matrix ())
         retcell = do_cellslices_nda (x.char_array_value (),
                                      lb, ub, dim);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -239,17 +239,17 @@ This function is equivalent to @code{arg
           FloatNDArray a1 = args(1).float_array_value ();
           retval = binmap<float> (a0, a1, ::atan2f, "atan2");
         }
     }
   else
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
         retval = atan2 (args(0).scalar_value (), args(1).scalar_value ());
-      else if (args(0).is_sparse_type ())
+      else if (args(0).issparse ())
         {
           SparseMatrix m0 = args(0).sparse_matrix_value ();
           SparseMatrix m1 = args(1).sparse_matrix_value ();
           retval = binmap<double> (m0, m1, ::atan2, "atan2");
         }
       else
         {
           NDArray a0 = args(0).array_value ();
@@ -349,17 +349,17 @@ do_hypot (const octave_value& x, const o
           FloatNDArray a1 = arg1.float_array_value ();
           retval = binmap<float> (a0, a1, ::hypotf, "hypot");
         }
     }
   else
     {
       if (arg0.is_scalar_type () && arg1.is_scalar_type ())
         retval = hypot (arg0.scalar_value (), arg1.scalar_value ());
-      else if (arg0.is_sparse_type () || arg1.is_sparse_type ())
+      else if (arg0.issparse () || arg1.issparse ())
         {
           SparseMatrix m0 = arg0.sparse_matrix_value ();
           SparseMatrix m1 = arg1.sparse_matrix_value ();
           retval = binmap<double> (m0, m1, ::hypot, "hypot");
         }
       else
         {
           NDArray a0 = arg0.array_value ();
@@ -661,17 +661,17 @@ periodic, @code{mod} is a better choice.
           FloatNDArray a1 = args(1).float_array_value ();
           retval = binmap<float> (a0, a1, octave::math::rem<float>, "rem");
         }
     }
   else
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
         retval = octave::math::rem (args(0).scalar_value (), args(1).scalar_value ());
-      else if (args(0).is_sparse_type () || args(1).is_sparse_type ())
+      else if (args(0).issparse () || args(1).issparse ())
         {
           SparseMatrix m0 = args(0).sparse_matrix_value ();
           SparseMatrix m1 = args(1).sparse_matrix_value ();
           retval = binmap<double> (m0, m1, octave::math::rem<double>, "rem");
         }
       else
         {
           NDArray a0 = args(0).array_value ();
@@ -840,17 +840,17 @@ negative numbers or when the values are 
           FloatNDArray a1 = args(1).float_array_value ();
           retval = binmap<float> (a0, a1, octave::math::mod<float>, "mod");
         }
     }
   else
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
         retval = octave::math::mod (args(0).scalar_value (), args(1).scalar_value ());
-      else if (args(0).is_sparse_type () || args(1).is_sparse_type ())
+      else if (args(0).issparse () || args(1).issparse ())
         {
           SparseMatrix m0 = args(0).sparse_matrix_value ();
           SparseMatrix m1 = args(1).sparse_matrix_value ();
           retval = binmap<double> (m0, m1, octave::math::mod<double>, "mod");
         }
       else
         {
           NDArray a0 = args(0).array_value ();
@@ -923,17 +923,17 @@ negative numbers or when the values are 
                                                                         \
   int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1);          \
                                                                         \
   if (dim < -1)                                                         \
     error (#FCN ": invalid dimension argument = %d", dim + 1);          \
                                                                         \
   if (arg.isreal ())                                              \
     {                                                                   \
-      if (arg.is_sparse_type ())                                        \
+      if (arg.issparse ())                                        \
         {                                                               \
           SparseMatrix tmp = arg.sparse_matrix_value ();                \
                                                                         \
           retval = tmp.FCN (dim);                                       \
         }                                                               \
       else if (arg.is_single_type ())                                   \
         {                                                               \
           FloatNDArray tmp = arg.float_array_value ();                  \
@@ -944,17 +944,17 @@ negative numbers or when the values are 
         {                                                               \
           NDArray tmp = arg.array_value ();                             \
                                                                         \
           retval = tmp.FCN (dim);                                       \
         }                                                               \
     }                                                                   \
   else if (arg.iscomplex ())                                      \
     {                                                                   \
-      if (arg.is_sparse_type ())                                        \
+      if (arg.issparse ())                                        \
         {                                                               \
           SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
                                                                         \
           retval = tmp.FCN (dim);                                       \
         }                                                               \
       else if (arg.is_single_type ())                                   \
         {                                                               \
           FloatComplexNDArray tmp                                       \
@@ -1074,23 +1074,23 @@ See @code{sum} for an explanation of the
     }
 
   octave_value retval;
   octave_value arg = args(0);
 
   switch (arg.builtin_type ())
     {
     case btyp_double:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         retval = arg.sparse_matrix_value ().cumsum (dim);
       else
         retval = arg.array_value ().cumsum (dim);
       break;
     case btyp_complex:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         retval = arg.sparse_complex_matrix_value ().cumsum (dim);
       else
         retval = arg.complex_array_value ().cumsum (dim);
       break;
     case btyp_float:
       if (isdouble)
         retval = arg.array_value ().cumsum (dim);
       else
@@ -1118,17 +1118,17 @@ See @code{sum} for an explanation of the
       MAKE_INT_BRANCH (uint8);
       MAKE_INT_BRANCH (uint16);
       MAKE_INT_BRANCH (uint32);
       MAKE_INT_BRANCH (uint64);
 
 #undef MAKE_INT_BRANCH
 
     case btyp_bool:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         {
           SparseMatrix cs = arg.sparse_matrix_value ().cumsum (dim);
           if (isnative)
             retval = cs != 0.0;
           else
             retval = cs;
         }
       else
@@ -1360,23 +1360,23 @@ in double precision even for single prec
       dim = args(1).int_value () - 1;
       if (dim < 0)
         error ("prod: invalid dimension DIM = %d", dim + 1);
     }
 
   switch (arg.builtin_type ())
     {
     case btyp_double:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         retval = arg.sparse_matrix_value ().prod (dim);
       else
         retval = arg.array_value ().prod (dim);
       break;
     case btyp_complex:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         retval = arg.sparse_complex_matrix_value ().prod (dim);
       else
         retval = arg.complex_array_value ().prod (dim);
       break;
     case btyp_float:
       if (isdouble)
         retval = arg.float_array_value ().dprod (dim);
       else
@@ -1409,17 +1409,17 @@ in double precision even for single prec
 #undef MAKE_INT_BRANCH
 
     // GAGME: Accursed Matlab compatibility...
     case btyp_char:
       retval = arg.array_value (true).prod (dim);
       break;
 
     case btyp_bool:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         {
           if (isnative)
             retval = arg.sparse_bool_matrix_value ().all (dim);
           else
             retval = arg.sparse_matrix_value ().prod (dim);
         }
       else if (isnative)
         retval = arg.bool_array_value ().all (dim);
@@ -1798,17 +1798,17 @@ do_cat (const octave_value_list& xargs, 
             all_sq_strings_p = false;
           if (all_dq_strings_p && ! args(i).is_dq_string ())
             all_dq_strings_p = false;
           if (all_real_p && ! args(i).isreal ())
             all_real_p = false;
           if (all_cmplx_p && ! (args(i).iscomplex ()
                                 || args(i).isreal ()))
             all_cmplx_p = false;
-          if (! any_sparse_p && args(i).is_sparse_type ())
+          if (! any_sparse_p && args(i).issparse ())
             any_sparse_p = true;
           if (! any_cell_p && args(i).iscell ())
             any_cell_p = true;
           if (! any_class_p && args(i).is_object ())
             any_class_p = true;
         }
 
       if (any_cell_p && ! any_class_p && ! first_elem_is_struct)
@@ -2900,30 +2900,30 @@ inputs, @qcode{"extra"} is the same as @
     }
 
   octave_value retval;
   octave_value arg = args(0);
 
   switch (arg.builtin_type ())
     {
     case btyp_double:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         {
           if (isextra)
             warning ("sum: 'extra' not yet implemented for sparse matrices");
           retval = arg.sparse_matrix_value ().sum (dim);
         }
       else if (isextra)
         retval = arg.array_value ().xsum (dim);
       else
         retval = arg.array_value ().sum (dim);
       break;
 
     case btyp_complex:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         {
           if (isextra)
             warning ("sum: 'extra' not yet implemented for sparse matrices");
           retval = arg.sparse_complex_matrix_value ().sum (dim);
         }
       else if (isextra)
         retval = arg.complex_array_value ().xsum (dim);
       else
@@ -2967,17 +2967,17 @@ inputs, @qcode{"extra"} is the same as @
     case btyp_char:
       if (isextra)
         retval = arg.array_value (true).xsum (dim);
       else
         retval = arg.array_value (true).sum (dim);
       break;
 
     case btyp_bool:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         {
           if (isnative)
             retval = arg.sparse_bool_matrix_value ().any (dim);
           else
             retval = arg.sparse_bool_matrix_value ().sum (dim);
         }
       else if (isnative)
         retval = arg.bool_array_value ().any (dim);
@@ -3250,17 +3250,17 @@ complex ([1, 2], [3, 4])
   if (nargin == 1)
     {
       octave_value arg = args(0);
 
       if (arg.iscomplex ())
         retval = arg;
       else
         {
-          if (arg.is_sparse_type ())
+          if (arg.issparse ())
             {
               SparseComplexMatrix val = arg.xsparse_complex_matrix_value ("complex: invalid conversion");
 
               retval = octave_value (new octave_sparse_complex_matrix (val));
             }
           else if (arg.is_single_type ())
             {
               if (arg.numel () == 1)
@@ -3293,17 +3293,17 @@ complex ([1, 2], [3, 4])
             }
         }
     }
   else
     {
       octave_value re = args(0);
       octave_value im = args(1);
 
-      if (re.is_sparse_type () && im.is_sparse_type ())
+      if (re.issparse () && im.issparse ())
         {
           const SparseMatrix re_val = re.sparse_matrix_value ();
           const SparseMatrix im_val = im.sparse_matrix_value ();
 
           if (re.numel () == 1)
             {
               SparseComplexMatrix result;
               if (re_val.nnz () == 0)
@@ -6684,17 +6684,17 @@ Undocumented internal function.
       else if (mode == "descend")
         smode = DESCENDING;
       else
         error ("__sort_rows_idx__: MODE must be either \"ascend\" or \"descend\"");
     }
 
   octave_value arg = args(0);
 
-  if (arg.is_sparse_type ())
+  if (arg.issparse ())
     error ("__sort_rows_idx__: sparse matrices not yet supported");
 
   if (arg.ndims () != 2)
     error ("__sort_rows_idx__: needs a 2-D object");
 
   Array<octave_idx_type> idx = arg.sort_rows_idx (smode);
 
   // This cannot be ovl(), relies on special overloaded octave_value call.
@@ -6765,17 +6765,17 @@ This function does not support sparse ma
     }
 
   octave_value retval;
 
   octave_value arg = args(0);
 
   if (by_rows)
     {
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         error ("issorted: sparse matrices not yet supported");
 
       if (arg.ndims () != 2)
         error ("issorted: A must be a 2-D object");
 
       retval = arg.is_sorted_rows (smode) != UNSORTED;
     }
   else
@@ -7499,17 +7499,17 @@ do_diff (const octave_value& array, octa
         retval = array.uint16_array_value ().diff (order, dim);
       else if (array.is_uint32_type ())
         retval = array.uint32_array_value ().diff (order, dim);
       else if (array.is_uint64_type ())
         retval = array.uint64_array_value ().diff (order, dim);
       else
         panic_impossible ();
     }
-  else if (array.is_sparse_type ())
+  else if (array.issparse ())
     {
       if (array.iscomplex ())
         retval = do_sparse_diff (array.sparse_complex_matrix_value (),
                                  order, dim);
       else
         retval = do_sparse_diff (array.sparse_matrix_value (), order, dim);
     }
   else if (array.is_single_type ())
@@ -7733,17 +7733,17 @@ Encode a double matrix or array @var{x} 
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_numeric_type ())
     error ("base64_encode: encoding is supported only for numeric arrays");
 
-  if (args(0).iscomplex () || args(0).is_sparse_type ())
+  if (args(0).iscomplex () || args(0).issparse ())
     error ("base64_encode: encoding complex or sparse data is not supported");
 
   octave_value_list retval;
 
   if (args(0).isinteger ())
     {
 #define MAKE_INT_BRANCH(X)                                               \
       if (args(0).is_ ## X ## _type ())                                  \
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -162,17 +162,17 @@ For that, use any of the condition numbe
     }
   else
     {
       if (arg.isreal ())
         {
           octave_idx_type info;
           double rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
-          if (arg.is_sparse_type ())
+          if (arg.issparse ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
               DET det = m.determinant (info, rcond);
               retval(0) = (info == -1 ? 0.0 : det.value ());
               retval(1) = rcond;
             }
           else
@@ -189,17 +189,17 @@ For that, use any of the condition numbe
                 rep->matrix_type (mtype);
             }
         }
       else if (arg.iscomplex ())
         {
           octave_idx_type info;
           double rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
-          if (arg.is_sparse_type ())
+          if (arg.issparse ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
               ComplexDET det = m.determinant (info, rcond);
               retval(0) = (info == -1 ? Complex (0.0) : det.value ());
               retval(1) = rcond;
             }
           else
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -422,17 +422,17 @@ b = sparse (i, j, v, sz(1), sz(2));
     }
 
   octave_value_list retval;
 
   octave_value arg = args(0);
 
   if (arg.islogical ())
     {
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         {
           SparseBoolMatrix v = arg.sparse_bool_matrix_value ();
 
           retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else if (nargout <= 1 && n_to_find == -1 && direction == 1)
         {
           // This case is equivalent to extracting indices from a logical
@@ -467,17 +467,17 @@ b = sparse (i, j, v, sz(1), sz(2));
       DO_INT_BRANCH (int64)
       DO_INT_BRANCH (uint8)
       DO_INT_BRANCH (uint16)
       DO_INT_BRANCH (uint32)
       DO_INT_BRANCH (uint64)
       else
         panic_impossible ();
     }
-  else if (arg.is_sparse_type ())
+  else if (arg.issparse ())
     {
       if (arg.isreal ())
         {
           SparseMatrix v = arg.sparse_matrix_value ();
 
           retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else if (arg.iscomplex ())
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -262,17 +262,17 @@ static octave_value
 do_simple_gcd (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
   builtin_type_t btyp = btyp_mixed_numeric (a.builtin_type (),
                                             b.builtin_type ());
   switch (btyp)
     {
     case btyp_double:
-      if (a.is_sparse_type () && b.is_sparse_type ())
+      if (a.issparse () && b.issparse ())
         {
           retval = do_simple_gcd<SparseMatrix> (a, b);
           break;
         }
       // fall through!
 
     case btyp_float:
       retval = do_simple_gcd<NDArray> (a, b);
@@ -415,17 +415,17 @@ do_extended_gcd (const octave_value& a, 
       break;
 
     default:
       error ("gcd: invalid class combination for gcd: %s and %s\n",
              a.class_name ().c_str (), b.class_name ().c_str ());
     }
 
   // For consistency.
-  if (a.is_sparse_type () && b.is_sparse_type ())
+  if (a.issparse () && b.issparse ())
     {
       retval = retval.sparse_matrix_value ();
       x = x.sparse_matrix_value ();
       y = y.sparse_matrix_value ();
     }
 
   if (btyp == btyp_float)
     {
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1363,17 +1363,17 @@ public:
       minval (std::pair<double, bool> (octave_NaN, true)),
       maxval (std::pair<double, bool> (octave_NaN, true))
   {
     get_data_limits ();
   }
 
   array_property (const std::string& nm, const graphics_handle& h,
                   const octave_value& m)
-    : base_property (nm, h), data (m.is_sparse_type () ? m.full_value () : m),
+    : base_property (nm, h), data (m.issparse () ? m.full_value () : m),
       xmin (), xmax (), xminp (), xmaxp (),
       type_constraints (), size_constraints (), finite_constraint (NO_CHECK),
       minval (std::pair<double, bool> (octave_NaN, true)),
       maxval (std::pair<double, bool> (octave_NaN, true))
   {
     get_data_limits ();
   }
 
@@ -1441,17 +1441,17 @@ public:
     p->maxval = maxval;
 
     return p;
   }
 
 protected:
   bool do_set (const octave_value& v)
   {
-    octave_value tmp = (v.is_sparse_type () ? v.full_value () : v);
+    octave_value tmp = (v.issparse () ? v.full_value () : v);
 
     if (! validate (tmp))
       error ("invalid value for array property \"%s\"",
              get_name ().c_str ());
 
     // FIXME: should we check for actual data change?
     if (! is_equal (tmp))
       {
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -133,17 +133,17 @@ sparse matrix if possible.
           result = m.inverse (mattyp, info, frcond, 1);
           args(0).matrix_type (mattyp);
         }
     }
   else
     {
       if (arg.isreal ())
         {
-          if (arg.is_sparse_type ())
+          if (arg.issparse ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
               MatrixType mattyp = args(0).matrix_type ();
               result = m.inverse (mattyp, info, rcond, 1);
               args(0).matrix_type (mattyp);
             }
           else
@@ -152,17 +152,17 @@ sparse matrix if possible.
 
               MatrixType mattyp = args(0).matrix_type ();
               result = m.inverse (mattyp, info, rcond, 1);
               args(0).matrix_type (mattyp);
             }
         }
       else if (arg.iscomplex ())
         {
-          if (arg.is_sparse_type ())
+          if (arg.issparse ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
               MatrixType mattyp = args(0).matrix_type ();
               result = m.inverse (mattyp, info, rcond, 1);
               args(0).matrix_type (mattyp);
             }
           else
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -161,17 +161,17 @@ do_kron (const octave_value& a, const oc
 }
 
 octave_value
 dispatch_kron (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
   if (a.is_perm_matrix () && b.is_perm_matrix ())
     retval = do_kron<PermMatrix, PermMatrix> (a, b);
-  else if (a.is_sparse_type () || b.is_sparse_type ())
+  else if (a.issparse () || b.issparse ())
     {
       if (a.iscomplex () || b.iscomplex ())
         retval = do_kron<SparseComplexMatrix, SparseComplexMatrix> (a, b);
       else
         retval = do_kron<SparseMatrix, SparseMatrix> (a, b);
     }
   else if (a.is_diag_matrix ())
     {
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -389,31 +389,31 @@ read_mat_binary_data (std::istream& is, 
 // in the MatLab version 4 binary format.
 
 bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
                       const std::string& name)
 {
   int32_t mopt = 0;
 
-  mopt += tc.is_sparse_type () ? 2 : tc.is_string () ? 1 : 0;
+  mopt += tc.issparse () ? 2 : tc.is_string () ? 1 : 0;
 
   octave::mach_info::float_format flt_fmt =
     octave::mach_info::native_float_format ();;
 
   mopt += 1000 * float_format_to_mopt_digit (flt_fmt);
 
   os.write (reinterpret_cast<char *> (&mopt), 4);
 
   octave_idx_type len;
   int32_t nr = tc.rows ();
 
   int32_t nc = tc.columns ();
 
-  if (tc.is_sparse_type ())
+  if (tc.issparse ())
     {
       len = tc.nnz ();
       uint32_t nnz = len + 1;
       os.write (reinterpret_cast<char *> (&nnz), 4);
 
       uint32_t iscmplx = (tc.iscomplex () ? 4 : 3);
       os.write (reinterpret_cast<char *> (&iscmplx), 4);
 
@@ -475,17 +475,17 @@ save_mat_binary_data (std::ostream& os, 
           os.write (reinterpret_cast<char *> (&x), 8);
         }
     }
   else if (tc.is_real_scalar ())
     {
       double tmp = tc.double_value ();
       os.write (reinterpret_cast<char *> (&tmp), 8);
     }
-  else if (tc.is_sparse_type ())
+  else if (tc.issparse ())
     {
       double ds;
       OCTAVE_LOCAL_BUFFER (double, dtmp, len);
       if (tc.is_complex_matrix ())
         {
           SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
 
           for (octave_idx_type i = 0; i < len; i++)
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -2068,17 +2068,17 @@ save_mat5_element_length (const octave_v
 
   if (tc.is_string ())
     {
       charNDArray chm = tc.char_array_value ();
       ret += 8;
       if (chm.numel () > 2)
         ret += PAD (2 * chm.numel ());
     }
-  else if (tc.is_sparse_type ())
+  else if (tc.issparse ())
     {
       if (tc.iscomplex ())
         {
           const SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
           octave_idx_type nc = m.cols ();
           octave_idx_type nnz = m.nnz ();
 
           ret += 16 + save_mat5_array_length (m.data (), nnz, save_as_floats);
@@ -2251,17 +2251,17 @@ save_mat5_binary_element (std::ostream& 
     {
       if (dv(i) > max_dim_val)
         {
           warn_dim_too_large (name);
           return true;  // skip to next
         }
     }
 
-  if (tc.is_sparse_type ())
+  if (tc.issparse ())
     {
       octave_idx_type nnz;
       octave_idx_type nc;
 
       if (tc.iscomplex ())
         {
           SparseComplexMatrix scm = tc.sparse_complex_matrix_value ();
           nnz = scm.nzmax ();
@@ -2359,17 +2359,17 @@ save_mat5_binary_element (std::ostream& 
   else if (cname == "uint8" || tc.islogical ())
     flags |= MAT_FILE_UINT8_CLASS;
   else if (cname == "uint16")
     flags |= MAT_FILE_UINT16_CLASS;
   else if (cname == "uint32")
     flags |= MAT_FILE_UINT32_CLASS;
   else if (cname == "uint64")
     flags |= MAT_FILE_UINT64_CLASS;
-  else if (tc.is_sparse_type ())
+  else if (tc.issparse ())
     flags |= MAT_FILE_SPARSE_CLASS;
   else if (tc.is_real_scalar () || tc.is_real_matrix () || tc.is_range ()
            || tc.is_complex_scalar () || tc.is_complex_matrix ())
     {
       if (tc.is_single_type ())
         flags |= MAT_FILE_SINGLE_CLASS;
       else
         flags |= MAT_FILE_DOUBLE_CLASS;
@@ -2443,17 +2443,17 @@ save_mat5_binary_element (std::ostream& 
       os.write (reinterpret_cast<char *> (buf), len);
 
       if (paddedlength > len)
         {
           static char padbuf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
           os.write (padbuf, paddedlength - len);
         }
     }
-  else if (tc.is_sparse_type ())
+  else if (tc.issparse ())
     {
       if (tc.iscomplex ())
         {
           const SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
           octave_idx_type nnz = m.nnz ();
           octave_idx_type nc = m.cols ();
 
           write_mat5_sparse_index_vector (os, m.ridx (), nnz);
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -133,17 +133,17 @@ With one output argument @var{y}, then t
 @sc{lapack} routines is returned.  If the input matrix is sparse then the
 matrix @var{L} is embedded into @var{U} to give a return value similar to
 the full case.  For both full and sparse matrices, @code{lu} loses the
 permutation information.
 @seealso{luupdate, ilu, chol, hess, qr, qz, schur, svd}
 @end deftypefn */)
 {
   int nargin = args.length ();
-  bool issparse = (nargin > 0 && args(0).is_sparse_type ());
+  bool issparse = (nargin > 0 && args(0).issparse ());
 
   if (nargin < 1 || (issparse && nargin > 3) || (! issparse && nargin > 2))
     print_usage ();
 
   bool vecout = false;
   Matrix thres;
   int n = 1;
 
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -136,17 +136,17 @@ LU@tie{}factorization.  Once the matrix 
 
   if (args(0).is_scalar_type ())
     {
       if (nargin == 1)
         retval = octave_value ("Diagonal");
       else
         retval = args(0);
     }
-  else if (args(0).is_sparse_type ())
+  else if (args(0).issparse ())
     {
       if (nargin == 1)
         {
           MatrixType mattyp;
 
           if (args(0).iscomplex ())
             {
               mattyp = args(0).matrix_type ();
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -110,17 +110,17 @@ do_minmax_red_op<charNDArray> (const oct
 // Specialization for bool arrays (dense or sparse).
 template <>
 octave_value_list
 do_minmax_red_op<boolNDArray> (const octave_value& arg,
                                int nargout, int dim, bool ismin)
 {
   octave_value_list retval;
 
-  if (! arg.is_sparse_type ())
+  if (! arg.issparse ())
     {
       if (nargout <= 1)
         {
           // This case can be handled using any/all.
           boolNDArray array = arg.bool_array_value ();
 
           if (array.isempty ())
             retval(0) = array;
@@ -283,28 +283,28 @@ do_minmax_body (const octave_value_list&
                 else
                   {
                     retval(0) = range.max ();
                     if (nargout > 1)
                       retval(1) = static_cast<double>
                                   (range.inc () >= 0 ? range.numel () : 1);
                   }
               }
-            else if (arg.is_sparse_type ())
+            else if (arg.issparse ())
               retval = do_minmax_red_op<SparseMatrix> (arg, nargout, dim,
                                                        ismin);
             else
               retval = do_minmax_red_op<NDArray> (arg, nargout, dim, ismin);
 
           }
           break;
 
         case btyp_complex:
           {
-            if (arg.is_sparse_type ())
+            if (arg.issparse ())
               retval = do_minmax_red_op<SparseComplexMatrix> (arg, nargout, dim,
                                                               ismin);
             else
               retval = do_minmax_red_op<ComplexNDArray> (arg, nargout, dim,
                                                          ismin);
           }
           break;
 
@@ -359,30 +359,30 @@ do_minmax_body (const octave_value_list&
       //   rtyp = btyp_bool;
       else
         rtyp = btyp_mixed_numeric (xtyp, ytyp);
 
       switch (rtyp)
         {
         case btyp_double:
           {
-            if ((argx.is_sparse_type ()
-                 && (argy.is_sparse_type () || argy.is_scalar_type ()))
-                || (argy.is_sparse_type () && argx.is_scalar_type ()))
+            if ((argx.issparse ()
+                 && (argy.issparse () || argy.is_scalar_type ()))
+                || (argy.issparse () && argx.is_scalar_type ()))
               retval = do_minmax_bin_op<SparseMatrix> (argx, argy, ismin);
             else
               retval = do_minmax_bin_op<NDArray> (argx, argy, ismin);
           }
           break;
 
         case btyp_complex:
           {
-            if ((argx.is_sparse_type ()
-                 && (argy.is_sparse_type () || argy.is_scalar_type ()))
-                || (argy.is_sparse_type () && argx.is_scalar_type ()))
+            if ((argx.issparse ()
+                 && (argy.issparse () || argy.is_scalar_type ()))
+                || (argy.issparse () && argx.is_scalar_type ()))
               retval = do_minmax_bin_op<SparseComplexMatrix> (argx, argy,
                                                               ismin);
             else
               retval = do_minmax_bin_op<ComplexNDArray> (argx, argy, ismin);
           }
           break;
 
         case btyp_float:
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -233,17 +233,17 @@ public:
   int is_int8 (void) const { return val.is_int8_type (); }
 
   int is_logical (void) const { return val.islogical (); }
 
   int is_numeric (void) const { return val.is_numeric_type (); }
 
   int is_single (void) const { return val.is_single_type (); }
 
-  int is_sparse (void) const { return val.is_sparse_type (); }
+  int is_sparse (void) const { return val.issparse (); }
 
   int is_struct (void) const { return val.is_map (); }
 
   int is_uint16 (void) const { return val.is_uint16_type (); }
 
   int is_uint32 (void) const { return val.is_uint32_type (); }
 
   int is_uint64 (void) const { return val.is_uint64_type (); }
@@ -383,17 +383,17 @@ public:
     return 0;
   }
 
   // Not allowed.
   void set_cell (mwIndex /*idx*/, mxArray * /*val*/) { request_mutation (); }
 
   double get_scalar (void) const
   {
-    if (val.is_sparse_type ())
+    if (val.issparse ())
       {
         // For sparse arrays, return the first non-zero value.
         void *data = val.mex_get_data ();
         if (data == nullptr)
           return 0.0;
 
         if (val.islogical ())
           return *static_cast<bool *> (data);
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -45,17 +45,17 @@ instead.
 @seealso{cond, condest}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_value retval;
 
-  if (args(0).is_sparse_type ())
+  if (args(0).issparse ())
     error ("rcond: for sparse matrices use 'rcond (full (a))' or 'condest (a)' instead");
 
   if (args(0).is_single_type ())
     {
       if (args(0).iscomplex ())
         {
           FloatComplexMatrix m = args(0).float_complex_matrix_value ();
           MatrixType mattyp;
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -46,17 +46,17 @@ DEFUN (issparse, args, ,
 @deftypefn {} {} issparse (@var{x})
 Return true if @var{x} is a sparse matrix.
 @seealso{ismatrix}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  return ovl (args(0).is_sparse_type ());
+  return ovl (args(0).issparse ());
 }
 
 DEFUN (sparse, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{s} =} sparse (@var{a})
 @deftypefnx {} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n})
 @deftypefnx {} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})
 @deftypefnx {} {@var{s} =} sparse (@var{m}, @var{n})
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -210,32 +210,32 @@ do_trilu (const std::string& name,
   else if (k < -dims(0) || k > dims(1))
     error ("%s: requested diagonal out of range", name.c_str ());
 
   octave_value retval;
 
   switch (arg.builtin_type ())
     {
     case btyp_double:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         retval = do_trilu (arg.sparse_matrix_value (), k, lower, pack);
       else
         retval = do_trilu (arg.array_value (), k, lower, pack);
       break;
 
     case btyp_complex:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         retval = do_trilu (arg.sparse_complex_matrix_value (), k, lower,
                            pack);
       else
         retval = do_trilu (arg.complex_array_value (), k, lower, pack);
       break;
 
     case btyp_bool:
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         retval = do_trilu (arg.sparse_bool_matrix_value (), k, lower,
                            pack);
       else
         retval = do_trilu (arg.bool_array_value (), k, lower, pack);
       break;
 
 #define ARRAYCASE(TYP)                                                  \
       case btyp_ ## TYP:                                                \
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1359,17 +1359,17 @@ public:
         global_info(j) = si.is_global;
         persistent_info(j) = si.is_persistent;
 
         octave_value val = si.varval;
 
         size_info(j) = val.size ();
         bytes_info(j) = val.byte_size ();
         class_info(j) = val.class_name ();
-        sparse_info(j) = val.is_sparse_type ();
+        sparse_info(j) = val.issparse ();
         complex_info(j) = val.iscomplex ();
         nesting_info(j) = ni;
       }
 
     octave_map info;
 
     info.assign ("name", name_info);
     info.assign ("size", size_info);
diff --git a/libinterp/corefcn/xnorm.cc b/libinterp/corefcn/xnorm.cc
--- a/libinterp/corefcn/xnorm.cc
+++ b/libinterp/corefcn/xnorm.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "xnorm.h"
 
 octave_value xnorm (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
   bool isvector = (x.columns () == 1 || x.rows () == 1);
   bool iscomplex = x.iscomplex ();
-  bool issparse = x.is_sparse_type ();
+  bool issparse = x.issparse ();
   bool isfloat = x.is_single_type ();
 
   if (! isfloat && ! x.is_double_type ())
     err_wrong_type_arg ("xnorm", x);
 
   if (x.isempty ())
     retval = octave_value (0);
   else if (isvector)
@@ -89,17 +89,17 @@ octave_value xnorm (const octave_value& 
   return retval;
 }
 
 octave_value xcolnorms (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
   bool iscomplex = x.iscomplex ();
-  bool issparse = x.is_sparse_type ();
+  bool issparse = x.issparse ();
   bool isfloat = x.is_single_type ();
 
   if (! isfloat && ! x.is_double_type ())
     err_wrong_type_arg ("xcolnorms", x);
 
   if (issparse)
     {
       if (iscomplex)
@@ -128,17 +128,17 @@ octave_value xcolnorms (const octave_val
   return retval;
 }
 
 octave_value xrownorms (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
   bool iscomplex = x.iscomplex ();
-  bool issparse = x.is_sparse_type ();
+  bool issparse = x.issparse ();
   bool isfloat = x.is_single_type ();
 
   if (! isfloat && ! x.is_double_type ())
     err_wrong_type_arg ("xrownorms", x);
 
   if (issparse)
     {
       if (iscomplex)
@@ -167,17 +167,17 @@ octave_value xrownorms (const octave_val
   return retval;
 }
 
 octave_value xfrobnorm (const octave_value& x)
 {
   octave_value retval;
 
   bool iscomplex = x.iscomplex ();
-  bool issparse = x.is_sparse_type ();
+  bool issparse = x.issparse ();
   bool isfloat = x.is_single_type ();
 
   if (! isfloat && ! x.is_double_type ())
     err_wrong_type_arg ("xfrobnorm", x);
 
   if (issparse)
     {
       if (iscomplex)
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -227,30 +227,30 @@ Undocumented internal function.
       n = args(1).nint_value ();
       arg_offset = 1;
       have_a_fun = true;
     }
   else
     {
       if (args(0).iscomplex ())
         {
-          if (args(0).is_sparse_type ())
+          if (args(0).issparse ())
             {
               ascm = (args(0).sparse_complex_matrix_value ());
               a_is_sparse = true;
             }
           else
             acm = (args(0).complex_matrix_value ());
           a_is_complex = true;
           symmetric = false; // ARPACK doesn't special case complex symmetric
           sym_tested = true;
         }
       else
         {
-          if (args(0).is_sparse_type ())
+          if (args(0).issparse ())
             {
               asmm = (args(0).sparse_matrix_value ());
               a_is_sparse = true;
             }
           else
             {
               amm = (args(0).matrix_value ());
             }
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -353,17 +353,17 @@ Undocumented internal function.
   Array<int> rn;
   Array<int> cn;
   ColumnVector a;
   int mrowsA;
   int nz = 0;
 
   // 2nd Input.  A matrix containing the constraints coefficients.
   // If matrix A is NOT a sparse matrix
-  if (args(1).is_sparse_type ())
+  if (args(1).issparse ())
     {
       SparseMatrix A = args(1).xsparse_matrix_value ("__glpk__: invalid value of A");
 
       mrowsA = A.rows ();
       octave_idx_type Anc = A.cols ();
       octave_idx_type Anz = A.nnz ();
       rn.resize (dim_vector (Anz+1, 1));
       cn.resize (dim_vector (Anz+1, 1));
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -83,17 +83,17 @@ The author of the code itself is Timothy
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_idx_type n_row, n_col;
   const octave::suitesparse_integer *ridx, *cidx;
   SparseMatrix sm;
   SparseComplexMatrix scm;
 
-  if (args(0).is_sparse_type ())
+  if (args(0).issparse ())
     {
       if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           ridx = octave::to_suitesparse_intptr (scm.xridx ());
           cidx = octave::to_suitesparse_intptr (scm.xcidx ());
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -206,17 +206,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
         }
     }
 
   octave_idx_type n_row, n_col, nnz;
   octave_idx_type *ridx, *cidx;
   SparseComplexMatrix scm;
   SparseMatrix sm;
 
-  if (args(0).is_sparse_type ())
+  if (args(0).issparse ())
     {
       if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           nnz = scm.nnz ();
           ridx = scm.xridx ();
@@ -450,17 +450,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
         }
     }
 
   octave_idx_type n_row, n_col;
   octave_idx_type *ridx, *cidx;
   SparseMatrix sm;
   SparseComplexMatrix scm;
 
-  if (args(0).is_sparse_type ())
+  if (args(0).issparse ())
     {
       if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           ridx = scm.xridx ();
           cidx = scm.xcidx ();
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -147,17 +147,17 @@ In general the lower triangular factoriz
 sparse matrices.
 @seealso{hess, lu, qr, qz, schur, svd, ichol, cholinv, chol2inv, cholupdate, cholinsert, choldelete, cholshift}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3 || nargout > 3)
     print_usage ();
-  if (nargout > 2 && ! args(0).is_sparse_type ())
+  if (nargout > 2 && ! args(0).issparse ())
     error ("chol: using three output arguments, matrix A must be sparse");
 
   bool LLt = false;
   bool vecout = false;
 
   int n = 1;
   while (n < nargin)
     {
@@ -174,17 +174,17 @@ sparse matrices.
     }
 
   octave_value_list retval;
   octave_value arg = args(0);
 
   if (arg.isempty ())
     return ovl (Matrix ());
 
-  if (arg.is_sparse_type ())
+  if (arg.issparse ())
     {
       octave_idx_type info;
       bool natural = (nargout != 3);
       bool force = nargout > 1;
 
       if (arg.isreal ())
         {
           SparseMatrix m = arg.sparse_matrix_value ();
@@ -369,17 +369,17 @@ the Cholesky@tie{}factorization.
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 || nc == 0)
     retval = Matrix ();
   else
     {
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         {
           octave_idx_type info;
 
           if (arg.isreal ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
               octave::math::sparse_chol<SparseMatrix> chol (m, info);
@@ -498,17 +498,17 @@ diagonal elements.  @code{chol2inv (@var
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 || nc == 0)
     retval = Matrix ();
   else
     {
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         {
           if (arg.isreal ())
             {
               SparseMatrix r = arg.sparse_matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
           else if (arg.iscomplex ())
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -328,17 +328,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
         }
     }
 
   octave_idx_type n_row, n_col, nnz;
   octave_idx_type *ridx, *cidx;
   SparseComplexMatrix scm;
   SparseMatrix sm;
 
-  if (args(0).is_sparse_type ())
+  if (args(0).issparse ())
     {
       if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           nnz = scm.nnz ();
           ridx = scm.xridx ();
@@ -538,17 +538,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
     octave_stdout << "symamd: dense row/col fraction: "
                   << knobs[COLAMD_DENSE_ROW] << std::endl;
 
   octave_idx_type n_row, n_col;
   octave_idx_type *ridx, *cidx;
   SparseMatrix sm;
   SparseComplexMatrix scm;
 
-  if (args(0).is_sparse_type ())
+  if (args(0).issparse ())
     {
       if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           ridx = scm.xridx ();
           cidx = scm.xcidx ();
@@ -662,17 +662,17 @@ permutations on the tree.
 
   octave_value_list retval (nargout == 2 ? 2 : 1);
 
   octave_idx_type n_row = 0;
   octave_idx_type n_col = 0;
   octave_idx_type *ridx = nullptr;
   octave_idx_type *cidx = nullptr;
 
-  if (args(0).is_sparse_type ())
+  if (args(0).issparse ())
     error ("etree: S must be a sparse matrix");
 
   if (args(0).iscomplex ())
     {
       SparseComplexMatrix scm = args(0).sparse_complex_matrix_value ();
 
       n_row = scm.rows ();
       n_col = scm.cols ();
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -263,17 +263,17 @@ permutation vector instead of a permutat
         err_wrong_type_arg ("qr", args(nargin-1));
       else if (nargin == 3)   // should be caught by is_scalar_type or is_string
         print_usage ();
 
       if (have_b && args(1).iscomplex ())
         is_cmplx = true;
     }
 
-  if (arg.is_sparse_type ())
+  if (arg.issparse ())
     {
       if (nargout > 2)
         error ("qr: Permutation output is not supported for sparse input");
 
       if (is_cmplx)
         {
           octave::math::sparse_qr<SparseComplexMatrix> q (arg.sparse_complex_matrix_value ());
 
diff --git a/libinterp/octave-value/ov-base-sparse.h b/libinterp/octave-value/ov-base-sparse.h
--- a/libinterp/octave-value/ov-base-sparse.h
+++ b/libinterp/octave-value/ov-base-sparse.h
@@ -137,17 +137,17 @@ public:
   MatrixType matrix_type (void) const { return typ; }
   MatrixType matrix_type (const MatrixType& _typ) const
   { MatrixType ret = typ; typ = _typ; return ret; }
 
   bool is_matrix_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
-  bool is_sparse_type (void) const { return true; }
+  bool issparse (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_true (void) const;
 
   OCTAVE_DEPRECATED ("use 'nzmax' instead")
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -420,17 +420,17 @@ public:
   // Would be nice to get rid of the next four functions:
 
   virtual bool is_scalar_type (void) const { return false; }
 
   virtual bool is_matrix_type (void) const { return false; }
 
   virtual bool is_numeric_type (void) const { return false; }
 
-  virtual bool is_sparse_type (void) const { return false; }
+  virtual bool issparse (void) const { return false; }
 
   virtual bool is_true (void) const { return false; }
 
   virtual bool is_null_value (void) const { return false; }
 
   virtual bool is_constant (void) const { return false; }
 
   virtual bool is_function_handle (void) const { return false; }
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -599,17 +599,17 @@ Compatibility Note: Octave accepts compl
   octave_value retval;
 
   octave_value arg = args(0);
 
   if (arg.islogical ())
     retval = arg;
   else if (arg.is_numeric_type ())
     {
-      if (arg.is_sparse_type ())
+      if (arg.issparse ())
         retval = arg.sparse_bool_matrix_value ();
       else if (arg.is_scalar_type ())
         retval = arg.bool_value ();
       else
         retval = arg.bool_array_value ();
     }
   else
     err_wrong_type_arg ("logical", arg);
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -692,18 +692,22 @@ public:
   { return rep->is_scalar_type (); }
 
   bool is_matrix_type (void) const
   { return rep->is_matrix_type (); }
 
   bool is_numeric_type (void) const
   { return rep->is_numeric_type (); }
 
+  bool issparse (void) const
+  { return rep->issparse (); }
+
+  OCTAVE_DEPRECATED ("use 'issparse' instead")
   bool is_sparse_type (void) const
-  { return rep->is_sparse_type (); }
+  { return rep->issparse (); }
 
   // Does this constant correspond to a truth value?
 
   bool is_true (void) const
   { return rep->is_true (); }
 
   // Do two constants match (in a switch statement)?
 
diff --git a/libinterp/parse-tree/pt-tm-const.cc b/libinterp/parse-tree/pt-tm-const.cc
--- a/libinterp/parse-tree/pt-tm-const.cc
+++ b/libinterp/parse-tree/pt-tm-const.cc
@@ -103,24 +103,24 @@ namespace octave
       all_real = false;
 
     if (all_cmplx && ! (val.iscomplex () || val.isreal ()))
       all_cmplx = false;
 
     if (! any_cell && val.iscell ())
       any_cell = true;
 
-    if (! any_sparse && val.is_sparse_type ())
+    if (! any_sparse && val.issparse ())
       any_sparse = true;
 
     if (! any_class && val.is_object ())
       any_class = true;
 
     // Special treatment of sparse matrices to avoid out-of-memory error
-    all_1x1 = all_1x1 && ! val.is_sparse_type () && val.numel () == 1;
+    all_1x1 = all_1x1 && ! val.issparse () && val.numel () == 1;
   }
 
   void
   tm_row_const::tm_row_const_rep::init (const tree_argument_list& row,
                                         tree_evaluator *tw)
   {
     all_str = true;
     all_sq_str = true;
