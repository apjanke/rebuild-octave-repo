# HG changeset patch
# User jwe
# Date 864334767 0
#      Thu May 22 20:59:27 1997 +0000
# Node ID 9d4e3a9de17e53328caac9ba8c4201ec4c117421
# Parent  953ce4558485219bb940af8e2e8bbcd80ee0088e
[project @ 1997-05-22 20:58:07 by jwe]

diff --git a/readline/COPYING b/readline/COPYING
new file mode 100644
--- /dev/null
+++ b/readline/COPYING
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                          675 Mass Ave, Cambridge, MA 02139, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	Appendix: How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/readline/ChangeLog b/readline/ChangeLog
new file mode 100644
--- /dev/null
+++ b/readline/ChangeLog
@@ -0,0 +1,403 @@
+Tue Mar 23 14:36:51 1993  Brian Fox  (bfox@eos.crseo.ucsb.edu)
+
+	* readline.c (rl_copy): Changed name to rl_copy_text.
+
+Mon Mar 22 19:16:05 1993  Brian Fox  (bfox@eos.crseo.ucsb.edu)
+
+	* dispose_cmd.c, several other files. Declare dispose_xxx () as
+	"void".
+
+	* builtins/hashcom.h: Make declarations of hashed_filenames be
+	"extern" to keep the SGI compiler happy.
+
+	* readline.c (rl_initialize_everything): Assign values to
+	out_stream and in_stream immediately, since
+	output_character_function () can be called before
+	readline_internal () is called.
+
+Tue Dec  8 09:30:56 1992  Brian Fox  (bfox@cubit)
+
+	* readline.c (rl_init_terminal) Set PC from BC, not from *buffer.
+
+Mon Nov 30 09:35:47 1992  Brian Fox  (bfox@cubit)
+
+	* readline.c (invoking_keyseqs_in_map, rl_parse_and_bind) Allow
+	backslash to quote characters, such as backslash, double quote,
+	and space. Backslash quotes all character indiscriminately.
+
+	* funmap.c (vi_keymap) Fix type in "vi-replace" declaration.
+
+Fri Nov 20 10:55:05 1992  Brian Fox  (bfox@cubit)
+
+	* readline.c (init_terminal_io, rl_prep_terminal): FINALLY!
+	Declare and use termcap variable `ospeed' when setting up terminal
+	parameters.
+
+Thu Oct  8 08:53:07 1992  Brian J. Fox  (bfox@helios)
+
+	* Makefile, this directory: Include (as links to the canonical
+	sources), tilde.c, tilde.h, posixstat.h and xmalloc.c.
+
+Tue Sep 29 13:07:21 1992  Brian J. Fox  (bfox@helios)
+
+	* readline.c (init_terminal_io) Don't set arrow keys if the key
+	sequences that represent them are already set.
+
+	* readline.c (rl_function_of_keyseq) New function returns the first
+	function (or macro) found while searching a key sequence.
+
+Mon Sep 28 00:34:04 1992  Brian J. Fox  (bfox@helios)
+
+	* readline.c (LibraryVersion) New static char * contains current
+	version number.  Version is at 2.0.
+
+	* readline.c (rl_complete_internal): Incorporated clean changes
+	from gilmore (gnu@cygnus.com) to support quoted substrings within
+	completion functions.
+
+	* readline.c (many locations) Added support for the _GO32_,
+	whatever that is.  Patches supplied by Cygnus, typed in by hand,
+	with cleanups.
+
+Sun Aug 16 12:46:24 1992  Brian Fox  (bfox@cubit)
+
+	* readline.c (init_terminal_io): Find out the values of the keypad
+	arrows and bind them to appropriate RL functions if present.
+
+Mon Aug 10 18:13:24 1992  Brian Fox  (bfox@cubit)
+
+	* history.c (stifle_history): A negative argument to stifle
+	becomes zero.
+
+Tue Jul 28 09:28:41 1992  Brian Fox  (bfox@cubit)
+
+	* readline.c (rl_variable_bind): New local structure describes
+	booleans by name and address; code in rl_variable_bind () looks at
+	structure to set simple variables.
+
+	* parens.c (rl_insert_close): New variable rl_blink_matching_paren
+	is non-zero if we want to blink the matching open when a close is
+	inserted.  If FD_SET is defined, rl_blink_matching_paren defaults
+	to 1, else 0.  If FD_SET is not defined, and
+	rl_blink_matching_paren is non-zero, the close character(s) are/is
+	simply inserted.
+
+Wed Jul 22 20:03:59 1992  Brian Fox  (bfox@cubit)
+
+	* history.c, readline.c, vi_mode.c: Cause the functions strchr ()
+	and strrchr () to be used instead of index () and rindex ()
+	throughout the source.
+
+Mon Jul 13 11:34:07 1992  Brian Fox  (bfox@cubit)
+
+	* readline.c: (rl_variable_bind) New variable "meta-flag" if "on"
+	means force the use of the 8th bit as Meta bit.  Internal variable
+	is called meta_flag.
+
+Thu Jul  9 10:37:56 1992  Brian Fox  (bfox@cubit)
+
+	* history.c (get_history_event) Change INDEX to LOCAL_INDEX.  If
+	compiling for the shell, allow shell metacharacters to separate
+	history tokens as they would for shell tokens.
+
+Sat Jul  4 19:29:12 1992  Brian Fox  (bfox@cubit)
+
+	* vi_keymap.c: According to Posix, TAB self-inserts instead of
+	doing completion.
+
+	* vi_mode.c: (rl_vi_yank_arg) Enter VI insert mode after yanking
+	an arg from the previous line.
+
+	* search.c: New file takes over vi style searching and implements
+	non-incremental searching the history.
+
+	Makefile: Add search.c and search.o.
+
+	funmap.c: Add names for non-incremental-forward-search-history and
+	non-incremental-reverse-search-history.
+
+	readline.h: Add extern definitions for non-incremental searching.
+
+	vi_mode.c: Remove old search code; add calls to code in search.c.
+
+Fri Jul  3 10:36:33 1992  Brian Fox  (bfox@cubit)
+
+	* readline.c (rl_delete_horizontal_space); New function deletes
+	all whitespace surrounding point.
+
+	funmap.c: Add "delete-horizontal-space".
+	emacs_keymap.c: Put rl_delete_horizontal_space () on M-\.
+
+	* readline.c (rl_set_signals, rl_clear_signals); New function
+	rl_set_sighandler () is either defined in a Posix way (if
+	HAVE_POSIX_SIGNALS is defined) or in a BSD way.  Function is
+	called from rl_set_signals () and rl_clear_signals ().
+
+Fri May  8 12:50:15 1992  Brian Fox  (bfox@cubit)
+
+	* readline.c: (readline_default_bindings) Do comparisons with
+	_POSIX_VDISABLE casted to `unsigned char'.  Change tty characters
+	to be unsigned char.
+
+Thu Apr 30 12:36:35 1992  Brian Fox  (bfox@cubit)
+
+	* readline.c: (rl_getc) Handle "read would block" error on
+	non-blocking IO streams.
+
+	* readline.c: (rl_signal_handler): Unblock only the signal that we
+	have caught, not all signals.
+
+Sun Feb 23 03:33:09 1992  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c: Many functions.  Use only the macros META_CHAR and
+	UNMETA to deal with meta characters.  Prior to this, we used
+	numeric values and tests.
+
+	* readline.c (rl_complete_internal) Report exactly the number of
+	possible completions, not the number + 1.
+
+	* vi_mode.c (rl_do_move) Do not change the cursor position when
+	using `cw' or `cW'.
+
+	* vi_mode.c (rl_vi_complete) Enter insert mode after completing
+	with `*' or `\'.
+
+Fri Feb 21 05:58:18 1992  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c (rl_dispatch) Increment rl_key_sequence_length for
+	meta characters that map onto ESC map.
+
+Mon Feb 10 01:41:35 1992  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* history.c (history_do_write) Build a buffer of all of the lines
+	to write and write them in one fell swoop (lower overhead than
+	calling write () for each line).  Suggested by Peter Ho.
+
+	* readline.c: Include hbullx20 as well as hpux for determining
+	USGr3ness.
+
+	* readline.c (rl_unix_word_rubout) As per the "Now REMEMBER"
+	comment, pass arguments to rl_kill_text () in the correct order to
+	preserve prepending and appending of killed text.
+
+	* readline.c (rl_search_history) malloc (), realloc (), and free
+	() SEARCH_STRING so that there are no static limits on searching.
+
+	* vi_mode.c (rl_vi_subst) Don't forget to end the undo group.
+
+Fri Jan 31 14:51:02 1992  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c (rl_signal_handler): Zero the current history entry's
+	pointer after freeing the undo_list when SIGINT received.
+	Reformat a couple of functions.
+
+Sat Jan 25 13:47:35 1992  Brian Fox  (bfox at bears)
+
+        * readline.c (parser_if): free () TNAME after use.
+
+Tue Jan 21 01:01:35 1992  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c (rl_redisplay) and (rl_character_len): Display
+	Control characters as "^c" and Meta characters as "\234", instead
+	of "C-C" and "M-C".
+
+Sun Dec 29 10:59:00 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c (init_terminal_io) Default to environment variables
+	LINES and COLUMNS before termcap entry values.  If all else fails,
+	then assume 80x24 terminal.
+
+Sat Dec 28 16:33:11 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c: If this machine is USG and it is hpux, then define
+	USGr3.
+
+	* history.c: Cosmetic fixes.
+
+Thu Nov 21 00:10:12 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* vi_mode.c: (rl_do_move) Place cursor at end of line, never at
+	next to last character.
+
+Thu Nov 14 05:08:01 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* history.c (get_history_event) Non-anchored searches can have a
+	return index of greater than zero from get_history_event ().
+
+Fri Nov  1 07:02:13 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c (rl_translate_keyseq) Make C-? translate to RUBOUT
+	unconditionally.
+
+Mon Oct 28 11:34:52 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c; Use Posix directory routines and macros.
+
+	* funmap.c; Add entry for call-last-kbd-macro.
+
+	* readline.c (rl_prep_term); Use system EOF character on POSIX
+	systems also.
+
+Thu Oct  3 16:19:53 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c; Make a distinction between having a TERMIOS tty
+	driver, and having POSIX signal handling.  You might one without
+	the other.  New defines used HAVE_POSIX_SIGNALS, and
+	TERMIOS_TTY_DRIVER.
+
+Tue Jul 30 22:37:26 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c: rl_getc () If a call to read () returns without an
+	error, but with zero characters, the file is empty, so return EOF.
+
+Thu Jul 11 20:58:38 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c: (rl_get_next_history, rl_get_previous_history)
+	Reallocate the buffer space if the line being moved to is longer
+	the the current space allocated.  Amazing that no one has found
+	this bug until now.
+
+Sun Jul  7 02:37:05 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c:(rl_parse_and_bind) Allow leading whitespace.
+	  Make sure TERMIO and TERMIOS systems treat CR and NL
+	  disctinctly.
+	
+Tue Jun 25 04:09:27 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c: Rework parsing conditionals to pay attention to the
+	prior states of the conditional stack.  This makes $if statements
+	work correctly.
+
+Mon Jun 24 20:45:59 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c: support for displaying key binding information
+	includes the functions rl_list_funmap_names (),
+	invoking_keyseqs_in_map (), rl_invoking_keyseqs (),
+	rl_dump_functions (), and rl_function_dumper ().
+
+	funmap.c: support for same includes rl_funmap_names ().
+
+	readline.c, funmap.c: no longer define STATIC_MALLOC.  However,
+	update both version of xrealloc () to handle a null pointer.
+
+Thu Apr 25 12:03:49 1991  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* vi_mode.c (rl_vi_fword, fWord, etc.  All functions use
+	the macro `isident()'.  Fixed movement bug which prevents
+	continious movement through the text.
+
+Fri Jul 27 16:47:01 1990  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c (parser_if) Allow "$if term=foo" construct.
+
+Wed May 23 16:10:33 1990  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c (rl_dispatch) Correctly remember the last command
+	executed.  Fixed typo in username_completion_function ().
+
+Mon Apr  9 19:55:48 1990  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c: username_completion_function (); For text passed in
+	with a leading `~', remember that this could be a filename (after
+	it is completed).
+
+Thu Apr  5 13:44:24 1990  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c: rl_search_history (): Correctly handle case of an
+	unfound search string, but a graceful exit (as with ESC).
+
+	* readline.c: rl_restart_output ();  The Apollo passes the address
+	of the file descriptor to TIOCSTART, not the descriptor itself.
+
+Tue Mar 20 05:38:55 1990  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* readline.c: rl_complete (); second call in a row causes possible
+	completions to be listed.
+
+	* readline.c: rl_redisplay (), added prompt_this_line variable
+	which is the first character character following \n in prompt.
+
+Sun Mar 11 04:32:03 1990  Brian Fox  (bfox at gnuwest.fsf.org)
+
+	* Signals are now supposedly handled inside of SYSV compilation.
+
+Wed Jan 17 19:24:09 1990  Brian Fox  (bfox at sbphy.ucsb.edu)
+
+	* history.c: history_expand (); fixed overwriting memory error,
+	added needed argument to call to get_history_event ().
+
+Thu Jan 11 10:54:04 1990  Brian Fox  (bfox at sbphy.ucsb.edu)
+
+	* readline.c: added mark_modified_lines to control the
+	display of an asterisk on modified history lines.  Also
+	added a user variable called mark-modified-lines to the
+	`set' command.
+
+Thu Jan  4 10:38:05 1990  Brian Fox  (bfox at sbphy.ucsb.edu)
+
+	* readline.c: start_insert ().  Only use IC if we don't have an im
+	capability.
+
+Fri Sep  8 09:00:45 1989  Brian Fox  (bfox at aurel)
+
+	* readline.c: rl_prep_terminal ().  Only turn on 8th bit
+	  as meta-bit iff the terminal is not using parity.
+
+Sun Sep  3 08:57:40 1989  Brian Fox  (bfox at aurel)
+
+	* readline.c: start_insert ().  Uses multiple
+	  insertion call in cases where that makes sense.
+
+	  rl_insert ().  Read type-ahead buffer for additional
+	  keys that are bound to rl_insert, and insert them
+	  all at once.  Make insertion of single keys given
+	  with an argument much more efficient.
+
+Tue Aug  8 18:13:57 1989  Brian Fox  (bfox at aurel)
+
+	* readline.c: Changed handling of EOF.  readline () returns
+	 (char *)EOF or consed string.  The EOF character is read from the
+	 tty, or if the tty doesn't have one, defaults to C-d.
+
+	* readline.c: Added support for event driven programs.
+	  rl_event_hook is the address of a function you want called
+	  while Readline is waiting for input.
+
+	* readline.c: Cleanup time.  Functions without type declarations
+	  do not use return with a value.
+
+	* history.c: history_expand () has new variable which is the
+	  characters to ignore immediately following history_expansion_char.
+
+Sun Jul 16 08:14:00 1989  Brian Fox  (bfox at aurel)
+
+	* rl_prep_terminal ()
+	  BSD version turns off C-s, C-q, C-y, C-v.
+
+	* readline.c -- rl_prep_terminal ()
+	  SYSV version hacks readline_echoing_p.
+	  BSD version turns on passing of the 8th bit for the duration
+	  of reading the line.
+
+Tue Jul 11 06:25:01 1989  Brian Fox  (bfox at aurel)
+
+	* readline.c: new variable rl_tilde_expander.
+	  If non-null, this contains the address of a function to call if
+	  the standard meaning for expanding a tilde fails.  The function is
+	  called with the text sans tilde (as in "foo"), and returns a
+	  malloc()'ed string which is the expansion, or a NULL pointer if
+	  there is no expansion. 
+
+	* readline.h - new file chardefs.h
+	  Separates things that only readline.c needs from the standard
+	  header file publishing interesting things about readline.
+
+	* readline.c:
+	  readline_default_bindings () now looks at terminal chararacters
+	  and binds those as well.
+
+Wed Jun 28 20:20:51 1989  Brian Fox  (bfox at aurel)
+
+	* Made readline and history into independent libraries.
+
diff --git a/readline/INSTALL b/readline/INSTALL
new file mode 100644
--- /dev/null
+++ b/readline/INSTALL
@@ -0,0 +1,176 @@
+Basic Installation
+==================
+
+   These are generic installation instructions.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, a file
+`config.cache' that saves the results of its tests to speed up
+reconfiguring, and a file `config.log' containing compiler output
+(useful mainly for debugging `configure').
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If at some point `config.cache'
+contains results you don't want to keep, you may remove or edit it.
+
+   The file `configure.in' is used to create `configure' by a program
+called `autoconf'.  You only need `configure.in' if you want to change
+it or regenerate `configure' using a newer version of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.  If you're
+     using `csh' on an old version of System V, you might need to type
+     `sh ./configure' instead to prevent `csh' from trying to execute
+     `configure' itself.
+
+     Running `configure' takes awhile.  While running, it prints some
+     messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+Compilers and Options
+=====================
+
+   Some systems require unusual options for compilation or linking that
+the `configure' script does not know about.  You can give `configure'
+initial values for variables by setting them in the environment.  Using
+a Bourne-compatible shell, you can do that on the command line like
+this:
+     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure
+
+Or on systems that have the `env' program, you can do it like this:
+     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
+
+Compiling For Multiple Architectures
+====================================
+
+   You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you must use a version of `make' that
+supports the `VPATH' variable, such as GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   If you have to use a `make' that does not supports the `VPATH'
+variable, you have to compile the package for one architecture at a time
+in the source code directory.  After you have installed the package for
+one architecture, use `make distclean' before reconfiguring for another
+architecture.
+
+Installation Names
+==================
+
+   By default, `make install' will install the package's files in
+`/usr/local/bin', `/usr/local/man', etc.  You can specify an
+installation prefix other than `/usr/local' by giving `configure' the
+option `--prefix=PATH'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+give `configure' the option `--exec-prefix=PATH', the package will use
+PATH as the prefix for installing programs and libraries.
+Documentation and other data files will still use the regular prefix.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+   Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+   There may be some features `configure' can not figure out
+automatically, but needs to determine by the type of host the package
+will run on.  Usually `configure' can figure that out, but if it prints
+a message saying it can not guess the host type, give it the
+`--host=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name with three fields:
+     CPU-COMPANY-SYSTEM
+
+See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the host type.
+
+   If you are building compiler tools for cross-compiling, you can also
+use the `--target=TYPE' option to select the type of system they will
+produce code for and the `--build=TYPE' option to select the type of
+system on which you are compiling the package.
+
+Sharing Defaults
+================
+
+   If you want to set default values for `configure' scripts to share,
+you can create a site shell script called `config.site' that gives
+default values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Operation Controls
+==================
+
+   `configure' recognizes the following options to control how it
+operates.
+
+`--cache-file=FILE'
+     Use and save the results of the tests in FILE instead of
+     `./config.cache'.  Set FILE to `/dev/null' to disable caching, for
+     debugging `configure'.
+
+`--help'
+     Print a summary of the options to `configure', and exit.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`--version'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`configure' also accepts some other, not widely useful, options.
+
diff --git a/readline/MANIFEST b/readline/MANIFEST
new file mode 100644
--- /dev/null
+++ b/readline/MANIFEST
@@ -0,0 +1,83 @@
+#
+# Master distribution manifest for the standalone readline distribution
+#
+doc		d
+examples	d
+support		d
+COPYING		f
+README		f
+MANIFEST	f
+INSTALL		f
+aclocal.m4	f
+acconfig.h	f
+config.h.in	f
+configure	f
+configure.in	f
+Makefile.in	f
+ChangeLog	f
+ansi_stdlib.h	f
+chardefs.h	f
+history.h	f
+histlib.h	f
+keymaps.h	f
+posixdir.h	f
+posixjmp.h	f
+posixstat.h	f
+readline.h	f
+rlconf.h	f
+rldefs.h	f
+rltty.h		f
+tcap.h		f
+tilde.h		f
+bind.c		f
+complete.c	f
+display.c	f
+emacs_keymap.c	f
+funmap.c	f
+input.c		f
+isearch.c	f
+keymaps.c	f
+kill.c		f
+macro.c		f
+nls.c		f
+parens.c	f
+readline.c	f
+rltty.c		f
+search.c	f
+shell.c		f
+signals.c	f
+terminal.c	f
+tilde.c		f
+undo.c		f
+util.c		f
+vi_keymap.c	f
+vi_mode.c	f
+callback.c	f
+xmalloc.c	f
+history.c	f
+histexpand.c	f
+histfile.c	f
+histsearch.c	f
+support/config.guess	f
+support/config.sub	f
+support/install.sh	f
+support/mkdirs		f
+support/mkdist		f
+doc/Makefile.in		f
+doc/texinfo.tex		f
+doc/rlman.texinfo	f
+doc/rltech.texinfo	f
+doc/rluser.texinfo	f
+doc/hist.texinfo	f
+doc/hstech.texinfo	f
+doc/hsuser.texinfo	f
+doc/readline.3		f
+doc/texi2dvi		f
+doc/texi2html		f
+examples/Makefile.in	f
+examples/fileman.c	f
+examples/manexamp.c	f
+examples/rltest.c	f
+examples/rl.c		f
+examples/histexamp.c	f
+examples/Inputrc	f
diff --git a/readline/MANIFEST.doc b/readline/MANIFEST.doc
new file mode 100644
--- /dev/null
+++ b/readline/MANIFEST.doc
@@ -0,0 +1,16 @@
+#
+# Master Manifest file for documentation-only distribution
+#
+doc	d
+MANIFEST.doc	f
+doc/readline.ps	f
+doc/history.ps	f
+doc/readline.dvi	f
+doc/history.dvi	f
+doc/readline.info	f
+doc/history.info	f
+doc/readline.html	f
+doc/readline_toc.html	f
+doc/history.html	f
+doc/history_toc.html	f
+doc/readline.0	f
diff --git a/readline/Makefile.in b/readline/Makefile.in
new file mode 100644
--- /dev/null
+++ b/readline/Makefile.in
@@ -0,0 +1,448 @@
+## -*- text -*- ##
+# Master Makefile for the GNU readline library.
+# Copyright (C) 1994 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+RL_LIBRARY_VERSION = @LIBVERSION@
+RL_LIBRARY_NAME = readline
+
+srcdir = @srcdir@
+VPATH = .:@srcdir@
+top_srcdir = @top_srcdir@
+BUILD_DIR = .
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+
+CC = @CC@
+LD = ld			# needed when building shared libraries
+RANLIB = @RANLIB@
+AR = ar
+RM = rm -f
+CP = cp
+MV = mv
+
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+bindir = @bindir@
+libdir = @libdir@
+mandir = @mandir@
+includedir = @includedir@
+
+infodir = @infodir@
+
+man3dir = $(mandir)/man3
+
+SHELL = /bin/sh
+
+# Programs to make tags files.
+ETAGS = etags -tw
+CTAGS = ctags -tw
+
+CFLAGS = @CFLAGS@
+LOCAL_CFLAGS = @LOCAL_CFLAGS@ -DRL_LIBRARY_VERSION='"$(RL_LIBRARY_VERSION)"'
+CPPFLAGS = @CPPFLAGS@
+LDFLAGS = @LDFLAGS@ @LOCAL_LDFLAGS@ @CFLAGS@
+
+DEFS = @DEFS@
+LOCAL_DEFS = @LOCAL_DEFS@
+
+# For libraries which include headers from other libraries.
+INCLUDES = -I. -I$(srcdir) -I$(includedir)
+
+CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES) $(LOCAL_CFLAGS) $(CFLAGS)
+
+# these two options need tweaking for compiler/OS versions other than gcc
+# and SunOS4
+PICFLAG=        -fpic    # -pic for some versions of cc
+SHLIB_OPTS=	-assert pure-text -ldl	# -Bshareable for some versions of gcc
+
+MAJOR=		3
+# shared library systems like SVR4's do not use minor versions
+MINOR=		.0
+
+.SUFFIXES:	.so
+
+.c.o:
+	$(CC) -c $(CCFLAGS) $<
+
+.c.so:
+	-mv $*.o z$*.o
+	$(CC) -c $(PICFLAG) $(CCFLAGS) $< 
+	mv $*.o $@
+	-mv z$*.o $*.o
+
+# The name of the main library target.
+LIBRARY_NAME = libreadline.a
+SHARED_READLINE = libreadline.so.$(MAJOR)$(MINOR)
+SHARED_HISTORY = libhistory.so.$(MAJOR)$(MINOR)
+SHARED_LIBS = $(SHARED_READLINE) $(SHARED_HISTORY)
+
+# The C code source files for this library.
+CSOURCES = $(srcdir)/readline.c $(srcdir)/funmap.c $(srcdir)/keymaps.c \
+	   $(srcdir)/vi_mode.c $(srcdir)/parens.c $(srcdir)/rltty.c \
+	   $(srcdir)/complete.c $(srcdir)/bind.c $(srcdir)/isearch.c \
+	   $(srcdir)/display.c $(srcdir)/signals.c $(srcdir)/emacs_keymap.c \
+	   $(srcdir)/vi_keymap.c $(srcdir)/util.c $(srcdir)/kill.c \
+	   $(srcdir)/undo.c $(srcdir)/macro.c $(srcdir)/input.c \
+	   $(srcdir)/callback.c $(srcdir)/terminal.c $(srcdir)/xmalloc.c \
+	   $(srcdir)/history.c $(srcdir)/histsearch.c $(srcdir)/histexpand.c \
+	   $(srcdir)/histfile.c $(srcdir)/nls.c $(srcdir)/search.c \
+	   $(srcdir)/shell.c $(srcdir)/tilde.c
+
+# The header files for this library.
+HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
+	   posixstat.h posixdir.h posixjmp.h tilde.h rlconf.h rltty.h \
+	   ansi_stdlib.h tcap.h
+
+HISTOBJ = history.o histexpand.o histfile.o histsearch.o shell.o
+TILDEOBJ = tilde.o
+OBJECTS = readline.o vi_mode.o funmap.o keymaps.o parens.o search.o \
+	  rltty.o complete.o bind.o isearch.o display.o signals.o \
+	  util.o kill.o undo.o macro.o input.o callback.o terminal.o \
+	  nls.o xmalloc.o $(HISTOBJ) $(TILDEOBJ) shell.o
+
+SHARED_HISTOBJ = history.so histexpand.so histfile.so histsearch.so shell.so
+SHARED_TILDEOBJ = tilde.so
+SHARED_OBJ = readline.so vi_mode.so funmap.so keymaps.so parens.so search.so \
+	  rltty.so complete.so bind.so isearch.so display.so signals.so \
+	  util.so kill.so undo.so macro.so input.so callback.so terminal.so \
+	  nls.so xmalloc.so $(SHARED_HISTOBJ) $(SHARED_TILDEOBJ)
+
+# The texinfo files which document this library.
+DOCSOURCE = doc/rlman.texinfo doc/rltech.texinfo doc/rluser.texinfo
+DOCOBJECT = doc/readline.dvi
+DOCSUPPORT = doc/Makefile
+DOCUMENTATION = $(DOCSOURCE) $(DOCOBJECT) $(DOCSUPPORT)
+
+CREATED_MAKEFILES = Makefile doc/Makefile examples/Makefile
+
+INSTALLED_HEADERS = readline.h chardefs.h keymaps.h history.h tilde.h
+
+##########################################################################
+
+all: libreadline.a libhistory.a
+shared: $(SHARED_LIBS)
+
+libreadline.a: $(OBJECTS)
+	$(RM) $@
+	$(AR) cr $@ $(OBJECTS)
+	-test -n "$(RANLIB)" && $(RANLIB) $@
+
+libhistory.a: $(HISTOBJ) xmalloc.o
+	$(RM) $@
+	$(AR) cr $@ $(HISTOBJ) xmalloc.o
+	-test -n "$(RANLIB)" && $(RANLIB) $@
+
+$(SHARED_READLINE):	$(SHARED_OBJ)
+	$(RM) $@
+	$(LD) ${SHLIB_OPTS} -o $@ $(SHARED_OBJ)
+
+$(SHARED_HISTORY):	$(SHARED_HISTOBJ) xmalloc.so
+	$(RM) $@
+	$(LD) ${SHLIB_OPTS} -o $@ $(SHARED_HISTOBJ) xmalloc.so
+
+readline: $(OBJECTS) readline.h rldefs.h chardefs.h
+	$(CC) $(CCFLAGS) -o $@ ./examples/rl.c ./libreadline.a -ltermcap
+
+Makefile makefile: config.status $(srcdir)/Makefile.in
+	CONFIG_FILES=Makefile CONFIG_HEADERS= $(SHELL) ./config.status
+
+Makefiles makefiles: config.status $(srcdir)/Makefile.in
+	@for mf in $(CREATED_MAKEFILES); do \
+		CONFIG_FILES=$$mf CONFIG_HEADERS= $(SHELL) ./config.status ; \
+	done
+
+config.status: configure
+	$(SHELL) ./config.status --recheck
+
+config.h:	stamp-h
+
+stamp-h: config.status $(srcdir)/config.h.in
+	CONFIG_FILES= CONFIG_HEADERS=config.h ./config.status
+	echo > $@
+
+$(srcdir)/configure: $(srcdir)/configure.in	## Comment-me-out in distribution
+	cd $(srcdir) && autoconf	## Comment-me-out in distribution
+
+documentation: force
+	-test -d doc || mkdir doc
+	-( cd doc && $(MAKE) $(MFLAGS) )
+
+force:
+
+install: installdirs libreadline.a
+	for f in ${INSTALLED_HEADERS}; do \
+		$(INSTALL_DATA) $(srcdir)/$$f $(includedir)/readline ; \
+	done
+	-$(MV) $(libdir)/libreadline.a $(libdir)/libreadline.old
+	$(INSTALL_DATA) libreadline.a $(libdir)/libreadline.a
+	-test -n "$(RANLIB)" && -$(RANLIB) -t $(libdir)/libreadline.a
+	-( if test -d doc ; then \
+		cd doc && \
+		${MAKE} ${MFLAGS} infodir=$(infodir) INSTALL_DATA=$(INSTALL_DATA) $@; \
+	  fi )
+
+installdirs: $(srcdir)/support/mkdirs
+	-$(SHELL) $(srcdir)/support/mkdirs $(includedir) \
+		$(includedir)/readline $(libdir) $(infodir) $(man3dir)
+
+uninstall:
+	-test -n "$(includedir)" && cd $(includedir)/readline && \
+		${RM} ${INSTALLED_HEADERS}
+	-test -n "$(libdir)" && cd $(libdir) && \
+		${RM} libreadline.a libreadline.old $(SHARED_LIBS)
+
+TAGS:	force
+	$(ETAGS) $(CSOURCES) $(HSOURCES)
+
+tags:	force
+	$(CTAGS) $(CSOURCES) $(HSOURCES)
+
+clean:	force
+	$(RM) $(OBJECTS) *.a
+	$(RM) $(SHARED_OBJ) $(SHARED_LIBS)
+	-( cd doc && $(MAKE) $(MFLAGS) $@ )
+
+mostlyclean: clean
+	-( cd doc && $(MAKE) $(MFLAGS) $@ )
+
+distclean maintainer-clean: clean
+	-( cd doc && $(MAKE) $(MFLAGS) $@ )
+	$(RM) Makefile
+	$(RM) config.status config.h config.cache config.log 
+	$(RM) stamp-config stamp-h
+	$(RM) TAGS tags
+
+info dvi:
+	-( cd doc && $(MAKE) $(MFLAGS) $@ )
+
+install-info:
+check:
+installcheck:
+
+dist:   force
+	@echo Readline distributions are created using $(srcdir)/support/mkdist.
+	@echo Here is a sample of the necessary commands:
+	@echo bash $(srcdir)/support/mkdist -m $(srcdir)/MANIFEST -s $(srcdir) -r $(RL_LIBRARY_NAME)-$(RL_LIBRARY_VERSION)
+	@echo tar cf $(RL_LIBRARY_NAME)-${RL_LIBRARY_VERSION}.tar ${RL_LIBRARY_NAME}-$(RL_LIBRARY_VERSION)
+	@echo gzip $(RL_LIBRARY_NAME)-$(RL_LIBRARY_VERSION).tar
+
+# Tell versions [3.59,3.63) of GNU make not to export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
+
+# Dependencies
+bind.o: ansi_stdlib.h posixstat.h
+bind.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+bind.o: readline.h keymaps.h chardefs.h tilde.h
+bind.o: history.h
+callback.o: rlconf.h
+callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+callback.o: readline.h keymaps.h chardefs.h tilde.h
+complete.o: ansi_stdlib.h posixdir.h posixstat.h
+complete.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+complete.o: readline.h keymaps.h chardefs.h tilde.h
+display.o: ansi_stdlib.h posixstat.h
+display.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+display.o: tcap.h
+display.o: readline.h keymaps.h chardefs.h tilde.h
+display.o: history.h
+funmap.o: readline.h keymaps.h chardefs.h tilde.h
+funmap.o: rlconf.h ansi_stdlib.h
+funmap.o: ${BUILD_DIR}/config.h
+histexpand.o: ansi_stdlib.h
+histexpand.o: history.h histlib.h
+histexpand.o: ${BUILD_DIR}/config.h
+histfile.o: ansi_stdlib.h
+histfile.o: history.h histlib.h
+histfile.o: ${BUILD_DIR}/config.h
+history.o: ansi_stdlib.h
+history.o: history.h histlib.h
+history.o: ${BUILD_DIR}/config.h
+histsearch.o: ansi_stdlib.h
+histsearch.o: history.h histlib.h
+histsearch.o: ${BUILD_DIR}/config.h
+input.o: ansi_stdlib.h
+input.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+input.o: readline.h keymaps.h chardefs.h tilde.h
+isearch.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+isearch.o: readline.h keymaps.h chardefs.h tilde.h
+isearch.o: ansi_stdlib.h history.h
+keymaps.o: emacs_keymap.c vi_keymap.c
+keymaps.o: keymaps.h chardefs.h rlconf.h ansi_stdlib.h
+keymaps.o: readline.h keymaps.h chardefs.h tilde.h
+keymaps.o: ${BUILD_DIR}/config.h
+kill.o: ansi_stdlib.h
+kill.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+kill.o: readline.h keymaps.h chardefs.h tilde.h
+kill.o: history.h
+macro.o: ansi_stdlib.h
+macro.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+macro.o: readline.h keymaps.h chardefs.h tilde.h
+macro.o: history.h
+nls.o: ansi_stdlib.h
+nls.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+parens.o: rlconf.h
+parens.o: ${BUILD_DIR}/config.h
+parens.o: readline.h keymaps.h chardefs.h tilde.h
+readline.o: readline.h keymaps.h chardefs.h tilde.h
+readline.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+readline.o: history.h
+readline.o: posixstat.h ansi_stdlib.h posixjmp.h
+rltty.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+rltty.o: rltty.h
+rltty.o: readline.h keymaps.h chardefs.h tilde.h
+search.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+search.o: readline.h keymaps.h chardefs.h tilde.h
+search.o: ansi_stdlib.h history.h
+signals.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+signals.o: readline.h keymaps.h chardefs.h tilde.h
+signals.o: history.h
+terminal.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+terminal.o: tcap.h
+terminal.o: readline.h keymaps.h chardefs.h tilde.h
+terminal.o: history.h
+tilde.o: ansi_stdlib.h
+tilde.o: ${BUILD_DIR}/config.h
+tilde.o: tilde.h
+undo.o: ansi_stdlib.h
+undo.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+undo.o: readline.h keymaps.h chardefs.h tilde.h
+undo.o: history.h
+util.o: posixjmp.h ansi_stdlib.h
+util.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+util.o: readline.h keymaps.h chardefs.h tilde.h
+vi_mode.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+vi_mode.o: readline.h keymaps.h chardefs.h tilde.h
+vi_mode.o: history.h ansi_stdlib.h
+xmalloc.o: ${BUILD_DIR}/config.h
+xmalloc.o: ansi_stdlib.h
+
+bind.so: ansi_stdlib.h posixstat.h
+bind.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+bind.so: readline.h keymaps.h chardefs.h tilde.h
+bind.so: history.h
+callback.so: rlconf.h
+callback.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+callback.so: readline.h keymaps.h chardefs.h tilde.h
+complete.so: ansi_stdlib.h posixdir.h posixstat.h
+complete.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+complete.so: readline.h keymaps.h chardefs.h tilde.h
+display.so: ansi_stdlib.h posixstat.h
+display.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+display.so: tcap.h
+display.so: readline.h keymaps.h chardefs.h tilde.h
+display.so: history.h
+funmap.so: readline.h keymaps.h chardefs.h tilde.h
+funmap.so: rlconf.h ansi_stdlib.h
+funmap.so: ${BUILD_DIR}/config.h
+histexpand.so: ansi_stdlib.h
+histexpand.so: history.h histlib.h
+histexpand.so: ${BUILD_DIR}/config.h
+histfile.so: ansi_stdlib.h
+histfile.so: history.h histlib.h
+histfile.so: ${BUILD_DIR}/config.h
+history.so: ansi_stdlib.h
+history.so: history.h histlib.h
+history.so: ${BUILD_DIR}/config.h
+histsearch.so: ansi_stdlib.h
+histsearch.so: history.h histlib.h
+histsearch.so: ${BUILD_DIR}/config.h
+input.so: ansi_stdlib.h
+input.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+input.so: readline.h keymaps.h chardefs.h tilde.h
+isearch.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+isearch.so: readline.h keymaps.h chardefs.h tilde.h
+isearch.so: ansi_stdlib.h history.h
+keymaps.so: emacs_keymap.c vi_keymap.c
+keymaps.so: keymaps.h chardefs.h rlconf.h ansi_stdlib.h
+keymaps.so: readline.h keymaps.h chardefs.h tilde.h
+keymaps.so: ${BUILD_DIR}/config.h
+kill.so: ansi_stdlib.h
+kill.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+kill.so: readline.h keymaps.h chardefs.h tilde.h
+kill.so: history.h
+macro.so: ansi_stdlib.h
+macro.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+macro.so: readline.h keymaps.h chardefs.h tilde.h
+macro.so: history.h
+nls.so: ansi_stdlib.h
+nls.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+parens.so: rlconf.h
+parens.so: ${BUILD_DIR}/config.h
+parens.so: readline.h keymaps.h chardefs.h tilde.h
+readline.so: readline.h keymaps.h chardefs.h tilde.h
+readline.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+readline.so: history.h
+readline.so: posixstat.h ansi_stdlib.h posixjmp.h
+rltty.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+rltty.so: rltty.h
+rltty.so: readline.h keymaps.h chardefs.h tilde.h
+search.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+search.so: readline.h keymaps.h chardefs.h tilde.h
+search.so: ansi_stdlib.h history.h
+signals.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+signals.so: readline.h keymaps.h chardefs.h tilde.h
+signals.so: history.h
+terminal.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+terminal.so: tcap.h
+terminal.so: readline.h keymaps.h chardefs.h tilde.h
+terminal.so: history.h
+tilde.so: ansi_stdlib.h
+tilde.so: ${BUILD_DIR}/config.h
+tilde.so: tilde.h
+undo.so: ansi_stdlib.h
+undo.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+undo.so: readline.h keymaps.h chardefs.h tilde.h
+undo.so: history.h
+util.so: posixjmp.h ansi_stdlib.h
+util.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+util.so: readline.h keymaps.h chardefs.h tilde.h
+vi_mode.so: rldefs.h ${BUILD_DIR}/config.h rlconf.h
+vi_mode.so: readline.h keymaps.h chardefs.h tilde.h
+vi_mode.so: history.h ansi_stdlib.h
+xmalloc.so: ${BUILD_DIR}/config.h
+xmalloc.so: ansi_stdlib.h
+
+readline.so: $(srcdir)/readline.c
+vi_mode.so: $(srcdir)/vi_mode.c
+funmap.so: $(srcdir)/funmap.c
+keymaps.so: $(srcdir)/keymaps.c
+parens.so: $(srcdir)/parens.c
+search.so: $(srcdir)/search.c
+rltty.so: $(srcdir)/rltty.c
+complete.so: $(srcdir)/complete.c
+bind.so: $(srcdir)/bind.c
+isearch.so: $(srcdir)/isearch.c
+display.so: $(srcdir)/display.c
+signals.so: $(srcdir)/signals.c
+util.so: $(srcdir)/util.c
+kill.so: $(srcdir)/kill.c
+undo.so: $(srcdir)/undo.c
+macro.so: $(srcdir)/macro.c
+input.so: $(srcdir)/input.c
+callback.so: $(srcdir)/callback.c
+terminal.so: $(srcdir)/terminal.c
+nls.so: $(srcdir)/nls.c
+xmalloc.so: $(srcdir)/xmalloc.c
+history.so: $(srcdir)/history.c
+histexpand.so: $(srcdir)/histexpand.c
+histfile.so: $(srcdir)/histfile.c
+histsearch.so: $(srcdir)/histsearch.c
+shell.so: $(srcdir)/shell.c
+tilde.so: $(srcdir)/tilde.c
diff --git a/readline/README b/readline/README
new file mode 100644
--- /dev/null
+++ b/readline/README
@@ -0,0 +1,112 @@
+Introduction
+============
+
+This is the Gnu Readline library, version 2.1.
+
+The Readline library provides a set of functions for use by applications
+that allow users to edit command lines as they are typed in.  Both
+Emacs and vi editing modes are available.  The Readline library includes
+additional functions to maintain a list of previously-entered command
+lines, to recall and perhaps reedit those lines, and perform csh-like
+history expansion on previous commands.
+
+The history facilites are also placed into a separate library, the
+History library, as part of the build process.  The History library
+may be used without Readline in applications which desire its
+capabilities.
+
+The Readline library is free software, distributed under the terms of
+the GNU Public License, version 2.  For more information, see the file
+COPYING.
+
+To build the library, try typing `./configure', then `make'.  The
+configuration process is automated, so no further intervention should
+be necessary.  Readline builds with `gcc' by default if it is
+available.  If you want to use `cc' instead, type
+
+        CC=cc ./configure
+
+if you are using a Bourne-style shell.  If you are not, the following
+may work:
+
+        env CC=cc ./configure
+
+Read the file INSTALL in this directory for more information about how
+to customize and control the build process.
+
+The file rlconf.h contains defines that enable and disable certain
+Readline features.
+
+Examples
+========
+
+There are several example programs that use Readline features in the
+examples directory.  The `rl' program is of particular interest.  It
+is a command-line interface to Readline, suitable for use in shell
+scripts in place of `read'.
+
+Shared Libraries
+================
+
+There is skeletal support for building shared versions of the
+Readline and History libraries.
+
+Typing `make shared' will cause shared versions of the Readline and
+History libraries to be built on SunOS 4.1.x.  For versions of Unix
+other than SunOS, you will have to make some changes to Makefile.in.
+The relevant variables are:
+
+PICFLAG		Options to give to the compiler to produce position-independent
+		code.  The value `-fpic' works for most versions of gcc.
+SHLIB_OPTS	Options to give to the linker to produce a shared library.
+		The value `-assert pure-text -ldl' works on SunOS 4.1.x.
+		The value `-Bshareable' works for some versions of GNU ld.
+
+MAJOR		The major version number of the shared library.  You should
+		not need to change this.
+MINOR		The minor version number of the shared library.  Some systems,
+		such as SVR4 and its descendents (e.g., Solaris, Unixware),
+		do not use minor version numbers.  For those systems, this
+		variable should be left unset.
+
+LD		The linker.  The value of `ld' is correct for SunOS 4.1.x.
+		You may need to change it to `gcc'; make sure to change
+		SHLIB_OPTS if you do so.
+
+Once you have edited Makefile.in, type `make Makefile' to rebuild the
+Makefile, then `make shared' to build the shared libraries.
+
+Documentation
+=============
+
+The documentation for the Readline and History libraries appears in the
+`doc' subdirectory.  There are two texinfo files and a Unix-style manual
+page describing the programming facilities available in the Readline
+library.  The texinfo files include both user and programmer's manuals.
+
+Reporting Bugs
+==============
+
+Bug reports for Readline should be sent to:
+
+        bug-readline@prep.ai.mit.edu
+
+When reporting a bug, please include the following information:
+
+        * the version number and release status of Readline (e.g., 2.1-release)
+        * the machine and OS that it is running on
+        * a list of the compilation flags or the contents of `config.h', if
+          appropriate
+        * a description of the bug
+        * a recipe for recreating the bug reliably
+        * a fix for the bug if you have one!
+
+If you would like to contact the Readline maintainer directly, send mail
+to bash-maintainers@prep.ai.mit.edu.
+
+Since Readline is developed along with bash, the bug-bash@prep.ai.mit.edu
+mailing list (mirrored to the Usenet newsgroup gnu.bash.bug) often contains
+Readline bug reports and fixes.
+
+Chet Ramey
+chet@po.cwru.edu
diff --git a/readline/acconfig.h b/readline/acconfig.h
new file mode 100644
--- /dev/null
+++ b/readline/acconfig.h
@@ -0,0 +1,30 @@
+/* acconfig.h
+   This file is in the public domain.
+
+   Descriptive text for the C preprocessor macros that
+   the distributed Autoconf macros can define.
+   No software package will use all of them; autoheader copies the ones
+   your configure.in uses into your configuration header file templates.
+
+   The entries are in sort -df order: alphabetical, case insensitive,
+   ignoring punctuation (such as underscores).  Although this order
+   can split up related entries, it makes it easier to check whether
+   a given entry is in the file.
+
+   Leave the following blank line there!!  Autoheader needs it.  */
+
+
+/* Definitions pulled in from aclocal.m4. */
+#undef VOID_SIGHANDLER
+
+#undef TIOCGWINSZ_IN_SYS_IOCTL
+
+#undef TIOCSTAT_IN_SYS_IOCTL
+
+#undef HAVE_GETPW_DECLS
+
+
+/* Leave that blank line there!!  Autoheader needs it.
+   If you're adding to this file, keep in mind:
+   The entries are in sort -df order: alphabetical, case insensitive,
+   ignoring punctuation (such as underscores).  */
diff --git a/readline/aclocal.m4 b/readline/aclocal.m4
new file mode 100644
--- /dev/null
+++ b/readline/aclocal.m4
@@ -0,0 +1,1096 @@
+dnl
+dnl Bash specific tests
+dnl
+dnl Some derived from PDKSH 5.1.3 autoconf tests
+dnl
+dnl
+dnl Check if dup2() does not clear the close on exec flag
+dnl
+AC_DEFUN(BASH_DUP2_CLOEXEC_CHECK,
+[AC_MSG_CHECKING(if dup2 fails to clear the close-on-exec flag)
+AC_CACHE_VAL(bash_cv_dup2_broken,
+[AC_TRY_RUN([
+#include <sys/types.h>
+#include <fcntl.h>
+main()
+{
+  int fd1, fd2, fl;
+  fd1 = open("/dev/null", 2);
+  if (fcntl(fd1, 2, 1) < 0)
+    exit(1);
+  fd2 = dup2(fd1, 1);
+  if (fd2 < 0)
+    exit(2);
+  fl = fcntl(fd2, 1, 0);
+  /* fl will be 1 if dup2 did not reset the close-on-exec flag. */
+  exit(fl != 1);
+}
+], bash_cv_dup2_broken=yes, bash_cv_dup2_broken=no,
+    AC_MSG_ERROR(cannot check dup2 if cross compiling))
+])
+AC_MSG_RESULT($bash_cv_dup2_broken)
+if test $bash_cv_dup2_broken = yes; then
+AC_DEFINE(DUP2_BROKEN)
+fi
+])
+
+dnl Check type of signal routines (posix, 4.2bsd, 4.1bsd or v7)
+AC_DEFUN(BASH_SIGNAL_CHECK,
+[AC_REQUIRE([AC_TYPE_SIGNAL])
+AC_MSG_CHECKING(for type of signal functions)
+AC_CACHE_VAL(bash_cv_signal_vintage,
+[
+  AC_TRY_LINK([#include <signal.h>],[
+    sigset_t ss;
+    struct sigaction sa;
+    sigemptyset(&ss); sigsuspend(&ss);
+    sigaction(SIGINT, &sa, (struct sigaction *) 0);
+    sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
+  ], bash_cv_signal_vintage=posix,
+  [
+    AC_TRY_LINK([#include <signal.h>], [
+	int mask = sigmask(SIGINT);
+	sigsetmask(mask); sigblock(mask); sigpause(mask);
+    ], bash_cv_signal_vintage=4.2bsd,
+    [
+      AC_TRY_LINK([
+	#include <signal.h>
+	RETSIGTYPE foo() { }], [
+		int mask = sigmask(SIGINT);
+		sigset(SIGINT, foo); sigrelse(SIGINT);
+		sighold(SIGINT); sigpause(SIGINT);
+        ], bash_cv_signal_vintage=svr3, bash_cv_signal_vintage=v7
+    )]
+  )]
+)
+])
+AC_MSG_RESULT($bash_cv_signal_vintage)
+if test "$bash_cv_signal_vintage" = posix; then
+AC_DEFINE(HAVE_POSIX_SIGNALS)
+elif test "$bash_cv_signal_vintage" = "4.2bsd"; then
+AC_DEFINE(HAVE_BSD_SIGNALS)
+elif test "$bash_cv_signal_vintage" = svr3; then
+AC_DEFINE(HAVE_USG_SIGHOLD)
+fi
+])
+
+dnl Check if the pgrp of setpgrp() can't be the pid of a zombie process.
+AC_DEFUN(BASH_PGRP_SYNC,
+[AC_REQUIRE([AC_FUNC_GETPGRP])
+AC_MSG_CHECKING(whether pgrps need synchronization)
+AC_CACHE_VAL(bash_cv_pgrp_pipe,
+[AC_TRY_RUN([
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+main()
+{
+# ifdef GETPGRP_VOID
+#  define getpgID()	getpgrp()
+# else
+#  define getpgID()	getpgrp(0)
+#  define setpgid(x,y)	setpgrp(x,y)
+# endif
+	int pid1, pid2, fds[2];
+	int status;
+	char ok;
+
+	switch (pid1 = fork()) {
+	  case -1:
+	    exit(1);
+	  case 0:
+	    setpgid(0, getpid());
+	    exit(0);
+	}
+	setpgid(pid1, pid1);
+
+	sleep(2);	/* let first child die */
+
+	if (pipe(fds) < 0)
+	  exit(2);
+
+	switch (pid2 = fork()) {
+	  case -1:
+	    exit(3);
+	  case 0:
+	    setpgid(0, pid1);
+	    ok = getpgID() == pid1;
+	    write(fds[1], &ok, 1);
+	    exit(0);
+	}
+	setpgid(pid2, pid1);
+
+	close(fds[1]);
+	if (read(fds[0], &ok, 1) != 1)
+	  exit(4);
+	wait(&status);
+	wait(&status);
+	exit(ok ? 0 : 5);
+}
+], bash_cv_pgrp_pipe=no,bash_cv_pgrp_pipe=yes,
+   AC_MSG_ERROR(cannot check pgrp synchronization if cross compiling))
+])
+AC_MSG_RESULT($bash_cv_pgrp_pipe)
+if test $bash_cv_pgrp_pipe = yes; then
+AC_DEFINE(PGRP_PIPE)
+fi
+])
+
+dnl
+dnl check for typedef'd symbols in header files, but allow the caller to
+dnl specify the include files to be checked in addition to the default
+dnl 
+dnl BASH_CHECK_TYPE(TYPE, HEADERS, DEFAULT[, VALUE-IF-FOUND])
+AC_DEFUN(BASH_CHECK_TYPE,
+[AC_REQUIRE([AC_HEADER_STDC])dnl
+AC_MSG_CHECKING(for $1)
+AC_CACHE_VAL(bash_cv_type_$1,
+[AC_EGREP_CPP($1, [#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#endif
+$2
+], bash_cv_type_$1=yes, bash_cv_type_$1=no)])
+AC_MSG_RESULT($bash_cv_type_$1)
+ifelse($#, 4, [if test $bash_cv_type_$1 = yes; then
+	AC_DEFINE($4)
+	fi])
+if test $bash_cv_type_$1 = no; then
+  AC_DEFINE($1, $3)
+fi
+])
+
+dnl
+dnl Type of struct rlimit fields: some systems (OSF/1, NetBSD, RISC/os 5.0)
+dnl have a rlim_t, others (4.4BSD based systems) use quad_t, others use
+dnl long and still others use int (HP-UX 9.01, SunOS 4.1.3).  To simplify
+dnl matters, this just checks for rlim_t, quad_t, or long.
+dnl
+AC_DEFUN(BASH_RLIMIT_TYPE,
+[AC_MSG_CHECKING(for size and type of struct rlimit fields)
+AC_CACHE_VAL(bash_cv_type_rlimit,
+[AC_TRY_COMPILE([#include <sys/types.h>],
+[rlim_t xxx;], bash_cv_type_rlimit=rlim_t,[
+AC_TRY_RUN([
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+main()
+{
+#ifdef HAVE_QUAD_T
+  struct rlimit rl;
+  if (sizeof(rl.rlim_cur) == sizeof(quad_t))
+    exit(0);
+#endif
+  exit(1);
+}], bash_cv_type_rlimit=quad_t, bash_cv_type_rlimit=long,
+        AC_MSG_ERROR(cannot check quad_t if cross compiling))])
+])
+AC_MSG_RESULT($bash_cv_type_rlimit)
+if test $bash_cv_type_rlimit = quad_t; then
+AC_DEFINE(RLIMTYPE, quad_t)
+elif test $bash_cv_type_rlimit = rlim_t; then
+AC_DEFINE(RLIMTYPE, rlim_t)
+fi
+])
+
+dnl
+dnl Check for sys_siglist[] or _sys_siglist[]
+dnl
+AC_DEFUN(BASH_UNDER_SYS_SIGLIST,
+[AC_MSG_CHECKING([for _sys_siglist in system C library])
+AC_CACHE_VAL(bash_cv_under_sys_siglist,
+[AC_TRY_RUN([
+#include <sys/types.h>
+#include <signal.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifndef _sys_siglist
+extern char *_sys_siglist[];
+#endif
+main()
+{
+char *msg = _sys_siglist[2];
+exit(msg == 0);
+}],
+bash_cv_under_sys_siglist=yes, bash_cv_under_sys_siglist=no,
+AC_MSG_ERROR(cannot check for _sys_siglist[] if cross compiling))])dnl
+AC_MSG_RESULT($bash_cv_under_sys_siglist)
+if test $bash_cv_under_sys_siglist = yes; then
+AC_DEFINE(HAVE_UNDER_SYS_SIGLIST)
+fi
+])
+
+AC_DEFUN(BASH_SYS_SIGLIST,
+[AC_REQUIRE([AC_DECL_SYS_SIGLIST])
+AC_MSG_CHECKING([for sys_siglist in system C library])
+AC_CACHE_VAL(bash_cv_sys_siglist,
+[AC_TRY_RUN([
+#include <sys/types.h>
+#include <signal.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifndef SYS_SIGLIST_DECLARED
+extern char *sys_siglist[];
+#endif
+main()
+{
+char *msg = sys_siglist[2];
+exit(msg == 0);
+}],
+bash_cv_sys_siglist=yes, bash_cv_sys_siglist=no,
+AC_MSG_ERROR(cannot check for sys_siglist if cross compiling))])dnl
+AC_MSG_RESULT($bash_cv_sys_siglist)
+if test $bash_cv_sys_siglist = yes; then
+AC_DEFINE(HAVE_SYS_SIGLIST)
+fi
+])
+
+dnl Check for sys_errlist[] and sys_nerr, check for declaration
+AC_DEFUN(BASH_SYS_ERRLIST,
+[AC_MSG_CHECKING([for sys_errlist and sys_nerr])
+AC_CACHE_VAL(bash_cv_sys_errlist,
+[AC_TRY_LINK([#include <errno.h>],
+[extern char *sys_errlist[];
+ extern int sys_nerr;
+ char *msg = sys_errlist[sys_nerr - 1];],
+    bash_cv_sys_errlist=yes, bash_cv_sys_errlist=no)])dnl
+AC_MSG_RESULT($bash_cv_sys_errlist)
+if test $bash_cv_sys_errlist = yes; then
+AC_DEFINE(HAVE_SYS_ERRLIST)
+fi
+])
+
+dnl Check to see if opendir will open non-directories (not a nice thing)
+AC_DEFUN(BASH_FUNC_OPENDIR_CHECK,
+[AC_REQUIRE([AC_HEADER_DIRENT])dnl
+AC_MSG_CHECKING(if opendir() opens non-directories)
+AC_CACHE_VAL(bash_cv_opendir_not_robust,
+[AC_TRY_RUN([
+#include <stdio.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+#if defined(HAVE_DIRENT_H)
+# include <dirent.h>
+#else
+# define dirent direct
+# ifdef HAVE_SYS_NDIR_H
+#  include <sys/ndir.h>
+# endif /* SYSNDIR */
+# ifdef HAVE_SYS_DIR_H
+#  include <sys/dir.h>
+# endif /* SYSDIR */
+# ifdef HAVE_NDIR_H
+#  include <ndir.h>
+# endif
+#endif /* HAVE_DIRENT_H */
+main()
+{
+DIR *dir;
+int fd;
+unlink("/tmp/not_a_directory");
+fd = open("/tmp/not_a_directory", O_WRONLY|O_CREAT, 0666);
+write(fd, "\n", 1);
+close(fd);
+dir = opendir("/tmp/not_a_directory");
+unlink("/tmp/not_a_directory");
+exit (dir == 0);
+}], bash_cv_opendir_not_robust=yes,bash_cv_opendir_not_robust=no,
+    AC_MSG_ERROR(cannot check opendir if cross compiling))])
+AC_MSG_RESULT($bash_cv_opendir_not_robust)
+if test $bash_cv_opendir_not_robust = yes; then
+AC_DEFINE(OPENDIR_NOT_ROBUST)
+fi
+])
+
+dnl
+AC_DEFUN(BASH_TYPE_SIGHANDLER,
+[AC_MSG_CHECKING([whether signal handlers are of type void])
+AC_CACHE_VAL(bash_cv_void_sighandler,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+#undef signal
+#endif
+#ifdef __cplusplus
+extern "C"
+#endif
+void (*signal ()) ();],
+[int i;], bash_cv_void_sighandler=yes, bash_cv_void_sighandler=no)])dnl
+AC_MSG_RESULT($bash_cv_void_sighandler)
+if test $bash_cv_void_sighandler = yes; then
+AC_DEFINE(VOID_SIGHANDLER)
+fi
+])
+
+AC_DEFUN(BASH_FUNC_STRSIGNAL,
+[AC_MSG_CHECKING([for the existance of strsignal])
+AC_CACHE_VAL(bash_cv_have_strsignal,
+[AC_TRY_LINK([#include <sys/types.h>
+#include <signal.h>],
+[char *s = (char *)strsignal(2);],
+ bash_cv_have_strsignal=yes, bash_cv_have_strsignal=no)])
+AC_MSG_RESULT($bash_cv_have_strsignal)
+if test $bash_cv_have_strsignal = yes; then
+AC_DEFINE(HAVE_STRSIGNAL)
+fi
+])
+
+AC_DEFUN(BASH_FUNC_LSTAT,
+[dnl Cannot use AC_CHECK_FUNCS(lstat) because Linux defines lstat() as an
+dnl inline function in <sys/stat.h>.
+AC_CACHE_CHECK([for lstat], bash_cv_func_lstat,
+[AC_TRY_LINK([
+#include <sys/types.h>
+#include <sys/stat.h>
+],[ lstat("",(struct stat *)0); ],
+bash_cv_func_lstat=yes, bash_cv_func_lstat=no)])
+if test $bash_cv_func_lstat = yes; then
+  AC_DEFINE(HAVE_LSTAT)
+fi
+])
+
+AC_DEFUN(BASH_STRUCT_TERMIOS_LDISC,
+[AC_MSG_CHECKING([for a c_line member of struct termios])
+AC_CACHE_VAL(bash_cv_termios_ldisc,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <termios.h>],[struct termios t; int i; i = t.c_line;],
+  bash_cv_termios_ldisc=yes, bash_cv_termios_ldisc=no)])dnl
+AC_MSG_RESULT($bash_cv_termios_ldisc)
+if test $bash_cv_termios_ldisc = yes; then
+AC_DEFINE(TERMIOS_LDISC)
+fi
+])
+
+AC_DEFUN(BASH_STRUCT_TERMIO_LDISC,
+[AC_MSG_CHECKING([for a c_line member of struct termio])
+AC_CACHE_VAL(bash_cv_termio_ldisc,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <termio.h>],[struct termio t; int i; i = t.c_line;],
+  bash_cv_termio_ldisc=yes, bash_cv_termio_ldisc=no)])dnl
+AC_MSG_RESULT($bash_cv_termio_ldisc)
+if test $bash_cv_termio_ldisc = yes; then
+AC_DEFINE(TERMIO_LDISC)
+fi
+])
+
+AC_DEFUN(BASH_FUNC_GETENV,
+[AC_MSG_CHECKING(to see if getenv can be redefined)
+AC_CACHE_VAL(bash_cv_getenv_redef,
+[AC_TRY_RUN([
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+#ifndef __STDC__
+#  ifndef const
+#    define const
+#  endif
+#endif
+char *
+getenv (name)
+#if defined (__linux__) || defined (__bsdi__) || defined (convex)
+     const char *name;
+#else
+     char const *name;
+#endif /* !__linux__ && !__bsdi__ && !convex */
+{
+return "42";
+}
+main()
+{
+char *s;
+/* The next allows this program to run, but does not allow bash to link
+   when it redefines getenv.  I'm not really interested in figuring out
+   why not. */
+#if defined (NeXT)
+exit(1);
+#endif
+s = getenv("ABCDE");
+exit(s == 0);	/* force optimizer to leave getenv in */
+}
+], bash_cv_getenv_redef=yes, bash_cv_getenv_redef=no,
+AC_MSG_ERROR(cannot check getenv redefinition if cross compiling))])
+AC_MSG_RESULT($bash_cv_getenv_redef)
+if test $bash_cv_getenv_redef = yes; then
+AC_DEFINE(CAN_REDEFINE_GETENV)
+fi
+])
+
+AC_DEFUN(BASH_FUNC_PRINTF,
+[AC_MSG_CHECKING(for declaration of printf in <stdio.h>)
+AC_CACHE_VAL(bash_cv_printf_declared,
+[AC_TRY_RUN([
+#include <stdio.h>
+#ifdef __STDC__
+typedef int (*_bashfunc)(const char *, ...);
+#else
+typedef int (*_bashfunc)();
+#endif
+main()
+{
+_bashfunc pf;
+pf = printf;
+exit(pf == 0);
+}
+],bash_cv_printf_declared=yes, bash_cv_printf_declared=no,
+AC_MSG_ERROR(cannot check printf declaration if cross compiling))])
+AC_MSG_RESULT($bash_cv_printf_declared)
+if test $bash_cv_printf_declared = yes; then
+AC_DEFINE(PRINTF_DECLARED)
+fi
+])
+
+AC_DEFUN(BASH_FUNC_ULIMIT_MAXFDS,
+[AC_MSG_CHECKING(whether ulimit can substitute for getdtablesize)
+AC_CACHE_VAL(bash_cv_ulimit_maxfds,
+[AC_TRY_RUN([
+main()
+{
+long maxfds = ulimit(4, 0L);
+exit (maxfds == -1L);
+}
+],bash_cv_ulimit_maxfds=yes, bash_cv_ulimit_maxfds=no,
+AC_MSG_ERROR(cannot check ulimit if cross compiling))])
+AC_MSG_RESULT($bash_cv_ulimit_maxfds)
+if test $bash_cv_ulimit_maxfds = yes; then
+AC_DEFINE(ULIMIT_MAXFDS)
+fi
+])
+
+AC_DEFUN(BASH_CHECK_LIB_TERMCAP,
+[
+if test "X$bash_cv_termcap_lib" = "X"; then
+_bash_needmsg=yes
+else
+AC_MSG_CHECKING(which library has the termcap functions)
+_bash_needmsg=
+fi
+AC_CACHE_VAL(bash_cv_termcap_lib,
+[AC_CHECK_LIB(termcap, tgetent, bash_cv_termcap_lib=libtermcap,
+    [AC_CHECK_LIB(curses, tgetent, bash_cv_termcap_lib=libcurses,
+	[AC_CHECK_LIB(ncurses, tgetent, bash_cv_termcap_lib=libncurses,
+	    bash_cv_termcap_lib=gnutermcap)])])])
+if test "X$_bash_needmsg" = "Xyes"; then
+AC_MSG_CHECKING(which library has the termcap functions)
+fi
+AC_MSG_RESULT(using $bash_cv_termcap_lib)
+if test $bash_cv_termcap_lib = gnutermcap; then
+LDFLAGS="$LDFLAGS -L./lib/termcap"
+TERMCAP_LIB="./lib/termcap/libtermcap.a"
+TERMCAP_DEP="./lib/termcap/libtermcap.a"
+elif test $bash_cv_termcap_lib = libtermcap && test -z "$prefer_curses"; then
+TERMCAP_LIB=-ltermcap
+TERMCAP_DEP=
+elif test $bash_cv_termcap_lib = libncurses; then
+TERMCAP_LIB=-lncurses
+TERMCAP_DEP=
+else
+TERMCAP_LIB=-lcurses
+TERMCAP_DEP=
+fi
+])
+
+AC_DEFUN(BASH_FUNC_GETCWD,
+[AC_MSG_CHECKING([if getcwd() calls popen()])
+AC_CACHE_VAL(bash_cv_getcwd_calls_popen,
+[AC_TRY_RUN([
+#include <stdio.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#ifndef __STDC__
+#ifndef const
+#define const
+#endif
+#endif
+
+int popen_called;
+
+FILE *
+popen(command, type)
+     const char *command;
+     const char *type;
+{
+	popen_called = 1;
+	return (FILE *)NULL;
+}
+
+FILE *_popen(command, type)
+     const char *command;
+     const char *type;
+{
+  return (popen (command, type));
+}
+
+int
+pclose(stream)
+FILE *stream;
+{
+	return 0;
+}
+
+int
+_pclose(stream)
+FILE *stream;
+{
+	return 0;
+}
+
+main()
+{
+	char	lbuf[32];
+	popen_called = 0;
+	getcwd(lbuf, 32);
+	exit (popen_called);
+}
+], bash_cv_getcwd_calls_popen=no, bash_cv_getcwd_calls_popen=yes,
+AC_MSG_ERROR(cannot check whether getcwd calls popen if cross compiling))])
+AC_MSG_RESULT($bash_cv_getcwd_calls_popen)
+if test $bash_cv_getcwd_calls_popen = yes; then
+AC_DEFINE(GETCWD_BROKEN)
+fi
+])
+
+AC_DEFUN(BASH_STRUCT_DIRENT_D_INO,
+[AC_REQUIRE([AC_HEADER_DIRENT])
+AC_MSG_CHECKING(if struct dirent has a d_ino member)
+AC_CACHE_VAL(bash_cv_dirent_has_dino,
+[AC_TRY_COMPILE([
+#include <stdio.h>
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+#if defined(HAVE_DIRENT_H)
+# include <dirent.h>
+#else
+# define dirent direct
+# ifdef HAVE_SYS_NDIR_H
+#  include <sys/ndir.h>
+# endif /* SYSNDIR */
+# ifdef HAVE_SYS_DIR_H
+#  include <sys/dir.h>
+# endif /* SYSDIR */
+# ifdef HAVE_NDIR_H
+#  include <ndir.h>
+# endif
+#endif /* HAVE_DIRENT_H */
+],[
+struct dirent d; int z; z = d.d_ino;
+], bash_cv_dirent_has_dino=yes, bash_cv_dirent_has_dino=no)])
+AC_MSG_RESULT($bash_cv_dirent_has_dino)
+if test $bash_cv_dirent_has_dino = yes; then
+AC_DEFINE(STRUCT_DIRENT_HAS_D_INO)
+fi
+])
+
+AC_DEFUN(BASH_STRUCT_DIRENT_D_FILENO,
+[AC_REQUIRE([AC_HEADER_DIRENT])
+AC_MSG_CHECKING(if struct dirent has a d_fileno member)
+AC_CACHE_VAL(bash_cv_dirent_has_d_fileno,
+[AC_TRY_COMPILE([
+#include <stdio.h>
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+#if defined(HAVE_DIRENT_H)
+# include <dirent.h>
+#else
+# define dirent direct
+# ifdef HAVE_SYS_NDIR_H
+#  include <sys/ndir.h>
+# endif /* SYSNDIR */
+# ifdef HAVE_SYS_DIR_H
+#  include <sys/dir.h>
+# endif /* SYSDIR */
+# ifdef HAVE_NDIR_H
+#  include <ndir.h>
+# endif
+#endif /* HAVE_DIRENT_H */
+],[
+struct dirent d; int z; z = d.d_fileno;
+], bash_cv_dirent_has_d_fileno=yes, bash_cv_dirent_has_d_fileno=no)])
+AC_MSG_RESULT($bash_cv_dirent_has_d_fileno)
+if test $bash_cv_dirent_has_d_fileno = yes; then
+AC_DEFINE(STRUCT_DIRENT_HAS_D_FILENO)
+fi
+])
+
+AC_DEFUN(BASH_REINSTALL_SIGHANDLERS,
+[AC_REQUIRE([AC_TYPE_SIGNAL])
+AC_REQUIRE([BASH_SIGNAL_CHECK])
+AC_MSG_CHECKING([if signal handlers must be reinstalled when invoked])
+AC_CACHE_VAL(bash_cv_must_reinstall_sighandlers,
+[AC_TRY_RUN([
+#include <signal.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+typedef RETSIGTYPE sigfunc();
+
+int nsigint;
+
+#ifdef HAVE_POSIX_SIGNALS
+sigfunc *
+set_signal_handler(sig, handler)
+     int sig;
+     sigfunc *handler;
+{
+  struct sigaction act, oact;
+  act.sa_handler = handler;
+  act.sa_flags = 0;
+  sigemptyset (&act.sa_mask);
+  sigemptyset (&oact.sa_mask);
+  sigaction (sig, &act, &oact);
+  return (oact.sa_handler);
+}
+#else
+#define set_signal_handler(s, h) signal(s, h)
+#endif
+
+RETSIGTYPE
+sigint(s)
+int s;
+{
+  nsigint++;
+}
+
+main()
+{
+	nsigint = 0;
+	set_signal_handler(SIGINT, sigint);
+	kill((int)getpid(), SIGINT);
+	kill((int)getpid(), SIGINT);
+	exit(nsigint != 2);
+}
+], bash_cv_must_reinstall_sighandlers=no, bash_cv_must_reinstall_sighandlers=yes,
+AC_MSG_ERROR(cannot check signal handling if cross compiling))])
+AC_MSG_RESULT($bash_cv_must_reinstall_sighandlers)
+if test $bash_cv_must_reinstall_sighandlers = yes; then
+AC_DEFINE(MUST_REINSTALL_SIGHANDLERS)
+fi
+])
+
+AC_DEFUN(BASH_FUNC_SBRK_DECLARED,
+[AC_MSG_CHECKING(for declaration of sbrk in <unistd.h>)
+AC_CACHE_VAL(bash_cv_sbrk_declared,
+[AC_EGREP_HEADER(sbrk, unistd.h,
+ bash_cv_sbrk_declared=yes, bash_cv_sbrk_declared=no)])
+AC_MSG_RESULT($bash_cv_sbrk_declared)
+if test $bash_cv_sbrk_declared = yes; then
+AC_DEFINE(SBRK_DECLARED)
+fi
+])
+
+dnl check that some necessary job control definitions are present
+AC_DEFUN(BASH_JOB_CONTROL_MISSING,
+[AC_REQUIRE([BASH_SIGNAL_CHECK])
+AC_MSG_CHECKING(for presence of necessary job control definitions)
+AC_CACHE_VAL(bash_cv_job_control_missing,
+[AC_TRY_RUN([
+#include <sys/types.h>
+#ifdef HAVE_SYS_WAIT_H
+#include <sys/wait.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <signal.h>
+
+/* Add more tests in here as appropriate. */
+main()
+{
+/* signal type */
+#if !defined (HAVE_POSIX_SIGNALS) && !defined (HAVE_BSD_SIGNALS)
+exit(1);
+#endif
+
+/* signals and tty control. */
+#if !defined (SIGTSTP) || !defined (SIGSTOP) || !defined (SIGCONT)
+exit (1);
+#endif
+
+/* process control */
+#if !defined (WNOHANG) || !defined (WUNTRACED) 
+exit(1);
+#endif
+
+/* Posix systems have tcgetpgrp and waitpid. */
+#if defined (_POSIX_VERSION) && !defined (HAVE_TCGETPGRP)
+exit(1);
+#endif
+
+#if defined (_POSIX_VERSION) && !defined (HAVE_WAITPID)
+exit(1);
+#endif
+
+/* Other systems have TIOCSPGRP/TIOCGPRGP and wait3. */
+#if !defined (_POSIX_VERSION) && !defined (HAVE_WAIT3)
+exit(1);
+#endif
+
+exit(0);
+}],bash_cv_job_control_missing=present, bash_cv_job_control_missing=missing,
+	AC_MSG_ERROR(cannot check job control if cross-compiling))
+])
+AC_MSG_RESULT($bash_cv_job_control_missing)
+if test $bash_cv_job_control_missing = missing; then
+AC_DEFINE(JOB_CONTROL_MISSING)
+fi
+])
+
+dnl check whether named pipes are present
+dnl this requires a previous check for mkfifo, but that is awkward to specify
+AC_DEFUN(BASH_SYS_NAMED_PIPES,
+[AC_MSG_CHECKING(for presence of named pipes)
+AC_CACHE_VAL(bash_cv_sys_named_pipes,
+[AC_TRY_RUN([
+#include <sys/types.h>
+#include <sys/stat.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+/* Add more tests in here as appropriate. */
+main()
+{
+int fd;
+
+#if defined (HAVE_MKFIFO)
+exit (0);
+#endif
+
+#if !defined (S_IFIFO) && (defined (_POSIX_VERSION) && !defined (S_ISFIFO))
+exit (1);
+#endif
+
+#if defined (NeXT)
+exit (1);
+#endif
+
+fd = mknod ("/tmp/sh-np-autoconf", 0666 | S_IFIFO, 0);
+if (fd == -1)
+  exit (1);
+close(fd);
+unlink ("/tmp/sh-np-autoconf");
+exit(0);
+}],bash_cv_sys_named_pipes=present, bash_cv_sys_named_pipes=missing,
+	AC_MSG_ERROR(cannot check for named pipes if cross-compiling))
+])
+AC_MSG_RESULT($bash_cv_sys_named_pipes)
+if test $bash_cv_sys_named_pipes = missing; then
+AC_DEFINE(NAMED_PIPES_MISSING)
+fi
+])
+
+AC_DEFUN(BASH_FUNC_POSIX_SETJMP,
+[AC_REQUIRE([BASH_SIGNAL_CHECK])
+AC_MSG_CHECKING(for presence of POSIX-style sigsetjmp/siglongjmp)
+AC_CACHE_VAL(bash_cv_func_sigsetjmp,
+[AC_TRY_RUN([
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <sys/types.h>
+#include <signal.h>
+#include <setjmp.h>
+
+main()
+{
+#if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
+exit (1);
+#else
+
+int code;
+sigset_t set, oset;
+sigjmp_buf xx;
+
+/* get the mask */
+sigemptyset(&set);
+sigemptyset(&oset);
+sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &set);
+sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
+
+/* save it */
+code = sigsetjmp(xx, 1);
+if (code)
+  exit(0);	/* could get sigmask and compare to oset here. */
+
+/* change it */
+sigaddset(&set, SIGINT);
+sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
+
+/* and siglongjmp */
+siglongjmp(xx, 10);
+exit(1);
+#endif
+}],bash_cv_func_sigsetjmp=present, bash_cv_func_sigsetjmp=missing,
+   AC_MSG_ERROR(cannot check for sigsetjmp/siglongjmp if cross-compiling))
+])
+AC_MSG_RESULT($bash_cv_func_sigsetjmp)
+if test $bash_cv_func_sigsetjmp = present; then
+AC_DEFINE(HAVE_POSIX_SIGSETJMP)
+fi
+])
+
+AC_DEFUN(BASH_HAVE_TIOCGWINSZ,
+[AC_MSG_CHECKING(for TIOCGWINSZ in sys/ioctl.h)
+AC_CACHE_VAL(bash_cv_tiocgwinsz_in_ioctl,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <sys/ioctl.h>], [int x = TIOCGWINSZ;],
+  bash_cv_tiocgwinsz_in_ioctl=yes,bash_cv_tiocgwinsz_in_ioctl=no)])
+AC_MSG_RESULT($bash_cv_tiocgwinsz_in_ioctl)
+if test $bash_cv_tiocgwinsz_in_ioctl = yes; then   
+AC_DEFINE(GWINSZ_IN_SYS_IOCTL)
+fi
+])
+
+AC_DEFUN(BASH_STRUCT_WINSIZE,
+[AC_MSG_CHECKING(for struct winsize in sys/ioctl.h)
+AC_CACHE_VAL(bash_cv_struct_winsize_in_ioctl,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <sys/ioctl.h>], [struct winsize x;],
+  bash_cv_struct_winsize_in_ioctl=yes,bash_cv_struct_winsize_in_ioctl=no)])
+AC_MSG_RESULT($bash_cv_struct_winsize_in_ioctl)
+if test $bash_cv_struct_winsize_in_ioctl = yes; then   
+AC_DEFINE(STRUCT_WINSIZE_IN_SYS_IOCTL)
+fi
+])
+
+AC_DEFUN(BASH_HAVE_TIOCSTAT,
+[AC_MSG_CHECKING(for TIOCSTAT in sys/ioctl.h)
+AC_CACHE_VAL(bash_cv_tiocstat_in_ioctl,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <sys/ioctl.h>], [int x = TIOCSTAT;],
+  bash_cv_tiocstat_in_ioctl=yes,bash_cv_tiocstat_in_ioctl=no)])
+AC_MSG_RESULT($bash_cv_tiocstat_in_ioctl)
+if test $bash_cv_tiocstat_in_ioctl = yes; then   
+AC_DEFINE(TIOCSTAT_IN_SYS_IOCTL)
+fi
+])
+
+AC_DEFUN(BASH_HAVE_FIONREAD,
+[AC_MSG_CHECKING(for FIONREAD in sys/ioctl.h)
+AC_CACHE_VAL(bash_cv_fionread_in_ioctl,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <sys/ioctl.h>], [int x = FIONREAD;],
+  bash_cv_fionread_in_ioctl=yes,bash_cv_fionread_in_ioctl=no)])
+AC_MSG_RESULT($bash_cv_fionread_in_ioctl)
+if test $bash_cv_fionread_in_ioctl = yes; then   
+AC_DEFINE(FIONREAD_IN_SYS_IOCTL)
+fi
+])
+
+dnl
+dnl See if speed_t is declared in <sys/types.h>.  Some versions of linux
+dnl require a definition of speed_t each time <termcap.h> is included,
+dnl but you can only get speed_t if you include <termios.h> (on some
+dnl versions) or <sys/types.h> (on others).
+dnl
+AC_DEFUN(BASH_MISC_SPEED_T,
+[AC_MSG_CHECKING(for speed_t in sys/types.h)
+AC_CACHE_VAL(bash_cv_speed_t_in_sys_types,
+[AC_TRY_COMPILE([#include <sys/types.h>], [speed_t x;],
+  bash_cv_speed_t_in_sys_types=yes,bash_cv_speed_t_in_sys_types=no)])
+AC_MSG_RESULT($bash_cv_speed_t_in_sys_types)
+if test $bash_cv_speed_t_in_sys_types = yes; then   
+AC_DEFINE(SPEED_T_IN_SYS_TYPES)
+fi
+])
+
+AC_DEFUN(BASH_CHECK_GETPW_FUNCS,
+[AC_MSG_CHECKING(whether programs are able to redeclare getpw functions)
+AC_CACHE_VAL(bash_cv_can_redecl_getpw,
+[AC_TRY_COMPILE([#include <sys/types.h>
+#include <pwd.h>
+extern struct passwd *getpwent();], [struct passwd *z; z = getpwent();],
+  bash_cv_can_redecl_getpw=yes,bash_cv_can_redecl_getpw=no)])
+AC_MSG_RESULT($bash_cv_can_redecl_getpw)
+if test $bash_cv_can_redecl_getpw = no; then
+AC_DEFINE(HAVE_GETPW_DECLS)
+fi
+])
+
+AC_DEFUN(BASH_CHECK_DEV_FD,
+[AC_MSG_CHECKING(whether /dev/fd is available)
+AC_CACHE_VAL(bash_cv_dev_fd,
+[if test -d /dev/fd  && test -r /dev/fd/0; then
+   bash_cv_dev_fd=standard
+ elif test -d /proc/self/fd && test -r /proc/self/fd/0; then
+   bash_cv_dev_fd=whacky
+ else
+   bash_cv_dev_fd=absent
+ fi
+])
+AC_MSG_RESULT($bash_cv_dev_fd)
+if test $bash_cv_dev_fd = "standard"; then
+  AC_DEFINE(HAVE_DEV_FD)
+  AC_DEFINE(DEV_FD_PREFIX, "/dev/fd/")
+elif test $bash_cv_dev_fd = "whacky"; then
+  AC_DEFINE(HAVE_DEV_FD)
+  AC_DEFINE(DEV_FD_PREFIX, "/proc/self/fd/")
+fi
+])
+
+dnl
+dnl Check for the presence of getpeername (the only networking function
+dnl bash currently requires) in libsocket.  If libsocket is present,
+dnl check for libnsl and add it to LIBS if it's there, since most
+dnl systems with libsocket require linking with libnsl as well.
+dnl This should only be called if getpeername was not found in libc.
+dnl
+AC_DEFUN(BASH_CHECK_SOCKLIB,
+[
+if test "X$bash_cv_have_socklib" = "X"; then
+_bash_needmsg=
+else
+AC_MSG_CHECKING(for socket library)
+_bash_needmsg=yes
+fi
+AC_CACHE_VAL(bash_cv_have_socklib,
+[AC_CHECK_LIB(socket, getpeername,
+        bash_cv_have_socklib=yes, bash_cv_have_socklib=no, -lnsl)])
+if test "X$_bash_needmsg" = Xyes; then
+  AC_MSG_RESULT($bash_cv_have_socklib)
+  _bash_needmsg=
+fi
+if test $bash_cv_have_socklib = yes; then
+  # check for libnsl, add it to LIBS if present
+  if test "X$bash_cv_have_libnsl" = "X"; then
+    _bash_needmsg=
+  else
+    AC_MSG_CHECKING(for libnsl)
+    _bash_needmsg=yes
+  fi
+  AC_CACHE_VAL(bash_cv_have_libnsl,
+	   [AC_CHECK_LIB(nsl, t_open,
+		 bash_cv_have_libnsl=yes, bash_cv_have_libnsl=no)])
+  if test "X$_bash_needmsg" = Xyes; then
+    AC_MSG_RESULT($bash_cv_have_libnsl)
+    _bash_needmsg=
+  fi
+  if test $bash_cv_have_libnsl = yes; then
+    LIBS="-lsocket -lnsl $LIBS"
+  else
+    LIBS="-lsocket $LIBS"
+  fi
+  AC_DEFINE(HAVE_LIBSOCKET)
+  AC_DEFINE(HAVE_GETPEERNAME)
+fi
+])
+
+AC_DEFUN(BASH_DEFAULT_MAIL_DIR,
+[AC_MSG_CHECKING(for default mail directory)
+AC_CACHE_VAL(bash_cv_mail_dir,
+[if test -d /var/mail; then
+   bash_cv_mail_dir=/var/mail
+ elif test -d /usr/mail; then
+   bash_cv_mail_dir=/usr/mail
+ elif test -d /usr/spool/mail; then
+   bash_cv_mail_dir=/usr/spool/mail
+ elif test -d /var/spool/mail; then
+   bash_cv_mail_dir=/var/spool/mail
+ else
+   bash_cv_mail_dir=unknown
+ fi
+])
+AC_MSG_RESULT($bash_cv_mail_dir)
+if test $bash_cv_mail_dir = "/var/mail"; then
+   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/var/mail")
+elif test $bash_cv_mail_dir = "/usr/mail"; then
+   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/usr/mail")
+elif test $bash_cv_mail_dir = "/var/spool/mail"; then
+   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/var/spool/mail")
+elif test $bash_cv_mail_dir = "/usr/spool/mail"; then
+   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "/usr/spool/mail")
+else
+   AC_DEFINE(DEFAULT_MAIL_DIRECTORY, "unknown")
+fi
+])
+
+dnl
+dnl Check if HPUX needs _KERNEL defined for RLIMIT_* definitions
+dnl
+AC_DEFUN(BASH_KERNEL_RLIMIT_CHECK,
+[AC_MSG_CHECKING([whether $host_os needs _KERNEL for RLIMIT defines])
+AC_CACHE_VAL(bash_cv_kernel_rlimit,
+[AC_TRY_COMPILE([
+#include <sys/types.h>
+#include <sys/resource.h>
+],
+[
+  int f;
+  f = RLIMIT_DATA;
+], bash_cv_kernel_rlimit=no,
+    [AC_TRY_COMPILE([
+     #include <sys/types.h>
+     #define _KERNEL
+     #include <sys/resource.h>
+     #undef _KERNEL
+     ],
+     [
+	int f;
+        f = RLIMIT_DATA;
+     ], bash_cv_kernel_rlimit=yes, bash_cv_kernel_rlimit=no)]
+)])
+AC_MSG_RESULT($bash_cv_kernel_rlimit)
+if test $bash_cv_kernel_rlimit = yes; then
+AC_DEFINE(RLIMIT_NEEDS_KERNEL)
+fi
+])
+
+AC_DEFUN(BASH_FUNC_STRCOLL,
+[
+AC_MSG_CHECKING(whether or not strcoll and strcmp differ)
+AC_CACHE_VAL(bash_cv_func_strcoll_broken,
+[AC_TRY_RUN([
+#include <stdio.h>
+#if defined (HAVE_LOCALE_H)
+#include <locale.h>
+#endif
+
+main(c, v)
+int     c;
+char    *v[];
+{
+        int     r1, r2;
+        char    *deflocale, *defcoll;
+
+#ifdef HAVE_SETLOCALE
+        deflocale = setlocale(LC_ALL, "");
+	defcoll = setlocale(LC_COLLATE, "");
+#endif
+
+#ifdef HAVE_STRCOLL
+	/* These two values are taken from tests/glob-test. */
+        r1 = strcoll("abd", "aXd");
+#else
+	r1 = 0;
+#endif
+        r2 = strcmp("abd", "aXd");
+
+	/* These two should both be greater than 0.  It is permissible for
+	   a system to return different values, as long as the sign is the
+	   same. */
+
+        /* Exit with 1 (failure) if these two values are both > 0, since
+	   this tests whether strcoll(3) is broken with respect to strcmp(3)
+	   in the default locale. */
+	exit (r1 > 0 && r2 > 0);
+}
+], bash_cv_func_strcoll_broken=yes, bash_cv_func_strcoll_broken=no,
+   AC_MSG_ERROR(cannot check strcoll if cross compiling))
+])
+AC_MSG_RESULT($bash_cv_func_strcoll_broken)
+if test $bash_cv_func_strcoll_broken = yes; then
+AC_DEFINE(STRCOLL_BROKEN)
+fi
+])
diff --git a/readline/ansi_stdlib.h b/readline/ansi_stdlib.h
new file mode 100644
--- /dev/null
+++ b/readline/ansi_stdlib.h
@@ -0,0 +1,41 @@
+/* ansi_stdlib.h -- An ANSI Standard stdlib.h. */
+/* A minimal stdlib.h containing extern declarations for those functions
+   that bash uses. */
+
+/* Copyright (C) 1993 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 2, or (at your option) any later
+   version.
+
+   Bash is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with Bash; see the file COPYING.  If not, write to the Free Software
+   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (_STDLIB_H_)
+#define	_STDLIB_H_ 1
+
+/* String conversion functions. */
+extern int atoi ();
+extern long int atol ();
+
+/* Memory allocation functions. */
+extern char *malloc ();
+extern char *realloc ();
+extern void free ();
+
+/* Other miscellaneous functions. */
+extern void abort ();
+extern void exit ();
+extern char *getenv ();
+extern void qsort ();
+
+#endif /* _STDLIB_H  */
diff --git a/readline/bind.c b/readline/bind.c
new file mode 100644
--- /dev/null
+++ b/readline/bind.c
@@ -0,0 +1,1775 @@
+/* bind.c -- key binding and startup file support for the readline library. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#if defined (HAVE_SYS_FILE_H)
+#  include <sys/file.h>
+#endif /* HAVE_SYS_FILE_H */
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include <signal.h>
+#include <errno.h>
+
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+#include "posixstat.h"
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+/* Some standard library routines. */
+#include "readline.h"
+#include "history.h"
+
+#if !defined (strchr) && !defined (__STDC__)
+extern char *strchr (), *strrchr ();
+#endif /* !strchr && !__STDC__ */
+
+extern int _rl_horizontal_scroll_mode;
+extern int _rl_mark_modified_lines;
+extern int _rl_bell_preference;
+extern int _rl_meta_flag;
+extern int _rl_convert_meta_chars_to_ascii;
+extern int _rl_output_meta_chars;
+extern int _rl_complete_show_all;
+extern int _rl_complete_mark_directories;
+extern int _rl_enable_keypad;
+#if defined (PAREN_MATCHING)
+extern int rl_blink_matching_paren;
+#endif /* PAREN_MATCHING */
+#if defined (VISIBLE_STATS)
+extern int rl_visible_stats;
+#endif /* VISIBLE_STATS */
+extern int rl_complete_with_tilde_expansion;
+extern int rl_completion_query_items;
+extern int rl_inhibit_completion;
+extern char *_rl_comment_begin;
+
+extern int rl_explicit_arg;
+extern int rl_editing_mode;
+extern unsigned char _rl_parsing_conditionalized_out;
+extern Keymap _rl_keymap;
+
+extern char *possible_control_prefixes[], *possible_meta_prefixes[];
+
+/* Functions imported from funmap.c */
+extern char **rl_funmap_names ();
+extern int rl_add_funmap_entry ();
+
+/* Functions imported from util.c */
+extern char *_rl_strindex ();
+
+/* Functions imported from shell.c */
+extern char *get_env_value ();
+
+/* Variables exported by this file. */
+Keymap rl_binding_keymap;
+
+/* Forward declarations */
+void rl_set_keymap_from_edit_mode ();
+
+static int glean_key_from_name ();
+static int substring_member_of_array ();
+
+extern char *xmalloc (), *xrealloc ();
+
+/* **************************************************************** */
+/*								    */
+/*			Binding keys				    */
+/*								    */
+/* **************************************************************** */
+
+/* rl_add_defun (char *name, Function *function, int key)
+   Add NAME to the list of named functions.  Make FUNCTION be the function
+   that gets called.  If KEY is not -1, then bind it. */
+int
+rl_add_defun (name, function, key)
+     char *name;
+     Function *function;
+     int key;
+{
+  if (key != -1)
+    rl_bind_key (key, function);
+  rl_add_funmap_entry (name, function);
+  return 0;
+}
+
+/* Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range. */
+int
+rl_bind_key (key, function)
+     int key;
+     Function *function;
+{
+  if (key < 0)
+    return (key);
+
+  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
+    {
+      if (_rl_keymap[ESC].type == ISKMAP)
+	{
+	  Keymap escmap;
+
+	  escmap = FUNCTION_TO_KEYMAP (_rl_keymap, ESC);
+	  key = UNMETA (key);
+	  escmap[key].type = ISFUNC;
+	  escmap[key].function = function;
+	  return (0);
+	}
+      return (key);
+    }
+
+  _rl_keymap[key].type = ISFUNC;
+  _rl_keymap[key].function = function;
+  rl_binding_keymap = _rl_keymap;
+  return (0);
+}
+
+/* Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid
+   KEY. */
+int
+rl_bind_key_in_map (key, function, map)
+     int key;
+     Function *function;
+     Keymap map;
+{
+  int result;
+  Keymap oldmap;
+
+  oldmap = _rl_keymap;
+  _rl_keymap = map;
+  result = rl_bind_key (key, function);
+  _rl_keymap = oldmap;
+  return (result);
+}
+
+/* Make KEY do nothing in the currently selected keymap.
+   Returns non-zero in case of error. */
+int
+rl_unbind_key (key)
+     int key;
+{
+  return (rl_bind_key (key, (Function *)NULL));
+}
+
+/* Make KEY do nothing in MAP.
+   Returns non-zero in case of error. */
+int
+rl_unbind_key_in_map (key, map)
+     int key;
+     Keymap map;
+{
+  return (rl_bind_key_in_map (key, (Function *)NULL, map));
+}
+
+/* Bind the key sequence represented by the string KEYSEQ to
+   FUNCTION.  This makes new keymaps as necessary.  The initial
+   place to do bindings is in MAP. */
+int
+rl_set_key (keyseq, function, map)
+     char *keyseq;
+     Function *function;
+     Keymap map;
+{
+  return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
+}
+
+/* Bind the key sequence represented by the string KEYSEQ to
+   the string of characters MACRO.  This makes new keymaps as
+   necessary.  The initial place to do bindings is in MAP. */
+int
+rl_macro_bind (keyseq, macro, map)
+     char *keyseq, *macro;
+     Keymap map;
+{
+  char *macro_keys;
+  int macro_keys_len;
+
+  macro_keys = (char *)xmalloc ((2 * strlen (macro)) + 1);
+
+  if (rl_translate_keyseq (macro, macro_keys, &macro_keys_len))
+    {
+      free (macro_keys);
+      return -1;
+    }
+  rl_generic_bind (ISMACR, keyseq, macro_keys, map);
+  return 0;
+}
+
+/* Bind the key sequence represented by the string KEYSEQ to
+   the arbitrary pointer DATA.  TYPE says what kind of data is
+   pointed to by DATA, right now this can be a function (ISFUNC),
+   a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps
+   as necessary.  The initial place to do bindings is in MAP. */
+int
+rl_generic_bind (type, keyseq, data, map)
+     int type;
+     char *keyseq, *data;
+     Keymap map;
+{
+  char *keys;
+  int keys_len;
+  register int i;
+
+  /* If no keys to bind to, exit right away. */
+  if (!keyseq || !*keyseq)
+    {
+      if (type == ISMACR)
+	free (data);
+      return -1;
+    }
+
+  keys = xmalloc (1 + (2 * strlen (keyseq)));
+
+  /* Translate the ASCII representation of KEYSEQ into an array of
+     characters.  Stuff the characters into KEYS, and the length of
+     KEYS into KEYS_LEN. */
+  if (rl_translate_keyseq (keyseq, keys, &keys_len))
+    {
+      free (keys);
+      return -1;
+    }
+
+  /* Bind keys, making new keymaps as necessary. */
+  for (i = 0; i < keys_len; i++)
+    {
+      int ic = (int) ((unsigned char)keys[i]);
+
+      if (_rl_convert_meta_chars_to_ascii && META_CHAR (ic))
+	{
+	  ic = UNMETA (ic);
+	  if (map[ESC].type == ISKMAP)
+	    map = FUNCTION_TO_KEYMAP (map, ESC);
+	}
+
+      if ((i + 1) < keys_len)
+	{
+	  if (map[ic].type != ISKMAP)
+	    {
+	      if (map[ic].type == ISMACR)
+		free ((char *)map[ic].function);
+
+	      map[ic].type = ISKMAP;
+	      map[ic].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap());
+	    }
+	  map = FUNCTION_TO_KEYMAP (map, ic);
+	}
+      else
+	{
+	  if (map[ic].type == ISMACR)
+	    free ((char *)map[ic].function);
+
+	  map[ic].function = KEYMAP_TO_FUNCTION (data);
+	  map[ic].type = type;
+	}
+
+      rl_binding_keymap = map;
+    }
+  free (keys);
+  return 0;
+}
+
+/* Translate the ASCII representation of SEQ, stuffing the values into ARRAY,
+   an array of characters.  LEN gets the final length of ARRAY.  Return
+   non-zero if there was an error parsing SEQ. */
+int
+rl_translate_keyseq (seq, array, len)
+     char *seq, *array;
+     int *len;
+{
+  register int i, c, l;
+
+  for (i = l = 0; c = seq[i]; i++)
+    {
+      if (c == '\\')
+	{
+	  c = seq[++i];
+
+	  if (c == 0)
+	    break;
+
+	  if (((c == 'C' || c == 'M') && seq[i + 1] == '-') || (c == 'e'))
+	    {
+	      /* Handle special case of backwards define. */
+	      if (strncmp (&seq[i], "C-\\M-", 5) == 0)
+		{
+		  array[l++] = ESC;
+		  i += 5;
+		  array[l++] = CTRL (_rl_to_upper (seq[i]));
+		  if (!seq[i])
+		    i--;
+		  continue;
+		}
+
+	      switch (c)
+		{
+		case 'M':
+		  i++;
+		  array[l++] = ESC;	/* XXX */
+		  break;
+
+		case 'C':
+		  i += 2;
+		  /* Special hack for C-?... */
+		  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));
+		  break;
+
+		case 'e':
+		  array[l++] = ESC;
+		}
+
+	      continue;
+	    }
+	}
+      array[l++] = c;
+    }
+
+  *len = l;
+  array[l] = '\0';
+  return (0);
+}
+
+char *
+rl_untranslate_keyseq (seq)
+     int seq;
+{
+  static char kseq[16];
+  int i, c;
+
+  i = 0;
+  c = seq;
+  if (META_CHAR (c))
+    {
+      kseq[i++] = '\\';
+      kseq[i++] = 'M';
+      kseq[i++] = '-';
+      c = UNMETA (c);
+    }
+  else if (CTRL_CHAR (c))
+    {
+      kseq[i++] = '\\';
+      kseq[i++] = 'C';
+      kseq[i++] = '-';
+      c = _rl_to_lower (UNCTRL (c));
+    }
+  else if (c == RUBOUT)
+    {
+      kseq[i++] = '\\';
+      kseq[i++] = 'C';
+      kseq[i++] = '-';
+      c = '?';
+    }
+
+  if (c == ESC)
+    {
+      kseq[i++] = '\\';
+      c = 'e';
+    }
+  else if (c == '\\' || c == '"')
+    {
+      kseq[i++] = '\\';
+    }
+
+  kseq[i++] = (unsigned char) c;
+  kseq[i] = '\0';
+  return kseq;
+}
+
+static char *
+_rl_untranslate_macro_value (seq)
+     char *seq;
+{
+  char *ret, *r, *s;
+  int c;
+
+  r = ret = xmalloc (7 * strlen (seq) + 1);
+  for (s = seq; *s; s++)
+    {
+      c = *s;
+      if (META_CHAR (c))
+	{
+	  *r++ = '\\';
+	  *r++ = 'M';
+	  *r++ = '-';
+	  c = UNMETA (c);
+	}
+      else if (CTRL_CHAR (c) && c != ESC)
+	{
+	  *r++ = '\\';
+	  *r++ = 'C';
+	  *r++ = '-';
+	  c = _rl_to_lower (UNCTRL (c));
+	}
+      else if (c == RUBOUT)
+ 	{
+ 	  *r++ = '\\';
+ 	  *r++ = 'C';
+ 	  *r++ = '-';
+ 	  c = '?';
+ 	}
+
+      if (c == ESC)
+	{
+	  *r++ = '\\';
+	  c = 'e';
+	}
+      else if (c == '\\' || c == '"')
+	*r++ = '\\';
+
+      *r++ = (unsigned char)c;
+    }
+  *r = '\0';
+  return ret;
+}
+
+/* Return a pointer to the function that STRING represents.
+   If STRING doesn't have a matching function, then a NULL pointer
+   is returned. */
+Function *
+rl_named_function (string)
+     char *string;
+{
+  register int i;
+
+  rl_initialize_funmap ();
+
+  for (i = 0; funmap[i]; i++)
+    if (_rl_stricmp (funmap[i]->name, string) == 0)
+      return (funmap[i]->function);
+  return ((Function *)NULL);
+}
+
+/* Return the function (or macro) definition which would be invoked via
+   KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is
+   used.  TYPE, if non-NULL, is a pointer to an int which will receive the
+   type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
+   or ISMACR (macro). */
+Function *
+rl_function_of_keyseq (keyseq, map, type)
+     char *keyseq;
+     Keymap map;
+     int *type;
+{
+  register int i;
+
+  if (!map)
+    map = _rl_keymap;
+
+  for (i = 0; keyseq && keyseq[i]; i++)
+    {
+      int ic = keyseq[i];
+
+      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)
+	{
+	  if (map[ESC].type != ISKMAP)
+	    {
+	      if (type)
+		*type = map[ESC].type;
+
+	      return (map[ESC].function);
+	    }
+	  else
+	    {
+	      map = FUNCTION_TO_KEYMAP (map, ESC);
+	      ic = UNMETA (ic);
+	    }
+	}
+
+      if (map[ic].type == ISKMAP)
+	{
+	  /* If this is the last key in the key sequence, return the
+	     map. */
+	  if (!keyseq[i + 1])
+	    {
+	      if (type)
+		*type = ISKMAP;
+
+	      return (map[ic].function);
+	    }
+	  else
+	    map = FUNCTION_TO_KEYMAP (map, ic);
+	}
+      else
+	{
+	  if (type)
+	    *type = map[ic].type;
+
+	  return (map[ic].function);
+	}
+    }
+  return ((Function *) NULL);
+}
+
+/* The last key bindings file read. */
+static char *last_readline_init_file = (char *)NULL;
+
+/* The file we're currently reading key bindings from. */
+static char *current_readline_init_file;
+static int current_readline_init_lineno;
+
+/* Re-read the current keybindings file. */
+int
+rl_re_read_init_file (count, ignore)
+     int count, ignore;
+{
+  int r;
+  r = rl_read_init_file ((char *)NULL);
+  rl_set_keymap_from_edit_mode ();
+  return r;
+}
+
+/* Do key bindings from a file.  If FILENAME is NULL it defaults
+   to the first non-null filename from this list:
+     1. the filename used for the previous call
+     2. the value of the shell variable `INPUTRC'
+     3. ~/.inputrc
+   If the file existed and could be opened and read, 0 is returned,
+   otherwise errno is returned. */
+int
+rl_read_init_file (filename)
+     char *filename;
+{
+  register int i;
+  char *buffer, *openname, *line, *end;
+  struct stat finfo;
+  int file;
+
+  /* Default the filename. */
+  if (filename == 0)
+    {
+      filename = last_readline_init_file;
+      if (filename == 0)
+        filename = get_env_value ("INPUTRC");
+      if (filename == 0)
+	filename = DEFAULT_INPUTRC;
+    }
+
+  if (*filename == 0)
+    filename = DEFAULT_INPUTRC;
+
+  current_readline_init_file = filename;
+  openname = tilde_expand (filename);
+
+  if ((stat (openname, &finfo) < 0) ||
+      (file = open (openname, O_RDONLY, 0666)) < 0)
+    {
+      free (openname);
+      return (errno);
+    }
+  else
+    free (openname);
+
+  if (filename != last_readline_init_file)
+    {
+      if (last_readline_init_file)
+	free (last_readline_init_file);
+
+      last_readline_init_file = savestring (filename);
+    }
+
+  /* Read the file into BUFFER. */
+  buffer = (char *)xmalloc ((int)finfo.st_size + 1);
+  i = read (file, buffer, finfo.st_size);
+  close (file);
+
+  if (i != finfo.st_size)
+    return (errno);
+
+  /* Loop over the lines in the file.  Lines that start with `#' are
+     comments; all other lines are commands for readline initialization. */
+  current_readline_init_lineno = 1;
+  line = buffer;
+  end = buffer + finfo.st_size;
+  while (line < end)
+    {
+      /* Find the end of this line. */
+      for (i = 0; line + i != end && line[i] != '\n'; i++);
+
+      /* Mark end of line. */
+      line[i] = '\0';
+
+      /* Skip leading whitespace. */
+      while (*line && whitespace (*line))
+        {
+	  line++;
+	  i--;
+        }
+
+      /* If the line is not a comment, then parse it. */
+      if (*line && *line != '#')
+	rl_parse_and_bind (line);
+
+      /* Move to the next line. */
+      line += i + 1;
+      current_readline_init_lineno++;
+    }
+  free (buffer);
+  return (0);
+}
+
+static void
+_rl_init_file_error (msg)
+     char *msg;
+{
+  fprintf (stderr, "readline: %s: line %d: %s\n", current_readline_init_file,
+ 		   current_readline_init_lineno,
+ 		   msg);
+}
+
+/* **************************************************************** */
+/*								    */
+/*			Parser Directives       		    */
+/*								    */
+/* **************************************************************** */
+
+/* Conditionals. */
+
+/* Calling programs set this to have their argv[0]. */
+char *rl_readline_name = "other";
+
+/* Stack of previous values of parsing_conditionalized_out. */
+static unsigned char *if_stack = (unsigned char *)NULL;
+static int if_stack_depth;
+static int if_stack_size;
+
+/* Push _rl_parsing_conditionalized_out, and set parser state based
+   on ARGS. */
+static int
+parser_if (args)
+     char *args;
+{
+  register int i;
+
+  /* Push parser state. */
+  if (if_stack_depth + 1 >= if_stack_size)
+    {
+      if (!if_stack)
+	if_stack = (unsigned char *)xmalloc (if_stack_size = 20);
+      else
+	if_stack = (unsigned char *)xrealloc (if_stack, if_stack_size += 20);
+    }
+  if_stack[if_stack_depth++] = _rl_parsing_conditionalized_out;
+
+  /* If parsing is turned off, then nothing can turn it back on except
+     for finding the matching endif.  In that case, return right now. */
+  if (_rl_parsing_conditionalized_out)
+    return 0;
+
+  /* Isolate first argument. */
+  for (i = 0; args[i] && !whitespace (args[i]); i++);
+
+  if (args[i])
+    args[i++] = '\0';
+
+  /* Handle "if term=foo" and "if mode=emacs" constructs.  If this
+     isn't term=foo, or mode=emacs, then check to see if the first
+     word in ARGS is the same as the value stored in rl_readline_name. */
+  if (rl_terminal_name && _rl_strnicmp (args, "term=", 5) == 0)
+    {
+      char *tem, *tname;
+
+      /* Terminals like "aaa-60" are equivalent to "aaa". */
+      tname = savestring (rl_terminal_name);
+      tem = strchr (tname, '-');
+      if (tem)
+	*tem = '\0';
+
+      /* Test the `long' and `short' forms of the terminal name so that
+	 if someone has a `sun-cmd' and does not want to have bindings
+	 that will be executed if the terminal is a `sun', they can put
+	 `$if term=sun-cmd' into their .inputrc. */
+      _rl_parsing_conditionalized_out = _rl_stricmp (args + 5, tname) &&
+					_rl_stricmp (args + 5, rl_terminal_name);
+      free (tname);
+    }
+#if defined (VI_MODE)
+  else if (_rl_strnicmp (args, "mode=", 5) == 0)
+    {
+      int mode;
+
+      if (_rl_stricmp (args + 5, "emacs") == 0)
+	mode = emacs_mode;
+      else if (_rl_stricmp (args + 5, "vi") == 0)
+	mode = vi_mode;
+      else
+	mode = no_mode;
+
+      _rl_parsing_conditionalized_out = mode != rl_editing_mode;
+    }
+#endif /* VI_MODE */
+  /* Check to see if the first word in ARGS is the same as the
+     value stored in rl_readline_name. */
+  else if (_rl_stricmp (args, rl_readline_name) == 0)
+    _rl_parsing_conditionalized_out = 0;
+  else
+    _rl_parsing_conditionalized_out = 1;
+  return 0;
+}
+
+/* Invert the current parser state if there is anything on the stack. */
+static int
+parser_else (args)
+     char *args;
+{
+  register int i;
+
+  if (!if_stack_depth)
+    {
+      /* Error message? */
+      return 0;
+    }
+
+  /* Check the previous (n - 1) levels of the stack to make sure that
+     we haven't previously turned off parsing. */
+  for (i = 0; i < if_stack_depth - 1; i++)
+    if (if_stack[i] == 1)
+      return 0;
+
+  /* Invert the state of parsing if at top level. */
+  _rl_parsing_conditionalized_out = !_rl_parsing_conditionalized_out;
+  return 0;
+}
+
+/* Terminate a conditional, popping the value of
+   _rl_parsing_conditionalized_out from the stack. */
+static int
+parser_endif (args)
+     char *args;
+{
+  if (if_stack_depth)
+    _rl_parsing_conditionalized_out = if_stack[--if_stack_depth];
+  else
+    {
+      /* *** What, no error message? *** */
+    }
+  return 0;
+}
+
+/* Associate textual names with actual functions. */
+static struct {
+  char *name;
+  Function *function;
+} parser_directives [] = {
+  { "if", parser_if },
+  { "endif", parser_endif },
+  { "else", parser_else },
+  { (char *)0x0, (Function *)0x0 }
+};
+
+/* Handle a parser directive.  STATEMENT is the line of the directive
+   without any leading `$'. */
+static int
+handle_parser_directive (statement)
+     char *statement;
+{
+  register int i;
+  char *directive, *args;
+
+  /* Isolate the actual directive. */
+
+  /* Skip whitespace. */
+  for (i = 0; whitespace (statement[i]); i++);
+
+  directive = &statement[i];
+
+  for (; statement[i] && !whitespace (statement[i]); i++);
+
+  if (statement[i])
+    statement[i++] = '\0';
+
+  for (; statement[i] && whitespace (statement[i]); i++);
+
+  args = &statement[i];
+
+  /* Lookup the command, and act on it. */
+  for (i = 0; parser_directives[i].name; i++)
+    if (_rl_stricmp (directive, parser_directives[i].name) == 0)
+      {
+	(*parser_directives[i].function) (args);
+	return (0);
+      }
+
+  /* *** Should an error message be output? */
+  return (1);
+}
+
+/* Read the binding command from STRING and perform it.
+   A key binding command looks like: Keyname: function-name\0,
+   a variable binding command looks like: set variable value.
+   A new-style keybinding looks like "\C-x\C-x": exchange-point-and-mark. */
+int
+rl_parse_and_bind (string)
+     char *string;
+{
+  char *funname, *kname;
+  register int c, i;
+  int key, equivalency;
+
+  while (string && whitespace (*string))
+    string++;
+
+  if (!string || !*string || *string == '#')
+    return 0;
+
+  /* If this is a parser directive, act on it. */
+  if (*string == '$')
+    {
+      handle_parser_directive (&string[1]);
+      return 0;
+    }
+
+  /* If we aren't supposed to be parsing right now, then we're done. */
+  if (_rl_parsing_conditionalized_out)
+    return 0;
+
+  i = 0;
+  /* If this keyname is a complex key expression surrounded by quotes,
+     advance to after the matching close quote.  This code allows the
+     backslash to quote characters in the key expression. */
+  if (*string == '"')
+    {
+      int passc = 0;
+
+      for (i = 1; c = string[i]; i++)
+	{
+	  if (passc)
+	    {
+	      passc = 0;
+	      continue;
+	    }
+
+	  if (c == '\\')
+	    {
+	      passc++;
+	      continue;
+	    }
+
+	  if (c == '"')
+	    break;
+	}
+      /* If we didn't find a closing quote, abort the line. */
+      if (string[i] == '\0')
+        {
+          _rl_init_file_error ("no closing `\"' in key binding");
+          return 1;
+        }
+    }
+
+  /* Advance to the colon (:) or whitespace which separates the two objects. */
+  for (; (c = string[i]) && c != ':' && c != ' ' && c != '\t'; i++ );
+
+  equivalency = (c == ':' && string[i + 1] == '=');
+
+  /* Mark the end of the command (or keyname). */
+  if (string[i])
+    string[i++] = '\0';
+
+  /* If doing assignment, skip the '=' sign as well. */
+  if (equivalency)
+    string[i++] = '\0';
+
+  /* If this is a command to set a variable, then do that. */
+  if (_rl_stricmp (string, "set") == 0)
+    {
+      char *var = string + i;
+      char *value;
+
+      /* Make VAR point to start of variable name. */
+      while (*var && whitespace (*var)) var++;
+
+      /* Make value point to start of value string. */
+      value = var;
+      while (*value && !whitespace (*value)) value++;
+      if (*value)
+	*value++ = '\0';
+      while (*value && whitespace (*value)) value++;
+
+      rl_variable_bind (var, value);
+      return 0;
+    }
+
+  /* Skip any whitespace between keyname and funname. */
+  for (; string[i] && whitespace (string[i]); i++);
+  funname = &string[i];
+
+  /* Now isolate funname.
+     For straight function names just look for whitespace, since
+     that will signify the end of the string.  But this could be a
+     macro definition.  In that case, the string is quoted, so skip
+     to the matching delimiter.  We allow the backslash to quote the
+     delimiter characters in the macro body. */
+  /* This code exists to allow whitespace in macro expansions, which
+     would otherwise be gobbled up by the next `for' loop.*/
+  /* XXX - it may be desirable to allow backslash quoting only if " is
+     the quoted string delimiter, like the shell. */
+  if (*funname == '\'' || *funname == '"')
+    {
+      int delimiter = string[i++];
+      int passc = 0;
+
+      for (; c = string[i]; i++)
+	{
+	  if (passc)
+	    {
+	      passc = 0;
+	      continue;
+	    }
+
+	  if (c == '\\')
+	    {
+	      passc = 1;
+	      continue;
+	    }
+
+	  if (c == delimiter)
+	    break;
+	}
+      if (c)
+	i++;
+    }
+
+  /* Advance to the end of the string.  */
+  for (; string[i] && !whitespace (string[i]); i++);
+
+  /* No extra whitespace at the end of the string. */
+  string[i] = '\0';
+
+  /* Handle equivalency bindings here.  Make the left-hand side be exactly
+     whatever the right-hand evaluates to, including keymaps. */
+  if (equivalency)
+    {
+      return 0;
+    }
+
+  /* If this is a new-style key-binding, then do the binding with
+     rl_set_key ().  Otherwise, let the older code deal with it. */
+  if (*string == '"')
+    {
+      char *seq = xmalloc (1 + strlen (string));
+      register int j, k = 0;
+      int passc = 0;
+
+      for (j = 1; string[j]; j++)
+	{
+	  /* Allow backslash to quote characters, but leave them in place.
+	     This allows a string to end with a backslash quoting another
+	     backslash, or with a backslash quoting a double quote.  The
+	     backslashes are left in place for rl_translate_keyseq (). */
+	  if (passc || (string[j] == '\\'))
+	    {
+	      seq[k++] = string[j];
+	      passc = !passc;
+	      continue;
+	    }
+
+	  if (string[j] == '"')
+	    break;
+
+	  seq[k++] = string[j];
+	}
+      seq[k] = '\0';
+
+      /* Binding macro? */
+      if (*funname == '\'' || *funname == '"')
+	{
+	  j = strlen (funname);
+
+	  /* Remove the delimiting quotes from each end of FUNNAME. */
+	  if (j && funname[j - 1] == *funname)
+	    funname[j - 1] = '\0';
+
+	  rl_macro_bind (seq, &funname[1], _rl_keymap);
+	}
+      else
+	rl_set_key (seq, rl_named_function (funname), _rl_keymap);
+
+      free (seq);
+      return 0;
+    }
+
+  /* Get the actual character we want to deal with. */
+  kname = strrchr (string, '-');
+  if (!kname)
+    kname = string;
+  else
+    kname++;
+
+  key = glean_key_from_name (kname);
+
+  /* Add in control and meta bits. */
+  if (substring_member_of_array (string, possible_control_prefixes))
+    key = CTRL (_rl_to_upper (key));
+
+  if (substring_member_of_array (string, possible_meta_prefixes))
+    key = META (key);
+
+  /* Temporary.  Handle old-style keyname with macro-binding. */
+  if (*funname == '\'' || *funname == '"')
+    {
+      unsigned char useq[2];
+      int fl = strlen (funname);
+
+      useq[0] = key; useq[1] = '\0';
+      if (fl && funname[fl - 1] == *funname)
+	funname[fl - 1] = '\0';
+
+      rl_macro_bind (useq, &funname[1], _rl_keymap);
+    }
+#if defined (PREFIX_META_HACK)
+  /* Ugly, but working hack to keep prefix-meta around. */
+  else if (_rl_stricmp (funname, "prefix-meta") == 0)
+    {
+      char seq[2];
+
+      seq[0] = key;
+      seq[1] = '\0';
+      rl_generic_bind (ISKMAP, seq, (char *)emacs_meta_keymap, _rl_keymap);
+    }
+#endif /* PREFIX_META_HACK */
+  else
+    rl_bind_key (key, rl_named_function (funname));
+  return 0;
+}
+
+/* Simple structure for boolean readline variables (i.e., those that can
+   have one of two values; either "On" or 1 for truth, or "Off" or 0 for
+   false. */
+
+static struct {
+  char *name;
+  int *value;
+} boolean_varlist [] = {
+#if defined (PAREN_MATCHING)
+  { "blink-matching-paren",	&rl_blink_matching_paren },
+#endif
+  { "convert-meta",		&_rl_convert_meta_chars_to_ascii },
+  { "disable-completion",	&rl_inhibit_completion },
+  { "enable-keypad",		&_rl_enable_keypad },
+  { "expand-tilde",		&rl_complete_with_tilde_expansion },
+  { "horizontal-scroll-mode",	&_rl_horizontal_scroll_mode },
+  { "input-meta",		&_rl_meta_flag },
+  { "mark-directories",		&_rl_complete_mark_directories },
+  { "mark-modified-lines",	&_rl_mark_modified_lines },
+  { "meta-flag",		&_rl_meta_flag },
+  { "output-meta",		&_rl_output_meta_chars },
+  { "show-all-if-ambiguous",	&_rl_complete_show_all },
+#if defined (VISIBLE_STATS)
+  { "visible-stats",		&rl_visible_stats },
+#endif /* VISIBLE_STATS */
+  { (char *)NULL, (int *)NULL }
+};
+
+int
+rl_variable_bind (name, value)
+     char *name, *value;
+{
+  register int i;
+
+  /* Check for simple variables first. */
+  for (i = 0; boolean_varlist[i].name; i++)
+    {
+      if (_rl_stricmp (name, boolean_varlist[i].name) == 0)
+	{
+	  /* A variable is TRUE if the "value" is "on", "1" or "". */
+	  *boolean_varlist[i].value = *value == 0 ||
+	  			      _rl_stricmp (value, "on") == 0 ||
+				      (value[0] == '1' && value[1] == '\0');
+	  return 0;
+	}
+    }
+
+  /* Not a boolean variable, so check for specials. */
+
+  /* Editing mode change? */
+  if (_rl_stricmp (name, "editing-mode") == 0)
+    {
+      if (_rl_strnicmp (value, "vi", 2) == 0)
+	{
+#if defined (VI_MODE)
+	  _rl_keymap = vi_insertion_keymap;
+	  rl_editing_mode = vi_mode;
+#endif /* VI_MODE */
+	}
+      else if (_rl_strnicmp (value, "emacs", 5) == 0)
+	{
+	  _rl_keymap = emacs_standard_keymap;
+	  rl_editing_mode = emacs_mode;
+	}
+    }
+
+  /* Comment string change? */
+  else if (_rl_stricmp (name, "comment-begin") == 0)
+    {
+      if (*value)
+	{
+	  if (_rl_comment_begin)
+	    free (_rl_comment_begin);
+
+	  _rl_comment_begin = savestring (value);
+	}
+    }
+  else if (_rl_stricmp (name, "completion-query-items") == 0)
+    {
+      int nval = 100;
+      if (*value)
+	{
+	  nval = atoi (value);
+	  if (nval < 0)
+	    nval = 0;
+	}
+      rl_completion_query_items = nval;
+    }
+  else if (_rl_stricmp (name, "keymap") == 0)
+    {
+      Keymap kmap;
+      kmap = rl_get_keymap_by_name (value);
+      if (kmap)
+        rl_set_keymap (kmap);
+    }
+  else if (_rl_stricmp (name, "bell-style") == 0)
+    {
+      if (!*value)
+        _rl_bell_preference = AUDIBLE_BELL;
+      else
+        {
+          if (_rl_stricmp (value, "none") == 0 || _rl_stricmp (value, "off") == 0)
+            _rl_bell_preference = NO_BELL;
+          else if (_rl_stricmp (value, "audible") == 0 || _rl_stricmp (value, "on") == 0)
+            _rl_bell_preference = AUDIBLE_BELL;
+          else if (_rl_stricmp (value, "visible") == 0)
+            _rl_bell_preference = VISIBLE_BELL;
+        }
+    }
+  else if (_rl_stricmp (name, "prefer-visible-bell") == 0)
+    {
+      /* Backwards compatibility. */
+      if (*value && (_rl_stricmp (value, "on") == 0 ||
+		     (*value == '1' && !value[1])))
+        _rl_bell_preference = VISIBLE_BELL;
+      else
+        _rl_bell_preference = AUDIBLE_BELL;
+    }
+
+  return 0;
+}
+
+/* Return the character which matches NAME.
+   For example, `Space' returns ' '. */
+
+typedef struct {
+  char *name;
+  int value;
+} assoc_list;
+
+static assoc_list name_key_alist[] = {
+  { "DEL", 0x7f },
+  { "ESC", '\033' },
+  { "Escape", '\033' },
+  { "LFD", '\n' },
+  { "Newline", '\n' },
+  { "RET", '\r' },
+  { "Return", '\r' },
+  { "Rubout", 0x7f },
+  { "SPC", ' ' },
+  { "Space", ' ' },
+  { "Tab", 0x09 },
+  { (char *)0x0, 0 }
+};
+
+static int
+glean_key_from_name (name)
+     char *name;
+{
+  register int i;
+
+  for (i = 0; name_key_alist[i].name; i++)
+    if (_rl_stricmp (name, name_key_alist[i].name) == 0)
+      return (name_key_alist[i].value);
+
+  return (*(unsigned char *)name);	/* XXX was return (*name) */
+}
+
+/* Auxiliary functions to manage keymaps. */
+static struct {
+  char *name;
+  Keymap map;
+} keymap_names[] = {
+  { "emacs", emacs_standard_keymap },
+  { "emacs-standard", emacs_standard_keymap },
+  { "emacs-meta", emacs_meta_keymap },
+  { "emacs-ctlx", emacs_ctlx_keymap },
+#if defined (VI_MODE)
+  { "vi", vi_movement_keymap },
+  { "vi-move", vi_movement_keymap },
+  { "vi-command", vi_movement_keymap },
+  { "vi-insert", vi_insertion_keymap },
+#endif /* VI_MODE */
+  { (char *)0x0, (Keymap)0x0 }
+};
+
+Keymap
+rl_get_keymap_by_name (name)
+     char *name;
+{
+  register int i;
+
+  for (i = 0; keymap_names[i].name; i++)
+    if (strcmp (name, keymap_names[i].name) == 0)
+      return (keymap_names[i].map);
+  return ((Keymap) NULL);
+}
+
+char *
+rl_get_keymap_name (map)
+     Keymap map;
+{
+  register int i;
+  for (i = 0; keymap_names[i].name; i++)
+    if (map == keymap_names[i].map)
+      return (keymap_names[i].name);
+  return ((char *)NULL);
+}
+  
+void
+rl_set_keymap (map)
+     Keymap map;
+{
+  if (map)
+    _rl_keymap = map;
+}
+
+Keymap
+rl_get_keymap ()
+{
+  return (_rl_keymap);
+}
+
+void
+rl_set_keymap_from_edit_mode ()
+{
+  if (rl_editing_mode == emacs_mode)
+    _rl_keymap = emacs_standard_keymap;
+#if defined (VI_MODE)
+  else if (rl_editing_mode == vi_mode)
+    _rl_keymap = vi_insertion_keymap;
+#endif /* VI_MODE */
+}
+
+char *
+rl_get_keymap_name_from_edit_mode ()
+{
+  if (rl_editing_mode == emacs_mode)
+    return "emacs";
+#if defined (VI_MODE)
+  else if (rl_editing_mode == vi_mode)
+    return "vi";
+#endif /* VI_MODE */
+  else
+    return "none";
+}
+
+/* **************************************************************** */
+/*								    */
+/*		  Key Binding and Function Information		    */
+/*								    */
+/* **************************************************************** */
+
+/* Each of the following functions produces information about the
+   state of keybindings and functions known to Readline.  The info
+   is always printed to rl_outstream, and in such a way that it can
+   be read back in (i.e., passed to rl_parse_and_bind (). */
+
+/* Print the names of functions known to Readline. */
+void
+rl_list_funmap_names ()
+{
+  register int i;
+  char **funmap_names;
+
+  funmap_names = rl_funmap_names ();
+
+  if (!funmap_names)
+    return;
+
+  for (i = 0; funmap_names[i]; i++)
+    fprintf (rl_outstream, "%s\n", funmap_names[i]);
+
+  free (funmap_names);
+}
+
+static char *
+_rl_get_keyname (key)
+     int key;
+{
+  char *keyname;
+  int i, c;
+
+  keyname = (char *)xmalloc (8);
+
+  c = key;
+  /* Since this is going to be used to write out keysequence-function
+     pairs for possible inclusion in an inputrc file, we don't want to
+     do any special meta processing on KEY. */
+
+#if 0
+  /* We might want to do this, but the old version of the code did not. */
+
+  /* If this is an escape character, we don't want to do any more processing.
+     Just add the special ESC key sequence and return. */
+  if (c == ESC)
+    {
+      keyseq[0] = '\\';
+      keyseq[1] = 'e';
+      keyseq[2] = '\0';
+      return keyseq;
+    }
+#endif
+
+  /* RUBOUT is translated directly into \C-? */
+  if (key == RUBOUT)
+    {
+      keyname[0] = '\\';
+      keyname[1] = 'C';
+      keyname[2] = '-';
+      keyname[3] = '?';
+      keyname[4] = '\0';
+      return keyname;
+    }
+
+  i = 0;
+  /* Now add special prefixes needed for control characters.  This can
+     potentially change C. */
+  if (CTRL_CHAR (c))
+    {
+      keyname[i++] = '\\';
+      keyname[i++] = 'C';
+      keyname[i++] = '-';
+      c = _rl_to_lower (UNCTRL (c));
+    }
+
+  /* Now, if the character needs to be quoted with a backslash, do that. */
+  if (c == '\\' || c == '"')
+    keyname[i++] = '\\';
+
+  /* Now add the key, terminate the string, and return it. */
+  keyname[i++] = (char) c;
+  keyname[i] = '\0';
+
+  return keyname;
+}
+
+/* Return a NULL terminated array of strings which represent the key
+   sequences that are used to invoke FUNCTION in MAP. */
+char **
+rl_invoking_keyseqs_in_map (function, map)
+     Function *function;
+     Keymap map;
+{
+  register int key;
+  char **result;
+  int result_index, result_size;
+
+  result = (char **)NULL;
+  result_index = result_size = 0;
+
+  for (key = 0; key < KEYMAP_SIZE; key++)
+    {
+      switch (map[key].type)
+	{
+	case ISMACR:
+	  /* Macros match, if, and only if, the pointers are identical.
+	     Thus, they are treated exactly like functions in here. */
+	case ISFUNC:
+	  /* If the function in the keymap is the one we are looking for,
+	     then add the current KEY to the list of invoking keys. */
+	  if (map[key].function == function)
+	    {
+	      char *keyname;
+
+	      keyname = _rl_get_keyname (key);
+
+	      if (result_index + 2 > result_size)
+	        {
+	          result_size += 10;
+		  result = (char **) xrealloc (result, result_size * sizeof (char *));
+	        }
+
+	      result[result_index++] = keyname;
+	      result[result_index] = (char *)NULL;
+	    }
+	  break;
+
+	case ISKMAP:
+	  {
+	    char **seqs;
+	    register int i;
+
+	    /* Find the list of keyseqs in this map which have FUNCTION as
+	       their target.  Add the key sequences found to RESULT. */
+	    if (map[key].function)
+	      seqs =
+	        rl_invoking_keyseqs_in_map (function, FUNCTION_TO_KEYMAP (map, key));
+	    else
+	      break;
+
+	    if (seqs == 0)
+	      break;
+
+	    for (i = 0; seqs[i]; i++)
+	      {
+		char *keyname = (char *)xmalloc (6 + strlen (seqs[i]));
+
+		if (key == ESC)
+		  sprintf (keyname, "\\e");
+		else if (CTRL_CHAR (key))
+		  sprintf (keyname, "\\C-%c", _rl_to_lower (UNCTRL (key)));
+		else if (key == RUBOUT)
+		  sprintf (keyname, "\\C-?");
+		else if (key == '\\' || key == '"')
+		  {
+		    keyname[0] = '\\';
+		    keyname[1] = (char) key;
+		    keyname[2] = '\0';
+		  }
+		else
+		  {
+		    keyname[0] = (char) key;
+		    keyname[1] = '\0';
+		  }
+		
+		strcat (keyname, seqs[i]);
+		free (seqs[i]);
+
+		if (result_index + 2 > result_size)
+		  {
+		    result_size += 10;
+		    result = (char **) xrealloc (result, result_size * sizeof (char *));
+		  }
+
+		result[result_index++] = keyname;
+		result[result_index] = (char *)NULL;
+	      }
+
+	    free (seqs);
+	  }
+	  break;
+	}
+    }
+  return (result);
+}
+
+/* Return a NULL terminated array of strings which represent the key
+   sequences that can be used to invoke FUNCTION using the current keymap. */
+char **
+rl_invoking_keyseqs (function)
+     Function *function;
+{
+  return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
+}
+
+/* Print all of the functions and their bindings to rl_outstream.  If
+   PRINT_READABLY is non-zero, then print the output in such a way
+   that it can be read back in. */
+void
+rl_function_dumper (print_readably)
+     int print_readably;
+{
+  register int i;
+  char **names;
+  char *name;
+
+  names = rl_funmap_names ();
+
+  fprintf (rl_outstream, "\n");
+
+  for (i = 0; name = names[i]; i++)
+    {
+      Function *function;
+      char **invokers;
+
+      function = rl_named_function (name);
+      invokers = rl_invoking_keyseqs_in_map (function, _rl_keymap);
+
+      if (print_readably)
+	{
+	  if (!invokers)
+	    fprintf (rl_outstream, "# %s (not bound)\n", name);
+	  else
+	    {
+	      register int j;
+
+	      for (j = 0; invokers[j]; j++)
+		{
+		  fprintf (rl_outstream, "\"%s\": %s\n",
+			   invokers[j], name);
+		  free (invokers[j]);
+		}
+
+	      free (invokers);
+	    }
+	}
+      else
+	{
+	  if (!invokers)
+	    fprintf (rl_outstream, "%s is not bound to any keys\n",
+		     name);
+	  else
+	    {
+	      register int j;
+
+	      fprintf (rl_outstream, "%s can be found on ", name);
+
+	      for (j = 0; invokers[j] && j < 5; j++)
+		{
+		  fprintf (rl_outstream, "\"%s\"%s", invokers[j],
+			   invokers[j + 1] ? ", " : ".\n");
+		}
+
+	      if (j == 5 && invokers[j])
+		fprintf (rl_outstream, "...\n");
+
+	      for (j = 0; invokers[j]; j++)
+		free (invokers[j]);
+
+	      free (invokers);
+	    }
+	}
+    }
+}
+
+/* Print all of the current functions and their bindings to
+   rl_outstream.  If an explicit argument is given, then print
+   the output in such a way that it can be read back in. */
+int
+rl_dump_functions (count, key)
+     int count, key;
+{
+  if (rl_dispatching)
+    fprintf (rl_outstream, "\r\n");
+  rl_function_dumper (rl_explicit_arg);
+  rl_on_new_line ();
+  return (0);
+}
+
+static void
+_rl_macro_dumper_internal (print_readably, map, prefix)
+     int print_readably;
+     Keymap map;
+     char *prefix;
+{
+  register int key;
+  char *keyname, *out;
+  int prefix_len;
+
+  for (key = 0; key < KEYMAP_SIZE; key++)
+    {
+      switch (map[key].type)
+	{
+	case ISMACR:
+	  keyname = _rl_get_keyname (key);
+#if 0
+	  out = (char *)map[key].function;
+#else
+	  out = _rl_untranslate_macro_value ((char *)map[key].function);
+#endif
+	  if (print_readably)
+	    fprintf (rl_outstream, "\"%s%s\": \"%s\"\n", prefix ? prefix : "",
+						         keyname,
+						         out ? out : "");
+	  else
+	    fprintf (rl_outstream, "%s%s outputs %s\n", prefix ? prefix : "",
+							keyname,
+							out ? out : "");
+	  free (keyname);
+#if 1
+	  free (out);
+#endif
+	  break;
+	case ISFUNC:
+	  break;
+	case ISKMAP:
+	  prefix_len = prefix ? strlen (prefix) : 0;
+	  if (key == ESC)
+	    {
+	      keyname = xmalloc (3 + prefix_len);
+	      if (prefix)
+		strcpy (keyname, prefix);
+	      keyname[prefix_len] = '\\';
+	      keyname[prefix_len + 1] = 'e';
+	      keyname[prefix_len + 2] = '\0';
+	    }
+	  else
+	    {
+	      keyname = _rl_get_keyname (key);
+	      if (prefix)
+		{
+		  out = xmalloc (strlen (keyname) + prefix_len + 1);
+		  strcpy (out, prefix);
+		  strcpy (out + prefix_len, keyname);
+		  free (keyname);
+		  keyname = out;
+		}
+	    }
+
+	  _rl_macro_dumper_internal (print_readably, FUNCTION_TO_KEYMAP (map, key), keyname);
+	  free (keyname);
+	  break;
+	}
+    }
+}
+
+void
+rl_macro_dumper (print_readably)
+     int print_readably;
+{
+  _rl_macro_dumper_internal (print_readably, _rl_keymap, (char *)NULL);
+}
+
+int
+rl_dump_macros (count, key)
+     int count, key;
+{
+  if (rl_dispatching)
+    fprintf (rl_outstream, "\r\n");
+  rl_macro_dumper (rl_explicit_arg);
+  rl_on_new_line ();
+  return (0);
+}
+
+void
+rl_variable_dumper (print_readably)
+     int print_readably;
+{
+  int i;
+  char *kname;
+
+  for (i = 0; boolean_varlist[i].name; i++)
+    {
+      if (print_readably)
+        fprintf (rl_outstream, "set %s %s\n", boolean_varlist[i].name,
+			       *boolean_varlist[i].value ? "on" : "off");
+      else
+        fprintf (rl_outstream, "%s is set to `%s'\n", boolean_varlist[i].name,
+			       *boolean_varlist[i].value ? "on" : "off");
+    }
+
+  /* bell-style */
+  switch (_rl_bell_preference)
+    {
+    case NO_BELL: kname = "none"; break;
+    case VISIBLE_BELL: kname = "visible"; break;
+    case AUDIBLE_BELL:
+    default: kname = "audible"; break;
+    }
+  if (print_readably)
+    fprintf (rl_outstream, "set bell-style %s\n", kname);
+  else
+    fprintf (rl_outstream, "bell-style is set to `%s'\n", kname);
+
+  /* comment-begin */
+  if (print_readably)
+    fprintf (rl_outstream, "set comment-begin %s\n", _rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
+  else
+    fprintf (rl_outstream, "comment-begin is set to `%s'\n", _rl_comment_begin ? _rl_comment_begin : "");
+
+  /* completion-query-items */
+  if (print_readably)
+    fprintf (rl_outstream, "set completion-query-items %d\n", rl_completion_query_items);
+  else
+    fprintf (rl_outstream, "completion-query-items is set to `%d'\n", rl_completion_query_items);
+
+  /* editing-mode */
+  if (print_readably)
+    fprintf (rl_outstream, "set editing-mode %s\n", (rl_editing_mode == emacs_mode) ? "emacs" : "vi");
+  else
+    fprintf (rl_outstream, "editing-mode is set to `%s'\n", (rl_editing_mode == emacs_mode) ? "emacs" : "vi");
+
+  /* keymap */
+  kname = rl_get_keymap_name (_rl_keymap);
+  if (kname == 0)
+    kname = rl_get_keymap_name_from_edit_mode ();
+  if (print_readably)
+    fprintf (rl_outstream, "set keymap %s\n", kname ? kname : "none");
+  else
+    fprintf (rl_outstream, "keymap is set to `%s'\n", kname ? kname : "none");
+}
+
+/* Print all of the current variables and their values to
+   rl_outstream.  If an explicit argument is given, then print
+   the output in such a way that it can be read back in. */
+int
+rl_dump_variables (count, key)
+     int count, key;
+{
+  if (rl_dispatching)
+    fprintf (rl_outstream, "\r\n");
+  rl_variable_dumper (rl_explicit_arg);
+  rl_on_new_line ();
+  return (0);
+}
+
+/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound. */
+void
+_rl_bind_if_unbound (keyseq, default_func)
+     char *keyseq;
+     Function *default_func;
+{
+  Function *func;
+
+  if (keyseq)
+    {
+      func = rl_function_of_keyseq (keyseq, _rl_keymap, (int *)NULL);
+      if (!func || func == rl_do_lowercase_version)
+	rl_set_key (keyseq, default_func, _rl_keymap);
+    }
+}
+
+/* Return non-zero if any members of ARRAY are a substring in STRING. */
+static int
+substring_member_of_array (string, array)
+     char *string, **array;
+{
+  while (*array)
+    {
+      if (_rl_strindex (string, *array))
+	return (1);
+      array++;
+    }
+  return (0);
+}
diff --git a/readline/callback.c b/readline/callback.c
new file mode 100644
--- /dev/null
+++ b/readline/callback.c
@@ -0,0 +1,149 @@
+/* callback.c -- functions to use readline as an X `callback' mechanism. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include "rlconf.h"
+
+#if defined (READLINE_CALLBACKS)
+
+#include <sys/types.h>
+#include <stdio.h>
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+#include "readline.h"
+
+extern void readline_internal_startup ();
+extern char *readline_internal_teardown ();
+extern int readline_internal_char ();
+extern void _rl_init_line_state ();
+
+extern int _rl_meta_flag;
+extern char *rl_prompt;
+extern int rl_visible_prompt_length;
+
+/* **************************************************************** */
+/*								    */
+/*			Callback Readline Functions                 */
+/*								    */
+/* **************************************************************** */
+
+/* Allow using readline in situations where a program may have multiple
+   things to handle at once, and dispatches them via select().  Call
+   rl_callback_handler_install() with the prompt and a function to call
+   whenever a complete line of input is ready.  The user must then
+   call readline_char() every time some input is available, and 
+   readline_char() will call the user's function with the complete text
+   read in at each end of line.  The terminal is kept prepped and signals
+   handled all the time, except during calls to the user's function. */
+
+VFunction *rl_linefunc;		/* user callback function */
+static int in_handler;		/* terminal_prepped and signals set? */
+
+/* Make sure the terminal is set up, initialize readline, and prompt. */
+static void
+_rl_callback_newline ()
+{
+  rl_initialize ();
+
+  if (in_handler == 0)
+    {
+      in_handler = 1;
+
+      (*rl_prep_term_function) (_rl_meta_flag);
+
+#if defined (HANDLE_SIGNALS)
+      rl_set_signals ();
+#endif
+    }
+
+  readline_internal_setup ();
+}
+
+/* Install a readline handler, set up the terminal, and issue the prompt. */
+void
+rl_callback_handler_install (prompt, linefunc)
+     char *prompt;
+     VFunction *linefunc;
+{
+  rl_prompt = prompt;
+  rl_visible_prompt_length = rl_prompt ? rl_expand_prompt (rl_prompt) : 0;
+  rl_linefunc = linefunc;
+  _rl_callback_newline ();
+}
+
+/* Read one character, and dispatch to the handler if it ends the line. */
+void
+rl_callback_read_char ()
+{
+  char *line;
+  int eof;
+
+  if (rl_linefunc == NULL)
+    {
+      fprintf (stderr, "readline: readline_callback_read_char() called with no handler!\r\n");
+      abort ();
+    }
+
+  eof = readline_internal_char ();
+
+  if (rl_done)
+    {
+      line = readline_internal_teardown (eof);
+
+      (*rl_deprep_term_function) ();
+#if defined (HANDLE_SIGNALS)
+      rl_clear_signals ();
+#endif
+      in_handler = 0;
+      (*rl_linefunc) (line);
+
+    /* If the user did not clear out the line, do it for him. */
+    if (rl_line_buffer[0])
+      _rl_init_line_state ();
+
+    /* Redisplay the prompt if readline_handler_{install,remove} not called. */
+      if (in_handler == 0 && rl_linefunc)
+	_rl_callback_newline ();
+    }
+}
+
+/* Remove the handler, and make sure the terminal is in its normal state. */
+void
+rl_callback_handler_remove ()
+{
+  rl_linefunc = NULL;
+  if (in_handler)
+    {
+      in_handler = 0;
+      (*rl_deprep_term_function) ();
+#if defined (HANDLE_SIGNALS)
+      rl_clear_signals ();
+#endif
+    }
+}
+
+#endif
diff --git a/readline/chardefs.h b/readline/chardefs.h
new file mode 100644
--- /dev/null
+++ b/readline/chardefs.h
@@ -0,0 +1,127 @@
+/* chardefs.h -- Character definitions for readline. */
+
+/* Copyright (C) 1994 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#ifndef _CHARDEFS_H_
+#define _CHARDEFS_H_
+
+#include <ctype.h>
+
+#if defined (HAVE_CONFIG_H)
+#  if defined (HAVE_STRING_H)
+#    include <string.h>
+#  else
+#    include <strings.h>
+#  endif /* HAVE_STRING_H */
+#else
+#  include <string.h>
+#endif /* !HAVE_CONFIG_H */
+
+#ifndef whitespace
+#define whitespace(c) (((c) == ' ') || ((c) == '\t'))
+#endif
+
+#ifdef CTRL
+#undef CTRL
+#endif
+
+/* Some character stuff. */
+#define control_character_threshold 0x020   /* Smaller than this is control. */
+#define control_character_mask 0x1f	    /* 0x20 - 1 */
+#define meta_character_threshold 0x07f	    /* Larger than this is Meta. */
+#define control_character_bit 0x40	    /* 0x000000, must be off. */
+#define meta_character_bit 0x080	    /* x0000000, must be on. */
+#define largest_char 255		    /* Largest character value. */
+
+#define CTRL_CHAR(c) ((c) < control_character_threshold && (c) >= 0)
+#define META_CHAR(c) ((c) > meta_character_threshold && (c) <= largest_char)
+
+#define CTRL(c) ((c) & control_character_mask)
+#define META(c) ((c) | meta_character_bit)
+
+#define UNMETA(c) ((c) & (~meta_character_bit))
+#define UNCTRL(c) _rl_to_upper(((c)|control_character_bit))
+
+/* Old versions
+#define _rl_lowercase_p(c) (((c) > ('a' - 1) && (c) < ('z' + 1)))
+#define _rl_uppercase_p(c) (((c) > ('A' - 1) && (c) < ('Z' + 1)))
+#define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
+*/
+
+#define _rl_lowercase_p(c) (islower(c))
+#define _rl_uppercase_p(c) (isupper(c))
+#define _rl_digit_p(x)  (isdigit (x))
+
+#define _rl_pure_alphabetic(c) (_rl_lowercase_p(c) || _rl_uppercase_p(c))
+#define ALPHABETIC(c)	(_rl_lowercase_p(c) || _rl_uppercase_p(c) || _rl_digit_p(c))
+
+/* Old versions
+#  define _rl_to_upper(c) (_rl_lowercase_p(c) ? ((c) - 32) : (c))
+#  define _rl_to_lower(c) (_rl_uppercase_p(c) ? ((c) + 32) : (c))
+*/
+
+#ifndef _rl_to_upper
+#  define _rl_to_upper(c) (islower(c) ? toupper(c) : (c))
+#  define _rl_to_lower(c) (isupper(c) ? tolower(c) : (c))
+#endif
+
+#ifndef _rl_digit_value
+#define _rl_digit_value(x) ((x) - '0')
+#endif
+
+#ifndef NEWLINE
+#define NEWLINE '\n'
+#endif
+
+#ifndef RETURN
+#define RETURN CTRL('M')
+#endif
+
+#ifndef RUBOUT
+#define RUBOUT 0x7f
+#endif
+
+#ifndef TAB
+#define TAB '\t'
+#endif
+
+#ifdef ABORT_CHAR
+#undef ABORT_CHAR
+#endif
+#define ABORT_CHAR CTRL('G')
+
+#ifdef PAGE
+#undef PAGE
+#endif
+#define PAGE CTRL('L')
+
+#ifdef SPACE
+#undef SPACE
+#endif
+#define SPACE ' '	/* XXX - was 0x20 */
+
+#ifdef ESC
+#undef ESC
+#endif
+
+#define ESC CTRL('[')
+
+#endif  /* _CHARDEFS_H_ */
diff --git a/readline/complete.c b/readline/complete.c
new file mode 100644
--- /dev/null
+++ b/readline/complete.c
@@ -0,0 +1,1558 @@
+/* complete.c -- filename completion for readline. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <fcntl.h>
+#if defined (HAVE_SYS_FILE_H)
+#include <sys/file.h>
+#endif
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include <stdio.h>
+
+#include <errno.h>
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+#include <pwd.h>
+#if !defined (HAVE_GETPW_DECLS)
+extern struct passwd *getpwent ();
+#endif /* USG && !HAVE_GETPW_DECLS */
+
+/* ISC systems don't define getpwent() if _POSIX_SOURCE is defined. */
+#if defined (isc386) && defined (_POSIX_SOURCE)
+#  if defined (__STDC__)
+extern struct passwd *getpwent (void);
+#  else
+extern struct passwd *getpwent ();
+#  endif /* !__STDC__ */
+#endif /* isc386 && _POSIX_SOURCE */
+
+#include "posixdir.h"
+#include "posixstat.h"
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+/* Some standard library routines. */
+#include "readline.h"
+
+extern char *tilde_expand ();
+extern char *rl_copy_text ();
+extern void _rl_abort_internal ();
+extern int _rl_qsort_string_compare ();
+
+extern Function *rl_last_func;
+extern int rl_editing_mode;
+extern int screenwidth;
+
+extern void _rl_move_vert ();
+extern int _rl_vis_botlin;
+extern int rl_display_fixed;
+
+/* Forward declarations for functions defined and used in this file. */
+char *filename_completion_function ();
+char **completion_matches ();
+
+static char *rl_quote_filename ();
+static char *rl_strpbrk ();
+
+static char **remove_duplicate_matches ();
+static void insert_text ();
+static void insert_match ();
+static void append_to_match ();
+static void insert_all_matches ();
+static void display_matches ();
+static int compute_lcd_of_matches ();
+
+extern char *xmalloc (), *xrealloc ();
+
+/* If non-zero, then this is the address of a function to call when
+   completing on a directory name.  The function is called with
+   the address of a string (the current directory name) as an arg. */
+Function *rl_directory_completion_hook = (Function *)NULL;
+
+/* Non-zero means readline completion functions perform tilde expansion. */
+int rl_complete_with_tilde_expansion = 0;
+
+/* If non-zero, non-unique completions always show the list of matches. */
+int _rl_complete_show_all = 0;
+
+/* If non-zero, completed directory names have a slash appended. */
+int _rl_complete_mark_directories = 1;
+
+#if defined (VISIBLE_STATS)
+#  if !defined (X_OK)
+#    define X_OK 1
+#  endif
+
+static int stat_char ();
+
+/* Non-zero means add an additional character to each filename displayed
+   during listing completion iff rl_filename_completion_desired which helps
+   to indicate the type of file being listed. */
+int rl_visible_stats = 0;
+#endif /* VISIBLE_STATS */
+
+/* **************************************************************** */
+/*								    */
+/*	Completion matching, from readline's point of view.	    */
+/*								    */
+/* **************************************************************** */
+
+/* Local variable states what happened during the last completion attempt. */
+static int completion_changed_buffer;
+
+/* Pointer to the generator function for completion_matches ().
+   NULL means to use filename_completion_function (), the default filename
+   completer. */
+Function *rl_completion_entry_function = (Function *)NULL;
+
+/* Pointer to alternative function to create matches.
+   Function is called with TEXT, START, and END.
+   START and END are indices in RL_LINE_BUFFER saying what the boundaries
+   of TEXT are.
+   If this function exists and returns NULL then call the value of
+   rl_completion_entry_function to try to match, otherwise use the
+   array of strings returned. */
+CPPFunction *rl_attempted_completion_function = (CPPFunction *)NULL;
+
+/* Non-zero means to suppress normal filename completion after the
+   user-specified completion function has been called. */
+int rl_attempted_completion_over = 0;
+
+/* Set to a character indicating the type of completion being performed
+   by rl_complete_internal, available for use by application completion
+   functions. */
+int rl_completion_type = 0;
+
+/* Up to this many items will be displayed in response to a
+   possible-completions call.  After that, we ask the user if
+   she is sure she wants to see them all. */
+int rl_completion_query_items = 100;
+
+/* The basic list of characters that signal a break between words for the
+   completer routine.  The contents of this variable is what breaks words
+   in the shell, i.e. " \t\n\"\\'`@$><=" */
+char *rl_basic_word_break_characters = " \t\n\"\\'`@$><=;|&{(";
+
+/* List of basic quoting characters. */
+char *rl_basic_quote_characters = "\"'";
+
+/* The list of characters that signal a break between words for
+   rl_complete_internal.  The default list is the contents of
+   rl_basic_word_break_characters.  */
+char *rl_completer_word_break_characters = (char *)NULL;
+
+/* List of characters which can be used to quote a substring of the line.
+   Completion occurs on the entire substring, and within the substring
+   rl_completer_word_break_characters are treated as any other character,
+   unless they also appear within this list. */
+char *rl_completer_quote_characters = (char *)NULL;
+
+/* List of characters that should be quoted in filenames by the completer. */
+char *rl_filename_quote_characters = (char *)NULL;
+
+/* List of characters that are word break characters, but should be left
+   in TEXT when it is passed to the completion function.  The shell uses
+   this to help determine what kind of completing to do. */
+char *rl_special_prefixes = (char *)NULL;
+
+/* If non-zero, then disallow duplicates in the matches. */
+int rl_ignore_completion_duplicates = 1;
+
+/* Non-zero means that the results of the matches are to be treated
+   as filenames.  This is ALWAYS zero on entry, and can only be changed
+   within a completion entry finder function. */
+int rl_filename_completion_desired = 0;
+
+/* Non-zero means that the results of the matches are to be quoted using
+   double quotes (or an application-specific quoting mechanism) if the
+   filename contains any characters in rl_filename_quote_chars.  This is
+   ALWAYS non-zero on entry, and can only be changed within a completion
+   entry finder function. */
+int rl_filename_quoting_desired = 1;
+
+/* This function, if defined, is called by the completer when real
+   filename completion is done, after all the matching names have been
+   generated. It is passed a (char**) known as matches in the code below.
+   It consists of a NULL-terminated array of pointers to potential
+   matching strings.  The 1st element (matches[0]) is the maximal
+   substring that is common to all matches. This function can re-arrange
+   the list of matches as required, but all elements of the array must be
+   free()'d if they are deleted. The main intent of this function is
+   to implement FIGNORE a la SunOS csh. */
+Function *rl_ignore_some_completions_function = (Function *)NULL;
+
+/* Set to a function to quote a filename in an application-specific fashion.
+   Called with the text to quote, the type of match found (single or multiple)
+   and a pointer to the quoting character to be used, which the function can
+   reset if desired. */
+CPFunction *rl_filename_quoting_function = rl_quote_filename;
+         
+/* Function to call to remove quoting characters from a filename.  Called
+   before completion is attempted, so the embedded quotes do not interfere
+   with matching names in the file system.  Readline doesn't do anything
+   with this; it's set only by applications. */
+CPFunction *rl_filename_dequoting_function = (CPFunction *)NULL;
+
+/* Function to call to decide whether or not a word break character is
+   quoted.  If a character is quoted, it does not break words for the
+   completer. */
+Function *rl_char_is_quoted_p = (Function *)NULL;
+
+/* Character appended to completed words when at the end of the line.  The
+   default is a space. */
+int rl_completion_append_character = ' ';
+
+/* If non-zero, inhibit completion (temporarily). */
+int rl_inhibit_completion;
+
+/* Complete the word at or before point.  You have supplied the function
+   that does the initial simple matching selection algorithm (see
+   completion_matches ()).  The default is to do filename completion. */
+int
+rl_complete (ignore, invoking_key)
+     int ignore, invoking_key;
+{
+  if (rl_inhibit_completion)
+    return (rl_insert (ignore, invoking_key));
+  else if (rl_last_func == rl_complete && !completion_changed_buffer)
+    return (rl_complete_internal ('?'));
+  else if (_rl_complete_show_all)
+    return (rl_complete_internal ('!'));
+  else
+    return (rl_complete_internal (TAB));
+}
+
+/* List the possible completions.  See description of rl_complete (). */
+int
+rl_possible_completions (ignore, invoking_key)
+     int ignore, invoking_key;
+{
+  return (rl_complete_internal ('?'));
+}
+
+int
+rl_insert_completions (ignore, invoking_key)
+     int ignore, invoking_key;
+{
+  return (rl_complete_internal ('*'));
+}
+
+/* The user must press "y" or "n". Non-zero return means "y" pressed. */
+static int
+get_y_or_n ()
+{
+  int c;
+
+  for (;;)
+    {
+      c = rl_read_key ();
+      if (c == 'y' || c == 'Y' || c == ' ')
+	return (1);
+      if (c == 'n' || c == 'N' || c == RUBOUT)
+	return (0);
+      if (c == ABORT_CHAR)
+	_rl_abort_internal ();
+      ding ();
+    }
+}
+
+/* Return the portion of PATHNAME that should be output when listing
+   possible completions.  If we are hacking filename completion, we
+   are only interested in the basename, the portion following the
+   final slash.  Otherwise, we return what we were passed. */
+static char *
+printable_part (pathname)
+      char *pathname;
+{
+  char *temp;
+
+  temp = rl_filename_completion_desired ? strrchr (pathname, '/') : (char *)NULL;
+  return (temp ? ++temp : pathname);
+}
+
+/* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we
+   are using it, check for and output a single character for `special'
+   filenames.  Return 1 if we printed an extension character, 0 if not. */
+
+#define PUTX(c) \
+      if (CTRL_CHAR (c)) \
+        { \
+          putc ('^', rl_outstream); \
+          putc (UNCTRL (c), rl_outstream); \
+        } \
+      else if (c == RUBOUT) \
+	{ \
+	  putc ('^', rl_outstream); \
+	  putc ('?', rl_outstream); \
+	} \
+      else \
+	putc (c, rl_outstream)
+
+static int
+print_filename (to_print, full_pathname)
+     char *to_print, *full_pathname;
+{
+#if !defined (VISIBLE_STATS)
+  char *s;
+
+  for (s = to_print; *s; s++)
+    {
+      PUTX (*s);
+    }
+  return 0;
+#else  
+  char *s, c, *new_full_pathname;
+  int extension_char, slen, tlen;
+
+  for (s = to_print; *s; s++)
+    {
+      PUTX (*s);
+    }
+
+ if (rl_filename_completion_desired && rl_visible_stats)
+    {
+      /* If to_print != full_pathname, to_print is the basename of the
+	 path passed.  In this case, we try to expand the directory
+	 name before checking for the stat character. */
+      if (to_print != full_pathname)
+	{
+	  /* Terminate the directory name. */
+	  c = to_print[-1];
+	  to_print[-1] = '\0';
+
+	  s = tilde_expand (full_pathname);
+	  if (rl_directory_completion_hook)
+	    (*rl_directory_completion_hook) (&s);
+
+	  slen = strlen (s);
+	  tlen = strlen (to_print);
+	  new_full_pathname = xmalloc (slen + tlen + 2);
+	  strcpy (new_full_pathname, s);
+	  new_full_pathname[slen] = '/';
+	  strcpy (new_full_pathname + slen + 1, to_print);
+
+	  extension_char = stat_char (new_full_pathname);
+
+	  free (new_full_pathname);
+	  to_print[-1] = c;
+	}
+      else
+	{
+	  s = tilde_expand (full_pathname);
+	  extension_char = stat_char (s);
+	}
+
+      free (s);
+      if (extension_char)
+	putc (extension_char, rl_outstream);
+      return (extension_char != 0);
+    }
+  else
+    return 0;
+#endif /* VISIBLE_STATS */
+}
+
+static char *
+rl_quote_filename (s, rtype, qcp)
+     char *s;
+     int rtype;
+     char *qcp;
+{
+  char *r;
+
+  r = xmalloc (strlen (s) + 2);
+  *r = *rl_completer_quote_characters;
+  strcpy (r + 1, s);
+  if (qcp)
+    *qcp = *rl_completer_quote_characters;
+  return r;
+}
+
+/* Find the bounds of the current word for completion purposes, and leave
+   rl_point set to the end of the word.  This function skips quoted
+   substrings (characters between matched pairs of characters in
+   rl_completer_quote_characters.  First we try to find an unclosed
+   quoted substring on which to do matching.  If one is not found, we use
+   the word break characters to find the boundaries of the current word.
+   We call an application-specific function to decide whether or not a
+   particular word break character is quoted; if that function returns a
+   non-zero result, the character does not break a word.  This function
+   returns the opening quote character if we found an unclosed quoted
+   substring, '\0' otherwise.  FP, if non-null, is set to a value saying
+   which (shell-like) quote characters we found (single quote, double
+   quote, or backslash) anywhere in the string.  DP, if non-null, is set to
+   the value of the delimiter character that caused a word break. */
+
+static char
+find_completion_word (fp, dp)
+     int *fp, *dp;
+{
+  int scan, end, found_quote, delimiter, pass_next, isbrk;
+  char quote_char;
+
+  end = rl_point;
+  found_quote = delimiter = 0;
+  quote_char = '\0';
+
+  if (rl_completer_quote_characters)
+    {
+      /* We have a list of characters which can be used in pairs to
+	 quote substrings for the completer.  Try to find the start
+	 of an unclosed quoted substring. */
+      /* FOUND_QUOTE is set so we know what kind of quotes we found. */
+      for (scan = pass_next = 0; scan < end; scan++)
+	{
+	  if (pass_next)
+	    {
+	      pass_next = 0;
+	      continue;
+	    }
+
+	  if (rl_line_buffer[scan] == '\\')
+	    {
+	      pass_next = 1;
+	      found_quote |= RL_QF_BACKSLASH;
+	      continue;
+	    }
+
+	  if (quote_char != '\0')
+	    {
+	      /* Ignore everything until the matching close quote char. */
+	      if (rl_line_buffer[scan] == quote_char)
+		{
+		  /* Found matching close.  Abandon this substring. */
+		  quote_char = '\0';
+		  rl_point = end;
+		}
+	    }
+	  else if (strchr (rl_completer_quote_characters, rl_line_buffer[scan]))
+	    {
+	      /* Found start of a quoted substring. */
+	      quote_char = rl_line_buffer[scan];
+	      rl_point = scan + 1;
+	      /* Shell-like quoting conventions. */
+	      if (quote_char == '\'')
+		found_quote |= RL_QF_SINGLE_QUOTE;
+	      else if (quote_char == '"')
+		found_quote |= RL_QF_DOUBLE_QUOTE;
+	    }
+	}
+    }
+
+  if (rl_point == end && quote_char == '\0')
+    {
+      /* We didn't find an unclosed quoted substring upon which to do
+         completion, so use the word break characters to find the
+         substring on which to complete. */
+      while (--rl_point)
+	{
+	  scan = rl_line_buffer[rl_point];
+
+	  if (strchr (rl_completer_word_break_characters, scan) == 0)
+	    continue;
+
+	  /* Call the application-specific function to tell us whether
+	     this word break character is quoted and should be skipped. */
+	  if (rl_char_is_quoted_p && found_quote &&
+	      (*rl_char_is_quoted_p) (rl_line_buffer, rl_point))
+	    continue;
+
+	  /* Convoluted code, but it avoids an n^2 algorithm with calls
+	     to char_is_quoted. */
+	  break;
+	}
+    }
+
+  /* If we are at an unquoted word break, then advance past it. */
+  scan = rl_line_buffer[rl_point];
+
+  /* If there is an application-specific function to say whether or not
+     a character is quoted and we found a quote character, let that
+     function decide whether or not a character is a word break, even
+     if it is found in rl_completer_word_break_characters. */
+  if (rl_char_is_quoted_p)
+    isbrk = (found_quote == 0 ||
+ 		(*rl_char_is_quoted_p) (rl_line_buffer, rl_point) == 0) &&
+	      strchr (rl_completer_word_break_characters, scan) != 0;
+  else
+    isbrk = strchr (rl_completer_word_break_characters, scan) != 0;
+
+  if (isbrk)
+    {
+      /* If the character that caused the word break was a quoting
+	 character, then remember it as the delimiter. */
+      if (rl_basic_quote_characters && strchr (rl_basic_quote_characters, scan) && (end - rl_point) > 1)
+	delimiter = scan;
+
+      /* If the character isn't needed to determine something special
+	 about what kind of completion to perform, then advance past it. */
+      if (rl_special_prefixes == 0 || strchr (rl_special_prefixes, scan) == 0)
+	rl_point++;
+    }
+
+  if (fp)
+    *fp = found_quote;
+  if (dp)
+    *dp = delimiter;
+
+  return (quote_char);
+}
+
+static char **
+gen_completion_matches (text, start, end, our_func, found_quote, quote_char)
+     char *text;
+     int start, end;
+     Function *our_func;
+     int found_quote, quote_char;
+{
+  char **matches, *temp;
+
+  /* If the user wants to TRY to complete, but then wants to give
+     up and use the default completion function, they set the
+     variable rl_attempted_completion_function. */
+  if (rl_attempted_completion_function)
+    {
+      matches = (*rl_attempted_completion_function) (text, start, end);
+
+      if (matches || rl_attempted_completion_over)
+	{
+	  rl_attempted_completion_over = 0;
+	  return (matches);
+	}
+    }
+
+  /* Beware -- we're stripping the quotes here.  Do this only if we know
+     we are doing filename completion and the application has defined a
+     filename dequoting function. */
+  temp = (char *)NULL;
+  if (found_quote && our_func == (Function *)filename_completion_function &&
+      rl_filename_dequoting_function)
+    {
+      /* delete single and double quotes */
+      temp = (*rl_filename_dequoting_function) (text, quote_char);
+      text = temp;	/* not freeing text is not a memory leak */
+    }
+
+  matches = completion_matches (text, our_func);
+  FREE (temp);
+  return matches;  
+}
+
+/* Filter out duplicates in MATCHES.  This frees up the strings in
+   MATCHES. */
+static char **
+remove_duplicate_matches (matches)
+     char **matches;
+{
+  char *lowest_common;
+  int i, j, newlen;
+  char dead_slot;
+  char **temp_array;
+
+  /* Sort the items. */
+  for (i = 0; matches[i]; i++)
+    ;
+
+  /* Sort the array without matches[0], since we need it to
+     stay in place no matter what. */
+  if (i)
+    qsort (matches+1, i-1, sizeof (char *), _rl_qsort_string_compare);
+
+  /* Remember the lowest common denominator for it may be unique. */
+  lowest_common = savestring (matches[0]);
+
+  for (i = newlen = 0; matches[i + 1]; i++)
+    {
+      if (strcmp (matches[i], matches[i + 1]) == 0)
+	{
+	  free (matches[i]);
+	  matches[i] = (char *)&dead_slot;
+	}
+      else
+	newlen++;
+    }
+
+  /* We have marked all the dead slots with (char *)&dead_slot.
+     Copy all the non-dead entries into a new array. */
+  temp_array = (char **)xmalloc ((3 + newlen) * sizeof (char *));
+  for (i = j = 1; matches[i]; i++)
+    {
+      if (matches[i] != (char *)&dead_slot)
+	temp_array[j++] = matches[i];
+    }
+  temp_array[j] = (char *)NULL;
+
+  if (matches[0] != (char *)&dead_slot)
+    free (matches[0]);
+
+  /* Place the lowest common denominator back in [0]. */
+  temp_array[0] = lowest_common;
+
+  /* If there is one string left, and it is identical to the
+     lowest common denominator, then the LCD is the string to
+     insert. */
+  if (j == 2 && strcmp (temp_array[0], temp_array[1]) == 0)
+    {
+      free (temp_array[1]);
+      temp_array[1] = (char *)NULL;
+    }
+  return (temp_array);
+}
+
+static void
+display_matches (matches)
+     char **matches;
+{
+  int len, count, limit, max, printed_len;
+  int i, j, k, l;
+  char *temp;
+
+  /* Move to the last visible line of a possibly-multiple-line command. */
+  _rl_move_vert (_rl_vis_botlin);
+
+  /* Handle simple case first.  What if there is only one answer? */
+  if (matches[1] == 0)
+    {
+      temp = printable_part (matches[0]);
+      crlf ();
+      print_filename (temp, matches[0]);
+      crlf ();
+#if 0
+      rl_on_new_line ();
+#else
+      rl_forced_update_display ();
+      rl_display_fixed = 1;
+#endif
+      return;
+    }
+
+  /* There is more than one answer.  Find out how many there are,
+     and find the maximum printed length of a single entry. */
+  for (max = 0, i = 1; matches[i]; i++)
+    {
+      temp = printable_part (matches[i]);
+      len = strlen (temp);
+
+      if (len > max)
+	max = len;
+    }
+
+  len = i - 1;
+
+  /* If there are many items, then ask the user if she really wants to
+     see them all. */
+  if (len >= rl_completion_query_items)
+    {
+      crlf ();
+      fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
+      fflush (rl_outstream);
+      if (get_y_or_n () == 0)
+	{
+	  crlf ();
+#if 0
+	  rl_on_new_line ();
+#else
+	  rl_forced_update_display ();
+	  rl_display_fixed = 1;
+#endif
+	  return;
+	}
+    }
+
+  /* How many items of MAX length can we fit in the screen window? */
+  max += 2;
+  limit = screenwidth / max;
+  if (limit != 1 && (limit * max == screenwidth))
+    limit--;
+
+  /* Avoid a possible floating exception.  If max > screenwidth,
+     limit will be 0 and a divide-by-zero fault will result. */
+  if (limit == 0)
+    limit = 1;
+
+  /* How many iterations of the printing loop? */
+  count = (len + (limit - 1)) / limit;
+
+  /* Watch out for special case.  If LEN is less than LIMIT, then
+     just do the inner printing loop.
+	   0 < len <= limit  implies  count = 1. */
+
+  /* Sort the items if they are not already sorted. */
+  if (rl_ignore_completion_duplicates == 0)
+    qsort (matches + 1, len, sizeof (char *), _rl_qsort_string_compare);
+
+  /* Print the sorted items, up-and-down alphabetically, like ls. */
+  crlf ();
+
+  for (i = 1; i <= count; i++)
+    {
+      for (j = 0, l = i; j < limit; j++)
+	{
+	  if (l > len || matches[l] == 0)
+	    break;
+	  else
+	    {
+	      temp = printable_part (matches[l]);
+	      printed_len = strlen (temp) + print_filename (temp, matches[l]);
+
+	      if (j + 1 < limit)
+		for (k = 0; k < max - printed_len; k++)
+		  putc (' ', rl_outstream);
+	    }
+	  l += count;
+	}
+      crlf ();
+    }
+
+#if 0
+  rl_on_new_line ();
+#else
+  rl_forced_update_display ();
+  rl_display_fixed = 1;
+#endif
+}
+
+static void
+insert_text (text, start, end)
+     char *text;
+     int start, end;
+{
+  rl_begin_undo_group ();
+  rl_delete_text (start, end + 1);
+  rl_point = start;
+  rl_insert_text (text);
+  rl_end_undo_group ();
+}
+
+static char *
+make_quoted_replacement (match, mtype, qc)
+     char *match;
+     int mtype;
+     char *qc;	/* Pointer to quoting character, if any */
+{
+  int should_quote, do_replace;
+  char *replacement;
+
+  /* If we are doing completion on quoted substrings, and any matches
+     contain any of the completer_word_break_characters, then auto-
+     matically prepend the substring with a quote character (just pick
+     the first one from the list of such) if it does not already begin
+     with a quote string.  FIXME: Need to remove any such automatically
+     inserted quote character when it no longer is necessary, such as
+     if we change the string we are completing on and the new set of
+     matches don't require a quoted substring. */
+  replacement = match;
+
+  should_quote = match && rl_completer_quote_characters &&
+			rl_filename_completion_desired &&
+			rl_filename_quoting_desired;
+
+  if (should_quote)
+#if defined (SHELL)
+    should_quote = should_quote && (!qc || !*qc || *qc == '"' || *qc == '\'');
+#else /* !SHELL */
+    should_quote = should_quote && (!qc || !*qc);
+#endif /* !SHELL */
+
+  if (should_quote)
+    {
+      /* If there is a single match, see if we need to quote it.
+         This also checks whether the common prefix of several
+	 matches needs to be quoted. */
+      should_quote = rl_strpbrk (match, rl_filename_quote_characters) != 0;
+
+      do_replace = should_quote ? mtype : NO_MATCH;
+      /* Quote the replacement, since we found an embedded
+	 word break character in a potential match. */
+      if (do_replace != NO_MATCH && rl_filename_quoting_function)
+	replacement = (*rl_filename_quoting_function) (match, do_replace, qc);
+    }
+  return (replacement);
+}
+
+static void
+insert_match (match, start, mtype, qc)
+     char *match;
+     int start, mtype;
+     char *qc;
+{
+  char *replacement;
+  char oqc;
+
+  oqc = qc ? *qc : '\0';
+  replacement = make_quoted_replacement (match, mtype, qc);
+
+  /* Now insert the match. */
+  if (replacement)
+    {
+      /* Don't double an opening quote character. */
+      if (qc && *qc && start && rl_line_buffer[start - 1] == *qc &&
+	    replacement[0] == *qc)
+	start--;
+      /* If make_quoted_replacement changed the quoting character, remove
+	 the opening quote and insert the (fully-quoted) replacement. */
+      else if (qc && (*qc != oqc) && start && rl_line_buffer[start - 1] == oqc &&
+	    replacement[0] != oqc)
+	start--;
+      insert_text (replacement, start, rl_point - 1);
+      if (replacement != match)
+        free (replacement);
+    }
+}
+
+/* Append any necessary closing quote and a separator character to the
+   just-inserted match.  If the user has specified that directories
+   should be marked by a trailing `/', append one of those instead.  The
+   default trailing character  */
+static void
+append_to_match (text, delimiter, quote_char)
+     char *text;
+     int delimiter, quote_char;
+{
+  char temp_string[4], *filename;
+  int temp_string_index;
+  struct stat finfo;
+
+  temp_string_index = 0;
+  if (quote_char && rl_point && rl_line_buffer[rl_point - 1] != quote_char)
+    temp_string[temp_string_index++] = quote_char;
+
+  if (delimiter)
+    temp_string[temp_string_index++] = delimiter;
+  else if (rl_completion_append_character)
+    temp_string[temp_string_index++] = rl_completion_append_character;
+
+  temp_string[temp_string_index++] = '\0';
+
+  if (rl_filename_completion_desired)
+    {
+      filename = tilde_expand (text);
+      if (stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))
+	{
+	  if (_rl_complete_mark_directories && rl_line_buffer[rl_point] != '/')
+	    rl_insert_text ("/");
+	}
+      else
+	{
+	  if (rl_point == rl_end)
+	    rl_insert_text (temp_string);
+	}
+      free (filename);
+    }
+  else
+    {
+      if (rl_point == rl_end)
+	rl_insert_text (temp_string);
+    }
+}
+
+static void
+insert_all_matches (matches, point, qc)
+     char **matches;
+     int point;
+     char *qc;
+{
+  int i;
+  char *rp;
+
+  rl_begin_undo_group ();
+  /* remove any opening quote character; make_quoted_replacement will add
+     it back. */
+  if (qc && *qc && point && rl_line_buffer[point - 1] == *qc)
+    point--;
+  rl_delete_text (point, rl_point);
+  rl_point = point;
+
+  if (matches[1])
+    {
+      for (i = 1; matches[i]; i++)
+	{
+	  rp = make_quoted_replacement (matches[i], SINGLE_MATCH, qc);
+	  rl_insert_text (rp);
+	  rl_insert_text (" ");
+	  if (rp != matches[i])
+	    free (rp);
+	}
+    }
+  else
+    {
+      rp = make_quoted_replacement (matches[0], SINGLE_MATCH, qc);
+      rl_insert_text (rp);
+      rl_insert_text (" ");
+      if (rp != matches[0])
+	free (rp);
+    }
+  rl_end_undo_group ();
+}
+
+/* Complete the word at or before point.
+   WHAT_TO_DO says what to do with the completion.
+   `?' means list the possible completions.
+   TAB means do standard completion.
+   `*' means insert all of the possible completions.
+   `!' means to do standard completion, and list all possible completions if
+   there is more than one. */
+int
+rl_complete_internal (what_to_do)
+     int what_to_do;
+{
+  char **matches, **temp_matches;
+  Function *our_func;
+  int start, end, delimiter, found_quote, nmatch, i;
+  char *text, *saved_line_buffer, *t;
+  char quote_char;
+
+  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;
+
+  our_func = rl_completion_entry_function
+		? rl_completion_entry_function
+		: (Function *)filename_completion_function;
+
+  /* Only the completion entry function can change these. */
+  rl_filename_completion_desired = 0;
+  rl_filename_quoting_desired = 1;
+
+  rl_completion_type = what_to_do;
+
+  /* We now look backwards for the start of a filename/variable word. */
+  end = rl_point;
+
+  found_quote = delimiter = 0;
+  quote_char = '\0';
+
+  if (rl_point)
+    /* This (possibly) changes rl_point.  If it returns a non-zero char,
+       we know we have an open quote. */
+    quote_char = find_completion_word (&found_quote, &delimiter);
+
+  start = rl_point;
+  rl_point = end;
+
+  text = rl_copy_text (start, end);
+  matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);
+
+  if (matches == 0)
+    {
+      ding ();
+      FREE (saved_line_buffer);
+      free (text);
+      return 0;
+    }
+    
+  /* It seems to me that in all the cases we handle we would like
+     to ignore duplicate possiblilities.  Scan for the text to
+     insert being identical to the other completions. */
+  if (rl_ignore_completion_duplicates)
+    {
+      temp_matches = remove_duplicate_matches (matches);
+      free (matches);
+      matches = temp_matches;
+    }
+
+  /* If we are matching filenames, then here is our chance to
+     do clever processing by re-examining the list.  Call the
+     ignore function with the array as a parameter.  It can
+     munge the array, deleting matches as it desires. */
+  if (rl_ignore_some_completions_function &&
+      our_func == (Function *)filename_completion_function)
+    {
+      for (nmatch = 1; matches[nmatch]; nmatch++)
+	;
+      (void)(*rl_ignore_some_completions_function) (matches);
+      if (matches == 0 || matches[0] == 0)
+	{
+	  FREE (matches);
+	  ding ();
+	  FREE (saved_line_buffer);
+	  FREE (text);
+	  return 0;
+        }
+      else
+	{
+	  /* If we removed some matches, recompute the common prefix. */
+	  for (i = 1; matches[i]; i++)
+	    ;
+	  if (i > 1 && i < nmatch)
+	    {
+	      t = matches[0];
+	      compute_lcd_of_matches (matches, i - 1, text);
+	      FREE (t);
+	    }
+	}
+    }
+  free (text);
+
+  switch (what_to_do)
+    {
+    case TAB:
+    case '!':
+      /* Insert the first match with proper quoting. */
+      if (*matches[0])
+	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
+
+      /* If there are more matches, ring the bell to indicate.
+	 If we are in vi mode, Posix.2 says to not ring the bell.
+	 If the `show-all-if-ambiguous' variable is set, display
+	 all the matches immediately.  Otherwise, if this was the
+	 only match, and we are hacking files, check the file to
+	 see if it was a directory.  If so, and the `mark-directories'
+	 variable is set, add a '/' to the name.  If not, and we
+	 are at the end of the line, then add a space.  */
+      if (matches[1])
+	{
+	  if (what_to_do == '!')
+	    {
+	      display_matches (matches);
+	      break;
+	    }
+	  else if (rl_editing_mode != vi_mode)
+	    ding ();	/* There are other matches remaining. */
+	}
+      else
+	append_to_match (matches[0], delimiter, quote_char);
+
+      break;
+
+    case '*':
+      insert_all_matches (matches, start, &quote_char);
+      break;
+
+    case '?':
+      display_matches (matches);
+      break;
+
+    default:
+      fprintf (stderr, "\r\nreadline: bad value %d for what_to_do in rl_complete\n", what_to_do);
+      ding ();
+      FREE (saved_line_buffer);
+      return 1;
+    }
+
+  for (i = 0; matches[i]; i++)
+    free (matches[i]);
+  free (matches);
+
+  /* Check to see if the line has changed through all of this manipulation. */
+  if (saved_line_buffer)
+    {
+      completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;
+      free (saved_line_buffer);
+    }
+
+  return 0;
+}
+
+#if defined (VISIBLE_STATS)
+/* Return the character which best describes FILENAME.
+     `@' for symbolic links
+     `/' for directories
+     `*' for executables
+     `=' for sockets
+     `|' for FIFOs
+     `%' for character special devices
+     `#' for block special devices */
+static int
+stat_char (filename)
+     char *filename;
+{
+  struct stat finfo;
+  int character, r;
+
+#if defined (HAVE_LSTAT) && defined (S_ISLNK)
+  r = lstat (filename, &finfo);
+#else
+  r = stat (filename, &finfo);
+#endif
+
+  if (r == -1)
+    return (0);
+
+  character = 0;
+  if (S_ISDIR (finfo.st_mode))
+    character = '/';
+#if defined (S_ISCHR)
+  else if (S_ISCHR (finfo.st_mode))
+    character = '%';
+#endif /* S_ISCHR */
+#if defined (S_ISBLK)
+  else if (S_ISBLK (finfo.st_mode))
+    character = '#';
+#endif /* S_ISBLK */
+#if defined (S_ISLNK)
+  else if (S_ISLNK (finfo.st_mode))
+    character = '@';
+#endif /* S_ISLNK */
+#if defined (S_ISSOCK)
+  else if (S_ISSOCK (finfo.st_mode))
+    character = '=';
+#endif /* S_ISSOCK */
+#if defined (S_ISFIFO)
+  else if (S_ISFIFO (finfo.st_mode))
+    character = '|';
+#endif
+  else if (S_ISREG (finfo.st_mode))
+    {
+      if (access (filename, X_OK) == 0)
+	character = '*';
+    }
+  return (character);
+}
+#endif /* VISIBLE_STATS */
+
+/* A completion function for usernames.
+   TEXT contains a partial username preceded by a random
+   character (usually `~').  */
+char *
+username_completion_function (text, state)
+     int state;
+     char *text;
+{
+#if defined (__GO32__) || defined (__WIN32__)
+  return (char *)NULL;
+#else /* !__GO32__ */
+  static char *username = (char *)NULL;
+  static struct passwd *entry;
+  static int namelen, first_char, first_char_loc;
+  char *value;
+
+  if (state == 0)
+    {
+      FREE (username);
+
+      first_char = *text;
+      first_char_loc = first_char == '~';
+
+      username = savestring (&text[first_char_loc]);
+      namelen = strlen (username);
+      setpwent ();
+    }
+
+  while (entry = getpwent ())
+    {
+      /* Null usernames should result in all users as possible completions. */
+      if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))
+	break;
+    }
+
+  if (entry == 0)
+    {
+      endpwent ();
+      return ((char *)NULL);
+    }
+  else
+    {
+      value = xmalloc (2 + strlen (entry->pw_name));
+
+      *value = *text;
+
+      strcpy (value + first_char_loc, entry->pw_name);
+
+      if (first_char == '~')
+	rl_filename_completion_desired = 1;
+
+      return (value);
+    }
+#endif /* !__GO32__ */
+}
+
+/* **************************************************************** */
+/*								    */
+/*			     Completion				    */
+/*								    */
+/* **************************************************************** */
+
+/* Non-zero means that case is not significant in completion. */
+int completion_case_fold = 0;
+
+/* Find the common prefix of the list of matches, and put it into
+   matches[0]. */
+static int
+compute_lcd_of_matches (match_list, matches, text)
+     char **match_list;
+     int matches;
+     char *text;
+{
+  register int i, c1, c2, si;
+  int low;		/* Count of max-matched characters. */
+
+  /* If only one match, just use that.  Otherwise, compare each
+     member of the list with the next, finding out where they
+     stop matching. */
+  if (matches == 1)
+    {
+      match_list[0] = match_list[1];
+      match_list[1] = (char *)NULL;
+      return 1;
+    }
+
+  for (i = 1, low = 100000; i < matches; i++)
+    {
+      if (completion_case_fold)
+	{
+	  for (si = 0;
+	       (c1 = _rl_to_lower(match_list[i][si])) &&
+	       (c2 = _rl_to_lower(match_list[i + 1][si]));
+	       si++)
+	    if (c1 != c2)
+	      break;
+	}
+      else
+	{
+	  for (si = 0;
+	       (c1 = match_list[i][si]) &&
+	       (c2 = match_list[i + 1][si]);
+	       si++)
+	    if (c1 != c2)
+	      break;
+	}
+
+      if (low > si)
+	low = si;
+    }
+
+  /* If there were multiple matches, but none matched up to even the
+     first character, and the user typed something, use that as the
+     value of matches[0]. */
+  if (low == 0 && text && *text)
+    {
+      match_list[0] = xmalloc (strlen (text) + 1);
+      strcpy (match_list[0], text);
+    }
+  else
+    {
+      match_list[0] = xmalloc (low + 1);
+      strncpy (match_list[0], match_list[1], low);
+      match_list[0][low] = '\0';
+    }
+
+  return matches;
+}
+
+/* Return an array of (char *) which is a list of completions for TEXT.
+   If there are no completions, return a NULL pointer.
+   The first entry in the returned array is the substitution for TEXT.
+   The remaining entries are the possible completions.
+   The array is terminated with a NULL pointer.
+
+   ENTRY_FUNCTION is a function of two args, and returns a (char *).
+     The first argument is TEXT.
+     The second is a state argument; it should be zero on the first call, and
+     non-zero on subsequent calls.  It returns a NULL pointer to the caller
+     when there are no more matches.
+ */
+char **
+completion_matches (text, entry_function)
+     char *text;
+     CPFunction *entry_function;
+{
+  /* Number of slots in match_list. */
+  int match_list_size;
+
+  /* The list of matches. */
+  char **match_list;
+
+  /* Number of matches actually found. */
+  int matches;
+
+  /* Temporary string binder. */
+  char *string;
+
+  matches = 0;
+  match_list_size = 10;
+  match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
+  match_list[1] = (char *)NULL;
+
+  while (string = (*entry_function) (text, matches))
+    {
+      if (matches + 1 == match_list_size)
+	match_list = (char **)xrealloc
+	  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));
+
+      match_list[++matches] = string;
+      match_list[matches + 1] = (char *)NULL;
+    }
+
+  /* If there were any matches, then look through them finding out the
+     lowest common denominator.  That then becomes match_list[0]. */
+  if (matches)
+    compute_lcd_of_matches (match_list, matches, text);
+  else				/* There were no matches. */
+    {
+      free (match_list);
+      match_list = (char **)NULL;
+    }
+  return (match_list);
+}
+
+/* Okay, now we write the entry_function for filename completion.  In the
+   general case.  Note that completion in the shell is a little different
+   because of all the pathnames that must be followed when looking up the
+   completion for a command. */
+char *
+filename_completion_function (text, state)
+     int state;
+     char *text;
+{
+  static DIR *directory = (DIR *)NULL;
+  static char *filename = (char *)NULL;
+  static char *dirname = (char *)NULL;
+  static char *users_dirname = (char *)NULL;
+  static int filename_len;
+  char *temp;
+  int dirlen;
+  struct dirent *entry;
+
+  /* If we don't have any state, then do some initialization. */
+  if (state == 0)
+    {
+      /* If we were interrupted before closing the directory or reading
+	 all of its contents, close it. */
+      if (directory)
+	{
+	  closedir (directory);
+	  directory = (DIR *)NULL;
+	}
+      FREE (dirname);
+      FREE (filename);
+      FREE (users_dirname);
+
+      filename = savestring (text);
+      if (*text == 0)
+	text = ".";
+      dirname = savestring (text);
+
+      temp = strrchr (dirname, '/');
+
+      if (temp)
+	{
+	  strcpy (filename, ++temp);
+	  *temp = '\0';
+	}
+      else
+	{
+	  dirname[0] = '.';
+	  dirname[1] = '\0';
+	}
+
+      /* We aren't done yet.  We also support the "~user" syntax. */
+
+      /* Save the version of the directory that the user typed. */
+      users_dirname = savestring (dirname);
+
+      if (*dirname == '~')
+	{
+	  temp = tilde_expand (dirname);
+	  free (dirname);
+	  dirname = temp;
+	}
+
+      if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
+	{
+	  free (users_dirname);
+	  users_dirname = savestring (dirname);
+	}
+
+      directory = opendir (dirname);
+      filename_len = strlen (filename);
+
+      rl_filename_completion_desired = 1;
+    }
+
+  /* At this point we should entertain the possibility of hacking wildcarded
+     filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name
+     contains globbing characters, then build an array of directories, and
+     then map over that list while completing. */
+  /* *** UNIMPLEMENTED *** */
+
+  /* Now that we have some state, we can read the directory. */
+
+  entry = (struct dirent *)NULL;
+  while (directory && (entry = readdir (directory)))
+    {
+      /* Special case for no filename.
+	 All entries except "." and ".." match. */
+      if (filename_len == 0)
+	{
+	  if (entry->d_name[0] != '.' ||
+	       (entry->d_name[1] &&
+		 (entry->d_name[1] != '.' || entry->d_name[2])))
+	    break;
+	}
+      else
+	{
+	  /* Otherwise, if these match up to the length of filename, then
+	     it is a match. */
+	    if ((entry->d_name[0] == filename[0]) &&
+		(((int)D_NAMLEN (entry)) >= filename_len) &&
+		(strncmp (filename, entry->d_name, filename_len) == 0))
+	      break;
+	}
+    }
+
+  if (entry == 0)
+    {
+      if (directory)
+	{
+	  closedir (directory);
+	  directory = (DIR *)NULL;
+	}
+      if (dirname)
+	{
+	  free (dirname);
+	  dirname = (char *)NULL;
+	}
+      if (filename)
+	{
+	  free (filename);
+	  filename = (char *)NULL;
+	}
+      if (users_dirname)
+	{
+	  free (users_dirname);
+	  users_dirname = (char *)NULL;
+	}
+
+      return (char *)NULL;
+    }
+  else
+    {
+      /* dirname && (strcmp (dirname, ".") != 0) */
+      if (dirname && (dirname[0] != '.' || dirname[1]))
+	{
+	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
+	    {
+	      dirlen = strlen (dirname);
+	      temp = xmalloc (2 + dirlen + D_NAMLEN (entry));
+	      strcpy (temp, dirname);
+	      /* Canonicalization cuts off any final slash present.  We
+		 may need to add it back. */
+	      if (dirname[dirlen - 1] != '/')
+	        {
+	          temp[dirlen++] = '/';
+	          temp[dirlen] = '\0';
+	        }
+	    }
+	  else
+	    {
+	      dirlen = strlen (users_dirname);
+	      temp = xmalloc (1 + dirlen + D_NAMLEN (entry));
+	      strcpy (temp, users_dirname);
+	    }
+
+	  strcpy (temp + dirlen, entry->d_name); /* strcat (temp, entry->d_name); */
+	}
+      else
+	temp = savestring (entry->d_name);
+
+      return (temp);
+    }
+}
+
+/* A function for simple tilde expansion. */
+int
+rl_tilde_expand (ignore, key)
+     int ignore, key;
+{
+  register int start, end;
+  char *homedir, *temp;
+  int len;
+
+  end = rl_point;
+  start = end - 1;
+
+  if (rl_point == rl_end && rl_line_buffer[rl_point] == '~')
+    {
+      homedir = tilde_expand ("~");
+      insert_text (homedir, start, end);
+      return (0);
+    }
+  else if (rl_line_buffer[start] != '~')
+    {
+      for (; !whitespace (rl_line_buffer[start]) && start >= 0; start--)
+        ;
+      start++;
+    }
+
+  end = start;
+  do
+    end++;
+  while (whitespace (rl_line_buffer[end]) == 0 && end < rl_end);
+
+  if (whitespace (rl_line_buffer[end]) || end >= rl_end)
+    end--;
+
+  /* If the first character of the current word is a tilde, perform
+     tilde expansion and insert the result.  If not a tilde, do
+     nothing. */
+  if (rl_line_buffer[start] == '~')
+    {
+      len = end - start + 1;
+      temp = xmalloc (len + 1);
+      strncpy (temp, rl_line_buffer + start, len);
+      temp[len] = '\0';
+      homedir = tilde_expand (temp);
+      free (temp);
+
+      insert_text (homedir, start, end);
+    }
+
+  return (0);
+}
+
+/* Find the first occurrence in STRING1 of any character from STRING2.
+   Return a pointer to the character in STRING1. */
+static char *
+rl_strpbrk (string1, string2)
+     char *string1, *string2;
+{
+  register char *scan;
+
+  for (; *string1; string1++)
+    {
+      for (scan = string2; *scan; scan++)
+	{
+	  if (*string1 == *scan)
+	    {
+	      return (string1);
+	    }
+	}
+    }
+  return ((char *)NULL);
+}
diff --git a/readline/config.h.in b/readline/config.h.in
new file mode 100644
--- /dev/null
+++ b/readline/config.h.in
@@ -0,0 +1,138 @@
+/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+
+/* Define as the return type of signal handlers (int or void).  */
+#undef RETSIGTYPE
+
+/* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
+#undef STAT_MACROS_BROKEN
+
+#undef VOID_SIGHANDLER
+
+/* Define if you have the lstat function. */
+#undef HAVE_LSTAT
+
+/* Define if you have the putenv function.  */
+#undef HAVE_PUTENV
+
+/* Define if you have the select function.  */
+#undef HAVE_SELECT
+
+/* Define if you have the setenv function.  */
+#undef HAVE_SETENV
+
+/* Define if you have the strcasecmp function.  */
+#undef HAVE_STRCASECMP
+
+/* Define if you have the setlocale function. */
+#undef HAVE_SETLOCALE
+
+/* Define if you have the tcgetattr function.  */
+#undef HAVE_TCGETATTR
+
+/* Define if you have the strcoll function.  */
+#undef HAVE_STRCOLL
+
+#undef STRCOLL_BROKEN
+
+/* Define if you have the <dirent.h> header file.  */
+#undef HAVE_DIRENT_H
+
+/* Define if you have the <ndir.h> header file.  */
+#undef HAVE_NDIR_H
+
+/* Define if you have the <stdlib.h> header file.  */
+#undef HAVE_STDLIB_H
+
+/* Define if you have the <string.h> header file.  */
+#undef HAVE_STRING_H
+
+/* Define if you have the <sys/dir.h> header file.  */
+#undef HAVE_SYS_DIR_H
+
+/* Define if you have the <sys/file.h> header file.  */
+#undef HAVE_SYS_FILE_H
+
+/* Define if you have the <sys/ndir.h> header file.  */
+#undef HAVE_SYS_NDIR_H
+
+/* Define if you have the <sys/pte.h> header file.  */
+#undef HAVE_SYS_PTE_H
+
+/* Define if you have the <sys/ptem.h> header file.  */
+#undef HAVE_SYS_PTEM_H
+
+/* Define if you have the <sys/select.h> header file.  */
+#undef HAVE_SYS_SELECT_H
+
+/* Define if you have the <sys/stream.h> header file.  */
+#undef HAVE_SYS_STREAM_H
+
+/* Define if you have the <termcap.h> header file.  */
+#undef HAVE_TERMCAP_H
+
+/* Define if you have the <termio.h> header file.  */
+#undef HAVE_TERMIO_H
+
+/* Define if you have the <termios.h> header file.  */
+#undef HAVE_TERMIOS_H
+
+/* Define if you have the <unistd.h> header file.  */
+#undef HAVE_UNISTD_H
+
+/* Define if you have the <varargs.h> header file.  */
+#undef HAVE_VARARGS_H
+
+/* Define if you have the <stdarg.h> header file.  */
+#undef HAVE_STDARG_H
+
+#undef HAVE_LOCALE_H
+
+/* Definitions pulled in from aclocal.m4. */
+#undef VOID_SIGHANDLER
+
+#undef GWINSZ_IN_SYS_IOCTL
+
+#undef TIOCSTAT_IN_SYS_IOCTL
+
+#undef FIONREAD_IN_SYS_IOCTL
+
+#undef SPEED_T_IN_SYS_TYPES
+
+#undef HAVE_GETPW_DECLS
+
+#undef STRUCT_DIRENT_HAS_D_INO
+
+#undef STRUCT_DIRENT_HAS_D_FILENO
+
+#undef HAVE_BSD_SIGNALS
+
+#undef HAVE_POSIX_SIGNALS
+
+#undef HAVE_USG_SIGHOLD
+
+#undef MUST_REINSTALL_SIGHANDLERS
+
+#undef HAVE_POSIX_SIGSETJMP
+
+/* config.h.bot */
+/* modify settings or make new ones based on what autoconf tells us. */
+
+/* Ultrix botches type-ahead when switching from canonical to
+   non-canonical mode, at least through version 4.3 */
+#if !defined (HAVE_TERMIOS_H) || !defined (HAVE_TCGETATTR) || defined (ultrix)
+#  define TERMIOS_MISSING
+#endif
+
+#if defined (STRCOLL_BROKEN)
+#  undef HAVE_STRCOLL
+#endif
+
+#if defined (__STDC__) && defined (HAVE_STDARG_H)
+#  define PREFER_STDARG
+#  define USE_VARARGS
+#else
+#  if defined (HAVE_VARARGS_H)
+#    define PREFER_VARARGS
+#    define USE_VARARGS
+#  endif
+#endif
diff --git a/readline/configure b/readline/configure
new file mode 100755
--- /dev/null
+++ b/readline/configure
@@ -0,0 +1,2458 @@
+#! /bin/sh
+
+# From configure.in for Readline 2.1, version 2.04, from autoconf version 2.12
+LIBVERSION=2.1
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Guess values for system-dependent variables and create Makefiles.
+# Generated automatically using autoconf version 2.12 
+# Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+
+# Defaults:
+ac_help=
+ac_default_prefix=/usr/local
+# Any additions from configure.in:
+
+# Initialize some variables set by options.
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+build=NONE
+cache_file=./config.cache
+exec_prefix=NONE
+host=NONE
+no_create=
+nonopt=NONE
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+target=NONE
+verbose=
+x_includes=NONE
+x_libraries=NONE
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+# Initialize some other variables.
+subdirs=
+MFLAGS= MAKEFLAGS=
+# Maximum number of lines to put in a shell here document.
+ac_max_here_lines=12
+
+ac_prev=
+for ac_option
+do
+
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  case "$ac_option" in
+  -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+  *) ac_optarg= ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case "$ac_option" in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir="$ac_optarg" ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build="$ac_optarg" ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file="$ac_optarg" ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir="$ac_optarg" ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    eval "enable_${ac_feature}=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
+    fi
+    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_${ac_feature}='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix="$ac_optarg" ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he)
+    # Omit some internal or obsolete options to make the list less imposing.
+    # This message is too long to be a string in the A/UX 3.1 sh.
+    cat << EOF
+Usage: configure [options] [host]
+Options: [defaults in brackets after descriptions]
+Configuration:
+  --cache-file=FILE       cache test results in FILE
+  --help                  print this message
+  --no-create             do not create output files
+  --quiet, --silent       do not print \`checking...' messages
+  --version               print the version of autoconf that created configure
+Directory and file names:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [same as prefix]
+  --bindir=DIR            user executables in DIR [EPREFIX/bin]
+  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
+  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
+  --datadir=DIR           read-only architecture-independent data in DIR
+                          [PREFIX/share]
+  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
+                          [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
+  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
+  --includedir=DIR        C header files in DIR [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
+  --infodir=DIR           info documentation in DIR [PREFIX/info]
+  --mandir=DIR            man documentation in DIR [PREFIX/man]
+  --srcdir=DIR            find the sources in DIR [configure dir or ..]
+  --program-prefix=PREFIX prepend PREFIX to installed program names
+  --program-suffix=SUFFIX append SUFFIX to installed program names
+  --program-transform-name=PROGRAM
+                          run sed PROGRAM on installed program names
+EOF
+    cat << EOF
+Host type:
+  --build=BUILD           configure for building on BUILD [BUILD=HOST]
+  --host=HOST             configure for HOST [guessed]
+  --target=TARGET         configure for TARGET [TARGET=HOST]
+Features and packages:
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --x-includes=DIR        X include files are in DIR
+  --x-libraries=DIR       X library files are in DIR
+EOF
+    if test -n "$ac_help"; then
+      echo "--enable and --with options recognized:$ac_help"
+    fi
+    exit 0 ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host="$ac_optarg" ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir="$ac_optarg" ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir="$ac_optarg" ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir="$ac_optarg" ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir="$ac_optarg" ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir="$ac_optarg" ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir="$ac_optarg" ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir="$ac_optarg" ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix="$ac_optarg" ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix="$ac_optarg" ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix="$ac_optarg" ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name="$ac_optarg" ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir="$ac_optarg" ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir="$ac_optarg" ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site="$ac_optarg" ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir="$ac_optarg" ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir="$ac_optarg" ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target="$ac_optarg" ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers)
+    echo "configure generated by autoconf version 2.12"
+    exit 0 ;;
+
+  -with-* | --with-*)
+    ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case "$ac_option" in
+      *=*) ;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_${ac_package}='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`echo $ac_option|sed -e 's/-*without-//'`
+    # Reject names that are not valid shell variable names.
+    if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
+      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
+    fi
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    eval "with_${ac_package}=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes="$ac_optarg" ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries="$ac_optarg" ;;
+
+  -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
+    ;;
+
+  *)
+    if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
+      echo "configure: warning: $ac_option: invalid host type" 1>&2
+    fi
+    if test "x$nonopt" != xNONE; then
+      { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
+    fi
+    nonopt="$ac_option"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
+fi
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+# File descriptor usage:
+# 0 standard input
+# 1 file creation
+# 2 errors and warnings
+# 3 some systems may open it to /dev/tty
+# 4 used on the Kubota Titan
+# 6 checking for... messages and results
+# 5 compiler messages saved in config.log
+if test "$silent" = yes; then
+  exec 6>/dev/null
+else
+  exec 6>&1
+fi
+exec 5>./config.log
+
+echo "\
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+" 1>&5
+
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Also quote any args containing shell metacharacters.
+ac_configure_args=
+for ac_arg
+do
+  case "$ac_arg" in
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c) ;;
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
+  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
+  ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+  *) ac_configure_args="$ac_configure_args $ac_arg" ;;
+  esac
+done
+
+# NLS nuisances.
+# Only set these to C if already set.  These must not be set unconditionally
+# because not all systems understand e.g. LANG=C (notably SCO).
+# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
+# Non-C LC_CTYPE values break the ctype check.
+if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
+if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
+if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
+if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo > confdefs.h
+
+# A filename unique to this package, relative to the directory that
+# configure is in, which we can look for to find out if srcdir is correct.
+ac_unique_file=readline.h
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_prog=$0
+  ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
+  test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
+  else
+    { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
+  fi
+fi
+srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
+
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    echo "loading site script $ac_site_file"
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  echo "loading cache $cache_file"
+  . $cache_file
+else
+  echo "creating cache $cache_file"
+  > $cache_file
+fi
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
+  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
+  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
+    ac_n= ac_c='
+' ac_t='	'
+  else
+    ac_n=-n ac_c= ac_t=
+  fi
+else
+  ac_n= ac_c='\c' ac_t=
+fi
+
+
+
+
+
+
+ac_aux_dir=
+for ac_dir in ./support $srcdir/./support; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { echo "configure: error: can not find install-sh or install.sh in ./support $srcdir/./support" 1>&2; exit 1; }
+fi
+ac_config_guess=$ac_aux_dir/config.guess
+ac_config_sub=$ac_aux_dir/config.sub
+ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
+
+
+
+# Make sure we can run config.sub.
+if $ac_config_sub sun4 >/dev/null 2>&1; then :
+else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking host system type""... $ac_c" 1>&6
+echo "configure:629: checking host system type" >&5
+
+host_alias=$host
+case "$host_alias" in
+NONE)
+  case $nonopt in
+  NONE)
+    if host_alias=`$ac_config_guess`; then :
+    else { echo "configure: error: can not guess host type; you must specify one" 1>&2; exit 1; }
+    fi ;;
+  *) host_alias=$nonopt ;;
+  esac ;;
+esac
+
+host=`$ac_config_sub $host_alias`
+host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$host" 1>&6
+
+
+# We want these before the checks, so the checks can modify their values.
+test -z "$CFLAGS" && CFLAGS=-g auto_cflags=1
+
+# Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:656: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_CC="gcc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:685: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  ac_prog_rejected=no
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
+        ac_prog_rejected=yes
+	continue
+      fi
+      ac_cv_prog_CC="cc"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# -gt 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    set dummy "$ac_dir/$ac_word" "$@"
+    shift
+    ac_cv_prog_CC="$@"
+  fi
+fi
+fi
+fi
+CC="$ac_cv_prog_CC"
+if test -n "$CC"; then
+  echo "$ac_t""$CC" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+  test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
+echo "configure:733: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+
+ac_ext=c
+# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
+ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
+cross_compiling=$ac_cv_prog_cc_cross
+
+cat > conftest.$ac_ext <<EOF
+#line 743 "configure"
+#include "confdefs.h"
+main(){return(0);}
+EOF
+if { (eval echo configure:747: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  ac_cv_prog_cc_works=yes
+  # If we can't run a trivial program, we are probably using a cross compiler.
+  if (./conftest; exit) 2>/dev/null; then
+    ac_cv_prog_cc_cross=no
+  else
+    ac_cv_prog_cc_cross=yes
+  fi
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  ac_cv_prog_cc_works=no
+fi
+rm -fr conftest*
+
+echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
+if test $ac_cv_prog_cc_works = no; then
+  { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
+fi
+echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
+echo "configure:767: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
+cross_compiling=$ac_cv_prog_cc_cross
+
+echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
+echo "configure:772: checking whether we are using GNU C" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:781: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+  ac_cv_prog_gcc=yes
+else
+  ac_cv_prog_gcc=no
+fi
+fi
+
+echo "$ac_t""$ac_cv_prog_gcc" 1>&6
+
+if test $ac_cv_prog_gcc = yes; then
+  GCC=yes
+  ac_test_CFLAGS="${CFLAGS+set}"
+  ac_save_CFLAGS="$CFLAGS"
+  CFLAGS=
+  echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
+echo "configure:796: checking whether ${CC-cc} accepts -g" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  echo 'void f(){}' > conftest.c
+if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
+  ac_cv_prog_cc_g=yes
+else
+  ac_cv_prog_cc_g=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
+  if test "$ac_test_CFLAGS" = set; then
+    CFLAGS="$ac_save_CFLAGS"
+  elif test $ac_cv_prog_cc_g = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-O2"
+  fi
+else
+  GCC=
+  test "${CFLAGS+set}" = set || CFLAGS="-g"
+fi
+
+
+# If we're using gcc and the user hasn't specified CFLAGS, add -O to CFLAGS.
+test -n "$GCC" && test -n "$auto_cflags" && CFLAGS="$CFLAGS -O"
+
+echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
+echo "configure:828: checking how to run the C preprocessor" >&5
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    # This must be in double quotes, not single quotes, because CPP may get
+  # substituted into the Makefile and "${CC-cc}" will confuse make.
+  CPP="${CC-cc} -E"
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp.
+  cat > conftest.$ac_ext <<EOF
+#line 843 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:849: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP="${CC-cc} -E -traditional-cpp"
+  cat > conftest.$ac_ext <<EOF
+#line 860 "configure"
+#include "confdefs.h"
+#include <assert.h>
+Syntax Error
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:866: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  :
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  CPP=/lib/cpp
+fi
+rm -f conftest*
+fi
+rm -f conftest*
+  ac_cv_prog_CPP="$CPP"
+fi
+  CPP="$ac_cv_prog_CPP"
+else
+  ac_cv_prog_CPP="$CPP"
+fi
+echo "$ac_t""$CPP" 1>&6
+
+if test $ac_cv_prog_gcc = yes; then
+    echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
+echo "configure:890: checking whether ${CC-cc} needs -traditional" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    ac_pattern="Autoconf.*'x'"
+  cat > conftest.$ac_ext <<EOF
+#line 896 "configure"
+#include "confdefs.h"
+#include <sgtty.h>
+Autoconf TIOCGETP
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "$ac_pattern" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_prog_gcc_traditional=yes
+else
+  rm -rf conftest*
+  ac_cv_prog_gcc_traditional=no
+fi
+rm -f conftest*
+
+
+  if test $ac_cv_prog_gcc_traditional = no; then
+    cat > conftest.$ac_ext <<EOF
+#line 914 "configure"
+#include "confdefs.h"
+#include <termio.h>
+Autoconf TCGETA
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "$ac_pattern" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_prog_gcc_traditional=yes
+fi
+rm -f conftest*
+
+  fi
+fi
+
+echo "$ac_t""$ac_cv_prog_gcc_traditional" 1>&6
+  if test $ac_cv_prog_gcc_traditional = yes; then
+    CC="$CC -traditional"
+  fi
+fi
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# ./install, which can be erroneously created by make from ./install.sh.
+echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
+echo "configure:946: checking for a BSD compatible install" >&5
+if test -z "$INSTALL"; then
+if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+    IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    # Account for people who put trailing slashes in PATH elements.
+    case "$ac_dir/" in
+    /|./|.//|/etc/*|/usr/sbin/*|/usr/etc/*|/sbin/*|/usr/afsws/bin/*|/usr/ucb/*) ;;
+    *)
+      # OSF1 and SCO ODT 3.0 have their own names for install.
+      for ac_prog in ginstall installbsd scoinst install; do
+        if test -f $ac_dir/$ac_prog; then
+	  if test $ac_prog = install &&
+            grep dspmsg $ac_dir/$ac_prog >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    # OSF/1 installbsd also uses dspmsg, but is usable.
+	    :
+	  else
+	    ac_cv_path_install="$ac_dir/$ac_prog -c"
+	    break 2
+	  fi
+	fi
+      done
+      ;;
+    esac
+  done
+  IFS="$ac_save_IFS"
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL="$ac_cv_path_install"
+  else
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the path is relative.
+    INSTALL="$ac_install_sh"
+  fi
+fi
+echo "$ac_t""$INSTALL" 1>&6
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+# Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
+echo "configure:998: checking for $ac_word" >&5
+if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      ac_cv_prog_RANLIB="ranlib"
+      break
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_prog_RANLIB" && ac_cv_prog_RANLIB=":"
+fi
+fi
+RANLIB="$ac_cv_prog_RANLIB"
+if test -n "$RANLIB"; then
+  echo "$ac_t""$RANLIB" 1>&6
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+
+echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
+echo "configure:1026: checking return type of signal handlers" >&5
+if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1031 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+#undef signal
+#endif
+#ifdef __cplusplus
+extern "C" void (*signal (int, void (*)(int)))(int);
+#else
+void (*signal ()) ();
+#endif
+
+int main() {
+int i;
+; return 0; }
+EOF
+if { (eval echo configure:1048: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_type_signal=void
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_type_signal=int
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_type_signal" 1>&6
+cat >> confdefs.h <<EOF
+#define RETSIGTYPE $ac_cv_type_signal
+EOF
+
+
+
+echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&6
+echo "configure:1068: checking whether stat file-mode macros are broken" >&5
+if eval "test \"`echo '$''{'ac_cv_header_stat_broken'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1073 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#if defined(S_ISBLK) && defined(S_IFDIR)
+# if S_ISBLK (S_IFDIR)
+You lose.
+# endif
+#endif
+
+#if defined(S_ISBLK) && defined(S_IFCHR)
+# if S_ISBLK (S_IFCHR)
+You lose.
+# endif
+#endif
+
+#if defined(S_ISLNK) && defined(S_IFREG)
+# if S_ISLNK (S_IFREG)
+You lose.
+# endif
+#endif
+
+#if defined(S_ISSOCK) && defined(S_IFREG)
+# if S_ISSOCK (S_IFREG)
+You lose.
+# endif
+#endif
+
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "You lose" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_header_stat_broken=yes
+else
+  rm -rf conftest*
+  ac_cv_header_stat_broken=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$ac_cv_header_stat_broken" 1>&6
+if test $ac_cv_header_stat_broken = yes; then
+  cat >> confdefs.h <<\EOF
+#define STAT_MACROS_BROKEN 1
+EOF
+
+fi
+
+ac_header_dirent=no
+for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
+echo "configure:1128: checking for $ac_hdr that defines DIR" >&5
+if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1133 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <$ac_hdr>
+int main() {
+DIR *dirp = 0;
+; return 0; }
+EOF
+if { (eval echo configure:1141: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  eval "ac_cv_header_dirent_$ac_safe=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_dirent_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_dirent_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ ac_header_dirent=$ac_hdr; break
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
+if test $ac_header_dirent = dirent.h; then
+echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
+echo "configure:1166: checking for opendir in -ldir" >&5
+ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-ldir  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1174 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char opendir();
+
+int main() {
+opendir()
+; return 0; }
+EOF
+if { (eval echo configure:1185: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  LIBS="$LIBS -ldir"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+else
+echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
+echo "configure:1207: checking for opendir in -lx" >&5
+ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lx  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 1215 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char opendir();
+
+int main() {
+opendir()
+; return 0; }
+EOF
+if { (eval echo configure:1226: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  LIBS="$LIBS -lx"
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+fi
+
+
+for ac_func in strcasecmp select setenv putenv tcgetattr setlocale lstat
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:1252: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1257 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:1280: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+echo $ac_n "checking for working strcoll""... $ac_c" 1>&6
+echo "configure:1306: checking for working strcoll" >&5
+if eval "test \"`echo '$''{'ac_cv_func_strcoll_works'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_strcoll_works=no
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1314 "configure"
+#include "confdefs.h"
+#include <string.h>
+main ()
+{
+  exit (strcoll ("abc", "def") >= 0 ||
+	strcoll ("ABC", "DEF") >= 0 ||
+	strcoll ("123", "456") >= 0);
+}
+EOF
+if { (eval echo configure:1324: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_func_strcoll_works=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_func_strcoll_works=no
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$ac_cv_func_strcoll_works" 1>&6
+if test $ac_cv_func_strcoll_works = yes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_STRCOLL 1
+EOF
+
+fi
+
+
+for ac_hdr in unistd.h stdlib.h varargs.h stdarg.h string.h \
+		sys/ptem.h sys/pte.h sys/stream.h sys/select.h \
+		termcap.h termios.h termio.h sys/file.h locale.h
+do
+ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
+echo "configure:1353: checking for $ac_hdr" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1358 "configure"
+#include "confdefs.h"
+#include <$ac_hdr>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:1363: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_hdr=HAVE_`echo $ac_hdr | sed 'y%abcdefghijklmnopqrstuvwxyz./-%ABCDEFGHIJKLMNOPQRSTUVWXYZ___%'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_hdr 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+
+echo $ac_n "checking for type of signal functions""... $ac_c" 1>&6
+echo "configure:1392: checking for type of signal functions" >&5
+if eval "test \"`echo '$''{'bash_cv_signal_vintage'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
+  cat > conftest.$ac_ext <<EOF
+#line 1398 "configure"
+#include "confdefs.h"
+#include <signal.h>
+int main() {
+
+    sigset_t ss;
+    struct sigaction sa;
+    sigemptyset(&ss); sigsuspend(&ss);
+    sigaction(SIGINT, &sa, (struct sigaction *) 0);
+    sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);
+  
+; return 0; }
+EOF
+if { (eval echo configure:1411: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  bash_cv_signal_vintage=posix
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  
+    cat > conftest.$ac_ext <<EOF
+#line 1420 "configure"
+#include "confdefs.h"
+#include <signal.h>
+int main() {
+
+	int mask = sigmask(SIGINT);
+	sigsetmask(mask); sigblock(mask); sigpause(mask);
+    
+; return 0; }
+EOF
+if { (eval echo configure:1430: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  bash_cv_signal_vintage=4.2bsd
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  
+      cat > conftest.$ac_ext <<EOF
+#line 1439 "configure"
+#include "confdefs.h"
+
+	#include <signal.h>
+	RETSIGTYPE foo() { }
+int main() {
+
+		int mask = sigmask(SIGINT);
+		sigset(SIGINT, foo); sigrelse(SIGINT);
+		sighold(SIGINT); sigpause(SIGINT);
+        
+; return 0; }
+EOF
+if { (eval echo configure:1452: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  bash_cv_signal_vintage=svr3
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_signal_vintage=v7
+    
+fi
+rm -f conftest*
+  
+fi
+rm -f conftest*
+
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$bash_cv_signal_vintage" 1>&6
+if test "$bash_cv_signal_vintage" = posix; then
+cat >> confdefs.h <<\EOF
+#define HAVE_POSIX_SIGNALS 1
+EOF
+
+elif test "$bash_cv_signal_vintage" = "4.2bsd"; then
+cat >> confdefs.h <<\EOF
+#define HAVE_BSD_SIGNALS 1
+EOF
+
+elif test "$bash_cv_signal_vintage" = svr3; then
+cat >> confdefs.h <<\EOF
+#define HAVE_USG_SIGHOLD 1
+EOF
+
+fi
+
+
+
+echo $ac_n "checking if signal handlers must be reinstalled when invoked""... $ac_c" 1>&6
+echo "configure:1493: checking if signal handlers must be reinstalled when invoked" >&5
+if eval "test \"`echo '$''{'bash_cv_must_reinstall_sighandlers'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  { echo "configure: error: cannot check signal handling if cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1501 "configure"
+#include "confdefs.h"
+
+#include <signal.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+typedef RETSIGTYPE sigfunc();
+
+int nsigint;
+
+#ifdef HAVE_POSIX_SIGNALS
+sigfunc *
+set_signal_handler(sig, handler)
+     int sig;
+     sigfunc *handler;
+{
+  struct sigaction act, oact;
+  act.sa_handler = handler;
+  act.sa_flags = 0;
+  sigemptyset (&act.sa_mask);
+  sigemptyset (&oact.sa_mask);
+  sigaction (sig, &act, &oact);
+  return (oact.sa_handler);
+}
+#else
+#define set_signal_handler(s, h) signal(s, h)
+#endif
+
+RETSIGTYPE
+sigint(s)
+int s;
+{
+  nsigint++;
+}
+
+main()
+{
+	nsigint = 0;
+	set_signal_handler(SIGINT, sigint);
+	kill((int)getpid(), SIGINT);
+	kill((int)getpid(), SIGINT);
+	exit(nsigint != 2);
+}
+
+EOF
+if { (eval echo configure:1548: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  bash_cv_must_reinstall_sighandlers=no
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  bash_cv_must_reinstall_sighandlers=yes
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$bash_cv_must_reinstall_sighandlers" 1>&6
+if test $bash_cv_must_reinstall_sighandlers = yes; then
+cat >> confdefs.h <<\EOF
+#define MUST_REINSTALL_SIGHANDLERS 1
+EOF
+
+fi
+
+
+
+echo $ac_n "checking for presence of POSIX-style sigsetjmp/siglongjmp""... $ac_c" 1>&6
+echo "configure:1573: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
+if eval "test \"`echo '$''{'bash_cv_func_sigsetjmp'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  { echo "configure: error: cannot check for sigsetjmp/siglongjmp if cross-compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1581 "configure"
+#include "confdefs.h"
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <sys/types.h>
+#include <signal.h>
+#include <setjmp.h>
+
+main()
+{
+#if !defined (_POSIX_VERSION) || !defined (HAVE_POSIX_SIGNALS)
+exit (1);
+#else
+
+int code;
+sigset_t set, oset;
+sigjmp_buf xx;
+
+/* get the mask */
+sigemptyset(&set);
+sigemptyset(&oset);
+sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &set);
+sigprocmask(SIG_BLOCK, (sigset_t *)NULL, &oset);
+
+/* save it */
+code = sigsetjmp(xx, 1);
+if (code)
+  exit(0);	/* could get sigmask and compare to oset here. */
+
+/* change it */
+sigaddset(&set, SIGINT);
+sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);
+
+/* and siglongjmp */
+siglongjmp(xx, 10);
+exit(1);
+#endif
+}
+EOF
+if { (eval echo configure:1622: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  bash_cv_func_sigsetjmp=present
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  bash_cv_func_sigsetjmp=missing
+fi
+rm -fr conftest*
+fi
+
+
+fi
+
+echo "$ac_t""$bash_cv_func_sigsetjmp" 1>&6
+if test $bash_cv_func_sigsetjmp = present; then
+cat >> confdefs.h <<\EOF
+#define HAVE_POSIX_SIGSETJMP 1
+EOF
+
+fi
+
+echo $ac_n "checking for lstat""... $ac_c" 1>&6
+echo "configure:1646: checking for lstat" >&5
+if eval "test \"`echo '$''{'bash_cv_func_lstat'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1651 "configure"
+#include "confdefs.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+int main() {
+ lstat("",(struct stat *)0); 
+; return 0; }
+EOF
+if { (eval echo configure:1661: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  bash_cv_func_lstat=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_func_lstat=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$bash_cv_func_lstat" 1>&6
+if test $bash_cv_func_lstat = yes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_LSTAT 1
+EOF
+
+fi
+
+echo $ac_n "checking whether programs are able to redeclare getpw functions""... $ac_c" 1>&6
+echo "configure:1682: checking whether programs are able to redeclare getpw functions" >&5
+if eval "test \"`echo '$''{'bash_cv_can_redecl_getpw'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1687 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <pwd.h>
+extern struct passwd *getpwent();
+int main() {
+struct passwd *z; z = getpwent();
+; return 0; }
+EOF
+if { (eval echo configure:1696: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  bash_cv_can_redecl_getpw=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_can_redecl_getpw=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$bash_cv_can_redecl_getpw" 1>&6
+if test $bash_cv_can_redecl_getpw = no; then
+cat >> confdefs.h <<\EOF
+#define HAVE_GETPW_DECLS 1
+EOF
+
+fi
+
+
+echo $ac_n "checking whether or not strcoll and strcmp differ""... $ac_c" 1>&6
+echo "configure:1718: checking whether or not strcoll and strcmp differ" >&5
+if eval "test \"`echo '$''{'bash_cv_func_strcoll_broken'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+  { echo "configure: error: cannot check strcoll if cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1726 "configure"
+#include "confdefs.h"
+
+#include <stdio.h>
+#if defined (HAVE_LOCALE_H)
+#include <locale.h>
+#endif
+
+main(c, v)
+int     c;
+char    *v[];
+{
+        int     r1, r2;
+        char    *deflocale, *defcoll;
+
+#ifdef HAVE_SETLOCALE
+        deflocale = setlocale(LC_ALL, "");
+	defcoll = setlocale(LC_COLLATE, "");
+#endif
+
+#ifdef HAVE_STRCOLL
+	/* These two values are taken from tests/glob-test. */
+        r1 = strcoll("abd", "aXd");
+#else
+	r1 = 0;
+#endif
+        r2 = strcmp("abd", "aXd");
+
+	/* These two should both be greater than 0.  It is permissible for
+	   a system to return different values, as long as the sign is the
+	   same. */
+
+        /* Exit with 1 (failure) if these two values are both > 0, since
+	   this tests whether strcoll(3) is broken with respect to strcmp(3)
+	   in the default locale. */
+	exit (r1 > 0 && r2 > 0);
+}
+
+EOF
+if { (eval echo configure:1765: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  bash_cv_func_strcoll_broken=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  bash_cv_func_strcoll_broken=no
+fi
+rm -fr conftest*
+fi
+
+
+fi
+
+echo "$ac_t""$bash_cv_func_strcoll_broken" 1>&6
+if test $bash_cv_func_strcoll_broken = yes; then
+cat >> confdefs.h <<\EOF
+#define STRCOLL_BROKEN 1
+EOF
+
+fi
+
+
+echo $ac_n "checking whether signal handlers are of type void""... $ac_c" 1>&6
+echo "configure:1790: checking whether signal handlers are of type void" >&5
+if eval "test \"`echo '$''{'bash_cv_void_sighandler'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1795 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <signal.h>
+#ifdef signal
+#undef signal
+#endif
+#ifdef __cplusplus
+extern "C"
+#endif
+void (*signal ()) ();
+int main() {
+int i;
+; return 0; }
+EOF
+if { (eval echo configure:1810: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  bash_cv_void_sighandler=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_void_sighandler=no
+fi
+rm -f conftest*
+fi
+echo "$ac_t""$bash_cv_void_sighandler" 1>&6
+if test $bash_cv_void_sighandler = yes; then
+cat >> confdefs.h <<\EOF
+#define VOID_SIGHANDLER 1
+EOF
+
+fi
+
+echo $ac_n "checking for TIOCGWINSZ in sys/ioctl.h""... $ac_c" 1>&6
+echo "configure:1830: checking for TIOCGWINSZ in sys/ioctl.h" >&5
+if eval "test \"`echo '$''{'bash_cv_tiocgwinsz_in_ioctl'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1835 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/ioctl.h>
+int main() {
+int x = TIOCGWINSZ;
+; return 0; }
+EOF
+if { (eval echo configure:1843: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  bash_cv_tiocgwinsz_in_ioctl=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_tiocgwinsz_in_ioctl=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$bash_cv_tiocgwinsz_in_ioctl" 1>&6
+if test $bash_cv_tiocgwinsz_in_ioctl = yes; then   
+cat >> confdefs.h <<\EOF
+#define GWINSZ_IN_SYS_IOCTL 1
+EOF
+
+fi
+
+echo $ac_n "checking for TIOCSTAT in sys/ioctl.h""... $ac_c" 1>&6
+echo "configure:1864: checking for TIOCSTAT in sys/ioctl.h" >&5
+if eval "test \"`echo '$''{'bash_cv_tiocstat_in_ioctl'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1869 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/ioctl.h>
+int main() {
+int x = TIOCSTAT;
+; return 0; }
+EOF
+if { (eval echo configure:1877: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  bash_cv_tiocstat_in_ioctl=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_tiocstat_in_ioctl=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$bash_cv_tiocstat_in_ioctl" 1>&6
+if test $bash_cv_tiocstat_in_ioctl = yes; then   
+cat >> confdefs.h <<\EOF
+#define TIOCSTAT_IN_SYS_IOCTL 1
+EOF
+
+fi
+
+echo $ac_n "checking for FIONREAD in sys/ioctl.h""... $ac_c" 1>&6
+echo "configure:1898: checking for FIONREAD in sys/ioctl.h" >&5
+if eval "test \"`echo '$''{'bash_cv_fionread_in_ioctl'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1903 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/ioctl.h>
+int main() {
+int x = FIONREAD;
+; return 0; }
+EOF
+if { (eval echo configure:1911: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  bash_cv_fionread_in_ioctl=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_fionread_in_ioctl=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$bash_cv_fionread_in_ioctl" 1>&6
+if test $bash_cv_fionread_in_ioctl = yes; then   
+cat >> confdefs.h <<\EOF
+#define FIONREAD_IN_SYS_IOCTL 1
+EOF
+
+fi
+
+echo $ac_n "checking for speed_t in sys/types.h""... $ac_c" 1>&6
+echo "configure:1932: checking for speed_t in sys/types.h" >&5
+if eval "test \"`echo '$''{'bash_cv_speed_t_in_sys_types'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1937 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+int main() {
+speed_t x;
+; return 0; }
+EOF
+if { (eval echo configure:1944: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  bash_cv_speed_t_in_sys_types=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_speed_t_in_sys_types=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$bash_cv_speed_t_in_sys_types" 1>&6
+if test $bash_cv_speed_t_in_sys_types = yes; then   
+cat >> confdefs.h <<\EOF
+#define SPEED_T_IN_SYS_TYPES 1
+EOF
+
+fi
+
+
+echo $ac_n "checking if struct dirent has a d_ino member""... $ac_c" 1>&6
+echo "configure:1966: checking if struct dirent has a d_ino member" >&5
+if eval "test \"`echo '$''{'bash_cv_dirent_has_dino'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1971 "configure"
+#include "confdefs.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+#if defined(HAVE_DIRENT_H)
+# include <dirent.h>
+#else
+# define dirent direct
+# ifdef HAVE_SYS_NDIR_H
+#  include <sys/ndir.h>
+# endif /* SYSNDIR */
+# ifdef HAVE_SYS_DIR_H
+#  include <sys/dir.h>
+# endif /* SYSDIR */
+# ifdef HAVE_NDIR_H
+#  include <ndir.h>
+# endif
+#endif /* HAVE_DIRENT_H */
+
+int main() {
+
+struct dirent d; int z; z = d.d_ino;
+
+; return 0; }
+EOF
+if { (eval echo configure:2000: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  bash_cv_dirent_has_dino=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_dirent_has_dino=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$bash_cv_dirent_has_dino" 1>&6
+if test $bash_cv_dirent_has_dino = yes; then
+cat >> confdefs.h <<\EOF
+#define STRUCT_DIRENT_HAS_D_INO 1
+EOF
+
+fi
+
+
+echo $ac_n "checking if struct dirent has a d_fileno member""... $ac_c" 1>&6
+echo "configure:2022: checking if struct dirent has a d_fileno member" >&5
+if eval "test \"`echo '$''{'bash_cv_dirent_has_d_fileno'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2027 "configure"
+#include "confdefs.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+#if defined(HAVE_DIRENT_H)
+# include <dirent.h>
+#else
+# define dirent direct
+# ifdef HAVE_SYS_NDIR_H
+#  include <sys/ndir.h>
+# endif /* SYSNDIR */
+# ifdef HAVE_SYS_DIR_H
+#  include <sys/dir.h>
+# endif /* SYSDIR */
+# ifdef HAVE_NDIR_H
+#  include <ndir.h>
+# endif
+#endif /* HAVE_DIRENT_H */
+
+int main() {
+
+struct dirent d; int z; z = d.d_fileno;
+
+; return 0; }
+EOF
+if { (eval echo configure:2056: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  bash_cv_dirent_has_d_fileno=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  bash_cv_dirent_has_d_fileno=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$bash_cv_dirent_has_d_fileno" 1>&6
+if test $bash_cv_dirent_has_d_fileno = yes; then
+cat >> confdefs.h <<\EOF
+#define STRUCT_DIRENT_HAS_D_FILENO 1
+EOF
+
+fi
+
+
+case "$host_cpu" in
+*cray*)	LOCAL_CFLAGS=-DCRAY ;;
+esac
+
+case "$host_os" in
+isc*)	LOCAL_CFLAGS=-Disc386 ;;
+esac
+
+
+
+
+
+
+
+
+
+
+trap '' 1 2 15
+cat > confcache <<\EOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs.  It is not useful on other systems.
+# If it contains results you don't want to keep, you may remove or edit it.
+#
+# By default, configure uses ./config.cache as the cache file,
+# creating it if it does not exist already.  You can give configure
+# the --cache-file=FILE option to use a different cache file; that is
+# what configure does when it calls configure scripts in
+# subdirectories, so they share the cache.
+# Giving --cache-file=/dev/null disables caching, for debugging configure.
+# config.status only pays attention to the cache file if you give it the
+# --recheck option to rerun configure.
+#
+EOF
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(set) 2>&1 |
+  case `(ac_space=' '; set) 2>&1` in
+  *ac_space=\ *)
+    # `set' does not quote correctly, so add quotes (double-quote substitution
+    # turns \\\\ into \\, and sed turns \\ into \).
+    sed -n \
+      -e "s/'/'\\\\''/g" \
+      -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
+    ;;
+  *)
+    # `set' quotes correctly as required by POSIX, so do not add quotes.
+    sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
+    ;;
+  esac >> confcache
+if cmp -s $cache_file confcache; then
+  :
+else
+  if test -w $cache_file; then
+    echo "updating cache $cache_file"
+    cat confcache > $cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# Any assignment to VPATH causes Sun make to only execute
+# the first set of double-colon rules, so remove it if not needed.
+# If there is a colon in the path, we need to keep it.
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
+fi
+
+trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
+
+DEFS=-DHAVE_CONFIG_H
+
+# Without the "./", some shells look in PATH for config.status.
+: ${CONFIG_STATUS=./config.status}
+
+echo creating $CONFIG_STATUS
+rm -f $CONFIG_STATUS
+cat > $CONFIG_STATUS <<EOF
+#! /bin/sh
+# Generated automatically by configure.
+# Run this file to recreate the current configuration.
+# This directory was configured as follows,
+# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+#
+# $0 $ac_configure_args
+#
+# Compiler output produced by configure, useful for debugging
+# configure, is in ./config.log if it exists.
+
+ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
+for ac_option
+do
+  case "\$ac_option" in
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
+    exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
+  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
+    echo "$CONFIG_STATUS generated by autoconf version 2.12"
+    exit 0 ;;
+  -help | --help | --hel | --he | --h)
+    echo "\$ac_cs_usage"; exit 0 ;;
+  *) echo "\$ac_cs_usage"; exit 1 ;;
+  esac
+done
+
+ac_given_srcdir=$srcdir
+ac_given_INSTALL="$INSTALL"
+
+trap 'rm -fr `echo "Makefile doc/Makefile examples/Makefile config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+# Protect against being on the right side of a sed subst in config.status.
+sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
+ s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
+$ac_vpsub
+$extrasub
+s%@CFLAGS@%$CFLAGS%g
+s%@CPPFLAGS@%$CPPFLAGS%g
+s%@CXXFLAGS@%$CXXFLAGS%g
+s%@DEFS@%$DEFS%g
+s%@LDFLAGS@%$LDFLAGS%g
+s%@LIBS@%$LIBS%g
+s%@exec_prefix@%$exec_prefix%g
+s%@prefix@%$prefix%g
+s%@program_transform_name@%$program_transform_name%g
+s%@bindir@%$bindir%g
+s%@sbindir@%$sbindir%g
+s%@libexecdir@%$libexecdir%g
+s%@datadir@%$datadir%g
+s%@sysconfdir@%$sysconfdir%g
+s%@sharedstatedir@%$sharedstatedir%g
+s%@localstatedir@%$localstatedir%g
+s%@libdir@%$libdir%g
+s%@includedir@%$includedir%g
+s%@oldincludedir@%$oldincludedir%g
+s%@infodir@%$infodir%g
+s%@mandir@%$mandir%g
+s%@host@%$host%g
+s%@host_alias@%$host_alias%g
+s%@host_cpu@%$host_cpu%g
+s%@host_vendor@%$host_vendor%g
+s%@host_os@%$host_os%g
+s%@CC@%$CC%g
+s%@CPP@%$CPP%g
+s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
+s%@INSTALL_DATA@%$INSTALL_DATA%g
+s%@RANLIB@%$RANLIB%g
+s%@LOCAL_CFLAGS@%$LOCAL_CFLAGS%g
+s%@LOCAL_DEFS@%$LOCAL_DEFS%g
+s%@LIBVERSION@%$LIBVERSION%g
+
+CEOF
+EOF
+
+cat >> $CONFIG_STATUS <<\EOF
+
+# Split the substitutions into bite-sized pieces for seds with
+# small command number limits, like on Digital OSF/1 and HP-UX.
+ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
+ac_file=1 # Number of current file.
+ac_beg=1 # First line for current file.
+ac_end=$ac_max_sed_cmds # Line after last line for current file.
+ac_more_lines=:
+ac_sed_cmds=""
+while $ac_more_lines; do
+  if test $ac_beg -gt 1; then
+    sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
+  else
+    sed "${ac_end}q" conftest.subs > conftest.s$ac_file
+  fi
+  if test ! -s conftest.s$ac_file; then
+    ac_more_lines=false
+    rm -f conftest.s$ac_file
+  else
+    if test -z "$ac_sed_cmds"; then
+      ac_sed_cmds="sed -f conftest.s$ac_file"
+    else
+      ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
+    fi
+    ac_file=`expr $ac_file + 1`
+    ac_beg=$ac_end
+    ac_end=`expr $ac_end + $ac_max_sed_cmds`
+  fi
+done
+if test -z "$ac_sed_cmds"; then
+  ac_sed_cmds=cat
+fi
+EOF
+
+cat >> $CONFIG_STATUS <<EOF
+
+CONFIG_FILES=\${CONFIG_FILES-"Makefile doc/Makefile examples/Makefile"}
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
+
+  # Remove last slash and all that follows it.  Not all systems have dirname.
+  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+    # The file is in a subdirectory.
+    test ! -d "$ac_dir" && mkdir "$ac_dir"
+    ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
+    # A "../" for each directory in $ac_dir_suffix.
+    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
+  else
+    ac_dir_suffix= ac_dots=
+  fi
+
+  case "$ac_given_srcdir" in
+  .)  srcdir=.
+      if test -z "$ac_dots"; then top_srcdir=.
+      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
+  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
+  *) # Relative path.
+    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
+    top_srcdir="$ac_dots$ac_given_srcdir" ;;
+  esac
+
+  case "$ac_given_INSTALL" in
+  [/$]*) INSTALL="$ac_given_INSTALL" ;;
+  *) INSTALL="$ac_dots$ac_given_INSTALL" ;;
+  esac
+
+  echo creating "$ac_file"
+  rm -f "$ac_file"
+  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
+  case "$ac_file" in
+  *Makefile*) ac_comsub="1i\\
+# $configure_input" ;;
+  *) ac_comsub= ;;
+  esac
+
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  sed -e "$ac_comsub
+s%@configure_input@%$configure_input%g
+s%@srcdir@%$srcdir%g
+s%@top_srcdir@%$top_srcdir%g
+s%@INSTALL@%$INSTALL%g
+" $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
+fi; done
+rm -f conftest.s*
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
+ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
+ac_dC='\3'
+ac_dD='%g'
+# ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
+ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uB='\([ 	]\)%\1#\2define\3'
+ac_uC=' '
+ac_uD='\4%g'
+# ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_eB='$%\1#\2define\3'
+ac_eC=' '
+ac_eD='%g'
+
+if test "${CONFIG_HEADERS+set}" != set; then
+EOF
+cat >> $CONFIG_STATUS <<EOF
+  CONFIG_HEADERS="config.h"
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+fi
+for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case "$ac_file" in
+  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
+       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+  *) ac_file_in="${ac_file}.in" ;;
+  esac
+
+  echo creating $ac_file
+
+  rm -f conftest.frag conftest.in conftest.out
+  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
+  cat $ac_file_inputs > conftest.in
+
+EOF
+
+# Transform confdefs.h into a sed script conftest.vals that substitutes
+# the proper values into config.h.in to produce config.h.  And first:
+# Protect against being on the right side of a sed subst in config.status.
+# Protect against being in an unquoted here document in config.status.
+rm -f conftest.vals
+cat > conftest.hdr <<\EOF
+s/[\\&%]/\\&/g
+s%[\\$`]%\\&%g
+s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD}%gp
+s%ac_d%ac_u%gp
+s%ac_u%ac_e%gp
+EOF
+sed -n -f conftest.hdr confdefs.h > conftest.vals
+rm -f conftest.hdr
+
+# This sed command replaces #undef with comments.  This is necessary, for
+# example, in the case of _POSIX_SOURCE, which is predefined and required
+# on some systems where configure will not decide to define it.
+cat >> conftest.vals <<\EOF
+s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
+EOF
+
+# Break up conftest.vals because some shells have a limit on
+# the size of here documents, and old seds have small limits too.
+
+rm -f conftest.tail
+while :
+do
+  ac_lines=`grep -c . conftest.vals`
+  # grep -c gives empty output for an empty file on some AIX systems.
+  if test -z "$ac_lines" || test "$ac_lines" -eq 0; then break; fi
+  # Write a limited-size here document to conftest.frag.
+  echo '  cat > conftest.frag <<CEOF' >> $CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.vals >> $CONFIG_STATUS
+  echo 'CEOF
+  sed -f conftest.frag conftest.in > conftest.out
+  rm -f conftest.in
+  mv conftest.out conftest.in
+' >> $CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.vals > conftest.tail
+  rm -f conftest.vals
+  mv conftest.tail conftest.vals
+done
+rm -f conftest.vals
+
+cat >> $CONFIG_STATUS <<\EOF
+  rm -f conftest.frag conftest.h
+  echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
+  cat conftest.in >> conftest.h
+  rm -f conftest.in
+  if cmp -s $ac_file conftest.h 2>/dev/null; then
+    echo "$ac_file is unchanged"
+    rm -f conftest.h
+  else
+    # Remove last slash and all that follows it.  Not all systems have dirname.
+      ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
+      if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
+      # The file is in a subdirectory.
+      test ! -d "$ac_dir" && mkdir "$ac_dir"
+    fi
+    rm -f $ac_file
+    mv conftest.h $ac_file
+  fi
+fi; done
+
+EOF
+cat >> $CONFIG_STATUS <<EOF
+
+EOF
+cat >> $CONFIG_STATUS <<\EOF
+
+# Makefile uses this timestamp file to record whether config.h is up to date.
+echo > stamp-h
+
+exit 0
+EOF
+chmod +x $CONFIG_STATUS
+rm -fr confdefs* $ac_clean_files
+test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
+
diff --git a/readline/configure.in b/readline/configure.in
new file mode 100644
--- /dev/null
+++ b/readline/configure.in
@@ -0,0 +1,82 @@
+dnl
+dnl Configure script for readline library
+dnl
+dnl report bugs to chet@po.cwru.edu
+dnl
+dnl Process this file with autoconf to produce a configure script.
+AC_REVISION([for Readline 2.1, version 2.04, from autoconf version] AC_ACVERSION)
+LIBVERSION=2.1
+
+AC_INIT(readline.h)
+AC_CONFIG_HEADER(config.h)
+
+dnl make sure we are using a recent autoconf version
+AC_PREREQ(2.10)
+
+AC_CONFIG_AUX_DIR(./support)
+
+AC_CANONICAL_HOST
+
+# We want these before the checks, so the checks can modify their values.
+test -z "$CFLAGS" && CFLAGS=-g auto_cflags=1
+
+AC_PROG_CC
+
+# If we're using gcc and the user hasn't specified CFLAGS, add -O to CFLAGS.
+test -n "$GCC" && test -n "$auto_cflags" && CFLAGS="$CFLAGS -O"
+
+AC_PROG_GCC_TRADITIONAL
+AC_PROG_INSTALL
+AC_PROG_RANLIB
+
+AC_RETSIGTYPE
+
+AC_HEADER_STAT
+AC_HEADER_DIRENT
+
+AC_CHECK_FUNCS(strcasecmp select setenv putenv tcgetattr setlocale lstat)
+
+AC_FUNC_STRCOLL
+
+AC_CHECK_HEADERS(unistd.h stdlib.h varargs.h stdarg.h string.h \
+		sys/ptem.h sys/pte.h sys/stream.h sys/select.h \
+		termcap.h termios.h termio.h sys/file.h locale.h)
+
+BASH_SIGNAL_CHECK
+BASH_REINSTALL_SIGHANDLERS
+
+BASH_FUNC_POSIX_SETJMP
+BASH_FUNC_LSTAT
+BASH_CHECK_GETPW_FUNCS
+BASH_FUNC_STRCOLL
+
+BASH_TYPE_SIGHANDLER
+BASH_HAVE_TIOCGWINSZ
+BASH_HAVE_TIOCSTAT
+BASH_HAVE_FIONREAD
+BASH_MISC_SPEED_T
+BASH_STRUCT_DIRENT_D_INO
+BASH_STRUCT_DIRENT_D_FILENO
+
+case "$host_cpu" in
+*cray*)	LOCAL_CFLAGS=-DCRAY ;;
+esac
+
+case "$host_os" in
+isc*)	LOCAL_CFLAGS=-Disc386 ;;
+esac
+
+AC_SUBST(CFLAGS)
+AC_SUBST(LOCAL_CFLAGS)
+AC_SUBST(LOCAL_DEFS)
+
+AC_SUBST(host_cpu)
+AC_SUBST(host_os)
+
+AC_SUBST(LIBVERSION)
+
+AC_OUTPUT([Makefile doc/Makefile examples/Makefile],
+[
+# Makefile uses this timestamp file to record whether config.h is up to date.
+echo > stamp-h
+])
diff --git a/readline/display.c b/readline/display.c
new file mode 100644
--- /dev/null
+++ b/readline/display.c
@@ -0,0 +1,1529 @@
+/* display.c -- readline redisplay facility. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#include "posixstat.h"
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include <stdio.h>
+
+#if defined (__GO32__)
+#  include <go32.h>
+#  include <pc.h>
+#endif /* __GO32__ */
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+/* Termcap library stuff. */
+#include "tcap.h"
+
+/* Some standard library routines. */
+#include "readline.h"
+#include "history.h"
+
+#if !defined (strchr) && !defined (__STDC__)
+extern char *strchr (), *strrchr ();
+#endif /* !strchr && !__STDC__ */
+
+/* Global and pseudo-global variables and functions
+   imported from readline.c. */
+extern char *rl_prompt;
+extern int readline_echoing_p;
+
+extern int _rl_output_meta_chars;
+extern int _rl_horizontal_scroll_mode;
+extern int _rl_mark_modified_lines;
+extern int _rl_prefer_visible_bell;
+
+/* Variables and functions imported from terminal.c */
+extern void _rl_output_some_chars ();
+extern int _rl_output_character_function ();
+extern int _rl_backspace ();
+
+extern char *term_clreol, *term_clrpag;
+extern char *term_im, *term_ic,  *term_ei, *term_DC;
+extern char *term_up, *term_dc, *term_cr, *term_IC;
+extern int screenheight, screenwidth, screenchars;
+extern int terminal_can_insert, _rl_term_autowrap;
+
+/* Pseudo-global functions (local to the readline library) exported
+   by this file. */
+void _rl_move_cursor_relative (), _rl_output_some_chars ();
+void _rl_move_vert ();
+void _rl_clear_to_eol (), _rl_clear_screen ();
+
+static void update_line (), space_to_eol ();
+static void delete_chars (), insert_some_chars ();
+static void cr ();
+
+static int *inv_lbreaks, *vis_lbreaks;
+
+extern char *xmalloc (), *xrealloc ();
+
+/* Heuristic used to decide whether it is faster to move from CUR to NEW
+   by backing up or outputting a carriage return and moving forward. */
+#define CR_FASTER(new, cur) (((new) + 1) < ((cur) - (new)))
+
+/* **************************************************************** */
+/*								    */
+/*			Display stuff				    */
+/*								    */
+/* **************************************************************** */
+
+/* This is the stuff that is hard for me.  I never seem to write good
+   display routines in C.  Let's see how I do this time. */
+
+/* (PWP) Well... Good for a simple line updater, but totally ignores
+   the problems of input lines longer than the screen width.
+
+   update_line and the code that calls it makes a multiple line,
+   automatically wrapping line update.  Careful attention needs
+   to be paid to the vertical position variables. */
+
+/* Keep two buffers; one which reflects the current contents of the
+   screen, and the other to draw what we think the new contents should
+   be.  Then compare the buffers, and make whatever changes to the
+   screen itself that we should.  Finally, make the buffer that we
+   just drew into be the one which reflects the current contents of the
+   screen, and place the cursor where it belongs.
+
+   Commands that want to can fix the display themselves, and then let
+   this function know that the display has been fixed by setting the
+   RL_DISPLAY_FIXED variable.  This is good for efficiency. */
+
+/* Application-specific redisplay function. */
+VFunction *rl_redisplay_function = rl_redisplay;
+
+/* Global variables declared here. */
+/* What YOU turn on when you have handled all redisplay yourself. */
+int rl_display_fixed = 0;
+
+int _rl_suppress_redisplay = 0;
+
+/* The stuff that gets printed out before the actual text of the line.
+   This is usually pointing to rl_prompt. */
+char *rl_display_prompt = (char *)NULL;
+
+/* Pseudo-global variables declared here. */
+/* The visible cursor position.  If you print some text, adjust this. */
+int _rl_last_c_pos = 0;
+int _rl_last_v_pos = 0;
+
+/* Number of lines currently on screen minus 1. */
+int _rl_vis_botlin = 0;
+
+/* Variables used only in this file. */
+/* The last left edge of text that was displayed.  This is used when
+   doing horizontal scrolling.  It shifts in thirds of a screenwidth. */
+static int last_lmargin;
+
+/* The line display buffers.  One is the line currently displayed on
+   the screen.  The other is the line about to be displayed. */
+static char *visible_line = (char *)NULL;
+static char *invisible_line = (char *)NULL;
+
+/* A buffer for `modeline' messages. */
+static char msg_buf[128];
+
+/* Non-zero forces the redisplay even if we thought it was unnecessary. */
+static int forced_display;
+
+/* Default and initial buffer size.  Can grow. */
+static int line_size = 1024;
+
+static char *local_prompt, *local_prompt_prefix;
+static int visible_length, prefix_length;
+
+/* The number of invisible characters in the line currently being
+   displayed on the screen. */
+static int visible_wrap_offset;
+
+/* static so it can be shared between rl_redisplay and update_line */
+static int wrap_offset;
+
+/* The index of the last invisible_character in the prompt string. */
+static int last_invisible;
+
+/* The length (buffer offset) of the first line of the last (possibly
+   multi-line) buffer displayed on the screen. */
+static int visible_first_line_len;
+
+/* Expand the prompt string S and return the number of visible
+   characters in *LP, if LP is not null.  This is currently more-or-less
+   a placeholder for expansion.  LIP, if non-null is a place to store the
+   index of the last invisible character in ther eturned string. */
+
+/* Current implementation:
+	\001 (^A) start non-visible characters
+	\002 (^B) end non-visible characters
+   all characters except \001 and \002 (following a \001) are copied to
+   the returned string; all characters except those between \001 and
+   \002 are assumed to be `visible'. */	
+
+static char *
+expand_prompt (pmt, lp, lip)
+     char *pmt;
+     int *lp, *lip;
+{
+  char *r, *ret, *p;
+  int l, rl, last, ignoring;
+
+  /* Short-circuit if we can. */
+  if (strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
+    {
+      r = savestring (pmt);
+      if (lp)
+	*lp = strlen (r);
+      return r;
+    }
+
+  l = strlen (pmt);
+  r = ret = xmalloc (l + 1);
+  
+  for (rl = ignoring = last = 0, p = pmt; p && *p; p++)
+    {
+      /* This code strips the invisible character string markers
+	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
+      if (*p == RL_PROMPT_START_IGNORE)
+	{
+	  ignoring++;
+	  continue;
+	}
+      else if (ignoring && *p == RL_PROMPT_END_IGNORE)
+	{
+	  ignoring = 0;
+	  last = r - ret - 1;
+	  continue;
+	}
+      else
+	{
+	  *r++ = *p;
+	  if (!ignoring)
+	    rl++;
+	}
+    }
+
+  *r = '\0';
+  if (lp)
+    *lp = rl;
+  if (lip)
+    *lip = last;
+  return ret;
+}
+
+/*
+ * Expand the prompt string into the various display components, if
+ * necessary.
+ *
+ * local_prompt = expanded last line of string in rl_display_prompt
+ *		  (portion after the final newline)
+ * local_prompt_prefix = portion before last newline of rl_display_prompt,
+ *			 expanded via expand_prompt
+ * visible_length = number of visible characters in local_prompt
+ * prefix_length = number of visible characters in local_prompt_prefix
+ *
+ * This function is called once per call to readline().  It may also be
+ * called arbitrarily to expand the primary prompt.
+ *
+ * The return value is the number of visible characters on the last line
+ * of the (possibly multi-line) prompt.
+ */
+int
+rl_expand_prompt (prompt)
+     char *prompt;
+{
+  char *p, *t;
+  int c;
+
+  /* Clear out any saved values. */
+  if (local_prompt)
+    free (local_prompt);
+  if (local_prompt_prefix)
+    free (local_prompt_prefix);
+  local_prompt = local_prompt_prefix = (char *)0;
+  last_invisible = 0;
+
+  if (prompt == 0 || *prompt == 0)
+    return (0);
+
+  p = strrchr (prompt, '\n');
+  if (!p)
+    {
+      /* The prompt is only one line. */
+      local_prompt = expand_prompt (prompt, &visible_length, &last_invisible);
+      local_prompt_prefix = (char *)0;
+      return (visible_length);
+    }
+  else
+    {
+      /* The prompt spans multiple lines. */
+      t = ++p;
+      local_prompt = expand_prompt (p, &visible_length, &last_invisible);
+      c = *t; *t = '\0';
+      /* The portion of the prompt string up to and including the
+	 final newline is now null-terminated. */
+      local_prompt_prefix = expand_prompt (prompt, &prefix_length, (int *)NULL);
+      *t = c;
+      return (prefix_length);
+    }
+}
+
+/* Basic redisplay algorithm. */
+void
+rl_redisplay ()
+{
+  register int in, out, c, linenum, cursor_linenum;
+  register char *line;
+  int c_pos, inv_botlin, lb_botlin, lb_linenum;
+  int newlines, lpos, temp;
+  char *prompt_this_line;
+
+  if (!readline_echoing_p)
+    return;
+
+  if (!rl_display_prompt)
+    rl_display_prompt = "";
+
+  if (invisible_line == 0)
+    {
+      visible_line = xmalloc (line_size);
+      invisible_line = xmalloc (line_size);
+      for (in = 0; in < line_size; in++)
+	{
+	  visible_line[in] = 0;
+	  invisible_line[in] = 1;
+	}
+
+      /* should be enough, but then again, this is just for testing. */
+      inv_lbreaks = (int *)malloc (256 * sizeof (int));
+      vis_lbreaks = (int *)malloc (256 * sizeof (int));
+      inv_lbreaks[0] = vis_lbreaks[0] = 0;
+
+      rl_on_new_line ();
+    }
+
+  /* Draw the line into the buffer. */
+  c_pos = -1;
+
+  line = invisible_line;
+  out = inv_botlin = 0;
+
+  /* Mark the line as modified or not.  We only do this for history
+     lines. */
+  if (_rl_mark_modified_lines && current_history () && rl_undo_list)
+    {
+      line[out++] = '*';
+      line[out] = '\0';
+    }
+
+  /* If someone thought that the redisplay was handled, but the currently
+     visible line has a different modification state than the one about
+     to become visible, then correct the caller's misconception. */
+  if (visible_line[0] != invisible_line[0])
+    rl_display_fixed = 0;
+
+  /* If the prompt to be displayed is the `primary' readline prompt (the
+     one passed to readline()), use the values we have already expanded.
+     If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the
+     number of non-visible characters in the prompt string. */
+  if (rl_display_prompt == rl_prompt || local_prompt)
+    {
+      int local_len = local_prompt ? strlen (local_prompt) : 0;
+      if (local_prompt_prefix && forced_display)
+	_rl_output_some_chars (local_prompt_prefix, strlen (local_prompt_prefix));
+
+      if (local_len > 0)
+	{
+	  strncpy (line + out, local_prompt, local_len);
+	  out += local_len;
+	}
+      line[out] = '\0';
+      wrap_offset = local_len - visible_length;
+    }
+  else
+    {
+      int pmtlen;
+      prompt_this_line = strrchr (rl_display_prompt, '\n');
+      if (!prompt_this_line)
+	prompt_this_line = rl_display_prompt;
+      else
+	{
+	  prompt_this_line++;
+	  if (forced_display)
+	    {
+	      _rl_output_some_chars (rl_display_prompt, prompt_this_line - rl_display_prompt);
+	      /* Make sure we are at column zero even after a newline,
+		 regardless of the state of terminal output processing. */
+	      if (prompt_this_line[-2] != '\r')
+		cr ();
+	    }
+	}
+
+      pmtlen = strlen (prompt_this_line);
+      strncpy (line + out,  prompt_this_line, pmtlen);
+      out += pmtlen;
+      line[out] = '\0';
+      wrap_offset = 0;
+    }
+
+#define CHECK_LPOS() \
+      do { \
+        lpos++; \
+        if (lpos >= screenwidth) \
+          { \
+            inv_lbreaks[++newlines] = out; \
+            lpos = 0; \
+          } \
+      } while (0)
+
+  /* inv_lbreaks[i] is where line i starts in the buffer. */
+  inv_lbreaks[newlines = 0] = 0;
+  lpos = out - wrap_offset;
+
+  /* XXX - what if lpos is already >= screenwidth before we start drawing the
+     contents of the command line? */
+  while (lpos >= screenwidth)
+    {
+      temp = ((newlines + 1) * screenwidth) - ((newlines == 0) ? wrap_offset : 0);
+      inv_lbreaks[++newlines] = temp;
+      lpos -= screenwidth;
+    }
+
+  lb_linenum = 0;
+  for (in = 0; in < rl_end; in++)
+    {
+      c = (unsigned char)rl_line_buffer[in];
+
+      if (out + 8 >= line_size)		/* XXX - 8 for \t */
+	{
+	  line_size *= 2;
+	  visible_line = xrealloc (visible_line, line_size);
+	  invisible_line = xrealloc (invisible_line, line_size);
+	  line = invisible_line;
+	}
+
+      if (in == rl_point)
+	{
+	  c_pos = out;
+	  lb_linenum = newlines;
+	}
+
+      if (META_CHAR (c))
+	{
+	  if (_rl_output_meta_chars == 0)
+	    {
+	      sprintf (line + out, "\\%o", c);
+
+	      if (lpos + 4 >= screenwidth)
+		{
+		  temp = screenwidth - lpos;
+		  inv_lbreaks[++newlines] = out + temp;
+		  lpos = 4 - temp;
+		}
+	      else
+		lpos += 4;
+
+	      out += 4;
+	    }
+	  else
+	    {
+	      line[out++] = c;
+	      CHECK_LPOS();
+	    }
+	}
+#if defined (DISPLAY_TABS)
+      else if (c == '\t')
+	{
+	  register int temp, newout;
+	  newout = (out | (int)7) + 1;
+	  temp = newout - out;
+	  if (lpos + temp >= screenwidth)
+	    {
+	      register int temp2;
+	      temp2 = screenwidth - lpos;
+	      inv_lbreaks[++newlines] = out + temp2;
+	      lpos = temp - temp2;
+	      while (out < newout)
+		line[out++] = ' ';
+	    }
+	  else
+	    {
+	      while (out < newout)
+		line[out++] = ' ';
+	      lpos += temp;
+	    }
+	}
+#endif
+      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && term_up && *term_up)
+        {
+          line[out++] = '\0';	/* XXX - sentinel */
+          inv_lbreaks[++newlines] = out;
+          lpos = 0;
+        }
+      else if (CTRL_CHAR (c) || c == RUBOUT)
+	{
+	  line[out++] = '^';
+	  CHECK_LPOS();
+	  line[out++] = CTRL_CHAR (c) ? UNCTRL (c) : '?';
+	  CHECK_LPOS();
+	}
+      else
+	{
+	  line[out++] = c;
+	  CHECK_LPOS();
+	}
+    }
+  line[out] = '\0';
+  if (c_pos < 0)
+    {
+      c_pos = out;
+      lb_linenum = newlines;
+    }
+
+  inv_botlin = lb_botlin = newlines;
+  inv_lbreaks[newlines+1] = out;
+  cursor_linenum = lb_linenum;
+
+  /* C_POS == position in buffer where cursor should be placed. */
+
+  /* PWP: now is when things get a bit hairy.  The visible and invisible
+     line buffers are really multiple lines, which would wrap every
+     (screenwidth - 1) characters.  Go through each in turn, finding
+     the changed region and updating it.  The line order is top to bottom. */
+
+  /* If we can move the cursor up and down, then use multiple lines,
+     otherwise, let long lines display in a single terminal line, and
+     horizontally scroll it. */
+
+  if (_rl_horizontal_scroll_mode == 0 && term_up && *term_up)
+    {
+      int nleft, pos, changed_screen_line;
+
+      if (!rl_display_fixed || forced_display)
+	{
+	  forced_display = 0;
+
+	  /* If we have more than a screenful of material to display, then
+	     only display a screenful.  We should display the last screen,
+	     not the first.  */
+	  if (out >= screenchars)
+	    out = screenchars - 1;
+
+	  /* The first line is at character position 0 in the buffer.  The
+	     second and subsequent lines start at inv_lbreaks[N], offset by
+	     OFFSET (which has already been calculated above).  */
+
+#define W_OFFSET(line, offset) ((line) == 0 ? offset : 0)
+#define VIS_LLEN(l)	((l) > _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))
+#define INV_LLEN(l)	(inv_lbreaks[l+1] - inv_lbreaks[l])
+#define VIS_CHARS(line) (visible_line + vis_lbreaks[line])
+#define VIS_LINE(line) ((line) > _rl_vis_botlin) ? "" : VIS_CHARS(line)
+#define INV_LINE(line) (invisible_line + inv_lbreaks[line])
+
+	  /* For each line in the buffer, do the updating display. */
+	  for (linenum = 0; linenum <= inv_botlin; linenum++)
+	    {
+	      update_line (VIS_LINE(linenum), INV_LINE(linenum), linenum,
+			   VIS_LLEN(linenum), INV_LLEN(linenum), inv_botlin);
+
+	      /* If this is the line with the prompt, we might need to
+		 compensate for invisible characters in the new line. Do
+		 this only if there is not more than one new line (which
+		 implies that we completely overwrite the old visible line)
+		 and the new line is shorter than the old.  Make sure we are
+		 at the end of the new line before clearing. */
+	      if (linenum == 0 &&
+		  inv_botlin == 0 && _rl_last_c_pos == out &&
+		  (wrap_offset > visible_wrap_offset) &&
+		  (_rl_last_c_pos < visible_first_line_len))
+		{
+		  nleft = screenwidth + wrap_offset - _rl_last_c_pos;
+		  if (nleft)
+		    _rl_clear_to_eol (nleft);
+		}
+
+	      /* Since the new first line is now visible, save its length. */
+	      if (linenum == 0)
+		visible_first_line_len = (inv_botlin > 0) ? inv_lbreaks[1] : out - wrap_offset;
+	    }
+
+	  /* We may have deleted some lines.  If so, clear the left over
+	     blank ones at the bottom out. */
+	  if (_rl_vis_botlin > inv_botlin)
+	    {
+	      char *tt;
+	      for (; linenum <= _rl_vis_botlin; linenum++)
+		{
+		  tt = VIS_CHARS (linenum);
+		  _rl_move_vert (linenum);
+		  _rl_move_cursor_relative (0, tt);
+		  _rl_clear_to_eol
+		    ((linenum == _rl_vis_botlin) ? strlen (tt) : screenwidth);
+		}
+	    }
+	  _rl_vis_botlin = inv_botlin;
+
+	  /* CHANGED_SCREEN_LINE is set to 1 if we have moved to a
+	     different screen line during this redisplay. */
+	  changed_screen_line = _rl_last_v_pos != cursor_linenum;
+	  if (changed_screen_line)
+	    {
+	      _rl_move_vert (cursor_linenum);
+	      /* If we moved up to the line with the prompt using term_up,
+	         the physical cursor position on the screen stays the same,
+	         but the buffer position needs to be adjusted to account
+	         for invisible characters. */
+	      if (cursor_linenum == 0 && wrap_offset)
+	        _rl_last_c_pos += wrap_offset;
+	    }
+
+	  /* We have to reprint the prompt if it contains invisible
+	     characters, since it's not generally OK to just reprint
+	     the characters from the current cursor position.  But we
+	     only need to reprint it if the cursor is before the last
+	     invisible character in the prompt string. */
+	  nleft = visible_length + wrap_offset;
+	  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&
+	      _rl_last_c_pos <= last_invisible && local_prompt)
+	    {
+	      if (term_cr)
+		tputs (term_cr, 1, _rl_output_character_function);
+	      _rl_output_some_chars (local_prompt, nleft);
+	      _rl_last_c_pos = nleft;
+	    }
+
+	  /* Where on that line?  And where does that line start
+	     in the buffer? */
+	  pos = inv_lbreaks[cursor_linenum];
+	  /* nleft == number of characters in the line buffer between the
+	     start of the line and the cursor position. */
+	  nleft = c_pos - pos;
+
+	  /* Since _rl_backspace() doesn't know about invisible characters in the
+	     prompt, and there's no good way to tell it, we compensate for
+	     those characters here and call _rl_backspace() directly. */
+	  if (wrap_offset && cursor_linenum == 0 && nleft < _rl_last_c_pos)
+	    {
+	      _rl_backspace (_rl_last_c_pos - nleft);
+	      _rl_last_c_pos = nleft;
+	    }
+
+	  if (nleft != _rl_last_c_pos)
+	    _rl_move_cursor_relative (nleft, &invisible_line[pos]);
+	}
+    }
+  else				/* Do horizontal scrolling. */
+    {
+#define M_OFFSET(margin, offset) ((margin) == 0 ? offset : 0)
+      int lmargin, ndisp, nleft, phys_c_pos, t;
+
+      /* Always at top line. */
+      _rl_last_v_pos = 0;
+
+      /* Compute where in the buffer the displayed line should start.  This
+	 will be LMARGIN. */
+
+      /* The number of characters that will be displayed before the cursor. */
+      ndisp = c_pos - wrap_offset;
+      nleft  = visible_length + wrap_offset;
+      /* Where the new cursor position will be on the screen.  This can be
+         longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
+      phys_c_pos = c_pos - (last_lmargin ? last_lmargin : wrap_offset);
+      t = screenwidth / 3;
+
+      /* If the number of characters had already exceeded the screenwidth,
+         last_lmargin will be > 0. */
+
+      /* If the number of characters to be displayed is more than the screen
+         width, compute the starting offset so that the cursor is about
+         two-thirds of the way across the screen. */
+      if (phys_c_pos > screenwidth - 2)
+	{
+	  lmargin = c_pos - (2 * t);
+	  if (lmargin < 0)
+	    lmargin = 0;
+	  /* If the left margin would be in the middle of a prompt with
+	     invisible characters, don't display the prompt at all. */
+	  if (wrap_offset && lmargin > 0 && lmargin < nleft)
+	    lmargin = nleft;
+	}
+      else if (ndisp < screenwidth - 2)		/* XXX - was -1 */
+        lmargin = 0;
+      else if (phys_c_pos < 1)
+	{
+	  /* If we are moving back towards the beginning of the line and
+	     the last margin is no longer correct, compute a new one. */
+	  lmargin = ((c_pos - 1) / t) * t;	/* XXX */
+	  if (wrap_offset && lmargin > 0 && lmargin < nleft)
+	    lmargin = nleft;
+	}
+      else
+        lmargin = last_lmargin;
+
+      /* If the first character on the screen isn't the first character
+	 in the display line, indicate this with a special character. */
+      if (lmargin > 0)
+	line[lmargin] = '<';
+
+      /* If SCREENWIDTH characters starting at LMARGIN do not encompass
+         the whole line, indicate that with a special characters at the
+         right edge of the screen.  If LMARGIN is 0, we need to take the
+         wrap offset into account. */
+      t = lmargin + M_OFFSET (lmargin, wrap_offset) + screenwidth;
+      if (t < out)
+        line[t - 1] = '>';
+
+      if (!rl_display_fixed || forced_display || lmargin != last_lmargin)
+	{
+	  forced_display = 0;
+	  update_line (&visible_line[last_lmargin],
+		       &invisible_line[lmargin],
+		       0,
+		       screenwidth + visible_wrap_offset,
+		       screenwidth + (lmargin ? 0 : wrap_offset),
+		       0);
+
+	  /* If the visible new line is shorter than the old, but the number
+	     of invisible characters is greater, and we are at the end of
+	     the new line, we need to clear to eol. */
+	  t = _rl_last_c_pos - M_OFFSET (lmargin, wrap_offset);
+	  if ((M_OFFSET (lmargin, wrap_offset) > visible_wrap_offset) &&
+	      (_rl_last_c_pos == out) &&
+	      t < visible_first_line_len)
+	    {
+	      nleft = screenwidth - t;
+	      _rl_clear_to_eol (nleft);
+	    }
+	  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);
+	  if (visible_first_line_len > screenwidth)
+	    visible_first_line_len = screenwidth;
+
+	  _rl_move_cursor_relative (c_pos - lmargin, &invisible_line[lmargin]);
+	  last_lmargin = lmargin;
+	}
+    }
+  fflush (rl_outstream);
+
+  /* Swap visible and non-visible lines. */
+  {
+    char *temp = visible_line;
+    int *itemp = vis_lbreaks;
+    visible_line = invisible_line;
+    invisible_line = temp;
+    vis_lbreaks = inv_lbreaks;
+    inv_lbreaks = itemp;
+    rl_display_fixed = 0;
+    /* If we are displaying on a single line, and last_lmargin is > 0, we
+       are not displaying any invisible characters, so set visible_wrap_offset
+       to 0. */
+    if (_rl_horizontal_scroll_mode && last_lmargin)
+      visible_wrap_offset = 0;
+    else
+      visible_wrap_offset = wrap_offset;
+  }
+}
+
+/* PWP: update_line() is based on finding the middle difference of each
+   line on the screen; vis:
+
+			     /old first difference
+	/beginning of line   |	      /old last same       /old EOL
+	v		     v	      v		    v
+old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as
+new:	eddie> Oh, my little buggy says to me, as lurgid as
+	^		     ^	^			   ^
+	\beginning of line   |	\new last same	   \new end of line
+			     \new first difference
+
+   All are character pointers for the sake of speed.  Special cases for
+   no differences, as well as for end of line additions must be handeled.
+
+   Could be made even smarter, but this works well enough */
+static void
+update_line (old, new, current_line, omax, nmax, inv_botlin)
+     register char *old, *new;
+     int current_line, omax, nmax, inv_botlin;
+{
+  register char *ofd, *ols, *oe, *nfd, *nls, *ne;
+  int temp, lendiff, wsatend, od, nd;
+  int current_invis_chars;
+
+  /* If we're at the right edge of a terminal that supports xn, we're
+     ready to wrap around, so do so.  This fixes problems with knowing
+     the exact cursor position and cut-and-paste with certain terminal
+     emulators.  In this calculation, TEMP is the physical screen
+     position of the cursor. */
+  temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
+  if (temp == screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
+      && _rl_last_v_pos == current_line - 1)
+    {
+      if (new[0])
+	putc (new[0], rl_outstream);
+      else
+	putc (' ', rl_outstream);
+      _rl_last_c_pos = 1;		/* XXX */
+      _rl_last_v_pos++;
+      if (old[0] && new[0])
+        old[0] = new[0];
+    }
+      
+  /* Find first difference. */
+  for (ofd = old, nfd = new;
+       (ofd - old < omax) && *ofd && (*ofd == *nfd);
+       ofd++, nfd++)
+    ;
+
+  /* Move to the end of the screen line.  ND and OD are used to keep track
+     of the distance between ne and new and oe and old, respectively, to
+     move a subtraction out of each loop. */
+  for (od = ofd - old, oe = ofd; od < omax && *oe; oe++, od++);
+  for (nd = nfd - new, ne = nfd; nd < nmax && *ne; ne++, nd++);
+
+  /* If no difference, continue to next line. */
+  if (ofd == oe && nfd == ne)
+    return;
+
+  wsatend = 1;			/* flag for trailing whitespace */
+  ols = oe - 1;			/* find last same */
+  nls = ne - 1;
+  while ((ols > ofd) && (nls > nfd) && (*ols == *nls))
+    {
+      if (*ols != ' ')
+	wsatend = 0;
+      ols--;
+      nls--;
+    }
+
+  if (wsatend)
+    {
+      ols = oe;
+      nls = ne;
+    }
+  else if (*ols != *nls)
+    {
+      if (*ols)			/* don't step past the NUL */
+	ols++;
+      if (*nls)
+	nls++;
+    }
+
+  /* count of invisible characters in the current invisible line. */
+  current_invis_chars = W_OFFSET (current_line, wrap_offset);
+  if (_rl_last_v_pos != current_line)
+    {
+      _rl_move_vert (current_line);
+      if (current_line == 0 && visible_wrap_offset)
+	_rl_last_c_pos += visible_wrap_offset;
+    }
+
+  /* If this is the first line and there are invisible characters in the
+     prompt string, and the prompt string has not changed, and the current
+     cursor position is before the last invisible character in the prompt,
+     and the index of the character to move to is past the end of the prompt
+     string, then redraw the entire prompt string.  We can only do this
+     reliably if the terminal supports a `cr' capability.
+
+     This is not an efficiency hack -- there is a problem with redrawing
+     portions of the prompt string if they contain terminal escape
+     sequences (like drawing the `unbold' sequence without a corresponding
+     `bold') that manifests itself on certain terminals. */
+
+  lendiff = local_prompt ? strlen (local_prompt) : 0;
+  od = ofd - old;	/* index of first difference in visible line */
+  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
+      term_cr && lendiff > visible_length && _rl_last_c_pos > 0 &&
+      od > lendiff && _rl_last_c_pos < last_invisible)
+    {
+      tputs (term_cr, 1, _rl_output_character_function);
+      _rl_output_some_chars (local_prompt, lendiff);
+      _rl_last_c_pos = lendiff;
+    }
+
+  _rl_move_cursor_relative (od, old);
+
+  /* if (len (new) > len (old)) */
+  lendiff = (nls - nfd) - (ols - ofd);
+
+  /* If we are changing the number of invisible characters in a line, and
+     the spot of first difference is before the end of the invisible chars,
+     lendiff needs to be adjusted. */
+  if (current_line == 0 && !_rl_horizontal_scroll_mode &&
+      current_invis_chars != visible_wrap_offset)
+    {
+      temp = visible_wrap_offset - current_invis_chars;
+      lendiff += temp;
+    }
+
+  /* Insert (diff (len (old), len (new)) ch. */
+  temp = ne - nfd;
+  if (lendiff > 0)
+    {
+      /* Non-zero if we're increasing the number of lines. */
+      int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
+      /* Sometimes it is cheaper to print the characters rather than
+	 use the terminal's capabilities.  If we're growing the number
+	 of lines, make sure we actually cause the new line to wrap
+	 around on auto-wrapping terminals. */
+      if (terminal_can_insert && ((2 * temp) >= lendiff || term_IC) && (!_rl_term_autowrap || !gl))
+	{
+	  /* If lendiff > visible_length and _rl_last_c_pos == 0 and
+	     _rl_horizontal_scroll_mode == 1, inserting the characters with
+	     term_IC or term_ic will screw up the screen because of the
+	     invisible characters.  We need to just draw them. */
+	  if (*ols && (!_rl_horizontal_scroll_mode || _rl_last_c_pos > 0 ||
+			lendiff <= visible_length || !current_invis_chars))
+	    {
+	      insert_some_chars (nfd, lendiff);
+	      _rl_last_c_pos += lendiff;
+	    }
+	  else if (*ols == 0)
+	    {
+	      /* At the end of a line the characters do not have to
+		 be "inserted".  They can just be placed on the screen. */
+	      /* However, this screws up the rest of this block, which
+	         assumes you've done the insert because you can. */
+	      _rl_output_some_chars (nfd, lendiff);
+	      _rl_last_c_pos += lendiff;
+	    }
+	  else
+	    {
+	      /* We have horizontal scrolling and we are not inserting at
+		 the end.  We have invisible characters in this line.  This
+		 is a dumb update. */
+	      _rl_output_some_chars (nfd, temp);
+	      _rl_last_c_pos += temp;
+	      return;
+	    }
+	  /* Copy (new) chars to screen from first diff to last match. */
+	  temp = nls - nfd;
+	  if ((temp - lendiff) > 0)
+	    {
+	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
+	      _rl_last_c_pos += temp - lendiff;
+	    }
+	}
+      else
+	{
+	  /* cannot insert chars, write to EOL */
+	  _rl_output_some_chars (nfd, temp);
+	  _rl_last_c_pos += temp;
+	}
+    }
+  else				/* Delete characters from line. */
+    {
+      /* If possible and inexpensive to use terminal deletion, then do so. */
+      if (term_dc && (2 * temp) >= -lendiff)
+	{
+	  /* If all we're doing is erasing the invisible characters in the
+	     prompt string, don't bother.  It screws up the assumptions
+	     about what's on the screen. */
+	  if (_rl_horizontal_scroll_mode && _rl_last_c_pos == 0 &&
+	      -lendiff == visible_wrap_offset)
+	    lendiff = 0;
+
+	  if (lendiff)
+	    delete_chars (-lendiff); /* delete (diff) characters */
+
+	  /* Copy (new) chars to screen from first diff to last match */
+	  temp = nls - nfd;
+	  if (temp > 0)
+	    {
+	      _rl_output_some_chars (nfd, temp);
+	      _rl_last_c_pos += temp;
+	    }
+	}
+      /* Otherwise, print over the existing material. */
+      else
+	{
+	  if (temp > 0)
+	    {
+	      _rl_output_some_chars (nfd, temp);
+	      _rl_last_c_pos += temp;
+	    }
+	  lendiff = (oe - old) - (ne - new);
+	  if (_rl_term_autowrap && current_line < inv_botlin)
+	    space_to_eol (lendiff);
+	  else
+	    _rl_clear_to_eol (lendiff);
+	}
+    }
+}
+
+/* Tell the update routines that we have moved onto a new (empty) line. */
+int
+rl_on_new_line ()
+{
+  if (visible_line)
+    visible_line[0] = '\0';
+
+  _rl_last_c_pos = _rl_last_v_pos = 0;
+  _rl_vis_botlin = last_lmargin = 0;
+  if (vis_lbreaks)
+    vis_lbreaks[0] = vis_lbreaks[1] = 0;
+  visible_wrap_offset = 0;
+  return 0;
+}
+
+/* Actually update the display, period. */
+int
+rl_forced_update_display ()
+{
+  if (visible_line)
+    {
+      register char *temp = visible_line;
+
+      while (*temp)
+        *temp++ = '\0';
+    }
+  rl_on_new_line ();
+  forced_display++;
+  (*rl_redisplay_function) ();
+  return 0;
+}
+
+/* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.
+   DATA is the contents of the screen line of interest; i.e., where
+   the movement is being done. */
+void
+_rl_move_cursor_relative (new, data)
+     int new;
+     char *data;
+{
+  register int i;
+
+  /* If we don't have to do anything, then return. */
+  if (_rl_last_c_pos == new) return;
+
+  /* It may be faster to output a CR, and then move forwards instead
+     of moving backwards. */
+  /* i == current physical cursor position. */
+  i = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
+  if (new == 0 || CR_FASTER (new, _rl_last_c_pos) ||
+      (_rl_term_autowrap && i == screenwidth))
+    {
+#if defined (__MSDOS__)
+      putc ('\r', rl_outstream);
+#else
+      tputs (term_cr, 1, _rl_output_character_function);
+#endif /* !__MSDOS__ */
+      _rl_last_c_pos = 0;
+    }
+
+  if (_rl_last_c_pos < new)
+    {
+      /* Move the cursor forward.  We do it by printing the command
+	 to move the cursor forward if there is one, else print that
+	 portion of the output buffer again.  Which is cheaper? */
+
+      /* The above comment is left here for posterity.  It is faster
+	 to print one character (non-control) than to print a control
+	 sequence telling the terminal to move forward one character.
+	 That kind of control is for people who don't know what the
+	 data is underneath the cursor. */
+#if defined (HACK_TERMCAP_MOTION)
+      extern char *term_forward_char;
+
+      if (term_forward_char)
+	for (i = _rl_last_c_pos; i < new; i++)
+	  tputs (term_forward_char, 1, _rl_output_character_function);
+      else
+	for (i = _rl_last_c_pos; i < new; i++)
+	  putc (data[i], rl_outstream);
+#else
+      for (i = _rl_last_c_pos; i < new; i++)
+	putc (data[i], rl_outstream);
+#endif /* HACK_TERMCAP_MOTION */
+    }
+  else if (_rl_last_c_pos != new)
+    _rl_backspace (_rl_last_c_pos - new);
+  _rl_last_c_pos = new;
+}
+
+/* PWP: move the cursor up or down. */
+void
+_rl_move_vert (to)
+     int to;
+{
+  register int delta, i;
+
+  if (_rl_last_v_pos == to || to > screenheight)
+    return;
+
+#if defined (__GO32__)
+  {
+    int row, col;
+
+    ScreenGetCursor (&row, &col);
+    ScreenSetCursor ((row + to - _rl_last_v_pos), col);
+  }
+#else /* !__GO32__ */
+
+  if ((delta = to - _rl_last_v_pos) > 0)
+    {
+      for (i = 0; i < delta; i++)
+	putc ('\n', rl_outstream);
+      tputs (term_cr, 1, _rl_output_character_function);
+      _rl_last_c_pos = 0;
+    }
+  else
+    {			/* delta < 0 */
+      if (term_up && *term_up)
+	for (i = 0; i < -delta; i++)
+	  tputs (term_up, 1, _rl_output_character_function);
+    }
+#endif /* !__GO32__ */
+  _rl_last_v_pos = to;		/* Now TO is here */
+}
+
+/* Physically print C on rl_outstream.  This is for functions which know
+   how to optimize the display.  Return the number of characters output. */
+int
+rl_show_char (c)
+     int c;
+{
+  int n = 1;
+  if (META_CHAR (c) && (_rl_output_meta_chars == 0))
+    {
+      fprintf (rl_outstream, "M-");
+      n += 2;
+      c = UNMETA (c);
+    }
+
+#if defined (DISPLAY_TABS)
+  if ((CTRL_CHAR (c) && c != '\t') || c == RUBOUT)
+#else
+  if (CTRL_CHAR (c) || c == RUBOUT)
+#endif /* !DISPLAY_TABS */
+    {
+      fprintf (rl_outstream, "C-");
+      n += 2;
+      c = CTRL_CHAR (c) ? UNCTRL (c) : '?';
+    }
+
+  putc (c, rl_outstream);
+  fflush (rl_outstream);
+  return n;
+}
+
+int
+rl_character_len (c, pos)
+     register int c, pos;
+{
+  unsigned char uc;
+
+  uc = (unsigned char)c;
+
+  if (META_CHAR (uc))
+    return ((_rl_output_meta_chars == 0) ? 4 : 1);
+
+  if (uc == '\t')
+    {
+#if defined (DISPLAY_TABS)
+      return (((pos | 7) + 1) - pos);
+#else
+      return (2);
+#endif /* !DISPLAY_TABS */
+    }
+
+  if (CTRL_CHAR (c) || c == RUBOUT)
+    return (2);
+
+  return ((isprint (uc)) ? 1 : 2);
+}
+
+/* How to print things in the "echo-area".  The prompt is treated as a
+   mini-modeline. */
+
+#if defined (USE_VARARGS)
+int
+#if defined (PREFER_STDARG)
+rl_message (const char *format, ...)
+#else
+rl_message (va_alist)
+     va_dcl
+#endif
+{
+  va_list args;
+#if defined (PREFER_VARARGS)
+  char *format;
+#endif
+
+#if defined (PREFER_STDARG)
+  va_start (args, format);
+#else
+  va_start (args);
+  format = va_arg (args, char *);
+#endif
+
+  vsprintf (msg_buf, format, args);
+  va_end (args);
+
+  rl_display_prompt = msg_buf;
+  (*rl_redisplay_function) ();
+  return 0;
+}
+#else /* !USE_VARARGS */
+int
+rl_message (format, arg1, arg2)
+     char *format;
+{
+  sprintf (msg_buf, format, arg1, arg2);
+  rl_display_prompt = msg_buf;
+  (*rl_redisplay_function) ();
+  return 0;
+}
+#endif /* !USE_VARARGS */
+
+/* How to clear things from the "echo-area". */
+int
+rl_clear_message ()
+{
+  rl_display_prompt = rl_prompt;
+  (*rl_redisplay_function) ();
+  return 0;
+}
+
+int
+rl_reset_line_state ()
+{
+  rl_on_new_line ();
+
+  rl_display_prompt = rl_prompt ? rl_prompt : "";
+  forced_display = 1;
+  return 0;
+}
+
+static char *saved_local_prompt;
+static char *saved_local_prefix;
+static int saved_last_invisible;
+static int saved_visible_length;
+
+void
+_rl_save_prompt ()
+{
+  saved_local_prompt = local_prompt;
+  saved_local_prefix = local_prompt_prefix;
+  saved_last_invisible = last_invisible;
+  saved_visible_length = visible_length;
+
+  local_prompt = local_prompt_prefix = (char *)0;
+  last_invisible = visible_length = 0;
+}
+
+void
+_rl_restore_prompt ()
+{
+  if (local_prompt)
+    free (local_prompt);
+  if (local_prompt_prefix)
+    free (local_prompt_prefix);
+
+  local_prompt = saved_local_prompt;
+  local_prompt_prefix = saved_local_prefix;
+  last_invisible = saved_last_invisible;
+  visible_length = saved_visible_length;
+}
+
+char *
+_rl_make_prompt_for_search (pchar)
+     int pchar;
+{
+  int len;
+  char *pmt;
+
+  _rl_save_prompt ();
+
+  if (saved_local_prompt == 0)
+    {
+      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
+      pmt = xmalloc (len + 2);
+      if (len)
+        strcpy (pmt, rl_prompt);
+      pmt[len] = pchar;
+      pmt[len+1] = '\0';
+    }
+  else
+    {
+      len = *saved_local_prompt ? strlen (saved_local_prompt) : 0;
+      pmt = xmalloc (len + 2);
+      if (len)
+        strcpy (pmt, saved_local_prompt);
+      pmt[len] = pchar;
+      pmt[len+1] = '\0';
+      local_prompt = savestring (pmt);
+      last_invisible = saved_last_invisible;
+      visible_length = saved_visible_length + 1;
+    }
+  return pmt;
+}
+
+/* Quick redisplay hack when erasing characters at the end of the line. */
+void
+_rl_erase_at_end_of_line (l)
+     int l;
+{
+  register int i;
+
+  _rl_backspace (l);
+  for (i = 0; i < l; i++)
+    putc (' ', rl_outstream);
+  _rl_backspace (l);
+  for (i = 0; i < l; i++)
+    visible_line[--_rl_last_c_pos] = '\0';
+  rl_display_fixed++;
+}
+
+/* Clear to the end of the line.  COUNT is the minimum
+   number of character spaces to clear, */
+void
+_rl_clear_to_eol (count)
+     int count;
+{
+#if !defined (__GO32__)
+  if (term_clreol)
+    tputs (term_clreol, 1, _rl_output_character_function);
+  else if (count)
+#endif /* !__GO32__ */
+    space_to_eol (count);
+}
+
+/* Clear to the end of the line using spaces.  COUNT is the minimum
+   number of character spaces to clear, */
+static void
+space_to_eol (count)
+     int count;
+{
+  register int i;
+
+  for (i = 0; i < count; i++)
+   putc (' ', rl_outstream);
+
+  _rl_last_c_pos += count;
+}
+
+void
+_rl_clear_screen ()
+{
+#if !defined (__GO32__)
+  if (term_clrpag)
+    tputs (term_clrpag, 1, _rl_output_character_function);
+  else
+#endif /* !__GO32__ */
+    crlf ();
+}
+
+/* Insert COUNT characters from STRING to the output stream. */
+static void
+insert_some_chars (string, count)
+     char *string;
+     int count;
+{
+#if defined (__GO32__)
+  int row, col, width;
+  char *row_start;
+
+  ScreenGetCursor (&row, &col);
+  width = ScreenCols ();
+  row_start = ScreenPrimary + (row * width);
+
+  memcpy (row_start + col + count, row_start + col, width - col - count);
+
+  /* Place the text on the screen. */
+  _rl_output_some_chars (string, count);
+#else /* !_GO32 */
+
+  /* If IC is defined, then we do not have to "enter" insert mode. */
+  if (term_IC)
+    {
+      char *buffer;
+      buffer = tgoto (term_IC, 0, count);
+      tputs (buffer, 1, _rl_output_character_function);
+      _rl_output_some_chars (string, count);
+    }
+  else
+    {
+      register int i;
+
+      /* If we have to turn on insert-mode, then do so. */
+      if (term_im && *term_im)
+	tputs (term_im, 1, _rl_output_character_function);
+
+      /* If there is a special command for inserting characters, then
+	 use that first to open up the space. */
+      if (term_ic && *term_ic)
+	{
+	  for (i = count; i--; )
+	    tputs (term_ic, 1, _rl_output_character_function);
+	}
+
+      /* Print the text. */
+      _rl_output_some_chars (string, count);
+
+      /* If there is a string to turn off insert mode, we had best use
+	 it now. */
+      if (term_ei && *term_ei)
+	tputs (term_ei, 1, _rl_output_character_function);
+    }
+#endif /* !__GO32__ */
+}
+
+/* Delete COUNT characters from the display line. */
+static void
+delete_chars (count)
+     int count;
+{
+#if defined (__GO32__)
+  int row, col, width;
+  char *row_start;
+
+  ScreenGetCursor (&row, &col);
+  width = ScreenCols ();
+  row_start = ScreenPrimary + (row * width);
+
+  memcpy (row_start + col, row_start + col + count, width - col - count);
+  memset (row_start + width - count, 0, count * 2);
+#else /* !_GO32 */
+
+  if (count > screenwidth)	/* XXX */
+    return;
+
+  if (term_DC && *term_DC)
+    {
+      char *buffer;
+      buffer = tgoto (term_DC, count, count);
+      tputs (buffer, count, _rl_output_character_function);
+    }
+  else
+    {
+      if (term_dc && *term_dc)
+	while (count--)
+	  tputs (term_dc, 1, _rl_output_character_function);
+    }
+#endif /* !__GO32__ */
+}
+
+void
+_rl_update_final ()
+{
+  int full_lines;
+
+  full_lines = 0;
+  /* If the cursor is the only thing on an otherwise-blank last line,
+     compensate so we don't print an extra CRLF. */
+  if (_rl_vis_botlin && _rl_last_c_pos == 0 &&
+	visible_line[vis_lbreaks[_rl_vis_botlin]] == 0)
+    {
+      _rl_vis_botlin--;
+      full_lines = 1;
+    }
+  _rl_move_vert (_rl_vis_botlin);
+  /* If we've wrapped lines, remove the final xterm line-wrap flag. */
+  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == screenwidth))
+    {
+      char *last_line;
+      last_line = &visible_line[inv_lbreaks[_rl_vis_botlin]];
+      _rl_move_cursor_relative (screenwidth - 1, last_line);
+      _rl_clear_to_eol (0);
+      putc (last_line[screenwidth - 1], rl_outstream);
+    }
+  _rl_vis_botlin = 0;
+  crlf ();
+  fflush (rl_outstream);
+  rl_display_fixed++;
+}
+
+/* Move to the start of the current line. */
+static void
+cr ()
+{
+  if (term_cr)
+    {
+      tputs (term_cr, 1, _rl_output_character_function);
+      _rl_last_c_pos = 0;
+    }
+}
+
+/* Redisplay the current line after a SIGWINCH is received. */
+void
+_rl_redisplay_after_sigwinch ()
+{
+  char *t, *oldp;
+
+  /* Clear the current line and put the cursor at column 0.  Make sure
+     the right thing happens if we have wrapped to a new screen line. */
+  if (term_cr)
+    {
+      tputs (term_cr, 1, _rl_output_character_function);
+      _rl_last_c_pos = 0;
+      if (term_clreol)
+	tputs (term_clreol, 1, _rl_output_character_function);
+      else
+	{
+	  space_to_eol (screenwidth);
+	  tputs (term_cr, 1, _rl_output_character_function);
+	}
+      if (_rl_last_v_pos > 0)
+	_rl_move_vert (0);
+    }
+  else
+    crlf ();
+
+  /* Redraw only the last line of a multi-line prompt. */
+  t = strrchr (rl_display_prompt, '\n');
+  if (t)
+    {
+      oldp = rl_display_prompt;
+      rl_display_prompt = ++t;
+      rl_forced_update_display ();
+      rl_display_prompt = oldp;
+    }
+  else
+    rl_forced_update_display ();
+}
+
+void
+_rl_clean_up_for_exit ()
+{
+  if (readline_echoing_p)
+    {
+      _rl_move_vert (_rl_vis_botlin);
+      _rl_vis_botlin = 0;
+      fflush (rl_outstream);
+      rl_restart_output ();
+    }
+}
diff --git a/readline/doc/Makefile.in b/readline/doc/Makefile.in
new file mode 100644
--- /dev/null
+++ b/readline/doc/Makefile.in
@@ -0,0 +1,123 @@
+# This makefile for Readline library documentation is in -*- text -*- mode.
+# Emacs likes it that way.
+top_srcdir = @top_srcdir@
+srcdir = @srcdir@
+
+prefix = @prefix@
+infodir = @infodir@
+
+mandir = @mandir@
+man3dir = $(mandir)/man3
+
+RM = rm -f
+
+TEXINPUTDIR = $(srcdir)
+
+MAKEINFO    = makeinfo
+TEXI2DVI    = $(srcdir)/texi2dvi
+TEXI2HTML   = $(srcdir)/texi2html
+QUIETPS     = #set this to -q to shut up dvips
+DVIPS       = dvips -D 300 $(QUIETPS) -o $@     # tricky
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+
+RLSRC = $(srcdir)/rlman.texinfo $(srcdir)/rluser.texinfo \
+	$(srcdir)/rltech.texinfo
+HISTSRC = $(srcdir)/hist.texinfo $(srcdir)/hsuser.texinfo \
+	  $(srcdir)/hstech.texinfo
+
+# This should be a program that converts troff to an ascii-readable format
+NROFF       = groff -Tascii
+
+# This should be a program that converts troff to postscript
+GROFF       = groff
+
+DVIOBJ = readline.dvi history.dvi
+INFOOBJ = readline.info history.info
+PSOBJ = readline.ps history.ps
+HTMLOBJ = readline.html history.html
+TEXTOBJ = readline.0
+
+CREATED_DOCS = $(DVIOBJ) $(INFOOBJ) $(PSOBJ) $(HTMLOBJ) $(TEXTOBJ)
+
+.SUFFIXES:      .0 .3 .ps .txt .dvi
+
+.3.0:
+	$(RM) $@
+	-${NROFF} -man $< > $@
+
+all: info dvi html ps text
+nodvi: info html text
+
+readline.dvi: $(RLSRC)
+	TEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/rlman.texinfo
+	mv rlman.dvi readline.dvi
+
+readline.info: $(RLSRC)
+	$(MAKEINFO) --no-split -I $(TEXINPUTDIR) -o $@ $(srcdir)/rlman.texinfo
+
+history.dvi: ${HISTSRC}
+	TEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2DVI) $(srcdir)/hist.texinfo
+	mv hist.dvi history.dvi
+
+history.info: ${HISTSRC}
+	$(MAKEINFO) --no-split -I $(TEXINPUTDIR) -o $@ $(srcdir)/hist.texinfo
+
+readline.ps:	readline.dvi
+	$(RM) $@
+	$(DVIPS) readline.dvi
+
+history.ps:	history.dvi
+	$(RM) $@
+	$(DVIPS) history.dvi
+
+readline.html:	${RLSRC}
+	$(TEXI2HTML) -I $(TEXINPUTDIR) $(srcdir)/rlman.texinfo
+	sed -e 's:rlman.html:readline.html:' -e 's:rlman_toc.html:readline_toc.html:' rlman.html > readline.html
+	sed -e 's:rlman.html:readline.html:' -e 's:rlman_toc.html:readline_toc.html:' rlman_toc.html > readline_toc.html
+	$(RM) rlman.html rlman_toc.html
+
+history.html:	${HISTSRC}
+	$(TEXI2HTML) -I $(TEXINPUTDIR) $(srcdir)/hist.texinfo
+	sed -e 's:hist.html:history.html:' -e 's:hist_toc.html:history_toc.html:' hist.html > history.html
+	sed -e 's:hist.html:history.html:' -e 's:hist_toc.html:history_toc.html:' hist_toc.html > history_toc.html
+	$(RM) hist.html hist_toc.html
+
+info:	$(INFOOBJ)
+dvi:	$(DVIOBJ)
+ps:	$(PSOBJ)
+html:	$(HTMLOBJ)
+text:	$(TEXTOBJ)
+
+readline.0: $(srcdir)/readline.3
+
+clean:
+	$(RM) *.aux *.cp *.fn *.ky *.log *.pg *.toc *.tp *.vr *.cps *.pgs \
+	      *.fns *.kys *.tps *.vrs *.o core
+
+distclean: clean
+	$(RM) $(CREATED_DOCS)
+
+mostlyclean: clean
+
+maintainer-clean: clean
+	$(RM) $(CREATED_DOCS)
+
+installdirs:	$(top_srcdir)/support/mkdirs
+	-$(SHELL) $(top_srcdir)/support/mkdirs $(infodir) $(man3dir)
+
+install:	installdirs info
+	${INSTALL_DATA} readline.info $(infodir)/readline.info
+	${INSTALL_DATA} history.info $(infodir)/history.info
+	if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
+		install-info --dir-file=$(infodir)/dir $(infodir)/readline.info ; \
+		install-info --dir-file=$(infodir)/dir $(infodir)/history.info ; \
+	else true; fi
+	-${INSTALL_DATA} $(srcdir)/readline.3 $(man3dir)/readline.3
+
+uninstall:
+	$(RM) $(infodir)/readline.info
+	$(RM) $(infodir)/history.info
+	$(RM) $(man3dir)/readline.3
diff --git a/readline/doc/hist.texinfo b/readline/doc/hist.texinfo
new file mode 100644
--- /dev/null
+++ b/readline/doc/hist.texinfo
@@ -0,0 +1,112 @@
+\input texinfo    @c -*-texinfo-*-
+@c %**start of header (This is for running Texinfo on a region.)
+@setfilename history.info
+@settitle GNU History Library
+@c %**end of header (This is for running Texinfo on a region.)
+
+@setchapternewpage odd
+
+@ignore
+last change: Thu Mar 21 16:07:29 EST 1996
+@end ignore
+
+@set EDITION 2.1
+@set VERSION 2.1
+@set UPDATED 21 March 1996
+@set UPDATE-MONTH March 1996
+
+@ifinfo
+This document describes the GNU History library, a programming tool that
+provides a consistent user interface for recalling lines of previously
+typed input.
+
+Copyright (C) 1988, 1991, 1993, 1995, 1996 Free Software Foundation, Inc.
+
+Permission is granted to make and distribute verbatim copies of
+this manual provided the copyright notice and this permission notice
+pare preserved on all copies.
+
+@ignore
+Permission is granted to process this file through TeX and print the
+results, provided the printed document carries copying permission
+notice identical to this one except for the removal of this paragraph
+(this paragraph not being relevant to the printed manual).
+@end ignore
+
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided that the entire
+resulting derived work is distributed under the terms of a permission
+notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions,
+except that this permission notice may be stated in a translation approved
+by the Foundation.
+@end ifinfo
+
+@titlepage
+@title GNU History Library
+@subtitle Edition @value{EDITION}, for @code{History Library} Version @value{VERSION}.
+@subtitle @value{UPDATE-MONTH}
+@author Brian Fox, Free Software Foundation
+@author Chet Ramey, Case Western Reserve University
+
+@page
+This document describes the GNU History library, a programming tool that
+provides a consistent user interface for recalling lines of previously
+typed input.
+
+Published by the Free Software Foundation @*
+675 Massachusetts Avenue, @*
+Cambridge, MA 02139 USA
+
+Permission is granted to make and distribute verbatim copies of
+this manual provided the copyright notice and this permission notice
+are preserved on all copies.
+
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided that the entire
+resulting derived work is distributed under the terms of a permission
+notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions,
+except that this permission notice may be stated in a translation approved
+by the Foundation.
+
+@vskip 0pt plus 1filll
+Copyright @copyright{} 1989, 1991 Free Software Foundation, Inc.
+@end titlepage
+
+@ifinfo
+@node Top
+@top GNU History Library
+
+This document describes the GNU History library, a programming tool that
+provides a consistent user interface for recalling lines of previously
+typed input.
+
+@menu
+* Using History Interactively::	  GNU History User's Manual.
+* Programming with GNU History::  GNU History Programmer's Manual.
+* Concept Index::		  Index of concepts described in this manual.
+* Function and Variable Index::	  Index of externally visible functions
+				  and variables.
+@end menu
+@end ifinfo
+
+@syncodeindex fn vr
+
+@include hsuser.texinfo
+@include hstech.texinfo
+
+@node Concept Index
+@appendix Concept Index
+@printindex cp
+
+@node Function and Variable Index
+@appendix Function and Variable Index
+@printindex vr
+
+@contents
+@bye
diff --git a/readline/doc/history.dvi b/readline/doc/history.dvi
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..4a4673cd2221a39e2375d04dc427408231bd24c9
GIT binary patch
literal 50348
zc%1Eh3z!^LwQkRJPZB~vL{WJNCV^xUCX?xzJV*wF5Rwoe5t4vtc%-JgdZtKs)lgNP
z%*aDN!3V-LQz>Yg1V~U$G@OVB^m@4}D2O8W#*0tz@SScLR8aA%IC=!nf!wv$e$=k&
zo|#U9FEaU*nW?V5_uA|6ueH}+d-tCk8?N8-&Eq;_@Gt($W8b$<zxaJt-tEo1?@KOP
zw6L{pUTbo};^h4H_M701hFBf{_QJn`?SF{H3OgFF?|61##~afh`PsnmMUOqbdPnS?
zU%w(Y1zwtv%60W6+h4wD#p(--6TkDhvkk|!?0)||qs!Lp{=)VtliF^KC1A*(Ji220
zp<C}8*b;j!^^W28b6?reADcYf5t|IXG^KKOvaP%<ZMcSI7UMfJ?XAfcKV#YcaL04M
zKDAH23FEnLvaJ#s$1h*x?R}T7+YYq%p>b<r`(d%zz?O!)9*eKi?9||cQ+qt<7nrf2
zu%qD<KiE7lyqsoocqS8?$?`L8Lo<s_nauKSZ|uxigE#N#Yw?$tY+d))S{e7YoA+$?
zHCy-ajgpl&(;5<8*nR|zx3ouhvFREur}ty?7JsSc=>7*wy5s7$>95fp-QKkI<~_Q9
zp=oR?A;oS9_%vzHo*QG0j8BE_?}^23MnN^!BPjScJ0z&rpZxvz2g>Vu45t`>==`*`
zbyX#m&*>&G!S&O+ld_F2Ajo%nbRXpA#UDCP@H5N!iOg*A;$Qzin%`?%-L{s?8D_Wd
zS|uwB%`_JuZ+&p;CIh<jH9uvU4)ma#CAV<z+kg>ym?p~6FySqjc}7d=Bu`sUY1u4x
z2LFM!RtCD#HyKvm$@creir&Fh6+P`6Cg^T!Vb@gX?EHLJ)^K|CH1^m99rhFH%aKYU
zmeS@D2!%ZhgmTZof`#+9L911o<7lbdKnr{z&2^p9l1;vD`gy$tURtW<fHz&Xk?z)8
zaFA6?{I>RF$0Gm2wMz;+2hN8vbvtJ`s9wd!zkJegd|(R97ASQsKc{Uh>Aq&B{WNd^
zxSMx%ABEcmWaNN5y#|}A3o?PX%~D>=A`45%z%<PUUMlt5Mt2Xe@SXwFa*dRZq+qYq
zj2I(`@YxHfh{!)wDwqLu1s?%_`H-zuw8t-bEkZku8>KyG!C+})3cSK}6y#e)KX6&M
zIqfDhT?a@9DHr3h>o(E2k^!ZDkU6N-)ce(GgCb#j)Efh40u#w+T~rR}8LcDjZ!TH(
zMju8Es7os&gKFh)P%A^cs?8)AjC9`s)x#;%EG$#6W>4ZvzpaNoF1+AmNyVz!VnAC9
zT3A4z?PoQ!JFj(<ni1K>_=YS}u62P~TA-1jhxjbuA=ydJDsld!T$u!bedb2JFQxao
zf_JDFrK$<%v_UiyFmm5<HJAwuZkUWi3hlnu3&LO|q|r*c{QeTqRtj5DD*)!g-<~kA
z)ar$INk@Hm0RDLs9ys#ufBjghP$=ME(82KHsnc4vs%Y)>C)<8;7`##Njy$8GoLqFu
zBC;?5;-tTPn_|JxHvubtssL+?ztT*#76MGH%Xz_TKO#&V7$`68(Ry75N6E!rqFlbv
zK@}5_x6-_gAWBQQ1~4Mqzop?_pKy{uv4GRh1Dp;Fzn|R2+gIGLx{F^Wy+a<lfI5W!
zR|S0*_vRl{JB10%?R|8>190TX{DVhRpnHrqfy$`8j^AUIHlywVQUw_OgRew=9x56i
zp#&pv%>IwtGq#ljOhyQv>7W9b={XFQdr{>KvV~T!spsUCZZZDj>zp1dpG}jt5RQYA
zg5Jpvy7TaaUT11y!@!`SIi^DJzdW&168d8|8UzUC>xcPTdE1BSnZmC)ExrQ^z-8pO
z`|HnF9L{FL?ZIA!ur6)!d%>9e`QYCdr*9b;czJoUHR(+{`VNrd&3gidtHM~;*9$6-
z?f~4$)x$yt@Xp+)BYqF58VuZ85C2pbJ@^@2bMv;&%nyvuF>*#$vl*)B)eT_o+{6&^
zgpE~FPEWZNRS{L8<mf5nWl2>6vO}le^j)p51d>PtsFVO=jNUvLuTCHH(MpOu5Yljd
zd|t))*Y1|II6m{nHi3H{a00<K4S0hJqmmEa*5x>ckI5H<BH6l@0}cD;Z@}N7bPU(m
zH3#METE+N(o@MI<zrdN4l>=JSfLMviry3?G5(9e8?#4g_sc?{Insol6i85>|Z`<e@
z`1lwvP=A&UBTnf<jnZw~vT<Hj{W$)Wc>}|~jm$EljA?x6q(G{!wh`R`U}+ZP6zC4)
z2@7=1b{&vY!3K5lr`Qh39LP)S=y-r2e{+wKD)kU?0Urf1KxdB_@99=yXJCXn8W*^f
zyp4Qx@?DN=xOozwmnh|NG*Ai)*+JtudKPp9px&|-r=z)iT(ZejHqSMViP<VPe)*UX
zAJOG`iGicBduqtK1wyJQm#P5cW5C9Pl;H)v_qUxB!uM>lZAb?If&t1cUgOUPS-_%`
zE9T^K2YvE80-EVJj9xS%AWzU_(i1-3&}NVx>L*&tmmj47U$cq0A?_V*$BW;6Tba5+
zv-S3-&(gpiyRte9%Y?ZgK|q9<Z!!LhcW>UxdIw~?;}yvfm~NMCK{RJ_MdT)eDuF_Q
zxZclbP7i4fPT@@W!%tgevtS#4eB80v2M#jD*0M0{GP4`w*JAwIFEoRwAn@;-<%{t_
z`k=%Z8XyGsgW6gyf{z_WV+vRpHNcMV?>IY(G}MHIf17IKA-@j(o(vR1fRtXcG9eU^
zJ(W^^kA^_1+bt#3Z@;GmD7B$7wLG(gU8VJm25}l-@B+l(;nn0B51al>Xd$&4kQuOf
zV!C<RrrU}`z)=@MgjHwhj?ryuFr-u9Hd$U`B9;0kpd4RAAms1hz#6Q*z|wW389-1g
zaT710#86T$VPI%7h+sh9iLbo~kx6ALL?4U3KU`kxf<YJK14jkWuG${RZ_7zMzS`Ua
z9cQd;)}pus`8aSCPF^cHy#Nvr#B4dq)w)_xFMx=&U?;&8$N>keoQ5D(2ANly%dLfb
zkK*JEnVg_CI5B*OB25N>q=!Q$ynhe9Jg4T{EbL}2hD^WAR#ROXL7r$jb%cgdu#~O{
z^<VSB?N}Hj^ydg#K=5;t<(Z<>Aq<1f?h(4qSpbr-$m6R`L8614mmZyWQC7pcI+wZ=
zUJ_wl`<8~DC$Gc21B@OGIl{qPW$NjCNH6yL_f*!OekqHG)EPXWSIuCnIs-7qlB*de
zPD0Y}CEj=zu>*o?gBG<LDyNrc0`Pz#lOOl3oZ+$n90xOKnS!GTdJ@HJ%Z3xuG+H<3
za(dbT<jP`47|d(Fsc%Lp!=m`8DeDF*m+>x=#n^L;<X`Q6<uX24`2y|%i}6QV)~Y^c
zThmExYoxPAa<ZBurwV59`0?P&!51o%O?rvD^s*|x_Ht`!8F<-EbNGN-mPwtf1L)sk
zXKskfxdD}P%jl9(p{8?HqL2(=fcS3Mde|a@)BqrCMzg`X+ZXmh1V}j3jyUr{?~TVl
z3jkRKGux+5n9Y#pgDiwi7ZbN!6`%}*TXM;Pv&D}QdL>XxC&}Git2gnE_b%}gx17GA
zvKXZ9=nyYxE>EoRm(c5=Z_`u8l$6HOTmE}wSKP<>0WF|Y&zLJg7@A2TIaeUx$c)ec
z-|B`Ki<y=NDtK9WCL+*=%8BqxF)`!G4VBsO8+<Ycf57@YaoDjNDkp(WdlTONy5I@p
z0=kcUjzuXjeSB3?%SIv-uoyW!D4X#l4ep94Nl*z55Gw8&fEBpqstKGnzxgA&ZOtO+
z2~)u0MZIPy$io)KXy!0+^#T5#P}xDu2jc*>YQyy?8zZb=m9{dF%B4!fi**gI;QMh=
zoHdxJoEEmkHk=UNGA~TpE3uh(4!Dh-v*~jMzbyO;F-Qr7JH=w6g>~#FdAk$C?Z`xV
zJ6gf9w@wPb#peZcaUm|{EDFOKun}NN1;o=ydo>$c@M-l`<_z`oo|j<15Hi5J3#2Zh
zvQAW|q5f^q9$IT%UFcIt`!`hD;DZu+45Dzh=qH;k#&7)`*BoJ1fHtKLnbgpI5)T@|
zaKs^%q&rH^IT2MCURg;2IjEKo)<TN`zHa7-M2b&%N`u-I;9Ze-Toz4nUh&|LTWlx$
zBiHMqauJiTm94|V&(!(bxW>^OU2w~bJ$iXC&wv-GgBy^UK(J(N^=n1tHBfO{jQATw
zw`j9numD0Na00aET1fhi*tRlLOf;o5IV%MraG{z<wMIAtL$&gZVQj)+I)f@efjz%>
zTCFev`$3Qd=4y^`WHM?C19Arf@+xc4IGzRSDhMyhU^*u8@H}j9_2QUXwg%lTUQ^>s
z{Us|;V5p@rDdFf><}ngPRYVz5s?62}9+4j{ZDyb&vzWF+IVWACj0?^S0%L9)2$+je
zSA$R_USBA3#3KikVd{uxm<B36GN{VQ%plL%vGAf-b9+o&gMdV6ePuEXY4NkVR@y|s
zY-X9k_vl(0V@{-SpyJl<I-A9o>CyUjl+G#T3bgQ8&>o9kCx3WfAR0Rdylx%Bhp5@8
z*U&TNTX^4HU{go~?_VF0XtW1c4ZN^Z-l~_kI^Q;ea0K3k_(^IqwohAx9D1Lg!lbU@
zV*3h2ELJu>Xs&@^1zHe3&Q-!i8A$2H#O^)xO4FS`FC#KZ_lJ6yVm^y$Dt75L9eaFP
zLJc>XZO{h=b>75Rj#y&S;wo!^q3d=jr}_OH$H*HO6L&XKjDqP7N>o748z7JZES&iG
z0~m+O#%c<fR+Q9=kuhamnXMX-^ujS^9yc&QDh4D|+2{b$02ojB-eN?Tb3eYJG6TV0
zEF)=MjQzmMKjH2%Tn3ax9J4MQu}mF6pmgqsxvz%aORR5zBakLh$VYaWAES}@x&*k2
z01-?M)As^40NL5NK^TjheS87yTc(o2V&Stei5XJ6cqA+oMdDs4F~gKgtb3MfAc|t*
zZFjOHE;vU@)Ucpm<5+8zFb5FY;t-h2gg)WuYcJ#yh4sZ1d6N=>ERx$$aWIbCE;Nrp
zF1%UkuBoGCjO;|y8DT_A)Q4zCuM~(jua3o)?7gYJ-j6@F241!kUXGUY-4grD#qXXU
z1<PNxW8z(DhZ)~!Q{cdy#!sn9_vT-Wm2_uWb=t2KDQf2L$q{X~K>>Xk>{7zJ`P&f&
zv3w&z24>hFc~NBkNI60|c2_5QOxl_fnf95Nj*w|*nyh5~X^Q|*farMSc}@rI1W>w*
zOiAR{lm7ZK{L-c5CMm;?JLn4%1<bIwiwyhV&3iDh<aDI-DZWv^3OFX2y=!XhV~p9W
zG|C?o6F2OZOtitza66O>3fy7<E>KjD`9R+_a)^a}UtGtzo4CP==IAjb>>{Lctzu&O
ze^I!k_o6QVSYhtQa@g7gGtf&nXpTdWjKLO!&|QX09i=r_W3q(EfG2U;`v8w%^jYI0
zdPoFFH)Zr0K2TInc^9%@<~51K=xV@!IwI?g!Fgh7r`St}Ne7!I(dqSQFu$#lY-WZ-
zgTpt`b9$~s>SQZh=@26+8Rz((3}(Svw#9$)qQU@tzZMIa6k1Bqw<TOM>sLyPx+~E_
z0U?%6z_#+;JtzyD;*npatplWyOBJ*og9x5D!7xsa?dp9l53qsjbDl!3i%cJTxzx|I
zvZfs0PXmgkT#?kjXJ93$;Xn+6LqnwS-Wg=~hJqY_S+J1wC(2)*#ut0j4xfTj*T8f&
zKnDzhQ?})h7Nm_sk!(tN355^IzVke4&ZI6)0?`CI5AdXxE>K*AqBiv@E^4<z77d6!
z%d9^mt{DH=7U9-)YP7keXR~uQnzZ*O_ee5q)yuNvGQdN*D0LZJ4ag`Q7Fi=87UPfI
zO|OD<l+X$j>g_kIW5FEej`@^=VJw9JT<_Q3Lqq&h+%Ex>tT|!91=~jBY=!_Oe)Y$g
z`<7P5aySmyzzsjc1-xd;P1Q93N2FY8$qS{sQMcKC3MztQ<@E3*Fx|x`667;@PP~QK
zB*X?<i720Ds)qSPwuTNRwsh27vs=a6cEno&<^Zy5;TLEs^W}W4AKtEWn0472(F3E%
z%}5y7#%d7sv`fN|2~E>_3i!`<8TbOqSzOqD{B?ll$Nlocire1{%cV@Q=^OWfxdQh4
zmt!ZF>n3(^RpH(#*FlKV+`TIWVV4JQ&Blp!VnC-pM698Q(C0Py<m{De*ImAB^}015
z>Kt`uuA^r&e$MFbA$_NXd<GYN%%LjeD<RK>I)jpa5tJ;bKc7ro38<&p%?7eA=X76=
zbaxhZO}qWd(6p!+L#&5txHSMit=FL)D|D4OTT4dfKI47f)<HJ!d-s)$in+5<EK7n9
zWg4>=Kwn9oxqfJLx&PtjGXN>H1J&x!p38*^U5_Mn*3DI1x&ar8#0As|(6vsl<LiH!
zJKI0sGE9s;xNY-K@%J1EbrUEhj>)=$H?a>ZlL5@?^m2>th7M?F&SHrPznAxh&_+H1
zl^!&{zq*&KZg#spqL<bATo*0|G7#l}?=)Sfo<1D#|D9gnLw^YM;AAam4vSEvim`g6
zPEav2S*_ctQu`0A`OxKS*DYDMOltm0xixSYH1NT}V@VoiVFNI#oV^yBtz3TIva`x9
zAvq%Cz+w-a2|(syIwpqBTJsu%la2_SEcf2nDFX@xR1ETEyc!`K9g`mM!abRS5o=xs
zZ)|He2vn#njd>{Gvl5jv&%ON&B5yU2$94%<nt+2E#9WbD8U)I<q;n8e0t#aKvpD32
z=}ydevL@XDIl?RqF$^o%%Tb?fb9WT$WYIis3I>HN;8PLP)k+;9jbK>Aq=kbmyi#jn
z*U8^m3oFSj4cm8ojpBU%ZlN%ID%HB;CaO~F`qC!LNPCGpO2eJU{9)Qf>c?Gu$+j2C
zCl7eBAN}dZSnN}ujwPo5wBRNF{5?*K*VMmtcwuh(!)rp@_D-_xh2~jYEz4(OUccD1
zd=176tdtB0M`uV0v)WV3QL!QiVPtQscgVv#Sk_iD+2LF7IE)cqZ(wp%s162U4$G$2
zV9ZM)lPLl(X8SL4f+907!pysMH}cf4{W23da!BFD8cOuCL{@;RT&qNk#4weVJES&j
zebb{V`bcvUVjX27&i+iK5@HrIc{Y9ef}G)6U8Xu}`ULX2S}JAPX;$@%JAUw9Xuo!1
zeg1Xk;rqYnUl?8VGqj++K3U+jbJclBZUh^)Pwo4NbiEEZ-@Q8&#bq{cm}vuoNvzpq
zq9oVEm)R;WV0CiT?*QvCl*XN>99IAEZn#1)e888H;VfbSQ*SnMV@V%k#L<lxBuXI^
z6C|#d0!f~qrC|T{iE=yn|D8~lMYZW#f`#yW=uz~l>Y_N!7J^gsY}#)&AReIQ`z+cx
z&=KMIfR)u3o_Ah(bUWqI05eitP2P4_1+0C{Nus~R4J-hio);8rl&Rmw2j>N`D;2W!
zW75Dn6iFQ7E4XsBn2n6kOWeE}=Zxf(sIHjB0VP-6+Tmk5mV)uPWXNENs@&})R<Sr=
ztqG7&u}|EgRA~*%AHmE)Pw%R@D$9z3Wi38xi9egsh`-}>+G8<_y90)<Vzq9?#^2r^
zs#s*JfogvCXvi>s2>bQoH{H#0$Ji&9KkO(G-ZKueFu?*H;=MUSZx}O+@%P+`{7f4T
zOO;6E!S0~9`?sz%d8olY)2IxKIf<;17F3mCnLqDU%_nvA%hVZLnXBTg1A0?gU9-p1
zOv$>X__jdK5Lk*eU{+`Om26ffeQjej$0jMEsI6Wb$!UEGnq$jaRJE`?5s(&SisbGP
zWy*)3BQMeY?ef@!;>bv6-mHsKg*vOZ7@wBLR>FCPE%SkLl?utsgO-DJ$yUDTlaqtE
z%MoENYcC=Ut|@uq2R}1mIS`A`X#`P2QKO$0-_*M`mQ!Ur3izQp(;b^5BfD?Isdm#i
zSj~WgVsFzj=U~Y~lu{$0Q+#ZQt#3>moVr{%#|{=s%bX=T$R%Ba#_<;4F$-3<PAxyV
zGZXkpCX!GFR6|t~T?LgoA!DGtwRElYDA2DUfS6QY0MTlS0OFMT7wC22?}#xZYBRZV
zE+@A6r^JR$Q;wG4!wP}PhpNdJB|YGmIhGpgdR*2uhk`|>63fUriM`7<dBj8{dSpsa
zt;V6uIfPX!l~M=OQoC;v5*2QI*Q_^|jiKF}v8%eRT~TFn1&8wNV=!$pX6bae6W#}x
z$pdfjg8N8RF@FAc!wxS9Awp7-m_gZO?Iq0#%Ds8sk(eTqJyd5jt1M(E*YQ#UawK{v
zg;2|V?E@o5R$W;Bgxv+psJu|ckgGew3>lORQF!1FkrdJ8-tbvj#z|3DMWnlM+a9BV
zr}l)Ej}IsqAQ?kDl}3hl?ZtnVDbuklU87u4j~0o+DVMXKj2j!KUCY(7QKaqy73;?e
zp4z(f>?>4Jz-#5mz2ZYqbqWPo5g^yBUfak~GCz`!<wb{>`}LZxx`w=<0AD_y9kwS2
z1`~yM#1lFQAfgSq6&3Zdh3$*~@|188^LSxSacC1yv@D_IUrpz*H#?$pzy#P<ELe>|
zT3YW@3im>eLGF(eD%d_?B5s_I5~z(Wyc$d7-odVEmJ>FCUdySu{-t9FT+t1)Cdos+
zCCe$dP<Fk`v9eSv!l%hHv|?{+AFNkIICX>AnXDkA7=LYIzBkNsK`=wxXo+_?z-NcV
z5{G?}ZMJcHQVfZY=UR+Ink(Uphig?1MvkP6@FroLsrS_n^Q*)<G4aHt5&R9~5JWS0
zSU4?Mg`?DDQ`6g$3Y%y{hY!Z5!#3Px^}FUO&1<oWMyi`lL8x>{eWB8VFYbS?Wl`;1
z%X~zOwY1|~9O~hKQ41+BLJE+g@%Q)FKnh-Bs+13hYz@=N5*yW}wWd@k@(p9)?mg$M
zW&QEPjYwSL(7Q$96P>ccv#}VwlH;~u+9-RV1*K1AU|2E0ltJbVs_aT}hOOR&!#;tD
z1U?lkGNh1?HUbIThBOmCuxvdIn32;pldXEVFW~j0xf0f(vKn0xfK&x^RjYFb=DSWh
z_x$~WOON0ZMR`}HN69P|gUnJ3V4B!shb~pfgm#z<E+#(x-cULigeHzd0I+;(vJ4TT
zaaG6&TfK=lHiC5w$+7&(seZYwMc@x*+E328g4dLXrqGuP4kD;y(BZ4In)ECs;@K;>
zeN0;wSgN1+^7A;HNRu7=adzqg9A9|I6Z%HL4i5PuA;v^n3pL`4U2z0XE=QH>VKpI6
ztbn-TLRsKo%9MzV8Y$QeDF5HNGOb&Qb_g8$|Mde1F`Eqs$A0MoJa^7ZmW6*6GX%0&
zT6<2izC1}i?w9LRl@qr0DSi8`WK9=;d}JkS`u3E1mF$o|b}H5ila`#IyCBd?7kf=V
zdmb&(CwNQD>S1vd=1tH@g;_>UE_o9&FVxasFL6#YYLf5P8kehPF~0kHMS-{S+%w4U
z{>h`L@b5cR6~1#@pu*Ttjw+bJ#}xHIiD$l6Q-?*|Pujb!>BJ+1_HySGC^0l_YxO2w
zSq?O=6sQ{?j#Xch+KKBc{x%AyMt!4e9Q!j867r&^V&h|%DC*|LA9Tw#0>hSVjlX+U
z)xsg>CCV+OI^skx;XTWgXO0Z?Sw&sr^Y2Hg@?;bytw6RDpI4Qsm(F&kbUp1<`7cQY
zHnN12WW)mlZ~H!9qX(!*VhU3nbw9LDCpe6tQSn*@jc8d1qLu^0%A>WoL&OpbXyw5-
zO`>tcawDrp;)r5={cyBM0@KG-NEm_#y6^xG=1_H}LAtH^Q?eL@eR~QmtmN)6F;ASK
z5nwEX6<Xu4qA0ev6V#GncVj9p(pLX=P6j58<?ewVE=dDK|Dl`A*kaqIpnMKK!!q(I
z?EP(tTg-Be6&9dRQ+IVaWz(bN`*`CLDj3TEg<apy3~`pYxuJ6H+*aN-ufyhg<G10;
z-N~m?y5nT>SrWQ#+a_ftDId8XOd4g+gH9er?OJe-nKF{hese7~&7lD^e|Wa$%fm}b
zL8D*?+DiEhtRH0A>6~AKvA{#^dOAH!+Q)33kAr;{<AWy;QMa@`f?IEh39eOc-IjRT
zMeegtf%TZcg)wivi{PVH^w(O#2Cn5Lj{7fck=3b^2UMSW0kH*3gUR(R4NiYnEDe%v
zTN+Xyc(Lv}C(@0?<ej7&d3KME*xisDjAUvPCf}*3nV0z77ZgqN64U<&d8iR}EJ(8|
zS;Sh(R$<y!7V5TZ<_-TjRu&V1;Xv$?PAFn0#l%-XJ3@qrxq?8c5_=zD<^MP~oud_u
zY5L%OM7xfY66NCFq+@)AdtzKHZF$Fel83DyCmu4KtCg&X+U<lBZ($cFfd5v`u+fbP
zlq;&BJT4E13NoWPmLcOokgjQ<2lZ@R(f)=gzY@EZH4u;;E@7c+uv5ib5@>sgqkmbh
zwSrV7a6lPB8{XEcGzQgtbRaSbV1mi4Beh|jMYrgnGeuw2lTeXOI@T#ontlVX+EI93
zc-4hUH3SxSDYxBhpW3o!#QdF+>kYg*RnpGM8hDMFbo!#B{pBQT0d<ldDJo++Fq>Ue
z7;ufIkS->6d`kxX+Y--xSR6=au_@jZCL^mM)&)jiBAGQvxfvD-@Ktv+-ZZq92Lj2~
zBp+{mP)m|o$=hl4lDKXtIZO3`iwnC>y!c+c@d_&<+6o2lqW^U^*6%en+==P_;6@G?
zgAHpVKdseFCmJs{_}(5#S)Lve*+;6VrjUv+6QS?4K8FrV8JT_-Ic1{pnXGbG&pyrS
zEZlokKxmQ^%I+Xgs7xDaya5OA8Do@o(orXBG$-7OCA07du;v6uZh>^!ozk{lX*%bV
z!HPoXh0pv{4Do?i@)`~hfR~K<uzc7SU-qT0yo-&Mb9(6(WR9qq=S~BLsVwfL%QkX&
z-60+Ntde(YhrfQ6xH(41wtW^=kjtGLIV%<@+BQ3$B_~K_m!{A-+PetOIN)JrRw>rY
z_L5mwIRyG{42MT{Rb(7vRkmq%w9*d<!*efg7-utvjr;!yNr)lB(xT-<%UIiD;}<_H
zjl|KrbMo>II%c5cqlWN!<F>}%e7G!Ds6*I)sT{i4iB*2mZh&&t2OD#V@*=St%eeWC
zJNaJjl<-m=HUD{NeL>E-f7;Ld=N~KAB&#lb8%s*nRfeM#?rgg4t_od&Gs*&Wc8XSC
z?2jw)l^3cvpPgdk&^n0}Q6LcKO7SI1fr^A8hNEIh`-5!dWPgZ{hWmDRwuryH_-DR^
zQJc7aP}vT+=`JPfO}LtI#o@;2L2@0hvH0=tmcTQ4>?V{W8+>($512Ubzk{^5BZ6;b
zABmG7mz>joSEfa1G2Zb^?YYATkvliU9T`B?|NO$xl?-(u)_XlxrV9ozQ^pUBiksau
zItNh-u>db8N%I-Y!FFaM=jTy_#d#z#pG!<Ep~z12MY#aVL<MUH6T6FV9ZT&--S~B_
zjf1FV#z*wA3J3W<X5xK6jvN|s$rK%|bHsvaEcLK5YKHf8D_6=>+M3lNI6Znc%WHul
z-dr^U6K=d0k!?d^op3E+yMY%kU|q4xFYKUYJ1@E9Qeo`yE6uY`eShbSt53uQ+Twn?
zM2LpM!@|Tp%PcXy<5!IFp=igO{7FAuiHi3U<Y%%<_<4~^_=~U-UX&k)(+@R^;kU|S
zcrZTQHbF`H{Y{2r;2E+|Ei*a{ysZs)9tOpYwF>Bj&x*1D>ocuC5VxGs0mpg*EZlmR
z(I&qr#OkKwq@n5yI+rfD_-kae4ulA{8Lg0k*Lj6D$MJS7x~a?1of2C+`EItqggxr%
z+P8O&MNdxat5tM`MKvQ-O{<J*eCkN(z@Rj5&NoYWaiDU9qf^CqQyz)!-0+jUJipG5
z^;N)CX0oy_gb$`Hq^hSv_Br}mL<SzwIZ+l=vm?S+jfi0xr5QrES&Hk6_~CkfbPYj|
z?sz*Oa_P)o9i%qCc1ks=SnF9r=y3Q|IO+*N%mh%H(U*H^m_MNdk?b^m;@;`Xe8iyx
zb_ok!igZ8|!!vsjw^SD%G3O!Xb{1XfSZsXmLx6#pzXderx2nV^HXFQ<OYt|9n*?j%
za7uQnd`#0LW>5zddm4Cqi||VTLB+(n6>_J5U0PNOfE3FGtl;`EcEwV+iFOBY{?TvX
z%`i3|`T!NKT2Syo=uT(0e6{tQX3+i1$`w$d3*;b*N45&!leYy1@!XX9;<<G}(yG1w
zq}9k09y7c)t?K9+m!c!+v!euOsMCp4x3dDsOvIOo`aiSB=rY_I%QmUn>b-BFyKE=~
z3Ml{lTp*|KOR@ObuNI2&S7xdxp?)S}3~}2mVT5Av<cb4NyrFU$n#ryizv?{@KC&I#
z8k;oo3XhsL<b<&7fnx<TMKA?EttMZorkwSxz?|4G5hu*!U;3^Rn1!OcfD0|`HXzOn
zycdhRN?DQ4Fo`df_<m(AC}kH&9f*5JPO{rTquk<(R8v_MtHqo|V&*xbs2Hq$#r5ng
z=^TD1jJ(^9ZhnJBwgbGx1-dxeS0lq9p+zj|B3c#MFC205%XxS^rZ$Z=+vo?88ajSJ
z(0L(r3x`rF1uB8~$D}KlE39NgTnx<a1Lmt-Sf?!ZCiFe6`9Xj!25VOCRV&XbHtw21
zJD?`Nds*+M<D6=doaV~>)R5uDZoR&Y*`^zvm9EH;$SNUO9<J~>qtp|~t={)^2LcQ2
zQnHcO8<%>C%{^t_KMFotFVpEIF6dE9(WA=6+7=T_XYkw&-7Y-g%g3=h+4ywnT3b{m
zJR#W?xn0j^2}im@m-rAlMk&fi#mE%jsF(ZDB@F>M^yY1Tu7sU+KT|oDPi|L@(3Nd)
z%&x;KVg3)FXRCzy$|?c(Db?h`vOWzHr&U{(xNQh<4b*K`u6Tg)b1+etT?^?@&Q;vm
zGU|e0`|<n~b_KmHo*KqFba6CW9KI$n#>39wg4ZY8+UH%`;?H))!TaDObPGwxKh1CJ
zEZlo^j2+geMs1hkEA#<tM4_xKZKiQMg9H8ml$ZjCr&F;<T26Mn_&U*Zdgg*&P%f8F
zj5kl?U7YAoo7Krb&SbKAr-zz5ZW@-B@)MU)k?GbUQf+2OnDF#9u!;Vf<<Iex@W@RY
zrfg)ekz9Yq445_1a?UUQg=o1b{TfW0bqd^v-~DDj8hj)guE*!l@umK0r};B4F=x(F
zVwA(`i%~AS?*MX6(JSCQ?dPj1L>3arC<DUUW(pC&{H`hNA_)=$m?-4jVXCR#ewrNP
z;j}CBhKmB&sW#w}k8(_2)DTMM62sV0c9wLf&fp>Yi}6?#g0pZ*NN|SiNMSuuz}gZ4
zFy)M*Hy~o&wt@1KoJ-7UExy{tPE~q*2jEn{&A<9;u^#|(Y!|)Kv~sC?@bn%H8leV0
zN?9f#W1d}A0Zp#qLjb0POrUxmz-cqgY9&EjrMa@%NVJe#cdA;AqRjRBVL9Ub+JxB9
z02%j_!XmJC2p<7tM>}w|O?spQ+C>b_QyA^#xT_V|?I_*i?qQ@`+E6^OUNP{C^eU9p
z*1HY-Dy3rR{t%yCzrn8EsD2UisfN%W@nTqWDb{R`>Zy2FYN|#3H5-JbzW5mYX{T?T
zeDW-=S1JyklwRy}T{ira<#?F4X;C|v^L|p7Kpkpw$yC`y=M8n}ctLGmakHi4p%LtB
zb}-W8ItpYhK#NO5S2O7CS=3=NYD$sIKG^*)r_rg}O;VHmX4XZg0;Y%82d3St<$`bC
zK2#|HWfg&iM3ZopeJ}i}Cbq1$u%@8LXA?LnP0|rmv#BEA@mJ^qXTK$OL)Xf{da<1%
zuo|DTj-d555?h!6M8_&Z)uIt&Jrkl$+el&D>318ObV?_0U}6V<#cfG+F0=+5@-;kk
zx<-+~+v<}+cAJoa+=(~nyEc|A_Lo{F-P5}g1K2GMOCRk_R$t5q&AiyBPZRA{Ey0WW
zLM?%){3Xo;1KYm?<Gj3lN#S1n?zG_s>&rJiLACDq|3oThFWQZTnvX1^LQOAz)H+&m
z`8|VI{ThP)Z(le(?ba*Tmt>PB{5pz7-)n_c!*RXzLTkYv|5@{=H}MPqvU^cs`!OVf
zWuPy+^-aKP_B9Phty3;X_Zo&SqE_Rat;xwl-f_h4WTC*+83Mb{OnG_v+3foO>95_g
ztmde7lE=<qU&A<44?ul)eGQm?@8N>UDvw2M<u#o4#5j*f=HVpkW4n{&zJP&e2MlDz
z&;YxX$9QhuI1fkR;Ss;vjc2C<KYK)de%3re#ySh?h;?N5Z?CWW{3l0n<7X~rU%Myr
zT)1Als3eji+_N_vcTckF_MIxvekOYM<=fuSR*cdabkgt~dix!3ToQ8k$3J)P>X_=g
zU3bxw>^2<l#2aI=)Vx^ZPaZ3H@r=j~dJWA#9oNM-L1#bg?_OBgh1mI|*4xYKH%H=m
z;~|6NJRg~thjgC1JK0v)emv>+Qb5xu#icSMaWr<*gX0|CcTP`yI0st06Zp&Svm6a4
z{`>K94v(U<tsmWeN?{jM*%hd=td>n>XE9)B<P%?qg{bQ_JTZ5i$AG1;{(5&Z32KQk
zKX9@(&ybs}b~DULUc1>a`;dc>m)@lHk0W+c5I+Lr(5f+2<|UFF4nh{~KWkS#foeIb
zLb8gMsNwsp7RJ5!AYivQY497PvI*6XA7L1egGS{fkAp^4ICaOqTIJ%;w7&%z>`ffL
zV@wsp8=J=0HgAqa!`kMQ(bcdz*zre*bm-RG!PCC-77~m%(YkW?g3%ci6x>9jl@ZKW
z)XaE^-@fZ_z$)*M$=B>owvRCfr&^d;otyR=zM6Uq$#ee=<u}K}a%xmqVrAW4{MN<e
z3>(Fu{_UPI0iJG?j6J(-oR0^fuv21VAv@LYR%2E)y+!ec151iOzlG%CO<H}~n5Zbr
zNki-y3-7)7HHp6?r@V=GY#eoFXkoN7+%tIE32z~h{`DDaKD&F-=o-WL8dVLoj=Pp+
z9W(nMNDSVj1>TsJQG1@fmNOnNa3(^$uwS~;YwH=K&x`%v`wk*DdXr-M*z6i#hZOj>
zAZ<bK8?VqdW4HhOEyR<*9<QI=4xv*}EHN6R`T4!-{7lo^uRREP?Hw}b7c9IVjdK`*
zxYkB?^tvH?#X-oZk&*E3lg4IXkr>GC;SQ-@7hS^Lu<`o`F-yHkciluwpD{TY+*=e*
z(BP?!*v&sX2zcmCeB^H0R5~Uo##>d`C5!Q%WT(cfQ(o-Ucr9=2#V`2xgMf2mbJjdV
zG31w*uP*H5JmvRvk67?9p7=N*>*t9N&i3;q+m%b?N34XnKRM3&8Z3S8H!4flNS5-e
zDaSSWucpb1)Ht*TyGJQJVK;$}ug4iL`FdP15|7}FthwWfv3+7LCdL*j%oShLS8s(B
zo&Y)+Gad^=ao1W2t8DLWTs{99>iP2W3nicF+xbT2^ms%tg7!j0u&}T_a82TCmB*`i
z-(1ywI7j6NTy;MvRabn`+&I7Abbg<r>b1BEdn6=Y`SLiM_kq1v?Zj+@dj99gIuGc)
zD9`_#Quq0vz3{KT?stjvKU*4p_?0`$M%7`Sb>17=3OuHRCwZ(4p6xB}%|FJzZvdt<
zo2tW;-Vq(`7a|lEn=+ENmF8_X?+L!hJ=^a!Uizy6uc4!Tc*VA_ed>(Z;h79w@`Ybv
zZzS7aUIE%P;h{D33UTkB>Zf=3)g@p>Vb_u0j171v#$x4UYtoxMJbz{Q3++|$Eej4I
z&c7S9<yWQQ`LD-jE{;te?x0Ki8Ee{}2hKFL{+QlidNuwNI6isuQ{^PTUhV8y3@>jc
zjxQ7UuHvOjXQ^kDpZONG9p`6#{M|iVru)x1bK8-*^d$$DosRH!@W|pgYxkYSlU{nF
z+^(>=16jNZZxv@3kb8}{Jw49Xznwe|-8d2C!4K-SqhC`lXhQE6y`#x%xbZ*81N?)z
zFYmC=-}LhG`FNcT`l5E>i|B4&(yx4qfAu$hFQuH#irdH4?afoC$;W-SJRi*)WYEs=
zGq_kfvlf2QFj@K2kB&3_@BY)9{Dps0gw+udmU`JbL=um8j*IN?Afh|6<ptbb;`iEc
zP%~UZ%Nify-+LmWYrJP*Efz)j^nG&Tn}NK>&A<LT$j&=-)v+PkRWv}d@k?@}lwR@g
z2cedEhn_LHyinm(2a_`1IjRYtwFEB|#V;O+e$TMi@ZkJ^BBpthKdFZ%JC8?z>}#HA
zs<pp*-D~*7Xa0#MIx+*+|EPS5!hre60Qps$oCj5tkA3xlx4`80nOTS2GE`oqFlzy6
zOYn7>Ax7cXWe#589h7{U@mPpY3nSiK$-Kl*J_s4K?+pFv`Z68eWzo^R2tU<pyPd(+
z{o^eCJBVodePt@WVj`L!i7#qgQ0>JAy2mA@aIow4a#Ak;@lGtKgI#0=EB_^!4G3LP
zIcQG(M_l^v?@w>a%}>3&JUPFxed;%31CiOEiL+n6?Tww8QLgdw8h-i1zXnIV!zW$`
zlr0n+D0}zreWT7D4!MD17+V^8<~&}<2Fk0k*kj*qxPHqwkL$!P;=gR%*70n^Paa(n
zn-F`~@I{Y3y?RINonOB~>|J#ACEJHr)6>JIKNEUdbDv{)IlZeqrFY*?Pv5@c{?OA?
zpZoQxee^_Z2e`?$;m%|JFzq7sDZJY@ym;!gmaXd6fzuC97v`ovye9P2fu{?4?{7ON
z^fU`kYi>RacMuKgQ>3B&+*daA%co7LoDC0aUA0>C4!2tOxV{#PeQRdpbL`*$2mC{2
A5dZ)H

diff --git a/readline/doc/history.html b/readline/doc/history.html
new file mode 100644
--- /dev/null
+++ b/readline/doc/history.html
@@ -0,0 +1,1062 @@
+<HTML>
+<HEAD>
+<!-- This HTML file has been created by texi2html 1.51
+     from /usr/homes/chet/src/bash/readline-src/doc/hist.texinfo on 16 April 1997 -->
+
+<TITLE>GNU History Library</TITLE>
+</HEAD>
+<BODY>
+<H1>GNU History Library</H1>
+<H2>Edition 2.1, for <CODE>History Library</CODE> Version 2.1.</H2>
+<H2>March 1996</H2>
+<ADDRESS>Brian Fox, Free Software Foundation</ADDRESS>
+<ADDRESS>Chet Ramey, Case Western Reserve University</ADDRESS>
+<P>
+<P><HR><P>
+
+<P>
+This document describes the GNU History library, a programming tool that
+provides a consistent user interface for recalling lines of previously
+typed input.
+
+</P>
+<P>
+Published by the Free Software Foundation <BR>
+675 Massachusetts Avenue, <BR>
+Cambridge, MA 02139 USA
+
+</P>
+<P>
+Permission is granted to make and distribute verbatim copies of
+this manual provided the copyright notice and this permission notice
+are preserved on all copies.
+
+</P>
+<P>
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided that the entire
+resulting derived work is distributed under the terms of a permission
+notice identical to this one.
+
+</P>
+<P>
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions,
+except that this permission notice may be stated in a translation approved
+by the Foundation.
+
+</P>
+<P>
+Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+
+</P>
+
+
+
+<H1><A NAME="SEC1" HREF="history_toc.html#TOC1">Using History Interactively</A></H1>
+
+<P>
+This chapter describes how to use the GNU History Library interactively,
+from a user's standpoint.  It should be considered a user's guide.  For
+information on using the GNU History Library in your own programs,
+see section <A HREF="history.html#SEC6">Programming with GNU History</A>.
+
+</P>
+
+
+
+<H2><A NAME="SEC2" HREF="history_toc.html#TOC2">Interactive History Expansion</A></H2>
+<P>
+<A NAME="IDX1"></A>
+
+</P>
+<P>
+The History library provides a history expansion feature that is similar
+to the history expansion provided by <CODE>csh</CODE>.  This section
+describes the syntax used to manipulate the history information.
+
+</P>
+<P>
+History expansions introduce words from the history list into
+the input stream, making it easy to repeat commands, insert the
+arguments to a previous command into the current input line, or
+fix errors in previous commands quickly.
+
+</P>
+<P>
+History expansion takes place in two parts.  The first is to determine
+which line from the previous history should be used during substitution.
+The second is to select portions of that line for inclusion into the
+current one.  The line selected from the previous history is called the
+<STRONG>event</STRONG>, and the portions of that line that are acted upon are
+called <STRONG>words</STRONG>.  Various <STRONG>modifiers</STRONG> are available to manipulate
+the selected words.  The line is broken into words in the same fashion
+that Bash does, so that several English (or Unix) words
+surrounded by quotes are considered as one word.
+History expansions are introduced by the appearance of the
+history expansion character, which is <SAMP>`!'</SAMP> by default.
+
+</P>
+
+
+
+<H3><A NAME="SEC3" HREF="history_toc.html#TOC3">Event Designators</A></H3>
+<P>
+<A NAME="IDX2"></A>
+
+</P>
+<P>
+An event designator is a reference to a command line entry in the
+history list.
+<A NAME="IDX3"></A>
+
+</P>
+<DL COMPACT>
+
+<DT><CODE>!</CODE>
+<DD>
+Start a history substitution, except when followed by a space, tab,
+the end of the line, <KBD>=</KBD> or <KBD>(</KBD>.
+
+<DT><CODE>!<VAR>n</VAR></CODE>
+<DD>
+Refer to command line <VAR>n</VAR>.
+
+<DT><CODE>!-<VAR>n</VAR></CODE>
+<DD>
+Refer to the command <VAR>n</VAR> lines back.
+
+<DT><CODE>!!</CODE>
+<DD>
+Refer to the previous command.  This is a synonym for <SAMP>`!-1'</SAMP>.
+
+<DT><CODE>!<VAR>string</VAR></CODE>
+<DD>
+Refer to the most recent command starting with <VAR>string</VAR>.
+
+<DT><CODE>!?<VAR>string</VAR>[?]</CODE>
+<DD>
+Refer to the most recent command containing <VAR>string</VAR>.  The trailing
+<SAMP>`?'</SAMP> may be omitted if the <VAR>string</VAR> is followed immediately by
+a newline.
+
+<DT><CODE>^<VAR>string1</VAR>^<VAR>string2</VAR>^</CODE>
+<DD>
+Quick Substitution.  Repeat the last command, replacing <VAR>string1</VAR>
+with <VAR>string2</VAR>.  Equivalent to
+<CODE>!!:s/<VAR>string1</VAR>/<VAR>string2</VAR>/</CODE>.
+
+<DT><CODE>!#</CODE>
+<DD>
+The entire command line typed so far.
+
+</DL>
+
+
+
+<H3><A NAME="SEC4" HREF="history_toc.html#TOC4">Word Designators</A></H3>
+
+<P>
+Word designators are used to select desired words from the event.
+A <SAMP>`:'</SAMP> separates the event specification from the word designator.  It
+can be omitted if the word designator begins with a <SAMP>`^'</SAMP>, <SAMP>`$'</SAMP>,
+<SAMP>`*'</SAMP>, <SAMP>`-'</SAMP>, or <SAMP>`%'</SAMP>.  Words are numbered from the beginning
+of the line, with the first word being denoted by 0 (zero).  Words are
+inserted into the current line separated by single spaces.
+
+</P>
+<DL COMPACT>
+
+<DT><CODE>0 (zero)</CODE>
+<DD>
+The <CODE>0</CODE>th word.  For many applications, this is the command word.
+
+<DT><CODE><VAR>n</VAR></CODE>
+<DD>
+The <VAR>n</VAR>th word.
+
+<DT><CODE>^</CODE>
+<DD>
+The first argument; that is, word 1.
+
+<DT><CODE>$</CODE>
+<DD>
+The last argument.
+
+<DT><CODE>%</CODE>
+<DD>
+The word matched by the most recent <SAMP>`?<VAR>string</VAR>?'</SAMP> search.
+
+<DT><CODE><VAR>x</VAR>-<VAR>y</VAR></CODE>
+<DD>
+A range of words; <SAMP>`-<VAR>y</VAR>'</SAMP> abbreviates <SAMP>`0-<VAR>y</VAR>'</SAMP>.
+
+<DT><CODE>*</CODE>
+<DD>
+All of the words, except the <CODE>0</CODE>th.  This is a synonym for <SAMP>`1-$'</SAMP>.
+It is not an error to use <SAMP>`*'</SAMP> if there is just one word in the event;
+the empty string is returned in that case.
+
+<DT><CODE><VAR>x</VAR>*</CODE>
+<DD>
+Abbreviates <SAMP>`<VAR>x</VAR>-$'</SAMP>
+
+<DT><CODE><VAR>x</VAR>-</CODE>
+<DD>
+Abbreviates <SAMP>`<VAR>x</VAR>-$'</SAMP> like <SAMP>`<VAR>x</VAR>*'</SAMP>, but omits the last word.
+
+</DL>
+
+<P>
+If a word designator is supplied without an event specification, the
+previous command is used as the event.
+
+</P>
+
+
+<H3><A NAME="SEC5" HREF="history_toc.html#TOC5">Modifiers</A></H3>
+
+<P>
+After the optional word designator, you can add a sequence of one or more
+of the following modifiers, each preceded by a <SAMP>`:'</SAMP>.
+
+</P>
+<DL COMPACT>
+
+<DT><CODE>h</CODE>
+<DD>
+Remove a trailing pathname component, leaving only the head.
+
+<DT><CODE>t</CODE>
+<DD>
+Remove all leading  pathname  components, leaving the tail.
+
+<DT><CODE>r</CODE>
+<DD>
+Remove a trailing suffix of the form <SAMP>`.<VAR>suffix</VAR>'</SAMP>, leaving
+the basename.
+
+<DT><CODE>e</CODE>
+<DD>
+Remove all but the trailing suffix.
+
+<DT><CODE>p</CODE>
+<DD>
+Print the new command but do not execute it.
+
+<DT><CODE>s/<VAR>old</VAR>/<VAR>new</VAR>/</CODE>
+<DD>
+Substitute <VAR>new</VAR> for the first occurrence of <VAR>old</VAR> in the
+event line.  Any delimiter may be used in place of <SAMP>`/'</SAMP>.
+The delimiter may be quoted in <VAR>old</VAR> and <VAR>new</VAR>
+with a single backslash.  If <SAMP>`&#38;'</SAMP> appears in <VAR>new</VAR>,
+it is replaced by <VAR>old</VAR>.  A single backslash will quote
+the <SAMP>`&#38;'</SAMP>.  The final delimiter is optional if it is the last
+character on the input line.
+
+<DT><CODE>&#38;</CODE>
+<DD>
+Repeat the previous substitution.
+
+<DT><CODE>g</CODE>
+<DD>
+Cause changes to be applied over the entire event line.  Used in
+conjunction with <SAMP>`s'</SAMP>, as in <CODE>gs/<VAR>old</VAR>/<VAR>new</VAR>/</CODE>,
+or with <SAMP>`&#38;'</SAMP>.
+
+</DL>
+
+
+
+<H1><A NAME="SEC6" HREF="history_toc.html#TOC6">Programming with GNU History</A></H1>
+
+<P>
+This chapter describes how to interface programs that you write
+with the GNU History Library.
+It should be considered a technical guide.
+For information on the interactive use of GNU History, see section <A HREF="history.html#SEC1">Using History Interactively</A>.
+
+</P>
+
+
+
+<H2><A NAME="SEC7" HREF="history_toc.html#TOC7">Introduction to History</A></H2>
+
+<P>
+Many programs read input from the user a line at a time.  The GNU History
+library is able to keep track of those lines, associate arbitrary data with
+each line, and utilize information from previous lines in composing new
+ones.
+
+</P>
+<P>
+The programmer using the History library has available functions
+for remembering lines on a history list, associating arbitrary data
+with a line, removing lines from the list, searching through the list
+for a line containing an arbitrary text string, and referencing any line
+in the list directly.  In addition, a history <STRONG>expansion</STRONG> function
+is available which provides for a consistent user interface across
+different programs.
+
+</P>
+<P>
+The user using programs written with the History library has the
+benefit of a consistent user interface with a set of well-known
+commands for manipulating the text of previous lines and using that text
+in new commands.  The basic history manipulation commands are similar to
+the history substitution provided by <CODE>csh</CODE>.
+
+</P>
+<P>
+If the programmer desires, he can use the Readline library, which
+includes some history manipulation by default, and has the added
+advantage of command line editing.
+
+</P>
+
+
+<H2><A NAME="SEC8" HREF="history_toc.html#TOC8">History Storage</A></H2>
+
+<P>
+The history list is an array of history entries.  A history entry is
+declared as follows:
+
+</P>
+
+<PRE>
+typedef struct _hist_entry {
+  char *line;
+  char *data;
+} HIST_ENTRY;
+</PRE>
+
+<P>
+The history list itself might therefore be declared as
+
+</P>
+
+<PRE>
+HIST_ENTRY **the_history_list;
+</PRE>
+
+<P>
+The state of the History library is encapsulated into a single structure:
+
+</P>
+
+<PRE>
+/* A structure used to pass the current state of the history stuff around. */
+typedef struct _hist_state {
+  HIST_ENTRY **entries;         /* Pointer to the entries themselves. */
+  int offset;                   /* The location pointer within this array. */
+  int length;                   /* Number of elements within this array. */
+  int size;                     /* Number of slots allocated to this array. */
+  int flags;
+} HISTORY_STATE;
+</PRE>
+
+<P>
+If the flags member includes <CODE>HS_STIFLED</CODE>, the history has been
+stifled.
+
+</P>
+
+
+<H2><A NAME="SEC9" HREF="history_toc.html#TOC9">History Functions</A></H2>
+
+<P>
+This section describes the calling sequence for the various functions
+present in GNU History.
+
+</P>
+
+
+
+<H3><A NAME="SEC10" HREF="history_toc.html#TOC10">Initializing History and State Management</A></H3>
+
+<P>
+This section describes functions used to initialize and manage
+the state of the History library when you want to use the history
+functions in your program.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>using_history</B> <I>()</I>
+<DD><A NAME="IDX4"></A>
+Begin a session in which the history functions might be used.  This
+initializes the interactive variables.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> HISTORY_STATE * <B>history_get_history_state</B> <I>()</I>
+<DD><A NAME="IDX5"></A>
+Return a structure describing the current state of the input history.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>history_set_history_state</B> <I>(HISTORY_STATE *state)</I>
+<DD><A NAME="IDX6"></A>
+Set the state of the history list according to <VAR>state</VAR>.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC11" HREF="history_toc.html#TOC11">History List Management</A></H3>
+
+<P>
+These functions manage individual entries on the history list, or set
+parameters managing the list itself.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>add_history</B> <I>(char *string)</I>
+<DD><A NAME="IDX7"></A>
+Place <VAR>string</VAR> at the end of the history list.  The associated data
+field (if any) is set to <CODE>NULL</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> HIST_ENTRY * <B>remove_history</B> <I>(int which)</I>
+<DD><A NAME="IDX8"></A>
+Remove history entry at offset <VAR>which</VAR> from the history.  The
+removed element is returned so you can free the line, data,
+and containing structure.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> HIST_ENTRY * <B>replace_history_entry</B> <I>(int which, char *line, char *data)</I>
+<DD><A NAME="IDX9"></A>
+Make the history entry at offset <VAR>which</VAR> have <VAR>line</VAR> and <VAR>data</VAR>.
+This returns the old entry so you can dispose of the data.  In the case
+of an invalid <VAR>which</VAR>, a <CODE>NULL</CODE> pointer is returned.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>clear_history</B> <I>()</I>
+<DD><A NAME="IDX10"></A>
+Clear the history list by deleting all the entries.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>stifle_history</B> <I>(int max)</I>
+<DD><A NAME="IDX11"></A>
+Stifle the history list, remembering only the last <VAR>max</VAR> entries.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>unstifle_history</B> <I>()</I>
+<DD><A NAME="IDX12"></A>
+Stop stifling the history.  This returns the previous amount the
+history was stifled.  The value is positive if the history was
+stifled, negative if it wasn't.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>history_is_stifled</B> <I>()</I>
+<DD><A NAME="IDX13"></A>
+Returns non-zero if the history is stifled, zero if it is not.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC12" HREF="history_toc.html#TOC12">Information About the History List</A></H3>
+
+<P>
+These functions return information about the entire history list or
+individual list entries.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> HIST_ENTRY ** <B>history_list</B> <I>()</I>
+<DD><A NAME="IDX14"></A>
+Return a <CODE>NULL</CODE> terminated array of <CODE>HIST_ENTRY</CODE> which is the
+current input history.  Element 0 of this list is the beginning of time.
+If there is no history, return <CODE>NULL</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>where_history</B> <I>()</I>
+<DD><A NAME="IDX15"></A>
+Returns the offset of the current history element.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> HIST_ENTRY * <B>current_history</B> <I>()</I>
+<DD><A NAME="IDX16"></A>
+Return the history entry at the current position, as determined by
+<CODE>where_history ()</CODE>.  If there is no entry there, return a <CODE>NULL</CODE>
+pointer.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> HIST_ENTRY * <B>history_get</B> <I>(int offset)</I>
+<DD><A NAME="IDX17"></A>
+Return the history entry at position <VAR>offset</VAR>, starting from
+<CODE>history_base</CODE>.  If there is no entry there, or if <VAR>offset</VAR>
+is greater than the history length, return a <CODE>NULL</CODE> pointer.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>history_total_bytes</B> <I>()</I>
+<DD><A NAME="IDX18"></A>
+Return the number of bytes that the primary history entries are using.
+This function returns the sum of the lengths of all the lines in the
+history.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC13" HREF="history_toc.html#TOC13">Moving Around the History List</A></H3>
+
+<P>
+These functions allow the current index into the history list to be
+set or changed.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>history_set_pos</B> <I>(int pos)</I>
+<DD><A NAME="IDX19"></A>
+Set the position in the history list to <VAR>pos</VAR>, an absolute index
+into the list.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> HIST_ENTRY * <B>previous_history</B> <I>()</I>
+<DD><A NAME="IDX20"></A>
+Back up the current history offset to the previous history entry, and
+return a pointer to that entry.  If there is no previous entry, return
+a <CODE>NULL</CODE> pointer.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> HIST_ENTRY * <B>next_history</B> <I>()</I>
+<DD><A NAME="IDX21"></A>
+Move the current history offset forward to the next history entry, and
+return the a pointer to that entry.  If there is no next entry, return
+a <CODE>NULL</CODE> pointer.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC14" HREF="history_toc.html#TOC14">Searching the History List</A></H3>
+<P>
+<A NAME="IDX22"></A>
+
+</P>
+<P>
+These functions allow searching of the history list for entries containing
+a specific string.  Searching may be performed both forward and backward
+from the current history position.  The search may be <STRONG>anchored</STRONG>,
+meaning that the string must match at the beginning of the history entry.
+<A NAME="IDX23"></A>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>history_search</B> <I>(char *string, int direction)</I>
+<DD><A NAME="IDX24"></A>
+Search the history for <VAR>string</VAR>, starting at the current history
+offset.  If <VAR>direction</VAR> &#60; 0, then the search is through previous entries,
+else through subsequent.  If <VAR>string</VAR> is found, then
+the current history index is set to that history entry, and the value
+returned is the offset in the line of the entry where
+<VAR>string</VAR> was found.  Otherwise, nothing is changed, and a -1 is
+returned.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>history_search_prefix</B> <I>(char *string, int direction)</I>
+<DD><A NAME="IDX25"></A>
+Search the history for <VAR>string</VAR>, starting at the current history
+offset.  The search is anchored: matching lines must begin with
+<VAR>string</VAR>.  If <VAR>direction</VAR> &#60; 0, then the search is through previous
+entries, else through subsequent.  If <VAR>string</VAR> is found, then the
+current history index is set to that entry, and the return value is 0. 
+Otherwise, nothing is changed, and a -1 is returned. 
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>history_search_pos</B> <I>(char *string, int direction, int pos)</I>
+<DD><A NAME="IDX26"></A>
+Search for <VAR>string</VAR> in the history list, starting at <VAR>pos</VAR>, an
+absolute index into the list.  If <VAR>direction</VAR> is negative, the search
+proceeds backward from <VAR>pos</VAR>, otherwise forward.  Returns the absolute
+index of the history element where <VAR>string</VAR> was found, or -1 otherwise.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC15" HREF="history_toc.html#TOC15">Managing the History File</A></H3>
+
+<P>
+The History library can read the history from and write it to a file.
+This section documents the functions for managing a history file.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>read_history</B> <I>(char *filename)</I>
+<DD><A NAME="IDX27"></A>
+Add the contents of <VAR>filename</VAR> to the history list, a line at a
+time.  If <VAR>filename</VAR> is <CODE>NULL</CODE>, then read from
+<TT>`~/.history'</TT>.  Returns 0 if successful, or errno if not.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>read_history_range</B> <I>(char *filename, int from, int to)</I>
+<DD><A NAME="IDX28"></A>
+Read a range of lines from <VAR>filename</VAR>, adding them to the history list.
+Start reading at line <VAR>from</VAR> and end at <VAR>to</VAR>.  If
+<VAR>from</VAR> is zero, start at the beginning.  If <VAR>to</VAR> is less than
+<VAR>from</VAR>, then read until the end of the file.  If <VAR>filename</VAR> is
+<CODE>NULL</CODE>, then read from <TT>`~/.history'</TT>.  Returns 0 if successful,
+or <CODE>errno</CODE> if not.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>write_history</B> <I>(char *filename)</I>
+<DD><A NAME="IDX29"></A>
+Write the current history to <VAR>filename</VAR>, overwriting <VAR>filename</VAR>
+if necessary.  If <VAR>filename</VAR> is
+<CODE>NULL</CODE>, then write the history list to <TT>`~/.history'</TT>.  Values
+returned are as in <CODE>read_history ()</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>append_history</B> <I>(int nelements, char *filename)</I>
+<DD><A NAME="IDX30"></A>
+Append the last <VAR>nelements</VAR> of the history list to <VAR>filename</VAR>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>history_truncate_file</B> <I>(char *filename, int nlines)</I>
+<DD><A NAME="IDX31"></A>
+Truncate the history file <VAR>filename</VAR>, leaving only the last
+<VAR>nlines</VAR> lines.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC16" HREF="history_toc.html#TOC16">History Expansion</A></H3>
+
+<P>
+These functions implement <CODE>csh</CODE>-like history expansion.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>history_expand</B> <I>(char *string, char **output)</I>
+<DD><A NAME="IDX32"></A>
+Expand <VAR>string</VAR>, placing the result into <VAR>output</VAR>, a pointer
+to a string (see section <A HREF="history.html#SEC2">Interactive History Expansion</A>).  Returns:
+<DL COMPACT>
+
+<DT><CODE>0</CODE>
+<DD>
+If no expansions took place (or, if the only change in
+the text was the de-slashifying of the history expansion
+character);
+<DT><CODE>1</CODE>
+<DD>
+if expansions did take place;
+<DT><CODE>-1</CODE>
+<DD>
+if there was an error in expansion;
+<DT><CODE>2</CODE>
+<DD>
+if the returned line should only be displayed, but not executed,
+as with the <CODE>:p</CODE> modifier (see section <A HREF="history.html#SEC5">Modifiers</A>).
+</DL>
+
+<P>
+If an error ocurred in expansion, then <VAR>output</VAR> contains a descriptive
+error message.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char * <B>history_arg_extract</B> <I>(int first, int last, char *string)</I>
+<DD><A NAME="IDX33"></A>
+Extract a string segment consisting of the <VAR>first</VAR> through <VAR>last</VAR>
+arguments present in <VAR>string</VAR>.  Arguments are broken up as in Bash.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char * <B>get_history_event</B> <I>(char *string, int *cindex, int qchar)</I>
+<DD><A NAME="IDX34"></A>
+Returns the text of the history event beginning at <VAR>string</VAR> +
+<VAR>*cindex</VAR>.  <VAR>*cindex</VAR> is modified to point to after the event
+specifier.  At function entry, <VAR>cindex</VAR> points to the index into
+<VAR>string</VAR> where the history event specification begins.  <VAR>qchar</VAR>
+is a character that is allowed to end the event specification in addition
+to the "normal" terminating characters.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char ** <B>history_tokenize</B> <I>(char *string)</I>
+<DD><A NAME="IDX35"></A>
+Return an array of tokens parsed out of <VAR>string</VAR>, much as the
+shell might.  The tokens are split on white space and on the
+characters <CODE>()&#60;&#62;;&#38;|$</CODE>, and shell quoting conventions are
+obeyed.
+</DL>
+
+</P>
+
+
+<H2><A NAME="SEC17" HREF="history_toc.html#TOC17">History Variables</A></H2>
+
+<P>
+This section describes the externally visible variables exported by
+the GNU History Library.
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>history_base</B>
+<DD><A NAME="IDX36"></A>
+The logical offset of the first entry in the history list.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>history_length</B>
+<DD><A NAME="IDX37"></A>
+The number of entries currently stored in the history list.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>max_input_history</B>
+<DD><A NAME="IDX38"></A>
+The maximum number of history entries.  This must be changed using
+<CODE>stifle_history ()</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char <B>history_expansion_char</B>
+<DD><A NAME="IDX39"></A>
+The character that starts a history event.  The default is <SAMP>`!'</SAMP>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char <B>history_subst_char</B>
+<DD><A NAME="IDX40"></A>
+The character that invokes word substitution if found at the start of
+a line.  The default is <SAMP>`^'</SAMP>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char <B>history_comment_char</B>
+<DD><A NAME="IDX41"></A>
+During tokenization, if this character is seen as the first character
+of a word, then it and all subsequent characters up to a newline are
+ignored, suppressing history expansion for the remainder of the line.
+This is disabled by default.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>history_no_expand_chars</B>
+<DD><A NAME="IDX42"></A>
+The list of characters which inhibit history expansion if found immediately
+following <VAR>history_expansion_char</VAR>.  The default is whitespace and
+<SAMP>`='</SAMP>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>history_search_delimiter_chars</B>
+<DD><A NAME="IDX43"></A>
+The list of additional characters which can delimit a history search
+string, in addition to whitespace, <SAMP>`:'</SAMP> and <SAMP>`?'</SAMP> in the case of
+a substring search.  The default is empty.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>history_quotes_inhibit_expansion</B>
+<DD><A NAME="IDX44"></A>
+If non-zero, single-quoted words are not scanned for the history expansion
+character.  The default value is 0.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Function * <B>history_inhibit_expansion_function</B>
+<DD><A NAME="IDX45"></A>
+This should be set to the address of a function that takes two arguments:
+a <CODE>char *</CODE> (<VAR>string</VAR>) and an integer index into that string (<VAR>i</VAR>).
+It should return a non-zero value if the history expansion starting at
+<VAR>string[i]</VAR> should not be performed; zero if the expansion should
+be done.
+It is intended for use by applications like Bash that use the history
+expansion character for additional purposes.
+By default, this variable is set to NULL.
+</DL>
+
+</P>
+
+
+<H2><A NAME="SEC18" HREF="history_toc.html#TOC18">History Programming Example</A></H2>
+
+<P>
+The following program demonstrates simple use of the GNU History Library.
+
+</P>
+
+<PRE>
+main ()
+{
+  char line[1024], *t;
+  int len, done = 0;
+
+  line[0] = 0;
+
+  using_history ();
+  while (!done)
+    {
+      printf ("history$ ");
+      fflush (stdout);
+      t = fgets (line, sizeof (line) - 1, stdin);
+      if (t &#38;&#38; *t)
+        {
+          len = strlen (t);
+          if (t[len - 1] == '\n')
+            t[len - 1] = '\0';
+        }
+
+      if (!t)
+        strcpy (line, "quit");
+
+      if (line[0])
+        {
+          char *expansion;
+          int result;
+
+          result = history_expand (line, &#38;expansion);
+          if (result)
+            fprintf (stderr, "%s\n", expansion);
+
+          if (result &#60; 0 || result == 2)
+            {
+              free (expansion);
+              continue;
+            }
+
+          add_history (expansion);
+          strncpy (line, expansion, sizeof (line) - 1);
+          free (expansion);
+        }
+
+      if (strcmp (line, "quit") == 0)
+        done = 1;
+      else if (strcmp (line, "save") == 0)
+        write_history ("history_file");
+      else if (strcmp (line, "read") == 0)
+        read_history ("history_file");
+      else if (strcmp (line, "list") == 0)
+        {
+          register HIST_ENTRY **the_list;
+          register int i;
+
+          the_list = history_list ();
+          if (the_list)
+            for (i = 0; the_list[i]; i++)
+              printf ("%d: %s\n", i + history_base, the_list[i]-&#62;line);
+        }
+      else if (strncmp (line, "delete", 6) == 0)
+        {
+          int which;
+          if ((sscanf (line + 6, "%d", &#38;which)) == 1)
+            {
+              HIST_ENTRY *entry = remove_history (which);
+              if (!entry)
+                fprintf (stderr, "No such entry %d\n", which);
+              else
+                {
+                  free (entry-&#62;line);
+                  free (entry);
+                }
+            }
+          else
+            {
+              fprintf (stderr, "non-numeric arg given to `delete'\n");
+            }
+        }
+    }
+}
+</PRE>
+
+
+
+<H1><A NAME="SEC19" HREF="history_toc.html#TOC19">Concept Index</A></H1>
+<P>
+<H2>a</H2>
+<DIR>
+<LI><A HREF="history.html#IDX23">anchored search</A>
+</DIR>
+<H2>e</H2>
+<DIR>
+<LI><A HREF="history.html#IDX2">event designators</A>
+</DIR>
+<H2>h</H2>
+<DIR>
+<LI><A HREF="history.html#IDX3">history events</A>
+<LI><A HREF="history.html#IDX1">history expansion</A>
+<LI><A HREF="history.html#IDX22">History Searching</A>
+</DIR>
+
+</P>
+
+
+<H1><A NAME="SEC20" HREF="history_toc.html#TOC20">Function and Variable Index</A></H1>
+<P>
+<H2>a</H2>
+<DIR>
+<LI><A HREF="history.html#IDX7">add_history</A>
+<LI><A HREF="history.html#IDX30">append_history</A>
+</DIR>
+<H2>c</H2>
+<DIR>
+<LI><A HREF="history.html#IDX10">clear_history</A>
+<LI><A HREF="history.html#IDX16">current_history</A>
+</DIR>
+<H2>g</H2>
+<DIR>
+<LI><A HREF="history.html#IDX34">get_history_event</A>
+</DIR>
+<H2>h</H2>
+<DIR>
+<LI><A HREF="history.html#IDX33">history_arg_extract</A>
+<LI><A HREF="history.html#IDX36">history_base</A>
+<LI><A HREF="history.html#IDX41">history_comment_char</A>
+<LI><A HREF="history.html#IDX32">history_expand</A>
+<LI><A HREF="history.html#IDX39">history_expansion_char</A>
+<LI><A HREF="history.html#IDX17">history_get</A>
+<LI><A HREF="history.html#IDX5">history_get_history_state</A>
+<LI><A HREF="history.html#IDX45">history_inhibit_expansion_function</A>
+<LI><A HREF="history.html#IDX13">history_is_stifled</A>
+<LI><A HREF="history.html#IDX37">history_length</A>
+<LI><A HREF="history.html#IDX14">history_list</A>
+<LI><A HREF="history.html#IDX42">history_no_expand_chars</A>
+<LI><A HREF="history.html#IDX44">history_quotes_inhibit_expansion</A>
+<LI><A HREF="history.html#IDX24">history_search</A>
+<LI><A HREF="history.html#IDX43">history_search_delimiter_chars</A>
+<LI><A HREF="history.html#IDX26">history_search_pos</A>
+<LI><A HREF="history.html#IDX25">history_search_prefix</A>
+<LI><A HREF="history.html#IDX6">history_set_history_state</A>
+<LI><A HREF="history.html#IDX19">history_set_pos</A>
+<LI><A HREF="history.html#IDX40">history_subst_char</A>
+<LI><A HREF="history.html#IDX35">history_tokenize</A>
+<LI><A HREF="history.html#IDX18">history_total_bytes</A>
+<LI><A HREF="history.html#IDX31">history_truncate_file</A>
+</DIR>
+<H2>m</H2>
+<DIR>
+<LI><A HREF="history.html#IDX38">max_input_history</A>
+</DIR>
+<H2>n</H2>
+<DIR>
+<LI><A HREF="history.html#IDX21">next_history</A>
+</DIR>
+<H2>p</H2>
+<DIR>
+<LI><A HREF="history.html#IDX20">previous_history</A>
+</DIR>
+<H2>r</H2>
+<DIR>
+<LI><A HREF="history.html#IDX27">read_history</A>
+<LI><A HREF="history.html#IDX28">read_history_range</A>
+<LI><A HREF="history.html#IDX8">remove_history</A>
+<LI><A HREF="history.html#IDX9">replace_history_entry</A>
+</DIR>
+<H2>s</H2>
+<DIR>
+<LI><A HREF="history.html#IDX11">stifle_history</A>
+</DIR>
+<H2>u</H2>
+<DIR>
+<LI><A HREF="history.html#IDX12">unstifle_history</A>
+<LI><A HREF="history.html#IDX4">using_history</A>
+</DIR>
+<H2>w</H2>
+<DIR>
+<LI><A HREF="history.html#IDX15">where_history</A>
+<LI><A HREF="history.html#IDX29">write_history</A>
+</DIR>
+
+</P>
+<P><HR><P>
+This document was generated on 16 April 1997 using the
+<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
+translator version 1.51.</P>
+</BODY>
+</HTML>
diff --git a/readline/doc/history.info b/readline/doc/history.info
new file mode 100644
--- /dev/null
+++ b/readline/doc/history.info
@@ -0,0 +1,785 @@
+This is Info file history.info, produced by Makeinfo-1.55 from the
+input file /usr/homes/chet/src/bash/readline-src/doc/hist.texinfo.
+
+   This document describes the GNU History library, a programming tool
+that provides a consistent user interface for recalling lines of
+previously typed input.
+
+   Copyright (C) 1988, 1991, 1993, 1995, 1996 Free Software Foundation,
+Inc.
+
+   Permission is granted to make and distribute verbatim copies of this
+manual provided the copyright notice and this permission notice pare
+preserved on all copies.
+
+   Permission is granted to copy and distribute modified versions of
+this manual under the conditions for verbatim copying, provided that
+the entire resulting derived work is distributed under the terms of a
+permission notice identical to this one.
+
+   Permission is granted to copy and distribute translations of this
+manual into another language, under the above conditions for modified
+versions, except that this permission notice may be stated in a
+translation approved by the Foundation.
+
+
+File: history.info,  Node: Top,  Next: Using History Interactively,  Prev: (DIR),  Up: (DIR)
+
+GNU History Library
+*******************
+
+   This document describes the GNU History library, a programming tool
+that provides a consistent user interface for recalling lines of
+previously typed input.
+
+* Menu:
+
+* Using History Interactively::	  GNU History User's Manual.
+* Programming with GNU History::  GNU History Programmer's Manual.
+* Concept Index::		  Index of concepts described in this manual.
+* Function and Variable Index::	  Index of externally visible functions
+				  and variables.
+
+
+File: history.info,  Node: Using History Interactively,  Next: Programming with GNU History,  Prev: Top,  Up: Top
+
+Using History Interactively
+***************************
+
+   This chapter describes how to use the GNU History Library
+interactively, from a user's standpoint.  It should be considered a
+user's guide.  For information on using the GNU History Library in your
+own programs, *note Programming with GNU History::..
+
+* Menu:
+
+* History Interaction::		What it feels like using History as a user.
+
+
+File: history.info,  Node: History Interaction,  Up: Using History Interactively
+
+Interactive History Expansion
+=============================
+
+   The History library provides a history expansion feature that is
+similar to the history expansion provided by `csh'.  This section
+describes the syntax used to manipulate the history information.
+
+   History expansions introduce words from the history list into the
+input stream, making it easy to repeat commands, insert the arguments
+to a previous command into the current input line, or fix errors in
+previous commands quickly.
+
+   History expansion takes place in two parts.  The first is to
+determine which line from the previous history should be used during
+substitution.  The second is to select portions of that line for
+inclusion into the current one.  The line selected from the previous
+history is called the "event", and the portions of that line that are
+acted upon are called "words".  Various "modifiers" are available to
+manipulate the selected words.  The line is broken into words in the
+same fashion that Bash does, so that several English (or Unix) words
+surrounded by quotes are considered as one word.  History expansions
+are introduced by the appearance of the history expansion character,
+which is `!' by default.
+
+* Menu:
+
+* Event Designators::	How to specify which history line to use.
+* Word Designators::	Specifying which words are of interest.
+* Modifiers::		Modifying the results of substitution.
+
+
+File: history.info,  Node: Event Designators,  Next: Word Designators,  Up: History Interaction
+
+Event Designators
+-----------------
+
+   An event designator is a reference to a command line entry in the
+history list.
+
+`!'
+     Start a history substitution, except when followed by a space, tab,
+     the end of the line, = or (.
+
+`!N'
+     Refer to command line N.
+
+`!-N'
+     Refer to the command N lines back.
+
+`!!'
+     Refer to the previous command.  This is a synonym for `!-1'.
+
+`!STRING'
+     Refer to the most recent command starting with STRING.
+
+`!?STRING[?]'
+     Refer to the most recent command containing STRING.  The trailing
+     `?' may be omitted if the STRING is followed immediately by a
+     newline.
+
+`^STRING1^STRING2^'
+     Quick Substitution.  Repeat the last command, replacing STRING1
+     with STRING2.  Equivalent to `!!:s/STRING1/STRING2/'.
+
+`!#'
+     The entire command line typed so far.
+
+
+File: history.info,  Node: Word Designators,  Next: Modifiers,  Prev: Event Designators,  Up: History Interaction
+
+Word Designators
+----------------
+
+   Word designators are used to select desired words from the event.  A
+`:' separates the event specification from the word designator.  It can
+be omitted if the word designator begins with a `^', `$', `*', `-', or
+`%'.  Words are numbered from the beginning of the line, with the first
+word being denoted by 0 (zero).  Words are inserted into the current
+line separated by single spaces.
+
+`0 (zero)'
+     The `0'th word.  For many applications, this is the command word.
+
+`N'
+     The Nth word.
+
+`^'
+     The first argument; that is, word 1.
+
+`$'
+     The last argument.
+
+`%'
+     The word matched by the most recent `?STRING?' search.
+
+`X-Y'
+     A range of words; `-Y' abbreviates `0-Y'.
+
+`*'
+     All of the words, except the `0'th.  This is a synonym for `1-$'.
+     It is not an error to use `*' if there is just one word in the
+     event; the empty string is returned in that case.
+
+`X*'
+     Abbreviates `X-$'
+
+`X-'
+     Abbreviates `X-$' like `X*', but omits the last word.
+
+   If a word designator is supplied without an event specification, the
+previous command is used as the event.
+
+
+File: history.info,  Node: Modifiers,  Prev: Word Designators,  Up: History Interaction
+
+Modifiers
+---------
+
+   After the optional word designator, you can add a sequence of one or
+more of the following modifiers, each preceded by a `:'.
+
+`h'
+     Remove a trailing pathname component, leaving only the head.
+
+`t'
+     Remove all leading  pathname  components, leaving the tail.
+
+`r'
+     Remove a trailing suffix of the form `.SUFFIX', leaving the
+     basename.
+
+`e'
+     Remove all but the trailing suffix.
+
+`p'
+     Print the new command but do not execute it.
+
+`s/OLD/NEW/'
+     Substitute NEW for the first occurrence of OLD in the event line.
+     Any delimiter may be used in place of `/'.  The delimiter may be
+     quoted in OLD and NEW with a single backslash.  If `&' appears in
+     NEW, it is replaced by OLD.  A single backslash will quote the
+     `&'.  The final delimiter is optional if it is the last character
+     on the input line.
+
+`&'
+     Repeat the previous substitution.
+
+`g'
+     Cause changes to be applied over the entire event line.  Used in
+     conjunction with `s', as in `gs/OLD/NEW/', or with `&'.
+
+
+File: history.info,  Node: Programming with GNU History,  Next: Concept Index,  Prev: Using History Interactively,  Up: Top
+
+Programming with GNU History
+****************************
+
+   This chapter describes how to interface programs that you write with
+the GNU History Library.  It should be considered a technical guide.
+For information on the interactive use of GNU History, *note Using
+History Interactively::..
+
+* Menu:
+
+* Introduction to History::	What is the GNU History library for?
+* History Storage::		How information is stored.
+* History Functions::		Functions that you can use.
+* History Variables::		Variables that control behaviour.
+* History Programming Example::	Example of using the GNU History Library.
+
+
+File: history.info,  Node: Introduction to History,  Next: History Storage,  Up: Programming with GNU History
+
+Introduction to History
+=======================
+
+   Many programs read input from the user a line at a time.  The GNU
+History library is able to keep track of those lines, associate
+arbitrary data with each line, and utilize information from previous
+lines in composing new ones.
+
+   The programmer using the History library has available functions for
+remembering lines on a history list, associating arbitrary data with a
+line, removing lines from the list, searching through the list for a
+line containing an arbitrary text string, and referencing any line in
+the list directly.  In addition, a history "expansion" function is
+available which provides for a consistent user interface across
+different programs.
+
+   The user using programs written with the History library has the
+benefit of a consistent user interface with a set of well-known
+commands for manipulating the text of previous lines and using that text
+in new commands.  The basic history manipulation commands are similar to
+the history substitution provided by `csh'.
+
+   If the programmer desires, he can use the Readline library, which
+includes some history manipulation by default, and has the added
+advantage of command line editing.
+
+
+File: history.info,  Node: History Storage,  Next: History Functions,  Prev: Introduction to History,  Up: Programming with GNU History
+
+History Storage
+===============
+
+   The history list is an array of history entries.  A history entry is
+declared as follows:
+
+     typedef struct _hist_entry {
+       char *line;
+       char *data;
+     } HIST_ENTRY;
+
+   The history list itself might therefore be declared as
+
+     HIST_ENTRY **the_history_list;
+
+   The state of the History library is encapsulated into a single
+structure:
+
+     /* A structure used to pass the current state of the history stuff around. */
+     typedef struct _hist_state {
+       HIST_ENTRY **entries;         /* Pointer to the entries themselves. */
+       int offset;                   /* The location pointer within this array. */
+       int length;                   /* Number of elements within this array. */
+       int size;                     /* Number of slots allocated to this array. */
+       int flags;
+     } HISTORY_STATE;
+
+   If the flags member includes `HS_STIFLED', the history has been
+stifled.
+
+
+File: history.info,  Node: History Functions,  Next: History Variables,  Prev: History Storage,  Up: Programming with GNU History
+
+History Functions
+=================
+
+   This section describes the calling sequence for the various functions
+present in GNU History.
+
+* Menu:
+
+* Initializing History and State Management::	Functions to call when you
+						want to use history in a
+						program.
+* History List Management::		Functions used to manage the list
+					of history entries.
+* Information About the History List::	Functions returning information about
+					the history list.
+* Moving Around the History List::	Functions used to change the position
+					in the history list.
+* Searching the History List::		Functions to search the history list
+					for entries containing a string.
+* Managing the History File::		Functions that read and write a file
+					containing the history list.
+* History Expansion::			Functions to perform csh-like history
+					expansion.
+
+
+File: history.info,  Node: Initializing History and State Management,  Next: History List Management,  Up: History Functions
+
+Initializing History and State Management
+-----------------------------------------
+
+   This section describes functions used to initialize and manage the
+state of the History library when you want to use the history functions
+in your program.
+
+ - Function: void using_history ()
+     Begin a session in which the history functions might be used.  This
+     initializes the interactive variables.
+
+ - Function: HISTORY_STATE * history_get_history_state ()
+     Return a structure describing the current state of the input
+     history.
+
+ - Function: void history_set_history_state (HISTORY_STATE *state)
+     Set the state of the history list according to STATE.
+
+
+File: history.info,  Node: History List Management,  Next: Information About the History List,  Prev: Initializing History and State Management,  Up: History Functions
+
+History List Management
+-----------------------
+
+   These functions manage individual entries on the history list, or set
+parameters managing the list itself.
+
+ - Function: void add_history (char *string)
+     Place STRING at the end of the history list.  The associated data
+     field (if any) is set to `NULL'.
+
+ - Function: HIST_ENTRY * remove_history (int which)
+     Remove history entry at offset WHICH from the history.  The
+     removed element is returned so you can free the line, data, and
+     containing structure.
+
+ - Function: HIST_ENTRY * replace_history_entry (int which, char *line,
+          char *data)
+     Make the history entry at offset WHICH have LINE and DATA.  This
+     returns the old entry so you can dispose of the data.  In the case
+     of an invalid WHICH, a `NULL' pointer is returned.
+
+ - Function: void clear_history ()
+     Clear the history list by deleting all the entries.
+
+ - Function: void stifle_history (int max)
+     Stifle the history list, remembering only the last MAX entries.
+
+ - Function: int unstifle_history ()
+     Stop stifling the history.  This returns the previous amount the
+     history was stifled.  The value is positive if the history was
+     stifled, negative if it wasn't.
+
+ - Function: int history_is_stifled ()
+     Returns non-zero if the history is stifled, zero if it is not.
+
+
+File: history.info,  Node: Information About the History List,  Next: Moving Around the History List,  Prev: History List Management,  Up: History Functions
+
+Information About the History List
+----------------------------------
+
+   These functions return information about the entire history list or
+individual list entries.
+
+ - Function: HIST_ENTRY ** history_list ()
+     Return a `NULL' terminated array of `HIST_ENTRY' which is the
+     current input history.  Element 0 of this list is the beginning of
+     time.  If there is no history, return `NULL'.
+
+ - Function: int where_history ()
+     Returns the offset of the current history element.
+
+ - Function: HIST_ENTRY * current_history ()
+     Return the history entry at the current position, as determined by
+     `where_history ()'.  If there is no entry there, return a `NULL'
+     pointer.
+
+ - Function: HIST_ENTRY * history_get (int offset)
+     Return the history entry at position OFFSET, starting from
+     `history_base'.  If there is no entry there, or if OFFSET is
+     greater than the history length, return a `NULL' pointer.
+
+ - Function: int history_total_bytes ()
+     Return the number of bytes that the primary history entries are
+     using.  This function returns the sum of the lengths of all the
+     lines in the history.
+
+
+File: history.info,  Node: Moving Around the History List,  Next: Searching the History List,  Prev: Information About the History List,  Up: History Functions
+
+Moving Around the History List
+------------------------------
+
+   These functions allow the current index into the history list to be
+set or changed.
+
+ - Function: int history_set_pos (int pos)
+     Set the position in the history list to POS, an absolute index
+     into the list.
+
+ - Function: HIST_ENTRY * previous_history ()
+     Back up the current history offset to the previous history entry,
+     and return a pointer to that entry.  If there is no previous
+     entry, return a `NULL' pointer.
+
+ - Function: HIST_ENTRY * next_history ()
+     Move the current history offset forward to the next history entry,
+     and return the a pointer to that entry.  If there is no next
+     entry, return a `NULL' pointer.
+
+
+File: history.info,  Node: Searching the History List,  Next: Managing the History File,  Prev: Moving Around the History List,  Up: History Functions
+
+Searching the History List
+--------------------------
+
+   These functions allow searching of the history list for entries
+containing a specific string.  Searching may be performed both forward
+and backward from the current history position.  The search may be
+"anchored", meaning that the string must match at the beginning of the
+history entry.
+
+ - Function: int history_search (char *string, int direction)
+     Search the history for STRING, starting at the current history
+     offset.  If DIRECTION < 0, then the search is through previous
+     entries, else through subsequent.  If STRING is found, then the
+     current history index is set to that history entry, and the value
+     returned is the offset in the line of the entry where STRING was
+     found.  Otherwise, nothing is changed, and a -1 is returned.
+
+ - Function: int history_search_prefix (char *string, int direction)
+     Search the history for STRING, starting at the current history
+     offset.  The search is anchored: matching lines must begin with
+     STRING.  If DIRECTION < 0, then the search is through previous
+     entries, else through subsequent.  If STRING is found, then the
+     current history index is set to that entry, and the return value
+     is 0.  Otherwise, nothing is changed, and a -1 is returned.
+
+ - Function: int history_search_pos (char *string, int direction, int
+          pos)
+     Search for STRING in the history list, starting at POS, an
+     absolute index into the list.  If DIRECTION is negative, the search
+     proceeds backward from POS, otherwise forward.  Returns the
+     absolute index of the history element where STRING was found, or
+     -1 otherwise.
+
+
+File: history.info,  Node: Managing the History File,  Next: History Expansion,  Prev: Searching the History List,  Up: History Functions
+
+Managing the History File
+-------------------------
+
+   The History library can read the history from and write it to a file.
+This section documents the functions for managing a history file.
+
+ - Function: int read_history (char *filename)
+     Add the contents of FILENAME to the history list, a line at a
+     time.  If FILENAME is `NULL', then read from `~/.history'.
+     Returns 0 if successful, or errno if not.
+
+ - Function: int read_history_range (char *filename, int from, int to)
+     Read a range of lines from FILENAME, adding them to the history
+     list.  Start reading at line FROM and end at TO.  If FROM is zero,
+     start at the beginning.  If TO is less than FROM, then read until
+     the end of the file.  If FILENAME is `NULL', then read from
+     `~/.history'.  Returns 0 if successful, or `errno' if not.
+
+ - Function: int write_history (char *filename)
+     Write the current history to FILENAME, overwriting FILENAME if
+     necessary.  If FILENAME is `NULL', then write the history list to
+     `~/.history'.  Values returned are as in `read_history ()'.
+
+ - Function: int append_history (int nelements, char *filename)
+     Append the last NELEMENTS of the history list to FILENAME.
+
+ - Function: int history_truncate_file (char *filename, int nlines)
+     Truncate the history file FILENAME, leaving only the last NLINES
+     lines.
+
+
+File: history.info,  Node: History Expansion,  Prev: Managing the History File,  Up: History Functions
+
+History Expansion
+-----------------
+
+   These functions implement `csh'-like history expansion.
+
+ - Function: int history_expand (char *string, char **output)
+     Expand STRING, placing the result into OUTPUT, a pointer to a
+     string (*note History Interaction::.).  Returns:
+    `0'
+          If no expansions took place (or, if the only change in the
+          text was the de-slashifying of the history expansion
+          character);
+
+    `1'
+          if expansions did take place;
+
+    `-1'
+          if there was an error in expansion;
+
+    `2'
+          if the returned line should only be displayed, but not
+          executed, as with the `:p' modifier (*note Modifiers::.).
+
+     If an error ocurred in expansion, then OUTPUT contains a
+     descriptive error message.
+
+ - Function: char * history_arg_extract (int first, int last, char
+          *string)
+     Extract a string segment consisting of the FIRST through LAST
+     arguments present in STRING.  Arguments are broken up as in Bash.
+
+ - Function: char * get_history_event (char *string, int *cindex, int
+          qchar)
+     Returns the text of the history event beginning at STRING +
+     *CINDEX.  *CINDEX is modified to point to after the event
+     specifier.  At function entry, CINDEX points to the index into
+     STRING where the history event specification begins.  QCHAR is a
+     character that is allowed to end the event specification in
+     addition to the "normal" terminating characters.
+
+ - Function: char ** history_tokenize (char *string)
+     Return an array of tokens parsed out of STRING, much as the shell
+     might.  The tokens are split on white space and on the characters
+     `()<>;&|$', and shell quoting conventions are obeyed.
+
+
+File: history.info,  Node: History Variables,  Next: History Programming Example,  Prev: History Functions,  Up: Programming with GNU History
+
+History Variables
+=================
+
+   This section describes the externally visible variables exported by
+the GNU History Library.
+
+ - Variable: int history_base
+     The logical offset of the first entry in the history list.
+
+ - Variable: int history_length
+     The number of entries currently stored in the history list.
+
+ - Variable: int max_input_history
+     The maximum number of history entries.  This must be changed using
+     `stifle_history ()'.
+
+ - Variable: char history_expansion_char
+     The character that starts a history event.  The default is `!'.
+
+ - Variable: char history_subst_char
+     The character that invokes word substitution if found at the start
+     of a line.  The default is `^'.
+
+ - Variable: char history_comment_char
+     During tokenization, if this character is seen as the first
+     character of a word, then it and all subsequent characters up to a
+     newline are ignored, suppressing history expansion for the
+     remainder of the line.  This is disabled by default.
+
+ - Variable: char * history_no_expand_chars
+     The list of characters which inhibit history expansion if found
+     immediately following HISTORY_EXPANSION_CHAR.  The default is
+     whitespace and `='.
+
+ - Variable: char * history_search_delimiter_chars
+     The list of additional characters which can delimit a history
+     search string, in addition to whitespace, `:' and `?' in the case
+     of a substring search.  The default is empty.
+
+ - Variable: int history_quotes_inhibit_expansion
+     If non-zero, single-quoted words are not scanned for the history
+     expansion character.  The default value is 0.
+
+ - Variable: Function * history_inhibit_expansion_function
+     This should be set to the address of a function that takes two
+     arguments: a `char *' (STRING) and an integer index into that
+     string (I).  It should return a non-zero value if the history
+     expansion starting at STRING[I] should not be performed; zero if
+     the expansion should be done.  It is intended for use by
+     applications like Bash that use the history expansion character
+     for additional purposes.  By default, this variable is set to NULL.
+
+
+File: history.info,  Node: History Programming Example,  Prev: History Variables,  Up: Programming with GNU History
+
+History Programming Example
+===========================
+
+   The following program demonstrates simple use of the GNU History
+Library.
+
+     main ()
+     {
+       char line[1024], *t;
+       int len, done = 0;
+     
+       line[0] = 0;
+     
+       using_history ();
+       while (!done)
+         {
+           printf ("history$ ");
+           fflush (stdout);
+           t = fgets (line, sizeof (line) - 1, stdin);
+           if (t && *t)
+             {
+               len = strlen (t);
+               if (t[len - 1] == '\n')
+                 t[len - 1] = '\0';
+             }
+     
+           if (!t)
+             strcpy (line, "quit");
+     
+           if (line[0])
+             {
+               char *expansion;
+               int result;
+     
+               result = history_expand (line, &expansion);
+               if (result)
+                 fprintf (stderr, "%s\n", expansion);
+     
+               if (result < 0 || result == 2)
+                 {
+                   free (expansion);
+                   continue;
+                 }
+     
+               add_history (expansion);
+               strncpy (line, expansion, sizeof (line) - 1);
+               free (expansion);
+             }
+     
+           if (strcmp (line, "quit") == 0)
+             done = 1;
+           else if (strcmp (line, "save") == 0)
+             write_history ("history_file");
+           else if (strcmp (line, "read") == 0)
+             read_history ("history_file");
+           else if (strcmp (line, "list") == 0)
+             {
+               register HIST_ENTRY **the_list;
+               register int i;
+     
+               the_list = history_list ();
+               if (the_list)
+                 for (i = 0; the_list[i]; i++)
+                   printf ("%d: %s\n", i + history_base, the_list[i]->line);
+             }
+           else if (strncmp (line, "delete", 6) == 0)
+             {
+               int which;
+               if ((sscanf (line + 6, "%d", &which)) == 1)
+                 {
+                   HIST_ENTRY *entry = remove_history (which);
+                   if (!entry)
+                     fprintf (stderr, "No such entry %d\n", which);
+                   else
+                     {
+                       free (entry->line);
+                       free (entry);
+                     }
+                 }
+               else
+                 {
+                   fprintf (stderr, "non-numeric arg given to `delete'\n");
+                 }
+             }
+         }
+     }
+
+
+File: history.info,  Node: Concept Index,  Next: Function and Variable Index,  Prev: Programming with GNU History,  Up: Top
+
+Concept Index
+*************
+
+* Menu:
+
+* anchored search:                      Searching the History List.
+* event designators:                    Event Designators.
+* history events:                       Event Designators.
+* history expansion:                    History Interaction.
+* History Searching:                    Searching the History List.
+
+
+File: history.info,  Node: Function and Variable Index,  Prev: Concept Index,  Up: Top
+
+Function and Variable Index
+***************************
+
+* Menu:
+
+* add_history:                          History List Management.
+* append_history:                       Managing the History File.
+* clear_history:                        History List Management.
+* current_history:                      Information About the History List.
+* get_history_event:                    History Expansion.
+* history_arg_extract:                  History Expansion.
+* history_base:                         History Variables.
+* history_comment_char:                 History Variables.
+* history_expand:                       History Expansion.
+* history_expansion_char:               History Variables.
+* history_get:                          Information About the History List.
+* history_get_history_state:            Initializing History and State Management.
+* history_inhibit_expansion_function:   History Variables.
+* history_is_stifled:                   History List Management.
+* history_length:                       History Variables.
+* history_list:                         Information About the History List.
+* history_no_expand_chars:              History Variables.
+* history_quotes_inhibit_expansion:     History Variables.
+* history_search:                       Searching the History List.
+* history_search_delimiter_chars:       History Variables.
+* history_search_pos:                   Searching the History List.
+* history_search_prefix:                Searching the History List.
+* history_set_history_state:            Initializing History and State Management.
+* history_set_pos:                      Moving Around the History List.
+* history_subst_char:                   History Variables.
+* history_tokenize:                     History Expansion.
+* history_total_bytes:                  Information About the History List.
+* history_truncate_file:                Managing the History File.
+* max_input_history:                    History Variables.
+* next_history:                         Moving Around the History List.
+* previous_history:                     Moving Around the History List.
+* read_history:                         Managing the History File.
+* read_history_range:                   Managing the History File.
+* remove_history:                       History List Management.
+* replace_history_entry:                History List Management.
+* stifle_history:                       History List Management.
+* unstifle_history:                     History List Management.
+* using_history:                        Initializing History and State Management.
+* where_history:                        Information About the History List.
+* write_history:                        Managing the History File.
+
+
+
+Tag Table:
+Node: Top1035
+Node: Using History Interactively1629
+Node: History Interaction2137
+Node: Event Designators3614
+Node: Word Designators4537
+Node: Modifiers5786
+Node: Programming with GNU History6924
+Node: Introduction to History7650
+Node: History Storage8971
+Node: History Functions10064
+Node: Initializing History and State Management11035
+Node: History List Management11827
+Node: Information About the History List13348
+Node: Moving Around the History List14654
+Node: Searching the History List15539
+Node: Managing the History File17371
+Node: History Expansion18877
+Node: History Variables20721
+Node: History Programming Example23039
+Node: Concept Index25643
+Node: Function and Variable Index26124
+
+End Tag Table
diff --git a/readline/doc/history.ps b/readline/doc/history.ps
new file mode 100644
--- /dev/null
+++ b/readline/doc/history.ps
@@ -0,0 +1,1558 @@
+%!PS (but not EPSF; comments have been disabled)
+%DVIPSCommandLine: dvips -D 300 -o history.ps history.dvi
+%DVIPSParameters: dpi=300, compressed, comments removed
+%DVIPSSource:  TeX output 1997.04.16:1522
+/TeXDict 250 dict def TeXDict begin /N{def}def /B{bind def}N /S{exch}N
+/X{S N}B /TR{translate}N /isls false N /vsize 11 72 mul N /hsize 8.5 72
+mul N /landplus90{false}def /@rigin{isls{[0 landplus90{1 -1}{-1 1}
+ifelse 0 0 0]concat}if 72 Resolution div 72 VResolution div neg scale
+isls{landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div
+hsize mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul
+TR[matrix currentmatrix{dup dup round sub abs 0.00001 lt{round}if}
+forall round exch round exch]setmatrix}N /@landscape{/isls true N}B
+/@manualfeed{statusdict /manualfeed true put}B /@copies{/#copies X}B
+/FMat[1 0 0 -1 0 0]N /FBB[0 0 0 0]N /nn 0 N /IE 0 N /ctr 0 N /df-tail{
+/nn 8 dict N nn begin /FontType 3 N /FontMatrix fntrx N /FontBBox FBB N
+string /base X array /BitMaps X /BuildChar{CharBuilder}N /Encoding IE N
+end dup{/foo setfont}2 array copy cvx N load 0 nn put /ctr 0 N[}B /df{
+/sf 1 N /fntrx FMat N df-tail}B /dfs{div /sf X /fntrx[sf 0 0 sf neg 0 0]
+N df-tail}B /E{pop nn dup definefont setfont}B /ch-width{ch-data dup
+length 5 sub get}B /ch-height{ch-data dup length 4 sub get}B /ch-xoff{
+128 ch-data dup length 3 sub get sub}B /ch-yoff{ch-data dup length 2 sub
+get 127 sub}B /ch-dx{ch-data dup length 1 sub get}B /ch-image{ch-data
+dup type /stringtype ne{ctr get /ctr ctr 1 add N}if}B /id 0 N /rw 0 N
+/rc 0 N /gp 0 N /cp 0 N /G 0 N /sf 0 N /CharBuilder{save 3 1 roll S dup
+/base get 2 index get S /BitMaps get S get /ch-data X pop /ctr 0 N ch-dx
+0 ch-xoff ch-yoff ch-height sub ch-xoff ch-width add ch-yoff
+setcachedevice ch-width ch-height true[1 0 0 -1 -.1 ch-xoff sub ch-yoff
+.1 sub]/id ch-image N /rw ch-width 7 add 8 idiv string N /rc 0 N /gp 0 N
+/cp 0 N{rc 0 ne{rc 1 sub /rc X rw}{G}ifelse}imagemask restore}B /G{{id
+gp get /gp gp 1 add N dup 18 mod S 18 idiv pl S get exec}loop}B /adv{cp
+add /cp X}B /chg{rw cp id gp 4 index getinterval putinterval dup gp add
+/gp X adv}B /nd{/cp 0 N rw exit}B /lsh{rw cp 2 copy get dup 0 eq{pop 1}{
+dup 255 eq{pop 254}{dup dup add 255 and S 1 and or}ifelse}ifelse put 1
+adv}B /rsh{rw cp 2 copy get dup 0 eq{pop 128}{dup 255 eq{pop 127}{dup 2
+idiv S 128 and or}ifelse}ifelse put 1 adv}B /clr{rw cp 2 index string
+putinterval adv}B /set{rw cp fillstr 0 4 index getinterval putinterval
+adv}B /fillstr 18 string 0 1 17{2 copy 255 put pop}for N /pl[{adv 1 chg}
+{adv 1 chg nd}{1 add chg}{1 add chg nd}{adv lsh}{adv lsh nd}{adv rsh}{
+adv rsh nd}{1 add adv}{/rc X nd}{1 add set}{1 add clr}{adv 2 chg}{adv 2
+chg nd}{pop nd}]dup{bind pop}forall N /D{/cc X dup type /stringtype ne{]
+}if nn /base get cc ctr put nn /BitMaps get S ctr S sf 1 ne{dup dup
+length 1 sub dup 2 index S get sf div put}if put /ctr ctr 1 add N}B /I{
+cc 1 add D}B /bop{userdict /bop-hook known{bop-hook}if /SI save N @rigin
+0 0 moveto /V matrix currentmatrix dup 1 get dup mul exch 0 get dup mul
+add .99 lt{/QV}{/RV}ifelse load def pop pop}N /eop{SI restore userdict
+/eop-hook known{eop-hook}if showpage}N /@start{userdict /start-hook
+known{start-hook}if pop /VResolution X /Resolution X 1000 div /DVImag X
+/IE 256 array N 0 1 255{IE S 1 string dup 0 3 index put cvn put}for
+65781.76 div /vsize X 65781.76 div /hsize X}N /p{show}N /RMat[1 0 0 -1 0
+0]N /BDot 260 string N /rulex 0 N /ruley 0 N /v{/ruley X /rulex X V}B /V
+{}B /RV statusdict begin /product where{pop product dup length 7 ge{0 7
+getinterval dup(Display)eq exch 0 4 getinterval(NeXT)eq or}{pop false}
+ifelse}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale rulex ruley false
+RMat{BDot}imagemask grestore}}{{gsave TR -.1 .1 TR rulex ruley scale 1 1
+false RMat{BDot}imagemask grestore}}ifelse B /QV{gsave newpath transform
+round exch round exch itransform moveto rulex 0 rlineto 0 ruley neg
+rlineto rulex neg 0 rlineto fill grestore}B /a{moveto}B /delta 0 N /tail
+{dup /delta X 0 rmoveto}B /M{S p delta add tail}B /b{S p tail}B /c{-4 M}
+B /d{-3 M}B /e{-2 M}B /f{-1 M}B /g{0 M}B /h{1 M}B /i{2 M}B /j{3 M}B /k{
+4 M}B /w{0 rmoveto}B /l{p -4 w}B /m{p -3 w}B /n{p -2 w}B /o{p -1 w}B /q{
+p 1 w}B /r{p 2 w}B /s{p 3 w}B /t{p 4 w}B /x{0 S rmoveto}B /y{3 2 roll p
+a}B /bos{/SS save N}B /eos{SS restore}B end
+TeXDict begin 40258431 52099146 1000 300 300 (history.dvi)
+@start /Fa 1 47 df<127012F8A212F012E005057B840E>46 D
+E /Fb 1 47 df<1238127C12FCA212F8127006067A8512>46 D E
+/Fc 25 123 df<EA1FC0EA7FF0EA7078EA2018EA001CA2EA07FC121FEA3C1C127012E0A3
+EA707C383FFF80EA0F8F11107E8F14>97 D<12FCA2121CA513F8EA1DFEEA1F07EA1E0300
+1C1380EB01C0A6EB0380001E1300EA1F0EEA1DFCEA0CF81217809614>I<EA03F8EA0FFE
+EA1C0EEA3804EA7000126012E0A412601270EA380EEA1C1EEA0FFCEA03F00F107E8F14>
+I<137EA2130EA5EA07CEEA0FFEEA1C3EEA301EEA700E12E0A61270EA301EEA383E381FEF
+C0EA07CF12177F9614>I<EA07E0EA0FF0EA1C38EA301CEA700CEAE00EA2EAFFFEA2EAE0
+0012601270EA380EEA1C1EEA0FFCEA03F00F107E8F14>I<13FCEA01FEEA038EEA070413
+00A3EA7FFE12FFEA0700ACEAFFF8A20F177F9614>I<EA07CF381FFF80EA383B38301800
+EA701CA3EA3018EA3838EA3FF0EA37C00070C7FCA2EA3FF86C7E487EEA700F38E00380A4
+38700700EA3C1EEA1FFCEA07F011197F8F14>I<12FCA2121CA51378EA1DFEEA1F86EA1E
+07121CAA38FF8FE0A21317809614>I<1206120FA21206C7FCA4B4FCA21207ACEAFFF8A2
+0D187C9714>I<12FCA2121CA5EBFF80A2EB1C005B5B5BEA1DC0EA1FE0A2EA1E70EA1C38
+133C131C7F38FF1F80A21117809614>107 D<EAFF80A21203B3EAFFFEA20F177E9614>I<
+EAFB8EEAFFDF383CF380A2EA38E3AA38FEFBE013791310808F14>I<EAFC78EAFDFEEA1F
+86EA1E07121CAA38FF8FE0A21310808F14>I<EA07C0EA1FF0EA3C78EA701CA2EAE00EA6
+EA701CEA783CEA3C78EA1FF0EA07C00F107E8F14>I<EAFCF8EAFDFEEA1F07EA1E03001C
+1380EB01C0A6EB0380001E1300EA1F0EEA1DFCEA1CF890C7FCA6B47EA21218808F14>I<
+EA03E7EA0FF7EA1C1FEA300F1270487EA6EA700F1230EA1C3FEA0FF7EA07C7EA0007A6EB
+3FE0A213187F8F14>I<EAFE1FEB7F80EA0EE3380F810090C7FCA2120EA8EAFFF0A21110
+7F8F14>I<EA0FD8EA3FF8EA603812C0A2EAF000EA7F80EA3FF0EA07F8EA001CEA600612
+E012F0EAF81CEAFFF8EACFE00F107E8F14>I<1206120EA4EA7FFC12FFEA0E00A8130EA3
+131CEA07F8EA01F00F157F9414>I<EAFC3FA2EA1C07AB131F380FFFE0EA03E71310808F
+14>I<38FE3F80A2383C1E00EA1C1CA36C5AA3EA0630EA0770A36C5AA311107F8F14>I<38
+FE3F80A238700700EA380EA3EA39CEA3EA1B6C121AA3EA1E7CA2EA0E3811107F8F14>I<
+EA7E3FA2EA1E3CEA0E78EA07705B12036C5A12037FEA0770EA0E781338487E38FE3F80A2
+11107F8F14>I<38FE3F80A2381C0E005BA2120E5BA212071330A2EA0370A25B1201A25B
+A3485A12730077C7FC127E123C11187F8F14>I<EA3FFF5AEA700E131C1338EA007013E0
+EA01C0EA0380EA0700120EEA1C0712381270B5FCA210107F8F14>I
+E /Fd 1 47 df<1270A212F0126004047D830B>46 D E /Fe 25
+122 df<EA07E0EA1C38EA381CEA300CEA700EEA6006A2EAE007AAEA6006A2EA700EEA30
+0CEA381CEA1C38EA07E010187F9713>48 D<12035AB4FC1207B3A2EA7FF80D187D9713>
+I<EA0F80EA1060EA2030EA4038EA803CEAC01C12E01240EA003C1338A21370136013C0EA
+018013001202EA040412081210EA3008EA3FF8127F12FF0E187E9713>I<EA01F8EA0704
+EA0C06EA180E123013001270126012E0EAE3E0EAE418EAE80CEAF00EEAE0061307A31260
+A2EA7006EA300EEA180CEA0C38EA07E010187F9713>54 D<1240EA7FFF13FEA2EA4004EA
+80081310A2EA00201340A21380120113005AA25A1206A2120EA5120410197E9813>I<EA
+07E0EA1818EA300CEA20061260A21270EA780CEA3E18EA1F30EA07C0EA03E0EA0CF8EA30
+7CEA601E130FEAC0071303A3EA6002EA2004EA1818EA07E010187F9713>I<EA07E0EA1C
+30EA3018EA700CEA600EEAE006A21307A31260EA700FEA3017EA1827EA07C7EA00071306
+130E130C12701318EA6030EA3060EA0F8010187F9713>I<39FFE1FFC0390E001C00AB38
+0FFFFC380E001CAC39FFE1FFC01A1A7F991D>72 D<EA0FC2EA1836EA200EEA600612C013
+02A3EAE0001270127EEA3FE0EA1FF8EA03FCEA007E130E130713031280A3EAC0021306EA
+E004EAD818EA87E0101A7E9915>83 D<EA1FC0EA38707FEA101C1200A2EA03FCEA1E1C12
+38127012E01480A2133CEA705F381F8F0011107F8F13>97 D<EA07F8EA1C1C1238EA7008
+13005AA612701304EA3808EA1C18EA07E00E107F8F11>99 D<133F1307A9EA03E7EA0C17
+EA180F487E127012E0A6126012706C5AEA1C373807C7E0131A7F9915>I<EA07C0EA1C30
+EA30181270EA600C12E0EAFFFCEAE000A41260EA7004EA3808EA1C18EA07E00E107F8F11
+>I<EA0FCF3818718038303000EA7038A4EA30306C5AEA2FC00060C7FCA21270EA3FF013
+FC6C7EEA600FEAC003A4EA6006EA381CEA07E011187F8F13>103
+D<12FC121CA9137CEA1D87381E0380A2121CAB38FF9FF0141A809915>I<1218123CA212
+181200A612FC121CAE12FF081A80990A>I<EAFC7CEA1D87381E0380A2121CAB38FF9FF0
+1410808F15>110 D<EA07E0EA1C38EA300CEA700EEA6006EAE007A6EA6006EA700EEA38
+1CEA1C38EA07E010107F8F13>I<EAFCFCEA1D07381E0380381C01C0A2EB00E0A6EB01C0
+1480381E0300EA1D06EA1CF890C7FCA6B47E1317808F15>I<EAFC78EA1D9CEA1E1C1308
+EA1C00ABEAFF800E10808F0F>114 D<EA1F20EA60E0EA402012C0A2EAF000127FEA3FC0
+EA1FE0EA00F0EA8070133012C01320EAF040EA8F800C107F8F0F>I<1208A41218A21238
+EAFFC0EA3800A81320A41218EA1C40EA07800B177F960F>I<38FF0F80383C0700EA1C06
+1304A26C5AA26C5AA3EA03A0A2EA01C0A36C5A11107F8F14>118
+D<38FE3F80383C1E00EA1C086C5AEA0F306C5A6C5A12017F1203EA0270487E1208EA181C
+EA381E38FC3FC012107F8F14>120 D<38FF0F80383C0700EA1C061304A26C5AA26C5AA3
+EA03A0A2EA01C0A36C5AA248C7FCA212E112E212E4127811177F8F14>I
+E /Ff 2 42 df<13E0EA01C0EA0380120713005A121EA2121C123CA212381278A3127012
+F0AE12701278A31238123CA2121C121EA27E7E13801203EA01C0EA00E00B2E7CA112>40
+D<12E012707E123C121C121E7EA27E1380A2120313C0A3120113E0AE13C01203A3138012
+07A213005AA2121E121C123C12385A5A0B2E7EA112>I E /Fg 27
+123 df<EB07F8EB7FFC3801FC0E3803F01F48485AEA0FC0A3141E140C91C7FCA2ECFF80
+B6FCA2380FC01FB2397FF8FFF0A21C237FA220>12 D<90380FFF80137F3801FC1F3803F0
+3FEA07E0EA0FC0141FA7B6FCA2380FC01FB2397FF8FFF0A21C237FA220>I<EA07FE381F
+FF80383F07E06D7E130180121E1200A2133FEA03FDEA1F81EA3E01127C12F8A4EA7C02EA
+7E0C391FF87F803807E03F19167E951C>97 D<B47EA2121FABEB87F0EBBFFCEBF03EEBC0
+1F9038800F8015C0140715E0A715C0A2140F15809038C01F00381E707E381C3FFC38180F
+E01B237EA220>I<EBFF80000713E0380F83F0EA1F03123E127E387C01E090C7FC12FCA6
+127C127EA2003E13186C1330380FC0603807FFC0C6130015167E9519>I<49B4FCA2EB00
+3FAB13FE3807FFBF380FC1FF48C67E003E7F127E127CA212FCA7127C127E123E6C5B380F
+81FF3907FF3FE0EA01FC1B237EA220>I<13FE3807FF80380F83C0381E01E0383E00F012
+7E007C13F8147812FCB512F8A200FCC7FCA3127CA26C1318A26C1330380F80E03803FFC0
+C6130015167E951A>I<EB1F80EBFFE03801F1F0EA03E31207EA0FC3EBC1E0EBC000A6EA
+FFFEA2EA0FC0B2EA7FFCA214237EA212>I<9038FE0F803903FF9FC0380F83E3381F01F3
+391E00F000003E7FA5001E5BEA1F01380F83E0380BFF80D808FEC7FC0018C8FCA2121C38
+1FFFE014FC6C13FF7E001F1480397C001FC00078130F00F81307A3007CEB0F806CEB1F00
+381F807E6CB45A000113E01A217F951D>I<B47EA2121FABEB83F0EB8FFCEB987EEBA03E
+EBC03FA21380AE39FFF1FFE0A21B237DA220>I<121E123FEA7F80A4EA3F00121EC7FCA6
+EAFF80A2121FB2EAFFF0A20C247EA30F>I<B47EA2121FABECFF80A2EC3C00143014E0EB
+81C00183C7FC1386139E13BE13FFEBDF80EB8FC01307806D7E6D7E130080147E39FFE1FF
+C0A21A237EA21E>107 D<EAFF80A2121FB3ADEAFFF0A20C237EA20F>I<3AFF03F803F890
+390FFE0FFE3A1F183F183F9039201F201F014001C01380A201801380AE3BFFF0FFF0FFF0
+A22C167D9531>I<38FF03F0EB0FFC381F187EEB203EEB403FA21380AE39FFF1FFE0A21B
+167D9520>I<13FF000713E0380F81F0381F00F8003E137C48133EA300FC133FA7007C13
+3E007E137E003E137C6C13F8380F81F03807FFE0C6130018167E951D>I<38FF87F0EBBF
+FC381FF07EEBC01F9038800F8015C0A2EC07E0A715C0140FA2EC1F8001C01300EBF07EEB
+BFFCEB8FE00180C7FCA8EAFFF0A21B207E9520>I<EBFE033807FF07380FC1CF381F00DF
+48137F007E7FA2127C12FCA7127EA2003E5B6C5BEA0FC13807FF3FEA00FC1300A8903801
+FFE0A21B207E951E>I<38FF0F80EB1FE0381F33F013631343A2EBC1E0EB8000ADEAFFF8
+A214167E9518>I<3807F980EA1FFFEA3807EA7003EAF001A26CC7FCB4FC13F8EA7FFE6C
+7E6C1380120738003FC0EAC007130312E0A200F0138038FC0F00EAEFFEEAC3F812167E95
+17>I<487EA41203A21207A2120F123FB5FCA2EA1F80ABEB8180A5380F830013C3EA07FE
+EA01F811207F9F16>I<38FF81FFA2381F803FAF5C5C380FC1BF3907FF3FE0EA01FC1B16
+7D9520>I<39FFF01FE0A2391FC00700000F1306EBE00E0007130C13F000035BA26C6C5A
+A26C6C5AA2EBFEE0EB7EC0137F6D5AA26DC7FCA2130EA21B167F951E>I<3AFFF3FF83FC
+A23A1F807C00E0D80FC014C08001E013010007017F1380A2D803F0EB0300ECCF8301F813
+87D801F913C61487D800FD13ECEBFF0315FC017F5BEB7E01013E5BEB3C00A20118136026
+167F9529>I<39FFF07FC0A2390FC01C006C6C5A6D5A00035B6C6C5A3800FD80137F91C7
+FC7F6D7E497EEB37E0EB67F013C33801C1F8380380FC48487E000E137F39FF81FFE0A21B
+167F951E>I<39FFF01FE0A2391FC00700000F1306EBE00E0007130C13F000035BA26C6C
+5AA26C6C5AA2EBFEE0EB7EC0137F6D5AA26DC7FCA2130EA2130CA25B1278EAFC3813305B
+EA69C0EA7F80001FC8FC1B207F951E>I<387FFFF0A2387C07E038700FC0EA601F00E013
+8038C03F005B137EC65A1201485AEBF030EA07E0120FEBC070EA1F80003F1360EB00E0EA
+7E03B5FCA214167E9519>I E /Fh 24 119 df<13E0A538F0E1E0EAFCE7387EEFC0381F
+FF00EA07FCEA01F0EA07FCEA1FFF387EEFC038FCE7E0EAF0E13800E000A513157D991A>
+42 D<1338137CA2136C13EEA313C6A2EA01C7A438038380A4380701C0A213FFA24813E0
+EA0E00A4481370387F01FC38FF83FE387F01FC171E7F9D1A>65 D<B512F8A3381C0038A5
+1400A2130EA3EA1FFEA3EA1C0EA390C7FCA3141CA5B512FCA3161E7E9D1A>69
+D<387FFFFCB5FC7E380E001CA51400A2EB0380A3EA0FFFA3EA0E03A390C7FCA8EA7FE012
+FF127F161E7F9D1A>I<38FF83FEA3381C0070AA381FFFF0A3381C0070AB38FF83FEA317
+1E7F9D1A>72 D<B51280A33801C000B3A6B51280A3111E7C9D1A>I<38FE03FE12FFA238
+1D8070A213C0121CA213E0A213601370A213301338A21318131CA2130C130EA21306A213
+071303A238FF81F0A21380171E7F9D1A>78 D<EA0FFE383FFF804813C0EA7C07EA700100
+F013E0EAE000B1EAF001A2007013C0EA7C07EA7FFF6C1380380FFE00131E7D9D1A>I<EA
+FFFC13FF1480381C07C0EB01E0EB00F01470A414F0EB01E0EB07C0381FFF801400148038
+1C07C01301EB00E0A514E214E7A338FF807EA21438181E7F9D1A>82
+D<3803F1C0EA0FFDEA3FFFEA7C0FEA700312E01301A390C7FC12701278123FEA1FF0EA07
+FE3800FF80EB0FC0EB01E013001470A2126012E0A214E0EAF00138FC03C0B5128000EF13
+00EAE3FC141E7D9D1A>I<387FFFFEB5FCA238E0380EA500001300B33803FF80A3171E7F
+9D1A>I<38FF01FEA3381C00706C13E0A2380701C0A213830003138013C700011300A2EA
+00EEA2137CA21338AA48B4FCA3171E7F9D1A>89 D<387FFFC0B512E0A26C13C013047D7E
+1A>95 D<EA1FF0EA3FFC487EEA780FEA300738000380A2137FEA07FF121FEA3F83EA7803
+127012E0A3EA7007EA780F383FFFFCEA1FFDEA07F016157D941A>97
+D<EBFF80000313C0000F13E0EA1F01383C00C04813001270A25AA51270A2007813707E38
+1F01F0380FFFE0000313C03800FE0014157D941A>99 D<EB1FC0A31301A6EA01F1EA07FD
+EA0FFFEA1E0FEA3C07EA7803EA700112E0A7EA7003A2EA3807EA3E0F381FFFFCEA07FDEA
+01F1161E7E9D1A>I<12FEA3120EA6133EEBFF80000F13C013C1EB80E01300120EAC38FF
+E3FE13E713E3171E7F9D1A>104 D<EA01C0487EA36C5AC8FCA5EA7FE0A31200AF387FFF
+80B512C06C1380121F7C9E1A>I<EAFE3EEBFF80B512C0EA0FC1EB80E01300120EAC38FF
+E3FE13E713E317157F941A>110 D<EA01F0EA07FCEA1FFF383E0F80EA3C07387803C0EA
+700138E000E0A6EAF001007013C0EA7803383C0780EA3E0F381FFF00EA07FCEA01F01315
+7D941A>I<387F81F838FF8FFC387F9FFE3803FE1EEBF80CEBE000A25B5BAAEA7FFFB5FC
+7E17157F941A>114 D<487E1203A6387FFFE0B5FCA238038000AA1470A43801C1E013FF
+6C1380EB3F00141C7F9B1A>116 D<38FE0FE0A3EA0E00AD1301EA0F033807FFFE7EEA00
+FC17157F941A>I<387FC7FC00FF13FE007F13FC380E00E0A3380701C0A338038380A338
+01C700A3EA00EEA3137CA2133817157F941A>I E /Fi 41 123 df<EB07FCEB3FFF9038
+FE0780D803F013C03807E00FA2EA0FC0A3EC030091C7FCA3EC7FE0B6FCA2380FC007B3A2
+39FFFC7FFEA21F267FA522>12 D<123C127E12FFA4127E123C08087C8711>46
+D<131C133C13FC12FFA21200B3AA387FFFFCA216237CA21F>49 D<48B4FC000713C0381E
+07F0383803F8386001FC387C00FE12FE14FF147FA2127C003813FFC7FC14FEA2EB01FC14
+F8EB03F0EB07E01480EB0F00131E5B1370EBE003EA01C038038007380700061206380FFF
+FE5A5A4813FCB5FCA218237DA21F>I<48B4FC000713E0381E03F0383801F8003C13FC38
+7E00FEA3123EEA1C01000013FCA2EB03F8EB07F0EB0FC03801FF00A2380007E0EB01F014
+F8EB00FC14FE14FFA21210127C12FEA214FEA2387C01FC007013F8383E07F0380FFFC000
+01130018237DA21F>I<14381478A214F81301130313071306130C131C13381330136013
+E0EA01C01380EA03005A120E5A12185A12705AB612C0A2390001F800A790387FFFC0A21A
+237EA21F>I<0018130C001F137CEBFFF814F014E014C01480EBFC000018C7FCA513FF00
+1B13E0381F03F0381C00F8000813FCC7127EA3147FA2127812FCA3147E5A006013FC1270
+383801F8381E07E03807FFC03801FE0018237DA21F>I<EB1FC0EB7FF03801F0383803E0
+0C3807803E000F137EEA1F005AA2007E133C1400A338FE3FC0EB7FF0EB80F800FF13FCEB
+007C147E5A147FA4127EA4003E137E123F6C137C380F80F83807C1F03803FFC038007F00
+18237DA21F>I<1230123C003FB512C0A215804814005C5C38600018A200E05B485B5CC6
+485AA249C7FC1306130EA25BA2133CA25BA213F8A41201A66C5A13601A257DA41F>I<14
+1CA2143EA3147FA24A7EA39038019FC0A29038031FE0140F01077FEB0607A2010C7F1403
+011C7FEB1801A2496C7EA2017FB5FCA29039E0007F8049133FA2484880151F00038190C7
+120FA2486E7ED8FFF090B51280A229257EA42E>65 D<B612E015FC3903F800FFED1FC0ED
+07E06F7E6F7E82150082A2167FA31780AA1700A316FEA24B5A5E4B5A4B5AED1FC0EDFF80
+B648C7FC15E029257EA42F>68 D<B7FCA23903F8007FED0F8015071503A21501A3ED00C0
+1406A21600A2140E141EEBFFFEA2EBF81E140E1406A21660A291C7FC16C0A415011503A2
+ED0F80153FB7FCA223257EA428>I<B612FEA23803F800151F8181A281A3ED01801403A2
+92C7FCA25C5C90B5FCA2EBF80F8080A491C8FCAAB512F0A221257EA427>I<B500E0B512
+E0A23B03F80003F800AF90B6FCA29038F80003B0B500E0B512E0A22B257EA430>72
+D<B512E0A23803F800B3AFB512E0A213257EA417>I<B512F0A2D803F8C7FCB3A31503A3
+1506A3150EA2151E153E157CEC03FCB6FCA220257EA425>76 D<D8FFF8EDFFF86D5C0003
+EEFE00017EEC037EA36D1406A26D6C130CA26D6C1318A26D6C1330A36D6C1360A26D6C13
+C0A2903900FC0180A291387E0300A3EC3F06A2EC1F8CA2EC0FD8A2EC07F0A36E5AEA0780
+3CFFFC01C01FFFF8A235257EA43A>I<01FF1380000713E3380F80F7381E001F48130F48
+1307140312F81401A27E91C7FCB4FCEA7FE013FE383FFFE014F86C13FE00077F6C1480C6
+7E010313C0EB003FEC0FE01407A200C01303A315C07E6C13076C14806CEB0F0038FFC03E
+38E3FFF838803FE01B257DA422>83 D<B53B81FFFE01FFF0A23D07F0001FC0000F007013
+066C6C010F5CA26F7E6C6C5EA26D496C1338000017304B7E017F01195CA291388030FE01
+3F5E829139C0607F01011F5E03E0138190280FE0C03F83C7FCA29139F1801FC3010715C6
+17E69139FB000FEE010315EC02FF14FC6D486D5AA24A130301005DA24A130102785CA202
+306D5A3C257FA43F>87 D<EA07FF001F13E0383E03F0383F00F880147E121EC7FCA3EB1F
+FE3803FE7EEA0FC0EA1F00123E127E5AA314BEEA7E01383F073E391FFE1FE03807F00F1B
+187E971E>97 D<EAFFC0A2120FACEBC1FCEBCFFF9038FC0FC09038F007E09038C003F0A2
+EC01F8A215FCA815F8A2EC03F013E09038F007E090381C1F80390E0FFF00380C03F81E26
+7FA522>I<EB7FE03803FFF83807C07C381F80FC13005A007E1378140012FEA8127E127F
+6C130CEA1F80EBC0183807E0703803FFE038007F0016187E971B>I<ECFFC0A2140FAC13
+7F3803FFCF380FE0FF381F803F383F000FA2127EA212FEA8127EA27E141F381F803F380F
+C0EF3903FFCFFC3800FE0F1E267EA522>I<137F3803FFC03807C1F0380F80F8EA1F0048
+137C127E147E12FEA2B512FEA248C7FCA3127EA214067E6C130C380F80183807E0703803
+FFE038007F8017187E971C>I<EB1FC0EB7FF0EA01F83803E1F8120713C1380FC0F01400
+A7B5FCA2EA0FC0B3A2EAFFFEA215267EA513>I<3901FF07C00007EBDFE0380F83F1EA1F
+01393E00F800007E7FA6003E5B6C485A380F83E0EBFFC0001190C7FC0030C8FCA2123812
+3C383FFFE06C13FC806C7F481480383C003F48EB0FC000F81307A4007CEB0F806CEB1F00
+381F807E3807FFF8C613C01B247E971F>I<EAFFC0A2120FAC14FE9038C3FF809038CE0F
+C013D89038D007E013E0A213C0AF39FFFC7FFEA21F267EA522>I<120FEA1F80EA3FC0A4
+EA1F80EA0F00C7FCA7EA7FC0A2120FB3A2EAFFF8A20D277EA611>I<EAFFC0A2120FB3B0
+EAFFFCA20E267EA511>108 D<26FF80FE137F903A83FF81FFC03B0F8E0FC707E0019813
+CC903A9007E803F001A013F0A201C013E0AF3BFFFC7FFE3FFFA230187E9733>I<38FF80
+FE903883FF80390F8E0FC0139890389007E013A0A213C0AF39FFFC7FFEA21F187E9722>
+I<EB7F803803FFF03807C0F8381F807E48487EA2007EEB1F80A200FE14C0A8007E1480A2
+6CEB3F00A2381F807E6C6C5A3803FFF038007F801A187E971F>I<38FFC1FCEBCFFF390F
+FC1FC09038F007E001C013F0140315F8140115FCA8EC03F8A215F0EBE0079038F00FE090
+38DC1F809038CFFF00EBC3F801C0C7FCA9EAFFFCA21E237F9722>I<38FF83E0EB8FF838
+0F8C7CEB90FC13B013A01478EBE0005BAEEAFFFEA216187F9719>114
+D<3807F8C0EA1FFFEA3C07EA7001EAF000A300FC1300B47EEA7FFC7F383FFF80000F13C0
+120338001FE01303EAC001A212E014C0EAF00338FC078038EFFF00EAC3FC13187E9718>
+I<13C0A41201A312031207120F121FB512C0A2380FC000AC1460A63807E0C013E13801FF
+8038007E0013237FA218>I<39FFC07FE0A2000F1307B0140FA200071317EBE0673903FF
+C7FE38007F071F187E9722>I<39FFF80FF8A2390FC001C015803907E00300A26D5A0003
+1306EBF80E0001130C13FC00005B13FEEB7E30A26D5AA214E06D5AA26D5AA26DC7FCA21D
+187F9720>I<39FFF83FF0A2390FC00F003807E00E6C6C5A6D5A6C6C5A00001360EB7EC0
+6D5AA2131F6D7E497E80EB33F81361EBE0FC3801C07E3803807F3907003F8048131F39FF
+C07FF8A21D187F9720>120 D<39FFF80FF8A2390FC001C015803907E00300A26D5A0003
+1306EBF80E0001130C13FC00005B13FEEB7E30A26D5AA214E06D5AA26D5AA26DC7FCA213
+06A25B1230EA781CEAFC185B1370EA68E0EA7FC0001FC8FC1D237F9720>I<387FFFF8A2
+387C03F0EA700738600FE000E013C0EB1F80EAC03F1400137EEA00FE5B485A0003130C13
+F0EA07E0120FEBC01C381F8018003F1338387F0078387E01F8B5FCA216187E971B>I
+E /Fj 31 122 df<903803F07C90381E0DC69038380F0FEB701E01E0130EEC0C003801C0
+1CA548485A007FB512C03903803800A448485AA6000E5BA648485A001E7F38FF8FFC2020
+7E9F1B>11 D<EB03E0EB1C181338EB703C13E014383801C000A5485A387FFFF038038070
+A4380700E0A6380E01C0A6381C0380001E13C038FF0FF016207E9F19>I<903803F03F90
+391E09E0809039380F80C09039701F01E0EBE03E021E13C02601C01CC7FCA548485A007F
+B612803903803803A43A0700700700A6000EEBE00EA64848485A001EEBE01E3AFF8FF8FF
+C023207E9F26>14 D<13201360A4383061C0383C4380380E4E00EA0778EA01E0A2EA07B8
+EA1C9CEA708FEAE083EA0180A490C7FC12147AA117>42 D<EAFFF0A20C027E8A0F>45
+D<13181338EA01F8EA0E701200A513E0A6EA01C0A6EA0380A6EA07001380EAFFFC0E1E7B
+9D17>49 D<EB3F80EBC1E038010070000213785AA2000F137C1380A2EB00781206C712F8
+14F0EB01E014C0EB0380EB0700130E5B5B13605B485A380300201206000813405A383FFF
+C0481380B5FC161E7E9D17>I<13FFEA01FE1380A5EA0300A61206A65AA65AA65AA65AA6
+B4FCA2102D7EA10D>91 D<13FFEA01FEEA0006A5130CA61318A61330A61360A613C0A6EA
+0180A6EAFF00A2102D82A10D>93 D<EA07F8EA0C0CEA1E061307121C1200A313FFEA07C7
+EA1E07EA3C0E127800F01310A3131EEB2E2038784F40381F878014147D9317>97
+D<13FEEA0383380E0780121C0038130090C7FC12785AA45AA37E5BEA70026C5AEA1C18EA
+07E011147D9314>99 D<1438EB01F8EB00781438A21470A614E013FCEA0382EA0601121C
+EA3C00383801C0127812F0A438E00380A412F0EA700738380F00381C37803807C7E01520
+7D9F19>I<13F8EA070EEA0E07121C383803801278127012F0A2B5FC00F0C7FC5AA46C5A
+EA7002EA3004EA1C18EA07E011147D9314>I<EB07C0EB1C60EB30F01360EBE0E0EBC000
+1201A5485AEA3FFCEA0380A448C7FCA6120EA65A121EEAFFC014207F9F0E>I<140EEB3E
+11EBE1A33801C1C2380381E0EA07801301120FA3380703C01480EB8700EA04FC48C7FCA2
+1218121CEA0FFF14C014E0381800F04813305A5AA3006013606C13C0381C0700EA07FC18
+1F809417>I<13E0120712011200A2485AA6485AEB8F80EB90E013A0EBC0601380000713
+E01300A5380E01C0A6381C0380001E13C038FF8FF014207E9F19>I<EA01C0EA03E0A213
+C0EA0180C7FCA6EA0380121F12071203A2EA0700A6120EA65A121EEAFF800B1F7F9E0C>
+I<13E0120712011200A2EA01C0A6EA0380A6EA0700A6120EA65A121EEAFF800B207F9F0C
+>108 D<390387C07C391F9861863907A072073903C03403EB80380007EB7807EB0070A5
+000EEBE00EA64848485A001EEBE01E3AFFCFFCFFC022147E9326>I<38038F80381F90E0
+EA07A03803C0601380000713E01300A5380E01C0A6381C0380001E13C038FF8FF014147E
+9319>I<13FCEA0387380E0180381C00C04813E0A24813F012F0A438E001E0A214C01303
+00F0138038700700EA380E6C5AEA07E014147D9317>I<EBE3E03807EC383800F01C497E
+140F48487E1580A53903800F00A2140E141E141C5C38074070EB61C0011FC7FC90C8FCA3
+120EA4121EEAFFC0191D809319>I<EBFC2038038260EA0702381E01E0123C003813C012
+7812F0A438E00380A212F0A21307127038380F00EA1C37EA07C7EA0007A3130EA4131EEB
+FFC0131D7D9318>I<EA038E381FB380EA07C71203EB8300EA078090C7FCA5120EA65A12
+1EEAFFC011147E9312>I<EA01F9EA0607EA080312181301EA3802EA3C00121F13F0EA07
+FCEA01FEEA001FEA40071303A212601306EAF004EAC818EA87E010147F9312>I<1380EA
+0100A35A5A5A121EEAFFF8EA0E00A45AA65A1310A41320A2EA1840EA0F800D1C7C9B12>
+I<381C0380EAFC1FEA3C07EA1C03A238380700A6EA700EA4131EA25BEA305E381F9F8011
+147B9319>I<38FF83F8381E00E0001C13C01480121E380E01005B13025B12075BA25BEA
+039013A013E05B5B120190C7FC15147C9318>I<39FF9FE1FC393C078070391C03006014
+8015401580EA0E0790380D81001309EB19C21311380F21C4EA0720EB40C814E8EB80F0A2
+6C485A1460000213401E147C9321>I<381FF0FF3803C0780001137014403800E0C0EBE1
+80EB73001376133CA2131C132E134E1387EA0107380203801204380C01C0383C03E038FE
+07FC18147F9318>I<390FF83F803901E00E00EBC00C140813E000005B143014205C1370
+5CA20171C7FC1339133A133E133C133813181310A25BA25BEA70C0EAF08000F1C8FC12E6
+1278191D809318>I E /Fk 36 122 df<EB01C01303130F137FEA1FFFB5FC13BFEAE03F
+1200B3B1007FB512F0A31C2E7AAD28>49 D<EB3FE03801FFFE0007EBFF80D80F8013C039
+1E003FE00038EB1FF0007CEB0FF8007EEB07FCB4FC018013FEA21403A2EA7F00003E1307
+C7FC15FCA2EC0FF8A215F0EC1FE015C0EC3F80EC7F00147E14F8495A495A495A49C7FC01
+1E130E5B133849131E49131C485A48C7123C48B512FC5A5A5A4814F8B6FCA31F2E7CAD28
+>I<1578A215FCA34A7EA24A7EA24A7FA34A7FEC0E7F021E7FEC1C3FA202387F151F0278
+7FEC700FA202E07F1507010180ECC003A249486C7EA201078191C7FC498191B6FCA24981
+011CC7123F013C810138141FA24981160F01F081491407A2484881486C1403B549B512FC
+A336317DB03D>65 D<B712C016FC16FFD801FEC77FEE7FE0707E161F707EA2831607A416
+0FA25FA24C5A4C5A4C5A4B485ADB1FFEC7FC90B65AEEFF8049C7EA3FE0EE0FF0EE07FCA2
+707E83821880A718005E5F16074C5A4C5AEEFFF0B812C094C7FC16F831317DB039>I<91
+3A03FF800180023FEBF00349B5EAFC0701079038003F0FD91FF8EB079FD93FC0EB01FFD9
+FF807F4848C8127F4848153F0007161F49150F485A001F1607A2485A1703127FA24992C7
+FCA212FFA9127FA27FEF0380123FA26C7E1707000F17006C7E6D150E0003161E6C6C151C
+6C6C6C1478D93FC05CD91FF8EB03E0D907FFEB3F800101D9FFFEC7FCD9003F13F8020313
+8031317CB03A>I<B812E0A3C6903880007FEE0FF016031601A21600A21770A31738A215
+07A21700A35D5D5D91B5FCA3EC803F818181A592C8FCACB612C0A32D317EB033>70
+D<DA03FF1303027FEBF00749B5EAFC0F01079038007E1FD91FF0EB0FBFD97FC0EB03FF49
+487F4848C87E485A0007824848815B001F82A2484881A2127FA24992C7FC12FFAA0307B5
+12F8127F7FDB00011300123FA26C7EA2120F7F6C7E12036C7E6C6C7E6D6C5BD91FF8497E
+D907FFEB3E3F01019038FFFC1F6D6CEBF00F0203EB800335317CB03F>I<B6D8807FB512
+C0A3C60180C7387FC000B391B7FCA30280C7127FB3A3B6D8807FB512C0A33A317EB03F>
+I<B61280A3C6EB8000B3B3A7B61280A319317EB01E>I<B56C49B512C08080C66D903900
+03E0006E6E5AEBEFFC13E780EBE3FF01E17F01E07F6E7E143F816E7E6E7E6E7E14036E7E
+16806E13C0ED7FE0ED3FF0151F16F8ED0FFCED07FEED03FF6F13818117C1EE7FE1EE3FF1
+EE1FF9EE0FFD160717FF828282177F173FA2171F170F486C1507B500E014031701A23A31
+7EB03F>78 D<B712E016FEEEFF80C6D9800013E0EE3FF0EE0FF8EE07FCA2EE03FEA217FF
+A717FEA2EE07FC17F8160FEE3FE0EEFFC091B6120016F80280C8FCB3A2B67EA330317EB0
+37>80 D<007FB8FCA39039C00FF801D87E00EC003F007C82007882A200708200F01780A3
+481603A5C792C7FCB3AA017FB6FCA331307DAF38>84 D<B6D88003B51280A3C60180C738
+07C000715AB3AE137F4DC7FC80013F150EA26D6C5C6D6C5C6D6C5C6D6C495A903A00FF80
+1FC0023FB55A020F49C8FC020013E039317EB03E>I<B500FC91B5FCA3000390C8EA03C0
+6C17806E14076C170080017F150EA26E141E013F151C6E143C011F153880010F5D800107
+5DA26E130101035D6E13036D5D15806D4AC7FCA26F5A027F130EEDE01E023F131CEDF03C
+021F133815F8020F5BA2EDFCF002075B15FF6E5BA26E5BA26E90C8FCA3157EA2153CA238
+317EB03D>I<EBFFF0000313FF390F803F809038C00FE0486C6C7EA26E7ED80FC07FEA07
+80C7FCA414FF131FEBFFE33803FC03EA0FF0EA1FC0123FEA7F80A2EAFF00A31407A2387F
+800D393FC01DFE3A1FE078FFF03907FFE07FC6EB803F24207E9F27>97
+D<EA01F812FFA3120F1207ADEC3FE0ECFFFC9038FBE07F9039FF001F8049EB0FC04914E0
+49EB07F016F8A2ED03FCA316FEA816FCA3ED07F8A216F06DEB0FE06D14C001E7EB3F8090
+39C3C0FE00903880FFF89038003FC027327EB12D>I<EB0FFF017F13C03901FC01F03803
+F0033907E007F8120FEA1FC0003FEB03F0EC01E04848C7FCA312FFA8127FA36C6C131CA2
+001F14386C7E000714703903F001E03901FC07C039007FFF00EB0FF81E207D9F24>I<ED
+0FC0EC07FFA3EC007F153FADEB07F8EB3FFF9038FE07BF3903F801FF3907E0007F120F48
+48133F123FA2485AA312FFA8127FA36C7EA2121F6C6C137F000714FF2603F00313E03A01
+FC0F3FFE38007FFEEB0FF027327DB12D>I<EB0FFC90387FFF803901FC0FC03903F003E0
+3907E001F0000F14F8391FC000FC003F14FEA24848137E157FA212FFA290B6FCA20180C7
+FCA4127FA36C6C1307121F150E6C7E6C6C131C6C6C13783900FE03E090383FFFC0903807
+FE0020207E9F25>I<EB01FE90380FFF8090381FC3C090387F07E09038FE0FF0120113FC
+1203EC07E0EC018091C7FCA8B512FCA3D803FCC7FCB3A8387FFFF0A31C327EB119>I<90
+391FF007C09039FFFE3FE03A01F83F79F03907E00FC3000F14E19039C007E0E0001FECF0
+00A2003F80A5001F5CA2000F5CEBE00F00075C2603F83FC7FC3806FFFE380E1FF090C9FC
+121EA2121F7F90B57E6C14F015FC6C806C801680000F15C0003FC7127F007EEC1FE0007C
+140F00FC1407A4007EEC0FC0003E1580003F141FD80FC0EB7E003907F803FC0001B512F0
+D8001F90C7FC242F7E9F28>I<EA01F812FFA3120F1207ADEC07F8EC3FFEEC783F02C013
+809039F9801FC0EBFB0001FE14E05BA35BB3B500C3B5FCA328327DB12D>I<EA03C0487E
+487E487EA46C5A6C5A6C5AC8FCA9EA01F8127FA31207B3A7B51280A311337DB217>I<EA
+01F812FFA3120F1207B3B3A6B512C0A312327DB117>108 D<2703F007F8EB1FE000FFD9
+3FFEEBFFF8913A783F01E0FC02C090388300FE280FF1801FC6137F2607F30013CC01F602
+F8148001FC5CA3495CB3B500C3B5380FFFFCA33E207D9F43>I<3903F007F800FFEB3FFE
+EC783F02C013803A0FF1801FC03807F30001F614E013FCA35BB3B500C3B5FCA328207D9F
+2D>I<EB07FC90387FFFC03901FC07F03903F001F848486C7E4848137E001F147F003F15
+8049133F007F15C0A300FF15E0A8007F15C0A36C6CEB7F80A2001F15006C6C13FE00075C
+3903F803F83901FE0FF039007FFFC0D907FCC7FC23207E9F28>I<3901F83FE000FFEBFF
+FC9038FBE07F9039FF003F80D807FEEB1FC049EB0FE04914F0ED07F8A216FC1503A216FE
+A816FC1507A216F8A2ED0FF06D14E06DEB1FC06DEB3F809039FBC0FE009038F8FFF8EC3F
+C091C8FCABB512C0A3272E7E9F2D>I<3803F03F00FFEB7FC09038F1C3E01487390FF30F
+F0EA07F6A29038FC07E0EC03C091C7FCA25BB2B512E0A31C207E9F21>114
+D<3801FF86000713FEEA1F00003C133E48131E140E12F8A36C90C7FCB47E13FC387FFFC0
+6C13F0806C7F00077F00017FEA003F01001380143F0060131F00E0130FA27E15007E6C13
+1E6C131C38FF807838F3FFF038C07F8019207D9F20>I<131CA5133CA3137CA213FC1201
+12031207381FFFFEB5FCA2D803FCC7FCB0EC0380A71201EC0700EA00FEEB7F0EEB3FFCEB
+07F0192E7FAD1F>I<D801F8EB07E000FFEB03FFA3000FEB003F0007141FB3153FA20003
+147FA26C6CEBDFF03A00FE039FFF90387FFF1FEB0FFC28207D9F2D>I<B5EB1FFCA3D80F
+F8EB03C0000715806D1307000315007F0001140E7F6C5CA2EC803C017F1338ECC078013F
+1370ECE0F0011F5B14F1010F5B14F9903807FB80A214FF6D90C7FCA26D5AA26D5AA21478
+A226207E9F2B>I<B53A1FFFE03FF8A33C0FF000FE0007806D150300076EEB0700816D5D
+00039138FF800EA26C6C486D5A15DF01FF153C6C9039038FE038A2D97F876D5A150702C7
+14F0D93FCF6D5AECCE03D91FFEEBF9C09138FC01FD16FF010F5D4A7EA26D486DC7FCA201
+03147E4A133EA26D48131C35207E9F3A>I<3A7FFF807FFCA33A03FC000F006C6C131E6C
+6C5BEC803890387FC078013F5B90381FE1E090380FF3C0ECFF806D90C7FC6D5A13016D7E
+81815B903803DFE09038078FF08190380F07FC90381E03FEEB3C01496C7E4914804848EB
+7FC00003EC3FE026FFFC01B5FCA328207F9F2B>I<B5EB1FFCA3D80FF8EB03C000071580
+6D1307000315007F0001140E7F6C5CA2EC803C017F1338ECC078013F1370ECE0F0011F5B
+14F1010F5B14F9903807FB80A214FF6D90C7FCA26D5AA26D5AA21478A21470A214F05C13
+01007C5BEAFE035C49C8FC5BEAFC1EEA787CEA3FF0EA0FC0262E7E9F2B>I
+E /Fl 1 14 df<14FF010713E090381F00F80178131E01E01307D80180EB018048C812C0
+00061560481530A248151848150CA2481506A4481503A900601506A46C150CA26C15186C
+1530A26C15606C15C06C6CEB0180D800E0EB07000178131E011F13F8903807FFE0010090
+C7FC282B7EA02D>13 D E /Fm 46 122 df<123C127FEAFF80A213C0A3127F123E1200A2
+EA0180A3EA0300A21206120E5A5A12100A157B8813>44 D<121C127FA2EAFF80A3EA7F00
+A2121C09097B8813>46 D<130E131E137EEA07FE12FFA212F81200B3ABB512FEA317277B
+A622>49 D<EBFF80000713F04813FC381E03FE393800FF80007C133F00FE14C06C131F15
+E0140FA2127E003C131FC7FC15C0A2EC3F801500147E5C5C495A495AEB078049C7FC131E
+4913E013705B3901C001C0EA0380EA0600000FB5FC5A5A5AB61280A31B277DA622>I<EB
+7F803803FFF04813FC380F81FE381F007FEA3F80EC3F80A3121F1300C7EA7F00A2147E5C
+495AEB07F0EBFFC0A2EB01F8EB007E801580EC1FC0A215E0A2123C127EB4FCA215C0143F
+481480007CEB7F00383F01FE6CB45A000713F0C613801B277DA622>I<140FA25C5C5C5C
+5BA2EB03BFEB073F130E131C133C1338137013E0EA01C0EA038012071300120E5A5A5A12
+F0B612F8A3C7EA7F00A890381FFFF8A31D277EA622>I<00181303381F801FEBFFFE5C5C
+5C14C091C7FC001CC8FCA7EB7FC0381DFFF8381F80FC381E003F1208C7EA1F8015C0A215
+E0A21218127C12FEA315C05A0078EB3F80A26CEB7F00381F01FE6CB45A000313F0C61380
+1B277DA622>I<1238123E003FB512F0A34814E015C0158015003870000EA25C485B5C5C
+C6485AA2495A130791C7FC5B5B131E133EA2137E137CA213FCA41201A76C5A13701C297C
+A822>55 D<EC0780A24A7EA34A7EA24A7EA3EC77F8A2ECF7FC14E3A2903801C1FEA20103
+7F1480A249486C7EA24980010E133FA2496D7EA2013FB57EA39039700007F8A201F08049
+1303000181491301A2000381D8FFFE013F13FCA32E297EA833>65
+D<B612F815FF16C03A03F8001FE0ED0FF0ED07F8150316FCA21501A3150316F8A2ED07F0
+150FED1FC0EDFF8090B5EAFE00EDFFC09039F8000FF0ED03F8ED01FC16FE1500A216FFA6
+16FE1501ED03FC1507ED1FF8B712E016C0EDFE0028297DA830>I<91387FE003903907FF
+FC07011FEBFF0F90397FF00F9F9039FF0001FFD801FC7F4848147F4848143F4848141F48
+5A160F485A1607127FA290C9FC5AA97E7F1607123FA26C7E160E6C7E6C6C141C6C6C143C
+6C6C14786CB4EB01F090397FF007C0011FB512800107EBFE009038007FF028297CA831>
+I<B712E0A33903FC001FED07F01501A215001670A3913801C0781638A302031300A2140F
+90B5FCA3EBFC0F1403A20201130EA3161C91C7FCA3163C1638167816F815011503151FB7
+12F0A327297EA82C>69 D<B712C0A33903FC003FED0FE015031501A21500A316F0913801
+C070A316001403A2140F90B5FCA3EBFC0F1403A21401A491C8FCA9B512FCA324297EA82A
+>I<91387FE003903907FFFC07011FEBFF0F90397FF00F9F9039FF0001FFD801FC7F4848
+80484880484880485A82485A82127FA290CAFC5AA892B512F87E7F03001300123FA26C7E
+A26C7E6C7E6C7E6C7E6CB45B90387FF007011FB5129F0107EBFE0F9039007FF0032D297C
+A835>I<B5D8F00FB5FCA3D803FCC7EA3FC0AF90B7FCA301FCC7123FB1B5D8F00FB5FCA3
+30297EA835>I<B512F0A33803FC00B3B1B512F0A314297EA819>I<D8FFFE92383FFF80A2
+6D5D0003EFE000A2D9BF8014EFA2D99FC0EB01CFA2D98FE0EB038FA3D987F0EB070FA2D9
+83F8130EA2D981FC131CA3D980FE1338A2027F1370A291383F80E0A391381FC1C0A29138
+0FE380A2913807F700A3EC03FEA26E5AA26E5AD8FFFE0203B51280A2157039297DA840>
+77 D<D8FFFCEC7FFF7F7F00036DEB01C080EBBFE0139F80EB8FF8EB87FCEB83FEEB81FF
+01801380147F15C0EC3FE0EC1FF0EC0FF8EC07FC140315FEEC01FF6E1381ED7FC1ED3FE1
+ED1FF1150F16F9ED07FDED03FF8181167FA2163F161F160F1607D8FFFE14031601A23029
+7EA835>I<B612F815FF16C03A03FC003FE0ED07F0ED03F816FC150116FEA716FC150316
+F8ED07F0ED3FE090B61280EDFE0001FCC8FCB0B512F0A327297EA82E>80
+D<B612E015FE6F7E3A03FC003FE0ED0FF06F7E6F7E150182A65E4B5A1507ED0FE0ED3FC0
+90B500FEC7FCA29039FC00FF80ED3FC06F7E6F7E6F7EA9170EA21503923801FC1CB538F0
+00FEEE7FF8EE0FE02F297EA832>82 D<9038FF80600003EBF0E0000F13F8381F80FD383F
+001F003E1307481303A200FC1301A214007EA26C140013C0EA7FFCEBFFE06C13F86C13FE
+80000714806C14C0C6FC010F13E0EB007FEC1FF0140F140700E01303A46C14E0A26C1307
+6C14C0B4EB0F80EBE03F39E3FFFE0000E15B38C01FF01C297CA825>I<B500F0EBFFFEA3
+D803FCC7EA0380B3AA0001ED07007F0000150E137F6D143CD91FC05B90390FF003F06DB5
+5A01001480DA1FFCC7FC2F297EA834>85 D<B500F0EB7FFFA3D803FEC7EA01C00001ED03
+80A26D14076C16006E5B017F140E80013F5CA26E133C011F14386E1378010F1470800107
+5CA26D6C485AA2ECFE0301015CECFF076D91C7FC1587EC7F8EA215DEEC3FDC15FC6E5AA2
+6E5AA36E5AA26E5AA230297FA833>I<B53CE07FFFE01FFFC0A32803FC0003FCC7EA7000
+A26D6D7E000160A26D6E13016C604B138002801503017F5F4B13C0D93FC0013F49C7FCA2
+913AE00E1FE00F011F160E17F09126F01C0F131E010F161C033C13F8902707F838075BA2
+037813FC902703FC70035BA2913AFEE001FEF001015E02FF14FF4B7E6D5EA26E486D5AA3
+6EC76CC8FCA2023E80021E141EA242297FA845>I<3803FF80000F13F0381F01FC383F80
+FE147F801580EA1F00C7FCA4EB3FFF3801FC3FEA0FE0EA1F80EA3F00127E5AA4145F007E
+13DF393F839FFC381FFE0F3803FC031E1B7E9A21>97 D<EAFFE0A3120FACEBE1FE9038EF
+FF809038FE07E09038F803F09038F001F89038E000FCA2157EA2157FA8157EA315FCA290
+38F001F89038F803F090389C0FE090380FFF80390E01FC00202A7EA925>I<EB3FF03801
+FFFC3803F03E380FC07FEA1F80EA3F00A248133E007E90C7FCA212FEA7127EA2127F6CEB
+03801380001FEB0700380FE00E3803F83C3801FFF838003FC0191B7E9A1E>I<EC7FF0A3
+1407ACEB3F873801FFF73807F03F380FC00F381F8007EA3F00A2127EA312FEA8127EA27E
+A2381F800F380FC01F3907E07FFF3801FFE738007F87202A7EA925>I<EB3FC03801FFF0
+3803E07C380F803E001F7F130048EB0F80127E15C0A200FE1307A2B6FCA248C8FCA3127E
+A2127F6CEB01C07E390F8003803907C007003803F01E3800FFFCEB3FE01A1B7E9A1F>I<
+EB07F8EB3FFCEB7E3E3801FC7FEA03F813F01207143E1400A7B512C0A33807F000B3A338
+7FFF80A3182A7EA915>I<9038FF80F00003EBE3F8390FC1FE1C391F007C7C48137E003E
+EB3E10007EEB3F00A6003E133E003F137E6C137C380FC1F8380BFFE00018138090C8FC12
+38A2123C383FFFF814FF6C14C06C14E06C14F0121F383C0007007CEB01F8481300A4007C
+EB01F0A2003FEB07E0390FC01F806CB5120038007FF01E287E9A22>I<EAFFE0A3120FAC
+147E9038E1FF809038E30FC001E413E0EBE80701F813F013F0A213E0B039FFFE3FFFA320
+2A7DA925>I<1207EA0F80EA1FC0EA3FE0A3EA1FC0EA0F80EA0700C7FCA7EAFFE0A3120F
+B3A3EAFFFEA30F2B7EAA12>I<EAFFE0A3120FB3B2EAFFFEA30F2A7EA912>108
+D<26FFC07FEB1FC0903AC1FFC07FF0903AC307E0C1F8D80FC49038F101FC9039C803F200
+01D801FE7F01D05BA201E05BB03CFFFE3FFF8FFFE0A3331B7D9A38>I<38FFC07E9038C1
+FF809038C30FC0D80FC413E0EBC80701D813F013D0A213E0B039FFFE3FFFA3201B7D9A25
+>I<EB3FE03801FFFC3803F07E390FC01F80391F800FC0393F0007E0A2007EEB03F0A300
+FE14F8A8007E14F0A26CEB07E0A2391F800FC0390FC01F803907F07F003801FFFC38003F
+E01D1B7E9A22>I<38FFE1FE9038EFFF809038FE0FE0390FF803F09038F001F801E013FC
+140015FEA2157FA8157E15FEA215FC140101F013F89038F807F09038FC0FE09038EFFF80
+9038E1FC0001E0C7FCA9EAFFFEA320277E9A25>I<38FFC1F0EBC7FCEBC63E380FCC7F13
+D813D0A2EBF03EEBE000B0B5FCA3181B7F9A1B>114 D<3803FE30380FFFF0EA3E03EA78
+00127000F01370A27E00FE1300EAFFE06CB4FC14C06C13E06C13F0000713F8C6FCEB07FC
+130000E0137C143C7E14387E6C137038FF01E038E7FFC000C11300161B7E9A1B>I<13E0
+A41201A31203A21207120F381FFFE0B5FCA2380FE000AD1470A73807F0E0000313C03801
+FF8038007F0014267FA51A>I<39FFE07FF0A3000F1307B2140FA2000713173903F067FF
+3801FFC738007F87201B7D9A25>I<39FFFC03FFA3390FF000F0000714E07F0003EB01C0
+A2EBFC0300011480EBFE070000140013FFEB7F0EA2149EEB3F9C14FC6D5AA26D5AA36D5A
+A26D5AA2201B7F9A23>I<3BFFFC7FFC1FFCA33B0FE00FE001C02607F007EB0380A201F8
+EBF00700031600EC0FF801FC5C0001150EEC1FFC2600FE1C5B15FE9039FF387E3C017F14
+38EC787F6D486C5A16F0ECE01F011F5CA26D486C5AA2EC800701075CA22E1B7F9A31>I<
+39FFFC1FFEA33907F003803803F8079038FC0F003801FE1E00005BEB7F3814F86D5A6D5A
+130F806D7E130F497EEB3CFEEB38FFEB787F9038F03F803901E01FC0D803C013E0EB800F
+39FFF03FFFA3201B7F9A23>I<39FFFC03FFA3390FF000F0000714E07F0003EB01C0A2EB
+FC0300011480EBFE070000140013FFEB7F0EA2149EEB3F9C14FC6D5AA26D5AA36D5AA26D
+5AA25CA21307003890C7FCEA7C0FEAFE0E131E131C5BEA74F0EA3FE0EA0F8020277F9A23
+>I E /Fn 75 127 df<127012F8B012701200A5127012F8A31270051C779B18>33
+D<EA4010EAE038EAF078EAE038AAEA60300D0E7B9C18>I<EA0306EA078FA6387FFFC0B5
+12E0A26C13C0380F1E00A6387FFFC0B512E0A26C13C0381E3C00A6EA0C18131C7E9B18>
+I<13C01201A3EA03F0EA0FFCEA3FFEEA7DCFEA71C738E1C38013C7A338F1C0001279123F
+6C7EEA0FF8EA01FC13DE13CF13C73861C38012F1A212E1EBC7001271EA79DEEA3FFEEA1F
+F8EA07E0EA01C0A3120011247D9F18>I<EA3803387C0780A2EAEE0F1400A25B131EA213
+3EEA7C3CA2EA387CEA0078A213F85B12015BA212035BA21207EB8380EB87C0120FEB0EE0
+A2121F121EA2123E383C07C0A23818038013247E9F18>I<EA01C0EA07E0487EEA0E7048
+7EA4EB73F813F313E3380FC1C0EBC38013831303381F0700EA3F87EA7B8EEA71CEEAE1FC
+12E0137CEB7870A2EA70FE387FFFE0EA3FC7380F03C0151C7F9B18>I<1238127CA2127E
+123E120EA3121CA2123812F812F012C0070E789B18>I<137013F0EA01E0EA03C0EA0780
+EA0F00121E121C5AA25AA45AA81270A47EA27E121E7EEA0780EA03C0EA01F0120013700C
+24799F18>I<126012F012787E7E7EEA07801203EA01C0A2EA00E0A41370A813E0A4EA01
+C0A2EA03801207EA0F00121E5A5A5A12600C247C9F18>I<EA01C0A4EA41C138F1C780EA
+FDDF387FFF00EA1FFCEA07F0A2EA1FFCEA7FFF38FDDF80EAF1C73841C100EA01C0A41114
+7D9718>I<136013F0A7387FFFC0B512E0A26C13C03800F000A7136013147E9718>I<121C
+123E127E127F123F121F1207120E121E127C12F81260080C788518>I<387FFFC0B512E0
+A26C13C013047E8F18>I<1230127812FCA2127812300606778518>I<1303EB0780A2130F
+14005B131EA2133E133C137C1378A213F85B12015B12035BA212075B120F90C7FCA25A12
+1E123E123CA2127C127812F85AA2126011247D9F18>I<EA01F0EA07FC487EEA1F1FEA1C
+0738380380007813C0EA7001A238E000E0A9EAF001007013C0A2EA780300381380381C07
+00EA1F1FEA0FFE6C5AEA01F0131C7E9B18>I<EA01801203A21207120F123F12FF12FB12
+431203B0EA7FFCEAFFFEEA7FFC0F1C7B9B18>I<EA03F0EA0FFEEA3FFF387C0F80387003
+C0EAE00138F000E0A21260C7FCA2EB01C0A21303EB0780EB0F00131E5B5B5B485AEA07C0
+485A381E00E05AEA7FFFB5FC7E131C7E9B18>I<131F5B1377A213E7120113C7EA038712
+071307120E121E123C1238127812F0B512F8A338000700A6EB7FF0A3151C7F9B18>52
+D<137E48B4FC00071380380F83C0EA1E03121C3838018090C7FC5AA2EAE1F8EAE7FEB5FC
+38FE078038F803C0EAF001EB00E05A7E1270A3383801C0EA3C03381E0780380FFF006C5A
+EA01F8131C7E9B18>54 D<1230127812FCA2127812301200A81230127812FCA212781230
+0614779318>58 D<1218123C127EA2123C12181200A81218123C127EA2123E121E120E12
+1C123C127812F01260071A789318>I<14C0EB03E01307EB1FC0EB3F80EBFE00485AEA07
+F0485AEA3F8048C7FC12FCA2127F6C7EEA0FE06C7EEA01FC6C7EEB3F80EB1FC0EB07E013
+03EB00C013187E9918>I<387FFFC0B512E0A3C8FCA4B512E0A36C13C0130C7E9318>I<12
+6012F87E127F6C7EEA0FE06C7EEA01FC6C7EEB3F80EB1FC0EB07E0A2EB1FC0EB3F80EBFE
+00485AEA07F0485AEA3F8048C7FC12FC5A126013187E9918>I<EA0FF0EA3FFC48B4FCEA
+700F38F00380A2EA600738000F00133E5BEA01F05B485AA55BC8FCA5EA0380487EA36C5A
+111C7D9B18>I<137013F8A213D8A2EA01DCA3138CEA038EA4EA0707A5380FFF80A3EA0E
+03381C01C0A3387F07F000FF13F8007F13F0151C7F9B18>65 D<EA7FF8EAFFFE6C7E381C
+0F80EB03C0A2EB01E01300A214F01470A814F014E0A2130114C01303EB0F80387FFF0048
+5AEA7FF8141C7F9B18>68 D<B512F0A3381C0070A41400A2130EA3EA1FFEA3EA1C0EA390
+C7FCA21438A5B512F8A3151C7F9B18>I<B512F8A3381C0038A41400A21307A3EA1FFFA3
+EA1C07A390C7FCA7EAFFC0A3151C7F9B18>I<387F07F038FF8FF8387F07F0381C01C0A9
+EA1FFFA3EA1C01AA387F07F038FF8FF8387F07F0151C7F9B18>72
+D<EA7FFFB512806C1300EA01C0B3A4EA7FFFB512806C1300111C7D9B18>I<EAFFC0A300
+1CC7FCB114E0A5B5FCA3131C7E9B18>76 D<387E07F038FF0FF8387F07F0381D81C0A313
+C1121CA213E1A313611371A213311339A31319A2131D130DA3EA7F07EAFF87EA7F03151C
+7F9B18>78 D<EA0FFE383FFF804813C0EA7803EA700100F013E0EAE000B0EAF001007013
+C0EA7C07EA7FFF6C1380380FFE00131C7E9B18>I<EAFFFEEBFF8014C0EA1C03EB01E013
+001470A514E01301EB03C0EA1FFF1480EBFE00001CC7FCA8B47EA3141C7F9B18>I<EA7F
+F8EAFFFE6C7E381C0F80130314C01301A313031480130F381FFF005BA2EA1C0F7FEB0380
+A5149CA3387F01F8EAFF81387F00F0161C7F9B18>82 D<3803F1C0EA1FFF5AEA7C0FEA70
+03EAE001A390C7FC12701278123FEA1FF0EA07FEC67EEB0F80EB03C01301EB00E0A21260
+12E0130100F013C038F80780B5FCEBFE00EAE7F8131C7E9B18>I<387FFFF8B5FCA238E0
+7038A400001300B2EA07FFA3151C7F9B18>I<38FF83FEA3381C0070B36C13E0EA0F0138
+0783C03803FF806C1300EA007C171C809B18>I<38FE03F8EAFF07EAFE03381C01C0EA1E
+03000E1380EA0F0700071300A2EA038EA2EA01DCA3EA00F8A21370A9EA01FC487E6C5A15
+1C7F9B18>89 D<EAFFF8A3EAE000B3ACEAFFF8A30D24779F18>91
+D<126012F0A27E1278127C123CA2123E121E121F7EA27F12077F1203A27F12017F12007F
+1378A2137C133C133E131EA2131F7F14801307A2EB030011247D9F18>I<EAFFF8A3EA00
+38B3ACEAFFF8A30D247F9F18>I<EA0180EA07C0EA1FF0EA7EFCEAF83EEAE00E0F067C9B
+18>I<387FFFC0B512E0A26C13C013047E7F18>I<1206121E123E12381270A212E0A312F8
+12FC127CA21238070E789E18>I<EA0FF0EA1FFC487EEA3C0FEA180738000380A213FF12
+07121FEA7F03127812E0A3EAF007EA780F383FFFF8EA1FFDEA07F015147E9318>I<127E
+12FE127E120EA5133EEBFF80000F13C0EBC1E01380EB0070120E1438A6000F1370A2EB80
+E013C1EBFFC0000E138038063E00151C809B18>I<EA01FEEA07FF001F1380EA3E073838
+030048C7FCA25AA61270EB01C01238EA3E03381FFF8000071300EA01FC12147D9318>I<
+EB1F80133F131F1303A5EA03E3EA0FFBEA1FFFEA3C1FEA380FEA7007130312E0A6EA7007
+A2EA380FEA3C1F381FFFF0380FFBF83803E3F0151C7E9B18>I<EA01F0EA07FCEA1FFEEA
+3E0F38380780EA7003A238E001C0A2B5FCA300E0C7FC1270EB01C01238EA3E07381FFF80
+00071300EA01F812147D9318>I<EB1F80EB7FC0EBFFE013E13801C0C01400A3387FFFC0
+B5FCA23801C000AEEA7FFFA3131C7F9B18>I<3801E1F03807FFF85A381E1E30381C0E00
+487EA5EA1C0EEA1E1EEA1FFC5BEA39E00038C7FC7EEA1FFEEBFFC04813E0387801F03870
+0070481338A4007813F0EA7E03381FFFC06C13803801FC00151F7F9318>I<127E12FE12
+7E120EA5133EEBFF80000F13C013C1EB80E01300120EAB387FC7FC38FFE7FE387FC7FC17
+1C809B18>I<EA0380EA07C0A3EA0380C7FCA4EA7FC012FF127F1201AEB5FCA3101D7C9C
+18>I<EAFFC0A31201B3A4B51280A3111C7D9B18>108 D<38F9C1C038FFF7F013FF383E3E
+38EA3C3CA2EA3838AB38FE3E3EEB7E7EEB3E3E1714809318>I<EA7E3E38FEFF80007F13
+C0EA0FC1EB80E01300120EAB387FC7FC38FFE7FE387FC7FC1714809318>I<EA01F0EA0F
+FE487E383E0F80EA3803387001C0A238E000E0A5EAF001007013C0EA7803383C0780EA3E
+0F381FFF006C5AEA01F013147E9318>I<EA7E3E38FEFF80007F13C0380FC1E01380EB00
+70120E1438A6000F1370A2EB80E013C1EBFFC0000E1380EB3E0090C7FCA7EA7FC0487E6C
+5A151E809318>I<3801F380EA07FBEA1FFFEA3E1FEA380FEA7007A2EAE003A6EA7007A2
+EA380FEA3C1FEA1FFFEA0FFBEA03E3EA0003A7EB1FF0EB3FF8EB1FF0151E7E9318>I<38
+FF0FC0EB3FE0EB7FF0EA07F0EBE060EBC0005BA290C7FCA9EAFFFC7F5B14147E9318>I<
+EA07F7EA3FFF5AEA780FEAE007A3007CC7FCEA7FE0EA1FFCEA03FEEA001F38600780EAE0
+03A212F038F80F00B5FC13FCEAE7F011147D9318>I<487E1203A4387FFFC0B5FCA23803
+8000A9144014E0A33801C1C013FF6C1380EB3E0013197F9818>I<387E07E0EAFE0FEA7E
+07EA0E00AC1301EA0F033807FFFC6C13FE3801FCFC1714809318>I<387F8FF000FF13F8
+007F13F0381C01C0380E0380A338070700A3138FEA038EA3EA01DCA3EA00F8A213701514
+7F9318>I<38FF07F8138F1307383800E0A4381C01C0137113F9A213D9EA1DDD000D1380
+A3138DEA0F8FA23807070015147F9318>I<387F8FF0139F138F380F0700EA078EEA039E
+EA01DC13F81200137013F07FEA01DCEA039E138EEA0707000E1380387F8FF000FF13F800
+7F13F015147F9318>I<387F8FF000FF13F8007F13F0380E01C0EB0380A21207EB0700A2
+EA0387A2138EEA01CEA213CC120013DC1378A31370A313F05B1279EA7BC0EA7F806CC7FC
+121E151E7F9318>I<383FFFF05AA2387001E0EB03C0EB078038000F00131E5B13F8485A
+EA03C0485A380F0070121E5A5AB512F0A314147F9318>I<EB07E0131F137FEB780013E0
+AB1201EA7FC0485AA26C7EEA01E01200AB1378EB7FE0131F130713247E9F18>I<126012
+F0B3B012600424769F18>I<127CB4FC13C01203C67EAB7FEB7FC0EB3FE0A2EB7FC0EBF0
+005BABEA03C012FF90C7FC127C13247E9F18>I<EA060CEA1F1EEA3FBEEAFBF8EAF1F0EA
+60C00F067C9B18>I E /Fo 74 123 df<90381F83E09038F06E303901C07878380380F8
+903800F03048EB7000A7B612803907007000B2383FE3FF1D20809F1B>11
+D<133FEBE0C0EA01C0380381E0EA0701A290C7FCA6B512E0EA0700B2383FC3FC1620809F
+19>I<EB3FE013E0EA01C1EA0381EA0700A8B5FCEA0700B2383FE7FC1620809F19>I<9038
+1F81F89038F04F043901C07C06390380F80FEB00F05A0270C7FCA6B7FC3907007007B23A
+3FE3FE3FE02320809F26>I<EA7038EAF87CEAFC7EA2EA743AEA0402A3EA0804A2EA1008
+A2EA2010EA40200F0E7F9F17>34 D<127012F812FCA212741204A31208A21210A2122012
+40060E7C9F0D>39 D<13401380EA01005A12061204120C5AA212381230A212701260A412
+E0AC1260A412701230A212381218A27E120412067E7EEA008013400A2E7BA112>I<7E12
+407E12307E1208120C7EA212077EA213801201A413C0AC1380A412031300A25A1206A25A
+120812185A12205A5A0A2E7EA112>I<127012F012F8A212781208A31210A31220A21240
+050E7C840D>44 D<EAFFF0A20C02808A0F>I<127012F8A3127005057C840D>I<EA03F0EA
+0E1C487EEA1806EA380738700380A400F013C0AD00701380A3EA780700381300EA1806EA
+1C0E6C5AEA03F0121F7E9D17>48 D<13801203120F12F31203B3A6EA07C0EAFFFE0F1E7C
+9D17>I<EA03F0EA0C1CEA100E487E00401380128000F013C0EAF803A3EA200712001480
+A2EB0F00130E5B5B5B13605B485A48C7FC000613405A5A00101380EA3FFF5AB5FC121E7E
+9D17>I<EA03F0EA0C1CEA100EEA200F007813801307A2EA380F12001400A2131E131C13
+70EA07F0EA003C130E130FEB0780A214C0122012F8A300F013801240EB0F00EA200EEA18
+3CEA07F0121F7E9D17>I<1306A2130EA2131E132EA2134E138EA2EA010E1202A2120412
+08A212101220A2124012C0B512F038000E00A7EBFFE0141E7F9D17>I<EA1803EA1FFE5B
+5B13E00010C7FCA6EA11F0EA161CEA180EEA10071480EA0003A214C0A3127012F0A200E0
+13801240EB0700EA20066C5AEA0838EA07E0121F7E9D17>I<137CEA0182EA0701380E03
+80EA0C0712183838030090C7FC12781270A2EAF1F0EAF21CEAF406EAF807EB0380A200F0
+13C0A51270A214801238EB07001218EA0C0E6C5AEA01F0121F7E9D17>I<1240387FFFE0
+14C0A23840008038800100A21302485AA25B5BA25BA21360A213E05B1201A41203A76C5A
+131F7E9D17>I<EA03F0EA0C0CEA1006EA3003382001801260A3127038780300123EEA3F
+06EA1FC8EA0FF0EA03F8487EEA0C7EEA103F38300F80EA6007EB01C012C01300A31480EA
+600100201300EA1002EA0C0CEA03F0121F7E9D17>I<EA03F0EA0E18487E487E13071270
+EB038012F0A214C0A5EA7007A21238EA180BEA0E13EA03E338000380A3EB07001230EA78
+06130EEA700CEA2018EA1070EA0FC0121F7E9D17>I<127012F8A312701200AA127012F8
+A3127005147C930D>I<127012F8A312701200AA127012F012F8A212781208A31210A312
+20A21240051D7C930D>I<5B497EA3497EA3EB09E0A3EB10F0A3EB2078A3497EA2EBC03E
+EB801EA248B5FCEB000FA20002EB0780A348EB03C0A2120C001E14E039FF801FFE1F207F
+9F22>65 D<B512E0380F0078141EA2801580A515005C141E147CEBFFF0EB007C141FEC0F
+80EC07C0140315E0A515C014071580EC0F00143EB512F01B1F7E9E20>I<90380FE01090
+38381C309038E002703803C00139078000F048C71270121E15305A1510127C127800F814
+00A91278007C1410123CA26C1420A27E6C6C13406C6C13803900E00300EB380CEB0FF01C
+217E9F21>I<B512F83807801EEC0780EC03C0EC01E0EC00F015701578A2153CA3153EA8
+153CA2157C1578A215F0EC01E0EC03C0EC0780EC1E00B512F81F1F7F9E23>I<B6128038
+0F000F14031401140015C01540A314401500A214C0130113FF130113001440A3EC0020A3
+1540A315C01401EC0380140FB6FC1B1F7E9E1F>I<B61280380780071401A2140015C015
+40A4EC2000A3146014E013FF138014601420A391C7FCA87FEAFFFE1A1F7F9E1E>I<9038
+0FE0109038381C309038E002703803C00139078000F048C71270121E15305A1510127C12
+7800F81400A7EC3FFEEC01F000781300127C123CA27EA27E6C7E3903C001703900E00230
+9038380C1090380FF0001F217E9F24>I<39FFF07FF8390F000780AD90B5FCEB0007AF39
+FFF07FF81D1F7E9E22>I<EAFFF0EA0F00B3ABEAFFF00C1F7E9E10>I<EAFFF8EA0F8090C7
+FCB21402A414061404A2140C141C147CB512FC171F7E9E1C>76 D<B46CEB07FE000715C0
+A2D805C0130BA2D804E01313A301701323A26D1343A36D1383A290380E0103A3EB0702A3
+EB0384A2EB01C8A3EB00F0A21460121FD8FFE0EB7FFE271F7F9E2A>I<B4EB0FF8390F80
+03E0EC0080EA0BC0EA09E0A2EA08F01378A27F7FA27FEB0780A2EB03C0EB01E0A2EB00F0
+1478A2143C141EA2140F1407A214031401123E38FF80001D1F7E9E22>I<EB1FE0EB7038
+3801C00E48487E39070003804814C0001EEB01E048EB00F0A2007C14F8A20078147800F8
+147CA900781478007C14F8A2003C14F0003E1301001E14E06CEB03C06C14803903800700
+3801E01E38007038EB1FE01E217E9F23>I<B512E0380F007C141E80EC0780A215C0A415
+80A2EC0F00141E147CEBFFE090C8FCAEEAFFF01A1F7E9E1F>I<EB1FE0EB70383801C00E
+48487E39070003804814C0001EEB01E0003E14F0003C1300007C14F8A20078147800F814
+7CA900781478007C14F8A2003C14F0383E0781391E0841E0390F1023C000071480390390
+17003801D01E3900783804EB1FF8EB001CEC0C0CEC0E1CEC0FF8A2140715F0EC01E01E29
+7E9F23>I<B57E380F00F0143C8080A21580A41500A2141E5C14F0EBFF80EB01C0EB0070
+A280143CA3143EA31504143F141FEC0F0839FFF00788C7EA01F01E207E9E21>I<3803F0
+40380C0CC0EA1803EA3001EA6000A212E01440A36C13007E127CEA7F80EA3FF86CB4FC00
+071380C613C0EB1FE013031301EB00F014707EA46C136014E06C13C038F8018038C60300
+EA81FC14217E9F19>I<007FB512E038780F010060EB006000401420A200C01430008014
+10A400001400B3497E3803FFFC1C1F7E9E21>I<39FFF00FF8390F0003E0EC0080B3A46C
+EB01001380120314026C6C5A6C6C5AEB3830EB0FC01D207E9E22>I<39FFF003FE391F80
+00F86CC7126015206C6C1340A36C6C1380A2EBE00100011400A23800F002A213F8EB7804
+A26D5AA36D5AA2131F6D5AA2EB07C0A36D5AA36DC7FC1F207F9E22>I<3BFFF07FF81FF0
+3B1F000FC007C06C903907800180170015C001805C00071502EC09E013C000035DEC19F0
+1410D801E05CA2EC2078D800F05CA2EC403C01785CA2EC801E017C1460013C144090383D
+000F133F6D5CA2011E1307010E91C7FCA2010C7F010413022C207F9E2F>I<12FFA212C0
+B3B3A512FFA2082D7CA10D>91 D<EA0804EA1008EA2010A2EA4020A2EA8040A3EAB85CEA
+FC7EA2EA7C3EEA381C0F0E7A9F17>I<12FFA21203B3B3A512FFA2082D80A10D>I<120812
+101220A21240A21280A312B812FCA2127C1238060E7D9F0D>96 D<EA1FE0EA3030EA7818
+131CEA300E1200A313FEEA078EEA1E0E1238127800F01310A3131E127838386720380F83
+C014147E9317>I<121C12FC121CAA137CEA1D87381E0180EB00C0001C13E01470A21478
+A6147014F014E0001E13C0381A018038198700EA107C15207E9F19>I<EA01FCEA0706EA
+1C0F123813060078C7FC127012F0A61270127800381380A2381C0100EA0706EA01F81114
+7F9314>I<EB01C0130F1301AAEA01F1EA070DEA0C03EA180112381278127012F0A61270
+A21238EA1803120CEA070D3801F1F815207F9F19>I<EA03F0EA0E1C487E487EA21270EB
+038012F0A2B5FC00F0C7FCA31270A26C1380A2381C0100EA0706EA01F811147F9314>I<
+137CEA01C6EA030F1207EA0E061300A7EAFFF0EA0E00B2EA7FE01020809F0E>I<14E038
+03E330EA0E3CEA1C1C38380E00EA780FA5EA380E6C5AEA1E38EA33E00020C7FCA21230A2
+EA3FFE381FFF8014C0383001E038600070481330A4006013606C13C0381C03803803FC00
+141F7F9417>I<121C12FC121CAA137C1386EA1D03001E1380A2121CAE38FF8FF014207E
+9F19>I<1238127CA31238C7FCA6121C12FC121CB1EAFF80091F7F9E0C>I<13E0EA01F0A3
+EA00E01300A61370EA07F012001370B3A31260EAF06013C0EA6180EA3F000C28829E0E>
+I<121C12FC121CAAEB1FE0EB0780EB060013045B5B5B136013E0EA1DF0EA1E70EA1C3813
+3C131C7F130F7F148014C038FF9FF014207E9F18>I<121C12FC121CB3ABEAFF8009207F
+9F0C>I<391C3E03E039FCC30C30391D039038391E01E01CA2001C13C0AE3AFF8FF8FF80
+21147E9326>I<EA1C7CEAFC86EA1D03001E1380A2121CAE38FF8FF014147E9319>I<EA01
+F8EA070E381C0380383801C0A2387000E0A200F013F0A6007013E0A2383801C0A2381C03
+8038070E00EA01F814147F9317>I<EA1C7CEAFD87381E018014C0381C00E014F0147014
+78A6147014F014E0381E01C0EB0380381D8700EA1C7C90C7FCA8B47E151D7E9319>I<38
+01F04038070CC0EA0E02EA1C03EA38011278127012F0A6127012781238EA1C03EA0C05EA
+0709EA01F1EA0001A8EB0FF8151D7F9318>I<EA1CF0EAFD18EA1E3CA21318EA1C00AEEA
+FFC00E147E9312>I<EA0FC8EA3038EA6018EAC008A3EAE000127CEA3FE0EA1FF0EA07F8
+EA003CEA800E130612C0A21304EAE00CEAD818EA87E00F147F9312>I<1202A31206A212
+0EA2123EEAFFF8EA0E00AB1304A5EA07081203EA01F00E1C7F9B12>I<381C0380EAFC1F
+EA1C03AE1307120CEA061B3803E3F014147E9319>I<38FF83F8383E00E0001C13C06C13
+80A338070100A21383EA0382A2EA01C4A213E4EA00E8A21370A3132015147F9318>I<39
+FF9FE1FC393C078070391C030060EC8020000E1440A214C0D80704138014E0A239038861
+001471A23801D032143A143E3800E01CA2EB6018EB40081E147F9321>I<38FF87F8381E
+03C0380E0180EB0300EA0702EA0384EA01C813D8EA00F01370137813F8139CEA010E1202
+EA060738040380000C13C0003C13E038FE07FC16147F9318>I<38FF83F8383E00E0001C
+13C06C1380A338070100A21383EA0382A2EA01C4A213E4EA00E8A21370A31320A25BA3EA
+F080A200F1C7FC1262123C151D7F9318>I<EA7FFFEA700E1260EA401C133813781370EA
+00E0120113C0EA038012071301120E121EEA1C03EA3802EA7006130EEAFFFE10147F9314
+>I E /Fp 13 122 df<DB1FFC14C00203B5EAC001021FECF003027FECFC07903B01FFFC
+00FE0F010701C0EB1F9F4948C7EA07FFD93FF880494814004948157F485B4A153F4890C9
+121F485A000F170F5B001F1707A2485A1803A2127FA24993C8FCA212FFAA041FB6128012
+7FA27FDC0001EBC000123FA36C7EA26C7EA26C7E7E6C7F806C7F6D6C5CEB3FFCD90FFF5C
+6D01C0EB1FBF010101FCEBFF1F6D6CB5EAFE0F021FECF8030203ECE0009126001FFEC9FC
+413D7BBB4C>71 D<B6D8F803B612E0A426007FF0C70001EBC000B3A491B8FCA402F0C712
+01B3A7B6D8F803B612E0A4433B7CBA4C>I<B612FEA426007FF0C9FCB3ADEF03C0A51707
+1880A3170FA3171FA2173F177F17FF5E04071300163FB9FCA4323B7DBA3A>76
+D<B500F00207B512E0808080D8007F92390007E0006E6F5A81017B7F81137901787F6E7E
+6E7E81141F6E7E6E7F6E7F82806E7F6F7E6F7E826F7E816F13806F13C017E06F13F081EE
+7FF8EE3FFC17FEEE1FFF827013837013C318E37013F382EF7FFBEF3FFFA283838383A283
+83187F183FA201FC161FB500FC150F18071803A2433B7CBA4C>78
+D<B600F80107B512E0A426007FF0C83807E000725AB3B3A3013F4C5AA280011F4CC7FCA2
+6D6C151E0107163E6E5D6D6C5D6D6D13019026007FE0EB0FE0DA3FFCEB7FC0020FB65A02
+034AC8FCDA007F13F003071380433C7DBA4A>85 D<EB3FFE48B512E0000714F8390FE007
+FC9038F001FE486C6C7E6F7E82153F6C48806C5A6C5AC8FCA491B5FC131F90387FF83F38
+03FF803807FC00EA0FF0485A123F485AA2485AA4157F6C7E15DF3A3FE0039FF03B1FF80F
+0FFFE03807FFFE0001497E39003FE0002B267DA52F>97 D<13FE12FFA412071203B04AB4
+FC021F13F0027F13FC9138FC03FE9039FFF000FF02C0EB3F8091C7EA1FC04915E0EE0FF0
+17F8A2EE07FCA317FEA917FCA3160F17F817F0161F6D15E06EEB3FC06EEB7F80D9F9E0EB
+FF009039F0FC07FE91387FFFF8D9E01F13E09026C003FEC7FC2F3C7DBB36>I<EA01E0EA
+07F8487EA2487EA46C5AA26C5AEA01E0C8FCAB13FE127FA412071203B3AAB512F0A4143D
+7DBC1A>105 D<903801FFC0010F13F8017F13FFD9FF807F3A03FE003FE0D807F8EB0FF0
+48486D7EA248486D7E003F81A248486D7EA400FF1680A9007F1600A36C6C495AA2001F5D
+6D1307000F5D6C6C495AD803FEEB3FE03A00FF80FF806DB5C7FC010F13F8010113C02926
+7DA530>111 D<3901FC03F000FFEB0FFC4AB4FC91383C3F80EC707F00079038E0FFC000
+035BEBFD80A201FFEB7F809138003F00151E92C7FC5BB3A3B512FCA422267DA528>114
+D<90383FF0383903FFFE7848EBFFF8381FC00F383F0003003E13005A157812FCA27E6C14
+0013C013FC387FFFF06C13FEECFF806C14C06C14E0000314F0C614F8011F13FCEB007FEC
+07FE0070130100F01300157E7EA27E157C6C14FC6C14F890388001F09038F00FE000F9B5
+12C0D8F07F130038C01FF81F267DA526>I<130FA55BA45BA25BA25B5A5A5A001FEBFFF0
+B6FCA3000190C7FCB3153CA86C14781480017F13F090383FC1E090381FFFC06D13809038
+01FE001E377EB626>I<B500F0EBFFFCA4D803FEC7EA1F806D15006C151E806C5DA26E13
+7C017F14786E13F8013F5CECF001011F5CECF803010F5CA2ECFC0701075CECFE0F010391
+C7FC6E5A6D131E15BE6D13BC15FC6E5AA36E5AA26E5AA26E5AA26E5AA2140F92C8FC5C14
+1E0008133E007F133C147C38FF807814F8EB81F0EB83E06C485A387C1F80D83FFFC9FCEA
+1FFCEA07F02E377EA533>121 D E end
+TeXDict begin
+
+1 0 bop 0 693 a Fp(GNU)33 b(History)f(Library)p 0 743
+1950 17 v 1035 791 a Fo(Edition)16 b(2.1,)e(for)h Fn(History)f(Library)
+g Fo(V)l(ersion)i(2.1.)1718 845 y(Marc)o(h)e(1996)0 2467
+y Fm(Brian)23 b(F)-6 b(o)n(x,)23 b(F)-6 b(ree)23 b(Soft)n(w)n(are)f(F)
+-6 b(oundation)0 2534 y(Chet)22 b(Ramey)-6 b(,)23 b(Case)e(W)-6
+b(estern)23 b(Reserv)n(e)f(Univ)n(ersit)n(y)p 0 2570
+1950 9 v eop
+2 1 bop 0 320 a Fo(This)16 b(do)q(cumen)o(t)g(describ)q(es)h(the)f(GNU)
+f(History)g(library)l(,)h(a)g(programming)e(to)q(ol)i(that)f(pro)o
+(vides)h(a)f(consisten)o(t)0 382 y(user)g(in)o(terface)h(for)e
+(recalling)j(lines)g(of)e(previously)h(t)o(yp)q(ed)g(input.)0
+519 y(Published)h(b)o(y)f(the)f(F)l(ree)g(Soft)o(w)o(are)f(F)l
+(oundation)0 582 y(675)g(Massac)o(h)o(usetts)g(Av)o(en)o(ue,)0
+644 y(Cam)o(bridge,)h(MA)g(02139)f(USA)0 781 y(P)o(ermission)f(is)g
+(gran)o(ted)f(to)f(mak)o(e)h(and)h(distribute)h(v)o(erbatim)e(copies)h
+(of)f(this)h(man)o(ual)g(pro)o(vided)g(the)f(cop)o(yrigh)o(t)0
+843 y(notice)k(and)f(this)h(p)q(ermission)h(notice)e(are)g(preserv)o
+(ed)h(on)f(all)h(copies.)0 980 y(P)o(ermission)f(is)f(gran)o(ted)f(to)h
+(cop)o(y)g(and)g(distribute)h(mo)q(di\014ed)h(v)o(ersions)e(of)f(this)i
+(man)o(ual)f(under)h(the)f(conditions)0 1043 y(for)e(v)o(erbatim)g(cop)
+o(ying,)h(pro)o(vided)h(that)d(the)i(en)o(tire)g(resulting)h(deriv)o
+(ed)f(w)o(ork)f(is)h(distributed)h(under)f(the)g(terms)0
+1105 y(of)i(a)g(p)q(ermission)h(notice)g(iden)o(tical)h(to)e(this)g
+(one.)0 1242 y(P)o(ermission)20 b(is)g(gran)o(ted)f(to)g(cop)o(y)h(and)
+f(distribute)i(translations)f(of)f(this)h(man)o(ual)f(in)o(to)h
+(another)f(language,)0 1304 y(under)c(the)f(ab)q(o)o(v)o(e)g
+(conditions)h(for)e(mo)q(di\014ed)j(v)o(ersions,)e(except)g(that)g
+(this)g(p)q(ermission)i(notice)e(ma)o(y)g(b)q(e)h(stated)0
+1366 y(in)h(a)f(translation)g(appro)o(v)o(ed)g(b)o(y)g(the)g(F)l
+(oundation.)0 2661 y(Cop)o(yrigh)o(t)226 2660 y(c)214
+2661 y Fl(\015)g Fo(1989,)f(1991)g(F)l(ree)h(Soft)o(w)o(are)f(F)l
+(oundation,)h(Inc.)p eop
+1 2 bop 0 -58 a Fo(Chapter)15 b(1:)k(Using)d(History)f(In)o(teractiv)o
+(ely)1157 b(1)0 183 y Fk(1)41 b(Using)14 b(History)h(In)n(teractiv)n
+(ely)62 380 y Fo(This)i(c)o(hapter)e(describ)q(es)j(ho)o(w)d(to)h(use)g
+(the)g(GNU)g(History)f(Library)i(in)o(teractiv)o(ely)l(,)g(from)e(a)g
+(user's)h(stand-)0 442 y(p)q(oin)o(t.)23 b(It)16 b(should)h(b)q(e)f
+(considered)i(a)d(user's)h(guide.)23 b(F)l(or)15 b(information)h(on)g
+(using)h(the)f(GNU)g(History)f(Library)0 505 y(in)h(y)o(our)f(o)o(wn)f
+(programs,)g(see)i(Chapter)e(2)h([Programming)f(with)i(GNU)f(History],)
+f(page)h(5.)0 747 y Fm(1.1)33 b(In)n(teractiv)n(e)16
+b(History)g(Expansion)62 886 y Fo(The)e(History)f(library)h(pro)o
+(vides)g(a)f(history)g(expansion)h(feature)f(that)g(is)g(similar)i(to)d
+(the)i(history)f(expansion)0 948 y(pro)o(vided)j(b)o(y)f
+Fn(csh)p Fo(.)20 b(This)15 b(section)h(describ)q(es)h(the)e(syn)o(tax)g
+(used)g(to)g(manipulate)h(the)g(history)f(information.)62
+1087 y(History)h(expansions)g(in)o(tro)q(duce)g(w)o(ords)f(from)g(the)h
+(history)f(list)i(in)o(to)e(the)h(input)g(stream,)f(making)g(it)h(easy)
+0 1150 y(to)g(rep)q(eat)g(commands,)h(insert)g(the)f(argumen)o(ts)g(to)
+g(a)g(previous)h(command)f(in)o(to)h(the)f(curren)o(t)h(input)g(line,)h
+(or)0 1212 y(\014x)d(errors)g(in)h(previous)g(commands)f(quic)o(kly)l
+(.)62 1351 y(History)c(expansion)i(tak)o(es)d(place)i(in)h(t)o(w)o(o)d
+(parts.)18 b(The)11 b(\014rst)g(is)h(to)f(determine)h(whic)o(h)g(line)h
+(from)e(the)g(previous)0 1413 y(history)h(should)h(b)q(e)f(used)h
+(during)f(substitution.)20 b(The)12 b(second)g(is)h(to)e(select)h(p)q
+(ortions)g(of)g(that)f(line)i(for)f(inclusion)0 1475
+y(in)o(to)f(the)h(curren)o(t)f(one.)18 b(The)12 b(line)h(selected)f
+(from)f(the)g(previous)h(history)g(is)f(called)i(the)e
+Fj(ev)o(en)o(t)p Fo(,)h(and)f(the)h(p)q(ortions)0 1538
+y(of)h(that)f(line)j(that)e(are)f(acted)i(up)q(on)g(are)e(called)j
+Fj(w)o(ords)p Fo(.)k(V)l(arious)13 b Fj(mo)q(di\014ers)j
+Fo(are)d(a)o(v)m(ailable)i(to)d(manipulate)j(the)0 1600
+y(selected)i(w)o(ords.)23 b(The)16 b(line)i(is)f(brok)o(en)f(in)o(to)g
+(w)o(ords)f(in)i(the)g(same)f(fashion)g(that)g(Bash)g(do)q(es,)g(so)g
+(that)g(sev)o(eral)0 1662 y(English)g(\(or)e(Unix\))h(w)o(ords)e
+(surrounded)j(b)o(y)e(quotes)h(are)f(considered)i(as)e(one)h(w)o(ord.)k
+(History)14 b(expansions)h(are)0 1725 y(in)o(tro)q(duced)h(b)o(y)g(the)
+f(app)q(earance)h(of)e(the)i(history)f(expansion)h(c)o(haracter,)e
+(whic)o(h)i(is)g(`)p Fn(!)p Fo(')e(b)o(y)h(default.)0
+1950 y Fi(1.1.1)30 b(Ev)n(en)n(t)16 b(Designators)62
+2089 y Fo(An)g(ev)o(en)o(t)f(designator)g(is)g(a)g(reference)h(to)f(a)g
+(command)g(line)i(en)o(try)d(in)i(the)g(history)f(list.)0
+2243 y Fn(!)216 b Fo(Start)14 b(a)g(history)h(substitution,)g(except)h
+(when)f(follo)o(w)o(ed)g(b)o(y)g(a)f(space,)h(tab,)f(the)h(end)g(of)g
+(the)g(line,)240 2305 y Fn(=)g Fo(or)g Fn(\()p Fo(.)0
+2396 y Fn(!)p Fj(n)191 b Fo(Refer)16 b(to)e(command)h(line)i
+Fj(n)p Fo(.)0 2488 y Fn(!-)p Fj(n)167 b Fo(Refer)16 b(to)e(the)i
+(command)f Fj(n)g Fo(lines)i(bac)o(k.)0 2579 y Fn(!!)192
+b Fo(Refer)16 b(to)e(the)i(previous)f(command.)20 b(This)c(is)g(a)f
+(synon)o(ym)g(for)f(`)p Fn(!-1)p Fo('.)0 2670 y Fn(!)p
+Fj(string)102 b Fo(Refer)16 b(to)e(the)i(most)e(recen)o(t)h(command)g
+(starting)g(with)g Fj(string)p Fo(.)p eop
+2 3 bop 0 -58 a Fo(2)1497 b(GNU)15 b(History)g(Library)0
+183 y Fn(!?)p Fj(string)t Fn([?])240 246 y Fo(Refer)h(to)f(the)g(most)g
+(recen)o(t)g(command)g(con)o(taining)h Fj(string)p Fo(.)21
+b(The)15 b(trailing)i(`)p Fn(?)p Fo(')d(ma)o(y)h(b)q(e)h(omitted)240
+308 y(if)g(the)f Fj(string)k Fo(is)d(follo)o(w)o(ed)f(immediately)i(b)o
+(y)e(a)g(newline.)0 395 y Fn(^)p Fj(string1)t Fn(^)p
+Fj(string2)t Fn(^)240 457 y Fo(Quic)o(k)i(Substitution.)22
+b(Rep)q(eat)16 b(the)g(last)f(command,)h(replacing)h
+Fj(string1)h Fo(with)e Fj(string2)p Fo(.)21 b(Equiv-)240
+520 y(alen)o(t)15 b(to)g Fn(!!:s/)p Fj(string1)t Fn(/)p
+Fj(string2)t Fn(/)p Fo(.)0 607 y Fn(!#)192 b Fo(The)15
+b(en)o(tire)h(command)f(line)i(t)o(yp)q(ed)f(so)e(far.)0
+816 y Fi(1.1.2)30 b(W)-5 b(ord)15 b(Designators)62 953
+y Fo(W)l(ord)k(designators)g(are)f(used)i(to)e(select)i(desired)g(w)o
+(ords)e(from)h(the)g(ev)o(en)o(t.)31 b(A)19 b(`)p Fn(:)p
+Fo(')f(separates)g(the)h(ev)o(en)o(t)0 1015 y(sp)q(eci\014cation)e
+(from)d(the)h(w)o(ord)f(designator.)20 b(It)15 b(can)g(b)q(e)g(omitted)
+g(if)g(the)g(w)o(ord)g(designator)f(b)q(egins)i(with)g(a)e(`)p
+Fn(^)p Fo(',)0 1077 y(`)p Fn($)p Fo(',)i(`)p Fn(*)p Fo(',)g(`)p
+Fn(-)p Fo(',)g(or)g(`)p Fn(\045)p Fo('.)24 b(W)l(ords)17
+b(are)f(n)o(um)o(b)q(ered)i(from)e(the)h(b)q(eginning)i(of)d(the)h
+(line,)i(with)e(the)g(\014rst)g(w)o(ord)f(b)q(eing)0
+1139 y(denoted)g(b)o(y)f(0)g(\(zero\).)k(W)l(ords)c(are)g(inserted)h
+(in)o(to)f(the)g(curren)o(t)g(line)i(separated)e(b)o(y)g(single)i
+(spaces.)0 1289 y Fn(0)e(\(zero\))57 b Fo(The)15 b Fn(0)p
+Fo(th)g(w)o(ord.)20 b(F)l(or)14 b(man)o(y)h(applications,)h(this)g(is)g
+(the)f(command)g(w)o(ord.)0 1376 y Fj(n)215 b Fo(The)15
+b Fj(n)p Fo(th)h(w)o(ord.)0 1464 y Fn(^)216 b Fo(The)15
+b(\014rst)g(argumen)o(t;)f(that)h(is,)g(w)o(ord)g(1.)0
+1551 y Fn($)216 b Fo(The)15 b(last)h(argumen)o(t.)0 1639
+y Fn(\045)216 b Fo(The)15 b(w)o(ord)g(matc)o(hed)g(b)o(y)g(the)g(most)g
+(recen)o(t)g(`)p Fn(?)p Fj(string)t Fn(?)p Fo(')f(searc)o(h.)0
+1726 y Fj(x)p Fn(-)p Fj(y)168 b Fo(A)15 b(range)g(of)g(w)o(ords;)f(`)p
+Fn(-)p Fj(y)t Fo(')g(abbreviates)i(`)p Fn(0-)p Fj(y)t
+Fo('.)0 1813 y Fn(*)216 b Fo(All)16 b(of)f(the)g(w)o(ords,)f(except)h
+(the)g Fn(0)p Fo(th.)k(This)d(is)f(a)g(synon)o(ym)g(for)f(`)p
+Fn(1-$)p Fo('.)k(It)d(is)h(not)e(an)h(error)f(to)h(use)240
+1876 y(`)p Fn(*)p Fo(')f(if)i(there)f(is)h(just)f(one)g(w)o(ord)g(in)h
+(the)f(ev)o(en)o(t;)g(the)g(empt)o(y)g(string)g(is)h(returned)f(in)h
+(that)f(case.)0 1963 y Fj(x)s Fn(*)189 b Fo(Abbreviates)16
+b(`)p Fj(x)p Fn(-$)p Fo(')0 2050 y Fj(x)p Fn(-)192 b
+Fo(Abbreviates)16 b(`)p Fj(x)p Fn(-$)p Fo(')e(lik)o(e)i(`)p
+Fj(x)s Fn(*)p Fo(',)e(but)i(omits)f(the)g(last)g(w)o(ord.)62
+2200 y(If)i(a)g(w)o(ord)f(designator)g(is)i(supplied)h(without)d(an)h
+(ev)o(en)o(t)g(sp)q(eci\014cation,)h(the)f(previous)h(command)e(is)h
+(used)0 2262 y(as)e(the)g(ev)o(en)o(t.)0 2471 y Fi(1.1.3)30
+b(Mo)r(di\014ers)62 2608 y Fo(After)20 b(the)f(optional)i(w)o(ord)e
+(designator,)h(y)o(ou)f(can)h(add)g(a)g(sequence)h(of)e(one)h(or)f
+(more)g(of)g(the)h(follo)o(wing)0 2670 y(mo)q(di\014ers,)c(eac)o(h)f
+(preceded)i(b)o(y)e(a)g(`)p Fn(:)p Fo('.)p eop
+3 4 bop 0 -58 a Fo(Chapter)15 b(1:)k(Using)d(History)f(In)o(teractiv)o
+(ely)1157 b(3)0 183 y Fn(h)216 b Fo(Remo)o(v)o(e)15 b(a)g(trailing)h
+(pathname)f(comp)q(onen)o(t,)g(lea)o(ving)h(only)g(the)f(head.)0
+270 y Fn(t)216 b Fo(Remo)o(v)o(e)15 b(all)h(leading)h(pathname)e(comp)q
+(onen)o(ts,)g(lea)o(ving)h(the)f(tail.)0 358 y Fn(r)216
+b Fo(Remo)o(v)o(e)15 b(a)g(trailing)h(su\016x)f(of)g(the)g(form)g(`)p
+Fn(.)p Fj(su\016x)s Fo(',)f(lea)o(ving)i(the)f(basename.)0
+445 y Fn(e)216 b Fo(Remo)o(v)o(e)15 b(all)h(but)g(the)f(trailing)h
+(su\016x.)0 532 y Fn(p)216 b Fo(Prin)o(t)15 b(the)g(new)h(command)f
+(but)g(do)g(not)g(execute)h(it.)0 619 y Fn(s/)p Fj(old)r
+Fn(/)p Fj(new)t Fn(/)240 681 y Fo(Substitute)k Fj(new)k
+Fo(for)19 b(the)g(\014rst)g(o)q(ccurrence)i(of)e Fj(old)j
+Fo(in)e(the)f(ev)o(en)o(t)h(line.)34 b(An)o(y)19 b(delimiter)j(ma)o(y)
+240 744 y(b)q(e)e(used)g(in)g(place)g(of)f(`)p Fn(/)p
+Fo('.)31 b(The)19 b(delimiter)i(ma)o(y)e(b)q(e)h(quoted)f(in)h
+Fj(old)h Fo(and)f Fj(new)j Fo(with)d(a)f(single)240 806
+y(bac)o(kslash.)28 b(If)18 b(`)p Fn(&)p Fo(')f(app)q(ears)h(in)h
+Fj(new)p Fo(,)f(it)h(is)f(replaced)h(b)o(y)f Fj(old)p
+Fo(.)28 b(A)18 b(single)h(bac)o(kslash)g(will)g(quote)240
+868 y(the)c(`)p Fn(&)p Fo('.)k(The)d(\014nal)g(delimiter)h(is)e
+(optional)h(if)g(it)f(is)h(the)f(last)g(c)o(haracter)g(on)g(the)g
+(input)i(line.)0 955 y Fn(&)216 b Fo(Rep)q(eat)16 b(the)f(previous)h
+(substitution.)0 1043 y Fn(g)216 b Fo(Cause)17 b(c)o(hanges)g(to)f(b)q
+(e)i(applied)g(o)o(v)o(er)e(the)h(en)o(tire)h(ev)o(en)o(t)e(line.)27
+b(Used)17 b(in)h(conjunction)g(with)f(`)p Fn(s)p Fo(',)240
+1105 y(as)e(in)h Fn(gs/)p Fj(old)r Fn(/)p Fj(new)t Fn(/)p
+Fo(,)f(or)f(with)i(`)p Fn(&)p Fo('.)p eop
+4 5 bop 0 -58 a Fo(4)1497 b(GNU)15 b(History)g(Library)p
+eop
+5 6 bop 0 -58 a Fo(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(History)1039 b(5)0 183 y Fk(2)41 b(Programming)16 b(with)f(GNU)h
+(History)62 370 y Fo(This)e(c)o(hapter)f(describ)q(es)i(ho)o(w)d(to)h
+(in)o(terface)g(programs)f(that)h(y)o(ou)g(write)g(with)g(the)h(GNU)f
+(History)g(Library)l(.)0 432 y(It)j(should)g(b)q(e)g(considered)h(a)f
+(tec)o(hnical)h(guide.)22 b(F)l(or)15 b(information)h(on)f(the)h(in)o
+(teractiv)o(e)g(use)g(of)f(GNU)g(History)l(,)0 495 y(see)g(Chapter)g(1)
+g([Using)h(History)f(In)o(teractiv)o(ely],)g(page)g(1.)0
+719 y Fm(2.1)33 b(In)n(tro)r(duction)17 b(to)e(History)62
+856 y Fo(Man)o(y)j(programs)g(read)h(input)h(from)e(the)g(user)h(a)g
+(line)h(at)f(a)f(time.)31 b(The)19 b(GNU)g(History)f(library)i(is)f
+(able)0 918 y(to)e(k)o(eep)g(trac)o(k)f(of)h(those)g(lines,)i(asso)q
+(ciate)e(arbitrary)g(data)g(with)g(eac)o(h)g(line,)j(and)d(utilize)i
+(information)f(from)0 980 y(previous)e(lines)h(in)f(comp)q(osing)f(new)
+h(ones.)62 1117 y(The)i(programmer)f(using)h(the)g(History)g(library)g
+(has)g(a)o(v)m(ailable)h(functions)g(for)e(remem)o(b)q(ering)h(lines)i
+(on)d(a)0 1180 y(history)f(list,)g(asso)q(ciating)g(arbitrary)g(data)f
+(with)h(a)f(line,)j(remo)o(ving)d(lines)j(from)d(the)h(list,)g(searc)o
+(hing)g(through)0 1242 y(the)h(list)h(for)e(a)h(line)h(con)o(taining)g
+(an)f(arbitrary)f(text)h(string,)g(and)g(referencing)h(an)o(y)f(line)h
+(in)g(the)f(list)h(directly)l(.)0 1304 y(In)d(addition,)h(a)e(history)h
+Fj(expansion)h Fo(function)g(is)f(a)o(v)m(ailable)h(whic)o(h)g(pro)o
+(vides)f(for)f(a)h(consisten)o(t)g(user)g(in)o(terface)0
+1366 y(across)f(di\013eren)o(t)i(programs.)62 1503 y(The)i(user)g
+(using)g(programs)f(written)g(with)h(the)g(History)f(library)i(has)e
+(the)h(b)q(ene\014t)h(of)e(a)g(consisten)o(t)h(user)0
+1566 y(in)o(terface)d(with)g(a)f(set)h(of)f(w)o(ell-kno)o(wn)h
+(commands)g(for)f(manipulating)i(the)f(text)f(of)g(previous)h(lines)h
+(and)f(using)0 1628 y(that)g(text)g(in)i(new)e(commands.)22
+b(The)15 b(basic)i(history)e(manipulation)j(commands)d(are)g(similar)i
+(to)e(the)h(history)0 1690 y(substitution)g(pro)o(vided)g(b)o(y)f
+Fn(csh)p Fo(.)62 1827 y(If)g(the)g(programmer)e(desires,)i(he)g(can)g
+(use)g(the)f(Readline)j(library)l(,)e(whic)o(h)h(includes)g(some)f
+(history)f(manip-)0 1889 y(ulation)i(b)o(y)f(default,)h(and)f(has)g
+(the)g(added)h(adv)m(an)o(tage)f(of)g(command)g(line)h(editing.)0
+2114 y Fm(2.2)33 b(History)15 b(Storage)62 2251 y Fo(The)h(history)f
+(list)h(is)g(an)f(arra)o(y)f(of)g(history)i(en)o(tries.)k(A)15
+b(history)g(en)o(try)g(is)h(declared)g(as)f(follo)o(ws:)120
+2377 y Fn(typedef)23 b(struct)g(_hist_entry)f({)168 2429
+y(char)h(*line;)168 2481 y(char)g(*data;)120 2533 y(})h(HIST_ENTRY;)62
+2670 y Fo(The)16 b(history)f(list)h(itself)g(migh)o(t)f(therefore)g(b)q
+(e)h(declared)g(as)p eop
+6 7 bop 0 -58 a Fo(6)1497 b(GNU)15 b(History)g(Library)120
+183 y Fn(HIST_ENTRY)22 b(**the_history_list;)62 327 y
+Fo(The)16 b(state)e(of)h(the)g(History)g(library)h(is)g(encapsulated)g
+(in)o(to)f(a)g(single)i(structure:)120 460 y Fn(/*)24
+b(A)f(structure)g(used)g(to)h(pass)f(the)h(current)f(state)g(of)g(the)h
+(history)f(stuff)g(around.)g(*/)120 512 y(typedef)g(struct)g
+(_hist_state)f({)168 564 y(HIST_ENTRY)g(**entries;)214
+b(/*)23 b(Pointer)g(to)h(the)f(entries)g(themselves.)f(*/)168
+616 y(int)h(offset;)453 b(/*)23 b(The)h(location)e(pointer)h(within)g
+(this)h(array.)f(*/)168 668 y(int)g(length;)453 b(/*)23
+b(Number)g(of)h(elements)f(within)g(this)g(array.)g(*/)168
+719 y(int)g(size;)501 b(/*)23 b(Number)g(of)h(slots)f(allocated)g(to)g
+(this)h(array.)f(*/)168 771 y(int)g(flags;)120 823 y(})h
+(HISTORY_STATE;)62 967 y Fo(If)16 b(the)f(\015ags)g(mem)o(b)q(er)g
+(includes)j Fn(HS_STIFLED)p Fo(,)13 b(the)i(history)h(has)f(b)q(een)h
+(sti\015ed.)0 1250 y Fm(2.3)33 b(History)15 b(F)-6 b(unctions)62
+1394 y Fo(This)16 b(section)g(describ)q(es)h(the)e(calling)i(sequence)f
+(for)f(the)g(v)m(arious)h(functions)g(presen)o(t)f(in)h(GNU)f(History)l
+(.)0 1661 y Fi(2.3.1)30 b(Initializing)15 b(History)g(and)g(State)g
+(Managemen)n(t)62 1805 y Fo(This)j(section)g(describ)q(es)h(functions)f
+(used)g(to)e(initialize)21 b(and)c(manage)g(the)g(state)g(of)g(the)g
+(History)g(library)0 1867 y(when)f(y)o(ou)f(w)o(an)o(t)f(to)g(use)i
+(the)f(history)g(functions)h(in)g(y)o(our)f(program.)1725
+2049 y(F)l(unction)-1899 b Fh(void)20 b Fg(using)p 258
+2049 18 3 v 20 w(history)j Ff(\(\))120 2111 y Fo(Begin)g(a)f(session)g
+(in)h(whic)o(h)g(the)f(history)g(functions)g(migh)o(t)g(b)q(e)h(used.)
+40 b(This)23 b(initializes)i(the)120 2173 y(in)o(teractiv)o(e)16
+b(v)m(ariables.)1725 2355 y(F)l(unction)-1899 b Fh(HISTORY_STATE)21
+b(*)e Fg(history)p 582 2355 V 21 w(get)p 680 2355 V 21
+w(history)p 876 2355 V 21 w(state)j Ff(\(\))120 2417
+y Fo(Return)16 b(a)f(structure)g(describing)i(the)e(curren)o(t)g(state)
+f(of)h(the)g(input)i(history)l(.)1725 2599 y(F)l(unction)-1899
+b Fh(void)20 b Fg(history)p 302 2599 V 20 w(set)p 393
+2599 V 21 w(history)p 589 2599 V 21 w(state)j Ff(\()p
+Fn(HISTORY_STATE)13 b(*state)p Ff(\))120 2661 y Fo(Set)i(the)h(state)e
+(of)h(the)g(history)g(list)h(according)g(to)e Fj(state)p
+Fo(.)p eop
+7 8 bop 0 -58 a Fo(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(History)1039 b(7)0 183 y Fi(2.3.2)30 b(History)15 b(List)g(Managemen)n
+(t)62 322 y Fo(These)i(functions)h(manage)e(individual)k(en)o(tries)d
+(on)f(the)h(history)g(list,)g(or)f(set)h(parameters)e(managing)i(the)0
+384 y(list)f(itself.)1725 552 y(F)l(unction)-1899 b Fh(void)20
+b Fg(add)p 219 552 18 3 v 20 w(history)j Ff(\()p Fn(char)14
+b(*string)p Ff(\))120 614 y Fo(Place)j Fj(string)k Fo(at)16
+b(the)g(end)i(of)e(the)g(history)h(list.)25 b(The)17
+b(asso)q(ciated)g(data)f(\014eld)h(\(if)g(an)o(y\))f(is)h(set)g(to)120
+677 y Fn(NULL)p Fo(.)1725 844 y(F)l(unction)-1899 b Fh(HIST_ENTRY)21
+b(*)e Fg(remo)n(v)n(e)p 509 844 V 20 w(history)k Ff(\()p
+Fn(int)14 b(which)p Ff(\))120 907 y Fo(Remo)o(v)o(e)d(history)g(en)o
+(try)g(at)g(o\013set)f Fj(whic)o(h)i Fo(from)f(the)g(history)l(.)19
+b(The)11 b(remo)o(v)o(ed)g(elemen)o(t)h(is)g(returned)120
+969 y(so)j(y)o(ou)g(can)g(free)g(the)h(line,)g(data,)e(and)i(con)o
+(taining)g(structure.)1725 1137 y(F)l(unction)-1899 b
+Fh(HIST_ENTRY)21 b(*)e Fg(replace)p 505 1137 V 22 w(history)p
+702 1137 V 20 w(en)n(try)24 b Ff(\()p Fn(int)14 b(which,)g(char)h
+(*line,)f(char)208 1199 y(*data)p Ff(\))120 1261 y Fo(Mak)o(e)d(the)i
+(history)f(en)o(try)g(at)f(o\013set)h Fj(whic)o(h)h Fo(ha)o(v)o(e)e
+Fj(line)17 b Fo(and)12 b Fj(data)p Fo(.)19 b(This)12
+b(returns)g(the)h(old)g(en)o(try)e(so)120 1324 y(y)o(ou)i(can)g(disp)q
+(ose)h(of)e(the)h(data.)19 b(In)13 b(the)g(case)g(of)f(an)h(in)o(v)m
+(alid)i Fj(whic)o(h)p Fo(,)f(a)f Fn(NULL)f Fo(p)q(oin)o(ter)i(is)f
+(returned.)1725 1491 y(F)l(unction)-1899 b Fh(void)20
+b Fg(clear)p 245 1491 V 21 w(history)j Ff(\(\))120 1554
+y Fo(Clear)15 b(the)h(history)f(list)h(b)o(y)f(deleting)i(all)f(the)f
+(en)o(tries.)1725 1721 y(F)l(unction)-1899 b Fh(void)20
+b Fg(sti\015e)p 245 1721 V 21 w(history)j Ff(\()p Fn(int)14
+b(max)p Ff(\))120 1784 y Fo(Sti\015e)i(the)f(history)h(list,)f(remem)o
+(b)q(ering)h(only)g(the)f(last)g Fj(max)j Fo(en)o(tries.)1725
+1951 y(F)l(unction)-1899 b Fh(int)20 b Fg(unsti\015e)p
+283 1951 V 21 w(history)i Ff(\(\))120 2014 y Fo(Stop)13
+b(sti\015ing)h(the)f(history)l(.)19 b(This)14 b(returns)f(the)g
+(previous)h(amoun)o(t)e(the)h(history)g(w)o(as)g(sti\015ed.)20
+b(The)120 2076 y(v)m(alue)c(is)g(p)q(ositiv)o(e)g(if)g(the)f(history)g
+(w)o(as)g(sti\015ed,)h(negativ)o(e)f(if)g(it)h(w)o(asn't.)1725
+2244 y(F)l(unction)-1899 b Fh(int)20 b Fg(history)p 276
+2244 V 20 w(is)p 334 2244 V 21 w(sti\015ed)k Ff(\(\))120
+2306 y Fo(Returns)16 b(non-zero)f(if)h(the)f(history)g(is)h(sti\015ed,)
+g(zero)f(if)g(it)h(is)g(not.)0 2531 y Fi(2.3.3)30 b(Information)14
+b(Ab)r(out)h(the)g(History)g(List)62 2670 y Fo(These)h(functions)g
+(return)f(information)g(ab)q(out)g(the)h(en)o(tire)f(history)g(list)h
+(or)f(individual)j(list)f(en)o(tries.)p eop
+8 9 bop 0 -58 a Fo(8)1497 b(GNU)15 b(History)g(Library)1725
+183 y(F)l(unction)-1899 b Fh(HIST_ENTRY)21 b(**)e Fg(history)p
+530 183 18 3 v 21 w(list)24 b Ff(\(\))120 246 y Fo(Return)e(a)e
+Fn(NULL)h Fo(terminated)g(arra)o(y)f(of)g Fn(HIST_ENTRY)g
+Fo(whic)o(h)i(is)f(the)g(curren)o(t)g(input)h(history)l(.)120
+308 y(Elemen)o(t)16 b(0)f(of)f(this)i(list)g(is)g(the)f(b)q(eginning)i
+(of)e(time.)20 b(If)c(there)f(is)h(no)f(history)l(,)g(return)g
+Fn(NULL)p Fo(.)1725 482 y(F)l(unction)-1899 b Fh(int)20
+b Fg(where)p 250 482 V 20 w(history)j Ff(\(\))120 544
+y Fo(Returns)16 b(the)f(o\013set)f(of)h(the)g(curren)o(t)g(history)g
+(elemen)o(t.)1725 719 y(F)l(unction)-1899 b Fh(HIST_ENTRY)21
+b(*)e Fg(curren)n(t)p 512 719 V 21 w(history)k Ff(\(\))120
+781 y Fo(Return)14 b(the)g(history)g(en)o(try)f(at)h(the)g(curren)o(t)f
+(p)q(osition,)i(as)e(determined)j(b)o(y)d Fn(where_history)h(\(\))p
+Fo(.)120 843 y(If)h(there)h(is)f(no)h(en)o(try)e(there,)h(return)g(a)g
+Fn(NULL)g Fo(p)q(oin)o(ter.)1725 1018 y(F)l(unction)-1899
+b Fh(HIST_ENTRY)21 b(*)e Fg(history)p 504 1018 V 21 w(get)j
+Ff(\()p Fn(int)15 b(offset)p Ff(\))120 1080 y Fo(Return)g(the)g
+(history)f(en)o(try)g(at)g(p)q(osition)i Fj(o\013set)p
+Fo(,)d(starting)h(from)g Fn(history_base)p Fo(.)k(If)c(there)h(is)g(no)
+120 1142 y(en)o(try)g(there,)g(or)f(if)i Fj(o\013set)f
+Fo(is)h(greater)e(than)h(the)h(history)f(length,)g(return)g(a)g
+Fn(NULL)g Fo(p)q(oin)o(ter.)1725 1316 y(F)l(unction)-1899
+b Fh(int)20 b Fg(history)p 276 1316 V 20 w(total)p 412
+1316 V 22 w(b)n(ytes)j Ff(\(\))120 1379 y Fo(Return)17
+b(the)f(n)o(um)o(b)q(er)g(of)g(b)o(ytes)g(that)f(the)h(primary)g
+(history)g(en)o(tries)h(are)e(using.)23 b(This)17 b(function)120
+1441 y(returns)e(the)g(sum)h(of)e(the)i(lengths)f(of)g(all)h(the)g
+(lines)g(in)g(the)g(history)l(.)0 1686 y Fi(2.3.4)30
+b(Mo)n(ving)15 b(Around)h(the)f(History)g(List)62 1827
+y Fo(These)h(functions)g(allo)o(w)f(the)g(curren)o(t)h(index)g(in)o(to)
+f(the)h(history)f(list)h(to)e(b)q(e)i(set)f(or)g(c)o(hanged.)1725
+2001 y(F)l(unction)-1899 b Fh(int)20 b Fg(history)p 276
+2001 V 20 w(set)p 367 2001 V 21 w(p)r(os)h Ff(\()p Fn(int)15
+b(pos)p Ff(\))120 2063 y Fo(Set)g(the)h(p)q(osition)g(in)g(the)f
+(history)g(list)h(to)f Fj(p)q(os)p Fo(,)g(an)g(absolute)g(index)i(in)o
+(to)e(the)g(list.)1725 2238 y(F)l(unction)-1899 b Fh(HIST_ENTRY)21
+b(*)e Fg(previous)p 540 2238 V 20 w(history)k Ff(\(\))120
+2300 y Fo(Bac)o(k)16 b(up)h(the)g(curren)o(t)f(history)h(o\013set)e(to)
+h(the)h(previous)g(history)g(en)o(try)l(,)f(and)h(return)f(a)g(p)q(oin)
+o(ter)120 2362 y(to)f(that)f(en)o(try)l(.)20 b(If)15
+b(there)g(is)h(no)f(previous)h(en)o(try)l(,)f(return)g(a)g
+Fn(NULL)g Fo(p)q(oin)o(ter.)1725 2537 y(F)l(unction)-1899
+b Fh(HIST_ENTRY)21 b(*)e Fg(next)p 439 2537 V 21 w(history)k
+Ff(\(\))120 2599 y Fo(Mo)o(v)o(e)c(the)h(curren)o(t)g(history)f
+(o\013set)g(forw)o(ard)g(to)g(the)h(next)g(history)g(en)o(try)l(,)g
+(and)g(return)g(the)g(a)120 2661 y(p)q(oin)o(ter)c(to)e(that)h(en)o
+(try)l(.)k(If)d(there)f(is)h(no)f(next)g(en)o(try)l(,)g(return)g(a)g
+Fn(NULL)g Fo(p)q(oin)o(ter.)p eop
+9 10 bop 0 -58 a Fo(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(History)1039 b(9)0 183 y Fi(2.3.5)30 b(Searc)n(hing)15
+b(the)h(History)f(List)62 320 y Fo(These)e(functions)g(allo)o(w)f
+(searc)o(hing)h(of)f(the)g(history)g(list)h(for)f(en)o(tries)h(con)o
+(taining)g(a)f(sp)q(eci\014c)i(string.)19 b(Searc)o(h-)0
+382 y(ing)e(ma)o(y)g(b)q(e)g(p)q(erformed)g(b)q(oth)g(forw)o(ard)f(and)
+h(bac)o(kw)o(ard)f(from)g(the)h(curren)o(t)f(history)h(p)q(osition.)26
+b(The)17 b(searc)o(h)0 445 y(ma)o(y)d(b)q(e)i Fj(anc)o(hored)p
+Fo(,)f(meaning)h(that)f(the)g(string)g(m)o(ust)g(matc)o(h)f(at)h(the)g
+(b)q(eginning)i(of)e(the)h(history)f(en)o(try)l(.)1725
+600 y(F)l(unction)-1899 b Fh(int)20 b Fg(history)p 276
+600 18 3 v 20 w(searc)n(h)j Ff(\()p Fn(char)14 b(*string,)g(int)h
+(direction)p Ff(\))120 662 y Fo(Searc)o(h)k(the)g(history)g(for)f
+Fj(string)p Fo(,)i(starting)e(at)g(the)h(curren)o(t)g(history)g
+(o\013set.)30 b(If)19 b Fj(direction)h Fn(<)f Fo(0,)120
+724 y(then)14 b(the)f(searc)o(h)g(is)h(through)e(previous)i(en)o
+(tries,)g(else)g(through)f(subsequen)o(t.)20 b(If)13
+b Fj(string)k Fo(is)d(found,)120 786 y(then)f(the)g(curren)o(t)g
+(history)g(index)i(is)e(set)g(to)f(that)h(history)g(en)o(try)l(,)f(and)
+i(the)f(v)m(alue)h(returned)f(is)h(the)120 849 y(o\013set)h(in)i(the)f
+(line)i(of)d(the)h(en)o(try)g(where)g Fj(string)k Fo(w)o(as)c(found.)22
+b(Otherwise,)17 b(nothing)f(is)h(c)o(hanged,)120 911
+y(and)e(a)g(-1)g(is)h(returned.)1725 1066 y(F)l(unction)-1899
+b Fh(int)20 b Fg(history)p 276 1066 V 20 w(searc)n(h)p
+452 1066 V 21 w(pre\014x)i Ff(\()p Fn(char)15 b(*string,)f(int)g
+(direction)p Ff(\))120 1128 y Fo(Searc)o(h)22 b(the)h(history)f(for)f
+Fj(string)p Fo(,)j(starting)e(at)f(the)i(curren)o(t)f(history)g
+(o\013set.)40 b(The)22 b(searc)o(h)g(is)120 1190 y(anc)o(hored:)i(matc)
+o(hing)18 b(lines)h(m)o(ust)d(b)q(egin)j(with)f Fj(string)p
+Fo(.)26 b(If)17 b Fj(direction)i Fn(<)e Fo(0,)g(then)h(the)f(searc)o(h)
+g(is)120 1253 y(through)e(previous)h(en)o(tries,)f(else)i(through)d
+(subsequen)o(t.)21 b(If)16 b Fj(string)j Fo(is)d(found,)f(then)h(the)f
+(curren)o(t)120 1315 y(history)20 b(index)i(is)e(set)g(to)g(that)f(en)o
+(try)l(,)i(and)f(the)g(return)h(v)m(alue)g(is)g(0.)34
+b(Otherwise,)22 b(nothing)e(is)120 1377 y(c)o(hanged,)15
+b(and)h(a)e(-1)h(is)h(returned.)1725 1532 y(F)l(unction)-1899
+b Fh(int)20 b Fg(history)p 276 1532 V 20 w(searc)n(h)p
+452 1532 V 21 w(p)r(os)h Ff(\()p Fn(char)15 b(*string,)f(int)g
+(direction,)g(int)h(pos)p Ff(\))120 1594 y Fo(Searc)o(h)d(for)f
+Fj(string)k Fo(in)d(the)g(history)f(list,)i(starting)e(at)g
+Fj(p)q(os)p Fo(,)h(an)f(absolute)h(index)h(in)o(to)e(the)h(list.)19
+b(If)12 b Fj(di-)120 1656 y(rection)g Fo(is)h(negativ)o(e,)f(the)g
+(searc)o(h)g(pro)q(ceeds)h(bac)o(kw)o(ard)e(from)g Fj(p)q(os)p
+Fo(,)i(otherwise)f(forw)o(ard.)17 b(Returns)120 1719
+y(the)e(absolute)h(index)g(of)f(the)g(history)h(elemen)o(t)f(where)h
+Fj(string)j Fo(w)o(as)14 b(found,)h(or)g(-1)g(otherwise.)0
+1912 y Fi(2.3.6)30 b(Managing)14 b(the)i(History)f(File)62
+2049 y Fo(The)f(History)g(library)h(can)f(read)g(the)g(history)g(from)f
+(and)i(write)f(it)g(to)f(a)h(\014le.)20 b(This)15 b(section)g(do)q
+(cumen)o(ts)f(the)0 2111 y(functions)i(for)f(managing)g(a)f(history)i
+(\014le.)1725 2266 y(F)l(unction)-1899 b Fh(int)20 b
+Fg(read)p 211 2266 V 20 w(history)i Ff(\()p Fn(char)15
+b(*filename)p Ff(\))120 2328 y Fo(Add)i(the)f(con)o(ten)o(ts)g(of)g
+Fj(\014lename)k Fo(to)c(the)h(history)f(list,)h(a)f(line)i(at)e(a)g
+(time.)24 b(If)17 b Fj(\014lename)j Fo(is)d Fn(NULL)p
+Fo(,)120 2391 y(then)f(read)f(from)f(`)p Fn(~/.history)p
+Fo('.)k(Returns)e(0)e(if)i(successful,)g(or)f(errno)g(if)h(not.)1725
+2545 y(F)l(unction)-1899 b Fh(int)20 b Fg(read)p 211
+2545 V 20 w(history)p 406 2545 V 20 w(range)i Ff(\()p
+Fn(char)15 b(*filename,)e(int)i(from,)g(int)f(to)p Ff(\))120
+2608 y Fo(Read)j(a)e(range)h(of)f(lines)j(from)d Fj(\014lename)p
+Fo(,)i(adding)f(them)g(to)f(the)h(history)g(list.)23
+b(Start)15 b(reading)i(at)120 2670 y(line)f Fj(from)f
+Fo(and)g(end)g(at)f Fj(to)p Fo(.)19 b(If)d Fj(from)e
+Fo(is)h(zero,)f(start)g(at)g(the)h(b)q(eginning.)22 b(If)15
+b Fj(to)i Fo(is)e(less)g(than)g Fj(from)p Fo(,)p eop
+10 11 bop 0 -58 a Fo(10)1474 b(GNU)15 b(History)g(Library)120
+183 y(then)i(read)g(un)o(til)h(the)f(end)g(of)g(the)g(\014le.)25
+b(If)17 b Fj(\014lename)k Fo(is)c Fn(NULL)p Fo(,)f(then)i(read)e(from)g
+(`)p Fn(~/.history)p Fo('.)120 246 y(Returns)g(0)f(if)g(successful,)h
+(or)f Fn(errno)g Fo(if)g(not.)1725 410 y(F)l(unction)-1899
+b Fh(int)20 b Fg(write)p 229 410 18 3 v 22 w(history)i
+Ff(\()p Fn(char)15 b(*filename)p Ff(\))120 472 y Fo(W)l(rite)20
+b(the)g(curren)o(t)f(history)h(to)f Fj(\014lename)p Fo(,)i(o)o(v)o
+(erwriting)f Fj(\014lename)j Fo(if)d(necessary)l(.)34
+b(If)20 b Fj(\014lename)120 534 y Fo(is)d Fn(NULL)p Fo(,)g(then)g
+(write)g(the)g(history)g(list)h(to)e(`)p Fn(~/.history)p
+Fo('.)23 b(V)l(alues)18 b(returned)g(are)e(as)h(in)h
+Fn(read_)120 596 y(history)c(\(\))p Fo(.)1725 760 y(F)l(unction)-1899
+b Fh(int)20 b Fg(app)r(end)p 285 760 V 19 w(history)j
+Ff(\()p Fn(int)14 b(nelements,)g(char)h(*filename)p Ff(\))120
+823 y Fo(App)q(end)i(the)e(last)g Fj(nelemen)o(ts)j Fo(of)d(the)g
+(history)g(list)h(to)f Fj(\014lename)p Fo(.)1725 987
+y(F)l(unction)-1899 b Fh(int)20 b Fg(history)p 276 987
+V 20 w(truncate)p 507 987 V 21 w(\014le)k Ff(\()p Fn(char)14
+b(*filename,)g(int)h(nlines)p Ff(\))120 1049 y Fo(T)l(runcate)g(the)h
+(history)f(\014le)h Fj(\014lename)p Fo(,)g(lea)o(ving)g(only)g(the)f
+(last)g Fj(nlines)k Fo(lines.)0 1263 y Fi(2.3.7)30 b(History)15
+b(Expansion)62 1401 y Fo(These)h(functions)g(implemen)o(t)g
+Fn(csh)p Fo(-lik)o(e)g(history)g(expansion.)1725 1565
+y(F)l(unction)-1899 b Fh(int)20 b Fg(history)p 276 1565
+V 20 w(expand)j Ff(\()p Fn(char)14 b(*string,)g(char)h(**output)p
+Ff(\))120 1627 y Fo(Expand)20 b Fj(string)p Fo(,)f(placing)i(the)e
+(result)h(in)o(to)f Fj(output)p Fo(,)h(a)f(p)q(oin)o(ter)h(to)e(a)h
+(string)h(\(see)f(Section)h(1.1)120 1689 y([History)15
+b(In)o(teraction],)f(page)h(1\).)20 b(Returns:)120 1840
+y Fn(0)216 b Fo(If)21 b(no)g(expansions)h(to)q(ok)e(place)h(\(or,)g(if)
+h(the)f(only)g(c)o(hange)g(in)h(the)f(text)f(w)o(as)g(the)360
+1902 y(de-slashifying)d(of)e(the)g(history)h(expansion)g(c)o
+(haracter\);)120 1991 y Fn(1)216 b Fo(if)16 b(expansions)g(did)g(tak)o
+(e)e(place;)120 2080 y Fn(-1)192 b Fo(if)16 b(there)f(w)o(as)f(an)h
+(error)g(in)h(expansion;)120 2168 y Fn(2)216 b Fo(if)14
+b(the)f(returned)h(line)h(should)f(only)g(b)q(e)f(displa)o(y)o(ed,)i
+(but)e(not)g(executed,)h(as)f(with)h(the)360 2231 y Fn(:p)h
+Fo(mo)q(di\014er)h(\(see)f(Section)h(1.1.3)e([Mo)q(di\014ers],)h(page)g
+(2\).)120 2381 y(If)g(an)h(error)e(o)q(curred)i(in)g(expansion,)f(then)
+h Fj(output)g Fo(con)o(tains)f(a)g(descriptiv)o(e)i(error)d(message.)
+1725 2545 y(F)l(unction)-1899 b Fh(char)20 b(*)f Fg(history)p
+347 2545 V 21 w(arg)p 449 2545 V 19 w(extract)24 b Ff(\()p
+Fn(int)14 b(first,)h(int)g(last,)f(char)h(*string)p Ff(\))120
+2608 y Fo(Extract)10 b(a)h(string)g(segmen)o(t)g(consisting)h(of)f(the)
+g Fj(\014rst)h Fo(through)f Fj(last)h Fo(argumen)o(ts)e(presen)o(t)h
+(in)h Fj(string)p Fo(.)120 2670 y(Argumen)o(ts)j(are)g(brok)o(en)g(up)g
+(as)g(in)h(Bash.)p eop
+11 12 bop 0 -58 a Fo(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(History)1017 b(11)1725 183 y(F)l(unction)-1899 b Fh(char)20
+b(*)f Fg(get)p 249 183 18 3 v 21 w(history)p 445 183
+V 20 w(ev)n(en)n(t)25 b Ff(\()p Fn(char)14 b(*string,)g(int)h(*cindex,)
+f(int)h(qchar)p Ff(\))120 246 y Fo(Returns)e(the)f(text)f(of)h(the)g
+(history)g(ev)o(en)o(t)f(b)q(eginning)k(at)c Fj(string)16
+b Fn(+)c Fj(*cindex)p Fo(.)20 b Fj(*cindex)c Fo(is)d(mo)q(di\014ed)120
+308 y(to)h(p)q(oin)o(t)h(to)f(after)h(the)f(ev)o(en)o(t)h(sp)q
+(eci\014er.)21 b(A)o(t)15 b(function)g(en)o(try)l(,)f
+Fj(cindex)20 b Fo(p)q(oin)o(ts)15 b(to)f(the)h(index)h(in)o(to)120
+370 y Fj(string)h Fo(where)d(the)f(history)h(ev)o(en)o(t)f(sp)q
+(eci\014cation)i(b)q(egins.)20 b Fj(qc)o(har)d Fo(is)c(a)g(c)o
+(haracter)g(that)g(is)h(allo)o(w)o(ed)120 432 y(to)h(end)g(the)h(ev)o
+(en)o(t)f(sp)q(eci\014cation)i(in)f(addition)g(to)f(the)g(\\normal")g
+(terminating)g(c)o(haracters.)1725 587 y(F)l(unction)-1899
+b Fh(char)20 b(**)f Fg(history)p 373 587 V 21 w(tok)n(enize)25
+b Ff(\()p Fn(char)14 b(*string)p Ff(\))120 649 y Fo(Return)k(an)f(arra)
+o(y)f(of)h(tok)o(ens)f(parsed)i(out)e(of)h Fj(string)p
+Fo(,)g(m)o(uc)o(h)h(as)e(the)i(shell)g(migh)o(t.)26 b(The)17
+b(tok)o(ens)120 711 y(are)c(split)h(on)f(white)g(space)h(and)f(on)g
+(the)g(c)o(haracters)f Fn(\(\)<>;&|$)p Fo(,)g(and)h(shell)i(quoting)e
+(con)o(v)o(en)o(tions)120 774 y(are)i(ob)q(ey)o(ed.)0
+983 y Fm(2.4)33 b(History)15 b(V)-6 b(ariables)62 1120
+y Fo(This)16 b(section)g(describ)q(es)h(the)e(externally)h(visible)i(v)
+m(ariables)e(exp)q(orted)g(b)o(y)f(the)g(GNU)g(History)g(Library)l(.)
+1736 1275 y(V)l(ariable)-1899 b Fh(int)20 b Fg(history)p
+276 1275 V 20 w(base)120 1337 y Fo(The)15 b(logical)i(o\013set)d(of)h
+(the)g(\014rst)g(en)o(try)g(in)h(the)f(history)g(list.)1736
+1491 y(V)l(ariable)-1899 b Fh(int)20 b Fg(history)p 276
+1491 V 20 w(length)120 1554 y Fo(The)15 b(n)o(um)o(b)q(er)h(of)f(en)o
+(tries)g(curren)o(tly)h(stored)f(in)h(the)f(history)g(list.)1736
+1708 y(V)l(ariable)-1899 b Fh(int)20 b Fg(max)p 208 1708
+V 19 w(input)p 360 1708 V 21 w(history)120 1771 y Fo(The)12
+b(maxim)o(um)g(n)o(um)o(b)q(er)g(of)f(history)h(en)o(tries.)19
+b(This)12 b(m)o(ust)f(b)q(e)h(c)o(hanged)g(using)h Fn(stifle_history)
+120 1833 y(\(\))p Fo(.)1736 1987 y(V)l(ariable)-1899
+b Fh(char)20 b Fg(history)p 302 1987 V 20 w(expansion)p
+569 1987 V 21 w(c)n(har)120 2050 y Fo(The)15 b(c)o(haracter)g(that)f
+(starts)g(a)h(history)g(ev)o(en)o(t.)20 b(The)15 b(default)h(is)g(`)p
+Fn(!)p Fo('.)1736 2204 y(V)l(ariable)-1899 b Fh(char)20
+b Fg(history)p 302 2204 V 20 w(subst)p 454 2204 V 20
+w(c)n(har)120 2266 y Fo(The)13 b(c)o(haracter)e(that)h(in)o(v)o(ok)o
+(es)g(w)o(ord)g(substitution)h(if)g(found)g(at)e(the)i(start)e(of)h(a)g
+(line.)21 b(The)12 b(default)120 2329 y(is)k(`)p Fn(^)p
+Fo('.)1736 2483 y(V)l(ariable)-1899 b Fh(char)20 b Fg(history)p
+302 2483 V 20 w(commen)n(t)p 552 2483 V 19 w(c)n(har)120
+2545 y Fo(During)12 b(tok)o(enization,)h(if)f(this)h(c)o(haracter)e(is)
+i(seen)f(as)g(the)g(\014rst)f(c)o(haracter)g(of)h(a)g(w)o(ord,)f(then)i
+(it)f(and)120 2608 y(all)19 b(subsequen)o(t)g(c)o(haracters)e(up)h(to)g
+(a)f(newline)j(are)e(ignored,)h(suppressing)g(history)f(expansion)120
+2670 y(for)d(the)g(remainder)h(of)f(the)g(line.)21 b(This)16
+b(is)g(disabled)h(b)o(y)e(default.)p eop
+12 13 bop 0 -58 a Fo(12)1474 b(GNU)15 b(History)g(Library)1736
+183 y(V)l(ariable)-1899 b Fh(char)20 b(*)f Fg(history)p
+347 183 18 3 v 21 w(no)p 429 183 V 20 w(expand)p 629
+183 V 20 w(c)n(hars)120 246 y Fo(The)f(list)g(of)g(c)o(haracters)e
+(whic)o(h)j(inhibit)h(history)d(expansion)i(if)f(found)g(immediately)h
+(follo)o(wing)120 308 y Fj(history)p 261 308 14 2 v 16
+w(expansion)p 472 308 V 18 w(c)o(har)p Fo(.)g(The)d(default)f(is)h
+(whitespace)g(and)g(`)p Fn(=)p Fo('.)1736 469 y(V)l(ariable)-1899
+b Fh(char)20 b(*)f Fg(history)p 347 469 18 3 v 21 w(searc)n(h)p
+524 469 V 20 w(delimiter)p 768 469 V 23 w(c)n(hars)120
+532 y Fo(The)d(list)g(of)f(additional)i(c)o(haracters)d(whic)o(h)i(can)
+g(delimit)h(a)e(history)g(searc)o(h)h(string,)f(in)h(addition)120
+594 y(to)f(whitespace,)g(`)p Fn(:)p Fo(')f(and)i(`)p
+Fn(?)p Fo(')e(in)i(the)f(case)h(of)e(a)h(substring)h(searc)o(h.)k(The)
+15 b(default)h(is)g(empt)o(y)l(.)1736 755 y(V)l(ariable)-1899
+b Fh(int)20 b Fg(history)p 276 755 V 20 w(quotes)p 458
+755 V 21 w(inhibit)p 642 755 V 23 w(expansion)120 818
+y Fo(If)e(non-zero,)f(single-quoted)i(w)o(ords)e(are)g(not)g(scanned)h
+(for)e(the)i(history)f(expansion)h(c)o(haracter.)120
+880 y(The)d(default)h(v)m(alue)h(is)e(0.)1736 1041 y(V)l(ariable)-1899
+b Fh(Function)20 b(*)g Fg(history)p 452 1041 V 20 w(inhibit)p
+635 1041 V 23 w(expansion)p 905 1041 V 21 w(function)120
+1104 y Fo(This)f(should)h(b)q(e)f(set)f(to)g(the)h(address)f(of)g(a)h
+(function)g(that)f(tak)o(es)f(t)o(w)o(o)h(argumen)o(ts:)25
+b(a)19 b Fn(char)14 b(*)120 1166 y Fo(\()p Fj(string)t
+Fo(\))c(and)i(an)f(in)o(teger)g(index)h(in)o(to)f(that)g(string)g(\()p
+Fj(i)r Fo(\).)19 b(It)11 b(should)h(return)f(a)g(non-zero)g(v)m(alue)h
+(if)g(the)120 1228 y(history)17 b(expansion)h(starting)e(at)h
+Fj(string[i])h Fo(should)g(not)f(b)q(e)h(p)q(erformed;)f(zero)g(if)h
+(the)f(expansion)120 1290 y(should)i(b)q(e)f(done.)28
+b(It)18 b(is)g(in)o(tended)h(for)e(use)h(b)o(y)g(applications)h(lik)o
+(e)g(Bash)f(that)f(use)h(the)g(history)120 1353 y(expansion)e(c)o
+(haracter)f(for)f(additional)j(purp)q(oses.)j(By)c(default,)f(this)h(v)
+m(ariable)g(is)g(set)f(to)f(NULL.)0 1576 y Fm(2.5)33
+b(History)15 b(Programming)h(Example)62 1713 y Fo(The)g(follo)o(wing)g
+(program)e(demonstrates)g(simple)j(use)e(of)g(the)g(GNU)g(History)g
+(Library)l(.)120 1840 y Fn(main)23 b(\(\))120 1892 y({)168
+1944 y(char)g(line[1024],)f(*t;)168 1995 y(int)h(len,)g(done)h(=)g(0;)
+168 2099 y(line[0])f(=)g(0;)168 2203 y(using_history)f(\(\);)168
+2255 y(while)h(\(!done\))215 2307 y({)263 2359 y(printf)g(\("history$)g
+("\);)263 2411 y(fflush)g(\(stdout\);)263 2462 y(t)h(=)g(fgets)f
+(\(line,)g(sizeof)g(\(line\))g(-)h(1,)f(stdin\);)263
+2514 y(if)h(\(t)f(&&)h(*t\))311 2566 y({)359 2618 y(len)f(=)h(strlen)f
+(\(t\);)359 2670 y(if)g(\(t[len)g(-)h(1])g(==)f('\\n'\))p
+eop
+13 14 bop 0 -58 a Fo(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(History)1017 b(13)406 183 y Fn(t[len)24 b(-)f(1])h(=)g('\\0';)311
+235 y(})263 339 y(if)g(\(!t\))311 391 y(strcpy)f(\(line,)g("quit"\);)
+263 495 y(if)h(\(line[0]\))311 546 y({)359 598 y(char)f(*expansion;)359
+650 y(int)g(result;)359 754 y(result)g(=)g(history_expand)f(\(line,)h
+(&expansion\);)359 806 y(if)g(\(result\))406 858 y(fprintf)g(\(stderr,)
+g("\045s\\n",)g(expansion\);)359 962 y(if)g(\(result)g(<)h(0)g(||)f
+(result)g(==)h(2\))406 1013 y({)454 1065 y(free)f(\(expansion\);)454
+1117 y(continue;)406 1169 y(})359 1273 y(add_history)f(\(expansion\);)
+359 1325 y(strncpy)h(\(line,)g(expansion,)f(sizeof)h(\(line\))g(-)h
+(1\);)359 1377 y(free)f(\(expansion\);)311 1429 y(})263
+1532 y(if)h(\(strcmp)f(\(line,)g("quit"\))g(==)g(0\))311
+1584 y(done)g(=)h(1;)263 1636 y(else)f(if)h(\(strcmp)f(\(line,)g
+("save"\))g(==)h(0\))311 1688 y(write_history)e(\("history_file"\);)263
+1740 y(else)h(if)h(\(strcmp)f(\(line,)g("read"\))g(==)h(0\))311
+1792 y(read_history)e(\("history_file"\);)263 1844 y(else)h(if)h
+(\(strcmp)f(\(line,)g("list"\))g(==)h(0\))311 1896 y({)359
+1947 y(register)e(HIST_ENTRY)h(**the_list;)359 1999 y(register)f(int)i
+(i;)359 2103 y(the_list)e(=)i(history_list)e(\(\);)359
+2155 y(if)h(\(the_list\))406 2207 y(for)h(\(i)f(=)h(0;)g(the_list[i];)e
+(i++\))454 2259 y(printf)h(\("\045d:)g(\045s\\n",)g(i)h(+)g
+(history_base,)e(the_list[i]->line\);)311 2311 y(})263
+2363 y(else)h(if)h(\(strncmp)f(\(line,)g("delete",)g(6\))g(==)h(0\))311
+2414 y({)359 2466 y(int)f(which;)359 2518 y(if)g(\(\(sscanf)g(\(line)g
+(+)h(6,)f("\045d",)h(&which\)\))e(==)i(1\))406 2570 y({)454
+2622 y(HIST_ENTRY)f(*entry)g(=)g(remove_history)f(\(which\);)p
+eop
+14 15 bop 0 -58 a Fo(14)1474 b(GNU)15 b(History)g(Library)454
+183 y Fn(if)24 b(\(!entry\))502 235 y(fprintf)f(\(stderr,)f("No)i(such)
+f(entry)g(\045d\\n",)g(which\);)454 287 y(else)502 339
+y({)550 391 y(free)g(\(entry->line\);)550 443 y(free)g(\(entry\);)502
+495 y(})406 546 y(})359 598 y(else)406 650 y({)454 702
+y(fprintf)g(\(stderr,)g("non-numeric)f(arg)h(given)h(to)f
+(`delete'\\n"\);)406 754 y(})311 806 y(})215 858 y(})120
+910 y(})p eop
+15 16 bop 0 -58 a Fo(App)q(endix)17 b(A:)e(Concept)g(Index)1346
+b(15)0 183 y Fk(App)r(endix)13 b(A)41 b(Concept)15 b(Index)0
+430 y Fm(A)0 496 y Fe(anc)o(hored)f(searc)o(h)5 b Fd(.)i(.)f(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)18
+b Fe(9)0 604 y Fm(E)0 670 y Fe(ev)o(en)o(t)13 b(designators)g
+Fd(.)6 b(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)23 b Fe(1)1015 430 y Fm(H)1015 496 y Fe(history)15
+b(ev)o(en)o(ts)5 b Fd(.)i(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)18 b Fe(1)1015 554
+y(history)d(expansion)8 b Fd(.)h(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)f(.)g(.)g(.)g(.)21 b Fe(1)1015 612 y(History)14
+b(Searc)o(hing)7 b Fd(.)h(.)e(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)20 b Fe(9)p eop
+16 17 bop 0 -58 a Fo(16)1474 b(GNU)15 b(History)g(Library)p
+eop
+17 18 bop 0 -58 a Fo(App)q(endix)17 b(B:)e(F)l(unction)h(and)g(V)l
+(ariable)g(Index)1069 b(17)0 183 y Fk(App)r(endix)13
+b(B)41 b(F)-7 b(unction)15 b(and)g(V)-7 b(ariable)14
+b(Index)0 430 y Fm(A)0 496 y Fc(add)p 62 496 12 2 v 13
+w(history)8 b Fd(.)s(.)e(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)20 b Fe(7)0 554 y
+Fc(append)p 122 554 V 12 w(history)9 b Fd(.)d(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)24 b Fe(10)0
+679 y Fm(C)0 745 y Fc(clear)p 102 745 V 12 w(history)5
+b Fd(.)t(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)18 b Fe(7)0 803 y Fc(current)p 142 803
+V 11 w(history)9 b Fd(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)24 b Fe(8)0 928 y Fm(G)0 994 y Fc(get)p
+62 994 V 13 w(history)p 215 994 V 11 w(event)9 b Fd(.)d(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)23 b Fe(11)0 1119
+y Fm(H)0 1185 y Fc(history)p 142 1185 V 11 w(arg)p 213
+1185 V 13 w(extract)8 b Fd(.)t(.)e(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)21 b Fe(10)0 1243 y Fc(history)p 142 1243 V 11 w(base)e
+Fd(.)6 b(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)20 b Fe(11)0 1301 y Fc(history)p 142 1301
+V 11 w(comment)p 293 1301 V 12 w(char)g Fd(.)6 b(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)h(.)21 b Fe(11)0 1359 y Fc(history)p 142 1359
+V 11 w(expand)10 b Fd(.)c(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)g(.)24 b Fe(10)0 1418 y Fc(history)p
+142 1418 V 11 w(expansion)p 333 1418 V 11 w(char)17 b
+Fd(.)7 b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)19 b Fe(11)0 1476
+y Fc(history)p 142 1476 V 11 w(get)8 b Fd(.)d(.)h(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)20
+b Fe(8)0 1534 y Fc(history)p 142 1534 V 11 w(get)p 213
+1534 V 13 w(history)p 366 1534 V 12 w(state)t Fd(.)t(.)6
+b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)17 b Fe(6)0 1592 y Fc(history)p
+142 1592 V 11 w(inhibit)p 293 1592 V 12 w(expansion)p
+484 1592 V 10 w(function)k Fd(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)23 b Fe(12)0 1650 y Fc(history)p 142 1650 V 11
+w(is)p 193 1650 V 14 w(stifled)7 b Fd(.)f(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)23 b Fe(7)0 1708 y Fc(history)p
+142 1708 V 11 w(length)16 b Fd(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)18 b Fe(11)0 1766 y Fc(history)p
+142 1766 V 11 w(list)7 b Fd(.)t(.)g(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)19 b Fe(8)0 1824
+y Fc(history)p 142 1824 V 11 w(no)p 193 1824 V 14 w(expand)p
+327 1824 V 12 w(chars)f Fd(.)6 b(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)20
+b Fe(12)0 1883 y Fc(history)p 142 1883 V 11 w(quotes)p
+273 1883 V 12 w(inhibit)p 425 1883 V 12 w(expansion)14
+b Fd(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)17
+b Fe(12)0 1941 y Fc(history)p 142 1941 V 11 w(search)t
+Fd(.)t(.)6 b(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)17 b Fe(9)0 1999 y Fc(history)p 142 1999 V
+11 w(search)p 273 1999 V 12 w(delimiter)p 465 1999 V
+11 w(chars)h Fd(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)20 b Fe(12)0 2057 y Fc(history)p 142 2057
+V 11 w(search)p 273 2057 V 12 w(pos)9 b Fd(.)d(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)23 b Fe(9)0 2115 y Fc(history)p
+142 2115 V 11 w(search)p 273 2115 V 12 w(prefix)6 b Fd(.)t(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)19 b Fe(9)0 2173 y Fc(history)p
+142 2173 V 11 w(set)p 213 2173 V 13 w(history)p 366 2173
+V 12 w(state)t Fd(.)t(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)17 b Fe(6)1015
+430 y Fc(history)p 1157 430 V 12 w(set)p 1229 430 V 13
+w(pos)5 b Fd(.)g(.)h(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)19 b Fe(8)1015 488 y Fc(history)p 1157
+488 V 12 w(subst)p 1269 488 V 12 w(char)k Fd(.)6 b(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)25 b Fe(11)1015 546 y Fc(history)p
+1157 546 V 12 w(tokenize)9 b Fd(.)s(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)22 b Fe(11)1015 604 y Fc(history)p
+1157 604 V 12 w(total)p 1269 604 V 12 w(bytes)9 b Fd(.)t(.)d(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)22 b Fe(8)1015 662
+y Fc(history)p 1157 662 V 12 w(truncate)p 1329 662 V
+11 w(file)5 b Fd(.)g(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)19
+b Fe(10)1015 770 y Fm(M)1015 836 y Fc(max)p 1077 836
+V 13 w(input)p 1190 836 V 13 w(history)14 b Fd(.)6 b(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)17 b Fe(11)1015 944
+y Fm(N)1015 1011 y Fc(next)p 1097 1011 V 13 w(history)7
+b Fd(.)s(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)20 b Fe(8)1015 1119 y Fm(P)1015 1185
+y Fc(previous)p 1177 1185 V 12 w(history)7 b Fd(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)23 b Fe(8)1015
+1293 y Fm(R)1015 1359 y Fc(read)p 1097 1359 V 13 w(history)7
+b Fd(.)s(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)20 b Fe(9)1015 1418 y Fc(read)p 1097
+1418 V 13 w(history)p 1250 1418 V 11 w(range)9 b Fd(.)d(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)23 b Fe(9)1015 1476
+y Fc(remove)p 1137 1476 V 12 w(history)t Fd(.)t(.)6 b(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)17
+b Fe(7)1015 1534 y Fc(replace)p 1157 1534 V 12 w(history)p
+1309 1534 V 11 w(entry)6 b Fd(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)19 b Fe(7)1015 1642 y Fm(S)1015 1708 y Fc(stifle)p
+1137 1708 V 12 w(history)t Fd(.)t(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)17 b Fe(7)1015 1816
+y Fm(U)1015 1883 y Fc(unstifle)p 1177 1883 V 12 w(history)7
+b Fd(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)23
+b Fe(7)1015 1941 y Fc(using)p 1117 1941 V 13 w(history)5
+b Fd(.)s(.)h(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)h(.)f(.)g(.)18 b Fe(6)1015 2049 y Fm(W)1015 2115 y
+Fc(where)p 1117 2115 V 13 w(history)5 b Fd(.)s(.)h(.)g(.)h(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)18
+b Fe(8)1015 2173 y Fc(write)p 1117 2173 V 13 w(history)t
+Fd(.)s(.)6 b(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)17 b Fe(10)p eop
+18 19 bop 0 -58 a Fo(18)1474 b(GNU)15 b(History)g(Library)p
+eop
+-1 20 bop 1937 -58 a Fo(i)0 183 y Fk(T)-7 b(able)15 b(of)g(Con)n(ten)n
+(ts)0 358 y Fm(1)67 b(Using)22 b(History)h(In)n(teractiv)n(ely)15
+b Fb(.)e(.)c(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)f(.)h(.)g(.)37 b Fm(1)149 435 y Fo(1.1)45
+b(In)o(teractiv)o(e)15 b(History)g(Expansion)9 b Fa(.)g(.)e(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)23 b
+Fo(1)299 498 y(1.1.1)44 b(Ev)o(en)o(t)14 b(Designators)d
+Fa(.)d(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)26 b Fo(1)299 560 y(1.1.2)44 b(W)l(ord)15 b(Designators)t
+Fa(.)7 b(.)g(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)19 b Fo(2)299 622 y(1.1.3)44 b(Mo)q(di\014ers)15
+b Fa(.)8 b(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)29 b Fo(2)0
+747 y Fm(2)67 b(Programming)23 b(with)g(GNU)f(History)11
+b Fb(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)
+g(.)33 b Fm(5)149 825 y Fo(2.1)45 b(In)o(tro)q(duction)16
+b(to)f(History)9 b Fa(.)e(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)24 b Fo(5)149
+887 y(2.2)45 b(History)15 b(Storage)c Fa(.)c(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)26 b Fo(5)149 949 y(2.3)45 b(History)15
+b(F)l(unctions)c Fa(.)e(.)e(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)26
+b Fo(6)299 1011 y(2.3.1)44 b(Initializing)18 b(History)d(and)h(State)e
+(Managemen)o(t)g Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)29 b Fo(6)299 1074 y(2.3.2)44 b(History)15 b(List)h(Managemen)o
+(t)d Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)28
+b Fo(7)299 1136 y(2.3.3)44 b(Information)15 b(Ab)q(out)g(the)h(History)
+f(List)c Fa(.)d(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)g(.)f(.)h(.)f(.)h(.)25 b Fo(7)299 1198 y(2.3.4)44
+b(Mo)o(ving)15 b(Around)g(the)g(History)g(List)10 b Fa(.)f(.)e(.)h(.)f
+(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)25 b Fo(8)299 1260 y(2.3.5)44 b(Searc)o(hing)16
+b(the)f(History)g(List)7 b Fa(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)
+f(.)h(.)21 b Fo(9)299 1323 y(2.3.6)44 b(Managing)15 b(the)g(History)g
+(File)5 b Fa(.)k(.)e(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)20
+b Fo(9)299 1385 y(2.3.7)44 b(History)15 b(Expansion)8
+b Fa(.)g(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)23 b Fo(10)149 1447 y(2.4)45 b(History)15 b(V)l(ariables)5
+b Fa(.)k(.)e(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)20 b Fo(11)149
+1510 y(2.5)45 b(History)15 b(Programming)f(Example)6
+b Fa(.)j(.)e(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)21
+b Fo(12)0 1634 y Fm(App)r(endix)j(A)67 b(Concept)22 b(Index)7
+b Fb(.)k(.)f(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)
+h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)29 b Fm(15)0 1774 y(App)r(endix)24
+b(B)67 b(F)-6 b(unction)25 b(and)e(V)-6 b(ariable)24
+b(Index)13 b Fb(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)35
+b Fm(17)p eop
+-2 21 bop 0 -58 a Fo(ii)1496 b(GNU)15 b(History)g(Library)p
+eop end
+userdict /end-hook known{end-hook}if
diff --git a/readline/doc/history_toc.html b/readline/doc/history_toc.html
new file mode 100644
--- /dev/null
+++ b/readline/doc/history_toc.html
@@ -0,0 +1,51 @@
+<HTML>
+<HEAD>
+<!-- This HTML file has been created by texi2html 1.51
+     from /usr/homes/chet/src/bash/readline-src/doc/hist.texinfo on 16 April 1997 -->
+
+<TITLE>GNU History Library - Table of Contents</TITLE>
+</HEAD>
+<BODY>
+<H1>GNU History Library</H1>
+<H2>Edition 2.1, for <CODE>History Library</CODE> Version 2.1.</H2>
+<H2>March 1996</H2>
+<ADDRESS>Brian Fox, Free Software Foundation</ADDRESS>
+<ADDRESS>Chet Ramey, Case Western Reserve University</ADDRESS>
+<P>
+<P><HR><P>
+<UL>
+<LI><A NAME="TOC1" HREF="history.html#SEC1">Using History Interactively</A>
+<UL>
+<LI><A NAME="TOC2" HREF="history.html#SEC2">Interactive History Expansion</A>
+<UL>
+<LI><A NAME="TOC3" HREF="history.html#SEC3">Event Designators</A>
+<LI><A NAME="TOC4" HREF="history.html#SEC4">Word Designators</A>
+<LI><A NAME="TOC5" HREF="history.html#SEC5">Modifiers</A>
+</UL>
+</UL>
+<LI><A NAME="TOC6" HREF="history.html#SEC6">Programming with GNU History</A>
+<UL>
+<LI><A NAME="TOC7" HREF="history.html#SEC7">Introduction to History</A>
+<LI><A NAME="TOC8" HREF="history.html#SEC8">History Storage</A>
+<LI><A NAME="TOC9" HREF="history.html#SEC9">History Functions</A>
+<UL>
+<LI><A NAME="TOC10" HREF="history.html#SEC10">Initializing History and State Management</A>
+<LI><A NAME="TOC11" HREF="history.html#SEC11">History List Management</A>
+<LI><A NAME="TOC12" HREF="history.html#SEC12">Information About the History List</A>
+<LI><A NAME="TOC13" HREF="history.html#SEC13">Moving Around the History List</A>
+<LI><A NAME="TOC14" HREF="history.html#SEC14">Searching the History List</A>
+<LI><A NAME="TOC15" HREF="history.html#SEC15">Managing the History File</A>
+<LI><A NAME="TOC16" HREF="history.html#SEC16">History Expansion</A>
+</UL>
+<LI><A NAME="TOC17" HREF="history.html#SEC17">History Variables</A>
+<LI><A NAME="TOC18" HREF="history.html#SEC18">History Programming Example</A>
+</UL>
+<LI><A NAME="TOC19" HREF="history.html#SEC19">Concept Index</A>
+<LI><A NAME="TOC20" HREF="history.html#SEC20">Function and Variable Index</A>
+</UL>
+<P><HR><P>
+This document was generated on 16 April 1997 using the
+<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
+translator version 1.51.</P>
+</BODY>
+</HTML>
diff --git a/readline/doc/hstech.texinfo b/readline/doc/hstech.texinfo
new file mode 100644
--- /dev/null
+++ b/readline/doc/hstech.texinfo
@@ -0,0 +1,515 @@
+@ignore
+This file documents the user interface to the GNU History library.
+
+Copyright (C) 1988, 1991, 1994, 1996 Free Software Foundation, Inc.
+Authored by Brian Fox and Chet Ramey.
+
+Permission is granted to make and distribute verbatim copies of this manual
+provided the copyright notice and this permission notice are preserved on
+all copies.
+
+Permission is granted to process this file through Tex and print the
+results, provided the printed document carries copying permission notice
+identical to this one except for the removal of this paragraph (this
+paragraph not being relevant to the printed manual).
+
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided also that the
+GNU Copyright statement is available to the distributee, and provided that
+the entire resulting derived work is distributed under the terms of a
+permission notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions.
+@end ignore
+
+@node Programming with GNU History
+@chapter Programming with GNU History
+
+This chapter describes how to interface programs that you write
+with the GNU History Library.
+It should be considered a technical guide.
+For information on the interactive use of GNU History, @pxref{Using
+History Interactively}.
+
+@menu
+* Introduction to History::	What is the GNU History library for?
+* History Storage::		How information is stored.
+* History Functions::		Functions that you can use.
+* History Variables::		Variables that control behaviour.
+* History Programming Example::	Example of using the GNU History Library.
+@end menu
+
+@node Introduction to History
+@section Introduction to History
+
+Many programs read input from the user a line at a time.  The GNU History
+library is able to keep track of those lines, associate arbitrary data with
+each line, and utilize information from previous lines in composing new
+ones.
+
+The programmer using the History library has available functions
+for remembering lines on a history list, associating arbitrary data
+with a line, removing lines from the list, searching through the list
+for a line containing an arbitrary text string, and referencing any line
+in the list directly.  In addition, a history @dfn{expansion} function
+is available which provides for a consistent user interface across
+different programs.
+
+The user using programs written with the History library has the
+benefit of a consistent user interface with a set of well-known
+commands for manipulating the text of previous lines and using that text
+in new commands.  The basic history manipulation commands are similar to
+the history substitution provided by @code{csh}.
+
+If the programmer desires, he can use the Readline library, which
+includes some history manipulation by default, and has the added
+advantage of command line editing.
+
+@node History Storage
+@section History Storage
+
+The history list is an array of history entries.  A history entry is
+declared as follows:
+
+@example
+typedef struct _hist_entry @{
+  char *line;
+  char *data;
+@} HIST_ENTRY;
+@end example
+
+The history list itself might therefore be declared as
+
+@example
+HIST_ENTRY **the_history_list;
+@end example
+
+The state of the History library is encapsulated into a single structure:
+
+@example
+/* A structure used to pass the current state of the history stuff around. */
+typedef struct _hist_state @{
+  HIST_ENTRY **entries;         /* Pointer to the entries themselves. */
+  int offset;                   /* The location pointer within this array. */
+  int length;                   /* Number of elements within this array. */
+  int size;                     /* Number of slots allocated to this array. */
+  int flags;
+@} HISTORY_STATE;
+@end example
+
+If the flags member includes @code{HS_STIFLED}, the history has been
+stifled.
+
+@node History Functions
+@section History Functions
+
+This section describes the calling sequence for the various functions
+present in GNU History.
+
+@menu
+* Initializing History and State Management::	Functions to call when you
+						want to use history in a
+						program.
+* History List Management::		Functions used to manage the list
+					of history entries.
+* Information About the History List::	Functions returning information about
+					the history list.
+* Moving Around the History List::	Functions used to change the position
+					in the history list.
+* Searching the History List::		Functions to search the history list
+					for entries containing a string.
+* Managing the History File::		Functions that read and write a file
+					containing the history list.
+* History Expansion::			Functions to perform csh-like history
+					expansion.
+@end menu
+
+@node Initializing History and State Management
+@subsection Initializing History and State Management
+
+This section describes functions used to initialize and manage
+the state of the History library when you want to use the history
+functions in your program.
+
+@deftypefun void using_history ()
+Begin a session in which the history functions might be used.  This
+initializes the interactive variables.
+@end deftypefun
+
+@deftypefun {HISTORY_STATE *} history_get_history_state ()
+Return a structure describing the current state of the input history.
+@end deftypefun
+
+@deftypefun void history_set_history_state (HISTORY_STATE *state)
+Set the state of the history list according to @var{state}.
+@end deftypefun
+
+@node History List Management
+@subsection History List Management
+
+These functions manage individual entries on the history list, or set
+parameters managing the list itself.
+
+@deftypefun void add_history (char *string)
+Place @var{string} at the end of the history list.  The associated data
+field (if any) is set to @code{NULL}.
+@end deftypefun
+
+@deftypefun {HIST_ENTRY *} remove_history (int which)
+Remove history entry at offset @var{which} from the history.  The
+removed element is returned so you can free the line, data,
+and containing structure.
+@end deftypefun
+
+@deftypefun {HIST_ENTRY *} replace_history_entry (int which, char *line, char *data)
+Make the history entry at offset @var{which} have @var{line} and @var{data}.
+This returns the old entry so you can dispose of the data.  In the case
+of an invalid @var{which}, a @code{NULL} pointer is returned.
+@end deftypefun
+
+@deftypefun void clear_history ()
+Clear the history list by deleting all the entries.
+@end deftypefun
+
+@deftypefun void stifle_history (int max)
+Stifle the history list, remembering only the last @var{max} entries.
+@end deftypefun
+
+@deftypefun int unstifle_history ()
+Stop stifling the history.  This returns the previous amount the
+history was stifled.  The value is positive if the history was
+stifled, negative if it wasn't.
+@end deftypefun
+
+@deftypefun int history_is_stifled ()
+Returns non-zero if the history is stifled, zero if it is not.
+@end deftypefun
+
+@node Information About the History List
+@subsection Information About the History List
+
+These functions return information about the entire history list or
+individual list entries.
+
+@deftypefun {HIST_ENTRY **} history_list ()
+Return a @code{NULL} terminated array of @code{HIST_ENTRY} which is the
+current input history.  Element 0 of this list is the beginning of time.
+If there is no history, return @code{NULL}.
+@end deftypefun
+
+@deftypefun int where_history ()
+Returns the offset of the current history element.
+@end deftypefun
+
+@deftypefun {HIST_ENTRY *} current_history ()
+Return the history entry at the current position, as determined by
+@code{where_history ()}.  If there is no entry there, return a @code{NULL}
+pointer.
+@end deftypefun
+
+@deftypefun {HIST_ENTRY *} history_get (int offset)
+Return the history entry at position @var{offset}, starting from
+@code{history_base}.  If there is no entry there, or if @var{offset}
+is greater than the history length, return a @code{NULL} pointer.
+@end deftypefun
+
+@deftypefun int history_total_bytes ()
+Return the number of bytes that the primary history entries are using.
+This function returns the sum of the lengths of all the lines in the
+history.
+@end deftypefun
+
+@node Moving Around the History List
+@subsection Moving Around the History List
+
+These functions allow the current index into the history list to be
+set or changed.
+
+@deftypefun int history_set_pos (int pos)
+Set the position in the history list to @var{pos}, an absolute index
+into the list.
+@end deftypefun
+
+@deftypefun {HIST_ENTRY *} previous_history ()
+Back up the current history offset to the previous history entry, and
+return a pointer to that entry.  If there is no previous entry, return
+a @code{NULL} pointer.
+@end deftypefun
+
+@deftypefun {HIST_ENTRY *} next_history ()
+Move the current history offset forward to the next history entry, and
+return the a pointer to that entry.  If there is no next entry, return
+a @code{NULL} pointer.
+@end deftypefun
+
+@node Searching the History List
+@subsection Searching the History List
+@cindex History Searching
+
+These functions allow searching of the history list for entries containing
+a specific string.  Searching may be performed both forward and backward
+from the current history position.  The search may be @dfn{anchored},
+meaning that the string must match at the beginning of the history entry.
+@cindex anchored search
+
+@deftypefun int history_search (char *string, int direction)
+Search the history for @var{string}, starting at the current history
+offset.  If @var{direction} < 0, then the search is through previous entries,
+else through subsequent.  If @var{string} is found, then
+the current history index is set to that history entry, and the value
+returned is the offset in the line of the entry where
+@var{string} was found.  Otherwise, nothing is changed, and a -1 is
+returned.
+@end deftypefun
+
+@deftypefun int history_search_prefix (char *string, int direction)
+Search the history for @var{string}, starting at the current history
+offset.  The search is anchored: matching lines must begin with
+@var{string}.  If @var{direction} < 0, then the search is through previous
+entries, else through subsequent.  If @var{string} is found, then the
+current history index is set to that entry, and the return value is 0. 
+Otherwise, nothing is changed, and a -1 is returned. 
+@end deftypefun
+
+@deftypefun int history_search_pos (char *string, int direction, int pos)
+Search for @var{string} in the history list, starting at @var{pos}, an
+absolute index into the list.  If @var{direction} is negative, the search
+proceeds backward from @var{pos}, otherwise forward.  Returns the absolute
+index of the history element where @var{string} was found, or -1 otherwise.
+@end deftypefun
+
+@node Managing the History File
+@subsection Managing the History File
+
+The History library can read the history from and write it to a file.
+This section documents the functions for managing a history file.
+
+@deftypefun int read_history (char *filename)
+Add the contents of @var{filename} to the history list, a line at a
+time.  If @var{filename} is @code{NULL}, then read from
+@file{~/.history}.  Returns 0 if successful, or errno if not.
+@end deftypefun
+
+@deftypefun int read_history_range (char *filename, int from, int to)
+Read a range of lines from @var{filename}, adding them to the history list.
+Start reading at line @var{from} and end at @var{to}.  If
+@var{from} is zero, start at the beginning.  If @var{to} is less than
+@var{from}, then read until the end of the file.  If @var{filename} is
+@code{NULL}, then read from @file{~/.history}.  Returns 0 if successful,
+or @code{errno} if not.
+@end deftypefun
+
+@deftypefun int write_history (char *filename)
+Write the current history to @var{filename}, overwriting @var{filename}
+if necessary.  If @var{filename} is
+@code{NULL}, then write the history list to @file{~/.history}.  Values
+returned are as in @code{read_history ()}.
+@end deftypefun
+
+@deftypefun int append_history (int nelements, char *filename)
+Append the last @var{nelements} of the history list to @var{filename}.
+@end deftypefun
+
+@deftypefun int history_truncate_file (char *filename, int nlines)
+Truncate the history file @var{filename}, leaving only the last
+@var{nlines} lines.
+@end deftypefun
+
+@node History Expansion
+@subsection History Expansion
+
+These functions implement @code{csh}-like history expansion.
+
+@deftypefun int history_expand (char *string, char **output)
+Expand @var{string}, placing the result into @var{output}, a pointer
+to a string (@pxref{History Interaction}).  Returns:
+@table @code
+@item 0
+If no expansions took place (or, if the only change in
+the text was the de-slashifying of the history expansion
+character);
+@item 1
+if expansions did take place;
+@item -1
+if there was an error in expansion;
+@item 2
+if the returned line should only be displayed, but not executed,
+as with the @code{:p} modifier (@pxref{Modifiers}).
+@end table
+
+If an error ocurred in expansion, then @var{output} contains a descriptive
+error message.
+@end deftypefun
+
+@deftypefun {char *} history_arg_extract (int first, int last, char *string)
+Extract a string segment consisting of the @var{first} through @var{last}
+arguments present in @var{string}.  Arguments are broken up as in Bash.
+@end deftypefun
+
+@deftypefun {char *} get_history_event (char *string, int *cindex, int qchar)
+Returns the text of the history event beginning at @var{string} +
+@var{*cindex}.  @var{*cindex} is modified to point to after the event
+specifier.  At function entry, @var{cindex} points to the index into
+@var{string} where the history event specification begins.  @var{qchar}
+is a character that is allowed to end the event specification in addition
+to the ``normal'' terminating characters.
+@end deftypefun
+
+@deftypefun {char **} history_tokenize (char *string)
+Return an array of tokens parsed out of @var{string}, much as the
+shell might.  The tokens are split on white space and on the
+characters @code{()<>;&|$}, and shell quoting conventions are
+obeyed.
+@end deftypefun
+
+@node History Variables
+@section History Variables
+
+This section describes the externally visible variables exported by
+the GNU History Library.
+
+@deftypevar int history_base
+The logical offset of the first entry in the history list.
+@end deftypevar
+
+@deftypevar int history_length
+The number of entries currently stored in the history list.
+@end deftypevar
+
+@deftypevar int max_input_history
+The maximum number of history entries.  This must be changed using
+@code{stifle_history ()}.
+@end deftypevar
+
+@deftypevar char history_expansion_char
+The character that starts a history event.  The default is @samp{!}.
+@end deftypevar
+
+@deftypevar char history_subst_char
+The character that invokes word substitution if found at the start of
+a line.  The default is @samp{^}.
+@end deftypevar
+
+@deftypevar char history_comment_char
+During tokenization, if this character is seen as the first character
+of a word, then it and all subsequent characters up to a newline are
+ignored, suppressing history expansion for the remainder of the line.
+This is disabled by default.
+@end deftypevar
+
+@deftypevar {char *} history_no_expand_chars
+The list of characters which inhibit history expansion if found immediately
+following @var{history_expansion_char}.  The default is whitespace and
+@samp{=}.
+@end deftypevar
+
+@deftypevar {char *} history_search_delimiter_chars
+The list of additional characters which can delimit a history search
+string, in addition to whitespace, @samp{:} and @samp{?} in the case of
+a substring search.  The default is empty.
+@end deftypevar
+
+@deftypevar int history_quotes_inhibit_expansion
+If non-zero, single-quoted words are not scanned for the history expansion
+character.  The default value is 0.
+@end deftypevar
+
+@deftypevar {Function *} history_inhibit_expansion_function
+This should be set to the address of a function that takes two arguments:
+a @code{char *} (@var{string}) and an integer index into that string (@var{i}).
+It should return a non-zero value if the history expansion starting at
+@var{string[i]} should not be performed; zero if the expansion should
+be done.
+It is intended for use by applications like Bash that use the history
+expansion character for additional purposes.
+By default, this variable is set to NULL.
+@end deftypevar
+
+@node History Programming Example
+@section History Programming Example
+
+The following program demonstrates simple use of the GNU History Library.
+
+@smallexample
+main ()
+@{
+  char line[1024], *t;
+  int len, done = 0;
+
+  line[0] = 0;
+
+  using_history ();
+  while (!done)
+    @{
+      printf ("history$ ");
+      fflush (stdout);
+      t = fgets (line, sizeof (line) - 1, stdin);
+      if (t && *t)
+        @{
+          len = strlen (t);
+          if (t[len - 1] == '\n')
+            t[len - 1] = '\0';
+        @}
+
+      if (!t)
+        strcpy (line, "quit");
+
+      if (line[0])
+        @{
+          char *expansion;
+          int result;
+
+          result = history_expand (line, &expansion);
+          if (result)
+            fprintf (stderr, "%s\n", expansion);
+
+          if (result < 0 || result == 2)
+            @{
+              free (expansion);
+              continue;
+            @}
+
+          add_history (expansion);
+          strncpy (line, expansion, sizeof (line) - 1);
+          free (expansion);
+        @}
+
+      if (strcmp (line, "quit") == 0)
+        done = 1;
+      else if (strcmp (line, "save") == 0)
+        write_history ("history_file");
+      else if (strcmp (line, "read") == 0)
+        read_history ("history_file");
+      else if (strcmp (line, "list") == 0)
+        @{
+          register HIST_ENTRY **the_list;
+          register int i;
+
+          the_list = history_list ();
+          if (the_list)
+            for (i = 0; the_list[i]; i++)
+              printf ("%d: %s\n", i + history_base, the_list[i]->line);
+        @}
+      else if (strncmp (line, "delete", 6) == 0)
+        @{
+          int which;
+          if ((sscanf (line + 6, "%d", &which)) == 1)
+            @{
+              HIST_ENTRY *entry = remove_history (which);
+              if (!entry)
+                fprintf (stderr, "No such entry %d\n", which);
+              else
+                @{
+                  free (entry->line);
+                  free (entry);
+                @}
+            @}
+          else
+            @{
+              fprintf (stderr, "non-numeric arg given to `delete'\n");
+            @}
+        @}
+    @}
+@}
+@end smallexample
diff --git a/readline/doc/hsuser.texinfo b/readline/doc/hsuser.texinfo
new file mode 100644
--- /dev/null
+++ b/readline/doc/hsuser.texinfo
@@ -0,0 +1,304 @@
+@ignore
+This file documents the user interface to the GNU History library.
+
+Copyright (C) 1988, 1991, 1996 Free Software Foundation, Inc.
+Authored by Brian Fox and Chet Ramey.
+
+Permission is granted to make and distribute verbatim copies of this manual
+provided the copyright notice and this permission notice are preserved on
+all copies.
+
+Permission is granted to process this file through Tex and print the
+results, provided the printed document carries copying permission notice
+identical to this one except for the removal of this paragraph (this
+paragraph not being relevant to the printed manual).
+
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided also that the
+GNU Copyright statement is available to the distributee, and provided that
+the entire resulting derived work is distributed under the terms of a
+permission notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions.
+@end ignore
+
+@node Using History Interactively
+@chapter Using History Interactively
+
+@ifset BashFeatures
+This chapter describes how to use the GNU History Library interactively,
+from a user's standpoint.  It should be considered a user's guide.  For
+information on using the GNU History Library in your own programs,
+see the GNU Readline Library Manual.
+@end ifset
+@ifclear BashFeatures
+This chapter describes how to use the GNU History Library interactively,
+from a user's standpoint.  It should be considered a user's guide.  For
+information on using the GNU History Library in your own programs,
+@pxref{Programming with GNU History}.
+@end ifclear
+
+@ifset BashFeatures
+@menu
+* Bash History Facilities::	How Bash lets you manipulate your command
+				history.
+* History Interaction::		What it feels like using History as a user.
+@end menu
+@end ifset
+@ifclear BashFeatures
+@menu
+* History Interaction::		What it feels like using History as a user.
+@end menu
+@end ifclear
+
+@ifset BashFeatures
+@node Bash History Facilities
+@section Bash History Facilities
+@cindex command history
+@cindex history list
+
+When the @samp{-o history} option to the @code{set} builtin
+is enabled (@pxref{The Set Builtin}),
+the shell provides access to the @var{command history},
+the list of commands previously typed.  The text of the last
+@code{HISTSIZE}
+commands (default 500) is saved in a history list.  The shell
+stores each command in the history list prior to parameter and
+variable expansion
+but after history expansion is performed, subject to the
+values of the shell variables
+@code{HISTIGNORE} and @code{HISTCONTROL}.
+When the shell starts up, the history is initialized from the
+file named by the @code{HISTFILE} variable (default @file{~/.bash_history}).
+@code{HISTFILE} is truncated, if necessary, to contain no more than
+the number of lines specified by the value of the @code{HISTFILESIZE}
+variable.  When an interactive shell exits, the last
+@code{HISTSIZE} lines are copied from the history list to @code{HISTFILE}.
+If the @code{histappend} shell option is set (@pxref{Bash Builtins}),
+the lines are appended to the history file,
+otherwise the history file is overwritten.
+If @code{HISTFILE}
+is unset, or if the history file is unwritable, the history is
+not saved.  After saving the history, the history file is truncated
+to contain no more than @code{$HISTFILESIZE}
+lines.  If @code{HISTFILESIZE} is not set, no truncation is performed.
+
+The builtin command @code{fc} (@pxref{Korn Shell Builtins})
+may be used to list or edit and re-execute a portion of
+the history list.  The @code{history} builtin (@pxref{C Shell Builtins})
+can be used to display or modify the history list and
+manipulate the history file.
+When using the command-line editing, search commands
+are available in each editing mode that provide access to the
+history list.
+
+The shell allows control over which commands are saved on the history
+list.  The @code{HISTCONTROL} and @code{HISTIGNORE}
+variables may be set to cause the shell to save only a subset of the
+commands entered.
+The @code{cmdhist}
+shell option, if enabled, causes the shell to attempt to save each
+line of a multi-line command in the same history entry, adding
+semicolons where necessary to preserve syntactic correctness.
+The @code{lithist}
+shell option causes the shell to save the command with embedded newlines
+instead of semicolons.
+@xref{Bash Builtins} for a description of @code{shopt}.
+@end ifset
+
+@node History Interaction
+@section Interactive History Expansion
+@cindex history expansion
+
+The History library provides a history expansion feature that is similar
+to the history expansion provided by @code{csh}.  This section
+describes the syntax used to manipulate the history information.
+
+History expansions introduce words from the history list into
+the input stream, making it easy to repeat commands, insert the
+arguments to a previous command into the current input line, or
+fix errors in previous commands quickly.
+
+History expansion takes place in two parts.  The first is to determine
+which line from the previous history should be used during substitution.
+The second is to select portions of that line for inclusion into the
+current one.  The line selected from the previous history is called the
+@dfn{event}, and the portions of that line that are acted upon are
+called @dfn{words}.  Various @dfn{modifiers} are available to manipulate
+the selected words.  The line is broken into words in the same fashion
+that Bash does, so that several English (or Unix) words
+surrounded by quotes are considered as one word.
+History expansions are introduced by the appearance of the
+history expansion character, which is @samp{!} by default.
+@ifset BashFeatures
+Only @samp{\} and @samp{'} may be used to escape the history expansion
+character.
+@end ifset
+
+@ifset BashFeatures
+Several shell options settable with the @code{shopt}
+builtin (@pxref{Bash Builtins}) may be used to tailor
+the behavior of history expansion.  If the
+@code{histverify} shell option is enabled, and Readline
+is being used, history substitutions are not immediately passed to
+the shell parser.
+Instead, the expanded line is reloaded into the Readline
+editing buffer for further modification.
+If Readline is being used, and the @code{histreedit}
+shell option is enabled, a failed history expansion will be
+reloaded into the Readline editing buffer for correction.
+The @samp{-p} option to the @code{history} builtin command
+may be used to see what a history expansion will do before using it.
+The @samp{-s} option to the @code{history} builtin may be used to
+add commands to the end of the history list without actually executing
+them, so that they are available for subsequent recall.
+
+The shell allows control of the various characters used by the
+history expansion mechanism with the @code{histchars} variable.
+@end ifset
+
+@menu
+* Event Designators::	How to specify which history line to use.
+* Word Designators::	Specifying which words are of interest.
+* Modifiers::		Modifying the results of substitution.
+@end menu
+
+@node Event Designators
+@subsection Event Designators
+@cindex event designators
+
+An event designator is a reference to a command line entry in the
+history list.
+@cindex history events
+
+@table @asis
+
+@item @code{!}
+Start a history substitution, except when followed by a space, tab,
+the end of the line, @key{=} or @key{(}.
+
+@item @code{!@var{n}}
+Refer to command line @var{n}.
+
+@item @code{!-@var{n}}
+Refer to the command @var{n} lines back.
+
+@item @code{!!}
+Refer to the previous command.  This is a synonym for @samp{!-1}.
+
+@item @code{!@var{string}}
+Refer to the most recent command starting with @var{string}.
+
+@item @code{!?@var{string}[?]}
+Refer to the most recent command containing @var{string}.  The trailing
+@samp{?} may be omitted if the @var{string} is followed immediately by
+a newline.
+
+@item @code{^@var{string1}^@var{string2}^}
+Quick Substitution.  Repeat the last command, replacing @var{string1}
+with @var{string2}.  Equivalent to
+@code{!!:s/@var{string1}/@var{string2}/}.
+
+@item @code{!#}
+The entire command line typed so far.
+
+@end table
+
+@node Word Designators
+@subsection Word Designators
+
+Word designators are used to select desired words from the event.
+A @samp{:} separates the event specification from the word designator.  It
+can be omitted if the word designator begins with a @samp{^}, @samp{$},
+@samp{*}, @samp{-}, or @samp{%}.  Words are numbered from the beginning
+of the line, with the first word being denoted by 0 (zero).  Words are
+inserted into the current line separated by single spaces.
+
+@table @code
+
+@item 0 (zero)
+The @code{0}th word.  For many applications, this is the command word.
+
+@item @var{n}
+The @var{n}th word.
+
+@item ^
+The first argument; that is, word 1.
+
+@item $
+The last argument.
+
+@item %
+The word matched by the most recent @samp{?@var{string}?} search.
+
+@item @var{x}-@var{y}
+A range of words; @samp{-@var{y}} abbreviates @samp{0-@var{y}}.
+
+@item *
+All of the words, except the @code{0}th.  This is a synonym for @samp{1-$}.
+It is not an error to use @samp{*} if there is just one word in the event;
+the empty string is returned in that case.
+
+@item @var{x}*
+Abbreviates @samp{@var{x}-$}
+
+@item @var{x}-
+Abbreviates @samp{@var{x}-$} like @samp{@var{x}*}, but omits the last word.
+
+@end table
+
+If a word designator is supplied without an event specification, the
+previous command is used as the event.
+
+@node Modifiers
+@subsection Modifiers
+
+After the optional word designator, you can add a sequence of one or more
+of the following modifiers, each preceded by a @samp{:}.
+
+@table @code
+
+@item h
+Remove a trailing pathname component, leaving only the head.
+
+@item t
+Remove all leading  pathname  components, leaving the tail.
+
+@item r
+Remove a trailing suffix of the form @samp{.@var{suffix}}, leaving
+the basename.
+
+@item e
+Remove all but the trailing suffix.
+
+@item p
+Print the new command but do not execute it.
+
+@ifset BashFeatures
+@item q
+Quote the substituted words, escaping further substitutions.
+
+@item x
+Quote the substituted words as with @samp{q},
+but break into words at spaces, tabs, and newlines.
+@end ifset
+
+@item s/@var{old}/@var{new}/
+Substitute @var{new} for the first occurrence of @var{old} in the
+event line.  Any delimiter may be used in place of @samp{/}.
+The delimiter may be quoted in @var{old} and @var{new}
+with a single backslash.  If @samp{&} appears in @var{new},
+it is replaced by @var{old}.  A single backslash will quote
+the @samp{&}.  The final delimiter is optional if it is the last
+character on the input line.
+
+@item &
+Repeat the previous substitution.
+
+@item g
+Cause changes to be applied over the entire event line.  Used in
+conjunction with @samp{s}, as in @code{gs/@var{old}/@var{new}/},
+or with @samp{&}.
+
+@end table
diff --git a/readline/doc/readline.0 b/readline/doc/readline.0
new file mode 100644
--- /dev/null
+++ b/readline/doc/readline.0
@@ -0,0 +1,1122 @@
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+NNAAMMEE
+       readline - get a line from a user with editing
+
+SSYYNNOOPPSSIISS
+       ##iinncclluuddee <<rreeaaddlliinnee..hh>>
+       ##iinncclluuddee <<hhiissttoorryy..hh>>
+
+       cchhaarr **rreeaaddlliinnee ((pprroommpptt))
+       cchhaarr **pprroommpptt;;
+
+CCOOPPYYRRIIGGHHTT
+       Readline  is Copyright (C) 1989, 1991, 1993, 1995, 1996 by
+       the Free Software Foundation, Inc.
+
+DDEESSCCRRIIPPTTIIOONN
+       rreeaaddlliinnee will read a line from the terminal and return it,
+       using pprroommpptt as a prompt.  If pprroommpptt is null, no prompt is
+       issued.  The line returned is allocated with _m_a_l_l_o_c(3), so
+       the  caller must free it when finished.  The line returned
+       has the final newline removed, so only  the  text  of  the
+       line remains.
+
+       rreeaaddlliinnee  offers  editing  capabilities  while the user is
+       entering the line.  By default, the line editing  commands
+       are  similar  to  those of emacs.  A vi-style line editing
+       interface is also available.
+
+RREETTUURRNN VVAALLUUEE
+       rreeaaddlliinnee returns the text of the line read.  A blank  line
+       returns  the  empty  string.   If EEOOFF is encountered while
+       reading a line, and the line is empty, NNUULLLL  is  returned.
+       If  an EEOOFF is read with a non-empty line, it is treated as
+       a newline.
+
+NNOOTTAATTIIOONN
+       An emacs-style notation  is  used  to  denote  keystrokes.
+       Control  keys  are  denoted by C-_k_e_y, e.g., C-n means Con-
+       trol-N.  Similarly, _m_e_t_a keys are denoted by M-_k_e_y, so M-x
+       means Meta-X.  (On keyboards without a _m_e_t_a key, M-_x means
+       ESC _x, i.e., press the Escape key then the  _x  key.   This
+       makes  ESC  the  _m_e_t_a _p_r_e_f_i_x.  The combination M-C-_x means
+       ESC-Control-_x, or press the Escape key then hold the  Con-
+       trol key while pressing the _x key.)
+
+       Readline  commands  may  be given numeric _a_r_g_u_m_e_n_t_s, which
+       normally act as a repeat count.  Sometimes, however, it is
+       the  sign  of the argument that is significant.  Passing a
+       negative argument to a command that acts  in  the  forward
+       direction  (e.g., kkiillll--lliinnee) causes that command to act in
+       a backward direction.  Commands whose behavior with  argu-
+       ments deviates from this are noted.
+
+       When  a  command  is  described  as _k_i_l_l_i_n_g text, the text
+       deleted is saved for possible future retrieval  (_y_a_n_k_i_n_g).
+
+
+
+GNU                         1997 Feb 5                          1
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+       The  killed  text  is  saved  in a _k_i_l_l _r_i_n_g.  Consecutive
+       kills cause the text to  be  accumulated  into  one  unit,
+       which  can  be  yanked all at once.  Commands which do not
+       kill text separate the chunks of text on the kill ring.
+
+IINNIITTIIAALLIIZZAATTIIOONN FFIILLEE
+       Readline is customized by putting commands in an  initial-
+       ization file (the _i_n_p_u_t_r_c file).  The name of this file is
+       taken from the value of the IINNPPUUTTRRCC environment  variable.
+       If  that  variable  is  unset,  the default is _~_/_._i_n_p_u_t_r_c.
+       When a program which uses the readline library starts  up,
+       the  init file is read, and the key bindings and variables
+       are set.  There are only a few basic constructs allowed in
+       the  readline  init file.  Blank lines are ignored.  Lines
+       beginning with a ## are comments.  Lines beginning with a $$
+       indicate  conditional  constructs.  Other lines denote key
+       bindings and variable settings.  Each program  using  this
+       library may add its own commands and bindings.
+
+       For example, placing
+
+              M-Control-u: universal-argument
+       or
+              C-Meta-u: universal-argument
+       into  the  _i_n_p_u_t_r_c  would  make M-C-u execute the readline
+       command _u_n_i_v_e_r_s_a_l_-_a_r_g_u_m_e_n_t.
+
+       The following  symbolic  character  names  are  recognized
+       while processing key bindings: _R_U_B_O_U_T, _D_E_L, _E_S_C, _L_F_D, _N_E_W_-
+       _L_I_N_E, _R_E_T, _R_E_T_U_R_N, _S_P_C, _S_P_A_C_E, and _T_A_B.   In  addition  to
+       command  names,  readline  allows  keys  to  be bound to a
+       string that is inserted when the key is pressed (a _m_a_c_r_o).
+
+
+   KKeeyy BBiinnddiinnggss
+       The  syntax  for  controlling  key bindings in the _i_n_p_u_t_r_c
+       file is simple.  All that is required is the name  of  the
+       command or the text of a macro and a key sequence to which
+       it should be bound. The name may be specified  in  one  of
+       two  ways:  as a symbolic key name, possibly with _M_e_t_a_- or
+       _C_o_n_t_r_o_l_- prefixes, or as a key sequence.  When  using  the
+       form  kkeeyynnaammee:_f_u_n_c_t_i_o_n_-_n_a_m_e  or _m_a_c_r_o, _k_e_y_n_a_m_e is the name
+       of a key spelled out in English.  For example:
+
+              Control-u: universal-argument
+              Meta-Rubout: backward-kill-word
+              Control-o: ">&output"
+
+       In the above example, _C_-_u is bound to the function uunniivveerr--
+       ssaall--aarrgguummeenntt,   _M_-_D_E_L  is  bound  to  the  function  bbaacckk--
+       wwaarrdd--kkiillll--wwoorrdd,  and  _C_-_o  is  bound  to  run  the   macro
+       expressed  on  the right hand side (that is, to insert the
+       text _>_&_o_u_t_p_u_t into the line).
+
+
+
+
+GNU                         1997 Feb 5                          2
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+       In the second form, ""kkeeyysseeqq"":_f_u_n_c_t_i_o_n_-_n_a_m_e or _m_a_c_r_o,  kkeeyy--
+       sseeqq differs from kkeeyynnaammee above in that strings denoting an
+       entire key  sequence  may  be  specified  by  placing  the
+       sequence  within  double quotes.  Some GNU Emacs style key
+       escapes can be used, as in the following example.
+
+              "\C-u": universal-argument
+              "\C-x\C-r": re-read-init-file
+              "\e[11~": "Function Key 1"
+
+       In this example, _C_-_u is again bound to the  function  uunnii--
+       vveerrssaall--aarrgguummeenntt.    _C_-_x  _C_-_r  is  bound  to  the  function
+       rree--rreeaadd--iinniitt--ffiillee, and _E_S_C _[ _1 _1 _~ is bound to insert  the
+       text FFuunnccttiioonn KKeeyy 11.  The full set of escape sequences is
+
+              \\CC--    control prefix
+
+              \\MM--    meta prefix
+
+              \\ee     an escape character
+
+              \\\\     backslash
+
+              \\""     literal "
+
+              \\''     literal '
+
+       When entering the text of a macro, single or double quotes
+       should be used to indicate a macro  definition.   Unquoted
+       text  is  assumed  to  be a function name.  Backslash will
+       quote any character in the macro text, including " and  '.
+
+       BBaasshh  allows  the current readline key bindings to be dis-
+       played or modified with the  bbiinndd  builtin  command.   The
+       editing  mode  may  be  switched during interactive use by
+       using the --oo option to the  sseett  builtin  command.   Other
+       programs  using  this  library provide similar mechanisms.
+       The _i_n_p_u_t_r_c file may be edited and re-read  if  a  program
+       does  not provide any other means to incorporate new bind-
+       ings.
+
+   VVaarriiaabblleess
+       Readline has variables that can be used  to  further  cus-
+       tomize its behavior.  A variable may be set in the _i_n_p_u_t_r_c
+       file with a statement of the form
+
+              sseett _v_a_r_i_a_b_l_e_-_n_a_m_e _v_a_l_u_e
+
+       Except where noted, readline variables can take the values
+       OOnn or OOffff.  The variables and their default values are:
+
+       bbeellll--ssttyyllee ((aauuddiibbllee))
+              Controls  what  happens when readline wants to ring
+              the terminal bell.  If set to nnoonnee, readline  never
+
+
+
+GNU                         1997 Feb 5                          3
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+              rings the bell.  If set to vviissiibbllee, readline uses a
+              visible bell if one is available.  If set to  aauuddii--
+              bbllee, readline attempts to ring the terminal's bell.
+       ccoommmmeenntt--bbeeggiinn ((````##''''))
+              The string that is inserted in  vvii  mode  when  the
+              iinnsseerrtt--ccoommmmeenntt  command  is executed.  This command
+              is bound to MM--## in emacs mode and to ## in  vi  com-
+              mand mode.
+       ccoommpplleettiioonn--qquueerryy--iitteemmss ((110000))
+              This  determines  when  the  user  is queried about
+              viewing the number of possible  completions  gener-
+              ated  by  the ppoossssiibbllee--ccoommpplleettiioonnss command.  It may
+              be set to any integer value greater than  or  equal
+              to  zero.  If the number of possible completions is
+              greater than or equal to the value  of  this  vari-
+              able, the user is asked whether or not he wishes to
+              view them; otherwise they are simply listed on  the
+              terminal.
+       ccoonnvveerrtt--mmeettaa ((OOnn))
+              If set to OOnn, readline will convert characters with
+              the eighth bit set to  an  ASCII  key  sequence  by
+              stripping  the  eighth bit and prepending an escape
+              character (in effect, using escape as the _m_e_t_a _p_r_e_-
+              _f_i_x).
+       ddiissaabbllee--ccoommpplleettiioonn ((OOffff))
+              If  set  to  OOnn, readline will inhibit word comple-
+              tion.  Completion characters will be inserted  into
+              the line as if they had been mapped to sseellff--iinnsseerrtt.
+       eeddiittiinngg--mmooddee ((eemmaaccss))
+              Controls whether readline begins with a set of  key
+              bindings  similar to _e_m_a_c_s or _v_i.  eeddiittiinngg--mmooddee can
+              be set to either eemmaaccss or vvii.
+       eennaabbllee--kkeeyyppaadd ((OOffff))
+              When set to OOnn, readline will  try  to  enable  the
+              application keypad when it is called.  Some systems
+              need this to enable the arrow keys.
+       eexxppaanndd--ttiillddee ((OOffff))
+              If set to oonn, tilde  expansion  is  performed  when
+              readline attempts word completion.
+       hhoorriizzoonnttaall--ssccrroollll--mmooddee ((OOffff))
+              When  set  to  OOnn, makes readline use a single line
+              for display, scrolling the input horizontally on  a
+              single  screen line when it becomes longer than the
+              screen width rather than wrapping to a new line.
+       kkeeyymmaapp ((eemmaaccss))
+              Set the current readline keymap.  The set of  legal
+              keymap  names is _e_m_a_c_s_, _e_m_a_c_s_-_s_t_a_n_d_a_r_d_, _e_m_a_c_s_-_m_e_t_a_,
+              _e_m_a_c_s_-_c_t_l_x_, _v_i_, _v_i_-_m_o_v_e_, _v_i_-_c_o_m_m_a_n_d, and _v_i_-_i_n_s_e_r_t.
+              _v_i is equivalent to _v_i_-_c_o_m_m_a_n_d; _e_m_a_c_s is equivalent
+              to _e_m_a_c_s_-_s_t_a_n_d_a_r_d.  The default value is _e_m_a_c_s; the
+              value  of  eeddiittiinngg--mmooddee  also  affects  the default
+              keymap.
+       mmaarrkk--ddiirreeccttoorriieess ((OOnn))
+              If set to OOnn,  completed  directory  names  have  a
+
+
+
+GNU                         1997 Feb 5                          4
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+              slash appended.
+       mmaarrkk--mmooddiiffiieedd--lliinneess ((OOffff))
+              If set to OOnn, history lines that have been modified
+              are displayed with a preceding asterisk (**).
+       mmeettaa--ffllaagg ((OOffff))
+              If set to OOnn, readline will enable eight-bit  input
+              (that  is,  it will not strip the high bit from the
+              characters it reads), regardless of what the termi-
+              nal claims it can support.
+       oouuttppuutt--mmeettaa ((OOffff))
+              If set to OOnn, readline will display characters with
+              the eighth bit set directly rather than as a  meta-
+              prefixed escape sequence.
+       sshhooww--aallll--iiff--aammbbiigguuoouuss ((OOffff))
+              This  alters the default behavior of the completion
+              functions.  If set to oonn,  words  which  have  more
+              than  one  possible completion cause the matches to
+              be listed immediately instead of ringing the  bell.
+       vviissiibbllee--ssttaattss ((OOffff))
+              If set to OOnn, a character denoting a file's type as
+              reported by ssttaatt(2) is  appended  to  the  filename
+              when listing possible completions.
+
+   CCoonnddiittiioonnaall CCoonnssttrruuccttss
+       Readline  implements  a  facility similar in spirit to the
+       conditional compilation features  of  the  C  preprocessor
+       which allows key bindings and variable settings to be per-
+       formed as the result of tests.   There  are  three  parser
+       directives used.
+
+       $$iiff    The  $$iiff construct allows bindings to be made based
+              on the editing mode, the terminal  being  used,  or
+              the  application  using  readline.  The text of the
+              test extends to the end of the line; no  characters
+              are required to isolate it.
+
+              mmooddee   The  mmooddee== form of the $$iiff directive is used
+                     to test whether readline is in emacs  or  vi
+                     mode.   This may be used in conjunction with
+                     the sseett kkeeyymmaapp command, for instance, to set
+                     bindings  in  the  _e_m_a_c_s_-_s_t_a_n_d_a_r_d and _e_m_a_c_s_-
+                     _c_t_l_x keymaps only if  readline  is  starting
+                     out in emacs mode.
+
+              tteerrmm   The tteerrmm== form may be used to include termi-
+                     nal-specific key bindings, perhaps  to  bind
+                     the  key  sequences output by the terminal's
+                     function keys.  The word on the  right  side
+                     of  the == is tested against the full name of
+                     the terminal and the portion of the terminal
+                     name before the first --.  This allows _s_u_n to
+                     match both _s_u_n and _s_u_n_-_c_m_d, for instance.
+
+
+
+
+
+GNU                         1997 Feb 5                          5
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+              aapppplliiccaattiioonn
+                     The aapppplliiccaattiioonn construct is used to include
+                     application-specific settings.  Each program
+                     using the readline library sets the _a_p_p_l_i_c_a_-
+                     _t_i_o_n  _n_a_m_e,  and  an initialization file can
+                     test for a particular value.  This could  be
+                     used to bind key sequences to functions use-
+                     ful for a specific program.   For  instance,
+                     the  following  command  adds a key sequence
+                     that quotes the current or previous word  in
+                     Bash:
+                     $$iiff bash
+                     # Quote the current or previous word
+                     "\C-xq": "\eb\"\ef\""
+                     $$eennddiiff
+
+       $$eennddiiff This  command,  as you saw in the previous example,
+              terminates an $$iiff command.
+
+       $$eellssee  Commands in this branch of the  $$iiff  directive  are
+              executed if the test fails.
+
+SSEEAARRCCHHIINNGG
+       Readline  provides commands for searching through the com-
+       mand history for  lines  containing  a  specified  string.
+       There   are   two   search  modes:  _i_n_c_r_e_m_e_n_t_a_l  and  _n_o_n_-
+       _i_n_c_r_e_m_e_n_t_a_l.
+
+       Incremental searches begin before the  user  has  finished
+       typing the search string.  As each character of the search
+       string is typed, readline displays the next entry from the
+       history  matching the string typed so far.  An incremental
+       search requires only as many characters as needed to  find
+       the  desired  history entry.  The Escape character is used
+       to terminate an incremental search.  Control-J  will  also
+       terminate the search.  Control-G will abort an incremental
+       search and restore the original line.  When the search  is
+       terminated, the history entry containing the search string
+       becomes the current line.  To find other matching  entries
+       in the history list, type Control-S or Control-R as appro-
+       priate.  This will search backward or forward in the  his-
+       tory for the next line matching the search string typed so
+       far.  Any other key sequence bound to a  readline  command
+       will  terminate  the search and execute that command.  For
+       instance, a _n_e_w_l_i_n_e will terminate the search  and  accept
+       the  line,  thereby executing the command from the history
+       list.
+
+       Non-incremental searches read  the  entire  search  string
+       before starting to search for matching history lines.  The
+       search string may be typed by the user or part of the con-
+       tents of the current line.
+
+
+
+
+
+GNU                         1997 Feb 5                          6
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+EEDDIITTIINNGG CCOOMMMMAANNDDSS
+       The  following  is a list of the names of the commands and
+       the default key sequences to which they are  bound.   Com-
+       mand  names  without  an  accompanying  key  sequence  are
+       unbound by default.
+
+   CCoommmmaannddss ffoorr MMoovviinngg
+       bbeeggiinnnniinngg--ooff--lliinnee ((CC--aa))
+              Move to the start of the current line.
+       eenndd--ooff--lliinnee ((CC--ee))
+              Move to the end of the line.
+       ffoorrwwaarrdd--cchhaarr ((CC--ff))
+              Move forward a character.
+       bbaacckkwwaarrdd--cchhaarr ((CC--bb))
+              Move back a character.
+       ffoorrwwaarrdd--wwoorrdd ((MM--ff))
+              Move forward to the end of the  next  word.   Words
+              are  composed  of  alphanumeric characters (letters
+              and digits).
+       bbaacckkwwaarrdd--wwoorrdd ((MM--bb))
+              Move back to the start of this,  or  the  previous,
+              word.   Words  are composed of alphanumeric charac-
+              ters (letters and digits).
+       cclleeaarr--ssccrreeeenn ((CC--ll))
+              Clear the screen leaving the current  line  at  the
+              top  of  the screen.  With an argument, refresh the
+              current line without clearing the screen.
+       rreeddrraaww--ccuurrrreenntt--lliinnee
+              Refresh the current line.
+
+   CCoommmmaannddss ffoorr MMaanniippuullaattiinngg tthhee HHiissttoorryy
+       aacccceepptt--lliinnee ((NNeewwlliinnee,, RReettuurrnn))
+              Accept the line regardless of where the cursor  is.
+              If  this  line  is non-empty, add it to the history
+              list. If the line is a modified history line,  then
+              restore the history line to its original state.
+       pprreevviioouuss--hhiissttoorryy ((CC--pp))
+              Fetch  the  previous command from the history list,
+              moving back in the list.
+       nneexxtt--hhiissttoorryy ((CC--nn))
+              Fetch the next command from the history list,  mov-
+              ing forward in the list.
+       bbeeggiinnnniinngg--ooff--hhiissttoorryy ((MM--<<))
+              Move to the first line in the history.
+       eenndd--ooff--hhiissttoorryy ((MM-->>))
+              Move  to  the  end  of the input history, i.e., the
+              line currently being entered.
+       rreevveerrssee--sseeaarrcchh--hhiissttoorryy ((CC--rr))
+              Search backward starting at the  current  line  and
+              moving `up' through the history as necessary.  This
+              is an incremental search.
+       ffoorrwwaarrdd--sseeaarrcchh--hhiissttoorryy ((CC--ss))
+              Search forward starting at  the  current  line  and
+              moving  `down'  through  the  history as necessary.
+
+
+
+GNU                         1997 Feb 5                          7
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+              This is an incremental search.
+       nnoonn--iinnccrreemmeennttaall--rreevveerrssee--sseeaarrcchh--hhiissttoorryy ((MM--pp))
+              Search backward through the history starting at the
+              current  line  using a non-incremental search for a
+              string supplied by the user.
+       nnoonn--iinnccrreemmeennttaall--ffoorrwwaarrdd--sseeaarrcchh--hhiissttoorryy ((MM--nn))
+              Search forward through the  history  using  a  non-
+              incremental  search  for  a  string supplied by the
+              user.
+       hhiissttoorryy--sseeaarrcchh--ffoorrwwaarrdd
+              Search forward through the history for  the  string
+              of characters between the start of the current line
+              and the current cursor position (the _p_o_i_n_t).   This
+              is a non-incremental search.
+       hhiissttoorryy--sseeaarrcchh--bbaacckkwwaarrdd
+              Search  backward through the history for the string
+              of characters between the start of the current line
+              and the point.  This is a non-incremental search.
+       yyaannkk--nntthh--aarrgg ((MM--CC--yy))
+              Insert  the  first argument to the previous command
+              (usually the second word on the previous  line)  at
+              point (the current cursor position).  With an argu-
+              ment _n, insert the _nth word from the previous  com-
+              mand  (the words in the previous command begin with
+              word 0).  A negative argument inserts the _nth  word
+              from the end of the previous command.
+       yyaannkk--llaasstt--aarrgg ((MM--..,, MM--__))
+              Insert  the  last  argument to the previous command
+              (the last word  of  the  previous  history  entry).
+              With an argument, behave exactly like yyaannkk--nntthh--aarrgg.
+
+   CCoommmmaannddss ffoorr CChhaannggiinngg TTeexxtt
+       ddeelleettee--cchhaarr ((CC--dd))
+              Delete the character under the cursor.  If point is
+              at  the beginning of the line, there are no charac-
+              ters in the line, and the last character typed  was
+              not CC--dd, then return EEOOFF.
+       bbaacckkwwaarrdd--ddeelleettee--cchhaarr ((RRuubboouutt))
+              Delete the character behind the cursor.  When given
+              a numeric argument, save the deleted  text  on  the
+              kill ring.
+       qquuootteedd--iinnsseerrtt ((CC--qq,, CC--vv))
+              Add  the  next  character that you type to the line
+              verbatim.  This is how to  insert  characters  like
+              CC--qq, for example.
+       ttaabb--iinnsseerrtt ((MM--TTAABB))
+              Insert a tab character.
+       sseellff--iinnsseerrtt ((aa,, bb,, AA,, 11,, !!,, ......))
+              Insert the character typed.
+       ttrraannssppoossee--cchhaarrss ((CC--tt))
+              Drag  the  character  before point forward over the
+              character at point.  Point moves forward  as  well.
+              If  point is at the end of the line, then transpose
+              the  two   characters   before   point.    Negative
+
+
+
+GNU                         1997 Feb 5                          8
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+              arguments don't work.
+       ttrraannssppoossee--wwoorrddss ((MM--tt))
+              Drag  the  word  behind the cursor past the word in
+              front of the cursor moving  the  cursor  over  that
+              word as well.
+       uuppccaassee--wwoorrdd ((MM--uu))
+              Uppercase  the current (or following) word.  With a
+              negative argument, do the previous word, but do not
+              move point.
+       ddoowwnnccaassee--wwoorrdd ((MM--ll))
+              Lowercase  the current (or following) word.  With a
+              negative argument, do the previous word, but do not
+              move point.
+       ccaappiittaalliizzee--wwoorrdd ((MM--cc))
+              Capitalize the current (or following) word.  With a
+              negative argument, do the previous word, but do not
+              move point.
+
+   KKiilllliinngg aanndd YYaannkkiinngg
+       kkiillll--lliinnee ((CC--kk))
+              Kill  the  text from the current cursor position to
+              the end of the line.
+       bbaacckkwwaarrdd--kkiillll--lliinnee ((CC--xx RRuubboouutt))
+              Kill backward to the beginning of the line.
+       uunniixx--lliinnee--ddiissccaarrdd ((CC--uu))
+              Kill backward from point to the  beginning  of  the
+              line.
+       kkiillll--wwhhoollee--lliinnee
+              Kill  all characters on the current line, no matter
+              where the cursor is.
+       kkiillll--wwoorrdd ((MM--dd))
+              Kill from the cursor to  the  end  of  the  current
+              word,  or  if between words, to the end of the next
+              word.  Word boundaries are the same as  those  used
+              by ffoorrwwaarrdd--wwoorrdd.
+       bbaacckkwwaarrdd--kkiillll--wwoorrdd ((MM--RRuubboouutt))
+              Kill  the  word behind the cursor.  Word boundaries
+              are the same as those used by bbaacckkwwaarrdd--wwoorrdd.
+       uunniixx--wwoorrdd--rruubboouutt ((CC--ww))
+              Kill the word behind the cursor, using white  space
+              as  a  word boundary.  The word boundaries are dif-
+              ferent from bbaacckkwwaarrdd--kkiillll--wwoorrdd.
+       ddeelleettee--hhoorriizzoonnttaall--ssppaaccee ((MM--\\))
+              Delete all spaces and tabs around point.
+       kkiillll--rreeggiioonn
+              Kill the text between the  point  and  _m_a_r_k  (saved
+              cursor  position).  This text is referred to as the
+              _r_e_g_i_o_n.
+       ccooppyy--rreeggiioonn--aass--kkiillll
+              Copy the text in the region to the kill buffer.
+       ccooppyy--bbaacckkwwaarrdd--wwoorrdd
+              Copy the word before point to the kill buffer.
+       ccooppyy--ffoorrwwaarrdd--wwoorrdd
+              Copy the word following point to the kill buffer.
+
+
+
+GNU                         1997 Feb 5                          9
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+       yyaannkk ((CC--yy))
+              Yank the top of the kill ring into  the  buffer  at
+              the cursor.
+       yyaannkk--ppoopp ((MM--yy))
+              Rotate  the  kill ring, and yank the new top.  Only
+              works following yyaannkk or yyaannkk--ppoopp.
+
+   NNuummeerriicc AArrgguummeennttss
+       ddiiggiitt--aarrgguummeenntt ((MM--00,, MM--11,, ......,, MM----))
+              Add this digit to the argument  already  accumulat-
+              ing,  or  start a new argument.  M-- starts a nega-
+              tive argument.
+       uunniivveerrssaall--aarrgguummeenntt
+              This is another way to  specify  an  argument.   If
+              this  command  is  followed  by one or more digits,
+              optionally with a leading minus sign, those  digits
+              define the argument.  If the command is followed by
+              digits, executing uunniivveerrssaall--aarrgguummeenntt again ends the
+              numeric  argument,  but is otherwise ignored.  As a
+              special case, if this command is  immediately  fol-
+              lowed  by  a  character  that is neither a digit or
+              minus sign, the argument count for the next command
+              is  multiplied by four.  The argument count is ini-
+              tially one, so executing this  function  the  first
+              time  makes  the argument count four, a second time
+              makes the argument count sixteen, and so on.
+
+   CCoommpplleettiinngg
+       ccoommpplleettee ((TTAABB))
+              Attempt to perform completion on  the  text  before
+              point.  The actual completion performed is applica-
+              tion-specific.  BBaasshh, for instance,  attempts  com-
+              pletion  treating  the  text  as a variable (if the
+              text begins with $$), username (if the  text  begins
+              with  ~~),  hostname (if the text begins with @@), or
+              command (including aliases and functions) in  turn.
+              If none of these produces a match, filename comple-
+              tion is attempted.  GGddbb, on the other hand,  allows
+              completion  of program functions and variables, and
+              only attempts  filename  completion  under  certain
+              circumstances.
+       ppoossssiibbllee--ccoommpplleettiioonnss ((MM--??))
+              List  the  possible  completions of the text before
+              point.
+       iinnsseerrtt--ccoommpplleettiioonnss ((MM--**))
+              Insert all completions of  the  text  before  point
+              that   would   have   been   generated   by  ppoossssii--
+              bbllee--ccoommpplleettiioonnss.
+
+   KKeeyybbooaarrdd MMaaccrrooss
+       ssttaarrtt--kkbbdd--mmaaccrroo ((CC--xx (())
+              Begin saving the characters typed into the  current
+              keyboard macro.
+
+
+
+
+GNU                         1997 Feb 5                         10
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+       eenndd--kkbbdd--mmaaccrroo ((CC--xx ))))
+              Stop  saving  the characters typed into the current
+              keyboard macro and store the definition.
+       ccaallll--llaasstt--kkbbdd--mmaaccrroo ((CC--xx ee))
+              Re-execute the last keyboard macro defined, by mak-
+              ing  the characters in the macro appear as if typed
+              at the keyboard.
+
+   MMiisscceellllaanneeoouuss
+       rree--rreeaadd--iinniitt--ffiillee ((CC--xx CC--rr))
+              Read in the  contents  of  the  _i_n_p_u_t_r_c  file,  and
+              incorporate  any  bindings  or variable assignments
+              found there.
+       aabboorrtt ((CC--gg))
+              Abort the current editing command and ring the ter-
+              minal's   bell   (subject   to   the   setting   of
+              bbeellll--ssttyyllee).
+       ddoo--uuppppeerrccaassee--vveerrssiioonn ((MM--aa,, MM--bb,, MM--_x,, ......))
+              If the metafied character _x is lowercase,  run  the
+              command  that  is bound to the corresponding upper-
+              case character.
+       pprreeffiixx--mmeettaa ((EESSCC))
+              Metafy the next character typed.  EESSCC ff is  equiva-
+              lent to MMeettaa--ff.
+       uunnddoo ((CC--__,, CC--xx CC--uu))
+              Incremental  undo,  separately  remembered for each
+              line.
+       rreevveerrtt--lliinnee ((MM--rr))
+              Undo all changes made to this line.  This  is  like
+              typing  the uunnddoo command enough times to return the
+              line to its initial state.
+       ttiillddee--eexxppaanndd ((MM--~~))
+              Perform tilde expansion on the current word.
+       sseett--mmaarrkk ((CC--@@,, MM--<<ssppaaccee>>))
+              Set the mark to the current point.   If  a  numeric
+              argument is supplied, the mark is set to that posi-
+              tion.
+       eexxcchhaannggee--ppooiinntt--aanndd--mmaarrkk ((CC--xx CC--xx))
+              Swap the point with the mark.  The  current  cursor
+              position  is set to the saved position, and the old
+              cursor position is saved as the mark.
+       cchhaarraacctteerr--sseeaarrcchh ((CC--]]))
+              A character is read and point is moved to the  next
+              occurrence  of  that  character.   A negative count
+              searches for previous occurrences.
+       cchhaarraacctteerr--sseeaarrcchh--bbaacckkwwaarrdd ((MM--CC--]]))
+              A character is read and point is moved to the  pre-
+              vious  occurrence  of  that  character.  A negative
+              count searches for subsequent occurrences.
+       iinnsseerrtt--ccoommmmeenntt ((MM--##))
+              The value of the readline ccoommmmeenntt--bbeeggiinn variable is
+              inserted  at the beginning of the current line, and
+              the line is accepted  as  if  a  newline  had  been
+              typed.    This  makes  the  current  line  a  shell
+
+
+
+GNU                         1997 Feb 5                         11
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+              comment.
+       gglloobb--eexxppaanndd--wwoorrdd ((CC--xx **))
+              The word before point is treated as a  pattern  for
+              pathname  expansion,  and the list of matching file
+              names is inserted, replacing the word.
+       gglloobb--lliisstt--eexxppaannssiioonnss ((CC--xx gg))
+              The list of expansions that would have been  gener-
+              ated by gglloobb--eexxppaanndd--wwoorrdd is inserted into the line,
+              replacing the word before point.
+       dduummpp--ffuunnccttiioonnss
+              Print all of the functions and their  key  bindings
+              to  the readline output stream.  If a numeric argu-
+              ment is supplied, the output is formatted in such a
+              way that it can be made part of an _i_n_p_u_t_r_c file.
+       dduummpp--vvaarriiaabblleess
+              Print  all of the settable variables and their val-
+              ues to the readline output stream.   If  a  numeric
+              argument  is  supplied,  the output is formatted in
+              such a way that it can be made part of  an  _i_n_p_u_t_r_c
+              file.
+       dduummpp--mmaaccrrooss
+              Print  all  of  the readline key sequences bound to
+              macros and the strings they ouput.   If  a  numeric
+              argument  is  supplied,  the output is formatted in
+              such a way that it can be made part of  an  _i_n_p_u_t_r_c
+              file.
+       eemmaaccss--eeddiittiinngg--mmooddee ((CC--ee))
+              When  in  vvii  editing mode, this causes a switch to
+              eemmaaccss editing mode.
+       vvii--eeddiittiinngg--mmooddee ((MM--CC--jj))
+              When in eemmaaccss editing mode, this causes a switch to
+              vvii editing mode.
+
+DDEEFFAAUULLTT KKEEYY BBIINNDDIINNGGSS
+       The  following is a list of the default emacs and vi bind-
+       ings.  Characters with the 8th  bit  set  are  written  as
+       M-<character>, and are referred to as _m_e_t_a_f_i_e_d characters.
+       The printable ASCII characters not mentioned in  the  list
+       of  emacs  standard  bindings are bound to the _s_e_l_f_-_i_n_s_e_r_t
+       function, which just inserts the given character into  the
+       input  line.   In  vi  insertion  mode, all characters not
+       specifically mentioned are bound to _s_e_l_f_-_i_n_s_e_r_t.   Charac-
+       ters  assigned to signal generation by _s_t_t_y(1) or the ter-
+       minal driver, such as C-Z or C-C,  retain  that  function.
+       Upper  and lower case _m_e_t_a_f_i_e_d characters are bound to the
+       same function in the emacs mode meta keymap.  The  remain-
+       ing  characters are unbound, which causes readline to ring
+       the bell (subject to the setting of the  bbeellll--ssttyyllee  vari-
+       able).
+
+   EEmmaaccss MMooddee
+             Emacs Standard bindings
+
+             "C-@"  set-mark
+
+
+
+GNU                         1997 Feb 5                         12
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+             "C-A"  beginning-of-line
+             "C-B"  backward-char
+             "C-D"  delete-char
+             "C-E"  end-of-line
+             "C-F"  forward-char
+             "C-G"  abort
+             "C-H"  backward-delete-char
+             "C-I"  complete
+             "C-J"  accept-line
+             "C-K"  kill-line
+             "C-L"  clear-screen
+             "C-M"  accept-line
+             "C-N"  next-history
+             "C-P"  previous-history
+             "C-Q"  quoted-insert
+             "C-R"  reverse-search-history
+             "C-S"  forward-search-history
+             "C-T"  transpose-chars
+             "C-U"  unix-line-discard
+             "C-V"  quoted-insert
+             "C-W"  unix-word-rubout
+             "C-Y"  yank
+             "C-]"  character-search
+             "C-_"  undo
+             " " to "/"  self-insert
+             "0"  to "9"  self-insert
+             ":"  to "~"  self-insert
+             "C-?"  backward-delete-char
+
+             Emacs Meta bindings
+
+             "M-C-G"  abort
+             "M-C-H"  backward-kill-word
+             "M-C-I"  tab-insert
+             "M-C-J"  vi-editing-mode
+             "M-C-M"  vi-editing-mode
+             "M-C-R"  revert-line
+             "M-C-Y"  yank-nth-arg
+             "M-C-["  complete
+             "M-C-]"  character-search-backward
+             "M-space"  set-mark
+             "M-#"  insert-comment
+             "M-&"  tilde-expand
+             "M-*"  insert-completions
+             "M--"  digit-argument
+             "M-."  yank-last-arg
+             "M-0"  digit-argument
+             "M-1"  digit-argument
+             "M-2"  digit-argument
+             "M-3"  digit-argument
+             "M-4"  digit-argument
+             "M-5"  digit-argument
+             "M-6"  digit-argument
+             "M-7"  digit-argument
+
+
+
+GNU                         1997 Feb 5                         13
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+             "M-8"  digit-argument
+             "M-9"  digit-argument
+             "M-<"  beginning-of-history
+             "M-="  possible-completions
+             "M->"  end-of-history
+             "M-?"  possible-completions
+             "M-B"  backward-word
+             "M-C"  capitalize-word
+             "M-D"  kill-word
+             "M-F"  forward-word
+             "M-L"  downcase-word
+             "M-N"  non-incremental-forward-search-history
+             "M-P"  non-incremental-reverse-search-history
+             "M-R"  revert-line
+             "M-T"  transpose-words
+             "M-U"  upcase-word
+             "M-Y"  yank-pop
+             "M-\"  delete-horizontal-space
+             "M-~"  tilde-expand
+             "M-C-?"  backward-delete-word
+             "M-_"  yank-last-arg
+
+             Emacs Control-X bindings
+
+             "C-XC-G"  abort
+             "C-XC-R"  re-read-init-file
+             "C-XC-U"  undo
+             "C-XC-X"  exchange-point-and-mark
+             "C-X("  start-kbd-macro
+             "C-X)"  end-kbd-macro
+             "C-XE"  call-last-kbd-macro
+             "C-XC-?"  backward-kill-line
+
+
+   VVII MMooddee bbiinnddiinnggss
+             VI Insert Mode functions
+
+             "C-D"  vi-eof-maybe
+             "C-H"  backward-delete-char
+             "C-I"  complete
+             "C-J"  accept-line
+             "C-M"  accept-line
+             "C-R"  reverse-search-history
+             "C-S"  forward-search-history
+             "C-T"  transpose-chars
+             "C-U"  unix-line-discard
+             "C-V"  quoted-insert
+             "C-W"  unix-word-rubout
+             "C-Y"  yank
+             "C-["  vi-movement-mode
+             "C-_"  undo
+             " " to "~"  self-insert
+             "C-?"  backward-delete-char
+
+
+
+
+GNU                         1997 Feb 5                         14
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+             VI Command Mode functions
+
+             "C-D"  vi-eof-maybe
+             "C-E"  emacs-editing-mode
+             "C-G"  abort
+             "C-H"  backward-char
+             "C-J"  accept-line
+             "C-K"  kill-line
+             "C-L"  clear-screen
+             "C-M"  accept-line
+             "C-N"  next-history
+             "C-P"  previous-history
+             "C-Q"  quoted-insert
+             "C-R"  reverse-search-history
+             "C-S"  forward-search-history
+             "C-T"  transpose-chars
+             "C-U"  unix-line-discard
+             "C-V"  quoted-insert
+             "C-W"  unix-word-rubout
+             "C-Y"  yank
+             " "  forward-char
+             "#"  insert-comment
+             "$"  end-of-line
+             "%"  vi-match
+             "&"  vi-tilde-expand
+             "*"  vi-complete
+             "+"  next-history
+             ","  vi-char-search
+             "-"  previous-history
+             "."  vi-redo
+             "/"  vi-search
+             "0"  beginning-of-line
+             "1" to "9"  vi-arg-digit
+             ";"  vi-char-search
+             "="  vi-complete
+             "?"  vi-search
+             "A"  vi-append-eol
+             "B"  vi-prev-word
+             "C"  vi-change-to
+             "D"  vi-delete-to
+             "E"  vi-end-word
+             "F"  vi-char-search
+             "G"  vi-fetch-history
+             "I"  vi-insert-beg
+             "N"  vi-search-again
+             "P"  vi-put
+             "R"  vi-replace
+             "S"  vi-subst
+             "T"  vi-char-search
+             "U"  revert-line
+             "W"  vi-next-word
+             "X"  backward-delete-char
+             "Y"  vi-yank-to
+             "\"  vi-complete
+
+
+
+GNU                         1997 Feb 5                         15
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+             "^"  vi-first-print
+             "_"  vi-yank-arg
+             "`"  vi-goto-mark
+             "a"  vi-append-mode
+             "b"  vi-prev-word
+             "c"  vi-change-to
+             "d"  vi-delete-to
+             "e"  vi-end-word
+             "f"  vi-char-search
+             "h"  backward-char
+             "i"  vi-insertion-mode
+             "j"  next-history
+             "k"  prev-history
+             "l"  forward-char
+             "m"  vi-set-mark
+             "n"  vi-search-again
+             "p"  vi-put
+             "r"  vi-change-char
+             "s"  vi-subst
+             "t"  vi-char-search
+             "u"  undo
+             "w"  vi-next-word
+             "x"  vi-delete
+             "y"  vi-yank-to
+             "|"  vi-column
+             "~"  vi-change-case
+
+SSEEEE AALLSSOO
+       _T_h_e _G_n_u _R_e_a_d_l_i_n_e _L_i_b_r_a_r_y, Brian Fox and Chet Ramey
+       _T_h_e _G_n_u _H_i_s_t_o_r_y _L_i_b_r_a_r_y, Brian Fox and Chet Ramey
+       _b_a_s_h(1)
+
+FFIILLEESS
+       _~_/_._i_n_p_u_t_r_c
+              Individual rreeaaddlliinnee initialization file
+
+AAUUTTHHOORRSS
+       Brian Fox, Free Software Foundation (primary author)
+       bfox@ai.MIT.Edu
+
+       Chet Ramey, Case Western Reserve University
+       chet@ins.CWRU.Edu
+
+BBUUGG RREEPPOORRTTSS
+       If  you find a bug in rreeaaddlliinnee,, you should report it.  But
+       first, you should make sure that it really is a  bug,  and
+       that  it  appears  in  the  latest version of the rreeaaddlliinnee
+       library that you have.
+
+       Once you have determined that a bug actually exists,  mail
+       a bug report to _b_u_g_-_r_e_a_d_l_i_n_e@_p_r_e_p_._a_i_._M_I_T_._E_d_u.  If you have
+       a fix, you are welcome to mail that as well!   Suggestions
+       and  `philosophical'  bug  reports  may  be mailed to _b_u_g_-
+       _r_e_a_d_l_i_n_e@_p_r_e_p_._a_i_._M_I_T_._E_d_u or posted to the Usenet newsgroup
+
+
+
+GNU                         1997 Feb 5                         16
+
+
+
+
+
+READLINE(3)                                           READLINE(3)
+
+
+       ggnnuu..bbaasshh..bbuugg.
+
+       Comments  and  bug  reports  concerning  this  manual page
+       should be directed to _c_h_e_t_@_i_n_s_._C_W_R_U_._E_d_u.
+
+BBUUGGSS
+       It's too big and too slow.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+GNU                         1997 Feb 5                         17
+
+
diff --git a/readline/doc/readline.3 b/readline/doc/readline.3
new file mode 100644
--- /dev/null
+++ b/readline/doc/readline.3
@@ -0,0 +1,1112 @@
+.\"
+.\" MAN PAGE COMMENTS to
+.\"
+.\"	Chet Ramey
+.\"	Information Network Services
+.\"	Case Western Reserve University
+.\"	chet@ins.CWRU.Edu
+.\"
+.\"	Last Change: Wed Feb  5 14:13:22 EST 1997
+.\"
+.TH READLINE 3 "1997 Feb 5" GNU
+.\"
+.\" File Name macro.  This used to be `.PN', for Path Name,
+.\" but Sun doesn't seem to like that very much.
+.\"
+.de FN
+\fI\|\\$1\|\fP
+..
+.SH NAME
+readline \- get a line from a user with editing
+.SH SYNOPSIS
+.LP
+.nf
+.ft B
+#include <readline.h>
+#include <history.h>
+.ft
+.fi
+.LP
+.nf
+.ft B
+char *readline (prompt)
+char *prompt;
+.ft
+.fi
+.SH COPYRIGHT
+.if n Readline is Copyright (C) 1989, 1991, 1993, 1995, 1996 by the Free Software Foundation, Inc.
+.if t Readline is Copyright \(co 1989, 1991, 1993, 1995, 1996 by the Free Software Foundation, Inc.
+.SH DESCRIPTION
+.LP
+.B readline
+will read a line from the terminal
+and return it, using
+.B prompt
+as a prompt.  If 
+.B prompt
+is null, no prompt is issued.  The line returned is allocated with
+.IR malloc (3),
+so the caller must free it when finished.  The line returned
+has the final newline removed, so only the text of the line
+remains.
+.LP
+.B readline
+offers editing capabilities while the user is entering the
+line.
+By default, the line editing commands
+are similar to those of emacs.
+A vi\-style line editing interface is also available.
+.SH RETURN VALUE
+.LP
+.B readline
+returns the text of the line read.  A blank line
+returns the empty string.  If
+.B EOF
+is encountered while reading a line, and the line is empty,
+.B NULL
+is returned.  If an
+.B EOF
+is read with a non\-empty line, it is
+treated as a newline.
+.SH NOTATION
+.LP
+An emacs-style notation is used to denote
+keystrokes.  Control keys are denoted by C\-\fIkey\fR, e.g., C\-n
+means Control\-N.  Similarly, 
+.I meta
+keys are denoted by M\-\fIkey\fR, so M\-x means Meta\-X.  (On keyboards
+without a 
+.I meta
+key, M\-\fIx\fP means ESC \fIx\fP, i.e., press the Escape key
+then the
+.I x
+key.  This makes ESC the \fImeta prefix\fP.
+The combination M\-C\-\fIx\fP means ESC\-Control\-\fIx\fP,
+or press the Escape key
+then hold the Control key while pressing the
+.I x
+key.)
+.PP
+Readline commands may be given numeric
+.IR arguments ,
+which normally act as a repeat count.  Sometimes, however, it is the
+sign of the argument that is significant.  Passing a negative argument
+to a command that acts in the forward direction (e.g., \fBkill\-line\fP)
+causes that command to act in a backward direction.  Commands whose
+behavior with arguments deviates from this are noted.
+.PP
+When a command is described as \fIkilling\fP text, the text
+deleted is saved for possible future retrieval
+(\fIyanking\fP).  The killed text is saved in a
+\fIkill ring\fP.  Consecutive kills cause the text to be
+accumulated into one unit, which can be yanked all at once. 
+Commands which do not kill text separate the chunks of text
+on the kill ring.
+.SH INITIALIZATION FILE
+.LP
+Readline is customized by putting commands in an initialization
+file (the \fIinputrc\fP file).
+The name of this file is taken from the value of the
+.B INPUTRC
+environment variable.  If that variable is unset, the default is
+.IR ~/.inputrc .
+When a program which uses the readline library starts up, the
+init file is read, and the key bindings and variables are set.
+There are only a few basic constructs allowed in the
+readline init file.  Blank lines are ignored.
+Lines beginning with a \fB#\fP are comments.
+Lines beginning with a \fB$\fP indicate conditional constructs.
+Other lines denote key bindings and variable settings.
+Each program using this library may add its own commands
+and bindings.
+.PP
+For example, placing
+.RS
+.PP
+M\-Control\-u: universal\-argument
+.RE
+or
+.RS
+C\-Meta\-u: universal\-argument
+.RE
+into the 
+.I inputrc
+would make M\-C\-u execute the readline command
+.IR universal\-argument .
+.PP
+The following symbolic character names are recognized while
+processing key bindings:
+.IR RUBOUT ,
+.IR DEL ,
+.IR ESC ,
+.IR LFD ,
+.IR NEWLINE ,
+.IR RET ,
+.IR RETURN ,
+.IR SPC ,
+.IR SPACE ,
+and
+.IR TAB .
+In addition to command names, readline allows keys to be bound
+to a string that is inserted when the key is pressed (a \fImacro\fP).
+.PP
+.SS Key Bindings
+.PP
+The syntax for controlling key bindings in the
+.I inputrc
+file is simple.  All that is required is the name of the
+command or the text of a macro and a key sequence to which
+it should be bound. The name may be specified in one of two ways:
+as a symbolic key name, possibly with \fIMeta\-\fP or \fIControl\-\fP
+prefixes, or as a key sequence.
+When using the form \fBkeyname\fP:\fIfunction-name\fP or \fImacro\fP,
+.I keyname
+is the name of a key spelled out in English.  For example:
+.sp
+.RS
+Control\-u: universal\-argument
+.br
+Meta\-Rubout: backward\-kill\-word
+.br
+Control\-o: ">&output"
+.RE
+.LP
+In the above example,
+.I C\-u
+is bound to the function
+.BR universal\-argument ,
+.I M-DEL
+is bound to the function
+.BR backward\-kill\-word ,
+and
+.I C\-o
+is bound to run the macro
+expressed on the right hand side (that is, to insert the text
+.I >&output
+into the line).
+.PP
+In the second form, \fB"keyseq"\fP:\fIfunction\-name\fP or \fImacro\fP,
+.B keyseq
+differs from
+.B keyname
+above in that strings denoting
+an entire key sequence may be specified by placing the sequence
+within double quotes.  Some GNU Emacs style key escapes can be
+used, as in the following example.
+.sp
+.RS
+"\eC\-u": universal\-argument
+.br
+"\eC\-x\eC\-r": re\-read\-init\-file
+.br
+"\ee[11~": "Function Key 1"
+.RE
+.PP
+In this example,
+.I C-u
+is again bound to the function
+.BR universal\-argument .
+.I "C-x C-r"
+is bound to the function
+.BR re\-read\-init\-file ,
+and 
+.I "ESC [ 1 1 ~"
+is bound to insert the text
+.BR "Function Key 1" .
+The full set of escape sequences is
+.RS
+.TP
+.B \eC\-
+control prefix
+.TP
+.B \eM\-
+meta prefix
+.TP
+.B \ee
+an escape character
+.TP
+.B \e\e
+backslash
+.TP
+.B \e"
+literal "
+.TP
+.B \e'
+literal '
+.RE
+.PP
+When entering the text of a macro, single or double quotes should
+be used to indicate a macro definition.  Unquoted text
+is assumed to be a function name.  Backslash
+will quote any character in the macro text, including " and '.
+.PP
+.B Bash
+allows the current readline key bindings to be displayed or modified
+with the
+.B bind
+builtin command.  The editing mode may be switched during interactive
+use by using the
+.B \-o
+option to the
+.B set
+builtin command.  Other programs using this library provide
+similar mechanisms.  The
+.I inputrc
+file may be edited and re-read if a program does not provide
+any other means to incorporate new bindings.
+.SS Variables
+.PP
+Readline has variables that can be used to further customize its
+behavior.  A variable may be set in the
+.I inputrc
+file with a statement of the form
+.RS
+.PP
+\fBset\fP \fIvariable\-name\fP \fIvalue\fP
+.RE
+.PP
+Except where noted, readline variables can take the values
+.B On
+or
+.BR Off .
+The variables and their default values are:
+.PP
+.PD 0
+.TP
+.B bell\-style (audible)
+Controls what happens when readline wants to ring the terminal bell.
+If set to \fBnone\fP, readline never rings the bell.  If set to
+\fBvisible\fP, readline uses a visible bell if one is available.
+If set to \fBaudible\fP, readline attempts to ring the terminal's bell.
+.TP
+.B comment\-begin (``#'')
+The string that is inserted in \fBvi\fP mode when the
+.B insert\-comment
+command is executed.
+This command is bound to
+.B M\-#
+in emacs mode and to
+.B #
+in vi command mode.
+.TP
+.B completion\-query\-items (100)
+This determines when the user is queried about viewing
+the number of possible completions
+generated by the \fBpossible\-completions\fP command.
+It may be set to any integer value greater than or equal to
+zero.  If the number of possible completions is greater than
+or equal to the value of this variable, the user is asked whether
+or not he wishes to view them; otherwise they are simply listed
+on the terminal.
+.TP
+.B convert\-meta (On)
+If set to \fBOn\fP, readline will convert characters with the
+eighth bit set to an ASCII key sequence
+by stripping the eighth bit and prepending an
+escape character (in effect, using escape as the \fImeta prefix\fP).
+.TP
+.B disable\-completion (Off)
+If set to \fBOn\fP, readline will inhibit word completion.  Completion 
+characters will be inserted into the line as if they had been
+mapped to \fBself-insert\fP.
+.TP
+.B editing\-mode (emacs)
+Controls whether readline begins with a set of key bindings similar
+to \fIemacs\fP or \fIvi\fP.
+.B editing\-mode
+can be set to either
+.B emacs
+or
+.BR vi .
+.TP
+.B enable\-keypad (Off)
+When set to \fBOn\fP, readline will try to enable the application
+keypad when it is called.  Some systems need this to enable the
+arrow keys.
+.TP
+.B expand\-tilde (Off)
+If set to \fBon\fP, tilde expansion is performed when readline
+attempts word completion.
+.TP
+.B horizontal\-scroll\-mode (Off)
+When set to \fBOn\fP, makes readline use a single line for display,
+scrolling the input horizontally on a single screen line when it
+becomes longer than the screen width rather than wrapping to a new line.
+.TP
+.B keymap (emacs)
+Set the current readline keymap.  The set of legal keymap names is
+\fIemacs, emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,
+vi-command\fP, and
+.IR vi-insert .
+\fIvi\fP is equivalent to \fIvi-command\fP; \fIemacs\fP is
+equivalent to \fIemacs-standard\fP.  The default value is
+.IR emacs ;
+the value of
+.B editing\-mode
+also affects the default keymap.
+.TP
+.B mark\-directories (On)
+If set to \fBOn\fP, completed directory names have a slash
+appended.
+.TP
+.B mark\-modified\-lines (Off)
+If set to \fBOn\fP, history lines that have been modified are displayed
+with a preceding asterisk (\fB*\fP).
+.TP
+.B meta\-flag (Off)
+If set to \fBOn\fP, readline will enable eight-bit input (that is,
+it will not strip the high bit from the characters it reads),
+regardless of what the terminal claims it can support.
+.TP
+.B output\-meta (Off)
+If set to \fBOn\fP, readline will display characters with the
+eighth bit set directly rather than as a meta-prefixed escape
+sequence.
+.TP
+.B show\-all\-if\-ambiguous (Off)
+This alters the default behavior of the completion functions.  If
+set to
+.BR on ,
+words which have more than one possible completion cause the
+matches to be listed immediately instead of ringing the bell.
+.TP
+.B visible\-stats (Off)
+If set to \fBOn\fP, a character denoting a file's type as reported  
+by \fBstat\fP(2) is appended to the filename when listing possible
+completions.
+.PD
+.SS Conditional Constructs
+.PP
+Readline implements a facility similar in spirit to the conditional
+compilation features of the C preprocessor which allows key
+bindings and variable settings to be performed as the result
+of tests.  There are three parser directives used.
+.IP \fB$if\fP
+The 
+.B $if
+construct allows bindings to be made based on the
+editing mode, the terminal being used, or the application using
+readline.  The text of the test extends to the end of the line;
+no characters are required to isolate it.
+.RS
+.IP \fBmode\fP
+The \fBmode=\fP form of the \fB$if\fP directive is used to test
+whether readline is in emacs or vi mode.
+This may be used in conjunction
+with the \fBset keymap\fP command, for instance, to set bindings in
+the \fIemacs-standard\fP and \fIemacs-ctlx\fP keymaps only if
+readline is starting out in emacs mode.
+.IP \fBterm\fP
+The \fBterm=\fP form may be used to include terminal-specific
+key bindings, perhaps to bind the key sequences output by the
+terminal's function keys.  The word on the right side of the
+.B =
+is tested against the full name of the terminal and the portion
+of the terminal name before the first \fB\-\fP.  This allows
+.I sun
+to match both
+.I sun
+and
+.IR sun\-cmd ,
+for instance.
+.IP \fBapplication\fP
+The \fBapplication\fP construct is used to include
+application-specific settings.  Each program using the readline
+library sets the \fIapplication name\fP, and an initialization
+file can test for a particular value.
+This could be used to bind key sequences to functions useful for
+a specific program.  For instance, the following command adds a
+key sequence that quotes the current or previous word in Bash:
+.RS
+.nf
+\fB$if\fP bash
+# Quote the current or previous word
+"\eC-xq": "\eeb\e"\eef\e""
+\fB$endif\fP
+.fi
+.RE
+.RE
+.IP \fB$endif\fP
+This command, as you saw in the previous example, terminates an
+\fB$if\fP command.
+.IP \fB$else\fP
+Commands in this branch of the \fB$if\fP directive are executed if
+the test fails.
+.SH SEARCHING
+.PP
+Readline provides commands for searching through the command history
+for lines containing a specified string.
+There are two search modes:
+.I incremental
+and
+.IR non-incremental .
+.PP
+Incremental searches begin before the user has finished typing the
+search string.
+As each character of the search string is typed, readline displays
+the next entry from the history matching the string typed so far.
+An incremental search requires only as many characters as needed to
+find the desired history entry.
+The Escape character is used to terminate an incremental search.
+Control-J will also terminate the search.
+Control-G will abort an incremental search and restore the original
+line.
+When the search is terminated, the history entry containing the
+search string becomes the current line.
+To find other matching entries in the history list, type Control-S or
+Control-R as appropriate.
+This will search backward or forward in the history for the next
+line matching the search string typed so far.
+Any other key sequence bound to a readline command will terminate
+the search and execute that command.
+For instance, a \fInewline\fP will terminate the search and accept
+the line, thereby executing the command from the history list.
+.PP
+Non-incremental searches read the entire search string before starting
+to search for matching history lines.  The search string may be
+typed by the user or part of the contents of the current line.
+.SH EDITING COMMANDS
+.PP
+The following is a list of the names of the commands and the default
+key sequences to which they are bound.
+Command names without an accompanying key sequence are unbound by default.
+.SS Commands for Moving
+.PP
+.PD 0
+.TP
+.B beginning\-of\-line (C\-a)
+Move to the start of the current line.
+.TP
+.B end\-of\-line (C\-e)
+Move to the end of the line.
+.TP
+.B forward\-char (C\-f)
+Move forward a character.
+.TP
+.B backward\-char (C\-b)
+Move back a character.
+.TP
+.B forward\-word (M\-f)
+Move forward to the end of the next word.  Words are composed of
+alphanumeric characters (letters and digits).
+.TP
+.B backward\-word (M\-b)
+Move back to the start of this, or the previous, word.  Words are
+composed of alphanumeric characters (letters and digits).
+.TP
+.B clear\-screen (C\-l)
+Clear the screen leaving the current line at the top of the screen.
+With an argument, refresh the current line without clearing the
+screen.
+.TP
+.B redraw\-current\-line
+Refresh the current line.
+.PD
+.SS Commands for Manipulating the History
+.PP
+.PD 0
+.TP
+.B accept\-line (Newline, Return)
+Accept the line regardless of where the cursor is.  If this line is
+non-empty, add it to the history list. If the line is a modified
+history line, then restore the history line to its original state.
+.TP
+.B previous\-history (C\-p)
+Fetch the previous command from the history list, moving back in
+the list.
+.TP
+.B next\-history (C\-n)
+Fetch the next command from the history list, moving forward in the
+list.
+.TP
+.B beginning\-of\-history (M\-<)
+Move to the first line in the history.
+.TP
+.B end\-of\-history (M\->)
+Move to the end of the input history, i.e., the line currently being
+entered.
+.TP
+.B reverse\-search\-history (C\-r)
+Search backward starting at the current line and moving `up' through
+the history as necessary.  This is an incremental search.
+.TP
+.B forward\-search\-history (C\-s)
+Search forward starting at the current line and moving `down' through
+the history as necessary.  This is an incremental search.
+.TP
+.B non\-incremental\-reverse\-search\-history (M\-p)
+Search backward through the history starting at the current line
+using a non-incremental search for a string supplied by the user.
+.TP
+.B non\-incremental\-forward\-search\-history (M\-n)
+Search forward through the history using a non-incremental search
+for a string supplied by the user.
+.TP
+.B history\-search\-forward
+Search forward through the history for the string of characters
+between the start of the current line and the current cursor
+position (the \fIpoint\fP).
+This is a non-incremental search.
+.TP
+.B history\-search\-backward
+Search backward through the history for the string of characters
+between the start of the current line and the point.
+This is a non-incremental search.
+.TP
+.B yank\-nth\-arg (M\-C\-y)
+Insert the first argument to the previous command (usually
+the second word on the previous line) at point (the current
+cursor position).  With an argument
+.IR n ,
+insert the \fIn\fPth word from the previous command (the words
+in the previous command begin with word 0).  A negative argument
+inserts the \fIn\fPth word from the end of the previous command.
+.TP
+.B
+yank\-last\-arg (M\-.\^, M\-_\^)
+Insert the last argument to the previous command (the last word of
+the previous history entry).  With an argument,
+behave exactly like \fByank\-nth\-arg\fP.
+.PD
+.SS Commands for Changing Text
+.PP
+.PD 0
+.TP
+.B delete\-char (C\-d)
+Delete the character under the cursor.  If point is at the
+beginning of the line, there are no characters in the line, and
+the last character typed was not
+.BR C\-d ,
+then return
+.SM
+.BR EOF .
+.TP
+.B backward\-delete\-char (Rubout)
+Delete the character behind the cursor.  When given a numeric argument,
+save the deleted text on the kill ring.
+.TP
+.B quoted\-insert (C\-q, C\-v)
+Add the next character that you type to the line verbatim.  This is
+how to insert characters like \fBC\-q\fP, for example.
+.TP
+.B tab\-insert (M-TAB)
+Insert a tab character.
+.TP
+.B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
+Insert the character typed.
+.TP
+.B transpose\-chars (C\-t)
+Drag the character before point forward over the character at point.
+Point moves forward as well.  If point is at the end of the line, then
+transpose the two characters before point.  Negative arguments don't work.
+.TP
+.B transpose\-words (M\-t)
+Drag the word behind the cursor past the word in front of the cursor
+moving the cursor over that word as well.
+.TP
+.B upcase\-word (M\-u)
+Uppercase the current (or following) word.  With a negative argument,
+do the previous word, but do not move point.
+.TP
+.B downcase\-word (M\-l)
+Lowercase the current (or following) word.  With a negative argument,
+do the previous word, but do not move point.
+.TP
+.B capitalize\-word (M\-c)
+Capitalize the current (or following) word.  With a negative argument,
+do the previous word, but do not move point.
+.PD
+.SS Killing and Yanking
+.PP
+.PD 0
+.TP
+.B kill\-line (C\-k)
+Kill the text from the current cursor position to the end of the line.
+.TP
+.B backward\-kill\-line (C\-x Rubout)
+Kill backward to the beginning of the line.
+.TP
+.B unix\-line\-discard (C\-u)
+Kill backward from point to the beginning of the line.
+.\" There is no real difference between this and backward-kill-line
+.TP
+.B kill\-whole\-line
+Kill all characters on the current line, no matter where the
+cursor is.
+.TP
+.B kill\-word  (M\-d)
+Kill from the cursor to the end of the current word, or if between
+words, to the end of the next word.  Word boundaries are the same as
+those used by \fBforward\-word\fP.
+.TP
+.B backward\-kill\-word (M\-Rubout)
+Kill the word behind the cursor.  Word boundaries are the same as
+those used by \fBbackward\-word\fP.
+.TP
+.B unix\-word\-rubout (C\-w)
+Kill the word behind the cursor, using white space as a word boundary.
+The word boundaries are different from
+.BR backward\-kill\-word .
+.TP
+.B delete\-horizontal\-space (M\-\e)
+Delete all spaces and tabs around point.
+.TP
+.B kill\-region
+Kill the text between the point and \fImark\fP (saved cursor position).
+This text is referred to as the \fIregion\fP.
+.TP
+.B copy\-region\-as\-kill
+Copy the text in the region to the kill buffer.
+.TP
+.B copy\-backward\-word
+Copy the word before point to the kill buffer.
+.TP
+.B copy\-forward\-word
+Copy the word following point to the kill buffer.
+.TP
+.B yank (C\-y)
+Yank the top of the kill ring into the buffer at the cursor.
+.TP
+.B yank\-pop (M\-y)
+Rotate the kill ring, and yank the new top.  Only works following
+.B yank
+or
+.BR yank\-pop .
+.PD
+.SS Numeric Arguments
+.PP
+.PD 0
+.TP
+.B digit\-argument (M\-0, M\-1, ..., M\-\-)
+Add this digit to the argument already accumulating, or start a new
+argument.  M\-\- starts a negative argument.
+.TP
+.B universal\-argument
+This is another way to specify an argument.
+If this command is followed by one or more digits, optionally with a
+leading minus sign, those digits define the argument.
+If the command is followed by digits, executing
+.B universal\-argument
+again ends the numeric argument, but is otherwise ignored.
+As a special case, if this command is immediately followed by a
+character that is neither a digit or minus sign, the argument count
+for the next command is multiplied by four.
+The argument count is initially one, so executing this function the
+first time makes the argument count four, a second time makes the
+argument count sixteen, and so on.
+.PD
+.SS Completing
+.PP
+.PD 0
+.TP
+.B complete (TAB)
+Attempt to perform completion on the text before point.
+The actual completion performed is application-specific.
+.BR Bash ,
+for instance, attempts completion treating the text as a variable
+(if the text begins with \fB$\fP), username (if the text begins with
+\fB~\fP), hostname (if the text begins with \fB@\fP), or
+command (including aliases and functions) in turn.  If none
+of these produces a match, filename completion is attempted.
+.BR Gdb ,
+on the other hand,
+allows completion of program functions and variables, and
+only attempts filename completion under certain circumstances.
+.TP
+.B possible\-completions (M\-?)
+List the possible completions of the text before point.
+.TP
+.B insert\-completions (M\-*)
+Insert all completions of the text before point
+that would have been generated by
+\fBpossible\-completions\fP.
+.PD
+.SS Keyboard Macros
+.PP
+.PD 0
+.TP
+.B start\-kbd\-macro (C\-x (\^)
+Begin saving the characters typed into the current keyboard macro.
+.TP
+.B end\-kbd\-macro (C\-x )\^)
+Stop saving the characters typed into the current keyboard macro
+and store the definition.
+.TP
+.B call\-last\-kbd\-macro (C\-x e)
+Re-execute the last keyboard macro defined, by making the characters
+in the macro appear as if typed at the keyboard.
+.PD
+.SS Miscellaneous
+.PP
+.PD 0
+.TP
+.B re\-read\-init\-file (C\-x C\-r)
+Read in the contents of the \fIinputrc\fP file, and incorporate
+any bindings or variable assignments found there.
+.TP
+.B abort (C\-g)
+Abort the current editing command and
+ring the terminal's bell (subject to the setting of
+.BR bell\-style ).
+.TP
+.B do\-uppercase\-version (M\-a, M\-b, M\-\fIx\fP, ...)
+If the metafied character \fIx\fP is lowercase, run the command
+that is bound to the corresponding uppercase character.
+.TP
+.B prefix\-meta (ESC)
+Metafy the next character typed.
+.SM
+.B ESC
+.B f
+is equivalent to
+.BR Meta\-f .
+.TP
+.B undo (C\-_, C\-x C\-u)
+Incremental undo, separately remembered for each line.
+.TP
+.B revert\-line (M\-r)
+Undo all changes made to this line.  This is like typing the
+.B undo
+command enough times to return the line to its initial state.
+.TP
+.B tilde\-expand (M\-~)
+Perform tilde expansion on the current word.
+.TP
+.B set\-mark (C\-@, M-<space>)
+Set the mark to the current point.  If a
+numeric argument is supplied, the mark is set to that position.
+.TP
+.B exchange\-point\-and\-mark (C\-x C\-x)
+Swap the point with the mark.  The current cursor position is set to
+the saved position, and the old cursor position is saved as the mark.
+.TP
+.B character\-search (C\-])
+A character is read and point is moved to the next occurrence of that
+character.  A negative count searches for previous occurrences.
+.TP
+.B character\-search\-backward (M\-C\-])
+A character is read and point is moved to the previous occurrence of that
+character.  A negative count searches for subsequent occurrences.
+.TP
+.B insert\-comment (M\-#)
+The value of the readline
+.B comment\-begin
+variable is inserted at the beginning of the current line, and the line
+is accepted as if a newline had been typed.  This makes the current line
+a shell comment.
+.TP
+.B glob\-expand\-word (C\-x *)
+The word before point is treated as a pattern for pathname expansion,
+and the list of matching file names is inserted, replacing the word.
+.TP
+.B glob\-list\-expansions (C\-x g)
+The list of expansions that would have been generated by
+.B glob\-expand\-word
+is inserted into the line, replacing the word before point.
+.TP
+.B dump\-functions
+Print all of the functions and their key bindings to the
+readline output stream.  If a numeric argument is supplied,
+the output is formatted in such a way that it can be made part
+of an \fIinputrc\fP file.
+.TP
+.B dump\-variables
+Print all of the settable variables and their values to the
+readline output stream.  If a numeric argument is supplied,
+the output is formatted in such a way that it can be made part
+of an \fIinputrc\fP file.
+.TP
+.B dump\-macros
+Print all of the readline key sequences bound to macros and the
+strings they ouput.  If a numeric argument is supplied,
+the output is formatted in such a way that it can be made part
+of an \fIinputrc\fP file.
+.TP
+.B emacs\-editing\-mode (C\-e)
+When in
+.B vi
+editing mode, this causes a switch to
+.B emacs
+editing mode.
+.TP
+.B vi\-editing\-mode (M\-C\-j)
+When in
+.B emacs
+editing mode, this causes a switch to
+.B vi
+editing mode.
+.PD
+.SH DEFAULT KEY BINDINGS
+.LP
+The following is a list of the default emacs and vi bindings.
+Characters with the 8th bit set are written as M\-<character>, and
+are referred to as
+.I metafied
+characters.
+The printable ASCII characters not mentioned in the list of emacs
+standard bindings are bound to the
+.I self\-insert
+function, which just inserts the given character into the input line.
+In vi insertion mode, all characters not specifically mentioned are
+bound to
+.IR self\-insert .
+Characters assigned to signal generation by
+.IR stty (1)
+or the terminal driver, such as C-Z or C-C,
+retain that function.
+Upper and lower case
+.I metafied
+characters are bound to the same function in the emacs mode
+meta keymap.
+The remaining characters are unbound, which causes readline
+to ring the bell (subject to the setting of the
+.B bell\-style
+variable).
+.SS Emacs Mode
+.RS +.6i
+.nf
+.ta 2.5i
+.sp
+Emacs Standard bindings
+.sp
+"C-@"  set-mark
+"C-A"  beginning-of-line
+"C-B"  backward-char
+"C-D"  delete-char
+"C-E"  end-of-line
+"C-F"  forward-char
+"C-G"  abort
+"C-H"  backward-delete-char
+"C-I"  complete
+"C-J"  accept-line
+"C-K"  kill-line
+"C-L"  clear-screen
+"C-M"  accept-line
+"C-N"  next-history
+"C-P"  previous-history
+"C-Q"  quoted-insert
+"C-R"  reverse-search-history
+"C-S"  forward-search-history
+"C-T"  transpose-chars
+"C-U"  unix-line-discard
+"C-V"  quoted-insert
+"C-W"  unix-word-rubout
+"C-Y"  yank
+"C-]"  character-search
+"C-_"  undo
+"\^ " to "/"  self-insert
+"0"  to "9"  self-insert
+":"  to "~"  self-insert
+"C-?"  backward-delete-char
+.PP
+Emacs Meta bindings
+.sp
+"M-C-G"  abort
+"M-C-H"  backward-kill-word
+"M-C-I"  tab-insert
+"M-C-J"  vi-editing-mode
+"M-C-M"  vi-editing-mode
+"M-C-R"  revert-line
+"M-C-Y"  yank-nth-arg
+"M-C-["  complete
+"M-C-]"  character-search-backward
+"M-space"  set-mark
+"M-#"  insert-comment
+"M-&"  tilde-expand
+"M-*"  insert-completions
+"M--"  digit-argument
+"M-."  yank-last-arg
+"M-0"  digit-argument
+"M-1"  digit-argument
+"M-2"  digit-argument
+"M-3"  digit-argument
+"M-4"  digit-argument
+"M-5"  digit-argument
+"M-6"  digit-argument
+"M-7"  digit-argument
+"M-8"  digit-argument
+"M-9"  digit-argument
+"M-<"  beginning-of-history
+"M-="  possible-completions
+"M->"  end-of-history
+"M-?"  possible-completions
+"M-B"  backward-word
+"M-C"  capitalize-word
+"M-D"  kill-word
+"M-F"  forward-word
+"M-L"  downcase-word
+"M-N"  non-incremental-forward-search-history
+"M-P"  non-incremental-reverse-search-history
+"M-R"  revert-line
+"M-T"  transpose-words
+"M-U"  upcase-word
+"M-Y"  yank-pop
+"M-\e"  delete-horizontal-space
+"M-~"  tilde-expand
+"M-C-?"  backward-delete-word
+"M-_"  yank-last-arg
+.PP
+Emacs Control-X bindings
+.sp
+"C-XC-G"  abort
+"C-XC-R"  re-read-init-file
+"C-XC-U"  undo
+"C-XC-X"  exchange-point-and-mark
+"C-X("  start-kbd-macro
+"C-X)"  end-kbd-macro
+"C-XE"  call-last-kbd-macro
+"C-XC-?"  backward-kill-line
+.sp
+.RE
+.SS VI Mode bindings
+.RS +.6i
+.nf
+.ta 2.5i
+.sp
+.PP
+VI Insert Mode functions
+.sp
+"C-D"  vi-eof-maybe
+"C-H"  backward-delete-char
+"C-I"  complete
+"C-J"  accept-line
+"C-M"  accept-line
+"C-R"  reverse-search-history
+"C-S"  forward-search-history
+"C-T"  transpose-chars
+"C-U"  unix-line-discard
+"C-V"  quoted-insert
+"C-W"  unix-word-rubout
+"C-Y"  yank
+"C-["  vi-movement-mode
+"C-_"  undo
+"\^ " to "~"  self-insert
+"C-?"  backward-delete-char
+.PP
+VI Command Mode functions
+.sp
+"C-D"  vi-eof-maybe
+"C-E"  emacs-editing-mode
+"C-G"  abort
+"C-H"  backward-char
+"C-J"  accept-line
+"C-K"  kill-line
+"C-L"  clear-screen
+"C-M"  accept-line
+"C-N"  next-history
+"C-P"  previous-history
+"C-Q"  quoted-insert
+"C-R"  reverse-search-history
+"C-S"  forward-search-history
+"C-T"  transpose-chars
+"C-U"  unix-line-discard
+"C-V"  quoted-insert
+"C-W"  unix-word-rubout
+"C-Y"  yank
+"\^ "  forward-char
+"#"  insert-comment
+"$"  end-of-line
+"%"  vi-match
+"&"  vi-tilde-expand
+"*"  vi-complete
+"+"  next-history
+","  vi-char-search
+"-"  previous-history
+"."  vi-redo
+"/"  vi-search
+"0"  beginning-of-line
+"1" to "9"  vi-arg-digit
+";"  vi-char-search
+"="  vi-complete
+"?"  vi-search
+"A"  vi-append-eol
+"B"  vi-prev-word
+"C"  vi-change-to
+"D"  vi-delete-to
+"E"  vi-end-word
+"F"  vi-char-search
+"G"  vi-fetch-history
+"I"  vi-insert-beg
+"N"  vi-search-again
+"P"  vi-put
+"R"  vi-replace
+"S"  vi-subst
+"T"  vi-char-search
+"U"  revert-line
+"W"  vi-next-word
+"X"  backward-delete-char
+"Y"  vi-yank-to
+"\e"  vi-complete
+"^"  vi-first-print
+"_"  vi-yank-arg
+"`"  vi-goto-mark
+"a"  vi-append-mode
+"b"  vi-prev-word
+"c"  vi-change-to
+"d"  vi-delete-to
+"e"  vi-end-word
+"f"  vi-char-search
+"h"  backward-char
+"i"  vi-insertion-mode
+"j"  next-history
+"k"  prev-history
+"l"  forward-char
+"m"  vi-set-mark
+"n"  vi-search-again
+"p"  vi-put
+"r"  vi-change-char
+"s"  vi-subst
+"t"  vi-char-search
+"u"  undo
+"w"  vi-next-word
+"x"  vi-delete
+"y"  vi-yank-to
+"|"  vi-column
+"~"  vi-change-case
+.RE
+.SH "SEE ALSO"
+.PD 0
+.TP
+\fIThe Gnu Readline Library\fP, Brian Fox and Chet Ramey
+.TP
+\fIThe Gnu History Library\fP, Brian Fox and Chet Ramey
+.TP
+\fIbash\fP(1)
+.PD
+.SH FILES
+.PD 0
+.TP
+.FN ~/.inputrc
+Individual \fBreadline\fP initialization file
+.PD
+.SH AUTHORS
+Brian Fox, Free Software Foundation (primary author)
+.br
+bfox@ai.MIT.Edu
+.PP
+Chet Ramey, Case Western Reserve University
+.br
+chet@ins.CWRU.Edu
+.SH BUG REPORTS
+If you find a bug in
+.B readline,
+you should report it.  But first, you should
+make sure that it really is a bug, and that it appears in the latest
+version of the
+.B readline
+library that you have.
+.PP
+Once you have determined that a bug actually exists, mail a
+bug report to \fIbug\-readline\fP@\fIprep.ai.MIT.Edu\fP.
+If you have a fix, you are welcome to mail that
+as well!  Suggestions and `philosophical' bug reports may be mailed
+to \fPbug-readline\fP@\fIprep.ai.MIT.Edu\fP or posted to the Usenet
+newsgroup
+.BR gnu.bash.bug .
+.PP
+Comments and bug reports concerning
+this manual page should be directed to
+.IR chet@ins.CWRU.Edu .
+.SH BUGS
+.PP
+It's too big and too slow.
diff --git a/readline/doc/readline.dvi b/readline/doc/readline.dvi
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..64449db5da229a68cc21b7173cc580ebe036fb79
GIT binary patch
literal 182704
zc%0n537i~NxhNjeJuDJj5EKzX!ZI_ld&nfLi7b;Lfe|LeWP&1KQqx^MQ%rYPQ`Mcx
zfOzk9U&xrIq%AYz$d!u*pIjfV2rlS#N5OsV*3s*J-M}k~ivMprr%qM(OeTSM-~0XX
zCnQ}}XZg-|zI}OQ=|Qi&>66E;T>}54e(~(*j@U1Lu3M{CYSriVpL5PxeJjuCTeWIU
z|LLn&zY*RzXvre}`3L;7YxbcfOQzqk^p&f>x9c5`o%Hda?0Wd}Pkn3SJC+=E?=?%7
z!Al3{N~1gbSN;0(i#Bd;9P-(BZMLm^(J9-(rOv2lc~jG~%MM-n`Xy<Y^PBfwG<*1-
zJ9gc)<l%QZ53jo958J1fJn7-pOP&P7bmdB3|H|h2yi;}DawBznVO3v$CMdXG@bKy%
z{_6QV^_wtZwc5Y3m7FMOUS9vlGi=-QVSoU>?wg)HV#$(SHyw1#r&7a~m)m{UiQ{z`
z7{GDn^g9lE%~vOPJ-mVT^5jAxwwDd-JjW_Gx(bC2GmqU~aChH$|ISRXA@poJ*y0wd
zH{W>wWMFxA9p4DuS~+jws;6h43iAz)+g1E@vsJRE@bgSCX!&;VqR{rMwpR`|+rI7X
z*mL9kcCfYV><Dqi)er!6=>7M<e#ue>)b#8zOP1V-N40b@M+N_^h#l46zwrA9cQr@G
z9lw#veLL^&8E)ljCA$njs0Ml4&w0)$EGVds+X0+hJ(c@x5}*jpOg(jNw-wZ?PSL6E
zx$DHKU~=5ah2w$c<o&=Y)Au>I>^rcxa&9Vc3qcLGH+|bv02EFcK7l<KtelNUYUMoF
z_k+9x)7w=$sCe#}XO(ajRy8Qwc0Q=O_-nYs$=iViBbQ26IUmrnoN_2*^-b?R5r*GX
z8!bBixShwbM`?AqoDH~ebyVSG2nWT#MF(~3t~1X%V+Ot&wtU~p-3*w4%dS@aa9~GZ
zmxG#}ftLoY62NQJbMj+$1}7OF2v)A@Uwuxnb<4o??YlO?oVHhTd_=j%(nnwG_yKGP
z*GW4mSrZ{_12zC#t^&ksuxUK-QCLO^c2{xW2moYNI45|!9M-I&-hW<zTM4H;XKXyI
z!ivgn)e%^h^ZZ$5_i#%uBH$MgIbj?^G}r+Q1&^#^QKsx`TYKuNza-X9^Cs6`a$&N(
zvkYEgyoHl*TR%YA_7r09efDALaFrXWCI7sG=G6cQr=0Q_VA+Xxn%f3!!0&BXjRQM@
zjns-&co8ty!yA(iCPUYo2pr#7UEY`(5T%5Zx&?w&XCT33bRV1?tQxjVyKu{PJ9yIX
z|LtPHQ-v4&BB5A2SP*?(_`-$tc|p-CkJYR(LNi)+BelJVE4N1Bs=9!YfQR^71VbW*
zB{vlK<GJz)0Qkxi_RgGLsVdkZUW9EME?K+rlEB3e{Hg^zfytdRL&#WrU{&BScnNvD
zC8NPq2x|-Dx2O+@=vlu#Vb`Erfp-Z<gX%8$r+)DNKJxAFc|~q|dK&)*13bLu#O0Yi
zCJFba`d9w+2zX<<e&huQHT%yw`y9GqK%D!74Kv0KhOvp*;!}gzW`dz|u5UV`lZ#?$
zNL-0d?%LHH9JeY}1U$^Trk-v#2Zh>PiqwWUQF-j9gSy>s_ro$3U41vu)m;ytM||UH
z7u{*{jbHZH5BtaqWfT~8*c=E}dgdv=-Bky=C}jEeLJp9O7okWpqA3&QQOkF7LBY1F
zHBS)<J9zl)8?%2tN(1tcTq)=0`d9u0NO;hUQA?YrjZw|n4U<#5cKv!oe_wz7&}Y4M
zs0@s)>bbl9)%jXZ`0g+uX?)$cE&oPNt(#7v;1-K6EPWEkuUMW17o#%nn|q+e0@g7;
z0coX6<Jm-$U_}8C#woZrF8mkB(XBK-4xfJOX;ph?HE0cHFA17}#vX8`!19CbgD!Cs
z&n;#z>8_{4KhWh%f(>{REGUN{1sq0dRm&l{7`K^MwO~}78%W3WUgS}@BA;0Zu(l$v
zJen(zmtiJ((_C%pv1@p>!^zbS+f@tKnR;xCvCciwI#C)iRvISOS%U9_3B2P|L61`a
ziZlfm!L7}t9$Y_e1#mM%pj5q~<A-`>KnK3}F_?|+YU`4)IT6@X_=Z|}z3a;BhYCQq
z+*+7-LpYyM#<D`3FvJgp?SJoMI0}-;fCwb4VB%(64xJj%rt}9tm9xqLANQDDwmqaM
zf$-sQs)E?jTEAs5c=*i9ohx4uyZy!fm2=BHzuL^y(|-w>m*Gt6vrC$N^+ON;{d$Lp
zC7)ytHi0KGQFg;gAW}XoX%3fNKps+0H(uVXGJ?_}6YOv^u>+fVjXJP41fwG}uxz3`
z*dG)d1-M4bfwdtDH`U}raJPPQwUuXD4)FcQvA)f`&|)O>gK;Ya-iC8HUO;;+gAD1z
zvE6mw7UEzzXBiwtk<X|BW3(<@e`zyAV8;Jky5U0n&z4Q}x6SKE;6Jd3I!xUf8CVC4
zYQpD@)QR5%`VV_Ujsnw_e7i{e#AgKbZTJ@ncK{!R7p(XBSHrvTn}tuDYOoBhN{^2;
z+9uKw^!Kd}uGBK*5Wcek?$gy7n6(0&4*9?ty(SS_g+xew0gs27AlV39l+pxr&C3cP
zTQ*V;K9;X}h#j<qn@O_7H;GX`_?T}qubbL~_k>W1P!rc26kYg^7KVhBcl7<++;VXW
z>5{NVEq5Sh!m1~6Bo9b~{WF(uCCj0}(}Azj=*1#ltMuou2ILC#=8K|{jG?UJ1M`IS
zSOC>3&Ms71*tu19Dm7%ggffV~>0E|T6i~8lD^=JH+?boLhEoItL156}u!n1EJ{-zU
z`n#t-artF9Y1kr8m@_{C8C;DF6T|c+tG;CBo@-o>W&K9#cP|mXgWCc;{K!YQ`Zxmo
z<VP$<?Fc42=q)rjNGXEJL9XWch-EJQtx~iUpi$h%E1YvZk5MQylltT5iFN+;*?GH&
z8Uo=QNU>Fs>ULHYCyYMB3-Z>#!2y&rA))WoZUP(1z&=3MM{#KqD2eP6_X10O^8F0n
zM(QuW_MK7%P=V+q-J7kOHv$Ff`cCl*7I}g^VTrz?uFyR#sOAF$Qmn<8W38>HPkJv;
zFES?!Gzy`t97=DnPR|~*ynGSARRa?3V@9g>&M?J2IT2!-!q6g>#)JQ^grQY89W;8|
zTTzFHRki8xN%3bRi9bi2^zE41yb-Q6NEV0Wd(;3ZPprdpSP%TCyt^@1b*!R4&FUN7
zZKR8*z*&;u?gAiLV>F1YFOsv`CfwZfSIU8z_*;T|c-If`9;#pSCaDIQ7JsumqH&(h
z8Y(f2_rFg86ehP&oc?esVo4Fa8LLS}2>c2mGB1nOGr*Uwdxr{qy?{dK#aYHWXmET3
zh#Rm^gf>V=a?`y4D4HMRFo<bZ4j6N-BHW1X1&IjJ6y{D*dqL1{ae)~*z&}8X_=ZrD
zk_Ai(iI?WIR%|l7m$ZD)nzgE<CP6jh<BFCD$z*C{d!Fl&B7;=fDbA$+Hcdi?NEa|D
zFEa$5hkGoBqy>e!K%X)|??+pQU{Y8^m;)%l6+QA88YPEoks(6hs_VjL)eTE7j}1}^
zpARgc>NZke+)9{Y7m&t(eUm;&As8Ce2tL%$Vd9~^1HfWDG!-BfgRck(DBjFV$@t9a
z4#LE+strvA`4_=-jr8*41n9u@nR3ZpEjf9(;CPoULFn|rVGMN#RCJRWnYSQ5FH-_U
zB3e}=J+%Vw+4f2e4I+VPZ(cV(U`qtb8Ue{GZb>nIURQMNLf)9<B4<0~@)egl0HjHW
z4&=SxX9COk%edG`pPHv(h#~?(${WyvZ#Lvv%~@z43bwKZ<f@GJ-T3;lVo_iRla7Ms
zJkdxWJHa<F2jZI{cH+P`o>~1L`3pg?lHqZEef5LS`OQE*eeA{}oV<F%YSt)Dj50DB
z9DqU*d=z`*d2tB5t$1uGe^hE!ruC!^0ZE?(J!bZ#=I24>MH~gi_M8VFZVt;ykQ!~}
zK+*&1Vc>n=^leAovzx!!(BT_c2x`Ciw$E<GZ$SE!Z!YAsfG^s#3q?EOM#RA_gA8Ub
z-1i`4qbLKc$CCqW@>m!{860)m=t=`WLK=%h4-rP`kqv}MP<O>q6D!;%E8JSnyK0o8
z<&&v{j>u9MJIFgIku{r&bK@<B)w^W>!tdak0~KVdN*0;GE>(cY2@{>|pL{OJr^L)w
znam81V;GL6F$YIeB4tHXec0&jT0x#!`n_=ruYw$6ShYrrb|_lJ&8S5X%__M-y$Som
zO5lR%if_d<ET3s1kw6rdLVy%8N`M!tZ-Sr9$k5RBly~CxBGd#hyytCfv+*?9%eiH|
z<7LM#=a8glzla7Zn1nPfEu0D^pgRqF1sVpI%%MM!27{18G;d}U^&|5QA`|Nz0jVZ*
z5*GuzWoZmpQbPX4o3jItu;ikl&#E|i;Oh*)TGfzkqN_EKxF&=Tj6p!ry{ajRnb&Lm
z{NE+yH$l7Mg>R%4PJ(=z*Dud|<rA+*Qd(+pQrc6WwErfn)k&ERA)tuGU=idXb&b##
z527;}XV_pbL=W$vN5&fSVpiP>97fO6UrHFik?ql4N4#a6EJBDA8-k{iln_?PR1+dl
z*I15iEePU{Z=-n^uJK_{uMAa5K4vl4^+j$2EM_31b%Omx%rN7I8)ab%Ts8n(s8W<;
zY?T+n=9c-tp!FbuzwkxRQ^a9)QqsKy*f+v1A`5#@I_%#GPIL0C-gU`Sn#4-dFL|V7
zTV>*hhEPYGwBP}Y*7EL5`gPA9#k=5wIwPnHUxPAev28S%!oTBn0!0#OHSp@N=GV|t
zfE*L8voooi{%Z~m))Qnad1boU<Jnne^zch>=pZ#h{)C*?B@!hx<lEbZ3iNlTVHE^;
z2(tl3%UuqASc8x&7-#zgY}W4<rkN2$)0%l?HS%koZAc&ZV9YjDJ*Ls5z~`OAZAQi(
z5nX(%WcP|fN&Ak8U#Y!+k?ByphO>3Z`$5YEs&_|APXgHG6R~6Z7R=$RSu`{t_4-9)
z0I6d+td&Aqw8uI;04`UnqJB?9qpu-4oP)lDyhaELKDI>yth%tjal8WQV?OA+y!S~1
zHd7#XPoSPpTc_6uGzb<v@M00f)!&~!BI5>R4{?0<3^h_8&Cpf#wXtYzJ@p??O$d5C
zlPn9Z{iv(%aNL@2XjFM^>##(aa*D{vBGs3c8Y)2zRzQc4VMA)PBc%IU*-*|8hn*~V
zTF4ym8^;%n_uH)`6LPUgjAP<M^z0I$XLz|3Ig4K)CSm0C6cLlmBEIHf9jX7`XYmZf
zS~B7pc7NF%*iZ(H5qL%<LQFIO*={}o%@_rS8+s&>qcTOIr?ElM=mj&1C9{mXncPiw
zD1;a<N=tpbtgA0;TUL@6suK>xrUmm({AQt5P5dUoQse82#*3|OF#Dp|%6@eGJOGQn
zA9t!YiSmHhZ#)=1Bka|q>rMv;SX&Nw+d-37o3r3j#}_2)2v~3^=PeIit27Lpr(#zF
zbosB?Jx)ls;UzGW@GV%^9AR`l_4}7L+bEDJq5@U;*mp^~WNI2{I?hf(((ypL%YwRz
z6stIug|+g1BP@+!C|%>x+Tl#U2!>Y(4AmS8wQ<mZ21WFO%W9IA<VtDCq%=LN5nIi%
z8GSSWi%q-LVu<tsl&pJDus~ZHk|gry*ptNm>*@P0Fr{lUqvpkb>L`SBTrEz@QL)nt
zHyAYGA+DlnibLtei9^qNpAv^o-yfqDGwst&rj0h|0dI`rA{uj5WZ2yYJ%dGg*<d4G
ztKc3hmhT4$cX-(YjnU%I!YUoSo?DSE(41fJH*J9-i0Cf@kUV@e?^-O&fZ#=zDWKmE
zost9O#nT1S-*q%oOCG`@PK5)_`Oa7wAXrEYOVk~?89YWmL77Za_Z_QDQnUpNPI1g4
z#s#M$ALE3L^wZH$5XD?bphwyDN+?M1s)<8tIW6xf%WXZ~cclnm@-?D0d_rHK5JFKF
zEDASL=U=Qp1#G(K<w{AhcUq-N5k#KUmS4bP=x!+N21J|)=9BX?p|WtXSwXR}U5I5_
z)Jq4m6VvtH+#T9VgYKa8b&s*<su)bd@<@`p?lH99E_mD#kQ`rG$k4UNVr1SKbKt$v
z&@Q;1t;{t1L0|pQ@9Y>VG}3?ht#UL3+v$Vuc56SLRtau&jn6dbX=R(eAU$t<P+KPH
z_clyG;3Ld&m`2y?emQcq0D(;Xs`D=^i|J0=vo+U8+h(*2+?<lgqTvbp=x*$4<h0<X
zhCrzgA^VaOJiBB$6p<kdWWazt``Tr3^QwZ)!GAd<i3v!~#vF1^vHunn%*fMil@mzJ
z2Ackr8IdU6S}`9%bUPqJf3Pwb%;uZjKn=$a`?R79XCPhJVq=(CV-9T!DA1$qp@ey5
zy}K9$6c?$BsQiWk@Pdkm%mjm2{I~$)<G`VqDm=F~Hg0Y_80RtRRUFGFExiiRBdG~x
zOC`}U3&Dt!@)#-CBjZZD=12(_)lQl(7!NsK$M#8AoO8;c>XGHbD%R6SeWZz^`&`*A
zXU!-2f(*%zXxy=iGpUc=DZ|=+NQR6tz|GNsu$=S*4EzGk$`6;7DJ(0*6_MmekJX~o
z;=4}z;D8_67XC(7BV?1Ll{Hdd91)zMkI-Bc@Mm=66t<G7)>E`M@A#k%gj2pSD<B()
zt_WAfY!#qOR#hJdVl0o{NZof9IlkmBfPh}GJXmPoWdmsPV{pK^6xD$OH@>#!P<#gR
zK#QY&reX>v{D{^Ywxus)yeH$S4<Ev5&K#~*#W>7?cW}1fI|{}8^?uG`>@^Ja00b3N
zfssy58P!y)^BQTSLBuC?YQF%co+R1qjbF2hzWKcdH-^K(SKmBn5M^Zi>Y{q;jbGBA
zk&FfO*O+h*;fMwcA~iszD)cXKJ-GU13yBg-PzV3|uWTjX`kDAClfzk71m~Onms`wp
zlk+rhhyFa&D8e$LD~y+I<euVkADZPA9Qx$fju5S(Ght2}p#@EZ5~SREwE$F4U{#O)
zFHKW4WVh7QAG(4FhWxM@f3Q$Dqj)Nih+t2EO?%Je_@7_(5tEGeP9hw0Rv1Tf*~Ai*
z>E1-}HhflNHkSV79)U_k;}u?~Z@X+DGW}7Yix2pWhCwYyGrRK=@(r{180y4kO+9)q
zzGd%3C0Y406qWD#-VYU(cgh%tfOg3AQ@&~iEs!v2nr8d>G2CKzsjwPxqh|0e&mN@^
zH=bD=vSih5bO4W2k-Los9Tbw6zW#F&$wL?r9V45Qm!xNG9Uxjr{E?`ht6xHU37%4b
zrvwX^6*STpy_qOJT#5S%Bb^8y`RpX9N+02<=ov_I5m_pRJVdvHWtEstN&%!vM{(EU
zWbWmk*nbn`8Eq2yhW@_QX3R%}Vm>5L1iiwKO2o%Nu{w@ivXT1nm#dv3EBJPkQ(p&G
zv_Rg-`OR$6VP6*_^e6}*upXZ=jr~dhy1ZSmYQ<_s!jwU7fMxh%8z57B%vJ(gG0G7|
z^n~GsV3Sg0l9C0O6T<EK_>W8_DOZC7FFDsmQO|_FAoZtTFo6T=J+dpSQme*-D<t-2
zj?DXBuAcs*+r$_grz}p`aWt;8SnVnva_|>^jW~s2M6AMBiSoRqLSF)TWVc{Bx*6g)
ztJw;7V1qjx&n>g)w_^q$10_QcwT3os+B&j%5bb2&`O#2;VYVYw&yh=&0XD#<_mmaa
zBfyKnXM5}Ar}fE(P#`nir~mvCOF@cMk=+ub&D^~WA?VJ*d=(HcKlE+(gGiK;#CT;?
zn3;stp@1xhMG>&*pRlWu@Y6`Ieus|Nnn_>&TM<8ZvNqvGQmAKVaROfyV3`+0*Kt%J
z@RywH5pH=D=o4rep*&`D@H;F<#rNG_C{ZM>a-Ns0yp5E^LDSco2j0aJ>+1GE3w@J<
zEmNe=T02e06k0s)x)!&|vPw_@b)MayXwIy9HBw89MVI7A6ix2BR(OvFx7r*~@q_-p
z4qdS#u;RF&ival}hX@h_0PEq)DC7}%Kk;h0uiINEHM{8xgdkga@WR}2G<}AeQ`;9O
z!xwm3Ib;VqCfX_*YlmquAgz)5#X2J<t#4Iu<)HCCL1|EbbTuI7pYO)_wBYPs*ws5L
zmuV9v27Q*@s=5?{)tDwgB!vwd5@(3M9(DDnXHWU>b-O4VMLxpETjV=2hG_f3E8a@v
zfn1`14@$qSN`wHOk~u#Sf{0cCBGpt#R?tF1)QlTlI7q0GdhMg;r2uGu{ciHhMJ6x_
z{2)@N^o_!l859Ciy&`|D9Zt|R1C3=mMXuIN&p!1!`04VyFUD0hx;}A-yqGPyc>t+1
zJ$vM%{7rK+AUv|%nbZXzE4#rYoXOTBiJN2cMu_+tS|LCpj6otqx`4_9+$Um?z-_B*
z>#5Oq_%6PkX}~a`qZB}B&d@$WG!xn(#>&ZhQ34SAS}DL8*G%ty2Am!~YmM5)V%D!t
z70KA>-}<v=6dnrL{hQ%Qgw42w7L_G>QXdWn(U66}Q%58+O_4b|ne*=oh6*x1LMnai
zk?_Ix7U*Smvl}SSnSa+KmTeCEr|~3CT#a+^**^vnj2J+l?{J8Z!3d%HTqZ#x+UR=5
zyMVm#J8BHH-MM1)N4KnD_V247);DVoZ`JZVe9%LxJ=68xjLc!srGizhqJzCN9J+nI
z1Ef_5btVec>?l$J1$ea9q@K4;$+E5r3lsw<jiHE!8HpDKe)9)e8C{K=)6x3KkVIh3
zE6rN%%V3M}R%`i5%VUPigBK@6^{rMy)S3HXxKuEy6m2A7SrE{@sjLGq^;vvT@R?cq
zl~1GOS}O&lo_nENFk%a$A;eRcxA_q0A|ZEID!k)|mQQpoFJOY_cpV$5Z|5<90!?KA
zRUiM3UP;@I`EJk_Mzdnlm_q@~m2VI6p{NChJQ}_o$_iyJW1WrE*9Ix?#<nCpO=6Pu
zaR8-gu8A%j86EwJNHms(%h0aZ=sIE<#c|q1&1^!-9S$0{fdH(ncYSgjX+s?E)K&N(
z{AG$`7dYY&_lWp$*wY>u8COd-q?)2rVoPnSf8|O*lD*G#f2@wMyaN#st!oPV&=UB|
z@90bAmf^bAyViUlz9a4I_Np`Rx)EU$B6Vk_#2JG>jXG7Nfgmo(3>JtnOTIg>WpD^C
z$WT4K<WnT@nTlRGMVdyXqOK+l6^x?05rmtHn5T)ip#+Mt=KA*B90l@#4tL%^V5tEu
z6wN8==Uzu-l~hRFb`}O(wi9G<No-Jy0OED&vyAH|!|PMl;vxb_(}}#}BWcP;2xEXX
zb?!kLtd|j3Q=5<WVqkU3;|}gpTw*~q4qX3_-aDxOYMOJ@g&<qVuIov>(eZNd2b5*Z
zXeQ+lnSw(@-2<I$C14mKTW^3j77OBr=Uf38e1w%+MSFPXg@Unlla<CO<UwzYJqwyK
z(ItwG@RfOA1-Xf(P-4|Ro23c>#O=RYHx);7U`gXI(*!;}@E$FDqiC`om9XTn6qqfx
zpm>av!c&k=)0gy+hYM~RFdcFg(qMoc_n$lxU3;~eD2#v)+U8`D?V<;E2d=vJ$PG>C
zl?iVq?5T>SC|r}H2EM*LaT!ys7sjy$%`FtD%-(P`j8`f}M*_4Nv0+$ZJTf-wm-S0v
z{W(kW1-|tS^bG|*fC0$3WWJ8GGr=6$^H?;a$Q1gn{gyaBN|$XIva<rWH(Paz5r!bO
z>G?upgXtlQUJB?7%An9mr3Ke3siY)Lk~BLPmunl@R?KrBI6Urp&UJ1XwDPQ<1C%T#
zuo)E9boqou9y#s>?I3EB`XOf=CIWZh82e>ktxUq&_aUR&+iM68e#`)X=*-8@OATc4
zXlDhcKtU9EUo;crpsGf?_vn}u!mI?7Q6hGRc$Ei&s|?;8js@p(AKEN1ImuPx;iP8~
znI<=fkQ$5Jviy~DPdA(EA{&RvF(bu1!UA<DyZBh(RsemPo~Ba(5CRi^#u9b-Agwuh
z+v*VOfEWtjakvIr5=9#_Jfi9M-ZPNPDs-_c6d2h^?fJ6I88j)~i9jTG7$o>xPT)Uh
zDPzg<@|fAgzaUGA{-y@57I(sT>9>6aFMS3Tm8`6R0}~tRiPzwdis;r4$(~Ev49b7k
z)*RtFD)_*Sjj&c`;W-<r?>?YEn@N6_ST;yOJD(YoDMKw#@@~}|iv7(P>`x$`r0&|*
zLbiPCa2s`aLm(G|1kg3*)k791ub#DY|BZfUb&_67mN$`ArYR5z4Y?I)QrD(uB_*Jb
zzFNqMosUdfoDBzjRKl#_JGga43zSl&f#pdw``({Aie`ocvG?i2M;S{4U^)fI&S&Z7
z$4F4B|EuQJ$;_mNmP?MDx#ZBd&}zrgeBy^fVadXh4-QDAJ=<F=n%%uhUm=#Mq*9Pp
zx=xQw(q)^uGZ}$Z9PS>D!&T|uaGTz}yqzaTWHw+sxNKh&T{5;MMbNIJN0J9{?Nj0+
zs4yiE4aX6`v!j%XhJnUCiZY^DO@gF&18{VFAIZabBi;BWeiMZQnfX0cGSK<GK=r=%
zhj<3mq{_)t3ZuH_MawC{@x1q^@HO%UzgA%rTeWW{{l}NgtGp?S7iz<3i$v2x(HcV<
zpac?fvrd(X%ucC<i3GegSh>(j60S>ky*UBbrJwnD9IlKjWblmzrAoFM0X!6G9LM6z
zP*f6`XR%sF(XVBSDTxc(w)P%IvUWnX?ZBG-ad$EcoGt4VvQ}x-8LPRq#I=~(WEDA`
z!x)M)K*)B0(LdTBp#|wet*lb^(qH+OX-^>dC^mO92^RiLdiNz_;!(Cxb~RgNN{2Aa
z^@esEQgj%{*ptIW-{`8_NT2Sq$j*9P;FLhXLBAYu@rd1$nL?>UAhVNs<+XpA52v)0
z8Hb`+SC9i#eFH60mwhBDWLi(Q;z<!?c;x)7WkqDWI>ZExGpIh4#iLANB*1n6lOtul
z%&MqQLzrF-L%H4uB3!~o&2?hb6muB`&D;~h#UPLGPP!L4@pw{<rpf%Z`_#0>lOl}{
z*ymI?I2ivD3q)~cqKPs|z5uKns*wjH=FLlHt5F0V8`WWNpZqEAjgoUhDO50K1Xif%
zK{6yZQlC91F*r^L#QrON?aWj*$NmK1K;!5OH)5j|*@_1!s)6$^Ws>(z&pz$cH_!_h
zjnhcIuA~BUF}*#QXVZWy(-SINRdQ+LFB1H<xmK;g1v%?=qdGTBLC}RQzU>zn&IB@P
z#>m5;2jnE^iX%Xgc?|3;ql)wCud!p`%;h7=HL=Yh65m1B;F1J5PUJ_U%p8n9{Zck>
zS{*O|pVZY@AR#G>urfeFI!3}p&iy5M7T=uXBg4him)vqllLKKC8OqY{>A_Od^$^+T
zN?4(2TJ90ATED`Rnvk)?XRb5B158;#9T+qL06yKYL_pJ;>DedW{)SyQE!q8swXH!=
ze=t&@wx-_oi92d#X9rMJ(1#?VsXBezvVUH}?^1Ds&9zaOfnFZ9aubulC$ki?Imvn$
zy{QIu*PzjT`FQ~|r{#ihM1;zXrT0CXG)%MF4E(0TuIfvF`^fgzV77*C7xc)eSOEM;
zfiGyaFS(hCggdgUK4&eC<H|TjRDoBMbV!7`ff15w?}?}ZlmXuNu^v>9c*<Do%}D-E
zGCzEKOKq84Msb5ouPFu}x;Qa-U5^rj&)%PSQ{n;31p$Hk?!Mq>t>ueEKn+61LHN3!
z-u#s&-4sxZpY{uqqvjC(c!WED*W|Dq$=_t+$kuY-;3j2VQwhJ-UI!Kp8tKa?>5dYk
z@qx)uz!^wouee^E(m-+)UyR3#;5~M0cnhzsxmBs@0%N0{qmjP!cC0a$zVu~m9r7v4
zswiWSjKY;sX!ek7w>a&NGcC<RbebiF=j>GK9-}Ls$Ec)>Dc2SH2F(n{NV!Bw6~ria
ztn6He?#jJS?Kxj=<npTk=a=vMI^ugf;r|}LD<0r162ff3Av1uyXJ6Uh|MKO07dNPj
z1I#t(hZ}k1yU*7*GWFEmZ8s8r(>F5J_u2!xk%qF>gO0C8YQ@Ve61vfV69JfFQDrue
z#8ZRow;SH>_WK*37a*Wy(ik9`Fw)!?;R?^BzWK}TXgkKUx-#g8|Gm7~jlKpoC^@<5
zGL!IzmpR<tQZSRzMJ(w@8_&U+V@Mu3`hi$QqIQ{=k3Esd!djg6b1K;-aVPvW)3-fi
z)63C1f@(h;`SkQnOWx~!x0z!L43OG7CqyjUNtuBB-mrcT<?&8$*y;tY0uZg*#9HJ1
ztJM1v3r(7@@qD>FU#@?<s#|{QjvF~&+|5=B+wjJ*^~+*v3}-g>WwvLbQ7v|{QQkoh
zF*9<!s1bspnDMqNw3}W=1M;)1?1*LXd#~JDrh)Q0`^xhDT8V{ODXO9IO4f~67X*t_
zA6#dll+0Uiq(1&((xGU$AQ5+|lkI5*Qt{<KzT}j1#Tv;J+kqG>xFDli`n4mrx4IFn
z(r-CB8HHS5`nOkWBBbz4S-5BsT<TBXn5&5Qu!k~k8Qk82XJn2@u%<O2vqVH_=T%oR
zX;}_`n4UfBS8G+=2jwIi5e+)@BMNE&9(N*AmUw*fJ6}VRw?u2As#pMOUc}my+UD-y
zm2f;ZnMyF35o%GYI8q`mS(pr6Lg*^em71{H-{p^JI|di5@e}F+vi8ow6^IPPhOmsC
z*r6@fHn|!g7xM9|#AzhFg`;??<5)VbVtMEQlsp5eZd9ZCU9+dqg>Ief6eJ6VtktV+
z`~~AD1dg<5%IuF;tk;EMIT$_@Ni31iBg`YcenBB=w}7b#!^wnu#~Yc;rQY*qiRd&P
z2^`d+4iAv>SC@<=%+$Dhz|g9V(P2>znM}l$4;6B)1*R7xEKCw5e3|Z^<GYx_7hs%G
zBqJTRI2md9wEZ^~p3|11%oaKH0!(X{R{AyXqMyzUnurE!^L$k1>BfVi{i^c)8o^73
z;n68Kx{iH-4X>PygeKq;)=AA{w8PqCM!0yRu9#R8bp_Dl8pZason|`*xhTDX?5%Lg
z(_j6SQrl*_j{8!<40sL6Z(eQFloM8CMYttIL7t+GTU9uNsU-Rw0Ag%4P*JE#DN%bB
zmmG*aN8^Dp&=E@wpm(J=(@zTM3JiM`&F2UVq@@vtXGLPnDfh10o3iV$Qwi_`G^saS
zfj3DhqzR|AF9N&{b2Xwxw8+6eG1F!G)@zk3*U%v_JQI}%!JF-^b6J!@6hWFYX5pEL
zG=pZ$NN-hUBbmIBe%Wa%gpfiUJhLW~4(y=;jN~6l@@ZwsEw$|&#4E*jgqv_)oDT|7
zlWMhKFgMFufL{DNRaAgKWpgF;W0<(44NeCAFrC8bk-yKGq{Sd`#+6a0X}p<@@`yEI
zRsdg5LdbX{UHXWM(v0HJ+M_dVaZAJ&f{?-jfU`GBxEhSBYI5DZo05v~9@AbimF<}?
zp*xvN$RB~iq?krRBvIQNqtGWf<VGsE4hOZ2L}?Xkiuvx-?cwREw+yx^Avy^upZ5c0
z_hn2b<FQhWNEH*|De{_O?HkX?gT=&Kyr%0wv{^Gf`xK>VAfZD!0Dm_WkdsiMcp*tX
z(U^%L4Wj^w6xS+=!XCW}{#CeY`EvFAWVEyt$O|ZcRE$w7l?oj*s?zyb&_bw|o>K`-
zQS81?F(blQIRk+6Tu-)(zO4#Uh?9`zA~v)G=9F1>=t%NIPI^)iTPp9AF$QFOw6Lv0
z0>@Gl6>Hc+i%UeE&+1xal!~5y>s1b|S+)`w1%JF8$4(ydp^tN-a<K>sl}Ec25~hrU
z_4K!%6_ad0%5}y#ikcoG%FjwE3ngLI+2^pEOsggre$wK&@a0<+7w%tq(?M6S_{Y9Y
z6(6iTxT}8LFSfP_p=ejAwjr0}I1w^|+v66VFPZek{D<UONjz|w7&UPu8Yo`b8v{mh
zoQuk}HrmivKm4CY*6&od>L@l|kEJNnhLKGfx*l9#=A!&)pL)%F{R#=V7oA+}&wP5c
zHDcOu9pL|7pZTRkAIF1_yH7Ghm08?un{x|r@*Qx}cm*^^ry5ekb5VZjo4)N?OBh0(
z;$i7U8B%UMNj>K8sz523_r}*C;M&cAbc|F#vQU*`*qUV$YeKx`KyAH~_}LA3o;w*#
zU`0~6iyS2rsMrj1=gUFMz3f6DD%rnp(hJFfgc*BbkYB)brjE}C__-n>S#gBM-dV@*
zV9HbSxp@rnl@Dy(GSq3^IO3HHESsLsziN8C@S^FJ16uRh<muZ7%z>5@*n7^seO|ER
zJA?ere2~Xi2KbeQfRC@O<JS&kFY}#(8vDvc?BvRQ@8rtG?c~Z%JJA<&FncX=NH$PN
zgowJ7!WK16K74UB`RecPr)G5GpU&;?pO-=pfWTSIb5Ob>HAF&*bYm#G&9x{-ZPPW|
z7v1rZfpxS=6=5;GS8bmr7^Wr-Ot+ctm3L6JFc!r8aS9YKM^$=bG;1B(r1WSMI7JeI
zRUOy21Bh=$WRXn+BNv~0^7Z(i8?Lh93I5+g;bbsdSZ)r5)&)}ULA{%*pp{7MNJ#a9
zY*yJ@+zQq!1F+_bF7Tb0@yZ+zUn#jeY+XDzBA7G;ePJ#c#3hlR@PC8Z(b)2|wFeQI
zqf&ZM7$HlM{)w!7oWo%lCvhbN_TJchrUl5DX;D(29;LI;7hTyr`Y@F#i;4mlJlh}F
zW~mIh-o`nZYZUFY=IGk~o%gKCtgI)ik`2@(h}*;;NfN?<T3NU%wx)<C47o$C7tvra
zJ8?4nYl<J)^4rw8%j1{w_Gl_j&C`huiL8blV*HiQg%L+-9_mAL#JpSXR*@~aSQ*Q+
zkibdO2Z|b!1rrS%Mccp%%rQ~%n?#FCmP$YOCk7rhLW()WgM$Sngq&2K#MLM`J9#3F
zR`I2n(dQt=#bCxkC{yMlVgV=};!n(F#V(bv<4<5kSeG^yIUTLXh?q&hh6Q=4X;5M%
z8us3Q#>$}5A&enlO%BmMqhkNf6;T=hjEQlUR++O<FkvC8&{ax8s#B^3&Tp=A1I!8n
zX`K3Ps8-C&F(z&wte^oHeExFtVO1WY936i+obBT~FlCh|vRLI3eL3^7p=FC>L%EVx
z4OT5uHPAV`r(@1827++F=Iz7!qo~r|?1|1b@#Yr3<lx0xAG8(9VMb$^*&@eQB1r%h
zx-&j-FDrDXbNZv9Hx6&8KlUH*gi{%IcQ@vCQ0I!-lfU+jT`eupXWc?p%Kj93fRyx#
zIdCz>B#lC1QX}kW92-s}F{<4w2G~W_nY?{h%M@y4j6&NOiNcd+Ay^n9COgR(qaDZK
z5`S$2s5Rg%qVI?IwFW5>2phsIBm5(ZR8ry+g_{?#4JGeW3Ljo7uHQ)S!~LT46)Zr)
zRbk@$FxJswAL*|5^FCw|bWpqu3=2p<=QXZJ4-`|(=rU#XuD|}rVpb+|QtyP@3&s+2
zSUNMy;no7_qF$lY)qK;ID3Du9VE}vNGGnIwN2-|ze}K=z9s8=fX&5D8E*_nh)PecZ
z%Ji}}GfP+g03&L9{&;a>_u4fZzj~|Yy?RDBg8<zXx>ye1L@wKqRf&N;8@b#=2FOCS
z=9Tq=2k5;<s{3i`rUc2TP?b$0W#t?UXM2BfNO~?Q8#vas!DI!bF4EWJg4bg`ZtdWb
zDRnu9^k=9hM7`_Je~AqyzH%!t<8(9i^l?{Jnf*t_PRuvRvWkTmq5>#%dYIo!hnLh>
z1g9z;smS(Pr8_VS2*vAIL`>m`#W4lvj|ZTeBrD6dOkGNrU+zR&k$!B?yTN3+JCse(
zEtOA0-o)Oc{^i01%{Ip#&OU!30!y}bBS1|-i2K0Yt_gO0$nzFSv)Srp44Da>KD#dy
z<$D=LFKuePgz6bzQVh$mvsB(=JOM6G&%Z_0-<e52{{o|Uur4WLRaM1%k4jMEtVBk!
z96r8)IMNZkmLh6p8~wAEt~1osESn9Vooo8U_(aED_#JkUx*@As#(wOf1C|(DQN)?n
z+<7;_KDT0)y}}%%1rBJ~xQ_p$2h^bM5F7?<t~XI_NqiZc8jW%AMJG`rrsIwmILzT}
z`Ty==22b3!WgfLn*>#*l8hh-$GLmsR98y6<3n}^o5`&qJ%e7R4$-tI;YC|+pti~)x
z_3~k6@=?zOX8o#G?VhMsEv4CSuY@kw=<e?As~=+Dq;Wk4C`?OJoJN%s5;kun<q4-Z
zN*TsDemm%tcs3vG(*ONp<3>DD(2L?3(&ugKAirqnkr?Mt)ysqb?Q`=(CMt{uuNi_*
zJ)OU*D$d!cl7-O48p{4L;E;A!u8yN}CYNR~JEg%Q9S_nk`@QB%MxnyCI=Jc-dZcbQ
zYali{hr~DNni1FPyGH68f8@B<dYALM7g4p8a%`fxGKS#&C^W)k;U{>HN7V^A$(6`N
zh<1(Cb(_Vr?zegT)WTH-1~wh=;45KS=?5|c_0)A2>9V6nAxU170(g}J<z;nJ&sVR{
zV8h9|qvKG@a)ZwUIP-9JTicO5dn2`uSk!S4XUDhY5E3hh6ERi5ua`9-00hM(m7^_Z
zRE`YA>DoIjGNy20sTf8zu@S}6*C~;Eb(_dN!y@+}<~xwM9fBA(ZODL6UYrbAIZPV{
zPTvp1K#ObEn;K`{6#Ar<$kLx4Ojow8m53p{1F&uxA1cJf`F$1k0GvMj{bVOn3<Q0*
zm4`6QDb{YrXpjXr{GB%|YC(r;_CC_J)h0tM+2~Ra%6yYP5*Z(r6q&BI{xWR%v-jxP
zhYY<n2^0?4*9fS9GJ7}e)lB&5)I0|O^O}tV^`*0uSbkpBp+(0#CmM2j-0?&*9cMAc
zqQGcbqF<Kiw!}Of4L-kXGr?eXN2G-1f%g63g*ZNy8jLMB%DstNa2aI}bdO^oOCP^Q
zk>YVmY|#<>D%zH~l-PJUZ;32F2>usJsEhdGY3WsKRMst2cVu8)@`|UZqpdX>Lp=K0
zsJB4dw%|r)f`LrXp9xOP1buydiLr1JPAc*6TV4Y8%B{FQpR_OdZ=ADd0SS87F`Z9Y
z2L=hU>q3tdyzeDWG+x3R(EeQ)V!w>2;u4b0^u!O1!LW;&N8yr_oV#{N-$g@8gQ12G
zz)Li@G%j1hJO!wK%k!(852V>5@0~3sIwOW#@kI4!O|CBHA#G~d$czA+jxtpYs=gnR
zm7UB-6A2KbEy$OnPJ;L;vpBno`s#Ftu#z)xPDj`PODVT?o)VZEKdBoerB@oN#fX|s
zgBO>JMZ#sRvecSh>Q+up_VA5HYQxfm4AVoWrqa}URqK=V$L?iz9(3TGSj2uPALm&z
zohtCJQX-^rVOt+FT6W%@EGHKpnX@jHN^r9Bm)@|*m4D`^3$DD_dIDCSvnmeAa?W+J
zwdW#JoPOR&<&R$E!aw(^1s8tpiy!a8XHS3N6N;r%C3<NKgB*PT@b(Hcq;XdPw3#7q
zp}-EqzC59~_(XTTh(w2{EKYQ|?uY|0A0?}Tw&Ecy+BS#*I*NTpVg>G5?AW@TyfOou
zqC$-7Oz%DFi)(gaYRpa=Kbv>_oYG?kjho7&4?Gqd9ieJ;8C+<#m=X;5bg#X|(oG7v
zSp%iDDAH0^$EW))5N>lU&$wH(I~a5M)E~G8{a0~G$1NL&uguFcsqen0OfjWZE{D}_
zH|=`yFAXgyG-y4SmT6agbg+?JyL@7G|CjrunC^!}Ll8^0kIjRSg2y}`&A1aHxyuXJ
zU)u5R>DD8AI*M@STEYcZ5_5j=QV3)5uUU_7f*|Z<Vj0JMdS6@+z<2fw*rY-YSEPL@
z8MK)%MqpBgw13Bzx@L<JjTBU2UaD|lV?vGI5ekbSY}WX}8RMuNwHriarWZIE0wgyC
z5IF)xPC-OjoTozJrw6ywEqAy)U5EZalT11@7F@7ik37;=7HwOY!#W}LuDgEJ>`~34
z+9_*a{jjd{M^w-3Kwl%zF4&$Y&0k!V#xlnXY<AvN%qo+-e>t}@CHu=-J|Sv+pM!3N
z8#o`aS#MPoA^uEV$f)}apvd!n@4HbaF5QYsqUf!V(z69S?)bK`WPKN7!NLoyz1`8*
zzI3@<p}txqH%CX)wu40gGHhQ;o9nZEC5OB%T8UXuKuge_mh$f3nWm*w_e=M+nki~N
zL>D}=A|+b@MSeiD{}%zIbK9S|J<-5bZ8NF36(MlZwEy#6fzWY+BVr1FNXx>tVynUa
zH`kQN#7#OXyPe}z$|ed<8$~ycck+p(nWrvJnt8>=+7NQ)ei=g0Ijpm7#qzWgEl>TV
zPr@IvrU-+2b^5%M2`swF3IfNpM_EM-D8i;Yxmqa{mnvE)kHQ!{3QXX_Us^szYvwW7
z>_(j-SLI_>*k}M_d@;TE8Lc1h>X0%VzX#+UTKdh;l1qhq1*m2@@GFMXM8$&R#z(-3
zaEo%I8mKRqC=_!&MrV-<rj0qeQ%vPUZiQpxi&KsC#TQ6D=psj3VRxL}RAL)r>rr%}
zh(GSXgITAx3E17VqJuv@F=RT@m6><xqYtZ<N&V{?_-PcdQ5I8AJ?C8ARv_#EwXjLa
zL>LpnEndq3W2UxH>1BXe_NLc>s?bQi{wpx6E;*`8XxG!<*gD`F87i25iA}LXryZO|
z5gVB*wvAN!3fzVn^dYSp{jkgx^xz@wGQ=(g4rU*Q1krlx<WJ#Fw5A?ne=7Ko81l8l
z3VS0vHyUdyVd?W?)rp)k1-FKD@e6Mr88>afI3OD#FlXG6dU|Nzt9{saqec!Uk4c}L
z)iLebx{htKRG;f)$1RxzmjIV&aMn_$b@frGdxaP$#U-hcpV6LuXJ-{l^O1MUcSEUk
zxDGJHl${BzZZ($HZiN$pEl%j!HP`&NB4}qKLA#Vwt73swBS6Kbh|mSf(t8Cq-JYI3
z1+T1%-KC3a+P?-6yQn^6Bi;RaEJo&<^_K)*k?51KMZxv3)@#p6EE9}V`}$;}i@0l6
zQKBl++yB`qG}3D??$q>Al_xTFY4|`38hKa05iNCXJ^kvBI7-Twtg!UuUyF~dtKy_z
z@n7b63K666=oP0B)i+gxNPjZ2LQWyp(zz8I>GWLyzKbqgmkG>~;T=9%N%V`&aNPR&
zW{71uD^#XV)|}A77DhEmEO96~4auZ%GlYk$m`I}xuCkV$A6asuD(6vk=0qH&(JDQb
zzGxU-q7vGPnN}nXuw56~7B^h&Jbov6j*M$uem>ECntQZWnUE+0e5Z{!<JapfGO^fG
zqi~U2R``cGzFl1;Vv^a3(R`Kyu(jnO;(qH;$)|WmYmc<5PMX{!*Fn^NQHx&G6a*0l
zO|mqJjzejmwm0&sf=Ja!z4Cca*sP2;mNrRIQ3fR}utXS%Oix>!$n?f%9Do5RSs}88
zRdLyK*A5Wdl$<u(SxNV6q^}*)c4yAKOYD}oKN5!94npPwB)$_2%_0$s_E)GD4fn^E
z^351NMirYyu9iArA<hRFch2OL!nm_ZLdBXlh-!|Xvx`NmY@@5th?PC%-JivXphV3W
zy=gNb2suKdt1|4UR(Zsg$Y_o~n}JE3otUY2{rI!Qgw3ua=q2Y6Ta}##9Hj$I(pies
zlcPZqpEcHjJv5{}16OX1x}LH{j76+xlyjmRskJ{z7$H@jVAQrR-?<Y2+S7v`zcyN5
zGIP&0c23L2l76hcS~$DWo}t+*=Im^(Qek^_7Ns+34Gt8_LV<h~|24O>mDv?Me9qzT
z7(H*vlOA48$(0A^N+qX%<$tbe9Q5`6HNl$c`csQvXhl@5&`90+2|^XSYAr+U-*oHD
z?X0IO$73Z}7Heq%Ai=!vo2tlFtY%$@LOO6%Qb7m#P~~QLO6P>)2W&}f@L`)f%ZU7^
z16jXiFp6bkS*VeE`6ZDPFPz7PN16Q?e=QpX(dNN_Qj!3=-~j*Kieyh>MFB1}DRXg6
z?<fK*m{MhmspL;k;GFwdd0nl<3!B8|j8c0LgzLPb0oyW?t64L6j2RC^K~nI329Ts;
zd0fj8pR0!5cAkBR76uLJuxpC<GNNUNjZ3!`r%!+JpvcBbje4l$N7ap@Li_56UVNtl
zl5~fX-5|ti8&R7eyNvNLn&Otkea0O&6AeyH>oWVputs;5t9r|NU#{1?3D23Tq|k_o
za^6Y1Fnc@L8CuPfVT(b1ff3UK*Z9E?Gi~(rstlX05p2_S)q_J=I>>ZVs{jvQ2WG)_
z`2Hn&K(0U?6NCsKlNJhlXO4iMt-xfUWta1`V1rcdj22CfPvDx}+pA_cP?XGqpJJTw
zYep6}ju-{9*+k10KjRH$@{#}{e9J9%vI%l~d9jrWOVLXqBb2(35@jW4adkvj>*?BN
zliW1Ywbx2dEAG%>dUDz6r0EJ>dMe4o+s#RB3(F)0ef2{wxnMx+a%3vN3vKE?x(yy`
ze#-w9#zyu{3F64bNf2)y(ngoF_s8gxgjzf{4I{Cxj@ex5si9ZJV3-=3Su6~7u+P5X
znEv?h_6Lr@=s5BLo+Lp@)maivYh-gL8KxN!h4TN<mBMwYgjf$9vraha*^*keK!{Dm
zyk#nKCUG=VK8o`|Es<jNxjK_mV5<~8qkb1swpvS2%%*FlidNwLxUp%I=SXa%bybw2
z6&3PO7J0`@l#-Ie(#;yAf{b5<UrK=CPyQqlDRnqEtIp0d>774_tQ(-ZNAxQF-YK+w
z@Id$o2`u{2@*!Y~U&Fe@SOdcXF3R?lYSfBKCPJ2hP*eRGV;%f9UDM=NToSV!GY;>G
z?B-_6!U%vWpRxl0cT+3mU;NYnAPP`~0A>e26PjF&exGpc`nN0pe+Ea+yqyONQ?Glv
z0YnXyM5P&1n&aWL<4Bd@tYY&Aw+1W5)@%0-Da(e{Nd2I@Q={<&@BHOkh{y0@ut>%*
zq*US>HAdz7xguj$qjJ0d=U_N{CRJG3(BF4Pvajb32Q%^f)p=^{sY<N8XdD%trC*xH
z-L#bn%DbE;NFAC~nSXfM;?hj2&nH&u(xpcfVaU{%KC;EZ;ERyUJW~}FryPl0AZ9H6
z;oDVBH>pFdbrUlbqMn}FGh!~#EDnZJvRa%^Bl=OTRHae=WYc9^hF)A>`ooE4|H_rC
z`&Lb3lWDH$Wwe+~efCWti`nEK_d!gN9>|nAVsVw5;#AxpuF7~(K`0Xvs@FFl%U9m2
zDz2zwM2>h3tf8msj*S&TkkqwDXivRn&lbIFqcC_>JS@!H@kX839HE+|(6WsJ(E>H@
z08~%!`I9z{Dfb4IuqL2w*O6)6f%yq@6)6#pE+eBscO!Mrw*ZN^x3IZSz3ceQCM+S0
zupp(QNe~UO$rpXkW|Hj!5@VXweXBSyLL2&Y*#e{9-ZVGQZKQtk9xYI+BUM{vtRNaV
z1Mi{H7tiCNzhN>&Ky5s=>=dOvQ3p0`<h8vu(d=gPawHkZyreA9#M@ifG`qDK5UXF0
zo08Yl7bkhW?TsC5H>=2Yvx$rFlynUo5X$sjxM|66?{4(B)$aS{s`_Ccd7<$o(tx&)
zVVSEw_6;LXIDPfoSuCq?)q6@6rUL0=*FcmiSkjPMUjlqa6@{;MlaeCAg}qd&m{1=}
zg4q6OdbMGp)(vJ$)V=KUr;=;a>~yJ1+@T1fDqgZh1aOvCu<Ory1ww|=?Qhs?8|jsA
z!pAe|qkb#bjt&o)ADMFaq6bluL`i2+x@F{$$Tz$YlW0P<BUtUqH<7bJvaDfBN6a-*
z4fNRyw%&!*c~xIOWpHD!S2TgH!yXMc-j6*RfHp5b<q<xRVXI93?xi;$qRThIAHp42
zK2O`))$LXX19bOGA5c3FS|!UVHZwr9KhP>vE7EZXMr`@x80qkekE_~h{E6PsH23mO
zA6HK_lOXe_l%9%}H>^E5=ZNF;f|nA{N@Scf8mXY;Sc_#{y`GtXPi`J@YKCNeVcT*h
zMAHjaEX1qp*+j2GG+6p{G8`8i=Fr}VZ?r&__j`K7CJ6Vf0{$iJ>1`@{N%ZxcFPlY^
zc|9zA1kH-bZa$-CsiFf=xWI%j*~A!!?(4#`d?Hj1Re}Hon5kplLRnDt^qti0gjtyu
zVw!3ohui+50zyW1y0&nV@LO(%meyQbPhIo_aZ*SD;8wx2?GTr()dA^w#_y?eta-OA
zHMg9q(Q_hKL|YA&lEvzq(W+GCra`LLdBVRv!qsn3<HLdpEA*Q^_*1ZAjv=-C+$F8v
zwE*en7MBzioVFzWXDDWV`qsoqG|IV=RM)e7eL3P_Yl7uG9-99j{a>0-v(DHKbRrTA
z@2>B?Ps5vmY@<(uY1%R>5-CcOXDg<Gg7Q;7?z>E@FnA&s+X*jXp-L?~6hJiHWIzoB
zQI`ZYuI-9#8ZX-rG$&EsQpHKk<caB#q#}n-Lu^_ko*1nW)5}#p*%rYZ7q+5z<JL<r
zrKVYGhjh4?DOYwTJ~*{2;W9gm)e~i(>8DKVHtgKyL*Q%_jHZTpY)BKOmgP!p8=9F(
z_kO2`ae6Sji7J{#b<RT>yA<Nu@MhySt$co)N(q;{i4vL;NmEf_-M}I@I|f6fsCJ<h
z%&APubmQes)e{xS9d$4#Rt}_D<Fzpr*8J$9Y%apP4KqY3iK?Uco42c2*HGE>kgrO9
zz2bdgM)zX1e4j3~LpQoa*8iGSGzEpD7AGj&-lYVERf{buNR7Yn^gw~S{!VNsNFi|Q
zm>7(%lb?a7zQt*xh<<^Rh9suY%nS!KeAPKX@N(Rw)(>G$5RO%6AS)aNBt#bh-5>0z
z*hszpPjp|oCeWzvR*umXqpJCJRBSxfW*#AqW@MuHenQwo!menx=q`XYY8-7QQ8(Vo
zv(cLk)?-9A$}Tne291v+wqT*0{&58Gt2NWJCuUbOew?;~$~39BbrmJV;&HbayVrfe
ziqoP(U;G7?v>`%?Z)_v#b*`eFbcxqS6~K71%}n7~b<G$&2icNKwZFKo0TmwGEL?=>
z0YDMx4y}W!Eu}&sv6a7j#cc#VM0Hi|>U#Wd&)8m`T{2ZhYXv|Vf}zqDMyZ|#awSCS
zj9L`CWlAay@Ah|rq6g!U%tn>KUAL%K1ha6do*oSiTE*(0{hd~Ee&L1qP2!EU@<{)J
z<0pa0quhXmOYh|(BuGpr;w&OsPGU@h88Q251B?(&B=S=_veT);)wgzF^=?HU<nqLJ
z-iYlhIQ3KmD-;|$5hMi$UJk>(6O7<6Z<yYD(tB5%rGT!!Ro}2NjzRMc8b03EJ}lJo
zUTb7v9r;g0mIm$Q?(5^>EXyQ9!VvOPpMR|obxFh!zM%<LRma5GG6anP6y~c>)heKL
zl44wx@@UGsO3RY;wMohHYyoEDd)p@LsepvO=nlh`LCDA6fZqaX4%5nDLA{`7h3*T}
z>h0-eaKoOA&zR^mQtQ_?t2)vNbRsvh8~FgF_g+k`Ve08KwjhI!d%X?EU(`1XCxHFG
zn5yE<8SNLS?a_uin2hB;slQ^HWC@&TB%?ZLbL@?;r_cOUlL<dI^}%$eKT0bx0UvhA
zgq<0gd_YVk5)0p;xg}4}Ki;WQ@?AZB|7Til@Q5T?O!dCb_FR-O^h$DPHXXJpsW6<P
zlMi%H?3DjB12{P`^7M>`QCv8zWu+qOtIjy1HxlU4aHl&FNki%wPV;6B%=TC?GUA9)
zlfgbC5xy8Zq#N6PRTUI|4K2Woh>IV+I4*u?-{VmCSM_&b?i?2SmKQ6CslFhgQIy$5
zM~T_;5|M{5r&iC`)|dX_{e+Gs4m6+ioT}LbMA|0v{ccH=pmQD5ok)FZq<()~Q}>&Q
z8W{WRuZ_$CpdM1s13i)@2E_EzH)utcN`F&s7Hab#8@eS4Z6~?`GIkG&T3bZrT-A3*
zaOEJq77XfluFg=`xnT9_fHJe^UT_&}<Eu~`=a=hTJ?ZwSQ2F%U6Th-9*}CJar&p*G
zG^*n0heo47<Pt$qpk$U_N?5Lx%>VtLV|E&~r^k|pW?w+6CrCmfhzw2zgTK>vOtJ^j
z&eNU8E3Pdn^+SI3)cJL8{7(59&~X;`-e_kO8cH}$r;(~|Mbs1PX`5j<(MAN2gP4b^
zJdZME9=)#!QtauZXSBGz32jd|)0mz;hmK++90k{rW6LMku~JwUg<ww0b#HEHkVIZj
zuXq*Wo;B(e$s8E~?p*T5$q<0H;#I8L+7h3w)1v``t`2LV_Zh8&IkJeztj)gq!PlHM
zFq2*}syiQ%l4S*hp+S}vKoBRjJphzG;3G|~Wb3)xv~6?fH56VjRk49&u?|xW^z$Cg
zh1fcL_ios@FT?P#jBrR{al6_&8*n#s?u!FB2cJ1CH}d^fWJ3^#5-KnjaJQ(ibYz3|
z)SpsD)6lN_AG#Dn6aI7z#(Z<%Q~*2akXEuiJVO`1uBYF@q#+#V?0zd!Z+T4-wV_Fd
zbP|2kMg{f?mn9brn&1@RAl!)xtpLW2Bas3(shqzhG%L}z)%yy-_|Xde!4~eqBT=<7
zF;~I_jd9~T<__wtfHUj>B`UZ)c3N8eH(p~ob#RmUB6$#$Nu=#vczII-2~cltEd57M
zbeS3P@Z`#F)DSf@lX~t<OY{Wcj5uhM0;lURLd#Ghj6cdtATe;vyYzJ_O5AkB@}99c
zmiIwj-E7tVmAoXnKt=9egt6D2qr$VTU?br8hEUzZ>AlO3{~X_rp>m_^_*=D+h;bZm
zM4U{kxij^ym;Jj)sYqd|oP%!snPbjF%}PNh#EyM305d@jx1xAEOkD!13F`C&1(-ba
zV#6br?$TBs?tUlyz`Q6@fm5zwl&`E}_o!4|(glJ<$71(`<;BdKz#?Vwy8i{&X;S9n
zR>5^aYewUQJ3&!Xc*ua>Z~q+QB0MLd2k8*nw5lu}gDlibmx@|Fb)B+wP8q!FU875t
znA;%+36s71Q6LnN%+B``8)6ap;G>UK-;z_8ou>$PcY<O-I2%?|2W6K6f&Sn=_LCB`
zFHQxuN?Thzi)bMAu#UA&i)^B_=nn2*47BIoi5FZEp%7X!oGRySdfXw^VkmJ|NxJY&
z-z`aE=Mk3ls3oz7Rzl_tmjb}i2?rMsTXe8TQ@S>zlTd0vBi1kd*1snrzu4*pxKvSf
zGmWy*O8VgPlpu2~S!0^pFd^t2xGmI2T>hL)36%DNP7I7E`|f|CYxL0x4*M>mVYEml
zLk(AegFi3mI)R6B4q%kTIVg)%9+?e7u1cFuRR`Dv#Aieo4gM=3Jye{8f`&p0@=Byt
zVI|5hpE@9hN;K(AVZIVsuwH&~+X^tNlD3YRNBr0D+++0$1n|5WT(cJ(onoPKwdsII
zvGQ^hE48F$aB-imX(A2;xeQ`JsM;eM-E)|lc^H(m;;PGc?b>zILI2wK)ypY0QKE;Z
zAAbH1fA##GRE=2TX{*)#l|LtQar&*{is0e3$3C?Da`T1Jo&76+<`s9<mwf%dU%zC@
z>)x;=ebRTP8|g>Bj9W<j%w{s-SK>Q7`2o4Pgpy-ak=oW&sebSk&r<n_xIK&xw2L`J
zK9ozy`HLxQ5>^e803KdUWR~eDQ40$ioAUnYDDe*%?SL?76#lDZ{#9plpPLS_`Z-Dq
z0F?I4*J1OO-J{D<4!WgPjkZfi<{mB)5D609p;{bz-$7p_^Nd*1npDebP77JP&t1Y{
z(+99dTZ<03wwcs_9m$bEjI~~}up3$dI4-ChCYA-#YS*1V#z+EsLgGLO6j{|3jAn{A
zw95qgb%}+5zhY&8Ce_}&Heu_2=Hf(#dw>3TwB%%E)B^x4hJ{MpqB{8WPrgYZvprE5
zDg0y{cCQLLN!F;YAKF+kRKTzq5I0t@)WNqxyBG~5Ptp=7>#X$Yz1=@O??ASIyiFm;
z7M0p|>O-U=kfg1RG+JZ?f=3kHw9pyG-Ne4kd`DH+bwAhHkbB1c#gn9lf}+~C;GP$4
zAzHakIFx`93b>`#bX5-}2r}pbNBGipQ9(ip(?SnG?eJKCP&Am|97U<luuDlQj?l6~
z3B;Rs&k@C)hrE!tG)7s<9}#D>hCiMLE_$O{G!h<d!8Q_E12W^q>@ZkvaO(RMokEOG
zrYgHcM1|{7nh8q|s-?ifN4e0pm}QVGpFGMPKt?$aBtc7wlhOl{86{PKi7WXuu@gkp
z-A{&pd}~yhF3ClrY@S%2?k30{QCwVxo858eKhtt`;0sa*xA20H)voT2Dc4baycN{S
z4hZ_v_K-Ak&a_ylo9V%?I$=cXA#jakGTm>rk$U8Iv-2!Ab2SX`M!Hkn3`hNOgDZ{h
zxPfYoo0U1FMefxZ4uu3xef9!eaKq50>leCBXePw_m^ePans;1@ndN(<eT({zaX<%c
z<-q56Yt?-(fK-s=^rnH7!%7!eg$RNR;S!m5Yn3D_fs_y8%!FDVx@VSG6bArG@%(S7
zA}$FRgVpX}pzwjHgq{)o5CzUqgoWoT0>^~Slmw1hoFwp>W3};Mf68JW82n~Xq}p*a
zkSf@0;#sI57)b>H#HD|}+5qCSGm8fzMmK@JgmgDYRTW?;-N8nMYf!a&M`hf>oCS_U
z&}2!_c5nCE-H!uj#_Vb?i7;mCZ-p^G*kf$=SKY?JQ}1os7dn@uH%(L_A3ab}{UA2Y
zP>_h}50i)~vYDa0^`&2Mop%-Te(1(gqm;``*U=X{Rf7Vy*rlCoV*0<~_=y&oXy}d;
z(F`2fp^R)v_2TT{%B@vw&rNxorja=EEA%fwx-MVL34p#t&3}MRw(-smCz0MY6rDu+
zb4&N{B=*or?A9kytAu$=T3N|5V5>46`&B>viG=l`T~kx>&r*1&>x`er3h#XB=(f{R
zo1SWBjB`)v!r1W`IewQI+x&-hW^m<Zc{7~SD&RQ_9M2`xx_N%_R2RNT9?JxZH27_d
zL#JMG?>rouOj~=TRdoBxfnD-a0ITY$*SC1(XOL1MCiAN9s1zLpho|X9M${uR8la)Q
zpvoH^7!btq{{IpPFy$P#9`A8&<c48J_?dUTkF7GNn^qYR=Z8TOx%tNXL5stddO15x
zIR9o>(U%)nsSZaQt&%oAo9-#}6F&X>k!L2o^*(ZmQ3Z)95XP9gN9n6(AOqbUQc?mA
z5Nwmre*GII`ID)V%Px2}EAn{$xTy4#J`l5ZN^u@GC0Dq9CW?hH-jhB%q9Q&}1rh^O
zR6BUwZvTwjTy~kQ%~(NAI@FnSim!{^@KkA|OwuuB!Urk@G=#rnyWQi1@3W1WI;nDX
z$$8qSM)ooke?Qtn$cdSljPIo01vWlv4X+;=$Zp=c?y{{T6xR>~%3QQB@n&@0@uw#4
zFCQdo4dRBW_Fuj0T@zxu%FLu5wXiwDFR=)<8L%EIJEAJ}7nzAwyd*gxP{m4u);Frx
zMvhUEh&^|=@-rLK1G)QLw(eThHHJL(ti{PwUq1QqSXPonLy?-yzT+N~Deg<%2dOAY
zMu6Pc%Jr_PJrAE%I_YDZ&0+w)-@o$5JuMyWia^UmZqXGw)=&8+e%xyaXjJ0seYeix
zSM{#pcPpe&!JvHlhF|lLzfBKYT=iN9-$>L*BGv|72^c`92r_v&=@tx;eM~}%DE3sM
zUa$@sg^&}baJ?~O7QXxK;Y)kFFZmMPfvrAKpbuS1Ts-n^6x~=PKCx#CMQ}07H`4yl
zZ+pZ&Lscc8f^0z9sd=uo&ZZDJ9*jU}q|d7qVqP-=onp<#0|bQ@$1xyowB}&8QW;C3
z{dK6Iis~r;8dmR7CVuqnqPe({y76dgF9`E<Ng-2Uj=XiL`V}fr7#FODRB2XJ(!Mwq
zOGq<AB5-f?2i9+~HTh30Md!)WxWz6aM^dDo`4P6&d)9?ah~Sq-y7Iy(-<1tdoI-_R
zY!-X8;4>f~hpe3)5tkOSJf#`<K01FeC>VEWhB)EaMBNB|7`iGa<5mC8p?cc4AEh@Y
zjss<DuLcKj$j-aXT7Vn{fI&W9;D(cBwJ`Ki-n%a6Rsg29^Z<uhHLv!glw+(6qEB16
zvf3V>gc38_3B$g`3^d|_MA7DQu)Mb4WJ;tOKh^=PO^JbRr20QeVIP1nLq}mmGl`Az
z4cyWX{S{Azi?8BUsm9M}-Yg8Utf?4FDTjr6zLAR&U?dz|Z_?&;svYw01BVP8&7Kab
zK@18l8H55IDnCvDMHL{NG$b%NJ~D>#;R8{eBg}oG&v2phYNXw+wxubjESeNTu3BRh
z3^Fr)X&LW64JO<9{w1l4|2$n!{h^y9^Z>1I%@D<p>cPm|D0(zf8?K4hZjO!1HDeqv
zUN0r28iZH8O<g@4NYy$d52bvLDO>qkPR$pkXxAwrN0r>4AJQ09GC!Q9cJ{m?c^ghl
z(4Qi-pxFRjl{W_?jZxr^XDrY;2s2ZNfpk#ID(Sw>Nb`N0ExBZq2+5&c)YJtSLG4!Z
zc$y(-974vGZ(JScn;<FV^|w?E%7LRLP{e(Js-1`=+cXxj4k!z6ij)`v*s+Tfz`j-0
z2Ce-mZ+ajo;_q|MozNo^pFk8s8Jp@%&tVQNz53TNOf=Iq){9f2N}QBeKxFBCZ2c2>
zPJ3j{ZG0hYBZw^N(biP+7m^v<sA0M?7uQBh7Un1;ogr}%dH1=OiR5_1FHnYaBZepC
z@mMg_Ezc<Hs3rAuU@itJ9&S@v$~mPVVJb(Pg&aOv$v1#1sB9N!^v;j-`*JHRg!2mk
zZhn#xhaGtu5Nt?632=to^ZyF$X4gFWfD-Vid6PuHV`K(wl;V8<QDo6hB&9~`?H@IX
zpdg7f<2EI&r~zmsT6}+FOcn;Z7|uf#*I<Sl<@0Y-DNWmW+s#a)>&OqwGc50=f0qIP
z+j7<7PUFWN&bE@fgBl7(zj9n5KGQk<>LF+X+uqxG?ndgX?@^Ihk@fBeHz;-|Aw*KM
z&+((2HYC)(4{WV2Riuo7G>&zNU<V)J3B`>!{(_WaL9G%;=#1-v)DD+~hCOytA0re;
z^Z?TTw&Qf#!i}dl<BD3$%O7^)3ib5&+|6yN5b_y_AksDgJ#A$U^~IQSof1L!XaNz7
zAo0@t{z9VNy`KCf;tLCdD<gVQ5TgzVI#zx6Xw|n3ax7h<p1cnLu>~pIPpHg?AGI<t
zk&d7VO%xHLm)z6&-_m<J?YGK^P!2H}RBvuESaHvLJ8jw!O1Yq-?Ri}2^@-l-fnvaZ
zoOWl(EPU$f#AV-+NcHT+iBv!Q@5f`)O4dO=0H9NVq|@d?!()g;6XUxx0f%-2WPSTu
z^|!oLwG^O51Y5OaNe763c`%Y&qS#(#5)P|I>s4vVN*4#-tf!yctB%O>Mx839beIA7
zbGV9Tp9(=jqXbu^tf#A|Hhn9Y0@C>H6DW>$!r>k=_z7x|x_~fSWN-~U+}e8Tch_^N
zbRAA<n0I<wLt8d%-8k6n1vc}OVHN+x<!93ezXYET4-9U`=jr2LL@~^U4*{NDGCZ)U
ziH$e^e)kA7BuZW*eNtF0npqPKis@~2?<A0e5MGaMcpb=SrA<CChbYN=v+kD;1Yt0a
zqD@7%+ApnvL0X(e%#Dy@6MBd}WUqfcZjOR~(&0%>&h2-qv7~+q71zN-EhScAy(tMr
z<2ZzX>yO0ix@mqzmp<m-iPx%?vMf)OjJqHhaYyYm&1sW*VTVa5VxixpVqoPP>3=y-
z${4G|rc9}h+eP0efpbnWSL<EJuW!!3ahV9Wk1%YLRM%g&T}i6clWYKGQ0I8E60$uq
zmKU{={RgnTb?S_!XHPoiLNmU&>%^zW74AJ~W>hNoGQ7dHD#yjM8%jsqCvD^HmPU*c
zFLMQf32JX}dx6^<U|lmOS1Vc`X@sF7Qu813Vm#!up7~tki&FVSpO3rANQn`R?{Te9
z4Vzq|Tj(r}AwiB-P0kI)5h8X=ZVlW9@PZY{JlZ$)>l<R5iXX|ZZ@?oV-JKXfCI>Q@
z($hoX%3beWK2)H;)YBKBw<5$u`b?~on$pS?acrc!4sj?CA`b)n<r71NU`}}v>*;@e
zvhsP*NSp_0B;euSqa?h*s9nN2^g$1`B2hxJ;t*tnRs=tTm9sT(ScH;1U%(GQ?3NZn
ztlhyK3gCP>skUsfxbC3T<BjK0`xTFa6|m@t6d#PZw93y&6fmqw7DsdqW72axO2UZ7
z=wOaIZgH~HFLk$_Rr^!;_5UEOlfSnKsbM6f>WgU}$UelV|KU^8rc*65^!cwmAamY)
z6b7qjVhptx*JC&{wrI)<x~A*XPGJXNGFGIlc}j<E8>&sBY<h{aL{-kb4u(YHvhFl=
zh<@(db80>HbiT#pL5Gq(xLSK<JCxMqgyZ(2nkp*<sY-*K9(hdE(M2`eB^)XBf1oCJ
zTwn(dG><jSPneaXg0ReobS5CiYN5D6(#7WFnfNMN%7E(h?8Ps6y^<BE85bqMH0CD7
zvL!h%)6;uTy8c@%5NxS&o|wnN#AS~7OI@?Xs0HwI%0-M?B=;<w&GrZInGUaK-=Sg1
z2`N(_dqzpQ9#kKw;LtFN{I-Y1KZ_WQ?307J3Oa{&|58m!_UCfer7rtHE2BbX5B$?m
zJ$3!M99a#igpfQngCbO=HH^3=!`&V%;*MDsp{?yuh=})nSc=6(pHuC*DJjP+Jp-{|
zLS`oQ`5P&{8WRi62b9f6nG#XyjBWT>)xn?z;WPf0o*4zKXloJ-P~)Rww<Firp-`Ww
zfM8(Ns%{Bu2&qOt=7#P#GAgoy9m=rPlhI$A8camLa|d!tN=@DIH&mvugaKec2pGuT
zXy(tTk#lIW6}^wAg9&=%>};eSnH}?7%(i3-FlM7CKVU3(xto|V1ki%7zBU%k#GX|Q
zc)+sP+Yl1lXha1@v0!pWQQPx)JwLcqhF=`537oMj9`Q)`#9_*m%e`iL_PKxk7LzTz
zTq|L^D@~Gffs$MwY~6U_W!o-Xf9d*>^%?%l(8ew6H;>3))~&y2Xrugj{l*J}8+3~P
zMi&mtZlo`LGR@sG1`3)b+u}<t?bj($6cGgU+u9_hP#JR>?=vpZ`-txFMPL1}RnHm0
ze8sM3e%0|aGhNl^8P}T1s*=av=buQ>M<+eDX$YyhFW2Ce-{``@kgaHc`ViDM$s|v0
zl`Pbb@)$ibN};ixPBM^V4B8Koqgx_@<vEKJSRQ)S<1zNM)k{49Q#10~v3AoL?kxEm
zW2^9i$gxJfjQmD={r7!N_k{&B{L9Sz#B65q02pk`=@NbQgYR8CqE6U+yXM!BI;e0Y
z7rR=d|29SXDb>kTY{Z~eGto5*62vN`{GqNF{v9io<P3*R6o3gb5>OS&hb+XWz{*v$
zK#pJPef9|l0%yD39I{Uk3#%P0x<2kd`^7}s8m)?9N_i4GyklM>goQw=Pa2`}53xKd
zEp{L=p?GWAeH)fbr9+DoKg?G<+?EBj(1nGQ4smrju*if&-csD4g~=Pz0*;y^NbnzF
z?QD?LIw#<QDLR+z(#>3i-1cVDH*FXPqJjliaa=57Wn)Aw=z2X?F6Vk^mB6QSI2q@;
z)(^S$h7s&!csOW&(uO<qYGpq(!vE)JN%hoE3Qg`wG6xG|k5+&MHcOO_?Ssk*UoQq?
z7?#t~Sl*6LDC8y3DH$oDBBU6d@Ph-iU$xI39hsh;n&70){*}t8VaZHYmy4EAPv8Ag
zWnFKr1Vx1SxW|35EmFtFC32VOe?7JFK_!DLGbn{FM$(yl$sAL0+YL@xHyoTvee84i
z(cQ=D7(YjZ0OD<BEj}@a3z3}Ytb};(w}vXoSv_{&SYJjOEtSW(CV}5bo!^Dtf?k+;
z%UyJp@E(=iJh!3M@)t>IoTsE)+{qHLbh?_8nP~c+F%=|NqBf>g_DfGml3N~_xgV=R
z!=+#)oExjS?bgMt$6Nuj-kq7OxE}~YX~>v!r1lo`B*ZUmbVWySbl~`nrSJcanZ~PY
zro!)f2VBcrhaSQsxp_-}{~h8Ac<<_|<tv(&QRbLXu2v@Dd{>I&N!jt6*Qzg<P*CyD
zn3AF^sfWp<N0|iAVS4uL7hb8f8tTZYQaP{!)N};F=AsE>J&{_I<P(HijjoeFfds1C
zm+Y6DDS0xFzsoJ-G8&u?eFU{bTPPbwr`GGb1)O1T2s_6wPT2YD8A{k$y+1Wy4}cWG
z4av3JS8Hfkz}%oVn?oB&Bk4vei-Q2X^arojWg*ZfM9s}4+eo_4*)fm<QA+=Ga-0+i
z{2IsyN~sYd16i8zjUy2VM_EhcPWQQwTMjehPC5M}2Lg|FGfUZ?Z08kaJAqRA{-vw0
zA^MC831wFSgRf#yUB-B-f}#3rszygHbw=P&$R4f(-77`o((gV(M7+Q%MEPsf$wb@(
z1zpSefZZt_BE~x9B~vY;wx~HDD}rSoh_cAYu*P+ZXj{1=s50_{dHCY4)Q!Nnh(8h{
zVRW=HmG^UC`y*<K{=YHh3ff_9vygEbv=f7@oj#*+wiIMho>WTK=oGz#@*D=LRtp&W
zbn59NWL-n~m?|*w*Nz{<Rz+pfXDyT1fjOIOU06iawoveV(^qgH8*B8?Z)_y+U2TEX
z@N2KPl<?S5!z&U%#msqtID%*BwM7k>fHkCW>E1~NFZdM|CSh|0B-#}a{ywLo2tW0T
z9Y)7j#M6gI(D4O4VgV+w;Hp_1NiLf#HVMyBT;P>1x+sCNdFLk>j<$#F8=A6N)j0aL
zH=jFD@sK2^1y;QeS>QtYJ|?pyI6iJHlC?F*PapM><~+4b4mcPw=T<r;w=RA+W*9q$
z!;95Eu{CK-vZ!5!``Xijr-P|t2fmv@-a#WB{C>e5q#yi!w1cjt>pJd0=T@SiMa9DF
z=?6AjWbozEDvDje5ncc3iqz!dj7f#c)WR1Ba0<~6$~G*TfW>dfuR!Xqet1N!J|b^~
zc9;zHfgNa}T+y#iW2~Qgv$A;^+g_1cH<KDXtQw6H=yiiU5K?v!_Av;eRqL_!IwP}3
zN$6dq^vI$!!dEqn0>9|eeB{J5WU~_%C7K<SUj8@?QLB@ce1-Z^-(pEO2cfr~aQb7o
z>Zw2f^#ReqPQemph@>gPsk^p`3Qlv!TC>rvC2@INqYO^tz9F*g!lC9lHk8_<sRoBp
zV{9{{Uk+`DV>MDg3Fi!yq_^tn=Z4Khj<6X<Vx}-t!tg`?$qB=&xUL{d;eHiF?`_JU
z0h6Iwi+x4d9gZyu@eGi7l#JQG`v9d5tVy8Ul|z@VCoVHzY{I@E{e&%yD}~e!Pa;GP
z5P~`dn4ZL3J41Z+<#V}u`m~ocm9-z&WVH1$>o%mn_MM?BD}k&5w3as!%B|%=Q#H8P
zpQ7Ur1YbY$C{j&+T*Yqlm^2`CDGY7M!w;hL$@xHomb#r)G}aka&<I#PT=WfL&??%7
ze}8@1uX(^v|LNb@te-6GhVkCq<xWz|04~@XBAA0=;^imMpYmEes{D*CE-*evRmaJx
zm>(=d2n0DEymnxS7**^}2x>$60ogM>^pi#}>$B<h164Hw;Z1V<6RByalWZ5s`1fte
zsGewzjiqnB+gxTIWMwTI2!2TGa$l0{=Zq>)$>cE#=1QIU$)+?8QLifVhOPxgK0UHj
z1+5*`{*@~iibPQmv5J*(i@XR`CpYg+iwFZ1O`YT3kW@fDkP%Q?0Fgi0jC|qQ5w|4|
zZU3h>>wFshcK11HUfZvtNd&)RXGHV?d9@3KVM-S<<&z`RiqUI6;r^pa{(GbdB&u!H
zQmiB~v6dewn$M-qsWc<v7=~5(ed96n%ySnf0vz#iZJyb$%Ek-A3jOpL&4G5#PIcqj
zkFA|=cS0H%7okhz3I>H8@Q2dP7hYk}z4?|FC=mOx#C>B{(PgcK1|=!~aUeORV?I$U
zJ3ySTCXM^J0Cl+YGguIqU-d<tzV9m?0rRRaGGO*}01PmdH@?y=*oamzzY@AER>9<w
z1G}H#?6?(;1q<zE=^x($dr7^0W`B?nwsB1N{M(2Dqz*GgB~A|<GeF8(doPy2TkvE+
zT{aQJthJhnS^yZey|FZ<Q`I456d@h2I&cn$???$~6!?eAAo@#JN3-(4K)I2=Y%Ho4
zt%_+;TTWb1TvWsq<f7#m?G4$R`JEq9;b*fjgs!8&c>qP5%#ykQfRZyCsj*iMopu@M
zaXtxKSlgwMsy;Js?{IQh=EcJ|fd1w&l*ga)L6i&NgA4_KN+BFf3}6my1=vb2;1c9i
zJfP)M^#x)QO$@g^>BlPc8rxSaD@N66To1E~FMlD~TV3pa?s5-ZE@b8Ko<I*C9MEBI
zIbxl@OTAIdKv|rKwA<~t#!>RrPIOO4<;ID>pu~wiX{nby95VhWi&w24xJQ5)HLVl7
zqEq1_475fJidtBrTiEHVmU~NUqOIT`sbX!WI_am93_a%he3{^Kv)C9qfQvFtbPu+m
znfHcYbKFnFx>;^iA^wOZH_V}S6`AHm0VJ6%uy<B0syq_i6RbVJ>(D7ETXd(tHxI-w
z6~3(2R!?7jO;f6X&@mdP$W<7usL_<_7s)ybl`Gjz`4KXuEh4Ucz+r+i`<@Pm(n$v=
zo{|ubunw~%)Hl-a+lqK=RPoH)40Yv8Fm*wtdMC*N+=Pc7jEbI1gGCjwDNCMU-3hUR
z>&K2A6g4<`Q4gtbq#sARYP@`3+%#p@@Aci9m&3H1KfMp@*QJ+oRF<jgsw0YOiNm6w
z?Q~wB6uOH-a4|3?65vi;oB((9eUHb6ldLmMp$idG4t}JmZqrQax;N>v(ILj<$95&3
zY?I3wHmN@~#W8}`M}hd#FY$p3u%9Rv=8mL3a!{j3jqCd2O;f!ejMcbrYD!(O7IzGl
z7Cb#;Uw@*pd>+z+Jywygv^$P~nu7}Wv(sY)g*qGhnqZi2Bh{-_eIwb{G%En<mM=>l
z7{P*FHPX9Es%U!LMM_#7X@WsPqpBhocc02@qa!)4nOM)BdDeBhI^0TP;FuFIyq<HT
zk!er<ftfb8w`?qZ<k<EOmlW14RWE$AKuN6737b|NFW~T9d80!?l4E-*C{^A<I|9p#
zzgZu*Z^3}ZTyP=px^75{Eyqg+nlawnTf^C0vm2&)?C%t{N(>zkOdcq=m~2Ny<34()
zO6?@NU|x2r)D$HjVz1s0ju?aX<N2%%XmlJXK0z!|nDSqA8#kD{pPIzQww(z`s8JfF
zxM;+?&z5eZ_Z&}x1q6?O<PS_FrS)TZ2ZpsIXCJ(5>&6jY18JW*J#V}ds3h~ypKzdU
zI0)I0sMCscS)mRqw^9d9X;>INP?d*Nt4^#E?<3uUw~SaWisN$DPTxiiMd3aAT{>Gz
zx&E~>gmk0SRs7GRS73zR>Ake@)j#{Y(P?sJZ{kB*T=4v0CANj(2A;Q5mrjoJLFtL+
z&GxUA2lR#fNPk`{U#g~^cG0)xr^F!rYH~i04XWmz&B>^g)xZdX0XXPEq!W-~%hKGF
zTi`t}khQM}^enxJ@iB}+O0|u0z%tMan!y-X0D)^bPs5Ivuczdn*BTq7BP#^-nE^fh
z#Y(fg;PS=svlCvS4HElPEg6^8l3g%t&OJAvUEDSg2JBUc75nNu{^-_NA6LO)H0uTe
zdez6(z)AuR|EeK?pLFi$I%10?B2gh2P{E?N4h4&Z2y8^+hyfaVv&!8<3MB#GW+biA
zr`3!si*`x3OZQ;Kg3Qz<N$)Lif)jZ^f%ClQwLyd71$3GT@U}|O6SpH@>0I4QU%lX`
z|JL?I0OM{0N&}Rt!>1aG28z+kk7qVo?!2?n@tD_U*xg}sM=|QBjDb@XUBRD-ZA5E@
z)W)DrpGt3EeKip$`+I})>8@vk{$P!PO!02GD~&F=vumFIuUrH6jCi}ps68asfbst%
zd9##65T#mV>PwqTtj5wiZr4o?5!<+Ey!adacvE3+3M~0bm?7`@7Uoxs)wnC9`idnu
z@>hQ9bC@a*OmOu<Lv4*Y1F4^*5;K4cf8j^Og{4IiRvN=fp@Gqo7u7K}5h&?j_z@Qv
zpu`mEqXhc%=f^1KW$2g0yHp1q=_TnK&B(^1%;9KVC~#=Xl5=k+H6F7)Xh<o6Mhlbf
zT>u=k6rcb_hXMlB8C+iXV#;1>M8|^bcoBL&U2h`lnuPtR-n~P2chgFpkwcMs_oJK;
z3%6a>`Q#=o++j0<k*}jYafcL$A9rg0=Mf{6ZRTev`m~WAe}<&B##?rx^`Yib9~9AR
zDUr$}xfKJwV8O&YFxi^&oXGqE3zR!y4hMpcmq%csjEFr*W>R}Mm8^-t4t=}qWBZX1
zQ83Kmz2f-QpY6erYIPK$G|4~}BA^Pgq(LBRh8R7-79)(yj$na1gmurP-m{LQLtN|~
zgr8v*QGBuFmW}sy4@_)x{PUY70Uq<BXdbRMoc^zCB^FSBSsr7LK1zsDx=thA^$7$8
zC&4`DX6`~8;?Z#JT%%&8iQ~HXaMxddIe!;ad#6R=#*<u1Q!)w@^@wP)yvrV8g|}p~
zl!8a5d*GzSapO}rKOXHeS!-8Z9UdFUF#%^Bi%pg+%A<D8q&yWK7WI}ez=jQum;CQt
zyXsxP`&obAbp7Z%^W;JCcH_xqV^&425s<nnw@oKTr0;Kx#PkNL@j>lAb@@gg^XrYE
zwEwTYuYr%ND)Y`HlO}0FK*d!={WY{SDVfkDP3Z@8Nz<lOo3^%TyV_!VGjo$%GBbBN
z_fC_D;P)pqZ*DJ)k-7rA*rjYlmu1yOM8Q?;f&${It4<JDMZ{It`trgm@Sf*6ANSmk
znM{(Fw#oSWVVax!anAod=Q+>!L$y}&O@*xb%CFH*zyV2*Y#3-FqODfIGRaHokddym
z=FIuTleDLt6(0B+jgn#Z0GeLxb?earLe`v{au~F%$H|t(pcOJ4lm^awKZK3IZWYn0
ze9|;rm8Q9jJ7DgC`e%eG^T2cLYmh`9hz;i%{~2Ywn|(~;L4<afzX#GK|II>{&f@3c
zNoohl!@CHhd-!~jvIzH$=DQ1dK0+QfF@hB9OW!2-WtJZT2U%*AMPe{r6$1z5?u3}b
zNBcK74j*|fr>ACzp29os<fMe=K|x9R!NZJ7y49a#DC%je@@+pBb`)F2m!%?+?*Urb
z@YVr<T4JTVHXXE-4_|XNOKVQryiu=-g>cgBn5IdOv<x70U7GXMSv)I%8O>;kU+1%|
z!3Rr$;(4WF<gN-x(guQ=t4T9Gw1?k7!xR9(7HLC1y))=lVvC8!ifW87H<Uo~Vhgss
zKT3UKc|<Flh^kPQ82+GXYQVXx^s25tdEfFVv49Z)E5hi=L*e^Ox(m@(lf&2GUq*RB
zId&+r&$6R2TXDq$u-`^p`;D-d`~HEx$*TC}QFsH^i*nLnw1lT9x4?$XcGoqEXzcD9
zIN$GjHhkzZXBXI5#cs$6wD2@{A{6wKG&|Ylc9T*aE5e|9!4683y+-@wln1`?$)Fmo
z>K$i+fj1le{y-i~Ifahbi71GAYPCZ{4HTeJf*BF}P+fgC94gPz<O<=JNa{3ETWk`D
zGt<EOr1pRb=D)wRoyC~v85evn<5*}7J}<o|8y^3qy!T`=3r+BBDJ!r3Enmt8t1=R%
z20gJK6Da8_5VVKu3+dS$MX<|DI6`Bzd;W19Bi)KiA7NqE6F`cxIo;*#)TfLd$;Dss
znOA!zAC=4VLqeG$71?5w)Tl?{jHG7tNvB`}-0J18ol4M-ICNc6rL<2g4J*}>`|-fr
z<0@RowVQ1Cg1>@c@`H^)OHgr=qD0v)!tl2J4`+BRFTsg#@AKBakLjYtyfA688d_(5
z2Q%s^FCAgEL8)gC`9-`}Cqi9cg4T%2&$FOQ?Hw<5Idv%chYZ%unkeo}@RZ1Hdfl^}
z_js+>Dh7r5JKK4?^Uy{WjgM+lcXOxJP9EaKX7G7|AWJiF-Uhj4w9~4M?7YhJt|)lA
zVBh-jI#=-;!A;bpT<MeJ$zCo-DhtaE_Bbz|C4bW?=tfQ(C#?47<~f&eO%Ds~w~I#t
zf?H8Cb?oLemq!v$oYoD%0Tef*k)%h*+YV>1=%+Hpln3^0zbh3e0>vA5&;TeJdrW;#
zOb^(P<=?xj$o&|;@m5Tn^+>W=BFSPvhJ2Ci1*_uSAIcd-m@(iRJk=kv{<$nJZxTAJ
zHmm&UUkj4TmjBnA2()|0|2ntGrey~ZZm){!5?{lA`=-6)U2SW`BhcP~m6UaT(NUik
z6sJB#ej$vRlc|&q^V&PU7~BSZSvn+^jVf#0!BRDu&e8V0<MYL2M2-y#2l5MqNH6?w
zvfPcN%M)<H7p0@ZM$}0iERqUs?Z&)Jj+zFXk{b?W?2a_PRC!WPkIF<_k<>c3IWg(e
zL!^t6t^S)o3s2wiI6a)I22O539^t#b@z9)qxe#@h_G>vKq#b61PnglJJ|=4N8OZAK
z9s(;e1zzxlx?PjDlvifQ<O~exPE>^AIyLTvZLBG&`XUb;f^`!J^EdhFLlDSD(6}nQ
z|4@iE9Gd&O_ij_AhElY+Opqx-LNs8_CWI6jJ?C6g#3?vMY#I=;Q2FqkYq+p%d-PLT
zMwa8~S?I$bmeXoIOr~XgAwColIuiR7+ntSvDz~lP24xDq_pvEp?gQJBz!u4b)cE8<
zeQ_bw<)UzT#Vgu#+r;z(UOCH&PC~<=-M*zmlC>Z>$=S%>Ku#lD*_!dxcaxPVGApU~
zi4ZEJ1p$$a)t9hpuA8@^$I+wMr;<d4-18lmwIw|KmH^d_N?V{0*Zif6tFM$1pq@$H
zmb?NYvq)&NYz;b)shJrXi?-(*(%=q-zq6$apND8VAQrkZY0&GanK1tr9qnQ!5Io*Q
z1{aILU?C;$uo0I?OXRx?j*QX37e1i?{sk*!ReazxL=erE|L8_35CTrq(ScD&1nmWD
zRoOyWAyiyz1{TNBQ30SZPGCJ=RtbcTAI&HG4jU@;E~ZP&!bcnyyvnNh@G9Dp67_c$
z3xKbNO+g0pzGfJV(C}qlbX26AF-`RQw@nB@xc0tWn)enNyvK{^sH7sG86!<~O27Ip
zY*fW0W3uyWQo2q+SygEtvN!`%%Ef52D$Z<{w1qSO#--Z$&rnYF^qII#V^P9){O2a!
zWDZ^DW}#qa!{@(yjbeyhYnl)ds?Ae*9R{=^VH0~^SdVf}vyWEW!xuBHAI(iHZUmC=
z0c@UQj!~Wc==QzjC>CIHGX}*;fvh=L2_%WbqCswSbhH?rjU5xQL^rKchx|IN@$8-`
zx+4RX7+GRoSe(SX>TT0;I22b1T_P>+={Z5PCH3*M!gKaIugr$$3`$Bg`HznT%;_(`
zp5|(Y+Xr)G{{vkR#%M?`Ies^&iBUC1E2i@kE*oC>8Zh+1sz@>Eb{#Ljuy_30+@gA-
zlfUaf+E`BzB`%BWj)D&-!rHGg%UAe;b8`-}kwxFbJ%a1lE{+3JbD6*BaZR}Hs{7x~
zwdxkXR=oqXYMvT7JbYyF<tDd@<W7oFge>3%x4KS_Z1{o)reP1+{s+c9g_@QTO%xpS
zgj>+hGE;bv!9y4r()sO2?OV1KgBHtR^cPc^cuz=h{lhn14YRZ1+snbx3<?m9|3^QV
ztE+e#d;yXJqw1-D>IyWE+mb{_56*^c_|c^_OPiM2%7$<FJZ5K;*WCUYo{Rq2=jB}V
z|A%D&S$QPx<8UQJVs$$V#u;FS=wYXL8pIYVAf;q0R)ip&n^suZAA;9HHLD(9Tq2f;
zGHh8yKr#UL#-^vhE5)7&=s(OioSv=tm&e3Y|2l>yFu!~(H`4Y+o)<K?@kOMS%Y?T|
zaz@!sQoGv)<y0VMvLH>GrDZD(wLk;s_M%8LSQfDNW%Qs1*8x<yaG9%lIN_B$v9gO>
zyT?((OTh=qHyG^+EQPU0Y$G+QMzu4db`Lo`C94!Qp|0NT5G+~OAQ^(i?xRPG?>eLo
zCtSvMrwxnh%&>%lPvBVhI8mF~@Kg8aSQ!EZpOP{NVtgo#R`tQ(dv=&46@u_Q?+MyJ
zk8ZL<6^kEy66gTJIs&9b(;iCQNIsdv0<(w6(@)~a0&Y#&Vi7<rzGD{zfUq5O#S>7&
z9bz|lSca*OcH8PGzAPpQ$%iUm|L2JYgcaQ@?<$9PQs?yO__ht3)^A+5r?aiA{R$`(
znYu;8V3D*sO77B=@geemsvIr?AF=!JRv`wBcW&R<#a=?@@Wm#`OUhQ9r?>(c=!VAf
zr%?^-7Sb}atTdEUM-}P|>6loA^W-aWqm<}oRUi9joOVS;eq<@zg)kYb^5F)UwlXSR
z1TYos>q#v*5YmG08g<gpM7#}WIwI7Cwg{#ZmE%vK#1HCdDlIaG4bxFS_hlR&=gl8e
zi{Jjse&{)rmc5v7`}1Ib*N!(31KjfLqpnzYsRASs!>+xZZ+YD0Xm50HezE6?n05D8
z4Ui@PKzF=*Oh-DQ`c)6sLv&6*$;L>OmVYvN6%wTvL`IX<=w`YK84k^9gAMmQt$Qbj
zyRcnuRWz&;FQQC{%l+Kn{gH=+znj93F6-+)jE8GJ!bGHUc%NgtfDiehWJXpst|c^6
zwj(e^vlV}pmE_q)xka#@_Kw%0U>m-(9ojkM9S4Qis`$k>98Ye=(hC_xxMG+<Kw-xa
zs>CR5zZ?@bD|*z)I?jc~={Ozl6kdVJHY}K;OOTet@Ogi{jS48+@kxCtw;oe=spkYO
z+veFqIu|-{2}P!thwmxQ>FH8aT<r(SpM4Y|>CVhkF=R*3+F73v1zO>YAfB;&GeJ%X
z74sl8gGRRUpih=sBo*hNKJjygA$*5W&)DS!q)wYf7ak(_J3VlThHCHQl4!-nTY-II
z+z5+7q+#5&5H$*|ke4$^_CmN~3u;h*_!?db%rs%UmnKkE-b-V@oC<30Q$>+>5l<EZ
zK{XqWw!5Qv)bySK0^pu*0ztndI}oY2Pbv||zk|1NKZ+q41ITAF(b&;Hjzr%6wmkG&
zjGr<<zaZ+PUq{mjC*$%;ZhI;le&z;L$Y@JPG@9ZqvJlGa&5hFf36PZy)SNU}g+JjH
zi^vuejC$c7#~w6G{9r54HzCB_Mp_9`G5VbVY9j6#eXOTF)?G%9!sC#@?}MQt7)(>C
z+#-bt`26D<DveD`mgGM^C#qc5tr-5^ZUZ;{?YQo5zl_TqnBhsO!-*0gyYnFhU+tKm
z-HBSj0BEESL6*{wt3nu!6c+u<1qJa+ld?55e9kunLWd+xhH6WrlB(q0KL&4t#wghN
zXpn)9U=5bA23u=Xp(skNz1!TK++DkS_oBU*FIau)WvkwI;nj7ux#PSV{HzM9W#k4P
z9al79k7_7^bA_mSYDQG(jOpyBK5DTzCxDK^8+xWsL4h8iVNo=TC%6N2oRE0GmO%9w
zmnoP-PGj-&!Z=9+sI1!QLrYqEH|yq_EIMJ*tPqWJq|}ssvE929Fm)G_46_w~`VI3e
zPz#<0{EWYd9AMR-!t#1Fu?*wM#8>hjHe9ul^wmdLPX@FBVYM5^!fAlDLpekRd(-DL
zyv2(;L<=GaUDp|j&}HTN=96Es0w#yz){DqYA0MRwz90WVFp2Y>%B4>sTvKsJ^uu&G
zBzLR`t1q8F?Zz9d?b97#OA!K~eSn3FW(7N<?4sgC*=?=UG1mvRvY7n(7+8-cswuu&
zmZ`LQ#-J+YnbZCM$i4#1253;?momp9XZ?TP4dvfm;t>R%VuM&}vOi;APIALQpTzg8
z&|4JB{l|oJEGPpc{3yqa_8FBe2YqTh<%rTe4+Or@k1bVy|D@#mr2=tGCz8cIn_2n_
zt(pNf<*jh}<<!-qqGIK>H9`@S+T4Qi%WH`osN4Q-Rh+J{HfSFN0Ljl&+a}RsP3p}U
zKC*CU?)b`r3avooZ>}NlKDiD>HvGx=h}!QG_KqPM1vqYZ=H+muj9gwsl*KhXaK6M{
zWFpE|)U9>b|Kv+9DoIM;XSq-R`~%OXR9NvnpCDhi7eqnOa4R?8wM}JZvmgE&PA2dn
ztn~zTUq_d&+dIB{2~mt;L-3YD&^3v+NWfSqG(e^>X#$vU#uRn@+-;kz%HKahjhmr+
zopXjl09laO3^~6?&~~TPsrGJ2&f*HSnncMv8$R<oo^xiXDTR7gocYw+F3rzlla(wq
z@~ZJ~4B;833<8kOtxDmz+rnWt7>icCt0b18gB8JJtS*!2CPz~|Am@^|J9Qr6x}f7D
zA*^<-Lpn`UoJ5{OuD~p4>I|R4CN}tNc<mT-Xfb~Yt0Hdjt;7vhJhp?Mbkf1k1_K!^
zU%j)-*=d?_sN&1!lS+JmsNm4b*$US`pM%ei>d8?!57R8;wc?&ZNaQ0FN^QCL2{dm4
zk&aRkVN{XryY%r<SC$3n&VoPBS$#RweR=cGX~+fIH?h<`_jL*hl5mI>D{0oRo*rT*
zxISJ8h`fPp@HntwnNK*j0THDi-utgoF;On<dyjR4l{<zeXxvv!o1)1^D|)DL=M@}n
zmbW75@g<!+Hraf1Q}NWNr$#qSLZSt^VtNM7Fuca8rVhe64&9NTO-SY<%EvS#QO|2g
z`{1UXGN?a3DV**uNg^9w{TXIz32@LD;Qc+E;eF(QoFUJe5c6Gc&dH%Vz^FMvhhv|o
z*?U4hPeK-4ven0cor*9H|D|sVa8ncZ@lb7-WPt^dkoGlV-@)3(Sg@RReR74u%Eolj
zG~G9Eh%9s`icNvbCi}E*e_w2$29M12V@jY8RqEGy{de7lc=r17OLOSpc)Y30EvC6F
zl#V$`m<{ORjz}3i5sNA=auFJ+4%ZW*cNYMn7@KbJsRLQ$1p+{e%=~z*NR&7f-uxG`
z5oo>9hEc~7+AYeVc~lZ80vzn=WFLV>Ok@GhIfzX_vgN<Mk~^rme;MeI^GtNWu<~Xi
zZxUAM=ATk4C=;wjD4G-aCuuWv#c4C|DdXDA(#iCyLG_D8X=cOqUm*-j%E9b?%n6ue
z#a!*WaTX4;Ysr<ldTxP8D1%x;iA(x3O<H&K7jVcw{bRt(@x>F7EPJs#i5Ud5v>Jgi
z@k&En<8fqM@X_zf052x1ajXUO8qE1)%S6X|6YKWM3gSCeBACbD6^NErF<oX6AUI{Z
z7RP4sqDUXKn9}=QL|pOS+Z`gV_;9bAh(WNT6*yyXCsx|INowTfoZYEWJ<Y>B#d!<#
z5D~Toa2;GJBAP)W`*z0fT0_uiwk-zs@s=uerl>cE;Zbg}p`NUh6S!RdU`h)ABp<S`
z+u-hP$PGTMhJ!IgB>+8+Hd<&r1o2n_N*g&bM2sP%Ji!{$;H;%s91QAOZ0jRf*p8*h
zmWqV|fr_N3@B?q8T1*1t!CZC!64(e*5i#Kzrv??-ZC3dHN5pPpMIfl&QN83(GN=R;
z43Z-9JvbD<^c5^Za_3>RKhYRQ-aV8+j)f4&6!(s^QV7Py?BT{}ZV>_U`Onef3;0LZ
zh@prbB#g&Uo{%E=Sl39VVjyr0w2Ye?!{A7}hX}Npw90Dq6P*PuR`diVU&BSFrYVP0
z)fdO9uKNBo>@G{aog1X`U;-9960zHCGLIn_9AIMXla>*fv_8P1*U(K%>n$}d+6K&%
zywSUyjn=&PcOlyHd(mEtwGp5M3GB}S^l(ut8hIOGedJ|iXj&=*RS#?!sc7`ArJ-z+
zN{f}z%1&fX7ih_7JQGu)qRyp;8PoK}zSV3yx&Jm~T+E7S=lwf;ufU%nLbAZ0)pR<E
zUq9^sJNH0d%>R++J>ot_JkIN&4L};}i(z5O#l5OI5VPw<4I%H}2We(7-a+5Mic<AS
zO}!<h9Sviw^a6w<(9?=7h2~V8q6Ok;y|=_3Jag*m8(@>{*{?xIF!oEDiU<5xz)t*<
za*bSi9qYo#??aOq|0Nm||0HLc>6=)aO}o#6FOHHhk>aTkFSnr8ld`pkS;v^$n9(6Q
zTUpI5LYt5z$g8Nq@k~f4reb+4`Z=2yxkDQ!xx5(Wy~@6LvArF<gxGKkrBlR%R|4e1
zxl>U}oSg6u_&dI%!{>3=`RZJycT10p&&PE7<XSxn$B3zjSXEb;BJNSKq}KrTwQuh1
zY}>S!!^(bTYlCR*y3)Q(O!#W}OKmh(%h#vDu5It*b?ux(ZtaGxwe~d)uBYfivnS~<
z<Z0Rp%7z9cz9)bdY8|qGyV1=%#0;o}{(aB<wfli>Lqt0mN+1?{;o2hK6F|@GA^0bG
z2s|;25s}j+XfAQX{e<f?aLxZ2vH@zvRv?dTNn;f<AtspifS&G0ZI{F7dk1WST4z6y
zx4aX!1yzzeD3A9&M0aJayhX`_Tj^c}++pc9t=qY&t<%2*u!n1%?JUNvXJ|M)bViLr
z6|mqH1olwta0>GH4qzB`H<Gg<Neux(&(=|%h8ao?wn!3pu1J5kui-T9<_{fudH}M0
zV`?<6uzv9pQxp3Kgtio6AjpR}kCOJn;vOv-+rxzdxWzfz7Z-Q5>w`iGnM_9p=?v#w
zTzJPB2g9UYQ|Tv~6s-iF?%hum5O;x3Ojd%Kz(dHbob!~v9xUp%Y^)?-=#A^$M04R5
z93BJ#v1>_{k)1pg_kjW5gB$sph%s=LF_R*|V_iH$sw)Z?3~xD6@obvcH%!wqeB#U_
zuYzVa<W=@Xc9STVNiIiIL$r`+gKg9Y6y-}xMfnah<G6-AxsG5NZ9qgl1B5@UVwc3&
z7Q>A}BS#vdu|kUtJ^{WGbRKNg_#d4PGJ8ZM6AY*x`TQEFE(#@moZuX%=qFvyjk=z~
zVu0uZfcDgbYBYlaY#hV3GD%a5JBteZ#E{MwUOv)ZMHl-rsQYPqi$?NsUFOuhtg8h^
z)Tty_+O_q(u&UOBNY95mcu_~RR`MI@ptlkMbU*msoM97bREyI<eX>2N14XE-aUM*v
z<@1}#_DD9cx{@NhT}d);2)OeaKvQEiQ@z4Edx=6Td{V5SzA8rqYJ&0-tq!li>3HV2
z*x(aHkaomggs$`KTa4IOvA?kI?4j*ioj;L>uVHTm^&9`hzI7|BYUwbbi;81F1KXyf
zTlgx9Lt$2RP%}kYOTlWc@p6`R3{8=nM%T^7D}+Sr0YngtywBj`MD>O>zR?*Q#|PQ>
zS9zHVgfOgfZJ!Oa2%F1G2zN<4L=)9;>F<Ol;&hY3_;zVm+816ZQ!T$-&o_~F(M94}
zh`z<w;U2mOhJQH!Tjx*sT3-LxlAh!@&|fdQh*eQtw0p@S{s5aQ{e%0^gCW*?UOb=u
z)yo!oXv<kvnwE&vg!R@gG*;T1blb?Fm`>jc@)Bbgjk}XXQea=9uaS6kq)DQEd7;*;
zBH`9#l{ewd4PfXeyI)!_2gxGQ%fBe})9u{C86eryq2t%;7T2*sMOMR|_4N!)-?1Y&
zcfXxU*&vVEtj`xe_Z4S;POcGzH|nTqQ_e<%2tcXfsh~vc-zo;A*eEjbM+i>%CCx}K
zGNnC=p(V~9mA4W1p-J?Ci-e{v?`EaK2H&g>+iEC|ZC(9CAvaCBaC87q5apre^2p?1
z6WWe;Wg}JQutc(`GA*h}r=tm?pHd;(`%pcelJ$P-y->PS>>-&%7`jZH%|jU5;N%HB
z2WgROJmqO{!?v!i8#b+%7T%!|MjPbcXnJ9Hx`kqSm7Vj>VhE69!nexwav`Qn#dU*7
zK&H1uwP9bz?53++43iwCt8Bw5Rqb$}EInx*yxoPs4FNJM)@+d7D+!1Zr(C<k6`)GE
z;pN$jO~Dz=NQ6JM_@awUKl5}3U<5DV;%WZRS)_{>9}Hcs{ZRVd>K*#ih9oPGie=4p
zr+TTBguCm1Zz=GW<26c0;Ll3u?jFZe>8M%arp3%iDJ3xaEm<mKxw3@9O_1DV$%SGh
z|DCEmpwOcMe5KN#*+!t&7ni|TWNR`HPLBp|9^lz>%s$kt2E~{AM7c?mQfE>(T@sE@
zoJT^f_iPwu)&e^zD9ABv(oHn5l#({2_|9uDZp0Qg=_r2PU89_TV2`6*aFM)LR$L>+
zG2jneHyydrS1TC!vS%$FS0k^Nk1IxwqO=n2r|3)CES;rDu?i~n#wxT+dC`Qk`pL`L
zr5=g3jlSGf$y*o^9kWH(y1(f{BHPy0wzUiS?>fT7yQyEek5d?MK{_V#j3*PB6_j8`
zOZdP5tMcojV)zpCwSv){HV6p3bEhgr8A7ld2KLIMc8@?D2e=EMb;y9TW1wOh6fkFn
zuNW1|#|n2E4skCeq!II-h5H(X4NWRigJOmwnaM|vBUyNtigIYI#31!L@SZ|&1J}x#
ziP^b3uSsDs8#m|U>{mua^xUEcvqwi@T!JzN5no6TV<{4wMSf{42#~QFHcWa7yOwaX
zNW#`c7`r0?0ydltG0P!)m9QH&;<SXG;%T2D4oufP{WT42hPRJ-*ZU8=I`&K+$z^?T
zAqCEKop1Bq)U}Ri>?XL1pe+3W&w_F}jp&3>1~LezAm3jlYS|O|Vuf|;Am78Luf)l-
z)fnKrQ?&YE%O`h)&<wMHWaI<JO{At@7WUAmMQ369lv%W_M!DDu!`OpqWY8=q>C;}R
zgdIegv>Bv2;A1Kcw$w(M0PJ}0m}kmhqcoKLtj7ofq9%I@n`f+#78LI3(W07~j1Ezi
zM7)=Kf^p#NZTp#Hn#m_iWNn&hln!t%GZRNZ*16#iYEoEbP`Cqx^Jt0^$HESAG#?bb
zMxuflXJJy$IAOA2wBQ_|jl~_HA3H;6Fq5hl2`8l^o#JROb5sro5~h1Nx{4n)&}r!r
z=QMgDh$SUmhLSD8P*P%`^NO>@skxRad3hivbeGhb3`LQQvF*k*RbZldv}DPgpNESa
z55Y8_;Cry_Bg;FOl!SgUhV#L)L(6{mstL@Fo=0P#Aqol;3u(vFx_W7!I{9@QH*D)_
zuy<@&x05zLSqJ*O+XP@pM*`|}oWCII<n`pfT}?}xmtN_Xw>R=Ct8nUo<^*etQm~Tl
zm02Tmg;~sK?&EyqnwQD(9nWtk)I|Qt1lC&4&<xp>gyU?mYvYC;>1dDl+6%!C2QOIV
zrzj2@eadfb;ZCW^jTv7(e?Q@Hu|2}>RL31%@EX59+Ej2dSUGLF6QO>+$xOx6^*u50
z+@|%6fe&&|VUUlc$>sC9xH!&tpmRE^gSYAzy22z;o%<x6NmC9u!Mv#pp9v7)=1unK
z9>aovd6^qDczF?=!yZ|SJVowqurI_9AXAMrdC#?!nojF!F@XTPr{C-;kx=b6#{-L=
z=Y__im1st#Z}UH}(7-bA3(*AMzmUZ+X?Uf3$W#}i$D1DWjr>gw%v*soX(VS#5+3GP
z>)e-d|FV8qwYBz2yOvP4_XP$KJN(bX)u6`(J<2oLkkn&@^+C@r7J#6bE9o|hVuAj;
z3&o4^LVe(CtlDe-f-hllT=`$36nM!SUcMb)f=$_=uyFp@B;2pb(;Lj$*fdaLnj4#i
zUgX=@L5Hp5=EsN}Ag{Kq>(S<cbq1Y+(;}>fD0$=-M@>!YxXozEbJKHLz*{FXtGxal
zrsv^$5adxf^mo9^Z{oc*s0-eF7=r!2_u0bYi<>!*!Pjy4IV^HXaV+xSdLbN6rf3Lk
zoN@QY-fiwS7aDZaddKO$64Rr?Uq{}<kYmm$bUkv8BQ;Z`XEnRm$H%0RY|<TyKp7C(
z5(+L`SZfcHRe<&IDsUVXyJV7kRi;<MybNuSJQvR-oKO#P6I)k7C70RD@IA_Zb>e#x
z(OcQyWDSE~rL(Uk!=<~0JcYZ3qbDsw0Q$n+8-TRSbu6Px{u=mcsik2--oac{A~wq%
z|4jC&XFo<`Q;>tAedLw6H>P^PHF=LW79d4u9muir&DG&p1%s+Q^XA{8i5I@P)64l{
zI><|@)J)?#oZa74-0uJMRnrlWym{8BF*0)w3l${;6kA;qPh4i8piR6EmJMEl0V4z>
zIL>gl(l-`ZM!_@W_qDUta3~OD4$m81%e*9bk-K=j$^bO7Vfk|+1kM$U1RUq>kjDTi
zeQP&wS|_5LJR|@wm<;hlJPbv-X%gfqEYZ~DV5(5wd`Qnw6EOTEs(@)UMoZmDWAq>B
zv<kCttn{*XxIGddVa|B?%kBk#4=#BGRo89t0X*IlES?j*a@`qjTE>ot8V)uMDNlIV
zuy?T`1<#$CUYwRxTvD(V8)a?Bg%4kEZ`-(W-PQ&hI>pjpS|(A@AYJ4sWQc~L^s2HS
z+_Sb$SczMn&pHs&(?`NF>)=TCbO8;J$p<JX6dnH1#%IZMbl7n%VdobAm-xj0JffS!
zdYX%4J%{=@>uD`2DN4M*rMUOs{Ip<gdNQh}u>Z^kFh(5=edH%!ZS^KA9C+5buM_Vh
ze=qy-?z#g9Zh0j}Ui4f?`|xdNlYblw>33iEU|9|M3j7z2Ceka$co;&(xm_$z!wNlC
zcfcz9_V#17H|*OrD(<h0CXD!s?==o*!{?{)hQ?vL^b>ztHRVr@H4h&-5Ag;Y(ilTC
zOMsQ5w+t)viCy^A>_XD2zUK`Dp~D284FHe37ayQ>Mx2P-!pR%D?(rFnl2!fn;jz}?
zn_oldMN5v{w}NH+KvzNn1xH~-sh`0hOd7PRga0+wge3G1AfbLO9!IpuHXBjvN=Utm
zE0KMAtYvtZoiGQ>{`7Zez-qwhK^6pDA|oBwmKNj$06(~#0Ds#8j{0*Qn}&~^&3_w9
z>Zao3B37vSE2Xu_k7@PFedJ`il>@q!a2Sdv2N2N|T`ofPH<i!~Kylahv8ELcjPDXK
z4w3UsN%l+3!3xcLyoBL#!2GfUz=kCyW@&Ls#x3nai76_nO1!_dxc86U&fnj0$munM
z<v@rWyhBtcWqM89H@3EV6D1Bj+i~b+WxexgXTYOm=4bwF$AJSkH!Qe=hy`^_(Ru3=
zw{0qu6&KT7akP%8mLuCgR-(I;N3T^MZyRfA8a{G<`@>|l+6c2as&wmV6Zk@1d!)DC
z3Z3=S(gIC`A++5%)^y46ZJ<{i1<zc{jL?c41mI2T0FA1nR;Bup!E;YxtgWgekB&7p
zBaOsUeM+}#YEi4~`i-aXm`|6VR@Hq~un|F(S~Gkz@XVv#O0*wxej~I!A8yF*daLZn
zduJiwR@Kj18Sx2Rs4v)oXKSWg&zOW|-Q92sB4kzn@|m%wrLGx(isrC`_Q;?u=J4#I
zQ(z8O&3R9aHMRQ33{jYfd1qwpx{ZV=tuLGc!<{@)eXGwqJ!xj8%|>uhd$lAq;ECux
z5uW->;koqmUiKE>^iVaY8&M%U@S2{}aBlgz&ll&@CG8$*dr&1?*f5C}I22b$-g@H<
zn&+wd)2iCCd8`%B_jY!^gRd+SR}3@K-yMr2lqeJ#WygR@=<nQBr_s7t)g8}+pnEIK
zE2Wtjk1sRRX#L0;U8m86roPat&tk{CXdVzTR3#nlW4z@`vbGPsI0K=us$aUB(|~8{
z5q`chY5){QhJJApK(MO*@z7Y)avWrwj4fhB)2f<eYZE7D+6!mSz_lrU4eP&4&k696
zs^|%e;E_QNN-Ol}muE3Hlg6^9eBT&KmpoYssjRDQP5sD%`6VEW*sI%rKGw8sST1WB
z!A4sVY@20;9-K3aV6>`VxPNS!L{GHTthL~iWo6N&W##|zz_3-(^DExSx$Kd(vj`kN
zSY@w_wNTng-gw`N{kEDmBMH@1Mruor(BrW;yH;>wObtc+`tz)k_gV!IJ+x4tjKjO1
znFTmFcwGN?G9I*KKtwSjJUXOqX3M`+$y>{mJg<$iJrX0+@3>_KPJi-n4enx^5<{s^
zPiyam3KH=M7Oi2_ayna?a3jRDUd@b%pk1m0EorbjBTWr<V`C%vM}$n%9y|%tw5q<{
zLS-yE%maRbA~o{5g{R>HoNhm@s<pouYiTaD68oWfk5%@}Ii=;82HSb#!vOOzjZwge
zn4?gnvlNPOa;cw&BA}-n7X|u@x!W9*gY$;c5(QB7;ARxX87=FPOe&?Op#)N7znV5!
zI5#<S6gYFb;s3rjc(mbweXOeW#n08saXATX#a%12p-<hh(q1`iopsf1M~S$yt#b;f
zTh$+}qSin@tbrsBNiqt@XSauKsRK?Xk&1|Z23$%miHX~}n7G^x6?#h;P9<AfaTEu(
zG!KlticyK;f++6D`O7Zj!L#eAK1btcStd~=p^vmZ7*j_UmXbn_2Z8Q*+BwD4B%b~K
zBloRPhf+$+3jI$hpJWQ4*3?R%9#xaE0B3VOIfchFvjAPI`s^iC*LC3Vg|)1nl?J;O
zFDOzlj9NMvIQ_uE(Ck1p7{#g-5iCd@fx74kCEYJJ7Wt1rw=r}QptGv4xmS|DX}i6M
zsl{We6-u5_TFm2s@Xg;Lto1OL5IQ6Y;V7@9e86qP$yW6IDzEQOR1_V_yx}xhAFJx{
zW7NUMrpz24lBv6=6ivaSDcl&bpcwh!X^$B7R(bh1PGPjHnx*fRPYR!_tFyG?z7<ca
zK};Z%jOpI(k5wnjZu`<KMz46@^P~Q;<`oX}y+UTbY+D6}o}J#_Bxmn==E$}ppW-hr
zKMkkoY@u`hEKQX;1tAa({DMSriN}TJy>d3kE?ZUc&9VftLAFs~R|OjH5-ug1p9t`m
z?HhBf+gj3q_#zrKX|mJsf?26bE)M{ONxTLFW-(EV8Xunl$XL~ThryyC_TW3@JxHxr
z2_<Ef9VuC_UQIgusciKUS$0g&?kCju^mj_@;m57!+z-lLDFluNaFtvwlOaEFwY0in
z9O%>IszZe(Jqh%rR#&NvWyO`U_(HWPl~HUTz4twQAuCC7)SJE<D=~vY%%FAnwm099
zIq+P^Mq1VAXj~tlp#=v50>w(9Nz>dEG&Jc}f_Ep8DaOE>%yb>?3^f*E^$N=`D1j`2
z){-NFI9BchbtiJB(rbnOk5Yo@1VVoQn^E_HVrPdB9EB!C9%E**bily@*TO2lK)qls
z8BMF89V+oi0Yh*n!48VyzOMStSq$IF{%KX+vyasX@UC52g`he$c<oZ9wL9rQ<+aNs
z)U+10LW7m11vznmS0DK%#_m#4aWjZ6ddB1iNGsG?D$sa5P=0?GJ9W3fshh$cB(4By
zZeRQB)7#CljGdaPwA!N$QW}DZt=raK3Ps_>0HG*YYk{D&U(+*&M*>UD>@>S(&TZZa
zdtqNjH;H~k4bCk7W?zHd9@$@Sm6!c#2B2WoG=GuW=4e6OqiHn)<!~cVw><*!CQ{f@
z`gAQHL-)N?C%Ha-8cpJK`Ds<}iqOiy1nF2>8HlhJL$Y~tX7di5dR{ReH_+)4i$f<O
ztz9Q>|I#VB-E~T);|Kg<I7%$$xoXGMo=nmTwf(3B-xT0Btg+_S$-oVPP*!L}E1^9N
z)E`&?!BBZoH%&E>BI1!3`-vk_t%_^HCvj!0s?YR~wdCKv-HM?_y<<mF&^J|HkBn$Y
zH#~M46Ps1_Ps_(zmQM~6aCdpHbrT`0zW_|(Z+++#g2}3W;@N`JhVo=Vyv2L1H?3z<
zR_O8B=pL|YD$gHlE&!sI^pQ!wI#goM$ALXBn=I<yOMddkxT3GWzO*!iDgN$}i6GXJ
zy#Xi#h86Gp&k}|N!{p^-%}d>7F#^$qy0s8f?S->XNyg%8+E2KKNuIDmiIb5BHT7Nl
zxqHDC@06oBE?}h9guY+3LSH)_>sVOT|Gjyv#fd?m6d+*J@m|AJq0q9^$xt<Q?0TQ4
zp&f;=BY60>kKw&SZJpk$DJxtRodrPpfxY10sg6(xSg7>tMU1uG9jW@%EQD?1<6y<Q
zv6dzIVYQr8M#9g=W>T&E<4>aF^T%3Rv1y%@Fd0m#3{oE(ND{3qsl=_apY5MTP+Qe!
zHWBEG!_2qCCo%<u`@Vh(Vrf->bOF_Mr!wcM==v3(T=pvBU{!toZ;PE@fNe@irBuJh
zBxYlU&s%&7Evi+$%o=N1G1bYcNi*$J1s&^LGI0t_)vEf`4+VRh=pfEJQ!MN4<9b--
zd!|_I3gVLTO`fTzrHtU>P=<`)2@eWC%C!4w$=x$0-ey<@WkkT7mi7%qy+qkXQ}%=?
zYiTtK{%bGL`5A7XuJ>EvuWUJmm%yri{3~NiC!D$wRs1p!<DQ`hFFu7Q`04@q!fz(z
zj(%qeb<U3erG()0SD@zXuTUp#0ew2ALkP!MRSEAC$W6bS9BVFM!-RDp`h`{TzonSv
zSA#MARcNev0<&m<x|i3rJJP+mv}_W!-!Qiz*Fkvq6D`vVCY27ZFV+1ohK6sy9z17-
zK^|1288g2VGW@`Evj}Rd`iZR*LYAk7UICFdrW!;Jj-8GspnQ{!sbItmpc`QXIu$27
zffXp<WGA%Op8DF#M24P1Qx8~WPSKT>PoKgw7YNkUzJ1D+J|Uf-28%xt-RtS7-*cNu
z#S}l;6SX!KSB6I3ekz6GO&g`E_gyxjErYMP50OkFrKYXW;AdwLB9o`HJ9g3-z9}H6
z_js=m>BCU>&88TP<_Y#_ubPC6VJ}b+LN>DFEwccnsqgKN|AYqN6-3vkX>d2kvGx+U
zlOW{<FHdOD%L}%TxP4}0IH0Z26ZR}v607E%O;e}aAmBz`cke8~ZDM|~ZlEBp7R5DM
z>Mr=|EC+NKY?_eFeJ7t2ZE#Dxv`!M9_dY(M2}A2m>gmZCFfysQ7A4w%VO2cz=~Do0
ztLmATC)DVIXKCn#OgBb;GF$ogufoKws-1Huo>;O^>-II`lxAUt7k>K`SfvxT`qgV1
z3W8)INSdiBaqYe8$cEWu!<;?^UVV5%hD-}u6xc>q+4ZM`WoY_f-S@e%iDGAi!77EC
zOaf&ZY9be9y`;FJtiOMp7iH}@^vWAl#>}BCtCEb_J4RWfL3=|orVbtqwS8l2YpYYB
z^_9LqJbK{3EiYe=)jxu{jA5o#C1Hi%f2_2UlV92D&%PVn-mJb#@b1~K_Xj(u40WGj
zg%;P$Lg20HUH?XHMpHt~dpR(Rb7aTer!lft)hF~q2tmPR@1#pXm(w6f9&{NDcbpc#
z_9D*uKwFjPTssRvw`wB4q)|WlKuh{`mF`SW52O=Zc5oH~Ry;Mn>qQ#BlMh(KCy)_M
zFOT7j95NsI{wzY<s{ZmP3l(HYDE)r2RQ#$ok9D2JRW0%t9SQ=mlv*(vfJJIWuxJiN
z>Pu0pCwK`UYBiY6;u6qQW-HWsTWJ-hk9KwMo_rz}qOHfYo*^RiTV<oOQJR`QHUImH
zLIuk}6!1mK2>Wm;ql3~YWOU@$y8OO{q&nceL~E>WsxIMK1m5reRw16CXH0IOYT8@E
za}v0AK3GUIODSnzt07zQCj?-8PAT?ZMiyiL^K%Huq7N`!Vc*b_uh#=5_<Dnh6#HK3
z8ua|U(kx+i0<a(YSs@Dp?}Ff^W7$U*dg=eppp~&|F8&hrh2^2fG?}_-Rlem-GicH$
z59}2mD0Dsrl{Ev8xc3@Fy_e1>_r@-KJ_R9Lszy3()S((FMjhlwJ;)l40ih+Sz)iq~
zrGm7|ayUw6f+^x#*i0bs_0p=7GBop}voHcNA3laZYB^|c8>Rv^{AREBpny9y5JXc=
zCp0L=SF%M>LVV#jh0c@!1WQRDQ^FaNKJu5jHd1O-Q+&Y|w2PW*%*Gt^0xbgw*Groj
zpC1|vA5{GAm05&T@rcgrDWnS-W~RrNVTd)JOZ$A%`@8@@<;RZ~>XMA^hq8c-4p3&2
z`I=soNOsaBOOB>t7Q|a1N;@y)-b=x;l5hLnEL;|=>YYab-XrI6Y@h4cHhlBh0%=2y
z_sHEZl?J=J!ES4?n;Pu-4R&K=W4%@Oo!d_#=&Y(2qR`J$YOp}$#0U*0!5(~<*N-fi
ze+rHGRQ+jHZT~rKa)&S)efo{}tr&<X@pwe*i6{xXTkFl}8N&)G56)sZt!n#&V@~ov
zihq&*?ieAtXj&J|Q|szS+Ge7e)~Yh*LTBZ}oPTu5{KHhb8T()@B)i(y5RUP}nKKZH
z;t8hyyR_pj!$^zA)QCEmQlLB_qI7KuBf!YnRi?Kp9~eU8`T*2z`N6->VxUgg0@Q>*
zD)*HMT!2g}Ra$^oYXQ<q(n#rs8UfAMV6u!^KXOLbEI{9?T78y_X9_f+FNML_=4?Yl
zoVnZOGZ$)@GO;6I&qDKhXyu+EN6fE(J`2Fg3u5(opO%l9Oj3hnCM6zG(!H64nxrDj
ztRkspG8%)}`a8nvpfiR;$R>2nOlrzxRey2*SW~Ne;=oiQ=}fntG1<HaW_IU#Y5u9G
z!q_U~s+m&PcMcVFeP1d;MZ_OK>p(!TlvVc3IVH@df%O|7mc^fp0d2~Bm0t??{^1V$
zk<1%TgQc*l4nGF*cj8pvF?^di)yMX07>*bLr@CR4-B_~5A5Y{TTr_rx1N^%L*$pX4
zZZ;euZ16p&LSL-Y{ijtuQU@oFWT6F^BXPwrLH5ehW2dpf?hF!OiQM|xnbe%xs`}m|
zV@)kCl8YqGK7fLqz(9N>?|x<mO?qNbuKzn9C@DR~02wNo@QZ{IO!%#?!aK{0D!fy^
zu8$YqX<c?Obmih#)^FMlWp}o+Ku&ujEeOGj?a=qXLjG6W`>%hJz5ih72VeedPIHR(
zymUJh?RmD#dRbWywSCA}JM|vBT~B6T$vj}HN!v8Yd=`_3pX+F{&TeUL*AodP8Ov7o
z^lXHot&3?;^4luE>*51esHOSX`a@s)#N}nL>FFsugM52VG+}B@&CjhTv@_?cTk#ge
zY)1XGUi0WU!Dsl$Yrk1`z*<mNmTPKkvgRIZ-H;r)YrdJ*M>@x28BtEj)NL1bq35B8
z>9eE9T3;$#w6bjOv6iyA0=p%@AkbAd{t)k=<W~CW{Iupi^t)Ws@NH+6QRJH%n*n&f
zbu0omT?7?65I{s}*?)K9vn5<l=(^NAaBU9aU#u%|QRsf)%L2P#jglr?z%W!?9!-fG
zR{860pT$dK&HeRHa?KKCE=oQ`AnVj`yleh`TTK9C9%ZbUXej@9&J2Rhs`<bg7Yr?4
z%6W$tC;#lV1puLuIWq`={PdwN%e6?rEcJ4_Hfl|U{X{@{{>`%hl&ORH(8k<S3Cvai
zbDOH9qXfP_LS8^=J$hPDnXQpc*QeT7Xa;oYw93!@@hOC_HTStHIv+d)eS2m@QZwxi
zEv{PSdtNw&#ywkpTJu`#a;<{iTKwmsSRs4c5N=^*&??KGH;dQGs_B1+3o|?riE;vR
zvz}Dq0yc8ZFw;cBHb&0=-7G@Ps{YkmbIT=!aNloJz)I`h^`S3(Z5H8j+;N`!q2K0K
z2=0mp?;0%`V>+{=sq@2PBz33+cff{T_fW3Mk?odJF33RxBs;8E-k_3Gw^Ju9a6eiW
zE?7B>p|s|{aFrXf=Dd(8NiCI$D_~QwyCg{^H2-91yjIQg*SbgE;v4xPI`Z~DCE1Ik
z9)+s1<yZf92CTR>@15u8np&j!Bimrg3rxQ)8MEI7i>D;}(GE1HeFn_?_|wtP%v{q_
z2}dfbr$#!*)hMmv254>~s!v*r+HNK2_YcefNUgd5_QzaPs|3L^fMBC)nr!mo0O}(1
z9ztkrzPsKvs%Naw#?><di1~UBLuWV;m*AdKhq}p>b&Q=k+|vos;Ks;~Ei+)ouih@Z
z=!0%#m*Xze6DZ(xYDQFz$Cae2XAH;iQufJ%GXP_&<~`raVR#x9?^?a8*?tY=k<RfL
z(ViE*Wd_Xnbopt`{Yz)AY5DNYZ$%GOGkBo3r1jpkl1KpOtL*6+(9Ax2{if}<V+dQ*
zi+-7t<aDymQqFy@qiMzPVd@HErtdY1p+$i^tx@|Flx_92Rrb)&OVo7Ie_A!So{?+f
z>K(JYw`Yj(oUpij&BB`q%lp>_r6qe6mu9#t*UbG$&D@Vfw41DFWhBYR3SIwFX^rw@
zI=4IG#uN#DCy0w_jZ2h@y-6LgJ4Sh2-_FNoF{D;aB$UGnhLl6Jcs(yWP>rJvk_@Z-
zs-MncuwJ!AnRoeIc~O>n-KFh%lKM-NnwpHNqaH?n|4fiwr%&10Z{?bo3TD7ea+{Qd
z-~%#jR_LcC(k_7J+%L^@quET|ig7jSFxGcq<)o3mKbMd!K$oi<a?Pz0k}cfm4yH1Q
z0#JvHk+*!fgyHeSy!wxK=bD#Em?KMVGYn9Eqng4=*d=#ug04SM&)a5;Ls;t*Z#@ai
zV%6NeIfvCq`S4MZZ;QvlmoUJ{W_vQGqgz3-OQbU~rt_AO<6*gk=`woC(z=Zxa$BK+
z^(7=v{7TH-IGDpyntUbD^hxbftd|KP?=IMy*e>;x_moy;8ocB^&*h+vs))6Ixwu&C
z18qE(Thk7Px~p>&#Bv|F<)x23e4$uVG`em#wYX;D-tw6r%HQ&%(y~rs(;TbHweav@
zhVcq|DwvSvX1XGTdz7d;a?a5bz!L*o{j2}YwKU6W!xDrw33#p>#0V6tJXul}jsw>7
z*3Qkfv<N-7)oq?^r#YEwnlOiojuPG{keU2sf3C$*?pmp;d<9CES!X36kYOi{$>=w%
zQ0E(G@tRn3Yd5$t<KZhTkJxv@jSS2LkNt7OuV&*Pb1khBel33d+{VYyecvkqC=sCj
zQm*9^2|%jT!hYS>r>7xylw)bLb8F<BFU&v$$&sDQEnUKWsqK0)szQ&M9wPq4)Ilrs
zA?0McO=rqa>&#ovdak3jY53;(-z+=Oap>j4yfgxMtHDgNW0dVxn*v{c>yDWOy!D!I
zh6w;IOm}*rto)uYgg$)mo9C|r1*ziK<%e2+8v2j>*O$#HyY$$O2Y$5ama^C1dlk<X
z?H+7uKDG(3o_WEKT~`A$OOJKnz0y^@cQsx;XZ@Y7tCv3Un@b1r3eT@Jo0c3~b>1Iq
zcgR=Cy-SX*oL}2;lbnlb43VoV=H1f0TE3dl$kpZ7M_zcnxLOrWM2#r9d`aShuWxm|
z!XQ_drS4qvcGuN7xf+=Id8`EoEMJ8IH^1Y5_6~`wmC;0+T&%re->%WJ8gikAUNqt>
yj=lAX+cuTS7fo};v8vV=KUXVXOlT{Ph4j0xdr({qlXtFov8?>TXUm_U|NH;Z^j{zV

diff --git a/readline/doc/readline.html b/readline/doc/readline.html
new file mode 100644
--- /dev/null
+++ b/readline/doc/readline.html
@@ -0,0 +1,3363 @@
+<HTML>
+<HEAD>
+<!-- This HTML file has been created by texi2html 1.51
+     from /usr/homes/chet/src/bash/readline-2.1-beta2/doc/rlman.texinfo on 22 May 1997 -->
+
+<TITLE>GNU Readline Library</TITLE>
+</HEAD>
+<BODY>
+<H1>GNU Readline Library</H1>
+<H2>Edition 2.1, for <CODE>Readline Library</CODE> Version 2.1.</H2>
+<H2>March 1996</H2>
+<ADDRESS>Brian Fox, Free Software Foundation</ADDRESS>
+<ADDRESS>Chet Ramey, Case Western Reserve University</ADDRESS>
+<P>
+<P><HR><P>
+
+<P>
+This document describes the GNU Readline Library, a utility which aids
+in the consistency of user interface across discrete programs that need
+to provide a command line interface.
+
+</P>
+<P>
+Published by the Free Software Foundation <BR>
+675 Massachusetts Avenue, <BR>
+Cambridge, MA 02139 USA
+
+</P>
+<P>
+Permission is granted to make and distribute verbatim copies of
+this manual provided the copyright notice and this permission notice
+are preserved on all copies.
+
+</P>
+<P>
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided that the entire
+resulting derived work is distributed under the terms of a permission
+notice identical to this one.
+
+</P>
+<P>
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions,
+except that this permission notice may be stated in a translation approved
+by the Foundation.
+
+</P>
+<P>
+Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+
+</P>
+
+
+
+<H1><A NAME="SEC1" HREF="readline_toc.html#TOC1">Command Line Editing</A></H1>
+
+<P>
+This chapter describes the basic features of the GNU
+command line editing interface.
+
+</P>
+
+
+
+<H2><A NAME="SEC2" HREF="readline_toc.html#TOC2">Introduction to Line Editing</A></H2>
+
+<P>
+The following paragraphs describe the notation used to represent
+keystrokes.
+
+</P>
+<P>
+The text <KBD>C-k</KBD> is read as `Control-K' and describes the character
+produced when the <KBD>k</KBD> key is pressed while the Control key
+is depressed.
+
+</P>
+<P>
+The text <KBD>M-k</KBD> is read as `Meta-K' and describes the character
+produced when the meta key (if you have one) is depressed, and the <KBD>k</KBD>
+key is pressed.  If you do not have a meta key, the identical keystroke
+can be generated by typing <KBD>ESC</KBD> <I>first</I>, and then typing <KBD>k</KBD>.
+Either process is known as <STRONG>metafying</STRONG> the <KBD>k</KBD> key.
+
+</P>
+<P>
+The text <KBD>M-C-k</KBD> is read as `Meta-Control-k' and describes the
+character produced by <STRONG>metafying</STRONG> <KBD>C-k</KBD>.
+
+</P>
+<P>
+In addition, several keys have their own names.  Specifically,
+<KBD>DEL</KBD>, <KBD>ESC</KBD>, <KBD>LFD</KBD>, <KBD>SPC</KBD>, <KBD>RET</KBD>, and <KBD>TAB</KBD> all
+stand for themselves when seen in this text, or in an init file
+(@xref{Readline Init File}).
+
+</P>
+
+
+<H2><A NAME="SEC3" HREF="readline_toc.html#TOC3">Readline Interaction</A></H2>
+<P>
+<A NAME="IDX1"></A>
+
+</P>
+<P>
+Often during an interactive session you type in a long line of text,
+only to notice that the first word on the line is misspelled.  The
+Readline library gives you a set of commands for manipulating the text
+as you type it in, allowing you to just fix your typo, and not forcing
+you to retype the majority of the line.  Using these editing commands,
+you move the cursor to the place that needs correction, and delete or
+insert the text of the corrections.  Then, when you are satisfied with
+the line, you simply press <KBD>RETURN</KBD>.  You do not have to be at the
+end of the line to press <KBD>RETURN</KBD>; the entire line is accepted
+regardless of the location of the cursor within the line.
+
+</P>
+
+
+
+<H3><A NAME="SEC4" HREF="readline_toc.html#TOC4">Readline Init File Syntax</A></H3>
+
+<P>
+There are only a few basic constructs allowed in the
+Readline init file.  Blank lines are ignored.
+Lines beginning with a <SAMP>`#'</SAMP> are comments.
+Lines beginning with a <SAMP>`$'</SAMP> indicate conditional
+constructs (see section <A HREF="readline.html#SEC5">Conditional Init Constructs</A>).  Other lines
+denote variable settings and key bindings.
+
+</P>
+<DL COMPACT>
+
+<DT>Variable Settings
+<DD>
+You can change the state of a few variables in Readline by
+using the <CODE>set</CODE> command within the init file.  Here is how you
+would specify that you wish to use <CODE>vi</CODE> line editing commands:
+
+
+<PRE>
+set editing-mode vi
+</PRE>
+
+Right now, there are only a few variables which can be set;
+so few, in fact, that we just list them here:
+
+<DL COMPACT>
+
+<DT><CODE>bell-style</CODE>
+<DD>
+<A NAME="IDX2"></A>
+Controls what happens when Readline wants to ring the terminal bell.
+If set to <SAMP>`none'</SAMP>, Readline never rings the bell.  If set to
+<SAMP>`visible'</SAMP>, Readline uses a visible bell if one is available.
+If set to <SAMP>`audible'</SAMP> (the default), Readline attempts to ring
+the terminal's bell.
+
+<DT><CODE>comment-begin</CODE>
+<DD>
+<A NAME="IDX3"></A>
+The string to insert at the beginning of the line when the
+<CODE>insert-comment</CODE> command is executed.  The default value
+is <CODE>"#"</CODE>.
+
+<DT><CODE>completion-query-items</CODE>
+<DD>
+<A NAME="IDX4"></A>
+The number of possible completions that determines when the user is
+asked whether he wants to see the list of possibilities.  If the
+number of possible completions is greater than this value,
+Readline will ask the user whether or not he wishes to view
+them; otherwise, they are simply listed.  The default limit is
+<CODE>100</CODE>.
+
+<DT><CODE>convert-meta</CODE>
+<DD>
+<A NAME="IDX5"></A>
+If set to <SAMP>`on'</SAMP>, Readline will convert characters with the
+eigth bit set to an ASCII key sequence by stripping the eigth
+bit and prepending an <KBD>ESC</KBD> character, converting them to a
+meta-prefixed key sequence.  The default value is <SAMP>`on'</SAMP>.
+
+<DT><CODE>disable-completion</CODE>
+<DD>
+<A NAME="IDX6"></A>
+If set to <SAMP>`On'</SAMP>, readline will inhibit word completion.
+Completion  characters will be inserted into the line as if they had
+been mapped to <CODE>self-insert</CODE>.  The default is <SAMP>`off'</SAMP>.
+
+<DT><CODE>editing-mode</CODE>
+<DD>
+<A NAME="IDX7"></A>
+The <CODE>editing-mode</CODE> variable controls which editing mode you are
+using.  By default, Readline starts up in Emacs editing mode, where
+the keystrokes are most similar to Emacs.  This variable can be
+set to either <SAMP>`emacs'</SAMP> or <SAMP>`vi'</SAMP>.
+
+<DT><CODE>enable-keypad</CODE>
+<DD>
+<A NAME="IDX8"></A>
+When set to <SAMP>`on'</SAMP>, readline will try to enable the application
+keypad when it is called.  Some systems need this to enable the
+arrow keys.  The default is <SAMP>`off'</SAMP>.
+
+<DT><CODE>expand-tilde</CODE>
+<DD>
+<A NAME="IDX9"></A>
+If set to <SAMP>`on'</SAMP>, tilde expansion is performed when Readline
+attempts word completion.  The default is <SAMP>`off'</SAMP>.
+
+<DT><CODE>horizontal-scroll-mode</CODE>
+<DD>
+<A NAME="IDX10"></A>
+This variable can be set to either <SAMP>`on'</SAMP> or <SAMP>`off'</SAMP>.  Setting it
+to <SAMP>`on'</SAMP> means that the text of the lines that you edit will scroll
+horizontally on a single screen line when they are longer than the width
+of the screen, instead of wrapping onto a new screen line.  By default,
+this variable is set to <SAMP>`off'</SAMP>.
+
+<DT><CODE>keymap</CODE>
+<DD>
+<A NAME="IDX11"></A>
+Sets Readline's idea of the current keymap for key binding commands.
+Acceptable <CODE>keymap</CODE> names are
+<CODE>emacs</CODE>,
+<CODE>emacs-standard</CODE>,
+<CODE>emacs-meta</CODE>,
+<CODE>emacs-ctlx</CODE>,
+<CODE>vi</CODE>,
+<CODE>vi-command</CODE>, and
+<CODE>vi-insert</CODE>.
+<CODE>vi</CODE> is equivalent to <CODE>vi-command</CODE>; <CODE>emacs</CODE> is
+equivalent to <CODE>emacs-standard</CODE>.  The default value is <CODE>emacs</CODE>.
+The value of the <CODE>editing-mode</CODE> variable also affects the
+default keymap.
+
+<DT><CODE>mark-directories</CODE>
+<DD>
+If set to <SAMP>`on'</SAMP>, completed directory names have a slash
+appended.  The default is <SAMP>`on'</SAMP>.
+
+<DT><CODE>mark-modified-lines</CODE>
+<DD>
+<A NAME="IDX12"></A>
+This variable, when set to <SAMP>`on'</SAMP>, says to display an asterisk
+(<SAMP>`*'</SAMP>) at the start of history lines which have been modified.
+This variable is <SAMP>`off'</SAMP> by default.
+
+<DT><CODE>input-meta</CODE>
+<DD>
+<A NAME="IDX13"></A>
+<A NAME="IDX14"></A>
+If set to <SAMP>`on'</SAMP>, Readline will enable eight-bit input (it
+will not strip the eighth bit from the characters it reads),
+regardless of what the terminal claims it can support.  The
+default value is <SAMP>`off'</SAMP>.  The name <CODE>meta-flag</CODE> is a
+synonym for this variable.
+
+<DT><CODE>output-meta</CODE>
+<DD>
+<A NAME="IDX15"></A>
+If set to <SAMP>`on'</SAMP>, Readline will display characters with the
+eighth bit set directly rather than as a meta-prefixed escape
+sequence.  The default is <SAMP>`off'</SAMP>.
+
+<DT><CODE>show-all-if-ambiguous</CODE>
+<DD>
+<A NAME="IDX16"></A>
+This alters the default behavior of the completion functions.  If
+set to <SAMP>`on'</SAMP>, 
+words which have more than one possible completion cause the
+matches to be listed immediately instead of ringing the bell.
+The default value is <SAMP>`off'</SAMP>.
+
+<DT><CODE>visible-stats</CODE>
+<DD>
+<A NAME="IDX17"></A>
+If set to <SAMP>`on'</SAMP>, a character denoting a file's type
+is appended to the filename when listing possible
+completions.  The default is <SAMP>`off'</SAMP>.
+
+</DL>
+
+<DT>Key Bindings
+<DD>
+The syntax for controlling key bindings in the init file is
+simple.  First you have to know the name of the command that you
+want to change.  The following pages contain tables of the command name,
+the default keybinding, and a short description of what the command
+does.
+
+Once you know the name of the command, simply place the name of the key
+you wish to bind the command to, a colon, and then the name of the
+command on a line in the init file.  The name of the key
+can be expressed in different ways, depending on which is most
+comfortable for you.
+
+<DL COMPACT>
+
+<DT><VAR>keyname</VAR>: <VAR>function-name</VAR> or <VAR>macro</VAR>
+<DD>
+<VAR>keyname</VAR> is the name of a key spelled out in English.  For example:
+
+<PRE>
+Control-u: universal-argument
+Meta-Rubout: backward-kill-word
+Control-o: "&#62; output"
+</PRE>
+
+In the above example, <SAMP>`C-u'</SAMP> is bound to the function
+<CODE>universal-argument</CODE>, and <SAMP>`C-o'</SAMP> is bound to run the macro
+expressed on the right hand side (that is, to insert the text
+<SAMP>`&#62; output'</SAMP> into the line).
+
+<DT>"<VAR>keyseq</VAR>": <VAR>function-name</VAR> or <VAR>macro</VAR>
+<DD>
+<VAR>keyseq</VAR> differs from <VAR>keyname</VAR> above in that strings
+denoting an entire key sequence can be specified, by placing
+the key sequence in double quotes.  Some GNU Emacs style key
+escapes can be used, as in the following example, but the
+special character names are not recognized.
+
+
+<PRE>
+"\C-u": universal-argument
+"\C-x\C-r": re-read-init-file
+"\e[11~": "Function Key 1"
+</PRE>
+
+In the above example, <SAMP>`C-u'</SAMP> is bound to the function
+<CODE>universal-argument</CODE> (just as it was in the first example),
+<SAMP>`C-x C-r'</SAMP> is bound to the function <CODE>re-read-init-file</CODE>, and
+<SAMP>`ESC [ 1 1 ~'</SAMP> is bound to insert the text <SAMP>`Function Key 1'</SAMP>.
+The following escape sequences are available when specifying key
+sequences:
+
+<DL COMPACT>
+
+<DT><CODE><KBD>\C-</KBD></CODE>
+<DD>
+control prefix
+<DT><CODE><KBD>\M-</KBD></CODE>
+<DD>
+meta prefix
+<DT><CODE><KBD>\e</KBD></CODE>
+<DD>
+an escape character
+<DT><CODE><KBD>\\</KBD></CODE>
+<DD>
+backslash
+<DT><CODE><KBD>\"</KBD></CODE>
+<DD>
+<KBD>"</KBD>
+<DT><CODE><KBD>\'</KBD></CODE>
+<DD>
+<KBD>'</KBD>
+</DL>
+
+When entering the text of a macro, single or double quotes should
+be used to indicate a macro definition.  Unquoted text
+is assumed to be a function name.  Backslash
+will quote any character in the macro text, including <SAMP>`"'</SAMP>
+and <SAMP>`''</SAMP>.
+For example, the following binding will make <SAMP>`C-x \'</SAMP>
+insert a single <SAMP>`\'</SAMP> into the line:
+
+<PRE>
+"\C-x\\": "\\"
+</PRE>
+
+</DL>
+</DL>
+
+
+
+<H3><A NAME="SEC5" HREF="readline_toc.html#TOC5">Conditional Init Constructs</A></H3>
+
+<P>
+Readline implements a facility similar in spirit to the conditional
+compilation features of the C preprocessor which allows key
+bindings and variable settings to be performed as the result
+of tests.  There are three parser directives used.
+
+</P>
+<DL COMPACT>
+
+<DT><CODE>$if</CODE>
+<DD>
+The <CODE>$if</CODE> construct allows bindings to be made based on the
+editing mode, the terminal being used, or the application using
+Readline.  The text of the test extends to the end of the line;
+no characters are required to isolate it.
+
+<DL COMPACT>
+
+<DT><CODE>mode</CODE>
+<DD>
+The <CODE>mode=</CODE> form of the <CODE>$if</CODE> directive is used to test
+whether Readline is in <CODE>emacs</CODE> or <CODE>vi</CODE> mode.
+This may be used in conjunction
+with the <SAMP>`set keymap'</SAMP> command, for instance, to set bindings in
+the <CODE>emacs-standard</CODE> and <CODE>emacs-ctlx</CODE> keymaps only if
+Readline is starting out in <CODE>emacs</CODE> mode.
+
+<DT><CODE>term</CODE>
+<DD>
+The <CODE>term=</CODE> form may be used to include terminal-specific
+key bindings, perhaps to bind the key sequences output by the
+terminal's function keys.  The word on the right side of the
+<SAMP>`='</SAMP> is tested against the full name of the terminal and the
+portion of the terminal name before the first <SAMP>`-'</SAMP>.  This
+allows <CODE>sun</CODE> to match both <CODE>sun</CODE> and <CODE>sun-cmd</CODE>,
+for instance.
+
+<DT><CODE>application</CODE>
+<DD>
+The <VAR>application</VAR> construct is used to include
+application-specific settings.  Each program using the Readline
+library sets the <VAR>application name</VAR>, and you can test for it. 
+This could be used to bind key sequences to functions useful for
+a specific program.  For instance, the following command adds a
+key sequence that quotes the current or previous word in Bash:
+
+<PRE>
+$if Bash
+# Quote the current or previous word
+"\C-xq": "\eb\"\ef\""
+$endif
+</PRE>
+
+</DL>
+
+<DT><CODE>$endif</CODE>
+<DD>
+This command, as you saw in the previous example, terminates an
+<CODE>$if</CODE> command.
+
+<DT><CODE>$else</CODE>
+<DD>
+Commands in this branch of the <CODE>$if</CODE> directive are executed if
+the test fails.
+</DL>
+
+
+
+<H3><A NAME="SEC6" HREF="readline_toc.html#TOC6">Sample Init File</A></H3>
+
+<P>
+Here is an example of an inputrc file.  This illustrates key
+binding, variable assignment, and conditional syntax.
+
+</P>
+
+<PRE>
+# This file controls the behaviour of line input editing for
+# programs that use the Gnu Readline library.  Existing programs
+# include FTP, Bash, and Gdb.
+#
+# You can re-read the inputrc file with C-x C-r.
+# Lines beginning with '#' are comments.
+#
+# Set various bindings for emacs mode.
+
+set editing-mode emacs 
+
+$if mode=emacs
+
+Meta-Control-h:	backward-kill-word	Text after the function name is ignored
+
+#
+# Arrow keys in keypad mode
+#
+#"\M-OD":        backward-char
+#"\M-OC":        forward-char
+#"\M-OA":        previous-history
+#"\M-OB":        next-history
+#
+# Arrow keys in ANSI mode
+#
+"\M-[D":        backward-char
+"\M-[C":        forward-char
+"\M-[A":        previous-history
+"\M-[B":        next-history
+#
+# Arrow keys in 8 bit keypad mode
+#
+#"\M-\C-OD":       backward-char
+#"\M-\C-OC":       forward-char
+#"\M-\C-OA":       previous-history
+#"\M-\C-OB":       next-history
+#
+# Arrow keys in 8 bit ANSI mode
+#
+#"\M-\C-[D":       backward-char
+#"\M-\C-[C":       forward-char
+#"\M-\C-[A":       previous-history
+#"\M-\C-[B":       next-history
+
+C-q: quoted-insert
+
+$endif
+
+# An old-style binding.  This happens to be the default.
+TAB: complete
+
+# Macros that are convenient for shell interaction
+$if Bash
+# edit the path
+"\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
+# prepare to type a quoted word -- insert open and close double quotes
+# and move to just after the open quote
+"\C-x\"": "\"\"\C-b"
+# insert a backslash (testing backslash escapes in sequences and macros)
+"\C-x\\": "\\"
+# Quote the current or previous word
+"\C-xq": "\eb\"\ef\""
+# Add a binding to refresh the line, which is unbound
+"\C-xr": redraw-current-line
+# Edit variable on current line.
+"\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
+$endif
+
+# use a visible bell if one is available
+set bell-style visible
+
+# don't strip characters to 7 bits when reading
+set input-meta on
+
+# allow iso-latin1 characters to be inserted rather than converted to
+# prefix-meta sequences
+set convert-meta off
+
+# display characters with the eighth bit set directly rather than
+# as meta-prefixed characters
+set output-meta on
+
+# if there are more than 150 possible completions for a word, ask the
+# user if he wants to see all of them
+set completion-query-items 150
+
+# For FTP
+$if Ftp
+"\C-xg": "get \M-?"
+"\C-xt": "put \M-?"
+"\M-.": yank-last-arg
+$endif
+</PRE>
+
+
+
+<H2><A NAME="SEC7" HREF="readline_toc.html#TOC7">Bindable Readline Commands</A></H2>
+
+<P>
+This section describes Readline commands that may be bound to key
+sequences.
+
+</P>
+
+
+<H3><A NAME="SEC8" HREF="readline_toc.html#TOC8">Commands For Moving</A></H3>
+<DL COMPACT>
+
+<DT><CODE>beginning-of-line (C-a)</CODE>
+<DD>
+<A NAME="IDX18"></A>
+Move to the start of the current line.
+
+<DT><CODE>end-of-line (C-e)</CODE>
+<DD>
+<A NAME="IDX19"></A>
+Move to the end of the line.
+
+<DT><CODE>forward-char (C-f)</CODE>
+<DD>
+<A NAME="IDX20"></A>
+Move forward a character.
+
+<DT><CODE>backward-char (C-b)</CODE>
+<DD>
+<A NAME="IDX21"></A>
+Move back a character.
+
+<DT><CODE>forward-word (M-f)</CODE>
+<DD>
+<A NAME="IDX22"></A>
+Move forward to the end of the next word.  Words are composed of
+letters and digits.
+
+<DT><CODE>backward-word (M-b)</CODE>
+<DD>
+<A NAME="IDX23"></A>
+Move back to the start of this, or the previous, word.  Words are
+composed of letters and digits.
+
+<DT><CODE>clear-screen (C-l)</CODE>
+<DD>
+<A NAME="IDX24"></A>
+Clear the screen and redraw the current line,
+leaving the current line at the top of the screen.
+
+<DT><CODE>redraw-current-line ()</CODE>
+<DD>
+<A NAME="IDX25"></A>
+Refresh the current line.  By default, this is unbound.
+
+</DL>
+
+
+
+<H3><A NAME="SEC9" HREF="readline_toc.html#TOC9">Commands For Manipulating The History</A></H3>
+
+<DL COMPACT>
+
+<DT><CODE>accept-line (Newline, Return)</CODE>
+<DD>
+<A NAME="IDX26"></A>
+Accept the line regardless of where the cursor is.  If this line is
+non-empty, add it to the history list.  If this line was a history
+line, then restore the history line to its original state.
+
+<DT><CODE>previous-history (C-p)</CODE>
+<DD>
+<A NAME="IDX27"></A>
+Move `up' through the history list.
+
+<DT><CODE>next-history (C-n)</CODE>
+<DD>
+<A NAME="IDX28"></A>
+Move `down' through the history list.
+
+<DT><CODE>beginning-of-history (M-&#60;)</CODE>
+<DD>
+<A NAME="IDX29"></A>
+Move to the first line in the history.
+
+<DT><CODE>end-of-history (M-&#62;)</CODE>
+<DD>
+<A NAME="IDX30"></A>
+Move to the end of the input history, i.e., the line you are entering.
+
+<DT><CODE>reverse-search-history (C-r)</CODE>
+<DD>
+<A NAME="IDX31"></A>
+Search backward starting at the current line and moving `up' through
+the history as necessary.  This is an incremental search.
+
+<DT><CODE>forward-search-history (C-s)</CODE>
+<DD>
+<A NAME="IDX32"></A>
+Search forward starting at the current line and moving `down' through
+the the history as necessary.  This is an incremental search.
+
+<DT><CODE>non-incremental-reverse-search-history (M-p)</CODE>
+<DD>
+<A NAME="IDX33"></A>
+Search backward starting at the current line and moving `up'
+through the history as necessary using a non-incremental search
+for a string supplied by the user.
+
+<DT><CODE>non-incremental-forward-search-history (M-n)</CODE>
+<DD>
+<A NAME="IDX34"></A>
+Search forward starting at the current line and moving `down'
+through the the history as necessary using a non-incremental search
+for a string supplied by the user.
+
+<DT><CODE>history-search-forward ()</CODE>
+<DD>
+<A NAME="IDX35"></A>
+Search forward through the history for the string of characters
+between the start of the current line and the current cursor
+position (the `point').  This is a non-incremental search.  By
+default, this command is unbound.
+
+<DT><CODE>history-search-backward ()</CODE>
+<DD>
+<A NAME="IDX36"></A>
+Search backward through the history for the string of characters
+between the start of the current line and the point.  This
+is a non-incremental search.  By default, this command is unbound.
+
+<DT><CODE>yank-nth-arg (M-C-y)</CODE>
+<DD>
+<A NAME="IDX37"></A>
+Insert the first argument to the previous command (usually
+the second word on the previous line).  With an argument <VAR>n</VAR>,
+insert the <VAR>n</VAR>th word from the previous command (the words
+in the previous command begin with word 0).  A negative argument
+inserts the <VAR>n</VAR>th word from the end of the previous command.
+
+<DT><CODE>yank-last-arg (M-., M-_)</CODE>
+<DD>
+<A NAME="IDX38"></A>
+Insert last argument to the previous command (the last word of the
+previous history entry).  With an
+argument, behave exactly like <CODE>yank-nth-arg</CODE>.
+
+</DL>
+
+
+
+<H3><A NAME="SEC10" HREF="readline_toc.html#TOC10">Commands For Changing Text</A></H3>
+
+<DL COMPACT>
+
+<DT><CODE>delete-char (C-d)</CODE>
+<DD>
+<A NAME="IDX39"></A>
+Delete the character under the cursor.  If the cursor is at the
+beginning of the line, there are no characters in the line, and
+the last character typed was not <KBD>C-d</KBD>, then return <CODE>EOF</CODE>.
+
+<DT><CODE>backward-delete-char (Rubout)</CODE>
+<DD>
+<A NAME="IDX40"></A>
+Delete the character behind the cursor.  A numeric arg says to kill
+the characters instead of deleting them.
+
+<DT><CODE>quoted-insert (C-q, C-v)</CODE>
+<DD>
+<A NAME="IDX41"></A>
+Add the next character that you type to the line verbatim.  This is
+how to insert key sequences like <KBD>C-q</KBD>, for example.
+
+<DT><CODE>tab-insert (M-TAB)</CODE>
+<DD>
+<A NAME="IDX42"></A>
+Insert a tab character.
+
+<DT><CODE>self-insert (a, b, A, 1, !, ...)</CODE>
+<DD>
+<A NAME="IDX43"></A>
+Insert yourself.
+
+<DT><CODE>transpose-chars (C-t)</CODE>
+<DD>
+<A NAME="IDX44"></A>
+Drag the character before the cursor forward over
+the character at the cursor, moving the
+cursor forward as well.  If the insertion point
+is at the end of the line, then this
+transposes the last two characters of the line.
+Negative argumentss don't work.
+
+<DT><CODE>transpose-words (M-t)</CODE>
+<DD>
+<A NAME="IDX45"></A>
+Drag the word behind the cursor past the word in front of the cursor
+moving the cursor over that word as well.
+
+<DT><CODE>upcase-word (M-u)</CODE>
+<DD>
+<A NAME="IDX46"></A>
+Uppercase the current (or following) word.  With a negative argument,
+do the previous word, but do not move the cursor.
+
+<DT><CODE>downcase-word (M-l)</CODE>
+<DD>
+<A NAME="IDX47"></A>
+Lowercase the current (or following) word.  With a negative argument,
+do the previous word, but do not move the cursor.
+
+<DT><CODE>capitalize-word (M-c)</CODE>
+<DD>
+<A NAME="IDX48"></A>
+Capitalize the current (or following) word.  With a negative argument,
+do the previous word, but do not move the cursor.
+
+</DL>
+
+
+
+<H3><A NAME="SEC11" HREF="readline_toc.html#TOC11">Killing And Yanking</A></H3>
+
+<DL COMPACT>
+
+<DT><CODE>kill-line (C-k)</CODE>
+<DD>
+<A NAME="IDX49"></A>
+Kill the text from the current cursor position to the end of the line.
+
+<DT><CODE>backward-kill-line (C-x Rubout)</CODE>
+<DD>
+<A NAME="IDX50"></A>
+Kill backward to the beginning of the line.
+
+<DT><CODE>unix-line-discard (C-u)</CODE>
+<DD>
+<A NAME="IDX51"></A>
+Kill backward from the cursor to the beginning of the current line.
+Save the killed text on the kill-ring.
+
+<DT><CODE>kill-whole-line ()</CODE>
+<DD>
+<A NAME="IDX52"></A>
+Kill all characters on the current line, no matter where the
+cursor is.  By default, this is unbound.
+
+<DT><CODE>kill-word (M-d)</CODE>
+<DD>
+<A NAME="IDX53"></A>
+Kill from the cursor to the end of the current word, or if between
+words, to the end of the next word.  Word boundaries are the same
+as <CODE>forward-word</CODE>.
+
+<DT><CODE>backward-kill-word (M-DEL)</CODE>
+<DD>
+<A NAME="IDX54"></A>
+Kill the word behind the cursor.  Word boundaries are the same
+as <CODE>backward-word</CODE>.
+
+<DT><CODE>unix-word-rubout (C-w)</CODE>
+<DD>
+<A NAME="IDX55"></A>
+Kill the word behind the cursor, using white space as a word
+boundary.  The killed text is saved on the kill-ring.
+
+<DT><CODE>delete-horizontal-space ()</CODE>
+<DD>
+<A NAME="IDX56"></A>
+Delete all spaces and tabs around point.  By default, this is unbound.
+
+<DT><CODE>kill-region ()</CODE>
+<DD>
+<A NAME="IDX57"></A>
+Kill the text between the point and the <EM>mark</EM> (saved
+cursor position.  This text is referred to as the <VAR>region</VAR>.
+By default, this command is unbound.
+
+<DT><CODE>copy-region-as-kill ()</CODE>
+<DD>
+<A NAME="IDX58"></A>
+Copy the text in the region to the kill buffer, so you can yank it
+right away.  By default, this command is unbound.
+
+<DT><CODE>copy-backward-word ()</CODE>
+<DD>
+<A NAME="IDX59"></A>
+Copy the word before point to the kill buffer.
+By default, this command is unbound.
+
+<DT><CODE>copy-forward-word ()</CODE>
+<DD>
+<A NAME="IDX60"></A>
+Copy the word following point to the kill buffer.
+By default, this command is unbound.
+
+<DT><CODE>yank (C-y)</CODE>
+<DD>
+<A NAME="IDX61"></A>
+Yank the top of the kill ring into the buffer at the current
+cursor position.
+
+<DT><CODE>yank-pop (M-y)</CODE>
+<DD>
+<A NAME="IDX62"></A>
+Rotate the kill-ring, and yank the new top.  You can only do this if
+the prior command is yank or yank-pop.
+</DL>
+
+
+
+<H3><A NAME="SEC12" HREF="readline_toc.html#TOC12">Specifying Numeric Arguments</A></H3>
+<DL COMPACT>
+
+<DT><CODE>digit-argument (M-0, M-1, ... M--)</CODE>
+<DD>
+<A NAME="IDX63"></A>
+Add this digit to the argument already accumulating, or start a new
+argument.  <KBD>M--</KBD> starts a negative argument.
+
+<DT><CODE>universal-argument ()</CODE>
+<DD>
+<A NAME="IDX64"></A>
+This is another way to specify an argument.
+If this command is followed by one or more digits, optionally with a
+leading minus sign, those digits define the argument.
+If the command is followed by digits, executing <CODE>universal-argument</CODE>
+again ends the numeric argument, but is otherwise ignored.
+As a special case, if this command is immediately followed by a
+character that is neither a digit or minus sign, the argument count
+for the next command is multiplied by four.
+The argument count is initially one, so executing this function the
+first time makes the argument count four, a second time makes the
+argument count sixteen, and so on.
+By default, this is not bound to a key.
+</DL>
+
+
+
+<H3><A NAME="SEC13" HREF="readline_toc.html#TOC13">Letting Readline Type For You</A></H3>
+
+<DL COMPACT>
+
+<DT><CODE>complete (TAB)</CODE>
+<DD>
+<A NAME="IDX65"></A>
+Attempt to do completion on the text before the cursor.  This is
+application-specific.  Generally, if you are typing a filename
+argument, you can do filename completion; if you are typing a command,
+you can do command completion, if you are typing in a symbol to GDB, you
+can do symbol name completion, if you are typing in a variable to Bash,
+you can do variable name completion, and so on.
+
+<DT><CODE>possible-completions (M-?)</CODE>
+<DD>
+<A NAME="IDX66"></A>
+List the possible completions of the text before the cursor.
+
+<DT><CODE>insert-completions (M-*)</CODE>
+<DD>
+<A NAME="IDX67"></A>
+Insert all completions of the text before point that would have
+been generated by <CODE>possible-completions</CODE>.
+
+</DL>
+
+
+
+<H3><A NAME="SEC14" HREF="readline_toc.html#TOC14">Keyboard Macros</A></H3>
+<DL COMPACT>
+
+<DT><CODE>start-kbd-macro (C-x ()</CODE>
+<DD>
+<A NAME="IDX68"></A>
+Begin saving the characters typed into the current keyboard macro.
+
+<DT><CODE>end-kbd-macro (C-x ))</CODE>
+<DD>
+<A NAME="IDX69"></A>
+Stop saving the characters typed into the current keyboard macro
+and save the definition.
+
+<DT><CODE>call-last-kbd-macro (C-x e)</CODE>
+<DD>
+<A NAME="IDX70"></A>
+Re-execute the last keyboard macro defined, by making the characters
+in the macro appear as if typed at the keyboard.
+
+</DL>
+
+
+
+<H3><A NAME="SEC15" HREF="readline_toc.html#TOC15">Some Miscellaneous Commands</A></H3>
+<DL COMPACT>
+
+<DT><CODE>re-read-init-file (C-x C-r)</CODE>
+<DD>
+<A NAME="IDX71"></A>
+Read in the contents of the inputrc file, and incorporate
+any bindings or variable assignments found there.
+
+<DT><CODE>abort (C-g)</CODE>
+<DD>
+<A NAME="IDX72"></A>
+Abort the current editing command and
+ring the terminal's bell (subject to the setting of
+<CODE>bell-style</CODE>).
+
+<DT><CODE>do-uppercase-version (M-a, M-b, M-<VAR>x</VAR>, ...)</CODE>
+<DD>
+<A NAME="IDX73"></A>
+If the metafied character <VAR>x</VAR> is lowercase, run the command
+that is bound to the corresponding uppercase character.
+
+<DT><CODE>prefix-meta (ESC)</CODE>
+<DD>
+<A NAME="IDX74"></A>
+Make the next character that you type be metafied.  This is for people
+without a meta key.  Typing <SAMP>`ESC f'</SAMP> is equivalent to typing
+<SAMP>`M-f'</SAMP>.
+
+<DT><CODE>undo (C-_, C-x C-u)</CODE>
+<DD>
+<A NAME="IDX75"></A>
+Incremental undo, separately remembered for each line.
+
+<DT><CODE>revert-line (M-r)</CODE>
+<DD>
+<A NAME="IDX76"></A>
+Undo all changes made to this line.  This is like typing the <CODE>undo</CODE>
+command enough times to get back to the beginning.
+
+<DT><CODE>tilde-expand (M-~)</CODE>
+<DD>
+<A NAME="IDX77"></A>
+Perform tilde expansion on the current word.
+
+<DT><CODE>set-mark (C-@)</CODE>
+<DD>
+<A NAME="IDX78"></A>
+Set the mark to the current point.  If a
+numeric argument is supplied, the mark is set to that position.
+
+<DT><CODE>exchange-point-and-mark (C-x C-x)</CODE>
+<DD>
+<A NAME="IDX79"></A>
+Swap the point with the mark.  The current cursor position is set to
+the saved position, and the old cursor position is saved as the mark.
+
+<DT><CODE>character-search (C-])</CODE>
+<DD>
+<A NAME="IDX80"></A>
+A character is read and point is moved to the next occurrence of that
+character.  A negative count searches for previous occurrences.
+
+<DT><CODE>character-search-backward (M-C-])</CODE>
+<DD>
+<A NAME="IDX81"></A>
+A character is read and point is moved to the previous occurrence
+of that character.  A negative count searches for subsequent
+occurrences.
+
+<DT><CODE>insert-comment (M-#)</CODE>
+<DD>
+<A NAME="IDX82"></A>
+The value of the <CODE>comment-begin</CODE>
+variable is inserted at the beginning of the current line,
+and the line is accepted as if a newline had been typed.
+
+<DT><CODE>dump-functions ()</CODE>
+<DD>
+<A NAME="IDX83"></A>
+Print all of the functions and their key bindings to the
+readline output stream.  If a numeric argument is supplied,
+the output is formatted in such a way that it can be made part
+of an <VAR>inputrc</VAR> file.  This command is unbound by default.
+
+<DT><CODE>dump-variables ()</CODE>
+<DD>
+<A NAME="IDX84"></A>
+Print all of the settable variables and their values to the
+readline output stream.  If a numeric argument is supplied,
+the output is formatted in such a way that it can be made part
+of an <VAR>inputrc</VAR> file.  This command is unbound by default.
+
+<DT><CODE>dump-macros ()</CODE>
+<DD>
+<A NAME="IDX85"></A>
+Print all of the readline key sequences bound to macros and the
+strings they ouput.  If a numeric argument is supplied,
+the output is formatted in such a way that it can be made part
+of an <VAR>inputrc</VAR> file.  This command is unbound by default.
+
+</DL>
+
+
+
+<H2><A NAME="SEC16" HREF="readline_toc.html#TOC16">Readline vi Mode</A></H2>
+
+<P>
+While the Readline library does not have a full set of <CODE>vi</CODE>
+editing functions, it does contain enough to allow simple editing
+of the line.  The Readline <CODE>vi</CODE> mode behaves as specified in
+the POSIX 1003.2 standard.
+
+</P>
+<P>
+In order to switch interactively between <CODE>emacs</CODE> and <CODE>vi</CODE>
+editing modes, use the command M-C-j (toggle-editing-mode).
+The Readline default is <CODE>emacs</CODE> mode.
+
+</P>
+<P>
+When you enter a line in <CODE>vi</CODE> mode, you are already placed in
+`insertion' mode, as if you had typed an <SAMP>`i'</SAMP>.  Pressing <KBD>ESC</KBD>
+switches you into `command' mode, where you can edit the text of the
+line with the standard <CODE>vi</CODE> movement keys, move to previous
+history lines with <SAMP>`k'</SAMP> and subsequent lines with <SAMP>`j'</SAMP>, and
+so forth.
+
+</P>
+
+
+
+<H1><A NAME="SEC17" HREF="readline_toc.html#TOC17">Programming with GNU Readline</A></H1>
+
+<P>
+This chapter describes the interface between the GNU Readline Library and
+other programs.  If you are a programmer, and you wish to include the
+features found in GNU Readline
+such as completion, line editing, and interactive history manipulation
+in your own programs, this section is for you.
+
+</P>
+
+
+
+<H2><A NAME="SEC18" HREF="readline_toc.html#TOC18">Basic Behavior</A></H2>
+
+<P>
+Many programs provide a command line interface, such as <CODE>mail</CODE>,
+<CODE>ftp</CODE>, and <CODE>sh</CODE>.  For such programs, the default behaviour of
+Readline is sufficient.  This section describes how to use Readline in
+the simplest way possible, perhaps to replace calls in your code to
+<CODE>gets()</CODE> or <CODE>fgets ()</CODE>.
+
+</P>
+<P>
+<A NAME="IDX86"></A>
+<A NAME="IDX87"></A>
+The function <CODE>readline ()</CODE> prints a prompt and then reads and returns
+a single line of text from the user.  The line <CODE>readline</CODE>
+returns is allocated with <CODE>malloc ()</CODE>; you should <CODE>free ()</CODE>
+the line when you are done with it.  The declaration for <CODE>readline</CODE>
+in ANSI C is
+
+</P>
+
+<PRE>
+<CODE>char *readline (char *<VAR>prompt</VAR>);</CODE>
+</PRE>
+
+<P>
+So, one might say
+
+<PRE>
+<CODE>char *line = readline ("Enter a line: ");</CODE>
+</PRE>
+
+<P>
+in order to read a line of text from the user.
+The line returned has the final newline removed, so only the
+text remains.
+
+</P>
+<P>
+If <CODE>readline</CODE> encounters an <CODE>EOF</CODE> while reading the line, and the
+line is empty at that point, then <CODE>(char *)NULL</CODE> is returned.
+Otherwise, the line is ended just as if a newline had been typed.
+
+</P>
+<P>
+If you want the user to be able to get at the line later, (with
+<KBD>C-p</KBD> for example), you must call <CODE>add_history ()</CODE> to save the
+line away in a <STRONG>history</STRONG> list of such lines.
+
+</P>
+
+<PRE>
+<CODE>add_history (line)</CODE>;
+</PRE>
+
+<P>
+For full details on the GNU History Library, see the associated manual.
+
+</P>
+<P>
+It is preferable to avoid saving empty lines on the history list, since
+users rarely have a burning need to reuse a blank line.  Here is
+a function which usefully replaces the standard <CODE>gets ()</CODE> library
+function, and has the advantage of no static buffer to overflow:
+
+</P>
+
+<PRE>
+/* A static variable for holding the line. */
+static char *line_read = (char *)NULL;
+
+/* Read a string, and return a pointer to it.  Returns NULL on EOF. */
+char *
+rl_gets ()
+{
+  /* If the buffer has already been allocated, return the memory
+     to the free pool. */
+  if (line_read)
+    {
+      free (line_read);
+      line_read = (char *)NULL;
+    }
+
+  /* Get a line from the user. */
+  line_read = readline ("");
+
+  /* If the line has any text in it, save it on the history. */
+  if (line_read &#38;&#38; *line_read)
+    add_history (line_read);
+
+  return (line_read);
+}
+</PRE>
+
+<P>
+This function gives the user the default behaviour of <KBD>TAB</KBD>
+completion: completion on file names.  If you do not want Readline to
+complete on filenames, you can change the binding of the <KBD>TAB</KBD> key
+with <CODE>rl_bind_key ()</CODE>.
+
+</P>
+
+<PRE>
+<CODE>int rl_bind_key (int <VAR>key</VAR>, int (*<VAR>function</VAR>)());</CODE>
+</PRE>
+
+<P>
+<CODE>rl_bind_key ()</CODE> takes two arguments: <VAR>key</VAR> is the character that
+you want to bind, and <VAR>function</VAR> is the address of the function to
+call when <VAR>key</VAR> is pressed.  Binding <KBD>TAB</KBD> to <CODE>rl_insert ()</CODE>
+makes <KBD>TAB</KBD> insert itself.
+<CODE>rl_bind_key ()</CODE> returns non-zero if <VAR>key</VAR> is not a valid
+ASCII character code (between 0 and 255).
+
+</P>
+<P>
+Thus, to disable the default <KBD>TAB</KBD> behavior, the following suffices:
+
+<PRE>
+<CODE>rl_bind_key ('\t', rl_insert);</CODE>
+</PRE>
+
+<P>
+This code should be executed once at the start of your program; you
+might write a function called <CODE>initialize_readline ()</CODE> which
+performs this and other desired initializations, such as installing
+custom completers (see section <A HREF="readline.html#SEC34">Custom Completers</A>).
+
+</P>
+
+
+<H2><A NAME="SEC19" HREF="readline_toc.html#TOC19">Custom Functions</A></H2>
+
+<P>
+Readline provides many functions for manipulating the text of
+the line, but it isn't possible to anticipate the needs of all
+programs.  This section describes the various functions and variables
+defined within the Readline library which allow a user program to add
+customized functionality to Readline.
+
+</P>
+
+
+
+<H3><A NAME="SEC20" HREF="readline_toc.html#TOC20">The Function Type</A></H3>
+
+<P>
+For readabilty, we declare a new type of object, called
+<STRONG>Function</STRONG>.  A <CODE>Function</CODE> is a C function which
+returns an <CODE>int</CODE>.  The type declaration for <CODE>Function</CODE> is:
+
+</P>
+<P>
+<CODE>typedef int Function ();</CODE>
+
+</P>
+<P>
+The reason for declaring this new type is to make it easier to write
+code describing pointers to C functions.  Let us say we had a variable
+called <VAR>func</VAR> which was a pointer to a function.  Instead of the
+classic C declaration
+
+</P>
+<P>
+<CODE>int (*)()func;</CODE>
+
+</P>
+<P>
+we may write
+
+</P>
+<P>
+<CODE>Function *func;</CODE>
+
+</P>
+<P>
+Similarly, there are
+
+</P>
+
+<PRE>
+typedef void VFunction ();
+typedef char *CPFunction (); and
+typedef char **CPPFunction ();
+</PRE>
+
+<P>
+for functions returning no value, <CODE>pointer to char</CODE>, and
+<CODE>pointer to pointer to char</CODE>, respectively.
+
+</P>
+
+
+<H3><A NAME="SEC21" HREF="readline_toc.html#TOC21">Writing a New Function</A></H3>
+
+<P>
+In order to write new functions for Readline, you need to know the
+calling conventions for keyboard-invoked functions, and the names of the
+variables that describe the current state of the line read so far.
+
+</P>
+<P>
+The calling sequence for a command <CODE>foo</CODE> looks like
+
+</P>
+
+<PRE>
+<CODE>foo (int count, int key)</CODE>
+</PRE>
+
+<P>
+where <VAR>count</VAR> is the numeric argument (or 1 if defaulted) and
+<VAR>key</VAR> is the key that invoked this function.
+
+</P>
+<P>
+It is completely up to the function as to what should be done with the
+numeric argument.  Some functions use it as a repeat count, some
+as a flag, and others to choose alternate behavior (refreshing the current
+line as opposed to refreshing the screen, for example).  Some choose to
+ignore it.  In general, if a
+function uses the numeric argument as a repeat count, it should be able
+to do something useful with both negative and positive arguments.
+At the very least, it should be aware that it can be passed a
+negative argument.
+
+</P>
+
+
+<H2><A NAME="SEC22" HREF="readline_toc.html#TOC22">Readline Variables</A></H2>
+
+<P>
+These variables are available to function writers.
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_line_buffer</B>
+<DD><A NAME="IDX88"></A>
+This is the line gathered so far.  You are welcome to modify the
+contents of the line, but see section <A HREF="readline.html#SEC28">Allowing Undoing</A>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_point</B>
+<DD><A NAME="IDX89"></A>
+The offset of the current cursor position in <CODE>rl_line_buffer</CODE>
+(the <EM>point</EM>).
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_end</B>
+<DD><A NAME="IDX90"></A>
+The number of characters present in <CODE>rl_line_buffer</CODE>.  When
+<CODE>rl_point</CODE> is at the end of the line, <CODE>rl_point</CODE> and
+<CODE>rl_end</CODE> are equal.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_mark</B>
+<DD><A NAME="IDX91"></A>
+The mark (saved position) in the current line.  If set, the mark
+and point define a <EM>region</EM>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_done</B>
+<DD><A NAME="IDX92"></A>
+Setting this to a non-zero value causes Readline to return the current
+line immediately.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_pending_input</B>
+<DD><A NAME="IDX93"></A>
+Setting this to a value makes it the next keystroke read.  This is a
+way to stuff a single character into the input stream.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_prompt</B>
+<DD><A NAME="IDX94"></A>
+The prompt Readline uses.  This is set from the argument to
+<CODE>readline ()</CODE>, and should not be assigned to directly.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_library_version</B>
+<DD><A NAME="IDX95"></A>
+The version number of this revision of the library.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_terminal_name</B>
+<DD><A NAME="IDX96"></A>
+The terminal type, used for initialization.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_readline_name</B>
+<DD><A NAME="IDX97"></A>
+This variable is set to a unique name by each application using Readline.
+The value allows conditional parsing of the inputrc file
+(see section <A HREF="readline.html#SEC5">Conditional Init Constructs</A>).
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> FILE * <B>rl_instream</B>
+<DD><A NAME="IDX98"></A>
+The stdio stream from which Readline reads input.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> FILE * <B>rl_outstream</B>
+<DD><A NAME="IDX99"></A>
+The stdio stream to which Readline performs output.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Function * <B>rl_startup_hook</B>
+<DD><A NAME="IDX100"></A>
+If non-zero, this is the address of a function to call just
+before <CODE>readline</CODE> prints the first prompt.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Function * <B>rl_event_hook</B>
+<DD><A NAME="IDX101"></A>
+If non-zero, this is the address of a function to call periodically
+when readline is waiting for terminal input.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Function * <B>rl_getc_function</B>
+<DD><A NAME="IDX102"></A>
+If non-zero, <CODE>readline</CODE> will call indirectly through this pointer
+to get a character from the input stream.  By default, it is set to
+<CODE>rl_getc</CODE>, the default <CODE>readline</CODE> character input function
+(see section <A HREF="readline.html#SEC31">Utility Functions</A>).
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> VFunction * <B>rl_redisplay_function</B>
+<DD><A NAME="IDX103"></A>
+If non-zero, <CODE>readline</CODE> will call indirectly through this pointer
+to update the display with the current contents of the editing buffer.
+By default, it is set to <CODE>rl_redisplay</CODE>, the default <CODE>readline</CODE>
+redisplay function (see section <A HREF="readline.html#SEC29">Redisplay</A>).
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Keymap <B>rl_executing_keymap</B>
+<DD><A NAME="IDX104"></A>
+This variable is set to the keymap (see section <A HREF="readline.html#SEC25">Selecting a Keymap</A>) in which the
+currently executing readline function was found.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Keymap <B>rl_binding_keymap</B>
+<DD><A NAME="IDX105"></A>
+This variable is set to the keymap (see section <A HREF="readline.html#SEC25">Selecting a Keymap</A>) in which the
+last key binding occurred.
+</DL>
+
+</P>
+
+
+<H2><A NAME="SEC23" HREF="readline_toc.html#TOC23">Readline Convenience Functions</A></H2>
+
+
+
+<H3><A NAME="SEC24" HREF="readline_toc.html#TOC24">Naming a Function</A></H3>
+
+<P>
+The user can dynamically change the bindings of keys while using
+Readline.  This is done by representing the function with a descriptive
+name.  The user is able to type the descriptive name when referring to
+the function.  Thus, in an init file, one might find
+
+</P>
+
+<PRE>
+Meta-Rubout:	backward-kill-word
+</PRE>
+
+<P>
+This binds the keystroke <KBD>Meta-Rubout</KBD> to the function
+<EM>descriptively</EM> named <CODE>backward-kill-word</CODE>.  You, as the
+programmer, should bind the functions you write to descriptive names as
+well.  Readline provides a function for doing that:
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_add_defun</B> <I>(char *name, Function *function, int key)</I>
+<DD><A NAME="IDX106"></A>
+Add <VAR>name</VAR> to the list of named functions.  Make <VAR>function</VAR> be
+the function that gets called.  If <VAR>key</VAR> is not -1, then bind it to
+<VAR>function</VAR> using <CODE>rl_bind_key ()</CODE>.
+</DL>
+
+</P>
+<P>
+Using this function alone is sufficient for most applications.  It is
+the recommended way to add a few functions to the default functions that
+Readline has built in.  If you need to do something other
+than adding a function to Readline, you may need to use the
+underlying functions described below.
+
+</P>
+
+
+<H3><A NAME="SEC25" HREF="readline_toc.html#TOC25">Selecting a Keymap</A></H3>
+
+<P>
+Key bindings take place on a <STRONG>keymap</STRONG>.  The keymap is the
+association between the keys that the user types and the functions that
+get run.  You can make your own keymaps, copy existing keymaps, and tell
+Readline which keymap to use.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> Keymap <B>rl_make_bare_keymap</B> <I>()</I>
+<DD><A NAME="IDX107"></A>
+Returns a new, empty keymap.  The space for the keymap is allocated with
+<CODE>malloc ()</CODE>; you should <CODE>free ()</CODE> it when you are done.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> Keymap <B>rl_copy_keymap</B> <I>(Keymap map)</I>
+<DD><A NAME="IDX108"></A>
+Return a new keymap which is a copy of <VAR>map</VAR>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> Keymap <B>rl_make_keymap</B> <I>()</I>
+<DD><A NAME="IDX109"></A>
+Return a new keymap with the printing characters bound to rl_insert,
+the lowercase Meta characters bound to run their equivalents, and
+the Meta digits bound to produce numeric arguments.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>rl_discard_keymap</B> <I>(Keymap keymap)</I>
+<DD><A NAME="IDX110"></A>
+Free the storage associated with <VAR>keymap</VAR>.
+</DL>
+
+</P>
+<P>
+Readline has several internal keymaps.  These functions allow you to
+change which keymap is active.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> Keymap <B>rl_get_keymap</B> <I>()</I>
+<DD><A NAME="IDX111"></A>
+Returns the currently active keymap.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>rl_set_keymap</B> <I>(Keymap keymap)</I>
+<DD><A NAME="IDX112"></A>
+Makes <VAR>keymap</VAR> the currently active keymap.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> Keymap <B>rl_get_keymap_by_name</B> <I>(char *name)</I>
+<DD><A NAME="IDX113"></A>
+Return the keymap matching <VAR>name</VAR>.  <VAR>name</VAR> is one which would
+be supplied in a <CODE>set keymap</CODE> inputrc line (@xref{Readline Init File}).
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char * <B>rl_get_keymap_name</B> <I>(Keymap keymap)</I>
+<DD><A NAME="IDX114"></A>
+Return the name matching <VAR>keymap</VAR>.  <VAR>name</VAR> is one which would
+be supplied in a <CODE>set keymap</CODE> inputrc line (@xref{Readline Init File}).
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC26" HREF="readline_toc.html#TOC26">Binding Keys</A></H3>
+
+<P>
+You associate keys with functions through the keymap.  Readline has
+several internal keymaps: <CODE>emacs_standard_keymap</CODE>,
+<CODE>emacs_meta_keymap</CODE>, <CODE>emacs_ctlx_keymap</CODE>,
+<CODE>vi_movement_keymap</CODE>, and <CODE>vi_insertion_keymap</CODE>.
+<CODE>emacs_standard_keymap</CODE> is the default, and the examples in
+this manual assume that.
+
+</P>
+<P>
+These functions manage key bindings.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_bind_key</B> <I>(int key, Function *function)</I>
+<DD><A NAME="IDX115"></A>
+Binds <VAR>key</VAR> to <VAR>function</VAR> in the currently active keymap.
+Returns non-zero in the case of an invalid <VAR>key</VAR>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_bind_key_in_map</B> <I>(int key, Function *function, Keymap map)</I>
+<DD><A NAME="IDX116"></A>
+Bind <VAR>key</VAR> to <VAR>function</VAR> in <VAR>map</VAR>.  Returns non-zero in the case
+of an invalid <VAR>key</VAR>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_unbind_key</B> <I>(int key)</I>
+<DD><A NAME="IDX117"></A>
+Bind <VAR>key</VAR> to the null function in the currently active keymap.
+Returns non-zero in case of error.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_unbind_key_in_map</B> <I>(int key, Keymap map)</I>
+<DD><A NAME="IDX118"></A>
+Bind <VAR>key</VAR> to the null function in <VAR>map</VAR>.
+Returns non-zero in case of error.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_generic_bind</B> <I>(int type, char *keyseq, char *data, Keymap map)</I>
+<DD><A NAME="IDX119"></A>
+Bind the key sequence represented by the string <VAR>keyseq</VAR> to the arbitrary
+pointer <VAR>data</VAR>.  <VAR>type</VAR> says what kind of data is pointed to by
+<VAR>data</VAR>; this can be a function (<CODE>ISFUNC</CODE>), a macro
+(<CODE>ISMACR</CODE>), or a keymap (<CODE>ISKMAP</CODE>).  This makes new keymaps as
+necessary.  The initial keymap in which to do bindings is <VAR>map</VAR>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_parse_and_bind</B> <I>(char *line)</I>
+<DD><A NAME="IDX120"></A>
+Parse <VAR>line</VAR> as if it had been read from the <CODE>inputrc</CODE> file and
+perform any key bindings and variable assignments found
+(@xref{Readline Init File}).
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_read_init_file</B> <I>(char *filename)</I>
+<DD><A NAME="IDX121"></A>
+Read keybindings and variable assignments from <VAR>filename</VAR>
+(@xref{Readline Init File}).
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC27" HREF="readline_toc.html#TOC27">Associating Function Names and Bindings</A></H3>
+
+<P>
+These functions allow you to find out what keys invoke named functions
+and the functions invoked by a particular key sequence.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> Function * <B>rl_named_function</B> <I>(char *name)</I>
+<DD><A NAME="IDX122"></A>
+Return the function with name <VAR>name</VAR>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> Function * <B>rl_function_of_keyseq</B> <I>(char *keyseq, Keymap map, int *type)</I>
+<DD><A NAME="IDX123"></A>
+Return the function invoked by <VAR>keyseq</VAR> in keymap <VAR>map</VAR>.
+If <VAR>map</VAR> is NULL, the current keymap is used.  If <VAR>type</VAR> is
+not NULL, the type of the object is returned in it (one of <CODE>ISFUNC</CODE>,
+<CODE>ISKMAP</CODE>, or <CODE>ISMACR</CODE>).
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char ** <B>rl_invoking_keyseqs</B> <I>(Function *function)</I>
+<DD><A NAME="IDX124"></A>
+Return an array of strings representing the key sequences used to
+invoke <VAR>function</VAR> in the current keymap.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char ** <B>rl_invoking_keyseqs_in_map</B> <I>(Function *function, Keymap map)</I>
+<DD><A NAME="IDX125"></A>
+Return an array of strings representing the key sequences used to
+invoke <VAR>function</VAR> in the keymap <VAR>map</VAR>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>rl_function_dumper</B> <I>(int readable)</I>
+<DD><A NAME="IDX126"></A>
+Print the readline function names and the key sequences currently
+bound to them to <CODE>rl_outstream</CODE>.  If <VAR>readable</VAR> is non-zero,
+the list is formatted in such a way that it can be made part of an
+<CODE>inputrc</CODE> file and re-read.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>rl_list_funmap_names</B> <I>()</I>
+<DD><A NAME="IDX127"></A>
+Print the names of all bindable Readline functions to <CODE>rl_outstream</CODE>.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC28" HREF="readline_toc.html#TOC28">Allowing Undoing</A></H3>
+
+<P>
+Supporting the undo command is a painless thing, and makes your
+functions much more useful.  It is certainly easy to try
+something if you know you can undo it.  I could use an undo function for
+the stock market.
+
+</P>
+<P>
+If your function simply inserts text once, or deletes text once, and
+uses <CODE>rl_insert_text ()</CODE> or <CODE>rl_delete_text ()</CODE> to do it, then
+undoing is already done for you automatically.
+
+</P>
+<P>
+If you do multiple insertions or multiple deletions, or any combination
+of these operations, you should group them together into one operation.
+This is done with <CODE>rl_begin_undo_group ()</CODE> and
+<CODE>rl_end_undo_group ()</CODE>.
+
+</P>
+<P>
+The types of events that can be undone are:
+
+</P>
+
+<PRE>
+enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END }; 
+</PRE>
+
+<P>
+Notice that <CODE>UNDO_DELETE</CODE> means to insert some text, and
+<CODE>UNDO_INSERT</CODE> means to delete some text.  That is, the undo code
+tells undo what to undo, not how to undo it.  <CODE>UNDO_BEGIN</CODE> and
+<CODE>UNDO_END</CODE> are tags added by <CODE>rl_begin_undo_group ()</CODE> and
+<CODE>rl_end_undo_group ()</CODE>.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_begin_undo_group</B> <I>()</I>
+<DD><A NAME="IDX128"></A>
+Begins saving undo information in a group construct.  The undo
+information usually comes from calls to <CODE>rl_insert_text ()</CODE> and
+<CODE>rl_delete_text ()</CODE>, but could be the result of calls to
+<CODE>rl_add_undo ()</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_end_undo_group</B> <I>()</I>
+<DD><A NAME="IDX129"></A>
+Closes the current undo group started with <CODE>rl_begin_undo_group
+()</CODE>.  There should be one call to <CODE>rl_end_undo_group ()</CODE>
+for each call to <CODE>rl_begin_undo_group ()</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>rl_add_undo</B> <I>(enum undo_code what, int start, int end, char *text)</I>
+<DD><A NAME="IDX130"></A>
+Remember how to undo an event (according to <VAR>what</VAR>).  The affected
+text runs from <VAR>start</VAR> to <VAR>end</VAR>, and encompasses <VAR>text</VAR>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>free_undo_list</B> <I>()</I>
+<DD><A NAME="IDX131"></A>
+Free the existing undo list.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_do_undo</B> <I>()</I>
+<DD><A NAME="IDX132"></A>
+Undo the first thing on the undo list.  Returns <CODE>0</CODE> if there was
+nothing to undo, non-zero if something was undone.
+</DL>
+
+</P>
+<P>
+Finally, if you neither insert nor delete text, but directly modify the
+existing text (e.g., change its case), call <CODE>rl_modifying ()</CODE>
+once, just before you modify the text.  You must supply the indices of
+the text range that you are going to modify.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_modifying</B> <I>(int start, int end)</I>
+<DD><A NAME="IDX133"></A>
+Tell Readline to save the text between <VAR>start</VAR> and <VAR>end</VAR> as a
+single undo unit.  It is assumed that you will subsequently modify
+that text.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC29" HREF="readline_toc.html#TOC29">Redisplay</A></H3>
+
+<P>
+<DL>
+<DT><U>Function:</U> void <B>rl_redisplay</B> <I>()</I>
+<DD><A NAME="IDX134"></A>
+Change what's displayed on the screen to reflect the current contents
+of <CODE>rl_line_buffer</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_forced_update_display</B> <I>()</I>
+<DD><A NAME="IDX135"></A>
+Force the line to be updated and redisplayed, whether or not
+Readline thinks the screen display is correct.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_on_new_line</B> <I>()</I>
+<DD><A NAME="IDX136"></A>
+Tell the update routines that we have moved onto a new (empty) line,
+usually after ouputting a newline.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_reset_line_state</B> <I>()</I>
+<DD><A NAME="IDX137"></A>
+Reset the display state to a clean state and redisplay the current line
+starting on a new line.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_message</B> <I>(va_alist)</I>
+<DD><A NAME="IDX138"></A>
+The arguments are a string as would be supplied to <CODE>printf</CODE>.  The
+resulting string is displayed in the <STRONG>echo area</STRONG>.  The echo area
+is also used to display numeric arguments and search strings.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_clear_message</B> <I>()</I>
+<DD><A NAME="IDX139"></A>
+Clear the message in the echo area.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC30" HREF="readline_toc.html#TOC30">Modifying Text</A></H3>
+
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_insert_text</B> <I>(char *text)</I>
+<DD><A NAME="IDX140"></A>
+Insert <VAR>text</VAR> into the line at the current cursor position.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_delete_text</B> <I>(int start, int end)</I>
+<DD><A NAME="IDX141"></A>
+Delete the text between <VAR>start</VAR> and <VAR>end</VAR> in the current line.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char * <B>rl_copy_text</B> <I>(int start, int end)</I>
+<DD><A NAME="IDX142"></A>
+Return a copy of the text between <VAR>start</VAR> and <VAR>end</VAR> in
+the current line.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_kill_text</B> <I>(int start, int end)</I>
+<DD><A NAME="IDX143"></A>
+Copy the text between <VAR>start</VAR> and <VAR>end</VAR> in the current line
+to the kill ring, appending or prepending to the last kill if the
+last command was a kill command.  The text is deleted.
+If <VAR>start</VAR> is less than <VAR>end</VAR>,
+the text is appended, otherwise prepended.  If the last command was
+not a kill, a new kill ring slot is used.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC31" HREF="readline_toc.html#TOC31">Utility Functions</A></H3>
+
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_read_key</B> <I>()</I>
+<DD><A NAME="IDX144"></A>
+Return the next character available.  This handles input inserted into
+the input stream via <VAR>pending input</VAR> (see section <A HREF="readline.html#SEC22">Readline Variables</A>)
+and <CODE>rl_stuff_char ()</CODE>, macros, and characters read from the keyboard.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_getc</B> <I>(FILE *)</I>
+<DD><A NAME="IDX145"></A>
+Return the next character available from the keyboard.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_stuff_char</B> <I>(int c)</I>
+<DD><A NAME="IDX146"></A>
+Insert <VAR>c</VAR> into the Readline input stream.  It will be "read"
+before Readline attempts to read characters from the terminal with
+<CODE>rl_read_key ()</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> rl_extend_line_buffer <B>(int</B> <I>len)</I>
+<DD><A NAME="IDX147"></A>
+Ensure that <CODE>rl_line_buffer</CODE> has enough space to hold <VAR>len</VAR>
+characters, possibly reallocating it if necessary.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_initialize</B> <I>()</I>
+<DD><A NAME="IDX148"></A>
+Initialize or re-initialize Readline's internal state.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_reset_terminal</B> <I>(char *terminal_name)</I>
+<DD><A NAME="IDX149"></A>
+Reinitialize Readline's idea of the terminal settings using
+<VAR>terminal_name</VAR> as the terminal type (e.g., <CODE>vt100</CODE>).
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>alphabetic</B> <I>(int c)</I>
+<DD><A NAME="IDX150"></A>
+Return 1 if <VAR>c</VAR> is an alphabetic character.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>numeric</B> <I>(int c)</I>
+<DD><A NAME="IDX151"></A>
+Return 1 if <VAR>c</VAR> is a numeric character.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>ding</B> <I>()</I>
+<DD><A NAME="IDX152"></A>
+Ring the terminal bell, obeying the setting of <CODE>bell-style</CODE>.
+</DL>
+
+</P>
+<P>
+The following are implemented as macros, defined in <CODE>chartypes.h</CODE>.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>uppercase_p</B> <I>(int c)</I>
+<DD><A NAME="IDX153"></A>
+Return 1 if <VAR>c</VAR> is an uppercase alphabetic character.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>lowercase_p</B> <I>(int c)</I>
+<DD><A NAME="IDX154"></A>
+Return 1 if <VAR>c</VAR> is a lowercase alphabetic character.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>digit_p</B> <I>(int c)</I>
+<DD><A NAME="IDX155"></A>
+Return 1 if <VAR>c</VAR> is a numeric character.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>to_upper</B> <I>(int c)</I>
+<DD><A NAME="IDX156"></A>
+If <VAR>c</VAR> is a lowercase alphabetic character, return the corresponding
+uppercase character.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>to_lower</B> <I>(int c)</I>
+<DD><A NAME="IDX157"></A>
+If <VAR>c</VAR> is an uppercase alphabetic character, return the corresponding
+lowercase character.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>digit_value</B> <I>(int c)</I>
+<DD><A NAME="IDX158"></A>
+If <VAR>c</VAR> is a number, return the value it represents.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC32" HREF="readline_toc.html#TOC32">Alternate Interface</A></H3>
+
+<P>
+An alternate interface is available to plain <CODE>readline()</CODE>.  Some
+applications need to interleave keyboard I/O with file, device, or
+window system I/O, typically by using a main loop to <CODE>select()</CODE>
+on various file descriptors.  To accomodate this need, readline can
+also be invoked as a `callback' function from an event loop.  There
+are functions available to make this easy.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>rl_callback_handler_install</B> <I>(char *prompt, Vfunction *lhandler)</I>
+<DD><A NAME="IDX159"></A>
+Set up the terminal for readline I/O and display the initial
+expanded value of <VAR>prompt</VAR>.  Save the value of <VAR>lhandler</VAR> to
+use as a callback when a complete line of input has been entered.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>rl_callback_read_char</B> <I>()</I>
+<DD><A NAME="IDX160"></A>
+Whenever an application determines that keyboard input is available, it
+should call <CODE>rl_callback_read_char()</CODE>, which will read the next
+character from the current input source.  If that character completes the
+line, <CODE>rl_callback_read_char</CODE> will invoke the <VAR>lhandler</VAR>
+function saved by <CODE>rl_callback_handler_install</CODE> to process the
+line.  <CODE>EOF</CODE> is  indicated by calling <VAR>lhandler</VAR> with a
+<CODE>NULL</CODE> line.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> void <B>rl_callback_handler_remove</B> <I>()</I>
+<DD><A NAME="IDX161"></A>
+Restore the terminal to its initial state and remove the line handler.
+This may be called from within a callback as well as independently.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC33" HREF="readline_toc.html#TOC33">An Example</A></H3>
+
+<P>
+Here is a function which changes lowercase characters to their uppercase
+equivalents, and uppercase characters to lowercase.  If
+this function was bound to <SAMP>`M-c'</SAMP>, then typing <SAMP>`M-c'</SAMP> would
+change the case of the character under point.  Typing <SAMP>`M-1 0 M-c'</SAMP>
+would change the case of the following 10 characters, leaving the cursor on
+the last character changed.
+
+</P>
+
+<PRE>
+/* Invert the case of the COUNT following characters. */
+int
+invert_case_line (count, key)
+     int count, key;
+{
+  register int start, end, i;
+
+  start = rl_point;
+
+  if (rl_point &#62;= rl_end)
+    return (0);
+
+  if (count &#60; 0)
+    {
+      direction = -1;
+      count = -count;
+    }
+  else
+    direction = 1;
+      
+  /* Find the end of the range to modify. */
+  end = start + (count * direction);
+
+  /* Force it to be within range. */
+  if (end &#62; rl_end)
+    end = rl_end;
+  else if (end &#60; 0)
+    end = 0;
+
+  if (start == end)
+    return (0);
+
+  if (start &#62; end)
+    {
+      int temp = start;
+      start = end;
+      end = temp;
+    }
+
+  /* Tell readline that we are modifying the line, so it will save
+     the undo information. */
+  rl_modifying (start, end);
+
+  for (i = start; i != end; i++)
+    {
+      if (uppercase_p (rl_line_buffer[i]))
+        rl_line_buffer[i] = to_lower (rl_line_buffer[i]);
+      else if (lowercase_p (rl_line_buffer[i]))
+        rl_line_buffer[i] = to_upper (rl_line_buffer[i]);
+    }
+  /* Move point to on top of the last character changed. */
+  rl_point = (direction == 1) ? end - 1 : start;
+  return (0);
+}
+</PRE>
+
+
+
+<H2><A NAME="SEC34" HREF="readline_toc.html#TOC34">Custom Completers</A></H2>
+
+<P>
+Typically, a program that reads commands from the user has a way of
+disambiguating commands and data.  If your program is one of these, then
+it can provide completion for commands, data, or both.
+The following sections describe how your program and Readline
+cooperate to provide this service.
+
+</P>
+
+
+
+<H3><A NAME="SEC35" HREF="readline_toc.html#TOC35">How Completing Works</A></H3>
+
+<P>
+In order to complete some text, the full list of possible completions
+must be available.  That is, it is not possible to accurately
+expand a partial word without knowing all of the possible words
+which make sense in that context.  The Readline library provides
+the user interface to completion, and two of the most common
+completion functions:  filename and username.  For completing other types
+of text, you must write your own completion function.  This section
+describes exactly what such functions must do, and provides an example.
+
+</P>
+<P>
+There are three major functions used to perform completion:
+
+</P>
+
+<OL>
+<LI>
+
+The user-interface function <CODE>rl_complete ()</CODE>.  This function is
+called with the same arguments as other Readline
+functions intended for interactive use:  <VAR>count</VAR> and
+<VAR>invoking_key</VAR>.  It isolates the word to be completed and calls
+<CODE>completion_matches ()</CODE> to generate a list of possible completions.
+It then either lists the possible completions, inserts the possible
+completions, or actually performs the
+completion, depending on which behavior is desired.
+
+<LI>
+
+The internal function <CODE>completion_matches ()</CODE> uses your
+<STRONG>generator</STRONG> function to generate the list of possible matches, and
+then returns the array of these matches.  You should place the address
+of your generator function in <CODE>rl_completion_entry_function</CODE>.
+
+<LI>
+
+The generator function is called repeatedly from
+<CODE>completion_matches ()</CODE>, returning a string each time.  The
+arguments to the generator function are <VAR>text</VAR> and <VAR>state</VAR>.
+<VAR>text</VAR> is the partial word to be completed.  <VAR>state</VAR> is zero the
+first time the function is called, allowing the generator to perform
+any necessary initialization, and a positive non-zero integer for
+each subsequent call.  When the generator function returns
+<CODE>(char *)NULL</CODE> this signals <CODE>completion_matches ()</CODE> that there are
+no more possibilities left.  Usually the generator function computes the
+list of possible completions when <VAR>state</VAR> is zero, and returns them
+one at a time on subsequent calls.  Each string the generator function
+returns as a match must be allocated with <CODE>malloc()</CODE>; Readline
+frees the strings when it has finished with them.
+
+</OL>
+
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_complete</B> <I>(int ignore, int invoking_key)</I>
+<DD><A NAME="IDX162"></A>
+Complete the word at or before point.  You have supplied the function
+that does the initial simple matching selection algorithm (see
+<CODE>completion_matches ()</CODE>).  The default is to do filename completion.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Function * <B>rl_completion_entry_function</B>
+<DD><A NAME="IDX163"></A>
+This is a pointer to the generator function for <CODE>completion_matches
+()</CODE>.  If the value of <CODE>rl_completion_entry_function</CODE> is
+<CODE>(Function *)NULL</CODE> then the default filename generator function,
+<CODE>filename_completion_function ()</CODE>, is used.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC36" HREF="readline_toc.html#TOC36">Completion Functions</A></H3>
+
+<P>
+Here is the complete list of callable completion functions present in
+Readline.
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_complete_internal</B> <I>(int what_to_do)</I>
+<DD><A NAME="IDX164"></A>
+Complete the word at or before point.  <VAR>what_to_do</VAR> says what to do
+with the completion.  A value of <SAMP>`?'</SAMP> means list the possible
+completions.  <SAMP>`TAB'</SAMP> means do standard completion.  <SAMP>`*'</SAMP> means
+insert all of the possible completions.  <SAMP>`!'</SAMP> means to display
+all of the possible completions, if there is more than one, as well as
+performing partial completion.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_complete</B> <I>(int ignore, int invoking_key)</I>
+<DD><A NAME="IDX165"></A>
+Complete the word at or before point.  You have supplied the function
+that does the initial simple matching selection algorithm (see
+<CODE>completion_matches ()</CODE> and <CODE>rl_completion_entry_function</CODE>).
+The default is to do filename
+completion.  This calls <CODE>rl_complete_internal ()</CODE> with an
+argument depending on <VAR>invoking_key</VAR>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_possible_completions</B> <I>(int count, int invoking_key))</I>
+<DD><A NAME="IDX166"></A>
+List the possible completions.  See description of <CODE>rl_complete
+()</CODE>.  This calls <CODE>rl_complete_internal ()</CODE> with an argument of
+<SAMP>`?'</SAMP>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> int <B>rl_insert_completions</B> <I>(int count, int invoking_key))</I>
+<DD><A NAME="IDX167"></A>
+Insert the list of possible completions into the line, deleting the
+partially-completed word.  See description of <CODE>rl_complete ()</CODE>.
+This calls <CODE>rl_complete_internal ()</CODE> with an argument of <SAMP>`*'</SAMP>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char ** <B>completion_matches</B> <I>(char *text, CPFunction *entry_func)</I>
+<DD><A NAME="IDX168"></A>
+Returns an array of <CODE>(char *)</CODE> which is a list of completions for
+<VAR>text</VAR>.  If there are no completions, returns <CODE>(char **)NULL</CODE>.
+The first entry in the returned array is the substitution for <VAR>text</VAR>.
+The remaining entries are the possible completions.  The array is
+terminated with a <CODE>NULL</CODE> pointer.
+
+</P>
+<P>
+<VAR>entry_func</VAR> is a function of two args, and returns a
+<CODE>(char *)</CODE>.  The first argument is <VAR>text</VAR>.  The second is a
+state argument; it is zero on the first call, and non-zero on subsequent
+calls.  <VAR>entry_func</VAR> returns a <CODE>NULL</CODE>  pointer to the caller
+when there are no more matches.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char * <B>filename_completion_function</B> <I>(char *text, int state)</I>
+<DD><A NAME="IDX169"></A>
+A generator function for filename completion in the general case.  Note
+that completion in Bash is a little different because of all
+the pathnames that must be followed when looking up completions for a
+command.  The Bash source is a useful reference for writing custom
+completion functions.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Function:</U> char * <B>username_completion_function</B> <I>(char *text, int state)</I>
+<DD><A NAME="IDX170"></A>
+A completion generator for usernames.  <VAR>text</VAR> contains a partial
+username preceded by a random character (usually <SAMP>`~'</SAMP>).  As with all
+completion generators, <VAR>state</VAR> is zero on the first call and non-zero
+for subsequent calls.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC37" HREF="readline_toc.html#TOC37">Completion Variables</A></H3>
+
+<P>
+<DL>
+<DT><U>Variable:</U> Function * <B>rl_completion_entry_function</B>
+<DD><A NAME="IDX171"></A>
+A pointer to the generator function for <CODE>completion_matches ()</CODE>.
+<CODE>NULL</CODE> means to use <CODE>filename_entry_function ()</CODE>, the default
+filename completer.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> CPPFunction * <B>rl_attempted_completion_function</B>
+<DD><A NAME="IDX172"></A>
+A pointer to an alternative function to create matches.
+The function is called with <VAR>text</VAR>, <VAR>start</VAR>, and <VAR>end</VAR>.
+<VAR>start</VAR> and <VAR>end</VAR> are indices in <CODE>rl_line_buffer</CODE> saying
+what the boundaries of <VAR>text</VAR> are.  If this function exists and
+returns <CODE>NULL</CODE>, or if this variable is set to <CODE>NULL</CODE>, then
+<CODE>rl_complete ()</CODE> will call the value of
+<CODE>rl_completion_entry_function</CODE> to generate matches, otherwise the
+array of strings returned will be used.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> CPFunction * <B>rl_filename_quoting_function</B>
+<DD><A NAME="IDX173"></A>
+A pointer to a function that will quote a filename in an application-
+specific fashion.  This is called if filename completion is being
+attempted and one of the characters in <CODE>rl_filename_quote_characters</CODE>
+appears in a completed filename.  The function is called with
+<VAR>text</VAR>, <VAR>match_type</VAR>, and <VAR>quote_pointer</VAR>.  The <VAR>text</VAR>
+is the filename to be quoted.  The <VAR>match_type</VAR> is either
+<CODE>SINGLE_MATCH</CODE>, if there is only one completion match, or
+<CODE>MULT_MATCH</CODE>.  Some functions use this to decide whether or not to
+insert a closing quote character.  The <VAR>quote_pointer</VAR> is a pointer
+to any opening quote character the user typed.  Some functions choose
+to reset this character.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> CPFunction * <B>rl_filename_dequoting_function</B>
+<DD><A NAME="IDX174"></A>
+A pointer to a function that will remove application-specific quoting
+characters from a filename before completion is attempted, so those
+characters do not interfere with matching the text against names in
+the filesystem.  It is called with <VAR>text</VAR>, the text of the word
+to be dequoted, and <VAR>quote_char</VAR>, which is the quoting character 
+that delimits the filename (usually <SAMP>`''</SAMP> or <SAMP>`"'</SAMP>).  If
+<VAR>quote_char</VAR> is zero, the filename was not in an embedded string.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Function * <B>rl_char_is_quoted_p</B>
+<DD><A NAME="IDX175"></A>
+A pointer to a function to call that determines whether or not a specific
+character in the line buffer is quoted, according to whatever quoting
+mechanism the program calling readline uses.  The function is called with
+two arguments: <VAR>text</VAR>, the text of the line, and <VAR>index</VAR>, the
+index of the character in the line.  It is used to decide whether a
+character found in <CODE>rl_completer_word_break_characters</CODE> should be
+used to break words for the completer.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_completion_query_items</B>
+<DD><A NAME="IDX176"></A>
+Up to this many items will be displayed in response to a
+possible-completions call.  After that, we ask the user if she is sure
+she wants to see them all.  The default value is 100.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_basic_word_break_characters</B>
+<DD><A NAME="IDX177"></A>
+The basic list of characters that signal a break between words for the
+completer routine.  The default value of this variable is the characters
+which break words for completion in Bash, i.e.,
+<CODE>" \t\n\"\\'`@$&#62;&#60;=;|&#38;{("</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_basic_quote_characters</B>
+<DD><A NAME="IDX178"></A>
+List of quote characters which can cause a word break.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_completer_word_break_characters</B>
+<DD><A NAME="IDX179"></A>
+The list of characters that signal a break between words for
+<CODE>rl_complete_internal ()</CODE>.  The default list is the value of
+<CODE>rl_basic_word_break_characters</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_completer_quote_characters</B>
+<DD><A NAME="IDX180"></A>
+List of characters which can be used to quote a substring of the line.
+Completion occurs on the entire substring, and within the substring
+<CODE>rl_completer_word_break_characters</CODE> are treated as any other character,
+unless they also appear within this list.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_filename_quote_characters</B>
+<DD><A NAME="IDX181"></A>
+A list of characters that cause a filename to be quoted by the completer
+when they appear in a completed filename.  The default is empty.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> char * <B>rl_special_prefixes</B>
+<DD><A NAME="IDX182"></A>
+The list of characters that are word break characters, but should be
+left in <VAR>text</VAR> when it is passed to the completion function.
+Programs can use this to help determine what kind of completing to do.
+For instance, Bash sets this variable to "$@" so that it can complete
+shell variables and hostnames.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_completion_append_character</B>
+<DD><A NAME="IDX183"></A>
+When a single completion alternative matches at the end of the command
+line, this character is appended to the inserted completion text.  The
+default is a space character (<SAMP>` '</SAMP>).  Setting this to the null
+character (<SAMP>`\0'</SAMP>) prevents anything being appended automatically.
+This can be changed in custom completion functions to
+provide the "most sensible word separator character" according to
+an application-specific command line syntax specification.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_ignore_completion_duplicates</B>
+<DD><A NAME="IDX184"></A>
+If non-zero, then disallow duplicates in the matches.  Default is 1.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_filename_completion_desired</B>
+<DD><A NAME="IDX185"></A>
+Non-zero means that the results of the matches are to be treated as
+filenames.  This is <EM>always</EM> zero on entry, and can only be changed
+within a completion entry generator function.  If it is set to a non-zero
+value, directory names have a slash appended and Readline attempts to
+quote completed filenames if they contain any embedded word break
+characters.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_filename_quoting_desired</B>
+<DD><A NAME="IDX186"></A>
+Non-zero means that the results of the matches are to be quoted using
+double quotes (or an application-specific quoting mechanism) if the
+completed filename contains any characters in
+<CODE>rl_filename_quote_chars</CODE>.  This is <EM>always</EM> non-zero
+on entry, and can only be changed within a completion entry generator
+function.  The quoting is effected via a call to the function pointed to
+by <CODE>rl_filename_quoting_function</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> int <B>rl_inhibit_completion</B>
+<DD><A NAME="IDX187"></A>
+If this variable is non-zero, completion is inhibit&#60;ed.  The completion
+character will be inserted as any other bound to <CODE>self-insert</CODE>.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Function * <B>rl_ignore_some_completions_function</B>
+<DD><A NAME="IDX188"></A>
+This function, if defined, is called by the completer when real filename
+completion is done, after all the matching names have been generated.
+It is passed a <CODE>NULL</CODE> terminated array of matches.
+The first element (<CODE>matches[0]</CODE>) is the
+maximal substring common to all matches. This function can
+re-arrange the list of matches as required, but each element deleted
+from the array must be freed.
+</DL>
+
+</P>
+<P>
+<DL>
+<DT><U>Variable:</U> Function * <B>rl_directory_completion_hook</B>
+<DD><A NAME="IDX189"></A>
+This function, if defined, is allowed to modify the directory portion
+of filenames Readline completes.  It is called with the address of a
+string (the current directory name) as an argument.  It could be used
+to expand symbolic links or shell variables in pathnames.
+</DL>
+
+</P>
+
+
+<H3><A NAME="SEC38" HREF="readline_toc.html#TOC38">A Short Completion Example</A></H3>
+
+<P>
+Here is a small application demonstrating the use of the GNU Readline
+library.  It is called <CODE>fileman</CODE>, and the source code resides in
+<TT>`examples/fileman.c'</TT>.  This sample application provides
+completion of command names, line editing features, and access to the
+history list.
+
+</P>
+
+<PRE>
+/* fileman.c -- A tiny application which demonstrates how to use the
+   GNU Readline library.  This application interactively allows users
+   to manipulate files and their modes. */
+
+#include &#60;stdio.h&#62;
+#include &#60;sys/types.h&#62;
+#include &#60;sys/file.h&#62;
+#include &#60;sys/stat.h&#62;
+#include &#60;sys/errno.h&#62;
+
+#include &#60;readline/readline.h&#62;
+#include &#60;readline/history.h&#62;
+
+extern char *getwd ();
+extern char *xmalloc ();
+
+/* The names of functions that actually do the manipulation. */
+int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
+int com_delete (), com_help (), com_cd (), com_quit ();
+
+/* A structure which contains information on the commands this program
+   can understand. */
+
+typedef struct {
+  char *name;			/* User printable name of the function. */
+  Function *func;		/* Function to call to do the job. */
+  char *doc;			/* Documentation for this function.  */
+} COMMAND;
+
+COMMAND commands[] = {
+  { "cd", com_cd, "Change to directory DIR" },
+  { "delete", com_delete, "Delete FILE" },
+  { "help", com_help, "Display this text" },
+  { "?", com_help, "Synonym for `help'" },
+  { "list", com_list, "List files in DIR" },
+  { "ls", com_list, "Synonym for `list'" },
+  { "pwd", com_pwd, "Print the current working directory" },
+  { "quit", com_quit, "Quit using Fileman" },
+  { "rename", com_rename, "Rename FILE to NEWNAME" },
+  { "stat", com_stat, "Print out statistics on FILE" },
+  { "view", com_view, "View the contents of FILE" },
+  { (char *)NULL, (Function *)NULL, (char *)NULL }
+};
+
+/* Forward declarations. */
+char *stripwhite ();
+COMMAND *find_command ();
+
+/* The name of this program, as taken from argv[0]. */
+char *progname;
+
+/* When non-zero, this global means the user is done using this program. */
+int done;
+
+char *
+dupstr (s)
+     int s;
+{
+  char *r;
+
+  r = xmalloc (strlen (s) + 1);
+  strcpy (r, s);
+  return (r);
+}
+
+main (argc, argv)
+     int argc;
+     char **argv;
+{
+  char *line, *s;
+
+  progname = argv[0];
+
+  initialize_readline ();	/* Bind our completer. */
+
+  /* Loop reading and executing lines until the user quits. */
+  for ( ; done == 0; )
+    {
+      line = readline ("FileMan: ");
+
+      if (!line)
+        break;
+
+      /* Remove leading and trailing whitespace from the line.
+         Then, if there is anything left, add it to the history list
+         and execute it. */
+      s = stripwhite (line);
+
+      if (*s)
+        {
+          add_history (s);
+          execute_line (s);
+        }
+
+      free (line);
+    }
+  exit (0);
+}
+
+/* Execute a command line. */
+int
+execute_line (line)
+     char *line;
+{
+  register int i;
+  COMMAND *command;
+  char *word;
+
+  /* Isolate the command word. */
+  i = 0;
+  while (line[i] &#38;&#38; whitespace (line[i]))
+    i++;
+  word = line + i;
+
+  while (line[i] &#38;&#38; !whitespace (line[i]))
+    i++;
+
+  if (line[i])
+    line[i++] = '\0';
+
+  command = find_command (word);
+
+  if (!command)
+    {
+      fprintf (stderr, "%s: No such command for FileMan.\n", word);
+      return (-1);
+    }
+
+  /* Get argument to command, if any. */
+  while (whitespace (line[i]))
+    i++;
+
+  word = line + i;
+
+  /* Call the function. */
+  return ((*(command-&#62;func)) (word));
+}
+
+/* Look up NAME as the name of a command, and return a pointer to that
+   command.  Return a NULL pointer if NAME isn't a command name. */
+COMMAND *
+find_command (name)
+     char *name;
+{
+  register int i;
+
+  for (i = 0; commands[i].name; i++)
+    if (strcmp (name, commands[i].name) == 0)
+      return (&#38;commands[i]);
+
+  return ((COMMAND *)NULL);
+}
+
+/* Strip whitespace from the start and end of STRING.  Return a pointer
+   into STRING. */
+char *
+stripwhite (string)
+     char *string;
+{
+  register char *s, *t;
+
+  for (s = string; whitespace (*s); s++)
+    ;
+    
+  if (*s == 0)
+    return (s);
+
+  t = s + strlen (s) - 1;
+  while (t &#62; s &#38;&#38; whitespace (*t))
+    t--;
+  *++t = '\0';
+
+  return s;
+}
+
+/* **************************************************************** */
+/*                                                                  */
+/*                  Interface to Readline Completion                */
+/*                                                                  */
+/* **************************************************************** */
+
+char *command_generator ();
+char **fileman_completion ();
+
+/* Tell the GNU Readline library how to complete.  We want to try to complete
+   on command names if this is the first word in the line, or on filenames
+   if not. */
+initialize_readline ()
+{
+  /* Allow conditional parsing of the ~/.inputrc file. */
+  rl_readline_name = "FileMan";
+
+  /* Tell the completer that we want a crack first. */
+  rl_attempted_completion_function = (CPPFunction *)fileman_completion;
+}
+
+/* Attempt to complete on the contents of TEXT.  START and END bound the
+   region of rl_line_buffer that contains the word to complete.  TEXT is
+   the word to complete.  We can use the entire contents of rl_line_buffer
+   in case we want to do some simple parsing.  Return the array of matches,
+   or NULL if there aren't any. */
+char **
+fileman_completion (text, start, end)
+     char *text;
+     int start, end;
+{
+  char **matches;
+
+  matches = (char **)NULL;
+
+  /* If this word is at the start of the line, then it is a command
+     to complete.  Otherwise it is the name of a file in the current
+     directory. */
+  if (start == 0)
+    matches = completion_matches (text, command_generator);
+
+  return (matches);
+}
+
+/* Generator function for command completion.  STATE lets us know whether
+   to start from scratch; without any state (i.e. STATE == 0), then we
+   start at the top of the list. */
+char *
+command_generator (text, state)
+     char *text;
+     int state;
+{
+  static int list_index, len;
+  char *name;
+
+  /* If this is a new word to complete, initialize now.  This includes
+     saving the length of TEXT for efficiency, and initializing the index
+     variable to 0. */
+  if (!state)
+    {
+      list_index = 0;
+      len = strlen (text);
+    }
+
+  /* Return the next name which partially matches from the command list. */
+  while (name = commands[list_index].name)
+    {
+      list_index++;
+
+      if (strncmp (name, text, len) == 0)
+        return (dupstr(name));
+    }
+
+  /* If no names matched, then return NULL. */
+  return ((char *)NULL);
+}
+
+/* **************************************************************** */
+/*                                                                  */
+/*                       FileMan Commands                           */
+/*                                                                  */
+/* **************************************************************** */
+
+/* String to pass to system ().  This is for the LIST, VIEW and RENAME
+   commands. */
+static char syscom[1024];
+
+/* List the file(s) named in arg. */
+com_list (arg)
+     char *arg;
+{
+  if (!arg)
+    arg = "";
+
+  sprintf (syscom, "ls -FClg %s", arg);
+  return (system (syscom));
+}
+
+com_view (arg)
+     char *arg;
+{
+  if (!valid_argument ("view", arg))
+    return 1;
+
+  sprintf (syscom, "more %s", arg);
+  return (system (syscom));
+}
+
+com_rename (arg)
+     char *arg;
+{
+  too_dangerous ("rename");
+  return (1);
+}
+
+com_stat (arg)
+     char *arg;
+{
+  struct stat finfo;
+
+  if (!valid_argument ("stat", arg))
+    return (1);
+
+  if (stat (arg, &#38;finfo) == -1)
+    {
+      perror (arg);
+      return (1);
+    }
+
+  printf ("Statistics for `%s':\n", arg);
+
+  printf ("%s has %d link%s, and is %d byte%s in length.\n", arg,
+          finfo.st_nlink,
+          (finfo.st_nlink == 1) ? "" : "s",
+          finfo.st_size,
+          (finfo.st_size == 1) ? "" : "s");
+  printf ("Inode Last Change at: %s", ctime (&#38;finfo.st_ctime));
+  printf ("      Last access at: %s", ctime (&#38;finfo.st_atime));
+  printf ("    Last modified at: %s", ctime (&#38;finfo.st_mtime));
+  return (0);
+}
+
+com_delete (arg)
+     char *arg;
+{
+  too_dangerous ("delete");
+  return (1);
+}
+
+/* Print out help for ARG, or for all of the commands if ARG is
+   not present. */
+com_help (arg)
+     char *arg;
+{
+  register int i;
+  int printed = 0;
+
+  for (i = 0; commands[i].name; i++)
+    {
+      if (!*arg || (strcmp (arg, commands[i].name) == 0))
+        {
+          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
+          printed++;
+        }
+    }
+
+  if (!printed)
+    {
+      printf ("No commands match `%s'.  Possibilties are:\n", arg);
+
+      for (i = 0; commands[i].name; i++)
+        {
+          /* Print in six columns. */
+          if (printed == 6)
+            {
+              printed = 0;
+              printf ("\n");
+            }
+
+          printf ("%s\t", commands[i].name);
+          printed++;
+        }
+
+      if (printed)
+        printf ("\n");
+    }
+  return (0);
+}
+
+/* Change to the directory ARG. */
+com_cd (arg)
+     char *arg;
+{
+  if (chdir (arg) == -1)
+    {
+      perror (arg);
+      return 1;
+    }
+
+  com_pwd ("");
+  return (0);
+}
+
+/* Print out the current working directory. */
+com_pwd (ignore)
+     char *ignore;
+{
+  char dir[1024], *s;
+
+  s = getwd (dir);
+  if (s == 0)
+    {
+      printf ("Error getting pwd: %s\n", dir);
+      return 1;
+    }
+
+  printf ("Current directory is %s\n", dir);
+  return 0;
+}
+
+/* The user wishes to quit using this program.  Just set DONE non-zero. */
+com_quit (arg)
+     char *arg;
+{
+  done = 1;
+  return (0);
+}
+
+/* Function which tells you that you can't do this. */
+too_dangerous (caller)
+     char *caller;
+{
+  fprintf (stderr,
+           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
+           caller);
+}
+
+/* Return non-zero if ARG is a valid argument for CALLER, else print
+   an error message and return zero. */
+int
+valid_argument (caller, arg)
+     char *caller, *arg;
+{
+  if (!arg || !*arg)
+    {
+      fprintf (stderr, "%s: Argument required.\n", caller);
+      return (0);
+    }
+
+  return (1);
+}
+</PRE>
+
+
+
+<H1><A NAME="SEC39" HREF="readline_toc.html#TOC39">Concept Index</A></H1>
+<P>
+<H2>i</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX1">interaction, readline</A>
+</DIR>
+<H2>r</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX87">readline, function</A>
+</DIR>
+
+</P>
+
+
+<H1><A NAME="SEC40" HREF="readline_toc.html#TOC40">Function and Variable Index</A></H1>
+<P>
+<H2>(</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX147">(int</A>
+</DIR>
+<H2>a</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX72">abort (C-g)</A>
+<LI><A HREF="readline.html#IDX26">accept-line (Newline, Return)</A>
+<LI><A HREF="readline.html#IDX150">alphabetic</A>
+</DIR>
+<H2>b</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX21">backward-char (C-b)</A>
+<LI><A HREF="readline.html#IDX40">backward-delete-char (Rubout)</A>
+<LI><A HREF="readline.html#IDX50">backward-kill-line (C-x Rubout)</A>
+<LI><A HREF="readline.html#IDX54">backward-kill-word (M-DEL)</A>
+<LI><A HREF="readline.html#IDX23">backward-word (M-b)</A>
+<LI><A HREF="readline.html#IDX29">beginning-of-history (M-&#38;#60;)</A>
+<LI><A HREF="readline.html#IDX18">beginning-of-line (C-a)</A>
+<LI><A HREF="readline.html#IDX2">bell-style</A>
+</DIR>
+<H2>c</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX70">call-last-kbd-macro (C-x e)</A>
+<LI><A HREF="readline.html#IDX48">capitalize-word (M-c)</A>
+<LI><A HREF="readline.html#IDX80">character-search (C-])</A>
+<LI><A HREF="readline.html#IDX81">character-search-backward (M-C-])</A>
+<LI><A HREF="readline.html#IDX24">clear-screen (C-l)</A>
+<LI><A HREF="readline.html#IDX3">comment-begin</A>
+<LI><A HREF="readline.html#IDX65">complete (TAB)</A>
+<LI><A HREF="readline.html#IDX4">completion-query-items</A>
+<LI><A HREF="readline.html#IDX168">completion_matches</A>
+<LI><A HREF="readline.html#IDX5">convert-meta</A>
+<LI><A HREF="readline.html#IDX59">copy-backward-word ()</A>
+<LI><A HREF="readline.html#IDX60">copy-forward-word ()</A>
+<LI><A HREF="readline.html#IDX58">copy-region-as-kill ()</A>
+</DIR>
+<H2>d</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX39">delete-char (C-d)</A>
+<LI><A HREF="readline.html#IDX56">delete-horizontal-space ()</A>
+<LI><A HREF="readline.html#IDX63">digit-argument (M-0, M-1, ... M--)</A>
+<LI><A HREF="readline.html#IDX155">digit_p</A>
+<LI><A HREF="readline.html#IDX158">digit_value</A>
+<LI><A HREF="readline.html#IDX152">ding</A>
+<LI><A HREF="readline.html#IDX6">disable-completion</A>
+<LI><A HREF="readline.html#IDX73">do-uppercase-version (M-a, M-b, M-<VAR>x</VAR>, ...)</A>
+<LI><A HREF="readline.html#IDX47">downcase-word (M-l)</A>
+<LI><A HREF="readline.html#IDX83">dump-functions ()</A>
+<LI><A HREF="readline.html#IDX85">dump-macros ()</A>
+<LI><A HREF="readline.html#IDX84">dump-variables ()</A>
+</DIR>
+<H2>e</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX7">editing-mode</A>
+<LI><A HREF="readline.html#IDX8">enable-keypad</A>
+<LI><A HREF="readline.html#IDX69">end-kbd-macro (C-x ))</A>
+<LI><A HREF="readline.html#IDX30">end-of-history (M-&#38;#62;)</A>
+<LI><A HREF="readline.html#IDX19">end-of-line (C-e)</A>
+<LI><A HREF="readline.html#IDX79">exchange-point-and-mark (C-x C-x)</A>
+<LI><A HREF="readline.html#IDX9">expand-tilde</A>
+</DIR>
+<H2>f</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX169">filename_completion_function</A>
+<LI><A HREF="readline.html#IDX20">forward-char (C-f)</A>
+<LI><A HREF="readline.html#IDX32">forward-search-history (C-s)</A>
+<LI><A HREF="readline.html#IDX22">forward-word (M-f)</A>
+<LI><A HREF="readline.html#IDX131">free_undo_list</A>
+</DIR>
+<H2>h</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX36">history-search-backward ()</A>
+<LI><A HREF="readline.html#IDX35">history-search-forward ()</A>
+<LI><A HREF="readline.html#IDX10">horizontal-scroll-mode</A>
+</DIR>
+<H2>i</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX13">input-meta</A>
+<LI><A HREF="readline.html#IDX82">insert-comment (M-#)</A>
+<LI><A HREF="readline.html#IDX67">insert-completions (M-*)</A>
+</DIR>
+<H2>k</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX11">keymap</A>
+<LI><A HREF="readline.html#IDX49">kill-line (C-k)</A>
+<LI><A HREF="readline.html#IDX57">kill-region ()</A>
+<LI><A HREF="readline.html#IDX52">kill-whole-line ()</A>
+<LI><A HREF="readline.html#IDX53">kill-word (M-d)</A>
+</DIR>
+<H2>l</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX154">lowercase_p</A>
+</DIR>
+<H2>m</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX12">mark-modified-lines</A>
+<LI><A HREF="readline.html#IDX14">meta-flag</A>
+</DIR>
+<H2>n</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX28">next-history (C-n)</A>
+<LI><A HREF="readline.html#IDX34">non-incremental-forward-search-history (M-n)</A>
+<LI><A HREF="readline.html#IDX33">non-incremental-reverse-search-history (M-p)</A>
+<LI><A HREF="readline.html#IDX151">numeric</A>
+</DIR>
+<H2>o</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX15">output-meta</A>
+</DIR>
+<H2>p</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX66">possible-completions (M-?)</A>
+<LI><A HREF="readline.html#IDX74">prefix-meta (ESC)</A>
+<LI><A HREF="readline.html#IDX27">previous-history (C-p)</A>
+</DIR>
+<H2>q</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX41">quoted-insert (C-q, C-v)</A>
+</DIR>
+<H2>r</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX71">re-read-init-file (C-x C-r)</A>
+<LI><A HREF="readline.html#IDX86">readline</A>
+<LI><A HREF="readline.html#IDX25">redraw-current-line ()</A>
+<LI><A HREF="readline.html#IDX31">reverse-search-history (C-r)</A>
+<LI><A HREF="readline.html#IDX76">revert-line (M-r)</A>
+<LI><A HREF="readline.html#IDX106">rl_add_defun</A>
+<LI><A HREF="readline.html#IDX130">rl_add_undo</A>
+<LI><A HREF="readline.html#IDX172">rl_attempted_completion_function</A>
+<LI><A HREF="readline.html#IDX178">rl_basic_quote_characters</A>
+<LI><A HREF="readline.html#IDX177">rl_basic_word_break_characters</A>
+<LI><A HREF="readline.html#IDX128">rl_begin_undo_group</A>
+<LI><A HREF="readline.html#IDX115">rl_bind_key</A>
+<LI><A HREF="readline.html#IDX116">rl_bind_key_in_map</A>
+<LI><A HREF="readline.html#IDX105">rl_binding_keymap</A>
+<LI><A HREF="readline.html#IDX159">rl_callback_handler_install</A>
+<LI><A HREF="readline.html#IDX161">rl_callback_handler_remove</A>
+<LI><A HREF="readline.html#IDX160">rl_callback_read_char</A>
+<LI><A HREF="readline.html#IDX175">rl_char_is_quoted_p</A>
+<LI><A HREF="readline.html#IDX139">rl_clear_message</A>
+<LI><A HREF="readline.html#IDX162">rl_complete</A>, <A HREF="rlman.html#IDX165">rl_complete</A>
+<LI><A HREF="readline.html#IDX164">rl_complete_internal</A>
+<LI><A HREF="readline.html#IDX180">rl_completer_quote_characters</A>
+<LI><A HREF="readline.html#IDX179">rl_completer_word_break_characters</A>
+<LI><A HREF="readline.html#IDX183">rl_completion_append_character</A>
+<LI><A HREF="readline.html#IDX163">rl_completion_entry_function</A>, <A HREF="rlman.html#IDX171">rl_completion_entry_function</A>
+<LI><A HREF="readline.html#IDX176">rl_completion_query_items</A>
+<LI><A HREF="readline.html#IDX108">rl_copy_keymap</A>
+<LI><A HREF="readline.html#IDX142">rl_copy_text</A>
+<LI><A HREF="readline.html#IDX141">rl_delete_text</A>
+<LI><A HREF="readline.html#IDX189">rl_directory_completion_hook</A>
+<LI><A HREF="readline.html#IDX110">rl_discard_keymap</A>
+<LI><A HREF="readline.html#IDX132">rl_do_undo</A>
+<LI><A HREF="readline.html#IDX92">rl_done</A>
+<LI><A HREF="readline.html#IDX90">rl_end</A>
+<LI><A HREF="readline.html#IDX129">rl_end_undo_group</A>
+<LI><A HREF="readline.html#IDX101">rl_event_hook</A>
+<LI><A HREF="readline.html#IDX104">rl_executing_keymap</A>
+<LI><A HREF="readline.html#IDX185">rl_filename_completion_desired</A>
+<LI><A HREF="readline.html#IDX174">rl_filename_dequoting_function</A>
+<LI><A HREF="readline.html#IDX181">rl_filename_quote_characters</A>
+<LI><A HREF="readline.html#IDX186">rl_filename_quoting_desired</A>
+<LI><A HREF="readline.html#IDX173">rl_filename_quoting_function</A>
+<LI><A HREF="readline.html#IDX135">rl_forced_update_display</A>
+<LI><A HREF="readline.html#IDX126">rl_function_dumper</A>
+<LI><A HREF="readline.html#IDX123">rl_function_of_keyseq</A>
+<LI><A HREF="readline.html#IDX119">rl_generic_bind</A>
+<LI><A HREF="readline.html#IDX111">rl_get_keymap</A>
+<LI><A HREF="readline.html#IDX113">rl_get_keymap_by_name</A>
+<LI><A HREF="readline.html#IDX114">rl_get_keymap_name</A>
+<LI><A HREF="readline.html#IDX145">rl_getc</A>
+<LI><A HREF="readline.html#IDX102">rl_getc_function</A>
+<LI><A HREF="readline.html#IDX184">rl_ignore_completion_duplicates</A>
+<LI><A HREF="readline.html#IDX188">rl_ignore_some_completions_function</A>
+<LI><A HREF="readline.html#IDX187">rl_inhibit_completion</A>
+<LI><A HREF="readline.html#IDX148">rl_initialize</A>
+<LI><A HREF="readline.html#IDX167">rl_insert_completions</A>
+<LI><A HREF="readline.html#IDX140">rl_insert_text</A>
+<LI><A HREF="readline.html#IDX98">rl_instream</A>
+<LI><A HREF="readline.html#IDX124">rl_invoking_keyseqs</A>
+<LI><A HREF="readline.html#IDX125">rl_invoking_keyseqs_in_map</A>
+<LI><A HREF="readline.html#IDX143">rl_kill_text</A>
+<LI><A HREF="readline.html#IDX95">rl_library_version</A>
+<LI><A HREF="readline.html#IDX88">rl_line_buffer</A>
+<LI><A HREF="readline.html#IDX127">rl_list_funmap_names</A>
+<LI><A HREF="readline.html#IDX107">rl_make_bare_keymap</A>
+<LI><A HREF="readline.html#IDX109">rl_make_keymap</A>
+<LI><A HREF="readline.html#IDX91">rl_mark</A>
+<LI><A HREF="readline.html#IDX138">rl_message</A>
+<LI><A HREF="readline.html#IDX133">rl_modifying</A>
+<LI><A HREF="readline.html#IDX122">rl_named_function</A>
+<LI><A HREF="readline.html#IDX136">rl_on_new_line</A>
+<LI><A HREF="readline.html#IDX99">rl_outstream</A>
+<LI><A HREF="readline.html#IDX120">rl_parse_and_bind</A>
+<LI><A HREF="readline.html#IDX93">rl_pending_input</A>
+<LI><A HREF="readline.html#IDX89">rl_point</A>
+<LI><A HREF="readline.html#IDX166">rl_possible_completions</A>
+<LI><A HREF="readline.html#IDX94">rl_prompt</A>
+<LI><A HREF="readline.html#IDX121">rl_read_init_file</A>
+<LI><A HREF="readline.html#IDX144">rl_read_key</A>
+<LI><A HREF="readline.html#IDX97">rl_readline_name</A>
+<LI><A HREF="readline.html#IDX134">rl_redisplay</A>
+<LI><A HREF="readline.html#IDX103">rl_redisplay_function</A>
+<LI><A HREF="readline.html#IDX137">rl_reset_line_state</A>
+<LI><A HREF="readline.html#IDX149">rl_reset_terminal</A>
+<LI><A HREF="readline.html#IDX112">rl_set_keymap</A>
+<LI><A HREF="readline.html#IDX182">rl_special_prefixes</A>
+<LI><A HREF="readline.html#IDX100">rl_startup_hook</A>
+<LI><A HREF="readline.html#IDX146">rl_stuff_char</A>
+<LI><A HREF="readline.html#IDX96">rl_terminal_name</A>
+<LI><A HREF="readline.html#IDX117">rl_unbind_key</A>
+<LI><A HREF="readline.html#IDX118">rl_unbind_key_in_map</A>
+</DIR>
+<H2>s</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX43">self-insert (a, b, A, 1, !, ...)</A>
+<LI><A HREF="readline.html#IDX78">set-mark (C-@)</A>
+<LI><A HREF="readline.html#IDX16">show-all-if-ambiguous</A>
+<LI><A HREF="readline.html#IDX68">start-kbd-macro (C-x ()</A>
+</DIR>
+<H2>t</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX42">tab-insert (M-TAB)</A>
+<LI><A HREF="readline.html#IDX77">tilde-expand (M-~)</A>
+<LI><A HREF="readline.html#IDX157">to_lower</A>
+<LI><A HREF="readline.html#IDX156">to_upper</A>
+<LI><A HREF="readline.html#IDX44">transpose-chars (C-t)</A>
+<LI><A HREF="readline.html#IDX45">transpose-words (M-t)</A>
+</DIR>
+<H2>u</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX75">undo (C-_, C-x C-u)</A>
+<LI><A HREF="readline.html#IDX64">universal-argument ()</A>
+<LI><A HREF="readline.html#IDX51">unix-line-discard (C-u)</A>
+<LI><A HREF="readline.html#IDX55">unix-word-rubout (C-w)</A>
+<LI><A HREF="readline.html#IDX46">upcase-word (M-u)</A>
+<LI><A HREF="readline.html#IDX153">uppercase_p</A>
+<LI><A HREF="readline.html#IDX170">username_completion_function</A>
+</DIR>
+<H2>v</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX17">visible-stats</A>
+</DIR>
+<H2>y</H2>
+<DIR>
+<LI><A HREF="readline.html#IDX61">yank (C-y)</A>
+<LI><A HREF="readline.html#IDX38">yank-last-arg (M-., M-_)</A>
+<LI><A HREF="readline.html#IDX37">yank-nth-arg (M-C-y)</A>
+<LI><A HREF="readline.html#IDX62">yank-pop (M-y)</A>
+</DIR>
+
+</P>
+<P><HR><P>
+This document was generated on 22 May 1997 using the
+<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
+translator version 1.51.</P>
+</BODY>
+</HTML>
diff --git a/readline/doc/readline.info b/readline/doc/readline.info
new file mode 100644
--- /dev/null
+++ b/readline/doc/readline.info
@@ -0,0 +1,2766 @@
+This is Info file readline.info, produced by Makeinfo-1.55 from the
+input file
+/usr/homes/chet/src/bash/readline-2.1-beta2/doc/rlman.texinfo.
+
+   This document describes the GNU Readline Library, a utility which
+aids in the consistency of user interface across discrete programs that
+need to provide a command line interface.
+
+   Copyright (C) 1988, 1991 Free Software Foundation, Inc.
+
+   Permission is granted to make and distribute verbatim copies of this
+manual provided the copyright notice and this permission notice pare
+preserved on all copies.
+
+   Permission is granted to copy and distribute modified versions of
+this manual under the conditions for verbatim copying, provided that
+the entire resulting derived work is distributed under the terms of a
+permission notice identical to this one.
+
+   Permission is granted to copy and distribute translations of this
+manual into another language, under the above conditions for modified
+versions, except that this permission notice may be stated in a
+translation approved by the Foundation.
+
+
+File: readline.info,  Node: Top,  Next: Command Line Editing,  Prev: (DIR),  Up: (DIR)
+
+GNU Readline Library
+********************
+
+   This document describes the GNU Readline Library, a utility which
+aids in the consistency of user interface across discrete programs that
+need to provide a command line interface.
+
+* Menu:
+
+* Command Line Editing::	   GNU Readline User's Manual.
+* Programming with GNU Readline::  GNU Readline Programmer's Manual.
+* Concept Index::		   Index of concepts described in this manual.
+* Function and Variable Index::	   Index of externally visible functions
+				   and variables.
+
+
+File: readline.info,  Node: Command Line Editing,  Next: Programming with GNU Readline,  Prev: Top,  Up: Top
+
+Command Line Editing
+********************
+
+   This chapter describes the basic features of the GNU command line
+editing interface.
+
+* Menu:
+
+* Introduction and Notation::	Notation used in this text.
+* Readline Interaction::	The minimum set of commands for editing a line.
+* Readline Init File::		Customizing Readline from a user's view.
+* Bindable Readline Commands::	A description of most of the Readline commands
+				available for binding
+* Readline vi Mode::		A short description of how to make Readline
+				behave like the vi editor.
+
+
+File: readline.info,  Node: Introduction and Notation,  Next: Readline Interaction,  Up: Command Line Editing
+
+Introduction to Line Editing
+============================
+
+   The following paragraphs describe the notation used to represent
+keystrokes.
+
+   The text C-k is read as `Control-K' and describes the character
+produced when the k key is pressed while the Control key is depressed.
+
+   The text M-k is read as `Meta-K' and describes the character
+produced when the meta key (if you have one) is depressed, and the k
+key is pressed.  If you do not have a meta key, the identical keystroke
+can be generated by typing ESC first, and then typing k.  Either
+process is known as "metafying" the k key.
+
+   The text M-C-k is read as `Meta-Control-k' and describes the
+character produced by "metafying" C-k.
+
+   In addition, several keys have their own names.  Specifically, DEL,
+ESC, LFD, SPC, RET, and TAB all stand for themselves when seen in this
+text, or in an init file (*note Readline Init File::.).
+
+
+File: readline.info,  Node: Readline Interaction,  Next: Readline Init File,  Prev: Introduction and Notation,  Up: Command Line Editing
+
+Readline Interaction
+====================
+
+   Often during an interactive session you type in a long line of text,
+only to notice that the first word on the line is misspelled.  The
+Readline library gives you a set of commands for manipulating the text
+as you type it in, allowing you to just fix your typo, and not forcing
+you to retype the majority of the line.  Using these editing commands,
+you move the cursor to the place that needs correction, and delete or
+insert the text of the corrections.  Then, when you are satisfied with
+the line, you simply press RETURN.  You do not have to be at the end of
+the line to press RETURN; the entire line is accepted regardless of the
+location of the cursor within the line.
+
+* Menu:
+
+* Readline Bare Essentials::	The least you need to know about Readline.
+* Readline Movement Commands::	Moving about the input line.
+* Readline Killing Commands::	How to delete text, and how to get it back!
+* Readline Arguments::		Giving numeric arguments to commands.
+* Searching::			Searching through previous lines.
+
+
+File: readline.info,  Node: Readline Bare Essentials,  Next: Readline Movement Commands,  Up: Readline Interaction
+
+Readline Bare Essentials
+------------------------
+
+   In order to enter characters into the line, simply type them.  The
+typed character appears where the cursor was, and then the cursor moves
+one space to the right.  If you mistype a character, you can use your
+erase character to back up and delete the mistyped character.
+
+   Sometimes you may miss typing a character that you wanted to type,
+and not notice your error until you have typed several other
+characters.  In that case, you can type C-b to move the cursor to the
+left, and then correct your mistake.  Afterwards, you can move the
+cursor to the right with C-f.
+
+   When you add text in the middle of a line, you will notice that
+characters to the right of the cursor are `pushed over' to make room
+for the text that you have inserted.  Likewise, when you delete text
+behind the cursor, characters to the right of the cursor are `pulled
+back' to fill in the blank space created by the removal of the text.  A
+list of the basic bare essentials for editing the text of an input line
+follows.
+
+C-b
+     Move back one character.
+
+C-f
+     Move forward one character.
+
+DEL
+     Delete the character to the left of the cursor.
+
+C-d
+     Delete the character underneath the cursor.
+
+Printing characters
+     Insert the character into the line at the cursor.
+
+C-_
+     Undo the last thing that you did.  You can undo all the way back
+     to an empty line.
+
+
+File: readline.info,  Node: Readline Movement Commands,  Next: Readline Killing Commands,  Prev: Readline Bare Essentials,  Up: Readline Interaction
+
+Readline Movement Commands
+--------------------------
+
+   The above table describes the most basic possible keystrokes that
+you need in order to do editing of the input line.  For your
+convenience, many other commands have been added in addition to C-b,
+C-f, C-d, and DEL.  Here are some commands for moving more rapidly
+about the line.
+
+C-a
+     Move to the start of the line.
+
+C-e
+     Move to the end of the line.
+
+M-f
+     Move forward a word.
+
+M-b
+     Move backward a word.
+
+C-l
+     Clear the screen, reprinting the current line at the top.
+
+   Notice how C-f moves forward a character, while M-f moves forward a
+word.  It is a loose convention that control keystrokes operate on
+characters while meta keystrokes operate on words.
+
+
+File: readline.info,  Node: Readline Killing Commands,  Next: Readline Arguments,  Prev: Readline Movement Commands,  Up: Readline Interaction
+
+Readline Killing Commands
+-------------------------
+
+   "Killing" text means to delete the text from the line, but to save
+it away for later use, usually by "yanking" (re-inserting) it back into
+the line.  If the description for a command says that it `kills' text,
+then you can be sure that you can get the text back in a different (or
+the same) place later.
+
+   When you use a kill command, the text is saved in a "kill-ring".
+Any number of consecutive kills save all of the killed text together, so
+that when you yank it back, you get it all.  The kill ring is not line
+specific; the text that you killed on a previously typed line is
+available to be yanked back later, when you are typing another line.
+
+   Here is the list of commands for killing text.
+
+C-k
+     Kill the text from the current cursor position to the end of the
+     line.
+
+M-d
+     Kill from the cursor to the end of the current word, or if between
+     words, to the end of the next word.
+
+M-DEL
+     Kill from the cursor the start of the previous word, or if between
+     words, to the start of the previous word.
+
+C-w
+     Kill from the cursor to the previous whitespace.  This is
+     different than M-DEL because the word boundaries differ.
+
+   And, here is how to "yank" the text back into the line.  Yanking
+means to copy the most-recently-killed text from the kill buffer.
+
+C-y
+     Yank the most recently killed text back into the buffer at the
+     cursor.
+
+M-y
+     Rotate the kill-ring, and yank the new top.  You can only do this
+     if the prior command is C-y or M-y.
+
+
+File: readline.info,  Node: Readline Arguments,  Next: Searching,  Prev: Readline Killing Commands,  Up: Readline Interaction
+
+Readline Arguments
+------------------
+
+   You can pass numeric arguments to Readline commands.  Sometimes the
+argument acts as a repeat count, other times it is the sign of the
+argument that is significant.  If you pass a negative argument to a
+command which normally acts in a forward direction, that command will
+act in a backward direction.  For example, to kill text back to the
+start of the line, you might type `M-- C-k'.
+
+   The general way to pass numeric arguments to a command is to type
+meta digits before the command.  If the first `digit' you type is a
+minus sign (-), then the sign of the argument will be negative.  Once
+you have typed one meta digit to get the argument started, you can type
+the remainder of the digits, and then the command.  For example, to give
+the C-d command an argument of 10, you could type `M-1 0 C-d'.
+
+
+File: readline.info,  Node: Searching,  Prev: Readline Arguments,  Up: Readline Interaction
+
+Searching for Commands in the History
+-------------------------------------
+
+   Readline provides commands for searching through the command history
+for lines containing a specified string.  There are two search modes:
+iNCREMENTAL and NON-INCREMENTAL.
+
+   Incremental searches begin before the user has finished typing the
+search string.  As each character of the search string is typed,
+readline displays the next entry from the history matching the string
+typed so far.  An incremental search requires only as many characters
+as needed to find the desired history entry.  The Escape character is
+used to terminate an incremental search.  Control-J will also terminate
+the search.  Control-G will abort an incremental search and restore the
+original line.  When the search is terminated, the history entry
+containing the search string becomes the current line.  To find other
+matching entries in the history list, type Control-S or Control-R as
+appropriate.  This will search backward or forward in the history for
+the next entry matching the search string typed so far.  Any other key
+sequence bound to a readline command will terminate the search and
+execute that command.  For instance, a `newline' will terminate the
+search and accept the line, thereby executing the command from the
+history list.
+
+   Non-incremental searches read the entire search string before
+starting to search for matching history lines.  The search string may be
+typed by the user or part of the contents of the current line.
+
+
+File: readline.info,  Node: Readline Init File,  Next: Bindable Readline Commands,  Prev: Readline Interaction,  Up: Command Line Editing
+
+Readline Init File
+==================
+
+   Although the Readline library comes with a set of `emacs'-like
+keybindings installed by default, it is possible that you would like to
+use a different set of keybindings.  You can customize programs that
+use Readline by putting commands in an "inputrc" file in your home
+directory.  The name of this file is taken from the value of the
+environment variable `INPUTRC'.  If that variable is unset, the default
+is `~/.inputrc'.
+
+   When a program which uses the Readline library starts up, the init
+file is read, and the key bindings are set.
+
+   In addition, the `C-x C-r' command re-reads this init file, thus
+incorporating any changes that you might have made to it.
+
+* Menu:
+
+* Readline Init File Syntax::	Syntax for the commands in the inputrc file.
+
+* Conditional Init Constructs::	Conditional key bindings in the inputrc file.
+
+* Sample Init File::		An example inputrc file.
+
+
+File: readline.info,  Node: Readline Init File Syntax,  Next: Conditional Init Constructs,  Up: Readline Init File
+
+Readline Init File Syntax
+-------------------------
+
+   There are only a few basic constructs allowed in the Readline init
+file.  Blank lines are ignored.  Lines beginning with a `#' are
+comments.  Lines beginning with a `$' indicate conditional constructs
+(*note Conditional Init Constructs::.).  Other lines denote variable
+settings and key bindings.
+
+Variable Settings
+     You can change the state of a few variables in Readline by using
+     the `set' command within the init file.  Here is how you would
+     specify that you wish to use `vi' line editing commands:
+
+          set editing-mode vi
+
+     Right now, there are only a few variables which can be set; so
+     few, in fact, that we just list them here:
+
+    `bell-style'
+          Controls what happens when Readline wants to ring the
+          terminal bell.  If set to `none', Readline never rings the
+          bell.  If set to `visible', Readline uses a visible bell if
+          one is available.  If set to `audible' (the default),
+          Readline attempts to ring the terminal's bell.
+
+    `comment-begin'
+          The string to insert at the beginning of the line when the
+          `insert-comment' command is executed.  The default value is
+          `"#"'.
+
+    `completion-query-items'
+          The number of possible completions that determines when the
+          user is asked whether he wants to see the list of
+          possibilities.  If the number of possible completions is
+          greater than this value, Readline will ask the user whether
+          or not he wishes to view them; otherwise, they are simply
+          listed.  The default limit is `100'.
+
+    `convert-meta'
+          If set to `on', Readline will convert characters with the
+          eigth bit set to an ASCII key sequence by stripping the eigth
+          bit and prepending an ESC character, converting them to a
+          meta-prefixed key sequence.  The default value is `on'.
+
+    `disable-completion'
+          If set to `On', readline will inhibit word completion.
+          Completion  characters will be inserted into the line as if
+          they had been mapped to `self-insert'.  The default is `off'.
+
+    `editing-mode'
+          The `editing-mode' variable controls which editing mode you
+          are using.  By default, Readline starts up in Emacs editing
+          mode, where the keystrokes are most similar to Emacs.  This
+          variable can be set to either `emacs' or `vi'.
+
+    `enable-keypad'
+          When set to `on', readline will try to enable the application
+          keypad when it is called.  Some systems need this to enable
+          the arrow keys.  The default is `off'.
+
+    `expand-tilde'
+          If set to `on', tilde expansion is performed when Readline
+          attempts word completion.  The default is `off'.
+
+    `horizontal-scroll-mode'
+          This variable can be set to either `on' or `off'.  Setting it
+          to `on' means that the text of the lines that you edit will
+          scroll horizontally on a single screen line when they are
+          longer than the width of the screen, instead of wrapping onto
+          a new screen line.  By default, this variable is set to `off'.
+
+    `keymap'
+          Sets Readline's idea of the current keymap for key binding
+          commands.  Acceptable `keymap' names are `emacs',
+          `emacs-standard', `emacs-meta', `emacs-ctlx', `vi',
+          `vi-command', and `vi-insert'.  `vi' is equivalent to
+          `vi-command'; `emacs' is equivalent to `emacs-standard'.  The
+          default value is `emacs'.  The value of the `editing-mode'
+          variable also affects the default keymap.
+
+    `mark-directories'
+          If set to `on', completed directory names have a slash
+          appended.  The default is `on'.
+
+    `mark-modified-lines'
+          This variable, when set to `on', says to display an asterisk
+          (`*') at the start of history lines which have been modified.
+          This variable is `off' by default.
+
+    `input-meta'
+          If set to `on', Readline will enable eight-bit input (it will
+          not strip the eighth bit from the characters it reads),
+          regardless of what the terminal claims it can support.  The
+          default value is `off'.  The name `meta-flag' is a synonym
+          for this variable.
+
+    `output-meta'
+          If set to `on', Readline will display characters with the
+          eighth bit set directly rather than as a meta-prefixed escape
+          sequence.  The default is `off'.
+
+    `show-all-if-ambiguous'
+          This alters the default behavior of the completion functions.
+          If set to `on', words which have more than one possible
+          completion cause the matches to be listed immediately instead
+          of ringing the bell.  The default value is `off'.
+
+    `visible-stats'
+          If set to `on', a character denoting a file's type is
+          appended to the filename when listing possible completions.
+          The default is `off'.
+
+Key Bindings
+     The syntax for controlling key bindings in the init file is
+     simple.  First you have to know the name of the command that you
+     want to change.  The following pages contain tables of the command
+     name, the default keybinding, and a short description of what the
+     command does.
+
+     Once you know the name of the command, simply place the name of
+     the key you wish to bind the command to, a colon, and then the
+     name of the command on a line in the init file.  The name of the
+     key can be expressed in different ways, depending on which is most
+     comfortable for you.
+
+    KEYNAME: FUNCTION-NAME or MACRO
+          KEYNAME is the name of a key spelled out in English.  For
+          example:
+               Control-u: universal-argument
+               Meta-Rubout: backward-kill-word
+               Control-o: "> output"
+
+          In the above example, `C-u' is bound to the function
+          `universal-argument', and `C-o' is bound to run the macro
+          expressed on the right hand side (that is, to insert the text
+          `> output' into the line).
+
+    "KEYSEQ": FUNCTION-NAME or MACRO
+          KEYSEQ differs from KEYNAME above in that strings denoting an
+          entire key sequence can be specified, by placing the key
+          sequence in double quotes.  Some GNU Emacs style key escapes
+          can be used, as in the following example, but the special
+          character names are not recognized.
+
+               "\C-u": universal-argument
+               "\C-x\C-r": re-read-init-file
+               "\e[11~": "Function Key 1"
+
+          In the above example, `C-u' is bound to the function
+          `universal-argument' (just as it was in the first example),
+          `C-x C-r' is bound to the function `re-read-init-file', and
+          `ESC [ 1 1 ~' is bound to insert the text `Function Key 1'.
+          The following escape sequences are available when specifying
+          key sequences:
+
+         ``\C-''
+               control prefix
+
+         ``\M-''
+               meta prefix
+
+         ``\e''
+               an escape character
+
+         ``\\''
+               backslash
+
+         ``\"''
+               "
+
+         ``\'''
+               '
+
+          When entering the text of a macro, single or double quotes
+          should be used to indicate a macro definition.  Unquoted text
+          is assumed to be a function name.  Backslash will quote any
+          character in the macro text, including `"' and `''.  For
+          example, the following binding will make `C-x \' insert a
+          single `\' into the line:
+               "\C-x\\": "\\"
+
+
+File: readline.info,  Node: Conditional Init Constructs,  Next: Sample Init File,  Prev: Readline Init File Syntax,  Up: Readline Init File
+
+Conditional Init Constructs
+---------------------------
+
+   Readline implements a facility similar in spirit to the conditional
+compilation features of the C preprocessor which allows key bindings
+and variable settings to be performed as the result of tests.  There
+are three parser directives used.
+
+`$if'
+     The `$if' construct allows bindings to be made based on the
+     editing mode, the terminal being used, or the application using
+     Readline.  The text of the test extends to the end of the line; no
+     characters are required to isolate it.
+
+    `mode'
+          The `mode=' form of the `$if' directive is used to test
+          whether Readline is in `emacs' or `vi' mode.  This may be
+          used in conjunction with the `set keymap' command, for
+          instance, to set bindings in the `emacs-standard' and
+          `emacs-ctlx' keymaps only if Readline is starting out in
+          `emacs' mode.
+
+    `term'
+          The `term=' form may be used to include terminal-specific key
+          bindings, perhaps to bind the key sequences output by the
+          terminal's function keys.  The word on the right side of the
+          `=' is tested against the full name of the terminal and the
+          portion of the terminal name before the first `-'.  This
+          allows `sun' to match both `sun' and `sun-cmd', for instance.
+
+    `application'
+          The APPLICATION construct is used to include
+          application-specific settings.  Each program using the
+          Readline library sets the APPLICATION NAME, and you can test
+          for it.  This could be used to bind key sequences to
+          functions useful for a specific program.  For instance, the
+          following command adds a key sequence that quotes the current
+          or previous word in Bash:
+               $if Bash
+               # Quote the current or previous word
+               "\C-xq": "\eb\"\ef\""
+               $endif
+
+`$endif'
+     This command, as you saw in the previous example, terminates an
+     `$if' command.
+
+`$else'
+     Commands in this branch of the `$if' directive are executed if the
+     test fails.
+
+
+File: readline.info,  Node: Sample Init File,  Prev: Conditional Init Constructs,  Up: Readline Init File
+
+Sample Init File
+----------------
+
+   Here is an example of an inputrc file.  This illustrates key
+binding, variable assignment, and conditional syntax.
+
+
+     # This file controls the behaviour of line input editing for
+     # programs that use the Gnu Readline library.  Existing programs
+     # include FTP, Bash, and Gdb.
+     #
+     # You can re-read the inputrc file with C-x C-r.
+     # Lines beginning with '#' are comments.
+     #
+     # Set various bindings for emacs mode.
+     
+     set editing-mode emacs
+     
+     $if mode=emacs
+     
+     Meta-Control-h:	backward-kill-word	Text after the function name is ignored
+     
+     #
+     # Arrow keys in keypad mode
+     #
+     #"\M-OD":        backward-char
+     #"\M-OC":        forward-char
+     #"\M-OA":        previous-history
+     #"\M-OB":        next-history
+     #
+     # Arrow keys in ANSI mode
+     #
+     "\M-[D":        backward-char
+     "\M-[C":        forward-char
+     "\M-[A":        previous-history
+     "\M-[B":        next-history
+     #
+     # Arrow keys in 8 bit keypad mode
+     #
+     #"\M-\C-OD":       backward-char
+     #"\M-\C-OC":       forward-char
+     #"\M-\C-OA":       previous-history
+     #"\M-\C-OB":       next-history
+     #
+     # Arrow keys in 8 bit ANSI mode
+     #
+     #"\M-\C-[D":       backward-char
+     #"\M-\C-[C":       forward-char
+     #"\M-\C-[A":       previous-history
+     #"\M-\C-[B":       next-history
+     
+     C-q: quoted-insert
+     
+     $endif
+     
+     # An old-style binding.  This happens to be the default.
+     TAB: complete
+     
+     # Macros that are convenient for shell interaction
+     $if Bash
+     # edit the path
+     "\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
+     # prepare to type a quoted word -- insert open and close double quotes
+     # and move to just after the open quote
+     "\C-x\"": "\"\"\C-b"
+     # insert a backslash (testing backslash escapes in sequences and macros)
+     "\C-x\\": "\\"
+     # Quote the current or previous word
+     "\C-xq": "\eb\"\ef\""
+     # Add a binding to refresh the line, which is unbound
+     "\C-xr": redraw-current-line
+     # Edit variable on current line.
+     "\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
+     $endif
+     
+     # use a visible bell if one is available
+     set bell-style visible
+     
+     # don't strip characters to 7 bits when reading
+     set input-meta on
+     
+     # allow iso-latin1 characters to be inserted rather than converted to
+     # prefix-meta sequences
+     set convert-meta off
+     
+     # display characters with the eighth bit set directly rather than
+     # as meta-prefixed characters
+     set output-meta on
+     
+     # if there are more than 150 possible completions for a word, ask the
+     # user if he wants to see all of them
+     set completion-query-items 150
+     
+     # For FTP
+     $if Ftp
+     "\C-xg": "get \M-?"
+     "\C-xt": "put \M-?"
+     "\M-.": yank-last-arg
+     $endif
+
+
+File: readline.info,  Node: Bindable Readline Commands,  Next: Readline vi Mode,  Prev: Readline Init File,  Up: Command Line Editing
+
+Bindable Readline Commands
+==========================
+
+* Menu:
+
+* Commands For Moving::		Moving about the line.
+* Commands For History::	Getting at previous lines.
+* Commands For Text::		Commands for changing text.
+* Commands For Killing::	Commands for killing and yanking.
+* Numeric Arguments::		Specifying numeric arguments, repeat counts.
+* Commands For Completion::	Getting Readline to do the typing for you.
+* Keyboard Macros::		Saving and re-executing typed characters
+* Miscellaneous Commands::	Other miscellaneous commands.
+
+   This section describes Readline commands that may be bound to key
+sequences.
+
+
+File: readline.info,  Node: Commands For Moving,  Next: Commands For History,  Up: Bindable Readline Commands
+
+Commands For Moving
+-------------------
+
+`beginning-of-line (C-a)'
+     Move to the start of the current line.
+
+`end-of-line (C-e)'
+     Move to the end of the line.
+
+`forward-char (C-f)'
+     Move forward a character.
+
+`backward-char (C-b)'
+     Move back a character.
+
+`forward-word (M-f)'
+     Move forward to the end of the next word.  Words are composed of
+     letters and digits.
+
+`backward-word (M-b)'
+     Move back to the start of this, or the previous, word.  Words are
+     composed of letters and digits.
+
+`clear-screen (C-l)'
+     Clear the screen and redraw the current line, leaving the current
+     line at the top of the screen.
+
+`redraw-current-line ()'
+     Refresh the current line.  By default, this is unbound.
+
+
+File: readline.info,  Node: Commands For History,  Next: Commands For Text,  Prev: Commands For Moving,  Up: Bindable Readline Commands
+
+Commands For Manipulating The History
+-------------------------------------
+
+`accept-line (Newline, Return)'
+     Accept the line regardless of where the cursor is.  If this line is
+     non-empty, add it to the history list.  If this line was a history
+     line, then restore the history line to its original state.
+
+`previous-history (C-p)'
+     Move `up' through the history list.
+
+`next-history (C-n)'
+     Move `down' through the history list.
+
+`beginning-of-history (M-<)'
+     Move to the first line in the history.
+
+`end-of-history (M->)'
+     Move to the end of the input history, i.e., the line you are
+     entering.
+
+`reverse-search-history (C-r)'
+     Search backward starting at the current line and moving `up'
+     through the history as necessary.  This is an incremental search.
+
+`forward-search-history (C-s)'
+     Search forward starting at the current line and moving `down'
+     through the the history as necessary.  This is an incremental
+     search.
+
+`non-incremental-reverse-search-history (M-p)'
+     Search backward starting at the current line and moving `up'
+     through the history as necessary using a non-incremental search
+     for a string supplied by the user.
+
+`non-incremental-forward-search-history (M-n)'
+     Search forward starting at the current line and moving `down'
+     through the the history as necessary using a non-incremental search
+     for a string supplied by the user.
+
+`history-search-forward ()'
+     Search forward through the history for the string of characters
+     between the start of the current line and the current cursor
+     position (the `point').  This is a non-incremental search.  By
+     default, this command is unbound.
+
+`history-search-backward ()'
+     Search backward through the history for the string of characters
+     between the start of the current line and the point.  This is a
+     non-incremental search.  By default, this command is unbound.
+
+`yank-nth-arg (M-C-y)'
+     Insert the first argument to the previous command (usually the
+     second word on the previous line).  With an argument N, insert the
+     Nth word from the previous command (the words in the previous
+     command begin with word 0).  A negative argument inserts the Nth
+     word from the end of the previous command.
+
+`yank-last-arg (M-., M-_)'
+     Insert last argument to the previous command (the last word of the
+     previous history entry).  With an argument, behave exactly like
+     `yank-nth-arg'.
+
+
+File: readline.info,  Node: Commands For Text,  Next: Commands For Killing,  Prev: Commands For History,  Up: Bindable Readline Commands
+
+Commands For Changing Text
+--------------------------
+
+`delete-char (C-d)'
+     Delete the character under the cursor.  If the cursor is at the
+     beginning of the line, there are no characters in the line, and
+     the last character typed was not `C-d', then return `EOF'.
+
+`backward-delete-char (Rubout)'
+     Delete the character behind the cursor.  A numeric arg says to kill
+     the characters instead of deleting them.
+
+`quoted-insert (C-q, C-v)'
+     Add the next character that you type to the line verbatim.  This is
+     how to insert key sequences like C-q, for example.
+
+`tab-insert (M-TAB)'
+     Insert a tab character.
+
+`self-insert (a, b, A, 1, !, ...)'
+     Insert yourself.
+
+`transpose-chars (C-t)'
+     Drag the character before the cursor forward over the character at
+     the cursor, moving the cursor forward as well.  If the insertion
+     point is at the end of the line, then this transposes the last two
+     characters of the line.  Negative argumentss don't work.
+
+`transpose-words (M-t)'
+     Drag the word behind the cursor past the word in front of the
+     cursor moving the cursor over that word as well.
+
+`upcase-word (M-u)'
+     Uppercase the current (or following) word.  With a negative
+     argument, do the previous word, but do not move the cursor.
+
+`downcase-word (M-l)'
+     Lowercase the current (or following) word.  With a negative
+     argument, do the previous word, but do not move the cursor.
+
+`capitalize-word (M-c)'
+     Capitalize the current (or following) word.  With a negative
+     argument, do the previous word, but do not move the cursor.
+
+
+File: readline.info,  Node: Commands For Killing,  Next: Numeric Arguments,  Prev: Commands For Text,  Up: Bindable Readline Commands
+
+Killing And Yanking
+-------------------
+
+`kill-line (C-k)'
+     Kill the text from the current cursor position to the end of the
+     line.
+
+`backward-kill-line (C-x Rubout)'
+     Kill backward to the beginning of the line.
+
+`unix-line-discard (C-u)'
+     Kill backward from the cursor to the beginning of the current line.
+     Save the killed text on the kill-ring.
+
+`kill-whole-line ()'
+     Kill all characters on the current line, no matter where the
+     cursor is.  By default, this is unbound.
+
+`kill-word (M-d)'
+     Kill from the cursor to the end of the current word, or if between
+     words, to the end of the next word.  Word boundaries are the same
+     as `forward-word'.
+
+`backward-kill-word (M-DEL)'
+     Kill the word behind the cursor.  Word boundaries are the same as
+     `backward-word'.
+
+`unix-word-rubout (C-w)'
+     Kill the word behind the cursor, using white space as a word
+     boundary.  The killed text is saved on the kill-ring.
+
+`delete-horizontal-space ()'
+     Delete all spaces and tabs around point.  By default, this is
+     unbound.
+
+`kill-region ()'
+     Kill the text between the point and the *mark* (saved cursor
+     position.  This text is referred to as the REGION.  By default,
+     this command is unbound.
+
+`copy-region-as-kill ()'
+     Copy the text in the region to the kill buffer, so you can yank it
+     right away.  By default, this command is unbound.
+
+`copy-backward-word ()'
+     Copy the word before point to the kill buffer.  By default, this
+     command is unbound.
+
+`copy-forward-word ()'
+     Copy the word following point to the kill buffer.  By default,
+     this command is unbound.
+
+`yank (C-y)'
+     Yank the top of the kill ring into the buffer at the current
+     cursor position.
+
+`yank-pop (M-y)'
+     Rotate the kill-ring, and yank the new top.  You can only do this
+     if the prior command is yank or yank-pop.
+
+
+File: readline.info,  Node: Numeric Arguments,  Next: Commands For Completion,  Prev: Commands For Killing,  Up: Bindable Readline Commands
+
+Specifying Numeric Arguments
+----------------------------
+
+`digit-argument (M-0, M-1, ... M--)'
+     Add this digit to the argument already accumulating, or start a new
+     argument.  M- starts a negative argument.
+
+`universal-argument ()'
+     This is another way to specify an argument.  If this command is
+     followed by one or more digits, optionally with a leading minus
+     sign, those digits define the argument.  If the command is
+     followed by digits, executing `universal-argument' again ends the
+     numeric argument, but is otherwise ignored.  As a special case, if
+     this command is immediately followed by a character that is
+     neither a digit or minus sign, the argument count for the next
+     command is multiplied by four.  The argument count is initially
+     one, so executing this function the first time makes the argument
+     count four, a second time makes the argument count sixteen, and so
+     on.  By default, this is not bound to a key.
+
+
+File: readline.info,  Node: Commands For Completion,  Next: Keyboard Macros,  Prev: Numeric Arguments,  Up: Bindable Readline Commands
+
+Letting Readline Type For You
+-----------------------------
+
+`complete (TAB)'
+     Attempt to do completion on the text before the cursor.  This is
+     application-specific.  Generally, if you are typing a filename
+     argument, you can do filename completion; if you are typing a
+     command, you can do command completion, if you are typing in a
+     symbol to GDB, you can do symbol name completion, if you are
+     typing in a variable to Bash, you can do variable name completion,
+     and so on.
+
+`possible-completions (M-?)'
+     List the possible completions of the text before the cursor.
+
+`insert-completions (M-*)'
+     Insert all completions of the text before point that would have
+     been generated by `possible-completions'.
+
+
+File: readline.info,  Node: Keyboard Macros,  Next: Miscellaneous Commands,  Prev: Commands For Completion,  Up: Bindable Readline Commands
+
+Keyboard Macros
+---------------
+
+`start-kbd-macro (C-x ()'
+     Begin saving the characters typed into the current keyboard macro.
+
+`end-kbd-macro (C-x ))'
+     Stop saving the characters typed into the current keyboard macro
+     and save the definition.
+
+`call-last-kbd-macro (C-x e)'
+     Re-execute the last keyboard macro defined, by making the
+     characters in the macro appear as if typed at the keyboard.
+
+
+File: readline.info,  Node: Miscellaneous Commands,  Prev: Keyboard Macros,  Up: Bindable Readline Commands
+
+Some Miscellaneous Commands
+---------------------------
+
+`re-read-init-file (C-x C-r)'
+     Read in the contents of the inputrc file, and incorporate any
+     bindings or variable assignments found there.
+
+`abort (C-g)'
+     Abort the current editing command and ring the terminal's bell
+     (subject to the setting of `bell-style').
+
+`do-uppercase-version (M-a, M-b, M-X, ...)'
+     If the metafied character X is lowercase, run the command that is
+     bound to the corresponding uppercase character.
+
+`prefix-meta (ESC)'
+     Make the next character that you type be metafied.  This is for
+     people without a meta key.  Typing `ESC f' is equivalent to typing
+     `M-f'.
+
+`undo (C-_, C-x C-u)'
+     Incremental undo, separately remembered for each line.
+
+`revert-line (M-r)'
+     Undo all changes made to this line.  This is like typing the `undo'
+     command enough times to get back to the beginning.
+
+`tilde-expand (M-~)'
+     Perform tilde expansion on the current word.
+
+`set-mark (C-@)'
+     Set the mark to the current point.  If a numeric argument is
+     supplied, the mark is set to that position.
+
+`exchange-point-and-mark (C-x C-x)'
+     Swap the point with the mark.  The current cursor position is set
+     to the saved position, and the old cursor position is saved as the
+     mark.
+
+`character-search (C-])'
+     A character is read and point is moved to the next occurrence of
+     that character.  A negative count searches for previous
+     occurrences.
+
+`character-search-backward (M-C-])'
+     A character is read and point is moved to the previous occurrence
+     of that character.  A negative count searches for subsequent
+     occurrences.
+
+`insert-comment (M-#)'
+     The value of the `comment-begin' variable is inserted at the
+     beginning of the current line, and the line is accepted as if a
+     newline had been typed.
+
+`dump-functions ()'
+     Print all of the functions and their key bindings to the readline
+     output stream.  If a numeric argument is supplied, the output is
+     formatted in such a way that it can be made part of an INPUTRC
+     file.  This command is unbound by default.
+
+`dump-variables ()'
+     Print all of the settable variables and their values to the
+     readline output stream.  If a numeric argument is supplied, the
+     output is formatted in such a way that it can be made part of an
+     INPUTRC file.  This command is unbound by default.
+
+`dump-macros ()'
+     Print all of the readline key sequences bound to macros and the
+     strings they ouput.  If a numeric argument is supplied, the output
+     is formatted in such a way that it can be made part of an INPUTRC
+     file.  This command is unbound by default.
+
+
+File: readline.info,  Node: Readline vi Mode,  Prev: Bindable Readline Commands,  Up: Command Line Editing
+
+Readline vi Mode
+================
+
+   While the Readline library does not have a full set of `vi' editing
+functions, it does contain enough to allow simple editing of the line.
+The Readline `vi' mode behaves as specified in the POSIX 1003.2
+standard.
+
+   In order to switch interactively between `emacs' and `vi' editing
+modes, use the command M-C-j (toggle-editing-mode).  The Readline
+default is `emacs' mode.
+
+   When you enter a line in `vi' mode, you are already placed in
+`insertion' mode, as if you had typed an `i'.  Pressing ESC switches
+you into `command' mode, where you can edit the text of the line with
+the standard `vi' movement keys, move to previous history lines with
+`k' and subsequent lines with `j', and so forth.
+
+   This document describes the GNU Readline Library, a utility for
+aiding in the consitency of user interface across discrete programs
+that need to provide a command line interface.
+
+   Copyright (C) 1988, 1994, 1996 Free Software Foundation, Inc.
+
+   Permission is granted to make and distribute verbatim copies of this
+manual provided the copyright notice and this permission notice pare
+preserved on all copies.
+
+   Permission is granted to copy and distribute modified versions of
+this manual under the conditions for verbatim copying, provided that
+the entire resulting derived work is distributed under the terms of a
+permission notice identical to this one.
+
+   Permission is granted to copy and distribute translations of this
+manual into another language, under the above conditions for modified
+versions, except that this permission notice may be stated in a
+translation approved by the Foundation.
+
+
+File: readline.info,  Node: Programming with GNU Readline,  Next: Concept Index,  Prev: Command Line Editing,  Up: Top
+
+Programming with GNU Readline
+*****************************
+
+   This chapter describes the interface between the GNU Readline
+Library and other programs.  If you are a programmer, and you wish to
+include the features found in GNU Readline such as completion, line
+editing, and interactive history manipulation in your own programs,
+this section is for you.
+
+* Menu:
+
+* Basic Behavior::	Using the default behavior of Readline.
+* Custom Functions::	Adding your own functions to Readline.
+* Readline Variables::			Variables accessible to custom
+					functions.
+* Readline Convenience Functions::	Functions which Readline supplies to
+					aid in writing your own
+* Custom Completers::	Supplanting or supplementing Readline's
+			completion functions.
+
+
+File: readline.info,  Node: Basic Behavior,  Next: Custom Functions,  Up: Programming with GNU Readline
+
+Basic Behavior
+==============
+
+   Many programs provide a command line interface, such as `mail',
+`ftp', and `sh'.  For such programs, the default behaviour of Readline
+is sufficient.  This section describes how to use Readline in the
+simplest way possible, perhaps to replace calls in your code to
+`gets()' or `fgets ()'.
+
+   The function `readline ()' prints a prompt and then reads and returns
+a single line of text from the user.  The line `readline' returns is
+allocated with `malloc ()'; you should `free ()' the line when you are
+done with it.  The declaration for `readline' in ANSI C is
+
+     `char *readline (char *PROMPT);'
+
+So, one might say
+     `char *line = readline ("Enter a line: ");'
+
+in order to read a line of text from the user.  The line returned has
+the final newline removed, so only the text remains.
+
+   If `readline' encounters an `EOF' while reading the line, and the
+line is empty at that point, then `(char *)NULL' is returned.
+Otherwise, the line is ended just as if a newline had been typed.
+
+   If you want the user to be able to get at the line later, (with C-p
+for example), you must call `add_history ()' to save the line away in a
+"history" list of such lines.
+
+     `add_history (line)';
+
+For full details on the GNU History Library, see the associated manual.
+
+   It is preferable to avoid saving empty lines on the history list,
+since users rarely have a burning need to reuse a blank line.  Here is
+a function which usefully replaces the standard `gets ()' library
+function, and has the advantage of no static buffer to overflow:
+
+     /* A static variable for holding the line. */
+     static char *line_read = (char *)NULL;
+     
+     /* Read a string, and return a pointer to it.  Returns NULL on EOF. */
+     char *
+     rl_gets ()
+     {
+       /* If the buffer has already been allocated, return the memory
+          to the free pool. */
+       if (line_read)
+         {
+           free (line_read);
+           line_read = (char *)NULL;
+         }
+     
+       /* Get a line from the user. */
+       line_read = readline ("");
+     
+       /* If the line has any text in it, save it on the history. */
+       if (line_read && *line_read)
+         add_history (line_read);
+     
+       return (line_read);
+     }
+
+   This function gives the user the default behaviour of TAB
+completion: completion on file names.  If you do not want Readline to
+complete on filenames, you can change the binding of the TAB key with
+`rl_bind_key ()'.
+
+     `int rl_bind_key (int KEY, int (*FUNCTION)());'
+
+   `rl_bind_key ()' takes two arguments: KEY is the character that you
+want to bind, and FUNCTION is the address of the function to call when
+KEY is pressed.  Binding TAB to `rl_insert ()' makes TAB insert itself.
+`rl_bind_key ()' returns non-zero if KEY is not a valid ASCII character
+code (between 0 and 255).
+
+   Thus, to disable the default TAB behavior, the following suffices:
+     `rl_bind_key ('\t', rl_insert);'
+
+   This code should be executed once at the start of your program; you
+might write a function called `initialize_readline ()' which performs
+this and other desired initializations, such as installing custom
+completers (*note Custom Completers::.).
+
+
+File: readline.info,  Node: Custom Functions,  Next: Readline Variables,  Prev: Basic Behavior,  Up: Programming with GNU Readline
+
+Custom Functions
+================
+
+   Readline provides many functions for manipulating the text of the
+line, but it isn't possible to anticipate the needs of all programs.
+This section describes the various functions and variables defined
+within the Readline library which allow a user program to add
+customized functionality to Readline.
+
+* Menu:
+
+* The Function Type::	C declarations to make code readable.
+* Function Writing::	Variables and calling conventions.
+
+
+File: readline.info,  Node: The Function Type,  Next: Function Writing,  Up: Custom Functions
+
+The Function Type
+-----------------
+
+   For readabilty, we declare a new type of object, called "Function".
+A `Function' is a C function which returns an `int'.  The type
+declaration for `Function' is:
+
+`typedef int Function ();'
+
+   The reason for declaring this new type is to make it easier to write
+code describing pointers to C functions.  Let us say we had a variable
+called FUNC which was a pointer to a function.  Instead of the classic
+C declaration
+
+   `int (*)()func;'
+
+we may write
+
+   `Function *func;'
+
+Similarly, there are
+
+     typedef void VFunction ();
+     typedef char *CPFunction (); and
+     typedef char **CPPFunction ();
+
+for functions returning no value, `pointer to char', and `pointer to
+pointer to char', respectively.
+
+
+File: readline.info,  Node: Function Writing,  Prev: The Function Type,  Up: Custom Functions
+
+Writing a New Function
+----------------------
+
+   In order to write new functions for Readline, you need to know the
+calling conventions for keyboard-invoked functions, and the names of the
+variables that describe the current state of the line read so far.
+
+   The calling sequence for a command `foo' looks like
+
+     `foo (int count, int key)'
+
+where COUNT is the numeric argument (or 1 if defaulted) and KEY is the
+key that invoked this function.
+
+   It is completely up to the function as to what should be done with
+the numeric argument.  Some functions use it as a repeat count, some as
+a flag, and others to choose alternate behavior (refreshing the current
+line as opposed to refreshing the screen, for example).  Some choose to
+ignore it.  In general, if a function uses the numeric argument as a
+repeat count, it should be able to do something useful with both
+negative and positive arguments.  At the very least, it should be aware
+that it can be passed a negative argument.
+
+
+File: readline.info,  Node: Readline Variables,  Next: Readline Convenience Functions,  Prev: Custom Functions,  Up: Programming with GNU Readline
+
+Readline Variables
+==================
+
+   These variables are available to function writers.
+
+ - Variable: char * rl_line_buffer
+     This is the line gathered so far.  You are welcome to modify the
+     contents of the line, but see *Note Allowing Undoing::.
+
+ - Variable: int rl_point
+     The offset of the current cursor position in `rl_line_buffer' (the
+     *point*).
+
+ - Variable: int rl_end
+     The number of characters present in `rl_line_buffer'.  When
+     `rl_point' is at the end of the line, `rl_point' and `rl_end' are
+     equal.
+
+ - Variable: int rl_mark
+     The mark (saved position) in the current line.  If set, the mark
+     and point define a *region*.
+
+ - Variable: int rl_done
+     Setting this to a non-zero value causes Readline to return the
+     current line immediately.
+
+ - Variable: int rl_pending_input
+     Setting this to a value makes it the next keystroke read.  This is
+     a way to stuff a single character into the input stream.
+
+ - Variable: char * rl_prompt
+     The prompt Readline uses.  This is set from the argument to
+     `readline ()', and should not be assigned to directly.
+
+ - Variable: char * rl_library_version
+     The version number of this revision of the library.
+
+ - Variable: char * rl_terminal_name
+     The terminal type, used for initialization.
+
+ - Variable: char * rl_readline_name
+     This variable is set to a unique name by each application using
+     Readline.  The value allows conditional parsing of the inputrc file
+     (*note Conditional Init Constructs::.).
+
+ - Variable: FILE * rl_instream
+     The stdio stream from which Readline reads input.
+
+ - Variable: FILE * rl_outstream
+     The stdio stream to which Readline performs output.
+
+ - Variable: Function * rl_startup_hook
+     If non-zero, this is the address of a function to call just before
+     `readline' prints the first prompt.
+
+ - Variable: Function * rl_event_hook
+     If non-zero, this is the address of a function to call periodically
+     when readline is waiting for terminal input.
+
+ - Variable: Function * rl_getc_function
+     If non-zero, `readline' will call indirectly through this pointer
+     to get a character from the input stream.  By default, it is set to
+     `rl_getc', the default `readline' character input function (*note
+     Utility Functions::.).
+
+ - Variable: VFunction * rl_redisplay_function
+     If non-zero, `readline' will call indirectly through this pointer
+     to update the display with the current contents of the editing
+     buffer.  By default, it is set to `rl_redisplay', the default
+     `readline' redisplay function (*note Redisplay::.).
+
+ - Variable: Keymap rl_executing_keymap
+     This variable is set to the keymap (*note Keymaps::.) in which the
+     currently executing readline function was found.
+
+ - Variable: Keymap rl_binding_keymap
+     This variable is set to the keymap (*note Keymaps::.) in which the
+     last key binding occurred.
+
+
+File: readline.info,  Node: Readline Convenience Functions,  Next: Custom Completers,  Prev: Readline Variables,  Up: Programming with GNU Readline
+
+Readline Convenience Functions
+==============================
+
+* Menu:
+
+* Function Naming::	How to give a function you write a name.
+* Keymaps::		Making keymaps.
+* Binding Keys::	Changing Keymaps.
+* Associating Function Names and Bindings::	Translate function names to
+						key sequences.
+* Allowing Undoing::	How to make your functions undoable.
+* Redisplay::		Functions to control line display.
+* Modifying Text::	Functions to modify `rl_line_buffer'.
+* Utility Functions::	Generally useful functions and hooks.
+* Alternate Interface::	Using Readline in a `callback' fashion.
+
+
+File: readline.info,  Node: Function Naming,  Next: Keymaps,  Up: Readline Convenience Functions
+
+Naming a Function
+-----------------
+
+   The user can dynamically change the bindings of keys while using
+Readline.  This is done by representing the function with a descriptive
+name.  The user is able to type the descriptive name when referring to
+the function.  Thus, in an init file, one might find
+
+     Meta-Rubout:	backward-kill-word
+
+   This binds the keystroke Meta-Rubout to the function *descriptively*
+named `backward-kill-word'.  You, as the programmer, should bind the
+functions you write to descriptive names as well.  Readline provides a
+function for doing that:
+
+ - Function: int rl_add_defun (char *name, Function *function, int key)
+     Add NAME to the list of named functions.  Make FUNCTION be the
+     function that gets called.  If KEY is not -1, then bind it to
+     FUNCTION using `rl_bind_key ()'.
+
+   Using this function alone is sufficient for most applications.  It is
+the recommended way to add a few functions to the default functions that
+Readline has built in.  If you need to do something other than adding a
+function to Readline, you may need to use the underlying functions
+described below.
+
+
+File: readline.info,  Node: Keymaps,  Next: Binding Keys,  Prev: Function Naming,  Up: Readline Convenience Functions
+
+Selecting a Keymap
+------------------
+
+   Key bindings take place on a "keymap".  The keymap is the
+association between the keys that the user types and the functions that
+get run.  You can make your own keymaps, copy existing keymaps, and tell
+Readline which keymap to use.
+
+ - Function: Keymap rl_make_bare_keymap ()
+     Returns a new, empty keymap.  The space for the keymap is
+     allocated with `malloc ()'; you should `free ()' it when you are
+     done.
+
+ - Function: Keymap rl_copy_keymap (Keymap map)
+     Return a new keymap which is a copy of MAP.
+
+ - Function: Keymap rl_make_keymap ()
+     Return a new keymap with the printing characters bound to
+     rl_insert, the lowercase Meta characters bound to run their
+     equivalents, and the Meta digits bound to produce numeric
+     arguments.
+
+ - Function: void rl_discard_keymap (Keymap keymap)
+     Free the storage associated with KEYMAP.
+
+   Readline has several internal keymaps.  These functions allow you to
+change which keymap is active.
+
+ - Function: Keymap rl_get_keymap ()
+     Returns the currently active keymap.
+
+ - Function: void rl_set_keymap (Keymap keymap)
+     Makes KEYMAP the currently active keymap.
+
+ - Function: Keymap rl_get_keymap_by_name (char *name)
+     Return the keymap matching NAME.  NAME is one which would be
+     supplied in a `set keymap' inputrc line (*note Readline Init
+     File::.).
+
+ - Function: char * rl_get_keymap_name (Keymap keymap)
+     Return the name matching KEYMAP.  NAME is one which would be
+     supplied in a `set keymap' inputrc line (*note Readline Init
+     File::.).
+
+
+File: readline.info,  Node: Binding Keys,  Next: Associating Function Names and Bindings,  Prev: Keymaps,  Up: Readline Convenience Functions
+
+Binding Keys
+------------
+
+   You associate keys with functions through the keymap.  Readline has
+several internal keymaps: `emacs_standard_keymap', `emacs_meta_keymap',
+`emacs_ctlx_keymap', `vi_movement_keymap', and `vi_insertion_keymap'.
+`emacs_standard_keymap' is the default, and the examples in this manual
+assume that.
+
+   These functions manage key bindings.
+
+ - Function: int rl_bind_key (int key, Function *function)
+     Binds KEY to FUNCTION in the currently active keymap.  Returns
+     non-zero in the case of an invalid KEY.
+
+ - Function: int rl_bind_key_in_map (int key, Function *function,
+          Keymap map)
+     Bind KEY to FUNCTION in MAP.  Returns non-zero in the case of an
+     invalid KEY.
+
+ - Function: int rl_unbind_key (int key)
+     Bind KEY to the null function in the currently active keymap.
+     Returns non-zero in case of error.
+
+ - Function: int rl_unbind_key_in_map (int key, Keymap map)
+     Bind KEY to the null function in MAP.  Returns non-zero in case of
+     error.
+
+ - Function: int rl_generic_bind (int type, char *keyseq, char *data,
+          Keymap map)
+     Bind the key sequence represented by the string KEYSEQ to the
+     arbitrary pointer DATA.  TYPE says what kind of data is pointed to
+     by DATA; this can be a function (`ISFUNC'), a macro (`ISMACR'), or
+     a keymap (`ISKMAP').  This makes new keymaps as necessary.  The
+     initial keymap in which to do bindings is MAP.
+
+ - Function: int rl_parse_and_bind (char *line)
+     Parse LINE as if it had been read from the `inputrc' file and
+     perform any key bindings and variable assignments found (*note
+     Readline Init File::.).
+
+ - Function: int rl_read_init_file (char *filename)
+     Read keybindings and variable assignments from FILENAME (*note
+     Readline Init File::.).
+
+
+File: readline.info,  Node: Associating Function Names and Bindings,  Next: Allowing Undoing,  Prev: Binding Keys,  Up: Readline Convenience Functions
+
+Associating Function Names and Bindings
+---------------------------------------
+
+   These functions allow you to find out what keys invoke named
+functions and the functions invoked by a particular key sequence.
+
+ - Function: Function * rl_named_function (char *name)
+     Return the function with name NAME.
+
+ - Function: Function * rl_function_of_keyseq (char *keyseq, Keymap
+          map, int *type)
+     Return the function invoked by KEYSEQ in keymap MAP.  If MAP is
+     NULL, the current keymap is used.  If TYPE is not NULL, the type
+     of the object is returned in it (one of `ISFUNC', `ISKMAP', or
+     `ISMACR').
+
+ - Function: char ** rl_invoking_keyseqs (Function *function)
+     Return an array of strings representing the key sequences used to
+     invoke FUNCTION in the current keymap.
+
+ - Function: char ** rl_invoking_keyseqs_in_map (Function *function,
+          Keymap map)
+     Return an array of strings representing the key sequences used to
+     invoke FUNCTION in the keymap MAP.
+
+ - Function: void rl_function_dumper (int readable)
+     Print the readline function names and the key sequences currently
+     bound to them to `rl_outstream'.  If READABLE is non-zero, the
+     list is formatted in such a way that it can be made part of an
+     `inputrc' file and re-read.
+
+ - Function: void rl_list_funmap_names ()
+     Print the names of all bindable Readline functions to
+     `rl_outstream'.
+
+
+File: readline.info,  Node: Allowing Undoing,  Next: Redisplay,  Prev: Associating Function Names and Bindings,  Up: Readline Convenience Functions
+
+Allowing Undoing
+----------------
+
+   Supporting the undo command is a painless thing, and makes your
+functions much more useful.  It is certainly easy to try something if
+you know you can undo it.  I could use an undo function for the stock
+market.
+
+   If your function simply inserts text once, or deletes text once, and
+uses `rl_insert_text ()' or `rl_delete_text ()' to do it, then undoing
+is already done for you automatically.
+
+   If you do multiple insertions or multiple deletions, or any
+combination of these operations, you should group them together into
+one operation.  This is done with `rl_begin_undo_group ()' and
+`rl_end_undo_group ()'.
+
+   The types of events that can be undone are:
+
+     enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };
+
+   Notice that `UNDO_DELETE' means to insert some text, and
+`UNDO_INSERT' means to delete some text.  That is, the undo code tells
+undo what to undo, not how to undo it.  `UNDO_BEGIN' and `UNDO_END' are
+tags added by `rl_begin_undo_group ()' and `rl_end_undo_group ()'.
+
+ - Function: int rl_begin_undo_group ()
+     Begins saving undo information in a group construct.  The undo
+     information usually comes from calls to `rl_insert_text ()' and
+     `rl_delete_text ()', but could be the result of calls to
+     `rl_add_undo ()'.
+
+ - Function: int rl_end_undo_group ()
+     Closes the current undo group started with `rl_begin_undo_group
+     ()'.  There should be one call to `rl_end_undo_group ()' for each
+     call to `rl_begin_undo_group ()'.
+
+ - Function: void rl_add_undo (enum undo_code what, int start, int end,
+          char *text)
+     Remember how to undo an event (according to WHAT).  The affected
+     text runs from START to END, and encompasses TEXT.
+
+ - Function: void free_undo_list ()
+     Free the existing undo list.
+
+ - Function: int rl_do_undo ()
+     Undo the first thing on the undo list.  Returns `0' if there was
+     nothing to undo, non-zero if something was undone.
+
+   Finally, if you neither insert nor delete text, but directly modify
+the existing text (e.g., change its case), call `rl_modifying ()' once,
+just before you modify the text.  You must supply the indices of the
+text range that you are going to modify.
+
+ - Function: int rl_modifying (int start, int end)
+     Tell Readline to save the text between START and END as a single
+     undo unit.  It is assumed that you will subsequently modify that
+     text.
+
+
+File: readline.info,  Node: Redisplay,  Next: Modifying Text,  Prev: Allowing Undoing,  Up: Readline Convenience Functions
+
+Redisplay
+---------
+
+ - Function: void rl_redisplay ()
+     Change what's displayed on the screen to reflect the current
+     contents of `rl_line_buffer'.
+
+ - Function: int rl_forced_update_display ()
+     Force the line to be updated and redisplayed, whether or not
+     Readline thinks the screen display is correct.
+
+ - Function: int rl_on_new_line ()
+     Tell the update routines that we have moved onto a new (empty)
+     line, usually after ouputting a newline.
+
+ - Function: int rl_reset_line_state ()
+     Reset the display state to a clean state and redisplay the current
+     line starting on a new line.
+
+ - Function: int rl_message (va_alist)
+     The arguments are a string as would be supplied to `printf'.  The
+     resulting string is displayed in the "echo area".  The echo area
+     is also used to display numeric arguments and search strings.
+
+ - Function: int rl_clear_message ()
+     Clear the message in the echo area.
+
+
+File: readline.info,  Node: Modifying Text,  Next: Utility Functions,  Prev: Redisplay,  Up: Readline Convenience Functions
+
+Modifying Text
+--------------
+
+ - Function: int rl_insert_text (char *text)
+     Insert TEXT into the line at the current cursor position.
+
+ - Function: int rl_delete_text (int start, int end)
+     Delete the text between START and END in the current line.
+
+ - Function: char * rl_copy_text (int start, int end)
+     Return a copy of the text between START and END in the current
+     line.
+
+ - Function: int rl_kill_text (int start, int end)
+     Copy the text between START and END in the current line to the
+     kill ring, appending or prepending to the last kill if the last
+     command was a kill command.  The text is deleted.  If START is
+     less than END, the text is appended, otherwise prepended.  If the
+     last command was not a kill, a new kill ring slot is used.
+
+
+File: readline.info,  Node: Utility Functions,  Next: Alternate Interface,  Prev: Modifying Text,  Up: Readline Convenience Functions
+
+Utility Functions
+-----------------
+
+ - Function: int rl_read_key ()
+     Return the next character available.  This handles input inserted
+     into the input stream via PENDING INPUT (*note Readline
+     Variables::.) and `rl_stuff_char ()', macros, and characters read
+     from the keyboard.
+
+ - Function: int rl_getc (FILE *)
+     Return the next character available from the keyboard.
+
+ - Function: int rl_stuff_char (int c)
+     Insert C into the Readline input stream.  It will be "read" before
+     Readline attempts to read characters from the terminal with
+     `rl_read_key ()'.
+
+ - Function: rl_extend_line_buffer (int len)
+     Ensure that `rl_line_buffer' has enough space to hold LEN
+     characters, possibly reallocating it if necessary.
+
+ - Function: int rl_initialize ()
+     Initialize or re-initialize Readline's internal state.
+
+ - Function: int rl_reset_terminal (char *terminal_name)
+     Reinitialize Readline's idea of the terminal settings using
+     TERMINAL_NAME as the terminal type (e.g., `vt100').
+
+ - Function: int alphabetic (int c)
+     Return 1 if C is an alphabetic character.
+
+ - Function: int numeric (int c)
+     Return 1 if C is a numeric character.
+
+ - Function: int ding ()
+     Ring the terminal bell, obeying the setting of `bell-style'.
+
+   The following are implemented as macros, defined in `chartypes.h'.
+
+ - Function: int uppercase_p (int c)
+     Return 1 if C is an uppercase alphabetic character.
+
+ - Function: int lowercase_p (int c)
+     Return 1 if C is a lowercase alphabetic character.
+
+ - Function: int digit_p (int c)
+     Return 1 if C is a numeric character.
+
+ - Function: int to_upper (int c)
+     If C is a lowercase alphabetic character, return the corresponding
+     uppercase character.
+
+ - Function: int to_lower (int c)
+     If C is an uppercase alphabetic character, return the corresponding
+     lowercase character.
+
+ - Function: int digit_value (int c)
+     If C is a number, return the value it represents.
+
+
+File: readline.info,  Node: Alternate Interface,  Prev: Utility Functions,  Up: Readline Convenience Functions
+
+Alternate Interface
+-------------------
+
+   An alternate interface is available to plain `readline()'.  Some
+applications need to interleave keyboard I/O with file, device, or
+window system I/O, typically by using a main loop to `select()' on
+various file descriptors.  To accomodate this need, readline can also
+be invoked as a `callback' function from an event loop.  There are
+functions available to make this easy.
+
+ - Function: void rl_callback_handler_install (char *prompt, Vfunction
+          *lhandler)
+     Set up the terminal for readline I/O and display the initial
+     expanded value of PROMPT.  Save the value of LHANDLER to use as a
+     callback when a complete line of input has been entered.
+
+ - Function: void rl_callback_read_char ()
+     Whenever an application determines that keyboard input is
+     available, it should call `rl_callback_read_char()', which will
+     read the next character from the current input source.  If that
+     character completes the line, `rl_callback_read_char' will invoke
+     the LHANDLER function saved by `rl_callback_handler_install' to
+     process the line.  `EOF' is  indicated by calling LHANDLER with a
+     `NULL' line.
+
+ - Function: void rl_callback_handler_remove ()
+     Restore the terminal to its initial state and remove the line
+     handler.  This may be called from within a callback as well as
+     independently.
+
+An Example
+----------
+
+   Here is a function which changes lowercase characters to their
+uppercase equivalents, and uppercase characters to lowercase.  If this
+function was bound to `M-c', then typing `M-c' would change the case of
+the character under point.  Typing `M-1 0 M-c' would change the case of
+the following 10 characters, leaving the cursor on the last character
+changed.
+
+     /* Invert the case of the COUNT following characters. */
+     int
+     invert_case_line (count, key)
+          int count, key;
+     {
+       register int start, end, i;
+     
+       start = rl_point;
+     
+       if (rl_point >= rl_end)
+         return (0);
+     
+       if (count < 0)
+         {
+           direction = -1;
+           count = -count;
+         }
+       else
+         direction = 1;
+     
+       /* Find the end of the range to modify. */
+       end = start + (count * direction);
+     
+       /* Force it to be within range. */
+       if (end > rl_end)
+         end = rl_end;
+       else if (end < 0)
+         end = 0;
+     
+       if (start == end)
+         return (0);
+     
+       if (start > end)
+         {
+           int temp = start;
+           start = end;
+           end = temp;
+         }
+     
+       /* Tell readline that we are modifying the line, so it will save
+          the undo information. */
+       rl_modifying (start, end);
+     
+       for (i = start; i != end; i++)
+         {
+           if (uppercase_p (rl_line_buffer[i]))
+             rl_line_buffer[i] = to_lower (rl_line_buffer[i]);
+           else if (lowercase_p (rl_line_buffer[i]))
+             rl_line_buffer[i] = to_upper (rl_line_buffer[i]);
+         }
+       /* Move point to on top of the last character changed. */
+       rl_point = (direction == 1) ? end - 1 : start;
+       return (0);
+     }
+
+
+File: readline.info,  Node: Custom Completers,  Prev: Readline Convenience Functions,  Up: Programming with GNU Readline
+
+Custom Completers
+=================
+
+   Typically, a program that reads commands from the user has a way of
+disambiguating commands and data.  If your program is one of these, then
+it can provide completion for commands, data, or both.  The following
+sections describe how your program and Readline cooperate to provide
+this service.
+
+* Menu:
+
+* How Completing Works::	The logic used to do completion.
+* Completion Functions::	Functions provided by Readline.
+* Completion Variables::	Variables which control completion.
+* A Short Completion Example::	An example of writing completer subroutines.
+
+
+File: readline.info,  Node: How Completing Works,  Next: Completion Functions,  Up: Custom Completers
+
+How Completing Works
+--------------------
+
+   In order to complete some text, the full list of possible completions
+must be available.  That is, it is not possible to accurately expand a
+partial word without knowing all of the possible words which make sense
+in that context.  The Readline library provides the user interface to
+completion, and two of the most common completion functions:  filename
+and username.  For completing other types of text, you must write your
+own completion function.  This section describes exactly what such
+functions must do, and provides an example.
+
+   There are three major functions used to perform completion:
+
+  1. The user-interface function `rl_complete ()'.  This function is
+     called with the same arguments as other Readline functions
+     intended for interactive use:  COUNT and INVOKING_KEY.  It
+     isolates the word to be completed and calls `completion_matches
+     ()' to generate a list of possible completions.  It then either
+     lists the possible completions, inserts the possible completions,
+     or actually performs the completion, depending on which behavior
+     is desired.
+
+  2. The internal function `completion_matches ()' uses your
+     "generator" function to generate the list of possible matches, and
+     then returns the array of these matches.  You should place the
+     address of your generator function in
+     `rl_completion_entry_function'.
+
+  3. The generator function is called repeatedly from
+     `completion_matches ()', returning a string each time.  The
+     arguments to the generator function are TEXT and STATE.  TEXT is
+     the partial word to be completed.  STATE is zero the first time
+     the function is called, allowing the generator to perform any
+     necessary initialization, and a positive non-zero integer for each
+     subsequent call.  When the generator function returns `(char
+     *)NULL' this signals `completion_matches ()' that there are no
+     more possibilities left.  Usually the generator function computes
+     the list of possible completions when STATE is zero, and returns
+     them one at a time on subsequent calls.  Each string the generator
+     function returns as a match must be allocated with `malloc()';
+     Readline frees the strings when it has finished with them.
+
+
+ - Function: int rl_complete (int ignore, int invoking_key)
+     Complete the word at or before point.  You have supplied the
+     function that does the initial simple matching selection algorithm
+     (see `completion_matches ()').  The default is to do filename
+     completion.
+
+ - Variable: Function * rl_completion_entry_function
+     This is a pointer to the generator function for `completion_matches
+     ()'.  If the value of `rl_completion_entry_function' is `(Function
+     *)NULL' then the default filename generator function,
+     `filename_completion_function ()', is used.
+
+
+File: readline.info,  Node: Completion Functions,  Next: Completion Variables,  Prev: How Completing Works,  Up: Custom Completers
+
+Completion Functions
+--------------------
+
+   Here is the complete list of callable completion functions present in
+Readline.
+
+ - Function: int rl_complete_internal (int what_to_do)
+     Complete the word at or before point.  WHAT_TO_DO says what to do
+     with the completion.  A value of `?' means list the possible
+     completions.  `TAB' means do standard completion.  `*' means
+     insert all of the possible completions.  `!' means to display all
+     of the possible completions, if there is more than one, as well as
+     performing partial completion.
+
+ - Function: int rl_complete (int ignore, int invoking_key)
+     Complete the word at or before point.  You have supplied the
+     function that does the initial simple matching selection algorithm
+     (see `completion_matches ()' and `rl_completion_entry_function').
+     The default is to do filename completion.  This calls
+     `rl_complete_internal ()' with an argument depending on
+     INVOKING_KEY.
+
+ - Function: int rl_possible_completions (int count, int invoking_key))
+     List the possible completions.  See description of `rl_complete
+     ()'.  This calls `rl_complete_internal ()' with an argument of `?'.
+
+ - Function: int rl_insert_completions (int count, int invoking_key))
+     Insert the list of possible completions into the line, deleting the
+     partially-completed word.  See description of `rl_complete ()'.
+     This calls `rl_complete_internal ()' with an argument of `*'.
+
+ - Function: char ** completion_matches (char *text, CPFunction
+          *entry_func)
+     Returns an array of `(char *)' which is a list of completions for
+     TEXT.  If there are no completions, returns `(char **)NULL'.  The
+     first entry in the returned array is the substitution for TEXT.
+     The remaining entries are the possible completions.  The array is
+     terminated with a `NULL' pointer.
+
+     ENTRY_FUNC is a function of two args, and returns a `(char *)'.
+     The first argument is TEXT.  The second is a state argument; it is
+     zero on the first call, and non-zero on subsequent calls.
+     eNTRY_FUNC returns a `NULL'  pointer to the caller when there are
+     no more matches.
+
+ - Function: char * filename_completion_function (char *text, int state)
+     A generator function for filename completion in the general case.
+     Note that completion in Bash is a little different because of all
+     the pathnames that must be followed when looking up completions
+     for a command.  The Bash source is a useful reference for writing
+     custom completion functions.
+
+ - Function: char * username_completion_function (char *text, int state)
+     A completion generator for usernames.  TEXT contains a partial
+     username preceded by a random character (usually `~').  As with all
+     completion generators, STATE is zero on the first call and non-zero
+     for subsequent calls.
+
+
+File: readline.info,  Node: Completion Variables,  Next: A Short Completion Example,  Prev: Completion Functions,  Up: Custom Completers
+
+Completion Variables
+--------------------
+
+ - Variable: Function * rl_completion_entry_function
+     A pointer to the generator function for `completion_matches ()'.
+     `NULL' means to use `filename_entry_function ()', the default
+     filename completer.
+
+ - Variable: CPPFunction * rl_attempted_completion_function
+     A pointer to an alternative function to create matches.  The
+     function is called with TEXT, START, and END.  START and END are
+     indices in `rl_line_buffer' saying what the boundaries of TEXT
+     are.  If this function exists and returns `NULL', or if this
+     variable is set to `NULL', then `rl_complete ()' will call the
+     value of `rl_completion_entry_function' to generate matches,
+     otherwise the array of strings returned will be used.
+
+ - Variable: CPFunction * rl_filename_quoting_function
+     A pointer to a function that will quote a filename in an
+     application- specific fashion.  This is called if filename
+     completion is being attempted and one of the characters in
+     `rl_filename_quote_characters' appears in a completed filename.
+     The function is called with TEXT, MATCH_TYPE, and QUOTE_POINTER.
+     The TEXT is the filename to be quoted.  The MATCH_TYPE is either
+     `SINGLE_MATCH', if there is only one completion match, or
+     `MULT_MATCH'.  Some functions use this to decide whether or not to
+     insert a closing quote character.  The QUOTE_POINTER is a pointer
+     to any opening quote character the user typed.  Some functions
+     choose to reset this character.
+
+ - Variable: CPFunction * rl_filename_dequoting_function
+     A pointer to a function that will remove application-specific
+     quoting characters from a filename before completion is attempted,
+     so those characters do not interfere with matching the text
+     against names in the filesystem.  It is called with TEXT, the text
+     of the word to be dequoted, and QUOTE_CHAR, which is the quoting
+     character that delimits the filename (usually `'' or `"').  If
+     QUOTE_CHAR is zero, the filename was not in an embedded string.
+
+ - Variable: Function * rl_char_is_quoted_p
+     A pointer to a function to call that determines whether or not a
+     specific character in the line buffer is quoted, according to
+     whatever quoting mechanism the program calling readline uses.  The
+     function is called with two arguments: TEXT, the text of the line,
+     and INDEX, the index of the character in the line.  It is used to
+     decide whether a character found in
+     `rl_completer_word_break_characters' should be used to break words
+     for the completer.
+
+ - Variable: int rl_completion_query_items
+     Up to this many items will be displayed in response to a
+     possible-completions call.  After that, we ask the user if she is
+     sure she wants to see them all.  The default value is 100.
+
+ - Variable: char * rl_basic_word_break_characters
+     The basic list of characters that signal a break between words for
+     the completer routine.  The default value of this variable is the
+     characters which break words for completion in Bash, i.e., `"
+     \t\n\"\\'`@$><=;|&{("'.
+
+ - Variable: char * rl_basic_quote_characters
+     List of quote characters which can cause a word break.
+
+ - Variable: char * rl_completer_word_break_characters
+     The list of characters that signal a break between words for
+     `rl_complete_internal ()'.  The default list is the value of
+     `rl_basic_word_break_characters'.
+
+ - Variable: char * rl_completer_quote_characters
+     List of characters which can be used to quote a substring of the
+     line.  Completion occurs on the entire substring, and within the
+     substring `rl_completer_word_break_characters' are treated as any
+     other character, unless they also appear within this list.
+
+ - Variable: char * rl_filename_quote_characters
+     A list of characters that cause a filename to be quoted by the
+     completer when they appear in a completed filename.  The default
+     is empty.
+
+ - Variable: char * rl_special_prefixes
+     The list of characters that are word break characters, but should
+     be left in TEXT when it is passed to the completion function.
+     Programs can use this to help determine what kind of completing to
+     do.  For instance, Bash sets this variable to "$@" so that it can
+     complete shell variables and hostnames.
+
+ - Variable: int rl_completion_append_character
+     When a single completion alternative matches at the end of the
+     command line, this character is appended to the inserted
+     completion text.  The default is a space character (` ').  Setting
+     this to the null character (`\0') prevents anything being appended
+     automatically.  This can be changed in custom completion functions
+     to provide the "most sensible word separator character" according
+     to an application-specific command line syntax specification.
+
+ - Variable: int rl_ignore_completion_duplicates
+     If non-zero, then disallow duplicates in the matches.  Default is
+     1.
+
+ - Variable: int rl_filename_completion_desired
+     Non-zero means that the results of the matches are to be treated as
+     filenames.  This is *always* zero on entry, and can only be changed
+     within a completion entry generator function.  If it is set to a
+     non-zero value, directory names have a slash appended and Readline
+     attempts to quote completed filenames if they contain any embedded
+     word break characters.
+
+ - Variable: int rl_filename_quoting_desired
+     Non-zero means that the results of the matches are to be quoted
+     using double quotes (or an application-specific quoting mechanism)
+     if the completed filename contains any characters in
+     `rl_filename_quote_chars'.  This is *always* non-zero on entry,
+     and can only be changed within a completion entry generator
+     function.  The quoting is effected via a call to the function
+     pointed to by `rl_filename_quoting_function'.
+
+ - Variable: int rl_inhibit_completion
+     If this variable is non-zero, completion is inhibit<ed.  The
+     completion character will be inserted as any other bound to
+     `self-insert'.
+
+ - Variable: Function * rl_ignore_some_completions_function
+     This function, if defined, is called by the completer when real
+     filename completion is done, after all the matching names have
+     been generated.  It is passed a `NULL' terminated array of matches.
+     The first element (`matches[0]') is the maximal substring common
+     to all matches. This function can re-arrange the list of matches
+     as required, but each element deleted from the array must be freed.
+
+ - Variable: Function * rl_directory_completion_hook
+     This function, if defined, is allowed to modify the directory
+     portion of filenames Readline completes.  It is called with the
+     address of a string (the current directory name) as an argument.
+     It could be used to expand symbolic links or shell variables in
+     pathnames.
+
+
+File: readline.info,  Node: A Short Completion Example,  Prev: Completion Variables,  Up: Custom Completers
+
+A Short Completion Example
+--------------------------
+
+   Here is a small application demonstrating the use of the GNU Readline
+library.  It is called `fileman', and the source code resides in
+`examples/fileman.c'.  This sample application provides completion of
+command names, line editing features, and access to the history list.
+
+     /* fileman.c -- A tiny application which demonstrates how to use the
+        GNU Readline library.  This application interactively allows users
+        to manipulate files and their modes. */
+     
+     #include <stdio.h>
+     #include <sys/types.h>
+     #include <sys/file.h>
+     #include <sys/stat.h>
+     #include <sys/errno.h>
+     
+     #include <readline/readline.h>
+     #include <readline/history.h>
+     
+     extern char *getwd ();
+     extern char *xmalloc ();
+     
+     /* The names of functions that actually do the manipulation. */
+     int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
+     int com_delete (), com_help (), com_cd (), com_quit ();
+     
+     /* A structure which contains information on the commands this program
+        can understand. */
+     
+     typedef struct {
+       char *name;			/* User printable name of the function. */
+       Function *func;		/* Function to call to do the job. */
+       char *doc;			/* Documentation for this function.  */
+     } COMMAND;
+     
+     COMMAND commands[] = {
+       { "cd", com_cd, "Change to directory DIR" },
+       { "delete", com_delete, "Delete FILE" },
+       { "help", com_help, "Display this text" },
+       { "?", com_help, "Synonym for `help'" },
+       { "list", com_list, "List files in DIR" },
+       { "ls", com_list, "Synonym for `list'" },
+       { "pwd", com_pwd, "Print the current working directory" },
+       { "quit", com_quit, "Quit using Fileman" },
+       { "rename", com_rename, "Rename FILE to NEWNAME" },
+       { "stat", com_stat, "Print out statistics on FILE" },
+       { "view", com_view, "View the contents of FILE" },
+       { (char *)NULL, (Function *)NULL, (char *)NULL }
+     };
+     
+     /* Forward declarations. */
+     char *stripwhite ();
+     COMMAND *find_command ();
+     
+     /* The name of this program, as taken from argv[0]. */
+     char *progname;
+     
+     /* When non-zero, this global means the user is done using this program. */
+     int done;
+     
+     char *
+     dupstr (s)
+          int s;
+     {
+       char *r;
+     
+       r = xmalloc (strlen (s) + 1);
+       strcpy (r, s);
+       return (r);
+     }
+     
+     main (argc, argv)
+          int argc;
+          char **argv;
+     {
+       char *line, *s;
+     
+       progname = argv[0];
+     
+       initialize_readline ();	/* Bind our completer. */
+     
+       /* Loop reading and executing lines until the user quits. */
+       for ( ; done == 0; )
+         {
+           line = readline ("FileMan: ");
+     
+           if (!line)
+             break;
+     
+           /* Remove leading and trailing whitespace from the line.
+              Then, if there is anything left, add it to the history list
+              and execute it. */
+           s = stripwhite (line);
+     
+           if (*s)
+             {
+               add_history (s);
+               execute_line (s);
+             }
+     
+           free (line);
+         }
+       exit (0);
+     }
+     
+     /* Execute a command line. */
+     int
+     execute_line (line)
+          char *line;
+     {
+       register int i;
+       COMMAND *command;
+       char *word;
+     
+       /* Isolate the command word. */
+       i = 0;
+       while (line[i] && whitespace (line[i]))
+         i++;
+       word = line + i;
+     
+       while (line[i] && !whitespace (line[i]))
+         i++;
+     
+       if (line[i])
+         line[i++] = '\0';
+     
+       command = find_command (word);
+     
+       if (!command)
+         {
+           fprintf (stderr, "%s: No such command for FileMan.\n", word);
+           return (-1);
+         }
+     
+       /* Get argument to command, if any. */
+       while (whitespace (line[i]))
+         i++;
+     
+       word = line + i;
+     
+       /* Call the function. */
+       return ((*(command->func)) (word));
+     }
+     
+     /* Look up NAME as the name of a command, and return a pointer to that
+        command.  Return a NULL pointer if NAME isn't a command name. */
+     COMMAND *
+     find_command (name)
+          char *name;
+     {
+       register int i;
+     
+       for (i = 0; commands[i].name; i++)
+         if (strcmp (name, commands[i].name) == 0)
+           return (&commands[i]);
+     
+       return ((COMMAND *)NULL);
+     }
+     
+     /* Strip whitespace from the start and end of STRING.  Return a pointer
+        into STRING. */
+     char *
+     stripwhite (string)
+          char *string;
+     {
+       register char *s, *t;
+     
+       for (s = string; whitespace (*s); s++)
+         ;
+     
+       if (*s == 0)
+         return (s);
+     
+       t = s + strlen (s) - 1;
+       while (t > s && whitespace (*t))
+         t--;
+       *++t = '\0';
+     
+       return s;
+     }
+     
+     /* **************************************************************** */
+     /*                                                                  */
+     /*                  Interface to Readline Completion                */
+     /*                                                                  */
+     /* **************************************************************** */
+     
+     char *command_generator ();
+     char **fileman_completion ();
+     
+     /* Tell the GNU Readline library how to complete.  We want to try to complete
+        on command names if this is the first word in the line, or on filenames
+        if not. */
+     initialize_readline ()
+     {
+       /* Allow conditional parsing of the ~/.inputrc file. */
+       rl_readline_name = "FileMan";
+     
+       /* Tell the completer that we want a crack first. */
+       rl_attempted_completion_function = (CPPFunction *)fileman_completion;
+     }
+     
+     /* Attempt to complete on the contents of TEXT.  START and END bound the
+        region of rl_line_buffer that contains the word to complete.  TEXT is
+        the word to complete.  We can use the entire contents of rl_line_buffer
+        in case we want to do some simple parsing.  Return the array of matches,
+        or NULL if there aren't any. */
+     char **
+     fileman_completion (text, start, end)
+          char *text;
+          int start, end;
+     {
+       char **matches;
+     
+       matches = (char **)NULL;
+     
+       /* If this word is at the start of the line, then it is a command
+          to complete.  Otherwise it is the name of a file in the current
+          directory. */
+       if (start == 0)
+         matches = completion_matches (text, command_generator);
+     
+       return (matches);
+     }
+     
+     /* Generator function for command completion.  STATE lets us know whether
+        to start from scratch; without any state (i.e. STATE == 0), then we
+        start at the top of the list. */
+     char *
+     command_generator (text, state)
+          char *text;
+          int state;
+     {
+       static int list_index, len;
+       char *name;
+     
+       /* If this is a new word to complete, initialize now.  This includes
+          saving the length of TEXT for efficiency, and initializing the index
+          variable to 0. */
+       if (!state)
+         {
+           list_index = 0;
+           len = strlen (text);
+         }
+     
+       /* Return the next name which partially matches from the command list. */
+       while (name = commands[list_index].name)
+         {
+           list_index++;
+     
+           if (strncmp (name, text, len) == 0)
+             return (dupstr(name));
+         }
+     
+       /* If no names matched, then return NULL. */
+       return ((char *)NULL);
+     }
+     
+     /* **************************************************************** */
+     /*                                                                  */
+     /*                       FileMan Commands                           */
+     /*                                                                  */
+     /* **************************************************************** */
+     
+     /* String to pass to system ().  This is for the LIST, VIEW and RENAME
+        commands. */
+     static char syscom[1024];
+     
+     /* List the file(s) named in arg. */
+     com_list (arg)
+          char *arg;
+     {
+       if (!arg)
+         arg = "";
+     
+       sprintf (syscom, "ls -FClg %s", arg);
+       return (system (syscom));
+     }
+     
+     com_view (arg)
+          char *arg;
+     {
+       if (!valid_argument ("view", arg))
+         return 1;
+     
+       sprintf (syscom, "more %s", arg);
+       return (system (syscom));
+     }
+     
+     com_rename (arg)
+          char *arg;
+     {
+       too_dangerous ("rename");
+       return (1);
+     }
+     
+     com_stat (arg)
+          char *arg;
+     {
+       struct stat finfo;
+     
+       if (!valid_argument ("stat", arg))
+         return (1);
+     
+       if (stat (arg, &finfo) == -1)
+         {
+           perror (arg);
+           return (1);
+         }
+     
+       printf ("Statistics for `%s':\n", arg);
+     
+       printf ("%s has %d link%s, and is %d byte%s in length.\n", arg,
+               finfo.st_nlink,
+               (finfo.st_nlink == 1) ? "" : "s",
+               finfo.st_size,
+               (finfo.st_size == 1) ? "" : "s");
+       printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
+       printf ("      Last access at: %s", ctime (&finfo.st_atime));
+       printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
+       return (0);
+     }
+     
+     com_delete (arg)
+          char *arg;
+     {
+       too_dangerous ("delete");
+       return (1);
+     }
+     
+     /* Print out help for ARG, or for all of the commands if ARG is
+        not present. */
+     com_help (arg)
+          char *arg;
+     {
+       register int i;
+       int printed = 0;
+     
+       for (i = 0; commands[i].name; i++)
+         {
+           if (!*arg || (strcmp (arg, commands[i].name) == 0))
+             {
+               printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
+               printed++;
+             }
+         }
+     
+       if (!printed)
+         {
+           printf ("No commands match `%s'.  Possibilties are:\n", arg);
+     
+           for (i = 0; commands[i].name; i++)
+             {
+               /* Print in six columns. */
+               if (printed == 6)
+                 {
+                   printed = 0;
+                   printf ("\n");
+                 }
+     
+               printf ("%s\t", commands[i].name);
+               printed++;
+             }
+     
+           if (printed)
+             printf ("\n");
+         }
+       return (0);
+     }
+     
+     /* Change to the directory ARG. */
+     com_cd (arg)
+          char *arg;
+     {
+       if (chdir (arg) == -1)
+         {
+           perror (arg);
+           return 1;
+         }
+     
+       com_pwd ("");
+       return (0);
+     }
+     
+     /* Print out the current working directory. */
+     com_pwd (ignore)
+          char *ignore;
+     {
+       char dir[1024], *s;
+     
+       s = getwd (dir);
+       if (s == 0)
+         {
+           printf ("Error getting pwd: %s\n", dir);
+           return 1;
+         }
+     
+       printf ("Current directory is %s\n", dir);
+       return 0;
+     }
+     
+     /* The user wishes to quit using this program.  Just set DONE non-zero. */
+     com_quit (arg)
+          char *arg;
+     {
+       done = 1;
+       return (0);
+     }
+     
+     /* Function which tells you that you can't do this. */
+     too_dangerous (caller)
+          char *caller;
+     {
+       fprintf (stderr,
+                "%s: Too dangerous for me to distribute.  Write it yourself.\n",
+                caller);
+     }
+     
+     /* Return non-zero if ARG is a valid argument for CALLER, else print
+        an error message and return zero. */
+     int
+     valid_argument (caller, arg)
+          char *caller, *arg;
+     {
+       if (!arg || !*arg)
+         {
+           fprintf (stderr, "%s: Argument required.\n", caller);
+           return (0);
+         }
+     
+       return (1);
+     }
+
+
+File: readline.info,  Node: Concept Index,  Next: Function and Variable Index,  Prev: Programming with GNU Readline,  Up: Top
+
+Concept Index
+*************
+
+* Menu:
+
+* command editing:                      Readline Bare Essentials.
+* editing command lines:                Readline Bare Essentials.
+* initialization file, readline:        Readline Init File.
+* interaction, readline:                Readline Interaction.
+* kill ring:                            Readline Killing Commands.
+* killing text:                         Readline Killing Commands.
+* notation, readline:                   Readline Bare Essentials.
+* readline, function:                   Basic Behavior.
+* yanking text:                         Readline Killing Commands.
+
+
+File: readline.info,  Node: Function and Variable Index,  Prev: Concept Index,  Up: Top
+
+Function and Variable Index
+***************************
+
+* Menu:
+
+* (:                                    Utility Functions.
+* abort (C-g):                          Miscellaneous Commands.
+* accept-line (Newline, Return):        Commands For History.
+* alphabetic:                           Utility Functions.
+* backward-char (C-b):                  Commands For Moving.
+* backward-delete-char (Rubout):        Commands For Text.
+* backward-kill-line (C-x Rubout):      Commands For Killing.
+* backward-kill-word (M-DEL):           Commands For Killing.
+* backward-word (M-b):                  Commands For Moving.
+* beginning-of-history (M-<):           Commands For History.
+* beginning-of-line (C-a):              Commands For Moving.
+* bell-style:                           Readline Init File Syntax.
+* call-last-kbd-macro (C-x e):          Keyboard Macros.
+* capitalize-word (M-c):                Commands For Text.
+* character-search (C-]):               Miscellaneous Commands.
+* character-search-backward (M-C-]):    Miscellaneous Commands.
+* clear-screen (C-l):                   Commands For Moving.
+* comment-begin:                        Readline Init File Syntax.
+* complete (TAB):                       Commands For Completion.
+* completion-query-items:               Readline Init File Syntax.
+* completion_matches:                   Completion Functions.
+* convert-meta:                         Readline Init File Syntax.
+* copy-backward-word ():                Commands For Killing.
+* copy-forward-word ():                 Commands For Killing.
+* copy-region-as-kill ():               Commands For Killing.
+* delete-char (C-d):                    Commands For Text.
+* delete-horizontal-space ():           Commands For Killing.
+* digit-argument (M-0, M-1, ... M-):    Numeric Arguments.
+* digit_p:                              Utility Functions.
+* digit_value:                          Utility Functions.
+* ding:                                 Utility Functions.
+* disable-completion:                   Readline Init File Syntax.
+* do-uppercase-version (M-a, M-b, M-X, ...): Miscellaneous Commands.
+* downcase-word (M-l):                  Commands For Text.
+* dump-functions ():                    Miscellaneous Commands.
+* dump-macros ():                       Miscellaneous Commands.
+* dump-variables ():                    Miscellaneous Commands.
+* editing-mode:                         Readline Init File Syntax.
+* enable-keypad:                        Readline Init File Syntax.
+* end-kbd-macro (C-x )):                Keyboard Macros.
+* end-of-history (M->):                 Commands For History.
+* end-of-line (C-e):                    Commands For Moving.
+* exchange-point-and-mark (C-x C-x):    Miscellaneous Commands.
+* expand-tilde:                         Readline Init File Syntax.
+* filename_completion_function:         Completion Functions.
+* forward-char (C-f):                   Commands For Moving.
+* forward-search-history (C-s):         Commands For History.
+* forward-word (M-f):                   Commands For Moving.
+* free_undo_list:                       Allowing Undoing.
+* history-search-backward ():           Commands For History.
+* history-search-forward ():            Commands For History.
+* horizontal-scroll-mode:               Readline Init File Syntax.
+* input-meta:                           Readline Init File Syntax.
+* insert-comment (M-#):                 Miscellaneous Commands.
+* insert-completions (M-*):             Commands For Completion.
+* keymap:                               Readline Init File Syntax.
+* kill-line (C-k):                      Commands For Killing.
+* kill-region ():                       Commands For Killing.
+* kill-whole-line ():                   Commands For Killing.
+* kill-word (M-d):                      Commands For Killing.
+* lowercase_p:                          Utility Functions.
+* mark-modified-lines:                  Readline Init File Syntax.
+* meta-flag:                            Readline Init File Syntax.
+* next-history (C-n):                   Commands For History.
+* non-incremental-forward-search-history (M-n): Commands For History.
+* non-incremental-reverse-search-history (M-p): Commands For History.
+* numeric:                              Utility Functions.
+* output-meta:                          Readline Init File Syntax.
+* possible-completions (M-?):           Commands For Completion.
+* prefix-meta (ESC):                    Miscellaneous Commands.
+* previous-history (C-p):               Commands For History.
+* quoted-insert (C-q, C-v):             Commands For Text.
+* re-read-init-file (C-x C-r):          Miscellaneous Commands.
+* readline:                             Basic Behavior.
+* redraw-current-line ():               Commands For Moving.
+* reverse-search-history (C-r):         Commands For History.
+* revert-line (M-r):                    Miscellaneous Commands.
+* rl_add_defun:                         Function Naming.
+* rl_add_undo:                          Allowing Undoing.
+* rl_attempted_completion_function:     Completion Variables.
+* rl_basic_quote_characters:            Completion Variables.
+* rl_basic_word_break_characters:       Completion Variables.
+* rl_begin_undo_group:                  Allowing Undoing.
+* rl_binding_keymap:                    Readline Variables.
+* rl_bind_key:                          Binding Keys.
+* rl_bind_key_in_map:                   Binding Keys.
+* rl_callback_handler_install:          Alternate Interface.
+* rl_callback_handler_remove:           Alternate Interface.
+* rl_callback_read_char:                Alternate Interface.
+* rl_char_is_quoted_p:                  Completion Variables.
+* rl_clear_message:                     Redisplay.
+* rl_complete:                          Completion Functions.
+* rl_complete:                          How Completing Works.
+* rl_completer_quote_characters:        Completion Variables.
+* rl_completer_word_break_characters:   Completion Variables.
+* rl_complete_internal:                 Completion Functions.
+* rl_completion_append_character:       Completion Variables.
+* rl_completion_entry_function:         Completion Variables.
+* rl_completion_entry_function:         How Completing Works.
+* rl_completion_query_items:            Completion Variables.
+* rl_copy_keymap:                       Keymaps.
+* rl_copy_text:                         Modifying Text.
+* rl_delete_text:                       Modifying Text.
+* rl_directory_completion_hook:         Completion Variables.
+* rl_discard_keymap:                    Keymaps.
+* rl_done:                              Readline Variables.
+* rl_do_undo:                           Allowing Undoing.
+* rl_end:                               Readline Variables.
+* rl_end_undo_group:                    Allowing Undoing.
+* rl_event_hook:                        Readline Variables.
+* rl_executing_keymap:                  Readline Variables.
+* rl_filename_completion_desired:       Completion Variables.
+* rl_filename_dequoting_function:       Completion Variables.
+* rl_filename_quote_characters:         Completion Variables.
+* rl_filename_quoting_desired:          Completion Variables.
+* rl_filename_quoting_function:         Completion Variables.
+* rl_forced_update_display:             Redisplay.
+* rl_function_dumper:                   Associating Function Names and Bindings.
+* rl_function_of_keyseq:                Associating Function Names and Bindings.
+* rl_generic_bind:                      Binding Keys.
+* rl_getc:                              Utility Functions.
+* rl_getc_function:                     Readline Variables.
+* rl_get_keymap:                        Keymaps.
+* rl_get_keymap_by_name:                Keymaps.
+* rl_get_keymap_name:                   Keymaps.
+* rl_ignore_completion_duplicates:      Completion Variables.
+* rl_ignore_some_completions_function:  Completion Variables.
+* rl_inhibit_completion:                Completion Variables.
+* rl_initialize:                        Utility Functions.
+* rl_insert_completions:                Completion Functions.
+* rl_insert_text:                       Modifying Text.
+* rl_instream:                          Readline Variables.
+* rl_invoking_keyseqs:                  Associating Function Names and Bindings.
+* rl_invoking_keyseqs_in_map:           Associating Function Names and Bindings.
+* rl_kill_text:                         Modifying Text.
+* rl_library_version:                   Readline Variables.
+* rl_line_buffer:                       Readline Variables.
+* rl_list_funmap_names:                 Associating Function Names and Bindings.
+* rl_make_bare_keymap:                  Keymaps.
+* rl_make_keymap:                       Keymaps.
+* rl_mark:                              Readline Variables.
+* rl_message:                           Redisplay.
+* rl_modifying:                         Allowing Undoing.
+* rl_named_function:                    Associating Function Names and Bindings.
+* rl_on_new_line:                       Redisplay.
+* rl_outstream:                         Readline Variables.
+* rl_parse_and_bind:                    Binding Keys.
+* rl_pending_input:                     Readline Variables.
+* rl_point:                             Readline Variables.
+* rl_possible_completions:              Completion Functions.
+* rl_prompt:                            Readline Variables.
+* rl_readline_name:                     Readline Variables.
+* rl_read_init_file:                    Binding Keys.
+* rl_read_key:                          Utility Functions.
+* rl_redisplay:                         Redisplay.
+* rl_redisplay_function:                Readline Variables.
+* rl_reset_line_state:                  Redisplay.
+* rl_reset_terminal:                    Utility Functions.
+* rl_set_keymap:                        Keymaps.
+* rl_special_prefixes:                  Completion Variables.
+* rl_startup_hook:                      Readline Variables.
+* rl_stuff_char:                        Utility Functions.
+* rl_terminal_name:                     Readline Variables.
+* rl_unbind_key:                        Binding Keys.
+* rl_unbind_key_in_map:                 Binding Keys.
+* self-insert (a, b, A, 1, !, ...):     Commands For Text.
+* set-mark (C-@):                       Miscellaneous Commands.
+* show-all-if-ambiguous:                Readline Init File Syntax.
+* start-kbd-macro (C-x ():              Keyboard Macros.
+* tab-insert (M-TAB):                   Commands For Text.
+* tilde-expand (M-~):                   Miscellaneous Commands.
+* to_lower:                             Utility Functions.
+* to_upper:                             Utility Functions.
+* transpose-chars (C-t):                Commands For Text.
+* transpose-words (M-t):                Commands For Text.
+* undo (C-_, C-x C-u):                  Miscellaneous Commands.
+* universal-argument ():                Numeric Arguments.
+* unix-line-discard (C-u):              Commands For Killing.
+* unix-word-rubout (C-w):               Commands For Killing.
+* upcase-word (M-u):                    Commands For Text.
+* uppercase_p:                          Utility Functions.
+* username_completion_function:         Completion Functions.
+* visible-stats:                        Readline Init File Syntax.
+* yank (C-y):                           Commands For Killing.
+* yank-last-arg (M-., M-_):             Commands For History.
+* yank-nth-arg (M-C-y):                 Commands For History.
+* yank-pop (M-y):                       Commands For Killing.
+
+
+
+Tag Table:
+Node: Top1048
+Node: Command Line Editing1661
+Node: Introduction and Notation2312
+Node: Readline Interaction3321
+Node: Readline Bare Essentials4510
+Node: Readline Movement Commands6040
+Node: Readline Killing Commands6931
+Node: Readline Arguments8634
+Node: Searching9608
+Node: Readline Init File11209
+Node: Readline Init File Syntax12272
+Node: Conditional Init Constructs20062
+Node: Sample Init File22344
+Node: Bindable Readline Commands25378
+Node: Commands For Moving26129
+Node: Commands For History26977
+Node: Commands For Text29591
+Node: Commands For Killing31334
+Node: Numeric Arguments33361
+Node: Commands For Completion34486
+Node: Keyboard Macros35370
+Node: Miscellaneous Commands35929
+Node: Readline vi Mode38740
+Node: Programming with GNU Readline40496
+Node: Basic Behavior41365
+Node: Custom Functions44678
+Node: The Function Type45279
+Node: Function Writing46124
+Node: Readline Variables47208
+Node: Readline Convenience Functions50296
+Node: Function Naming51027
+Node: Keymaps52254
+Node: Binding Keys53968
+Node: Associating Function Names and Bindings55912
+Node: Allowing Undoing57490
+Node: Redisplay60075
+Node: Modifying Text61146
+Node: Utility Functions62057
+Node: Alternate Interface64176
+Node: Custom Completers67470
+Node: How Completing Works68191
+Node: Completion Functions71187
+Node: Completion Variables74202
+Node: A Short Completion Example81344
+Node: Concept Index93650
+Node: Function and Variable Index94395
+
+End Tag Table
diff --git a/readline/doc/readline.ps b/readline/doc/readline.ps
new file mode 100644
--- /dev/null
+++ b/readline/doc/readline.ps
@@ -0,0 +1,3856 @@
+%!PS (but not EPSF; comments have been disabled)
+%DVIPSCommandLine: dvips -D 300 -o readline.ps readline.dvi
+%DVIPSParameters: dpi=300, compressed, comments removed
+%DVIPSSource:  TeX output 1997.05.22:1433
+/TeXDict 250 dict def TeXDict begin /N{def}def /B{bind def}N /S{exch}N
+/X{S N}B /TR{translate}N /isls false N /vsize 11 72 mul N /hsize 8.5 72
+mul N /landplus90{false}def /@rigin{isls{[0 landplus90{1 -1}{-1 1}
+ifelse 0 0 0]concat}if 72 Resolution div 72 VResolution div neg scale
+isls{landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div
+hsize mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul
+TR[matrix currentmatrix{dup dup round sub abs 0.00001 lt{round}if}
+forall round exch round exch]setmatrix}N /@landscape{/isls true N}B
+/@manualfeed{statusdict /manualfeed true put}B /@copies{/#copies X}B
+/FMat[1 0 0 -1 0 0]N /FBB[0 0 0 0]N /nn 0 N /IE 0 N /ctr 0 N /df-tail{
+/nn 8 dict N nn begin /FontType 3 N /FontMatrix fntrx N /FontBBox FBB N
+string /base X array /BitMaps X /BuildChar{CharBuilder}N /Encoding IE N
+end dup{/foo setfont}2 array copy cvx N load 0 nn put /ctr 0 N[}B /df{
+/sf 1 N /fntrx FMat N df-tail}B /dfs{div /sf X /fntrx[sf 0 0 sf neg 0 0]
+N df-tail}B /E{pop nn dup definefont setfont}B /ch-width{ch-data dup
+length 5 sub get}B /ch-height{ch-data dup length 4 sub get}B /ch-xoff{
+128 ch-data dup length 3 sub get sub}B /ch-yoff{ch-data dup length 2 sub
+get 127 sub}B /ch-dx{ch-data dup length 1 sub get}B /ch-image{ch-data
+dup type /stringtype ne{ctr get /ctr ctr 1 add N}if}B /id 0 N /rw 0 N
+/rc 0 N /gp 0 N /cp 0 N /G 0 N /sf 0 N /CharBuilder{save 3 1 roll S dup
+/base get 2 index get S /BitMaps get S get /ch-data X pop /ctr 0 N ch-dx
+0 ch-xoff ch-yoff ch-height sub ch-xoff ch-width add ch-yoff
+setcachedevice ch-width ch-height true[1 0 0 -1 -.1 ch-xoff sub ch-yoff
+.1 sub]/id ch-image N /rw ch-width 7 add 8 idiv string N /rc 0 N /gp 0 N
+/cp 0 N{rc 0 ne{rc 1 sub /rc X rw}{G}ifelse}imagemask restore}B /G{{id
+gp get /gp gp 1 add N dup 18 mod S 18 idiv pl S get exec}loop}B /adv{cp
+add /cp X}B /chg{rw cp id gp 4 index getinterval putinterval dup gp add
+/gp X adv}B /nd{/cp 0 N rw exit}B /lsh{rw cp 2 copy get dup 0 eq{pop 1}{
+dup 255 eq{pop 254}{dup dup add 255 and S 1 and or}ifelse}ifelse put 1
+adv}B /rsh{rw cp 2 copy get dup 0 eq{pop 128}{dup 255 eq{pop 127}{dup 2
+idiv S 128 and or}ifelse}ifelse put 1 adv}B /clr{rw cp 2 index string
+putinterval adv}B /set{rw cp fillstr 0 4 index getinterval putinterval
+adv}B /fillstr 18 string 0 1 17{2 copy 255 put pop}for N /pl[{adv 1 chg}
+{adv 1 chg nd}{1 add chg}{1 add chg nd}{adv lsh}{adv lsh nd}{adv rsh}{
+adv rsh nd}{1 add adv}{/rc X nd}{1 add set}{1 add clr}{adv 2 chg}{adv 2
+chg nd}{pop nd}]dup{bind pop}forall N /D{/cc X dup type /stringtype ne{]
+}if nn /base get cc ctr put nn /BitMaps get S ctr S sf 1 ne{dup dup
+length 1 sub dup 2 index S get sf div put}if put /ctr ctr 1 add N}B /I{
+cc 1 add D}B /bop{userdict /bop-hook known{bop-hook}if /SI save N @rigin
+0 0 moveto /V matrix currentmatrix dup 1 get dup mul exch 0 get dup mul
+add .99 lt{/QV}{/RV}ifelse load def pop pop}N /eop{SI restore userdict
+/eop-hook known{eop-hook}if showpage}N /@start{userdict /start-hook
+known{start-hook}if pop /VResolution X /Resolution X 1000 div /DVImag X
+/IE 256 array N 0 1 255{IE S 1 string dup 0 3 index put cvn put}for
+65781.76 div /vsize X 65781.76 div /hsize X}N /p{show}N /RMat[1 0 0 -1 0
+0]N /BDot 260 string N /rulex 0 N /ruley 0 N /v{/ruley X /rulex X V}B /V
+{}B /RV statusdict begin /product where{pop product dup length 7 ge{0 7
+getinterval dup(Display)eq exch 0 4 getinterval(NeXT)eq or}{pop false}
+ifelse}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale rulex ruley false
+RMat{BDot}imagemask grestore}}{{gsave TR -.1 .1 TR rulex ruley scale 1 1
+false RMat{BDot}imagemask grestore}}ifelse B /QV{gsave newpath transform
+round exch round exch itransform moveto rulex 0 rlineto 0 ruley neg
+rlineto rulex neg 0 rlineto fill grestore}B /a{moveto}B /delta 0 N /tail
+{dup /delta X 0 rmoveto}B /M{S p delta add tail}B /b{S p tail}B /c{-4 M}
+B /d{-3 M}B /e{-2 M}B /f{-1 M}B /g{0 M}B /h{1 M}B /i{2 M}B /j{3 M}B /k{
+4 M}B /w{0 rmoveto}B /l{p -4 w}B /m{p -3 w}B /n{p -2 w}B /o{p -1 w}B /q{
+p 1 w}B /r{p 2 w}B /s{p 3 w}B /t{p 4 w}B /x{0 S rmoveto}B /y{3 2 roll p
+a}B /bos{/SS save N}B /eos{SS restore}B end
+TeXDict begin 40258431 52099146 1000 300 300 (readline.dvi)
+@start /Fa 1 47 df<127012F8A212F012E005057B840E>46 D
+E /Fb 1 47 df<1238127C12FCA212F8127006067A8512>46 D E
+/Fc 1 59 df<126012F0A2126004047D830B>58 D E /Fd 52 127
+df<126012F0AD12601200A4126012F0A212600417789614>33 D<EA071CA5EA7FFFB512
+80A2380E3800A7B51280A26C1300EA1C70A511177F9614>35 D<EA01801203EA06005A12
+1C121812385AA35AA91270A37E1218121C120C7EEA03801201091D799914>40
+D<128012C01260123012381218121C120EA31207A9120EA3121C121812381230126012C0
+1280081D7C9914>I<EA0380A3EA638CEAF39EEA7FFCEA3FF8EA0FE0A2EA3FF8EA7FFCEA
+F39EEA638CEA0380A30F107E9214>I<127012F812FCA2127C120C1218123012E012C006
+0A798414>44 D<EAFFFEA30F037E8C14>I<127012F8A312700505798414>I<EA07C0EA0F
+E0EA1C70EA3838EA3018EA701CA2EAE00EA9EA701CA2EA3838A2EA1C70EA0FE0EA07C00F
+177E9614>48 D<1203A25A5A123F12F712471207AEEA7FF0A20C177C9614>I<130E133E
+137C13F0EA03E0EA07C0EA1F00123E12F85A7E123E7EEA07C0EA03E0EA00F0137C133E13
+0E0F137E9414>60 D<124012E012F8127C121EEA0F80EA07C0EA01F0EA00F8133E131E13
+3E13F8EA01F0EA07C0EA0F80EA1E00127C5A12E012400F157E9514>62
+D<EA1FE0EA3FF8EA701CEAE00EA21240EA003C137013E0EA01C0EA0380A41300C7FCA412
+03EA0780A2EA03000F177E9614>I<EA01E0EA07F0EA0E38EA181CEA38FC1271EA731E12
+77EAEE0EA7EA771CEA7318EA71F0EA38E0EA1806EA0E1EEA07F8EA01F00F177E9614>I<
+EA01C0487EA21360A2EA0770A4EA0630EA0E38A4487EEA1FFCA2EA1C1CA2487EA238FE3F
+80A211177F9614>I<EAFFF013FCEA381E130E1307A4130E131EEA3FFCA2EA381E130E13
+07A5130E131EEAFFFC13F810177F9614>I<3801F180EA07FFEA0E1FEA1C071238EA7003
+A348C7FCA738700380A338380700121CEA0E0EEA07FCEA01F011177F9614>I<EAFFE013
+F8EA383C7F130E7FA3EB0380A8EB0700A2130E131E5BEAFFF813E011177F9614>I<B5FC
+A2EA3807A490C7FCA21338A2EA3FF8A2EA3838A290C7FCA3EB0380A4B5FCA211177F9614
+>I<B4FCA21238AF1307A4B5FCA210177E9614>76 D<38FC1F80A2007C1300EA7637A4EA
+7777A2EA7367A313E7EA71C7A2EA7007A638F80F80A211177F9614>I<38FE3F80A2383E
+0E00123BA4138E1239A213CEA31238A213EE136EA4133E12FEA211177F9614>I<EAFFE0
+13F8EA383C131C7FA45B133CEA3FF85BEA38387FA51480EB1DC0A238FE0F80EB07001217
+7F9614>82 D<EA0FCCEA1FFCEA307CEA603CEAE01CA313001270127EEA3FE0EA0FF0EA01
+F8EA001C131E130E126012E0A2EAF01CEAF838EAFFF0EAC7E00F177E9614>I<387FFF80
+B5FCEAE1C3A43801C000AFEA0FF8A211177F9614>I<EAFFE0A21200B3A712FFA20B1D7F
+9914>93 D<EA1FC0EA7FF0EA7078EA2018EA001CA2EA07FC121FEA3C1C127012E0A3EA70
+7C383FFF80EA0F8F11107E8F14>97 D<12FCA2121CA513F8EA1DFEEA1F07EA1E03001C13
+80EB01C0A6EB0380001E1300EA1F0EEA1DFCEA0CF81217809614>I<EA03F8EA0FFEEA1C
+0EEA3804EA7000126012E0A412601270EA380EEA1C1EEA0FFCEA03F00F107E8F14>I<13
+7EA2130EA5EA07CEEA0FFEEA1C3EEA301EEA700E12E0A61270EA301EEA383E381FEFC0EA
+07CF12177F9614>I<EA07E0EA0FF0EA1C38EA301CEA700CEAE00EA2EAFFFEA2EAE00012
+601270EA380EEA1C1EEA0FFCEA03F00F107E8F14>I<13FCEA01FEEA038EEA07041300A3
+EA7FFE12FFEA0700ACEAFFF8A20F177F9614>I<EA07CF381FFF80EA383B38301800EA70
+1CA3EA3018EA3838EA3FF0EA37C00070C7FCA2EA3FF86C7E487EEA700F38E00380A43870
+0700EA3C1EEA1FFCEA07F011197F8F14>I<12FCA2121CA51378EA1DFEEA1F86EA1E0712
+1CAA38FF8FE0A21317809614>I<1206120FA21206C7FCA4B4FCA21207ACEAFFF8A20D18
+7C9714>I<12FCA2121CA5EBFF80A2EB1C005B5B5BEA1DC0EA1FE0A2EA1E70EA1C38133C
+131C7F38FF1F80A21117809614>107 D<EAFF80A21203B3EAFFFEA20F177E9614>I<EAFB
+8EEAFFDF383CF380A2EA38E3AA38FEFBE013791310808F14>I<EAFC78EAFDFEEA1F86EA
+1E07121CAA38FF8FE0A21310808F14>I<EA07C0EA1FF0EA3C78EA701CA2EAE00EA6EA70
+1CEA783CEA3C78EA1FF0EA07C00F107E8F14>I<EAFCF8EAFDFEEA1F07EA1E03001C1380
+EB01C0A6EB0380001E1300EA1F0EEA1DFCEA1CF890C7FCA6B47EA21218808F14>I<EA03
+E7EA0FF7EA1C1FEA300F1270487EA6EA700F1230EA1C3FEA0FF7EA07C7EA0007A6EB3FE0
+A213187F8F14>I<EAFE1FEB7F80EA0EE3380F810090C7FCA2120EA8EAFFF0A211107F8F
+14>I<EA0FD8EA3FF8EA603812C0A2EAF000EA7F80EA3FF0EA07F8EA001CEA600612E012
+F0EAF81CEAFFF8EACFE00F107E8F14>I<1206120EA4EA7FFC12FFEA0E00A8130EA3131C
+EA07F8EA01F00F157F9414>I<EAFC3FA2EA1C07AB131F380FFFE0EA03E71310808F14>I<
+38FE3F80A2383C1E00EA1C1CA36C5AA3EA0630EA0770A36C5AA311107F8F14>I<38FE3F
+80A238700700EA380EA3EA39CEA3EA1B6C121AA3EA1E7CA2EA0E3811107F8F14>I<EA7E
+3FA2EA1E3CEA0E78EA07705B12036C5A12037FEA0770EA0E781338487E38FE3F80A21110
+7F8F14>I<38FE3F80A2381C0E005BA2120E5BA212071330A2EA0370A25B1201A25BA348
+5A12730077C7FC127E123C11187F8F14>I<EA3FFF5AEA700E131C1338EA007013E0EA01
+C0EA0380EA0700120EEA1C0712381270B5FCA210107F8F14>I<EA1C10EA3F38EAE7E0EA
+41C00D047D9614>126 D E /Fe 2 121 df<1270A212F0126004047D830B>46
+D<383FC7E038078380EB0200EA038413C8EA01D8EA00F05B7F120113381202487EEA081E
+123838FC3FC013107F8F14>120 D E /Ff 39 123 df<13FEEA038138060180EA0E0338
+1C010090C7FCA5B51280EA1C03AE38FF8FF0141A809915>12 D<EBFF80EA0383EA060312
+0E121CA6B5FCEA1C03AE38FF9FF0141A809915>I<126012F0A212701210A31220A21240
+A2040B7D830B>44 D<EAFFC0A20A0280880D>I<EA07E0EA1C38EA381CEA300CEA700EEA
+6006A2EAE007AAEA6006A2EA700EEA300CEA381CEA1C38EA07E010187F9713>48
+D<12035AB4FC1207B3A2EA7FF80D187D9713>I<EA0F80EA1060EA2030EA4038EA803CEA
+C01C12E01240EA003C1338A21370136013C0EA018013001202EA040412081210EA3008EA
+3FF8127F12FF0E187E9713>I<EA07E0EA1838EA201CEA601EEA700EEA201E1200131CA2
+13381370EA07E0EA0038131C130E130FA212E0A212C0EA400EEA601CEA1838EA07E01018
+7F9713>I<1318A21338137813F813B8EA01381202A212041208121812101220124012C0
+B5FCEA0038A6EA03FF10187F9713>I<EA3018EA3FF013E01380EA2000A5EA2FC0EA3060
+EA2030EA00381318131CA2124012E0A2EA8018EA40381330EA30E0EA0F800E187E9713>
+I<EA01F8EA0704EA0C06EA180E123013001270126012E0EAE3E0EAE418EAE80CEAF00EEA
+E0061307A31260A2EA7006EA300EEA180CEA0C38EA07E010187F9713>I<1240EA7FFF13
+FEA2EA4004EA80081310A2EA00201340A21380120113005AA25A1206A2120EA512041019
+7E9813>I<EA07E0EA1818EA300CEA20061260A21270EA780CEA3E18EA1F30EA07C0EA03
+E0EA0CF8EA307CEA601E130FEAC0071303A3EA6002EA2004EA1818EA07E010187F9713>
+I<EA07E0EA1C30EA3018EA700CEA600EEAE006A21307A31260EA700FEA3017EA1827EA07
+C7EA00071306130E130C12701318EA6030EA3060EA0F8010187F9713>I<EA1FC0EA3870
+7FEA101C1200A2EA03FCEA1E1C1238127012E01480A2133CEA705F381F8F0011107F8F13
+>97 D<12FC121CA913FCEA1D07381E0380381C01C0130014E0A6EB01C01480381E0300EA
+1906EA10F8131A809915>I<EA07F8EA1C1C1238EA700813005AA612701304EA3808EA1C
+18EA07E00E107F8F11>I<133F1307A9EA03E7EA0C17EA180F487E127012E0A612601270
+6C5AEA1C373807C7E0131A7F9915>I<EA07C0EA1C30EA30181270EA600C12E0EAFFFCEA
+E000A41260EA7004EA3808EA1C18EA07E00E107F8F11>I<EA01F0EA0718EA0E38EA1C10
+1300A6EAFFC0EA1C00AEEAFF800D1A80990C>I<EA0FCF3818718038303000EA7038A4EA
+30306C5AEA2FC00060C7FCA21270EA3FF013FC6C7EEA600FEAC003A4EA6006EA381CEA07
+E011187F8F13>I<12FC121CA9137CEA1D87381E0380A2121CAB38FF9FF0141A809915>I<
+1218123CA212181200A612FC121CAE12FF081A80990A>I<12FC121CA9EB1FC0EB0F0013
+0C5B13205B13E0121DEA1E70EA1C7813387F131E7F148038FF9FE0131A809914>107
+D<12FC121CB3A6EAFF80091A80990A>I<38FC7C1F391D8E6380391E0781C0A2001C1301
+AB39FF9FE7F81D107F8F20>I<EAFC7CEA1D87381E0380A2121CAB38FF9FF01410808F15>
+I<EA07E0EA1C38EA300CEA700EEA6006EAE007A6EA6006EA700EEA381CEA1C38EA07E010
+107F8F13>I<EAFCFCEA1D07381E0380381C01C0A2EB00E0A6EB01C01480381E0300EA1D
+06EA1CF890C7FCA6B47E1317808F15>I<EA03E1EA0C13EA180BEA300FEA700712E0A612
+70A26C5AEA1C37EA07C7EA0007A6EB3FE013177F8F14>I<EAFC78EA1D9CEA1E1C1308EA
+1C00ABEAFF800E10808F0F>I<EA1F20EA60E0EA402012C0A2EAF000127FEA3FC0EA1FE0
+EA00F0EA8070133012C01320EAF040EA8F800C107F8F0F>I<1208A41218A21238EAFFC0
+EA3800A81320A41218EA1C40EA07800B177F960F>I<38FC1F80EA1C03AB1307120CEA0E
+0B3803F3F01410808F15>I<38FF0F80383C0700EA1C061304A26C5AA26C5AA3EA03A0A2
+EA01C0A36C5A11107F8F14>I<39FE7F1F8039381C0700003C1306381C0C04130E380E16
+081317A238072310149013A33803C1A014E0380180C0A319107F8F1C>I<38FE3F80383C
+1E00EA1C086C5AEA0F306C5A6C5A12017F1203EA0270487E1208EA181CEA381E38FC3FC0
+12107F8F14>I<38FF0F80383C0700EA1C061304A26C5AA26C5AA3EA03A0A2EA01C0A36C
+5AA248C7FCA212E112E212E4127811177F8F14>I<EAFFF8EAE07012C0EA80E0EA81C0A2
+EA0380EA0700A2EA0E04121CA2EA380812701338EAFFF80E107F8F11>I
+E /Fg 2 42 df<13E0EA01C0EA0380120713005A121EA2121C123CA212381278A3127012
+F0AE12701278A31238123CA2121C121EA27E7E13801203EA01C0EA00E00B2E7CA112>40
+D<12E012707E123C121C121E7EA27E1380A2120313C0A3120113E0AE13C01203A3138012
+07A213005AA2121E121C123C12385A5A0B2E7EA112>I E /Fh 28
+123 df<90380FF83F90397FFDFFC03A01FC1FE3E03903F03FC7EA07E0D80FC01387ED83
+C091381F8000A6B612FCA2390FC01F80B2397FF8FFF8A223237FA221>11
+D<EB07F8EB7FFC3801FC0E3803F01F48485AEA0FC0A3141E140C91C7FCA2ECFF80B6FCA2
+380FC01FB2397FF8FFF0A21C237FA220>I<13181330136013C01201EA0380120713005A
+121EA2123E123CA2127CA3127812F8AD1278127CA3123CA2123E121EA27E7E13801203EA
+01C012001360133013180D317BA416>40 D<EA07FE381FFF80383F07E06D7E130180121E
+1200A2133FEA03FDEA1F81EA3E01127C12F8A4EA7C02EA7E0C391FF87F803807E03F1916
+7E951C>97 D<B47EA2121FABEB87F0EBBFFCEBF03EEBC01F9038800F8015C0140715E0A7
+15C0A2140F15809038C01F00381E707E381C3FFC38180FE01B237EA220>I<EBFF800007
+13E0380F83F0EA1F03123E127E387C01E090C7FC12FCA6127C127EA2003E13186C133038
+0FC0603807FFC0C6130015167E9519>I<49B4FCA2EB003FAB13FE3807FFBF380FC1FF48
+C67E003E7F127E127CA212FCA7127C127E123E6C5B380F81FF3907FF3FE0EA01FC1B237E
+A220>I<13FE3807FF80380F83C0381E01E0383E00F0127E007C13F8147812FCB512F8A2
+00FCC7FCA3127CA26C1318A26C1330380F80E03803FFC0C6130015167E951A>I<EB1F80
+EBFFE03801F1F0EA03E31207EA0FC3EBC1E0EBC000A6EAFFFEA2EA0FC0B2EA7FFCA21423
+7EA212>I<9038FE0F803903FF9FC0380F83E3381F01F3391E00F000003E7FA5001E5BEA
+1F01380F83E0380BFF80D808FEC7FC0018C8FCA2121C381FFFE014FC6C13FF7E001F1480
+397C001FC00078130F00F81307A3007CEB0F806CEB1F00381F807E6CB45A000113E01A21
+7F951D>I<B47EA2121FABEB83F0EB8FFCEB987EEBA03EEBC03FA21380AE39FFF1FFE0A2
+1B237DA220>I<121E123FEA7F80A4EA3F00121EC7FCA6EAFF80A2121FB2EAFFF0A20C24
+7EA30F>I<B47EA2121FABECFF80A2EC3C00143014E0EB81C00183C7FC1386139E13BE13
+FFEBDF80EB8FC01307806D7E6D7E130080147E39FFE1FFC0A21A237EA21E>107
+D<EAFF80A2121FB3ADEAFFF0A20C237EA20F>I<3AFF03F803F890390FFE0FFE3A1F183F
+183F9039201F201F014001C01380A201801380AE3BFFF0FFF0FFF0A22C167D9531>I<38
+FF03F0EB0FFC381F187EEB203EEB403FA21380AE39FFF1FFE0A21B167D9520>I<13FF00
+0713E0380F81F0381F00F8003E137C48133EA300FC133FA7007C133E007E137E003E137C
+6C13F8380F81F03807FFE0C6130018167E951D>I<38FF87F0EBBFFC381FF07EEBC01F90
+38800F8015C0A2EC07E0A715C0140FA2EC1F8001C01300EBF07EEBBFFCEB8FE00180C7FC
+A8EAFFF0A21B207E9520>I<EBFE033807FF07380FC1CF381F00DF48137F007E7FA2127C
+12FCA7127EA2003E5B6C5BEA0FC13807FF3FEA00FC1300A8903801FFE0A21B207E951E>
+I<38FF0F80EB1FE0381F33F013631343A2EBC1E0EB8000ADEAFFF8A214167E9518>I<38
+07F980EA1FFFEA3807EA7003EAF001A26CC7FCB4FC13F8EA7FFE6C7E6C1380120738003F
+C0EAC007130312E0A200F0138038FC0F00EAEFFEEAC3F812167E9517>I<487EA41203A2
+1207A2120F123FB5FCA2EA1F80ABEB8180A5380F830013C3EA07FEEA01F811207F9F16>
+I<38FF81FFA2381F803FAF5C5C380FC1BF3907FF3FE0EA01FC1B167D9520>I<39FFF01F
+E0A2391FC00700000F1306EBE00E0007130C13F000035BA26C6C5AA26C6C5AA2EBFEE0EB
+7EC0137F6D5AA26DC7FCA2130EA21B167F951E>I<3AFFF3FF83FCA23A1F807C00E0D80F
+C014C08001E013010007017F1380A2D803F0EB0300ECCF8301F81387D801F913C61487D8
+00FD13ECEBFF0315FC017F5BEB7E01013E5BEB3C00A20118136026167F9529>I<39FFF0
+7FC0A2390FC01C006C6C5A6D5A00035B6C6C5A3800FD80137F91C7FC7F6D7E497EEB37E0
+EB67F013C33801C1F8380380FC48487E000E137F39FF81FFE0A21B167F951E>I<39FFF0
+1FE0A2391FC00700000F1306EBE00E0007130C13F000035BA26C6C5AA26C6C5AA2EBFEE0
+EB7EC0137F6D5AA26DC7FCA2130EA2130CA25B1278EAFC3813305BEA69C0EA7F80001FC8
+FC1B207F951E>I<387FFFF0A2387C07E038700FC0EA601F00E0138038C03F005B137EC6
+5A1201485AEBF030EA07E0120FEBC070EA1F80003F1360EB00E0EA7E03B5FCA214167E95
+19>I E /Fi 29 122 df<13E0A538F0E1E0EAFCE7387EEFC0381FFF00EA07FCEA01F0EA
+07FCEA1FFF387EEFC038FCE7E0EAF0E13800E000A513157D991A>42
+D<EB7C38EA01FF000713F8EA0F83EA1E00001C13785A14385AA214005AA812701438A27E
+A26C1370001E13F0380F83E03807FFC00001138038007C00151E7E9D1A>67
+D<B512F8A3381C0038A51400A2130EA3EA1FFEA3EA1C0EA390C7FCA3141CA5B512FCA316
+1E7E9D1A>69 D<387FFFFCB5FC7E380E001CA51400A2EB0380A3EA0FFFA3EA0E03A390C7
+FCA8EA7FE012FF127F161E7F9D1A>I<B51280A33801C000B3A6B51280A3111E7C9D1A>
+73 D<387F03F838FF87FC387F03F8381C01E0EB03C01480EB07005B131E131C5B13785B
+7F121DEA1FDC139C130EEA1E0F7F001C13801303EB01C0A2EB00E0A21470007F13FC38FF
+81FE387F00FC171E7F9D1A>75 D<EA7FE0487E6C5A000EC7FCB3141CA5387FFFFCB5FC7E
+161E7F9D1A>I<EAFFFEEBFF8014C0381C03E0EB00F0147014781438A41478147014F0EB
+03E0381FFFC01480EBFE00001CC7FCA9B47EA3151E7E9D1A>80 D<38FF01FEA3381C0070
+A3001E13F0000E13E0A3380701C0A438038380A43801C700A4EA00C613EEA3136C137CA2
+1338171E7F9D1A>86 D<387FFFC0B512E0A26C13C013047D7E1A>95
+D<EA1FF0EA3FFC487EEA780FEA300738000380A2137FEA07FF121FEA3F83EA7803127012
+E0A3EA7007EA780F383FFFFCEA1FFDEA07F016157D941A>97 D<12FEA3120EA6133EEBFF
+80000F13E0EBC1F0EB8070EB0038120E141CA7000F13381478EB80F0EBC1E0EBFFC0000E
+138038063E00161E7F9D1A>I<EBFF80000313C0000F13E0EA1F01383C00C04813001270
+A25AA51270A2007813707E381F01F0380FFFE0000313C03800FE0014157D941A>I<EB1F
+C0A31301A6EA01F1EA07FDEA0FFFEA1E0FEA3C07EA7803EA700112E0A7EA7003A2EA3807
+EA3E0F381FFFFCEA07FDEA01F1161E7E9D1A>I<EA01F8EA07FF481380381E07C0EA3C01
+387800E01270481370A2B512F0A300E0C7FC1270A2007813707E381F01F0380FFFE00003
+13803800FE0014157D941A>I<EB07E0EB1FF0EB3FF8EB7878EBF030EBE000A4387FFFF0
+B5FCA23800E000AF383FFF804813C06C1380151E7F9D1A>I<12FEA3120EA6133EEBFF80
+000F13C013C1EB80E01300120EAC38FFE3FE13E713E3171E7F9D1A>104
+D<EA01C0487EA36C5AC8FCA5EA7FE0A31200AF387FFF80B512C06C1380121F7C9E1A>I<
+EAFFE0A31200B3A6B512E0A3131E7D9D1A>108 D<387CE0E038FFFBF8EA7FFF381F1F1C
+EA1E1EA2EA1C1CAC387F1F1F39FF9F9F80397F1F1F00191580941A>I<EAFE3EEBFF80B5
+12C0EA0FC1EB80E01300120EAC38FFE3FE13E713E317157F941A>I<EA01F0EA07FCEA1F
+FF383E0F80EA3C07387803C0EA700138E000E0A6EAF001007013C0EA7803383C0780EA3E
+0F381FFF00EA07FCEA01F013157D941A>I<EAFE3EEBFF80B512E0380FC1F0EB8070EB00
+38120E141CA7000F13381478EB80F0EBC1E0EBFFC0000E1380EB3E0090C7FCA8EAFFE0A3
+16207F941A>I<387F81F838FF8FFC387F9FFE3803FE1EEBF80CEBE000A25B5BAAEA7FFF
+B5FC7E17157F941A>114 D<487E1203A6387FFFE0B5FCA238038000AA1470A43801C1E0
+13FF6C1380EB3F00141C7F9B1A>116 D<38FE0FE0A3EA0E00AD1301EA0F033807FFFE7E
+EA00FC17157F941A>I<387FC7FC00FF13FE007F13FC380E00E0A3380701C0A338038380
+A33801C700A3EA00EEA3137CA2133817157F941A>I<387FC7F8EBCFFCEBC7F8380703C0
+38038380EBC700EA01EFEA00FE137C13781338137C13EE120113C738038380000713C013
+01387FC7FC00FF13FE007F13FC17157F941A>120 D<387FC7FC00FF13FE007F13FC380E
+00E0A27EEB01C013811203EB8380EA01C3A2EBC700EA00E7A213E61366136E133CA31338
+A3137813701230EA78E01271EA7FC06C5A001EC7FC17207F941A>I
+E /Fj 1 59 df<127012F8A3127005057C840D>58 D E /Fk 52
+122 df<123C127E12FFA4127E123C08087C8711>46 D<EB7F803803FFF03807E1F8380F
+807C48487E48133F003E7F007E1480A400FE14C0AD007E1480A46CEB3F00A26C133E6C6C
+5A3807E1F86CB45A38007F801A237EA21F>48 D<131C133C13FC12FFA21200B3AA387FFF
+FCA216237CA21F>I<48B4FC000713C0381E07F0383803F8386001FC387C00FE12FE14FF
+147FA2127C003813FFC7FC14FEA2EB01FC14F8EB03F0EB07E01480EB0F00131E5B1370EB
+E003EA01C038038007380700061206380FFFFE5A5A4813FCB5FCA218237DA21F>I<48B4
+FC000713E0381E03F0383801F8003C13FC387E00FEA3123EEA1C01000013FCA2EB03F8EB
+07F0EB0FC03801FF00A2380007E0EB01F014F8EB00FC14FE14FFA21210127C12FEA214FE
+A2387C01FC007013F8383E07F0380FFFC00001130018237DA21F>I<14381478A214F813
+01130313071306130C131C13381330136013E0EA01C01380EA03005A120E5A12185A1270
+5AB612C0A2390001F800A790387FFFC0A21A237EA21F>I<0018130C001F137CEBFFF814
+F014E014C01480EBFC000018C7FCA513FF001B13E0381F03F0381C00F8000813FCC7127E
+A3147FA2127812FCA3147E5A006013FC1270383801F8381E07E03807FFC03801FE001823
+7DA21F>I<EB1FC0EB7FF03801F0383803E00C3807803E000F137EEA1F005AA2007E133C
+1400A338FE3FC0EB7FF0EB80F800FF13FCEB007C147E5A147FA4127EA4003E137E123F6C
+137C380F80F83807C1F03803FFC038007F0018237DA21F>I<1230123C003FB512C0A215
+804814005C5C38600018A200E05B485B5CC6485AA249C7FC1306130EA25BA2133CA25BA2
+13F8A41201A66C5A13601A257DA41F>I<EBFF80000313E0380F01F8381C007C48133C14
+1E1278A2127C127E387F803C13E0383FF878381FFDF0EBFFC07E000313E014F8000F13FC
+EA1E1F383C07FEEA7803EB00FF48133F141F140FA3140E1278141C6C1338381F80F03807
+FFE00001130018237DA21F>I<13FF000313C0380F83E0381F00F04813F8007E137CA214
+7E12FEA3147FA4127E14FF123EEA3F01001F137FEA0FFEEA03FCC7FC147EA2123C007E13
+FCA214F814F0EA7C01383003E0381C0F80380FFF00EA03F818237DA21F>I<141CA2143E
+A3147FA24A7EA39038019FC0A29038031FE0140F01077FEB0607A2010C7F1403011C7FEB
+1801A2496C7EA2017FB5FCA29039E0007F8049133FA2484880151F00038190C7120FA248
+6E7ED8FFF090B51280A229257EA42E>65 D<B612E015FC3903F0007FED3F80ED1FC0ED0F
+E0A216F0A21507150FA216E0151F16C0ED7F80913801FE0090B512F815FF9039F0003FC0
+ED0FE0ED07F016F8150316FCA616F81507ED0FF0ED1FE0ED7FC0B7120015F826257EA42C
+>I<9138FF8008010FEBF01890393FC03C789039FE0006F8D801F8130348481301484813
+0048481478121F48481438A2007F151890C8FCA2481500A97E16187F123FA26C6C143012
+0F6C6C14606C6C14C06C6CEB0180D800FEEB070090383FC01E90380FFFF8010013C02525
+7DA42C>I<B7FCA23903F8007FED0F8015071503A21501A3ED00C01406A21600A2140E14
+1EEBFFFEA2EBF81E140E1406A21660A291C7FC16C0A415011503A2ED0F80153FB7FCA223
+257EA428>69 D<B612FEA23803F800151F8181A281A3ED01801403A292C7FCA25C5C90B5
+FCA2EBF80F8080A491C8FCAAB512F0A221257EA427>I<B500E0B512E0A23B03F80003F8
+00AF90B6FCA29038F80003B0B500E0B512E0A22B257EA430>72 D<B512E0A23803F800B3
+AFB512E0A213257EA417>I<B539E007FF80A2D803F8C7EA780016605E4B5A0307C7FC15
+0E15185D5D5DEC03804AC8FC140E141F4A7E147FECDFC09038FB8FE09038FF0FF0EBFC07
+496C7E816E7E1400157F82153F6F7E6F7E8215076F7E82B539E03FFFC0A22A257EA430>
+75 D<B512F0A2D803F8C7FCB3A31503A31506A3150EA2151E153E157CEC03FCB6FCA220
+257EA425>I<D8FFF8EDFFF86D5C0003EEFE00017EEC037EA36D1406A26D6C130CA26D6C
+1318A26D6C1330A36D6C1360A26D6C13C0A2903900FC0180A291387E0300A3EC3F06A2EC
+1F8CA2EC0FD8A2EC07F0A36E5AEA07803CFFFC01C01FFFF8A235257EA43A>I<D8FFF890
+3807FFE07FD803FE9038003C006D14187F6D7E6D7E806D7E6D7E13036D7E6D7E80EC7F80
+EC3FC0141FEC0FE015F0EC07F8EC03FC1401EC00FE157F1698ED3FD8ED1FF8150F150715
+03A2150115001678486C1438D8FFFC1418A22B257EA430>I<B67E15F83903F801FEEC00
+7F6F7E6F7EA282A55EA24B5A4BC7FCEC01FE90B512F815C09038F803F06E7E6E7E157EA2
+157FA482A31760ED3FC017C0ED1FE1B539E00FFF80923801FE002B257EA42E>82
+D<01FF1380000713E3380F80F7381E001F48130F481307140312F81401A27E91C7FCB4FC
+EA7FE013FE383FFFE014F86C13FE00077F6C1480C67E010313C0EB003FEC0FE01407A200
+C01303A315C07E6C13076C14806CEB0F0038FFC03E38E3FFF838803FE01B257DA422>I<
+007FB612F8A2397E00FE010078EC00780070153800601518A200E0151C160C5AA4C71400
+B3A390B512FEA226247EA32B>I<B539E00FFFC0A2D803F8C7EA78001630B3A700015D7F
+00005D137C6D495A6D0107C7FC90380FE03E903803FFF89038007FC02A257EA42F>I<B5
+398001FFE0A2D807F8C7EA1C0000031518A26D1438000115306D1470000015607F6D5C80
+013F495AA2ECC003011F91C7FC6E5A010F130614F001075BA26D6C5AA2ECFC3801011330
+ECFE700100136014FF6E5AA26E5AA36EC8FCA2140EA22B257FA42E>I<B53B81FFFE01FF
+F0A23D07F0001FC0000F007013066C6C010F5CA26F7E6C6C5EA26D496C1338000017304B
+7E017F01195CA291388030FE013F5E829139C0607F01011F5E03E0138190280FE0C03F83
+C7FCA29139F1801FC3010715C617E69139FB000FEE010315EC02FF14FC6D486D5AA24A13
+0301005DA24A130102785CA202306D5A3C257FA43F>I<B539C001FFE0A2D807F8C7EA1C
+006C6C141816386C6C14306C6C5C16E06D6C5B6D6C485A1503D91FE090C7FC90380FF006
+150E903807F80C6D6C5A15386D6C5A903800FF6015E06E5A6E5AAE90380FFFFCA22B257F
+A42E>89 D<EA07FF001F13E0383E03F0383F00F880147E121EC7FCA3EB1FFE3803FE7EEA
+0FC0EA1F00123E127E5AA314BEEA7E01383F073E391FFE1FE03807F00F1B187E971E>97
+D<EAFFC0A2120FACEBC1FCEBCFFF9038FC0FC09038F007E09038C003F0A2EC01F8A215FC
+A815F8A2EC03F013E09038F007E090381C1F80390E0FFF00380C03F81E267FA522>I<EB
+7FE03803FFF83807C07C381F80FC13005A007E1378140012FEA8127E127F6C130CEA1F80
+EBC0183807E0703803FFE038007F0016187E971B>I<ECFFC0A2140FAC137F3803FFCF38
+0FE0FF381F803F383F000FA2127EA212FEA8127EA27E141F381F803F380FC0EF3903FFCF
+FC3800FE0F1E267EA522>I<137F3803FFC03807C1F0380F80F8EA1F0048137C127E147E
+12FEA2B512FEA248C7FCA3127EA214067E6C130C380F80183807E0703803FFE038007F80
+17187E971C>I<EB1FC0EB7FF0EA01F83803E1F8120713C1380FC0F01400A7B5FCA2EA0F
+C0B3A2EAFFFEA215267EA513>I<3901FF07C00007EBDFE0380F83F1EA1F01393E00F800
+007E7FA6003E5B6C485A380F83E0EBFFC0001190C7FC0030C8FCA21238123C383FFFE06C
+13FC806C7F481480383C003F48EB0FC000F81307A4007CEB0F806CEB1F00381F807E3807
+FFF8C613C01B247E971F>I<EAFFC0A2120FAC14FE9038C3FF809038CE0FC013D89038D0
+07E013E0A213C0AF39FFFC7FFEA21F267EA522>I<120FEA1F80EA3FC0A4EA1F80EA0F00
+C7FCA7EA7FC0A2120FB3A2EAFFF8A20D277EA611>I<EAFFC0A2120FACEC1FF0A2EC0780
+EC0E005C14305CEBC1C0EBC38013C713DFEBFFC0EBE7E0EBC3F0138180EB80FC147E80A2
+EC1F80EC0FC039FFF83FF8A21D267FA520>107 D<EAFFC0A2120FB3B0EAFFFCA20E267E
+A511>I<26FF80FE137F903A83FF81FFC03B0F8E0FC707E0019813CC903A9007E803F001
+A013F0A201C013E0AF3BFFFC7FFE3FFFA230187E9733>I<38FF80FE903883FF80390F8E
+0FC0139890389007E013A0A213C0AF39FFFC7FFEA21F187E9722>I<EB7F803803FFF038
+07C0F8381F807E48487EA2007EEB1F80A200FE14C0A8007E1480A26CEB3F00A2381F807E
+6C6C5A3803FFF038007F801A187E971F>I<38FFC1FCEBCFFF390FFC1FC09038F007E001
+C013F0140315F8140115FCA8EC03F8A215F0EBE0079038F00FE09038DC1F809038CFFF00
+EBC3F801C0C7FCA9EAFFFCA21E237F9722>I<38FF83E0EB8FF8380F8C7CEB90FC13B013
+A01478EBE0005BAEEAFFFEA216187F9719>114 D<3807F8C0EA1FFFEA3C07EA7001EAF0
+00A300FC1300B47EEA7FFC7F383FFF80000F13C0120338001FE01303EAC001A212E014C0
+EAF00338FC078038EFFF00EAC3FC13187E9718>I<13C0A41201A312031207120F121FB5
+12C0A2380FC000AC1460A63807E0C013E13801FF8038007E0013237FA218>I<39FFC07F
+E0A2000F1307B0140FA200071317EBE0673903FFC7FE38007F071F187E9722>I<39FFF8
+0FF8A2390FC001C015803907E00300A26D5A00031306EBF80E0001130C13FC00005B13FE
+EB7E30A26D5AA214E06D5AA26D5AA26DC7FCA21D187F9720>I<3BFFF9FFE0FF80A23B1F
+C03F001C00000F6D13181580D807E05CA29039F03FC07000030137136015E02601F8635B
+A29038FCE3F1000001C15B15F990267F80FBC7FCA215FF90383F007EA2011E133CA3010C
+131829187F972C>I<39FFF83FF0A2390FC00F003807E00E6C6C5A6D5A6C6C5A00001360
+EB7EC06D5AA2131F6D7E497E80EB33F81361EBE0FC3801C07E3803807F3907003F804813
+1F39FFC07FF8A21D187F9720>I<39FFF80FF8A2390FC001C015803907E00300A26D5A00
+031306EBF80E0001130C13FC00005B13FEEB7E30A26D5AA214E06D5AA26D5AA26DC7FCA2
+1306A25B1230EA781CEAFC185B1370EA68E0EA7FC0001FC8FC1D237F9720>I
+E /Fl 28 122 df<EB03E0EB1C181338EB703C13E014383801C000A5485A387FFFF03803
+8070A4380700E0A6380E01C0A6381C0380001E13C038FF0FF016207E9F19>12
+D<EAFFF0A20C027E8A0F>45 D<0007B512F83900F800780178133815185B1508A53901E0
+0800A314181438EBFFF83803C0301410A491C7FC485AA648C8FC7FEAFFFC1D1F7E9E1E>
+70 D<3A07FF803FE03A00F8001F000178130C5D4913205D5D4AC7FC1402140848485A5C
+146014F013E1EBE4F83803C878EBD07CEBE03CEBC03E141E141F48487E81140781140381
+380F00016D487E39FFF00FFE231F7E9E23>75 D<EA07F8EA0C0CEA1E061307121C1200A3
+13FFEA07C7EA1E07EA3C0E127800F01310A3131EEB2E2038784F40381F878014147D9317
+>97 D<1207123F120F7EA2120EA65A137CEA1D83381E0180001C13C0EB00E05A14F0A538
+7001E0A214C013031480EB0700EAE80EEACC38EA83E014207B9F19>I<13FEEA0383380E
+0780121C0038130090C7FC12785AA45AA37E5BEA70026C5AEA1C18EA07E011147D9314>
+I<1438EB01F8EB00781438A21470A614E013FCEA0382EA0601121CEA3C00383801C01278
+12F0A438E00380A412F0EA700738380F00381C37803807C7E015207D9F19>I<13F8EA07
+0EEA0E07121C383803801278127012F0A2B5FC00F0C7FC5AA46C5AEA7002EA3004EA1C18
+EA07E011147D9314>I<EB07C0EB1C60EB30F01360EBE0E0EBC0001201A5485AEA3FFCEA
+0380A448C7FCA6120EA65A121EEAFFC014207F9F0E>I<140EEB3E11EBE1A33801C1C238
+0381E0EA07801301120FA3380703C01480EB8700EA04FC48C7FCA21218121CEA0FFF14C0
+14E0381800F04813305A5AA3006013606C13C0381C0700EA07FC181F809417>I<13E012
+0712011200A2485AA6485AEB8F80EB90E013A0EBC0601380000713E01300A5380E01C0A6
+381C0380001E13C038FF8FF014207E9F19>I<EA01C0EA03E0A213C0EA0180C7FCA6EA03
+80121F12071203A2EA0700A6120EA65A121EEAFF800B1F7F9E0C>I<13E0120712011200
+A2485AA6485AEB81FCEB80F014C0EB81801400EA07045B13181338137C131C120E7FA213
+0F7F1480EA1C03381E07C038FF8FF016207E9F18>107 D<13E0120712011200A2EA01C0
+A6EA0380A6EA0700A6120EA65A121EEAFF800B207F9F0C>I<390387C07C391F98618639
+07A072073903C03403EB80380007EB7807EB0070A5000EEBE00EA64848485A001EEBE01E
+3AFFCFFCFFC022147E9326>I<38038F80381F90E0EA07A03803C0601380000713E01300
+A5380E01C0A6381C0380001E13C038FF8FF014147E9319>I<13FCEA0387380E0180381C
+00C04813E0A24813F012F0A438E001E0A214C0130300F0138038700700EA380E6C5AEA07
+E014147D9317>I<EBE3E03807EC383800F01C497E140F48487E1580A53903800F00A214
+0E141E141C5C38074070EB61C0011FC7FC90C8FCA3120EA4121EEAFFC0191D809319>I<
+EBFC2038038260EA0702381E01E0123C003813C0127812F0A438E00380A212F0A2130712
+7038380F00EA1C37EA07C7EA0007A3130EA4131EEBFFC0131D7D9318>I<EA038E381FB3
+80EA07C71203EB8300EA078090C7FCA5120EA65A121EEAFFC011147E9312>I<EA01F9EA
+0607EA080312181301EA3802EA3C00121F13F0EA07FCEA01FEEA001FEA40071303A21260
+1306EAF004EAC818EA87E010147F9312>I<1380EA0100A35A5A5A121EEAFFF8EA0E00A4
+5AA65A1310A41320A2EA1840EA0F800D1C7C9B12>I<381C0380EAFC1FEA3C07EA1C03A2
+38380700A6EA700EA4131EA25BEA305E381F9F8011147B9319>I<38FF83F8381E00E000
+1C13C01480121E380E01005B13025B12075BA25BEA039013A013E05B5B120190C7FC1514
+7C9318>I<39FF9FE1FC393C078070391C030060148015401580EA0E0790380D81001309
+EB19C21311380F21C4EA0720EB40C814E8EB80F0A26C485A1460000213401E147C9321>
+I<381FF0FF3803C0780001137014403800E0C0EBE180EB73001376133CA2131C132E134E
+1387EA0107380203801204380C01C0383C03E038FE07FC18147F9318>I<390FF83F8039
+01E00E00EBC00C140813E000005B143014205C13705CA20171C7FC1339133A133E133C13
+3813181310A25BA25BEA70C0EAF08000F1C8FC12E61278191D809318>I
+E /Fm 8 89 df<903807F00890383C0C189038E003383901C000B8D80780137848C71238
+120E001E14185A1508127C1278150012F8A6EC1FFF0078EB00F81578127C123CA27E120E
+120F6C7ED801C013B83900E0011890383C0E08903807F00020217C9F27>71
+D<EAFFF0EA0F00B3ABEAFFF00C1F7D9E12>73 D<B4EB0FF8390F8003E0EC0080EA0BC0EA
+09E0A2EA08F01378A27F7FA27FEB0780A2EB03C0EB01E0A2EB00F01478A2143C141EA214
+0F1407A214031401123E38FF80001D1F7C9E25>78 D<EB1FE0EB70383801C00E48487E39
+070003804814C0001EEB01E048EB00F0A2007C14F8A20078147800F8147CA90078147800
+7C14F8A2003C14F0003E1301001E14E06CEB03C06C148039038007003801E01E38007038
+EB1FE01E217C9F26>I<B512F0380F803E0007130FEC0780EC03C0A215E0A415C0A2EC07
+80EC0F00143EEBFFF00180C7FCAD487EEAFFFC1B1F7D9E22>I<3803F020380C0C603818
+03E0EA30005A146012E01420A36C13007E127CEA7F80EA3FFC6CB4FC00071380000113C0
+38000FE013031301EB00F014707EA46C136014E06C13C038F8018038C60300EA81FC1421
+7C9F1C>83 D<39FFF00FF8390F0003E0EC0080B3A46CEB01001380120314026C6C5A6C6C
+5AEB3830EB0FC01D207C9E25>85 D<397FF807FE390FE001F0D807C013C06C6C6C5A0001
+49C7FCEBF0023800F806EB78046D5AEB3E18EB1F106D5A14C0130713036D7E497EEB06F8
+EB0478EB087CEB183EEB101EEB201F496C7EEBC007496C7ED801007F486D7E481300391F
+8001F83AFFC007FF80211F7E9E25>88 D E /Fn 34 121 df<EB01C01303130F137FEA1F
+FFB5FC13BFEAE03F1200B3B1007FB512F0A31C2E7AAD28>49 D<EB3FE03801FFFE0007EB
+FF80D80F8013C0391E003FE00038EB1FF0007CEB0FF8007EEB07FCB4FC018013FEA21403
+A2EA7F00003E1307C7FC15FCA2EC0FF8A215F0EC1FE015C0EC3F80EC7F00147E14F8495A
+495A495A49C7FC011E130E5B133849131E49131C485A48C7123C48B512FC5A5A5A4814F8
+B6FCA31F2E7CAD28>I<913A03FF800180023FEBF00349B5EAFC0701079038003F0FD91F
+F8EB079FD93FC0EB01FFD9FF807F4848C8127F4848153F0007161F49150F485A001F1607
+A2485A1703127FA24992C7FCA212FFA9127FA27FEF0380123FA26C7E1707000F17006C7E
+6D150E0003161E6C6C151C6C6C6C1478D93FC05CD91FF8EB03E0D907FFEB3F800101D9FF
+FEC7FCD9003F13F80203138031317CB03A>67 D<B812F0A3C6903880003FEE07F8160316
+00A21778A21738A3171C1507A31700A25D5D5D91B5FCA3EC803F818181A21707A392C712
+0EA4171EA2173CA2177C17FC16011607163FB812F8A330317EB035>69
+D<B812E0A3C6903880007FEE0FF016031601A21600A21770A31738A21507A21700A35D5D
+5D91B5FCA3EC803F818181A592C8FCACB612C0A32D317EB033>I<DA03FF1303027FEBF0
+0749B5EAFC0F01079038007E1FD91FF0EB0FBFD97FC0EB03FF49487F4848C87E485A0007
+824848815B001F82A2484881A2127FA24992C7FC12FFAA0307B512F8127F7FDB00011300
+123FA26C7EA2120F7F6C7E12036C7E6C6C7E6D6C5BD91FF8497ED907FFEB3E3F01019038
+FFFC1F6D6CEBF00F0203EB800335317CB03F>I<B61280A3C6EB8000B3B3A7B61280A319
+317EB01E>73 D<B67EA3000190C9FCB3A9EE0380A416071700A25EA35E5E5E5E4B5A150F
+B7FCA329317DB030>76 D<B56C49B512C08080C66D90390003E0006E6E5AEBEFFC13E780
+EBE3FF01E17F01E07F6E7E143F816E7E6E7E6E7E14036E7E16806E13C0ED7FE0ED3FF015
+1F16F8ED0FFCED07FEED03FF6F13818117C1EE7FE1EE3FF1EE1FF9EE0FFD160717FF8282
+82177F173FA2171F170F486C1507B500E014031701A23A317EB03F>78
+D<B712E016FEEEFF80C6D9800013E0EE3FF0EE0FF8EE07FCA2EE03FEA217FFA717FEA2EE
+07FC17F8160FEE3FE0EEFFC091B6120016F80280C8FCB3A2B67EA330317EB037>80
+D<B77E16F816FEC690398003FF809238007FE0EE1FF0707EA283160783A65F160F5F4C5A
+4C5A4C5ADB03FFC8FC91B512F816E091388007F8ED01FC6F7E167F83707EA283A583A4F0
+038017F8161F1900706C5AB6398003FE0E933801FFFC9338001FF039317EB03C>82
+D<007FB8FCA39039C00FF801D87E00EC003F007C82007882A200708200F01780A3481603
+A5C792C7FCB3AA017FB6FCA331307DAF38>84 D<B6D88003B51280A3C60180C73807C000
+715AB3AE137F4DC7FC80013F150EA26D6C5C6D6C5C6D6C5C6D6C495A903A00FF801FC002
+3FB55A020F49C8FC020013E039317EB03E>I<B500FC91B5FCA3000390C8EA03C06C1780
+6E14076C170080017F150EA26E141E013F151C6E143C011F153880010F5D8001075DA26E
+130101035D6E13036D5D15806D4AC7FCA26F5A027F130EEDE01E023F131CEDF03C021F13
+3815F8020F5BA2EDFCF002075B15FF6E5BA26E5BA26E90C8FCA3157EA2153CA238317EB0
+3D>I<EBFFF0000313FF390F803F809038C00FE0486C6C7EA26E7ED80FC07FEA0780C7FC
+A414FF131FEBFFE33803FC03EA0FF0EA1FC0123FEA7F80A2EAFF00A31407A2387F800D39
+3FC01DFE3A1FE078FFF03907FFE07FC6EB803F24207E9F27>97 D<EA01F812FFA3120F12
+07ADEC3FE0ECFFFC9038FBE07F9039FF001F8049EB0FC04914E049EB07F016F8A2ED03FC
+A316FEA816FCA3ED07F8A216F06DEB0FE06D14C001E7EB3F809039C3C0FE00903880FFF8
+9038003FC027327EB12D>I<EB0FFF017F13C03901FC01F03803F0033907E007F8120FEA
+1FC0003FEB03F0EC01E04848C7FCA312FFA8127FA36C6C131CA2001F14386C7E00071470
+3903F001E03901FC07C039007FFF00EB0FF81E207D9F24>I<ED0FC0EC07FFA3EC007F15
+3FADEB07F8EB3FFF9038FE07BF3903F801FF3907E0007F120F4848133F123FA2485AA312
+FFA8127FA36C7EA2121F6C6C137F000714FF2603F00313E03A01FC0F3FFE38007FFEEB0F
+F027327DB12D>I<EB0FFC90387FFF803901FC0FC03903F003E03907E001F0000F14F839
+1FC000FC003F14FEA24848137E157FA212FFA290B6FCA20180C7FCA4127FA36C6C130712
+1F150E6C7E6C6C131C6C6C13783900FE03E090383FFFC0903807FE0020207E9F25>I<EB
+01FE90380FFF8090381FC3C090387F07E09038FE0FF0120113FC1203EC07E0EC018091C7
+FCA8B512FCA3D803FCC7FCB3A8387FFFF0A31C327EB119>I<90391FF007C09039FFFE3F
+E03A01F83F79F03907E00FC3000F14E19039C007E0E0001FECF000A2003F80A5001F5CA2
+000F5CEBE00F00075C2603F83FC7FC3806FFFE380E1FF090C9FC121EA2121F7F90B57E6C
+14F015FC6C806C801680000F15C0003FC7127F007EEC1FE0007C140F00FC1407A4007EEC
+0FC0003E1580003F141FD80FC0EB7E003907F803FC0001B512F0D8001F90C7FC242F7E9F
+28>I<EA01F812FFA3120F1207ADEC07F8EC3FFEEC783F02C013809039F9801FC0EBFB00
+01FE14E05BA35BB3B500C3B5FCA328327DB12D>I<EA03C0487E487E487EA46C5A6C5A6C
+5AC8FCA9EA01F8127FA31207B3A7B51280A311337DB217>I<EA01F812FFA3120F1207B3
+B3A6B512C0A312327DB117>108 D<2703F007F8EB1FE000FFD93FFEEBFFF8913A783F01
+E0FC02C090388300FE280FF1801FC6137F2607F30013CC01F602F8148001FC5CA3495CB3
+B500C3B5380FFFFCA33E207D9F43>I<3903F007F800FFEB3FFEEC783F02C013803A0FF1
+801FC03807F30001F614E013FCA35BB3B500C3B5FCA328207D9F2D>I<EB07FC90387FFF
+C03901FC07F03903F001F848486C7E4848137E001F147F003F158049133F007F15C0A300
+FF15E0A8007F15C0A36C6CEB7F80A2001F15006C6C13FE00075C3903F803F83901FE0FF0
+39007FFFC0D907FCC7FC23207E9F28>I<3901F83FE000FFEBFFFC9038FBE07F9039FF00
+3F80D807FEEB1FC049EB0FE04914F0ED07F8A216FC1503A216FEA816FC1507A216F8A2ED
+0FF06D14E06DEB1FC06DEB3F809039FBC0FE009038F8FFF8EC3FC091C8FCABB512C0A327
+2E7E9F2D>I<3803F03F00FFEB7FC09038F1C3E01487390FF30FF0EA07F6A29038FC07E0
+EC03C091C7FCA25BB2B512E0A31C207E9F21>114 D<3801FF86000713FEEA1F00003C13
+3E48131E140E12F8A36C90C7FCB47E13FC387FFFC06C13F0806C7F00077F00017FEA003F
+01001380143F0060131F00E0130FA27E15007E6C131E6C131C38FF807838F3FFF038C07F
+8019207D9F20>I<131CA5133CA3137CA213FC120112031207381FFFFEB5FCA2D803FCC7
+FCB0EC0380A71201EC0700EA00FEEB7F0EEB3FFCEB07F0192E7FAD1F>I<D801F8EB07E0
+00FFEB03FFA3000FEB003F0007141FB3153FA20003147FA26C6CEBDFF03A00FE039FFF90
+387FFF1FEB0FFC28207D9F2D>I<B53A1FFFE03FF8A33C0FF000FE0007806D150300076E
+EB0700816D5D00039138FF800EA26C6C486D5A15DF01FF153C6C9039038FE038A2D97F87
+6D5A150702C714F0D93FCF6D5AECCE03D91FFEEBF9C09138FC01FD16FF010F5D4A7EA26D
+486DC7FCA20103147E4A133EA26D48131C35207E9F3A>119 D<3A7FFF807FFCA33A03FC
+000F006C6C131E6C6C5BEC803890387FC078013F5B90381FE1E090380FF3C0ECFF806D90
+C7FC6D5A13016D7E81815B903803DFE09038078FF08190380F07FC90381E03FEEB3C0149
+6C7E4914804848EB7FC00003EC3FE026FFFC01B5FCA328207F9F2B>I
+E /Fo 1 14 df<14FF010713E090381F00F80178131E01E01307D80180EB018048C812C0
+00061560481530A248151848150CA2481506A4481503A900601506A46C150CA26C15186C
+1530A26C15606C15C06C6CEB0180D800E0EB07000178131E011F13F8903807FFE0010090
+C7FC282B7EA02D>13 D E /Fp 54 122 df<1306130C13181338137013E01201EA03C0A2
+EA0780A2120F13005AA2123EA3127EA3127CA212FCAE127CA2127EA3123EA37EA27E1380
+1207A2EA03C0A2EA01E01200137013381318130C13060F3C7AAC1A>40
+D<123C127FEAFF80A213C0A3127F123E1200A2EA0180A3EA0300A21206120E5A5A12100A
+157B8813>44 D<121C127FA2EAFF80A3EA7F00A2121C09097B8813>46
+D<130E131E137EEA07FE12FFA212F81200B3ABB512FEA317277BA622>49
+D<EBFF80000713F04813FC381E03FE393800FF80007C133F00FE14C06C131F15E0140FA2
+127E003C131FC7FC15C0A2EC3F801500147E5C5C495A495AEB078049C7FC131E4913E013
+705B3901C001C0EA0380EA0600000FB5FC5A5A5AB61280A31B277DA622>I<EB7F803803
+FFF04813FC380F81FE381F007FEA3F80EC3F80A3121F1300C7EA7F00A2147E5C495AEB07
+F0EBFFC0A2EB01F8EB007E801580EC1FC0A215E0A2123C127EB4FCA215C0143F48148000
+7CEB7F00383F01FE6CB45A000713F0C613801B277DA622>I<140FA25C5C5C5C5BA2EB03
+BFEB073F130E131C133C1338137013E0EA01C0EA038012071300120E5A5A5A12F0B612F8
+A3C7EA7F00A890381FFFF8A31D277EA622>I<00181303381F801FEBFFFE5C5C5C14C091
+C7FC001CC8FCA7EB7FC0381DFFF8381F80FC381E003F1208C7EA1F8015C0A215E0A21218
+127C12FEA315C05A0078EB3F80A26CEB7F00381F01FE6CB45A000313F0C613801B277DA6
+22>I<EB7F803801FFF000077F380FC0FC381F803E48487E007E1480A2140F00FE14C0A3
+15E0A5007E131FA26C133F6C132F380F80CF3807FF8F0001130FEA0008010013C0A3EC1F
+80123E127FEC3F00143E147E007E5B383E03F8381FFFE06C1380D801FEC7FC1B277DA622
+>57 D<EC0780A24A7EA34A7EA24A7EA3EC77F8A2ECF7FC14E3A2903801C1FEA201037F14
+80A249486C7EA24980010E133FA2496D7EA2013FB57EA39039700007F8A201F080491303
+000181491301A2000381D8FFFE013F13FCA32E297EA833>65 D<B612F815FF16C03A03F8
+001FE0ED0FF0ED07F8150316FCA21501A3150316F8A2ED07F0150FED1FC0EDFF8090B5EA
+FE00EDFFC09039F8000FF0ED03F8ED01FC16FE1500A216FFA616FE1501ED03FC1507ED1F
+F8B712E016C0EDFE0028297DA830>I<91387FE003903907FFFC07011FEBFF0F90397FF0
+0F9F9039FF0001FFD801FC7F4848147F4848143F4848141F485A160F485A1607127FA290
+C9FC5AA97E7F1607123FA26C7E160E6C7E6C6C141C6C6C143C6C6C14786CB4EB01F09039
+7FF007C0011FB512800107EBFE009038007FF028297CA831>I<B612FCEDFF8016E03A03
+FC001FF8ED03FCED00FE167FEE3F80EE1FC0A2EE0FE0A2EE07F0A417F8AA17F0A3EE0FE0
+A217C0161FEE3F80EE7F005EED03FCED1FF8B75A168003FCC7FC2D297EA834>I<B712E0
+A33903FC001FED07F01501A215001670A3913801C0781638A302031300A2140F90B5FCA3
+EBFC0F1403A20201130EA3161C91C7FCA3163C1638167816F815011503151FB712F0A327
+297EA82C>I<B712C0A33903FC003FED0FE015031501A21500A316F0913801C070A31600
+1403A2140F90B5FCA3EBFC0F1403A21401A491C8FCA9B512FCA324297EA82A>I<91387F
+E003903907FFFC07011FEBFF0F90397FF00F9F9039FF0001FFD801FC7F48488048488048
+4880485A82485A82127FA290CAFC5AA892B512F87E7F03001300123FA26C7EA26C7E6C7E
+6C7E6C7E6CB45B90387FF007011FB5129F0107EBFE0F9039007FF0032D297CA835>I<B5
+D8F00FB5FCA3D803FCC7EA3FC0AF90B7FCA301FCC7123FB1B5D8F00FB5FCA330297EA835
+>I<B512F0A33803FC00B3B1B512F0A314297EA819>I<B500F0EBFFFEA3D803FCC7EA0F00
+161E5E5E16E0ED03C04B5A4BC7FC151E5D15F04A5A4A5A1407140F4A7EEC7FF04A7EEBFD
+E79038FFC3FCEC83FE9038FE01FF497E6F7E826F7E151F6F7E8215076F7E6F7E8281EE7F
+80B539F00FFFFEA32F297EA835>75 D<B512FCA3D803FCC8FCB3A3ED01C0A415031680A2
+1507A2150FA2151F157F913801FF00B7FCA322297EA828>I<D8FFFE92383FFF80A26D5D
+0003EFE000A2D9BF8014EFA2D99FC0EB01CFA2D98FE0EB038FA3D987F0EB070FA2D983F8
+130EA2D981FC131CA3D980FE1338A2027F1370A291383F80E0A391381FC1C0A291380FE3
+80A2913807F700A3EC03FEA26E5AA26E5AD8FFFE0203B51280A2157039297DA840>I<D8
+FFFCEC7FFF7F7F00036DEB01C080EBBFE0139F80EB8FF8EB87FCEB83FEEB81FF01801380
+147F15C0EC3FE0EC1FF0EC0FF8EC07FC140315FEEC01FF6E1381ED7FC1ED3FE1ED1FF115
+0F16F9ED07FDED03FF8181167FA2163F161F160F1607D8FFFE14031601A230297EA835>
+I<ECFFC0010F13FC90383F807F9039FE001FC0D801F8EB07E048486D7E48486D7E000F81
+48486D7EA24848147FA2007F168090C8123FA34816C0AA6C16806D147FA2003F1600A26C
+6C14FEA26C6C495A6C6C495A6C6C495A6C6C495A6C6C495A90263FC0FFC7FC90380FFFFC
+010013C02A297CA833>I<B612F815FF16C03A03FC003FE0ED07F0ED03F816FC150116FE
+A716FC150316F8ED07F0ED3FE090B61280EDFE0001FCC8FCB0B512F0A327297EA82E>I<
+ECFFC0010F13FC90383FC0FF9039FE001FC048486D7ED803F0EB03F000078148486D7E48
+486D7EA24848147FA2007F1680A290C8123FA24816C0AA6C16806D147FA2003F1600A26C
+6C14FE143E3A0FE07F81FC00079038C1C1F83A03F18063F0D801F9EB67E0D800FFEB3FC0
+90263FC07FC7FC90380FFFFC01004913C0EC003C811601ED1F8316FF6F1380A21700816F
+5A6F5A6F5A2A357CA833>I<B612E015FE6F7E3A03FC003FE0ED0FF06F7E6F7E150182A6
+5E4B5A1507ED0FE0ED3FC090B500FEC7FCA29039FC00FF80ED3FC06F7E6F7E6F7EA9170E
+A21503923801FC1CB538F000FEEE7FF8EE0FE02F297EA832>I<9038FF80600003EBF0E0
+000F13F8381F80FD383F001F003E1307481303A200FC1301A214007EA26C140013C0EA7F
+FCEBFFE06C13F86C13FE80000714806C14C0C6FC010F13E0EB007FEC1FF0140F140700E0
+1303A46C14E0A26C13076C14C0B4EB0F80EBE03F39E3FFFE0000E15B38C01FF01C297CA8
+25>I<007FB71280A39039807F807FD87C00140F00781507A20070150300F016C0A24815
+01A5C791C7FCB3A490B612C0A32A287EA72F>I<B500F0EBFFFEA3D803FCC7EA0380B3AA
+0001ED07007F0000150E137F6D143CD91FC05B90390FF003F06DB55A01001480DA1FFCC7
+FC2F297EA834>I<B500F0EB7FFFA3D803FEC7EA01C00001ED0380A26D14076C16006E5B
+017F140E80013F5CA26E133C011F14386E1378010F14708001075CA26D6C485AA2ECFE03
+01015CECFF076D91C7FC1587EC7F8EA215DEEC3FDC15FC6E5AA26E5AA36E5AA26E5AA230
+297FA833>I<B53CE07FFFE01FFFC0A32803FC0003FCC7EA7000A26D6D7E000160A26D6E
+13016C604B138002801503017F5F4B13C0D93FC0013F49C7FCA2913AE00E1FE00F011F16
+0E17F09126F01C0F131E010F161C033C13F8902707F838075BA2037813FC902703FC7003
+5BA2913AFEE001FEF001015E02FF14FF4B7E6D5EA26E486D5AA36EC76CC8FCA2023E8002
+1E141EA242297FA845>I<B500F0EB3FFFA3D803FEC7EA03C06C6C15806C6DEB07005E6D
+6C130E6E5B013F143C6D6C13386E5B010F14F06D6C5B6E485A01031303D901FF5B0387C7
+FC6D138FEC7FCE15FC143F6E5A5D140FAE0103B512C0A330297FA833>89
+D<3803FF80000F13F0381F01FC383F80FE147F801580EA1F00C7FCA4EB3FFF3801FC3FEA
+0FE0EA1F80EA3F00127E5AA4145F007E13DF393F839FFC381FFE0F3803FC031E1B7E9A21
+>97 D<EAFFE0A3120FACEBE1FE9038EFFF809038FE07E09038F803F09038F001F89038E0
+00FCA2157EA2157FA8157EA315FCA29038F001F89038F803F090389C0FE090380FFF8039
+0E01FC00202A7EA925>I<EB3FF03801FFFC3803F03E380FC07FEA1F80EA3F00A248133E
+007E90C7FCA212FEA7127EA2127F6CEB03801380001FEB0700380FE00E3803F83C3801FF
+F838003FC0191B7E9A1E>I<EC7FF0A31407ACEB3F873801FFF73807F03F380FC00F381F
+8007EA3F00A2127EA312FEA8127EA27EA2381F800F380FC01F3907E07FFF3801FFE73800
+7F87202A7EA925>I<EB3FC03801FFF03803E07C380F803E001F7F130048EB0F80127E15
+C0A200FE1307A2B6FCA248C8FCA3127EA2127F6CEB01C07E390F8003803907C007003803
+F01E3800FFFCEB3FE01A1B7E9A1F>I<EB07F8EB3FFCEB7E3E3801FC7FEA03F813F01207
+143E1400A7B512C0A33807F000B3A3387FFF80A3182A7EA915>I<9038FF80F00003EBE3
+F8390FC1FE1C391F007C7C48137E003EEB3E10007EEB3F00A6003E133E003F137E6C137C
+380FC1F8380BFFE00018138090C8FC1238A2123C383FFFF814FF6C14C06C14E06C14F012
+1F383C0007007CEB01F8481300A4007CEB01F0A2003FEB07E0390FC01F806CB512003800
+7FF01E287E9A22>I<EAFFE0A3120FAC147E9038E1FF809038E30FC001E413E0EBE80701
+F813F013F0A213E0B039FFFE3FFFA3202A7DA925>I<1207EA0F80EA1FC0EA3FE0A3EA1F
+C0EA0F80EA0700C7FCA7EAFFE0A3120FB3A3EAFFFEA30F2B7EAA12>I<EAFFE0A3120FB3
+B2EAFFFEA30F2A7EA912>108 D<26FFC07FEB1FC0903AC1FFC07FF0903AC307E0C1F8D8
+0FC49038F101FC9039C803F20001D801FE7F01D05BA201E05BB03CFFFE3FFF8FFFE0A333
+1B7D9A38>I<38FFC07E9038C1FF809038C30FC0D80FC413E0EBC80701D813F013D0A213
+E0B039FFFE3FFFA3201B7D9A25>I<EB3FE03801FFFC3803F07E390FC01F80391F800FC0
+393F0007E0A2007EEB03F0A300FE14F8A8007E14F0A26CEB07E0A2391F800FC0390FC01F
+803907F07F003801FFFC38003FE01D1B7E9A22>I<38FFE1FE9038EFFF809038FE0FE039
+0FF803F09038F001F801E013FC140015FEA2157FA8157E15FEA215FC140101F013F89038
+F807F09038FC0FE09038EFFF809038E1FC0001E0C7FCA9EAFFFEA320277E9A25>I<38FF
+C1F0EBC7FCEBC63E380FCC7F13D813D0A2EBF03EEBE000B0B5FCA3181B7F9A1B>114
+D<3803FE30380FFFF0EA3E03EA7800127000F01370A27E00FE1300EAFFE06CB4FC14C06C
+13E06C13F0000713F8C6FCEB07FC130000E0137C143C7E14387E6C137038FF01E038E7FF
+C000C11300161B7E9A1B>I<13E0A41201A31203A21207120F381FFFE0B5FCA2380FE000
+AD1470A73807F0E0000313C03801FF8038007F0014267FA51A>I<39FFE07FF0A3000F13
+07B2140FA2000713173903F067FF3801FFC738007F87201B7D9A25>I<39FFFC03FFA339
+0FF000F0000714E07F0003EB01C0A2EBFC0300011480EBFE070000140013FFEB7F0EA214
+9EEB3F9C14FC6D5AA26D5AA36D5AA26D5AA2201B7F9A23>I<3BFFFC7FFC1FFCA33B0FE0
+0FE001C02607F007EB0380A201F8EBF00700031600EC0FF801FC5C0001150EEC1FFC2600
+FE1C5B15FE9039FF387E3C017F1438EC787F6D486C5A16F0ECE01F011F5CA26D486C5AA2
+EC800701075CA22E1B7F9A31>I<39FFFC1FFEA33907F003803803F8079038FC0F003801
+FE1E00005BEB7F3814F86D5A6D5A130F806D7E130F497EEB3CFEEB38FFEB787F9038F03F
+803901E01FC0D803C013E0EB800F39FFF03FFFA3201B7F9A23>I<39FFFC03FFA3390FF0
+00F0000714E07F0003EB01C0A2EBFC0300011480EBFE070000140013FFEB7F0EA2149EEB
+3F9C14FC6D5AA26D5AA36D5AA26D5AA25CA21307003890C7FCEA7C0FEAFE0E131E131C5B
+EA74F0EA3FE0EA0F8020277F9A23>I E /Fq 90 127 df<127012F8B012701200A51270
+12F8A31270051C779B18>33 D<EA4010EAE038EAF078EAE038AAEA60300D0E7B9C18>I<
+EA0306EA078FA6387FFFC0B512E0A26C13C0380F1E00A6387FFFC0B512E0A26C13C0381E
+3C00A6EA0C18131C7E9B18>I<13C01201A3EA03F0EA0FFCEA3FFEEA7DCFEA71C738E1C3
+8013C7A338F1C0001279123F6C7EEA0FF8EA01FC13DE13CF13C73861C38012F1A212E1EB
+C7001271EA79DEEA3FFEEA1FF8EA07E0EA01C0A3120011247D9F18>I<EA3803387C0780
+A2EAEE0F1400A25B131EA2133EEA7C3CA2EA387CEA0078A213F85B12015BA212035BA212
+07EB8380EB87C0120FEB0EE0A2121F121EA2123E383C07C0A23818038013247E9F18>I<
+EA01C0EA07E0487EEA0E70487EA4EB73F813F313E3380FC1C0EBC38013831303381F0700
+EA3F87EA7B8EEA71CEEAE1FC12E0137CEB7870A2EA70FE387FFFE0EA3FC7380F03C0151C
+7F9B18>I<1238127CA2127E123E120EA3121CA2123812F812F012C0070E789B18>I<1370
+13F0EA01E0EA03C0EA0780EA0F00121E121C5AA25AA45AA81270A47EA27E121E7EEA0780
+EA03C0EA01F0120013700C24799F18>I<126012F012787E7E7EEA07801203EA01C0A2EA
+00E0A41370A813E0A4EA01C0A2EA03801207EA0F00121E5A5A5A12600C247C9F18>I<EA
+01C0A4EA41C138F1C780EAFDDF387FFF00EA1FFCEA07F0A2EA1FFCEA7FFF38FDDF80EAF1
+C73841C100EA01C0A411147D9718>I<136013F0A7387FFFC0B512E0A26C13C03800F000
+A7136013147E9718>I<121C123E127E127F123F121F1207120E121E127C12F81260080C
+788518>I<387FFFC0B512E0A26C13C013047E8F18>I<1230127812FCA212781230060677
+8518>I<1303EB0780A2130F14005B131EA2133E133C137C1378A213F85B12015B12035B
+A212075B120F90C7FCA25A121E123E123CA2127C127812F85AA2126011247D9F18>I<EA
+01F0EA07FC487EEA1F1FEA1C0738380380007813C0EA7001A238E000E0A9EAF001007013
+C0A2EA780300381380381C0700EA1F1FEA0FFE6C5AEA01F0131C7E9B18>I<EA01801203
+A21207120F123F12FF12FB12431203B0EA7FFCEAFFFEEA7FFC0F1C7B9B18>I<EA03F0EA
+0FFEEA3FFF387C0F80387003C0EAE00138F000E0A21260C7FCA2EB01C0A21303EB0780EB
+0F00131E5B5B5B485AEA07C0485A381E00E05AEA7FFFB5FC7E131C7E9B18>I<131F5B13
+77A213E7120113C7EA038712071307120E121E123C1238127812F0B512F8A338000700A6
+EB7FF0A3151C7F9B18>52 D<383FFF80A30038C7FCA8EA3BF8EA3FFE7F383C0780383003
+C0EA0001EB00E0A2126012F0A238E001C0EA7003387C0F80383FFF00EA1FFCEA03F0131C
+7E9B18>I<137E48B4FC00071380380F83C0EA1E03121C3838018090C7FC5AA2EAE1F8EA
+E7FEB5FC38FE078038F803C0EAF001EB00E05A7E1270A3383801C0EA3C03381E0780380F
+FF006C5AEA01F8131C7E9B18>I<12E0B512E0A214C038E00380EB0700C65A131E131C5B
+A25B13F05BA2485AA3485AA448C7FCA7131D7E9C18>I<EA03F8EA0FFE487E383E0F80EA
+3803387001C0A438380380EA3C07381FFF00EA07FC487EEA1F1F383C0780387001C000F0
+13E0EAE000A4387001C0EA7803383E0F80381FFF006C5AEA03F8131C7E9B18>I<123012
+7812FCA2127812301200A81230127812FCA2127812300614779318>58
+D<1218123C127EA2123C12181200A81218123C127EA2123E121E120E121C123C127812F0
+1260071A789318>I<14C0EB03E01307EB1FC0EB3F80EBFE00485AEA07F0485AEA3F8048
+C7FC12FCA2127F6C7EEA0FE06C7EEA01FC6C7EEB3F80EB1FC0EB07E01303EB00C013187E
+9918>I<387FFFC0B512E0A3C8FCA4B512E0A36C13C0130C7E9318>I<126012F87E127F6C
+7EEA0FE06C7EEA01FC6C7EEB3F80EB1FC0EB07E0A2EB1FC0EB3F80EBFE00485AEA07F048
+5AEA3F8048C7FC12FC5A126013187E9918>I<EA0FF0EA3FFC48B4FCEA700F38F00380A2
+EA600738000F00133E5BEA01F05B485AA55BC8FCA5EA0380487EA36C5A111C7D9B18>I<
+137CEA01FEEA07FF380F8780381E03C0EA3C1DEA387F3870FFE0EA71E313C112E1EAE380
+A638E1C1C0127113E33870FF8038387F00EA3C1C381E00E0EA0F833807FFC00001138038
+007E00131C7E9B18>I<137013F8A213D8A2EA01DCA3138CEA038EA4EA0707A5380FFF80
+A3EA0E03381C01C0A3387F07F000FF13F8007F13F0151C7F9B18>I<EA7FFCB5FC6C1380
+381C03C01301EB00E0A4130114C01307381FFF80140014C0EA1C03EB00E014F01470A414
+F014E01303387FFFC0B51280387FFE00141C7F9B18>I<EBF8E0EA03FEEA07FFEA0F07EA
+1E03EA3C01EA38005AA214005AA8127014E0A27E123C381E01C0EA0F073807FF803803FE
+00EA00F8131C7E9B18>I<EA7FF8EAFFFE6C7E381C0F80EB03C0A2EB01E01300A214F014
+70A814F014E0A2130114C01303EB0F80387FFF00485AEA7FF8141C7F9B18>I<B512F0A3
+381C0070A41400A2130EA3EA1FFEA3EA1C0EA390C7FCA21438A5B512F8A3151C7F9B18>
+I<B512F8A3381C0038A41400A21307A3EA1FFFA3EA1C07A390C7FCA7EAFFC0A3151C7F9B
+18>I<3801F1C0EA03FDEA0FFFEA1F0FEA1C03123813011270A290C7FC5AA5EB0FF0131F
+130F387001C0A213031238A2EA1C07EA1F0FEA0FFFEA03FDEA01F1141C7E9B18>I<387F
+07F038FF8FF8387F07F0381C01C0A9EA1FFFA3EA1C01AA387F07F038FF8FF8387F07F015
+1C7F9B18>I<EA7FFFB512806C1300EA01C0B3A4EA7FFFB512806C1300111C7D9B18>I<38
+01FFC0A338000E00B312F0A2133CEA7FFCEA3FF0EA0FC0121C7D9B18>I<387F07F038FF
+87F8387F07F0381C03C0EB07801400130E131E5B13385B13F0121DA2EA1FB8A2131C121E
+EA1C0EA27FA2EB0380A2EB01C0387F03F038FF87F8387F03F0151C7F9B18>I<EAFFC0A3
+001CC7FCB114E0A5B5FCA3131C7E9B18>I<38FC01F8EAFE03A2383B06E0A4138EA2EA39
+8CA213DCA3EA38D8A213F81370A21300A638FE03F8A3151C7F9B18>I<387E07F038FF0F
+F8387F07F0381D81C0A313C1121CA213E1A313611371A213311339A31319A2131D130DA3
+EA7F07EAFF87EA7F03151C7F9B18>I<EA0FFE383FFF804813C0EA7803EA700100F013E0
+EAE000B0EAF001007013C0EA7C07EA7FFF6C1380380FFE00131C7E9B18>I<EAFFFEEBFF
+8014C0EA1C03EB01E013001470A514E01301EB03C0EA1FFF1480EBFE00001CC7FCA8B47E
+A3141C7F9B18>I<EA0FFE383FFF804813C0EA7803EA700100F013E0EAE000AE1370A2EA
+F079387039C0EA783FEA7FFF6C1380380FFE00EA000FEB0780A2EB03C01301A213227E9B
+18>I<EA7FF8EAFFFE6C7E381C0F80130314C01301A313031480130F381FFF005BA2EA1C
+0F7FEB0380A5149CA3387F01F8EAFF81387F00F0161C7F9B18>I<3803F1C0EA1FFF5AEA
+7C0FEA7003EAE001A390C7FC12701278123FEA1FF0EA07FEC67EEB0F80EB03C01301EB00
+E0A2126012E0130100F013C038F80780B5FCEBFE00EAE7F8131C7E9B18>I<387FFFF8B5
+FCA238E07038A400001300B2EA07FFA3151C7F9B18>I<38FF83FEA3381C0070B36C13E0
+EA0F01380783C03803FF806C1300EA007C171C809B18>I<38FE03F8EAFF07EAFE03383C
+01E0001C13C0A3EA1E03000E1380A438070700A4EA038EA4EA018C13DCA3EA00D813F8A2
+1370151C7F9B18>I<38FE03F8A338700070A36C13E0A513F8EA39FC13DCA2001913C0A3
+138CA2EA1D8DA31305000D1380EA0F07A2EA0E03151C7F9B18>I<387F0FE0139F130F38
+0E0700120FEA070E138EEA039C13DCEA01F8A212005B137013F07F487E13DCEA039E138E
+EA070F7F000E13801303001E13C0387F07F000FF13F8007F13F0151C7F9B18>I<38FE03
+F8EAFF07EAFE03381C01C0EA1E03000E1380EA0F0700071300A2EA038EA2EA01DCA3EA00
+F8A21370A9EA01FC487E6C5A151C7F9B18>I<EAFFF8A3EAE000B3ACEAFFF8A30D24779F
+18>91 D<126012F0A27E1278127C123CA2123E121E121F7EA27F12077F1203A27F12017F
+12007F1378A2137C133C133E131EA2131F7F14801307A2EB030011247D9F18>I<EAFFF8
+A3EA0038B3ACEAFFF8A30D247F9F18>I<387FFFC0B512E0A26C13C013047E7F18>95
+D<1206121E123E12381270A212E0A312F812FC127CA21238070E789E18>I<EA0FF0EA1F
+FC487EEA3C0FEA180738000380A213FF1207121FEA7F03127812E0A3EAF007EA780F383F
+FFF8EA1FFDEA07F015147E9318>I<127E12FE127E120EA5133EEBFF80000F13C0EBC1E0
+1380EB0070120E1438A6000F1370A2EB80E013C1EBFFC0000E138038063E00151C809B18
+>I<EA01FEEA07FF001F1380EA3E073838030048C7FCA25AA61270EB01C01238EA3E0338
+1FFF8000071300EA01FC12147D9318>I<EB1F80133F131F1303A5EA03E3EA0FFBEA1FFF
+EA3C1FEA380FEA7007130312E0A6EA7007A2EA380FEA3C1F381FFFF0380FFBF83803E3F0
+151C7E9B18>I<EA01F0EA07FCEA1FFEEA3E0F38380780EA7003A238E001C0A2B5FCA300
+E0C7FC1270EB01C01238EA3E07381FFF8000071300EA01F812147D9318>I<EB1F80EB7F
+C0EBFFE013E13801C0C01400A3387FFFC0B5FCA23801C000AEEA7FFFA3131C7F9B18>I<
+3801E1F03807FFF85A381E1E30381C0E00487EA5EA1C0EEA1E1EEA1FFC5BEA39E00038C7
+FC7EEA1FFEEBFFC04813E0387801F038700070481338A4007813F0EA7E03381FFFC06C13
+803801FC00151F7F9318>I<127E12FE127E120EA5133EEBFF80000F13C013C1EB80E013
+00120EAB387FC7FC38FFE7FE387FC7FC171C809B18>I<EA0380EA07C0A3EA0380C7FCA4
+EA7FC012FF127F1201AEB5FCA3101D7C9C18>I<1338137CA313381300A4EA0FFCA3EA00
+1CB3A4EA6038EAF078EAFFF0EA7FE0EA3F800E277E9C18>I<127E12FE127E120EA5EB3F
+F0A3EB0780EB0F00131E5B5B5BEA0FF87F139C130EEA0E0F7FEB038014C0387FC7F812FF
+127F151C7F9B18>I<EAFFC0A31201B3A4B51280A3111C7D9B18>I<38F9C1C038FFF7F013
+FF383E3E38EA3C3CA2EA3838AB38FE3E3EEB7E7EEB3E3E1714809318>I<EA7E3E38FEFF
+80007F13C0EA0FC1EB80E01300120EAB387FC7FC38FFE7FE387FC7FC1714809318>I<EA
+01F0EA0FFE487E383E0F80EA3803387001C0A238E000E0A5EAF001007013C0EA7803383C
+0780EA3E0F381FFF006C5AEA01F013147E9318>I<EA7E3E38FEFF80007F13C0380FC1E0
+1380EB0070120E1438A6000F1370A2EB80E013C1EBFFC0000E1380EB3E0090C7FCA7EA7F
+C0487E6C5A151E809318>I<3801F380EA07FBEA1FFFEA3E1FEA380FEA7007A2EAE003A6
+EA7007A2EA380FEA3C1FEA1FFFEA0FFBEA03E3EA0003A7EB1FF0EB3FF8EB1FF0151E7E93
+18>I<38FF0FC0EB3FE0EB7FF0EA07F0EBE060EBC0005BA290C7FCA9EAFFFC7F5B14147E
+9318>I<EA07F7EA3FFF5AEA780FEAE007A3007CC7FCEA7FE0EA1FFCEA03FEEA001F3860
+0780EAE003A212F038F80F00B5FC13FCEAE7F011147D9318>I<487E1203A4387FFFC0B5
+FCA238038000A9144014E0A33801C1C013FF6C1380EB3E0013197F9818>I<387E07E0EA
+FE0FEA7E07EA0E00AC1301EA0F033807FFFC6C13FE3801FCFC1714809318>I<387F8FF0
+00FF13F8007F13F0381C01C0380E0380A338070700A3138FEA038EA3EA01DCA3EA00F8A2
+137015147F9318>I<38FF07F8138F1307383800E0A4381C01C0137113F9A213D9EA1DDD
+000D1380A3138DEA0F8FA23807070015147F9318>I<387F8FF0139F138F380F0700EA07
+8EEA039EEA01DC13F81200137013F07FEA01DCEA039E138EEA0707000E1380387F8FF000
+FF13F8007F13F015147F9318>I<387F8FF000FF13F8007F13F0380E01C0EB0380A21207
+EB0700A2EA0387A2138EEA01CEA213CC120013DC1378A31370A313F05B1279EA7BC0EA7F
+806CC7FC121E151E7F9318>I<383FFFF05AA2387001E0EB03C0EB078038000F00131E5B
+13F8485AEA03C0485A380F0070121E5A5AB512F0A314147F9318>I<EB07E0131F137FEB
+780013E0AB1201EA7FC0485AA26C7EEA01E01200AB1378EB7FE0131F130713247E9F18>
+I<126012F0B3B012600424769F18>I<127CB4FC13C01203C67EAB7FEB7FC0EB3FE0A2EB
+7FC0EBF0005BABEA03C012FF90C7FC127C13247E9F18>I<EA060CEA1F1EEA3FBEEAFBF8
+EAF1F0EA60C00F067C9B18>I E /Fr 78 123 df<90381F83E09038F06E303901C07878
+380380F8903800F03048EB7000A7B612803907007000B2383FE3FF1D20809F1B>11
+D<133FEBE0C0EA01C0380381E0EA0701A290C7FCA6B512E0EA0700B2383FC3FC1620809F
+19>I<EB3FE013E0EA01C1EA0381EA0700A8B5FCEA0700B2383FE7FC1620809F19>I<9038
+1F81F89038F04F043901C07C06390380F80FEB00F05A0270C7FCA6B7FC3907007007B23A
+3FE3FE3FE02320809F26>I<EA7038EAF87CEAFC7EA2EA743AEA0402A3EA0804A2EA1008
+A2EA2010EA40200F0E7F9F17>34 D<1340A2EA03F0EA0C4EEA1041382040801260004013
+4038C041C01343A238E04180EB40001270127CEA3FC0EA1FF86C7EEA03FEEA007FEB4F80
+1343EB41C0A2EAF040A312801480EA404100201300EA3042EA0C4CEA03F0EA0040A31225
+7EA117>36 D<127012F812FCA212741204A31208A21210A212201240060E7C9F0D>39
+D<13401380EA01005A12061204120C5AA212381230A212701260A412E0AC1260A4127012
+30A212381218A27E120412067E7EEA008013400A2E7BA112>I<7E12407E12307E120812
+0C7EA212077EA213801201A413C0AC1380A412031300A25A1206A25A120812185A12205A
+5A0A2E7EA112>I<127012F012F8A212781208A31210A31220A21240050E7C840D>44
+D<EAFFF0A20C02808A0F>I<127012F8A3127005057C840D>I<144014C0EB0180A3EB0300
+A31306A25BA35BA35BA25BA35BA3485AA348C7FCA21206A35AA35AA25AA35AA35AA2122D
+7EA117>I<EA03F0EA0E1C487EEA1806EA380738700380A400F013C0AD00701380A3EA78
+0700381300EA1806EA1C0E6C5AEA03F0121F7E9D17>I<13801203120F12F31203B3A6EA
+07C0EAFFFE0F1E7C9D17>I<EA03F0EA0C1CEA100E487E00401380128000F013C0EAF803
+A3EA200712001480A2EB0F00130E5B5B5B13605B485A48C7FC000613405A5A00101380EA
+3FFF5AB5FC121E7E9D17>I<EA03F0EA0C1CEA100EEA200F007813801307A2EA380F1200
+1400A2131E131C1370EA07F0EA003C130E130FEB0780A214C0122012F8A300F013801240
+EB0F00EA200EEA183CEA07F0121F7E9D17>I<1306A2130EA2131E132EA2134E138EA2EA
+010E1202A212041208A212101220A2124012C0B512F038000E00A7EBFFE0141E7F9D17>
+I<EA1803EA1FFE5B5B13E00010C7FCA6EA11F0EA161CEA180EEA10071480EA0003A214C0
+A3127012F0A200E013801240EB0700EA20066C5AEA0838EA07E0121F7E9D17>I<137CEA
+0182EA0701380E0380EA0C0712183838030090C7FC12781270A2EAF1F0EAF21CEAF406EA
+F807EB0380A200F013C0A51270A214801238EB07001218EA0C0E6C5AEA01F0121F7E9D17
+>I<1240387FFFE014C0A23840008038800100A21302485AA25B5BA25BA21360A213E05B
+1201A41203A76C5A131F7E9D17>I<EA03F0EA0C0CEA1006EA3003382001801260A31270
+38780300123EEA3F06EA1FC8EA0FF0EA03F8487EEA0C7EEA103F38300F80EA6007EB01C0
+12C01300A31480EA600100201300EA1002EA0C0CEA03F0121F7E9D17>I<EA03F0EA0E18
+487E487E13071270EB038012F0A214C0A5EA7007A21238EA180BEA0E13EA03E338000380
+A3EB07001230EA7806130EEA700CEA2018EA1070EA0FC0121F7E9D17>I<127012F8A312
+701200AA127012F8A3127005147C930D>I<127012F8A312701200AA127012F012F8A212
+781208A31210A31220A21240051D7C930D>I<5B497EA3497EA3EB09E0A3EB10F0A3EB20
+78A3497EA2EBC03EEB801EA248B5FCEB000FA20002EB0780A348EB03C0A2120C001E14E0
+39FF801FFE1F207F9F22>65 D<B512E0380F0078141EA2801580A515005C141E147CEBFF
+F0EB007C141FEC0F80EC07C0140315E0A515C014071580EC0F00143EB512F01B1F7E9E20
+>I<90380FE0109038381C309038E002703803C00139078000F048C71270121E15305A15
+10127C127800F81400A91278007C1410123CA26C1420A27E6C6C13406C6C13803900E003
+00EB380CEB0FF01C217E9F21>I<B512F83807801EEC0780EC03C0EC01E0EC00F0157015
+78A2153CA3153EA8153CA2157C1578A215F0EC01E0EC03C0EC0780EC1E00B512F81F1F7F
+9E23>I<B61280380F000F14031401140015C01540A314401500A214C0130113FF130113
+001440A3EC0020A31540A315C01401EC0380140FB6FC1B1F7E9E1F>I<B6128038078007
+1401A2140015C01540A4EC2000A3146014E013FF138014601420A391C7FCA87FEAFFFE1A
+1F7F9E1E>I<90380FE0109038381C309038E002703803C00139078000F048C71270121E
+15305A1510127C127800F81400A7EC3FFEEC01F000781300127C123CA27EA27E6C7E3903
+C001703900E002309038380C1090380FF0001F217E9F24>I<39FFF07FF8390F000780AD
+90B5FCEB0007AF39FFF07FF81D1F7E9E22>I<EAFFF0EA0F00B3ABEAFFF00C1F7E9E10>I<
+3807FFC038003E00131EB3A3122012F8A3EAF01CEA403CEA6038EA1070EA0FC012207F9E
+17>I<39FFF007FC390F0003E0EC0180150014025C5C5C5C5C5C49C7FC5B497E130FEB13
+C0EB21E01341EB80F0EB0078A28080A280EC0780A2EC03C015E015F039FFF01FFE1F1F7E
+9E23>I<EAFFF8EA0F8090C7FCB21402A414061404A2140C141C147CB512FC171F7E9E1C>
+I<B46CEB07FE000715C0A2D805C0130BA2D804E01313A301701323A26D1343A36D1383A2
+90380E0103A3EB0702A3EB0384A2EB01C8A3EB00F0A21460121FD8FFE0EB7FFE271F7F9E
+2A>I<B4EB0FF8390F8003E0EC0080EA0BC0EA09E0A2EA08F01378A27F7FA27FEB0780A2
+EB03C0EB01E0A2EB00F01478A2143C141EA2140F1407A214031401123E38FF80001D1F7E
+9E22>I<EB1FE0EB70383801C00E48487E39070003804814C0001EEB01E048EB00F0A200
+7C14F8A20078147800F8147CA900781478007C14F8A2003C14F0003E1301001E14E06CEB
+03C06C148039038007003801E01E38007038EB1FE01E217E9F23>I<B512E0380F007C14
+1E80EC0780A215C0A41580A2EC0F00141E147CEBFFE090C8FCAEEAFFF01A1F7E9E1F>I<
+B57E380F00F0143C8080A21580A41500A2141E5C14F0EBFF80EB01C0EB0070A280143CA3
+143EA31504143F141FEC0F0839FFF00788C7EA01F01E207E9E21>82
+D<3803F040380C0CC0EA1803EA3001EA6000A212E01440A36C13007E127CEA7F80EA3FF8
+6CB4FC00071380C613C0EB1FE013031301EB00F014707EA46C136014E06C13C038F80180
+38C60300EA81FC14217E9F19>I<007FB512E038780F010060EB006000401420A200C014
+3000801410A400001400B3497E3803FFFC1C1F7E9E21>I<39FFF00FF8390F0003E0EC00
+80B3A46CEB01001380120314026C6C5A6C6C5AEB3830EB0FC01D207E9E22>I<39FFF003
+FE391F8000F86CC7126015206C6C1340A36C6C1380A2EBE00100011400A23800F002A213
+F8EB7804A26D5AA36D5AA2131F6D5AA2EB07C0A36D5AA36DC7FC1F207F9E22>I<3BFFF0
+7FF81FF03B1F000FC007C06C903907800180170015C001805C00071502EC09E013C00003
+5DEC19F01410D801E05CA2EC2078D800F05CA2EC403C01785CA2EC801E017C1460013C14
+4090383D000F133F6D5CA2011E1307010E91C7FCA2010C7F010413022C207F9E2F>I<39
+FFF001FF391F800078000F146012076D1340000314807F3901F001001200EBF802EB7C06
+EB3C04EB3E08131EEB1F10EB0FB0EB07A014E06D5AACEB3FFC201F7F9E22>89
+D<12FFA212C0B3B3A512FFA2082D7CA10D>91 D<EA0804EA1008EA2010A2EA4020A2EA80
+40A3EAB85CEAFC7EA2EA7C3EEA381C0F0E7A9F17>I<12FFA21203B3B3A512FFA2082D80
+A10D>I<120812101220A21240A21280A312B812FCA2127C1238060E7D9F0D>96
+D<EA1FE0EA3030EA7818131CEA300E1200A313FEEA078EEA1E0E1238127800F01310A313
+1E127838386720380F83C014147E9317>I<121C12FC121CAA137CEA1D87381E0180EB00
+C0001C13E01470A21478A6147014F014E0001E13C0381A018038198700EA107C15207E9F
+19>I<EA01FCEA0706EA1C0F123813060078C7FC127012F0A61270127800381380A2381C
+0100EA0706EA01F811147F9314>I<EB01C0130F1301AAEA01F1EA070DEA0C03EA180112
+381278127012F0A61270A21238EA1803120CEA070D3801F1F815207F9F19>I<EA03F0EA
+0E1C487E487EA21270EB038012F0A2B5FC00F0C7FCA31270A26C1380A2381C0100EA0706
+EA01F811147F9314>I<137CEA01C6EA030F1207EA0E061300A7EAFFF0EA0E00B2EA7FE0
+1020809F0E>I<14E03803E330EA0E3CEA1C1C38380E00EA780FA5EA380E6C5AEA1E38EA
+33E00020C7FCA21230A2EA3FFE381FFF8014C0383001E038600070481330A4006013606C
+13C0381C03803803FC00141F7F9417>I<121C12FC121CAA137C1386EA1D03001E1380A2
+121CAE38FF8FF014207E9F19>I<1238127CA31238C7FCA6121C12FC121CB1EAFF80091F
+7F9E0C>I<13E0EA01F0A3EA00E01300A61370EA07F012001370B3A31260EAF06013C0EA
+6180EA3F000C28829E0E>I<121C12FC121CAAEB1FE0EB0780EB060013045B5B5B136013
+E0EA1DF0EA1E70EA1C38133C131C7F130F7F148014C038FF9FF014207E9F18>I<121C12
+FC121CB3ABEAFF8009207F9F0C>I<391C3E03E039FCC30C30391D039038391E01E01CA2
+001C13C0AE3AFF8FF8FF8021147E9326>I<EA1C7CEAFC86EA1D03001E1380A2121CAE38
+FF8FF014147E9319>I<EA01F8EA070E381C0380383801C0A2387000E0A200F013F0A600
+7013E0A2383801C0A2381C038038070E00EA01F814147F9317>I<EA1C7CEAFD87381E01
+8014C0381C00E014F014701478A6147014F014E0381E01C0EB0380381D8700EA1C7C90C7
+FCA8B47E151D7E9319>I<3801F04038070CC0EA0E02EA1C03EA38011278127012F0A612
+7012781238EA1C03EA0C05EA0709EA01F1EA0001A8EB0FF8151D7F9318>I<EA1CF0EAFD
+18EA1E3CA21318EA1C00AEEAFFC00E147E9312>I<EA0FC8EA3038EA6018EAC008A3EAE0
+00127CEA3FE0EA1FF0EA07F8EA003CEA800E130612C0A21304EAE00CEAD818EA87E00F14
+7F9312>I<1202A31206A2120EA2123EEAFFF8EA0E00AB1304A5EA07081203EA01F00E1C
+7F9B12>I<381C0380EAFC1FEA1C03AE1307120CEA061B3803E3F014147E9319>I<38FF83
+F8383E00E0001C13C06C1380A338070100A21383EA0382A2EA01C4A213E4EA00E8A21370
+A3132015147F9318>I<39FF9FE1FC393C078070391C030060EC8020000E1440A214C0D8
+0704138014E0A239038861001471A23801D032143A143E3800E01CA2EB6018EB40081E14
+7F9321>I<38FF87F8381E03C0380E0180EB0300EA0702EA0384EA01C813D8EA00F01370
+137813F8139CEA010E1202EA060738040380000C13C0003C13E038FE07FC16147F9318>
+I<38FF83F8383E00E0001C13C06C1380A338070100A21383EA0382A2EA01C4A213E4EA00
+E8A21370A31320A25BA3EAF080A200F1C7FC1262123C151D7F9318>I<EA7FFFEA700E12
+60EA401C133813781370EA00E0120113C0EA038012071301120E121EEA1C03EA3802EA70
+06130EEAFFFE10147F9314>I E /Fs 14 122 df<DB1FFC14C00203B5EAC001021FECF0
+03027FECFC07903B01FFFC00FE0F010701C0EB1F9F4948C7EA07FFD93FF8804948140049
+48157F485B4A153F4890C9121F485A000F170F5B001F1707A2485A1803A2127FA24993C8
+FCA212FFAA041FB61280127FA27FDC0001EBC000123FA36C7EA26C7EA26C7E7E6C7F806C
+7F6D6C5CEB3FFCD90FFF5C6D01C0EB1FBF010101FCEBFF1F6D6CB5EAFE0F021FECF80302
+03ECE0009126001FFEC9FC413D7BBB4C>71 D<B612FEA426007FF0C9FCB3ADEF03C0A517
+071880A3170FA3171FA2173F177F17FF5E04071300163FB9FCA4323B7DBA3A>76
+D<B500F00207B512E0808080D8007F92390007E0006E6F5A81017B7F81137901787F6E7E
+6E7E81141F6E7E6E7F6E7F82806E7F6F7E6F7E826F7E816F13806F13C017E06F13F081EE
+7FF8EE3FFC17FEEE1FFF827013837013C318E37013F382EF7FFBEF3FFFA283838383A283
+83187F183FA201FC161FB500FC150F18071803A2433B7CBA4C>78
+D<B712F8EEFFC017F817FE3B007FF0001FFF040313C004007F717E717EA284171FA284A6
+60A2173F604D5A604C485A4C5BDC1FFEC8FC91B612F817C0A29139F0007FF0EE1FF8707E
+707E707E8482A284A584A5F101E0A27013F0A2F103C0EF7FF8B600F890393FFC07809438
+1FFE0F0507B51200050113FCCBEA1FF0433C7CBA48>82 D<B600F80107B512E0A426007F
+F0C83807E000725AB3B3A3013F4C5AA280011F4CC7FCA26D6C151E0107163E6E5D6D6C5D
+6D6D13019026007FE0EB0FE0DA3FFCEB7FC0020FB65A02034AC8FCDA007F13F003071380
+433C7DBA4A>85 D<EB3FFE48B512E0000714F8390FE007FC9038F001FE486C6C7E6F7E82
+153F6C48806C5A6C5AC8FCA491B5FC131F90387FF83F3803FF803807FC00EA0FF0485A12
+3F485AA2485AA4157F6C7E15DF3A3FE0039FF03B1FF80F0FFFE03807FFFE0001497E3900
+3FE0002B267DA52F>97 D<13FE12FFA412071203B04AB4FC021F13F0027F13FC9138FC03
+FE9039FFF000FF02C0EB3F8091C7EA1FC04915E0EE0FF017F8A2EE07FCA317FEA917FCA3
+160F17F817F0161F6D15E06EEB3FC06EEB7F80D9F9E0EBFF009039F0FC07FE91387FFFF8
+D9E01F13E09026C003FEC7FC2F3C7DBB36>I<EE3F80ED3FFFA4150181B0ECFF80010F13
+F0013F13FC9038FFC03F3901FE000F4848130348487F48487F121F485AA2127F5BA312FF
+A9127FA36C7EA2121F6C6C5B6C6C5B00035CD801FE011F13C02700FF807E13FE90387FFF
+F8010F13E0010113002F3C7DBB36>100 D<49B47E010F13F0017F13FC9038FF81FE3A03
+FE007F80D807F8133F4848EB1FC0ED0FE0485A003F15F01507485A16F8A212FFA290B6FC
+A301C0C8FCA4127FA36C7E1678121F7F000F15F06C6C13016C6CEB03E06C6CEB0FC03A00
+FFC07F8090393FFFFE00010F13F8010013C025267DA52C>I<EA01E0EA07F8487EA2487E
+A46C5AA26C5AEA01E0C8FCAB13FE127FA412071203B3AAB512F0A4143D7DBC1A>105
+D<13FE12FFA412071203B3B3AEB512F8A4153C7DBB1A>108 D<D801FCEBFF8000FF0103
+13F0020F7F91381E03FC91383801FE000701607F0003497E01FD15805C01FFC7FCA35BB3
+A4B5D8F83F13FEA42F267CA536>110 D<3901FC03F000FFEB0FFC4AB4FC91383C3F80EC
+707F00079038E0FFC000035BEBFD80A201FFEB7F809138003F00151E92C7FC5BB3A3B512
+FCA422267DA528>114 D<B500F0EBFFFCA4D803FEC7EA1F806D15006C151E806C5DA26E
+137C017F14786E13F8013F5CECF001011F5CECF803010F5CA2ECFC0701075CECFE0F0103
+91C7FC6E5A6D131E15BE6D13BC15FC6E5AA36E5AA26E5AA26E5AA26E5AA2140F92C8FC5C
+141E0008133E007F133C147C38FF807814F8EB81F0EB83E06C485A387C1F80D83FFFC9FC
+EA1FFCEA07F02E377EA533>121 D E end
+TeXDict begin
+
+1 0 bop 0 693 a Fs(GNU)33 b(Readline)h(Library)p 0 743
+1950 17 v 1011 791 a Fr(Edition)17 b(2.1,)c(for)i Fq(Readline)f
+(Library)g Fr(V)l(ersion)i(2.1.)1718 845 y(Marc)o(h)e(1996)0
+2467 y Fp(Brian)23 b(F)-6 b(o)n(x,)23 b(F)-6 b(ree)23
+b(Soft)n(w)n(are)f(F)-6 b(oundation)0 2534 y(Chet)22
+b(Ramey)-6 b(,)23 b(Case)e(W)-6 b(estern)23 b(Reserv)n(e)f(Univ)n
+(ersit)n(y)p 0 2570 1950 9 v eop
+2 1 bop 0 320 a Fr(This)15 b(do)q(cumen)o(t)f(describ)q(es)i(the)e(GNU)
+g(Readline)j(Library)l(,)d(a)g(utilit)o(y)h(whic)o(h)g(aids)g(in)g(the)
+f(consistency)h(of)f(user)0 382 y(in)o(terface)h(across)g(discrete)h
+(programs)e(that)g(need)j(to)d(pro)o(vide)i(a)f(command)g(line)i(in)o
+(terface.)0 519 y(Published)g(b)o(y)f(the)f(F)l(ree)g(Soft)o(w)o(are)f
+(F)l(oundation)0 582 y(675)g(Massac)o(h)o(usetts)g(Av)o(en)o(ue,)0
+644 y(Cam)o(bridge,)h(MA)g(02139)f(USA)0 781 y(P)o(ermission)f(is)g
+(gran)o(ted)f(to)f(mak)o(e)h(and)h(distribute)h(v)o(erbatim)e(copies)h
+(of)f(this)h(man)o(ual)g(pro)o(vided)g(the)f(cop)o(yrigh)o(t)0
+843 y(notice)k(and)f(this)h(p)q(ermission)h(notice)e(are)g(preserv)o
+(ed)h(on)f(all)h(copies.)0 980 y(P)o(ermission)f(is)f(gran)o(ted)f(to)h
+(cop)o(y)g(and)g(distribute)h(mo)q(di\014ed)h(v)o(ersions)e(of)f(this)i
+(man)o(ual)f(under)h(the)f(conditions)0 1043 y(for)e(v)o(erbatim)g(cop)
+o(ying,)h(pro)o(vided)h(that)d(the)i(en)o(tire)g(resulting)h(deriv)o
+(ed)f(w)o(ork)f(is)h(distributed)h(under)f(the)g(terms)0
+1105 y(of)i(a)g(p)q(ermission)h(notice)g(iden)o(tical)h(to)e(this)g
+(one.)0 1242 y(P)o(ermission)20 b(is)g(gran)o(ted)f(to)g(cop)o(y)h(and)
+f(distribute)i(translations)f(of)f(this)h(man)o(ual)f(in)o(to)h
+(another)f(language,)0 1304 y(under)c(the)f(ab)q(o)o(v)o(e)g
+(conditions)h(for)e(mo)q(di\014ed)j(v)o(ersions,)e(except)g(that)g
+(this)g(p)q(ermission)i(notice)e(ma)o(y)g(b)q(e)h(stated)0
+1366 y(in)h(a)f(translation)g(appro)o(v)o(ed)g(b)o(y)g(the)g(F)l
+(oundation.)0 2661 y(Cop)o(yrigh)o(t)226 2660 y(c)214
+2661 y Fo(\015)g Fr(1989,)f(1991)g(F)l(ree)h(Soft)o(w)o(are)f(F)l
+(oundation,)h(Inc.)p eop
+1 2 bop 0 -58 a Fr(Chapter)15 b(1:)k(Command)c(Line)i(Editing)1227
+b(1)0 183 y Fn(1)41 b(Command)16 b(Line)f(Editing)62
+408 y Fr(This)h(c)o(hapter)f(describ)q(es)i(the)e(basic)h(features)f
+(of)g(the)g Fm(GNU)g Fr(command)g(line)i(editing)f(in)o(terface.)0
+701 y Fp(1.1)33 b(In)n(tro)r(duction)17 b(to)e(Line)h(Editing)62
+845 y Fr(The)g(follo)o(wing)g(paragraphs)e(describ)q(e)j(the)e
+(notation)g(used)h(to)e(represen)o(t)i(k)o(eystrok)o(es.)62
+990 y(The)k(text)e Fq(C-K)h Fr(is)h(read)f(as)f(`Con)o(trol-K')h(and)g
+(describ)q(es)i(the)e(c)o(haracter)f(pro)q(duced)j(when)e(the)g
+Fq(K)g Fr(k)o(ey)g(is)0 1052 y(pressed)d(while)g(the)g(Con)o(trol)e(k)o
+(ey)h(is)h(depressed.)62 1197 y(The)h(text)f Fq(M-K)g
+Fr(is)i(read)e(as)g(`Meta-K')g(and)h(describ)q(es)h(the)f(c)o(haracter)
+f(pro)q(duced)h(when)h(the)e(meta)g(k)o(ey)h(\(if)0 1259
+y(y)o(ou)f(ha)o(v)o(e)f(one\))h(is)g(depressed,)h(and)f(the)g
+Fq(K)f Fr(k)o(ey)h(is)h(pressed.)22 b(If)16 b(y)o(ou)g(do)g(not)f(ha)o
+(v)o(e)g(a)h(meta)f(k)o(ey)l(,)h(the)g(iden)o(tical)0
+1321 y(k)o(eystrok)o(e)j(can)g(b)q(e)i(generated)e(b)o(y)h(t)o(yping)f
+Fq(ESC)h Fl(\014rst)p Fr(,)g(and)f(then)h(t)o(yping)g
+Fq(K)p Fr(.)33 b(Either)20 b(pro)q(cess)g(is)g(kno)o(wn)f(as)0
+1383 y Fl(metafying)g Fr(the)c Fq(K)g Fr(k)o(ey)l(.)62
+1528 y(The)h(text)e Fq(M-C-K)g Fr(is)i(read)f(as)f(`Meta-Con)o(trol-k')
+g(and)h(describ)q(es)h(the)g(c)o(haracter)e(pro)q(duced)i(b)o(y)f
+Fl(metafying)0 1590 y Fq(C-K)p Fr(.)62 1735 y(In)i(addition,)h(sev)o
+(eral)e(k)o(eys)g(ha)o(v)o(e)g(their)h(o)o(wn)f(names.)23
+b(Sp)q(eci\014cally)m(,)c Fq(DEL)p Fr(,)d Fq(ESC)p Fr(,)f
+Fq(LFD)p Fr(,)h Fq(SPC)p Fr(,)g Fq(RET)p Fr(,)g(and)g
+Fq(TAB)0 1797 y Fr(all)e(stand)f(for)f(themselv)o(es)i(when)f(seen)h
+(in)g(this)f(text,)g(or)g(in)g(an)g(init)i(\014le)f(\(see)f(Section)h
+(1.3)e([Readline)j(Init)f(File],)0 1859 y(page)h(5\).)0
+2152 y Fp(1.2)33 b(Readline)16 b(In)n(teraction)62 2296
+y Fr(Often)g(during)h(an)f(in)o(teractiv)o(e)g(session)h(y)o(ou)e(t)o
+(yp)q(e)h(in)h(a)f(long)g(line)h(of)f(text,)f(only)h(to)g(notice)g
+(that)f(the)h(\014rst)0 2359 y(w)o(ord)d(on)i(the)f(line)i(is)e(missp)q
+(elled.)23 b(The)14 b(Readline)i(library)f(giv)o(es)g(y)o(ou)e(a)h(set)
+g(of)g(commands)g(for)f(manipulating)0 2421 y(the)18
+b(text)g(as)g(y)o(ou)g(t)o(yp)q(e)g(it)h(in,)g(allo)o(wing)g(y)o(ou)f
+(to)g(just)g(\014x)g(y)o(our)g(t)o(yp)q(o,)g(and)h(not)f(forcing)g(y)o
+(ou)g(to)g(ret)o(yp)q(e)g(the)0 2483 y(ma)s(jorit)o(y)d(of)h(the)g
+(line.)25 b(Using)17 b(these)g(editing)h(commands,)e(y)o(ou)g(mo)o(v)o
+(e)f(the)i(cursor)f(to)g(the)g(place)h(that)f(needs)0
+2545 y(correction,)g(and)h(delete)g(or)f(insert)g(the)h(text)e(of)h
+(the)g(corrections.)23 b(Then,)17 b(when)g(y)o(ou)f(are)g(satis\014ed)g
+(with)h(the)0 2608 y(line,)h(y)o(ou)e(simply)i(press)f
+Fq(RETURN)p Fr(.)23 b(Y)l(ou)17 b(do)f(not)g(ha)o(v)o(e)g(to)g(b)q(e)i
+(at)e(the)g(end)h(of)f(the)h(line)h(to)e(press)h Fq(RETURN)p
+Fr(;)f(the)0 2670 y(en)o(tire)g(line)h(is)e(accepted)h(regardless)f(of)
+g(the)g(lo)q(cation)h(of)f(the)h(cursor)e(within)j(the)e(line.)p
+eop
+2 3 bop 0 -58 a Fr(2)1472 b(GNU)15 b(Readline)i(Library)0
+183 y Fk(1.2.1)30 b(Readline)15 b(Bare)g(Essen)n(tials)62
+320 y Fr(In)f(order)f(to)f(en)o(ter)h(c)o(haracters)g(in)o(to)g(the)g
+(line,)i(simply)f(t)o(yp)q(e)f(them.)19 b(The)14 b(t)o(yp)q(ed)f(c)o
+(haracter)f(app)q(ears)i(where)0 382 y(the)h(cursor)h(w)o(as,)e(and)h
+(then)h(the)g(cursor)f(mo)o(v)o(es)f(one)i(space)g(to)e(the)i(righ)o
+(t.)k(If)c(y)o(ou)f(mist)o(yp)q(e)h(a)f(c)o(haracter,)f(y)o(ou)0
+445 y(can)h(use)h(y)o(our)f(erase)g(c)o(haracter)f(to)h(bac)o(k)g(up)g
+(and)h(delete)g(the)f(mist)o(yp)q(ed)h(c)o(haracter.)62
+582 y(Sometimes)f(y)o(ou)e(ma)o(y)h(miss)g(t)o(yping)g(a)g(c)o
+(haracter)g(that)f(y)o(ou)h(w)o(an)o(ted)f(to)g(t)o(yp)q(e,)h(and)h
+(not)e(notice)i(y)o(our)f(error)0 644 y(un)o(til)k(y)o(ou)e(ha)o(v)o(e)
+g(t)o(yp)q(ed)h(sev)o(eral)g(other)f(c)o(haracters.)23
+b(In)18 b(that)d(case,)i(y)o(ou)f(can)h(t)o(yp)q(e)g
+Fq(C-B)f Fr(to)g(mo)o(v)o(e)g(the)g(cursor)0 706 y(to)f(the)h(left,)g
+(and)g(then)g(correct)f(y)o(our)h(mistak)o(e.)21 b(Afterw)o(ards,)14
+b(y)o(ou)i(can)g(mo)o(v)o(e)f(the)h(cursor)f(to)g(the)h(righ)o(t)g
+(with)0 769 y Fq(C-F)p Fr(.)62 906 y(When)i(y)o(ou)f(add)g(text)g(in)h
+(the)f(middle)i(of)e(a)g(line,)i(y)o(ou)e(will)i(notice)e(that)g(c)o
+(haracters)f(to)h(the)g(righ)o(t)g(of)g(the)0 968 y(cursor)h(are)h
+(`pushed)g(o)o(v)o(er')e(to)h(mak)o(e)g(ro)q(om)g(for)g(the)h(text)f
+(that)g(y)o(ou)g(ha)o(v)o(e)h(inserted.)31 b(Lik)o(ewise,)20
+b(when)f(y)o(ou)0 1030 y(delete)f(text)f(b)q(ehind)i(the)f(cursor,)f(c)
+o(haracters)f(to)h(the)g(righ)o(t)g(of)g(the)h(cursor)f(are)g(`pulled)i
+(bac)o(k')d(to)h(\014ll)i(in)f(the)0 1092 y(blank)g(space)f(created)g
+(b)o(y)g(the)h(remo)o(v)m(al)f(of)f(the)i(text.)25 b(A)17
+b(list)h(of)e(the)h(basic)h(bare)f(essen)o(tials)h(for)e(editing)j(the)
+0 1155 y(text)c(of)f(an)i(input)g(line)h(follo)o(ws.)0
+1303 y Fq(C-B)168 b Fr(Mo)o(v)o(e)14 b(bac)o(k)h(one)h(c)o(haracter.)0
+1390 y Fq(C-F)168 b Fr(Mo)o(v)o(e)14 b(forw)o(ard)g(one)h(c)o
+(haracter.)0 1476 y Fq(DEL)168 b Fr(Delete)16 b(the)f(c)o(haracter)g
+(to)f(the)h(left)h(of)f(the)g(cursor.)0 1562 y Fq(C-D)168
+b Fr(Delete)16 b(the)f(c)o(haracter)g(underneath)h(the)f(cursor.)0
+1648 y(Prin)o(ting)h(c)o(haracters)240 1710 y(Insert)f(the)h(c)o
+(haracter)e(in)o(to)h(the)h(line)h(at)d(the)h(cursor.)0
+1796 y Fq(C-_)168 b Fr(Undo)15 b(the)h(last)f(thing)h(that)e(y)o(ou)h
+(did.)21 b(Y)l(ou)15 b(can)h(undo)f(all)h(the)g(w)o(a)o(y)e(bac)o(k)h
+(to)f(an)i(empt)o(y)e(line.)0 2001 y Fk(1.2.2)30 b(Readline)15
+b(Mo)n(v)n(emen)n(t)h(Commands)62 2138 y Fr(The)c(ab)q(o)o(v)o(e)g
+(table)g(describ)q(es)i(the)e(most)f(basic)h(p)q(ossible)i(k)o(eystrok)
+o(es)d(that)g(y)o(ou)g(need)i(in)g(order)f(to)f(do)h(editing)0
+2201 y(of)g(the)h(input)h(line.)21 b(F)l(or)12 b(y)o(our)g(con)o(v)o
+(enience,)i(man)o(y)f(other)f(commands)h(ha)o(v)o(e)f(b)q(een)i(added)f
+(in)h(addition)g(to)e Fq(C-B)p Fr(,)0 2263 y Fq(C-F)p
+Fr(,)i Fq(C-D)p Fr(,)h(and)g Fq(DEL)p Fr(.)20 b(Here)15
+b(are)g(some)g(commands)g(for)f(mo)o(ving)h(more)g(rapidly)i(ab)q(out)e
+(the)g(line.)0 2412 y Fq(C-A)168 b Fr(Mo)o(v)o(e)14 b(to)h(the)g(start)
+f(of)h(the)g(line.)0 2498 y Fq(C-E)168 b Fr(Mo)o(v)o(e)14
+b(to)h(the)g(end)h(of)f(the)g(line.)0 2584 y Fq(M-F)168
+b Fr(Mo)o(v)o(e)14 b(forw)o(ard)g(a)h(w)o(ord.)0 2670
+y Fq(M-B)168 b Fr(Mo)o(v)o(e)14 b(bac)o(kw)o(ard)h(a)g(w)o(ord.)p
+eop
+3 4 bop 0 -58 a Fr(Chapter)15 b(1:)k(Command)c(Line)i(Editing)1227
+b(3)0 183 y Fq(C-L)168 b Fr(Clear)15 b(the)h(screen,)f(reprin)o(ting)h
+(the)f(curren)o(t)g(line)i(at)e(the)g(top.)62 350 y(Notice)22
+b(ho)o(w)e Fq(C-F)h Fr(mo)o(v)o(es)f(forw)o(ard)g(a)g(c)o(haracter,)i
+(while)g Fq(M-F)f Fr(mo)o(v)o(es)f(forw)o(ard)g(a)h(w)o(ord.)36
+b(It)21 b(is)h(a)f(lo)q(ose)0 412 y(con)o(v)o(en)o(tion)15
+b(that)g(con)o(trol)g(k)o(eystrok)o(es)f(op)q(erate)h(on)g(c)o
+(haracters)f(while)j(meta)e(k)o(eystrok)o(es)f(op)q(erate)h(on)g(w)o
+(ords.)0 696 y Fk(1.2.3)30 b(Readline)15 b(Killing)g(Commands)62
+841 y Fl(Killing)25 b Fr(text)18 b(means)g(to)f(delete)i(the)g(text)e
+(from)h(the)g(line,)i(but)e(to)g(sa)o(v)o(e)f(it)i(a)o(w)o(a)o(y)d(for)
+i(later)g(use,)h(usually)0 903 y(b)o(y)c Fl(y)o(anking)k
+Fr(\(re-inserting\))c(it)g(bac)o(k)g(in)o(to)g(the)g(line.)21
+b(If)16 b(the)f(description)h(for)e(a)h(command)f(sa)o(ys)h(that)f(it)h
+(`kills')0 966 y(text,)f(then)i(y)o(ou)f(can)g(b)q(e)h(sure)f(that)g(y)
+o(ou)g(can)g(get)g(the)g(text)g(bac)o(k)g(in)h(a)f(di\013eren)o(t)g
+(\(or)f(the)i(same\))e(place)i(later.)62 1111 y(When)g(y)o(ou)f(use)g
+(a)g(kill)i(command,)e(the)h(text)e(is)i(sa)o(v)o(ed)f(in)h(a)f
+Fl(kill-ring)p Fr(.)22 b(An)o(y)16 b(n)o(um)o(b)q(er)f(of)g(consecutiv)
+o(e)h(kills)0 1173 y(sa)o(v)o(e)g(all)i(of)e(the)h(killed)i(text)d
+(together,)g(so)g(that)g(when)h(y)o(ou)f(y)o(ank)h(it)g(bac)o(k,)f(y)o
+(ou)h(get)f(it)h(all.)25 b(The)17 b(kill)h(ring)f(is)0
+1236 y(not)e(line)i(sp)q(eci\014c;)g(the)f(text)f(that)g(y)o(ou)g
+(killed)j(on)d(a)h(previously)g(t)o(yp)q(ed)g(line)h(is)f(a)o(v)m
+(ailable)i(to)d(b)q(e)h(y)o(ank)o(ed)f(bac)o(k)0 1298
+y(later,)g(when)h(y)o(ou)e(are)h(t)o(yping)h(another)e(line.)62
+1443 y(Here)i(is)f(the)h(list)g(of)e(commands)h(for)g(killing)j(text.)0
+1610 y Fq(C-K)168 b Fr(Kill)17 b(the)f(text)e(from)h(the)g(curren)o(t)g
+(cursor)g(p)q(osition)h(to)f(the)g(end)h(of)f(the)g(line.)0
+1714 y Fq(M-D)168 b Fr(Kill)17 b(from)d(the)h(cursor)g(to)f(the)h(end)g
+(of)g(the)g(curren)o(t)f(w)o(ord,)g(or)g(if)i(b)q(et)o(w)o(een)f(w)o
+(ords,)f(to)g(the)h(end)g(of)240 1776 y(the)g(next)h(w)o(ord.)0
+1880 y Fq(M-DEL)120 b Fr(Kill)16 b(from)d(the)i(cursor)e(the)h(start)f
+(of)h(the)g(previous)h(w)o(ord,)e(or)g(if)i(b)q(et)o(w)o(een)f(w)o
+(ords,)f(to)h(the)g(start)e(of)240 1942 y(the)j(previous)h(w)o(ord.)0
+2046 y Fq(C-W)168 b Fr(Kill)18 b(from)e(the)g(cursor)g(to)f(the)h
+(previous)h(whitespace.)24 b(This)17 b(is)f(di\013eren)o(t)h(than)f
+Fq(M-DEL)f Fr(b)q(ecause)240 2109 y(the)g(w)o(ord)g(b)q(oundaries)h
+(di\013er.)62 2275 y(And,)e(here)g(is)h(ho)o(w)e(to)g
+Fl(y)o(ank)j Fr(the)e(text)f(bac)o(k)g(in)o(to)h(the)f(line.)22
+b(Y)l(anking)14 b(means)g(to)f(cop)o(y)g(the)h(most-recen)o(tly-)0
+2337 y(killed)j(text)e(from)g(the)g(kill)i(bu\013er.)0
+2504 y Fq(C-Y)168 b Fr(Y)l(ank)15 b(the)h(most)e(recen)o(tly)i(killed)h
+(text)e(bac)o(k)g(in)o(to)g(the)h(bu\013er)f(at)f(the)i(cursor.)0
+2608 y Fq(M-Y)168 b Fr(Rotate)13 b(the)h(kill-ring,)i(and)e(y)o(ank)g
+(the)g(new)g(top.)19 b(Y)l(ou)14 b(can)g(only)g(do)g(this)g(if)g(the)g
+(prior)g(command)240 2670 y(is)i Fq(C-Y)e Fr(or)h Fq(M-Y)p
+Fr(.)p eop
+4 5 bop 0 -58 a Fr(4)1472 b(GNU)15 b(Readline)i(Library)0
+183 y Fk(1.2.4)30 b(Readline)15 b(Argumen)n(ts)62 345
+y Fr(Y)l(ou)k(can)g(pass)f(n)o(umeric)i(argumen)o(ts)d(to)h(Readline)j
+(commands.)30 b(Sometimes)19 b(the)f(argumen)o(t)g(acts)g(as)g(a)0
+407 y(rep)q(eat)f(coun)o(t,)f(other)g(times)g(it)h(is)g(the)g
+Fl(sign)f Fr(of)g(the)h(argumen)o(t)f(that)f(is)i(signi\014can)o(t.)25
+b(If)16 b(y)o(ou)h(pass)f(a)g(negativ)o(e)0 470 y(argumen)o(t)g(to)g(a)
+h(command)g(whic)o(h)h(normally)f(acts)g(in)h(a)e(forw)o(ard)g
+(direction,)i(that)f(command)f(will)j(act)d(in)i(a)0
+532 y(bac)o(kw)o(ard)13 b(direction.)20 b(F)l(or)13 b(example,)i(to)d
+(kill)k(text)d(bac)o(k)g(to)g(the)h(start)e(of)h(the)h(line,)h(y)o(ou)e
+(migh)o(t)g(t)o(yp)q(e)h Fq(M--)h(C-k)o Fr(.)62 694 y(The)k(general)g
+(w)o(a)o(y)f(to)g(pass)g(n)o(umeric)i(argumen)o(ts)e(to)g(a)g(command)h
+(is)g(to)f(t)o(yp)q(e)g(meta)g(digits)i(b)q(efore)f(the)0
+756 y(command.)36 b(If)21 b(the)g(\014rst)f(`digit')h(y)o(ou)g(t)o(yp)q
+(e)f(is)i(a)e(min)o(us)h(sign)g(\()p Fq(-)p Fr(\),)g(then)g(the)g(sign)
+g(of)g(the)f(argumen)o(t)g(will)0 818 y(b)q(e)i(negativ)o(e.)40
+b(Once)22 b(y)o(ou)f(ha)o(v)o(e)h(t)o(yp)q(ed)g(one)f(meta)g(digit)i
+(to)e(get)g(the)h(argumen)o(t)f(started,)h(y)o(ou)f(can)h(t)o(yp)q(e)0
+881 y(the)c(remainder)h(of)f(the)g(digits,)h(and)f(then)h(the)f
+(command.)29 b(F)l(or)17 b(example,)i(to)f(giv)o(e)g(the)g
+Fq(C-D)g Fr(command)g(an)0 943 y(argumen)o(t)c(of)h(10,)f(y)o(ou)h
+(could)h(t)o(yp)q(e)g(`)p Fq(M-1)e(0)h(C-d)p Fr('.)0
+1375 y Fk(1.2.5)30 b(Searc)n(hing)15 b(for)g(Commands)h(in)f(the)g
+(History)62 1537 y Fr(Readline)j(pro)o(vides)d(commands)g(for)g(searc)o
+(hing)h(through)e(the)i(command)f(history)g(for)g(lines)h(con)o
+(taining)g(a)0 1599 y(sp)q(eci\014ed)h(string.)j(There)c(are)f(t)o(w)o
+(o)e(searc)o(h)i(mo)q(des:)20 b Fl(incremen)o(tal)f Fr(and)c
+Fl(non-incremen)o(tal)p Fr(.)62 1761 y(Incremen)o(tal)i(searc)o(hes)e
+(b)q(egin)i(b)q(efore)f(the)g(user)f(has)h(\014nished)h(t)o(yping)f
+(the)g(searc)o(h)f(string.)21 b(As)15 b(eac)o(h)h(c)o(har-)0
+1823 y(acter)f(of)h(the)g(searc)o(h)f(string)h(is)g(t)o(yp)q(ed,)g
+(readline)h(displa)o(ys)g(the)f(next)g(en)o(try)f(from)g(the)h(history)
+g(matc)o(hing)g(the)0 1885 y(string)g(t)o(yp)q(ed)g(so)f(far.)20
+b(An)c(incremen)o(tal)h(searc)o(h)e(requires)i(only)f(as)f(man)o(y)g(c)
+o(haracters)g(as)h(needed)h(to)e(\014nd)h(the)0 1948
+y(desired)g(history)f(en)o(try)l(.)20 b(The)15 b(Escap)q(e)h(c)o
+(haracter)e(is)h(used)h(to)e(terminate)h(an)g(incremen)o(tal)h(searc)o
+(h.)k(Con)o(trol-J)0 2010 y(will)c(also)f(terminate)g(the)g(searc)o(h.)
+k(Con)o(trol-G)14 b(will)j(ab)q(ort)d(an)h(incremen)o(tal)g(searc)o(h)g
+(and)g(restore)f(the)h(original)0 2072 y(line.)30 b(When)18
+b(the)h(searc)o(h)e(is)i(terminated,)g(the)f(history)g(en)o(try)f(con)o
+(taining)i(the)f(searc)o(h)g(string)g(b)q(ecomes)h(the)0
+2134 y(curren)o(t)g(line.)35 b(T)l(o)20 b(\014nd)g(other)f(matc)o(hing)
+h(en)o(tries)g(in)g(the)g(history)g(list,)h(t)o(yp)q(e)e(Con)o(trol-S)h
+(or)f(Con)o(trol-R)g(as)0 2197 y(appropriate.)k(This)17
+b(will)h(searc)o(h)e(bac)o(kw)o(ard)g(or)f(forw)o(ard)g(in)j(the)e
+(history)g(for)g(the)g(next)h(en)o(try)f(matc)o(hing)g(the)0
+2259 y(searc)o(h)c(string)h(t)o(yp)q(ed)f(so)g(far.)19
+b(An)o(y)12 b(other)g(k)o(ey)g(sequence)i(b)q(ound)f(to)f(a)g(readline)
+i(command)e(will)i(terminate)f(the)0 2321 y(searc)o(h)j(and)h(execute)g
+(that)f(command.)24 b(F)l(or)16 b(instance,)h(a)g Fq(newline)e
+Fr(will)j(terminate)f(the)g(searc)o(h)f(and)h(accept)0
+2384 y(the)e(line,)i(thereb)o(y)e(executing)h(the)g(command)f(from)f
+(the)h(history)h(list.)62 2545 y(Non-incremen)o(tal)k(searc)o(hes)f
+(read)f(the)h(en)o(tire)g(searc)o(h)g(string)f(b)q(efore)h(starting)f
+(to)g(searc)o(h)h(for)f(matc)o(hing)0 2608 y(history)g(lines.)29
+b(The)18 b(searc)o(h)g(string)g(ma)o(y)f(b)q(e)h(t)o(yp)q(ed)g(b)o(y)g
+(the)g(user)g(or)f(part)g(of)h(the)g(con)o(ten)o(ts)f(of)g(the)h
+(curren)o(t)0 2670 y(line.)p eop
+5 6 bop 0 -58 a Fr(Chapter)15 b(1:)k(Command)c(Line)i(Editing)1227
+b(5)0 183 y Fp(1.3)33 b(Readline)16 b(Init)g(File)62
+324 y Fr(Although)h(the)f(Readline)j(library)e(comes)f(with)g(a)g(set)g
+(of)g Fq(emacs)p Fr(-lik)o(e)h(k)o(eybindings)h(installed)g(b)o(y)e
+(default,)0 387 y(it)e(is)g(p)q(ossible)i(that)d(y)o(ou)g(w)o(ould)h
+(lik)o(e)h(to)e(use)h(a)f(di\013eren)o(t)h(set)g(of)f(k)o(eybindings.)
+21 b(Y)l(ou)14 b(can)g(customize)g(programs)0 449 y(that)j(use)h
+(Readline)i(b)o(y)e(putting)h(commands)e(in)i(an)f Fl(inputrc)j
+Fr(\014le)e(in)g(y)o(our)e(home)h(directory)l(.)28 b(The)19
+b(name)e(of)0 511 y(this)e(\014le)h(is)g(tak)o(en)e(from)h(the)g(v)m
+(alue)h(of)e(the)h(en)o(vironmen)o(t)h(v)m(ariable)g
+Fq(INPUTRC)p Fr(.)j(If)c(that)f(v)m(ariable)j(is)e(unset,)g(the)0
+573 y(default)h(is)f(`)p Fq(~/.inputrc)p Fr('.)62 714
+y(When)k(a)g(program)e(whic)o(h)j(uses)f(the)g(Readline)i(library)e
+(starts)f(up,)h(the)g(init)h(\014le)g(is)f(read,)g(and)g(the)g(k)o(ey)0
+777 y(bindings)e(are)e(set.)62 918 y(In)j(addition,)h(the)f
+Fq(C-x)c(C-r)k Fr(command)f(re-reads)g(this)h(init)h(\014le,)g(th)o(us)
+e(incorp)q(orating)h(an)o(y)f(c)o(hanges)h(that)0 980
+y(y)o(ou)d(migh)o(t)g(ha)o(v)o(e)g(made)g(to)f(it.)0
+1224 y Fk(1.3.1)30 b(Readline)15 b(Init)g(File)g(Syn)n(tax)62
+1365 y Fr(There)h(are)f(only)h(a)f(few)g(basic)h(constructs)f(allo)o(w)
+o(ed)h(in)g(the)g(Readline)i(init)e(\014le.)22 b(Blank)16
+b(lines)h(are)e(ignored.)0 1427 y(Lines)f(b)q(eginning)h(with)e(a)f(`)p
+Fq(#)p Fr(')g(are)g(commen)o(ts.)19 b(Lines)14 b(b)q(eginning)h(with)e
+(a)f(`)p Fq($)p Fr(')g(indicate)i(conditional)g(constructs)0
+1490 y(\(see)i(Section)h(1.3.2)e([Conditional)i(Init)g(Constructs],)e
+(page)i(8\).)22 b(Other)16 b(lines)i(denote)f(v)m(ariable)h(settings)e
+(and)0 1552 y(k)o(ey)f(bindings.)0 1710 y(V)l(ariable)h(Settings)240
+1772 y(Y)l(ou)j(can)g(c)o(hange)g(the)g(state)f(of)g(a)g(few)h(v)m
+(ariables)h(in)g(Readline)h(b)o(y)d(using)i(the)f Fq(set)f
+Fr(command)240 1834 y(within)e(the)f(init)h(\014le.)k(Here)15
+b(is)g(ho)o(w)g(y)o(ou)f(w)o(ould)h(sp)q(ecify)h(that)e(y)o(ou)g(wish)i
+(to)e(use)h Fq(vi)f Fr(line)j(editing)240 1896 y(commands:)360
+1965 y Fq(set)23 b(editing-mode)g(vi)240 2044 y Fr(Righ)o(t)14
+b(no)o(w,)f(there)h(are)f(only)h(a)f(few)h(v)m(ariables)g(whic)o(h)h
+(can)f(b)q(e)g(set;)f(so)g(few,)h(in)g(fact,)f(that)g(w)o(e)g(just)240
+2106 y(list)j(them)f(here:)240 2201 y Fq(bell-style)480
+2263 y Fr(Con)o(trols)h(what)f(happ)q(ens)j(when)f(Readline)h(w)o(an)o
+(ts)e(to)f(ring)i(the)f(terminal)h(b)q(ell.)26 b(If)480
+2326 y(set)17 b(to)f(`)p Fq(none)p Fr(',)g(Readline)j(nev)o(er)f(rings)
+f(the)g(b)q(ell.)28 b(If)17 b(set)g(to)f(`)p Fq(visible)p
+Fr(',)g(Readline)480 2388 y(uses)21 b(a)g(visible)j(b)q(ell)f(if)e(one)
+h(is)f(a)o(v)m(ailable.)40 b(If)21 b(set)g(to)g(`)p Fq(audible)p
+Fr(')e(\(the)i(default\),)480 2450 y(Readline)d(attempts)c(to)g(ring)i
+(the)f(terminal's)h(b)q(ell.)240 2545 y Fq(comment-begin)480
+2608 y Fr(The)d(string)h(to)e(insert)i(at)e(the)i(b)q(eginning)h(of)e
+(the)g(line)i(when)f(the)f Fq(insert-comment)480 2670
+y Fr(command)i(is)h(executed.)21 b(The)15 b(default)h(v)m(alue)g(is)g
+Fq("#")p Fr(.)p eop
+6 7 bop 0 -58 a Fr(6)1472 b(GNU)15 b(Readline)i(Library)240
+183 y Fq(completion-query-items)480 246 y Fr(The)12 b(n)o(um)o(b)q(er)g
+(of)f(p)q(ossible)j(completions)e(that)f(determines)i(when)f(the)g
+(user)g(is)g(ask)o(ed)480 308 y(whether)k(he)h(w)o(an)o(ts)d(to)i(see)g
+(the)g(list)h(of)e(p)q(ossibiliti)q(es.)25 b(If)16 b(the)g(n)o(um)o(b)q
+(er)h(of)e(p)q(ossible)480 370 y(completions)i(is)f(greater)f(than)h
+(this)h(v)m(alue,)f(Readline)j(will)e(ask)f(the)g(user)g(whether)480
+432 y(or)k(not)h(he)h(wishes)f(to)g(view)g(them;)j(otherwise,)e(they)f
+(are)g(simply)h(listed.)39 b(The)480 495 y(default)16
+b(limit)g(is)g Fq(100)p Fr(.)240 592 y Fq(convert-meta)480
+654 y Fr(If)21 b(set)f(to)g(`)p Fq(on)p Fr(',)g(Readline)j(will)f(con)o
+(v)o(ert)e(c)o(haracters)f(with)i(the)g(eigth)f(bit)h(set)g(to)480
+716 y(an)c(ASCI)q(I)g(k)o(ey)g(sequence)h(b)o(y)e(stripping)i(the)f
+(eigth)g(bit)g(and)g(prep)q(ending)i(an)d Fq(ESC)480
+779 y Fr(c)o(haracter,)h(con)o(v)o(erting)g(them)g(to)f(a)h
+(meta-pre\014xed)h(k)o(ey)f(sequence.)27 b(The)17 b(default)480
+841 y(v)m(alue)f(is)g(`)p Fq(on)p Fr('.)240 938 y Fq
+(disable-completion)480 1000 y Fr(If)e(set)f(to)g(`)p
+Fq(On)p Fr(',)f(readline)j(will)h(inhibit)f(w)o(ord)e(completion.)20
+b(Completion)15 b(c)o(haracters)480 1063 y(will)h(b)q(e)g(inserted)g
+(in)o(to)e(the)h(line)i(as)d(if)h(they)g(had)g(b)q(een)h(mapp)q(ed)g
+(to)e Fq(self-insert)p Fr(.)480 1125 y(The)h(default)h(is)g(`)p
+Fq(off)p Fr('.)240 1222 y Fq(editing-mode)480 1285 y
+Fr(The)d Fq(editing-mode)e Fr(v)m(ariable)j(con)o(trols)e(whic)o(h)h
+(editing)h(mo)q(de)f(y)o(ou)f(are)g(using.)20 b(By)480
+1347 y(default,)f(Readline)h(starts)c(up)i(in)h(Emacs)e(editing)i(mo)q
+(de,)f(where)g(the)g(k)o(eystrok)o(es)480 1409 y(are)g(most)f(similar)i
+(to)e(Emacs.)27 b(This)19 b(v)m(ariable)g(can)f(b)q(e)h(set)e(to)g
+(either)i(`)p Fq(emacs)p Fr(')d(or)480 1471 y(`)p Fq(vi)p
+Fr('.)240 1569 y Fq(enable-keypad)480 1631 y Fr(When)g(set)g(to)f(`)p
+Fq(on)p Fr(',)g(readline)j(will)f(try)e(to)h(enable)h(the)f
+(application)h(k)o(eypad)f(when)480 1693 y(it)f(is)g(called.)22
+b(Some)15 b(systems)f(need)i(this)f(to)f(enable)i(the)f(arro)o(w)f(k)o
+(eys.)19 b(The)c(default)480 1755 y(is)h(`)p Fq(off)p
+Fr('.)240 1853 y Fq(expand-tilde)480 1915 y Fr(If)i(set)f(to)f(`)p
+Fq(on)p Fr(',)h(tilde)h(expansion)h(is)e(p)q(erformed)h(when)g
+(Readline)h(attempts)e(w)o(ord)480 1977 y(completion.)k(The)15
+b(default)h(is)g(`)p Fq(off)p Fr('.)240 2075 y Fq
+(horizontal-scroll-mode)480 2137 y Fr(This)j(v)m(ariable)h(can)e(b)q(e)
+i(set)e(to)g(either)h(`)p Fq(on)p Fr(')e(or)h(`)p Fq(off)p
+Fr('.)28 b(Setting)19 b(it)g(to)f(`)p Fq(on)p Fr(')f(means)480
+2199 y(that)f(the)h(text)f(of)h(the)f(lines)j(that)d(y)o(ou)g(edit)i
+(will)g(scroll)g(horizon)o(tally)f(on)g(a)g(single)480
+2261 y(screen)h(line)h(when)f(they)f(are)g(longer)h(than)f(the)g(width)
+h(of)f(the)g(screen,)h(instead)g(of)480 2324 y(wrapping)e(on)o(to)e(a)h
+(new)g(screen)h(line.)21 b(By)16 b(default,)f(this)h(v)m(ariable)g(is)g
+(set)f(to)g(`)p Fq(off)p Fr('.)240 2421 y Fq(keymap)96
+b Fr(Sets)13 b(Readline's)i(idea)e(of)g(the)g(curren)o(t)f(k)o(eymap)h
+(for)f(k)o(ey)h(binding)i(commands.)k(Ac-)480 2483 y(ceptable)d
+Fq(keymap)e Fr(names)h(are)g Fq(emacs)p Fr(,)f Fq(emacs-standard)p
+Fr(,)f Fq(emacs-meta)p Fr(,)g Fq(emacs-)480 2545 y(ctlx)p
+Fr(,)18 b Fq(vi)p Fr(,)h Fq(vi-command)p Fr(,)e(and)i
+Fq(vi-insert)p Fr(.)28 b Fq(vi)18 b Fr(is)h(equiv)m(alen)o(t)h(to)e
+Fq(vi-command)p Fr(;)480 2608 y Fq(emacs)d Fr(is)i(equiv)m(alen)o(t)h
+(to)d Fq(emacs-standard)p Fr(.)20 b(The)d(default)f(v)m(alue)i(is)e
+Fq(emacs)p Fr(.)22 b(The)480 2670 y(v)m(alue)16 b(of)f(the)g
+Fq(editing-mode)f Fr(v)m(ariable)j(also)e(a\013ects)f(the)h(default)h
+(k)o(eymap.)p eop
+7 8 bop 0 -58 a Fr(Chapter)15 b(1:)k(Command)c(Line)i(Editing)1227
+b(7)240 183 y Fq(mark-directories)480 246 y Fr(If)22
+b(set)g(to)g(`)p Fq(on)p Fr(',)g(completed)h(directory)f(names)h(ha)o
+(v)o(e)e(a)h(slash)h(app)q(ended.)42 b(The)480 308 y(default)16
+b(is)f(`)p Fq(on)p Fr('.)240 388 y Fq(mark-modified-lines)480
+450 y Fr(This)f(v)m(ariable,)h(when)e(set)g(to)g(`)p
+Fq(on)p Fr(',)f(sa)o(ys)h(to)g(displa)o(y)h(an)f(asterisk)g(\(`)p
+Fq(*)p Fr('\))f(at)h(the)g(start)480 512 y(of)f(history)h(lines)h(whic)
+o(h)f(ha)o(v)o(e)f(b)q(een)i(mo)q(di\014ed.)21 b(This)13
+b(v)m(ariable)h(is)f(`)p Fq(off)p Fr(')e(b)o(y)i(default.)240
+593 y Fq(input-meta)480 655 y Fr(If)21 b(set)g(to)g(`)p
+Fq(on)p Fr(',)g(Readline)i(will)g(enable)g(eigh)o(t-bit)f(input)g(\(it)
+f(will)i(not)d(strip)i(the)480 717 y(eigh)o(th)e(bit)f(from)f(the)i(c)o
+(haracters)e(it)h(reads\),)h(regardless)f(of)f(what)h(the)g(terminal)
+480 779 y(claims)d(it)g(can)f(supp)q(ort.)21 b(The)15
+b(default)h(v)m(alue)h(is)e(`)p Fq(off)p Fr('.)20 b(The)15
+b(name)g Fq(meta-flag)f Fr(is)480 842 y(a)h(synon)o(ym)g(for)f(this)i
+(v)m(ariable.)240 922 y Fq(output-meta)480 984 y Fr(If)11
+b(set)f(to)g(`)p Fq(on)p Fr(',)g(Readline)j(will)g(displa)o(y)e(c)o
+(haracters)f(with)h(the)g(eigh)o(th)g(bit)g(set)g(directly)480
+1046 y(rather)k(than)g(as)f(a)h(meta-pre\014xed)h(escap)q(e)g
+(sequence.)21 b(The)16 b(default)f(is)h(`)p Fq(off)p
+Fr('.)240 1126 y Fq(show-all-if-ambiguous)480 1189 y
+Fr(This)f(alters)f(the)h(default)g(b)q(eha)o(vior)g(of)f(the)h
+(completion)g(functions.)21 b(If)14 b(set)h(to)e(`)p
+Fq(on)p Fr(',)480 1251 y(w)o(ords)18 b(whic)o(h)i(ha)o(v)o(e)f(more)f
+(than)h(one)g(p)q(ossible)i(completion)f(cause)f(the)g(matc)o(hes)480
+1313 y(to)e(b)q(e)h(listed)h(immediately)g(instead)f(of)f(ringing)i
+(the)e(b)q(ell.)29 b(The)18 b(default)g(v)m(alue)g(is)480
+1375 y(`)p Fq(off)p Fr('.)240 1456 y Fq(visible-stats)480
+1518 y Fr(If)c(set)g(to)f(`)p Fq(on)p Fr(',)f(a)i(c)o(haracter)f
+(denoting)h(a)g(\014le's)g(t)o(yp)q(e)g(is)g(app)q(ended)i(to)d(the)h
+(\014lename)480 1580 y(when)i(listing)g(p)q(ossible)h(completions.)k
+(The)16 b(default)f(is)h(`)p Fq(off)p Fr('.)0 1660 y(Key)g(Bindings)240
+1722 y(The)k(syn)o(tax)f(for)g(con)o(trolling)i(k)o(ey)e(bindings)j(in)
+e(the)g(init)h(\014le)g(is)f(simple.)35 b(First)19 b(y)o(ou)g(ha)o(v)o
+(e)h(to)240 1785 y(kno)o(w)13 b(the)h(name)g(of)f(the)h(command)g(that)
+f(y)o(ou)g(w)o(an)o(t)g(to)g(c)o(hange.)20 b(The)14 b(follo)o(wing)g
+(pages)g(con)o(tain)240 1847 y(tables)i(of)f(the)h(command)g(name,)f
+(the)h(default)g(k)o(eybinding,)i(and)e(a)f(short)g(description)i(of)f
+(what)240 1909 y(the)f(command)g(do)q(es.)240 1980 y(Once)h(y)o(ou)e
+(kno)o(w)g(the)h(name)g(of)f(the)h(command,)f(simply)i(place)g(the)f
+(name)f(of)h(the)f(k)o(ey)h(y)o(ou)f(wish)240 2043 y(to)g(bind)j(the)e
+(command)g(to,)f(a)g(colon,)i(and)f(then)g(the)g(name)g(of)g(the)g
+(command)g(on)g(a)f(line)j(in)f(the)240 2105 y(init)h(\014le.)22
+b(The)16 b(name)g(of)f(the)h(k)o(ey)f(can)h(b)q(e)g(expressed)h(in)f
+(di\013eren)o(t)g(w)o(a)o(ys,)f(dep)q(ending)i(on)f(whic)o(h)240
+2167 y(is)g(most)e(comfortable)h(for)g(y)o(ou.)240 2247
+y Fl(k)o(eyname)s Fr(:)k Fl(function-name)g Fr(or)c Fl(macro)480
+2310 y(k)o(eyname)j Fr(is)d(the)h(name)f(of)g(a)g(k)o(ey)g(sp)q(elled)i
+(out)e(in)h(English.)21 b(F)l(or)15 b(example:)600 2370
+y Fq(Control-u:)22 b(universal-argument)600 2422 y(Meta-Rubout:)g
+(backward-kill-word)600 2474 y(Control-o:)g(">)i(output")480
+2545 y Fr(In)12 b(the)g(ab)q(o)o(v)o(e)f(example,)h(`)p
+Fq(C-u)p Fr(')f(is)h(b)q(ound)g(to)f(the)h(function)g
+Fq(universal-argument)p Fr(,)480 2608 y(and)h(`)p Fq(C-o)p
+Fr(')f(is)h(b)q(ound)h(to)f(run)g(the)g(macro)f(expressed)i(on)f(the)g
+(righ)o(t)g(hand)g(side)h(\(that)480 2670 y(is,)h(to)g(insert)h(the)f
+(text)g(`)p Fq(>)f(output)p Fr(')g(in)o(to)h(the)h(line\).)p
+eop
+8 9 bop 0 -58 a Fr(8)1472 b(GNU)15 b(Readline)i(Library)240
+183 y Fq(")p Fl(k)o(eyseq)q Fq(")p Fr(:)j Fl(function-name)e
+Fr(or)d Fl(macro)480 246 y(k)o(eyseq)j Fr(di\013ers)f(from)f
+Fl(k)o(eyname)k Fr(ab)q(o)o(v)o(e)c(in)i(that)e(strings)h(denoting)h
+(an)f(en)o(tire)g(k)o(ey)480 308 y(sequence)i(can)f(b)q(e)h(sp)q
+(eci\014ed,)i(b)o(y)d(placing)h(the)f(k)o(ey)g(sequence)h(in)g(double)h
+(quotes.)480 370 y(Some)e(GNU)g(Emacs)f(st)o(yle)h(k)o(ey)g(escap)q(es)
+g(can)g(b)q(e)h(used,)g(as)e(in)i(the)f(follo)o(wing)h(ex-)480
+432 y(ample,)c(but)h(the)f(sp)q(ecial)i(c)o(haracter)e(names)g(are)g
+(not)f(recognized.)600 499 y Fq("\\C-u":)23 b(universal-argument)600
+551 y("\\C-x\\C-r":)f(re-read-init-file)600 603 y("\\e[11~":)h
+("Function)f(Key)i(1")480 681 y Fr(In)13 b(the)g(ab)q(o)o(v)o(e)g
+(example,)g(`)p Fq(C-u)p Fr(')f(is)h(b)q(ound)h(to)e(the)h(function)g
+Fq(universal-argument)480 743 y Fr(\(just)g(as)f(it)i(w)o(as)e(in)i
+(the)f(\014rst)g(example\),)h(`)p Fq(C-x)g(C-r)p Fr(')f(is)g(b)q(ound)i
+(to)d(the)h(function)h Fq(re-)480 805 y(read-init-file)p
+Fr(,)g(and)i(`)p Fq(ESC)e([)h(1)g(1)g(~)p Fr(')h(is)g(b)q(ound)h(to)f
+(insert)g(the)g(text)f(`)p Fq(Function)480 867 y(Key)g(1)p
+Fr('.)24 b(The)18 b(follo)o(wing)f(escap)q(e)h(sequences)g(are)f(a)o(v)
+m(ailable)i(when)e(sp)q(ecifying)i(k)o(ey)480 930 y(sequences:)480
+1022 y Fq(\\C-)168 b Fr(con)o(trol)15 b(pre\014x)480
+1115 y Fq(\\M-)168 b Fr(meta)15 b(pre\014x)480 1208 y
+Fq(\\e)192 b Fr(an)15 b(escap)q(e)h(c)o(haracter)480
+1300 y Fq(\\\\)192 b Fr(bac)o(kslash)480 1393 y Fq(\\")g(")480
+1485 y(\\')g(')480 1578 y Fr(When)14 b(en)o(tering)h(the)f(text)f(of)h
+(a)f(macro,)g(single)j(or)d(double)i(quotes)f(should)h(b)q(e)f(used)480
+1640 y(to)g(indicate)j(a)e(macro)f(de\014nition.)22 b(Unquoted)15
+b(text)g(is)g(assumed)g(to)g(b)q(e)g(a)g(function)480
+1703 y(name.)21 b(Bac)o(kslash)16 b(will)h(quote)f(an)o(y)f(c)o
+(haracter)g(in)h(the)g(macro)f(text,)g(including)j(`)p
+Fq(")p Fr(')480 1765 y(and)12 b(`)p Fq(')p Fr('.)18 b(F)l(or)11
+b(example,)i(the)f(follo)o(wing)g(binding)i(will)f(mak)o(e)e(`)p
+Fq(C-x)k(\\)p Fr(')c(insert)h(a)g(single)480 1827 y(`)p
+Fq(\\)p Fr(')i(in)o(to)h(the)h(line:)600 1894 y Fq("\\C-x\\\\":)23
+b("\\\\")0 2126 y Fk(1.3.2)30 b(Conditional)15 b(Init)g(Constructs)62
+2266 y Fr(Readline)j(implemen)o(ts)e(a)f(facilit)o(y)h(similar)g(in)g
+(spirit)g(to)f(the)g(conditional)i(compilation)f(features)f(of)g(the)g
+(C)0 2328 y(prepro)q(cessor)f(whic)o(h)h(allo)o(ws)f(k)o(ey)g(bindings)
+h(and)f(v)m(ariable)i(settings)e(to)f(b)q(e)h(p)q(erformed)h(as)e(the)h
+(result)g(of)g(tests.)0 2391 y(There)h(are)g(three)h(parser)e(directiv)
+o(es)j(used.)0 2545 y Fq($if)168 b Fr(The)14 b Fq($if)e
+Fr(construct)h(allo)o(ws)h(bindings)h(to)e(b)q(e)h(made)f(based)h(on)f
+(the)h(editing)g(mo)q(de,)g(the)f(terminal)240 2608 y(b)q(eing)k(used,)
+e(or)g(the)g(application)i(using)f(Readline.)22 b(The)16
+b(text)f(of)g(the)g(test)g(extends)g(to)g(the)g(end)240
+2670 y(of)g(the)g(line;)i(no)e(c)o(haracters)f(are)h(required)h(to)f
+(isolate)g(it.)p eop
+9 10 bop 0 -58 a Fr(Chapter)15 b(1:)k(Command)c(Line)i(Editing)1227
+b(9)240 183 y Fq(mode)144 b Fr(The)19 b Fq(mode=)f Fr(form)g(of)h(the)g
+Fq($if)f Fr(directiv)o(e)i(is)f(used)h(to)e(test)g(whether)h(Readline)i
+(is)480 246 y(in)h Fq(emacs)f Fr(or)f Fq(vi)h Fr(mo)q(de.)38
+b(This)22 b(ma)o(y)f(b)q(e)h(used)g(in)g(conjunction)g(with)f(the)h(`)p
+Fq(set)480 308 y(keymap)p Fr(')d(command,)i(for)e(instance,)j(to)d(set)
+h(bindings)i(in)f(the)f Fq(emacs-standard)480 370 y Fr(and)15
+b Fq(emacs-ctlx)f Fr(k)o(eymaps)h(only)h(if)f(Readline)j(is)e(starting)
+e(out)h(in)h Fq(emacs)f Fr(mo)q(de.)240 457 y Fq(term)144
+b Fr(The)21 b Fq(term=)f Fr(form)g(ma)o(y)h(b)q(e)g(used)h(to)e
+(include)j(terminal-sp)q(eci\014c)h(k)o(ey)c(bindings,)480
+519 y(p)q(erhaps)15 b(to)f(bind)j(the)d(k)o(ey)h(sequences)h(output)e
+(b)o(y)h(the)g(terminal's)g(function)h(k)o(eys.)480 582
+y(The)f(w)o(ord)g(on)f(the)i(righ)o(t)e(side)i(of)f(the)g(`)p
+Fq(=)p Fr(')f(is)h(tested)g(against)g(the)g(full)h(name)f(of)g(the)480
+644 y(terminal)k(and)g(the)g(p)q(ortion)g(of)f(the)h(terminal)g(name)g
+(b)q(efore)g(the)g(\014rst)f(`)p Fq(-)p Fr('.)29 b(This)480
+706 y(allo)o(ws)15 b Fq(sun)g Fr(to)g(matc)o(h)f(b)q(oth)i
+Fq(sun)e Fr(and)i Fq(sun-cmd)p Fr(,)e(for)g(instance.)240
+793 y Fq(application)480 856 y Fr(The)k Fl(application)i
+Fr(construct)e(is)g(used)h(to)e(include)k(application-sp)q(eci\014c)g
+(settings.)480 918 y(Eac)o(h)d(program)g(using)h(the)f(Readline)j
+(library)e(sets)f(the)h Fl(application)h(name)p Fr(,)f(and)480
+980 y(y)o(ou)c(can)h(test)f(for)g(it.)21 b(This)16 b(could)g(b)q(e)h
+(used)f(to)e(bind)j(k)o(ey)f(sequences)g(to)f(functions)480
+1043 y(useful)h(for)e(a)h(sp)q(eci\014c)i(program.)h(F)l(or)d
+(instance,)g(the)g(follo)o(wing)h(command)e(adds)h(a)480
+1105 y(k)o(ey)g(sequence)h(that)f(quotes)g(the)g(curren)o(t)g(or)g
+(previous)h(w)o(ord)e(in)i(Bash:)600 1169 y Fq($if)23
+b(Bash)600 1221 y(#)h(Quote)f(the)g(current)g(or)h(previous)f(word)600
+1273 y("\\C-xq":)g("\\eb\\"\\ef\\"")600 1325 y($endif)0
+1412 y($endif)96 b Fr(This)16 b(command,)e(as)h(y)o(ou)g(sa)o(w)g(in)h
+(the)f(previous)h(example,)f(terminates)h(an)f Fq($if)f
+Fr(command.)0 1499 y Fq($else)120 b Fr(Commands)15 b(in)h(this)f(branc)
+o(h)h(of)e(the)i Fq($if)e Fr(directiv)o(e)j(are)e(executed)h(if)g(the)f
+(test)g(fails.)0 1707 y Fk(1.3.3)30 b(Sample)15 b(Init)g(File)62
+1844 y Fr(Here)20 b(is)f(an)g(example)h(of)f(an)g(inputrc)h(\014le.)33
+b(This)20 b(illustrates)g(k)o(ey)f(binding,)j(v)m(ariable)e(assignmen)o
+(t,)g(and)0 1906 y(conditional)d(syn)o(tax.)p eop
+10 11 bop 0 -58 a Fr(10)1449 b(GNU)15 b(Readline)i(Library)120
+235 y Fq(#)24 b(This)f(file)g(controls)g(the)h(behaviour)e(of)i(line)f
+(input)g(editing)g(for)120 287 y(#)h(programs)e(that)i(use)f(the)h(Gnu)
+f(Readline)g(library.)47 b(Existing)22 b(programs)120
+339 y(#)i(include)f(FTP,)g(Bash,)g(and)h(Gdb.)120 391
+y(#)120 443 y(#)g(You)f(can)h(re-read)f(the)g(inputrc)g(file)g(with)h
+(C-x)f(C-r.)120 495 y(#)h(Lines)f(beginning)g(with)g('#')g(are)h
+(comments.)120 546 y(#)120 598 y(#)g(Set)f(various)g(bindings)g(for)g
+(emacs)g(mode.)120 702 y(set)g(editing-mode)g(emacs)120
+806 y($if)g(mode=emacs)120 910 y(Meta-Control-h:)46 b
+(backward-kill-word)21 b(Text)i(after)h(the)f(function)g(name)g(is)h
+(ignored)120 1013 y(#)120 1065 y(#)g(Arrow)f(keys)g(in)h(keypad)f(mode)
+120 1117 y(#)120 1169 y(#"\\M-OD":)190 b(backward-char)120
+1221 y(#"\\M-OC":)g(forward-char)120 1273 y(#"\\M-OA":)g
+(previous-history)120 1325 y(#"\\M-OB":)g(next-history)120
+1377 y(#)120 1429 y(#)24 b(Arrow)f(keys)g(in)h(ANSI)f(mode)120
+1480 y(#)120 1532 y("\\M-[D":)190 b(backward-char)120
+1584 y("\\M-[C":)g(forward-char)120 1636 y("\\M-[A":)g
+(previous-history)120 1688 y("\\M-[B":)g(next-history)120
+1740 y(#)120 1792 y(#)24 b(Arrow)f(keys)g(in)h(8)g(bit)f(keypad)g(mode)
+120 1844 y(#)120 1896 y(#"\\M-\\C-OD":)165 b(backward-char)120
+1947 y(#"\\M-\\C-OC":)g(forward-char)120 1999 y(#"\\M-\\C-OA":)g
+(previous-history)120 2051 y(#"\\M-\\C-OB":)g(next-history)120
+2103 y(#)120 2155 y(#)24 b(Arrow)f(keys)g(in)h(8)g(bit)f(ANSI)g(mode)
+120 2207 y(#)120 2259 y(#"\\M-\\C-[D":)165 b(backward-char)120
+2311 y(#"\\M-\\C-[C":)g(forward-char)120 2363 y(#"\\M-\\C-[A":)g
+(previous-history)120 2414 y(#"\\M-\\C-[B":)g(next-history)120
+2518 y(C-q:)23 b(quoted-insert)120 2622 y($endif)p eop
+11 12 bop 0 -58 a Fr(Chapter)15 b(1:)k(Command)c(Line)i(Editing)1205
+b(11)120 235 y Fq(#)24 b(An)f(old-style)g(binding.)47
+b(This)23 b(happens)g(to)g(be)h(the)f(default.)120 287
+y(TAB:)g(complete)120 391 y(#)h(Macros)f(that)g(are)h(convenient)e(for)
+h(shell)h(interaction)120 443 y($if)f(Bash)120 495 y(#)h(edit)f(the)g
+(path)120 546 y("\\C-xp":)g("PATH=${PATH}\\e\\C-e\\C-a\\)o(ef\\C-f")120
+598 y(#)h(prepare)f(to)g(type)h(a)f(quoted)g(word)h(--)f(insert)g(open)
+h(and)f(close)g(double)g(quotes)120 650 y(#)h(and)f(move)g(to)h(just)f
+(after)h(the)f(open)g(quote)120 702 y("\\C-x\\"":)g("\\"\\"\\C-b")120
+754 y(#)h(insert)f(a)g(backslash)g(\(testing)g(backslash)g(escapes)f
+(in)i(sequences)f(and)g(macros\))120 806 y("\\C-x\\\\":)g("\\\\")120
+858 y(#)h(Quote)f(the)g(current)g(or)h(previous)f(word)120
+910 y("\\C-xq":)g("\\eb\\"\\ef\\"")120 962 y(#)h(Add)f(a)h(binding)f
+(to)g(refresh)g(the)h(line,)f(which)g(is)h(unbound)120
+1013 y("\\C-xr":)f(redraw-current-line)120 1065 y(#)h(Edit)f(variable)g
+(on)g(current)g(line.)120 1117 y("\\M-\\C-v":)f
+("\\C-a\\C-k$\\C-y\\M-\\C-e\\C-a\\C-y=)o(")120 1169 y($endif)120
+1273 y(#)i(use)f(a)h(visible)f(bell)g(if)h(one)f(is)h(available)120
+1325 y(set)f(bell-style)g(visible)120 1429 y(#)h(don't)f(strip)g
+(characters)g(to)g(7)h(bits)f(when)h(reading)120 1480
+y(set)f(input-meta)g(on)120 1584 y(#)h(allow)f(iso-latin1)f(characters)
+h(to)g(be)h(inserted)f(rather)g(than)g(converted)g(to)120
+1636 y(#)h(prefix-meta)e(sequences)120 1688 y(set)h(convert-meta)g(off)
+120 1792 y(#)h(display)f(characters)f(with)h(the)h(eighth)f(bit)g(set)h
+(directly)f(rather)g(than)120 1844 y(#)h(as)f(meta-prefixed)f
+(characters)120 1896 y(set)h(output-meta)g(on)120 1999
+y(#)h(if)f(there)g(are)h(more)f(than)h(150)f(possible)g(completions)f
+(for)i(a)f(word,)h(ask)f(the)120 2051 y(#)h(user)f(if)h(he)f(wants)g
+(to)h(see)f(all)h(of)f(them)120 2103 y(set)g(completion-query-items)e
+(150)120 2207 y(#)j(For)f(FTP)120 2259 y($if)g(Ftp)120
+2311 y("\\C-xg":)g("get)g(\\M-?")120 2363 y("\\C-xt":)g("put)g(\\M-?")
+120 2414 y("\\M-.":)g(yank-last-arg)120 2466 y($endif)p
+eop
+12 13 bop 0 -58 a Fr(12)1449 b(GNU)15 b(Readline)i(Library)0
+183 y Fp(1.4)33 b(Bindable)16 b(Readline)h(Commands)62
+322 y Fr(This)f(section)g(describ)q(es)h(Readline)g(commands)e(that)g
+(ma)o(y)f(b)q(e)i(b)q(ound)g(to)f(k)o(ey)g(sequences.)0
+545 y Fk(1.4.1)30 b(Commands)15 b(F)-5 b(or)15 b(Mo)n(ving)0
+698 y Fq(beginning-of-line)e(\(C-a\))240 760 y Fr(Mo)o(v)o(e)h(to)h
+(the)g(start)f(of)h(the)g(curren)o(t)g(line.)0 851 y
+Fq(end-of-line)f(\(C-e\))240 913 y Fr(Mo)o(v)o(e)g(to)h(the)g(end)h(of)
+f(the)g(line.)0 1003 y Fq(forward-char)f(\(C-f\))240
+1066 y Fr(Mo)o(v)o(e)g(forw)o(ard)g(a)h(c)o(haracter.)0
+1156 y Fq(backward-char)e(\(C-b\))240 1219 y Fr(Mo)o(v)o(e)h(bac)o(k)h
+(a)g(c)o(haracter.)0 1309 y Fq(forward-word)f(\(M-f\))240
+1371 y Fr(Mo)o(v)o(e)g(forw)o(ard)g(to)h(the)g(end)h(of)f(the)g(next)g
+(w)o(ord.)k(W)l(ords)c(are)g(comp)q(osed)h(of)e(letters)i(and)f
+(digits.)0 1462 y Fq(backward-word)e(\(M-b\))240 1524
+y Fr(Mo)o(v)o(e)j(bac)o(k)g(to)g(the)h(start)f(of)g(this,)h(or)g(the)f
+(previous,)i(w)o(ord.)24 b(W)l(ords)16 b(are)g(comp)q(osed)i(of)e
+(letters)240 1587 y(and)f(digits.)0 1677 y Fq(clear-screen)f(\(C-l\))
+240 1739 y Fr(Clear)h(the)g(screen)g(and)g(redra)o(w)f(the)h(curren)o
+(t)g(line,)h(lea)o(ving)g(the)f(curren)o(t)f(line)j(at)d(the)h(top)f
+(of)h(the)240 1802 y(screen.)0 1892 y Fq(redraw-current-line)e(\(\))240
+1955 y Fr(Refresh)j(the)f(curren)o(t)g(line.)22 b(By)15
+b(default,)h(this)f(is)h(un)o(b)q(ound.)0 2177 y Fk(1.4.2)30
+b(Commands)15 b(F)-5 b(or)15 b(Manipulating)g(The)g(History)0
+2330 y Fq(accept-line)f(\(Newline,)g(Return\))240 2393
+y Fr(Accept)g(the)f(line)i(regardless)e(of)g(where)g(the)g(cursor)g
+(is.)20 b(If)13 b(this)h(line)h(is)e(non-empt)o(y)l(,)h(add)f(it)g(to)g
+(the)240 2455 y(history)k(list.)25 b(If)17 b(this)g(line)i(w)o(as)c(a)i
+(history)g(line,)h(then)f(restore)f(the)h(history)f(line)j(to)d(its)h
+(original)240 2517 y(state.)0 2608 y Fq(previous-history)c(\(C-p\))240
+2670 y Fr(Mo)o(v)o(e)h(`up')h(through)g(the)g(history)g(list.)p
+eop
+13 14 bop 0 -58 a Fr(Chapter)15 b(1:)k(Command)c(Line)i(Editing)1205
+b(13)0 183 y Fq(next-history)14 b(\(C-n\))240 246 y Fr(Mo)o(v)o(e)g
+(`do)o(wn')g(through)h(the)h(history)f(list.)0 331 y
+Fq(beginning-of-history)d(\(M-<\))240 393 y Fr(Mo)o(v)o(e)i(to)h(the)g
+(\014rst)g(line)i(in)f(the)f(history)l(.)0 478 y Fq(end-of-history)e
+(\(M->\))240 540 y Fr(Mo)o(v)o(e)h(to)h(the)g(end)h(of)f(the)g(input)h
+(history)l(,)f(i.e.,)g(the)g(line)i(y)o(ou)e(are)g(en)o(tering.)0
+625 y Fq(reverse-search-history)d(\(C-r\))240 688 y Fr(Searc)o(h)18
+b(bac)o(kw)o(ard)f(starting)g(at)g(the)g(curren)o(t)h(line)h(and)f(mo)o
+(ving)f(`up')h(through)f(the)h(history)f(as)240 750 y(necessary)l(.)j
+(This)c(is)g(an)f(incremen)o(tal)h(searc)o(h.)0 835 y
+Fq(forward-search-history)c(\(C-s\))240 897 y Fr(Searc)o(h)j(forw)o
+(ard)e(starting)h(at)g(the)g(curren)o(t)h(line)h(and)f(mo)o(ving)f(`do)
+o(wn')g(through)g(the)g(the)h(history)240 960 y(as)g(necessary)l(.)20
+b(This)c(is)g(an)f(incremen)o(tal)h(searc)o(h.)0 1045
+y Fq(non-incremental-reverse-se)o(arch-hi)o(story)c(\(M-p\))240
+1107 y Fr(Searc)o(h)18 b(bac)o(kw)o(ard)f(starting)g(at)g(the)g(curren)
+o(t)h(line)h(and)f(mo)o(ving)f(`up')h(through)f(the)h(history)f(as)240
+1169 y(necessary)e(using)h(a)f(non-incremen)o(tal)i(searc)o(h)e(for)g
+(a)f(string)i(supplied)h(b)o(y)e(the)h(user.)0 1254 y
+Fq(non-incremental-forward-se)o(arch-hi)o(story)c(\(M-n\))240
+1317 y Fr(Searc)o(h)j(forw)o(ard)e(starting)h(at)g(the)g(curren)o(t)h
+(line)h(and)f(mo)o(ving)f(`do)o(wn')g(through)g(the)g(the)h(history)240
+1379 y(as)g(necessary)g(using)h(a)f(non-incremen)o(tal)i(searc)o(h)e
+(for)f(a)h(string)g(supplied)j(b)o(y)d(the)g(user.)0
+1464 y Fq(history-search-forward)d(\(\))240 1526 y Fr(Searc)o(h)h(forw)
+o(ard)f(through)h(the)g(history)g(for)g(the)g(string)g(of)g(c)o
+(haracters)f(b)q(et)o(w)o(een)i(the)f(start)f(of)h(the)240
+1589 y(curren)o(t)19 b(line)h(and)f(the)g(curren)o(t)f(cursor)h(p)q
+(osition)g(\(the)g(`p)q(oin)o(t'\).)30 b(This)19 b(is)g(a)f
+(non-incremen)o(tal)240 1651 y(searc)o(h.)i(By)15 b(default,)g(this)h
+(command)f(is)h(un)o(b)q(ound.)0 1736 y Fq(history-search-backward)c
+(\(\))240 1798 y Fr(Searc)o(h)21 b(bac)o(kw)o(ard)f(through)g(the)h
+(history)f(for)g(the)h(string)f(of)h(c)o(haracters)f(b)q(et)o(w)o(een)g
+(the)h(start)240 1860 y(of)c(the)h(curren)o(t)g(line)h(and)f(the)f(p)q
+(oin)o(t.)28 b(This)18 b(is)h(a)e(non-incremen)o(tal)i(searc)o(h.)27
+b(By)18 b(default,)h(this)240 1923 y(command)c(is)h(un)o(b)q(ound.)0
+2008 y Fq(yank-nth-arg)e(\(M-C-y\))240 2070 y Fr(Insert)19
+b(the)g(\014rst)f(argumen)o(t)g(to)g(the)h(previous)g(command)g
+(\(usually)g(the)g(second)g(w)o(ord)f(on)h(the)240 2132
+y(previous)e(line\).)23 b(With)16 b(an)g(argumen)o(t)f
+Fl(n)p Fr(,)h(insert)h(the)f Fl(n)p Fr(th)g(w)o(ord)f(from)g(the)h
+(previous)h(command)240 2195 y(\(the)d(w)o(ords)g(in)h(the)g(previous)g
+(command)f(b)q(egin)i(with)f(w)o(ord)f(0\).)19 b(A)14
+b(negativ)o(e)h(argumen)o(t)f(inserts)240 2257 y(the)h
+Fl(n)p Fr(th)h(w)o(ord)e(from)h(the)g(end)h(of)e(the)i(previous)g
+(command.)0 2342 y Fq(yank-last-arg)d(\(M-.,)i(M-_\))240
+2404 y Fr(Insert)i(last)g(argumen)o(t)g(to)f(the)h(previous)h(command)f
+(\(the)g(last)g(w)o(ord)f(of)h(the)g(previous)h(history)240
+2467 y(en)o(try\).)h(With)d(an)f(argumen)o(t,)f(b)q(eha)o(v)o(e)h
+(exactly)h(lik)o(e)g Fq(yank-nth-arg)p Fr(.)0 2670 y
+Fk(1.4.3)30 b(Commands)15 b(F)-5 b(or)15 b(Changing)g(T)-5
+b(ext)p eop
+14 15 bop 0 -58 a Fr(14)1449 b(GNU)15 b(Readline)i(Library)0
+183 y Fq(delete-char)d(\(C-d\))240 246 y Fr(Delete)f(the)f(c)o
+(haracter)f(under)i(the)f(cursor.)19 b(If)12 b(the)g(cursor)g(is)g(at)g
+(the)g(b)q(eginning)i(of)e(the)g(line,)i(there)240 308
+y(are)k(no)h(c)o(haracters)e(in)j(the)e(line,)j(and)d(the)h(last)f(c)o
+(haracter)g(t)o(yp)q(ed)h(w)o(as)f(not)g Fq(C-d)p Fr(,)g(then)h(return)
+240 370 y Fq(EOF)p Fr(.)0 460 y Fq(backward-delete-char)12
+b(\(Rubout\))240 522 y Fr(Delete)g(the)f(c)o(haracter)f(b)q(ehind)j
+(the)e(cursor.)18 b(A)11 b(n)o(umeric)h(arg)e(sa)o(ys)g(to)g(kill)j
+(the)e(c)o(haracters)f(instead)240 584 y(of)15 b(deleting)h(them.)0
+674 y Fq(quoted-insert)d(\(C-q,)i(C-v\))240 736 y Fr(Add)i(the)f(next)h
+(c)o(haracter)f(that)f(y)o(ou)h(t)o(yp)q(e)h(to)f(the)g(line)i(v)o
+(erbatim.)24 b(This)17 b(is)g(ho)o(w)e(to)h(insert)h(k)o(ey)240
+799 y(sequences)f(lik)o(e)h Fq(C-Q)p Fr(,)d(for)h(example.)0
+888 y Fq(tab-insert)f(\(M-TAB\))240 951 y Fr(Insert)h(a)g(tab)g(c)o
+(haracter.)0 1040 y Fq(self-insert)f(\(a,)g(b,)h(A,)g(1,)g(!,)g(...\))
+240 1103 y Fr(Insert)g(y)o(ourself.)0 1192 y Fq(transpose-chars)e
+(\(C-t\))240 1255 y Fr(Drag)h(the)h(c)o(haracter)g(b)q(efore)g(the)h
+(cursor)f(forw)o(ard)f(o)o(v)o(er)g(the)h(c)o(haracter)g(at)f(the)i
+(cursor,)e(mo)o(ving)240 1317 y(the)k(cursor)h(forw)o(ard)e(as)h(w)o
+(ell.)30 b(If)19 b(the)f(insertion)i(p)q(oin)o(t)f(is)g(at)e(the)i(end)
+g(of)f(the)g(line,)j(then)e(this)240 1379 y(transp)q(oses)c(the)g(last)
+g(t)o(w)o(o)f(c)o(haracters)h(of)f(the)i(line.)21 b(Negativ)o(e)15
+b(argumen)o(tss)f(don't)h(w)o(ork.)0 1469 y Fq(transpose-words)e
+(\(M-t\))240 1531 y Fr(Drag)f(the)h(w)o(ord)f(b)q(ehind)i(the)f(cursor)
+g(past)f(the)h(w)o(ord)f(in)h(fron)o(t)f(of)h(the)f(cursor)h(mo)o(ving)
+f(the)h(cursor)240 1594 y(o)o(v)o(er)h(that)h(w)o(ord)f(as)h(w)o(ell.)0
+1683 y Fq(upcase-word)f(\(M-u\))240 1746 y Fr(Upp)q(ercase)h(the)e
+(curren)o(t)h(\(or)f(follo)o(wing\))h(w)o(ord.)k(With)c(a)f(negativ)o
+(e)h(argumen)o(t,)f(do)g(the)h(previous)240 1808 y(w)o(ord,)g(but)h(do)
+h(not)e(mo)o(v)o(e)h(the)g(cursor.)0 1898 y Fq(downcase-word)e(\(M-l\))
+240 1960 y Fr(Lo)o(w)o(ercase)g(the)i(curren)o(t)f(\(or)f(follo)o
+(wing\))h(w)o(ord.)19 b(With)14 b(a)g(negativ)o(e)g(argumen)o(t,)f(do)h
+(the)g(previous)240 2022 y(w)o(ord,)g(but)h(do)h(not)e(mo)o(v)o(e)h
+(the)g(cursor.)0 2112 y Fq(capitalize-word)e(\(M-c\))240
+2174 y Fr(Capitalize)j(the)e(curren)o(t)g(\(or)f(follo)o(wing\))i(w)o
+(ord.)j(With)d(a)f(negativ)o(e)g(argumen)o(t,)f(do)h(the)g(previous)240
+2236 y(w)o(ord,)g(but)h(do)h(not)e(mo)o(v)o(e)h(the)g(cursor.)0
+2456 y Fk(1.4.4)30 b(Killing)15 b(And)h(Y)-5 b(anking)0
+2608 y Fq(kill-line)14 b(\(C-k\))240 2670 y Fr(Kill)j(the)f(text)e
+(from)h(the)g(curren)o(t)g(cursor)g(p)q(osition)h(to)f(the)g(end)h(of)f
+(the)g(line.)p eop
+15 16 bop 0 -58 a Fr(Chapter)15 b(1:)k(Command)c(Line)i(Editing)1205
+b(15)0 183 y Fq(backward-kill-line)13 b(\(C-x)h(Rubout\))240
+246 y Fr(Kill)j(bac)o(kw)o(ard)e(to)f(the)i(b)q(eginning)h(of)e(the)g
+(line.)0 332 y Fq(unix-line-discard)e(\(C-u\))240 394
+y Fr(Kill)j(bac)o(kw)o(ard)d(from)f(the)i(cursor)f(to)g(the)h(b)q
+(eginning)i(of)d(the)g(curren)o(t)h(line.)21 b(Sa)o(v)o(e)13
+b(the)h(killed)h(text)240 456 y(on)g(the)g(kill-ring.)0
+543 y Fq(kill-whole-line)e(\(\))240 605 y Fr(Kill)18
+b(all)f(c)o(haracters)e(on)h(the)g(curren)o(t)f(line,)j(no)e(matter)e
+(where)i(the)g(cursor)g(is.)22 b(By)16 b(default,)h(this)240
+667 y(is)f(un)o(b)q(ound.)0 753 y Fq(kill-word)e(\(M-d\))240
+816 y Fr(Kill)j(from)d(the)h(cursor)g(to)f(the)h(end)g(of)g(the)g
+(curren)o(t)f(w)o(ord,)g(or)g(if)i(b)q(et)o(w)o(een)f(w)o(ords,)f(to)g
+(the)h(end)g(of)240 878 y(the)g(next)h(w)o(ord.)j(W)l(ord)c(b)q
+(oundaries)h(are)f(the)g(same)g(as)g Fq(forward-word)p
+Fr(.)0 964 y Fq(backward-kill-word)e(\(M-DEL\))240 1027
+y Fr(Kill)k(the)f(w)o(ord)e(b)q(ehind)j(the)f(cursor.)j(W)l(ord)c(b)q
+(oundaries)i(are)d(the)i(same)f(as)f Fq(backward-word)p
+Fr(.)0 1113 y Fq(unix-word-rubout)f(\(C-w\))240 1175
+y Fr(Kill)i(the)e(w)o(ord)f(b)q(ehind)j(the)f(cursor,)e(using)i(white)f
+(space)h(as)e(a)h(w)o(ord)f(b)q(oundary)l(.)20 b(The)13
+b(killed)i(text)240 1237 y(is)h(sa)o(v)o(ed)e(on)i(the)f(kill-ring.)0
+1324 y Fq(delete-horizontal-space)d(\(\))240 1386 y Fr(Delete)k(all)g
+(spaces)f(and)h(tabs)e(around)i(p)q(oin)o(t.)k(By)15
+b(default,)h(this)f(is)h(un)o(b)q(ound.)0 1472 y Fq(kill-region)e(\(\))
+240 1535 y Fr(Kill)23 b(the)e(text)g(b)q(et)o(w)o(een)g(the)g(p)q(oin)o
+(t)g(and)g(the)g Fl(mark)j Fr(\(sa)o(v)o(ed)c(cursor)g(p)q(osition.)38
+b(This)22 b(text)e(is)240 1597 y(referred)15 b(to)g(as)g(the)g
+Fl(region)p Fr(.)20 b(By)15 b(default,)h(this)g(command)f(is)g(un)o(b)q
+(ound.)0 1683 y Fq(copy-region-as-kill)e(\(\))240 1745
+y Fr(Cop)o(y)f(the)h(text)f(in)i(the)f(region)g(to)f(the)g(kill)j
+(bu\013er,)e(so)f(y)o(ou)h(can)f(y)o(ank)h(it)g(righ)o(t)f(a)o(w)o(a)o
+(y)l(.)18 b(By)13 b(default,)240 1808 y(this)j(command)f(is)g(un)o(b)q
+(ound.)0 1894 y Fq(copy-backward-word)e(\(\))240 1956
+y Fr(Cop)o(y)i(the)g(w)o(ord)f(b)q(efore)i(p)q(oin)o(t)g(to)e(the)h
+(kill)j(bu\013er.)h(By)d(default,)f(this)h(command)f(is)h(un)o(b)q
+(ound.)0 2043 y Fq(copy-forward-word)d(\(\))240 2105
+y Fr(Cop)o(y)f(the)h(w)o(ord)f(follo)o(wing)h(p)q(oin)o(t)g(to)f(the)h
+(kill)h(bu\013er.)19 b(By)13 b(default,)g(this)h(command)e(is)h(un)o(b)
+q(ound.)0 2191 y Fq(yank)i(\(C-y\))240 2253 y Fr(Y)l(ank)g(the)h(top)f
+(of)f(the)i(kill)h(ring)e(in)o(to)g(the)h(bu\013er)f(at)f(the)i(curren)
+o(t)f(cursor)g(p)q(osition.)0 2340 y Fq(yank-pop)f(\(M-y\))240
+2402 y Fr(Rotate)f(the)h(kill-ring,)i(and)e(y)o(ank)g(the)g(new)g(top.)
+19 b(Y)l(ou)14 b(can)g(only)g(do)g(this)g(if)g(the)g(prior)g(command)
+240 2464 y(is)i(y)o(ank)f(or)f(y)o(ank-p)q(op.)0 2670
+y Fk(1.4.5)30 b(Sp)r(ecifying)15 b(Numeric)h(Argumen)n(ts)p
+eop
+16 17 bop 0 -58 a Fr(16)1449 b(GNU)15 b(Readline)i(Library)0
+183 y Fq(digit-argument)c(\(M-0,)i(M-1,)f(...)h(M--\))240
+246 y Fr(Add)j(this)g(digit)h(to)e(the)h(argumen)o(t)e(already)i(accum)
+o(ulating,)h(or)e(start)g(a)g(new)h(argumen)o(t.)26 b
+Fq(M--)240 308 y Fr(starts)14 b(a)h(negativ)o(e)g(argumen)o(t.)0
+403 y Fq(universal-argument)e(\(\))240 465 y Fr(This)f(is)h(another)e
+(w)o(a)o(y)g(to)g(sp)q(ecify)i(an)f(argumen)o(t.)18 b(If)12
+b(this)g(command)g(is)g(follo)o(w)o(ed)g(b)o(y)g(one)g(or)f(more)240
+527 y(digits,)19 b(optionally)g(with)f(a)g(leading)h(min)o(us)f(sign,)h
+(those)e(digits)i(de\014ne)g(the)f(argumen)o(t.)27 b(If)18
+b(the)240 590 y(command)12 b(is)h(follo)o(w)o(ed)g(b)o(y)f(digits,)i
+(executing)f Fq(universal-argument)d Fr(again)j(ends)g(the)f(n)o
+(umeric)240 652 y(argumen)o(t,)i(but)h(is)g(otherwise)g(ignored.)20
+b(As)15 b(a)f(sp)q(ecial)j(case,)d(if)h(this)g(command)g(is)g
+(immediately)240 714 y(follo)o(w)o(ed)e(b)o(y)f(a)h(c)o(haracter)e
+(that)h(is)h(neither)h(a)e(digit)i(or)e(min)o(us)h(sign,)g(the)g
+(argumen)o(t)f(coun)o(t)g(for)g(the)240 776 y(next)i(command)g(is)h(m)o
+(ultiplied)i(b)o(y)d(four.)19 b(The)c(argumen)o(t)e(coun)o(t)h(is)h
+(initially)i(one,)d(so)g(executing)240 839 y(this)k(function)g(the)f
+(\014rst)g(time)g(mak)o(es)g(the)g(argumen)o(t)g(coun)o(t)g(four,)g(a)g
+(second)h(time)f(mak)o(es)g(the)240 901 y(argumen)o(t)d(coun)o(t)h
+(sixteen,)h(and)f(so)g(on.)20 b(By)15 b(default,)h(this)f(is)h(not)f(b)
+q(ound)h(to)f(a)g(k)o(ey)l(.)0 1143 y Fk(1.4.6)30 b(Letting)14
+b(Readline)h(T)n(yp)r(e)h(F)-5 b(or)14 b(Y)-5 b(ou)0
+1301 y Fq(complete)14 b(\(TAB\))240 1363 y Fr(A)o(ttempt)i(to)h(do)g
+(completion)i(on)e(the)g(text)g(b)q(efore)h(the)f(cursor.)26
+b(This)18 b(is)g(application-sp)q(eci\014c.)240 1425
+y(Generally)l(,)h(if)f(y)o(ou)f(are)h(t)o(yping)g(a)f(\014lename)i
+(argumen)o(t,)e(y)o(ou)g(can)h(do)f(\014lename)i(completion;)g(if)240
+1487 y(y)o(ou)f(are)f(t)o(yping)i(a)e(command,)i(y)o(ou)e(can)i(do)f
+(command)g(completion,)h(if)g(y)o(ou)e(are)h(t)o(yping)g(in)h(a)240
+1550 y(sym)o(b)q(ol)e(to)f(GDB,)g(y)o(ou)g(can)h(do)g(sym)o(b)q(ol)g
+(name)g(completion,)h(if)f(y)o(ou)f(are)h(t)o(yping)g(in)g(a)g(v)m
+(ariable)240 1612 y(to)e(Bash,)f(y)o(ou)h(can)h(do)f(v)m(ariable)h
+(name)g(completion,)g(and)f(so)g(on.)0 1707 y Fq(possible-completions)d
+(\(M-?\))240 1769 y Fr(List)k(the)f(p)q(ossible)i(completions)f(of)f
+(the)g(text)g(b)q(efore)h(the)f(cursor.)0 1864 y Fq(insert-completions)
+e(\(M-*\))240 1926 y Fr(Insert)22 b(all)h(completions)g(of)f(the)g
+(text)f(b)q(efore)h(p)q(oin)o(t)h(that)e(w)o(ould)h(ha)o(v)o(e)g(b)q
+(een)h(generated)f(b)o(y)240 1989 y Fq(possible-completions)p
+Fr(.)0 2231 y Fk(1.4.7)30 b(Keyb)r(oard)15 b(Macros)0
+2388 y Fq(start-kbd-macro)e(\(C-x)i(\(\))240 2451 y Fr(Begin)h(sa)o
+(ving)f(the)h(c)o(haracters)e(t)o(yp)q(ed)i(in)o(to)f(the)g(curren)o(t)
+g(k)o(eyb)q(oard)g(macro.)0 2545 y Fq(end-kbd-macro)e(\(C-x)i(\)\))240
+2608 y Fr(Stop)f(sa)o(ving)h(the)g(c)o(haracters)f(t)o(yp)q(ed)h(in)o
+(to)f(the)h(curren)o(t)f(k)o(eyb)q(oard)h(macro)f(and)h(sa)o(v)o(e)f
+(the)g(de\014ni-)240 2670 y(tion.)p eop
+17 18 bop 0 -58 a Fr(Chapter)15 b(1:)k(Command)c(Line)i(Editing)1205
+b(17)0 183 y Fq(call-last-kbd-macro)13 b(\(C-x)h(e\))240
+246 y Fr(Re-execute)20 b(the)f(last)f(k)o(eyb)q(oard)g(macro)g
+(de\014ned,)i(b)o(y)f(making)f(the)h(c)o(haracters)f(in)h(the)g(macro)
+240 308 y(app)q(ear)c(as)g(if)h(t)o(yp)q(ed)f(at)g(the)g(k)o(eyb)q
+(oard.)0 546 y Fk(1.4.8)30 b(Some)15 b(Miscellaneous)h(Commands)0
+703 y Fq(re-read-init-file)d(\(C-x)h(C-r\))240 765 y
+Fr(Read)23 b(in)h(the)e(con)o(ten)o(ts)g(of)h(the)f(inputrc)i(\014le,)h
+(and)e(incorp)q(orate)g(an)o(y)f(bindings)i(or)f(v)m(ariable)240
+827 y(assignmen)o(ts)15 b(found)h(there.)0 921 y Fq(abort)e(\(C-g\))240
+984 y Fr(Ab)q(ort)f(the)h(curren)o(t)f(editing)i(command)e(and)h(ring)g
+(the)f(terminal's)h(b)q(ell)h(\(sub)s(ject)f(to)e(the)i(setting)240
+1046 y(of)h Fq(bell-style)p Fr(\).)0 1140 y Fq(do-uppercase-version)d
+(\(M-a,)j(M-b,)f(M-)p Fl(x)p Fq(,)h Fj(:)8 b(:)g(:)n
+Fq(\))240 1202 y Fr(If)16 b(the)f(meta\014ed)g(c)o(haracter)g
+Fl(x)k Fr(is)c(lo)o(w)o(ercase,)g(run)h(the)f(command)g(that)g(is)h(b)q
+(ound)g(to)f(the)g(corre-)240 1264 y(sp)q(onding)h(upp)q(ercase)h(c)o
+(haracter.)0 1358 y Fq(prefix-meta)d(\(ESC\))240 1421
+y Fr(Mak)o(e)g(the)g(next)h(c)o(haracter)f(that)g(y)o(ou)g(t)o(yp)q(e)h
+(b)q(e)g(meta\014ed.)20 b(This)15 b(is)g(for)f(p)q(eople)i(without)e(a)
+h(meta)240 1483 y(k)o(ey)l(.)20 b(T)o(yping)c(`)p Fq(ESC)e(f)p
+Fr(')h(is)g(equiv)m(alen)o(t)i(to)e(t)o(yping)g(`)p Fq(M-f)p
+Fr('.)0 1577 y Fq(undo)g(\(C-_,)f(C-x)h(C-u\))240 1639
+y Fr(Incremen)o(tal)h(undo,)f(separately)h(remem)o(b)q(ered)g(for)e
+(eac)o(h)h(line.)0 1733 y Fq(revert-line)f(\(M-r\))240
+1796 y Fr(Undo)20 b(all)h(c)o(hanges)f(made)g(to)f(this)i(line.)35
+b(This)21 b(is)f(lik)o(e)h(t)o(yping)f(the)g Fq(undo)g
+Fr(command)g(enough)240 1858 y(times)15 b(to)g(get)g(bac)o(k)g(to)f
+(the)i(b)q(eginning.)0 1952 y Fq(tilde-expand)e(\(M-~\))240
+2014 y Fr(P)o(erform)g(tilde)j(expansion)f(on)f(the)g(curren)o(t)g(w)o
+(ord.)0 2108 y Fq(set-mark)f(\(C-@\))240 2171 y Fr(Set)i(the)g(mark)f
+(to)g(the)h(curren)o(t)g(p)q(oin)o(t.)23 b(If)16 b(a)f(n)o(umeric)i
+(argumen)o(t)e(is)i(supplied,)h(the)e(mark)f(is)h(set)240
+2233 y(to)f(that)f(p)q(osition.)0 2327 y Fq(exchange-point-and-mark)e
+(\(C-x)j(C-x\))240 2389 y Fr(Sw)o(ap)e(the)g(p)q(oin)o(t)h(with)f(the)g
+(mark.)19 b(The)13 b(curren)o(t)g(cursor)g(p)q(osition)h(is)g(set)f(to)
+f(the)i(sa)o(v)o(ed)e(p)q(osition,)240 2451 y(and)j(the)h(old)f(cursor)
+g(p)q(osition)i(is)e(sa)o(v)o(ed)g(as)g(the)g(mark.)0
+2545 y Fq(character-search)e(\(C-]\))240 2608 y Fr(A)19
+b(c)o(haracter)e(is)j(read)e(and)h(p)q(oin)o(t)g(is)g(mo)o(v)o(ed)f(to)
+g(the)g(next)h(o)q(ccurrence)h(of)e(that)g(c)o(haracter.)29
+b(A)240 2670 y(negativ)o(e)15 b(coun)o(t)g(searc)o(hes)g(for)g
+(previous)h(o)q(ccurrences.)p eop
+18 19 bop 0 -58 a Fr(18)1449 b(GNU)15 b(Readline)i(Library)0
+183 y Fq(character-search-backward)12 b(\(M-C-]\))240
+246 y Fr(A)i(c)o(haracter)f(is)h(read)g(and)f(p)q(oin)o(t)i(is)f(mo)o
+(v)o(ed)f(to)g(the)h(previous)g(o)q(ccurrence)h(of)e(that)g(c)o
+(haracter.)19 b(A)240 308 y(negativ)o(e)c(coun)o(t)g(searc)o(hes)g(for)
+g(subsequen)o(t)h(o)q(ccurrences.)0 395 y Fq(insert-comment)d(\(M-#\))
+240 457 y Fr(The)19 b(v)m(alue)g(of)f(the)g Fq(comment-begin)f
+Fr(v)m(ariable)i(is)g(inserted)g(at)f(the)g(b)q(eginning)j(of)d(the)g
+(curren)o(t)240 519 y(line,)e(and)g(the)f(line)i(is)f(accepted)g(as)e
+(if)i(a)f(newline)i(had)e(b)q(een)i(t)o(yp)q(ed.)0 607
+y Fq(dump-functions)c(\(\))240 669 y Fr(Prin)o(t)18 b(all)h(of)f(the)g
+(functions)h(and)g(their)g(k)o(ey)f(bindings)i(to)d(the)i(readline)h
+(output)e(stream.)28 b(If)18 b(a)240 731 y(n)o(umeric)i(argumen)o(t)d
+(is)i(supplied,)j(the)d(output)f(is)h(formatted)f(in)h(suc)o(h)g(a)f(w)
+o(a)o(y)g(that)g(it)h(can)f(b)q(e)240 793 y(made)d(part)g(of)g(an)g
+Fl(inputrc)k Fr(\014le.)i(This)15 b(command)g(is)h(un)o(b)q(ound)h(b)o
+(y)e(default.)0 881 y Fq(dump-variables)e(\(\))240 943
+y Fr(Prin)o(t)j(all)h(of)f(the)h(settable)f(v)m(ariables)i(and)e(their)
+h(v)m(alues)g(to)f(the)g(readline)i(output)e(stream.)23
+b(If)16 b(a)240 1005 y(n)o(umeric)k(argumen)o(t)d(is)i(supplied,)j(the)
+d(output)f(is)h(formatted)f(in)h(suc)o(h)g(a)f(w)o(a)o(y)g(that)g(it)h
+(can)f(b)q(e)240 1067 y(made)d(part)g(of)g(an)g Fl(inputrc)k
+Fr(\014le.)i(This)15 b(command)g(is)h(un)o(b)q(ound)h(b)o(y)e(default.)
+0 1155 y Fq(dump-macros)f(\(\))240 1217 y Fr(Prin)o(t)h(all)g(of)g(the)
+f(readline)j(k)o(ey)d(sequences)i(b)q(ound)g(to)e(macros)g(and)h(the)f
+(strings)h(they)g(ouput.)20 b(If)240 1279 y(a)c(n)o(umeric)h(argumen)o
+(t)e(is)i(supplied,)h(the)e(output)g(is)g(formatted)f(in)i(suc)o(h)g(a)
+e(w)o(a)o(y)g(that)h(it)g(can)g(b)q(e)240 1341 y(made)f(part)g(of)g(an)
+g Fl(inputrc)k Fr(\014le.)i(This)15 b(command)g(is)h(un)o(b)q(ound)h(b)
+o(y)e(default.)0 1566 y Fp(1.5)33 b(Readline)16 b(vi)g(Mo)r(de)62
+1703 y Fr(While)d(the)f(Readline)i(library)e(do)q(es)g(not)g(ha)o(v)o
+(e)f(a)g(full)i(set)f(of)f Fq(vi)g Fr(editing)i(functions,)g(it)f(do)q
+(es)g(con)o(tain)g(enough)0 1765 y(to)f(allo)o(w)i(simple)g(editing)g
+(of)f(the)g(line.)20 b(The)13 b(Readline)h Fq(vi)d Fr(mo)q(de)i(b)q
+(eha)o(v)o(es)f(as)g(sp)q(eci\014ed)i(in)e(the)h Fm(POSIX)f
+Fr(1003.2)0 1827 y(standard.)62 1964 y(In)17 b(order)e(to)g(switc)o(h)h
+(in)o(teractiv)o(ely)h(b)q(et)o(w)o(een)f Fq(emacs)f
+Fr(and)h Fq(vi)f Fr(editing)i(mo)q(des,)f(use)g(the)g(command)f(M-C-j)0
+2026 y(\(toggle-editing-mo)q(de\).)21 b(The)15 b(Readline)j(default)e
+(is)f Fq(emacs)g Fr(mo)q(de.)62 2163 y(When)k(y)o(ou)f(en)o(ter)g(a)g
+(line)i(in)g Fq(vi)e Fr(mo)q(de,)h(y)o(ou)f(are)g(already)g(placed)i
+(in)f(`insertion')g(mo)q(de,)g(as)f(if)h(y)o(ou)f(had)0
+2226 y(t)o(yp)q(ed)e(an)f(`)p Fq(i)p Fr('.)20 b(Pressing)c
+Fq(ESC)f Fr(switc)o(hes)h(y)o(ou)f(in)o(to)h(`command')f(mo)q(de,)g
+(where)h(y)o(ou)f(can)h(edit)g(the)g(text)f(of)g(the)0
+2288 y(line)j(with)e(the)h(standard)e Fq(vi)h Fr(mo)o(v)o(emen)o(t)f(k)
+o(eys,)h(mo)o(v)o(e)g(to)f(previous)i(history)f(lines)i(with)f(`)p
+Fq(k)p Fr(')e(and)h(subsequen)o(t)0 2350 y(lines)h(with)e(`)p
+Fq(j)p Fr(',)f(and)i(so)e(forth.)p eop
+19 20 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(19)0 183 y Fn(2)41 b(Programming)16 b(with)f(GNU)h
+(Readline)62 394 y Fr(This)j(c)o(hapter)f(describ)q(es)i(the)e(in)o
+(terface)g(b)q(et)o(w)o(een)h(the)f(GNU)g(Readline)j(Library)d(and)h
+(other)f(programs.)0 456 y(If)h(y)o(ou)g(are)f(a)h(programmer,)f(and)i
+(y)o(ou)e(wish)i(to)e(include)j(the)e(features)g(found)g(in)h(GNU)f
+(Readline)i(suc)o(h)e(as)0 518 y(completion,)f(line)h(editing,)f(and)f
+(in)o(teractiv)o(e)h(history)f(manipulation)h(in)g(y)o(our)f(o)o(wn)f
+(programs,)g(this)h(section)0 581 y(is)f(for)e(y)o(ou.)0
+848 y Fp(2.1)33 b(Basic)14 b(Beha)n(vior)62 989 y Fr(Man)o(y)c
+(programs)g(pro)o(vide)h(a)g(command)f(line)j(in)o(terface,)e(suc)o(h)g
+(as)g Fq(mail)p Fr(,)f Fq(ftp)p Fr(,)h(and)g Fq(sh)p
+Fr(.)18 b(F)l(or)10 b(suc)o(h)i(programs,)0 1052 y(the)17
+b(default)h(b)q(eha)o(viour)g(of)e(Readline)k(is)e(su\016cien)o(t.)26
+b(This)18 b(section)f(describ)q(es)i(ho)o(w)e(to)f(use)i(Readline)h(in)
+f(the)0 1114 y(simplest)e(w)o(a)o(y)e(p)q(ossible,)j(p)q(erhaps)f(to)e
+(replace)j(calls)f(in)g(y)o(our)f(co)q(de)g(to)g Fq(gets\(\))f
+Fr(or)h Fq(fgets)f(\(\))p Fr(.)62 1256 y(The)g(function)g
+Fq(readline)g(\(\))f Fr(prin)o(ts)h(a)f(prompt)g(and)h(then)g(reads)f
+(and)g(returns)h(a)f(single)i(line)g(of)e(text)g(from)0
+1318 y(the)g(user.)19 b(The)13 b(line)i Fq(readline)d
+Fr(returns)g(is)i(allo)q(cated)g(with)f Fq(malloc)h(\(\))p
+Fr(;)f(y)o(ou)g(should)h Fq(free)g(\(\))f Fr(the)g(line)h(when)0
+1380 y(y)o(ou)h(are)g(done)g(with)h(it.)k(The)15 b(declaration)h(for)f
+Fq(readline)f Fr(in)i(ANSI)g(C)f(is)120 1512 y Fq(char)23
+b(*readline)g(\(char)g(*)p Fl(prompt)q Fq(\);)0 1653
+y Fr(So,)15 b(one)g(migh)o(t)g(sa)o(y)120 1785 y Fq(char)23
+b(*line)g(=)h(readline)f(\("Enter)g(a)h(line:)f("\);)0
+1927 y Fr(in)17 b(order)g(to)f(read)g(a)g(line)j(of)d(text)g(from)g
+(the)g(user.)24 b(The)17 b(line)h(returned)f(has)g(the)f(\014nal)i
+(newline)g(remo)o(v)o(ed,)e(so)0 1989 y(only)g(the)f(text)g(remains.)62
+2131 y(If)g Fq(readline)f Fr(encoun)o(ters)h(an)f Fq(EOF)h
+Fr(while)h(reading)f(the)g(line,)h(and)f(the)g(line)h(is)f(empt)o(y)g
+(at)f(that)g(p)q(oin)o(t,)h(then)0 2193 y Fq(\(char)f(*\)NULL)h
+Fr(is)h(returned.)k(Otherwise,)15 b(the)h(line)h(is)e(ended)i(just)d
+(as)h(if)h(a)f(newline)i(had)e(b)q(een)i(t)o(yp)q(ed.)62
+2335 y(If)g(y)o(ou)g(w)o(an)o(t)f(the)h(user)g(to)f(b)q(e)i(able)f(to)g
+(get)f(at)g(the)h(line)i(later,)e(\(with)g Fq(C-P)f Fr(for)g
+(example\),)i(y)o(ou)e(m)o(ust)h(call)0 2397 y Fq(add_history)d(\(\))h
+Fr(to)f(sa)o(v)o(e)h(the)g(line)i(a)o(w)o(a)o(y)c(in)j(a)f
+Fl(history)k Fr(list)d(of)f(suc)o(h)h(lines.)120 2528
+y Fq(add_history)22 b(\(line\);)0 2670 y Fr(F)l(or)15
+b(full)h(details)g(on)f(the)h(GNU)f(History)g(Library)l(,)g(see)h(the)f
+(asso)q(ciated)g(man)o(ual.)p eop
+20 21 bop 0 -58 a Fr(20)1449 b(GNU)15 b(Readline)i(Library)62
+183 y(It)e(is)g(preferable)g(to)f(a)o(v)o(oid)g(sa)o(ving)h(empt)o(y)f
+(lines)i(on)f(the)f(history)h(list,)g(since)g(users)g(rarely)g(ha)o(v)o
+(e)f(a)g(burning)0 246 y(need)i(to)e(reuse)h(a)f(blank)i(line.)21
+b(Here)15 b(is)g(a)g(function)g(whic)o(h)h(usefully)g(replaces)g(the)f
+(standard)f Fq(gets)h(\(\))f Fr(library)0 308 y(function,)i(and)f(has)g
+(the)g(adv)m(an)o(tage)g(of)g(no)g(static)g(bu\013er)g(to)g(o)o(v)o
+(er\015o)o(w:)120 445 y Fq(/*)24 b(A)f(static)g(variable)g(for)h
+(holding)e(the)i(line.)f(*/)120 497 y(static)g(char)g(*line_read)g(=)h
+(\(char)f(*\)NULL;)120 601 y(/*)h(Read)f(a)h(string,)f(and)g(return)g
+(a)h(pointer)f(to)g(it.)48 b(Returns)22 b(NULL)i(on)f(EOF.)h(*/)120
+653 y(char)f(*)120 705 y(rl_gets)g(\(\))120 757 y({)168
+809 y(/*)g(If)h(the)f(buffer)g(has)h(already)f(been)g(allocated,)g
+(return)g(the)g(memory)239 861 y(to)h(the)f(free)h(pool.)f(*/)168
+912 y(if)g(\(line_read\))215 964 y({)263 1016 y(free)g(\(line_read\);)
+263 1068 y(line_read)g(=)h(\(char)f(*\)NULL;)215 1120
+y(})168 1224 y(/*)g(Get)h(a)f(line)h(from)f(the)h(user.)f(*/)168
+1276 y(line_read)f(=)i(readline)f(\(""\);)168 1379 y(/*)g(If)h(the)f
+(line)h(has)f(any)h(text)f(in)g(it,)h(save)f(it)h(on)f(the)h(history.)f
+(*/)168 1431 y(if)g(\(line_read)g(&&)g(*line_read\))215
+1483 y(add_history)g(\(line_read\);)168 1587 y(return)g(\(line_read\);)
+120 1639 y(})62 1787 y Fr(This)15 b(function)g(giv)o(es)f(the)g(user)g
+(the)g(default)h(b)q(eha)o(viour)g(of)e Fq(TAB)h Fr(completion:)20
+b(completion)15 b(on)f(\014le)h(names.)0 1849 y(If)h(y)o(ou)f(do)h(not)
+f(w)o(an)o(t)g(Readline)j(to)d(complete)i(on)e(\014lenames,)i(y)o(ou)e
+(can)h(c)o(hange)g(the)g(binding)i(of)d(the)h Fq(TAB)f
+Fr(k)o(ey)0 1912 y(with)h Fq(rl_bind_key)d(\(\))p Fr(.)120
+2049 y Fq(int)23 b(rl_bind_key)g(\(int)g Fl(k)o(ey)p
+Fq(,)h(int)f(\(*)p Fl(function)p Fq(\)\(\)\);)62 2197
+y(rl_bind_key)14 b(\(\))f Fr(tak)o(es)g(t)o(w)o(o)f(argumen)o(ts:)19
+b Fl(k)o(ey)e Fr(is)d(the)g(c)o(haracter)f(that)g(y)o(ou)g(w)o(an)o(t)f
+(to)h(bind,)i(and)f Fl(function)0 2260 y Fr(is)g(the)g(address)g(of)f
+(the)h(function)g(to)f(call)i(when)f Fl(k)o(ey)j Fr(is)d(pressed.)20
+b(Binding)c Fq(TAB)d Fr(to)g Fq(rl_insert)h(\(\))f Fr(mak)o(es)g
+Fq(TAB)0 2322 y Fr(insert)i(itself.)20 b Fq(rl_bind_key)14
+b(\(\))g Fr(returns)g(non-zero)h(if)g Fl(k)o(ey)j Fr(is)d(not)f(a)g(v)m
+(alid)i(ASCI)q(I)f(c)o(haracter)f(co)q(de)h(\(b)q(et)o(w)o(een)0
+2384 y(0)g(and)g(255\).)62 2532 y(Th)o(us,)g(to)g(disable)h(the)g
+(default)f Fq(TAB)g Fr(b)q(eha)o(vior,)h(the)f(follo)o(wing)h
+(su\016ces:)120 2670 y Fq(rl_bind_key)22 b(\('\\t',)h(rl_insert\);)p
+eop
+21 22 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(21)62 183 y(This)12 b(co)q(de)f(should)h(b)q(e)f
+(executed)h(once)f(at)f(the)h(start)f(of)g(y)o(our)g(program;)h(y)o(ou)
+g(migh)o(t)f(write)h(a)g(function)g(called)0 246 y Fq
+(initialize_readline)i(\(\))j Fr(whic)o(h)h(p)q(erforms)f(this)h(and)f
+(other)g(desired)i(initializations,)h(suc)o(h)e(as)f(installing)0
+308 y(custom)f(completers)g(\(see)h(Section)g(2.5)e([Custom)g
+(Completers],)h(page)g(34\).)0 562 y Fp(2.2)33 b(Custom)14
+b(F)-6 b(unctions)62 702 y Fr(Readline)18 b(pro)o(vides)f(man)o(y)e
+(functions)i(for)e(manipulating)j(the)e(text)f(of)g(the)h(line,)i(but)e
+(it)g(isn't)g(p)q(ossible)i(to)0 765 y(an)o(ticipate)i(the)g(needs)g
+(of)f(all)h(programs.)31 b(This)20 b(section)g(describ)q(es)h(the)f(v)m
+(arious)g(functions)g(and)g(v)m(ariables)0 827 y(de\014ned)c(within)f
+(the)g(Readline)i(library)e(whic)o(h)g(allo)o(w)g(a)f(user)g(program)f
+(to)h(add)h(customized)g(functionalit)o(y)h(to)0 889
+y(Readline.)0 1127 y Fk(2.2.1)30 b(The)15 b(F)-5 b(unction)14
+b(T)n(yp)r(e)62 1267 y Fr(F)l(or)j(readabilt)o(y)l(,)h(w)o(e)f(declare)
+i(a)e(new)g(t)o(yp)q(e)h(of)f(ob)s(ject,)f(called)j Fl(F)l(unction)p
+Fr(.)28 b(A)17 b Fq(Function)f Fr(is)i(a)f(C)g(function)0
+1329 y(whic)o(h)f(returns)f(an)g Fq(int)p Fr(.)20 b(The)15
+b(t)o(yp)q(e)g(declaration)h(for)f Fq(Function)f Fr(is:)0
+1470 y Fq(typedef)g(int)h(Function)f(\(\);)62 1610 y
+Fr(The)i(reason)f(for)g(declaring)i(this)f(new)g(t)o(yp)q(e)f(is)h(to)f
+(mak)o(e)g(it)h(easier)g(to)f(write)g(co)q(de)h(describing)i(p)q(oin)o
+(ters)e(to)0 1672 y(C)g(functions.)25 b(Let)17 b(us)f(sa)o(y)g(w)o(e)g
+(had)h(a)f(v)m(ariable)i(called)g Fl(func)i Fr(whic)o(h)d(w)o(as)f(a)g
+(p)q(oin)o(ter)h(to)f(a)g(function.)25 b(Instead)0 1735
+y(of)15 b(the)g(classic)h(C)f(declaration)62 1875 y Fq(int)g
+(\(*\)\(\)func;)0 2015 y Fr(w)o(e)g(ma)o(y)f(write)62
+2156 y Fq(Function)g(*func;)0 2296 y Fr(Similarly)l(,)j(there)e(are)120
+2426 y Fq(typedef)23 b(void)g(VFunction)g(\(\);)120 2478
+y(typedef)g(char)g(*CPFunction)g(\(\);)g Fr(and)120 2530
+y Fq(typedef)g(char)g(**CPPFunction)f(\(\);)0 2670 y
+Fr(for)12 b(functions)h(returning)g(no)g(v)m(alue,)g
+Fq(pointer)i(to)g(char)p Fr(,)d(and)g Fq(pointer)i(to)h(pointer)g(to)f
+(char)p Fr(,)e(resp)q(ectiv)o(ely)l(.)p eop
+22 23 bop 0 -58 a Fr(22)1449 b(GNU)15 b(Readline)i(Library)0
+183 y Fk(2.2.2)30 b(W)-5 b(riting)15 b(a)g(New)g(F)-5
+b(unction)62 325 y Fr(In)22 b(order)f(to)g(write)g(new)h(functions)g
+(for)f(Readline,)j(y)o(ou)d(need)h(to)f(kno)o(w)g(the)g(calling)i(con)o
+(v)o(en)o(tions)f(for)0 387 y(k)o(eyb)q(oard-in)o(v)o(ok)o(ed)17
+b(functions,)g(and)f(the)h(names)f(of)g(the)h(v)m(ariables)h(that)d
+(describ)q(e)j(the)f(curren)o(t)f(state)g(of)g(the)0
+449 y(line)h(read)e(so)g(far.)62 591 y(The)h(calling)h(sequence)f(for)f
+(a)f(command)i Fq(foo)e Fr(lo)q(oks)i(lik)o(e)120 722
+y Fq(foo)23 b(\(int)h(count,)f(int)g(key\))0 864 y Fr(where)f
+Fl(coun)o(t)g Fr(is)g(the)f(n)o(umeric)i(argumen)o(t)d(\(or)h(1)g(if)h
+(defaulted\))g(and)f Fl(k)o(ey)26 b Fr(is)21 b(the)h(k)o(ey)f(that)g
+(in)o(v)o(ok)o(ed)h(this)0 926 y(function.)62 1068 y(It)f(is)h
+(completely)g(up)f(to)f(the)h(function)h(as)f(to)f(what)g(should)i(b)q
+(e)g(done)f(with)g(the)g(n)o(umeric)h(argumen)o(t.)0
+1130 y(Some)c(functions)g(use)g(it)g(as)f(a)h(rep)q(eat)g(coun)o(t,)f
+(some)h(as)f(a)g(\015ag,)h(and)g(others)f(to)g(c)o(ho)q(ose)h
+(alternate)f(b)q(eha)o(vior)0 1192 y(\(refreshing)12
+b(the)g(curren)o(t)g(line)h(as)f(opp)q(osed)g(to)f(refreshing)i(the)f
+(screen,)g(for)g(example\).)19 b(Some)12 b(c)o(ho)q(ose)f(to)h(ignore)0
+1255 y(it.)24 b(In)17 b(general,)g(if)g(a)g(function)g(uses)g(the)g(n)o
+(umeric)g(argumen)o(t)f(as)g(a)g(rep)q(eat)h(coun)o(t,)f(it)h(should)h
+(b)q(e)f(able)g(to)f(do)0 1317 y(something)f(useful)g(with)g(b)q(oth)f
+(negativ)o(e)h(and)f(p)q(ositiv)o(e)i(argumen)o(ts.)i(A)o(t)c(the)h(v)o
+(ery)f(least,)g(it)h(should)g(b)q(e)g(a)o(w)o(are)0 1379
+y(that)f(it)i(can)f(b)q(e)h(passed)g(a)e(negativ)o(e)i(argumen)o(t.)0
+1645 y Fp(2.3)33 b(Readline)16 b(V)-6 b(ariables)62 1787
+y Fr(These)16 b(v)m(ariables)g(are)f(a)o(v)m(ailable)i(to)e(function)h
+(writers.)1736 1963 y(V)l(ariable)-1899 b Fi(char)20
+b(*)f Fh(rl)p 211 1963 18 3 v 21 w(line)p 320 1963 V
+23 w(bu\013er)120 2025 y Fr(This)f(is)g(the)f(line)i(gathered)e(so)g
+(far.)25 b(Y)l(ou)18 b(are)f(w)o(elcome)g(to)g(mo)q(dify)h(the)f(con)o
+(ten)o(ts)g(of)f(the)i(line,)120 2087 y(but)d(see)h(Section)g(2.4.5)d
+([Allo)o(wing)k(Undoing],)e(page)g(28.)1736 2263 y(V)l(ariable)-1899
+b Fi(int)20 b Fh(rl)p 140 2263 V 21 w(p)r(oin)n(t)120
+2325 y Fr(The)15 b(o\013set)g(of)f(the)i(curren)o(t)f(cursor)g(p)q
+(osition)h(in)g Fq(rl_line_buffer)d Fr(\(the)i Fl(p)q(oin)o(t)q
+Fr(\).)1736 2501 y(V)l(ariable)-1899 b Fi(int)20 b Fh(rl)p
+140 2501 V 21 w(end)120 2563 y Fr(The)d(n)o(um)o(b)q(er)f(of)g(c)o
+(haracters)g(presen)o(t)g(in)h Fq(rl_line_buffer)p Fr(.)k(When)c
+Fq(rl_point)e Fr(is)i(at)f(the)g(end)120 2626 y(of)f(the)g(line,)i
+Fq(rl_point)d Fr(and)h Fq(rl_end)f Fr(are)h(equal.)p
+eop
+23 24 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(23)1736 183 y(V)l(ariable)-1899 b Fi(int)20
+b Fh(rl)p 140 183 18 3 v 21 w(mark)120 246 y Fr(The)h(mark)e(\(sa)o(v)o
+(ed)h(p)q(osition\))h(in)g(the)f(curren)o(t)h(line.)37
+b(If)20 b(set,)h(the)g(mark)e(and)i(p)q(oin)o(t)g(de\014ne)g(a)120
+308 y Fl(region)p Fr(.)1736 473 y(V)l(ariable)-1899 b
+Fi(int)20 b Fh(rl)p 140 473 V 21 w(done)120 536 y Fr(Setting)13
+b(this)h(to)f(a)f(non-zero)i(v)m(alue)g(causes)f(Readline)j(to)c
+(return)h(the)h(curren)o(t)f(line)h(immediately)l(.)1736
+701 y(V)l(ariable)-1899 b Fi(int)20 b Fh(rl)p 140 701
+V 21 w(p)r(ending)p 361 701 V 20 w(input)120 764 y Fr(Setting)15
+b(this)f(to)g(a)g(v)m(alue)i(mak)o(es)d(it)i(the)f(next)h(k)o(eystrok)o
+(e)e(read.)19 b(This)c(is)g(a)f(w)o(a)o(y)f(to)h(stu\013)g(a)g(single)
+120 826 y(c)o(haracter)g(in)o(to)i(the)f(input)h(stream.)1736
+991 y(V)l(ariable)-1899 b Fi(char)20 b(*)f Fh(rl)p 211
+991 V 21 w(prompt)120 1054 y Fr(The)c(prompt)e(Readline)k(uses.)j(This)
+15 b(is)f(set)h(from)e(the)h(argumen)o(t)g(to)g Fq(readline)g(\(\))p
+Fr(,)f(and)i(should)120 1116 y(not)g(b)q(e)h(assigned)f(to)g(directly)l
+(.)1736 1282 y(V)l(ariable)-1899 b Fi(char)20 b(*)f Fh(rl)p
+211 1282 V 21 w(library)p 400 1282 V 22 w(v)n(ersion)120
+1344 y Fr(The)c(v)o(ersion)h(n)o(um)o(b)q(er)f(of)g(this)h(revision)g
+(of)f(the)g(library)l(.)1736 1509 y(V)l(ariable)-1899
+b Fi(char)20 b(*)f Fh(rl)p 211 1509 V 21 w(terminal)p
+443 1509 V 21 w(name)120 1572 y Fr(The)c(terminal)h(t)o(yp)q(e,)f(used)
+h(for)f(initialization.)1736 1737 y(V)l(ariable)-1899
+b Fi(char)20 b(*)f Fh(rl)p 211 1737 V 21 w(readline)p
+430 1737 V 22 w(name)120 1800 y Fr(This)f(v)m(ariable)h(is)f(set)f(to)g
+(a)g(unique)i(name)f(b)o(y)f(eac)o(h)h(application)h(using)f(Readline.)
+29 b(The)18 b(v)m(alue)120 1862 y(allo)o(ws)f(conditional)h(parsing)f
+(of)f(the)g(inputrc)i(\014le)f(\(see)g(Section)g(1.3.2)e([Conditional)j
+(Init)f(Con-)120 1924 y(structs],)d(page)h(8\).)1736
+2090 y(V)l(ariable)-1899 b Fi(FILE)20 b(*)f Fh(rl)p 211
+2090 V 21 w(instream)120 2152 y Fr(The)c(stdio)h(stream)e(from)h(whic)o
+(h)h(Readline)h(reads)e(input.)1736 2318 y(V)l(ariable)-1899
+b Fi(FILE)20 b(*)f Fh(rl)p 211 2318 V 21 w(outstream)120
+2380 y Fr(The)c(stdio)h(stream)e(to)h(whic)o(h)h(Readline)h(p)q
+(erforms)e(output.)1736 2545 y(V)l(ariable)-1899 b Fi(Function)20
+b(*)g Fh(rl)p 316 2545 V 21 w(startup)p 520 2545 V 20
+w(ho)r(ok)120 2608 y Fr(If)13 b(non-zero,)h(this)f(is)h(the)f(address)g
+(of)g(a)f(function)i(to)f(call)h(just)f(b)q(efore)g Fq(readline)f
+Fr(prin)o(ts)h(the)g(\014rst)120 2670 y(prompt.)p eop
+24 25 bop 0 -58 a Fr(24)1449 b(GNU)15 b(Readline)i(Library)1736
+183 y(V)l(ariable)-1899 b Fi(Function)20 b(*)g Fh(rl)p
+316 183 18 3 v 21 w(ev)n(en)n(t)p 469 183 V 22 w(ho)r(ok)120
+246 y Fr(If)13 b(non-zero,)f(this)h(is)g(the)g(address)f(of)g(a)g
+(function)h(to)f(call)i(p)q(erio)q(dically)h(when)e(readline)h(is)f(w)o
+(aiting)120 308 y(for)i(terminal)h(input.)1736 471 y(V)l(ariable)-1899
+b Fi(Function)20 b(*)g Fh(rl)p 316 471 V 21 w(getc)p
+439 471 V 21 w(function)120 533 y Fr(If)c(non-zero,)h
+Fq(readline)d Fr(will)k(call)f(indirectly)i(through)c(this)i(p)q(oin)o
+(ter)g(to)e(get)h(a)f(c)o(haracter)h(from)120 595 y(the)k(input)h
+(stream.)33 b(By)20 b(default,)i(it)e(is)g(set)g(to)g
+Fq(rl_getc)p Fr(,)f(the)h(default)h Fq(readline)e Fr(c)o(haracter)120
+657 y(input)d(function)g(\(see)f(Section)h(2.4.8)e([Utilit)o(y)i(F)l
+(unctions],)f(page)g(31\).)1736 820 y(V)l(ariable)-1899
+b Fi(VFunction)20 b(*)g Fh(rl)p 342 820 V 21 w(redispla)n(y)p
+586 820 V 22 w(function)120 883 y Fr(If)f(non-zero,)h
+Fq(readline)e Fr(will)i(call)g(indirectly)i(through)c(this)i(p)q(oin)o
+(ter)f(to)f(up)q(date)i(the)f(displa)o(y)120 945 y(with)d(the)g(curren)
+o(t)f(con)o(ten)o(ts)g(of)h(the)f(editing)i(bu\013er.)22
+b(By)15 b(default,)h(it)g(is)h(set)e(to)g Fq(rl_redisplay)p
+Fr(,)120 1007 y(the)g(default)h Fq(readline)e Fr(redispla)o(y)i
+(function)g(\(see)g(Section)g(2.4.6)d([Redispla)o(y],)j(page)f(29\).)
+1736 1170 y(V)l(ariable)-1899 b Fi(Keymap)20 b Fh(rl)p
+218 1170 V 21 w(executing)p 476 1170 V 22 w(k)n(eymap)120
+1232 y Fr(This)15 b(v)m(ariable)h(is)f(set)g(to)f(the)g(k)o(eymap)h
+(\(see)f(Section)i(2.4.2)d([Keymaps],)h(page)g(25\))g(in)h(whic)o(h)h
+(the)120 1294 y(curren)o(tly)g(executing)g(readline)h(function)f(w)o
+(as)e(found.)1736 1457 y(V)l(ariable)-1899 b Fi(Keymap)20
+b Fh(rl)p 218 1457 V 21 w(binding)p 426 1457 V 22 w(k)n(eymap)120
+1520 y Fr(This)15 b(v)m(ariable)h(is)f(set)g(to)f(the)g(k)o(eymap)h
+(\(see)f(Section)i(2.4.2)d([Keymaps],)h(page)g(25\))g(in)h(whic)o(h)h
+(the)120 1582 y(last)f(k)o(ey)g(binding)i(o)q(ccurred.)0
+1809 y Fp(2.4)33 b(Readline)16 b(Con)n(v)n(enience)g(F)-6
+b(unctions)0 2019 y Fk(2.4.1)30 b(Naming)15 b(a)g(F)-5
+b(unction)62 2157 y Fr(The)19 b(user)f(can)g(dynamically)i(c)o(hange)e
+(the)g(bindings)i(of)e(k)o(eys)f(while)j(using)f(Readline.)30
+b(This)19 b(is)g(done)f(b)o(y)0 2219 y(represen)o(ting)f(the)g
+(function)h(with)f(a)g(descriptiv)o(e)h(name.)25 b(The)17
+b(user)g(is)g(able)h(to)e(t)o(yp)q(e)h(the)g(descriptiv)o(e)h(name)0
+2281 y(when)e(referring)f(to)g(the)g(function.)21 b(Th)o(us,)14
+b(in)j(an)e(init)h(\014le,)g(one)f(migh)o(t)g(\014nd)120
+2408 y Fq(Meta-Rubout:)46 b(backward-kill-word)62 2545
+y Fr(This)21 b(binds)f(the)g(k)o(eystrok)o(e)f Fq(META-RUBOUT)f
+Fr(to)h(the)h(function)g Fl(descriptiv)o(ely)26 b Fr(named)20
+b Fq(backward-kill-)0 2608 y(word)p Fr(.)j(Y)l(ou,)16
+b(as)g(the)g(programmer,)f(should)i(bind)h(the)e(functions)i(y)o(ou)d
+(write)i(to)e(descriptiv)o(e)j(names)e(as)g(w)o(ell.)0
+2670 y(Readline)i(pro)o(vides)d(a)g(function)h(for)f(doing)g(that:)p
+eop
+25 26 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(25)1725 183 y(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 183 18 3 v 21 w(add)p 253 183 V 20 w(defun)i
+Fg(\()p Fq(char)14 b(*name,)g(Function)g(*function,)g(int)h(key)p
+Fg(\))120 246 y Fr(Add)20 b Fl(name)i Fr(to)d(the)h(list)g(of)f(named)h
+(functions.)33 b(Mak)o(e)19 b Fl(function)i Fr(b)q(e)f(the)f(function)i
+(that)d(gets)120 308 y(called.)j(If)16 b Fl(k)o(ey)j
+Fr(is)d(not)e(-1,)h(then)h(bind)g(it)g(to)e Fl(function)i
+Fr(using)g Fq(rl_bind_key)e(\(\))p Fr(.)62 471 y(Using)i(this)g
+(function)g(alone)g(is)g(su\016cien)o(t)h(for)d(most)h(applications.)22
+b(It)16 b(is)g(the)f(recommended)i(w)o(a)o(y)d(to)h(add)0
+533 y(a)i(few)h(functions)g(to)f(the)h(default)g(functions)h(that)e
+(Readline)j(has)d(built)i(in.)28 b(If)18 b(y)o(ou)g(need)g(to)f(do)h
+(something)0 595 y(other)c(than)h(adding)h(a)e(function)i(to)e
+(Readline,)j(y)o(ou)d(ma)o(y)g(need)i(to)e(use)h(the)g(underlying)h
+(functions)g(describ)q(ed)0 658 y(b)q(elo)o(w.)0 869
+y Fk(2.4.2)30 b(Selecting)15 b(a)g(Keymap)62 1006 y Fr(Key)k(bindings)i
+(tak)o(e)c(place)j(on)e(a)g Fl(k)o(eymap)p Fr(.)30 b(The)18
+b(k)o(eymap)h(is)g(the)f(asso)q(ciation)h(b)q(et)o(w)o(een)g(the)f(k)o
+(eys)h(that)0 1069 y(the)g(user)g(t)o(yp)q(es)g(and)g(the)g(functions)g
+(that)f(get)h(run.)30 b(Y)l(ou)20 b(can)e(mak)o(e)h(y)o(our)f(o)o(wn)g
+(k)o(eymaps,)h(cop)o(y)g(existing)0 1131 y(k)o(eymaps,)14
+b(and)i(tell)g(Readline)i(whic)o(h)e(k)o(eymap)f(to)f(use.)1725
+1294 y(F)l(unction)-1899 b Fi(Keymap)20 b Fh(rl)p 218
+1294 V 21 w(mak)n(e)p 370 1294 V 20 w(bare)p 500 1294
+V 20 w(k)n(eymap)j Fg(\(\))120 1356 y Fr(Returns)14 b(a)f(new,)g(empt)o
+(y)g(k)o(eymap.)19 b(The)14 b(space)f(for)g(the)h(k)o(eymap)f(is)g
+(allo)q(cated)i(with)e Fq(malloc)i(\(\))p Fr(;)120 1419
+y(y)o(ou)g(should)h Fq(free)f(\(\))g Fr(it)g(when)h(y)o(ou)f(are)f
+(done.)1725 1582 y(F)l(unction)-1899 b Fi(Keymap)20 b
+Fh(rl)p 218 1582 V 21 w(cop)n(y)p 353 1582 V 21 w(k)n(eymap)j
+Fg(\()p Fq(Keymap)14 b(map)p Fg(\))120 1644 y Fr(Return)i(a)f(new)g(k)o
+(eymap)g(whic)o(h)h(is)g(a)f(cop)o(y)g(of)g Fl(map)p
+Fr(.)1725 1807 y(F)l(unction)-1899 b Fi(Keymap)20 b Fh(rl)p
+218 1807 V 21 w(mak)n(e)p 370 1807 V 20 w(k)n(eymap)j
+Fg(\(\))120 1869 y Fr(Return)c(a)f(new)h(k)o(eymap)f(with)h(the)f(prin)
+o(ting)i(c)o(haracters)d(b)q(ound)j(to)e(rl)p 1407 1869
+14 2 v 16 w(insert,)i(the)e(lo)o(w)o(ercase)120 1932
+y(Meta)13 b(c)o(haracters)g(b)q(ound)h(to)f(run)h(their)g(equiv)m(alen)
+o(ts,)i(and)d(the)h(Meta)f(digits)h(b)q(ound)h(to)e(pro)q(duce)120
+1994 y(n)o(umeric)j(argumen)o(ts.)1725 2157 y(F)l(unction)-1899
+b Fi(void)20 b Fh(rl)p 166 2157 18 3 v 21 w(discard)p
+366 2157 V 21 w(k)n(eymap)i Fg(\()p Fq(Keymap)14 b(keymap)p
+Fg(\))120 2219 y Fr(F)l(ree)h(the)h(storage)d(asso)q(ciated)j(with)f
+Fl(k)o(eymap)p Fr(.)62 2382 y(Readline)20 b(has)d(sev)o(eral)h(in)o
+(ternal)g(k)o(eymaps.)26 b(These)18 b(functions)g(allo)o(w)g(y)o(ou)f
+(to)g(c)o(hange)g(whic)o(h)h(k)o(eymap)f(is)0 2445 y(activ)o(e.)1725
+2608 y(F)l(unction)-1899 b Fi(Keymap)20 b Fh(rl)p 218
+2608 V 21 w(get)p 316 2608 V 21 w(k)n(eymap)i Fg(\(\))120
+2670 y Fr(Returns)16 b(the)f(curren)o(tly)h(activ)o(e)f(k)o(eymap.)p
+eop
+26 27 bop 0 -58 a Fr(26)1449 b(GNU)15 b(Readline)i(Library)1725
+183 y(F)l(unction)-1899 b Fi(void)20 b Fh(rl)p 166 183
+18 3 v 21 w(set)p 258 183 V 21 w(k)n(eymap)i Fg(\()p
+Fq(Keymap)14 b(keymap)p Fg(\))120 246 y Fr(Mak)o(es)g
+Fl(k)o(eymap)j Fr(the)e(curren)o(tly)h(activ)o(e)f(k)o(eymap.)1725
+420 y(F)l(unction)-1899 b Fi(Keymap)20 b Fh(rl)p 218
+420 V 21 w(get)p 316 420 V 21 w(k)n(eymap)p 530 420 V
+20 w(b)n(y)p 610 420 V 21 w(name)i Fg(\()p Fq(char)14
+b(*name)p Fg(\))120 482 y Fr(Return)19 b(the)g(k)o(eymap)f(matc)o(hing)
+g Fl(name)p Fr(.)30 b Fl(name)21 b Fr(is)e(one)g(whic)o(h)g(w)o(ould)g
+(b)q(e)g(supplied)i(in)e(a)f Fq(set)120 544 y(keymap)c
+Fr(inputrc)j(line)f(\(see)g(Section)g(1.3)e([Readline)j(Init)f(File],)g
+(page)f(5\).)1725 719 y(F)l(unction)-1899 b Fi(char)20
+b(*)f Fh(rl)p 211 719 V 21 w(get)p 309 719 V 21 w(k)n(eymap)p
+523 719 V 20 w(name)i Fg(\()p Fq(Keymap)14 b(keymap)p
+Fg(\))120 781 y Fr(Return)19 b(the)g(name)f(matc)o(hing)h
+Fl(k)o(eymap)p Fr(.)29 b Fl(name)21 b Fr(is)e(one)g(whic)o(h)g(w)o
+(ould)g(b)q(e)g(supplied)i(in)e(a)f Fq(set)120 843 y(keymap)c
+Fr(inputrc)j(line)f(\(see)g(Section)g(1.3)e([Readline)j(Init)f(File],)g
+(page)f(5\).)0 1088 y Fk(2.4.3)30 b(Binding)15 b(Keys)62
+1229 y Fr(Y)l(ou)h(asso)q(ciate)f(k)o(eys)f(with)i(functions)g(through)
+e(the)i(k)o(eymap.)j(Readline)f(has)c(sev)o(eral)i(in)o(ternal)g(k)o
+(eymaps:)0 1291 y Fq(emacs_standard_keymap)p Fr(,)i Fq
+(emacs_meta_keymap)p Fr(,)g Fq(emacs_ctlx_keymap)p Fr(,)h
+Fq(vi_movement_keymap)p Fr(,)f(and)0 1354 y Fq(vi_insertion_keymap)p
+Fr(.)h Fq(emacs_standard_keymap)13 b Fr(is)k(the)f(default,)g(and)g
+(the)g(examples)h(in)f(this)h(man)o(ual)0 1416 y(assume)e(that.)62
+1557 y(These)h(functions)g(manage)e(k)o(ey)i(bindings.)1725
+1731 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p 140 1731
+V 21 w(bind)p 272 1731 V 21 w(k)n(ey)k Fg(\()p Fq(int)14
+b(key,)h(Function)f(*function)p Fg(\))120 1794 y Fr(Binds)i
+Fl(k)o(ey)j Fr(to)14 b Fl(function)i Fr(in)g(the)f(curren)o(tly)h
+(activ)o(e)f(k)o(eymap.)k(Returns)d(non-zero)f(in)h(the)f(case)g(of)120
+1856 y(an)g(in)o(v)m(alid)j Fl(k)o(ey)p Fr(.)1725 2030
+y(F)l(unction)-1899 b Fi(int)19 b Fh(rl)p 139 2030 V
+21 w(bind)p 271 2030 V 21 w(k)n(ey)p 376 2030 V 21 w(in)p
+444 2030 V 22 w(map)i Fg(\()p Fq(int)14 b(key,)h(Function)f(*function,)
+g(Keymap)g(map)p Fg(\))120 2093 y Fr(Bind)i Fl(k)o(ey)j
+Fr(to)c Fl(function)h Fr(in)g Fl(map)p Fr(.)k(Returns)15
+b(non-zero)h(in)g(the)f(case)g(of)g(an)g(in)o(v)m(alid)j
+Fl(k)o(ey)p Fr(.)1725 2267 y(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 2267 V 21 w(un)n(bind)p 334 2267 V 21 w(k)n(ey)k
+Fg(\()p Fq(int)14 b(key)p Fg(\))120 2329 y Fr(Bind)h
+Fl(k)o(ey)i Fr(to)c(the)h(n)o(ull)h(function)f(in)g(the)g(curren)o(tly)
+g(activ)o(e)g(k)o(eymap.)19 b(Returns)14 b(non-zero)g(in)g(case)120
+2391 y(of)h(error.)1725 2566 y(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 2566 V 21 w(un)n(bind)p 334 2566 V 21 w(k)n(ey)p
+439 2566 V 21 w(in)p 507 2566 V 22 w(map)h Fg(\()p Fq(int)14
+b(key,)h(Keymap)f(map)p Fg(\))120 2628 y Fr(Bind)i Fl(k)o(ey)j
+Fr(to)c(the)g(n)o(ull)i(function)f(in)g Fl(map)p Fr(.)k(Returns)15
+b(non-zero)h(in)g(case)f(of)g(error.)p eop
+27 28 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(27)1725 183 y(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 183 18 3 v 21 w(generic)p 338 183 V 21
+w(bind)j Fg(\()p Fq(int)15 b(type,)f(char)h(*keyseq,)f(char)h(*data,)f
+(Keymap)208 246 y(map)p Fg(\))120 308 y Fr(Bind)j(the)f(k)o(ey)g
+(sequence)h(represen)o(ted)f(b)o(y)g(the)g(string)g Fl(k)o(eyseq)g
+Fr(to)g(the)f(arbitrary)h(p)q(oin)o(ter)g Fl(data)p Fr(.)120
+370 y Fl(t)o(yp)q(e)j Fr(sa)o(ys)c(what)g(kind)i(of)f(data)f(is)i(p)q
+(oin)o(ted)g(to)e(b)o(y)h Fl(data)p Fr(;)f(this)i(can)f(b)q(e)g(a)g
+(function)h(\()p Fq(ISFUNC)p Fr(\),)d(a)120 432 y(macro)i(\()p
+Fq(ISMACR)p Fr(\),)f(or)i(a)f(k)o(eymap)g(\()p Fq(ISKMAP)p
+Fr(\).)23 b(This)18 b(mak)o(es)e(new)h(k)o(eymaps)f(as)h(necessary)l(.)
+25 b(The)120 495 y(initial)17 b(k)o(eymap)e(in)h(whic)o(h)g(to)f(do)g
+(bindings)i(is)f Fl(map)p Fr(.)1725 683 y(F)l(unction)-1899
+b Fi(int)20 b Fh(rl)p 140 683 V 21 w(parse)p 294 683
+V 19 w(and)p 405 683 V 21 w(bind)j Fg(\()p Fq(char)14
+b(*line)p Fg(\))120 745 y Fr(P)o(arse)i Fl(line)21 b
+Fr(as)16 b(if)h(it)g(had)f(b)q(een)i(read)f(from)e(the)i
+Fq(inputrc)f Fr(\014le)h(and)g(p)q(erform)f(an)o(y)h(k)o(ey)f(bindings)
+120 808 y(and)f(v)m(ariable)i(assignmen)o(ts)e(found)h(\(see)f(Section)
+h(1.3)e([Readline)j(Init)f(File],)g(page)f(5\).)1725
+996 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p 140 996
+V 21 w(read)p 271 996 V 20 w(init)p 375 996 V 22 w(\014le)k
+Fg(\()p Fq(char)14 b(*filename)p Fg(\))120 1059 y Fr(Read)19
+b(k)o(eybindings)i(and)e(v)m(ariable)h(assignmen)o(ts)f(from)f
+Fl(\014lename)k Fr(\(see)d(Section)g(1.3)f([Readline)120
+1121 y(Init)e(File],)g(page)f(5\).)0 1409 y Fk(2.4.4)30
+b(Asso)r(ciating)15 b(F)-5 b(unction)15 b(Names)g(and)g(Bindings)62
+1554 y Fr(These)22 b(functions)g(allo)o(w)g(y)o(ou)f(to)f(\014nd)i(out)
+f(what)g(k)o(eys)g(in)o(v)o(ok)o(e)h(named)f(functions)h(and)g(the)f
+(functions)0 1617 y(in)o(v)o(ok)o(ed)15 b(b)o(y)h(a)e(particular)i(k)o
+(ey)f(sequence.)1725 1805 y(F)l(unction)-1899 b Fi(Function)20
+b(*)g Fh(rl)p 316 1805 V 21 w(named)p 504 1805 V 19 w(function)j
+Fg(\()p Fq(char)14 b(*name)p Fg(\))120 1868 y Fr(Return)i(the)f
+(function)h(with)g(name)f Fl(name)p Fr(.)1725 2056 y(F)l(unction)-1899
+b Fi(Function)20 b(*)g Fh(rl)p 316 2056 V 21 w(function)p
+542 2056 V 21 w(of)p 610 2056 V 19 w(k)n(eyseq)k Fg(\()p
+Fq(char)15 b(*keyseq,)f(Keymap)g(map,)h(int)208 2118
+y(*type)p Fg(\))120 2181 y Fr(Return)i(the)f(function)h(in)o(v)o(ok)o
+(ed)g(b)o(y)f Fl(k)o(eyseq)i Fr(in)f(k)o(eymap)f Fl(map)p
+Fr(.)23 b(If)16 b Fl(map)i Fr(is)f(NULL,)g(the)f(curren)o(t)120
+2243 y(k)o(eymap)g(is)i(used.)25 b(If)17 b Fl(t)o(yp)q(e)i
+Fr(is)e(not)g(NULL,)g(the)g(t)o(yp)q(e)g(of)f(the)h(ob)s(ject)f(is)h
+(returned)g(in)h(it)f(\(one)f(of)120 2305 y Fq(ISFUNC)p
+Fr(,)e Fq(ISKMAP)p Fr(,)g(or)h Fq(ISMACR)p Fr(\).)1725
+2494 y(F)l(unction)-1899 b Fi(char)20 b(**)f Fh(rl)p
+237 2494 V 21 w(in)n(v)n(oking)p 466 2494 V 23 w(k)n(eyseqs)k
+Fg(\()p Fq(Function)14 b(*function)p Fg(\))120 2556 y
+Fr(Return)19 b(an)e(arra)o(y)g(of)h(strings)f(represen)o(ting)i(the)f
+(k)o(ey)g(sequences)h(used)f(to)f(in)o(v)o(ok)o(e)h Fl(function)h
+Fr(in)120 2618 y(the)c(curren)o(t)g(k)o(eymap.)p eop
+28 29 bop 0 -58 a Fr(28)1449 b(GNU)15 b(Readline)i(Library)1725
+183 y(F)l(unction)-1899 b Fi(char)20 b(**)f Fh(rl)p 237
+183 18 3 v 21 w(in)n(v)n(oking)p 466 183 V 23 w(k)n(eyseqs)p
+675 183 V 21 w(in)p 743 183 V 22 w(map)i Fg(\()p Fq(Function)14
+b(*function,)f(Keymap)208 246 y(map)p Fg(\))120 308 y
+Fr(Return)19 b(an)e(arra)o(y)g(of)h(strings)f(represen)o(ting)i(the)f
+(k)o(ey)g(sequences)h(used)f(to)f(in)o(v)o(ok)o(e)h Fl(function)h
+Fr(in)120 370 y(the)c(k)o(eymap)g Fl(map)p Fr(.)1725
+563 y(F)l(unction)-1899 b Fi(void)20 b Fh(rl)p 166 563
+V 21 w(function)p 392 563 V 21 w(dump)r(er)g Fg(\()p
+Fq(int)15 b(readable)p Fg(\))120 625 y Fr(Prin)o(t)i(the)g(readline)h
+(function)g(names)f(and)g(the)g(k)o(ey)g(sequences)h(curren)o(tly)g(b)q
+(ound)f(to)g(them)g(to)120 687 y Fq(rl_outstream)p Fr(.)j(If)c
+Fl(readable)j Fr(is)d(non-zero,)g(the)g(list)g(is)g(formatted)f(in)i
+(suc)o(h)f(a)f(w)o(a)o(y)g(that)g(it)h(can)120 750 y(b)q(e)g(made)f
+(part)g(of)f(an)i Fq(inputrc)e Fr(\014le)i(and)f(re-read.)1725
+942 y(F)l(unction)-1899 b Fi(void)20 b Fh(rl)p 166 942
+V 21 w(list)p 262 942 V 22 w(funmap)p 475 942 V 18 w(names)h
+Fg(\(\))120 1005 y Fr(Prin)o(t)15 b(the)g(names)h(of)e(all)j(bindable)g
+(Readline)g(functions)f(to)f Fq(rl_outstream)p Fr(.)0
+1305 y Fk(2.4.5)30 b(Allo)n(wing)16 b(Undoing)62 1452
+y Fr(Supp)q(orting)f(the)f(undo)g(command)g(is)g(a)g(painless)h(thing,)
+f(and)g(mak)o(es)f(y)o(our)h(functions)g(m)o(uc)o(h)g(more)f(useful.)0
+1515 y(It)i(is)g(certainly)g(easy)f(to)g(try)g(something)h(if)g(y)o(ou)
+f(kno)o(w)g(y)o(ou)g(can)h(undo)g(it.)20 b(I)15 b(could)g(use)g(an)f
+(undo)h(function)h(for)0 1577 y(the)f(sto)q(c)o(k)g(mark)o(et.)62
+1724 y(If)h(y)o(our)f(function)i(simply)g(inserts)f(text)f(once,)h(or)f
+(deletes)h(text)f(once,)h(and)g(uses)g Fq(rl_insert_text)d(\(\))i
+Fr(or)0 1786 y Fq(rl_delete_text)e(\(\))i Fr(to)g(do)g(it,)g(then)g
+(undoing)i(is)e(already)h(done)f(for)g(y)o(ou)g(automatically)l(.)62
+1934 y(If)h(y)o(ou)f(do)g(m)o(ultiple)i(insertions)f(or)f(m)o(ultiple)i
+(deletions,)f(or)f(an)o(y)g(com)o(bination)h(of)f(these)g(op)q
+(erations,)g(y)o(ou)0 1996 y(should)j(group)e(them)g(together)g(in)o
+(to)g(one)h(op)q(eration.)24 b(This)17 b(is)g(done)g(with)g
+Fq(rl_begin_undo_group)c(\(\))j Fr(and)0 2058 y Fq(rl_end_undo_group)d
+(\(\))p Fr(.)62 2206 y(The)j(t)o(yp)q(es)f(of)g(ev)o(en)o(ts)g(that)f
+(can)h(b)q(e)h(undone)g(are:)120 2343 y Fq(enum)23 b(undo_code)g({)h
+(UNDO_DELETE,)e(UNDO_INSERT,)g(UNDO_BEGIN,)g(UNDO_END)h(};)62
+2490 y Fr(Notice)c(that)e Fq(UNDO_DELETE)f Fr(means)i(to)f(insert)i
+(some)e(text,)h(and)g Fq(UNDO_INSERT)e Fr(means)i(to)f(delete)i(some)0
+2552 y(text.)37 b(That)21 b(is,)i(the)e(undo)h(co)q(de)f(tells)i(undo)e
+(what)g(to)f(undo,)j(not)e(ho)o(w)g(to)f(undo)i(it.)38
+b Fq(UNDO_BEGIN)20 b Fr(and)0 2614 y Fq(UNDO_END)14 b
+Fr(are)h(tags)f(added)i(b)o(y)f Fq(rl_begin_undo_group)e(\(\))i
+Fr(and)g Fq(rl_end_undo_group)e(\(\))p Fr(.)p eop
+29 30 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(29)1725 183 y(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 183 18 3 v 21 w(b)r(egin)p 297 183 V 20
+w(undo)p 442 183 V 20 w(group)h Fg(\(\))120 246 y Fr(Begins)e(sa)o
+(ving)e(undo)i(information)f(in)g(a)g(group)f(construct.)27
+b(The)18 b(undo)h(information)f(usually)120 308 y(comes)j(from)f(calls)
+h(to)g Fq(rl_insert_text)13 b(\(\))20 b Fr(and)h Fq(rl_delete_text)13
+b(\(\))p Fr(,)22 b(but)f(could)g(b)q(e)h(the)120 370
+y(result)16 b(of)e(calls)j(to)d Fq(rl_add_undo)g(\(\))p
+Fr(.)1725 541 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p
+140 541 V 21 w(end)p 251 541 V 20 w(undo)p 396 541 V
+20 w(group)h Fg(\(\))120 603 y Fr(Closes)d(the)f(curren)o(t)g(undo)h
+(group)f(started)g(with)h Fq(rl_begin_undo_group)12 b(\(\))p
+Fr(.)26 b(There)18 b(should)120 665 y(b)q(e)e(one)f(call)i(to)d
+Fq(rl_end_undo_group)f(\(\))i Fr(for)f(eac)o(h)i(call)g(to)f
+Fq(rl_begin_undo_group)d(\(\))p Fr(.)1725 836 y(F)l(unction)-1899
+b Fi(void)20 b Fh(rl)p 166 836 V 21 w(add)p 279 836 V
+20 w(undo)i Fg(\()p Fq(enum)14 b(undo_code)g(what,)g(int)h(start,)g
+(int)f(end,)h(char)208 898 y(*text)p Fg(\))120 960 y
+Fr(Remem)o(b)q(er)20 b(ho)o(w)e(to)h(undo)g(an)g(ev)o(en)o(t)g
+(\(according)g(to)g Fl(what)q Fr(\).)30 b(The)19 b(a\013ected)g(text)f
+(runs)i(from)120 1023 y Fl(start)15 b Fr(to)g Fl(end)p
+Fr(,)g(and)g(encompasses)h Fl(text)p Fr(.)1725 1193 y(F)l(unction)-1899
+b Fi(void)20 b Fh(free)p 221 1193 V 20 w(undo)p 366 1193
+V 20 w(list)k Fg(\(\))120 1256 y Fr(F)l(ree)15 b(the)h(existing)g(undo)
+f(list.)1725 1426 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p
+140 1426 V 21 w(do)p 222 1426 V 20 w(undo)i Fg(\(\))120
+1488 y Fr(Undo)14 b(the)f(\014rst)g(thing)h(on)g(the)f(undo)h(list.)20
+b(Returns)14 b Fq(0)f Fr(if)h(there)g(w)o(as)e(nothing)i(to)f(undo,)h
+(non-zero)120 1551 y(if)i(something)f(w)o(as)f(undone.)62
+1721 y(Finally)l(,)j(if)f(y)o(ou)f(neither)i(insert)f(nor)f(delete)i
+(text,)d(but)i(directly)h(mo)q(dify)f(the)f(existing)i(text)e(\(e.g.,)f
+(c)o(hange)0 1784 y(its)g(case\),)f(call)i Fq(rl_modifying)e(\(\))g
+Fr(once,)h(just)f(b)q(efore)h(y)o(ou)f(mo)q(dify)h(the)g(text.)19
+b(Y)l(ou)14 b(m)o(ust)f(supply)h(the)g(indices)0 1846
+y(of)h(the)g(text)g(range)g(that)f(y)o(ou)h(are)g(going)g(to)g(mo)q
+(dify)l(.)1725 2017 y(F)l(unction)-1899 b Fi(int)20 b
+Fh(rl)p 140 2017 V 21 w(mo)r(difying)h Fg(\()p Fq(int)15
+b(start,)f(int)h(end)p Fg(\))120 2079 y Fr(T)l(ell)e(Readline)g(to)e
+(sa)o(v)o(e)f(the)i(text)f(b)q(et)o(w)o(een)g Fl(start)g
+Fr(and)h Fl(end)h Fr(as)e(a)g(single)i(undo)e(unit.)20
+b(It)11 b(is)h(assumed)120 2141 y(that)i(y)o(ou)h(will)i(subsequen)o
+(tly)g(mo)q(dify)e(that)g(text.)0 2375 y Fk(2.4.6)30
+b(Redispla)n(y)1725 2545 y Fr(F)l(unction)-1899 b Fi(void)20
+b Fh(rl)p 166 2545 V 21 w(redispla)n(y)k Fg(\(\))120
+2608 y Fr(Change)d(what's)g(displa)o(y)o(ed)h(on)g(the)f(screen)h(to)f
+(re\015ect)h(the)f(curren)o(t)g(con)o(ten)o(ts)g(of)g
+Fq(rl_line_)120 2670 y(buffer)p Fr(.)p eop
+30 31 bop 0 -58 a Fr(30)1449 b(GNU)15 b(Readline)i(Library)1725
+183 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p 140 183
+18 3 v 21 w(forced)p 315 183 V 20 w(up)r(date)p 509 183
+V 20 w(displa)n(y)k Fg(\(\))120 246 y Fr(F)l(orce)12
+b(the)g(line)h(to)f(b)q(e)g(up)q(dated)h(and)f(redispla)o(y)o(ed,)i
+(whether)e(or)f(not)h(Readline)i(thinks)e(the)g(screen)120
+308 y(displa)o(y)k(is)g(correct.)1725 462 y(F)l(unction)-1899
+b Fi(int)20 b Fh(rl)p 140 462 V 21 w(on)p 222 462 V 20
+w(new)p 341 462 V 21 w(line)k Fg(\(\))120 524 y Fr(T)l(ell)c(the)f(up)q
+(date)g(routines)g(that)f(w)o(e)g(ha)o(v)o(e)g(mo)o(v)o(ed)g(on)o(to)g
+(a)g(new)h(\(empt)o(y\))e(line,)k(usually)f(after)120
+587 y(ouputting)c(a)e(newline.)1725 741 y(F)l(unction)-1899
+b Fi(int)20 b Fh(rl)p 140 741 V 21 w(reset)p 282 741
+V 20 w(line)p 390 741 V 23 w(state)j Fg(\(\))120 803
+y Fr(Reset)14 b(the)f(displa)o(y)h(state)f(to)f(a)h(clean)h(state)f
+(and)g(redispla)o(y)i(the)e(curren)o(t)g(line)i(starting)e(on)g(a)g
+(new)120 866 y(line.)1725 1020 y(F)l(unction)-1899 b
+Fi(int)20 b Fh(rl)p 140 1020 V 21 w(message)g Fg(\()p
+Fq(va_alist)p Fg(\))120 1082 y Fr(The)f(argumen)o(ts)e(are)h(a)g
+(string)g(as)g(w)o(ould)h(b)q(e)g(supplied)i(to)d Fq(printf)p
+Fr(.)28 b(The)19 b(resulting)g(string)f(is)120 1145 y(displa)o(y)o(ed)h
+(in)f(the)g Fl(ec)o(ho)f(area)p Fr(.)27 b(The)18 b(ec)o(ho)f(area)g(is)
+h(also)g(used)g(to)f(displa)o(y)h(n)o(umeric)h(argumen)o(ts)120
+1207 y(and)c(searc)o(h)g(strings.)1725 1361 y(F)l(unction)-1899
+b Fi(int)20 b Fh(rl)p 140 1361 V 21 w(clear)p 279 1361
+V 21 w(message)h Fg(\(\))120 1424 y Fr(Clear)15 b(the)h(message)e(in)i
+(the)g(ec)o(ho)f(area.)0 1616 y Fk(2.4.7)30 b(Mo)r(difying)15
+b(T)-5 b(ext)1725 1771 y Fr(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 1771 V 21 w(insert)p 303 1771 V 21 w(text)k
+Fg(\()p Fq(char)14 b(*text)p Fg(\))120 1833 y Fr(Insert)h
+Fl(text)h Fr(in)o(to)f(the)h(line)g(at)f(the)g(curren)o(t)g(cursor)g(p)
+q(osition.)1725 1988 y(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 1988 V 21 w(delete)p 308 1988 V 22 w(text)k
+Fg(\()p Fq(int)14 b(start,)h(int)f(end)p Fg(\))120 2050
+y Fr(Delete)i(the)f(text)g(b)q(et)o(w)o(een)g Fl(start)g
+Fr(and)h Fl(end)h Fr(in)f(the)g(curren)o(t)f(line.)1725
+2204 y(F)l(unction)-1899 b Fi(char)20 b(*)f Fh(rl)p 211
+2204 V 21 w(cop)n(y)p 346 2204 V 21 w(text)24 b Fg(\()p
+Fq(int)14 b(start,)h(int)g(end)p Fg(\))120 2266 y Fr(Return)h(a)f(cop)o
+(y)g(of)g(the)g(text)f(b)q(et)o(w)o(een)i Fl(start)f
+Fr(and)g Fl(end)j Fr(in)e(the)f(curren)o(t)g(line.)1725
+2421 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p 140 2421
+V 21 w(kill)p 236 2421 V 23 w(text)k Fg(\()p Fq(int)14
+b(start,)h(int)g(end)p Fg(\))120 2483 y Fr(Cop)o(y)k(the)g(text)f(b)q
+(et)o(w)o(een)i Fl(start)e Fr(and)i Fl(end)h Fr(in)f(the)f(curren)o(t)g
+(line)i(to)d(the)h(kill)i(ring,)f(app)q(ending)120 2545
+y(or)e(prep)q(ending)j(to)d(the)h(last)f(kill)j(if)e(the)g(last)f
+(command)h(w)o(as)e(a)i(kill)h(command.)30 b(The)19 b(text)f(is)120
+2608 y(deleted.)j(If)13 b Fl(start)g Fr(is)h(less)f(than)h
+Fl(end)p Fr(,)f(the)h(text)e(is)i(app)q(ended,)h(otherwise)e(prep)q
+(ended.)21 b(If)14 b(the)f(last)120 2670 y(command)i(w)o(as)f(not)h(a)g
+(kill,)i(a)e(new)g(kill)i(ring)f(slot)f(is)g(used.)p
+eop
+31 32 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(31)0 183 y Fk(2.4.8)30 b(Utilit)n(y)16
+b(F)-5 b(unctions)1725 345 y Fr(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 345 18 3 v 21 w(read)p 271 345 V 20 w(k)n(ey)k
+Fg(\(\))120 407 y Fr(Return)14 b(the)g(next)g(c)o(haracter)f(a)o(v)m
+(ailable.)21 b(This)15 b(handles)g(input)g(inserted)f(in)o(to)g(the)g
+(input)h(stream)120 469 y(via)h Fl(p)q(ending)i(input)h
+Fr(\(see)d(Section)h(2.3)e([Readline)j(V)l(ariables],)f(page)f(22\))f
+(and)i Fq(rl_stuff_char)120 532 y(\(\))p Fr(,)e(macros,)f(and)h(c)o
+(haracters)f(read)h(from)g(the)g(k)o(eyb)q(oard.)1725
+693 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p 140 693
+V 21 w(getc)j Fg(\()p Fq(FILE)14 b(*)p Fg(\))120 755
+y Fr(Return)i(the)f(next)g(c)o(haracter)g(a)o(v)m(ailable)i(from)d(the)
+h(k)o(eyb)q(oard.)1725 917 y(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 917 V 21 w(stu\013)p 271 917 V 20 w(c)n(har)j
+Fg(\()p Fq(int)15 b(c)p Fg(\))120 979 y Fr(Insert)g Fl(c)i
+Fr(in)o(to)e(the)g(Readline)i(input)e(stream.)k(It)c(will)h(b)q(e)g
+Fq(")p Fr(read)p Fq(")e Fr(b)q(efore)h(Readline)i(attempts)d(to)120
+1041 y(read)h(c)o(haracters)g(from)f(the)h(terminal)h(with)g
+Fq(rl_read_key)d(\(\))p Fr(.)1725 1203 y(F)l(unction)-1899
+b Fi(rl_extend_line_buffer)22 b Fh(\(in)n(t)j Fq(len)p
+Fg(\))120 1265 y Fr(Ensure)15 b(that)f Fq(rl_line_buffer)e
+Fr(has)j(enough)g(space)g(to)e(hold)j Fl(len)f Fr(c)o(haracters,)f(p)q
+(ossibly)i(reallo-)120 1327 y(cating)f(it)h(if)f(necessary)l(.)1725
+1489 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p 140 1489
+V 21 w(initiali)q(z)q(e)26 b Fg(\(\))120 1551 y Fr(Initialize)18
+b(or)d(re-initialize)j(Readline's)f(in)o(ternal)f(state.)1725
+1713 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p 140 1713
+V 21 w(reset)p 282 1713 V 20 w(terminal)j Fg(\()p Fq(char)15
+b(*terminal_name)p Fg(\))120 1775 y Fr(Reinitializ)q(e)f(Readline's)e
+(idea)g(of)e(the)h(terminal)h(settings)f(using)g Fl(terminal)p
+1404 1775 14 2 v 17 w(name)j Fr(as)c(the)h(terminal)120
+1837 y(t)o(yp)q(e)k(\(e.g.,)f Fq(vt100)p Fr(\).)1725
+1999 y(F)l(unction)-1899 b Fi(int)20 b Fh(alphab)r(etic)k
+Fg(\()p Fq(int)14 b(c)p Fg(\))120 2061 y Fr(Return)i(1)f(if)g
+Fl(c)j Fr(is)e(an)f(alphab)q(etic)i(c)o(haracter.)1725
+2222 y(F)l(unction)-1899 b Fi(int)20 b Fh(n)n(umeric)i
+Fg(\()p Fq(int)15 b(c)p Fg(\))120 2285 y Fr(Return)h(1)f(if)g
+Fl(c)j Fr(is)e(a)f(n)o(umeric)h(c)o(haracter.)1725 2446
+y(F)l(unction)-1899 b Fi(int)20 b Fh(ding)i Fg(\(\))120
+2508 y Fr(Ring)16 b(the)f(terminal)h(b)q(ell,)h(ob)q(eying)f(the)g
+(setting)f(of)g Fq(bell-style)p Fr(.)62 2670 y(The)h(follo)o(wing)g
+(are)f(implemen)o(ted)h(as)f(macros,)f(de\014ned)j(in)f
+Fq(chartypes.h)p Fr(.)p eop
+32 33 bop 0 -58 a Fr(32)1449 b(GNU)15 b(Readline)i(Library)1725
+183 y(F)l(unction)-1899 b Fi(int)20 b Fh(upp)r(ercase)p
+351 183 18 3 v 19 w(p)j Fg(\()p Fq(int)14 b(c)p Fg(\))120
+246 y Fr(Return)i(1)f(if)g Fl(c)j Fr(is)e(an)f(upp)q(ercase)i(alphab)q
+(etic)f(c)o(haracter.)1725 409 y(F)l(unction)-1899 b
+Fi(int)20 b Fh(lo)n(w)n(ercase)p 334 409 V 22 w(p)i Fg(\()p
+Fq(int)15 b(c)p Fg(\))120 471 y Fr(Return)h(1)f(if)g
+Fl(c)j Fr(is)e(a)f(lo)o(w)o(ercase)g(alphab)q(etic)i(c)o(haracter.)1725
+634 y(F)l(unction)-1899 b Fi(int)20 b Fh(digit)p 214
+634 V 22 w(p)i Fg(\()p Fq(int)15 b(c)p Fg(\))120 696
+y Fr(Return)h(1)f(if)g Fl(c)j Fr(is)e(a)f(n)o(umeric)h(c)o(haracter.)
+1725 859 y(F)l(unction)-1899 b Fi(int)20 b Fh(to)p 152
+859 V 20 w(upp)r(er)i Fg(\()p Fq(int)14 b(c)p Fg(\))120
+922 y Fr(If)h Fl(c)i Fr(is)f(a)e(lo)o(w)o(ercase)g(alphab)q(etic)j(c)o
+(haracter,)c(return)i(the)g(corresp)q(onding)g(upp)q(ercase)h(c)o
+(haracter.)1725 1085 y(F)l(unction)-1899 b Fi(int)20
+b Fh(to)p 152 1085 V 20 w(lo)n(w)n(er)k Fg(\()p Fq(int)15
+b(c)p Fg(\))120 1147 y Fr(If)e Fl(c)i Fr(is)e(an)f(upp)q(ercase)h
+(alphab)q(etic)h(c)o(haracter,)e(return)g(the)h(corresp)q(onding)g(lo)o
+(w)o(ercase)f(c)o(haracter.)1725 1310 y(F)l(unction)-1899
+b Fi(int)20 b Fh(digit)p 214 1310 V 22 w(v)m(alue)j Fg(\()p
+Fq(int)15 b(c)p Fg(\))120 1372 y Fr(If)g Fl(c)k Fr(is)c(a)g(n)o(um)o(b)
+q(er,)g(return)g(the)h(v)m(alue)g(it)g(represen)o(ts.)0
+1584 y Fk(2.4.9)30 b(Alternate)15 b(In)n(terface)62 1721
+y Fr(An)k(alternate)e(in)o(terface)h(is)h(a)o(v)m(ailable)h(to)d(plain)
+i Fq(readline\(\))p Fr(.)27 b(Some)18 b(applications)h(need)g(to)e(in)o
+(terlea)o(v)o(e)0 1783 y(k)o(eyb)q(oard)d(I/O)h(with)f(\014le,)h
+(device,)h(or)d(windo)o(w)i(system)e(I/O,)i(t)o(ypically)g(b)o(y)f
+(using)h(a)f(main)h(lo)q(op)g(to)e Fq(select\(\))0 1846
+y Fr(on)k(v)m(arious)h(\014le)g(descriptors.)26 b(T)l(o)17
+b(accomo)q(date)g(this)h(need,)g(readline)h(can)e(also)h(b)q(e)f(in)o
+(v)o(ok)o(ed)h(as)f(a)g(`callbac)o(k')0 1908 y(function)f(from)e(an)i
+(ev)o(en)o(t)f(lo)q(op.)20 b(There)15 b(are)g(functions)h(a)o(v)m
+(ailable)h(to)e(mak)o(e)f(this)i(easy)l(.)1725 2071 y(F)l(unction)-1899
+b Fi(void)20 b Fh(rl)p 166 2071 V 21 w(callbac)n(k)p
+383 2071 V 23 w(handler)p 595 2071 V 21 w(install)25
+b Fg(\()p Fq(char)14 b(*prompt,)g(Vfunction)208 2133
+y(*lhandler)p Fg(\))120 2196 y Fr(Set)h(up)g(the)f(terminal)i(for)d
+(readline)k(I/O)e(and)f(displa)o(y)i(the)f(initial)h(expanded)g(v)m
+(alue)g(of)e Fl(prompt)p Fr(.)120 2258 y(Sa)o(v)o(e)h(the)f(v)m(alue)j
+(of)d Fl(lhandler)20 b Fr(to)14 b(use)h(as)g(a)g(callbac)o(k)h(when)f
+(a)f(complete)i(line)h(of)d(input)i(has)f(b)q(een)120
+2320 y(en)o(tered.)1725 2483 y(F)l(unction)-1899 b Fi(void)20
+b Fh(rl)p 166 2483 V 21 w(callbac)n(k)p 383 2483 V 23
+w(read)p 516 2483 V 20 w(c)n(har)j Fg(\(\))120 2545 y
+Fr(Whenev)o(er)d(an)f(application)i(determines)g(that)e(k)o(eyb)q(oard)
+g(input)i(is)f(a)o(v)m(ailable,)i(it)d(should)i(call)120
+2608 y Fq(rl_callback_read_char\(\))p Fr(,)11 b(whic)o(h)j(will)i(read)
+e(the)g(next)g(c)o(haracter)f(from)g(the)h(curren)o(t)g(input)120
+2670 y(source.)24 b(If)17 b(that)f(c)o(haracter)g(completes)i(the)f
+(line,)h Fq(rl_callback_read_char)c Fr(will)k(in)o(v)o(ok)o(e)f(the)p
+eop
+33 34 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(33)120 183 y Fl(lhandler)19 b Fr(function)d(sa)o(v)o
+(ed)e(b)o(y)g Fq(rl_callback_handler_install)d Fr(to)j(pro)q(cess)h
+(the)f(line.)21 b Fq(EOF)14 b Fr(is)120 246 y(indicated)j(b)o(y)e
+(calling)i Fl(lhandler)j Fr(with)c(a)f Fq(NULL)f Fr(line.)1725
+413 y(F)l(unction)-1899 b Fi(void)20 b Fh(rl)p 166 413
+18 3 v 21 w(callbac)n(k)p 383 413 V 23 w(handler)p 595
+413 V 21 w(remo)n(v)n(e)i Fg(\(\))120 476 y Fr(Restore)12
+b(the)g(terminal)h(to)e(its)i(initial)h(state)d(and)h(remo)o(v)o(e)g
+(the)g(line)i(handler.)20 b(This)12 b(ma)o(y)g(b)q(e)g(called)120
+538 y(from)i(within)j(a)e(callbac)o(k)h(as)f(w)o(ell)h(as)f(indep)q
+(enden)o(tly)l(.)0 763 y Fk(2.4.10)29 b(An)16 b(Example)62
+902 y Fr(Here)d(is)g(a)f(function)h(whic)o(h)g(c)o(hanges)g(lo)o(w)o
+(ercase)f(c)o(haracters)f(to)h(their)h(upp)q(ercase)g(equiv)m(alen)o
+(ts,)h(and)f(upp)q(er-)0 964 y(case)j(c)o(haracters)g(to)g(lo)o(w)o
+(ercase.)23 b(If)16 b(this)h(function)g(w)o(as)f(b)q(ound)h(to)f(`)p
+Fq(M-c)p Fr(',)f(then)h(t)o(yping)h(`)p Fq(M-c)p Fr(')e(w)o(ould)i(c)o
+(hange)0 1026 y(the)g(case)f(of)g(the)h(c)o(haracter)f(under)h(p)q(oin)
+o(t.)25 b(T)o(yping)17 b(`)p Fq(M-1)d(0)h(M-c)p Fr(')h(w)o(ould)h(c)o
+(hange)f(the)h(case)f(of)h(the)f(follo)o(wing)0 1089
+y(10)f(c)o(haracters,)f(lea)o(ving)i(the)f(cursor)g(on)g(the)g(last)g
+(c)o(haracter)g(c)o(hanged.)120 1217 y Fq(/*)24 b(Invert)f(the)g(case)g
+(of)h(the)f(COUNT)h(following)e(characters.)h(*/)120
+1269 y(int)120 1321 y(invert_case_line)f(\(count,)h(key\))239
+1373 y(int)h(count,)f(key;)120 1425 y({)168 1477 y(register)f(int)i
+(start,)f(end,)g(i;)168 1580 y(start)g(=)h(rl_point;)168
+1684 y(if)f(\(rl_point)g(>=)h(rl_end\))215 1736 y(return)f(\(0\);)168
+1840 y(if)g(\(count)g(<)h(0\))215 1892 y({)263 1944 y(direction)f(=)h
+(-1;)263 1995 y(count)f(=)h(-count;)215 2047 y(})168
+2099 y(else)215 2151 y(direction)f(=)h(1;)168 2255 y(/*)f(Find)h(the)f
+(end)h(of)f(the)h(range)f(to)g(modify.)g(*/)168 2307
+y(end)g(=)h(start)f(+)h(\(count)f(*)h(direction\);)168
+2411 y(/*)f(Force)g(it)h(to)g(be)f(within)g(range.)g(*/)168
+2462 y(if)g(\(end)h(>)f(rl_end\))215 2514 y(end)h(=)g(rl_end;)168
+2566 y(else)f(if)h(\(end)f(<)h(0\))215 2618 y(end)g(=)g(0;)p
+eop
+34 35 bop 0 -58 a Fr(34)1449 b(GNU)15 b(Readline)i(Library)168
+183 y Fq(if)23 b(\(start)g(==)h(end\))215 235 y(return)f(\(0\);)168
+339 y(if)g(\(start)g(>)h(end\))215 391 y({)263 443 y(int)g(temp)f(=)h
+(start;)263 495 y(start)f(=)h(end;)263 546 y(end)g(=)f(temp;)215
+598 y(})168 702 y(/*)g(Tell)h(readline)e(that)i(we)f(are)h(modifying)e
+(the)i(line,)f(so)h(it)f(will)h(save)239 754 y(the)g(undo)f
+(information.)f(*/)168 806 y(rl_modifying)g(\(start,)h(end\);)168
+910 y(for)g(\(i)h(=)f(start;)h(i)f(!=)h(end;)f(i++\))215
+962 y({)263 1013 y(if)h(\(uppercase_p)e(\(rl_line_buffer[i]\)\))311
+1065 y(rl_line_buffer[i])f(=)j(to_lower)f(\(rl_line_buffer[i]\);)263
+1117 y(else)g(if)h(\(lowercase_p)e(\(rl_line_buffer[i]\)\))311
+1169 y(rl_line_buffer[i])f(=)j(to_upper)f(\(rl_line_buffer[i]\);)215
+1221 y(})168 1273 y(/*)g(Move)h(point)f(to)g(on)h(top)f(of)h(the)f
+(last)h(character)e(changed.)h(*/)168 1325 y(rl_point)f(=)i
+(\(direction)f(==)g(1\))h(?)g(end)f(-)h(1)g(:)f(start;)168
+1377 y(return)g(\(0\);)120 1429 y(})0 1670 y Fp(2.5)33
+b(Custom)14 b(Completers)62 1809 y Fr(T)o(ypically)l(,)g(a)c(program)g
+(that)h(reads)g(commands)g(from)f(the)h(user)h(has)e(a)h(w)o(a)o(y)f
+(of)h(disam)o(biguating)h(commands)0 1871 y(and)k(data.)k(If)c(y)o(our)
+f(program)g(is)h(one)g(of)f(these,)h(then)g(it)g(can)g(pro)o(vide)g
+(completion)g(for)g(commands,)f(data,)f(or)0 1933 y(b)q(oth.)28
+b(The)18 b(follo)o(wing)h(sections)f(describ)q(e)h(ho)o(w)f(y)o(our)f
+(program)g(and)h(Readline)i(co)q(op)q(erate)e(to)f(pro)o(vide)i(this)0
+1995 y(service.)0 2220 y Fk(2.5.1)30 b(Ho)n(w)15 b(Completing)g(W)-5
+b(orks)62 2359 y Fr(In)16 b(order)f(to)g(complete)h(some)f(text,)f(the)
+h(full)i(list)f(of)f(p)q(ossible)i(completions)f(m)o(ust)f(b)q(e)h(a)o
+(v)m(ailable.)21 b(That)15 b(is,)0 2421 y(it)k(is)f(not)g(p)q(ossible)i
+(to)e(accurately)h(expand)g(a)f(partial)h(w)o(ord)e(without)i(kno)o
+(wing)f(all)h(of)f(the)h(p)q(ossible)h(w)o(ords)0 2483
+y(whic)o(h)c(mak)o(e)f(sense)h(in)g(that)e(con)o(text.)20
+b(The)15 b(Readline)j(library)e(pro)o(vides)f(the)h(user)f(in)o
+(terface)h(to)e(completion,)0 2545 y(and)h(t)o(w)o(o)f(of)h(the)h(most)
+e(common)h(completion)h(functions:)21 b(\014lename)c(and)e(username.)20
+b(F)l(or)15 b(completing)h(other)0 2608 y(t)o(yp)q(es)h(of)f(text,)g(y)
+o(ou)h(m)o(ust)f(write)h(y)o(our)f(o)o(wn)g(completion)i(function.)25
+b(This)18 b(section)f(describ)q(es)h(exactly)g(what)0
+2670 y(suc)o(h)e(functions)f(m)o(ust)g(do,)g(and)g(pro)o(vides)h(an)f
+(example.)p eop
+35 36 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(35)62 183 y(There)16 b(are)f(three)g(ma)s(jor)f
+(functions)i(used)f(to)g(p)q(erform)g(completion:)25
+320 y(1.)29 b(The)15 b(user-in)o(terface)g(function)g
+Fq(rl_complete)e(\(\))p Fr(.)20 b(This)15 b(function)g(is)g(called)h
+(with)e(the)h(same)f(argumen)o(ts)90 383 y(as)j(other)g(Readline)j
+(functions)f(in)o(tended)g(for)e(in)o(teractiv)o(e)h(use:)25
+b Fl(coun)o(t)18 b Fr(and)g Fl(in)o(v)o(oking)p 1633
+383 14 2 v 17 w(k)o(ey)p Fr(.)27 b(It)18 b(isolates)90
+445 y(the)j(w)o(ord)g(to)f(b)q(e)i(completed)h(and)e(calls)h
+Fq(completion_matches)13 b(\(\))21 b Fr(to)f(generate)h(a)g(list)h(of)f
+(p)q(ossible)90 507 y(completions.)h(It)16 b(then)g(either)h(lists)f
+(the)g(p)q(ossible)h(completions,)g(inserts)f(the)g(p)q(ossible)h
+(completions,)f(or)90 569 y(actually)g(p)q(erforms)f(the)g(completion,)
+h(dep)q(ending)i(on)d(whic)o(h)h(b)q(eha)o(vior)f(is)h(desired.)25
+644 y(2.)29 b(The)18 b(in)o(ternal)h(function)g Fq(completion_matches)
+13 b(\(\))18 b Fr(uses)g(y)o(our)f Fl(generator)k Fr(function)e(to)e
+(generate)h(the)90 706 y(list)h(of)e(p)q(ossible)j(matc)o(hes,)e(and)g
+(then)g(returns)g(the)g(arra)o(y)f(of)h(these)g(matc)o(hes.)28
+b(Y)l(ou)18 b(should)h(place)g(the)90 769 y(address)c(of)g(y)o(our)g
+(generator)f(function)i(in)g Fq(rl_completion_entry_functi)o(on)p
+Fr(.)25 843 y(3.)29 b(The)16 b(generator)g(function)h(is)f(called)i
+(rep)q(eatedly)g(from)d Fq(completion_matches)e(\(\))p
+Fr(,)i(returning)i(a)f(string)90 906 y(eac)o(h)j(time.)31
+b(The)19 b(argumen)o(ts)f(to)g(the)h(generator)e(function)j(are)e
+Fl(text)i Fr(and)f Fl(state)p Fr(.)29 b Fl(text)19 b
+Fr(is)h(the)f(partial)90 968 y(w)o(ord)13 b(to)g(b)q(e)h(completed.)21
+b Fl(state)15 b Fr(is)f(zero)g(the)g(\014rst)f(time)h(the)g(function)g
+(is)g(called,)i(allo)o(wing)e(the)g(generator)90 1030
+y(to)19 b(p)q(erform)f(an)o(y)h(necessary)h(initialization,)i(and)e(a)f
+(p)q(ositiv)o(e)h(non-zero)f(in)o(teger)h(for)e(eac)o(h)h(subsequen)o
+(t)90 1092 y(call.)35 b(When)21 b(the)f(generator)f(function)i(returns)
+f Fq(\(char)14 b(*\)NULL)19 b Fr(this)i(signals)f Fq
+(completion_matches)90 1155 y(\(\))c Fr(that)g(there)h(are)f(no)h(more)
+f(p)q(ossibilitie)q(s)j(left.)25 b(Usually)18 b(the)e(generator)g
+(function)i(computes)e(the)h(list)90 1217 y(of)j(p)q(ossible)i
+(completions)f(when)g Fl(state)h Fr(is)f(zero,)g(and)f(returns)g(them)h
+(one)f(at)g(a)g(time)g(on)g(subsequen)o(t)90 1279 y(calls.)g(Eac)o(h)14
+b(string)f(the)h(generator)e(function)j(returns)e(as)g(a)g(matc)o(h)g
+(m)o(ust)g(b)q(e)h(allo)q(cated)h(with)e Fq(malloc\(\))p
+Fr(;)90 1341 y(Readline)18 b(frees)d(the)g(strings)g(when)h(it)f(has)g
+(\014nished)i(with)f(them.)1725 1503 y(F)l(unction)-1899
+b Fi(int)20 b Fh(rl)p 140 1503 18 3 v 21 w(complete)j
+Fg(\()p Fq(int)14 b(ignore,)g(int)h(invoking_key)p Fg(\))120
+1566 y Fr(Complete)j(the)f(w)o(ord)f(at)h(or)g(b)q(efore)g(p)q(oin)o
+(t.)27 b(Y)l(ou)17 b(ha)o(v)o(e)g(supplied)i(the)f(function)g(that)e
+(do)q(es)i(the)120 1628 y(initial)d(simple)f(matc)o(hing)f(selection)h
+(algorithm)f(\(see)f Fq(completion_matches)h(\(\))p Fr(\).)18
+b(The)13 b(default)120 1690 y(is)j(to)e(do)h(\014lename)i(completion.)
+1736 1852 y(V)l(ariable)-1899 b Fi(Function)20 b(*)g
+Fh(rl)p 316 1852 V 21 w(completion)p 611 1852 V 21 w(en)n(try)p
+764 1852 V 21 w(function)120 1914 y Fr(This)e(is)g(a)f(p)q(oin)o(ter)h
+(to)f(the)g(generator)g(function)h(for)f Fq(completion_matches)12
+b(\(\))p Fr(.)27 b(If)17 b(the)h(v)m(alue)120 1977 y(of)j
+Fq(rl_completion_entry_funct)o(ion)d Fr(is)k Fq(\(Function)14
+b(*\)NULL)20 b Fr(then)i(the)f(default)h(\014lename)120
+2039 y(generator)14 b(function,)i Fq(filename_completion_functi)o(on)c
+(\(\))p Fr(,)j(is)g(used.)0 2247 y Fk(2.5.2)30 b(Completion)15
+b(F)-5 b(unctions)62 2384 y Fr(Here)16 b(is)f(the)h(complete)g(list)g
+(of)e(callable)k(completion)e(functions)g(presen)o(t)f(in)h(Readline.)
+1725 2545 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p 140
+2545 V 21 w(complete)p 385 2545 V 21 w(in)n(ternal)k
+Fg(\()p Fq(int)15 b(what_to_do)p Fg(\))120 2608 y Fr(Complete)d(the)g
+(w)o(ord)f(at)g(or)g(b)q(efore)h(p)q(oin)o(t.)19 b Fl(what)p
+979 2608 14 2 v 16 w(to)p 1036 2608 V 16 w(do)14 b Fr(sa)o(ys)d(what)g
+(to)g(do)g(with)h(the)g(completion.)120 2670 y(A)g(v)m(alue)h(of)f(`)p
+Fq(?)p Fr(')f(means)h(list)h(the)f(p)q(ossible)i(completions.)20
+b(`)p Fq(TAB)p Fr(')11 b(means)h(do)g(standard)f(completion.)p
+eop
+36 37 bop 0 -58 a Fr(36)1449 b(GNU)15 b(Readline)i(Library)120
+183 y(`)p Fq(*)p Fr(')c(means)h(insert)h(all)g(of)f(the)g(p)q(ossible)i
+(completions.)21 b(`)p Fq(!)p Fr(')13 b(means)h(to)g(displa)o(y)h(all)g
+(of)f(the)g(p)q(ossible)120 246 y(completions,)i(if)g(there)f(is)h
+(more)e(than)h(one,)g(as)g(w)o(ell)h(as)f(p)q(erforming)h(partial)f
+(completion.)1725 441 y(F)l(unction)-1899 b Fi(int)20
+b Fh(rl)p 140 441 18 3 v 21 w(complete)j Fg(\()p Fq(int)14
+b(ignore,)g(int)h(invoking_key)p Fg(\))120 503 y Fr(Complete)23
+b(the)g(w)o(ord)e(at)h(or)g(b)q(efore)h(p)q(oin)o(t.)43
+b(Y)l(ou)23 b(ha)o(v)o(e)f(supplied)j(the)d(function)i(that)e(do)q(es)
+120 565 y(the)16 b(initial)j(simple)f(matc)o(hing)e(selection)i
+(algorithm)e(\(see)g Fq(completion_matches)d(\(\))j Fr(and)g
+Fq(rl_)120 627 y(completion_entry_function)p Fr(\))o(.)25
+b(The)18 b(default)g(is)g(to)f(do)h(\014lename)h(completion.)29
+b(This)18 b(calls)120 690 y Fq(rl_complete_internal)12
+b(\(\))j Fr(with)h(an)f(argumen)o(t)f(dep)q(ending)k(on)d
+Fl(in)o(v)o(oking)p 1496 690 14 2 v 17 w(k)o(ey)p Fr(.)1725
+885 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p 140 885
+18 3 v 21 w(p)r(ossible)p 358 885 V 20 w(completions)j
+Fg(\()p Fq(int)15 b(count,)f(int)h(invoking_key)p Fg(\)\))120
+947 y Fr(List)23 b(the)f(p)q(ossible)j(completions.)42
+b(See)23 b(description)h(of)e Fq(rl_complete)14 b(\(\))p
+Fr(.)41 b(This)23 b(calls)g Fq(rl_)120 1009 y(complete_internal)13
+b(\(\))i Fr(with)g(an)g(argumen)o(t)g(of)g(`)p Fq(?)p
+Fr('.)1725 1204 y(F)l(unction)-1899 b Fi(int)20 b Fh(rl)p
+140 1204 V 21 w(insert)p 303 1204 V 21 w(completions)j
+Fg(\()p Fq(int)14 b(count,)g(int)h(invoking_key)p Fg(\)\))120
+1267 y Fr(Insert)20 b(the)f(list)i(of)e(p)q(ossible)i(completions)f(in)
+o(to)g(the)f(line,)j(deleting)f(the)f(partially-completed)120
+1329 y(w)o(ord.)h(See)c(description)g(of)e Fq(rl_complete)f(\(\))p
+Fr(.)21 b(This)c(calls)g Fq(rl_complete_internal)12 b(\(\))k
+Fr(with)120 1391 y(an)f(argumen)o(t)g(of)f(`)p Fq(*)p
+Fr('.)1725 1586 y(F)l(unction)-1899 b Fi(char)20 b(**)f
+Fh(completion)p 472 1586 V 21 w(matc)n(hes)j Fg(\()p
+Fq(char)15 b(*text,)f(CPFunction)208 1648 y(*entry_func)p
+Fg(\))120 1711 y Fr(Returns)22 b(an)g(arra)o(y)e(of)h
+Fq(\(char)15 b(*\))21 b Fr(whic)o(h)i(is)f(a)f(list)i(of)e(completions)
+i(for)e Fl(text)p Fr(.)39 b(If)22 b(there)f(are)120 1773
+y(no)d(completions,)i(returns)e Fq(\(char)c(**\)NULL)p
+Fr(.)28 b(The)19 b(\014rst)e(en)o(try)h(in)h(the)g(returned)f(arra)o(y)
+f(is)i(the)120 1835 y(substitution)c(for)e Fl(text)p
+Fr(.)19 b(The)c(remaining)g(en)o(tries)f(are)g(the)g(p)q(ossible)i
+(completions.)k(The)15 b(arra)o(y)d(is)120 1897 y(terminated)j(with)h
+(a)f Fq(NULL)f Fr(p)q(oin)o(ter.)120 2045 y Fl(en)o(try)p
+227 2045 14 2 v 16 w(func)h Fr(is)d(a)g(function)h(of)e(t)o(w)o(o)g
+(args,)g(and)h(returns)g(a)f Fq(\(char)k(*\))p Fr(.)j(The)12
+b(\014rst)f(argumen)o(t)g(is)i Fl(text)p Fr(.)120 2108
+y(The)i(second)f(is)h(a)f(state)g(argumen)o(t;)f(it)i(is)g(zero)f(on)g
+(the)h(\014rst)f(call,)h(and)f(non-zero)h(on)f(subsequen)o(t)120
+2170 y(calls.)21 b Fl(en)o(try)p 346 2170 V 16 w(func)c
+Fr(returns)e(a)f Fq(NULL)g Fr(p)q(oin)o(ter)h(to)f(the)g(caller)i(when)
+f(there)f(are)g(no)h(more)f(matc)o(hes.)1725 2365 y(F)l(unction)-1899
+b Fi(char)20 b(*)f Fh(\014lename)p 380 2365 18 3 v 20
+w(completion)p 674 2365 V 21 w(function)k Fg(\()p Fq(char)15
+b(*text,)f(int)h(state)p Fg(\))120 2427 y Fr(A)e(generator)f(function)h
+(for)f(\014lename)i(completion)g(in)f(the)g(general)g(case.)19
+b(Note)13 b(that)f(completion)120 2490 y(in)18 b(Bash)f(is)h(a)f
+(little)h(di\013eren)o(t)f(b)q(ecause)h(of)f(all)h(the)f(pathnames)g
+(that)g(m)o(ust)f(b)q(e)i(follo)o(w)o(ed)f(when)120 2552
+y(lo)q(oking)23 b(up)f(completions)h(for)e(a)g(command.)39
+b(The)22 b(Bash)g(source)g(is)g(a)f(useful)i(reference)g(for)120
+2614 y(writing)16 b(custom)f(completion)h(functions.)p
+eop
+37 38 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(37)1725 183 y(F)l(unction)-1899 b Fi(char)20
+b(*)f Fh(username)p 412 183 18 3 v 19 w(completion)p
+705 183 V 21 w(function)k Fg(\()p Fq(char)14 b(*text,)g(int)h(state)p
+Fg(\))120 246 y Fr(A)i(completion)h(generator)e(for)g(usernames.)24
+b Fl(text)18 b Fr(con)o(tains)e(a)h(partial)g(username)g(preceded)h(b)o
+(y)120 308 y(a)f(random)g(c)o(haracter)f(\(usually)j(`)p
+Fq(~)p Fr('\).)24 b(As)18 b(with)f(all)h(completion)h(generators,)d
+Fl(state)j Fr(is)f(zero)f(on)120 370 y(the)e(\014rst)g(call)h(and)g
+(non-zero)f(for)g(subsequen)o(t)h(calls.)0 618 y Fk(2.5.3)30
+b(Completion)15 b(V)-5 b(ariables)1736 793 y Fr(V)l(ariable)-1899
+b Fi(Function)20 b(*)g Fh(rl)p 316 793 V 21 w(completion)p
+611 793 V 21 w(en)n(try)p 764 793 V 21 w(function)120
+856 y Fr(A)d(p)q(oin)o(ter)h(to)f(the)g(generator)f(function)i(for)f
+Fq(completion_matches)c(\(\))p Fr(.)25 b Fq(NULL)17 b
+Fr(means)g(to)g(use)120 918 y Fq(filename_entry_function)12
+b(\(\))p Fr(,)j(the)g(default)h(\014lename)g(completer.)1736
+1093 y(V)l(ariable)-1899 b Fi(CPPFunction)21 b(*)e Fh(rl)p
+394 1093 V 21 w(attempted)p 674 1093 V 20 w(completion)p
+968 1093 V 21 w(function)120 1156 y Fr(A)g(p)q(oin)o(ter)h(to)f(an)g
+(alternativ)o(e)h(function)g(to)f(create)g(matc)o(hes.)32
+b(The)20 b(function)g(is)g(called)h(with)120 1218 y Fl(text)p
+Fr(,)e Fl(start)p Fr(,)g(and)g Fl(end)p Fr(.)32 b Fl(start)19
+b Fr(and)g Fl(end)j Fr(are)c(indices)j(in)f Fq(rl_line_buffer)d
+Fr(sa)o(ying)i(what)g(the)120 1280 y(b)q(oundaries)c(of)e
+Fl(text)h Fr(are.)19 b(If)13 b(this)h(function)g(exists)g(and)g
+(returns)f Fq(NULL)p Fr(,)g(or)g(if)h(this)f(v)m(ariable)i(is)f(set)120
+1342 y(to)h Fq(NULL)p Fr(,)f(then)i Fq(rl_complete)e(\(\))h
+Fr(will)i(call)g(the)e(v)m(alue)i(of)e Fq(rl_completion_entry_funct)o
+(ion)120 1405 y Fr(to)g(generate)f(matc)o(hes,)h(otherwise)g(the)h
+(arra)o(y)e(of)g(strings)h(returned)h(will)h(b)q(e)f(used.)1736
+1580 y(V)l(ariable)-1899 b Fi(CPFunction)21 b(*)e Fh(rl)p
+368 1580 V 21 w(\014lename)p 597 1580 V 20 w(quoting)p
+806 1580 V 21 w(function)120 1642 y Fr(A)e(p)q(oin)o(ter)h(to)f(a)g
+(function)h(that)e(will)j(quote)e(a)g(\014lename)h(in)h(an)e
+(application-)i(sp)q(eci\014c)g(fashion.)120 1705 y(This)f(is)g(called)
+i(if)e(\014lename)h(completion)f(is)h(b)q(eing)f(attempted)g(and)f(one)
+h(of)f(the)h(c)o(haracters)f(in)120 1767 y Fq
+(rl_filename_quote_characte)o(rs)g Fr(app)q(ears)k(in)g(a)f(completed)h
+(\014lename.)37 b(The)20 b(function)h(is)120 1829 y(called)14
+b(with)f Fl(text)p Fr(,)g Fl(matc)o(h)p 579 1829 14 2
+v 15 w(t)o(yp)q(e)p Fr(,)g(and)g Fl(quote)p 903 1829
+V 16 w(p)q(oin)o(ter)p Fr(.)20 b(The)13 b Fl(text)g Fr(is)g(the)g
+(\014lename)h(to)e(b)q(e)h(quoted.)120 1891 y(The)21
+b Fl(matc)o(h)p 345 1891 V 16 w(t)o(yp)q(e)j Fr(is)e(either)f
+Fq(SINGLE_MATCH)p Fr(,)g(if)h(there)f(is)h(only)f(one)h(completion)g
+(matc)o(h,)f(or)120 1954 y Fq(MULT_MATCH)p Fr(.)d(Some)13
+b(functions)g(use)h(this)f(to)f(decide)j(whether)e(or)f(not)h(to)f
+(insert)i(a)e(closing)i(quote)120 2016 y(c)o(haracter.)36
+b(The)21 b Fl(quote)p 565 2016 V 16 w(p)q(oin)o(ter)k
+Fr(is)c(a)g(p)q(oin)o(ter)g(to)f(an)o(y)h(op)q(ening)h(quote)f(c)o
+(haracter)f(the)h(user)120 2078 y(t)o(yp)q(ed.)f(Some)15
+b(functions)h(c)o(ho)q(ose)g(to)e(reset)h(this)h(c)o(haracter.)1736
+2254 y(V)l(ariable)-1899 b Fi(CPFunction)21 b(*)e Fh(rl)p
+368 2254 18 3 v 21 w(\014lename)p 597 2254 V 20 w(dequoting)p
+864 2254 V 21 w(function)120 2316 y Fr(A)f(p)q(oin)o(ter)g(to)f(a)g
+(function)h(that)f(will)i(remo)o(v)o(e)e(application-sp)q(eci\014c)k
+(quoting)d(c)o(haracters)f(from)120 2378 y(a)h(\014lename)i(b)q(efore)f
+(completion)h(is)f(attempted,)g(so)f(those)h(c)o(haracters)f(do)g(not)h
+(in)o(terfere)g(with)120 2440 y(matc)o(hing)13 b(the)g(text)f(against)g
+(names)h(in)g(the)g(\014lesystem.)20 b(It)13 b(is)g(called)h(with)f
+Fl(text)p Fr(,)g(the)f(text)h(of)f(the)120 2503 y(w)o(ord)i(to)g(b)q(e)
+h(dequoted,)g(and)g Fl(quote)p 757 2503 14 2 v 16 w(c)o(har)p
+Fr(,)f(whic)o(h)i(is)f(the)g(quoting)g(c)o(haracter)f(that)f(delimits)k
+(the)120 2565 y(\014lename)d(\(usually)g(`)p Fq(')p Fr(')e(or)g(`)p
+Fq(")p Fr('\).)18 b(If)13 b Fl(quote)p 838 2565 V 16
+w(c)o(har)j Fr(is)e(zero,)e(the)h(\014lename)h(w)o(as)e(not)h(in)h(an)f
+(em)o(b)q(edded)120 2627 y(string.)p eop
+38 39 bop 0 -58 a Fr(38)1449 b(GNU)15 b(Readline)i(Library)1736
+183 y(V)l(ariable)-1899 b Fi(Function)20 b(*)g Fh(rl)p
+316 183 18 3 v 21 w(c)n(har)p 444 183 V 20 w(is)p 502
+183 V 22 w(quoted)p 695 183 V 20 w(p)120 246 y Fr(A)d(p)q(oin)o(ter)g
+(to)f(a)g(function)i(to)e(call)h(that)f(determines)i(whether)f(or)f
+(not)g(a)h(sp)q(eci\014c)h(c)o(haracter)e(in)120 308
+y(the)c(line)i(bu\013er)e(is)h(quoted,)f(according)h(to)e(whatev)o(er)h
+(quoting)g(mec)o(hanism)h(the)f(program)f(calling)120
+370 y(readline)j(uses.)20 b(The)13 b(function)g(is)h(called)g(with)f(t)
+o(w)o(o)f(argumen)o(ts:)17 b Fl(text)p Fr(,)c(the)g(text)f(of)g(the)h
+(line,)i(and)120 432 y Fl(index)p Fr(,)j(the)e(index)i(of)e(the)g(c)o
+(haracter)g(in)h(the)g(line.)25 b(It)16 b(is)h(used)g(to)f(decide)i
+(whether)f(a)f(c)o(haracter)120 495 y(found)j(in)g Fq
+(rl_completer_word_break_)o(charact)o(ers)c Fr(should)20
+b(b)q(e)e(used)h(to)f(break)g(w)o(ords)g(for)120 557
+y(the)d(completer.)1736 745 y(V)l(ariable)-1899 b Fi(int)20
+b Fh(rl)p 140 745 V 21 w(completion)p 435 745 V 21 w(query)p
+598 745 V 21 w(items)120 807 y Fr(Up)h(to)e(this)i(man)o(y)f(items)h
+(will)h(b)q(e)f(displa)o(y)o(ed)h(in)f(resp)q(onse)g(to)f(a)g(p)q
+(ossible-completions)j(call.)120 869 y(After)16 b(that,)f(w)o(e)g(ask)h
+(the)g(user)g(if)g(she)g(is)h(sure)f(she)g(w)o(an)o(ts)f(to)g(see)h
+(them)g(all.)23 b(The)16 b(default)h(v)m(alue)120 932
+y(is)f(100.)1736 1120 y(V)l(ariable)-1899 b Fi(char)20
+b(*)f Fh(rl)p 211 1120 V 21 w(basic)p 355 1120 V 21 w(w)n(ord)p
+500 1120 V 21 w(break)p 661 1120 V 20 w(c)n(haracters)120
+1182 y Fr(The)12 b(basic)g(list)h(of)e(c)o(haracters)g(that)g(signal)h
+(a)g(break)f(b)q(et)o(w)o(een)h(w)o(ords)f(for)g(the)h(completer)g
+(routine.)120 1244 y(The)17 b(default)h(v)m(alue)g(of)e(this)i(v)m
+(ariable)g(is)g(the)f(c)o(haracters)f(whic)o(h)h(break)g(w)o(ords)g
+(for)f(completion)120 1306 y(in)g(Bash,)f(i.e.,)g Fq(")g
+(\\t\\n\\"\\\\'`@$><=;|&{\(")p Fr(.)1736 1494 y(V)l(ariable)-1899
+b Fi(char)20 b(*)f Fh(rl)p 211 1494 V 21 w(basic)p 355
+1494 V 21 w(quote)p 515 1494 V 21 w(c)n(haracters)120
+1557 y Fr(List)d(of)f(quote)g(c)o(haracters)f(whic)o(h)i(can)f(cause)h
+(a)f(w)o(ord)f(break.)1736 1745 y(V)l(ariable)-1899 b
+Fi(char)20 b(*)f Fh(rl)p 211 1745 V 21 w(completer)p
+480 1745 V 21 w(w)n(ord)p 625 1745 V 20 w(break)p 785
+1745 V 20 w(c)n(haracters)120 1807 y Fr(The)f(list)h(of)e(c)o
+(haracters)g(that)g(signal)i(a)f(break)f(b)q(et)o(w)o(een)h(w)o(ords)g
+(for)f Fq(rl_complete_internal)120 1869 y(\(\))p Fr(.)j(The)15
+b(default)h(list)g(is)f(the)h(v)m(alue)g(of)f Fq
+(rl_basic_word_break_charac)o(ters)p Fr(.)1736 2057 y(V)l(ariable)-1899
+b Fi(char)20 b(*)f Fh(rl)p 211 2057 V 21 w(completer)p
+480 2057 V 21 w(quote)p 640 2057 V 21 w(c)n(haracters)120
+2120 y Fr(List)j(of)e(c)o(haracters)g(whic)o(h)i(can)f(b)q(e)h(used)f
+(to)f(quote)h(a)g(substring)g(of)f(the)h(line.)39 b(Completion)120
+2182 y(o)q(ccurs)17 b(on)f(the)h(en)o(tire)g(substring,)g(and)f(within)
+i(the)e(substring)h Fq(rl_completer_word_break_)120 2244
+y(characters)i Fr(are)g(treated)h(as)f(an)o(y)h(other)g(c)o(haracter,)g
+(unless)h(they)f(also)g(app)q(ear)g(within)i(this)120
+2306 y(list.)1736 2494 y(V)l(ariable)-1899 b Fi(char)20
+b(*)f Fh(rl)p 211 2494 V 21 w(\014lename)p 440 2494 V
+20 w(quote)p 599 2494 V 21 w(c)n(haracters)120 2557 y
+Fr(A)g(list)h(of)e(c)o(haracters)g(that)g(cause)h(a)g(\014lename)h(to)e
+(b)q(e)i(quoted)e(b)o(y)h(the)g(completer)h(when)f(they)120
+2619 y(app)q(ear)c(in)h(a)f(completed)h(\014lename.)21
+b(The)16 b(default)g(is)f(empt)o(y)l(.)p eop
+39 40 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(39)1736 183 y(V)l(ariable)-1899 b Fi(char)20
+b(*)f Fh(rl)p 211 183 18 3 v 21 w(sp)r(ecial)p 398 183
+V 22 w(pre\014xes)120 246 y Fr(The)d(list)h(of)e(c)o(haracters)g(that)g
+(are)h(w)o(ord)f(break)h(c)o(haracters,)f(but)h(should)h(b)q(e)f(left)g
+(in)h Fl(text)f Fr(when)120 308 y(it)f(is)g(passed)g(to)f(the)g
+(completion)i(function.)k(Programs)14 b(can)g(use)h(this)g(to)f(help)i
+(determine)g(what)120 370 y(kind)h(of)f(completing)i(to)e(do.)23
+b(F)l(or)16 b(instance,)h(Bash)f(sets)g(this)h(v)m(ariable)h(to)e
+Fq(")p Fr($)p Fq(@")f Fr(so)h(that)g(it)h(can)120 432
+y(complete)f(shell)h(v)m(ariables)f(and)g(hostnames.)1736
+587 y(V)l(ariable)-1899 b Fi(int)20 b Fh(rl)p 140 587
+V 21 w(completion)p 435 587 V 21 w(app)r(end)p 640 587
+V 19 w(c)n(haracter)120 650 y Fr(When)f(a)g(single)h(completion)g
+(alternativ)o(e)f(matc)o(hes)g(at)f(the)h(end)g(of)g(the)g(command)f
+(line,)k(this)120 712 y(c)o(haracter)12 b(is)i(app)q(ended)h(to)d(the)i
+(inserted)g(completion)g(text.)19 b(The)13 b(default)h(is)f(a)g(space)h
+(c)o(haracter)120 774 y(\(`)g('\).)21 b(Setting)c(this)f(to)f(the)h(n)o
+(ull)h(c)o(haracter)e(\(`)p Fq(\\0)p Fr('\))f(prev)o(en)o(ts)i(an)o
+(ything)g(b)q(eing)h(app)q(ended)g(auto-)120 836 y(matically)l(.)26
+b(This)17 b(can)g(b)q(e)g(c)o(hanged)g(in)g(custom)g(completion)h
+(functions)f(to)f(pro)o(vide)h(the)g(\\most)120 899 y(sensible)i(w)o
+(ord)d(separator)g(c)o(haracter")g(according)h(to)f(an)h
+(application-sp)q(eci\014)q(c)j(command)c(line)120 961
+y(syn)o(tax)e(sp)q(eci\014cation.)1736 1116 y(V)l(ariable)-1899
+b Fi(int)20 b Fh(rl)p 140 1116 V 21 w(ignore)p 316 1116
+V 20 w(completion)p 610 1116 V 21 w(duplicates)120 1178
+y Fr(If)15 b(non-zero,)h(then)f(disallo)o(w)h(duplicates)h(in)f(the)g
+(matc)o(hes.)j(Default)c(is)h(1.)1736 1333 y(V)l(ariable)-1899
+b Fi(int)20 b Fh(rl)p 140 1333 V 21 w(\014lename)p 369
+1333 V 20 w(completion)p 663 1333 V 21 w(desired)120
+1395 y Fr(Non-zero)e(means)g(that)f(the)g(results)i(of)e(the)h(matc)o
+(hes)f(are)h(to)f(b)q(e)h(treated)f(as)h(\014lenames.)28
+b(This)120 1458 y(is)16 b Fl(alw)o(a)o(ys)h Fr(zero)e(on)g(en)o(try)l
+(,)g(and)h(can)g(only)g(b)q(e)g(c)o(hanged)f(within)i(a)e(completion)i
+(en)o(try)e(generator)120 1520 y(function.)26 b(If)18
+b(it)f(is)h(set)f(to)f(a)h(non-zero)g(v)m(alue,)i(directory)e(names)g
+(ha)o(v)o(e)g(a)g(slash)g(app)q(ended)i(and)120 1582
+y(Readline)i(attempts)c(to)g(quote)h(completed)i(\014lenames)f(if)f
+(they)h(con)o(tain)f(an)o(y)g(em)o(b)q(edded)i(w)o(ord)120
+1645 y(break)15 b(c)o(haracters.)1736 1800 y(V)l(ariable)-1899
+b Fi(int)20 b Fh(rl)p 140 1800 V 21 w(\014lename)p 369
+1800 V 20 w(quoting)p 578 1800 V 21 w(desired)120 1862
+y Fr(Non-zero)c(means)g(that)g(the)g(results)h(of)e(the)i(matc)o(hes)e
+(are)h(to)g(b)q(e)h(quoted)f(using)h(double)g(quotes)120
+1924 y(\(or)d(an)h(application-sp)q(eci\014)q(c)j(quoting)d(mec)o
+(hanism\))g(if)h(the)f(completed)h(\014lename)g(con)o(tains)f(an)o(y)
+120 1986 y(c)o(haracters)i(in)h Fq(rl_filename_quote_chars)p
+Fr(.)24 b(This)19 b(is)f Fl(alw)o(a)o(ys)h Fr(non-zero)f(on)f(en)o(try)
+l(,)h(and)g(can)120 2049 y(only)d(b)q(e)g(c)o(hanged)f(within)i(a)e
+(completion)h(en)o(try)f(generator)g(function.)20 b(The)14
+b(quoting)h(is)g(e\013ected)120 2111 y(via)g(a)g(call)i(to)d(the)i
+(function)g(p)q(oin)o(ted)g(to)e(b)o(y)h Fq
+(rl_filename_quoting_function)p Fr(.)1736 2266 y(V)l(ariable)-1899
+b Fi(int)20 b Fh(rl)p 140 2266 V 21 w(inhibit)p 324 2266
+V 23 w(completion)120 2328 y Fr(If)15 b(this)g(v)m(ariable)h(is)f
+(non-zero,)g(completion)h(is)f(inhibit)p Fq(<)p Fr(ed.)22
+b(The)15 b(completion)h(c)o(haracter)e(will)i(b)q(e)120
+2390 y(inserted)g(as)f(an)o(y)g(other)g(b)q(ound)h(to)e
+Fq(self-insert)p Fr(.)1736 2545 y(V)l(ariable)-1899 b
+Fi(Function)20 b(*)g Fh(rl)p 316 2545 V 21 w(ignore)p
+492 2545 V 20 w(some)p 639 2545 V 19 w(completions)p
+955 2545 V 21 w(function)120 2608 y Fr(This)e(function,)g(if)g
+(de\014ned,)h(is)f(called)h(b)o(y)e(the)h(completer)g(when)g(real)f
+(\014lename)i(completion)f(is)120 2670 y(done,)13 b(after)e(all)i(the)g
+(matc)o(hing)f(names)g(ha)o(v)o(e)g(b)q(een)h(generated.)19
+b(It)12 b(is)h(passed)f(a)g Fq(NULL)g Fr(terminated)p
+eop
+40 41 bop 0 -58 a Fr(40)1449 b(GNU)15 b(Readline)i(Library)120
+183 y(arra)o(y)f(of)h(matc)o(hes.)26 b(The)17 b(\014rst)g(elemen)o(t)h
+(\()p Fq(matches[0])p Fr(\))e(is)h(the)h(maximal)g(substring)f(common)
+120 246 y(to)f(all)h(matc)o(hes.)22 b(This)17 b(function)g(can)f
+(re-arrange)g(the)g(list)h(of)f(matc)o(hes)g(as)f(required,)j(but)e
+(eac)o(h)120 308 y(elemen)o(t)g(deleted)g(from)f(the)g(arra)o(y)f(m)o
+(ust)h(b)q(e)h(freed.)1736 470 y(V)l(ariable)-1899 b
+Fi(Function)20 b(*)g Fh(rl)p 316 470 18 3 v 21 w(directory)p
+564 470 V 21 w(completion)p 859 470 V 21 w(ho)r(ok)120
+532 y Fr(This)15 b(function,)g(if)g(de\014ned,)h(is)f(allo)o(w)o(ed)g
+(to)e(mo)q(dify)j(the)e(directory)h(p)q(ortion)g(of)f(\014lenames)h
+(Read-)120 594 y(line)h(completes.)k(It)14 b(is)g(called)i(with)e(the)g
+(address)g(of)g(a)g(string)g(\(the)g(curren)o(t)f(directory)i(name\))e
+(as)120 656 y(an)f(argumen)o(t.)17 b(It)12 b(could)h(b)q(e)f(used)g(to)
+f(expand)h(sym)o(b)q(olic)h(links)g(or)e(shell)i(v)m(ariables)g(in)f
+(pathnames.)0 864 y Fk(2.5.4)30 b(A)15 b(Short)g(Completion)g(Example)
+62 1001 y Fr(Here)20 b(is)h(a)e(small)i(application)g(demonstrating)f
+(the)f(use)i(of)e(the)h(GNU)f(Readline)k(library)l(.)34
+b(It)20 b(is)g(called)0 1063 y Fq(fileman)p Fr(,)14 b(and)i(the)f
+(source)g(co)q(de)h(resides)g(in)h(`)p Fq(examples/fileman.c)p
+Fr(')o(.)h(This)e(sample)f(application)i(pro)o(vides)0
+1126 y(completion)f(of)f(command)g(names,)g(line)i(editing)f(features,)
+f(and)g(access)g(to)g(the)g(history)g(list.)p eop
+41 42 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(41)120 183 y Fq(/*)24 b(fileman.c)e(--)i(A)g(tiny)f
+(application)f(which)h(demonstrates)g(how)g(to)h(use)f(the)192
+235 y(GNU)g(Readline)g(library.)46 b(This)24 b(application)e
+(interactively)g(allows)h(users)192 287 y(to)g(manipulate)g(files)g
+(and)g(their)g(modes.)h(*/)120 391 y(#include)f(<stdio.h>)120
+443 y(#include)g(<sys/types.h>)120 495 y(#include)g(<sys/file.h>)120
+546 y(#include)g(<sys/stat.h>)120 598 y(#include)g(<sys/errno.h>)120
+702 y(#include)g(<readline/readline.h>)120 754 y(#include)g
+(<readline/history.h>)120 858 y(extern)g(char)g(*getwd)g(\(\);)120
+910 y(extern)g(char)g(*xmalloc)g(\(\);)120 1013 y(/*)h(The)f(names)g
+(of)h(functions)e(that)i(actually)f(do)g(the)h(manipulation.)e(*/)120
+1065 y(int)h(com_list)g(\(\),)h(com_view)e(\(\),)i(com_rename)e(\(\),)i
+(com_stat)f(\(\),)g(com_pwd)g(\(\);)120 1117 y(int)g(com_delete)g
+(\(\),)g(com_help)g(\(\),)h(com_cd)f(\(\),)g(com_quit)g(\(\);)120
+1221 y(/*)h(A)f(structure)g(which)g(contains)g(information)f(on)i(the)f
+(commands)g(this)g(program)192 1273 y(can)g(understand.)f(*/)120
+1377 y(typedef)h(struct)g({)168 1429 y(char)g(*name;)g(/*)h(User)f
+(printable)g(name)g(of)h(the)f(function.)g(*/)168 1480
+y(Function)f(*func;)i(/*)f(Function)g(to)g(call)h(to)f(do)h(the)f(job.)
+h(*/)168 1532 y(char)f(*doc;)g(/*)h(Documentation)e(for)h(this)h
+(function.)46 b(*/)120 1584 y(})24 b(COMMAND;)120 1688
+y(COMMAND)f(commands[])f(=)i({)168 1740 y({)f("cd",)h(com_cd,)f
+("Change)f(to)i(directory)f(DIR")g(},)168 1792 y({)g("delete",)g
+(com_delete,)f("Delete)h(FILE")h(},)168 1844 y({)f("help",)g(com_help,)
+g("Display)g(this)g(text")g(},)168 1896 y({)g("?",)h(com_help,)e
+("Synonym)h(for)h(`help'")f(},)168 1947 y({)g("list",)g(com_list,)g
+("List)g(files)g(in)h(DIR")f(},)168 1999 y({)g("ls",)h(com_list,)e
+("Synonym)h(for)g(`list'")g(},)168 2051 y({)g("pwd",)g(com_pwd,)g
+("Print)g(the)h(current)f(working)g(directory")f(},)168
+2103 y({)h("quit",)g(com_quit,)g("Quit)g(using)g(Fileman")g(},)168
+2155 y({)g("rename",)g(com_rename,)f("Rename)h(FILE)h(to)f(NEWNAME")g
+(},)168 2207 y({)g("stat",)g(com_stat,)g("Print)g(out)g(statistics)g
+(on)h(FILE")f(},)168 2259 y({)g("view",)g(com_view,)g("View)g(the)h
+(contents)e(of)i(FILE")f(},)168 2311 y({)g(\(char)h(*\)NULL,)f
+(\(Function)f(*\)NULL,)h(\(char)g(*\)NULL)g(})120 2363
+y(};)120 2466 y(/*)h(Forward)e(declarations.)h(*/)120
+2518 y(char)g(*stripwhite)g(\(\);)120 2570 y(COMMAND)g(*find_command)f
+(\(\);)p eop
+42 43 bop 0 -58 a Fr(42)1449 b(GNU)15 b(Readline)i(Library)120
+183 y Fq(/*)24 b(The)f(name)g(of)h(this)f(program,)g(as)h(taken)f(from)
+g(argv[0].)g(*/)120 235 y(char)g(*progname;)120 339 y(/*)h(When)f
+(non-zero,)g(this)g(global)g(means)g(the)h(user)f(is)g(done)h(using)f
+(this)g(program.)g(*/)120 391 y(int)g(done;)120 495 y(char)g(*)120
+546 y(dupstr)g(\(s\))239 598 y(int)h(s;)120 650 y({)168
+702 y(char)f(*r;)168 806 y(r)g(=)h(xmalloc)f(\(strlen)g(\(s\))g(+)h
+(1\);)168 858 y(strcpy)f(\(r,)g(s\);)168 910 y(return)g(\(r\);)120
+962 y(})120 1065 y(main)g(\(argc,)g(argv\))239 1117 y(int)h(argc;)239
+1169 y(char)g(**argv;)120 1221 y({)168 1273 y(char)f(*line,)g(*s;)168
+1377 y(progname)f(=)i(argv[0];)168 1480 y(initialize_readline)d(\(\);)i
+(/*)h(Bind)f(our)h(completer.)e(*/)168 1584 y(/*)h(Loop)h(reading)f
+(and)g(executing)g(lines)g(until)g(the)g(user)h(quits.)f(*/)168
+1636 y(for)g(\()h(;)g(done)f(==)h(0;)f(\))215 1688 y({)263
+1740 y(line)g(=)h(readline)f(\("FileMan:)f("\);)263 1844
+y(if)i(\(!line\))311 1896 y(break;)263 1999 y(/*)g(Remove)f(leading)g
+(and)g(trailing)g(whitespace)f(from)i(the)f(line.)335
+2051 y(Then,)g(if)h(there)f(is)g(anything)g(left,)g(add)h(it)f(to)h
+(the)f(history)g(list)335 2103 y(and)g(execute)g(it.)h(*/)263
+2155 y(s)g(=)g(stripwhite)e(\(line\);)263 2259 y(if)i(\(*s\))311
+2311 y({)359 2363 y(add_history)e(\(s\);)359 2414 y(execute_line)g
+(\(s\);)311 2466 y(})263 2570 y(free)h(\(line\);)215
+2622 y(})p eop
+43 44 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(43)168 183 y Fq(exit)23 b(\(0\);)120
+235 y(})120 339 y(/*)h(Execute)e(a)i(command)f(line.)g(*/)120
+391 y(int)120 443 y(execute_line)f(\(line\))239 495 y(char)i(*line;)120
+546 y({)168 598 y(register)e(int)i(i;)168 650 y(COMMAND)f(*command;)168
+702 y(char)g(*word;)168 806 y(/*)g(Isolate)g(the)h(command)f(word.)g
+(*/)168 858 y(i)g(=)h(0;)168 910 y(while)f(\(line[i])g(&&)g(whitespace)
+g(\(line[i]\)\))215 962 y(i++;)168 1013 y(word)g(=)h(line)f(+)h(i;)168
+1117 y(while)f(\(line[i])g(&&)g(!whitespace)g(\(line[i]\)\))215
+1169 y(i++;)168 1273 y(if)g(\(line[i]\))215 1325 y(line[i++])g(=)h
+('\\0';)168 1429 y(command)f(=)g(find_command)g(\(word\);)168
+1532 y(if)g(\(!command\))215 1584 y({)263 1636 y(fprintf)g(\(stderr,)g
+("\045s:)g(No)h(such)f(command)g(for)g(FileMan.\\n",)g(word\);)263
+1688 y(return)g(\(-1\);)215 1740 y(})168 1844 y(/*)g(Get)h(argument)f
+(to)g(command,)g(if)g(any.)h(*/)168 1896 y(while)f(\(whitespace)f
+(\(line[i]\)\))215 1947 y(i++;)168 2051 y(word)h(=)h(line)f(+)h(i;)168
+2155 y(/*)f(Call)h(the)f(function.)g(*/)168 2207 y(return)g
+(\(\(*\(command->func\)\))e(\(word\)\);)120 2259 y(})120
+2363 y(/*)j(Look)f(up)g(NAME)h(as)f(the)h(name)f(of)h(a)f(command,)g
+(and)h(return)f(a)g(pointer)g(to)h(that)192 2414 y(command.)46
+b(Return)23 b(a)h(NULL)f(pointer)g(if)h(NAME)f(isn't)g(a)h(command)f
+(name.)g(*/)120 2466 y(COMMAND)g(*)120 2518 y(find_command)f(\(name\))
+239 2570 y(char)i(*name;)120 2622 y({)p eop
+44 45 bop 0 -58 a Fr(44)1449 b(GNU)15 b(Readline)i(Library)168
+183 y Fq(register)22 b(int)i(i;)168 287 y(for)f(\(i)h(=)f(0;)h
+(commands[i].name;)e(i++\))215 339 y(if)i(\(strcmp)f(\(name,)g
+(commands[i].name\))f(==)h(0\))263 391 y(return)g(\(&commands[i]\);)168
+495 y(return)g(\(\(COMMAND)f(*\)NULL\);)120 546 y(})120
+650 y(/*)i(Strip)f(whitespace)f(from)i(the)f(start)g(and)h(end)f(of)h
+(STRING.)46 b(Return)24 b(a)f(pointer)192 702 y(into)g(STRING.)g(*/)120
+754 y(char)g(*)120 806 y(stripwhite)f(\(string\))239
+858 y(char)i(*string;)120 910 y({)168 962 y(register)e(char)i(*s,)f
+(*t;)168 1065 y(for)g(\(s)h(=)f(string;)g(whitespace)g(\(*s\);)g(s++\))
+215 1117 y(;)168 1221 y(if)g(\(*s)h(==)f(0\))215 1273
+y(return)g(\(s\);)168 1377 y(t)g(=)h(s)g(+)g(strlen)f(\(s\))g(-)h(1;)
+168 1429 y(while)f(\(t)g(>)h(s)g(&&)g(whitespace)e(\(*t\)\))215
+1480 y(t--;)168 1532 y(*++t)h(=)h('\\0';)168 1636 y(return)f(s;)120
+1688 y(})120 1792 y(/*)h(***********************)o(*******)o(********)o
+(*******)o(*******)o(********)o(****)d(*/)120 1844 y(/*)1575
+b(*/)120 1896 y(/*)429 b(Interface)23 b(to)g(Readline)g(Completion)381
+b(*/)120 1947 y(/*)1575 b(*/)120 1999 y(/*)24 b
+(***********************)o(*******)o(********)o(*******)o(*******)o
+(********)o(****)d(*/)120 2103 y(char)i(*command_generator)f(\(\);)120
+2155 y(char)h(**fileman_completion)e(\(\);)120 2259 y(/*)j(Tell)f(the)g
+(GNU)h(Readline)f(library)f(how)i(to)g(complete.)46 b(We)24
+b(want)f(to)h(try)f(to)h(complete)192 2311 y(on)f(command)g(names)g(if)
+h(this)f(is)h(the)f(first)g(word)h(in)f(the)h(line,)f(or)h(on)f
+(filenames)192 2363 y(if)g(not.)g(*/)120 2414 y(initialize_readline)e
+(\(\))120 2466 y({)168 2518 y(/*)i(Allow)g(conditional)g(parsing)g(of)g
+(the)h(~/.inputrc)e(file.)h(*/)168 2570 y(rl_readline_name)e(=)j
+("FileMan";)p eop
+45 46 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(45)168 183 y Fq(/*)23 b(Tell)h(the)f(completer)g(that)g
+(we)h(want)f(a)h(crack)f(first.)g(*/)168 235 y
+(rl_attempted_completion_)o(functio)o(n)e(=)j(\(CPPFunction)e
+(*\)fileman_completion;)120 287 y(})120 391 y(/*)i(Attempt)e(to)i
+(complete)f(on)g(the)h(contents)f(of)g(TEXT.)47 b(START)23
+b(and)h(END)f(bound)h(the)192 443 y(region)f(of)g(rl_line_buffer)f
+(that)h(contains)g(the)h(word)f(to)h(complete.)46 b(TEXT)23
+b(is)192 495 y(the)g(word)g(to)h(complete.)46 b(We)24
+b(can)f(use)h(the)f(entire)g(contents)g(of)h(rl_line_buffer)192
+546 y(in)f(case)g(we)h(want)f(to)h(do)g(some)f(simple)g(parsing.)47
+b(Return)23 b(the)g(array)g(of)h(matches,)192 598 y(or)f(NULL)g(if)h
+(there)f(aren't)g(any.)h(*/)120 650 y(char)f(**)120 702
+y(fileman_completion)e(\(text,)i(start,)g(end\))239 754
+y(char)h(*text;)239 806 y(int)g(start,)f(end;)120 858
+y({)168 910 y(char)g(**matches;)168 1013 y(matches)g(=)g(\(char)h
+(**\)NULL;)168 1117 y(/*)f(If)h(this)f(word)h(is)f(at)h(the)f(start)g
+(of)h(the)f(line,)h(then)f(it)g(is)h(a)g(command)239
+1169 y(to)g(complete.)46 b(Otherwise)23 b(it)h(is)f(the)h(name)f(of)h
+(a)f(file)h(in)f(the)h(current)239 1221 y(directory.)f(*/)168
+1273 y(if)g(\(start)g(==)h(0\))215 1325 y(matches)f(=)h
+(completion_matches)d(\(text,)j(command_generator\);)168
+1429 y(return)f(\(matches\);)120 1480 y(})120 1584 y(/*)h(Generator)e
+(function)h(for)g(command)g(completion.)47 b(STATE)23
+b(lets)g(us)h(know)f(whether)192 1636 y(to)g(start)g(from)h(scratch;)e
+(without)h(any)h(state)f(\(i.e.)g(STATE)g(==)h(0\),)f(then)h(we)192
+1688 y(start)f(at)g(the)h(top)f(of)h(the)f(list.)g(*/)120
+1740 y(char)g(*)120 1792 y(command_generator)f(\(text,)h(state\))239
+1844 y(char)h(*text;)239 1896 y(int)g(state;)120 1947
+y({)168 1999 y(static)f(int)g(list_index,)g(len;)168
+2051 y(char)g(*name;)168 2155 y(/*)g(If)h(this)f(is)h(a)g(new)f(word)g
+(to)h(complete,)f(initialize)f(now.)47 b(This)24 b(includes)239
+2207 y(saving)f(the)h(length)f(of)g(TEXT)h(for)f(efficiency,)g(and)g
+(initializing)f(the)i(index)239 2259 y(variable)f(to)h(0.)f(*/)168
+2311 y(if)g(\(!state\))215 2363 y({)263 2414 y(list_index)g(=)g(0;)263
+2466 y(len)h(=)f(strlen)g(\(text\);)215 2518 y(})168
+2622 y(/*)g(Return)g(the)h(next)f(name)g(which)h(partially)e(matches)h
+(from)g(the)h(command)f(list.)g(*/)p eop
+46 47 bop 0 -58 a Fr(46)1449 b(GNU)15 b(Readline)i(Library)168
+183 y Fq(while)23 b(\(name)g(=)h(commands[list_index].name)o(\))215
+235 y({)263 287 y(list_index++;)263 391 y(if)g(\(strncmp)f(\(name,)g
+(text,)g(len\))g(==)h(0\))311 443 y(return)f(\(dupstr\(name\)\);)215
+495 y(})168 598 y(/*)g(If)h(no)f(names)h(matched,)e(then)i(return)f
+(NULL.)g(*/)168 650 y(return)g(\(\(char)g(*\)NULL\);)120
+702 y(})120 806 y(/*)h(***********************)o(*******)o(********)o
+(*******)o(*******)o(********)o(****)d(*/)120 858 y(/*)1575
+b(*/)120 910 y(/*)549 b(FileMan)22 b(Commands)644 b(*/)120
+962 y(/*)1575 b(*/)120 1013 y(/*)24 b(***********************)o
+(*******)o(********)o(*******)o(*******)o(********)o(****)d(*/)120
+1117 y(/*)j(String)f(to)g(pass)h(to)f(system)g(\(\).)47
+b(This)24 b(is)f(for)h(the)f(LIST,)g(VIEW)h(and)f(RENAME)192
+1169 y(commands.)f(*/)120 1221 y(static)h(char)g(syscom[1024];)120
+1325 y(/*)h(List)f(the)g(file\(s\))g(named)g(in)h(arg.)f(*/)120
+1377 y(com_list)g(\(arg\))239 1429 y(char)h(*arg;)120
+1480 y({)168 1532 y(if)f(\(!arg\))215 1584 y(arg)h(=)g("";)168
+1688 y(sprintf)f(\(syscom,)f("ls)i(-FClg)f(\045s",)g(arg\);)168
+1740 y(return)g(\(system)g(\(syscom\)\);)120 1792 y(})120
+1896 y(com_view)g(\(arg\))239 1947 y(char)h(*arg;)120
+1999 y({)168 2051 y(if)f(\(!valid_argument)f(\("view",)h(arg\)\))215
+2103 y(return)g(1;)168 2207 y(sprintf)g(\(syscom,)f("more)i(\045s",)f
+(arg\);)168 2259 y(return)g(\(system)g(\(syscom\)\);)120
+2311 y(})120 2414 y(com_rename)f(\(arg\))239 2466 y(char)i(*arg;)120
+2518 y({)168 2570 y(too_dangerous)e(\("rename"\);)168
+2622 y(return)h(\(1\);)p eop
+47 48 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(47)120 183 y Fq(})120 287 y(com_stat)23
+b(\(arg\))239 339 y(char)h(*arg;)120 391 y({)168 443
+y(struct)f(stat)g(finfo;)168 546 y(if)g(\(!valid_argument)f(\("stat",)h
+(arg\)\))215 598 y(return)g(\(1\);)168 702 y(if)g(\(stat)g(\(arg,)h
+(&finfo\))f(==)g(-1\))215 754 y({)263 806 y(perror)g(\(arg\);)263
+858 y(return)g(\(1\);)215 910 y(})168 1013 y(printf)g(\("Statistics)f
+(for)h(`\045s':\\n",)g(arg\);)168 1117 y(printf)g(\("\045s)g(has)h
+(\045d)f(link\045s,)g(and)g(is)h(\045d)g(byte\045s)f(in)g(length.\\n",)
+g(arg,)359 1169 y(finfo.st_nlink,)359 1221 y(\(finfo.st_nlink)e(==)j
+(1\))g(?)f("")h(:)g("s",)359 1273 y(finfo.st_size,)359
+1325 y(\(finfo.st_size)e(==)h(1\))h(?)f("")h(:)g("s"\);)168
+1377 y(printf)f(\("Inode)g(Last)g(Change)g(at:)g(\045s",)h(ctime)f
+(\(&finfo.st_ctime\)\);)168 1429 y(printf)g(\(")143 b(Last)23
+b(access)g(at:)g(\045s",)h(ctime)f(\(&finfo.st_atime\)\);)168
+1480 y(printf)g(\(")95 b(Last)23 b(modified)g(at:)g(\045s",)h(ctime)f
+(\(&finfo.st_mtime\)\);)168 1532 y(return)g(\(0\);)120
+1584 y(})120 1688 y(com_delete)f(\(arg\))239 1740 y(char)i(*arg;)120
+1792 y({)168 1844 y(too_dangerous)e(\("delete"\);)168
+1896 y(return)h(\(1\);)120 1947 y(})120 2051 y(/*)h(Print)f(out)g(help)
+h(for)f(ARG,)g(or)h(for)f(all)h(of)f(the)h(commands)f(if)g(ARG)h(is)192
+2103 y(not)f(present.)g(*/)120 2155 y(com_help)g(\(arg\))239
+2207 y(char)h(*arg;)120 2259 y({)168 2311 y(register)e(int)i(i;)168
+2363 y(int)f(printed)g(=)h(0;)168 2466 y(for)f(\(i)h(=)f(0;)h
+(commands[i].name;)e(i++\))215 2518 y({)263 2570 y(if)i(\(!*arg)f(||)g
+(\(strcmp)g(\(arg,)g(commands[i].name\))f(==)i(0\)\))311
+2622 y({)p eop
+48 49 bop 0 -58 a Fr(48)1449 b(GNU)15 b(Readline)i(Library)359
+183 y Fq(printf)23 b(\("\045s\\t\\t\045s.\\n",)e(commands[i].name,)h
+(commands[i].doc\);)359 235 y(printed++;)311 287 y(})215
+339 y(})168 443 y(if)h(\(!printed\))215 495 y({)263 546
+y(printf)g(\("No)h(commands)e(match)h(`\045s'.)48 b(Possibilties)22
+b(are:\\n",)h(arg\);)263 650 y(for)h(\(i)f(=)h(0;)g(commands[i].name;)d
+(i++\))311 702 y({)359 754 y(/*)i(Print)g(in)h(six)f(columns.)g(*/)359
+806 y(if)g(\(printed)g(==)h(6\))406 858 y({)454 910 y(printed)f(=)h(0;)
+454 962 y(printf)f(\("\\n"\);)406 1013 y(})359 1117 y(printf)g
+(\("\045s\\t",)f(commands[i].name\);)359 1169 y(printed++;)311
+1221 y(})263 1325 y(if)i(\(printed\))311 1377 y(printf)f(\("\\n"\);)215
+1429 y(})168 1480 y(return)g(\(0\);)120 1532 y(})120
+1636 y(/*)h(Change)f(to)g(the)h(directory)e(ARG.)i(*/)120
+1688 y(com_cd)f(\(arg\))239 1740 y(char)h(*arg;)120 1792
+y({)168 1844 y(if)f(\(chdir)g(\(arg\))h(==)f(-1\))215
+1896 y({)263 1947 y(perror)g(\(arg\);)263 1999 y(return)g(1;)215
+2051 y(})168 2155 y(com_pwd)g(\(""\);)168 2207 y(return)g(\(0\);)120
+2259 y(})120 2363 y(/*)h(Print)f(out)g(the)h(current)f(working)f
+(directory.)h(*/)120 2414 y(com_pwd)g(\(ignore\))239
+2466 y(char)h(*ignore;)120 2518 y({)168 2570 y(char)f(dir[1024],)g(*s;)
+p eop
+49 50 bop 0 -58 a Fr(Chapter)15 b(2:)k(Programming)c(with)g(GNU)g
+(Readline)994 b(49)168 183 y Fq(s)23 b(=)h(getwd)f(\(dir\);)168
+235 y(if)g(\(s)h(==)f(0\))215 287 y({)263 339 y(printf)g(\("Error)g
+(getting)g(pwd:)g(\045s\\n",)g(dir\);)263 391 y(return)g(1;)215
+443 y(})168 546 y(printf)g(\("Current)f(directory)h(is)h(\045s\\n",)f
+(dir\);)168 598 y(return)g(0;)120 650 y(})120 754 y(/*)h(The)f(user)g
+(wishes)g(to)h(quit)f(using)g(this)h(program.)46 b(Just)24
+b(set)f(DONE)h(non-zero.)e(*/)120 806 y(com_quit)h(\(arg\))239
+858 y(char)h(*arg;)120 910 y({)168 962 y(done)f(=)h(1;)168
+1013 y(return)f(\(0\);)120 1065 y(})120 1169 y(/*)h(Function)e(which)i
+(tells)f(you)g(that)g(you)h(can't)f(do)h(this.)f(*/)120
+1221 y(too_dangerous)f(\(caller\))239 1273 y(char)i(*caller;)120
+1325 y({)168 1377 y(fprintf)f(\(stderr,)382 1429 y("\045s:)h(Too)f
+(dangerous)g(for)g(me)h(to)g(distribute.)46 b(Write)23
+b(it)h(yourself.\\n",)382 1480 y(caller\);)120 1532 y(})120
+1636 y(/*)g(Return)f(non-zero)f(if)i(ARG)f(is)h(a)g(valid)f(argument)g
+(for)g(CALLER,)g(else)g(print)192 1688 y(an)g(error)g(message)g(and)h
+(return)f(zero.)g(*/)120 1740 y(int)120 1792 y(valid_argument)f
+(\(caller,)h(arg\))239 1844 y(char)h(*caller,)e(*arg;)120
+1896 y({)168 1947 y(if)h(\(!arg)g(||)h(!*arg\))215 1999
+y({)263 2051 y(fprintf)f(\(stderr,)g("\045s:)g(Argument)g
+(required.\\n",)f(caller\);)263 2103 y(return)h(\(0\);)215
+2155 y(})168 2259 y(return)g(\(1\);)120 2311 y(})p eop
+50 51 bop 0 -58 a Fr(50)1449 b(GNU)15 b(Readline)i(Library)p
+eop
+51 52 bop 0 -58 a Fr(Concept)15 b(Index)1616 b(51)0 183
+y Fn(Concept)16 b(Index)0 430 y Fp(C)0 496 y Ff(command)e(editing)f
+Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g
+(.)23 b Ff(2)0 604 y Fp(E)0 670 y Ff(editing)15 b(command)f(lines)d
+Fe(.)6 b(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)22
+b Ff(2)0 778 y Fp(I)0 845 y Ff(initiali)q(zati)q(on)16
+b(\014le,)e(readline)d Fe(.)6 b(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)22
+b Ff(5)0 903 y(in)o(teraction,)15 b(readline)5 b Fe(.)j(.)e(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)17 b Ff(1)0 1011
+y Fp(K)0 1077 y Ff(kill)e(ring)5 b Fe(.)i(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)17 b Ff(3)1015 430 y(killin)q(g)f(text)t Fe(.)6
+b(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)17 b Ff(3)1015 579 y Fp(N)1015
+646 y Ff(notation,)e(readline)7 b Fe(.)h(.)f(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)20 b Ff(2)1015 795
+y Fp(R)1015 861 y Ff(readline,)15 b(function)8 b Fe(.)g(.)e(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)21 b Ff(19)1015
+1011 y Fp(Y)1015 1077 y Ff(y)o(anking)15 b(text)7 b Fe(.)g(.)f(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)20 b Ff(3)p eop
+52 53 bop 0 -58 a Fr(52)1449 b(GNU)15 b(Readline)i(Library)p
+eop
+53 54 bop 0 -58 a Fr(F)l(unction)16 b(and)f(V)l(ariable)i(Index)1337
+b(53)0 183 y Fn(F)-7 b(unction)15 b(and)g(V)-7 b(ariable)14
+b(Index)0 424 y Fp(\()0 490 y Fd(\(int)t Fe(.)5 b(.)h(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)17 b Ff(31)0 608 y Fp(A)0 674
+y Fd(abort)11 b(\(C-g\))c Fe(.)t(.)f(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)20 b Ff(17)0
+732 y Fd(accept-lin)o(e)10 b(\(Newline)o(,)g(Return\))5
+b Fe(.)s(.)h(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)18 b Ff(12)0 790 y Fd(alphabetic)t Fe(.)s(.)7
+b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)18 b Ff(31)0 908 y Fp(B)0 974 y Fd(backward-c)o(ha)o(r)10
+b(\(C-b\))c Fe(.)t(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)19
+b Ff(12)0 1032 y Fd(backward-d)o(el)o(ete)o(-c)o(har)9
+b(\(Rubout\))e Fe(.)f(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)23 b Ff(14)0 1090 y Fd(backward-k)o(il)o(l-l)o(in)o
+(e)10 b(\(C-x)h(Rubout\))d Fe(.)e(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)24 b Ff(15)0 1148 y Fd(backward-k)o(il)o(l-w)o
+(or)o(d)10 b(\(M-DEL\))5 b Fe(.)t(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)18 b Ff(15)0
+1207 y Fd(backward-w)o(or)o(d)10 b(\(M-b\))c Fe(.)t(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)19 b Ff(12)0 1265 y Fd(beginning-)o(of)o(-hi)o
+(st)o(ory)9 b(\(M-<\))c Fe(.)g(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)18 b Ff(13)0
+1323 y Fd(beginning-)o(of)o(-li)o(ne)9 b(\(C-a\))g Fe(.)c(.)h(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)22 b Ff(12)0 1381 y(b)q(ell-st)o(yle)s Fe(.)9
+b(.)d(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)16 b Ff(5)0 1498 y Fp(C)0
+1565 y Fd(call-last-)o(kb)o(d-m)o(ac)o(ro)9 b(\(C-x)j(e\))7
+b Fe(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)20 b Ff(17)0 1623 y Fd(capitalize)o(-w)o(ord)9
+b(\(M-c\))s Fe(.)t(.)d(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)16
+b Ff(14)0 1681 y Fd(character-)o(se)o(arc)o(h)10 b(\(C-]\))e
+Fe(.)e(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)23 b Ff(17)0 1739
+y Fd(character-)o(se)o(arc)o(h-)o(bac)o(kwa)o(rd)9 b(\(M-C-]\))c
+Fe(.)s(.)i(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)18
+b Ff(18)0 1797 y Fd(clear-scre)o(en)9 b(\(C-l\))e Fe(.)t(.)f(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)20 b Ff(12)0 1855
+y(commen)o(t-b)q(egin)13 b Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)23 b Ff(5)0 1913
+y Fd(complete)10 b(\(TAB\))t Fe(.)s(.)c(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)16 b Ff(16)0 1972 y(completion-query-i)
+q(tems)d Fe(.)6 b(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)23
+b Ff(6)0 2030 y Fd(completion)p 201 2030 12 2 v 10 w(matches)6
+b Fe(.)t(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)19
+b Ff(36)0 2088 y(con)o(v)o(ert-meta)t Fe(.)6 b(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)16
+b Ff(6)0 2146 y Fd(copy-backw)o(ar)o(d-w)o(or)o(d)10
+b(\(\))s Fe(.)5 b(.)h(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)16
+b Ff(15)0 2204 y Fd(copy-forwa)o(rd)o(-wo)o(rd)9 b(\(\))t
+Fe(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)17 b Ff(15)0
+2262 y Fd(copy-regio)o(n-)o(as-)o(ki)o(ll)9 b(\(\))h
+Fe(.)c(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)23 b Ff(15)0 2379
+y Fp(D)0 2446 y Fd(delete-cha)o(r)10 b(\(C-d\))e Fe(.)t(.)e(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)21 b Ff(14)0 2504
+y Fd(delete-hor)o(iz)o(ont)o(al)o(-sp)o(ace)9 b(\(\))c
+Fe(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)g(.)18 b Ff(15)0 2562 y Fd(digit-argu)o(me)o(nt)9
+b(\(M-0,)i(M-1,)h(...)f(M--\))5 b Fe(.)g(.)h(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)18 b Ff(16)0 2620 y Fd(digit)p 102
+2620 V 12 w(p)s Fe(.)6 b(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)16
+b Ff(32)0 2678 y Fd(digit)p 102 2678 V 12 w(value)7 b
+Fe(.)t(.)f(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)20 b Ff(32)1015 424 y Fd(ding)t Fe(.)5
+b(.)h(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)18 b Ff(31)1015
+482 y(disable-compl)q(eti)q(on)9 b Fe(.)g(.)d(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)21 b Ff(6)1015 540 y
+Fd(do-uppercas)o(e-)o(ver)o(sio)o(n)10 b(\(M-a,)g(M-b,)i(M-)p
+Fe(x)p Fd(,)g Fc(:)6 b(:)g(:)g Fd(\))j Fe(.)c(.)h(.)g(.)g(.)g(.)22
+b Ff(17)1015 598 y Fd(downcase-wo)o(rd)9 b(\(M-l\))d
+Fe(.)t(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)19
+b Ff(14)1015 656 y Fd(dump-functi)o(on)o(s)10 b(\(\))e
+Fe(.)d(.)i(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)22
+b Ff(18)1015 715 y Fd(dump-macros)9 b(\(\))t Fe(.)c(.)h(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)17 b
+Ff(18)1015 773 y Fd(dump-variab)o(le)o(s)10 b(\(\))e
+Fe(.)d(.)i(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)22
+b Ff(18)1015 890 y Fp(E)1015 956 y Ff(editing-mo)q(de)t
+Fe(.)9 b(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)17 b Ff(6)1015 1014 y(enable-k)o(eypad)d
+Fe(.)7 b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)24 b Ff(6)1015 1072 y Fd(end-kbd-mac)o(ro)9
+b(\(C-x)j(\)\))7 b Fe(.)t(.)f(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)20
+b Ff(16)1015 1131 y Fd(end-of-hist)o(or)o(y)10 b(\(M->\))t
+Fe(.)t(.)d(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)18 b Ff(13)1015
+1189 y Fd(end-of-line)9 b(\(C-e\))f Fe(.)t(.)f(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)22 b Ff(12)1015 1247 y Fd(exchange-po)o(in)o
+(t-a)o(nd-)o(ma)o(rk)9 b(\(C-x)j(C-x\))c Fe(.)d(.)h(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)22 b Ff(17)1015 1305 y(expand-tilde)10
+b Fe(.)f(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)22 b Ff(6)1015 1422 y Fp(F)1015
+1488 y Fd(filename)p 1177 1488 V 12 w(completi)o(on)p
+1388 1488 V 11 w(function)5 b Fe(.)s(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)18 b Ff(36)1015
+1547 y Fd(forward-cha)o(r)10 b(\(C-f\))d Fe(.)t(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)20 b Ff(12)1015 1605 y Fd(forward-sea)o(rc)o
+(h-h)o(ist)o(or)o(y)10 b(\(C-s\))f Fe(.)d(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)25 b Ff(13)1015
+1663 y Fd(forward-wor)o(d)10 b(\(M-f\))d Fe(.)t(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)20 b Ff(12)1015 1721 y Fd(free)p
+1097 1721 V 13 w(undo)p 1190 1721 V 13 w(list)6 b Fe(.)t(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)19
+b Ff(29)1015 1838 y Fp(H)1015 1904 y Fd(history-sea)o(rc)o(h-b)o(ack)o
+(wa)o(rd)9 b(\(\))c Fe(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)19 b Ff(13)1015
+1963 y Fd(history-sea)o(rc)o(h-f)o(orw)o(ar)o(d)10 b(\(\))d
+Fe(.)e(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)20 b Ff(13)1015 2021 y(horizon)o(tal-scrol)q(l)q
+(-mo)q(de)t Fe(.)9 b(.)d(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)17
+b Ff(6)1015 2138 y Fp(I)1015 2204 y Ff(input-meta)s Fe(.)8
+b(.)e(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)g(.)g(.)16 b Ff(7)1015 2262 y Fd(insert-comm)o(en)o(t)
+10 b(\(M-#\))t Fe(.)t(.)d(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)18
+b Ff(18)1015 2320 y Fd(insert-comp)o(le)o(tio)o(ns)9
+b(\(M-*\))f Fe(.)t(.)e(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)21 b Ff(16)1015
+2438 y Fp(K)1015 2504 y Ff(k)o(eymap)6 b Fe(.)h(.)f(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)19 b Ff(6)1015 2562 y Fd(kill-line)10 b(\(C-k\))f
+Fe(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)24
+b Ff(14)1015 2620 y Fd(kill-region)9 b(\(\))t Fe(.)c(.)h(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)17
+b Ff(15)1015 2678 y Fd(kill-whole-)o(li)o(ne)10 b(\(\))d
+Fe(.)e(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)20
+b Ff(15)p eop
+54 55 bop 0 -58 a Fr(54)1449 b(GNU)15 b(Readline)i(Library)0
+183 y Fd(kill-word)9 b(\(M-d\))g Fe(.)d(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)24 b Ff(15)0 298 y Fp(L)0
+364 y Fd(lowercase)p 182 364 12 2 v 11 w(p)7 b Fe(.)e(.)h(.)g(.)g(.)g
+(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)20
+b Ff(32)0 479 y Fp(M)0 545 y Ff(mark-mo)q(di\014ed-lin)q(es)7
+b Fe(.)i(.)d(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)20
+b Ff(7)0 603 y(meta-\015ag)10 b Fe(.)c(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)22
+b Ff(7)0 718 y Fp(N)0 784 y Fd(next-histo)o(ry)9 b(\(C-n\))e
+Fe(.)t(.)f(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)20
+b Ff(13)0 842 y Fd(non-increm)o(en)o(tal)o(-f)o(orw)o(ard)o(-s)o(ear)o
+(ch)o(-hi)o(st)o(ory)9 b(\(M-n\))82 900 y Fe(.)d(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)18 b Ff(13)0 958 y Fd(non-increm)o(en)o(tal)o(-r)o
+(eve)o(rse)o(-s)o(ear)o(ch)o(-hi)o(st)o(ory)9 b(\(M-p\))82
+1017 y Fe(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)18
+b Ff(13)0 1075 y Fd(numeric)9 b Fe(.)s(.)e(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)22
+b Ff(31)0 1189 y Fp(O)0 1256 y Ff(output-meta)8 b Fe(.)g(.)e(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+21 b Ff(7)0 1370 y Fp(P)0 1436 y Fd(possible-c)o(om)o(ple)o(ti)o(ons)9
+b(\(M-?\))c Fe(.)g(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)18 b Ff(16)0 1495 y Fd(prefix-met)o(a)10
+b(\(ESC\))e Fe(.)t(.)e(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+21 b Ff(17)0 1553 y Fd(previous-h)o(is)o(tor)o(y)10 b(\(C-p\))e
+Fe(.)e(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)23 b Ff(12)0 1667
+y Fp(Q)0 1734 y Fd(quoted-ins)o(er)o(t)10 b(\(C-q,)h(C-v\))e
+Fe(.)d(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)24 b Ff(14)0 1848 y Fp(R)0
+1914 y Fd(re-read-in)o(it)o(-fi)o(le)9 b(\(C-x)i(C-r\))c
+Fe(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)20 b Ff(17)0 1973 y Fd(readline)8 b Fe(.)s(.)e(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)21 b Ff(19)0 2031 y Fd(redraw-cur)o(re)o(nt-)o(li)o(ne)9
+b(\(\))h Fe(.)c(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)23 b Ff(12)0
+2089 y Fd(reverse-se)o(ar)o(ch-)o(hi)o(sto)o(ry)9 b(\(C-r\))h
+Fe(.)c(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g
+(.)g(.)24 b Ff(13)0 2147 y Fd(revert-lin)o(e)10 b(\(M-r\))e
+Fe(.)t(.)e(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)21
+b Ff(17)0 2205 y Fd(rl)p 42 2205 V 13 w(add)p 115 2205
+V 13 w(defun)8 b Fe(.)d(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)g(.)21 b Ff(25)0 2263 y Fd(rl)p
+42 2263 V 13 w(add)p 115 2263 V 13 w(undo)8 b Fe(.)e(.)g(.)g(.)h(.)f(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)22
+b Ff(29)0 2321 y Fd(rl)p 42 2321 V 13 w(attempted)p 235
+2321 V 11 w(completion)p 445 2321 V 10 w(function)15
+b Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)17
+b Ff(37)0 2379 y Fd(rl)p 42 2379 V 13 w(basic)p 155 2379
+V 13 w(quote)p 268 2379 V 12 w(character)o(s)e Fe(.)6
+b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)18 b Ff(38)0 2438 y Fd(rl)p 42 2438
+V 13 w(basic)p 155 2438 V 13 w(word)p 248 2438 V 12 w(break)p
+360 2438 V 12 w(characters)h Fe(.)6 b(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)23 b Ff(38)0 2496 y Fd(rl)p
+42 2496 V 13 w(begin)p 155 2496 V 13 w(undo)p 248 2496
+V 12 w(group)9 b Fe(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)23
+b Ff(28)0 2554 y Fd(rl)p 42 2554 V 13 w(bind)p 135 2554
+V 13 w(key)8 b Fe(.)e(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)22 b Ff(26)0 2612 y Fd(rl)p
+42 2612 V 13 w(bind)p 135 2612 V 13 w(key)p 208 2612
+V 13 w(in)p 261 2612 V 13 w(map)6 b Fe(.)f(.)h(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)19 b Ff(26)0 2670 y Fd(rl)p 42
+2670 V 13 w(binding)p 195 2670 V 12 w(keymap)14 b Fe(.)6
+b(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)17
+b Ff(24)1015 183 y Fd(rl)p 1057 183 V 14 w(callback)p
+1231 183 V 11 w(handler)p 1382 183 V 11 w(install)9 b
+Fe(.)t(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)22 b Ff(32)1015 241 y Fd(rl)p 1057 241
+V 14 w(callback)p 1231 241 V 11 w(handler)p 1382 241
+V 11 w(remove)8 b Fe(.)e(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)23 b Ff(33)1015 299
+y Fd(rl)p 1057 299 V 14 w(callback)p 1231 299 V 11 w(read)p
+1322 299 V 12 w(char)8 b Fe(.)d(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)21
+b Ff(32)1015 358 y Fd(rl)p 1057 358 V 14 w(char)p 1151
+358 V 12 w(is)p 1203 358 V 14 w(quoted)p 1337 358 V 12
+w(p)e Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)20
+b Ff(37)1015 416 y Fd(rl)p 1057 416 V 14 w(clear)p 1171
+416 V 12 w(message)s Fe(.)t(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)16 b Ff(30)1015 474 y Fd(rl)p 1057
+474 V 14 w(complete)7 b Fe(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)23 b Ff(35,)13 b(36)1015 532
+y Fd(rl)p 1057 532 V 14 w(complete)p 1231 532 V 11 w(internal)6
+b Fe(.)s(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)20 b
+Ff(35)1015 590 y Fd(rl)p 1057 590 V 14 w(completer)p
+1250 590 V 10 w(quote)p 1361 590 V 13 w(character)o(s)e
+Fe(.)6 b(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)22 b Ff(38)1015 648 y Fd(rl)p 1057 648 V 14 w(completer)p
+1250 648 V 10 w(word)p 1341 648 V 13 w(break)p 1454 648
+V 12 w(characters)14 b Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)18 b Ff(38)1015 706 y Fd(rl)p 1057 706 V 14 w(completio)o(n)p
+1270 706 V 11 w(append)p 1401 706 V 12 w(character)e
+Fe(.)7 b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+20 b Ff(39)1015 764 y Fd(rl)p 1057 764 V 14 w(completio)o(n)p
+1270 764 V 11 w(entry)p 1381 764 V 12 w(function)14 b
+Fe(.)7 b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)18
+b Ff(35,)13 b(37)1015 823 y Fd(rl)p 1057 823 V 14 w(completio)o(n)p
+1270 823 V 11 w(query)p 1381 823 V 12 w(items)j Fe(.)6
+b(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)f(.)g(.)18 b Ff(38)1015 881 y Fd(rl)p 1057
+881 V 14 w(copy)p 1151 881 V 12 w(keymap)6 b Fe(.)t(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)19 b
+Ff(25)1015 939 y Fd(rl)p 1057 939 V 14 w(copy)p 1151
+939 V 12 w(text)8 b Fe(.)d(.)h(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)21 b Ff(30)1015 997 y
+Fd(rl)p 1057 997 V 14 w(delete)p 1191 997 V 12 w(text)6
+b Fe(.)t(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)19 b Ff(30)1015 1055 y Fd(rl)p 1057 1055 V 14
+w(directory)p 1250 1055 V 10 w(completion)p 1461 1055
+V 11 w(hook)i Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)23 b Ff(40)1015 1113 y Fd(rl)p
+1057 1113 V 14 w(discard)p 1211 1113 V 11 w(keymap)8
+b Fe(.)e(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)24
+b Ff(25)1015 1171 y Fd(rl)p 1057 1171 V 14 w(do)p 1111
+1171 V 13 w(undo)9 b Fe(.)d(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)24 b Ff(29)1015
+1229 y Fd(rl)p 1057 1229 V 14 w(done)17 b Fe(.)6 b(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)19 b Ff(23)1015 1287 y Fd(rl)p 1057 1287 V 14
+w(end)f Fe(.)6 b(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)20 b Ff(22)1015
+1346 y Fd(rl)p 1057 1346 V 14 w(end)p 1131 1346 V 13
+w(undo)p 1224 1346 V 12 w(group)5 b Fe(.)t(.)h(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)18 b Ff(29)1015 1404 y Fd(rl)p
+1057 1404 V 14 w(event)p 1171 1404 V 12 w(hook)i Fe(.)6
+b(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)
+22 b Ff(24)1015 1462 y Fd(rl)p 1057 1462 V 14 w(executing)p
+1250 1462 V 10 w(keymap)f Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)
+g(.)23 b Ff(24)1015 1520 y Fd(rl)p 1057 1520 V 14 w(filename)p
+1231 1520 V 11 w(completio)o(n)p 1441 1520 V 11 w(desired)17
+b Fe(.)7 b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)20 b Ff(39)1015 1578 y Fd(rl)p 1057 1578 V 14 w(filename)p
+1231 1578 V 11 w(dequoting)p 1421 1578 V 11 w(function)c
+Fe(.)7 b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+20 b Ff(37)1015 1636 y Fd(rl)p 1057 1636 V 14 w(filename)p
+1231 1636 V 11 w(quote)p 1342 1636 V 12 w(characters)f
+Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)23 b Ff(38)1015 1694 y Fd(rl)p 1057 1694 V 14
+w(filename)p 1231 1694 V 11 w(quoting)p 1382 1694 V 11
+w(desired)e Fe(.)7 b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)g(.)24 b Ff(39)1015 1752 y Fd(rl)p
+1057 1752 V 14 w(filename)p 1231 1752 V 11 w(quoting)p
+1382 1752 V 11 w(function)c Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)23 b Ff(37)1015 1810
+y Fd(rl)p 1057 1810 V 14 w(forced)p 1191 1810 V 12 w(update)p
+1323 1810 V 11 w(display)t Fe(.)t(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)17
+b Ff(30)1015 1869 y Fd(rl)p 1057 1869 V 14 w(function)p
+1231 1869 V 11 w(dumper)9 b Fe(.)t(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)22 b Ff(28)1015 1927 y Fd(rl)p 1057 1927
+V 14 w(function)p 1231 1927 V 11 w(of)p 1282 1927 V 13
+w(keyseq)8 b Fe(.)t(.)e(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)21
+b Ff(27)1015 1985 y Fd(rl)p 1057 1985 V 14 w(generic)p
+1211 1985 V 11 w(bind)t Fe(.)5 b(.)h(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)18 b Ff(26)1015 2043 y Fd(rl)p
+1057 2043 V 14 w(get)p 1131 2043 V 13 w(keymap)7 b Fe(.)t(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)20
+b Ff(25)1015 2101 y Fd(rl)p 1057 2101 V 14 w(get)p 1131
+2101 V 13 w(keymap)p 1264 2101 V 12 w(by)p 1316 2101
+V 13 w(name)9 b Fe(.)d(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)24
+b Ff(26)1015 2159 y Fd(rl)p 1057 2159 V 14 w(get)p 1131
+2159 V 13 w(keymap)p 1264 2159 V 12 w(name)s Fe(.)t(.)7
+b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)17
+b Ff(26)1015 2217 y Fd(rl)p 1057 2217 V 14 w(getc)s Fe(.)5
+b(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)17 b Ff(31)1015 2275
+y Fd(rl)p 1057 2275 V 14 w(getc)p 1151 2275 V 12 w(function)e
+Fe(.)6 b(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)19
+b Ff(24)1015 2334 y Fd(rl)p 1057 2334 V 14 w(ignore)p
+1191 2334 V 12 w(completio)o(n)p 1402 2334 V 11 w(duplicate)o(s)d
+Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)19
+b Ff(39)1015 2392 y Fd(rl)p 1057 2392 V 14 w(ignore)p
+1191 2392 V 12 w(some)p 1283 2392 V 12 w(completion)o(s)p
+1514 2392 V 11 w(function)13 b Fe(.)6 b(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)17 b Ff(39)1015 2450 y Fd(rl)p 1057 2450 V
+14 w(inhibit)p 1211 2450 V 11 w(completion)g Fe(.)6 b(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)21 b Ff(39)1015 2508 y Fd(rl)p 1057 2508
+V 14 w(initializ)o(e)t Fe(.)s(.)6 b(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)17 b Ff(31)1015 2566
+y Fd(rl)p 1057 2566 V 14 w(insert)p 1191 2566 V 12 w(completio)o(ns)t
+Fe(.)t(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)19 b Ff(36)1015
+2624 y Fd(rl)p 1057 2624 V 14 w(insert)p 1191 2624 V
+12 w(text)6 b Fe(.)t(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)19 b Ff(30)p eop
+55 56 bop 0 -58 a Fr(F)l(unction)16 b(and)f(V)l(ariable)i(Index)1337
+b(55)0 183 y Fd(rl)p 42 183 12 2 v 13 w(instream)19 b
+Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)22 b Ff(23)0 241 y Fd(rl)p 42 241 V 13
+w(invoking)p 215 241 V 11 w(keyseqs)8 b Fe(.)t(.)e(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)21 b Ff(27)0 299 y Fd(rl)p 42 299
+V 13 w(invoking)p 215 299 V 11 w(keyseqs)p 366 299 V
+12 w(in)p 418 299 V 13 w(map)t Fe(.)5 b(.)i(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)17
+b Ff(27)0 358 y Fd(rl)p 42 358 V 13 w(kill)p 135 358
+V 13 w(text)8 b Fe(.)d(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)g(.)21 b Ff(30)0 416 y Fd(rl)p
+42 416 V 13 w(library)p 195 416 V 12 w(version)g Fe(.)6
+b(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)24 b Ff(23)0
+474 y Fd(rl)p 42 474 V 13 w(line)p 135 474 V 13 w(buffer)18
+b Fe(.)6 b(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)21 b Ff(22)0 532 y Fd(rl)p 42 532 V 13 w(list)p 135
+532 V 13 w(funmap)p 268 532 V 12 w(names)7 b Fe(.)f(.)g(.)g(.)g(.)g(.)g
+(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)
+g(.)g(.)g(.)g(.)g(.)22 b Ff(28)0 590 y Fd(rl)p 42 590
+V 13 w(make)p 135 590 V 13 w(bare)p 228 590 V 13 w(keymap)8
+b Fe(.)e(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)23
+b Ff(25)0 648 y Fd(rl)p 42 648 V 13 w(make)p 135 648
+V 13 w(keymap)6 b Fe(.)s(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)18 b Ff(25)0 706 y Fd(rl)p 42
+706 V 13 w(mark)f Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)18
+b Ff(22)0 764 y Fd(rl)p 42 764 V 13 w(message)8 b Fe(.)t(.)e(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+21 b Ff(30)0 823 y Fd(rl)p 42 823 V 13 w(modifying)5
+b Fe(.)s(.)h(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)18 b Ff(29)0 881 y Fd(rl)p 42 881 V 13
+w(named)p 155 881 V 13 w(function)7 b Fe(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)h(.)f(.)g(.)g(.)g(.)g(.)23 b Ff(27)0 939 y Fd(rl)p
+42 939 V 13 w(on)p 95 939 V 14 w(new)p 169 939 V 13 w(line)8
+b Fe(.)d(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)21 b Ff(30)0 997 y Fd(rl)p 42 997 V 13 w(outstream)c
+Fe(.)6 b(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)20 b Ff(23)0 1055 y Fd(rl)p 42 1055 V 13 w(parse)p
+155 1055 V 13 w(and)p 228 1055 V 13 w(bind)5 b Fe(.)t(.)h(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)17 b Ff(27)0
+1113 y Fd(rl)p 42 1113 V 13 w(pending)p 195 1113 V 12
+w(input)f Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)18 b Ff(23)0 1171 y Fd(rl)p 42 1171 V 13 w(point)d
+Fe(.)6 b(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)17 b Ff(22)0 1229 y Fd(rl)p
+42 1229 V 13 w(possible)p 215 1229 V 11 w(completions)7
+b Fe(.)f(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)24 b Ff(36)0 1287 y Fd(rl)p
+42 1287 V 13 w(prompt)e Fe(.)6 b(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)24 b Ff(23)0
+1346 y Fd(rl)p 42 1346 V 13 w(read)p 135 1346 V 13 w(init)p
+228 1346 V 13 w(file)5 b Fe(.)t(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)17 b Ff(27)0 1404 y Fd(rl)p 42 1404 V
+13 w(read)p 135 1404 V 13 w(key)8 b Fe(.)e(.)g(.)g(.)h(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)22
+b Ff(31)0 1462 y Fd(rl)p 42 1462 V 13 w(readline)p 215
+1462 V 11 w(name)17 b Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)
+g(.)g(.)g(.)g(.)18 b Ff(23)0 1520 y Fd(rl)p 42 1520 V
+13 w(redisplay)5 b Fe(.)s(.)h(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)18 b Ff(29)0 1578 y Fd(rl)p
+42 1578 V 13 w(redisplay)p 235 1578 V 11 w(function)f
+Fe(.)6 b(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)20 b Ff(24)0
+1636 y Fd(rl)p 42 1636 V 13 w(reset)p 155 1636 V 13 w(line)p
+248 1636 V 12 w(state)9 b Fe(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)23 b Ff(30)0 1694 y Fd(rl)p 42 1694 V 13 w(reset)p
+155 1694 V 13 w(terminal)7 b Fe(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)
+g(.)g(.)g(.)g(.)23 b Ff(31)0 1752 y Fd(rl)p 42 1752 V
+13 w(set)p 115 1752 V 13 w(keymap)7 b Fe(.)t(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)20 b Ff(26)0
+1810 y Fd(rl)p 42 1810 V 13 w(special)p 195 1810 V 12
+w(prefixes)f Fe(.)7 b(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)23
+b Ff(38)0 1869 y Fd(rl)p 42 1869 V 13 w(startup)p 195
+1869 V 12 w(hook)18 b Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)19 b Ff(23)0 1927 y Fd(rl)p 42 1927
+V 13 w(stuff)p 155 1927 V 13 w(char)7 b Fe(.)t(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)20 b
+Ff(31)0 1985 y Fd(rl)p 42 1985 V 13 w(terminal)p 215
+1985 V 11 w(name)d Fe(.)6 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)
+g(.)g(.)g(.)18 b Ff(23)0 2043 y Fd(rl)p 42 2043 V 13
+w(unbind)p 175 2043 V 12 w(key)7 b Fe(.)e(.)h(.)g(.)g(.)g(.)g(.)g(.)g
+(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)20 b Ff(26)1015
+183 y Fd(rl)p 1057 183 V 14 w(unbind)p 1191 183 V 12
+w(key)p 1263 183 V 13 w(in)p 1316 183 V 13 w(map)t Fe(.)t(.)6
+b(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)17 b Ff(26)1015
+291 y Fp(S)1015 358 y Fd(self-insert)9 b(\(a,)j(b,)g(A,)g(1,)g(!,)g
+(...\))6 b Fe(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)h(.)19 b Ff(14)1015 416 y Fd(set-mark)10 b(\(C-@\))t
+Fe(.)t(.)c(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)17 b Ff(17)1015 474 y(sho)o(w-all-if-am)o(bigu)q(ous)9
+b Fe(.)g(.)d(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)22
+b Ff(7)1015 532 y Fd(start-kbd-m)o(ac)o(ro)10 b(\(C-x)h(\(\))t
+Fe(.)5 b(.)h(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)17 b Ff(16)1015 640
+y Fp(T)1015 706 y Fd(tab-insert)9 b(\(M-TAB\))e Fe(.)t(.)f(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)20 b Ff(14)1015 764 y
+Fd(tilde-expan)o(d)10 b(\(M-~\))d Fe(.)t(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)h(.)f(.)g(.)g(.)20 b Ff(17)1015 823 y Fd(to)p 1057
+823 V 14 w(lower)8 b Fe(.)f(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)24 b
+Ff(32)1015 881 y Fd(to)p 1057 881 V 14 w(upper)8 b Fe(.)f(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)24 b Ff(32)1015 939 y Fd(transpose-c)o(ha)o(rs)10
+b(\(C-t\))s Fe(.)t(.)c(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)16
+b Ff(14)1015 997 y Fd(transpose-w)o(or)o(ds)10 b(\(M-t\))s
+Fe(.)t(.)c(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)16 b Ff(14)1015
+1105 y Fp(U)1015 1171 y Fd(undo)c(\(C-)p 1169 1171 V
+13 w(,)g(C-x)g(C-u\))7 b Fe(.)t(.)f(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)
+g(.)g(.)20 b Ff(17)1015 1229 y Fd(universal-a)o(rg)o(ume)o(nt)9
+b(\(\))s Fe(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)16
+b Ff(16)1015 1287 y Fd(unix-line-d)o(is)o(car)o(d)10
+b(\(C-u\))f Fe(.)t(.)d(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)22 b Ff(15)1015
+1346 y Fd(unix-word-r)o(ub)o(out)9 b(\(C-w\))g Fe(.)d(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)24 b Ff(15)1015 1404 y Fd(upcase-word)9 b(\(M-u\))f
+Fe(.)t(.)f(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)22
+b Ff(14)1015 1462 y Fd(uppercase)p 1197 1462 V 11 w(p)7
+b Fe(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)
+f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g
+(.)g(.)g(.)g(.)g(.)20 b Ff(32)1015 1520 y Fd(username)p
+1177 1520 V 12 w(completi)o(on)p 1388 1520 V 11 w(function)5
+b Fe(.)s(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)
+g(.)g(.)g(.)18 b Ff(36)1015 1628 y Fp(V)1015 1694 y Ff(visible-stats)6
+b Fe(.)j(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)h(.)18 b Ff(7)1015 1802 y Fp(Y)1015
+1869 y Fd(yank)12 b(\(C-y\))d Fe(.)t(.)d(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)22
+b Ff(15)1015 1927 y Fd(yank-last-a)o(rg)9 b(\(M-.,)i(M-)p
+1436 1927 V 13 w(\))6 b Fe(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g
+(.)g(.)g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)19
+b Ff(13)1015 1985 y Fd(yank-nth-ar)o(g)10 b(\(M-C-y\))t
+Fe(.)s(.)d(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)18 b Ff(13)1015
+2043 y Fd(yank-pop)10 b(\(M-y\))t Fe(.)t(.)c(.)g(.)g(.)g(.)g(.)g(.)g(.)
+g(.)h(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)h
+(.)f(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)17 b Ff(15)p eop
+56 57 bop 0 -58 a Fr(56)1449 b(GNU)15 b(Readline)i(Library)p
+eop
+-1 58 bop 1937 -58 a Fr(i)0 183 y Fn(T)-7 b(able)15 b(of)g(Con)n(ten)n
+(ts)0 358 y Fp(1)67 b(Command)22 b(Line)i(Editing)18
+b Fb(.)10 b(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g
+(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)38 b Fp(1)149
+435 y Fr(1.1)45 b(In)o(tro)q(duction)16 b(to)f(Line)h(Editing)d
+Fa(.)8 b(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)27 b Fr(1)149 498 y(1.2)45 b(Readline)17 b(In)o(teraction)8
+b Fa(.)g(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)22 b Fr(1)299
+560 y(1.2.1)44 b(Readline)17 b(Bare)e(Essen)o(tials)f
+Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)27
+b Fr(2)299 622 y(1.2.2)44 b(Readline)17 b(Mo)o(v)o(emen)o(t)d(Commands)
+7 b Fa(.)g(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)21 b Fr(2)299 684
+y(1.2.3)44 b(Readline)17 b(Killing)h(Commands)10 b Fa(.)e(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)25 b Fr(3)299 747 y(1.2.4)44
+b(Readline)17 b(Argumen)o(ts)12 b Fa(.)7 b(.)h(.)g(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)27 b Fr(4)299 809
+y(1.2.5)44 b(Searc)o(hing)16 b(for)e(Commands)h(in)h(the)f(History)e
+Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+27 b Fr(4)149 871 y(1.3)45 b(Readline)17 b(Init)g(File)e
+Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)28 b Fr(5)299
+934 y(1.3.1)44 b(Readline)17 b(Init)f(File)h(Syn)o(tax)6
+b Fa(.)h(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)21
+b Fr(5)299 996 y(1.3.2)44 b(Conditional)16 b(Init)g(Constructs)t
+Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)19 b
+Fr(8)299 1058 y(1.3.3)44 b(Sample)16 b(Init)g(File)11
+b Fa(.)e(.)e(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)25 b Fr(9)149 1120 y(1.4)45 b(Bindable)17
+b(Readline)h(Commands)6 b Fa(.)h(.)g(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)g(.)f(.)h(.)f(.)21 b Fr(12)299 1183 y(1.4.1)44
+b(Commands)14 b(F)l(or)h(Mo)o(ving)e Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)28 b Fr(12)299 1245 y(1.4.2)44
+b(Commands)14 b(F)l(or)h(Manipulating)i(The)e(History)9
+b Fa(.)e(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)24
+b Fr(12)299 1307 y(1.4.3)44 b(Commands)14 b(F)l(or)h(Changing)h(T)l
+(ext)e Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)29 b Fr(13)299 1369
+y(1.4.4)44 b(Killing)18 b(And)e(Y)l(anking)8 b Fa(.)g(.)g(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)23 b Fr(14)299
+1432 y(1.4.5)44 b(Sp)q(ecifying)17 b(Numeric)f(Argumen)o(ts)c
+Fa(.)c(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)27 b Fr(15)299 1494 y(1.4.6)44
+b(Letting)15 b(Readline)j(T)o(yp)q(e)d(F)l(or)g(Y)l(ou)9
+b Fa(.)f(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)25 b Fr(16)299 1556 y(1.4.7)44
+b(Keyb)q(oard)15 b(Macros)5 b Fa(.)i(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)21 b Fr(16)299
+1618 y(1.4.8)44 b(Some)15 b(Miscellaneous)i(Commands)6
+b Fa(.)h(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)21 b Fr(17)149 1681 y(1.5)45
+b(Readline)17 b(vi)f(Mo)q(de)d Fa(.)8 b(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)28 b Fr(18)0 1805 y Fp(2)67 b(Programming)23 b(with)g(GNU)f
+(Readline)d Fb(.)10 b(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g
+(.)g(.)41 b Fp(19)149 1883 y Fr(2.1)k(Basic)16 b(Beha)o(vior)7
+b Fa(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)22
+b Fr(19)149 1945 y(2.2)45 b(Custom)14 b(F)l(unctions)7
+b Fa(.)i(.)e(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)22 b Fr(21)299
+2008 y(2.2.1)44 b(The)15 b(F)l(unction)h(T)o(yp)q(e)10
+b Fa(.)e(.)g(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)26 b Fr(21)299 2070 y(2.2.2)44 b(W)l(riting)16 b(a)e(New)i(F)l
+(unction)5 b Fa(.)k(.)e(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)21
+b Fr(22)149 2132 y(2.3)45 b(Readline)17 b(V)l(ariables)f
+Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)29 b Fr(22)149
+2194 y(2.4)45 b(Readline)17 b(Con)o(v)o(enience)g(F)l(unctions)7
+b Fa(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)22
+b Fr(24)299 2257 y(2.4.1)44 b(Naming)15 b(a)g(F)l(unction)e
+Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)27 b Fr(24)299 2319 y(2.4.2)44 b(Selecting)17 b(a)e(Keymap)6
+b Fa(.)h(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)21 b Fr(25)299 2381 y(2.4.3)44 b(Binding)17 b(Keys)t
+Fa(.)8 b(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)20 b Fr(26)299 2444 y(2.4.4)44
+b(Asso)q(ciating)16 b(F)l(unction)g(Names)f(and)g(Bindings)8
+b Fa(.)h(.)f(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)23
+b Fr(27)299 2506 y(2.4.5)44 b(Allo)o(wing)16 b(Undoing)f
+Fa(.)7 b(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)29 b Fr(28)299 2568 y(2.4.6)44 b(Redispla)o(y)10
+b Fa(.)f(.)f(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)25 b Fr(29)299
+2630 y(2.4.7)44 b(Mo)q(difying)16 b(T)l(ext)6 b Fa(.)i(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)21
+b Fr(30)p eop
+-2 59 bop 0 -58 a Fr(ii)1471 b(GNU)15 b(Readline)i(Library)299
+42 y(2.4.8)44 b(Utilit)o(y)16 b(F)l(unctions)e Fa(.)7
+b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)
+f(.)28 b Fr(31)299 104 y(2.4.9)44 b(Alternate)15 b(In)o(terface)t
+Fa(.)8 b(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f
+(.)h(.)19 b Fr(32)299 166 y(2.4.10)43 b(An)16 b(Example)f
+Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f
+(.)h(.)f(.)h(.)f(.)h(.)29 b Fr(33)149 228 y(2.5)45 b(Custom)14
+b(Completers)f Fa(.)7 b(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h
+(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)27 b
+Fr(34)299 291 y(2.5.1)44 b(Ho)o(w)14 b(Completing)i(W)l(orks)9
+b Fa(.)f(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)25
+b Fr(34)299 353 y(2.5.2)44 b(Completion)16 b(F)l(unctions)6
+b Fa(.)i(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)21
+b Fr(35)299 415 y(2.5.3)44 b(Completion)16 b(V)l(ariables)11
+b Fa(.)e(.)e(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)
+h(.)f(.)h(.)f(.)h(.)f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)26
+b Fr(37)299 477 y(2.5.4)44 b(A)15 b(Short)g(Completion)h(Example)t
+Fa(.)8 b(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)f(.)h(.)
+f(.)h(.)g(.)f(.)h(.)f(.)h(.)f(.)h(.)19 b Fr(40)0 602
+y Fp(Concept)j(Index)11 b Fb(.)g(.)f(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)
+g(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)h
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)34 b Fp(51)0
+742 y(F)-6 b(unction)25 b(and)d(V)-6 b(ariable)24 b(Index)17
+b Fb(.)10 b(.)g(.)g(.)g(.)g(.)f(.)h(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)f(.)h
+(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)g(.)38 b Fp(53)p eop end
+userdict /end-hook known{end-hook}if
diff --git a/readline/doc/readline_toc.html b/readline/doc/readline_toc.html
new file mode 100644
--- /dev/null
+++ b/readline/doc/readline_toc.html
@@ -0,0 +1,77 @@
+<HTML>
+<HEAD>
+<!-- This HTML file has been created by texi2html 1.51
+     from /usr/homes/chet/src/bash/readline-2.1-beta2/doc/rlman.texinfo on 22 May 1997 -->
+
+<TITLE>GNU Readline Library - Table of Contents</TITLE>
+</HEAD>
+<BODY>
+<H1>GNU Readline Library</H1>
+<H2>Edition 2.1, for <CODE>Readline Library</CODE> Version 2.1.</H2>
+<H2>March 1996</H2>
+<ADDRESS>Brian Fox, Free Software Foundation</ADDRESS>
+<ADDRESS>Chet Ramey, Case Western Reserve University</ADDRESS>
+<P>
+<P><HR><P>
+<UL>
+<LI><A NAME="TOC1" HREF="readline.html#SEC1">Command Line Editing</A>
+<UL>
+<LI><A NAME="TOC2" HREF="readline.html#SEC2">Introduction to Line Editing</A>
+<LI><A NAME="TOC3" HREF="readline.html#SEC3">Readline Interaction</A>
+<UL>
+<LI><A NAME="TOC4" HREF="readline.html#SEC4">Readline Init File Syntax</A>
+<LI><A NAME="TOC5" HREF="readline.html#SEC5">Conditional Init Constructs</A>
+<LI><A NAME="TOC6" HREF="readline.html#SEC6">Sample Init File</A>
+</UL>
+<LI><A NAME="TOC7" HREF="readline.html#SEC7">Bindable Readline Commands</A>
+<UL>
+<LI><A NAME="TOC8" HREF="readline.html#SEC8">Commands For Moving</A>
+<LI><A NAME="TOC9" HREF="readline.html#SEC9">Commands For Manipulating The History</A>
+<LI><A NAME="TOC10" HREF="readline.html#SEC10">Commands For Changing Text</A>
+<LI><A NAME="TOC11" HREF="readline.html#SEC11">Killing And Yanking</A>
+<LI><A NAME="TOC12" HREF="readline.html#SEC12">Specifying Numeric Arguments</A>
+<LI><A NAME="TOC13" HREF="readline.html#SEC13">Letting Readline Type For You</A>
+<LI><A NAME="TOC14" HREF="readline.html#SEC14">Keyboard Macros</A>
+<LI><A NAME="TOC15" HREF="readline.html#SEC15">Some Miscellaneous Commands</A>
+</UL>
+<LI><A NAME="TOC16" HREF="readline.html#SEC16">Readline vi Mode</A>
+</UL>
+<LI><A NAME="TOC17" HREF="readline.html#SEC17">Programming with GNU Readline</A>
+<UL>
+<LI><A NAME="TOC18" HREF="readline.html#SEC18">Basic Behavior</A>
+<LI><A NAME="TOC19" HREF="readline.html#SEC19">Custom Functions</A>
+<UL>
+<LI><A NAME="TOC20" HREF="readline.html#SEC20">The Function Type</A>
+<LI><A NAME="TOC21" HREF="readline.html#SEC21">Writing a New Function</A>
+</UL>
+<LI><A NAME="TOC22" HREF="readline.html#SEC22">Readline Variables</A>
+<LI><A NAME="TOC23" HREF="readline.html#SEC23">Readline Convenience Functions</A>
+<UL>
+<LI><A NAME="TOC24" HREF="readline.html#SEC24">Naming a Function</A>
+<LI><A NAME="TOC25" HREF="readline.html#SEC25">Selecting a Keymap</A>
+<LI><A NAME="TOC26" HREF="readline.html#SEC26">Binding Keys</A>
+<LI><A NAME="TOC27" HREF="readline.html#SEC27">Associating Function Names and Bindings</A>
+<LI><A NAME="TOC28" HREF="readline.html#SEC28">Allowing Undoing</A>
+<LI><A NAME="TOC29" HREF="readline.html#SEC29">Redisplay</A>
+<LI><A NAME="TOC30" HREF="readline.html#SEC30">Modifying Text</A>
+<LI><A NAME="TOC31" HREF="readline.html#SEC31">Utility Functions</A>
+<LI><A NAME="TOC32" HREF="readline.html#SEC32">Alternate Interface</A>
+<LI><A NAME="TOC33" HREF="readline.html#SEC33">An Example</A>
+</UL>
+<LI><A NAME="TOC34" HREF="readline.html#SEC34">Custom Completers</A>
+<UL>
+<LI><A NAME="TOC35" HREF="readline.html#SEC35">How Completing Works</A>
+<LI><A NAME="TOC36" HREF="readline.html#SEC36">Completion Functions</A>
+<LI><A NAME="TOC37" HREF="readline.html#SEC37">Completion Variables</A>
+<LI><A NAME="TOC38" HREF="readline.html#SEC38">A Short Completion Example</A>
+</UL>
+</UL>
+<LI><A NAME="TOC39" HREF="readline.html#SEC39">Concept Index</A>
+<LI><A NAME="TOC40" HREF="readline.html#SEC40">Function and Variable Index</A>
+</UL>
+<P><HR><P>
+This document was generated on 22 May 1997 using the
+<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
+translator version 1.51.</P>
+</BODY>
+</HTML>
diff --git a/readline/doc/rlman.texinfo b/readline/doc/rlman.texinfo
new file mode 100644
--- /dev/null
+++ b/readline/doc/rlman.texinfo
@@ -0,0 +1,110 @@
+\input texinfo    @c -*-texinfo-*-
+@comment %**start of header (This is for running Texinfo on a region.)
+@setfilename readline.info
+@settitle GNU Readline Library
+@comment %**end of header (This is for running Texinfo on a region.)
+@synindex vr fn
+@setchapternewpage odd
+
+@ignore
+last change: Thu Mar 21 16:06:39 EST 1996
+@end ignore
+
+@set EDITION 2.1
+@set VERSION 2.1
+@set UPDATED 21 March 1996
+@set UPDATE-MONTH March 1996
+
+@ifinfo
+This document describes the GNU Readline Library, a utility which aids
+in the consistency of user interface across discrete programs that need
+to provide a command line interface.
+
+Copyright (C) 1988, 1991 Free Software Foundation, Inc.
+
+Permission is granted to make and distribute verbatim copies of
+this manual provided the copyright notice and this permission notice
+pare preserved on all copies.
+
+@ignore
+Permission is granted to process this file through TeX and print the
+results, provided the printed document carries copying permission
+notice identical to this one except for the removal of this paragraph
+(this paragraph not being relevant to the printed manual).
+@end ignore
+
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided that the entire
+resulting derived work is distributed under the terms of a permission
+notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions,
+except that this permission notice may be stated in a translation approved
+by the Foundation.
+@end ifinfo
+
+@titlepage  
+@title GNU Readline Library
+@subtitle Edition @value{EDITION}, for @code{Readline Library} Version @value{VERSION}.
+@subtitle @value{UPDATE-MONTH}
+@author Brian Fox, Free Software Foundation
+@author Chet Ramey, Case Western Reserve University
+
+@page
+This document describes the GNU Readline Library, a utility which aids
+in the consistency of user interface across discrete programs that need
+to provide a command line interface.
+
+Published by the Free Software Foundation @*
+675 Massachusetts Avenue, @*
+Cambridge, MA 02139 USA
+
+Permission is granted to make and distribute verbatim copies of
+this manual provided the copyright notice and this permission notice
+are preserved on all copies.
+
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided that the entire
+resulting derived work is distributed under the terms of a permission
+notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions,
+except that this permission notice may be stated in a translation approved
+by the Foundation.
+
+@vskip 0pt plus 1filll
+Copyright @copyright{} 1989, 1991 Free Software Foundation, Inc.
+@end titlepage
+
+@ifinfo
+@node Top
+@top GNU Readline Library
+
+This document describes the GNU Readline Library, a utility which aids
+in the consistency of user interface across discrete programs that need
+to provide a command line interface.
+
+@menu
+* Command Line Editing::	   GNU Readline User's Manual.
+* Programming with GNU Readline::  GNU Readline Programmer's Manual.
+* Concept Index::		   Index of concepts described in this manual.
+* Function and Variable Index::	   Index of externally visible functions
+				   and variables.
+@end menu
+@end ifinfo
+
+@include rluser.texinfo
+@include rltech.texinfo
+
+@node Concept Index
+@unnumbered Concept Index
+@printindex cp
+
+@node Function and Variable Index
+@unnumbered Function and Variable Index
+@printindex fn
+
+@contents
+@bye
diff --git a/readline/doc/rltech.texinfo b/readline/doc/rltech.texinfo
new file mode 100644
--- /dev/null
+++ b/readline/doc/rltech.texinfo
@@ -0,0 +1,1540 @@
+@comment %**start of header (This is for running Texinfo on a region.)
+@setfilename rltech.info
+@comment %**end of header (This is for running Texinfo on a region.)
+@setchapternewpage odd
+
+@ifinfo
+This document describes the GNU Readline Library, a utility for aiding
+in the consitency of user interface across discrete programs that need
+to provide a command line interface.
+
+Copyright (C) 1988, 1994, 1996 Free Software Foundation, Inc.
+
+Permission is granted to make and distribute verbatim copies of
+this manual provided the copyright notice and this permission notice
+pare preserved on all copies.
+
+@ignore
+Permission is granted to process this file through TeX and print the
+results, provided the printed document carries copying permission
+notice identical to this one except for the removal of this paragraph
+(this paragraph not being relevant to the printed manual).
+@end ignore
+
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided that the entire
+resulting derived work is distributed under the terms of a permission
+notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions,
+except that this permission notice may be stated in a translation approved
+by the Foundation.
+@end ifinfo
+
+@node Programming with GNU Readline
+@chapter Programming with GNU Readline
+
+This chapter describes the interface between the GNU Readline Library and
+other programs.  If you are a programmer, and you wish to include the
+features found in GNU Readline
+such as completion, line editing, and interactive history manipulation
+in your own programs, this section is for you.
+
+@menu
+* Basic Behavior::	Using the default behavior of Readline.
+* Custom Functions::	Adding your own functions to Readline.
+* Readline Variables::			Variables accessible to custom
+					functions.
+* Readline Convenience Functions::	Functions which Readline supplies to
+					aid in writing your own
+* Custom Completers::	Supplanting or supplementing Readline's
+			completion functions.
+@end menu
+
+@node Basic Behavior
+@section Basic Behavior
+
+Many programs provide a command line interface, such as @code{mail},
+@code{ftp}, and @code{sh}.  For such programs, the default behaviour of
+Readline is sufficient.  This section describes how to use Readline in
+the simplest way possible, perhaps to replace calls in your code to
+@code{gets()} or @code{fgets ()}.
+
+@findex readline
+@cindex readline, function
+The function @code{readline ()} prints a prompt and then reads and returns
+a single line of text from the user.  The line @code{readline}
+returns is allocated with @code{malloc ()}; you should @code{free ()}
+the line when you are done with it.  The declaration for @code{readline}
+in ANSI C is
+
+@example
+@code{char *readline (char *@var{prompt});}
+@end example
+
+@noindent
+So, one might say
+@example
+@code{char *line = readline ("Enter a line: ");}
+@end example
+@noindent
+in order to read a line of text from the user.
+The line returned has the final newline removed, so only the
+text remains.
+
+If @code{readline} encounters an @code{EOF} while reading the line, and the
+line is empty at that point, then @code{(char *)NULL} is returned.
+Otherwise, the line is ended just as if a newline had been typed.
+
+If you want the user to be able to get at the line later, (with
+@key{C-p} for example), you must call @code{add_history ()} to save the
+line away in a @dfn{history} list of such lines.
+
+@example
+@code{add_history (line)};
+@end example
+
+@noindent
+For full details on the GNU History Library, see the associated manual.
+
+It is preferable to avoid saving empty lines on the history list, since
+users rarely have a burning need to reuse a blank line.  Here is
+a function which usefully replaces the standard @code{gets ()} library
+function, and has the advantage of no static buffer to overflow:
+
+@example
+/* A static variable for holding the line. */
+static char *line_read = (char *)NULL;
+
+/* Read a string, and return a pointer to it.  Returns NULL on EOF. */
+char *
+rl_gets ()
+@{
+  /* If the buffer has already been allocated, return the memory
+     to the free pool. */
+  if (line_read)
+    @{
+      free (line_read);
+      line_read = (char *)NULL;
+    @}
+
+  /* Get a line from the user. */
+  line_read = readline ("");
+
+  /* If the line has any text in it, save it on the history. */
+  if (line_read && *line_read)
+    add_history (line_read);
+
+  return (line_read);
+@}
+@end example
+
+This function gives the user the default behaviour of @key{TAB}
+completion: completion on file names.  If you do not want Readline to
+complete on filenames, you can change the binding of the @key{TAB} key
+with @code{rl_bind_key ()}.
+
+@example
+@code{int rl_bind_key (int @var{key}, int (*@var{function})());}
+@end example
+
+@code{rl_bind_key ()} takes two arguments: @var{key} is the character that
+you want to bind, and @var{function} is the address of the function to
+call when @var{key} is pressed.  Binding @key{TAB} to @code{rl_insert ()}
+makes @key{TAB} insert itself.
+@code{rl_bind_key ()} returns non-zero if @var{key} is not a valid
+ASCII character code (between 0 and 255).
+
+Thus, to disable the default @key{TAB} behavior, the following suffices:
+@example
+@code{rl_bind_key ('\t', rl_insert);}
+@end example
+
+This code should be executed once at the start of your program; you
+might write a function called @code{initialize_readline ()} which
+performs this and other desired initializations, such as installing
+custom completers (@pxref{Custom Completers}).
+
+@node Custom Functions
+@section Custom Functions
+
+Readline provides many functions for manipulating the text of
+the line, but it isn't possible to anticipate the needs of all
+programs.  This section describes the various functions and variables
+defined within the Readline library which allow a user program to add
+customized functionality to Readline.
+
+@menu
+* The Function Type::	C declarations to make code readable.
+* Function Writing::	Variables and calling conventions.
+@end menu
+
+@node The Function Type
+@subsection The Function Type
+
+For readabilty, we declare a new type of object, called
+@dfn{Function}.  A @code{Function} is a C function which
+returns an @code{int}.  The type declaration for @code{Function} is:
+
+@noindent
+@code{typedef int Function ();}
+
+The reason for declaring this new type is to make it easier to write
+code describing pointers to C functions.  Let us say we had a variable
+called @var{func} which was a pointer to a function.  Instead of the
+classic C declaration
+
+@code{int (*)()func;}
+
+@noindent
+we may write
+
+@code{Function *func;}
+
+@noindent
+Similarly, there are
+
+@example
+typedef void VFunction ();
+typedef char *CPFunction (); @r{and}
+typedef char **CPPFunction ();
+@end example
+
+@noindent
+for functions returning no value, @code{pointer to char}, and
+@code{pointer to pointer to char}, respectively.
+
+@node Function Writing
+@subsection Writing a New Function
+
+In order to write new functions for Readline, you need to know the
+calling conventions for keyboard-invoked functions, and the names of the
+variables that describe the current state of the line read so far.
+
+The calling sequence for a command @code{foo} looks like
+
+@example
+@code{foo (int count, int key)}
+@end example
+
+@noindent
+where @var{count} is the numeric argument (or 1 if defaulted) and
+@var{key} is the key that invoked this function.
+
+It is completely up to the function as to what should be done with the
+numeric argument.  Some functions use it as a repeat count, some
+as a flag, and others to choose alternate behavior (refreshing the current
+line as opposed to refreshing the screen, for example).  Some choose to
+ignore it.  In general, if a
+function uses the numeric argument as a repeat count, it should be able
+to do something useful with both negative and positive arguments.
+At the very least, it should be aware that it can be passed a
+negative argument.
+
+@node Readline Variables
+@section Readline Variables
+
+These variables are available to function writers.
+
+@deftypevar {char *} rl_line_buffer
+This is the line gathered so far.  You are welcome to modify the
+contents of the line, but see @ref{Allowing Undoing}.
+@end deftypevar
+
+@deftypevar int rl_point
+The offset of the current cursor position in @code{rl_line_buffer}
+(the @emph{point}).
+@end deftypevar
+
+@deftypevar int rl_end
+The number of characters present in @code{rl_line_buffer}.  When
+@code{rl_point} is at the end of the line, @code{rl_point} and
+@code{rl_end} are equal.
+@end deftypevar
+
+@deftypevar int rl_mark
+The mark (saved position) in the current line.  If set, the mark
+and point define a @emph{region}.
+@end deftypevar
+
+@deftypevar int rl_done
+Setting this to a non-zero value causes Readline to return the current
+line immediately.
+@end deftypevar
+
+@deftypevar int rl_pending_input
+Setting this to a value makes it the next keystroke read.  This is a
+way to stuff a single character into the input stream.
+@end deftypevar
+
+@deftypevar {char *} rl_prompt
+The prompt Readline uses.  This is set from the argument to
+@code{readline ()}, and should not be assigned to directly.
+@end deftypevar
+
+@deftypevar {char *} rl_library_version
+The version number of this revision of the library.
+@end deftypevar
+
+@deftypevar {char *} rl_terminal_name
+The terminal type, used for initialization.
+@end deftypevar
+
+@deftypevar {char *} rl_readline_name
+This variable is set to a unique name by each application using Readline.
+The value allows conditional parsing of the inputrc file
+(@pxref{Conditional Init Constructs}).
+@end deftypevar
+
+@deftypevar {FILE *} rl_instream
+The stdio stream from which Readline reads input.
+@end deftypevar
+
+@deftypevar {FILE *} rl_outstream
+The stdio stream to which Readline performs output.
+@end deftypevar
+
+@deftypevar {Function *} rl_startup_hook
+If non-zero, this is the address of a function to call just
+before @code{readline} prints the first prompt.
+@end deftypevar
+
+@deftypevar {Function *} rl_event_hook
+If non-zero, this is the address of a function to call periodically
+when readline is waiting for terminal input.
+@end deftypevar
+
+@deftypevar {Function *} rl_getc_function
+If non-zero, @code{readline} will call indirectly through this pointer
+to get a character from the input stream.  By default, it is set to
+@code{rl_getc}, the default @code{readline} character input function
+(@pxref{Utility Functions}).
+@end deftypevar
+
+@deftypevar {VFunction *} rl_redisplay_function
+If non-zero, @code{readline} will call indirectly through this pointer
+to update the display with the current contents of the editing buffer.
+By default, it is set to @code{rl_redisplay}, the default @code{readline}
+redisplay function (@pxref{Redisplay}).
+@end deftypevar
+
+@deftypevar {Keymap} rl_executing_keymap
+This variable is set to the keymap (@pxref{Keymaps}) in which the
+currently executing readline function was found.
+@end deftypevar 
+
+@deftypevar {Keymap} rl_binding_keymap
+This variable is set to the keymap (@pxref{Keymaps}) in which the
+last key binding occurred.
+@end deftypevar 
+
+@node Readline Convenience Functions
+@section Readline Convenience Functions
+
+@menu
+* Function Naming::	How to give a function you write a name.
+* Keymaps::		Making keymaps.
+* Binding Keys::	Changing Keymaps.
+* Associating Function Names and Bindings::	Translate function names to
+						key sequences.
+* Allowing Undoing::	How to make your functions undoable.
+* Redisplay::		Functions to control line display.
+* Modifying Text::	Functions to modify @code{rl_line_buffer}.
+* Utility Functions::	Generally useful functions and hooks.
+* Alternate Interface::	Using Readline in a `callback' fashion.
+@end menu
+
+@node Function Naming
+@subsection Naming a Function
+
+The user can dynamically change the bindings of keys while using
+Readline.  This is done by representing the function with a descriptive
+name.  The user is able to type the descriptive name when referring to
+the function.  Thus, in an init file, one might find
+
+@example
+Meta-Rubout:	backward-kill-word
+@end example
+
+This binds the keystroke @key{Meta-Rubout} to the function
+@emph{descriptively} named @code{backward-kill-word}.  You, as the
+programmer, should bind the functions you write to descriptive names as
+well.  Readline provides a function for doing that:
+
+@deftypefun int rl_add_defun (char *name, Function *function, int key)
+Add @var{name} to the list of named functions.  Make @var{function} be
+the function that gets called.  If @var{key} is not -1, then bind it to
+@var{function} using @code{rl_bind_key ()}.
+@end deftypefun
+
+Using this function alone is sufficient for most applications.  It is
+the recommended way to add a few functions to the default functions that
+Readline has built in.  If you need to do something other
+than adding a function to Readline, you may need to use the
+underlying functions described below.
+
+@node Keymaps
+@subsection Selecting a Keymap
+
+Key bindings take place on a @dfn{keymap}.  The keymap is the
+association between the keys that the user types and the functions that
+get run.  You can make your own keymaps, copy existing keymaps, and tell
+Readline which keymap to use.
+
+@deftypefun Keymap rl_make_bare_keymap ()
+Returns a new, empty keymap.  The space for the keymap is allocated with
+@code{malloc ()}; you should @code{free ()} it when you are done.
+@end deftypefun
+
+@deftypefun Keymap rl_copy_keymap (Keymap map)
+Return a new keymap which is a copy of @var{map}.
+@end deftypefun
+
+@deftypefun Keymap rl_make_keymap ()
+Return a new keymap with the printing characters bound to rl_insert,
+the lowercase Meta characters bound to run their equivalents, and
+the Meta digits bound to produce numeric arguments.
+@end deftypefun
+
+@deftypefun void rl_discard_keymap (Keymap keymap)
+Free the storage associated with @var{keymap}.
+@end deftypefun
+
+Readline has several internal keymaps.  These functions allow you to
+change which keymap is active.
+
+@deftypefun Keymap rl_get_keymap ()
+Returns the currently active keymap.
+@end deftypefun
+
+@deftypefun void rl_set_keymap (Keymap keymap)
+Makes @var{keymap} the currently active keymap.
+@end deftypefun
+
+@deftypefun Keymap rl_get_keymap_by_name (char *name)
+Return the keymap matching @var{name}.  @var{name} is one which would
+be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
+@end deftypefun
+
+@deftypefun {char *} rl_get_keymap_name (Keymap keymap)
+Return the name matching @var{keymap}.  @var{name} is one which would
+be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
+@end deftypefun
+
+@node Binding Keys
+@subsection Binding Keys
+
+You associate keys with functions through the keymap.  Readline has
+several internal keymaps: @code{emacs_standard_keymap},
+@code{emacs_meta_keymap}, @code{emacs_ctlx_keymap},
+@code{vi_movement_keymap}, and @code{vi_insertion_keymap}.
+@code{emacs_standard_keymap} is the default, and the examples in
+this manual assume that.
+
+These functions manage key bindings.
+
+@deftypefun int rl_bind_key (int key, Function *function)
+Binds @var{key} to @var{function} in the currently active keymap.
+Returns non-zero in the case of an invalid @var{key}.
+@end deftypefun
+
+@deftypefun int rl_bind_key_in_map (int key, Function *function, Keymap map)
+Bind @var{key} to @var{function} in @var{map}.  Returns non-zero in the case
+of an invalid @var{key}.
+@end deftypefun
+
+@deftypefun int rl_unbind_key (int key)
+Bind @var{key} to the null function in the currently active keymap.
+Returns non-zero in case of error.
+@end deftypefun
+
+@deftypefun int rl_unbind_key_in_map (int key, Keymap map)
+Bind @var{key} to the null function in @var{map}.
+Returns non-zero in case of error.
+@end deftypefun
+
+@deftypefun int rl_generic_bind (int type, char *keyseq, char *data, Keymap map)
+Bind the key sequence represented by the string @var{keyseq} to the arbitrary
+pointer @var{data}.  @var{type} says what kind of data is pointed to by
+@var{data}; this can be a function (@code{ISFUNC}), a macro
+(@code{ISMACR}), or a keymap (@code{ISKMAP}).  This makes new keymaps as
+necessary.  The initial keymap in which to do bindings is @var{map}.
+@end deftypefun
+
+@deftypefun int rl_parse_and_bind (char *line)
+Parse @var{line} as if it had been read from the @code{inputrc} file and
+perform any key bindings and variable assignments found
+(@pxref{Readline Init File}).
+@end deftypefun
+
+@deftypefun int rl_read_init_file (char *filename)
+Read keybindings and variable assignments from @var{filename}
+(@pxref{Readline Init File}).
+@end deftypefun
+
+@node Associating Function Names and Bindings
+@subsection Associating Function Names and Bindings
+
+These functions allow you to find out what keys invoke named functions
+and the functions invoked by a particular key sequence.
+
+@deftypefun {Function *} rl_named_function (char *name)
+Return the function with name @var{name}.
+@end deftypefun
+
+@deftypefun {Function *} rl_function_of_keyseq (char *keyseq, Keymap map, int *type)
+Return the function invoked by @var{keyseq} in keymap @var{map}.
+If @var{map} is NULL, the current keymap is used.  If @var{type} is
+not NULL, the type of the object is returned in it (one of @code{ISFUNC},
+@code{ISKMAP}, or @code{ISMACR}).
+@end deftypefun
+
+@deftypefun {char **} rl_invoking_keyseqs (Function *function)
+Return an array of strings representing the key sequences used to
+invoke @var{function} in the current keymap.
+@end deftypefun
+
+@deftypefun {char **} rl_invoking_keyseqs_in_map (Function *function, Keymap map)
+Return an array of strings representing the key sequences used to
+invoke @var{function} in the keymap @var{map}.
+@end deftypefun
+
+@deftypefun void rl_function_dumper (int readable)
+Print the readline function names and the key sequences currently
+bound to them to @code{rl_outstream}.  If @var{readable} is non-zero,
+the list is formatted in such a way that it can be made part of an
+@code{inputrc} file and re-read.
+@end deftypefun
+
+@deftypefun void rl_list_funmap_names ()
+Print the names of all bindable Readline functions to @code{rl_outstream}.
+@end deftypefun
+
+@node Allowing Undoing
+@subsection Allowing Undoing
+
+Supporting the undo command is a painless thing, and makes your
+functions much more useful.  It is certainly easy to try
+something if you know you can undo it.  I could use an undo function for
+the stock market.
+
+If your function simply inserts text once, or deletes text once, and
+uses @code{rl_insert_text ()} or @code{rl_delete_text ()} to do it, then
+undoing is already done for you automatically.
+
+If you do multiple insertions or multiple deletions, or any combination
+of these operations, you should group them together into one operation.
+This is done with @code{rl_begin_undo_group ()} and
+@code{rl_end_undo_group ()}.
+
+The types of events that can be undone are:
+
+@example
+enum undo_code @{ UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END @}; 
+@end example
+
+Notice that @code{UNDO_DELETE} means to insert some text, and
+@code{UNDO_INSERT} means to delete some text.  That is, the undo code
+tells undo what to undo, not how to undo it.  @code{UNDO_BEGIN} and
+@code{UNDO_END} are tags added by @code{rl_begin_undo_group ()} and
+@code{rl_end_undo_group ()}.
+
+@deftypefun int rl_begin_undo_group ()
+Begins saving undo information in a group construct.  The undo
+information usually comes from calls to @code{rl_insert_text ()} and
+@code{rl_delete_text ()}, but could be the result of calls to
+@code{rl_add_undo ()}.
+@end deftypefun
+
+@deftypefun int rl_end_undo_group ()
+Closes the current undo group started with @code{rl_begin_undo_group
+()}.  There should be one call to @code{rl_end_undo_group ()}
+for each call to @code{rl_begin_undo_group ()}.
+@end deftypefun
+
+@deftypefun void rl_add_undo (enum undo_code what, int start, int end, char *text)
+Remember how to undo an event (according to @var{what}).  The affected
+text runs from @var{start} to @var{end}, and encompasses @var{text}.
+@end deftypefun
+
+@deftypefun void free_undo_list ()
+Free the existing undo list.
+@end deftypefun
+
+@deftypefun int rl_do_undo ()
+Undo the first thing on the undo list.  Returns @code{0} if there was
+nothing to undo, non-zero if something was undone.
+@end deftypefun
+
+Finally, if you neither insert nor delete text, but directly modify the
+existing text (e.g., change its case), call @code{rl_modifying ()}
+once, just before you modify the text.  You must supply the indices of
+the text range that you are going to modify.
+
+@deftypefun int rl_modifying (int start, int end)
+Tell Readline to save the text between @var{start} and @var{end} as a
+single undo unit.  It is assumed that you will subsequently modify
+that text.
+@end deftypefun
+
+@node Redisplay
+@subsection Redisplay
+
+@deftypefun void rl_redisplay ()
+Change what's displayed on the screen to reflect the current contents
+of @code{rl_line_buffer}.
+@end deftypefun
+
+@deftypefun int rl_forced_update_display ()
+Force the line to be updated and redisplayed, whether or not
+Readline thinks the screen display is correct.
+@end deftypefun
+
+@deftypefun int rl_on_new_line ()
+Tell the update routines that we have moved onto a new (empty) line,
+usually after ouputting a newline.
+@end deftypefun
+
+@deftypefun int rl_reset_line_state ()
+Reset the display state to a clean state and redisplay the current line
+starting on a new line.
+@end deftypefun
+
+@deftypefun int rl_message (va_alist)
+The arguments are a string as would be supplied to @code{printf}.  The
+resulting string is displayed in the @dfn{echo area}.  The echo area
+is also used to display numeric arguments and search strings.
+@end deftypefun
+
+@deftypefun int rl_clear_message ()
+Clear the message in the echo area.
+@end deftypefun
+
+@node Modifying Text
+@subsection Modifying Text
+
+@deftypefun int rl_insert_text (char *text)
+Insert @var{text} into the line at the current cursor position.
+@end deftypefun
+
+@deftypefun int rl_delete_text (int start, int end)
+Delete the text between @var{start} and @var{end} in the current line.
+@end deftypefun
+
+@deftypefun {char *} rl_copy_text (int start, int end)
+Return a copy of the text between @var{start} and @var{end} in
+the current line.
+@end deftypefun
+
+@deftypefun int rl_kill_text (int start, int end)
+Copy the text between @var{start} and @var{end} in the current line
+to the kill ring, appending or prepending to the last kill if the
+last command was a kill command.  The text is deleted.
+If @var{start} is less than @var{end},
+the text is appended, otherwise prepended.  If the last command was
+not a kill, a new kill ring slot is used.
+@end deftypefun
+
+@node Utility Functions
+@subsection Utility Functions
+
+@deftypefun int rl_read_key ()
+Return the next character available.  This handles input inserted into
+the input stream via @var{pending input} (@pxref{Readline Variables})
+and @code{rl_stuff_char ()}, macros, and characters read from the keyboard.
+@end deftypefun
+
+@deftypefun int rl_getc (FILE *)
+Return the next character available from the keyboard.
+@end deftypefun
+
+@deftypefun int rl_stuff_char (int c)
+Insert @var{c} into the Readline input stream.  It will be "read"
+before Readline attempts to read characters from the terminal with
+@code{rl_read_key ()}.
+@end deftypefun
+
+@deftypefun rl_extend_line_buffer (int len)
+Ensure that @code{rl_line_buffer} has enough space to hold @var{len}
+characters, possibly reallocating it if necessary.
+@end deftypefun
+
+@deftypefun int rl_initialize ()
+Initialize or re-initialize Readline's internal state.
+@end deftypefun
+
+@deftypefun int rl_reset_terminal (char *terminal_name)
+Reinitialize Readline's idea of the terminal settings using
+@var{terminal_name} as the terminal type (e.g., @code{vt100}).
+@end deftypefun
+
+@deftypefun int alphabetic (int c)
+Return 1 if @var{c} is an alphabetic character.
+@end deftypefun
+
+@deftypefun int numeric (int c)
+Return 1 if @var{c} is a numeric character.
+@end deftypefun
+
+@deftypefun int ding ()
+Ring the terminal bell, obeying the setting of @code{bell-style}.
+@end deftypefun
+
+The following are implemented as macros, defined in @code{chartypes.h}.
+
+@deftypefun int uppercase_p (int c)
+Return 1 if @var{c} is an uppercase alphabetic character.
+@end deftypefun
+
+@deftypefun int lowercase_p (int c)
+Return 1 if @var{c} is a lowercase alphabetic character.
+@end deftypefun
+
+@deftypefun int digit_p (int c)
+Return 1 if @var{c} is a numeric character.
+@end deftypefun
+
+@deftypefun int to_upper (int c)
+If @var{c} is a lowercase alphabetic character, return the corresponding
+uppercase character.
+@end deftypefun
+
+@deftypefun int to_lower (int c)
+If @var{c} is an uppercase alphabetic character, return the corresponding
+lowercase character.
+@end deftypefun
+
+@deftypefun int digit_value (int c)
+If @var{c} is a number, return the value it represents.
+@end deftypefun
+
+@node Alternate Interface
+@subsection Alternate Interface
+
+An alternate interface is available to plain @code{readline()}.  Some
+applications need to interleave keyboard I/O with file, device, or
+window system I/O, typically by using a main loop to @code{select()}
+on various file descriptors.  To accomodate this need, readline can
+also be invoked as a `callback' function from an event loop.  There
+are functions available to make this easy.
+
+@deftypefun void rl_callback_handler_install (char *prompt, Vfunction *lhandler)
+Set up the terminal for readline I/O and display the initial
+expanded value of @var{prompt}.  Save the value of @var{lhandler} to
+use as a callback when a complete line of input has been entered.
+@end deftypefun
+
+@deftypefun void rl_callback_read_char ()
+Whenever an application determines that keyboard input is available, it
+should call @code{rl_callback_read_char()}, which will read the next
+character from the current input source.  If that character completes the
+line, @code{rl_callback_read_char} will invoke the @var{lhandler}
+function saved by @code{rl_callback_handler_install} to process the
+line.  @code{EOF} is  indicated by calling @var{lhandler} with a
+@code{NULL} line.
+@end deftypefun
+
+@deftypefun void rl_callback_handler_remove ()
+Restore the terminal to its initial state and remove the line handler.
+This may be called from within a callback as well as independently.
+@end deftypefun
+
+@subsection An Example
+
+Here is a function which changes lowercase characters to their uppercase
+equivalents, and uppercase characters to lowercase.  If
+this function was bound to @samp{M-c}, then typing @samp{M-c} would
+change the case of the character under point.  Typing @samp{M-1 0 M-c}
+would change the case of the following 10 characters, leaving the cursor on
+the last character changed.
+
+@example
+/* Invert the case of the COUNT following characters. */
+int
+invert_case_line (count, key)
+     int count, key;
+@{
+  register int start, end, i;
+
+  start = rl_point;
+
+  if (rl_point >= rl_end)
+    return (0);
+
+  if (count < 0)
+    @{
+      direction = -1;
+      count = -count;
+    @}
+  else
+    direction = 1;
+      
+  /* Find the end of the range to modify. */
+  end = start + (count * direction);
+
+  /* Force it to be within range. */
+  if (end > rl_end)
+    end = rl_end;
+  else if (end < 0)
+    end = 0;
+
+  if (start == end)
+    return (0);
+
+  if (start > end)
+    @{
+      int temp = start;
+      start = end;
+      end = temp;
+    @}
+
+  /* Tell readline that we are modifying the line, so it will save
+     the undo information. */
+  rl_modifying (start, end);
+
+  for (i = start; i != end; i++)
+    @{
+      if (uppercase_p (rl_line_buffer[i]))
+        rl_line_buffer[i] = to_lower (rl_line_buffer[i]);
+      else if (lowercase_p (rl_line_buffer[i]))
+        rl_line_buffer[i] = to_upper (rl_line_buffer[i]);
+    @}
+  /* Move point to on top of the last character changed. */
+  rl_point = (direction == 1) ? end - 1 : start;
+  return (0);
+@}
+@end example
+
+@node Custom Completers
+@section Custom Completers
+
+Typically, a program that reads commands from the user has a way of
+disambiguating commands and data.  If your program is one of these, then
+it can provide completion for commands, data, or both.
+The following sections describe how your program and Readline
+cooperate to provide this service.
+
+@menu
+* How Completing Works::	The logic used to do completion.
+* Completion Functions::	Functions provided by Readline.
+* Completion Variables::	Variables which control completion.
+* A Short Completion Example::	An example of writing completer subroutines.
+@end menu
+
+@node How Completing Works
+@subsection How Completing Works
+
+In order to complete some text, the full list of possible completions
+must be available.  That is, it is not possible to accurately
+expand a partial word without knowing all of the possible words
+which make sense in that context.  The Readline library provides
+the user interface to completion, and two of the most common
+completion functions:  filename and username.  For completing other types
+of text, you must write your own completion function.  This section
+describes exactly what such functions must do, and provides an example.
+
+There are three major functions used to perform completion:
+
+@enumerate
+@item
+The user-interface function @code{rl_complete ()}.  This function is
+called with the same arguments as other Readline
+functions intended for interactive use:  @var{count} and
+@var{invoking_key}.  It isolates the word to be completed and calls
+@code{completion_matches ()} to generate a list of possible completions.
+It then either lists the possible completions, inserts the possible
+completions, or actually performs the
+completion, depending on which behavior is desired.
+
+@item
+The internal function @code{completion_matches ()} uses your
+@dfn{generator} function to generate the list of possible matches, and
+then returns the array of these matches.  You should place the address
+of your generator function in @code{rl_completion_entry_function}.
+
+@item
+The generator function is called repeatedly from
+@code{completion_matches ()}, returning a string each time.  The
+arguments to the generator function are @var{text} and @var{state}.
+@var{text} is the partial word to be completed.  @var{state} is zero the
+first time the function is called, allowing the generator to perform
+any necessary initialization, and a positive non-zero integer for
+each subsequent call.  When the generator function returns
+@code{(char *)NULL} this signals @code{completion_matches ()} that there are
+no more possibilities left.  Usually the generator function computes the
+list of possible completions when @var{state} is zero, and returns them
+one at a time on subsequent calls.  Each string the generator function
+returns as a match must be allocated with @code{malloc()}; Readline
+frees the strings when it has finished with them.
+
+@end enumerate
+
+@deftypefun int rl_complete (int ignore, int invoking_key)
+Complete the word at or before point.  You have supplied the function
+that does the initial simple matching selection algorithm (see
+@code{completion_matches ()}).  The default is to do filename completion.
+@end deftypefun
+
+@deftypevar {Function *} rl_completion_entry_function
+This is a pointer to the generator function for @code{completion_matches
+()}.  If the value of @code{rl_completion_entry_function} is
+@code{(Function *)NULL} then the default filename generator function,
+@code{filename_completion_function ()}, is used.
+@end deftypevar
+
+@node Completion Functions
+@subsection Completion Functions
+
+Here is the complete list of callable completion functions present in
+Readline.
+
+@deftypefun int rl_complete_internal (int what_to_do)
+Complete the word at or before point.  @var{what_to_do} says what to do
+with the completion.  A value of @samp{?} means list the possible
+completions.  @samp{TAB} means do standard completion.  @samp{*} means
+insert all of the possible completions.  @samp{!} means to display
+all of the possible completions, if there is more than one, as well as
+performing partial completion.
+@end deftypefun
+
+@deftypefun int rl_complete (int ignore, int invoking_key)
+Complete the word at or before point.  You have supplied the function
+that does the initial simple matching selection algorithm (see
+@code{completion_matches ()} and @code{rl_completion_entry_function}).
+The default is to do filename
+completion.  This calls @code{rl_complete_internal ()} with an
+argument depending on @var{invoking_key}.
+@end deftypefun
+
+@deftypefun int rl_possible_completions (int count, int invoking_key))
+List the possible completions.  See description of @code{rl_complete
+()}.  This calls @code{rl_complete_internal ()} with an argument of
+@samp{?}.
+@end deftypefun
+
+@deftypefun int rl_insert_completions (int count, int invoking_key))
+Insert the list of possible completions into the line, deleting the
+partially-completed word.  See description of @code{rl_complete ()}.
+This calls @code{rl_complete_internal ()} with an argument of @samp{*}.
+@end deftypefun
+
+@deftypefun {char **} completion_matches (char *text, CPFunction *entry_func)
+Returns an array of @code{(char *)} which is a list of completions for
+@var{text}.  If there are no completions, returns @code{(char **)NULL}.
+The first entry in the returned array is the substitution for @var{text}.
+The remaining entries are the possible completions.  The array is
+terminated with a @code{NULL} pointer.
+
+@var{entry_func} is a function of two args, and returns a
+@code{(char *)}.  The first argument is @var{text}.  The second is a
+state argument; it is zero on the first call, and non-zero on subsequent
+calls.  @var{entry_func} returns a @code{NULL}  pointer to the caller
+when there are no more matches.
+@end deftypefun
+
+@deftypefun {char *} filename_completion_function (char *text, int state)
+A generator function for filename completion in the general case.  Note
+that completion in Bash is a little different because of all
+the pathnames that must be followed when looking up completions for a
+command.  The Bash source is a useful reference for writing custom
+completion functions.
+@end deftypefun
+
+@deftypefun {char *} username_completion_function (char *text, int state)
+A completion generator for usernames.  @var{text} contains a partial
+username preceded by a random character (usually @samp{~}).  As with all
+completion generators, @var{state} is zero on the first call and non-zero
+for subsequent calls.
+@end deftypefun
+
+@node Completion Variables
+@subsection Completion Variables
+
+@deftypevar {Function *} rl_completion_entry_function
+A pointer to the generator function for @code{completion_matches ()}.
+@code{NULL} means to use @code{filename_entry_function ()}, the default
+filename completer.
+@end deftypevar
+
+@deftypevar {CPPFunction *} rl_attempted_completion_function
+A pointer to an alternative function to create matches.
+The function is called with @var{text}, @var{start}, and @var{end}.
+@var{start} and @var{end} are indices in @code{rl_line_buffer} saying
+what the boundaries of @var{text} are.  If this function exists and
+returns @code{NULL}, or if this variable is set to @code{NULL}, then
+@code{rl_complete ()} will call the value of
+@code{rl_completion_entry_function} to generate matches, otherwise the
+array of strings returned will be used.
+@end deftypevar
+
+@deftypevar {CPFunction *} rl_filename_quoting_function
+A pointer to a function that will quote a filename in an application-
+specific fashion.  This is called if filename completion is being
+attempted and one of the characters in @code{rl_filename_quote_characters}
+appears in a completed filename.  The function is called with
+@var{text}, @var{match_type}, and @var{quote_pointer}.  The @var{text}
+is the filename to be quoted.  The @var{match_type} is either
+@code{SINGLE_MATCH}, if there is only one completion match, or
+@code{MULT_MATCH}.  Some functions use this to decide whether or not to
+insert a closing quote character.  The @var{quote_pointer} is a pointer
+to any opening quote character the user typed.  Some functions choose
+to reset this character.
+@end deftypevar
+
+@deftypevar {CPFunction *} rl_filename_dequoting_function
+A pointer to a function that will remove application-specific quoting
+characters from a filename before completion is attempted, so those
+characters do not interfere with matching the text against names in
+the filesystem.  It is called with @var{text}, the text of the word
+to be dequoted, and @var{quote_char}, which is the quoting character 
+that delimits the filename (usually @samp{'} or @samp{"}).  If
+@var{quote_char} is zero, the filename was not in an embedded string.
+@end deftypevar
+
+@deftypevar {Function *} rl_char_is_quoted_p
+A pointer to a function to call that determines whether or not a specific
+character in the line buffer is quoted, according to whatever quoting
+mechanism the program calling readline uses.  The function is called with
+two arguments: @var{text}, the text of the line, and @var{index}, the
+index of the character in the line.  It is used to decide whether a
+character found in @code{rl_completer_word_break_characters} should be
+used to break words for the completer.
+@end deftypevar
+
+@deftypevar int rl_completion_query_items
+Up to this many items will be displayed in response to a
+possible-completions call.  After that, we ask the user if she is sure
+she wants to see them all.  The default value is 100.
+@end deftypevar
+
+@deftypevar {char *} rl_basic_word_break_characters
+The basic list of characters that signal a break between words for the
+completer routine.  The default value of this variable is the characters
+which break words for completion in Bash, i.e.,
+@code{" \t\n\"\\'`@@$><=;|&@{("}.
+@end deftypevar
+
+@deftypevar {char *} rl_basic_quote_characters
+List of quote characters which can cause a word break.
+@end deftypevar
+
+@deftypevar {char *} rl_completer_word_break_characters
+The list of characters that signal a break between words for
+@code{rl_complete_internal ()}.  The default list is the value of
+@code{rl_basic_word_break_characters}.
+@end deftypevar
+
+@deftypevar {char *} rl_completer_quote_characters
+List of characters which can be used to quote a substring of the line.
+Completion occurs on the entire substring, and within the substring
+@code{rl_completer_word_break_characters} are treated as any other character,
+unless they also appear within this list.
+@end deftypevar
+
+@deftypevar {char *} rl_filename_quote_characters
+A list of characters that cause a filename to be quoted by the completer
+when they appear in a completed filename.  The default is empty.
+@end deftypevar
+
+@deftypevar {char *} rl_special_prefixes
+The list of characters that are word break characters, but should be
+left in @var{text} when it is passed to the completion function.
+Programs can use this to help determine what kind of completing to do.
+For instance, Bash sets this variable to "$@@" so that it can complete
+shell variables and hostnames.
+@end deftypevar
+
+@deftypevar {int} rl_completion_append_character
+When a single completion alternative matches at the end of the command
+line, this character is appended to the inserted completion text.  The
+default is a space character (@samp{ }).  Setting this to the null
+character (@samp{\0}) prevents anything being appended automatically.
+This can be changed in custom completion functions to
+provide the ``most sensible word separator character'' according to
+an application-specific command line syntax specification.
+@end deftypevar
+
+@deftypevar int rl_ignore_completion_duplicates
+If non-zero, then disallow duplicates in the matches.  Default is 1.
+@end deftypevar
+
+@deftypevar int rl_filename_completion_desired
+Non-zero means that the results of the matches are to be treated as
+filenames.  This is @emph{always} zero on entry, and can only be changed
+within a completion entry generator function.  If it is set to a non-zero
+value, directory names have a slash appended and Readline attempts to
+quote completed filenames if they contain any embedded word break
+characters.
+@end deftypevar
+
+@deftypevar int rl_filename_quoting_desired
+Non-zero means that the results of the matches are to be quoted using
+double quotes (or an application-specific quoting mechanism) if the
+completed filename contains any characters in
+@code{rl_filename_quote_chars}.  This is @emph{always} non-zero
+on entry, and can only be changed within a completion entry generator
+function.  The quoting is effected via a call to the function pointed to
+by @code{rl_filename_quoting_function}.
+@end deftypevar
+
+@deftypevar int rl_inhibit_completion
+If this variable is non-zero, completion is inhibit<ed.  The completion
+character will be inserted as any other bound to @code{self-insert}.
+@end deftypevar
+
+@deftypevar {Function *} rl_ignore_some_completions_function
+This function, if defined, is called by the completer when real filename
+completion is done, after all the matching names have been generated.
+It is passed a @code{NULL} terminated array of matches.
+The first element (@code{matches[0]}) is the
+maximal substring common to all matches. This function can
+re-arrange the list of matches as required, but each element deleted
+from the array must be freed.
+@end deftypevar
+
+@deftypevar {Function *} rl_directory_completion_hook
+This function, if defined, is allowed to modify the directory portion
+of filenames Readline completes.  It is called with the address of a
+string (the current directory name) as an argument.  It could be used
+to expand symbolic links or shell variables in pathnames.
+@end deftypevar
+
+@node A Short Completion Example
+@subsection A Short Completion Example
+
+Here is a small application demonstrating the use of the GNU Readline
+library.  It is called @code{fileman}, and the source code resides in
+@file{examples/fileman.c}.  This sample application provides
+completion of command names, line editing features, and access to the
+history list.
+
+@page
+@smallexample
+/* fileman.c -- A tiny application which demonstrates how to use the
+   GNU Readline library.  This application interactively allows users
+   to manipulate files and their modes. */
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <sys/errno.h>
+
+#include <readline/readline.h>
+#include <readline/history.h>
+
+extern char *getwd ();
+extern char *xmalloc ();
+
+/* The names of functions that actually do the manipulation. */
+int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
+int com_delete (), com_help (), com_cd (), com_quit ();
+
+/* A structure which contains information on the commands this program
+   can understand. */
+
+typedef struct @{
+  char *name;			/* User printable name of the function. */
+  Function *func;		/* Function to call to do the job. */
+  char *doc;			/* Documentation for this function.  */
+@} COMMAND;
+
+COMMAND commands[] = @{
+  @{ "cd", com_cd, "Change to directory DIR" @},
+  @{ "delete", com_delete, "Delete FILE" @},
+  @{ "help", com_help, "Display this text" @},
+  @{ "?", com_help, "Synonym for `help'" @},
+  @{ "list", com_list, "List files in DIR" @},
+  @{ "ls", com_list, "Synonym for `list'" @},
+  @{ "pwd", com_pwd, "Print the current working directory" @},
+  @{ "quit", com_quit, "Quit using Fileman" @},
+  @{ "rename", com_rename, "Rename FILE to NEWNAME" @},
+  @{ "stat", com_stat, "Print out statistics on FILE" @},
+  @{ "view", com_view, "View the contents of FILE" @},
+  @{ (char *)NULL, (Function *)NULL, (char *)NULL @}
+@};
+
+/* Forward declarations. */
+char *stripwhite ();
+COMMAND *find_command ();
+
+/* The name of this program, as taken from argv[0]. */
+char *progname;
+
+/* When non-zero, this global means the user is done using this program. */
+int done;
+
+char *
+dupstr (s)
+     int s;
+@{
+  char *r;
+
+  r = xmalloc (strlen (s) + 1);
+  strcpy (r, s);
+  return (r);
+@}
+
+main (argc, argv)
+     int argc;
+     char **argv;
+@{
+  char *line, *s;
+
+  progname = argv[0];
+
+  initialize_readline ();	/* Bind our completer. */
+
+  /* Loop reading and executing lines until the user quits. */
+  for ( ; done == 0; )
+    @{
+      line = readline ("FileMan: ");
+
+      if (!line)
+        break;
+
+      /* Remove leading and trailing whitespace from the line.
+         Then, if there is anything left, add it to the history list
+         and execute it. */
+      s = stripwhite (line);
+
+      if (*s)
+        @{
+          add_history (s);
+          execute_line (s);
+        @}
+
+      free (line);
+    @}
+  exit (0);
+@}
+
+/* Execute a command line. */
+int
+execute_line (line)
+     char *line;
+@{
+  register int i;
+  COMMAND *command;
+  char *word;
+
+  /* Isolate the command word. */
+  i = 0;
+  while (line[i] && whitespace (line[i]))
+    i++;
+  word = line + i;
+
+  while (line[i] && !whitespace (line[i]))
+    i++;
+
+  if (line[i])
+    line[i++] = '\0';
+
+  command = find_command (word);
+
+  if (!command)
+    @{
+      fprintf (stderr, "%s: No such command for FileMan.\n", word);
+      return (-1);
+    @}
+
+  /* Get argument to command, if any. */
+  while (whitespace (line[i]))
+    i++;
+
+  word = line + i;
+
+  /* Call the function. */
+  return ((*(command->func)) (word));
+@}
+
+/* Look up NAME as the name of a command, and return a pointer to that
+   command.  Return a NULL pointer if NAME isn't a command name. */
+COMMAND *
+find_command (name)
+     char *name;
+@{
+  register int i;
+
+  for (i = 0; commands[i].name; i++)
+    if (strcmp (name, commands[i].name) == 0)
+      return (&commands[i]);
+
+  return ((COMMAND *)NULL);
+@}
+
+/* Strip whitespace from the start and end of STRING.  Return a pointer
+   into STRING. */
+char *
+stripwhite (string)
+     char *string;
+@{
+  register char *s, *t;
+
+  for (s = string; whitespace (*s); s++)
+    ;
+    
+  if (*s == 0)
+    return (s);
+
+  t = s + strlen (s) - 1;
+  while (t > s && whitespace (*t))
+    t--;
+  *++t = '\0';
+
+  return s;
+@}
+
+/* **************************************************************** */
+/*                                                                  */
+/*                  Interface to Readline Completion                */
+/*                                                                  */
+/* **************************************************************** */
+
+char *command_generator ();
+char **fileman_completion ();
+
+/* Tell the GNU Readline library how to complete.  We want to try to complete
+   on command names if this is the first word in the line, or on filenames
+   if not. */
+initialize_readline ()
+@{
+  /* Allow conditional parsing of the ~/.inputrc file. */
+  rl_readline_name = "FileMan";
+
+  /* Tell the completer that we want a crack first. */
+  rl_attempted_completion_function = (CPPFunction *)fileman_completion;
+@}
+
+/* Attempt to complete on the contents of TEXT.  START and END bound the
+   region of rl_line_buffer that contains the word to complete.  TEXT is
+   the word to complete.  We can use the entire contents of rl_line_buffer
+   in case we want to do some simple parsing.  Return the array of matches,
+   or NULL if there aren't any. */
+char **
+fileman_completion (text, start, end)
+     char *text;
+     int start, end;
+@{
+  char **matches;
+
+  matches = (char **)NULL;
+
+  /* If this word is at the start of the line, then it is a command
+     to complete.  Otherwise it is the name of a file in the current
+     directory. */
+  if (start == 0)
+    matches = completion_matches (text, command_generator);
+
+  return (matches);
+@}
+
+/* Generator function for command completion.  STATE lets us know whether
+   to start from scratch; without any state (i.e. STATE == 0), then we
+   start at the top of the list. */
+char *
+command_generator (text, state)
+     char *text;
+     int state;
+@{
+  static int list_index, len;
+  char *name;
+
+  /* If this is a new word to complete, initialize now.  This includes
+     saving the length of TEXT for efficiency, and initializing the index
+     variable to 0. */
+  if (!state)
+    @{
+      list_index = 0;
+      len = strlen (text);
+    @}
+
+  /* Return the next name which partially matches from the command list. */
+  while (name = commands[list_index].name)
+    @{
+      list_index++;
+
+      if (strncmp (name, text, len) == 0)
+        return (dupstr(name));
+    @}
+
+  /* If no names matched, then return NULL. */
+  return ((char *)NULL);
+@}
+
+/* **************************************************************** */
+/*                                                                  */
+/*                       FileMan Commands                           */
+/*                                                                  */
+/* **************************************************************** */
+
+/* String to pass to system ().  This is for the LIST, VIEW and RENAME
+   commands. */
+static char syscom[1024];
+
+/* List the file(s) named in arg. */
+com_list (arg)
+     char *arg;
+@{
+  if (!arg)
+    arg = "";
+
+  sprintf (syscom, "ls -FClg %s", arg);
+  return (system (syscom));
+@}
+
+com_view (arg)
+     char *arg;
+@{
+  if (!valid_argument ("view", arg))
+    return 1;
+
+  sprintf (syscom, "more %s", arg);
+  return (system (syscom));
+@}
+
+com_rename (arg)
+     char *arg;
+@{
+  too_dangerous ("rename");
+  return (1);
+@}
+
+com_stat (arg)
+     char *arg;
+@{
+  struct stat finfo;
+
+  if (!valid_argument ("stat", arg))
+    return (1);
+
+  if (stat (arg, &finfo) == -1)
+    @{
+      perror (arg);
+      return (1);
+    @}
+
+  printf ("Statistics for `%s':\n", arg);
+
+  printf ("%s has %d link%s, and is %d byte%s in length.\n", arg,
+          finfo.st_nlink,
+          (finfo.st_nlink == 1) ? "" : "s",
+          finfo.st_size,
+          (finfo.st_size == 1) ? "" : "s");
+  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
+  printf ("      Last access at: %s", ctime (&finfo.st_atime));
+  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
+  return (0);
+@}
+
+com_delete (arg)
+     char *arg;
+@{
+  too_dangerous ("delete");
+  return (1);
+@}
+
+/* Print out help for ARG, or for all of the commands if ARG is
+   not present. */
+com_help (arg)
+     char *arg;
+@{
+  register int i;
+  int printed = 0;
+
+  for (i = 0; commands[i].name; i++)
+    @{
+      if (!*arg || (strcmp (arg, commands[i].name) == 0))
+        @{
+          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
+          printed++;
+        @}
+    @}
+
+  if (!printed)
+    @{
+      printf ("No commands match `%s'.  Possibilties are:\n", arg);
+
+      for (i = 0; commands[i].name; i++)
+        @{
+          /* Print in six columns. */
+          if (printed == 6)
+            @{
+              printed = 0;
+              printf ("\n");
+            @}
+
+          printf ("%s\t", commands[i].name);
+          printed++;
+        @}
+
+      if (printed)
+        printf ("\n");
+    @}
+  return (0);
+@}
+
+/* Change to the directory ARG. */
+com_cd (arg)
+     char *arg;
+@{
+  if (chdir (arg) == -1)
+    @{
+      perror (arg);
+      return 1;
+    @}
+
+  com_pwd ("");
+  return (0);
+@}
+
+/* Print out the current working directory. */
+com_pwd (ignore)
+     char *ignore;
+@{
+  char dir[1024], *s;
+
+  s = getwd (dir);
+  if (s == 0)
+    @{
+      printf ("Error getting pwd: %s\n", dir);
+      return 1;
+    @}
+
+  printf ("Current directory is %s\n", dir);
+  return 0;
+@}
+
+/* The user wishes to quit using this program.  Just set DONE non-zero. */
+com_quit (arg)
+     char *arg;
+@{
+  done = 1;
+  return (0);
+@}
+
+/* Function which tells you that you can't do this. */
+too_dangerous (caller)
+     char *caller;
+@{
+  fprintf (stderr,
+           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
+           caller);
+@}
+
+/* Return non-zero if ARG is a valid argument for CALLER, else print
+   an error message and return zero. */
+int
+valid_argument (caller, arg)
+     char *caller, *arg;
+@{
+  if (!arg || !*arg)
+    @{
+      fprintf (stderr, "%s: Argument required.\n", caller);
+      return (0);
+    @}
+
+  return (1);
+@}
+@end smallexample
diff --git a/readline/doc/rluser.texinfo b/readline/doc/rluser.texinfo
new file mode 100644
--- /dev/null
+++ b/readline/doc/rluser.texinfo
@@ -0,0 +1,1180 @@
+@comment %**start of header (This is for running Texinfo on a region.)
+@setfilename rluser.info
+@comment %**end of header (This is for running Texinfo on a region.)
+@setchapternewpage odd
+
+@ignore
+This file documents the end user interface to the GNU command line
+editing features.  It is to be an appendix to manuals for programs which
+use these features.  There is a document entitled "readline.texinfo"
+which contains both end-user and programmer documentation for the GNU
+Readline Library.
+
+Copyright (C) 1988, 1991, 1993, 1996 Free Software Foundation, Inc.
+
+Authored by Brian Fox and Chet Ramey.
+
+Permission is granted to process this file through Tex and print the
+results, provided the printed document carries copying permission notice
+identical to this one except for the removal of this paragraph (this
+paragraph not being relevant to the printed manual).
+
+Permission is granted to make and distribute verbatim copies of this manual
+provided the copyright notice and this permission notice are preserved on
+all copies.
+
+Permission is granted to copy and distribute modified versions of this
+manual under the conditions for verbatim copying, provided also that the
+GNU Copyright statement is available to the distributee, and provided that
+the entire resulting derived work is distributed under the terms of a
+permission notice identical to this one.
+
+Permission is granted to copy and distribute translations of this manual
+into another language, under the above conditions for modified versions.
+@end ignore
+
+@comment If you are including this manual as an appendix, then set the
+@comment variable readline-appendix.
+
+@node Command Line Editing
+@chapter Command Line Editing
+
+This chapter describes the basic features of the @sc{GNU}
+command line editing interface.
+
+@menu
+* Introduction and Notation::	Notation used in this text.
+* Readline Interaction::	The minimum set of commands for editing a line.
+* Readline Init File::		Customizing Readline from a user's view.
+* Bindable Readline Commands::	A description of most of the Readline commands
+				available for binding
+* Readline vi Mode::		A short description of how to make Readline
+				behave like the vi editor.
+@end menu
+
+@node Introduction and Notation
+@section Introduction to Line Editing
+
+The following paragraphs describe the notation used to represent
+keystrokes.
+
+The text @key{C-k} is read as `Control-K' and describes the character
+produced when the @key{k} key is pressed while the Control key
+is depressed.
+
+The text @key{M-k} is read as `Meta-K' and describes the character
+produced when the meta key (if you have one) is depressed, and the @key{k}
+key is pressed.  If you do not have a meta key, the identical keystroke
+can be generated by typing @key{ESC} @i{first}, and then typing @key{k}.
+Either process is known as @dfn{metafying} the @key{k} key.
+
+The text @key{M-C-k} is read as `Meta-Control-k' and describes the
+character produced by @dfn{metafying} @key{C-k}.
+
+In addition, several keys have their own names.  Specifically,
+@key{DEL}, @key{ESC}, @key{LFD}, @key{SPC}, @key{RET}, and @key{TAB} all
+stand for themselves when seen in this text, or in an init file
+(@pxref{Readline Init File}).
+
+@node Readline Interaction
+@section Readline Interaction
+@cindex interaction, readline
+
+Often during an interactive session you type in a long line of text,
+only to notice that the first word on the line is misspelled.  The
+Readline library gives you a set of commands for manipulating the text
+as you type it in, allowing you to just fix your typo, and not forcing
+you to retype the majority of the line.  Using these editing commands,
+you move the cursor to the place that needs correction, and delete or
+insert the text of the corrections.  Then, when you are satisfied with
+the line, you simply press @key{RETURN}.  You do not have to be at the
+end of the line to press @key{RETURN}; the entire line is accepted
+regardless of the location of the cursor within the line.
+
+@menu
+* Readline Bare Essentials::	The least you need to know about Readline.
+* Readline Movement Commands::	Moving about the input line.
+* Readline Killing Commands::	How to delete text, and how to get it back!
+* Readline Arguments::		Giving numeric arguments to commands.
+* Searching::			Searching through previous lines.
+ @end menu
+
+@node Readline Bare Essentials
+@subsection Readline Bare Essentials
+@cindex notation, readline
+@cindex command editing
+@cindex editing command lines
+
+In order to enter characters into the line, simply type them.  The typed
+character appears where the cursor was, and then the cursor moves one
+space to the right.  If you mistype a character, you can use your
+erase character to back up and delete the mistyped character.
+
+Sometimes you may miss typing a character that you wanted to type, and
+not notice your error until you have typed several other characters.  In
+that case, you can type @key{C-b} to move the cursor to the left, and then
+correct your mistake.  Afterwards, you can move the cursor to the right
+with @key{C-f}.
+
+When you add text in the middle of a line, you will notice that characters
+to the right of the cursor are `pushed over' to make room for the text
+that you have inserted.  Likewise, when you delete text behind the cursor,
+characters to the right of the cursor are `pulled back' to fill in the
+blank space created by the removal of the text.  A list of the basic bare
+essentials for editing the text of an input line follows.
+
+@table @asis
+@item @key{C-b}
+Move back one character.
+@item @key{C-f}
+Move forward one character.
+@item @key{DEL}
+Delete the character to the left of the cursor.
+@item @key{C-d}
+Delete the character underneath the cursor.
+@item @w{Printing characters}
+Insert the character into the line at the cursor.
+@item @key{C-_}
+Undo the last thing that you did.  You can undo all the way back to an
+empty line.
+@end table
+
+@node Readline Movement Commands
+@subsection Readline Movement Commands
+
+
+The above table describes the most basic possible keystrokes that you need
+in order to do editing of the input line.  For your convenience, many
+other commands have been added in addition to @key{C-b}, @key{C-f},
+@key{C-d}, and @key{DEL}.  Here are some commands for moving more rapidly
+about the line.
+
+@table @key
+@item C-a
+Move to the start of the line.
+@item C-e
+Move to the end of the line.
+@item M-f
+Move forward a word.
+@item M-b
+Move backward a word.
+@item C-l
+Clear the screen, reprinting the current line at the top.
+@end table
+
+Notice how @key{C-f} moves forward a character, while @key{M-f} moves
+forward a word.  It is a loose convention that control keystrokes
+operate on characters while meta keystrokes operate on words.
+
+@node Readline Killing Commands
+@subsection Readline Killing Commands
+
+@cindex killing text
+@cindex yanking text
+
+@dfn{Killing} text means to delete the text from the line, but to save
+it away for later use, usually by @dfn{yanking} (re-inserting)
+it back into the line.
+If the description for a command says that it `kills' text, then you can
+be sure that you can get the text back in a different (or the same)
+place later.
+
+When you use a kill command, the text is saved in a @dfn{kill-ring}.
+Any number of consecutive kills save all of the killed text together, so
+that when you yank it back, you get it all.  The kill
+ring is not line specific; the text that you killed on a previously
+typed line is available to be yanked back later, when you are typing
+another line.
+@cindex kill ring
+
+Here is the list of commands for killing text.
+
+@table @key
+@item C-k
+Kill the text from the current cursor position to the end of the line.
+
+@item M-d
+Kill from the cursor to the end of the current word, or if between
+words, to the end of the next word.
+
+@item M-DEL
+Kill from the cursor the start of the previous word, or if between
+words, to the start of the previous word.
+
+@item C-w
+Kill from the cursor to the previous whitespace.  This is different than
+@key{M-DEL} because the word boundaries differ.
+
+@end table
+
+And, here is how to @dfn{yank} the text back into the line.  Yanking
+means to copy the most-recently-killed text from the kill buffer.
+
+@table @key
+@item C-y
+Yank the most recently killed text back into the buffer at the cursor.
+
+@item M-y
+Rotate the kill-ring, and yank the new top.  You can only do this if
+the prior command is @key{C-y} or @key{M-y}.
+@end table
+
+@node Readline Arguments
+@subsection Readline Arguments
+
+You can pass numeric arguments to Readline commands.  Sometimes the
+argument acts as a repeat count, other times it is the @i{sign} of the
+argument that is significant.  If you pass a negative argument to a
+command which normally acts in a forward direction, that command will
+act in a backward direction.  For example, to kill text back to the
+start of the line, you might type @w{@kbd{M-- C-k}}.
+
+The general way to pass numeric arguments to a command is to type meta
+digits before the command.  If the first `digit' you type is a minus
+sign (@key{-}), then the sign of the argument will be negative.  Once
+you have typed one meta digit to get the argument started, you can type
+the remainder of the digits, and then the command.  For example, to give
+the @key{C-d} command an argument of 10, you could type @samp{M-1 0 C-d}.
+
+@node Searching
+@subsection Searching for Commands in the History
+
+Readline provides commands for searching through the command history
+@ifset BashFeatures
+(@pxref{Bash History Facilities})
+@end ifset
+for lines containing a specified string.
+There are two search modes:  @var{incremental} and @var{non-incremental}.
+
+Incremental searches begin before the user has finished typing the
+search string.
+As each character of the search string is typed, readline displays
+the next entry from the history matching the string typed so far.
+An incremental search requires only as many characters as needed to
+find the desired history entry.
+The Escape character is used to terminate an incremental search.
+Control-J will also terminate the search.
+Control-G will abort an incremental search and restore the original
+line.
+When the search is terminated, the history entry containing the
+search string becomes the current line.
+To find other matching entries in the history list, type Control-S or
+Control-R as appropriate.
+This will search backward or forward in the history for the next
+entry matching the search string typed so far.
+Any other key sequence bound to a readline command will terminate
+the search and execute that command.
+For instance, a @code{newline} will terminate the search and accept
+the line, thereby executing the command from the history list.
+
+Non-incremental searches read the entire search string before starting
+to search for matching history lines.  The search string may be
+typed by the user or part of the contents of the current line.
+
+@node Readline Init File
+@section Readline Init File
+@cindex initialization file, readline
+
+Although the Readline library comes with a set of @code{emacs}-like
+keybindings installed by default,
+it is possible that you would like to use a different set
+of keybindings.  You can customize programs that use Readline by putting
+commands in an @dfn{inputrc} file in your home directory.  The name of this
+@ifset BashFeatures
+file is taken from the value of the shell variable @code{INPUTRC}.  If
+@end ifset
+@ifclear BashFeatures
+file is taken from the value of the environment variable @code{INPUTRC}.  If
+@end ifclear
+that variable is unset, the default is @file{~/.inputrc}.
+
+When a program which uses the Readline library starts up, the
+init file is read, and the key bindings are set.
+
+In addition, the @code{C-x C-r} command re-reads this init file, thus
+incorporating any changes that you might have made to it.
+
+@menu
+* Readline Init File Syntax::	Syntax for the commands in the inputrc file.
+
+* Conditional Init Constructs::	Conditional key bindings in the inputrc file.
+
+* Sample Init File::		An example inputrc file.
+@end menu
+
+@node Readline Init File Syntax
+@subsection Readline Init File Syntax
+
+There are only a few basic constructs allowed in the
+Readline init file.  Blank lines are ignored.
+Lines beginning with a @samp{#} are comments.
+Lines beginning with a @samp{$} indicate conditional
+constructs (@pxref{Conditional Init Constructs}).  Other lines
+denote variable settings and key bindings.
+
+@table @asis
+@item Variable Settings
+You can change the state of a few variables in Readline by
+using the @code{set} command within the init file.  Here is how you
+would specify that you wish to use @code{vi} line editing commands:
+
+@example
+set editing-mode vi
+@end example
+
+Right now, there are only a few variables which can be set;
+so few, in fact, that we just list them here:
+
+@table @code
+
+@item bell-style
+@vindex bell-style
+Controls what happens when Readline wants to ring the terminal bell.
+If set to @samp{none}, Readline never rings the bell.  If set to
+@samp{visible}, Readline uses a visible bell if one is available.
+If set to @samp{audible} (the default), Readline attempts to ring
+the terminal's bell.
+
+@item comment-begin
+@vindex comment-begin
+The string to insert at the beginning of the line when the
+@code{insert-comment} command is executed.  The default value
+is @code{"#"}.
+
+@item completion-query-items
+@vindex completion-query-items
+The number of possible completions that determines when the user is
+asked whether he wants to see the list of possibilities.  If the
+number of possible completions is greater than this value,
+Readline will ask the user whether or not he wishes to view
+them; otherwise, they are simply listed.  The default limit is
+@code{100}.
+
+@item convert-meta
+@vindex convert-meta
+If set to @samp{on}, Readline will convert characters with the
+eigth bit set to an ASCII key sequence by stripping the eigth
+bit and prepending an @key{ESC} character, converting them to a
+meta-prefixed key sequence.  The default value is @samp{on}.
+
+@item disable-completion
+@vindex disable-completion
+If set to @samp{On}, readline will inhibit word completion.
+Completion  characters will be inserted into the line as if they had
+been mapped to @code{self-insert}.  The default is @samp{off}.
+
+@item editing-mode
+@vindex editing-mode
+The @code{editing-mode} variable controls which editing mode you are
+using.  By default, Readline starts up in Emacs editing mode, where
+the keystrokes are most similar to Emacs.  This variable can be
+set to either @samp{emacs} or @samp{vi}.
+
+@item enable-keypad
+@vindex enable-keypad
+When set to @samp{on}, readline will try to enable the application
+keypad when it is called.  Some systems need this to enable the
+arrow keys.  The default is @samp{off}.
+
+@item expand-tilde
+@vindex expand-tilde
+If set to @samp{on}, tilde expansion is performed when Readline
+attempts word completion.  The default is @samp{off}.
+
+@item horizontal-scroll-mode
+@vindex horizontal-scroll-mode
+This variable can be set to either @samp{on} or @samp{off}.  Setting it
+to @samp{on} means that the text of the lines that you edit will scroll
+horizontally on a single screen line when they are longer than the width
+of the screen, instead of wrapping onto a new screen line.  By default,
+this variable is set to @samp{off}.
+
+@item keymap
+@vindex keymap
+Sets Readline's idea of the current keymap for key binding commands.
+Acceptable @code{keymap} names are
+@code{emacs},
+@code{emacs-standard},
+@code{emacs-meta},
+@code{emacs-ctlx},
+@code{vi},
+@code{vi-command}, and
+@code{vi-insert}.
+@code{vi} is equivalent to @code{vi-command}; @code{emacs} is
+equivalent to @code{emacs-standard}.  The default value is @code{emacs}.
+The value of the @code{editing-mode} variable also affects the
+default keymap.
+
+@item mark-directories
+If set to @samp{on}, completed directory names have a slash
+appended.  The default is @samp{on}.
+
+@item mark-modified-lines
+@vindex mark-modified-lines
+This variable, when set to @samp{on}, says to display an asterisk
+(@samp{*}) at the start of history lines which have been modified.
+This variable is @samp{off} by default.
+
+@item input-meta
+@vindex input-meta
+@vindex meta-flag
+If set to @samp{on}, Readline will enable eight-bit input (it
+will not strip the eighth bit from the characters it reads),
+regardless of what the terminal claims it can support.  The
+default value is @samp{off}.  The name @code{meta-flag} is a
+synonym for this variable.
+
+@item output-meta
+@vindex output-meta
+If set to @samp{on}, Readline will display characters with the
+eighth bit set directly rather than as a meta-prefixed escape
+sequence.  The default is @samp{off}.
+
+@item show-all-if-ambiguous
+@vindex show-all-if-ambiguous
+This alters the default behavior of the completion functions.  If
+set to @samp{on}, 
+words which have more than one possible completion cause the
+matches to be listed immediately instead of ringing the bell.
+The default value is @samp{off}.
+
+@item visible-stats
+@vindex visible-stats
+If set to @samp{on}, a character denoting a file's type
+is appended to the filename when listing possible
+completions.  The default is @samp{off}.
+
+@end table
+
+@item Key Bindings
+The syntax for controlling key bindings in the init file is
+simple.  First you have to know the name of the command that you
+want to change.  The following pages contain tables of the command name,
+the default keybinding, and a short description of what the command
+does.
+
+Once you know the name of the command, simply place the name of the key
+you wish to bind the command to, a colon, and then the name of the
+command on a line in the init file.  The name of the key
+can be expressed in different ways, depending on which is most
+comfortable for you.
+
+@table @asis
+@item @w{@var{keyname}: @var{function-name} or @var{macro}}
+@var{keyname} is the name of a key spelled out in English.  For example:
+@example
+Control-u: universal-argument
+Meta-Rubout: backward-kill-word
+Control-o: "> output"
+@end example
+
+In the above example, @samp{C-u} is bound to the function
+@code{universal-argument}, and @samp{C-o} is bound to run the macro
+expressed on the right hand side (that is, to insert the text
+@samp{> output} into the line).
+
+@item @w{"@var{keyseq}": @var{function-name} or @var{macro}}
+@var{keyseq} differs from @var{keyname} above in that strings
+denoting an entire key sequence can be specified, by placing
+the key sequence in double quotes.  Some GNU Emacs style key
+escapes can be used, as in the following example, but the
+special character names are not recognized.
+
+@example
+"\C-u": universal-argument
+"\C-x\C-r": re-read-init-file
+"\e[11~": "Function Key 1"
+@end example
+
+In the above example, @samp{C-u} is bound to the function
+@code{universal-argument} (just as it was in the first example),
+@samp{C-x C-r} is bound to the function @code{re-read-init-file}, and
+@samp{ESC [ 1 1 ~} is bound to insert the text @samp{Function Key 1}.
+The following escape sequences are available when specifying key
+sequences:
+
+@table @code
+@item @kbd{\C-}
+control prefix
+@item @kbd{\M-}
+meta prefix
+@item @kbd{\e}
+an escape character
+@item @kbd{\\}
+backslash
+@item @kbd{\"}
+@key{"}
+@item @kbd{\'}
+@key{'}
+@end table
+
+When entering the text of a macro, single or double quotes should
+be used to indicate a macro definition.  Unquoted text
+is assumed to be a function name.  Backslash
+will quote any character in the macro text, including @samp{"}
+and @samp{'}.
+For example, the following binding will make @samp{C-x \}
+insert a single @samp{\} into the line:
+@example
+"\C-x\\": "\\"
+@end example
+
+@end table
+@end table
+
+@node Conditional Init Constructs
+@subsection Conditional Init Constructs
+
+Readline implements a facility similar in spirit to the conditional
+compilation features of the C preprocessor which allows key
+bindings and variable settings to be performed as the result
+of tests.  There are three parser directives used.
+
+@table @code
+@item $if
+The @code{$if} construct allows bindings to be made based on the
+editing mode, the terminal being used, or the application using
+Readline.  The text of the test extends to the end of the line;
+no characters are required to isolate it.
+
+@table @code
+@item mode
+The @code{mode=} form of the @code{$if} directive is used to test
+whether Readline is in @code{emacs} or @code{vi} mode.
+This may be used in conjunction
+with the @samp{set keymap} command, for instance, to set bindings in
+the @code{emacs-standard} and @code{emacs-ctlx} keymaps only if
+Readline is starting out in @code{emacs} mode.
+
+@item term
+The @code{term=} form may be used to include terminal-specific
+key bindings, perhaps to bind the key sequences output by the
+terminal's function keys.  The word on the right side of the
+@samp{=} is tested against the full name of the terminal and the
+portion of the terminal name before the first @samp{-}.  This
+allows @code{sun} to match both @code{sun} and @code{sun-cmd},
+for instance.
+
+@item application
+The @var{application} construct is used to include
+application-specific settings.  Each program using the Readline
+library sets the @var{application name}, and you can test for it. 
+This could be used to bind key sequences to functions useful for
+a specific program.  For instance, the following command adds a
+key sequence that quotes the current or previous word in Bash:
+@example
+$if Bash
+# Quote the current or previous word
+"\C-xq": "\eb\"\ef\""
+$endif
+@end example
+@end table
+
+@item $endif
+This command, as you saw in the previous example, terminates an
+@code{$if} command.
+
+@item $else
+Commands in this branch of the @code{$if} directive are executed if
+the test fails.
+@end table
+
+@node Sample Init File
+@subsection Sample Init File
+
+Here is an example of an inputrc file.  This illustrates key
+binding, variable assignment, and conditional syntax.
+
+@example
+@page
+# This file controls the behaviour of line input editing for
+# programs that use the Gnu Readline library.  Existing programs
+# include FTP, Bash, and Gdb.
+#
+# You can re-read the inputrc file with C-x C-r.
+# Lines beginning with '#' are comments.
+#
+# Set various bindings for emacs mode.
+
+set editing-mode emacs 
+
+$if mode=emacs
+
+Meta-Control-h:	backward-kill-word	Text after the function name is ignored
+
+#
+# Arrow keys in keypad mode
+#
+#"\M-OD":        backward-char
+#"\M-OC":        forward-char
+#"\M-OA":        previous-history
+#"\M-OB":        next-history
+#
+# Arrow keys in ANSI mode
+#
+"\M-[D":        backward-char
+"\M-[C":        forward-char
+"\M-[A":        previous-history
+"\M-[B":        next-history
+#
+# Arrow keys in 8 bit keypad mode
+#
+#"\M-\C-OD":       backward-char
+#"\M-\C-OC":       forward-char
+#"\M-\C-OA":       previous-history
+#"\M-\C-OB":       next-history
+#
+# Arrow keys in 8 bit ANSI mode
+#
+#"\M-\C-[D":       backward-char
+#"\M-\C-[C":       forward-char
+#"\M-\C-[A":       previous-history
+#"\M-\C-[B":       next-history
+
+C-q: quoted-insert
+
+$endif
+
+# An old-style binding.  This happens to be the default.
+TAB: complete
+
+# Macros that are convenient for shell interaction
+$if Bash
+# edit the path
+"\C-xp": "PATH=$@{PATH@}\e\C-e\C-a\ef\C-f"
+# prepare to type a quoted word -- insert open and close double quotes
+# and move to just after the open quote
+"\C-x\"": "\"\"\C-b"
+# insert a backslash (testing backslash escapes in sequences and macros)
+"\C-x\\": "\\"
+# Quote the current or previous word
+"\C-xq": "\eb\"\ef\""
+# Add a binding to refresh the line, which is unbound
+"\C-xr": redraw-current-line
+# Edit variable on current line.
+"\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
+$endif
+
+# use a visible bell if one is available
+set bell-style visible
+
+# don't strip characters to 7 bits when reading
+set input-meta on
+
+# allow iso-latin1 characters to be inserted rather than converted to
+# prefix-meta sequences
+set convert-meta off
+
+# display characters with the eighth bit set directly rather than
+# as meta-prefixed characters
+set output-meta on
+
+# if there are more than 150 possible completions for a word, ask the
+# user if he wants to see all of them
+set completion-query-items 150
+
+# For FTP
+$if Ftp
+"\C-xg": "get \M-?"
+"\C-xt": "put \M-?"
+"\M-.": yank-last-arg
+$endif
+@end example
+
+@node Bindable Readline Commands
+@section Bindable Readline Commands
+
+@menu
+* Commands For Moving::		Moving about the line.
+* Commands For History::	Getting at previous lines.
+* Commands For Text::		Commands for changing text.
+* Commands For Killing::	Commands for killing and yanking.
+* Numeric Arguments::		Specifying numeric arguments, repeat counts.
+* Commands For Completion::	Getting Readline to do the typing for you.
+* Keyboard Macros::		Saving and re-executing typed characters
+* Miscellaneous Commands::	Other miscellaneous commands.
+@end menu
+
+This section describes Readline commands that may be bound to key
+sequences.
+
+@node Commands For Moving
+@subsection Commands For Moving
+@ftable @code
+@item beginning-of-line (C-a)
+Move to the start of the current line.
+
+@item end-of-line (C-e)
+Move to the end of the line.
+
+@item forward-char (C-f)
+Move forward a character.
+
+@item backward-char (C-b)
+Move back a character.
+
+@item forward-word (M-f)
+Move forward to the end of the next word.  Words are composed of
+letters and digits.
+
+@item backward-word (M-b)
+Move back to the start of this, or the previous, word.  Words are
+composed of letters and digits.
+
+@item clear-screen (C-l)
+Clear the screen and redraw the current line,
+leaving the current line at the top of the screen.
+
+@item redraw-current-line ()
+Refresh the current line.  By default, this is unbound.
+
+@end ftable
+
+@node Commands For History
+@subsection Commands For Manipulating The History
+
+@ftable @code
+@item accept-line (Newline, Return)
+@ifset BashFeatures
+Accept the line regardless of where the cursor is.  If this line is
+non-empty, add it to the history list according to the setting of
+the @code{HISTCONTROL} variable.  If this line was a history
+line, then restore the history line to its original state.
+@end ifset
+@ifclear BashFeatures
+Accept the line regardless of where the cursor is.  If this line is
+non-empty, add it to the history list.  If this line was a history
+line, then restore the history line to its original state.
+@end ifclear
+
+@item previous-history (C-p)
+Move `up' through the history list.
+
+@item next-history (C-n)
+Move `down' through the history list.
+
+@item beginning-of-history (M-<)
+Move to the first line in the history.
+
+@item end-of-history (M->)
+Move to the end of the input history, i.e., the line you are entering.
+
+@item reverse-search-history (C-r)
+Search backward starting at the current line and moving `up' through
+the history as necessary.  This is an incremental search.
+
+@item forward-search-history (C-s)
+Search forward starting at the current line and moving `down' through
+the the history as necessary.  This is an incremental search.
+
+@item non-incremental-reverse-search-history (M-p)
+Search backward starting at the current line and moving `up'
+through the history as necessary using a non-incremental search
+for a string supplied by the user.
+
+@item non-incremental-forward-search-history (M-n)
+Search forward starting at the current line and moving `down'
+through the the history as necessary using a non-incremental search
+for a string supplied by the user.
+
+@item history-search-forward ()
+Search forward through the history for the string of characters
+between the start of the current line and the current cursor
+position (the `point').  This is a non-incremental search.  By
+default, this command is unbound.
+
+@item history-search-backward ()
+Search backward through the history for the string of characters
+between the start of the current line and the point.  This
+is a non-incremental search.  By default, this command is unbound.
+
+@item yank-nth-arg (M-C-y)
+Insert the first argument to the previous command (usually
+the second word on the previous line).  With an argument @var{n},
+insert the @var{n}th word from the previous command (the words
+in the previous command begin with word 0).  A negative argument
+inserts the @var{n}th word from the end of the previous command.
+
+@item yank-last-arg (M-., M-_)
+Insert last argument to the previous command (the last word of the
+previous history entry).  With an
+argument, behave exactly like @code{yank-nth-arg}.
+
+@end ftable
+
+@node Commands For Text
+@subsection Commands For Changing Text
+
+@ftable @code
+@item delete-char (C-d)
+Delete the character under the cursor.  If the cursor is at the
+beginning of the line, there are no characters in the line, and
+the last character typed was not @kbd{C-d}, then return @code{EOF}.
+
+@item backward-delete-char (Rubout)
+Delete the character behind the cursor.  A numeric arg says to kill
+the characters instead of deleting them.
+
+@item quoted-insert (C-q, C-v)
+Add the next character that you type to the line verbatim.  This is
+how to insert key sequences like @key{C-q}, for example.
+
+@item tab-insert (M-TAB)
+Insert a tab character.
+
+@item self-insert (a, b, A, 1, !, ...)
+Insert yourself.
+
+@item transpose-chars (C-t)
+Drag the character before the cursor forward over
+the character at the cursor, moving the
+cursor forward as well.  If the insertion point
+is at the end of the line, then this
+transposes the last two characters of the line.
+Negative argumentss don't work.
+
+@item transpose-words (M-t)
+Drag the word behind the cursor past the word in front of the cursor
+moving the cursor over that word as well.
+
+@item upcase-word (M-u)
+Uppercase the current (or following) word.  With a negative argument,
+do the previous word, but do not move the cursor.
+
+@item downcase-word (M-l)
+Lowercase the current (or following) word.  With a negative argument,
+do the previous word, but do not move the cursor.
+
+@item capitalize-word (M-c)
+Capitalize the current (or following) word.  With a negative argument,
+do the previous word, but do not move the cursor.
+
+@end ftable
+
+@node Commands For Killing
+@subsection Killing And Yanking
+
+@ftable @code
+
+@item kill-line (C-k)
+Kill the text from the current cursor position to the end of the line.
+
+@item backward-kill-line (C-x Rubout)
+Kill backward to the beginning of the line.
+
+@item unix-line-discard (C-u)
+Kill backward from the cursor to the beginning of the current line.
+Save the killed text on the kill-ring.
+
+@item kill-whole-line ()
+Kill all characters on the current line, no matter where the
+cursor is.  By default, this is unbound.
+
+@item kill-word (M-d)
+Kill from the cursor to the end of the current word, or if between
+words, to the end of the next word.  Word boundaries are the same
+as @code{forward-word}.
+
+@item backward-kill-word (M-DEL)
+Kill the word behind the cursor.  Word boundaries are the same
+as @code{backward-word}.
+
+@item unix-word-rubout (C-w)
+Kill the word behind the cursor, using white space as a word
+boundary.  The killed text is saved on the kill-ring.
+
+@item delete-horizontal-space ()
+Delete all spaces and tabs around point.  By default, this is unbound.
+
+@item kill-region ()
+Kill the text between the point and the @emph{mark} (saved
+cursor position.  This text is referred to as the @var{region}.
+By default, this command is unbound.
+
+@item copy-region-as-kill ()
+Copy the text in the region to the kill buffer, so you can yank it
+right away.  By default, this command is unbound.
+
+@item copy-backward-word ()
+Copy the word before point to the kill buffer.
+By default, this command is unbound.
+
+@item copy-forward-word ()
+Copy the word following point to the kill buffer.
+By default, this command is unbound.
+
+@item yank (C-y)
+Yank the top of the kill ring into the buffer at the current
+cursor position.
+
+@item yank-pop (M-y)
+Rotate the kill-ring, and yank the new top.  You can only do this if
+the prior command is yank or yank-pop.
+@end ftable
+
+@node Numeric Arguments
+@subsection Specifying Numeric Arguments
+@ftable @code
+
+@item digit-argument (M-0, M-1, ... M--)
+Add this digit to the argument already accumulating, or start a new
+argument.  @key{M--} starts a negative argument.
+
+@item universal-argument ()
+This is another way to specify an argument.
+If this command is followed by one or more digits, optionally with a
+leading minus sign, those digits define the argument.
+If the command is followed by digits, executing @code{universal-argument}
+again ends the numeric argument, but is otherwise ignored.
+As a special case, if this command is immediately followed by a
+character that is neither a digit or minus sign, the argument count
+for the next command is multiplied by four.
+The argument count is initially one, so executing this function the
+first time makes the argument count four, a second time makes the
+argument count sixteen, and so on.
+By default, this is not bound to a key.
+@end ftable
+
+@node Commands For Completion
+@subsection Letting Readline Type For You
+
+@ftable @code
+@item complete (TAB)
+Attempt to do completion on the text before the cursor.  This is
+application-specific.  Generally, if you are typing a filename
+argument, you can do filename completion; if you are typing a command,
+you can do command completion, if you are typing in a symbol to GDB, you
+can do symbol name completion, if you are typing in a variable to Bash,
+you can do variable name completion, and so on.
+@ifset BashFeatures
+Bash attempts completion treating the text as a variable (if the
+text begins with @samp{$}), username (if the text begins with
+@samp{~}), hostname (if the text begins with @samp{@@}), or
+command (including aliases and functions) in turn.  If none 
+of these produces a match, filename completion is attempted.
+@end ifset
+
+@item possible-completions (M-?)
+List the possible completions of the text before the cursor.
+
+@item insert-completions (M-*)
+Insert all completions of the text before point that would have
+been generated by @code{possible-completions}.
+
+@ifset BashFeatures
+@item complete-filename (M-/)
+Attempt filename completion on the text before point.
+
+@item possible-filename-completions (C-x /)
+List the possible completions of the text before point,
+treating it as a filename.
+
+@item complete-username (M-~)
+Attempt completion on the text before point, treating
+it as a username.
+
+@item possible-username-completions (C-x ~)
+List the possible completions of the text before point,
+treating it as a username.
+
+@item complete-variable (M-$)
+Attempt completion on the text before point, treating
+it as a shell variable.
+
+@item possible-variable-completions (C-x $)
+List the possible completions of the text before point,
+treating it as a shell variable.
+
+@item complete-hostname (M-@@)
+Attempt completion on the text before point, treating
+it as a hostname.
+
+@item possible-hostname-completions (C-x @@)
+List the possible completions of the text before point,
+treating it as a hostname.
+
+@item complete-command (M-!)
+Attempt completion on the text before point, treating
+it as a command name.  Command completion attempts to
+match the text against aliases, reserved words, shell
+functions, builtins, and finally executable filenames,
+in that order.
+
+@item possible-command-completions (C-x !)
+List the possible completions of the text before point,
+treating it as a command name.
+
+@item dynamic-complete-history (M-TAB)
+Attempt completion on the text before point, comparing
+the text against lines from the history list for possible
+completion matches.
+
+@item complete-into-braces (M-@{)
+Perform filename completion and return the list of possible completions
+enclosed within braces so the list is available to the shell
+(@pxref{Brace Expansion}).
+
+@end ifset
+@end ftable
+
+@node Keyboard Macros
+@subsection Keyboard Macros
+@ftable @code
+
+@item start-kbd-macro (C-x ()
+Begin saving the characters typed into the current keyboard macro.
+
+@item end-kbd-macro (C-x ))
+Stop saving the characters typed into the current keyboard macro
+and save the definition.
+
+@item call-last-kbd-macro (C-x e)
+Re-execute the last keyboard macro defined, by making the characters
+in the macro appear as if typed at the keyboard.
+
+@end ftable
+
+@node Miscellaneous Commands
+@subsection Some Miscellaneous Commands
+@ftable @code
+
+@item re-read-init-file (C-x C-r)
+Read in the contents of the inputrc file, and incorporate
+any bindings or variable assignments found there.
+
+@item abort (C-g)
+Abort the current editing command and
+ring the terminal's bell (subject to the setting of
+@code{bell-style}).
+
+@item do-uppercase-version (M-a, M-b, M-@var{x}, @dots{})
+If the metafied character @var{x} is lowercase, run the command
+that is bound to the corresponding uppercase character.
+
+@item prefix-meta (ESC)
+Make the next character that you type be metafied.  This is for people
+without a meta key.  Typing @samp{ESC f} is equivalent to typing
+@samp{M-f}.
+
+@item undo (C-_, C-x C-u)
+Incremental undo, separately remembered for each line.
+
+@item revert-line (M-r)
+Undo all changes made to this line.  This is like typing the @code{undo}
+command enough times to get back to the beginning.
+
+@item tilde-expand (M-~)
+Perform tilde expansion on the current word.
+
+@item set-mark (C-@@)
+Set the mark to the current point.  If a
+numeric argument is supplied, the mark is set to that position.
+
+@item exchange-point-and-mark (C-x C-x)
+Swap the point with the mark.  The current cursor position is set to
+the saved position, and the old cursor position is saved as the mark.
+
+@item character-search (C-])
+A character is read and point is moved to the next occurrence of that
+character.  A negative count searches for previous occurrences.
+
+@item character-search-backward (M-C-])
+A character is read and point is moved to the previous occurrence
+of that character.  A negative count searches for subsequent
+occurrences.
+
+@item insert-comment (M-#)
+The value of the @code{comment-begin}
+variable is inserted at the beginning of the current line,
+and the line is accepted as if a newline had been typed.
+@ifset BashFeatures
+This makes the current line a shell comment.
+@end ifset
+
+@item dump-functions ()
+Print all of the functions and their key bindings to the
+readline output stream.  If a numeric argument is supplied,
+the output is formatted in such a way that it can be made part
+of an @var{inputrc} file.  This command is unbound by default.
+
+@item dump-variables ()
+Print all of the settable variables and their values to the
+readline output stream.  If a numeric argument is supplied,
+the output is formatted in such a way that it can be made part
+of an @var{inputrc} file.  This command is unbound by default.
+
+@item dump-macros ()
+Print all of the readline key sequences bound to macros and the
+strings they ouput.  If a numeric argument is supplied,
+the output is formatted in such a way that it can be made part
+of an @var{inputrc} file.  This command is unbound by default.
+
+@ifset BashFeatures
+@item glob-expand-word (C-x *)
+The word before point is treated as a pattern for pathname expansion,
+and the list of matching file names is inserted, replacing the word.
+
+@item glob-list-expansions (C-x g)
+The list of expansions that would have been generated by
+@code{glob-expand-word}
+is inserted into the line, replacing the word before point.
+
+@item display-shell-version (C-x C-v)
+Display version information about the current instance of Bash.
+
+@item shell-expand-line (M-C-e)
+Expand the line the way the shell does when it reads it.  This
+performs alias and history expansion as well as all of the shell
+word expansions.
+
+@item history-expand-line (M-^)
+Perform history expansion on the current line.
+
+@item alias-expand-line
+Perform alias expansion on the current line (@pxref{Aliases}).
+
+@item history-and-alias-expand-line
+Perform history and alias expansion on the current line.
+
+@item insert-last-argument (M-., M-_)
+A synonym for @code{yank-last-arg}.
+
+@item operate-and-get-next (C-o)
+Accept the current line for execution and fetch the next line
+relative to the current line from the history for editing.  Any
+argument is ignored.
+
+@item emacs-editing-mode (C-e)
+When in @code{vi} editing mode, this causes a switch back to
+@code{emacs} editing mode, as if the command @samp{set -o emacs} had
+been executed.
+
+@end ifset
+
+@end ftable
+
+@node Readline vi Mode
+@section Readline vi Mode
+
+While the Readline library does not have a full set of @code{vi}
+editing functions, it does contain enough to allow simple editing
+of the line.  The Readline @code{vi} mode behaves as specified in
+the @sc{POSIX} 1003.2 standard.
+
+@ifset BashFeatures
+In order to switch interactively between @code{emacs} and @code{vi}
+editing modes, use the @samp{set -o emacs} and @samp{set -o vi}
+commands (@pxref{The Set Builtin}).
+@end ifset
+@ifclear BashFeatures
+In order to switch interactively between @code{emacs} and @code{vi}
+editing modes, use the command M-C-j (toggle-editing-mode).
+@end ifclear
+The Readline default is @code{emacs} mode.
+
+When you enter a line in @code{vi} mode, you are already placed in
+`insertion' mode, as if you had typed an @samp{i}.  Pressing @key{ESC}
+switches you into `command' mode, where you can edit the text of the
+line with the standard @code{vi} movement keys, move to previous
+history lines with @samp{k} and subsequent lines with @samp{j}, and
+so forth.
diff --git a/readline/doc/texi2dvi b/readline/doc/texi2dvi
new file mode 100755
--- /dev/null
+++ b/readline/doc/texi2dvi
@@ -0,0 +1,275 @@
+#! /bin/sh
+# texi2dvi --- smartly produce DVI files from texinfo sources
+
+# Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
+
+# $Id: texi2dvi,v 1.1 1997-05-22 20:59:04 jwe Exp $
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, you can either send email to this
+# program's maintainer or write to: The Free Software Foundation,
+# Inc.; 59 Temple Place, Suite 330; Boston, MA 02111-1307, USA.
+
+# Commentary:
+
+# Author: Noah Friedman <friedman@prep.ai.mit.edu>
+
+# Please send bug reports, etc. to bug-texinfo@prep.ai.mit.edu
+# If possible, please send a copy of the output of the script called with
+# the `--debug' option when making a bug report.
+
+# In the interest of general portability, some common bourne shell
+# constructs were avoided because they weren't guaranteed to be available
+# in some earlier implementations.  I've tried to make this program as
+# portable as possible.  Welcome to unix, where the lowest common
+# denominator is rapidly diminishing.
+#
+# Among the more interesting lossages I noticed with some bourne shells
+# are:
+#     * No shell functions.
+#     * No `unset' builtin.
+#     * `shift' cannot take a numeric argument, and signals an error if
+#       there are no arguments to shift.
+
+# Code:
+
+# Name by which this script was invoked.
+progname=`echo "$0" | sed -e 's/[^\/]*\///g'`
+
+# This string is expanded by rcs automatically when this file is checked out.
+rcs_revision='$Revision: 1.1 $'
+version=`set - $rcs_revision; echo $2`
+
+# To prevent hairy quoting and escaping later.
+bq='`'
+eq="'"
+
+usage="Usage: $progname {options} [file1] {file2 {...}}
+(version $version)
+
+Options are:
+-D, --debug          Turn on shell debugging ($bq${bq}set -x$eq$eq).
+-h, --help           You're looking at it.
+-v, --version        Print version number.
+
+Arguments in brackets are required.  Those in braces are optional.
+"
+
+# Initialize variables.
+# Don't use `unset' since old bourne shells don't have this command.
+# Instead, assign them an empty value.
+# Some of these, like TEX and TEXINDEX, may be inherited from the environment
+backup_extension=.bak
+debug=
+orig_pwd="`pwd`"
+verbose=
+texindex="${TEXINDEX-texindex}"
+tex="${TEX-tex}"
+
+# Save this so we can construct a new TEXINPUTS path for each file to be
+# processed.
+TEXINPUTS_orig="$TEXINPUTS"
+export TEXINPUTS
+
+# Parse command line arguments.
+# Make sure that all wildcarded options are long enough to be unambiguous.
+# It's a good idea to document the full long option name in each case.
+# Long options which take arguments will need a `*' appended to the
+# canonical name to match the value appended after the `=' character.
+while : ; do
+  case $# in 0) break ;; esac
+  case "$1" in
+    -D | --debug | --d* )
+      debug=t
+      shift
+     ;;
+    -h | --help | --h* )
+      echo "$usage" 1>&2
+      exit 0
+     ;;
+    -v | --version | --v* )
+      echo "texi2dvi version $version" 1>&2
+      exit 0
+     ;;
+    -- )     # Stop option processing
+      shift
+      break
+     ;;
+    -* )
+      case "$1" in
+        --*=* ) arg=`echo "$1" | sed -e 's/=.*//'` ;;
+        * )     arg="$1" ;;
+      esac
+      exec 1>&2
+      echo "$progname: unknown or ambiguous option $bq$arg$eq"
+      echo "$progname: Use $bq--help$eq for a list of options."
+      exit 1
+     ;;
+    * )
+      break
+     ;;
+   esac
+done
+
+# See if there are any command line args left (which will be interpreted as
+# filename arguments)
+case $# in
+  0 )
+    exec 1>&2
+    echo "$progname: at least one file name is required as an argument."
+    echo "$progname: Use $bq--help$eq for a description of command syntax."
+    exit 2
+   ;;
+esac
+
+case "$debug" in t ) set -x ;; esac
+
+# Texify files
+for command_line_filename in ${1+"$@"} ; do
+   # Roughly equivalent to `dirname ...`, but more portable
+   directory="`echo ${command_line_filename} | sed 's/\/[^\/]*$//'`"
+   filename_texi="`basename ${command_line_filename}`"
+   # Strip off the last extension part (probably .texinfo or .texi)
+   filename_noext="`echo ${filename_texi} | sed 's/\.[^.]*$//'`"
+
+   # If directory and file are the same, then it's probably because there's
+   # no pathname component.  Set dirname to `.', the current directory.
+   if test "z${directory}" = "z${command_line_filename}" ; then
+      directory="."
+   fi
+
+   # Source file might @include additional texinfo sources.  Put `.' and
+   # directory where source file(s) reside in TEXINPUTS before anything
+   # else.  `.' goes first to ensure that any old .aux, .cps, etc. files in
+   # ${directory} don't get used in preference to fresher files in `.'.
+   TEXINPUTS=".:${directory}:${TEXINPUTS_orig}"
+
+   # "Unset" variables that might have values from previous iterations and
+   # which won't be completely reset later.
+   definite_index_files=""
+
+   # See if file exists here.  If it doesn't we're in trouble since, even
+   # though the user may be able to reenter a valid filename at the tex
+   # prompt (assuming they're attending the terminal), this script won't be
+   # able to find the right index files and so forth.
+   if test ! -r "${command_line_filename}" ; then
+      echo "${progname}: ${command_line_filename}: No such file or permission denied." 1>&2
+      continue;
+   fi
+
+   # Find all files having root filename with a two-letter extension,
+   # determine whether they're really index files, and save them.  Foo.aux
+   # is actually the cross-references file, but we need to keep track of
+   # that too.
+   possible_index_files="`eval echo ${filename_noext}.?? ${filename_noext}.aux`"
+   for this_file in ${possible_index_files} ; do
+      # If file is empty, forget it.
+      if test ! -s "${this_file}" ; then
+         continue;
+      fi
+
+      # Examine first character of file.  If it's not a backslash or
+      # single quote, then it's definitely not an index or xref file.
+      first_character="`sed -n '1s/^\(.\).*$/\1/p;q' ${this_file}`"
+      if test "${first_character}" = "\\" -o "${first_character}" = "'" ; then
+         definite_index_files="${definite_index_files} ${this_file}"
+      fi
+   done
+   orig_index_files="${definite_index_files}"
+   orig_index_files_sans_aux="`echo ${definite_index_files} \
+                                | sed 's/'${filename_noext}'\.aux//;
+                                       s/^[ ]*//;s/[ ]*$//;'`"
+
+   # Now save copies of original index files so we have some means of
+   # comparison later.
+   for index_file_to_save in ${orig_index_files} ; do
+       cp "${index_file_to_save}" "${index_file_to_save}${backup_extension}"
+   done
+
+   # Run texindex on current index files.  If they already exist, and
+   # after running TeX a first time the index files don't change, then
+   # there's no reason to run TeX again.  But we won't know that if the
+   # index files are out of date or nonexistent.
+   if test "${orig_index_files_sans_aux}" ; then
+      ${texindex} ${orig_index_files_sans_aux}
+   fi
+
+   if ${tex} ${command_line_filename} ; then		# TeX run first time
+      definite_index_files=""
+      # Get list of new index files
+      possible_index_files="`eval echo ${filename_noext}.?? ${filename_noext}.aux`"
+      for this_file in ${possible_index_files} ; do
+         # If file is empty, forget it.
+         if test ! -s ${this_file} ; then
+            continue;
+         fi
+
+         # Examine first character of file.  If it's not a backslash or
+         # single quote, then it's definitely not an index or xref file.
+         first_character="`sed -n '1s/^\(.\).*$/\1/p;q' ${this_file}`"
+         if test "${first_character}" = "\\" -o "${first_character}" = "'" ; then
+            definite_index_files="${definite_index_files} ${this_file}"
+         fi
+      done
+      new_index_files="${definite_index_files}"
+      new_index_files_sans_aux="`echo ${definite_index_files} \
+                                  | sed 's/'${filename_noext}'\.aux//;
+                                         s/^[ ]*//;s/[ ]*$//;'`"
+
+      # If old and new list don't at least have the same file list, then one
+      # file or another has definitely changed.
+      if test "${orig_index_files}" != "${new_index_files}" ; then
+         index_files_changed_p=t
+      else
+         # File list is the same.  We must compare each file until we find a
+         # difference.
+         index_files_changed_p=""
+         for this_file in ${new_index_files} ; do
+            # cmp -s will return nonzero exit status if files differ.
+            cmp -s "${this_file}" "${this_file}${backup_extension}"
+            if test $? -ne 0  ; then
+               # We only need to keep comparing until we find *one* that
+               # differs, because we'll have to run texindex & tex no
+               # matter what.
+               index_files_changed_p=t
+               break
+            fi
+         done
+      fi
+
+      # If index files have changed since TeX has been run, or if the aux
+      # file wasn't present originally, run texindex and TeX again.
+      if test "${index_files_changed_p}"  ; then
+         retval=0
+         if test "${new_index_files_sans_aux}" ; then
+            ${texindex} ${new_index_files_sans_aux}
+            retval=$?
+         fi
+         if test ${retval} -eq 0 ; then
+            ${tex} "${command_line_filename}"
+         fi
+      fi
+   fi
+
+   # Generate list of files to delete, then call rm once with the entire
+   # list.  This is significantly faster than multiple executions of rm.
+   file_list=""
+   for file in ${orig_index_files} ; do
+       file_list="${file_list} ${file}${backup_extension}"
+   done
+   if test "${file_list}" ; then
+      rm -f ${file_list}
+   fi
+done
+
+# texi2dvi ends here
diff --git a/readline/doc/texi2html b/readline/doc/texi2html
new file mode 100755
--- /dev/null
+++ b/readline/doc/texi2html
@@ -0,0 +1,2021 @@
+#!/usr/local/bin/perl
+'di ';
+'ig 00 ';
+#+##############################################################################
+#                                                                              #
+# File: texi2html                                                              #
+#                                                                              #
+# Description: Program to transform most Texinfo documents to HTML             #
+#                                                                              #
+#-##############################################################################
+
+# @(#)texi2html	1.51 09/10/96	Written (mainly) by Lionel Cons, Lionel.Cons@cern.ch
+
+# The man page for this program is included at the end of this file and can be
+# viewed using the command 'nroff -man texi2html'.
+# Please read the copyright at the end of the man page.
+
+#+++############################################################################
+#                                                                              #
+# Constants                                                                    #
+#                                                                              #
+#---############################################################################
+
+$DEBUG_TOC   =  1;
+$DEBUG_INDEX =  2;
+$DEBUG_BIB   =  4;
+$DEBUG_GLOSS =  8;
+$DEBUG_DEF   = 16;
+$DEBUG_HTML  = 32;
+$DEBUG_USER  = 64;
+
+$BIBRE = '\[[\w\/]+\]';			# RE for a bibliography reference
+$FILERE = '[\/\w.+-]+';			# RE for a file name
+$VARRE = '[^\s\{\}]+';			# RE for a variable name
+$NODERE = '[^@{}:\'`",]+';		# RE for a node name
+$NODESRE = '[^@{}:\'`"]+';		# RE for a list of node names
+$XREFRE = '[^@{}]+';			# RE for a xref (should use NODERE)
+
+$ERROR = "***";			        # prefix for errors and warnings
+$THISPROG = "texi2html 1.51";			# program name and version
+$HOMEPAGE = "http://wwwcn.cern.ch/dci/texi2html/"; # program home page
+$TODAY = &pretty_date;			# like "20 September 1993"
+$SPLITTAG = "<!-- SPLIT HERE -->\n";	# tag to know where to split
+$PROTECTTAG = "_ThisIsProtected_";	# tag to recognize protected sections
+$html2_doctype = '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0 Strict Level 2//EN">';
+
+#
+# language dependent constants
+#
+#$LDC_SEE = 'see';
+#$LDC_SECTION = 'section';
+#$LDC_IN = 'in';
+#$LDC_TOC = 'Table of Contents';
+#$LDC_GOTO = 'Go to the';
+#$LDC_FOOT = 'Footnotes';
+# TODO: @def* shortcuts
+
+#
+# pre-defined indices
+#
+%predefined_index = (
+		    'cp', 'c',
+		    'fn', 'f',
+		    'vr', 'v',
+		    'ky', 'k',
+		    'pg', 'p',
+		    'tp', 't',
+	            );
+
+#
+# valid indices
+#
+%valid_index = (
+		    'c', 1,
+		    'f', 1,
+		    'v', 1,
+		    'k', 1,
+		    'p', 1,
+		    't', 1,
+		);
+
+#
+# texinfo section names to level
+#
+%sec2level = (
+	      'top', 0,
+	      'chapter', 1,
+	      'unnumbered', 1,
+	      'majorheading', 1,
+	      'chapheading', 1,
+	      'appendix', 1,
+	      'section', 2,
+	      'unnumberedsec', 2,
+	      'heading', 2,
+	      'appendixsec', 2,
+	      'appendixsection', 2,
+	      'subsection', 3,
+	      'unnumberedsubsec', 3,
+	      'subheading', 3,
+	      'appendixsubsec', 3,
+	      'subsubsection', 4,
+	      'unnumberedsubsubsec', 4,
+	      'subsubheading', 4,
+	      'appendixsubsubsec', 4,
+	      );
+
+#
+# accent map, TeX command to ISO name
+#
+%accent_map = (
+	       '"',  'uml',
+	       '~',  'tilde',
+	       '^',  'circ',
+	       '`',  'grave',
+	       '\'', 'acute',
+	       );
+
+#
+# texinfo "simple things" (@foo) to HTML ones
+#
+%simple_map = (
+	       # cf. makeinfo.c
+	       "*", "<BR>",		# HTML+
+	       " ", " ",
+	       "\n", "\n",
+	       "|", "",
+	       # spacing commands
+	       ":", "",
+	       "!", "!",
+	       "?", "?",
+	       ".", ".",
+	       );
+
+#
+# texinfo "things" (@foo{}) to HTML ones
+#
+%things_map = (
+	       'TeX', 'TeX',
+	       'br', '<P>',		# paragraph break
+	       'bullet', '*',
+	       'copyright', '(C)',
+	       'dots', '...',
+	       'equiv', '==',
+	       'error', 'error-->',
+	       'expansion', '==>',
+	       'minus', '-',
+	       'point', '-!-',
+	       'print', '-|',
+	       'result', '=>',
+	       'today', $TODAY,
+	       );
+
+#
+# texinfo styles (@foo{bar}) to HTML ones
+#
+%style_map = (
+	      'asis', '',
+	      'b', 'B',
+	      'cite', 'CITE',
+	      'code', 'CODE',
+	      'ctrl', '&do_ctrl',	# special case
+	      'dfn', 'STRONG',		# DFN tag is illegal in the standard
+	      'dmn', '',		# useless
+	      'emph', 'EM',
+	      'file', '"TT',		# will put quotes, cf. &apply_style
+	      'i', 'I',
+	      'kbd', 'KBD',
+	      'key', 'KBD',
+	      'r', '',			# unsupported
+	      'samp', '"SAMP',		# will put quotes, cf. &apply_style
+	      'sc', '&do_sc',		# special case
+	      'strong', 'STRONG',
+	      't', 'TT',
+	      'titlefont', '',		# useless
+	      'var', 'VAR',
+	      'w', '',			# unsupported
+	      );
+
+#
+# texinfo format (@foo/@end foo) to HTML ones
+#
+%format_map = (
+	       'display', 'PRE',
+	       'example', 'PRE',
+	       'format', 'PRE',
+	       'lisp', 'PRE',
+	       'quotation', 'BLOCKQUOTE',
+	       'smallexample', 'PRE',
+	       'smalllisp', 'PRE',
+	       # lists
+	       'itemize', 'UL',
+	       'enumerate', 'OL',
+	       # poorly supported
+	       'flushleft', 'PRE',
+	       'flushright', 'PRE',
+	       );
+
+#
+# texinfo definition shortcuts to real ones
+#
+%def_map = (
+	    # basic commands
+	    'deffn', 0,
+	    'defvr', 0,
+	    'deftypefn', 0,
+	    'deftypevr', 0,
+	    'defcv', 0,
+	    'defop', 0,
+	    'deftp', 0,
+	    # basic x commands
+	    'deffnx', 0,
+	    'defvrx', 0,
+	    'deftypefnx', 0,
+	    'deftypevrx', 0,
+	    'defcvx', 0,
+	    'defopx', 0,
+	    'deftpx', 0,
+	    # shortcuts
+	    'defun', 'deffn Function',
+	    'defmac', 'deffn Macro',
+	    'defspec', 'deffn {Special Form}',
+	    'defvar', 'defvr Variable',
+	    'defopt', 'defvr {User Option}',
+	    'deftypefun', 'deftypefn Function',
+	    'deftypevar', 'deftypevr Variable',
+	    'defivar', 'defcv {Instance Variable}',
+	    'defmethod', 'defop Method',
+	    # x shortcuts
+	    'defunx', 'deffnx Function',
+	    'defmacx', 'deffnx Macro',
+	    'defspecx', 'deffnx {Special Form}',
+	    'defvarx', 'defvrx Variable',
+	    'defoptx', 'defvrx {User Option}',
+	    'deftypefunx', 'deftypefnx Function',
+	    'deftypevarx', 'deftypevrx Variable',
+	    'defivarx', 'defcvx {Instance Variable}',
+	    'defmethodx', 'defopx Method',
+	    );
+
+#
+# things to skip
+#
+%to_skip = (
+	    # comments
+	    'c', 1,
+	    'comment', 1,
+	    # useless
+	    'contents', 1,
+	    'shortcontents', 1,
+	    'summarycontents', 1,
+	    'footnotestyle', 1,
+	    'end ifclear', 1,
+	    'end ifset', 1,
+	    'titlepage', 1,
+	    'end titlepage', 1,
+	    # unsupported commands (formatting)
+	    'afourpaper', 1,
+	    'cropmarks', 1,
+	    'finalout', 1,
+	    'headings', 1,
+	    'need', 1,
+	    'page', 1,
+	    'setchapternewpage', 1,
+	    'everyheading', 1,
+	    'everyfooting', 1,
+	    'evenheading', 1,
+	    'evenfooting', 1,
+	    'oddheading', 1,
+	    'oddfooting', 1,
+	    'smallbook', 1,
+	    'vskip', 1,
+	    'filbreak', 1,
+	    # unsupported formats
+	    'cartouche', 1,
+	    'end cartouche', 1,
+	    'group', 1,
+	    'end group', 1,
+	    );
+
+#+++############################################################################
+#                                                                              #
+# Argument parsing, initialisation                                             #
+#                                                                              #
+#---############################################################################
+
+$use_bibliography = 1;
+$use_acc = 0;
+$debug = 0;
+$doctype = '';
+$check = 0;
+$expandinfo = 0;
+$use_glossary = 0;
+$invisible_mark = '';
+$use_iso = 0;
+@include_dirs = ();
+$show_menu = 0;
+$number_sections = 0;
+$split_node = 0;
+$split_chapter = 0;
+$monolithic = 0;
+$verbose = 0;
+$usage = <<EOT;
+This is $THISPROG
+To convert a Texinfo file to HMTL: $0 [options] file
+  where options can be:
+    -expandinfo    : use \@ifinfo sections, not \@iftex
+    -glossary      : handle a glossary
+    -invisible name: use 'name' as an invisible anchor
+    -I dir         : search also for files in 'dir'
+    -menu          : handle menus
+    -monolithic    : output only one file including ToC
+    -number        : number sections
+    -split_chapter : split on main sections
+    -split_node    : split on nodes
+    -usage         : print usage instructions
+    -verbose       : verbose output
+To check converted files: $0 -check [-verbose] files
+EOT
+
+while ($#ARGV >= 0 && $ARGV[0] =~ /^-/) {
+    $_ = shift(@ARGV);
+    if (/^-acc$/)            { $use_acc = 1; next; }
+    if (/^-d(ebug)?(\d+)?$/) { $debug = $2 || shift(@ARGV); next; }
+    if (/^-doctype$/)        { $doctype = shift(@ARGV); next; }
+    if (/^-c(heck)?$/)       { $check = 1; next; }
+    if (/^-e(xpandinfo)?$/)  { $expandinfo = 1; next; }
+    if (/^-g(lossary)?$/)    { $use_glossary = 1; next; }
+    if (/^-i(nvisible)?$/)   { $invisible_mark = shift(@ARGV); next; }
+    if (/^-iso$/)            { $use_iso = 1; next; }
+    if (/^-I(.+)?$/)         { push(@include_dirs, $1 || shift(@ARGV)); next; }
+    if (/^-m(enu)?$/)        { $show_menu = 1; next; }
+    if (/^-mono(lithic)?$/)  { $monolithic = 1; next; }
+    if (/^-n(umber)?$/)      { $number_sections = 1; next; }
+    if (/^-s(plit)?_?(n(ode)?|c(hapter)?)?$/) {
+	if ($2 =~ /^n/) {
+	    $split_node = 1;
+	} else {
+	    $split_chapter = 1;
+	}
+	next;
+    }
+    if (/^-v(erbose)?$/)     { $verbose = 1; next; }
+    die $usage;
+}
+if ($check) {
+    die $usage unless @ARGV > 0;
+    &check;
+    exit;
+}
+
+if (($split_node || $split_chapter) && $monolithic) {
+    warn "Can't use -monolithic with -split, -monolithic ignored.\n";
+    $monolithic = 0;
+}
+if ($expandinfo) {
+    $to_skip{'ifinfo'}++;
+    $to_skip{'end ifinfo'}++;
+} else {
+    $to_skip{'iftex'}++;
+    $to_skip{'end iftex'}++;
+}
+$invisible_mark = '<IMG SRC="invisible.xbm">' if $invisible_mark eq 'xbm';
+die $usage unless @ARGV == 1;
+$docu = shift(@ARGV);
+if ($docu =~ /.*\//) {
+    chop($docu_dir = $&);
+    $docu_name = $';
+} else {
+    $docu_dir = '.';
+    $docu_name = $docu;
+}
+unshift(@include_dirs, $docu_dir);
+$docu_name =~ s/\.te?x(i|info)?$//;	# basename of the document
+
+$docu_doc = "$docu_name.html";		# document's contents
+if ($monolithic) {
+    $docu_toc = $docu_foot = $docu_doc;
+} else {
+    $docu_toc  = "${docu_name}_toc.html";  # document's table of contents
+    $docu_foot = "${docu_name}_foot.html"; # document's footnotes
+}
+
+#
+# variables
+#
+%value = ();				# hold texinfo variables
+$value{'html'} = 1;			# predefine html (the output format)
+$value{'texi2html'} = '1.51';		# predefine texi2html (the translator)
+# _foo: internal to track @foo
+foreach ('_author', '_title', '_subtitle',
+	 '_settitle', '_setfilename') {
+    $value{$_} = '';		        # prevent -w warnings
+}
+%node2sec = ();				# node to section name
+%node2href = ();			# node to HREF
+%bib2href = ();				# bibliography reference to HREF
+%gloss2href = ();			# glossary term to HREF
+@sections = ();				# list of sections
+%tag2pro = ();				# protected sections
+
+#
+# initial indexes
+#
+$bib_num = 0;
+$foot_num = 0;
+$gloss_num = 0;
+$idx_num = 0;
+$sec_num = 0;
+$doc_num = 0;
+$html_num = 0;
+
+#
+# can I use ISO8879 characters? (HTML+)
+#
+if ($use_iso) {
+    $things_map{'bullet'} = "&bull;";
+    $things_map{'copyright'} = "&copy;";
+    $things_map{'dots'} = "&hellip;";
+    $things_map{'equiv'} = "&equiv;";
+    $things_map{'expansion'} = "&rarr;";
+    $things_map{'point'} = "&lowast;";
+    $things_map{'result'} = "&rArr;";
+}
+
+#
+# read texi2html extensions (if any)
+#
+$extensions = 'texi2html.ext'; # extensions in working directory
+if (-f $extensions) {
+    print "# reading extensions from $extensions\n" if $verbose;
+    require($extensions);
+}
+($progdir = $0) =~ s/[^\/]+$//;
+if ($progdir && ($progdir ne './')) {
+    $extensions = "${progdir}texi2html.ext"; # extensions in texi2html directory
+    if (-f $extensions) {
+	print "# reading extensions from $extensions\n" if $verbose;
+	require($extensions);
+    }
+}
+
+print "# reading from $docu\n" if $verbose;
+
+#+++############################################################################
+#                                                                              #
+# Pass 1: read source, handle command, variable, simple substitution           #
+#                                                                              #
+#---############################################################################
+
+@lines = ();				# whole document
+@toc_lines = ();			# table of contents
+$toplevel = 0;			        # top level seen in hierarchy
+$curlevel = 0;				# current level in TOC
+$node = '';				# current node name
+$in_table = 0;				# am I inside a table
+$table_type = '';			# type of table ('', 'f', 'v')
+@tables = ();			        # nested table support
+$in_bibliography = 0;			# am I inside a bibliography
+$in_glossary = 0;			# am I inside a glossary
+$in_top = 0;				# am I inside the top node
+$in_pre = 0;				# am I inside a preformatted section
+$in_list = 0;				# am I inside a list
+$in_html = 0;				# am I inside an HTML section
+$first_line = 1;		        # is it the first line
+$dont_html = 0;				# don't protect HTML on this line
+$split_num = 0;				# split index
+$deferred_ref = '';			# deferred reference for indexes
+@html_stack = ();			# HTML elements stack
+$html_element = '';			# current HTML element
+&html_reset;
+
+# build code for simple substitutions
+# the maps used (%simple_map and %things_map) MUST be aware of this
+# watch out for regexps, / and escaped characters!
+$subst_code = '';
+foreach (keys(%simple_map)) {
+    ($re = $_) =~ s/(\W)/\\$1/g; # protect regexp chars
+    $subst_code .= "s/\\\@$re/$simple_map{$_}/g;\n";
+}
+foreach (keys(%things_map)) {
+    $subst_code .= "s/\\\@$_\\{\\}/$things_map{$_}/g;\n";
+}
+if ($use_acc) {
+    # accentuated characters
+    foreach (keys(%accent_map)) {
+	if ($_ eq "`") {
+	    $subst_code .= "s/$;3";
+	} elsif ($_ eq "'") {
+	    $subst_code .= "s/$;4";
+	} else {
+	    $subst_code .= "s/\\\@\\$_";
+	}
+	$subst_code .= "([aeiou])/&\${1}$accent_map{$_};/gi;\n";
+    }
+}
+eval("sub simple_substitutions { $subst_code }");
+
+&init_input;
+while ($_ = &next_line) {
+    #
+    # remove \input on the first lines only
+    #
+    if ($first_line) {
+	next if /^\\input/;
+	$first_line = 0;
+    }
+    #
+    # parse texinfo tags
+    #
+    $tag = '';
+    $end_tag = '';
+    if (/^\@end\s+(\w+)\b/) {
+	$end_tag = $1;
+    } elsif (/^\@(\w+)\b/) {
+	$tag = $1;
+    }
+    #
+    # handle @ifhtml / @end ifhtml
+    #
+    if ($in_html) {
+	if ($end_tag eq 'ifhtml') {
+	    $in_html = 0;
+	} else {
+	    $tag2pro{$in_html} .= $_;
+	}
+	next;
+    } elsif ($tag eq 'ifhtml') {
+	$in_html = $PROTECTTAG . ++$html_num;
+	push(@lines, $in_html);
+	next;
+    }
+    #
+    # try to skip the line
+    #
+    if ($end_tag) {
+	next if $to_skip{"end $end_tag"};
+    } elsif ($tag) {
+	next if $to_skip{$tag};
+	last if $tag eq 'bye';
+    }
+    if ($in_top) {
+	# parsing the top node
+	if ($tag eq 'node' || $tag eq 'include' || $sec2level{$tag}) {
+	    # no more in top
+	    $in_top = 0;
+	} else {
+	    # skip it
+	    next;
+	}
+    }
+    #
+    # try to remove inlined comments
+    # syntax from tex-mode.el comment-start-skip
+    #
+    s/((^|[^\@])(\@\@)*)\@c(omment)? .*/$1/;
+    # non-@ substitutions cf. texinfmt.el
+    s/``/\"/g;
+    s/''/\"/g;
+    s/([\w ])---([\w ])/$1--$2/g;
+    #
+    # analyze the tag
+    #
+    if ($tag) {
+	# skip lines
+	&skip_until($tag), next if $tag eq 'ignore';
+	if ($expandinfo) {
+	    &skip_until($tag), next if $tag eq 'iftex';
+	} else {
+	    &skip_until($tag), next if $tag eq 'ifinfo';
+	}
+	&skip_until($tag), next if $tag eq 'tex';
+	# handle special tables
+	if ($tag eq 'table') {
+	    $table_type = '';
+	} elsif ($tag eq 'ftable') {
+	    $tag = 'table';
+	    $table_type = 'f';
+	} elsif ($tag eq 'vtable') {
+	    $tag = 'table';
+	    $table_type = 'v';
+	}
+	# special cases
+	if ($tag eq 'top' || ($tag eq 'node' && /^\@node\s+top\s*,/i)) {
+	    $in_top = 1;
+	    @lines = (); # ignore all lines before top (title page garbage)
+	    next;
+	} elsif ($tag eq 'node') {
+	    $in_top = 0;
+	    warn "$ERROR Bad node line: $_" unless $_ =~ /^\@node\s$NODESRE$/o;
+	    $_ = &protect_html($_); # if node contains '&' for instance
+	    s/^\@node\s+//;
+	    ($node) = split(/,/);
+	    &normalise_node($node);
+	    if ($split_node) {
+		&next_doc;
+		push(@lines, $SPLITTAG) if $split_num++;
+		push(@sections, $node);
+	    }
+	    next;
+	} elsif ($tag eq 'include') {
+	    if (/^\@include\s+($FILERE)\s*$/o) {
+		$file = $1;
+		unless (-e $file) {
+		    foreach $dir (@include_dirs) {
+			$file = "$dir/$1";
+			last if -e $file;
+		    }
+		}
+		if (-e $file) {
+		    &open($file);
+		    print "# including $file\n" if $verbose;
+		} else {
+		    warn "$ERROR Can't find $file, skipping";
+		}
+	    } else {
+		warn "$ERROR Bad include line: $_";
+	    }
+	    next;
+	} elsif ($tag eq 'ifclear') {
+	    if (/^\@ifclear\s+($VARRE)\s*$/o) {
+		next unless defined($value{$1});
+		&skip_until($tag);
+	    } else {
+		warn "$ERROR Bad ifclear line: $_";
+	    }
+	    next;
+	} elsif ($tag eq 'ifset') {
+	    if (/^\@ifset\s+($VARRE)\s*$/o) {
+		next if defined($value{$1});
+		&skip_until($tag);
+	    } else {
+		warn "$ERROR Bad ifset line: $_";
+	    }
+	    next;
+	} elsif ($tag eq 'menu') {
+	    unless ($show_menu) {
+		&skip_until($tag);
+		next;
+	    }
+	    &html_push_if($tag);
+	    push(@lines, &html_debug("\n", __LINE__));
+	} elsif ($format_map{$tag}) {
+	    $in_pre = 1 if $format_map{$tag} eq 'PRE';
+	    &html_push_if($format_map{$tag});
+	    push(@lines, &html_debug("\n", __LINE__));
+	    $in_list++ if $format_map{$tag} eq 'UL' || $format_map{$tag} eq 'OL' ;
+	    push(@lines, &debug("<$format_map{$tag}>\n", __LINE__));
+	    next;
+	} elsif ($tag eq 'table') {
+	    if (/^\@[fv]?table\s+\@(\w+)\s*$/) {
+		$in_table = $1;
+		unshift(@tables, join($;, $table_type, $in_table));
+		push(@lines, &debug("<DL COMPACT>\n", __LINE__));
+		&html_push_if('DL');
+		push(@lines, &html_debug("\n", __LINE__));
+	    } else {
+		warn "$ERROR Bad table line: $_";
+	    }
+	    next;
+	} elsif ($tag eq 'synindex' || $tag eq 'syncodeindex') {
+	    if (/^\@$tag\s+(\w)\w\s+(\w)\w\s*$/) {
+		eval("*${1}index = *${2}index");
+	    } else {
+		warn "$ERROR Bad syn*index line: $_";
+	    }
+	    next;
+	} elsif ($tag eq 'sp') {
+	    push(@lines, &debug("<P>\n", __LINE__));
+	    next;
+	} elsif ($tag eq 'setref') {
+	    &protect_html; # if setref contains '&' for instance
+	    if (/^\@$tag\s*{($NODERE)}\s*$/) {
+		$setref = $1;
+		$setref =~ s/\s+/ /g; # normalize
+		$setref =~ s/ $//;
+		$node2sec{$setref} = $name;
+		$node2href{$setref} = "$docu_doc#$docid";
+	    } else {
+		warn "$ERROR Bad setref line: $_";
+	    }
+	    next;
+	} elsif ($tag eq 'defindex' || $tag eq 'defcodeindex') {
+	    if (/^\@$tag\s+(\w\w)\s*$/) {
+		$valid_index{$1} = 1;
+	    } else {
+		warn "$ERROR Bad defindex line: $_";
+	    }
+	    next;
+	} elsif (defined($def_map{$tag})) {
+	    if ($def_map{$tag}) {
+		s/^\@$tag\s+//;
+		$tag = $def_map{$tag};
+		$_ = "\@$tag $_";
+		$tag =~ s/\s.*//;
+	    }
+	} elsif (defined($user_sub{$tag})) {
+	    s/^\@$tag\s+//;
+	    $sub = $user_sub{$tag};
+	    print "# user $tag = $sub, arg: $_" if $debug & $DEBUG_USER;
+	    if (defined(&$sub)) {
+		chop($_);
+		&$sub($_);
+	    } else {
+		warn "$ERROR Bad user sub for $tag: $sub\n";
+	    }
+	    next;
+	}
+	if (defined($def_map{$tag})) {
+	    s/^\@$tag\s+//;
+	    if ($tag =~ /x$/) {
+		# extra definition line
+		$tag = $`;
+		$is_extra = 1;
+	    } else {
+		$is_extra = 0;
+	    }
+	    while (/\{([^\{\}]*)\}/) {
+		# this is a {} construct
+		($before, $contents, $after) = ($`, $1, $');
+		# protect spaces
+		$contents =~ s/\s+/$;9/g;
+		# restore $_ protecting {}
+		$_ = "$before$;7$contents$;8$after";
+	    }
+	    @args = split(/\s+/, &protect_html($_));
+	    foreach (@args) {
+		s/$;9/ /g;	# unprotect spaces
+		s/$;7/\{/g;	# ... {
+		s/$;8/\}/g;	# ... }
+	    }
+	    $type = shift(@args);
+	    $type =~ s/^\{(.*)\}$/$1/;
+	    print "# def ($tag): {$type} ", join(', ', @args), "\n"
+		if $debug & $DEBUG_DEF;
+	    $type .= ':'; # it's nicer like this
+	    $name = shift(@args);
+	    $name =~ s/^\{(.*)\}$/$1/;
+	    if ($is_extra) {
+		$_ = &debug("<DT>", __LINE__);
+	    } else {
+		$_ = &debug("<DL>\n<DT>", __LINE__);
+	    }
+	    if ($tag eq 'deffn' || $tag eq 'defvr' || $tag eq 'deftp') {
+		$_ .= "<U>$type</U> <B>$name</B>";
+		$_ .= " <I>@args</I>" if @args;
+	    } elsif ($tag eq 'deftypefn' || $tag eq 'deftypevr'
+		     || $tag eq 'defcv' || $tag eq 'defop') {
+		$ftype = $name;
+		$name = shift(@args);
+		$name =~ s/^\{(.*)\}$/$1/;
+		$_ .= "<U>$type</U> $ftype <B>$name</B>";
+		$_ .= " <I>@args</I>" if @args;
+	    } else {
+		warn "$ERROR Unknown definition type: $tag\n";
+		$_ .= "<U>$type</U> <B>$name</B>";
+		$_ .= " <I>@args</I>" if @args;
+	    }
+ 	    $_ .= &debug("\n<DD>", __LINE__);
+	    $name = &unprotect_html($name);
+	    if ($tag eq 'deffn' || $tag eq 'deftypefn') {
+		unshift(@input_spool, "\@findex $name\n");
+	    } elsif ($tag eq 'defop') {
+		unshift(@input_spool, "\@findex $name on $ftype\n");
+	    } elsif ($tag eq 'defvr' || $tag eq 'deftypevr' || $tag eq 'defcv') {
+		unshift(@input_spool, "\@vindex $name\n");
+	    } else {
+		unshift(@input_spool, "\@tindex $name\n");
+	    }
+	    $dont_html = 1;
+	}
+    } elsif ($end_tag) {
+	if ($format_map{$end_tag}) {
+	    $in_pre = 0 if $format_map{$end_tag} eq 'PRE';
+	    $in_list-- if $format_map{$end_tag} eq 'UL' || $format_map{$end_tag} eq 'OL' ;
+	    &html_pop_if('LI', 'P');
+	    &html_pop_if();
+	    push(@lines, &debug("</$format_map{$end_tag}>\n", __LINE__));
+	    push(@lines, &html_debug("\n", __LINE__));
+	} elsif ($end_tag eq 'table' ||
+		 $end_tag eq 'ftable' ||
+		 $end_tag eq 'vtable') {
+	    shift(@tables);
+	    if (@tables) {
+		($table_type, $in_table) = split($;, $tables[0]);
+	    } else {
+		$in_table = 0;
+	    }
+	    push(@lines, "</DL>\n");
+	    &html_pop_if('DD');
+	    &html_pop_if();
+	} elsif (defined($def_map{$end_tag})) {
+ 	    push(@lines, &debug("</DL>\n", __LINE__));
+	} elsif ($end_tag eq 'menu') {
+	    &html_pop_if();
+	    push(@lines, $_); # must keep it for pass 2
+	}
+	next;
+    }
+    #
+    # misc things
+    #
+    # protect texi and HTML things
+    &protect_texi;
+    $_ = &protect_html($_) unless $dont_html;
+    $dont_html = 0;
+    # substitution (unsupported things)
+    s/^\@center\s+//g;
+    s/^\@exdent\s+//g;
+    s/\@noindent\s+//g;
+    s/\@refill\s+//g;
+    # other substitutions
+    &simple_substitutions;
+    s/\@value{($VARRE)}/$value{$1}/eg;
+    s/\@footnote\{/\@footnote$docu_doc\{/g; # mark footnotes, cf. pass 4
+    #
+    # analyze the tag again
+    #
+    if ($tag) {
+	if (defined($sec2level{$tag}) && $sec2level{$tag} > 0) {
+	    if (/^\@$tag\s+(.+)$/) {
+		$name = $1;
+		$name =~ s/\s+$//;
+		$level = $sec2level{$tag};
+		$name = &update_sec_num($tag, $level) . "  $name"
+		    if $number_sections && $tag !~ /^unnumbered/;
+		if ($tag =~ /heading$/) {
+		    push(@lines, &html_debug("\n", __LINE__));
+		    if ($html_element ne 'body') {
+			# We are in a nice pickle here. We are trying to get a H? heading
+			# even though we are not in the body level. So, we convert it to a
+			# nice, bold, line by itself.
+			$_ = &debug("\n\n<P><STRONG>$name</STRONG></P>\n\n", __LINE__);
+		    } else {
+			$_ = &debug("<H$level>$name</H$level>\n", __LINE__);
+			&html_push_if('body');
+		    }
+		    print "# heading, section $name, level $level\n"
+			if $debug & $DEBUG_TOC;
+		} else {
+		    if ($split_chapter) {
+			unless ($toplevel) {
+			    # first time we see a "section"
+			    unless ($level == 1) {
+				warn "$ERROR The first section found is not of level 1: $_";
+				warn "$ERROR I'll split on sections of level $level...\n";
+			    }
+			    $toplevel = $level;
+			}
+			if ($level == $toplevel) {
+			    &next_doc;
+			    push(@lines, $SPLITTAG) if $split_num++;
+			    push(@sections, $name);
+			}
+		    }
+		    $sec_num++;
+		    $docid = "SEC$sec_num";
+		    $tocid = "TOC$sec_num";
+		    # check biblio and glossary
+		    $in_bibliography = ($name =~ /^([A-Z]|\d+)?(\.\d+)*\s*bibliography$/i);
+		    $in_glossary = ($name =~ /^([A-Z]|\d+)?(\.\d+)*\s*glossary$/i);
+		    # check node
+		    if ($node) {
+			if ($node2sec{$node}) {
+			    warn "$ERROR Duplicate node found: $node\n";
+			} else {
+			    $node2sec{$node} = $name;
+			    $node2href{$node} = "$docu_doc#$docid";
+			    print "# node $node, section $name, level $level\n"
+				if $debug & $DEBUG_TOC;
+			}
+			$node = '';
+		    } else {
+			print "# no node, section $name, level $level\n"
+			    if $debug & $DEBUG_TOC;
+		    }
+		    # update TOC
+		    while ($level > $curlevel) {
+			$curlevel++;
+			push(@toc_lines, "<UL>\n");
+		    }
+		    while ($level < $curlevel) {
+			$curlevel--;
+			push(@toc_lines, "</UL>\n");
+		    }
+		    $_ = "<LI>" . &anchor($tocid, "$docu_doc#$docid", $name, 1);
+		    push(@toc_lines, &substitute_style($_));
+		    # update DOC
+		    push(@lines, &html_debug("\n", __LINE__));
+		    &html_reset;
+		    $_ =  "<H$level>".&anchor($docid, "$docu_toc#$tocid", $name)."</H$level>\n";
+		    $_ = &debug($_, __LINE__);
+		    push(@lines, &html_debug("\n", __LINE__));
+		}
+		# update DOC
+		foreach $line (split(/\n+/, $_)) {
+		    push(@lines, "$line\n");
+		}
+		next;
+	    } else {
+		warn "$ERROR Bad section line: $_";
+	    }
+	} else {
+	    # track variables
+	    $value{$1} = $2, next if /^\@set\s+($VARRE)\s+(.*)$/o;
+	    delete $value{$1}, next if /^\@clear\s+($VARRE)\s*$/o;
+	    # store things
+	    $value{'_setfilename'}   = $1, next if /^\@setfilename\s+(.*)$/;
+	    $value{'_settitle'}      = $1, next if /^\@settitle\s+(.*)$/;
+	    $value{'_author'}   .= "$1\n", next if /^\@author\s+(.*)$/;
+	    $value{'_subtitle'} .= "$1\n", next if /^\@subtitle\s+(.*)$/;
+	    $value{'_title'}    .= "$1\n", next if /^\@title\s+(.*)$/;
+	    # index
+	    if (/^\@(..?)index\s+/) {
+		unless ($valid_index{$1}) {
+		    warn "$ERROR Undefined index command: $_";
+		    next;
+		}
+		$id = 'IDX' . ++$idx_num;
+		$index = $1 . 'index';
+		$what = &substitute_style($');
+		$what =~ s/\s+$//;
+		print "# found $index for '$what' id $id\n"
+		    if $debug & $DEBUG_INDEX;
+		eval(<<EOC);
+		if (defined(\$$index\{\$what\})) {
+		    \$$index\{\$what\} .= "$;$docu_doc#$id";
+		} else {
+		    \$$index\{\$what\} = "$docu_doc#$id";
+		}
+EOC
+		#
+		# dirty hack to see if I can put an invisible anchor...
+		#
+		if ($html_element eq 'P' ||
+		    $html_element eq 'LI' ||
+		    $html_element eq 'DT' ||
+		    $html_element eq 'DD' ||
+		    $html_element eq 'ADDRESS' ||
+		    $html_element eq 'B' ||
+		    $html_element eq 'BLOCKQUOTE' ||
+		    $html_element eq 'PRE' ||
+		    $html_element eq 'SAMP') {
+                    push(@lines, &anchor($id, '', $invisible_mark, !$in_pre));
+                } elsif ($html_element eq 'body') {
+		    push(@lines, &debug("<P>\n", __LINE__));
+                    push(@lines, &anchor($id, '', $invisible_mark, !$in_pre));
+		    &html_push('P');
+		} elsif ($html_element eq 'DL' ||
+			 $html_element eq 'UL' ||
+			 $html_element eq 'OL' ) {
+		    $deferred_ref .= &anchor($id, '', $invisible_mark, !$in_pre) . " ";
+		}
+		next;
+	    }
+	    # list item
+	    if (/^\@itemx?\s+/) {
+		$what = $';
+		$what =~ s/\s+$//;
+		if ($in_bibliography && $use_bibliography) {
+		    if ($what =~ /^$BIBRE$/o) {
+			$id = 'BIB' . ++$bib_num;
+			$bib2href{$what} = "$docu_doc#$id";
+			print "# found bibliography for '$what' id $id\n"
+			    if $debug & $DEBUG_BIB;
+			$what = &anchor($id, '', $what);
+		    }
+		} elsif ($in_glossary && $use_glossary) {
+		    $id = 'GLOSS' . ++$gloss_num;
+		    $entry = $what;
+		    $entry =~ tr/A-Z/a-z/ unless $entry =~ /^[A-Z\s]+$/;
+		    $gloss2href{$entry} = "$docu_doc#$id";
+		    print "# found glossary for '$entry' id $id\n"
+			if $debug & $DEBUG_GLOSS;
+		    $what = &anchor($id, '', $what);
+		}
+		&html_pop_if('P');
+		if ($html_element eq 'DL' || $html_element eq 'DD') {
+		    if ($things_map{$in_table} && !$what) {
+			# special case to allow @table @bullet for instance
+			push(@lines, &debug("<DT>$things_map{$in_table}\n", __LINE__));
+		    } else {
+			push(@lines, &debug("<DT>\@$in_table\{$what\}\n", __LINE__));
+		    }
+		    push(@lines, "<DD>");
+		    &html_push('DD') unless $html_element eq 'DD';
+		    if ($table_type) { # add also an index
+			unshift(@input_spool, "\@${table_type}index $what\n");
+		    }
+		} else {
+		    push(@lines, &debug("<LI>$what\n", __LINE__));
+		    &html_push('LI') unless $html_element eq 'LI';
+		}
+		push(@lines, &html_debug("\n", __LINE__));
+		if ($deferred_ref) {
+		    push(@lines, &debug("$deferred_ref\n", __LINE__));
+		    $deferred_ref = '';
+		}
+		next;
+	    }
+	}
+    }
+    # paragraph separator
+    if ($_ eq "\n") {
+	next if $#lines >= 0 && $lines[$#lines] eq "\n";
+	if ($html_element eq 'P') {
+	    push(@lines, "\n");
+	    $_ = &debug("</P>\n", __LINE__);
+	    &html_pop;
+	}
+    } elsif ($html_element eq 'body' || $html_element eq 'BLOCKQUOTE') {
+	push(@lines, "<P>\n");
+	&html_push('P');
+	$_ = &debug($_, __LINE__);
+    }
+    # otherwise
+    push(@lines, $_);
+}
+
+# finish TOC
+$level = 0;
+while ($level < $curlevel) {
+    $curlevel--;
+    push(@toc_lines, "</UL>\n");
+}
+
+print "# end of pass 1\n" if $verbose;
+
+#+++############################################################################
+#                                                                              #
+# Pass 2/3: handle style, menu, index, cross-reference                         #
+#                                                                              #
+#---############################################################################
+
+@lines2 = ();				# whole document (2nd pass)
+@lines3 = ();				# whole document (3rd pass)
+$in_menu = 0;				# am I inside a menu
+
+while (@lines) {
+    $_ = shift(@lines);
+    #
+    # special case (protected sections)
+    #
+    if (/^$PROTECTTAG/o) {
+	push(@lines2, $_);
+	next;
+    }
+    #
+    # menu
+    #
+    $in_menu = 1, push(@lines2, &debug("<UL>\n", __LINE__)), next if /^\@menu\b/;
+    $in_menu = 0, push(@lines2, &debug("</UL>\n", __LINE__)), next if /^\@end\s+menu\b/;
+    if ($in_menu) {
+	if (/^\*\s+($NODERE)::/o) {
+	    $descr = $';
+	    chop($descr);
+	    &menu_entry($1, $1, $descr);
+	} elsif (/^\*\s+(.+):\s+([^\t,\.\n]+)[\t,\.\n]/) {
+	    $descr = $';
+	    chop($descr);
+	    &menu_entry($1, $2, $descr);
+	} elsif (/^\*/) {
+	    warn "$ERROR Bad menu line: $_";
+	} else { # description continued?
+	    push(@lines2, $_);
+	}
+	next;
+    }
+    #
+    # printindex
+    #
+    if (/^\@printindex\s+(\w\w)\b/) {
+	local($index, *ary, @keys, $key, $letter, $last_letter, @refs);
+	if ($predefined_index{$1}) {
+	    $index = $predefined_index{$1} . 'index';
+	} else {
+	    $index = $1 . 'index';
+	}
+	eval("*ary = *$index");
+	@keys = keys(%ary);
+	foreach $key (@keys) {
+	    $_ = $key;
+	    1 while s/<(\w+)>\`(.*)\'<\/\1>/$2/; # remove HTML tags with quotes
+	    1 while s/<(\w+)>(.*)<\/\1>/$2/;     # remove HTML tags
+	    $_ = &unprotect_html($_);
+	    &unprotect_texi;
+	    tr/A-Z/a-z/; # lowercase
+	    $key2alpha{$key} = $_;
+	    print "# index $key sorted as $_\n"
+		if $key ne $_ && $debug & $DEBUG_INDEX;
+	}
+	$last_letter = undef;
+	foreach $key (sort byalpha @keys) {
+	    $letter = substr($key2alpha{$key}, 0, 1);
+	    $letter = substr($key2alpha{$key}, 0, 2) if $letter eq $;;
+	    if (!defined($last_letter) || $letter ne $last_letter) {
+		push(@lines2, "</DIR>\n") if defined($last_letter);
+		push(@lines2, "<H2>" . &protect_html($letter) . "</H2>\n");
+		push(@lines2, "<DIR>\n");
+		$last_letter = $letter;
+	    }
+	    @refs = ();
+	    foreach (split(/$;/, $ary{$key})) {
+		push(@refs, &anchor('', $_, $key, 0));
+	    }
+	    push(@lines2, "<LI>" . join(", ", @refs) . "\n");
+	}
+	push(@lines2, "</DIR>\n") if defined($last_letter);
+	next;
+    }
+    #
+    # simple style substitutions
+    #
+    $_ = &substitute_style($_);
+    #
+    # xref
+    #
+    while (/\@(x|px|info|)ref{($XREFRE)(}?)/o) {
+	# note: Texinfo may accept other characters
+	($type, $nodes, $full) = ($1, $2, $3);
+	($before, $after) = ($`, $');
+	if (! $full && $after) {
+	    warn "$ERROR Bad xref (no ending } on line): $_";
+	    $_ = "$before$;0${type}ref\{$nodes$after";
+	    next; # while xref
+	}
+	if ($type eq 'x') {
+	    $type = 'See ';
+	} elsif ($type eq 'px') {
+	    $type = 'see ';
+	} elsif ($type eq 'info') {
+	    $type = 'See Info';
+	} else {
+	    $type = '';
+	}
+	unless ($full) {
+	    $next = shift(@lines);
+	    $next = &substitute_style($next);
+	    chop($nodes); # remove final newline
+	    if ($next =~ /\}/) { # split on 2 lines
+		$nodes .= " $`";
+		$after = $';
+	    } else {
+		$nodes .= " $next";
+		$next = shift(@lines);
+		$next = &substitute_style($next);
+		chop($nodes);
+		if ($next =~ /\}/) { # split on 3 lines
+		    $nodes .= " $`";
+		    $after = $';
+		} else {
+		    warn "$ERROR Bad xref (no ending }): $_";
+		    $_ = "$before$;0xref\{$nodes$after";
+		    unshift(@lines, $next);
+		    next; # while xref
+		}
+	    }
+	}
+	$nodes =~ s/\s+/ /g; # remove useless spaces
+	@args = split(/\s*,\s*/, $nodes);
+	$node = $args[0]; # the node is always the first arg
+	&normalise_node($node);
+	$sec = $node2sec{$node};
+	if (@args == 5) { # reference to another manual
+	    $sec = $args[2] || $node;
+	    $man = $args[4] || $args[3];
+	    $_ = "${before}${type}section `$sec' in \@cite{$man}$after";
+	} elsif ($type =~ /Info/) { # inforef
+	    warn "$ERROR Wrong number of arguments: $_" unless @args == 3;
+	    ($nn, $_, $in) = @args;
+	    $_ = "${before}${type} file `$in', node `$nn'$after";
+	} elsif ($sec) {
+	    $href = $node2href{$node};
+	    $_ = "${before}${type}section " . &anchor('', $href, $sec) . $after;
+	} else {
+	    warn "$ERROR Undefined node ($node): $_";
+	    $_ = "$before$;0xref{$nodes}$after";
+	}
+    }
+    #
+    # try to guess bibliography references or glossary terms
+    #
+    unless (/^<H\d><A NAME=\"SEC\d/) {
+	if ($use_bibliography) {
+	    $done = '';
+	    while (/$BIBRE/o) {
+		($pre, $what, $post) = ($`, $&, $');
+		$href = $bib2href{$what};
+		if (defined($href) && $post !~ /^[^<]*<\/A>/) {
+		    $done .= $pre . &anchor('', $href, $what);
+		} else {
+		    $done .= "$pre$what";
+		}
+		$_ = $post;
+	    }
+	    $_ = $done . $_;
+	}
+	if ($use_glossary) {
+	    $done = '';
+	    while (/\b\w+\b/) {
+		($pre, $what, $post) = ($`, $&, $');
+		$entry = $what;
+		$entry =~ tr/A-Z/a-z/ unless $entry =~ /^[A-Z\s]+$/;
+		$href = $gloss2href{$entry};
+		if (defined($href) && $post !~ /^[^<]*<\/A>/) {
+		    $done .= $pre . &anchor('', $href, $what);
+		} else {
+		    $done .= "$pre$what";
+		}
+		$_ = $post;
+	    }
+	    $_ = $done . $_;
+	}
+    }
+    # otherwise
+    push(@lines2, $_);
+}
+print "# end of pass 2\n" if $verbose;
+
+#
+# split style substitutions
+#
+while (@lines2) {
+    $_ = shift(@lines2);
+    #
+    # special case (protected sections)
+    #
+    if (/^$PROTECTTAG/o) {
+	push(@lines3, $_);
+	next;
+    }
+    #
+    # split style substitutions
+    #
+    $old = '';
+    while ($old ne $_) {
+        $old = $_;
+	if (/\@(\w+)\{/) {
+	    ($before, $style, $after) = ($`, $1, $');
+	    if (defined($style_map{$style})) {
+		$_ = $after;
+		$text = '';
+		$after = '';
+		$failed = 1;
+		while (@lines2) {
+		    if (/\}/) {
+			$text .= $`;
+			$after = $';
+			$failed = 0;
+			last;
+		    } else {
+			$text .= $_;
+			$_ = shift(@lines2);
+		    }
+		}
+		if ($failed) {
+		    die "* Bad syntax (\@$style) after: $before\n";
+		} else {
+		    $text = &apply_style($style, $text);
+		    $_ = "$before$text$after";
+		}
+	    }
+	}
+    }
+    # otherwise
+    push(@lines3, $_);
+}
+print "# end of pass 3\n" if $verbose;
+
+#+++############################################################################
+#                                                                              #
+# Pass 4: foot notes, final cleanup                                            #
+#                                                                              #
+#---############################################################################
+
+@foot_lines = ();			# footnotes
+@doc_lines = ();			# final document
+$end_of_para = 0;			# true if last line is <P>
+
+while (@lines3) {
+    $_ = shift(@lines3);
+    #
+    # special case (protected sections)
+    #
+    if (/^$PROTECTTAG/o) {
+	push(@doc_lines, $_);
+	$end_of_para = 0;
+	next;
+    }
+    #
+    # footnotes
+    #
+    while (/\@footnote([^\{\s]+)\{/) {
+	($before, $d, $after) = ($`, $1, $');
+	$_ = $after;
+	$text = '';
+	$after = '';
+	$failed = 1;
+	while (@lines3) {
+	    if (/\}/) {
+		$text .= $`;
+		$after = $';
+		$failed = 0;
+		last;
+	    } else {
+		$text .= $_;
+		$_ = shift(@lines3);
+	    }
+	}
+	if ($failed) {
+	    die "* Bad syntax (\@footnote) after: $before\n";
+	} else {
+	    $foot_num++;
+	    $docid  = "DOCF$foot_num";
+	    $footid = "FOOT$foot_num";
+	    $foot = "($foot_num)";
+	    push(@foot_lines, "<H3>" . &anchor($footid, "$d#$docid", $foot) . "</H3>\n");
+	    $text = "<P>$text" unless $text =~ /^\s*<P>/;
+	    push(@foot_lines, "$text\n");
+	    $_ = $before . &anchor($docid, "$docu_foot#$footid", $foot) . $after;
+	}
+    }
+    #
+    # remove unnecessary <P>
+    #
+    if (/^\s*<P>\s*$/) {
+	next if $end_of_para++;
+    } else {
+	$end_of_para = 0;
+    }
+    # otherwise
+    push(@doc_lines, $_);
+}
+print "# end of pass 4\n" if $verbose;
+
+#+++############################################################################
+#                                                                              #
+# Pass 5: print things                                                         #
+#                                                                              #
+#---############################################################################
+
+$header = <<EOT;
+<!-- This HTML file has been created by $THISPROG
+     from $docu on $TODAY -->
+EOT
+
+$full_title = $value{'_title'} || $value{'_settitle'} || "Untitled Document";
+$title = $value{'_settitle'} || $full_title;
+$_ = &substitute_style($full_title);
+&unprotect_texi;
+s/\n$//; # rmv last \n (if any)
+$full_title = "<H1>" . join("</H1>\n<H1>", split(/\n/, $_)) . "</H1>\n";
+
+#
+# print ToC
+#
+if (!$monolithic && @toc_lines) {
+    if (open(FILE, "> $docu_toc")) {
+	print "# creating $docu_toc...\n" if $verbose;
+	&print_toplevel_header("$title - Table of Contents");
+	&print_ruler;
+	&print(*toc_lines, FILE);
+	&print_toplevel_footer;
+	close(FILE);
+    } else {
+	warn "$ERROR Can't write to $docu_toc: $!\n";
+    }
+}
+
+#
+# print footnotes
+#
+if (!$monolithic && @foot_lines) {
+    if (open(FILE, "> $docu_foot")) {
+	print "# creating $docu_foot...\n" if $verbose;
+	&print_toplevel_header("$title - Footnotes");
+	&print_ruler;
+        &print(*foot_lines, FILE);
+	&print_toplevel_footer;
+	close(FILE);
+    } else {
+	warn "$ERROR Can't write to $docu_foot: $!\n";
+    }
+}
+
+#
+# print document
+#
+if ($split_chapter || $split_node) { # split
+    $doc_num = 0;
+    $last_num = scalar(@sections);
+    $first_doc = &doc_name(1);
+    $last_doc = &doc_name($last_num);
+    while (@sections) {
+	$section = shift(@sections);
+	&next_doc;
+	if (open(FILE, "> $docu_doc")) {
+	    print "# creating $docu_doc...\n" if $verbose;
+	    &print_header("$title - $section");
+	    $prev_doc = ($doc_num == 1 ? undef : &doc_name($doc_num - 1));
+	    $next_doc = ($doc_num == $last_num ? undef : &doc_name($doc_num + 1));
+	    $navigation = "Go to the ";
+	    $navigation .= ($prev_doc ? &anchor('', $first_doc, "first") : "first");
+	    $navigation .= ", ";
+	    $navigation .= ($prev_doc ? &anchor('', $prev_doc, "previous") : "previous");
+	    $navigation .= ", ";
+	    $navigation .= ($next_doc ? &anchor('', $next_doc, "next") : "next");
+	    $navigation .= ", ";
+	    $navigation .= ($next_doc ? &anchor('', $last_doc, "last") : "last");
+	    $navigation .= " section, " . &anchor('', $docu_toc, "table of contents") . ".\n";
+	    print FILE $navigation;
+	    &print_ruler;
+	    # find corresponding lines
+            @tmp_lines = ();
+            while (@doc_lines) {
+		$_ = shift(@doc_lines);
+		last if ($_ eq $SPLITTAG);
+		push(@tmp_lines, $_);
+	    }
+            &print(*tmp_lines, FILE);
+	    &print_ruler;
+	    print FILE $navigation;
+	    &print_footer;
+	    close(FILE);
+	} else {
+	    warn "$ERROR Can't write to $docu_doc: $!\n";
+	}
+    }
+} else { # not split
+    if (open(FILE, "> $docu_doc")) {
+	print "# creating $docu_doc...\n" if $verbose;
+	if ($monolithic || !@toc_lines) {
+	    &print_toplevel_header($title);
+	} else {
+	    &print_header($title);
+	    print FILE $full_title;
+	}
+	if ($monolithic && @toc_lines) {
+	    &print_ruler;
+ 	    print FILE "<H1>Table of Contents</H1>\n";
+ 	    &print(*toc_lines, FILE);
+	}
+	&print_ruler;
+        &print(*doc_lines, FILE);
+	if ($monolithic && @foot_lines) {
+	    &print_ruler;
+ 	    print FILE "<H1>Footnotes</H1>\n";
+ 	    &print(*foot_lines, FILE);
+	}
+	if ($monolithic || !@toc_lines) {
+	    &print_toplevel_footer;
+	} else {
+	    &print_footer;
+	}
+	close(FILE);
+    } else {
+	warn "$ERROR Can't write to $docu_doc: $!\n";
+    }
+}
+
+print "# that's all folks\n" if $verbose;
+
+#+++############################################################################
+#                                                                              #
+# Low level functions                                                          #
+#                                                                              #
+#---############################################################################
+
+sub update_sec_num {
+    local($name, $level) = @_;
+
+    $level--; # here we start at 0
+    if ($name =~ /^appendix/) {
+	# appendix style
+	if (defined(@appendix_sec_num)) {
+	    &incr_sec_num($level, @appendix_sec_num);
+	} else {
+	    @appendix_sec_num = ('A', 0, 0, 0);
+	}
+	return(join('.', @appendix_sec_num[0..$level]));
+    } else {
+	# normal style
+	if (defined(@normal_sec_num)) {
+	    &incr_sec_num($level, @normal_sec_num);
+	} else {
+	    @normal_sec_num = (1, 0, 0, 0);
+	}
+	return(join('.', @normal_sec_num[0..$level]));
+    }
+}
+
+sub incr_sec_num {
+    local($level, $l);
+    $level = shift(@_);
+    $_[$level]++;
+    foreach $l ($level+1 .. 3) {
+	$_[$l] = 0;
+    }
+}
+
+sub check {
+    local($_, %seen, %context, $before, $match, $after);
+
+    while (<>) {
+	if (/\@(\*|\.|\:|\@|\{|\})/) {
+	    $seen{$&}++;
+	    $context{$&} .= "> $_" if $verbose;
+	    $_ = "$`XX$'";
+	    redo;
+	}
+	if (/\@(\w+)/) {
+	    ($before, $match, $after) = ($`, $&, $');
+	    if ($before =~ /\b[\w-]+$/ && $after =~ /^[\w-.]*\b/) { # e-mail address
+		$seen{'e-mail address'}++;
+		$context{'e-mail address'} .= "> $_" if $verbose;
+	    } else {
+		$seen{$match}++;
+		$context{$match} .= "> $_" if $verbose;
+	    }
+	    $match =~ s/^\@/X/;
+	    $_ = "$before$match$after";
+	    redo;
+	}
+    }
+    
+    foreach (sort(keys(%seen))) {
+	if ($verbose) {
+	    print "$_\n";
+	    print $context{$_};
+	} else {
+	    print "$_ ($seen{$_})\n";
+	}
+    }
+}
+
+sub open {
+    local($name) = @_;
+
+    ++$fh_name;
+    if (open($fh_name, $name)) {
+	unshift(@fhs, $fh_name);
+    } else {
+	warn "$ERROR Can't read file $name: $!\n";
+    }
+}
+
+sub init_input {
+    @fhs = ();			# hold the file handles to read
+    @input_spool = ();		# spooled lines to read
+    $fh_name = 'FH000';
+    &open($docu);
+}
+
+sub next_line {
+    local($fh, $line);
+
+    if (@input_spool) {
+	$line = shift(@input_spool);
+	return($line);
+    }
+    while (@fhs) {
+	$fh = $fhs[0];
+	$line = <$fh>;
+	return($line) if $line;
+	close($fh);
+	shift(@fhs);
+    }
+    return(undef);
+}
+
+# used in pass 1, use &next_line
+sub skip_until {
+    local($tag) = @_;
+    local($_);
+
+    while ($_ = &next_line) {
+	return if /^\@end\s+$tag\s*$/;
+    }
+    die "* Failed to find '$tag' after: " . $lines[$#lines];
+}
+
+#
+# HTML stacking to have a better HTML output
+#
+
+sub html_reset {
+    @html_stack = ('html');
+    $html_element = 'body';
+}
+
+sub html_push {
+    local($what) = @_;
+    push(@html_stack, $html_element);
+    $html_element = $what;
+}
+
+sub html_push_if {
+    local($what) = @_;
+    push(@html_stack, $html_element)
+	if ($html_element && $html_element ne 'P');
+    $html_element = $what;
+}
+
+sub html_pop {
+    $html_element = pop(@html_stack);
+}
+
+sub html_pop_if {
+    local($elt);
+
+    if (@_) {
+	foreach $elt (@_) {
+	    if ($elt eq $html_element) {
+		$html_element = pop(@html_stack) if @html_stack;
+		last;
+	    }
+	}
+    } else {
+	$html_element = pop(@html_stack) if @html_stack;
+    }
+}
+
+sub html_debug {
+    local($what, $line) = @_;
+    return("<!-- $line @html_stack, $html_element -->$what")
+	if $debug & $DEBUG_HTML;
+    return($what);
+}
+
+# to debug the output...
+sub debug {
+    local($what, $line) = @_;
+    return("<!-- $line -->$what")
+	if $debug & $DEBUG_HTML;
+    return($what);
+}
+
+sub normalise_node {
+    $_[0] =~ s/\s+/ /g;
+    $_[0] =~ s/ $//;
+    $_[0] =~ s/^ //;
+}
+
+sub menu_entry {
+    local($entry, $node, $descr) = @_;
+    local($href);
+
+    &normalise_node($node);
+    $href = $node2href{$node};
+    if ($href) {
+	$descr =~ s/^\s+//;
+	$descr = ": $descr" if $descr;
+	push(@lines2, "<LI>" . &anchor('', $href, $entry) . "$descr\n");
+    } else {
+	warn "$ERROR Undefined node ($node): $_";
+    }
+}
+
+sub do_ctrl { "^$_[0]" }
+
+sub do_sc { "\U$_[0]\E" }
+
+sub apply_style {
+    local($texi_style, $text) = @_;
+    local($style);
+
+    $style = $style_map{$texi_style};
+    if (defined($style)) { # known style
+	if ($style =~ /^\"/) { # add quotes
+	    $style = $';
+	    $text = "\`$text\'";
+	}
+	if ($style =~ /^\&/) { # custom
+	    $style = $';
+	    $text = &$style($text);
+	} elsif ($style) { # good style
+	    $text = "<$style>$text</$style>";
+	} else { # no style
+	}
+    } else { # unknown style
+	$text = undef;
+    }
+    return($text);
+}
+
+# remove Texinfo styles
+sub remove_style {
+    local($_) = @_;
+    s/\@\w+{([^\{\}]+)}/$1/g;
+    return($_);
+}
+
+sub substitute_style {
+    local($_) = @_;
+    local($changed, $done, $style, $text);
+
+    $changed = 1;
+    while ($changed) {
+	$changed = 0;
+	$done = '';
+	while (/\@(\w+){([^\{\}]+)}/) {
+	    $text = &apply_style($1, $2);
+	    if ($text) {
+		$_ = "$`$text$'";
+		$changed = 1;
+	    } else {
+		$done .= "$`\@$1";
+		$_ = "{$2}$'";
+	    }
+	}
+        $_ = $done . $_;
+    }
+    return($_);
+}
+
+sub anchor {
+    local($name, $href, $text, $newline) = @_;
+    local($result);
+
+    $result = "<A";
+    $result .= " NAME=\"$name\"" if $name;
+    $result .= " HREF=\"$href\"" if $href;
+    $result .= ">$text</A>";
+    $result .= "\n" if $newline;
+    return($result);
+}
+
+sub pretty_date {
+    local(@MoY, $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);
+
+    @MoY = ('January', 'Febuary', 'March', 'April', 'May', 'June',
+	    'July', 'August', 'September', 'October', 'November', 'December');
+    ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time);
+    $year += ($year < 70) ? 2000 : 1900;
+    return("$mday $MoY[$mon] $year");
+}
+
+sub doc_name {
+    local($num) = @_;
+
+    return("${docu_name}_$num.html");
+}
+
+sub next_doc {
+    $docu_doc = &doc_name(++$doc_num);
+}
+
+sub print {
+    local(*lines, $fh) = @_;
+    local($_);
+
+    while (@lines) {
+	$_ = shift(@lines);
+	if (/^$PROTECTTAG/o) {
+	    $_ = $tag2pro{$_};
+	} else {
+	    &unprotect_texi;
+	}
+	print $fh $_;
+    }
+}
+
+sub print_ruler {
+    print FILE "<P><HR><P>\n";
+}
+
+sub print_header {
+    local($_);
+
+    # clean the title
+    $_ = &remove_style($_[0]);
+    &unprotect_texi;
+    # print the header
+    if ($doctype eq 'html2') {
+	print FILE $html2_doctype;
+    } elsif ($doctype) {
+	print FILE $doctype;
+    }
+    print FILE <<EOT;
+<HTML>
+<HEAD>
+$header
+<TITLE>$_</TITLE>
+</HEAD>
+<BODY>
+EOT
+}
+
+sub print_toplevel_header {
+    local($_);
+
+    &print_header; # pass given arg...
+    print FILE $full_title;
+    if ($value{'_subtitle'}) {
+	$value{'_subtitle'} =~ s/\n+$//;
+	foreach (split(/\n/, $value{'_subtitle'})) {
+	    $_ = &substitute_style($_);
+	    &unprotect_texi;
+	    print FILE "<H2>$_</H2>\n";
+	}
+    }
+    if ($value{'_author'}) {
+	$value{'_author'} =~ s/\n+$//;
+	foreach (split(/\n/, $value{'_author'})) {
+	    $_ = &substitute_style($_);
+	    &unprotect_texi;
+	    s/[\w.-]+\@[\w.-]+/<A HREF="mailto:$&">$&<\/A>/g;
+	    print FILE "<ADDRESS>$_</ADDRESS>\n";
+	}
+    }
+    print FILE "<P>\n";
+}
+
+sub print_footer {
+    print FILE <<EOT;
+</BODY>
+</HTML>
+EOT
+}
+
+sub print_toplevel_footer {
+    &print_ruler;
+    print FILE <<EOT;
+This document was generated on $TODAY using the
+<A HREF=\"$HOMEPAGE\">texi2html</A>
+translator version 1.51.</P>
+EOT
+    &print_footer;
+}
+
+sub protect_texi {
+    # protect @ { } ` '
+    s/\@\@/$;0/go;
+    s/\@\{/$;1/go;
+    s/\@\}/$;2/go;
+    s/\@\`/$;3/go;
+    s/\@\'/$;4/go;
+}
+
+sub protect_html {
+    local($what) = @_;
+    # protect & < >
+    $what =~ s/\&/\&\#38;/g;
+    $what =~ s/\</\&\#60;/g;
+    $what =~ s/\>/\&\#62;/g;
+    # but recognize some HTML things
+    $what =~ s/\&\#60;\/A\&\#62;/<\/A>/g;	      # </A>
+    $what =~ s/\&\#60;A ([^\&]+)\&\#62;/<A $1>/g;     # <A [^&]+>
+    $what =~ s/\&\#60;IMG ([^\&]+)\&\#62;/<IMG $1>/g; # <IMG [^&]+>
+    return($what);
+}
+
+sub unprotect_texi {
+    s/$;0/\@/go;
+    s/$;1/\{/go;
+    s/$;2/\}/go;
+    s/$;3/\`/go;
+    s/$;4/\'/go;
+}
+
+sub unprotect_html {
+    local($what) = @_;
+    $what =~ s/\&\#38;/\&/g;
+    $what =~ s/\&\#60;/\</g;
+    $what =~ s/\&\#62;/\>/g;
+    return($what);
+}
+
+sub byalpha {
+    $key2alpha{$a} cmp $key2alpha{$b};
+}
+
+##############################################################################
+
+	# These next few lines are legal in both Perl and nroff.
+
+.00 ;			# finish .ig
+ 
+'di			\" finish diversion--previous line must be blank
+.nr nl 0-1		\" fake up transition to first page again
+.nr % 0			\" start at page 1
+'; __END__ ############# From here on it's a standard manual page ############
+.TH TEXI2HTML 1 "09/10/96"
+.AT 3
+.SH NAME
+texi2html \- a Texinfo to HTML converter
+.SH SYNOPSIS
+.B texi2html [options] file
+.PP
+.B texi2html -check [-verbose] files
+.SH DESCRIPTION
+.I Texi2html
+converts the given Texinfo file to a set of HTML files. It tries to handle
+most of the Texinfo commands. It creates hypertext links for cross-references,
+footnotes...
+.PP
+It also tries to add links from a reference to its corresponding entry in the
+bibliography (if any). It may also handle a glossary (see the
+.B \-glossary
+option).
+.PP
+.I Texi2html
+creates several files depending on the contents of the Texinfo file and on
+the chosen options (see FILES).
+.PP
+The HTML files created by
+.I texi2html
+are closer to TeX than to Info, that's why
+.I texi2html
+converts @iftex sections and not @ifinfo ones by default. You can reverse
+this with the \-expandinfo option.
+.SH OPTIONS
+.TP 12
+.B \-check
+Check the given file and give the list of all things that may be Texinfo commands.
+This may be used to check the output of
+.I texi2html
+to find the Texinfo commands that have been left in the HTML file.
+.TP
+.B \-expandinfo
+Expand @ifinfo sections, not @iftex ones.
+.TP
+.B \-glossary
+Use the section named 'Glossary' to build a list of terms and put links in the HTML
+document from each term toward its definition.
+.TP
+.B \-invisible \fIname\fP
+Use \fIname\fP to create invisible destination anchors for index links. This is a workaround
+for a known bug of many WWW browsers, including xmosaic.
+.TP
+.B \-I \fIdir\fP
+Look also in \fIdir\fP to find included files.
+.TP
+.B \-menu
+Show the Texinfo menus; by default they are ignored.
+.TP
+.B \-monolithic
+Output only one file, including the table of contents and footnotes.
+.TP
+.B \-number
+Number the sections.
+.TP
+.B \-split_chapter
+Split the output into several HTML files (one per main section:
+chapter, appendix...).
+.TP
+.B \-split_node
+Split the output into several HTML files (one per node).
+.TP
+.B \-usage
+Print usage instructions, listing the current available command-line options.
+.TP
+.B \-verbose
+Give a verbose output. Can be used with the
+.B \-check
+option.
+.PP
+.SH FILES
+By default
+.I texi2html
+creates the following files (foo being the name of the Texinfo file):
+.TP 16
+.B foo_toc.html
+The table of contents.
+.TP
+.B foo.html
+The document's contents.
+.TP
+.B foo_foot.html
+The footnotes (if any).
+.PP
+When used with the
+.B \-split
+option, it creates several files (one per chapter or node), named
+.B foo_n.html
+(n being the indice of the chapter or node), instead of the single
+.B foo.html
+file.
+.PP
+When used with the
+.B \-monolithic
+option, it creates only one file:
+.B foo.html
+.SH VARIABLES
+.I texi2html
+predefines the following variables: \fBhtml\fP, \fBtexi2html\fP.
+.SH ADDITIONAL COMMANDS
+.I texi2html
+implements the following non-Texinfo commands:
+.TP 16
+.B @ifhtml
+This indicates the start of an HTML section, this section will passed through
+without any modofication.
+.TP
+.B @end ifhtml
+This indcates the end of an HTML section.
+.SH VERSION
+This is \fItexi2html\fP version 1.51, 09/10/96.
+.PP
+The latest version of \fItexi2html\fP can be found in WWW, cf. URL
+http://wwwcn.cern.ch/dci/texi2html/
+.SH AUTHOR
+The main author is Lionel Cons, CERN CN/DCI/UWS, Lionel.Cons@cern.ch.
+Many other people around the net contributed to this program.
+.SH COPYRIGHT
+This program is the intellectual property of the European
+Laboratory for Particle Physics (known as CERN). No guarantee whatsoever is
+provided by CERN. No liability whatsoever is accepted for any loss or damage
+of any kind resulting from any defect or inaccuracy in this information or
+code.
+.PP
+CERN, 1211 Geneva 23, Switzerland
+.SH "SEE ALSO"
+GNU Texinfo Documentation Format,
+HyperText Markup Language (HTML),
+World Wide Web (WWW).
+.SH BUGS
+This program does not understand all Texinfo commands (yet).
+.PP
+TeX specific commands (normally enclosed in @iftex) will be
+passed unmodified.
+.ex
diff --git a/readline/doc/texinfo.tex b/readline/doc/texinfo.tex
new file mode 100644
--- /dev/null
+++ b/readline/doc/texinfo.tex
@@ -0,0 +1,4421 @@
+%% TeX macros to handle texinfo files
+
+%   Copyright (C) 1985, 86, 88, 90, 91, 92, 93, 1994 Free Software Foundation, Inc.
+
+%This texinfo.tex file is free software; you can redistribute it and/or
+%modify it under the terms of the GNU General Public License as
+%published by the Free Software Foundation; either version 2, or (at
+%your option) any later version.
+
+%This texinfo.tex file is distributed in the hope that it will be
+%useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+%of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+%General Public License for more details.
+
+%You should have received a copy of the GNU General Public License
+%along with this texinfo.tex file; see the file COPYING.  If not, write
+%to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139,
+%USA.
+
+
+%In other words, you are welcome to use, share and improve this program.
+%You are forbidden to forbid anyone else to use, share and improve
+%what you give them.   Help stamp out software-hoarding!
+
+
+% Send bug reports to bug-texinfo@prep.ai.mit.edu.
+% Please include a *precise* test case in each bug report.
+
+
+% Make it possible to create a .fmt file just by loading this file:
+% if the underlying format is not loaded, start by loading it now.
+% Added by gildea November 1993.
+\expandafter\ifx\csname fmtname\endcsname\relax\input plain\fi
+
+% This automatically updates the version number based on RCS.
+\def\deftexinfoversion$#1: #2 ${\def\texinfoversion{#2}}
+\deftexinfoversion$Revision: 1.1 $
+\message{Loading texinfo package [Version \texinfoversion]:}
+
+% If in a .fmt file, print the version number
+% and turn on active characters that we couldn't do earlier because
+% they might have appeared in the input file name.
+\everyjob{\message{[Texinfo version \texinfoversion]}\message{}
+  \catcode`+=\active \catcode`\_=\active}
+
+% Save some parts of plain tex whose names we will redefine.
+
+\let\ptextilde=\~
+\let\ptexlbrace=\{
+\let\ptexrbrace=\}
+\let\ptexdots=\dots
+\let\ptexdot=\.
+\let\ptexstar=\*
+\let\ptexend=\end
+\let\ptexbullet=\bullet
+\let\ptexb=\b
+\let\ptexc=\c
+\let\ptexi=\i
+\let\ptext=\t
+\let\ptexl=\l
+\let\ptexL=\L
+
+% Be sure we're in horizontal mode when doing a tie, since we make space
+% equivalent to this in @example-like environments. Otherwise, a space
+% at the beginning of a line will start with \penalty -- and
+% since \penalty is valid in vertical mode, we'd end up putting the
+% penalty on the vertical list instead of in the new paragraph.
+{\catcode`@ = 11
+ \gdef\tie{\leavevmode\penalty\@M\ }
+}
+\let\~ = \tie                  % And make it available as @~.
+
+\message{Basics,}
+\chardef\other=12
+
+% If this character appears in an error message or help string, it
+% starts a new line in the output.
+\newlinechar = `^^J
+
+% Set up fixed words for English.
+\ifx\putwordChapter\undefined{\gdef\putwordChapter{Chapter}}\fi%
+\def\putwordInfo{Info}%
+\ifx\putwordSee\undefined{\gdef\putwordSee{See}}\fi%
+\ifx\putwordsee\undefined{\gdef\putwordsee{see}}\fi%
+\ifx\putwordfile\undefined{\gdef\putwordfile{file}}\fi%
+\ifx\putwordpage\undefined{\gdef\putwordpage{page}}\fi%
+\ifx\putwordsection\undefined{\gdef\putwordsection{section}}\fi%
+\ifx\putwordSection\undefined{\gdef\putwordSection{Section}}\fi%
+\ifx\putwordTableofContents\undefined{\gdef\putwordTableofContents{Table of Contents}}\fi%
+\ifx\putwordShortContents\undefined{\gdef\putwordShortContents{Short Contents}}\fi%
+\ifx\putwordAppendix\undefined{\gdef\putwordAppendix{Appendix}}\fi%
+
+% Ignore a token.
+%
+\def\gobble#1{}
+
+\hyphenation{ap-pen-dix}
+\hyphenation{mini-buf-fer mini-buf-fers}
+\hyphenation{eshell}
+
+% Margin to add to right of even pages, to left of odd pages.
+\newdimen \bindingoffset  \bindingoffset=0pt
+\newdimen \normaloffset   \normaloffset=\hoffset
+\newdimen\pagewidth \newdimen\pageheight
+\pagewidth=\hsize \pageheight=\vsize
+
+% Sometimes it is convenient to have everything in the transcript file
+% and nothing on the terminal.  We don't just call \tracingall here,
+% since that produces some useless output on the terminal.
+%
+\def\gloggingall{\begingroup \globaldefs = 1 \loggingall \endgroup}%
+\def\loggingall{\tracingcommands2 \tracingstats2
+   \tracingpages1 \tracingoutput1 \tracinglostchars1
+   \tracingmacros2 \tracingparagraphs1 \tracingrestores1
+   \showboxbreadth\maxdimen\showboxdepth\maxdimen
+}%
+
+%---------------------Begin change-----------------------
+%
+%%%% For @cropmarks command.
+% Dimensions to add cropmarks at corners Added by P. A. MacKay, 12 Nov. 1986
+%
+\newdimen\cornerlong \newdimen\cornerthick
+\newdimen \topandbottommargin
+\newdimen \outerhsize \newdimen \outervsize
+\cornerlong=1pc\cornerthick=.3pt	% These set size of cropmarks
+\outerhsize=7in
+%\outervsize=9.5in
+% Alternative @smallbook page size is 9.25in
+\outervsize=9.25in
+\topandbottommargin=.75in
+%
+%---------------------End change-----------------------
+
+% \onepageout takes a vbox as an argument.  Note that \pagecontents
+% does insertions itself, but you have to call it yourself.
+\chardef\PAGE=255  \output={\onepageout{\pagecontents\PAGE}}
+\def\onepageout#1{\hoffset=\normaloffset
+\ifodd\pageno  \advance\hoffset by \bindingoffset
+\else \advance\hoffset by -\bindingoffset\fi
+{\escapechar=`\\\relax % makes sure backslash is used in output files.
+\shipout\vbox{{\let\hsize=\pagewidth \makeheadline} \pagebody{#1}%
+{\let\hsize=\pagewidth \makefootline}}}%
+\advancepageno \ifnum\outputpenalty>-20000 \else\dosupereject\fi}
+
+%%%% For @cropmarks command %%%%
+
+% Here is a modification of the main output routine for Near East Publications
+% This provides right-angle cropmarks at all four corners.
+% The contents of the page are centerlined into the cropmarks,
+% and any desired binding offset is added as an \hskip on either
+% site of the centerlined box.  (P. A. MacKay, 12 November, 1986)
+%
+\def\croppageout#1{\hoffset=0pt % make sure this doesn't mess things up
+{\escapechar=`\\\relax % makes sure backslash is used in output files.
+		 \shipout
+		 \vbox to \outervsize{\hsize=\outerhsize
+                 \vbox{\line{\ewtop\hfill\ewtop}}
+                 \nointerlineskip
+                 \line{\vbox{\moveleft\cornerthick\nstop}
+                       \hfill
+                       \vbox{\moveright\cornerthick\nstop}}
+                 \vskip \topandbottommargin
+                 \centerline{\ifodd\pageno\hskip\bindingoffset\fi
+			\vbox{
+			{\let\hsize=\pagewidth \makeheadline}
+			\pagebody{#1}
+			{\let\hsize=\pagewidth \makefootline}}
+			\ifodd\pageno\else\hskip\bindingoffset\fi}
+		 \vskip \topandbottommargin plus1fill minus1fill
+                 \boxmaxdepth\cornerthick
+                 \line{\vbox{\moveleft\cornerthick\nsbot}
+                       \hfill
+                       \vbox{\moveright\cornerthick\nsbot}}
+                 \nointerlineskip
+                 \vbox{\line{\ewbot\hfill\ewbot}}
+	}}
+  \advancepageno
+  \ifnum\outputpenalty>-20000 \else\dosupereject\fi}
+%
+% Do @cropmarks to get crop marks
+\def\cropmarks{\let\onepageout=\croppageout }
+
+\newinsert\margin \dimen\margin=\maxdimen
+
+\def\pagebody#1{\vbox to\pageheight{\boxmaxdepth=\maxdepth #1}}
+{\catcode`\@ =11
+\gdef\pagecontents#1{\ifvoid\topins\else\unvbox\topins\fi
+% marginal hacks, juha@viisa.uucp (Juha Takala)
+\ifvoid\margin\else % marginal info is present
+  \rlap{\kern\hsize\vbox to\z@{\kern1pt\box\margin \vss}}\fi
+\dimen@=\dp#1 \unvbox#1
+\ifvoid\footins\else\vskip\skip\footins\footnoterule \unvbox\footins\fi
+\ifr@ggedbottom \kern-\dimen@ \vfil \fi}
+}
+
+%
+% Here are the rules for the cropmarks.  Note that they are
+% offset so that the space between them is truly \outerhsize or \outervsize
+% (P. A. MacKay, 12 November, 1986)
+%
+\def\ewtop{\vrule height\cornerthick depth0pt width\cornerlong}
+\def\nstop{\vbox
+  {\hrule height\cornerthick depth\cornerlong width\cornerthick}}
+\def\ewbot{\vrule height0pt depth\cornerthick width\cornerlong}
+\def\nsbot{\vbox
+  {\hrule height\cornerlong depth\cornerthick width\cornerthick}}
+
+% Parse an argument, then pass it to #1.  The argument is the rest of
+% the input line (except we remove a trailing comment).  #1 should be a
+% macro which expects an ordinary undelimited TeX argument.
+%
+\def\parsearg#1{%
+  \let\next = #1%
+  \begingroup
+    \obeylines
+    \futurelet\temp\parseargx
+}
+
+% If the next token is an obeyed space (from an @example environment or
+% the like), remove it and recurse.  Otherwise, we're done.
+\def\parseargx{%
+  % \obeyedspace is defined far below, after the definition of \sepspaces.
+  \ifx\obeyedspace\temp
+    \expandafter\parseargdiscardspace
+  \else
+    \expandafter\parseargline
+  \fi
+}
+
+% Remove a single space (as the delimiter token to the macro call).
+{\obeyspaces %
+ \gdef\parseargdiscardspace {\futurelet\temp\parseargx}}
+
+{\obeylines %
+  \gdef\parseargline#1^^M{%
+    \endgroup % End of the group started in \parsearg.
+    %
+    % First remove any @c comment, then any @comment.
+    % Result of each macro is put in \toks0.
+    \argremovec #1\c\relax %
+    \expandafter\argremovecomment \the\toks0 \comment\relax %
+    %
+    % Call the caller's macro, saved as \next in \parsearg.
+    \expandafter\next\expandafter{\the\toks0}%
+  }%
+}
+
+% Since all \c{,omment} does is throw away the argument, we can let TeX
+% do that for us.  The \relax here is matched by the \relax in the call
+% in \parseargline; it could be more or less anything, its purpose is
+% just to delimit the argument to the \c.
+\def\argremovec#1\c#2\relax{\toks0 = {#1}}
+\def\argremovecomment#1\comment#2\relax{\toks0 = {#1}}
+
+% \argremovec{,omment} might leave us with trailing spaces, though; e.g.,
+%    @end itemize  @c foo
+% will have two active spaces as part of the argument with the
+% `itemize'.  Here we remove all active spaces from #1, and assign the
+% result to \toks0.
+%
+% This loses if there are any *other* active characters besides spaces
+% in the argument -- _ ^ +, for example -- since they get expanded.
+% Fortunately, Texinfo does not define any such commands.  (If it ever
+% does, the catcode of the characters in questionwill have to be changed
+% here.)  But this means we cannot call \removeactivespaces as part of
+% \argremovec{,omment}, since @c uses \parsearg, and thus the argument
+% that \parsearg gets might well have any character at all in it.
+%
+\def\removeactivespaces#1{%
+  \begingroup
+    \ignoreactivespaces
+    \edef\temp{#1}%
+    \global\toks0 = \expandafter{\temp}%
+  \endgroup
+}
+
+% Change the active space to expand to nothing.
+%
+\begingroup
+  \obeyspaces
+  \gdef\ignoreactivespaces{\obeyspaces\let =\empty}
+\endgroup
+
+
+\def\flushcr{\ifx\par\lisppar \def\next##1{}\else \let\next=\relax \fi \next}
+
+%% These are used to keep @begin/@end levels from running away
+%% Call \inENV within environments (after a \begingroup)
+\newif\ifENV \ENVfalse \def\inENV{\ifENV\relax\else\ENVtrue\fi}
+\def\ENVcheck{%
+\ifENV\errmessage{Still within an environment.  Type Return to continue.}
+\endgroup\fi} % This is not perfect, but it should reduce lossage
+
+% @begin foo  is the same as @foo, for now.
+\newhelp\EMsimple{Type <Return> to continue.}
+
+\outer\def\begin{\parsearg\beginxxx}
+
+\def\beginxxx #1{%
+\expandafter\ifx\csname #1\endcsname\relax
+{\errhelp=\EMsimple \errmessage{Undefined command @begin #1}}\else
+\csname #1\endcsname\fi}
+
+% @end foo executes the definition of \Efoo.
+%
+\def\end{\parsearg\endxxx}
+\def\endxxx #1{%
+  \removeactivespaces{#1}%
+  \edef\endthing{\the\toks0}%
+  %
+  \expandafter\ifx\csname E\endthing\endcsname\relax
+    \expandafter\ifx\csname \endthing\endcsname\relax
+      % There's no \foo, i.e., no ``environment'' foo.
+      \errhelp = \EMsimple
+      \errmessage{Undefined command `@end \endthing'}%
+    \else
+      \unmatchedenderror\endthing
+    \fi
+  \else
+    % Everything's ok; the right environment has been started.
+    \csname E\endthing\endcsname
+  \fi
+}
+
+% There is an environment #1, but it hasn't been started.  Give an error.
+%
+\def\unmatchedenderror#1{%
+  \errhelp = \EMsimple
+  \errmessage{This `@end #1' doesn't have a matching `@#1'}%
+}
+
+% Define the control sequence \E#1 to give an unmatched @end error.
+%
+\def\defineunmatchedend#1{%
+  \expandafter\def\csname E#1\endcsname{\unmatchedenderror{#1}}%
+}
+
+
+% Single-spacing is done by various environments (specifically, in
+% \nonfillstart and \quotations).
+\newskip\singlespaceskip \singlespaceskip = 12.5pt
+\def\singlespace{%
+  % Why was this kern here?  It messes up equalizing space above and below
+  % environments.  --karl, 6may93
+  %{\advance \baselineskip by -\singlespaceskip
+  %\kern \baselineskip}%
+  \setleading \singlespaceskip
+}
+
+%% Simple single-character @ commands
+
+% @@ prints an @
+% Kludge this until the fonts are right (grr).
+\def\@{{\tt \char '100}}
+
+% This is turned off because it was never documented
+% and you can use @w{...} around a quote to suppress ligatures.
+%% Define @` and @' to be the same as ` and '
+%% but suppressing ligatures.
+%\def\`{{`}}
+%\def\'{{'}}
+
+% Used to generate quoted braces.
+
+\def\mylbrace {{\tt \char '173}}
+\def\myrbrace {{\tt \char '175}}
+\let\{=\mylbrace
+\let\}=\myrbrace
+
+% @: forces normal size whitespace following.
+\def\:{\spacefactor=1000 }
+
+% @* forces a line break.
+\def\*{\hfil\break\hbox{}\ignorespaces}
+
+% @. is an end-of-sentence period.
+\def\.{.\spacefactor=3000 }
+
+% @enddots{} is an end-of-sentence ellipsis.
+\gdef\enddots{$\mathinner{\ldotp\ldotp\ldotp\ldotp}$\spacefactor=3000}
+
+% @! is an end-of-sentence bang.
+\gdef\!{!\spacefactor=3000 }
+
+% @? is an end-of-sentence query.
+\gdef\?{?\spacefactor=3000 }
+
+% @w prevents a word break.  Without the \leavevmode, @w at the
+% beginning of a paragraph, when TeX is still in vertical mode, would
+% produce a whole line of output instead of starting the paragraph.
+\def\w#1{\leavevmode\hbox{#1}}
+
+% @group ... @end group forces ... to be all on one page, by enclosing
+% it in a TeX vbox.  We use \vtop instead of \vbox to construct the box
+% to keep its height that of a normal line.  According to the rules for
+% \topskip (p.114 of the TeXbook), the glue inserted is
+% max (\topskip - \ht (first item), 0).  If that height is large,
+% therefore, no glue is inserted, and the space between the headline and
+% the text is small, which looks bad.
+%
+\def\group{\begingroup
+  \ifnum\catcode13=\active \else
+    \errhelp = \groupinvalidhelp
+    \errmessage{@group invalid in context where filling is enabled}%
+  \fi
+  %
+  % The \vtop we start below produces a box with normal height and large
+  % depth; thus, TeX puts \baselineskip glue before it, and (when the
+  % next line of text is done) \lineskip glue after it.  (See p.82 of
+  % the TeXbook.)  Thus, space below is not quite equal to space
+  % above.  But it's pretty close.
+  \def\Egroup{%
+    \egroup           % End the \vtop.
+    \endgroup         % End the \group.
+  }%
+  %
+  \vtop\bgroup
+    % We have to put a strut on the last line in case the @group is in
+    % the midst of an example, rather than completely enclosing it.
+    % Otherwise, the interline space between the last line of the group
+    % and the first line afterwards is too small.  But we can't put the
+    % strut in \Egroup, since there it would be on a line by itself.
+    % Hence this just inserts a strut at the beginning of each line.
+    \everypar = {\strut}%
+    %
+    % Since we have a strut on every line, we don't need any of TeX's
+    % normal interline spacing.
+    \offinterlineskip
+    %
+    % OK, but now we have to do something about blank
+    % lines in the input in @example-like environments, which normally
+    % just turn into \lisppar, which will insert no space now that we've
+    % turned off the interline space.  Simplest is to make them be an
+    % empty paragraph.
+    \ifx\par\lisppar
+      \edef\par{\leavevmode \par}%
+      %
+      % Reset ^^M's definition to new definition of \par.
+      \obeylines
+    \fi
+    %
+    % Do @comment since we are called inside an environment such as
+    % @example, where each end-of-line in the input causes an
+    % end-of-line in the output.  We don't want the end-of-line after
+    % the `@group' to put extra space in the output.  Since @group
+    % should appear on a line by itself (according to the Texinfo
+    % manual), we don't worry about eating any user text.
+    \comment
+}
+%
+% TeX puts in an \escapechar (i.e., `@') at the beginning of the help
+% message, so this ends up printing `@group can only ...'.
+%
+\newhelp\groupinvalidhelp{%
+group can only be used in environments such as @example,^^J%
+where each line of input produces a line of output.}
+
+% @need space-in-mils
+% forces a page break if there is not space-in-mils remaining.
+
+\newdimen\mil  \mil=0.001in
+
+\def\need{\parsearg\needx}
+
+% Old definition--didn't work.
+%\def\needx #1{\par %
+%% This method tries to make TeX break the page naturally
+%% if the depth of the box does not fit.
+%{\baselineskip=0pt%
+%\vtop to #1\mil{\vfil}\kern -#1\mil\penalty 10000
+%\prevdepth=-1000pt
+%}}
+
+\def\needx#1{%
+  % Go into vertical mode, so we don't make a big box in the middle of a
+  % paragraph.
+  \par
+  %
+  % Don't add any leading before our big empty box, but allow a page
+  % break, since the best break might be right here.
+  \allowbreak
+  \nointerlineskip
+  \vtop to #1\mil{\vfil}%
+  %
+  % TeX does not even consider page breaks if a penalty added to the
+  % main vertical list is 10000 or more.  But in order to see if the
+  % empty box we just added fits on the page, we must make it consider
+  % page breaks.  On the other hand, we don't want to actually break the
+  % page after the empty box.  So we use a penalty of 9999.
+  %
+  % There is an extremely small chance that TeX will actually break the
+  % page at this \penalty, if there are no other feasible breakpoints in
+  % sight.  (If the user is using lots of big @group commands, which
+  % almost-but-not-quite fill up a page, TeX will have a hard time doing
+  % good page breaking, for example.)  However, I could not construct an
+  % example where a page broke at this \penalty; if it happens in a real
+  % document, then we can reconsider our strategy.
+  \penalty9999
+  %
+  % Back up by the size of the box, whether we did a page break or not.
+  \kern -#1\mil
+  %
+  % Do not allow a page break right after this kern.
+  \nobreak
+}
+
+% @br   forces paragraph break
+
+\let\br = \par
+
+% @dots{}  output some dots
+
+\def\dots{$\ldots$}
+
+% @page    forces the start of a new page
+
+\def\page{\par\vfill\supereject}
+
+% @exdent text....
+% outputs text on separate line in roman font, starting at standard page margin
+
+% This records the amount of indent in the innermost environment.
+% That's how much \exdent should take out.
+\newskip\exdentamount
+
+% This defn is used inside fill environments such as @defun.
+\def\exdent{\parsearg\exdentyyy}
+\def\exdentyyy #1{{\hfil\break\hbox{\kern -\exdentamount{\rm#1}}\hfil\break}}
+
+% This defn is used inside nofill environments such as @example.
+\def\nofillexdent{\parsearg\nofillexdentyyy}
+\def\nofillexdentyyy #1{{\advance \leftskip by -\exdentamount
+\leftline{\hskip\leftskip{\rm#1}}}}
+
+%\hbox{{\rm#1}}\hfil\break}}
+
+% @include file    insert text of that file as input.
+
+\def\include{\parsearg\includezzz}
+%Use \input\thisfile to avoid blank after \input, which may be an active
+%char (in which case the blank would become the \input argument).
+%The grouping keeps the value of \thisfile correct even when @include
+%is nested.
+\def\includezzz #1{\begingroup
+\def\thisfile{#1}\input\thisfile
+\endgroup}
+
+\def\thisfile{}
+
+% @center line   outputs that line, centered
+
+\def\center{\parsearg\centerzzz}
+\def\centerzzz #1{{\advance\hsize by -\leftskip
+\advance\hsize by -\rightskip
+\centerline{#1}}}
+
+% @sp n   outputs n lines of vertical space
+
+\def\sp{\parsearg\spxxx}
+\def\spxxx #1{\par \vskip #1\baselineskip}
+
+% @comment ...line which is ignored...
+% @c is the same as @comment
+% @ignore ... @end ignore  is another way to write a comment
+
+\def\comment{\catcode 64=\other \catcode 123=\other \catcode 125=\other%
+\parsearg \commentxxx}
+
+\def\commentxxx #1{\catcode 64=0 \catcode 123=1 \catcode 125=2 }
+
+\let\c=\comment
+
+% Prevent errors for section commands.
+% Used in @ignore and in failing conditionals.
+\def\ignoresections{%
+\let\chapter=\relax
+\let\unnumbered=\relax
+\let\top=\relax
+\let\unnumberedsec=\relax
+\let\unnumberedsection=\relax
+\let\unnumberedsubsec=\relax
+\let\unnumberedsubsection=\relax
+\let\unnumberedsubsubsec=\relax
+\let\unnumberedsubsubsection=\relax
+\let\section=\relax
+\let\subsec=\relax
+\let\subsubsec=\relax
+\let\subsection=\relax
+\let\subsubsection=\relax
+\let\appendix=\relax
+\let\appendixsec=\relax
+\let\appendixsection=\relax
+\let\appendixsubsec=\relax
+\let\appendixsubsection=\relax
+\let\appendixsubsubsec=\relax
+\let\appendixsubsubsection=\relax
+\let\contents=\relax
+\let\smallbook=\relax
+\let\titlepage=\relax
+}
+
+% Used in nested conditionals, where we have to parse the Texinfo source
+% and so want to turn off most commands, in case they are used
+% incorrectly.
+%
+\def\ignoremorecommands{%
+  \let\defcv = \relax
+  \let\deffn = \relax
+  \let\deffnx = \relax
+  \let\defindex = \relax
+  \let\defivar = \relax
+  \let\defmac = \relax
+  \let\defmethod = \relax
+  \let\defop = \relax
+  \let\defopt = \relax
+  \let\defspec = \relax
+  \let\deftp = \relax
+  \let\deftypefn = \relax
+  \let\deftypefun = \relax
+  \let\deftypevar = \relax
+  \let\deftypevr = \relax
+  \let\defun = \relax
+  \let\defvar = \relax
+  \let\defvr = \relax
+  \let\ref = \relax
+  \let\xref = \relax
+  \let\printindex = \relax
+  \let\pxref = \relax
+  \let\settitle = \relax
+  \let\include = \relax
+  \let\lowersections = \relax
+  \let\down = \relax
+  \let\raisesections = \relax
+  \let\up = \relax
+  \let\set = \relax
+  \let\clear = \relax
+  \let\item = \relax
+  \let\message = \relax
+}
+
+% Ignore @ignore ... @end ignore.
+%
+\def\ignore{\doignore{ignore}}
+
+% Also ignore @ifinfo, @ifhtml, @html, @menu, and @direntry text.
+%
+\def\ifinfo{\doignore{ifinfo}}
+\def\ifhtml{\doignore{ifhtml}}
+\def\html{\doignore{html}}
+\def\menu{\doignore{menu}}
+\def\direntry{\doignore{direntry}}
+
+% Ignore text until a line `@end #1'.
+%
+\def\doignore#1{\begingroup
+  % Don't complain about control sequences we have declared \outer.
+  \ignoresections
+  %
+  % Define a command to swallow text until we reach `@end #1'.
+  \long\def\doignoretext##1\end #1{\enddoignore}%
+  %
+  % Make sure that spaces turn into tokens that match what \doignoretext wants.
+  \catcode32 = 10
+  %
+  % And now expand that command.
+  \doignoretext
+}
+
+% What we do to finish off ignored text.
+%
+\def\enddoignore{\endgroup\ignorespaces}%
+
+\newif\ifwarnedobs\warnedobsfalse
+\def\obstexwarn{%
+  \ifwarnedobs\relax\else
+  % We need to warn folks that they may have trouble with TeX 3.0.
+  % This uses \immediate\write16 rather than \message to get newlines.
+    \immediate\write16{}
+    \immediate\write16{***WARNING*** for users of Unix TeX 3.0!}
+    \immediate\write16{This manual trips a bug in TeX version 3.0 (tex hangs).}
+    \immediate\write16{If you are running another version of TeX, relax.}
+    \immediate\write16{If you are running Unix TeX 3.0, kill this TeX process.}
+    \immediate\write16{  Then upgrade your TeX installation if you can.}
+    \immediate\write16{If you are stuck with version 3.0, run the}
+    \immediate\write16{  script ``tex3patch'' from the Texinfo distribution}
+    \immediate\write16{  to use a workaround.}
+    \immediate\write16{}
+    \warnedobstrue
+    \fi
+}
+
+% **In TeX 3.0, setting text in \nullfont hangs tex.  For a
+% workaround (which requires the file ``dummy.tfm'' to be installed),
+% uncomment the following line:
+%%%%%\font\nullfont=dummy\let\obstexwarn=\relax
+
+% Ignore text, except that we keep track of conditional commands for
+% purposes of nesting, up to an `@end #1' command.
+%
+\def\nestedignore#1{%
+  \obstexwarn
+  % We must actually expand the ignored text to look for the @end
+  % command, so that nested ignore constructs work.  Thus, we put the
+  % text into a \vbox and then do nothing with the result.  To minimize
+  % the change of memory overflow, we follow the approach outlined on
+  % page 401 of the TeXbook: make the current font be a dummy font.
+  %
+  \setbox0 = \vbox\bgroup
+    % Don't complain about control sequences we have declared \outer.
+    \ignoresections
+    %
+    % Define `@end #1' to end the box, which will in turn undefine the
+    % @end command again.
+    \expandafter\def\csname E#1\endcsname{\egroup\ignorespaces}%
+    %
+    % We are going to be parsing Texinfo commands.  Most cause no
+    % trouble when they are used incorrectly, but some commands do
+    % complicated argument parsing or otherwise get confused, so we
+    % undefine them.
+    %
+    % We can't do anything about stray @-signs, unfortunately;
+    % they'll produce `undefined control sequence' errors.
+    \ignoremorecommands
+    %
+    % Set the current font to be \nullfont, a TeX primitive, and define
+    % all the font commands to also use \nullfont.  We don't use
+    % dummy.tfm, as suggested in the TeXbook, because not all sites
+    % might have that installed.  Therefore, math mode will still
+    % produce output, but that should be an extremely small amount of
+    % stuff compared to the main input.
+    %
+    \nullfont
+    \let\tenrm = \nullfont  \let\tenit = \nullfont  \let\tensl = \nullfont
+    \let\tenbf = \nullfont  \let\tentt = \nullfont  \let\smallcaps = \nullfont
+    \let\tensf = \nullfont
+    % Similarly for index fonts (mostly for their use in
+    % smallexample)
+    \let\indrm = \nullfont  \let\indit = \nullfont  \let\indsl = \nullfont
+    \let\indbf = \nullfont  \let\indtt = \nullfont  \let\indsc = \nullfont
+    \let\indsf = \nullfont
+    %
+    % Don't complain when characters are missing from the fonts.
+    \tracinglostchars = 0
+    %
+    % Don't bother to do space factor calculations.
+    \frenchspacing
+    %
+    % Don't report underfull hboxes.
+    \hbadness = 10000
+    %
+    % Do minimal line-breaking.
+    \pretolerance = 10000
+    %
+    % Do not execute instructions in @tex
+    \def\tex{\doignore{tex}}
+}
+
+% @set VAR sets the variable VAR to an empty value.
+% @set VAR REST-OF-LINE sets VAR to the value REST-OF-LINE.
+%
+% Since we want to separate VAR from REST-OF-LINE (which might be
+% empty), we can't just use \parsearg; we have to insert a space of our
+% own to delimit the rest of the line, and then take it out again if we
+% didn't need it.
+%
+\def\set{\parsearg\setxxx}
+\def\setxxx#1{\setyyy#1 \endsetyyy}
+\def\setyyy#1 #2\endsetyyy{%
+  \def\temp{#2}%
+  \ifx\temp\empty \global\expandafter\let\csname SET#1\endcsname = \empty
+  \else \setzzz{#1}#2\endsetzzz % Remove the trailing space \setxxx inserted.
+  \fi
+}
+% Can't use \xdef to pre-expand #2 and save some time, since \temp or
+% \next or other control sequences that we've defined might get us into
+% an infinite loop. Consider `@set foo @cite{bar}'.
+\def\setzzz#1#2 \endsetzzz{\expandafter\gdef\csname SET#1\endcsname{#2}}
+
+% @clear VAR clears (i.e., unsets) the variable VAR.
+%
+\def\clear{\parsearg\clearxxx}
+\def\clearxxx#1{\global\expandafter\let\csname SET#1\endcsname=\relax}
+
+% @value{foo} gets the text saved in variable foo.
+%
+\def\value#1{\expandafter
+		\ifx\csname SET#1\endcsname\relax
+			{\{No value for ``#1''\}}
+		\else \csname SET#1\endcsname \fi}
+
+% @ifset VAR ... @end ifset reads the `...' iff VAR has been defined
+% with @set.
+%
+\def\ifset{\parsearg\ifsetxxx}
+\def\ifsetxxx #1{%
+  \expandafter\ifx\csname SET#1\endcsname\relax
+    \expandafter\ifsetfail
+  \else
+    \expandafter\ifsetsucceed
+  \fi
+}
+\def\ifsetsucceed{\conditionalsucceed{ifset}}
+\def\ifsetfail{\nestedignore{ifset}}
+\defineunmatchedend{ifset}
+
+% @ifclear VAR ... @end ifclear reads the `...' iff VAR has never been
+% defined with @set, or has been undefined with @clear.
+%
+\def\ifclear{\parsearg\ifclearxxx}
+\def\ifclearxxx #1{%
+  \expandafter\ifx\csname SET#1\endcsname\relax
+    \expandafter\ifclearsucceed
+  \else
+    \expandafter\ifclearfail
+  \fi
+}
+\def\ifclearsucceed{\conditionalsucceed{ifclear}}
+\def\ifclearfail{\nestedignore{ifclear}}
+\defineunmatchedend{ifclear}
+
+% @iftex always succeeds; we read the text following, through @end
+% iftex).  But `@end iftex' should be valid only after an @iftex.
+%
+\def\iftex{\conditionalsucceed{iftex}}
+\defineunmatchedend{iftex}
+
+% We can't just want to start a group at @iftex (for example) and end it
+% at @end iftex, since then @set commands inside the conditional have no
+% effect (they'd get reverted at the end of the group).  So we must
+% define \Eiftex to redefine itself to be its previous value.  (We can't
+% just define it to fail again with an ``unmatched end'' error, since
+% the @ifset might be nested.)
+%
+\def\conditionalsucceed#1{%
+  \edef\temp{%
+    % Remember the current value of \E#1.
+    \let\nece{prevE#1} = \nece{E#1}%
+    %
+    % At the `@end #1', redefine \E#1 to be its previous value.
+    \def\nece{E#1}{\let\nece{E#1} = \nece{prevE#1}}%
+  }%
+  \temp
+}
+
+% We need to expand lots of \csname's, but we don't want to expand the
+% control sequences after we've constructed them.
+%
+\def\nece#1{\expandafter\noexpand\csname#1\endcsname}
+
+% @asis just yields its argument.  Used with @table, for example.
+%
+\def\asis#1{#1}
+
+% @math means output in math mode.
+% We don't use $'s directly in the definition of \math because control
+% sequences like \math are expanded when the toc file is written.  Then,
+% we read the toc file back, the $'s will be normal characters (as they
+% should be, according to the definition of Texinfo).  So we must use a
+% control sequence to switch into and out of math mode.
+%
+% This isn't quite enough for @math to work properly in indices, but it
+% seems unlikely it will ever be needed there.
+%
+\let\implicitmath = $
+\def\math#1{\implicitmath #1\implicitmath}
+
+% @bullet and @minus need the same treatment as @math, just above.
+\def\bullet{\implicitmath\ptexbullet\implicitmath}
+\def\minus{\implicitmath-\implicitmath}
+
+\def\node{\ENVcheck\parsearg\nodezzz}
+\def\nodezzz#1{\nodexxx [#1,]}
+\def\nodexxx[#1,#2]{\gdef\lastnode{#1}}
+\let\nwnode=\node
+\let\lastnode=\relax
+
+\def\donoderef{\ifx\lastnode\relax\else
+\expandafter\expandafter\expandafter\setref{\lastnode}\fi
+\global\let\lastnode=\relax}
+
+\def\unnumbnoderef{\ifx\lastnode\relax\else
+\expandafter\expandafter\expandafter\unnumbsetref{\lastnode}\fi
+\global\let\lastnode=\relax}
+
+\def\appendixnoderef{\ifx\lastnode\relax\else
+\expandafter\expandafter\expandafter\appendixsetref{\lastnode}\fi
+\global\let\lastnode=\relax}
+
+\let\refill=\relax
+
+% @setfilename is done at the beginning of every texinfo file.
+% So open here the files we need to have open while reading the input.
+% This makes it possible to make a .fmt file for texinfo.
+\def\setfilename{%
+   \readauxfile
+   \opencontents
+   \openindices
+   \fixbackslash  % Turn off hack to swallow `\input texinfo'.
+   \global\let\setfilename=\comment % Ignore extra @setfilename cmds.
+   \comment % Ignore the actual filename.
+}
+
+\outer\def\bye{\pagealignmacro\tracingstats=1\ptexend}
+
+\def\inforef #1{\inforefzzz #1,,,,**}
+\def\inforefzzz #1,#2,#3,#4**{\putwordSee{} \putwordInfo{} \putwordfile{} \file{\ignorespaces #3{}},
+  node \samp{\ignorespaces#1{}}}
+
+\message{fonts,}
+
+% Font-change commands.
+
+% Texinfo supports the sans serif font style, which plain TeX does not.
+% So we set up a \sf analogous to plain's \rm, etc.
+\newfam\sffam
+\def\sf{\fam=\sffam \tensf}
+\let\li = \sf % Sometimes we call it \li, not \sf.
+
+%% Try out Computer Modern fonts at \magstephalf
+\let\mainmagstep=\magstephalf
+
+% Set the font macro #1 to the font named #2, adding on the
+% specified font prefix (normally `cm').
+\def\setfont#1#2{\font#1=\fontprefix#2}
+
+% Use cm as the default font prefix.
+% To specify the font prefix, you must define \fontprefix
+% before you read in texinfo.tex.
+\ifx\fontprefix\undefined
+\def\fontprefix{cm}
+\fi
+
+\ifx\bigger\relax
+\let\mainmagstep=\magstep1
+\setfont\textrm{r12}
+\setfont\texttt{tt12}
+\else
+\setfont\textrm{r10 scaled \mainmagstep}
+\setfont\texttt{tt10 scaled \mainmagstep}
+\fi
+% Instead of cmb10, you many want to use cmbx10.
+% cmbx10 is a prettier font on its own, but cmb10
+% looks better when embedded in a line with cmr10.
+\setfont\textbf{b10 scaled \mainmagstep}
+\setfont\textit{ti10 scaled \mainmagstep}
+\setfont\textsl{sl10 scaled \mainmagstep}
+\setfont\textsf{ss10 scaled \mainmagstep}
+\setfont\textsc{csc10 scaled \mainmagstep}
+\font\texti=cmmi10 scaled \mainmagstep
+\font\textsy=cmsy10 scaled \mainmagstep
+
+% A few fonts for @defun, etc.
+\setfont\defbf{bx10 scaled \magstep1} %was 1314
+\setfont\deftt{tt10 scaled \magstep1}
+\def\df{\let\tentt=\deftt \let\tenbf = \defbf \bf}
+
+% Fonts for indices and small examples.
+% We actually use the slanted font rather than the italic,
+% because texinfo normally uses the slanted fonts for that.
+% Do not make many font distinctions in general in the index, since they
+% aren't very useful.
+\setfont\ninett{tt9}
+\setfont\indrm{r9}
+\setfont\indit{sl9}
+\let\indsl=\indit
+\let\indtt=\ninett
+\let\indsf=\indrm
+\let\indbf=\indrm
+\setfont\indsc{csc10 at 9pt}
+\font\indi=cmmi9
+\font\indsy=cmsy9
+
+% Fonts for headings
+\setfont\chaprm{bx12 scaled \magstep2}
+\setfont\chapit{ti12 scaled \magstep2}
+\setfont\chapsl{sl12 scaled \magstep2}
+\setfont\chaptt{tt12 scaled \magstep2}
+\setfont\chapsf{ss12 scaled \magstep2}
+\let\chapbf=\chaprm
+\setfont\chapsc{csc10 scaled\magstep3}
+\font\chapi=cmmi12 scaled \magstep2
+\font\chapsy=cmsy10 scaled \magstep3
+
+\setfont\secrm{bx12 scaled \magstep1}
+\setfont\secit{ti12 scaled \magstep1}
+\setfont\secsl{sl12 scaled \magstep1}
+\setfont\sectt{tt12 scaled \magstep1}
+\setfont\secsf{ss12 scaled \magstep1}
+\setfont\secbf{bx12 scaled \magstep1}
+\setfont\secsc{csc10 scaled\magstep2}
+\font\seci=cmmi12 scaled \magstep1
+\font\secsy=cmsy10 scaled \magstep2
+
+% \setfont\ssecrm{bx10 scaled \magstep1}    % This size an font looked bad.
+% \setfont\ssecit{cmti10 scaled \magstep1}    % The letters were too crowded.
+% \setfont\ssecsl{sl10 scaled \magstep1}
+% \setfont\ssectt{tt10 scaled \magstep1}
+% \setfont\ssecsf{ss10 scaled \magstep1}
+
+%\setfont\ssecrm{b10 scaled 1315}	% Note the use of cmb rather than cmbx.
+%\setfont\ssecit{ti10 scaled 1315}	% Also, the size is a little larger than
+%\setfont\ssecsl{sl10 scaled 1315}	% being scaled magstep1.
+%\setfont\ssectt{tt10 scaled 1315}
+%\setfont\ssecsf{ss10 scaled 1315}
+
+%\let\ssecbf=\ssecrm
+
+\setfont\ssecrm{bx12 scaled \magstephalf}
+\setfont\ssecit{ti12 scaled \magstephalf}
+\setfont\ssecsl{sl12 scaled \magstephalf}
+\setfont\ssectt{tt12 scaled \magstephalf}
+\setfont\ssecsf{ss12 scaled \magstephalf}
+\setfont\ssecbf{bx12 scaled \magstephalf}
+\setfont\ssecsc{csc10 scaled \magstep1}
+\font\sseci=cmmi12 scaled \magstephalf
+\font\ssecsy=cmsy10 scaled \magstep1
+% The smallcaps and symbol fonts should actually be scaled \magstep1.5,
+% but that is not a standard magnification.
+
+% Fonts for title page:
+\setfont\titlerm{bx12 scaled \magstep3}
+\let\authorrm = \secrm
+
+% In order for the font changes to affect most math symbols and letters,
+% we have to define the \textfont of the standard families.  Since
+% texinfo doesn't allow for producing subscripts and superscripts, we
+% don't bother to reset \scriptfont and \scriptscriptfont (which would
+% also require loading a lot more fonts).
+%
+\def\resetmathfonts{%
+  \textfont0 = \tenrm \textfont1 = \teni \textfont2 = \tensy
+  \textfont\itfam = \tenit \textfont\slfam = \tensl \textfont\bffam = \tenbf
+  \textfont\ttfam = \tentt \textfont\sffam = \tensf
+}
+
+
+% The font-changing commands redefine the meanings of \tenSTYLE, instead
+% of just \STYLE.  We do this so that font changes will continue to work
+% in math mode, where it is the current \fam that is relevant in most
+% cases, not the current.  Plain TeX does, for example,
+% \def\bf{\fam=\bffam \tenbf}  By redefining \tenbf, we obviate the need
+% to redefine \bf itself.
+\def\textfonts{%
+  \let\tenrm=\textrm \let\tenit=\textit \let\tensl=\textsl
+  \let\tenbf=\textbf \let\tentt=\texttt \let\smallcaps=\textsc
+  \let\tensf=\textsf \let\teni=\texti \let\tensy=\textsy
+  \resetmathfonts}
+\def\chapfonts{%
+  \let\tenrm=\chaprm \let\tenit=\chapit \let\tensl=\chapsl
+  \let\tenbf=\chapbf \let\tentt=\chaptt \let\smallcaps=\chapsc
+  \let\tensf=\chapsf \let\teni=\chapi \let\tensy=\chapsy
+  \resetmathfonts}
+\def\secfonts{%
+  \let\tenrm=\secrm \let\tenit=\secit \let\tensl=\secsl
+  \let\tenbf=\secbf \let\tentt=\sectt \let\smallcaps=\secsc
+  \let\tensf=\secsf \let\teni=\seci \let\tensy=\secsy
+  \resetmathfonts}
+\def\subsecfonts{%
+  \let\tenrm=\ssecrm \let\tenit=\ssecit \let\tensl=\ssecsl
+  \let\tenbf=\ssecbf \let\tentt=\ssectt \let\smallcaps=\ssecsc
+  \let\tensf=\ssecsf \let\teni=\sseci \let\tensy=\ssecsy
+  \resetmathfonts}
+\def\indexfonts{%
+  \let\tenrm=\indrm \let\tenit=\indit \let\tensl=\indsl
+  \let\tenbf=\indbf \let\tentt=\indtt \let\smallcaps=\indsc
+  \let\tensf=\indsf \let\teni=\indi \let\tensy=\indsy
+  \resetmathfonts}
+
+% Set up the default fonts, so we can use them for creating boxes.
+%
+\textfonts
+
+% Count depth in font-changes, for error checks
+\newcount\fontdepth \fontdepth=0
+
+% Fonts for short table of contents.
+\setfont\shortcontrm{r12}
+\setfont\shortcontbf{bx12}
+\setfont\shortcontsl{sl12}
+
+%% Add scribe-like font environments, plus @l for inline lisp (usually sans
+%% serif) and @ii for TeX italic
+
+% \smartitalic{ARG} outputs arg in italics, followed by an italic correction
+% unless the following character is such as not to need one.
+\def\smartitalicx{\ifx\next,\else\ifx\next-\else\ifx\next.\else\/\fi\fi\fi}
+\def\smartitalic#1{{\sl #1}\futurelet\next\smartitalicx}
+
+\let\i=\smartitalic
+\let\var=\smartitalic
+\let\dfn=\smartitalic
+\let\emph=\smartitalic
+\let\cite=\smartitalic
+
+\def\b#1{{\bf #1}}
+\let\strong=\b
+
+% We can't just use \exhyphenpenalty, because that only has effect at
+% the end of a paragraph.  Restore normal hyphenation at the end of the
+% group within which \nohyphenation is presumably called.
+%
+\def\nohyphenation{\hyphenchar\font = -1  \aftergroup\restorehyphenation}
+\def\restorehyphenation{\hyphenchar\font = `- }
+
+\def\t#1{%
+  {\tt \nohyphenation \rawbackslash \frenchspacing #1}%
+  \null
+}
+\let\ttfont = \t
+%\def\samp #1{`{\tt \rawbackslash \frenchspacing #1}'\null}
+\def\samp #1{`\tclose{#1}'\null}
+\def\key #1{{\tt \nohyphenation \uppercase{#1}}\null}
+\def\ctrl #1{{\tt \rawbackslash \hat}#1}
+
+\let\file=\samp
+
+% @code is a modification of @t,
+% which makes spaces the same size as normal in the surrounding text.
+\def\tclose#1{%
+  {%
+    % Change normal interword space to be same as for the current font.
+    \spaceskip = \fontdimen2\font
+    %
+    % Switch to typewriter.
+    \tt
+    %
+    % But `\ ' produces the large typewriter interword space.
+    \def\ {{\spaceskip = 0pt{} }}%
+    %
+    % Turn off hyphenation.
+    \nohyphenation
+    %
+    \rawbackslash
+    \frenchspacing
+    #1%
+  }%
+  \null
+}
+
+% We *must* turn on hyphenation at `-' and `_' in \code.
+% Otherwise, it is too hard to avoid overful hboxes
+% in the Emacs manual, the Library manual, etc.
+
+% Unfortunately, TeX uses one parameter (\hyphenchar) to control
+% both hyphenation at - and hyphenation within words.
+% We must therefore turn them both off (\tclose does that)
+% and arrange explicitly to hyphenate an a dash.
+%  -- rms.
+{
+\catcode`\-=\active
+\catcode`\_=\active
+\global\def\code{\begingroup \catcode`\-=\active \let-\codedash \catcode`\_=\active \let_\codeunder \codex}
+% The following is used by \doprintindex to insure that long function names
+% wrap around.  It is necessary for - and _ to be active before the index is
+% read from the file, as \entry parses the arguments long before \code is
+% ever called.  -- mycroft
+\global\def\indexbreaks{\catcode`\-=\active \let-\realdash \catcode`\_=\active \let_\realunder}
+}
+\def\realdash{-}
+\def\realunder{_}
+\def\codedash{-\discretionary{}{}{}}
+\def\codeunder{\normalunderscore\discretionary{}{}{}}
+\def\codex #1{\tclose{#1}\endgroup}
+
+%\let\exp=\tclose  %Was temporary
+
+% @kbd is like @code, except that if the argument is just one @key command,
+% then @kbd has no effect.
+
+\def\xkey{\key}
+\def\kbdfoo#1#2#3\par{\def\one{#1}\def\three{#3}\def\threex{??}%
+\ifx\one\xkey\ifx\threex\three \key{#2}%
+\else\tclose{\look}\fi
+\else\tclose{\look}\fi}
+
+% Typeset a dimension, e.g., `in' or `pt'.  The only reason for the
+% argument is to make the input look right: @dmn{pt} instead of
+% @dmn{}pt.
+%
+\def\dmn#1{\thinspace #1}
+
+\def\kbd#1{\def\look{#1}\expandafter\kbdfoo\look??\par}
+
+\def\l#1{{\li #1}\null}		%
+
+\def\r#1{{\rm #1}}		% roman font
+% Use of \lowercase was suggested.
+\def\sc#1{{\smallcaps#1}}	% smallcaps font
+\def\ii#1{{\it #1}}		% italic font
+
+\message{page headings,}
+
+\newskip\titlepagetopglue \titlepagetopglue = 1.5in
+\newskip\titlepagebottomglue \titlepagebottomglue = 2pc
+
+% First the title page.  Must do @settitle before @titlepage.
+\def\titlefont#1{{\titlerm #1}}
+
+\newif\ifseenauthor
+\newif\iffinishedtitlepage
+
+\def\shorttitlepage{\parsearg\shorttitlepagezzz}
+\def\shorttitlepagezzz #1{\begingroup\hbox{}\vskip 1.5in \chaprm \centerline{#1}%
+	\endgroup\page\hbox{}\page}
+
+\def\titlepage{\begingroup \parindent=0pt \textfonts
+   \let\subtitlerm=\tenrm
+% I deinstalled the following change because \cmr12 is undefined.
+% This change was not in the ChangeLog anyway.  --rms.
+%   \let\subtitlerm=\cmr12
+   \def\subtitlefont{\subtitlerm \normalbaselineskip = 13pt \normalbaselines}%
+   %
+   \def\authorfont{\authorrm \normalbaselineskip = 16pt \normalbaselines}%
+   %
+   % Leave some space at the very top of the page.
+   \vglue\titlepagetopglue
+   %
+   % Now you can print the title using @title.
+   \def\title{\parsearg\titlezzz}%
+   \def\titlezzz##1{\leftline{\titlefont{##1}}
+		    % print a rule at the page bottom also.
+		    \finishedtitlepagefalse
+		    \vskip4pt \hrule height 4pt width \hsize \vskip4pt}%
+   % No rule at page bottom unless we print one at the top with @title.
+   \finishedtitlepagetrue
+   %
+   % Now you can put text using @subtitle.
+   \def\subtitle{\parsearg\subtitlezzz}%
+   \def\subtitlezzz##1{{\subtitlefont \rightline{##1}}}%
+   %
+   % @author should come last, but may come many times.
+   \def\author{\parsearg\authorzzz}%
+   \def\authorzzz##1{\ifseenauthor\else\vskip 0pt plus 1filll\seenauthortrue\fi
+      {\authorfont \leftline{##1}}}%
+   %
+   % Most title ``pages'' are actually two pages long, with space
+   % at the top of the second.  We don't want the ragged left on the second.
+   \let\oldpage = \page
+   \def\page{%
+      \iffinishedtitlepage\else
+	 \finishtitlepage
+      \fi
+      \oldpage
+      \let\page = \oldpage
+      \hbox{}}%
+%   \def\page{\oldpage \hbox{}}
+}
+
+\def\Etitlepage{%
+   \iffinishedtitlepage\else
+      \finishtitlepage
+   \fi
+   % It is important to do the page break before ending the group,
+   % because the headline and footline are only empty inside the group.
+   % If we use the new definition of \page, we always get a blank page
+   % after the title page, which we certainly don't want.
+   \oldpage
+   \endgroup
+   \HEADINGSon
+}
+
+\def\finishtitlepage{%
+   \vskip4pt \hrule height 2pt width \hsize
+   \vskip\titlepagebottomglue
+   \finishedtitlepagetrue
+}
+
+%%% Set up page headings and footings.
+
+\let\thispage=\folio
+
+\newtoks \evenheadline    % Token sequence for heading line of even pages
+\newtoks \oddheadline     % Token sequence for heading line of odd pages
+\newtoks \evenfootline    % Token sequence for footing line of even pages
+\newtoks \oddfootline     % Token sequence for footing line of odd pages
+
+% Now make Tex use those variables
+\headline={{\textfonts\rm \ifodd\pageno \the\oddheadline
+                            \else \the\evenheadline \fi}}
+\footline={{\textfonts\rm \ifodd\pageno \the\oddfootline
+                            \else \the\evenfootline \fi}\HEADINGShook}
+\let\HEADINGShook=\relax
+
+% Commands to set those variables.
+% For example, this is what  @headings on  does
+% @evenheading @thistitle|@thispage|@thischapter
+% @oddheading @thischapter|@thispage|@thistitle
+% @evenfooting @thisfile||
+% @oddfooting ||@thisfile
+
+\def\evenheading{\parsearg\evenheadingxxx}
+\def\oddheading{\parsearg\oddheadingxxx}
+\def\everyheading{\parsearg\everyheadingxxx}
+
+\def\evenfooting{\parsearg\evenfootingxxx}
+\def\oddfooting{\parsearg\oddfootingxxx}
+\def\everyfooting{\parsearg\everyfootingxxx}
+
+{\catcode`\@=0 %
+
+\gdef\evenheadingxxx #1{\evenheadingyyy #1@|@|@|@|\finish}
+\gdef\evenheadingyyy #1@|#2@|#3@|#4\finish{%
+\global\evenheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
+
+\gdef\oddheadingxxx #1{\oddheadingyyy #1@|@|@|@|\finish}
+\gdef\oddheadingyyy #1@|#2@|#3@|#4\finish{%
+\global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
+
+\gdef\everyheadingxxx #1{\everyheadingyyy #1@|@|@|@|\finish}
+\gdef\everyheadingyyy #1@|#2@|#3@|#4\finish{%
+\global\evenheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}
+\global\oddheadline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
+
+\gdef\evenfootingxxx #1{\evenfootingyyy #1@|@|@|@|\finish}
+\gdef\evenfootingyyy #1@|#2@|#3@|#4\finish{%
+\global\evenfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
+
+\gdef\oddfootingxxx #1{\oddfootingyyy #1@|@|@|@|\finish}
+\gdef\oddfootingyyy #1@|#2@|#3@|#4\finish{%
+\global\oddfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
+
+\gdef\everyfootingxxx #1{\everyfootingyyy #1@|@|@|@|\finish}
+\gdef\everyfootingyyy #1@|#2@|#3@|#4\finish{%
+\global\evenfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}
+\global\oddfootline={\rlap{\centerline{#2}}\line{#1\hfil#3}}}
+%
+}% unbind the catcode of @.
+
+% @headings double	turns headings on for double-sided printing.
+% @headings single	turns headings on for single-sided printing.
+% @headings off		turns them off.
+% @headings on		same as @headings double, retained for compatibility.
+% @headings after	turns on double-sided headings after this page.
+% @headings doubleafter	turns on double-sided headings after this page.
+% @headings singleafter turns on single-sided headings after this page.
+% By default, they are off.
+
+\def\headings #1 {\csname HEADINGS#1\endcsname}
+
+\def\HEADINGSoff{
+\global\evenheadline={\hfil} \global\evenfootline={\hfil}
+\global\oddheadline={\hfil} \global\oddfootline={\hfil}}
+\HEADINGSoff
+% When we turn headings on, set the page number to 1.
+% For double-sided printing, put current file name in lower left corner,
+% chapter name on inside top of right hand pages, document
+% title on inside top of left hand pages, and page numbers on outside top
+% edge of all pages.
+\def\HEADINGSdouble{
+%\pagealignmacro
+\global\pageno=1
+\global\evenfootline={\hfil}
+\global\oddfootline={\hfil}
+\global\evenheadline={\line{\folio\hfil\thistitle}}
+\global\oddheadline={\line{\thischapter\hfil\folio}}
+}
+% For single-sided printing, chapter title goes across top left of page,
+% page number on top right.
+\def\HEADINGSsingle{
+%\pagealignmacro
+\global\pageno=1
+\global\evenfootline={\hfil}
+\global\oddfootline={\hfil}
+\global\evenheadline={\line{\thischapter\hfil\folio}}
+\global\oddheadline={\line{\thischapter\hfil\folio}}
+}
+\def\HEADINGSon{\HEADINGSdouble}
+
+\def\HEADINGSafter{\let\HEADINGShook=\HEADINGSdoublex}
+\let\HEADINGSdoubleafter=\HEADINGSafter
+\def\HEADINGSdoublex{%
+\global\evenfootline={\hfil}
+\global\oddfootline={\hfil}
+\global\evenheadline={\line{\folio\hfil\thistitle}}
+\global\oddheadline={\line{\thischapter\hfil\folio}}
+}
+
+\def\HEADINGSsingleafter{\let\HEADINGShook=\HEADINGSsinglex}
+\def\HEADINGSsinglex{%
+\global\evenfootline={\hfil}
+\global\oddfootline={\hfil}
+\global\evenheadline={\line{\thischapter\hfil\folio}}
+\global\oddheadline={\line{\thischapter\hfil\folio}}
+}
+
+% Subroutines used in generating headings
+% Produces Day Month Year style of output.
+\def\today{\number\day\space
+\ifcase\month\or
+January\or February\or March\or April\or May\or June\or
+July\or August\or September\or October\or November\or December\fi
+\space\number\year}
+
+% Use this if you want the Month Day, Year style of output.
+%\def\today{\ifcase\month\or
+%January\or February\or March\or April\or May\or June\or
+%July\or August\or September\or October\or November\or December\fi
+%\space\number\day, \number\year}
+
+% @settitle line...  specifies the title of the document, for headings
+% It generates no output of its own
+
+\def\thistitle{No Title}
+\def\settitle{\parsearg\settitlezzz}
+\def\settitlezzz #1{\gdef\thistitle{#1}}
+
+\message{tables,}
+
+% @tabs -- simple alignment
+
+% These don't work.  For one thing, \+ is defined as outer.
+% So these macros cannot even be defined.
+
+%\def\tabs{\parsearg\tabszzz}
+%\def\tabszzz #1{\settabs\+#1\cr}
+%\def\tabline{\parsearg\tablinezzz}
+%\def\tablinezzz #1{\+#1\cr}
+%\def\&{&}
+
+% Tables -- @table, @ftable, @vtable, @item(x), @kitem(x), @xitem(x).
+
+% default indentation of table text
+\newdimen\tableindent \tableindent=.8in
+% default indentation of @itemize and @enumerate text
+\newdimen\itemindent  \itemindent=.3in
+% margin between end of table item and start of table text.
+\newdimen\itemmargin  \itemmargin=.1in
+
+% used internally for \itemindent minus \itemmargin
+\newdimen\itemmax
+
+% Note @table, @vtable, and @vtable define @item, @itemx, etc., with
+% these defs.
+% They also define \itemindex
+% to index the item name in whatever manner is desired (perhaps none).
+
+\newif\ifitemxneedsnegativevskip
+
+\def\itemxpar{\par\ifitemxneedsnegativevskip\vskip-\parskip\nobreak\fi}
+
+\def\internalBitem{\smallbreak \parsearg\itemzzz}
+\def\internalBitemx{\itemxpar \parsearg\itemzzz}
+
+\def\internalBxitem "#1"{\def\xitemsubtopix{#1} \smallbreak \parsearg\xitemzzz}
+\def\internalBxitemx "#1"{\def\xitemsubtopix{#1} \itemxpar \parsearg\xitemzzz}
+
+\def\internalBkitem{\smallbreak \parsearg\kitemzzz}
+\def\internalBkitemx{\itemxpar \parsearg\kitemzzz}
+
+\def\kitemzzz #1{\dosubind {kw}{\code{#1}}{for {\bf \lastfunction}}%
+                 \itemzzz {#1}}
+
+\def\xitemzzz #1{\dosubind {kw}{\code{#1}}{for {\bf \xitemsubtopic}}%
+                 \itemzzz {#1}}
+
+\def\itemzzz #1{\begingroup %
+  \advance\hsize by -\rightskip
+  \advance\hsize by -\tableindent
+  \setbox0=\hbox{\itemfont{#1}}%
+  \itemindex{#1}%
+  \nobreak % This prevents a break before @itemx.
+  %
+  % Be sure we are not still in the middle of a paragraph.
+  %{\parskip = 0in
+  %\par
+  %}%
+  %
+  % If the item text does not fit in the space we have, put it on a line
+  % by itself, and do not allow a page break either before or after that
+  % line.  We do not start a paragraph here because then if the next
+  % command is, e.g., @kindex, the whatsit would get put into the
+  % horizontal list on a line by itself, resulting in extra blank space.
+  \ifdim \wd0>\itemmax
+    %
+    % Make this a paragraph so we get the \parskip glue and wrapping,
+    % but leave it ragged-right.
+    \begingroup
+      \advance\leftskip by-\tableindent
+      \advance\hsize by\tableindent
+      \advance\rightskip by0pt plus1fil
+      \leavevmode\unhbox0\par
+    \endgroup
+    %
+    % We're going to be starting a paragraph, but we don't want the
+    % \parskip glue -- logically it's part of the @item we just started.
+    \nobreak \vskip-\parskip
+    %
+    % Stop a page break at the \parskip glue coming up.  Unfortunately
+    % we can't prevent a possible page break at the following
+    % \baselineskip glue.
+    \nobreak
+    \endgroup
+    \itemxneedsnegativevskipfalse
+  \else
+    % The item text fits into the space.  Start a paragraph, so that the
+    % following text (if any) will end up on the same line.  Since that
+    % text will be indented by \tableindent, we make the item text be in
+    % a zero-width box.
+    \noindent
+    \rlap{\hskip -\tableindent\box0}\ignorespaces%
+    \endgroup%
+    \itemxneedsnegativevskiptrue%
+  \fi
+}
+
+\def\item{\errmessage{@item while not in a table}}
+\def\itemx{\errmessage{@itemx while not in a table}}
+\def\kitem{\errmessage{@kitem while not in a table}}
+\def\kitemx{\errmessage{@kitemx while not in a table}}
+\def\xitem{\errmessage{@xitem while not in a table}}
+\def\xitemx{\errmessage{@xitemx while not in a table}}
+
+%% Contains a kludge to get @end[description] to work
+\def\description{\tablez{\dontindex}{1}{}{}{}{}}
+
+\def\table{\begingroup\inENV\obeylines\obeyspaces\tablex}
+{\obeylines\obeyspaces%
+\gdef\tablex #1^^M{%
+\tabley\dontindex#1        \endtabley}}
+
+\def\ftable{\begingroup\inENV\obeylines\obeyspaces\ftablex}
+{\obeylines\obeyspaces%
+\gdef\ftablex #1^^M{%
+\tabley\fnitemindex#1        \endtabley
+\def\Eftable{\endgraf\afterenvbreak\endgroup}%
+\let\Etable=\relax}}
+
+\def\vtable{\begingroup\inENV\obeylines\obeyspaces\vtablex}
+{\obeylines\obeyspaces%
+\gdef\vtablex #1^^M{%
+\tabley\vritemindex#1        \endtabley
+\def\Evtable{\endgraf\afterenvbreak\endgroup}%
+\let\Etable=\relax}}
+
+\def\dontindex #1{}
+\def\fnitemindex #1{\doind {fn}{\code{#1}}}%
+\def\vritemindex #1{\doind {vr}{\code{#1}}}%
+
+{\obeyspaces %
+\gdef\tabley#1#2 #3 #4 #5 #6 #7\endtabley{\endgroup%
+\tablez{#1}{#2}{#3}{#4}{#5}{#6}}}
+
+\def\tablez #1#2#3#4#5#6{%
+\aboveenvbreak %
+\begingroup %
+\def\Edescription{\Etable}% Neccessary kludge.
+\let\itemindex=#1%
+\ifnum 0#3>0 \advance \leftskip by #3\mil \fi %
+\ifnum 0#4>0 \tableindent=#4\mil \fi %
+\ifnum 0#5>0 \advance \rightskip by #5\mil \fi %
+\def\itemfont{#2}%
+\itemmax=\tableindent %
+\advance \itemmax by -\itemmargin %
+\advance \leftskip by \tableindent %
+\exdentamount=\tableindent
+\parindent = 0pt
+\parskip = \smallskipamount
+\ifdim \parskip=0pt \parskip=2pt \fi%
+\def\Etable{\endgraf\afterenvbreak\endgroup}%
+\let\item = \internalBitem %
+\let\itemx = \internalBitemx %
+\let\kitem = \internalBkitem %
+\let\kitemx = \internalBkitemx %
+\let\xitem = \internalBxitem %
+\let\xitemx = \internalBxitemx %
+}
+
+% This is the counter used by @enumerate, which is really @itemize
+
+\newcount \itemno
+
+\def\itemize{\parsearg\itemizezzz}
+
+\def\itemizezzz #1{%
+  \begingroup % ended by the @end itemsize
+  \itemizey {#1}{\Eitemize}
+}
+
+\def\itemizey #1#2{%
+\aboveenvbreak %
+\itemmax=\itemindent %
+\advance \itemmax by -\itemmargin %
+\advance \leftskip by \itemindent %
+\exdentamount=\itemindent
+\parindent = 0pt %
+\parskip = \smallskipamount %
+\ifdim \parskip=0pt \parskip=2pt \fi%
+\def#2{\endgraf\afterenvbreak\endgroup}%
+\def\itemcontents{#1}%
+\let\item=\itemizeitem}
+
+% Set sfcode to normal for the chars that usually have another value.
+% These are `.?!:;,'
+\def\frenchspacing{\sfcode46=1000 \sfcode63=1000 \sfcode33=1000
+  \sfcode58=1000 \sfcode59=1000 \sfcode44=1000 }
+
+% \splitoff TOKENS\endmark defines \first to be the first token in
+% TOKENS, and \rest to be the remainder.
+%
+\def\splitoff#1#2\endmark{\def\first{#1}\def\rest{#2}}%
+
+% Allow an optional argument of an uppercase letter, lowercase letter,
+% or number, to specify the first label in the enumerated list.  No
+% argument is the same as `1'.
+%
+\def\enumerate{\parsearg\enumeratezzz}
+\def\enumeratezzz #1{\enumeratey #1  \endenumeratey}
+\def\enumeratey #1 #2\endenumeratey{%
+  \begingroup % ended by the @end enumerate
+  %
+  % If we were given no argument, pretend we were given `1'.
+  \def\thearg{#1}%
+  \ifx\thearg\empty \def\thearg{1}\fi
+  %
+  % Detect if the argument is a single token.  If so, it might be a
+  % letter.  Otherwise, the only valid thing it can be is a number.
+  % (We will always have one token, because of the test we just made.
+  % This is a good thing, since \splitoff doesn't work given nothing at
+  % all -- the first parameter is undelimited.)
+  \expandafter\splitoff\thearg\endmark
+  \ifx\rest\empty
+    % Only one token in the argument.  It could still be anything.
+    % A ``lowercase letter'' is one whose \lccode is nonzero.
+    % An ``uppercase letter'' is one whose \lccode is both nonzero, and
+    %   not equal to itself.
+    % Otherwise, we assume it's a number.
+    %
+    % We need the \relax at the end of the \ifnum lines to stop TeX from
+    % continuing to look for a <number>.
+    %
+    \ifnum\lccode\expandafter`\thearg=0\relax
+      \numericenumerate % a number (we hope)
+    \else
+      % It's a letter.
+      \ifnum\lccode\expandafter`\thearg=\expandafter`\thearg\relax
+        \lowercaseenumerate % lowercase letter
+      \else
+        \uppercaseenumerate % uppercase letter
+      \fi
+    \fi
+  \else
+    % Multiple tokens in the argument.  We hope it's a number.
+    \numericenumerate
+  \fi
+}
+
+% An @enumerate whose labels are integers.  The starting integer is
+% given in \thearg.
+%
+\def\numericenumerate{%
+  \itemno = \thearg
+  \startenumeration{\the\itemno}%
+}
+
+% The starting (lowercase) letter is in \thearg.
+\def\lowercaseenumerate{%
+  \itemno = \expandafter`\thearg
+  \startenumeration{%
+    % Be sure we're not beyond the end of the alphabet.
+    \ifnum\itemno=0
+      \errmessage{No more lowercase letters in @enumerate; get a bigger
+                  alphabet}%
+    \fi
+    \char\lccode\itemno
+  }%
+}
+
+% The starting (uppercase) letter is in \thearg.
+\def\uppercaseenumerate{%
+  \itemno = \expandafter`\thearg
+  \startenumeration{%
+    % Be sure we're not beyond the end of the alphabet.
+    \ifnum\itemno=0
+      \errmessage{No more uppercase letters in @enumerate; get a bigger
+                  alphabet}
+    \fi
+    \char\uccode\itemno
+  }%
+}
+
+% Call itemizey, adding a period to the first argument and supplying the
+% common last two arguments.  Also subtract one from the initial value in
+% \itemno, since @item increments \itemno.
+%
+\def\startenumeration#1{%
+  \advance\itemno by -1
+  \itemizey{#1.}\Eenumerate\flushcr
+}
+
+% @alphaenumerate and @capsenumerate are abbreviations for giving an arg
+% to @enumerate.
+%
+\def\alphaenumerate{\enumerate{a}}
+\def\capsenumerate{\enumerate{A}}
+\def\Ealphaenumerate{\Eenumerate}
+\def\Ecapsenumerate{\Eenumerate}
+
+% Definition of @item while inside @itemize.
+
+\def\itemizeitem{%
+\advance\itemno by 1
+{\let\par=\endgraf \smallbreak}%
+\ifhmode \errmessage{\in hmode at itemizeitem}\fi
+{\parskip=0in \hskip 0pt
+\hbox to 0pt{\hss \itemcontents\hskip \itemmargin}%
+\vadjust{\penalty 1200}}%
+\flushcr}
+
+% @multitable macros
+% Amy Hendrickson, 8/18/94
+%
+% @multitable ... @endmultitable will make as many columns as desired.
+% Contents of each column will wrap at width given in preamble. Width
+% can be specified either with sample text given in a template line,
+% or in percent of \hsize, the current width of text on page.
+
+% Table can continue over pages but will only break between lines.
+
+% To make preamble:
+%
+% Either define widths of columns in terms of percent of \hsize: 
+%   @multitable @percentofhsize .2 .3 .5
+%   @item ...
+%
+%   Numbers following @percentofhsize are the percent of the total
+%   current hsize to be used for each column. You may use as many
+%   columns as desired.
+
+% Or use a template:
+%   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
+%   @item ...
+%   using the widest term desired in each column.
+
+
+% Each new table line starts with @item, each subsequent new column 
+% starts with @tab. Empty columns may be produced by supplying @tab's
+% with nothing between them for as many times as empty columns are needed,
+% ie, @tab@tab@tab will produce two empty columns.
+
+% @item, @tab, @multicolumn or @endmulticolumn do not need to be on their
+% own lines, but it will not hurt if they are.
+
+% Sample multitable:
+
+%   @multitable {Column 1 template} {Column 2 template} {Column 3 template}
+%   @item first col stuff @tab second col stuff @tab third col
+%   @item 
+%   first col stuff 
+%   @tab 
+%   second col stuff 
+%   @tab 
+%   third col 
+%   @item first col stuff @tab second col stuff 
+%   @tab Many paragraphs of text may be used in any column.
+%     
+%         They will wrap at the width determined by the template.
+%   @item@tab@tab This will be in third column.
+%   @endmultitable
+
+% Default dimensions may be reset by user.
+% @intableparskip will set vertical space between paragraphs in table.
+% @intableparindent will set paragraph indent in table.
+% @spacebetweencols will set horizontal space to be left between columns.
+% @spacebetweenlines will set vertical space to be left between lines.
+
+%%%%
+% Dimensions 
+
+\newdimen\intableparskip
+\newdimen\intableparindent
+\newdimen\spacebetweencols
+\newdimen\spacebetweenlines
+\intableparskip=0pt
+\intableparindent=6pt
+\spacebetweencols=12pt
+\spacebetweenlines=12pt
+
+%%%%
+% Macros used to set up halign preamble:
+\let\endsetuptable\relax
+\def\xendsetuptable{\endsetuptable}
+\let\percentofhsize\relax
+\def\xpercentofhsize{\percentofhsize}
+\newif\ifsetpercent
+
+\newcount\colcount
+\def\setuptable#1{\def\firstarg{#1}%
+\ifx\firstarg\xendsetuptable\let\go\relax%
+\else
+  \ifx\firstarg\xpercentofhsize\global\setpercenttrue%
+  \else
+    \ifsetpercent
+       \if#1.\else%
+       \global\advance\colcount by1 %
+       \expandafter\xdef\csname col\the\colcount\endcsname{.#1\hsize}%
+       \fi
+    \else
+       \global\advance\colcount by1
+       \setbox0=\hbox{#1}%
+       \expandafter\xdef\csname col\the\colcount\endcsname{\the\wd0}%
+    \fi%
+  \fi%
+  \let\go\setuptable%
+\fi\go}
+%%%%
+% multitable syntax
+\def\tab{&}
+
+%%%%
+% @multitable ... @endmultitable definitions:
+
+\def\multitable#1\item{\bgroup
+\let\item\cr
+\tolerance=9500
+\hbadness=9500
+\parskip=\intableparskip
+\parindent=\intableparindent
+\overfullrule=0pt
+\global\colcount=0\relax%
+\def\Emultitable{\global\setpercentfalse\global\everycr{}\cr\egroup\egroup}%
+ % To parse everything between @multitable and @item :
+\def\one{#1}\expandafter\setuptable\one\endsetuptable
+ % Need to reset this to 0 after \setuptable.
+\global\colcount=0\relax% 
+ %
+ % This preamble sets up a generic column definition, which will
+ % be used as many times as user calls for columns.
+ % \vtop will set a single line and will also let text wrap and 
+ % continue for many paragraphs if desired.
+\halign\bgroup&\global\advance\colcount by 1\relax%
+\vtop{\hsize=\expandafter\csname col\the\colcount\endcsname
+ % In order to keep entries from bumping into each other
+ % we will add a \leftskip of \spacebetweencols to all columns after
+ % the first one.
+ %  If a template has been used, we will add \spacebetweencols 
+ % to the width of each template entry.
+ %  If user has set preamble in terms of percent of \hsize
+ % we will use that dimension as the width of the column, and
+ % the \leftskip will keep entries from bumping into each other.
+ % Table will start at left margin and final column will justify at
+ % right margin.
+\ifnum\colcount=1
+\else
+  \ifsetpercent
+  \else
+   % If user has <not> set preamble in terms of percent of \hsize
+   % we will advance \hsize by \spacebetweencols 
+  \advance\hsize by \spacebetweencols
+  \fi
+ % In either case we will make \leftskip=\spacebetweencols:
+\leftskip=\spacebetweencols
+\fi
+\noindent##}\cr%
+ % \everycr will reset column counter, \colcount, at the end of
+ % each line. Every column  entry will cause \colcount to advance by one. 
+ % The table preamble
+ % looks at the current \colcount to find the correct column width.
+\global\everycr{\noalign{\nointerlineskip\vskip\spacebetweenlines
+\filbreak%% keeps underfull box messages off when table breaks over pages.
+\global\colcount=0\relax}}}
+
+\message{indexing,}
+% Index generation facilities
+
+% Define \newwrite to be identical to plain tex's \newwrite
+% except not \outer, so it can be used within \newindex.
+{\catcode`\@=11
+\gdef\newwrite{\alloc@7\write\chardef\sixt@@n}}
+
+% \newindex {foo} defines an index named foo.
+% It automatically defines \fooindex such that
+% \fooindex ...rest of line... puts an entry in the index foo.
+% It also defines \fooindfile to be the number of the output channel for
+% the file that	accumulates this index.  The file's extension is foo.
+% The name of an index should be no more than 2 characters long
+% for the sake of vms.
+
+\def\newindex #1{
+\expandafter\newwrite \csname#1indfile\endcsname% Define number for output file
+\openout \csname#1indfile\endcsname \jobname.#1	% Open the file
+\expandafter\xdef\csname#1index\endcsname{%	% Define \xxxindex
+\noexpand\doindex {#1}}
+}
+
+% @defindex foo  ==  \newindex{foo}
+
+\def\defindex{\parsearg\newindex}
+
+% Define @defcodeindex, like @defindex except put all entries in @code.
+
+\def\newcodeindex #1{
+\expandafter\newwrite \csname#1indfile\endcsname% Define number for output file
+\openout \csname#1indfile\endcsname \jobname.#1	% Open the file
+\expandafter\xdef\csname#1index\endcsname{%	% Define \xxxindex
+\noexpand\docodeindex {#1}}
+}
+
+\def\defcodeindex{\parsearg\newcodeindex}
+
+% @synindex foo bar    makes index foo feed into index bar.
+% Do this instead of @defindex foo if you don't want it as a separate index.
+\def\synindex #1 #2 {%
+\expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
+\expandafter\let\csname#1indfile\endcsname=\synindexfoo
+\expandafter\xdef\csname#1index\endcsname{%	% Define \xxxindex
+\noexpand\doindex {#2}}%
+}
+
+% @syncodeindex foo bar   similar, but put all entries made for index foo
+% inside @code.
+\def\syncodeindex #1 #2 {%
+\expandafter\let\expandafter\synindexfoo\expandafter=\csname#2indfile\endcsname
+\expandafter\let\csname#1indfile\endcsname=\synindexfoo
+\expandafter\xdef\csname#1index\endcsname{%	% Define \xxxindex
+\noexpand\docodeindex {#2}}%
+}
+
+% Define \doindex, the driver for all \fooindex macros.
+% Argument #1 is generated by the calling \fooindex macro,
+%  and it is "foo", the name of the index.
+
+% \doindex just uses \parsearg; it calls \doind for the actual work.
+% This is because \doind is more useful to call from other macros.
+
+% There is also \dosubind {index}{topic}{subtopic}
+% which makes an entry in a two-level index such as the operation index.
+
+\def\doindex#1{\edef\indexname{#1}\parsearg\singleindexer}
+\def\singleindexer #1{\doind{\indexname}{#1}}
+
+% like the previous two, but they put @code around the argument.
+\def\docodeindex#1{\edef\indexname{#1}\parsearg\singlecodeindexer}
+\def\singlecodeindexer #1{\doind{\indexname}{\code{#1}}}
+
+\def\indexdummies{%
+% Take care of the plain tex accent commands.
+\def\"{\realbackslash "}%
+\def\`{\realbackslash `}%
+\def\'{\realbackslash '}%
+\def\^{\realbackslash ^}%
+\def\~{\realbackslash ~}%
+\def\={\realbackslash =}%
+\def\b{\realbackslash b}%
+\def\c{\realbackslash c}%
+\def\d{\realbackslash d}%
+\def\u{\realbackslash u}%
+\def\v{\realbackslash v}%
+\def\H{\realbackslash H}%
+% Take care of the plain tex special European modified letters.
+\def\oe{\realbackslash oe}%
+\def\ae{\realbackslash ae}%
+\def\aa{\realbackslash aa}%
+\def\OE{\realbackslash OE}%
+\def\AE{\realbackslash AE}%
+\def\AA{\realbackslash AA}%
+\def\o{\realbackslash o}%
+\def\O{\realbackslash O}%
+\def\l{\realbackslash l}%
+\def\L{\realbackslash L}%
+\def\ss{\realbackslash ss}%
+% Take care of texinfo commands likely to appear in an index entry.
+\def\_{{\realbackslash _}}%
+\def\w{\realbackslash w }%
+\def\bf{\realbackslash bf }%
+\def\rm{\realbackslash rm }%
+\def\sl{\realbackslash sl }%
+\def\sf{\realbackslash sf}%
+\def\tt{\realbackslash tt}%
+\def\gtr{\realbackslash gtr}%
+\def\less{\realbackslash less}%
+\def\hat{\realbackslash hat}%
+\def\char{\realbackslash char}%
+\def\TeX{\realbackslash TeX}%
+\def\dots{\realbackslash dots }%
+\def\copyright{\realbackslash copyright }%
+\def\tclose##1{\realbackslash tclose {##1}}%
+\def\code##1{\realbackslash code {##1}}%
+\def\samp##1{\realbackslash samp {##1}}%
+\def\t##1{\realbackslash r {##1}}%
+\def\r##1{\realbackslash r {##1}}%
+\def\i##1{\realbackslash i {##1}}%
+\def\b##1{\realbackslash b {##1}}%
+\def\cite##1{\realbackslash cite {##1}}%
+\def\key##1{\realbackslash key {##1}}%
+\def\file##1{\realbackslash file {##1}}%
+\def\var##1{\realbackslash var {##1}}%
+\def\kbd##1{\realbackslash kbd {##1}}%
+\def\dfn##1{\realbackslash dfn {##1}}%
+\def\emph##1{\realbackslash emph {##1}}%
+}
+
+% \indexnofonts no-ops all font-change commands.
+% This is used when outputting the strings to sort the index by.
+\def\indexdummyfont#1{#1}
+\def\indexdummytex{TeX}
+\def\indexdummydots{...}
+
+\def\indexnofonts{%
+% Just ignore accents.
+\let\"=\indexdummyfont
+\let\`=\indexdummyfont
+\let\'=\indexdummyfont
+\let\^=\indexdummyfont
+\let\~=\indexdummyfont
+\let\==\indexdummyfont
+\let\b=\indexdummyfont
+\let\c=\indexdummyfont
+\let\d=\indexdummyfont
+\let\u=\indexdummyfont
+\let\v=\indexdummyfont
+\let\H=\indexdummyfont
+% Take care of the plain tex special European modified letters.
+\def\oe{oe}%
+\def\ae{ae}%
+\def\aa{aa}%
+\def\OE{OE}%
+\def\AE{AE}%
+\def\AA{AA}%
+\def\o{o}%
+\def\O{O}%
+\def\l{l}%
+\def\L{L}%
+\def\ss{ss}%
+\let\w=\indexdummyfont
+\let\t=\indexdummyfont
+\let\r=\indexdummyfont
+\let\i=\indexdummyfont
+\let\b=\indexdummyfont
+\let\emph=\indexdummyfont
+\let\strong=\indexdummyfont
+\let\cite=\indexdummyfont
+\let\sc=\indexdummyfont
+%Don't no-op \tt, since it isn't a user-level command
+% and is used in the definitions of the active chars like <, >, |...
+%\let\tt=\indexdummyfont
+\let\tclose=\indexdummyfont
+\let\code=\indexdummyfont
+\let\file=\indexdummyfont
+\let\samp=\indexdummyfont
+\let\kbd=\indexdummyfont
+\let\key=\indexdummyfont
+\let\var=\indexdummyfont
+\let\TeX=\indexdummytex
+\let\dots=\indexdummydots
+}
+
+% To define \realbackslash, we must make \ not be an escape.
+% We must first make another character (@) an escape
+% so we do not become unable to do a definition.
+
+{\catcode`\@=0 \catcode`\\=\other
+@gdef@realbackslash{\}}
+
+\let\indexbackslash=0  %overridden during \printindex.
+
+\let\SETmarginindex=\relax %initialize!
+% workhorse for all \fooindexes
+% #1 is name of index, #2 is stuff to put there
+\def\doind #1#2{%
+% Put the index entry in the margin if desired.
+\ifx\SETmarginindex\relax\else%
+\insert\margin{\hbox{\vrule height8pt depth3pt width0pt #2}}%
+\fi%
+{\count10=\lastpenalty %
+{\indexdummies % Must do this here, since \bf, etc expand at this stage
+\escapechar=`\\%
+{\let\folio=0% Expand all macros now EXCEPT \folio
+\def\rawbackslashxx{\indexbackslash}% \indexbackslash isn't defined now
+% so it will be output as is; and it will print as backslash in the indx.
+%
+% Now process the index-string once, with all font commands turned off,
+% to get the string to sort the index by.
+{\indexnofonts
+\xdef\temp1{#2}%
+}%
+% Now produce the complete index entry.  We process the index-string again,
+% this time with font commands expanded, to get what to print in the index.
+\edef\temp{%
+\write \csname#1indfile\endcsname{%
+\realbackslash entry {\temp1}{\folio}{#2}}}%
+\temp }%
+}\penalty\count10}}
+
+\def\dosubind #1#2#3{%
+{\count10=\lastpenalty %
+{\indexdummies % Must do this here, since \bf, etc expand at this stage
+\escapechar=`\\%
+{\let\folio=0%
+\def\rawbackslashxx{\indexbackslash}%
+%
+% Now process the index-string once, with all font commands turned off,
+% to get the string to sort the index by.
+{\indexnofonts
+\xdef\temp1{#2 #3}%
+}%
+% Now produce the complete index entry.  We process the index-string again,
+% this time with font commands expanded, to get what to print in the index.
+\edef\temp{%
+\write \csname#1indfile\endcsname{%
+\realbackslash entry {\temp1}{\folio}{#2}{#3}}}%
+\temp }%
+}\penalty\count10}}
+
+% The index entry written in the file actually looks like
+%  \entry {sortstring}{page}{topic}
+% or
+%  \entry {sortstring}{page}{topic}{subtopic}
+% The texindex program reads in these files and writes files
+% containing these kinds of lines:
+%  \initial {c}
+%     before the first topic whose initial is c
+%  \entry {topic}{pagelist}
+%     for a topic that is used without subtopics
+%  \primary {topic}
+%     for the beginning of a topic that is used with subtopics
+%  \secondary {subtopic}{pagelist}
+%     for each subtopic.
+
+% Define the user-accessible indexing commands
+% @findex, @vindex, @kindex, @cindex.
+
+\def\findex {\fnindex}
+\def\kindex {\kyindex}
+\def\cindex {\cpindex}
+\def\vindex {\vrindex}
+\def\tindex {\tpindex}
+\def\pindex {\pgindex}
+
+\def\cindexsub {\begingroup\obeylines\cindexsub}
+{\obeylines %
+\gdef\cindexsub "#1" #2^^M{\endgroup %
+\dosubind{cp}{#2}{#1}}}
+
+% Define the macros used in formatting output of the sorted index material.
+
+% This is what you call to cause a particular index to get printed.
+% Write
+% @unnumbered Function Index
+% @printindex fn
+
+\def\printindex{\parsearg\doprintindex}
+
+\def\doprintindex#1{%
+  \tex
+  \dobreak \chapheadingskip {10000}
+  \catcode`\%=\other\catcode`\&=\other\catcode`\#=\other
+  \catcode`\$=\other
+  \catcode`\~=\other
+  \indexbreaks
+  %
+  % The following don't help, since the chars were translated
+  % when the raw index was written, and their fonts were discarded
+  % due to \indexnofonts.
+  %\catcode`\"=\active
+  %\catcode`\^=\active
+  %\catcode`\_=\active
+  %\catcode`\|=\active
+  %\catcode`\<=\active
+  %\catcode`\>=\active
+  % %
+  \def\indexbackslash{\rawbackslashxx}
+  \indexfonts\rm \tolerance=9500 \advance\baselineskip -1pt
+  \begindoublecolumns
+  %
+  % See if the index file exists and is nonempty.
+  \openin 1 \jobname.#1s
+  \ifeof 1
+    % \enddoublecolumns gets confused if there is no text in the index,
+    % and it loses the chapter title and the aux file entries for the
+    % index.  The easiest way to prevent this problem is to make sure
+    % there is some text.
+    (Index is nonexistent)
+    \else
+    %
+    % If the index file exists but is empty, then \openin leaves \ifeof
+    % false.  We have to make TeX try to read something from the file, so
+    % it can discover if there is anything in it.
+    \read 1 to \temp
+    \ifeof 1
+      (Index is empty)
+    \else
+      \input \jobname.#1s
+    \fi
+  \fi
+  \closein 1
+  \enddoublecolumns
+  \Etex
+}
+
+% These macros are used by the sorted index file itself.
+% Change them to control the appearance of the index.
+
+% Same as \bigskipamount except no shrink.
+% \balancecolumns gets confused if there is any shrink.
+\newskip\initialskipamount \initialskipamount 12pt plus4pt
+
+\def\initial #1{%
+{\let\tentt=\sectt \let\tt=\sectt \let\sf=\sectt
+\ifdim\lastskip<\initialskipamount
+\removelastskip \penalty-200 \vskip \initialskipamount\fi
+\line{\secbf#1\hfill}\kern 2pt\penalty10000}}
+
+% This typesets a paragraph consisting of #1, dot leaders, and then #2
+% flush to the right margin.  It is used for index and table of contents
+% entries.  The paragraph is indented by \leftskip.
+%
+\def\entry #1#2{\begingroup
+  %
+  % Start a new paragraph if necessary, so our assignments below can't
+  % affect previous text.
+  \par
+  %
+  % Do not fill out the last line with white space.
+  \parfillskip = 0in
+  %
+  % No extra space above this paragraph.
+  \parskip = 0in
+  %
+  % Do not prefer a separate line ending with a hyphen to fewer lines.
+  \finalhyphendemerits = 0
+  %
+  % \hangindent is only relevant when the entry text and page number
+  % don't both fit on one line.  In that case, bob suggests starting the
+  % dots pretty far over on the line.  Unfortunately, a large
+  % indentation looks wrong when the entry text itself is broken across
+  % lines.  So we use a small indentation and put up with long leaders.
+  %
+  % \hangafter is reset to 1 (which is the value we want) at the start
+  % of each paragraph, so we need not do anything with that.
+  \hangindent=2em
+  %
+  % When the entry text needs to be broken, just fill out the first line
+  % with blank space.
+  \rightskip = 0pt plus1fil
+  %
+  % Start a ``paragraph'' for the index entry so the line breaking
+  % parameters we've set above will have an effect.
+  \noindent
+  %
+  % Insert the text of the index entry.  TeX will do line-breaking on it.
+  #1%
+  % The following is kluged to not output a line of dots in the index if
+  % there are no page numbers.  The next person who breaks this will be
+  % cursed by a Unix daemon.
+  \def\tempa{{\rm }}%
+  \def\tempb{#2}%
+  \edef\tempc{\tempa}%
+  \edef\tempd{\tempb}%
+  \ifx\tempc\tempd\ \else%
+    %
+    % If we must, put the page number on a line of its own, and fill out
+    % this line with blank space.  (The \hfil is overwhelmed with the
+    % fill leaders glue in \indexdotfill if the page number does fit.)
+    \hfil\penalty50
+    \null\nobreak\indexdotfill % Have leaders before the page number.
+    %
+    % The `\ ' here is removed by the implicit \unskip that TeX does as
+    % part of (the primitive) \par.  Without it, a spurious underfull
+    % \hbox ensues.
+    \ #2% The page number ends the paragraph.
+  \fi%
+  \par
+\endgroup}
+
+% Like \dotfill except takes at least 1 em.
+\def\indexdotfill{\cleaders
+  \hbox{$\mathsurround=0pt \mkern1.5mu ${\it .}$ \mkern1.5mu$}\hskip 1em plus 1fill}
+
+\def\primary #1{\line{#1\hfil}}
+
+\newskip\secondaryindent \secondaryindent=0.5cm
+
+\def\secondary #1#2{
+{\parfillskip=0in \parskip=0in
+\hangindent =1in \hangafter=1
+\noindent\hskip\secondaryindent\hbox{#1}\indexdotfill #2\par
+}}
+
+%% Define two-column mode, which is used in indexes.
+%% Adapted from the TeXbook, page 416.
+\catcode `\@=11
+
+\newbox\partialpage
+
+\newdimen\doublecolumnhsize
+
+\def\begindoublecolumns{\begingroup
+  % Grab any single-column material above us.
+  \output = {\global\setbox\partialpage
+    =\vbox{\unvbox255\kern -\topskip \kern \baselineskip}}%
+  \eject
+  %
+  % Now switch to the double-column output routine.
+  \output={\doublecolumnout}%
+  %
+  % Change the page size parameters.  We could do this once outside this
+  % routine, in each of @smallbook, @afourpaper, and the default 8.5x11
+  % format, but then we repeat the same computation.  Repeating a couple
+  % of assignments once per index is clearly meaningless for the
+  % execution time, so we may as well do it once.
+  %
+  % First we halve the line length, less a little for the gutter between
+  % the columns.  We compute the gutter based on the line length, so it
+  % changes automatically with the paper format.  The magic constant
+  % below is chosen so that the gutter has the same value (well, +- <
+  % 1pt) as it did when we hard-coded it.
+  %
+  % We put the result in a separate register, \doublecolumhsize, so we
+  % can restore it in \pagesofar, after \hsize itself has (potentially)
+  % been clobbered.
+  %
+  \doublecolumnhsize = \hsize
+    \advance\doublecolumnhsize by -.04154\hsize
+    \divide\doublecolumnhsize by 2
+  \hsize = \doublecolumnhsize
+  %
+  % Double the \vsize as well.  (We don't need a separate register here,
+  % since nobody clobbers \vsize.)
+  \vsize = 2\vsize
+  \doublecolumnpagegoal
+}
+
+\def\enddoublecolumns{\eject \endgroup \pagegoal=\vsize \unvbox\partialpage}
+
+\def\doublecolumnsplit{\splittopskip=\topskip \splitmaxdepth=\maxdepth
+  \global\dimen@=\pageheight \global\advance\dimen@ by-\ht\partialpage
+  \global\setbox1=\vsplit255 to\dimen@ \global\setbox0=\vbox{\unvbox1}
+  \global\setbox3=\vsplit255 to\dimen@ \global\setbox2=\vbox{\unvbox3}
+  \ifdim\ht0>\dimen@ \setbox255=\vbox{\unvbox0\unvbox2} \global\setbox255=\copy5 \fi
+  \ifdim\ht2>\dimen@ \setbox255=\vbox{\unvbox0\unvbox2} \global\setbox255=\copy5 \fi
+}
+\def\doublecolumnpagegoal{%
+  \dimen@=\vsize \advance\dimen@ by-2\ht\partialpage \global\pagegoal=\dimen@
+}
+\def\pagesofar{\unvbox\partialpage %
+  \hsize=\doublecolumnhsize % have to restore this since output routine
+  \wd0=\hsize \wd2=\hsize \hbox to\pagewidth{\box0\hfil\box2}}
+\def\doublecolumnout{%
+  \setbox5=\copy255
+  {\vbadness=10000 \doublecolumnsplit}
+  \ifvbox255
+    \setbox0=\vtop to\dimen@{\unvbox0}
+    \setbox2=\vtop to\dimen@{\unvbox2}
+    \onepageout\pagesofar \unvbox255 \penalty\outputpenalty
+  \else
+    \setbox0=\vbox{\unvbox5}
+    \ifvbox0
+      \dimen@=\ht0 \advance\dimen@ by\topskip \advance\dimen@ by-\baselineskip
+      \divide\dimen@ by2 \splittopskip=\topskip \splitmaxdepth=\maxdepth
+      {\vbadness=10000
+	\loop \global\setbox5=\copy0
+          \setbox1=\vsplit5 to\dimen@
+          \setbox3=\vsplit5 to\dimen@
+          \ifvbox5 \global\advance\dimen@ by1pt \repeat
+        \setbox0=\vbox to\dimen@{\unvbox1}
+        \setbox2=\vbox to\dimen@{\unvbox3}
+        \global\setbox\partialpage=\vbox{\pagesofar}
+        \doublecolumnpagegoal
+      }
+    \fi
+  \fi
+}
+
+\catcode `\@=\other
+\message{sectioning,}
+% Define chapters, sections, etc.
+
+\newcount \chapno
+\newcount \secno        \secno=0
+\newcount \subsecno     \subsecno=0
+\newcount \subsubsecno  \subsubsecno=0
+
+% This counter is funny since it counts through charcodes of letters A, B, ...
+\newcount \appendixno  \appendixno = `\@
+\def\appendixletter{\char\the\appendixno}
+
+\newwrite \contentsfile
+% This is called from \setfilename.
+\def\opencontents{\openout \contentsfile = \jobname.toc}
+
+% Each @chapter defines this as the name of the chapter.
+% page headings and footings can use it.  @section does likewise
+
+\def\thischapter{} \def\thissection{}
+\def\seccheck#1{\if \pageno<0 %
+\errmessage{@#1 not allowed after generating table of contents}\fi
+%
+}
+
+\def\chapternofonts{%
+\let\rawbackslash=\relax%
+\let\frenchspacing=\relax%
+\def\result{\realbackslash result}
+\def\equiv{\realbackslash equiv}
+\def\expansion{\realbackslash expansion}
+\def\print{\realbackslash print}
+\def\TeX{\realbackslash TeX}
+\def\dots{\realbackslash dots}
+\def\copyright{\realbackslash copyright}
+\def\tt{\realbackslash tt}
+\def\bf{\realbackslash bf }
+\def\w{\realbackslash w}
+\def\less{\realbackslash less}
+\def\gtr{\realbackslash gtr}
+\def\hat{\realbackslash hat}
+\def\char{\realbackslash char}
+\def\tclose##1{\realbackslash tclose {##1}}
+\def\code##1{\realbackslash code {##1}}
+\def\samp##1{\realbackslash samp {##1}}
+\def\r##1{\realbackslash r {##1}}
+\def\b##1{\realbackslash b {##1}}
+\def\key##1{\realbackslash key {##1}}
+\def\file##1{\realbackslash file {##1}}
+\def\kbd##1{\realbackslash kbd {##1}}
+% These are redefined because @smartitalic wouldn't work inside xdef.
+\def\i##1{\realbackslash i {##1}}
+\def\cite##1{\realbackslash cite {##1}}
+\def\var##1{\realbackslash var {##1}}
+\def\emph##1{\realbackslash emph {##1}}
+\def\dfn##1{\realbackslash dfn {##1}}
+}
+
+\newcount\absseclevel % used to calculate proper heading level
+\newcount\secbase\secbase=0 % @raise/lowersections modify this count
+
+% @raisesections: treat @section as chapter, @subsection as section, etc.
+\def\raisesections{\global\advance\secbase by -1}
+\let\up=\raisesections % original BFox name
+
+% @lowersections: treat @chapter as section, @section as subsection, etc.
+\def\lowersections{\global\advance\secbase by 1}
+\let\down=\lowersections % original BFox name
+
+% Choose a numbered-heading macro
+% #1 is heading level if unmodified by @raisesections or @lowersections
+% #2 is text for heading
+\def\numhead#1#2{\absseclevel=\secbase\advance\absseclevel by #1
+\ifcase\absseclevel
+  \chapterzzz{#2}
+\or
+  \seczzz{#2}
+\or
+  \numberedsubseczzz{#2}
+\or
+  \numberedsubsubseczzz{#2}
+\else
+  \ifnum \absseclevel<0
+    \chapterzzz{#2}
+  \else
+    \numberedsubsubseczzz{#2}
+  \fi
+\fi
+}
+
+% like \numhead, but chooses appendix heading levels
+\def\apphead#1#2{\absseclevel=\secbase\advance\absseclevel by #1
+\ifcase\absseclevel
+  \appendixzzz{#2}
+\or
+  \appendixsectionzzz{#2}
+\or
+  \appendixsubseczzz{#2}
+\or
+  \appendixsubsubseczzz{#2}
+\else
+  \ifnum \absseclevel<0
+    \appendixzzz{#2}
+  \else
+    \appendixsubsubseczzz{#2}
+  \fi
+\fi
+}
+
+% like \numhead, but chooses numberless heading levels
+\def\unnmhead#1#2{\absseclevel=\secbase\advance\absseclevel by #1
+\ifcase\absseclevel
+  \unnumberedzzz{#2}
+\or
+  \unnumberedseczzz{#2}
+\or
+  \unnumberedsubseczzz{#2}
+\or
+  \unnumberedsubsubseczzz{#2}
+\else
+  \ifnum \absseclevel<0
+    \unnumberedzzz{#2}
+  \else
+    \unnumberedsubsubseczzz{#2}
+  \fi
+\fi
+}
+
+
+\def\thischaptername{No Chapter Title}
+\outer\def\chapter{\parsearg\chapteryyy}
+\def\chapteryyy #1{\numhead0{#1}} % normally numhead0 calls chapterzzz
+\def\chapterzzz #1{\seccheck{chapter}%
+\secno=0 \subsecno=0 \subsubsecno=0
+\global\advance \chapno by 1 \message{\putwordChapter \the\chapno}%
+\chapmacro {#1}{\the\chapno}%
+\gdef\thissection{#1}%
+\gdef\thischaptername{#1}%
+% We don't substitute the actual chapter name into \thischapter
+% because we don't want its macros evaluated now.
+\xdef\thischapter{\putwordChapter{} \the\chapno: \noexpand\thischaptername}%
+{\chapternofonts%
+\edef\temp{{\realbackslash chapentry {#1}{\the\chapno}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp  %
+\donoderef %
+\global\let\section = \numberedsec
+\global\let\subsection = \numberedsubsec
+\global\let\subsubsection = \numberedsubsubsec
+}}
+
+\outer\def\appendix{\parsearg\appendixyyy}
+\def\appendixyyy #1{\apphead0{#1}} % normally apphead0 calls appendixzzz
+\def\appendixzzz #1{\seccheck{appendix}%
+\secno=0 \subsecno=0 \subsubsecno=0
+\global\advance \appendixno by 1 \message{Appendix \appendixletter}%
+\chapmacro {#1}{\putwordAppendix{} \appendixletter}%
+\gdef\thissection{#1}%
+\gdef\thischaptername{#1}%
+\xdef\thischapter{\putwordAppendix{} \appendixletter: \noexpand\thischaptername}%
+{\chapternofonts%
+\edef\temp{{\realbackslash chapentry
+  {#1}{\putwordAppendix{} \appendixletter}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp  %
+\appendixnoderef %
+\global\let\section = \appendixsec
+\global\let\subsection = \appendixsubsec
+\global\let\subsubsection = \appendixsubsubsec
+}}
+
+\outer\def\top{\parsearg\unnumberedyyy}
+\outer\def\unnumbered{\parsearg\unnumberedyyy}
+\def\unnumberedyyy #1{\unnmhead0{#1}} % normally unnmhead0 calls unnumberedzzz
+\def\unnumberedzzz #1{\seccheck{unnumbered}%
+\secno=0 \subsecno=0 \subsubsecno=0
+%
+% This used to be simply \message{#1}, but TeX fully expands the
+% argument to \message.  Therefore, if #1 contained @-commands, TeX
+% expanded them.  For example, in `@unnumbered The @cite{Book}', TeX
+% expanded @cite (which turns out to cause errors because \cite is meant
+% to be executed, not expanded).
+%
+% Anyway, we don't want the fully-expanded definition of @cite to appear
+% as a result of the \message, we just want `@cite' itself.  We use
+% \the<toks register> to achieve this: TeX expands \the<toks> only once,
+% simply yielding the contents of the <toks register>.
+\toks0 = {#1}\message{(\the\toks0)}%
+%
+\unnumbchapmacro {#1}%
+\gdef\thischapter{#1}\gdef\thissection{#1}%
+{\chapternofonts%
+\edef\temp{{\realbackslash unnumbchapentry {#1}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp  %
+\unnumbnoderef %
+\global\let\section = \unnumberedsec
+\global\let\subsection = \unnumberedsubsec
+\global\let\subsubsection = \unnumberedsubsubsec
+}}
+
+\outer\def\numberedsec{\parsearg\secyyy}
+\def\secyyy #1{\numhead1{#1}} % normally calls seczzz
+\def\seczzz #1{\seccheck{section}%
+\subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
+\gdef\thissection{#1}\secheading {#1}{\the\chapno}{\the\secno}%
+{\chapternofonts%
+\edef\temp{{\realbackslash secentry %
+{#1}{\the\chapno}{\the\secno}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp %
+\donoderef %
+\penalty 10000 %
+}}
+
+\outer\def\appenixsection{\parsearg\appendixsecyyy}
+\outer\def\appendixsec{\parsearg\appendixsecyyy}
+\def\appendixsecyyy #1{\apphead1{#1}} % normally calls appendixsectionzzz
+\def\appendixsectionzzz #1{\seccheck{appendixsection}%
+\subsecno=0 \subsubsecno=0 \global\advance \secno by 1 %
+\gdef\thissection{#1}\secheading {#1}{\appendixletter}{\the\secno}%
+{\chapternofonts%
+\edef\temp{{\realbackslash secentry %
+{#1}{\appendixletter}{\the\secno}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp %
+\appendixnoderef %
+\penalty 10000 %
+}}
+
+\outer\def\unnumberedsec{\parsearg\unnumberedsecyyy}
+\def\unnumberedsecyyy #1{\unnmhead1{#1}} % normally calls unnumberedseczzz
+\def\unnumberedseczzz #1{\seccheck{unnumberedsec}%
+\plainsecheading {#1}\gdef\thissection{#1}%
+{\chapternofonts%
+\edef\temp{{\realbackslash unnumbsecentry{#1}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp %
+\unnumbnoderef %
+\penalty 10000 %
+}}
+
+\outer\def\numberedsubsec{\parsearg\numberedsubsecyyy}
+\def\numberedsubsecyyy #1{\numhead2{#1}} % normally calls numberedsubseczzz
+\def\numberedsubseczzz #1{\seccheck{subsection}%
+\gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
+\subsecheading {#1}{\the\chapno}{\the\secno}{\the\subsecno}%
+{\chapternofonts%
+\edef\temp{{\realbackslash subsecentry %
+{#1}{\the\chapno}{\the\secno}{\the\subsecno}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp %
+\donoderef %
+\penalty 10000 %
+}}
+
+\outer\def\appendixsubsec{\parsearg\appendixsubsecyyy}
+\def\appendixsubsecyyy #1{\apphead2{#1}} % normally calls appendixsubseczzz
+\def\appendixsubseczzz #1{\seccheck{appendixsubsec}%
+\gdef\thissection{#1}\subsubsecno=0 \global\advance \subsecno by 1 %
+\subsecheading {#1}{\appendixletter}{\the\secno}{\the\subsecno}%
+{\chapternofonts%
+\edef\temp{{\realbackslash subsecentry %
+{#1}{\appendixletter}{\the\secno}{\the\subsecno}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp %
+\appendixnoderef %
+\penalty 10000 %
+}}
+
+\outer\def\unnumberedsubsec{\parsearg\unnumberedsubsecyyy}
+\def\unnumberedsubsecyyy #1{\unnmhead2{#1}} %normally calls unnumberedsubseczzz
+\def\unnumberedsubseczzz #1{\seccheck{unnumberedsubsec}%
+\plainsecheading {#1}\gdef\thissection{#1}%
+{\chapternofonts%
+\edef\temp{{\realbackslash unnumbsubsecentry{#1}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp %
+\unnumbnoderef %
+\penalty 10000 %
+}}
+
+\outer\def\numberedsubsubsec{\parsearg\numberedsubsubsecyyy}
+\def\numberedsubsubsecyyy #1{\numhead3{#1}} % normally numberedsubsubseczzz
+\def\numberedsubsubseczzz #1{\seccheck{subsubsection}%
+\gdef\thissection{#1}\global\advance \subsubsecno by 1 %
+\subsubsecheading {#1}
+  {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
+{\chapternofonts%
+\edef\temp{{\realbackslash subsubsecentry %
+  {#1}
+  {\the\chapno}{\the\secno}{\the\subsecno}{\the\subsubsecno}
+  {\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp %
+\donoderef %
+\penalty 10000 %
+}}
+
+\outer\def\appendixsubsubsec{\parsearg\appendixsubsubsecyyy}
+\def\appendixsubsubsecyyy #1{\apphead3{#1}} % normally appendixsubsubseczzz
+\def\appendixsubsubseczzz #1{\seccheck{appendixsubsubsec}%
+\gdef\thissection{#1}\global\advance \subsubsecno by 1 %
+\subsubsecheading {#1}
+  {\appendixletter}{\the\secno}{\the\subsecno}{\the\subsubsecno}%
+{\chapternofonts%
+\edef\temp{{\realbackslash subsubsecentry{#1}%
+  {\appendixletter}
+  {\the\secno}{\the\subsecno}{\the\subsubsecno}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp %
+\appendixnoderef %
+\penalty 10000 %
+}}
+
+\outer\def\unnumberedsubsubsec{\parsearg\unnumberedsubsubsecyyy}
+\def\unnumberedsubsubsecyyy #1{\unnmhead3{#1}} %normally unnumberedsubsubseczzz
+\def\unnumberedsubsubseczzz #1{\seccheck{unnumberedsubsubsec}%
+\plainsecheading {#1}\gdef\thissection{#1}%
+{\chapternofonts%
+\edef\temp{{\realbackslash unnumbsubsubsecentry{#1}{\noexpand\folio}}}%
+\escapechar=`\\%
+\write \contentsfile \temp %
+\unnumbnoderef %
+\penalty 10000 %
+}}
+
+% These are variants which are not "outer", so they can appear in @ifinfo.
+% Actually, they should now be obsolete; ordinary section commands should work.
+\def\infotop{\parsearg\unnumberedzzz}
+\def\infounnumbered{\parsearg\unnumberedzzz}
+\def\infounnumberedsec{\parsearg\unnumberedseczzz}
+\def\infounnumberedsubsec{\parsearg\unnumberedsubseczzz}
+\def\infounnumberedsubsubsec{\parsearg\unnumberedsubsubseczzz}
+
+\def\infoappendix{\parsearg\appendixzzz}
+\def\infoappendixsec{\parsearg\appendixseczzz}
+\def\infoappendixsubsec{\parsearg\appendixsubseczzz}
+\def\infoappendixsubsubsec{\parsearg\appendixsubsubseczzz}
+
+\def\infochapter{\parsearg\chapterzzz}
+\def\infosection{\parsearg\sectionzzz}
+\def\infosubsection{\parsearg\subsectionzzz}
+\def\infosubsubsection{\parsearg\subsubsectionzzz}
+
+% These macros control what the section commands do, according
+% to what kind of chapter we are in (ordinary, appendix, or unnumbered).
+% Define them by default for a numbered chapter.
+\global\let\section = \numberedsec
+\global\let\subsection = \numberedsubsec
+\global\let\subsubsection = \numberedsubsubsec
+
+% Define @majorheading, @heading and @subheading
+
+% NOTE on use of \vbox for chapter headings, section headings, and
+% such:
+%	1) We use \vbox rather than the earlier \line to permit
+%	   overlong headings to fold.
+%	2) \hyphenpenalty is set to 10000 because hyphenation in a
+%	   heading is obnoxious; this forbids it.
+%       3) Likewise, headings look best if no \parindent is used, and
+%          if justification is not attempted.  Hence \raggedright.
+
+
+\def\majorheading{\parsearg\majorheadingzzz}
+\def\majorheadingzzz #1{%
+{\advance\chapheadingskip by 10pt \chapbreak }%
+{\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
+                  \parindent=0pt\raggedright
+                  \rm #1\hfill}}\bigskip \par\penalty 200}
+
+\def\chapheading{\parsearg\chapheadingzzz}
+\def\chapheadingzzz #1{\chapbreak %
+{\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
+                  \parindent=0pt\raggedright
+                  \rm #1\hfill}}\bigskip \par\penalty 200}
+
+\def\heading{\parsearg\secheadingi}
+
+\def\subheading{\parsearg\subsecheadingi}
+
+\def\subsubheading{\parsearg\subsubsecheadingi}
+
+% These macros generate a chapter, section, etc. heading only
+% (including whitespace, linebreaking, etc. around it),
+% given all the information in convenient, parsed form.
+
+%%% Args are the skip and penalty (usually negative)
+\def\dobreak#1#2{\par\ifdim\lastskip<#1\removelastskip\penalty#2\vskip#1\fi}
+
+\def\setchapterstyle #1 {\csname CHAPF#1\endcsname}
+
+%%% Define plain chapter starts, and page on/off switching for it
+% Parameter controlling skip before chapter headings (if needed)
+
+\newskip \chapheadingskip \chapheadingskip = 30pt plus 8pt minus 4pt
+
+\def\chapbreak{\dobreak \chapheadingskip {-4000}}
+\def\chappager{\par\vfill\supereject}
+\def\chapoddpage{\chappager \ifodd\pageno \else \hbox to 0pt{} \chappager\fi}
+
+\def\setchapternewpage #1 {\csname CHAPPAG#1\endcsname}
+
+\def\CHAPPAGoff{
+\global\let\pchapsepmacro=\chapbreak
+\global\let\pagealignmacro=\chappager}
+
+\def\CHAPPAGon{
+\global\let\pchapsepmacro=\chappager
+\global\let\pagealignmacro=\chappager
+\global\def\HEADINGSon{\HEADINGSsingle}}
+
+\def\CHAPPAGodd{
+\global\let\pchapsepmacro=\chapoddpage
+\global\let\pagealignmacro=\chapoddpage
+\global\def\HEADINGSon{\HEADINGSdouble}}
+
+\CHAPPAGon
+
+\def\CHAPFplain{
+\global\let\chapmacro=\chfplain
+\global\let\unnumbchapmacro=\unnchfplain}
+
+\def\chfplain #1#2{%
+  \pchapsepmacro
+  {%
+    \chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
+                     \parindent=0pt\raggedright
+                     \rm #2\enspace #1}%
+  }%
+  \bigskip
+  \penalty5000
+}
+
+\def\unnchfplain #1{%
+\pchapsepmacro %
+{\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
+                  \parindent=0pt\raggedright
+                  \rm #1\hfill}}\bigskip \par\penalty 10000 %
+}
+\CHAPFplain % The default
+
+\def\unnchfopen #1{%
+\chapoddpage {\chapfonts \vbox{\hyphenpenalty=10000\tolerance=5000
+                       \parindent=0pt\raggedright
+                       \rm #1\hfill}}\bigskip \par\penalty 10000 %
+}
+
+\def\chfopen #1#2{\chapoddpage {\chapfonts
+\vbox to 3in{\vfil \hbox to\hsize{\hfil #2} \hbox to\hsize{\hfil #1} \vfil}}%
+\par\penalty 5000 %
+}
+
+\def\CHAPFopen{
+\global\let\chapmacro=\chfopen
+\global\let\unnumbchapmacro=\unnchfopen}
+
+% Parameter controlling skip before section headings.
+
+\newskip \subsecheadingskip  \subsecheadingskip = 17pt plus 8pt minus 4pt
+\def\subsecheadingbreak{\dobreak \subsecheadingskip {-500}}
+
+\newskip \secheadingskip  \secheadingskip = 21pt plus 8pt minus 4pt
+\def\secheadingbreak{\dobreak \secheadingskip {-1000}}
+
+% @paragraphindent  is defined for the Info formatting commands only.
+\let\paragraphindent=\comment
+
+% Section fonts are the base font at magstep2, which produces
+% a size a bit more than 14 points in the default situation.
+
+\def\secheading #1#2#3{\secheadingi {#2.#3\enspace #1}}
+\def\plainsecheading #1{\secheadingi {#1}}
+\def\secheadingi #1{{\advance \secheadingskip by \parskip %
+\secheadingbreak}%
+{\secfonts \vbox{\hyphenpenalty=10000\tolerance=5000
+                 \parindent=0pt\raggedright
+                 \rm #1\hfill}}%
+\ifdim \parskip<10pt \kern 10pt\kern -\parskip\fi \penalty 10000 }
+
+
+% Subsection fonts are the base font at magstep1,
+% which produces a size of 12 points.
+
+\def\subsecheading #1#2#3#4{\subsecheadingi {#2.#3.#4\enspace #1}}
+\def\subsecheadingi #1{{\advance \subsecheadingskip by \parskip %
+\subsecheadingbreak}%
+{\subsecfonts \vbox{\hyphenpenalty=10000\tolerance=5000
+                     \parindent=0pt\raggedright
+                     \rm #1\hfill}}%
+\ifdim \parskip<10pt \kern 10pt\kern -\parskip\fi \penalty 10000 }
+
+\def\subsubsecfonts{\subsecfonts} % Maybe this should change:
+				  % Perhaps make sssec fonts scaled
+				  % magstep half
+\def\subsubsecheading #1#2#3#4#5{\subsubsecheadingi {#2.#3.#4.#5\enspace #1}}
+\def\subsubsecheadingi #1{{\advance \subsecheadingskip by \parskip %
+\subsecheadingbreak}%
+{\subsubsecfonts \vbox{\hyphenpenalty=10000\tolerance=5000
+                       \parindent=0pt\raggedright
+                       \rm #1\hfill}}%
+\ifdim \parskip<10pt \kern 10pt\kern -\parskip\fi \penalty 10000}
+
+
+\message{toc printing,}
+
+% Finish up the main text and prepare to read what we've written
+% to \contentsfile.
+
+\newskip\contentsrightmargin \contentsrightmargin=1in
+\def\startcontents#1{%
+   \pagealignmacro
+   \immediate\closeout \contentsfile
+   \ifnum \pageno>0
+      \pageno = -1		% Request roman numbered pages.
+   \fi
+   % Don't need to put `Contents' or `Short Contents' in the headline.
+   % It is abundantly clear what they are.
+   \unnumbchapmacro{#1}\def\thischapter{}%
+   \begingroup   		% Set up to handle contents files properly.
+      \catcode`\\=0  \catcode`\{=1  \catcode`\}=2  \catcode`\@=11
+      \catcode`\^=7 % to see ^^e4 as \"a etc. juha@piuha.ydi.vtt.fi
+      \raggedbottom             % Worry more about breakpoints than the bottom.
+      \advance\hsize by -\contentsrightmargin % Don't use the full line length.
+}
+
+
+% Normal (long) toc.
+\outer\def\contents{%
+   \startcontents{\putwordTableofContents}%
+      \input \jobname.toc
+   \endgroup
+   \vfill \eject
+}
+
+% And just the chapters.
+\outer\def\summarycontents{%
+   \startcontents{\putwordShortContents}%
+      %
+      \let\chapentry = \shortchapentry
+      \let\unnumbchapentry = \shortunnumberedentry
+      % We want a true roman here for the page numbers.
+      \secfonts
+      \let\rm=\shortcontrm \let\bf=\shortcontbf \let\sl=\shortcontsl
+      \rm
+      \advance\baselineskip by 1pt % Open it up a little.
+      \def\secentry ##1##2##3##4{}
+      \def\unnumbsecentry ##1##2{}
+      \def\subsecentry ##1##2##3##4##5{}
+      \def\unnumbsubsecentry ##1##2{}
+      \def\subsubsecentry ##1##2##3##4##5##6{}
+      \def\unnumbsubsubsecentry ##1##2{}
+      \input \jobname.toc
+   \endgroup
+   \vfill \eject
+}
+\let\shortcontents = \summarycontents
+
+% These macros generate individual entries in the table of contents.
+% The first argument is the chapter or section name.
+% The last argument is the page number.
+% The arguments in between are the chapter number, section number, ...
+
+% Chapter-level things, for both the long and short contents.
+\def\chapentry#1#2#3{\dochapentry{#2\labelspace#1}{#3}}
+
+% See comments in \dochapentry re vbox and related settings
+\def\shortchapentry#1#2#3{%
+  \tocentry{\shortchaplabel{#2}\labelspace #1}{\doshortpageno{#3}}%
+}
+
+% Typeset the label for a chapter or appendix for the short contents.
+% The arg is, e.g. `Appendix A' for an appendix, or `3' for a chapter.
+% We could simplify the code here by writing out an \appendixentry
+% command in the toc file for appendices, instead of using \chapentry
+% for both, but it doesn't seem worth it.
+\setbox0 = \hbox{\shortcontrm \putwordAppendix }
+\newdimen\shortappendixwidth \shortappendixwidth = \wd0
+
+\def\shortchaplabel#1{%
+  % We typeset #1 in a box of constant width, regardless of the text of
+  % #1, so the chapter titles will come out aligned.
+  \setbox0 = \hbox{#1}%
+  \dimen0 = \ifdim\wd0 > \shortappendixwidth \shortappendixwidth \else 0pt \fi
+  %
+  % This space should be plenty, since a single number is .5em, and the
+  % widest letter (M) is 1em, at least in the Computer Modern fonts.
+  % (This space doesn't include the extra space that gets added after
+  % the label; that gets put in in \shortchapentry above.)
+  \advance\dimen0 by 1.1em
+  \hbox to \dimen0{#1\hfil}%
+}
+
+\def\unnumbchapentry#1#2{\dochapentry{#1}{#2}}
+\def\shortunnumberedentry#1#2{\tocentry{#1}{\doshortpageno{#2}}}
+
+% Sections.
+\def\secentry#1#2#3#4{\dosecentry{#2.#3\labelspace#1}{#4}}
+\def\unnumbsecentry#1#2{\dosecentry{#1}{#2}}
+
+% Subsections.
+\def\subsecentry#1#2#3#4#5{\dosubsecentry{#2.#3.#4\labelspace#1}{#5}}
+\def\unnumbsubsecentry#1#2{\dosubsecentry{#1}{#2}}
+
+% And subsubsections.
+\def\subsubsecentry#1#2#3#4#5#6{%
+  \dosubsubsecentry{#2.#3.#4.#5\labelspace#1}{#6}}
+\def\unnumbsubsubsecentry#1#2{\dosubsubsecentry{#1}{#2}}
+
+
+% This parameter controls the indentation of the various levels.
+\newdimen\tocindent \tocindent = 3pc
+
+% Now for the actual typesetting. In all these, #1 is the text and #2 is the
+% page number.
+%
+% If the toc has to be broken over pages, we would want to be at chapters
+% if at all possible; hence the \penalty.
+\def\dochapentry#1#2{%
+   \penalty-300 \vskip\baselineskip
+   \begingroup
+     \chapentryfonts
+     \tocentry{#1}{\dopageno{#2}}%
+   \endgroup
+   \nobreak\vskip .25\baselineskip
+}
+
+\def\dosecentry#1#2{\begingroup
+  \secentryfonts \leftskip=\tocindent
+  \tocentry{#1}{\dopageno{#2}}%
+\endgroup}
+
+\def\dosubsecentry#1#2{\begingroup
+  \subsecentryfonts \leftskip=2\tocindent
+  \tocentry{#1}{\dopageno{#2}}%
+\endgroup}
+
+\def\dosubsubsecentry#1#2{\begingroup
+  \subsubsecentryfonts \leftskip=3\tocindent
+  \tocentry{#1}{\dopageno{#2}}%
+\endgroup}
+
+% Final typesetting of a toc entry; we use the same \entry macro as for
+% the index entries, but we want to suppress hyphenation here.  (We
+% can't do that in the \entry macro, since index entries might consist
+% of hyphenated-identifiers-that-do-not-fit-on-a-line-and-nothing-else.)
+%
+\def\tocentry#1#2{\begingroup
+  \hyphenpenalty = 10000
+  \entry{#1}{#2}%
+\endgroup}
+
+% Space between chapter (or whatever) number and the title.
+\def\labelspace{\hskip1em \relax}
+
+\def\dopageno#1{{\rm #1}}
+\def\doshortpageno#1{{\rm #1}}
+
+\def\chapentryfonts{\secfonts \rm}
+\def\secentryfonts{\textfonts}
+\let\subsecentryfonts = \textfonts
+\let\subsubsecentryfonts = \textfonts
+
+
+\message{environments,}
+
+% Since these characters are used in examples, it should be an even number of
+% \tt widths. Each \tt character is 1en, so two makes it 1em.
+% Furthermore, these definitions must come after we define our fonts.
+\newbox\dblarrowbox    \newbox\longdblarrowbox
+\newbox\pushcharbox    \newbox\bullbox
+\newbox\equivbox       \newbox\errorbox
+
+\let\ptexequiv = \equiv
+
+%{\tentt
+%\global\setbox\dblarrowbox = \hbox to 1em{\hfil$\Rightarrow$\hfil}
+%\global\setbox\longdblarrowbox = \hbox to 1em{\hfil$\mapsto$\hfil}
+%\global\setbox\pushcharbox = \hbox to 1em{\hfil$\dashv$\hfil}
+%\global\setbox\equivbox = \hbox to 1em{\hfil$\ptexequiv$\hfil}
+% Adapted from the manmac format (p.420 of TeXbook)
+%\global\setbox\bullbox = \hbox to 1em{\kern.15em\vrule height .75ex width .85ex
+%                                      depth .1ex\hfil}
+%}
+
+\def\point{$\star$}
+
+\def\result{\leavevmode\raise.15ex\hbox to 1em{\hfil$\Rightarrow$\hfil}}
+\def\expansion{\leavevmode\raise.1ex\hbox to 1em{\hfil$\mapsto$\hfil}}
+\def\print{\leavevmode\lower.1ex\hbox to 1em{\hfil$\dashv$\hfil}}
+
+\def\equiv{\leavevmode\lower.1ex\hbox to 1em{\hfil$\ptexequiv$\hfil}}
+
+% Adapted from the TeXbook's \boxit.
+{\tentt \global\dimen0 = 3em}% Width of the box.
+\dimen2 = .55pt % Thickness of rules
+% The text. (`r' is open on the right, `e' somewhat less so on the left.)
+\setbox0 = \hbox{\kern-.75pt \tensf error\kern-1.5pt}
+
+\global\setbox\errorbox=\hbox to \dimen0{\hfil
+   \hsize = \dimen0 \advance\hsize by -5.8pt % Space to left+right.
+   \advance\hsize by -2\dimen2 % Rules.
+   \vbox{
+      \hrule height\dimen2
+      \hbox{\vrule width\dimen2 \kern3pt          % Space to left of text.
+         \vtop{\kern2.4pt \box0 \kern2.4pt}% Space above/below.
+         \kern3pt\vrule width\dimen2}% Space to right.
+      \hrule height\dimen2}
+    \hfil}
+
+% The @error{} command.
+\def\error{\leavevmode\lower.7ex\copy\errorbox}
+
+% @tex ... @end tex    escapes into raw Tex temporarily.
+% One exception: @ is still an escape character, so that @end tex works.
+% But \@ or @@ will get a plain tex @ character.
+
+\def\tex{\begingroup
+\catcode `\\=0 \catcode `\{=1 \catcode `\}=2
+\catcode `\$=3 \catcode `\&=4 \catcode `\#=6
+\catcode `\^=7 \catcode `\_=8 \catcode `\~=13 \let~=\tie
+\catcode `\%=14
+\catcode 43=12
+\catcode`\"=12
+\catcode`\==12
+\catcode`\|=12
+\catcode`\<=12
+\catcode`\>=12
+\escapechar=`\\
+%
+\let\~=\ptextilde
+\let\{=\ptexlbrace
+\let\}=\ptexrbrace
+\let\.=\ptexdot
+\let\*=\ptexstar
+\let\dots=\ptexdots
+\def\@{@}%
+\let\bullet=\ptexbullet
+\let\b=\ptexb \let\c=\ptexc \let\i=\ptexi \let\t=\ptext \let\l=\ptexl
+\let\L=\ptexL
+%
+\let\Etex=\endgroup}
+
+% Define @lisp ... @endlisp.
+% @lisp does a \begingroup so it can rebind things,
+% including the definition of @endlisp (which normally is erroneous).
+
+% Amount to narrow the margins by for @lisp.
+\newskip\lispnarrowing \lispnarrowing=0.4in
+
+% This is the definition that ^^M gets inside @lisp, @example, and other
+% such environments.  \null is better than a space, since it doesn't
+% have any width.
+\def\lisppar{\null\endgraf}
+
+% Make each space character in the input produce a normal interword
+% space in the output.  Don't allow a line break at this space, as this
+% is used only in environments like @example, where each line of input
+% should produce a line of output anyway.
+%
+{\obeyspaces %
+\gdef\sepspaces{\obeyspaces\let =\tie}}
+
+% Define \obeyedspace to be our active space, whatever it is.  This is
+% for use in \parsearg.
+{\sepspaces%
+\global\let\obeyedspace= }
+
+% This space is always present above and below environments.
+\newskip\envskipamount \envskipamount = 0pt
+
+% Make spacing and below environment symmetrical.  We use \parskip here
+% to help in doing that, since in @example-like environments \parskip
+% is reset to zero; thus the \afterenvbreak inserts no space -- but the
+% start of the next paragraph will insert \parskip
+%
+\def\aboveenvbreak{{\advance\envskipamount by \parskip
+\endgraf \ifdim\lastskip<\envskipamount
+\removelastskip \penalty-50 \vskip\envskipamount \fi}}
+
+\let\afterenvbreak = \aboveenvbreak
+
+% \nonarrowing is a flag.  If "set", @lisp etc don't narrow margins.
+\let\nonarrowing=\relax
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+% \cartouche: draw rectangle w/rounded corners around argument
+\font\circle=lcircle10
+\newdimen\circthick
+\newdimen\cartouter\newdimen\cartinner
+\newskip\normbskip\newskip\normpskip\newskip\normlskip
+\circthick=\fontdimen8\circle
+%
+\def\ctl{{\circle\char'013\hskip -6pt}}% 6pt from pl file: 1/2charwidth
+\def\ctr{{\hskip 6pt\circle\char'010}}
+\def\cbl{{\circle\char'012\hskip -6pt}}
+\def\cbr{{\hskip 6pt\circle\char'011}}
+\def\carttop{\hbox to \cartouter{\hskip\lskip
+	\ctl\leaders\hrule height\circthick\hfil\ctr
+	\hskip\rskip}}
+\def\cartbot{\hbox to \cartouter{\hskip\lskip
+	\cbl\leaders\hrule height\circthick\hfil\cbr
+	\hskip\rskip}}
+%
+\newskip\lskip\newskip\rskip
+
+\long\def\cartouche{%
+\begingroup
+	\lskip=\leftskip \rskip=\rightskip
+	\leftskip=0pt\rightskip=0pt %we want these *outside*.
+	\cartinner=\hsize \advance\cartinner by-\lskip
+		 	  \advance\cartinner by-\rskip
+	\cartouter=\hsize
+	\advance\cartouter by 18pt % allow for 3pt kerns on either
+%				     side, and for 6pt waste from
+%				     each corner char
+	\normbskip=\baselineskip \normpskip=\parskip \normlskip=\lineskip
+	% Flag to tell @lisp, etc., not to narrow margin.
+	\let\nonarrowing=\comment
+	\vbox\bgroup
+		\baselineskip=0pt\parskip=0pt\lineskip=0pt
+		\carttop
+		\hbox\bgroup
+			\hskip\lskip
+			\vrule\kern3pt
+			\vbox\bgroup
+				\hsize=\cartinner
+				\kern3pt
+				\begingroup
+					\baselineskip=\normbskip
+					\lineskip=\normlskip
+					\parskip=\normpskip
+					\vskip -\parskip
+\def\Ecartouche{%
+				\endgroup
+				\kern3pt
+			\egroup
+			\kern3pt\vrule
+			\hskip\rskip
+		\egroup
+		\cartbot
+	\egroup
+\endgroup
+}}
+
+
+% This macro is called at the beginning of all the @example variants,
+% inside a group.
+\def\nonfillstart{%
+  \aboveenvbreak
+  \inENV % This group ends at the end of the body
+  \hfuzz = 12pt % Don't be fussy
+  \sepspaces % Make spaces be word-separators rather than space tokens.
+  \singlespace
+  \let\par = \lisppar % don't ignore blank lines
+  \obeylines % each line of input is a line of output
+  \parskip = 0pt
+  \parindent = 0pt
+  \emergencystretch = 0pt % don't try to avoid overfull boxes
+  % @cartouche defines \nonarrowing to inhibit narrowing
+  % at next level down.
+  \ifx\nonarrowing\relax
+    \advance \leftskip by \lispnarrowing
+    \exdentamount=\lispnarrowing
+    \let\exdent=\nofillexdent
+    \let\nonarrowing=\relax
+  \fi
+}
+
+% To ending an @example-like environment, we first end the paragraph
+% (via \afterenvbreak's vertical glue), and then the group.  That way we
+% keep the zero \parskip that the environments set -- \parskip glue
+% will be inserted at the beginning of the next paragraph in the
+% document, after the environment.
+%
+\def\nonfillfinish{\afterenvbreak\endgroup}%
+
+% This macro is
+\def\lisp{\begingroup
+  \nonfillstart
+  \let\Elisp = \nonfillfinish
+  \tt
+  \rawbackslash % have \ input char produce \ char from current font
+  \gobble
+}
+
+% Define the \E... control sequence only if we are inside the
+% environment, so the error checking in \end will work.
+%
+% We must call \lisp last in the definition, since it reads the
+% return following the @example (or whatever) command.
+%
+\def\example{\begingroup \def\Eexample{\nonfillfinish\endgroup}\lisp}
+\def\smallexample{\begingroup \def\Esmallexample{\nonfillfinish\endgroup}\lisp}
+\def\smalllisp{\begingroup \def\Esmalllisp{\nonfillfinish\endgroup}\lisp}
+
+% @smallexample and @smalllisp.  This is not used unless the @smallbook
+% command is given.  Originally contributed by Pavel@xerox.
+%
+\def\smalllispx{\begingroup
+  \nonfillstart
+  \let\Esmalllisp = \nonfillfinish
+  \let\Esmallexample = \nonfillfinish
+  %
+  % Smaller interline space and fonts for small examples.
+  \setleading{10pt}%
+  \indexfonts \tt
+  \rawbackslash % make \ output the \ character from the current font (tt)
+  \gobble
+}
+
+% This is @display; same as @lisp except use roman font.
+%
+\def\display{\begingroup
+  \nonfillstart
+  \let\Edisplay = \nonfillfinish
+  \gobble
+}
+
+% This is @format; same as @display except don't narrow margins.
+%
+\def\format{\begingroup
+  \let\nonarrowing = t
+  \nonfillstart
+  \let\Eformat = \nonfillfinish
+  \gobble
+}
+
+% @flushleft (same as @format) and @flushright.
+%
+\def\flushleft{\begingroup
+  \let\nonarrowing = t
+  \nonfillstart
+  \let\Eflushleft = \nonfillfinish
+  \gobble
+}
+\def\flushright{\begingroup
+  \let\nonarrowing = t
+  \nonfillstart
+  \let\Eflushright = \nonfillfinish
+  \advance\leftskip by 0pt plus 1fill
+  \gobble}
+
+% @quotation does normal linebreaking (hence we can't use \nonfillstart)
+% and narrows the margins.
+%
+\def\quotation{%
+  \begingroup\inENV %This group ends at the end of the @quotation body
+  {\parskip=0pt \aboveenvbreak}% because \aboveenvbreak inserts \parskip
+  \singlespace
+  \parindent=0pt
+  % We have retained a nonzero parskip for the environment, since we're
+  % doing normal filling. So to avoid extra space below the environment...
+  \def\Equotation{\parskip = 0pt \nonfillfinish}%
+  %
+  % @cartouche defines \nonarrowing to inhibit narrowing at next level down.
+  \ifx\nonarrowing\relax
+    \advance\leftskip by \lispnarrowing
+    \advance\rightskip by \lispnarrowing
+    \exdentamount = \lispnarrowing
+    \let\nonarrowing = \relax
+  \fi
+}
+
+\message{defuns,}
+% Define formatter for defuns
+% First, allow user to change definition object font (\df) internally
+\def\setdeffont #1 {\csname DEF#1\endcsname}
+
+\newskip\defbodyindent \defbodyindent=.4in
+\newskip\defargsindent \defargsindent=50pt
+\newskip\deftypemargin \deftypemargin=12pt
+\newskip\deflastargmargin \deflastargmargin=18pt
+
+\newcount\parencount
+% define \functionparens, which makes ( and ) and & do special things.
+% \functionparens affects the group it is contained in.
+\def\activeparens{%
+\catcode`\(=\active \catcode`\)=\active \catcode`\&=\active
+\catcode`\[=\active \catcode`\]=\active}
+
+% Make control sequences which act like normal parenthesis chars.
+\let\lparen = ( \let\rparen = )
+
+{\activeparens % Now, smart parens don't turn on until &foo (see \amprm)
+
+% Be sure that we always have a definition for `(', etc.  For example,
+% if the fn name has parens in it, \boldbrax will not be in effect yet,
+% so TeX would otherwise complain about undefined control sequence.
+\global\let(=\lparen \global\let)=\rparen
+\global\let[=\lbrack \global\let]=\rbrack
+
+\gdef\functionparens{\boldbrax\let&=\amprm\parencount=0 }
+\gdef\boldbrax{\let(=\opnr\let)=\clnr\let[=\lbrb\let]=\rbrb}
+% This is used to turn on special parens
+% but make & act ordinary (given that it's active).
+\gdef\boldbraxnoamp{\let(=\opnr\let)=\clnr\let[=\lbrb\let]=\rbrb\let&=\ampnr}
+
+% Definitions of (, ) and & used in args for functions.
+% This is the definition of ( outside of all parentheses.
+\gdef\oprm#1 {{\rm\char`\(}#1 \bf \let(=\opnested %
+\global\advance\parencount by 1 }
+%
+% This is the definition of ( when already inside a level of parens.
+\gdef\opnested{\char`\(\global\advance\parencount by 1 }
+%
+\gdef\clrm{% Print a paren in roman if it is taking us back to depth of 0.
+% also in that case restore the outer-level definition of (.
+\ifnum \parencount=1 {\rm \char `\)}\sl \let(=\oprm \else \char `\) \fi
+\global\advance \parencount by -1 }
+% If we encounter &foo, then turn on ()-hacking afterwards
+\gdef\amprm#1 {{\rm\&#1}\let(=\oprm \let)=\clrm\ }
+%
+\gdef\normalparens{\boldbrax\let&=\ampnr}
+} % End of definition inside \activeparens
+%% These parens (in \boldbrax) actually are a little bolder than the
+%% contained text.  This is especially needed for [ and ]
+\def\opnr{{\sf\char`\(}} \def\clnr{{\sf\char`\)}} \def\ampnr{\&}
+\def\lbrb{{\bf\char`\[}} \def\rbrb{{\bf\char`\]}}
+
+% First, defname, which formats the header line itself.
+% #1 should be the function name.
+% #2 should be the type of definition, such as "Function".
+
+\def\defname #1#2{%
+% Get the values of \leftskip and \rightskip as they were
+% outside the @def...
+\dimen2=\leftskip
+\advance\dimen2 by -\defbodyindent
+\dimen3=\rightskip
+\advance\dimen3 by -\defbodyindent
+\noindent        %
+\setbox0=\hbox{\hskip \deflastargmargin{\rm #2}\hskip \deftypemargin}%
+\dimen0=\hsize \advance \dimen0 by -\wd0 % compute size for first line
+\dimen1=\hsize \advance \dimen1 by -\defargsindent %size for continuations
+\parshape 2 0in \dimen0 \defargsindent \dimen1     %
+% Now output arg 2 ("Function" or some such)
+% ending at \deftypemargin from the right margin,
+% but stuck inside a box of width 0 so it does not interfere with linebreaking
+{% Adjust \hsize to exclude the ambient margins,
+% so that \rightline will obey them.
+\advance \hsize by -\dimen2 \advance \hsize by -\dimen3
+\rlap{\rightline{{\rm #2}\hskip \deftypemargin}}}%
+% Make all lines underfull and no complaints:
+\tolerance=10000 \hbadness=10000
+\advance\leftskip by -\defbodyindent
+\exdentamount=\defbodyindent
+{\df #1}\enskip        % Generate function name
+}
+
+% Actually process the body of a definition
+% #1 should be the terminating control sequence, such as \Edefun.
+% #2 should be the "another name" control sequence, such as \defunx.
+% #3 should be the control sequence that actually processes the header,
+%    such as \defunheader.
+
+\def\defparsebody #1#2#3{\begingroup\inENV% Environment for definitionbody
+\medbreak %
+% Define the end token that this defining construct specifies
+% so that it will exit this group.
+\def#1{\endgraf\endgroup\medbreak}%
+\def#2{\begingroup\obeylines\activeparens\spacesplit#3}%
+\parindent=0in
+\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\exdentamount=\defbodyindent
+\begingroup %
+\catcode 61=\active % 61 is `='
+\obeylines\activeparens\spacesplit#3}
+
+\def\defmethparsebody #1#2#3#4 {\begingroup\inENV %
+\medbreak %
+% Define the end token that this defining construct specifies
+% so that it will exit this group.
+\def#1{\endgraf\endgroup\medbreak}%
+\def#2##1 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}}}%
+\parindent=0in
+\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\exdentamount=\defbodyindent
+\begingroup\obeylines\activeparens\spacesplit{#3{#4}}}
+
+\def\defopparsebody #1#2#3#4#5 {\begingroup\inENV %
+\medbreak %
+% Define the end token that this defining construct specifies
+% so that it will exit this group.
+\def#1{\endgraf\endgroup\medbreak}%
+\def#2##1 ##2 {\def#4{##1}%
+\begingroup\obeylines\activeparens\spacesplit{#3{##2}}}%
+\parindent=0in
+\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\exdentamount=\defbodyindent
+\begingroup\obeylines\activeparens\spacesplit{#3{#5}}}
+
+% These parsing functions are similar to the preceding ones
+% except that they do not make parens into active characters.
+% These are used for "variables" since they have no arguments.
+
+\def\defvarparsebody #1#2#3{\begingroup\inENV% Environment for definitionbody
+\medbreak %
+% Define the end token that this defining construct specifies
+% so that it will exit this group.
+\def#1{\endgraf\endgroup\medbreak}%
+\def#2{\begingroup\obeylines\spacesplit#3}%
+\parindent=0in
+\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\exdentamount=\defbodyindent
+\begingroup %
+\catcode 61=\active %
+\obeylines\spacesplit#3}
+
+% This is used for \def{tp,vr}parsebody.  It could probably be used for
+% some of the others, too, with some judicious conditionals.
+% 
+\def\parsebodycommon#1#2#3{%
+  \begingroup\inENV %
+  \medbreak %
+  % Define the end token that this defining construct specifies
+  % so that it will exit this group.
+  \def#1{\endgraf\endgroup\medbreak}%
+  \def#2##1 {\begingroup\obeylines\spacesplit{#3{##1}}}%
+  \parindent=0in
+  \advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+  \exdentamount=\defbodyindent
+  \begingroup\obeylines
+}
+
+\def\defvrparsebody#1#2#3#4 {%
+  \parsebodycommon{#1}{#2}{#3}%
+  \spacesplit{#3{#4}}%
+}
+
+% This loses on `@deftp {Data Type} {struct termios}' -- it thinks the
+% type is just `struct', because we lose the braces in `{struct
+% termios}' when \spacesplit reads its undelimited argument.  Sigh.
+% \let\deftpparsebody=\defvrparsebody
+%
+% So, to get around this, we put \empty in with the type name.  That
+% way, TeX won't find exactly `{...}' as an undelimited argument, and
+% won't strip off the braces.
+%
+\def\deftpparsebody #1#2#3#4 {%
+  \parsebodycommon{#1}{#2}{#3}%
+  \spacesplit{\parsetpheaderline{#3{#4}}}\empty
+}
+
+% Fine, but then we have to eventually remove the \empty *and* the
+% braces (if any).  That's what this does, putting the result in \tptemp.
+% 
+\def\removeemptybraces\empty#1\relax{\def\tptemp{#1}}%
+
+% After \spacesplit has done its work, this is called -- #1 is the final
+% thing to call, #2 the type name (which starts with \empty), and #3
+% (which might be empty) the arguments.
+% 
+\def\parsetpheaderline#1#2#3{%
+  \removeemptybraces#2\relax
+  #1{\tptemp}{#3}%
+}%
+
+\def\defopvarparsebody #1#2#3#4#5 {\begingroup\inENV %
+\medbreak %
+% Define the end token that this defining construct specifies
+% so that it will exit this group.
+\def#1{\endgraf\endgroup\medbreak}%
+\def#2##1 ##2 {\def#4{##1}%
+\begingroup\obeylines\spacesplit{#3{##2}}}%
+\parindent=0in
+\advance\leftskip by \defbodyindent \advance \rightskip by \defbodyindent
+\exdentamount=\defbodyindent
+\begingroup\obeylines\spacesplit{#3{#5}}}
+
+% Split up #2 at the first space token.
+% call #1 with two arguments:
+%  the first is all of #2 before the space token,
+%  the second is all of #2 after that space token.
+% If #2 contains no space token, all of it is passed as the first arg
+% and the second is passed as empty.
+
+{\obeylines
+\gdef\spacesplit#1#2^^M{\endgroup\spacesplitfoo{#1}#2 \relax\spacesplitfoo}%
+\long\gdef\spacesplitfoo#1#2 #3#4\spacesplitfoo{%
+\ifx\relax #3%
+#1{#2}{}\else #1{#2}{#3#4}\fi}}
+
+% So much for the things common to all kinds of definitions.
+
+% Define @defun.
+
+% First, define the processing that is wanted for arguments of \defun
+% Use this to expand the args and terminate the paragraph they make up
+
+\def\defunargs #1{\functionparens \sl
+% Expand, preventing hyphenation at `-' chars.
+% Note that groups don't affect changes in \hyphenchar.
+\hyphenchar\tensl=0
+#1%
+\hyphenchar\tensl=45
+\ifnum\parencount=0 \else \errmessage{unbalanced parens in @def arguments}\fi%
+\interlinepenalty=10000
+\advance\rightskip by 0pt plus 1fil
+\endgraf\penalty 10000\vskip -\parskip\penalty 10000%
+}
+
+\def\deftypefunargs #1{%
+% Expand, preventing hyphenation at `-' chars.
+% Note that groups don't affect changes in \hyphenchar.
+% Use \boldbraxnoamp, not \functionparens, so that & is not special.
+\boldbraxnoamp
+\tclose{#1}% avoid \code because of side effects on active chars
+\interlinepenalty=10000
+\advance\rightskip by 0pt plus 1fil
+\endgraf\penalty 10000\vskip -\parskip\penalty 10000%
+}
+
+% Do complete processing of one @defun or @defunx line already parsed.
+
+% @deffn Command forward-char nchars
+
+\def\deffn{\defmethparsebody\Edeffn\deffnx\deffnheader}
+
+\def\deffnheader #1#2#3{\doind {fn}{\code{#2}}%
+\begingroup\defname {#2}{#1}\defunargs{#3}\endgroup %
+\catcode 61=\other % Turn off change made in \defparsebody
+}
+
+% @defun == @deffn Function
+
+\def\defun{\defparsebody\Edefun\defunx\defunheader}
+
+\def\defunheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
+\begingroup\defname {#1}{Function}%
+\defunargs {#2}\endgroup %
+\catcode 61=\other % Turn off change made in \defparsebody
+}
+
+% @deftypefun int foobar (int @var{foo}, float @var{bar})
+
+\def\deftypefun{\defparsebody\Edeftypefun\deftypefunx\deftypefunheader}
+
+% #1 is the data type.  #2 is the name and args.
+\def\deftypefunheader #1#2{\deftypefunheaderx{#1}#2 \relax}
+% #1 is the data type, #2 the name, #3 the args.
+\def\deftypefunheaderx #1#2 #3\relax{%
+\doind {fn}{\code{#2}}% Make entry in function index
+\begingroup\defname {\defheaderxcond#1\relax$$$#2}{Function}%
+\deftypefunargs {#3}\endgroup %
+\catcode 61=\other % Turn off change made in \defparsebody
+}
+
+% @deftypefn {Library Function} int foobar (int @var{foo}, float @var{bar})
+
+\def\deftypefn{\defmethparsebody\Edeftypefn\deftypefnx\deftypefnheader}
+
+% \defheaderxcond#1\relax$$$
+% puts #1 in @code, followed by a space, but does nothing if #1 is null.
+\def\defheaderxcond#1#2$$${\ifx#1\relax\else\code{#1#2} \fi}
+
+% #1 is the classification.  #2 is the data type.  #3 is the name and args.
+\def\deftypefnheader #1#2#3{\deftypefnheaderx{#1}{#2}#3 \relax}
+% #1 is the classification, #2 the data type, #3 the name, #4 the args.
+\def\deftypefnheaderx #1#2#3 #4\relax{%
+\doind {fn}{\code{#3}}% Make entry in function index
+\begingroup
+\normalparens % notably, turn off `&' magic, which prevents
+%               at least some C++ text from working
+\defname {\defheaderxcond#2\relax$$$#3}{#1}%
+\deftypefunargs {#4}\endgroup %
+\catcode 61=\other % Turn off change made in \defparsebody
+}
+
+% @defmac == @deffn Macro
+
+\def\defmac{\defparsebody\Edefmac\defmacx\defmacheader}
+
+\def\defmacheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
+\begingroup\defname {#1}{Macro}%
+\defunargs {#2}\endgroup %
+\catcode 61=\other % Turn off change made in \defparsebody
+}
+
+% @defspec == @deffn Special Form
+
+\def\defspec{\defparsebody\Edefspec\defspecx\defspecheader}
+
+\def\defspecheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
+\begingroup\defname {#1}{Special Form}%
+\defunargs {#2}\endgroup %
+\catcode 61=\other % Turn off change made in \defparsebody
+}
+
+% This definition is run if you use @defunx
+% anywhere other than immediately after a @defun or @defunx.
+
+\def\deffnx #1 {\errmessage{@deffnx in invalid context}}
+\def\defunx #1 {\errmessage{@defunx in invalid context}}
+\def\defmacx #1 {\errmessage{@defmacx in invalid context}}
+\def\defspecx #1 {\errmessage{@defspecx in invalid context}}
+\def\deftypefnx #1 {\errmessage{@deftypefnx in invalid context}}
+\def\deftypeunx #1 {\errmessage{@deftypeunx in invalid context}}
+
+% @defmethod, and so on
+
+% @defop {Funny Method} foo-class frobnicate argument
+
+\def\defop #1 {\def\defoptype{#1}%
+\defopparsebody\Edefop\defopx\defopheader\defoptype}
+
+\def\defopheader #1#2#3{%
+\dosubind {fn}{\code{#2}}{on #1}% Make entry in function index
+\begingroup\defname {#2}{\defoptype{} on #1}%
+\defunargs {#3}\endgroup %
+}
+
+% @defmethod == @defop Method
+
+\def\defmethod{\defmethparsebody\Edefmethod\defmethodx\defmethodheader}
+
+\def\defmethodheader #1#2#3{%
+\dosubind {fn}{\code{#2}}{on #1}% entry in function index
+\begingroup\defname {#2}{Method on #1}%
+\defunargs {#3}\endgroup %
+}
+
+% @defcv {Class Option} foo-class foo-flag
+
+\def\defcv #1 {\def\defcvtype{#1}%
+\defopvarparsebody\Edefcv\defcvx\defcvarheader\defcvtype}
+
+\def\defcvarheader #1#2#3{%
+\dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
+\begingroup\defname {#2}{\defcvtype{} of #1}%
+\defvarargs {#3}\endgroup %
+}
+
+% @defivar == @defcv {Instance Variable}
+
+\def\defivar{\defvrparsebody\Edefivar\defivarx\defivarheader}
+
+\def\defivarheader #1#2#3{%
+\dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
+\begingroup\defname {#2}{Instance Variable of #1}%
+\defvarargs {#3}\endgroup %
+}
+
+% These definitions are run if you use @defmethodx, etc.,
+% anywhere other than immediately after a @defmethod, etc.
+
+\def\defopx #1 {\errmessage{@defopx in invalid context}}
+\def\defmethodx #1 {\errmessage{@defmethodx in invalid context}}
+\def\defcvx #1 {\errmessage{@defcvx in invalid context}}
+\def\defivarx #1 {\errmessage{@defivarx in invalid context}}
+
+% Now @defvar
+
+% First, define the processing that is wanted for arguments of @defvar.
+% This is actually simple: just print them in roman.
+% This must expand the args and terminate the paragraph they make up
+\def\defvarargs #1{\normalparens #1%
+\interlinepenalty=10000
+\endgraf\penalty 10000\vskip -\parskip\penalty 10000}
+
+% @defvr Counter foo-count
+
+\def\defvr{\defvrparsebody\Edefvr\defvrx\defvrheader}
+
+\def\defvrheader #1#2#3{\doind {vr}{\code{#2}}%
+\begingroup\defname {#2}{#1}\defvarargs{#3}\endgroup}
+
+% @defvar == @defvr Variable
+
+\def\defvar{\defvarparsebody\Edefvar\defvarx\defvarheader}
+
+\def\defvarheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
+\begingroup\defname {#1}{Variable}%
+\defvarargs {#2}\endgroup %
+}
+
+% @defopt == @defvr {User Option}
+
+\def\defopt{\defvarparsebody\Edefopt\defoptx\defoptheader}
+
+\def\defoptheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
+\begingroup\defname {#1}{User Option}%
+\defvarargs {#2}\endgroup %
+}
+
+% @deftypevar int foobar
+
+\def\deftypevar{\defvarparsebody\Edeftypevar\deftypevarx\deftypevarheader}
+
+% #1 is the data type.  #2 is the name.
+\def\deftypevarheader #1#2{%
+\doind {vr}{\code{#2}}% Make entry in variables index
+\begingroup\defname {\defheaderxcond#1\relax$$$#2}{Variable}%
+\interlinepenalty=10000
+\endgraf\penalty 10000\vskip -\parskip\penalty 10000
+\endgroup}
+
+% @deftypevr {Global Flag} int enable
+
+\def\deftypevr{\defvrparsebody\Edeftypevr\deftypevrx\deftypevrheader}
+
+\def\deftypevrheader #1#2#3{\doind {vr}{\code{#3}}%
+\begingroup\defname {\defheaderxcond#2\relax$$$#3}{#1}
+\interlinepenalty=10000
+\endgraf\penalty 10000\vskip -\parskip\penalty 10000
+\endgroup}
+
+% This definition is run if you use @defvarx
+% anywhere other than immediately after a @defvar or @defvarx.
+
+\def\defvrx #1 {\errmessage{@defvrx in invalid context}}
+\def\defvarx #1 {\errmessage{@defvarx in invalid context}}
+\def\defoptx #1 {\errmessage{@defoptx in invalid context}}
+\def\deftypevarx #1 {\errmessage{@deftypevarx in invalid context}}
+\def\deftypevrx #1 {\errmessage{@deftypevrx in invalid context}}
+
+% Now define @deftp
+% Args are printed in bold, a slight difference from @defvar.
+
+\def\deftpargs #1{\bf \defvarargs{#1}}
+
+% @deftp Class window height width ...
+
+\def\deftp{\deftpparsebody\Edeftp\deftpx\deftpheader}
+
+\def\deftpheader #1#2#3{\doind {tp}{\code{#2}}%
+\begingroup\defname {#2}{#1}\deftpargs{#3}\endgroup}
+
+% This definition is run if you use @deftpx, etc
+% anywhere other than immediately after a @deftp, etc.
+
+\def\deftpx #1 {\errmessage{@deftpx in invalid context}}
+
+\message{cross reference,}
+% Define cross-reference macros
+\newwrite \auxfile
+
+\newif\ifhavexrefs  % True if xref values are known.
+\newif\ifwarnedxrefs  % True if we warned once that they aren't known.
+
+% \setref{foo} defines a cross-reference point named foo.
+
+\def\setref#1{%
+\dosetq{#1-title}{Ytitle}%
+\dosetq{#1-pg}{Ypagenumber}%
+\dosetq{#1-snt}{Ysectionnumberandtype}}
+
+\def\unnumbsetref#1{%
+\dosetq{#1-title}{Ytitle}%
+\dosetq{#1-pg}{Ypagenumber}%
+\dosetq{#1-snt}{Ynothing}}
+
+\def\appendixsetref#1{%
+\dosetq{#1-title}{Ytitle}%
+\dosetq{#1-pg}{Ypagenumber}%
+\dosetq{#1-snt}{Yappendixletterandtype}}
+
+% \xref, \pxref, and \ref generate cross-references to specified points.
+% For \xrefX, #1 is the node name, #2 the name of the Info
+% cross-reference, #3 the printed node name, #4 the name of the Info
+% file, #5 the name of the printed manual.  All but the node name can be
+% omitted.
+%
+\def\pxref#1{\putwordsee{} \xrefX[#1,,,,,,,]}
+\def\xref#1{\putwordSee{} \xrefX[#1,,,,,,,]}
+\def\ref#1{\xrefX[#1,,,,,,,]}
+\def\xrefX[#1,#2,#3,#4,#5,#6]{\begingroup
+  \def\printedmanual{\ignorespaces #5}%
+  \def\printednodename{\ignorespaces #3}%
+  \setbox1=\hbox{\printedmanual}%
+  \setbox0=\hbox{\printednodename}%
+  \ifdim \wd0 = 0pt
+    % No printed node name was explicitly given.
+    \ifx\SETxref-automatic-section-title\relax %
+      % Use the actual chapter/section title appear inside
+      % the square brackets.  Use the real section title if we have it.
+      \ifdim \wd1>0pt%
+        % It is in another manual, so we don't have it.
+        \def\printednodename{\ignorespaces #1}%
+      \else
+        \ifhavexrefs
+          % We know the real title if we have the xref values.
+          \def\printednodename{\refx{#1-title}}%
+        \else
+          % Otherwise just copy the Info node name.
+          \def\printednodename{\ignorespaces #1}%
+        \fi%
+      \fi
+      \def\printednodename{#1-title}%
+    \else
+      % Use the node name inside the square brackets.
+      \def\printednodename{\ignorespaces #1}%
+    \fi
+  \fi
+  %
+  % If we use \unhbox0 and \unhbox1 to print the node names, TeX does not
+  % insert empty discretionaries after hyphens, which means that it will
+  % not find a line break at a hyphen in a node names.  Since some manuals
+  % are best written with fairly long node names, containing hyphens, this
+  % is a loss.  Therefore, we give the text of the node name again, so it
+  % is as if TeX is seeing it for the first time.
+  \ifdim \wd1 > 0pt
+    \putwordsection{} ``\printednodename'' in \cite{\printedmanual}%
+  \else
+    % _ (for example) has to be the character _ for the purposes of the
+    % control sequence corresponding to the node, but it has to expand
+    % into the usual \leavevmode...\vrule stuff for purposes of
+    % printing. So we \turnoffactive for the \refx-snt, back on for the
+    % printing, back off for the \refx-pg.
+    {\turnoffactive \refx{#1-snt}{}}%
+    \space [\printednodename],\space
+    \turnoffactive \putwordpage\tie\refx{#1-pg}{}%
+  \fi
+\endgroup}
+
+% \dosetq is the interface for calls from other macros
+
+% Use \turnoffactive so that punctuation chars such as underscore
+% work in node names.
+\def\dosetq #1#2{{\let\folio=0 \turnoffactive \auxhat%
+\edef\next{\write\auxfile{\internalsetq {#1}{#2}}}%
+\next}}
+
+% \internalsetq {foo}{page} expands into
+% CHARACTERS 'xrdef {foo}{...expansion of \Ypage...}
+% When the aux file is read, ' is the escape character
+
+\def\internalsetq #1#2{'xrdef {#1}{\csname #2\endcsname}}
+
+% Things to be expanded by \internalsetq
+
+\def\Ypagenumber{\folio}
+
+\def\Ytitle{\thissection}
+
+\def\Ynothing{}
+
+\def\Ysectionnumberandtype{%
+\ifnum\secno=0 \putwordChapter\xreftie\the\chapno %
+\else \ifnum \subsecno=0 \putwordSection\xreftie\the\chapno.\the\secno %
+\else \ifnum \subsubsecno=0 %
+\putwordSection\xreftie\the\chapno.\the\secno.\the\subsecno %
+\else %
+\putwordSection\xreftie\the\chapno.\the\secno.\the\subsecno.\the\subsubsecno %
+\fi \fi \fi }
+
+\def\Yappendixletterandtype{%
+\ifnum\secno=0 \putwordAppendix\xreftie'char\the\appendixno{}%
+\else \ifnum \subsecno=0 \putwordSection\xreftie'char\the\appendixno.\the\secno %
+\else \ifnum \subsubsecno=0 %
+\putwordSection\xreftie'char\the\appendixno.\the\secno.\the\subsecno %
+\else %
+\putwordSection\xreftie'char\the\appendixno.\the\secno.\the\subsecno.\the\subsubsecno %
+\fi \fi \fi }
+
+\gdef\xreftie{'tie}
+
+% Use TeX 3.0's \inputlineno to get the line number, for better error
+% messages, but if we're using an old version of TeX, don't do anything.
+%
+\ifx\inputlineno\thisisundefined
+  \let\linenumber = \empty % Non-3.0.
+\else
+  \def\linenumber{\the\inputlineno:\space}
+\fi
+
+% Define \refx{NAME}{SUFFIX} to reference a cross-reference string named NAME.
+% If its value is nonempty, SUFFIX is output afterward.
+
+\def\refx#1#2{%
+  \expandafter\ifx\csname X#1\endcsname\relax
+    % If not defined, say something at least.
+    $\langle$un\-de\-fined$\rangle$%
+    \ifhavexrefs
+      \message{\linenumber Undefined cross reference `#1'.}%
+    \else
+      \ifwarnedxrefs\else
+        \global\warnedxrefstrue
+        \message{Cross reference values unknown; you must run TeX again.}%
+      \fi
+    \fi
+  \else
+    % It's defined, so just use it.
+    \csname X#1\endcsname
+  \fi
+  #2% Output the suffix in any case.
+}
+
+% Read the last existing aux file, if any.  No error if none exists.
+
+% This is the macro invoked by entries in the aux file.
+\def\xrdef #1#2{
+{\catcode`\'=\other\expandafter \gdef \csname X#1\endcsname {#2}}}
+
+\def\readauxfile{%
+\begingroup
+\catcode `\^^@=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\^^C=\other
+\catcode `\^^D=\other
+\catcode `\^^E=\other
+\catcode `\^^F=\other
+\catcode `\^^G=\other
+\catcode `\^^H=\other
+\catcode `\=\other
+\catcode `\^^L=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode `\=\other
+\catcode 26=\other
+\catcode `\^^[=\other
+\catcode `\^^\=\other
+\catcode `\^^]=\other
+\catcode `\^^^=\other
+\catcode `\^^_=\other
+\catcode `\@=\other
+\catcode `\^=\other
+\catcode `\~=\other
+\catcode `\[=\other
+\catcode `\]=\other
+\catcode`\"=\other
+\catcode`\_=\other
+\catcode`\|=\other
+\catcode`\<=\other
+\catcode`\>=\other
+\catcode `\$=\other
+\catcode `\#=\other
+\catcode `\&=\other
+% `\+ does not work, so use 43.
+\catcode 43=\other
+% Make the characters 128-255 be printing characters
+{%
+  \count 1=128
+  \def\loop{%
+    \catcode\count 1=\other
+    \advance\count 1 by 1
+    \ifnum \count 1<256 \loop \fi
+  }%
+}%
+% the aux file uses ' as the escape.
+% Turn off \ as an escape so we do not lose on
+% entries which were dumped with control sequences in their names.
+% For example, 'xrdef {$\leq $-fun}{page ...} made by @defun ^^
+% Reference to such entries still does not work the way one would wish,
+% but at least they do not bomb out when the aux file is read in.
+\catcode `\{=1 \catcode `\}=2
+\catcode `\%=\other
+\catcode `\'=0
+\catcode`\^=7 % to make ^^e4 etc usable in xref tags 
+\catcode `\\=\other
+\openin 1 \jobname.aux
+\ifeof 1 \else \closein 1 \input \jobname.aux \global\havexrefstrue
+\global\warnedobstrue
+\fi
+% Open the new aux file.  Tex will close it automatically at exit.
+\openout \auxfile=\jobname.aux
+\endgroup}
+
+
+% Footnotes.
+
+\newcount \footnoteno
+
+% The trailing space in the following definition for supereject is
+% vital for proper filling; pages come out unaligned when you do a
+% pagealignmacro call if that space before the closing brace is
+% removed.
+\def\supereject{\par\penalty -20000\footnoteno =0 }
+
+% @footnotestyle is meaningful for info output only..
+\let\footnotestyle=\comment
+
+\let\ptexfootnote=\footnote
+
+{\catcode `\@=11
+%
+% Auto-number footnotes.  Otherwise like plain.
+\gdef\footnote{%
+  \global\advance\footnoteno by \@ne
+  \edef\thisfootno{$^{\the\footnoteno}$}%
+  %
+  % In case the footnote comes at the end of a sentence, preserve the
+  % extra spacing after we do the footnote number.
+  \let\@sf\empty
+  \ifhmode\edef\@sf{\spacefactor\the\spacefactor}\/\fi
+  %
+  % Remove inadvertent blank space before typesetting the footnote number.
+  \unskip
+  \thisfootno\@sf
+  \footnotezzz
+}%
+
+% Don't bother with the trickery in plain.tex to not require the
+% footnote text as a parameter.  Our footnotes don't need to be so general.
+%
+\long\gdef\footnotezzz#1{\insert\footins{%
+  % We want to typeset this text as a normal paragraph, even if the
+  % footnote reference occurs in (for example) a display environment.
+  % So reset some parameters.
+  \interlinepenalty\interfootnotelinepenalty
+  \splittopskip\ht\strutbox % top baseline for broken footnotes
+  \splitmaxdepth\dp\strutbox
+  \floatingpenalty\@MM
+  \leftskip\z@skip
+  \rightskip\z@skip
+  \spaceskip\z@skip
+  \xspaceskip\z@skip
+  \parindent\defaultparindent
+  %
+  % Hang the footnote text off the number.
+  \hang
+  \textindent{\thisfootno}%
+  %
+  % Don't crash into the line above the footnote text.  Since this
+  % expands into a box, it must come within the paragraph, lest it
+  % provide a place where TeX can split the footnote.
+  \footstrut
+  #1\strut}%
+}
+
+}%end \catcode `\@=11
+
+% Set the baselineskip to #1, and the lineskip and strut size
+% correspondingly.  There is no deep meaning behind these magic numbers
+% used as factors; they just match (closely enough) what Knuth defined.
+%
+\def\lineskipfactor{.08333}
+\def\strutheightpercent{.70833}
+\def\strutdepthpercent {.29167}
+%
+\def\setleading#1{%
+  \normalbaselineskip = #1\relax
+  \normallineskip = \lineskipfactor\normalbaselineskip
+  \normalbaselines
+  \setbox\strutbox =\hbox{%
+    \vrule width0pt height\strutheightpercent\baselineskip
+                    depth \strutdepthpercent \baselineskip
+  }%
+}
+
+% @| inserts a changebar to the left of the current line.  It should
+% surround any changed text.  This approach does *not* work if the
+% change spans more than two lines of output.  To handle that, we would
+% have adopt a much more difficult approach (putting marks into the main
+% vertical list for the beginning and end of each change).
+%
+\def\|{%
+  % \vadjust can only be used in horizontal mode.
+  \leavevmode
+  %
+  % Append this vertical mode material after the current line in the output.
+  \vadjust{%
+    % We want to insert a rule with the height and depth of the current
+    % leading; that is exactly what \strutbox is supposed to record.
+    \vskip-\baselineskip
+    %
+    % \vadjust-items are inserted at the left edge of the type.  So
+    % the \llap here moves out into the left-hand margin.
+    \llap{%
+      %
+      % For a thicker or thinner bar, change the `1pt'.
+      \vrule height\baselineskip width1pt
+      %
+      % This is the space between the bar and the text.
+      \hskip 12pt
+    }%
+  }%
+}
+
+% For a final copy, take out the rectangles
+% that mark overfull boxes (in case you have decided
+% that the text looks ok even though it passes the margin).
+%
+\def\finalout{\overfullrule=0pt}
+
+
+% End of control word definitions.
+
+\message{and turning on texinfo input format.}
+
+\def\openindices{%
+   \newindex{cp}%
+   \newcodeindex{fn}%
+   \newcodeindex{vr}%
+   \newcodeindex{tp}%
+   \newcodeindex{ky}%
+   \newcodeindex{pg}%
+}
+
+% Set some numeric style parameters, for 8.5 x 11 format.
+
+%\hsize = 6.5in
+\newdimen\defaultparindent \defaultparindent = 15pt
+\parindent = \defaultparindent
+\parskip 18pt plus 1pt
+\setleading{15pt}
+\advance\topskip by 1.2cm
+
+% Prevent underfull vbox error messages.
+\vbadness=10000
+
+% Following George Bush, just get rid of widows and orphans.
+\widowpenalty=10000
+\clubpenalty=10000
+
+% Use TeX 3.0's \emergencystretch to help line breaking, but if we're
+% using an old version of TeX, don't do anything.  We want the amount of
+% stretch added to depend on the line length, hence the dependence on
+% \hsize.  This makes it come to about 9pt for the 8.5x11 format.
+%
+\ifx\emergencystretch\thisisundefined
+  % Allow us to assign to \emergencystretch anyway.
+  \def\emergencystretch{\dimen0}%
+\else
+  \emergencystretch = \hsize
+  \divide\emergencystretch by 45
+\fi
+
+% Use @smallbook to reset parameters for 7x9.5 format  (or else 7x9.25)
+\def\smallbook{
+
+% These values for secheadingskip and subsecheadingskip are
+% experiments.  RJC 7 Aug 1992
+\global\secheadingskip = 17pt plus 6pt minus 3pt
+\global\subsecheadingskip = 14pt plus 6pt minus 3pt
+
+\global\lispnarrowing = 0.3in
+\setleading{12pt}
+\advance\topskip by -1cm
+\global\parskip 3pt plus 1pt
+\global\hsize = 5in
+\global\vsize=7.5in
+\global\tolerance=700
+\global\hfuzz=1pt
+\global\contentsrightmargin=0pt
+\global\deftypemargin=0pt
+\global\defbodyindent=.5cm
+
+\global\pagewidth=\hsize
+\global\pageheight=\vsize
+
+\global\let\smalllisp=\smalllispx
+\global\let\smallexample=\smalllispx
+\global\def\Esmallexample{\Esmalllisp}
+}
+
+% Use @afourpaper to print on European A4 paper.
+\def\afourpaper{
+\global\tolerance=700
+\global\hfuzz=1pt
+\setleading{12pt}
+\global\parskip 15pt plus 1pt
+
+\global\vsize= 53\baselineskip
+\advance\vsize by \topskip
+%\global\hsize=   5.85in     % A4 wide 10pt
+\global\hsize=  6.5in
+\global\outerhsize=\hsize
+\global\advance\outerhsize by 0.5in
+\global\outervsize=\vsize
+\global\advance\outervsize by 0.6in
+
+\global\pagewidth=\hsize
+\global\pageheight=\vsize
+}
+
+% Allow control of the text dimensions.  Parameters in order: textheight;
+% textwidth; \voffset; \hoffset (!); binding offset.  All require a dimension;
+% header is additional; added length extends the bottom of the page.
+
+\def\changepagesizes#1#2#3#4#5{
+ \global\vsize= #1
+ \advance\vsize by \topskip
+ \global\voffset= #3
+ \global\hsize= #2
+ \global\outerhsize=\hsize
+ \global\advance\outerhsize by 0.5in
+ \global\outervsize=\vsize
+ \global\advance\outervsize by 0.6in
+ \global\pagewidth=\hsize
+ \global\pageheight=\vsize
+ \global\normaloffset= #4
+ \global\bindingoffset= #5}
+
+% This layout is compatible with Latex on A4 paper.
+
+\def\afourlatex{\changepagesizes{22cm}{15cm}{7mm}{4.6mm}{5mm}}
+
+% Use @afourwide to print on European A4 paper in wide format.
+\def\afourwide{\afourpaper
+\changepagesizes{9.5in}{6.5in}{\hoffset}{\normaloffset}{\bindingoffset}}
+
+% Define macros to output various characters with catcode for normal text.
+\catcode`\"=\other
+\catcode`\~=\other
+\catcode`\^=\other
+\catcode`\_=\other
+\catcode`\|=\other
+\catcode`\<=\other
+\catcode`\>=\other
+\catcode`\+=\other
+\def\normaldoublequote{"}
+\def\normaltilde{~}
+\def\normalcaret{^}
+\def\normalunderscore{_}
+\def\normalverticalbar{|}
+\def\normalless{<}
+\def\normalgreater{>}
+\def\normalplus{+}
+
+% This macro is used to make a character print one way in ttfont
+% where it can probably just be output, and another way in other fonts,
+% where something hairier probably needs to be done.
+%
+% #1 is what to print if we are indeed using \tt; #2 is what to print
+% otherwise.  Since all the Computer Modern typewriter fonts have zero
+% interword stretch (and shrink), and it is reasonable to expect all
+% typewriter fonts to have this, we can check that font parameter.
+%
+\def\ifusingtt#1#2{\ifdim \fontdimen3\the\font=0pt #1\else #2\fi}
+
+% Turn off all special characters except @
+% (and those which the user can use as if they were ordinary).
+% Most of these we simply print from the \tt font, but for some, we can
+% use math or other variants that look better in normal text.
+
+\catcode`\"=\active
+\def\activedoublequote{{\tt \char '042}}
+\let"=\activedoublequote
+\catcode`\~=\active
+\def~{{\tt \char '176}}
+\chardef\hat=`\^
+\catcode`\^=\active
+\def\auxhat{\def^{'hat}}
+\def^{{\tt \hat}}
+
+\catcode`\_=\active
+\def_{\ifusingtt\normalunderscore\_}
+% Subroutine for the previous macro.
+\def\_{\lvvmode \kern.06em \vbox{\hrule width.3em height.1ex}}
+
+% \lvvmode is equivalent in function to \leavevmode.
+% Using \leavevmode runs into trouble when written out to
+% an index file due to the expansion of \leavevmode into ``\unhbox
+% \voidb@x'' ---which looks to TeX like ``\unhbox \voidb\x'' due to our
+% magic tricks with @.
+\def\lvvmode{\vbox to 0pt{}}
+
+\catcode`\|=\active
+\def|{{\tt \char '174}}
+\chardef \less=`\<
+\catcode`\<=\active
+\def<{{\tt \less}}
+\chardef \gtr=`\>
+\catcode`\>=\active
+\def>{{\tt \gtr}}
+\catcode`\+=\active
+\def+{{\tt \char 43}}
+%\catcode 27=\active
+%\def^^[{$\diamondsuit$}
+
+% Set up an active definition for =, but don't enable it most of the time.
+{\catcode`\==\active
+\global\def={{\tt \char 61}}}
+
+\catcode`+=\active
+\catcode`\_=\active
+
+% If a .fmt file is being used, characters that might appear in a file
+% name cannot be active until we have parsed the command line.
+% So turn them off again, and have \everyjob (or @setfilename) turn them on.
+% \otherifyactive is called near the end of this file.
+\def\otherifyactive{\catcode`+=\other \catcode`\_=\other}
+
+\catcode`\@=0
+
+% \rawbackslashxx output one backslash character in current font
+\global\chardef\rawbackslashxx=`\\
+%{\catcode`\\=\other
+%@gdef@rawbackslashxx{\}}
+
+% \rawbackslash redefines \ as input to do \rawbackslashxx.
+{\catcode`\\=\active
+@gdef@rawbackslash{@let\=@rawbackslashxx }}
+
+% \normalbackslash outputs one backslash in fixed width font.
+\def\normalbackslash{{\tt\rawbackslashxx}}
+
+% Say @foo, not \foo, in error messages.
+\escapechar=`\@
+
+% \catcode 17=0   % Define control-q
+\catcode`\\=\active
+
+% Used sometimes to turn off (effectively) the active characters
+% even after parsing them.
+@def@turnoffactive{@let"=@normaldoublequote
+@let\=@realbackslash
+@let~=@normaltilde
+@let^=@normalcaret
+@let_=@normalunderscore
+@let|=@normalverticalbar
+@let<=@normalless
+@let>=@normalgreater
+@let+=@normalplus}
+
+@def@normalturnoffactive{@let"=@normaldoublequote
+@let\=@normalbackslash
+@let~=@normaltilde
+@let^=@normalcaret
+@let_=@normalunderscore
+@let|=@normalverticalbar
+@let<=@normalless
+@let>=@normalgreater
+@let+=@normalplus}
+
+% Make _ and + \other characters, temporarily.
+% This is canceled by @fixbackslash.
+@otherifyactive
+
+% If a .fmt file is being used, we don't want the `\input texinfo' to show up.
+% That is what \eatinput is for; after that, the `\' should revert to printing
+% a backslash.
+%
+@gdef@eatinput input texinfo{@fixbackslash}
+@global@let\ = @eatinput
+
+% On the other hand, perhaps the file did not have a `\input texinfo'. Then
+% the first `\{ in the file would cause an error. This macro tries to fix
+% that, assuming it is called before the first `\' could plausibly occur.
+% Also back turn on active characters that might appear in the input
+% file name, in case not using a pre-dumped format.
+%
+@gdef@fixbackslash{@ifx\@eatinput @let\ = @normalbackslash @fi
+  @catcode`+=@active @catcode`@_=@active}
+
+%% These look ok in all fonts, so just make them not special.  The @rm below
+%% makes sure that the current font starts out as the newly loaded cmr10
+@catcode`@$=@other @catcode`@%=@other @catcode`@&=@other @catcode`@#=@other
+
+@textfonts
+@rm
+
+@c Local variables:
+@c page-delimiter: "^\\\\message"
+@c End:
diff --git a/readline/emacs_keymap.c b/readline/emacs_keymap.c
new file mode 100644
--- /dev/null
+++ b/readline/emacs_keymap.c
@@ -0,0 +1,885 @@
+/* emacs_keymap.c -- the keymap for emacs_mode in readline (). */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (BUFSIZ)
+#include <stdio.h>
+#endif /* !BUFSIZ */
+
+#include "readline.h"
+
+/* An array of function pointers, one for each possible key.
+   If the type byte is ISKMAP, then the pointer is the address of
+   a keymap. */
+
+KEYMAP_ENTRY_ARRAY emacs_standard_keymap = {
+
+  /* Control keys. */
+  { ISFUNC, rl_set_mark },		/* Control-@ */
+  { ISFUNC, rl_beg_of_line },		/* Control-a */
+  { ISFUNC, rl_backward },		/* Control-b */
+  { ISFUNC, (Function *)0x0 },		/* Control-c */
+  { ISFUNC, rl_delete },		/* Control-d */
+  { ISFUNC, rl_end_of_line },		/* Control-e */
+  { ISFUNC, rl_forward },		/* Control-f */
+  { ISFUNC, rl_abort },			/* Control-g */
+  { ISFUNC, rl_rubout },		/* Control-h */
+  { ISFUNC, rl_complete },		/* Control-i */
+  { ISFUNC, rl_newline },		/* Control-j */
+  { ISFUNC, rl_kill_line },		/* Control-k */
+  { ISFUNC, rl_clear_screen },		/* Control-l */
+  { ISFUNC, rl_newline },		/* Control-m */
+  { ISFUNC, rl_get_next_history },	/* Control-n */
+  { ISFUNC, (Function *)0x0 },		/* Control-o */
+  { ISFUNC, rl_get_previous_history },	/* Control-p */
+  { ISFUNC, rl_quoted_insert },		/* Control-q */
+  { ISFUNC, rl_reverse_search_history }, /* Control-r */
+  { ISFUNC, rl_forward_search_history }, /* Control-s */
+  { ISFUNC, rl_transpose_chars },	/* Control-t */
+  { ISFUNC, rl_unix_line_discard },	/* Control-u */
+  { ISFUNC, rl_quoted_insert },		/* Control-v */
+  { ISFUNC, rl_unix_word_rubout },	/* Control-w */
+  { ISKMAP, (Function *)emacs_ctlx_keymap },	/* Control-x */
+  { ISFUNC, rl_yank },			/* Control-y */
+  { ISFUNC, (Function *)0x0 },		/* Control-z */
+  { ISKMAP, (Function *)emacs_meta_keymap }, /* Control-[ */
+  { ISFUNC, (Function *)0x0 },		/* Control-\ */
+  { ISFUNC, rl_char_search },		/* Control-] */
+  { ISFUNC, (Function *)0x0 },		/* Control-^ */
+  { ISFUNC, rl_undo_command },		/* Control-_ */
+
+  /* The start of printing characters. */
+  { ISFUNC, rl_insert },	/* SPACE */
+  { ISFUNC, rl_insert },	/* ! */
+  { ISFUNC, rl_insert },	/* " */
+  { ISFUNC, rl_insert },	/* # */
+  { ISFUNC, rl_insert },	/* $ */
+  { ISFUNC, rl_insert },	/* % */
+  { ISFUNC, rl_insert },	/* & */
+  { ISFUNC, rl_insert },	/* ' */
+  { ISFUNC, rl_insert },	/* ( */
+#if defined (PAREN_MATCHING)
+  { ISFUNC, rl_insert_close },	/* ) */
+#else
+  { ISFUNC, rl_insert },	/* ) */
+#endif /* !PAREN_MATCHING */
+  { ISFUNC, rl_insert },	/* * */
+  { ISFUNC, rl_insert },	/* + */
+  { ISFUNC, rl_insert },	/* , */
+  { ISFUNC, rl_insert },	/* - */
+  { ISFUNC, rl_insert },	/* . */
+  { ISFUNC, rl_insert },	/* / */
+
+  /* Regular digits. */
+  { ISFUNC, rl_insert },	/* 0 */
+  { ISFUNC, rl_insert },	/* 1 */
+  { ISFUNC, rl_insert },	/* 2 */
+  { ISFUNC, rl_insert },	/* 3 */
+  { ISFUNC, rl_insert },	/* 4 */
+  { ISFUNC, rl_insert },	/* 5 */
+  { ISFUNC, rl_insert },	/* 6 */
+  { ISFUNC, rl_insert },	/* 7 */
+  { ISFUNC, rl_insert },	/* 8 */
+  { ISFUNC, rl_insert },	/* 9 */
+
+  /* A little more punctuation. */
+  { ISFUNC, rl_insert },	/* : */
+  { ISFUNC, rl_insert },	/* ; */
+  { ISFUNC, rl_insert },	/* < */
+  { ISFUNC, rl_insert },	/* = */
+  { ISFUNC, rl_insert },	/* > */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* @ */
+
+  /* Uppercase alphabet. */
+  { ISFUNC, rl_insert },	/* A */
+  { ISFUNC, rl_insert },	/* B */
+  { ISFUNC, rl_insert },	/* C */
+  { ISFUNC, rl_insert },	/* D */
+  { ISFUNC, rl_insert },	/* E */
+  { ISFUNC, rl_insert },	/* F */
+  { ISFUNC, rl_insert },	/* G */
+  { ISFUNC, rl_insert },	/* H */
+  { ISFUNC, rl_insert },	/* I */
+  { ISFUNC, rl_insert },	/* J */
+  { ISFUNC, rl_insert },	/* K */
+  { ISFUNC, rl_insert },	/* L */
+  { ISFUNC, rl_insert },	/* M */
+  { ISFUNC, rl_insert },	/* N */
+  { ISFUNC, rl_insert },	/* O */
+  { ISFUNC, rl_insert },	/* P */
+  { ISFUNC, rl_insert },	/* Q */
+  { ISFUNC, rl_insert },	/* R */
+  { ISFUNC, rl_insert },	/* S */
+  { ISFUNC, rl_insert },	/* T */
+  { ISFUNC, rl_insert },	/* U */
+  { ISFUNC, rl_insert },	/* V */
+  { ISFUNC, rl_insert },	/* W */
+  { ISFUNC, rl_insert },	/* X */
+  { ISFUNC, rl_insert },	/* Y */
+  { ISFUNC, rl_insert },	/* Z */
+
+  /* Some more punctuation. */
+  { ISFUNC, rl_insert },	/* [ */
+  { ISFUNC, rl_insert },	/* \ */
+#if defined (PAREN_MATCHING)
+  { ISFUNC, rl_insert_close },	/* ] */
+#else
+  { ISFUNC, rl_insert },	/* ] */
+#endif /* !PAREN_MATCHING */
+  { ISFUNC, rl_insert },	/* ^ */
+  { ISFUNC, rl_insert },	/* _ */
+  { ISFUNC, rl_insert },	/* ` */
+
+  /* Lowercase alphabet. */
+  { ISFUNC, rl_insert },	/* a */
+  { ISFUNC, rl_insert },	/* b */
+  { ISFUNC, rl_insert },	/* c */
+  { ISFUNC, rl_insert },	/* d */
+  { ISFUNC, rl_insert },	/* e */
+  { ISFUNC, rl_insert },	/* f */
+  { ISFUNC, rl_insert },	/* g */
+  { ISFUNC, rl_insert },	/* h */
+  { ISFUNC, rl_insert },	/* i */
+  { ISFUNC, rl_insert },	/* j */
+  { ISFUNC, rl_insert },	/* k */
+  { ISFUNC, rl_insert },	/* l */
+  { ISFUNC, rl_insert },	/* m */
+  { ISFUNC, rl_insert },	/* n */
+  { ISFUNC, rl_insert },	/* o */
+  { ISFUNC, rl_insert },	/* p */
+  { ISFUNC, rl_insert },	/* q */
+  { ISFUNC, rl_insert },	/* r */
+  { ISFUNC, rl_insert },	/* s */
+  { ISFUNC, rl_insert },	/* t */
+  { ISFUNC, rl_insert },	/* u */
+  { ISFUNC, rl_insert },	/* v */
+  { ISFUNC, rl_insert },	/* w */
+  { ISFUNC, rl_insert },	/* x */
+  { ISFUNC, rl_insert },	/* y */
+  { ISFUNC, rl_insert },	/* z */
+
+  /* Final punctuation. */
+  { ISFUNC, rl_insert },	/* { */
+  { ISFUNC, rl_insert },	/* | */
+#if defined (PAREN_MATCHING)
+  { ISFUNC, rl_insert_close },	/* } */
+#else
+  { ISFUNC, rl_insert },	/* } */
+#endif /* !PAREN_MATCHING */
+  { ISFUNC, rl_insert },	/* ~ */
+  { ISFUNC, rl_rubout },	/* RUBOUT */
+
+#if KEYMAP_SIZE > 128
+  /* Pure 8-bit characters (128 - 159).
+     These might be used in some
+     character sets. */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+
+  /* ISO Latin-1 characters (160 - 255) */
+  { ISFUNC, rl_insert },	/* No-break space */
+  { ISFUNC, rl_insert },	/* Inverted exclamation mark */
+  { ISFUNC, rl_insert },	/* Cent sign */
+  { ISFUNC, rl_insert },	/* Pound sign */
+  { ISFUNC, rl_insert },	/* Currency sign */
+  { ISFUNC, rl_insert },	/* Yen sign */
+  { ISFUNC, rl_insert },	/* Broken bar */
+  { ISFUNC, rl_insert },	/* Section sign */
+  { ISFUNC, rl_insert },	/* Diaeresis */
+  { ISFUNC, rl_insert },	/* Copyright sign */
+  { ISFUNC, rl_insert },	/* Feminine ordinal indicator */
+  { ISFUNC, rl_insert },	/* Left pointing double angle quotation mark */
+  { ISFUNC, rl_insert },	/* Not sign */
+  { ISFUNC, rl_insert },	/* Soft hyphen */
+  { ISFUNC, rl_insert },	/* Registered sign */
+  { ISFUNC, rl_insert },	/* Macron */
+  { ISFUNC, rl_insert },	/* Degree sign */
+  { ISFUNC, rl_insert },	/* Plus-minus sign */
+  { ISFUNC, rl_insert },	/* Superscript two */
+  { ISFUNC, rl_insert },	/* Superscript three */
+  { ISFUNC, rl_insert },	/* Acute accent */
+  { ISFUNC, rl_insert },	/* Micro sign */
+  { ISFUNC, rl_insert },	/* Pilcrow sign */
+  { ISFUNC, rl_insert },	/* Middle dot */
+  { ISFUNC, rl_insert },	/* Cedilla */
+  { ISFUNC, rl_insert },	/* Superscript one */
+  { ISFUNC, rl_insert },	/* Masculine ordinal indicator */
+  { ISFUNC, rl_insert },	/* Right pointing double angle quotation mark */
+  { ISFUNC, rl_insert },	/* Vulgar fraction one quarter */
+  { ISFUNC, rl_insert },	/* Vulgar fraction one half */
+  { ISFUNC, rl_insert },	/* Vulgar fraction three quarters */
+  { ISFUNC, rl_insert },	/* Inverted questionk mark */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with tilde */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with ring above */
+  { ISFUNC, rl_insert },	/* Latin capital letter ae */
+  { ISFUNC, rl_insert },	/* Latin capital letter c with cedilla */
+  { ISFUNC, rl_insert },	/* Latin capital letter e with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter e with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter e with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter e with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin capital letter i with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter i with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter i with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter i with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin capital letter eth (Icelandic) */
+  { ISFUNC, rl_insert },	/* Latin capital letter n with tilde */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with tilde */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with diaeresis */
+  { ISFUNC, rl_insert },	/* Multiplication sign */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with stroke */
+  { ISFUNC, rl_insert },	/* Latin capital letter u with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter u with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter u with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter u with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin capital letter Y with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter thorn (Icelandic) */
+  { ISFUNC, rl_insert },	/* Latin small letter sharp s (German) */
+  { ISFUNC, rl_insert },	/* Latin small letter a with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter a with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter a with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter a with tilde */
+  { ISFUNC, rl_insert },	/* Latin small letter a with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin small letter a with ring above */
+  { ISFUNC, rl_insert },	/* Latin small letter ae */
+  { ISFUNC, rl_insert },	/* Latin small letter c with cedilla */
+  { ISFUNC, rl_insert },	/* Latin small letter e with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter e with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter e with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter e with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin small letter i with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter i with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter i with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter i with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin small letter eth (Icelandic) */
+  { ISFUNC, rl_insert },	/* Latin small letter n with tilde */
+  { ISFUNC, rl_insert },	/* Latin small letter o with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter o with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter o with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter o with tilde */
+  { ISFUNC, rl_insert },	/* Latin small letter o with diaeresis */
+  { ISFUNC, rl_insert },	/* Division sign */
+  { ISFUNC, rl_insert },	/* Latin small letter o with stroke */
+  { ISFUNC, rl_insert },	/* Latin small letter u with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter u with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter u with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter u with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin small letter y with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter thorn (Icelandic) */
+  { ISFUNC, rl_insert }		/* Latin small letter y with diaeresis */
+#endif /* KEYMAP_SIZE > 128 */
+};
+
+KEYMAP_ENTRY_ARRAY emacs_meta_keymap = {
+
+  /* Meta keys.  Just like above, but the high bit is set. */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-@ */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-a */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-b */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-c */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-d */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-e */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-f */
+  { ISFUNC, rl_abort },		/* Meta-Control-g */
+  { ISFUNC, rl_backward_kill_word },	/* Meta-Control-h */
+  { ISFUNC, rl_tab_insert },	/* Meta-Control-i */
+  { ISFUNC, rl_vi_editing_mode }, /* Meta-Control-j */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-k */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-l */
+  { ISFUNC, rl_vi_editing_mode }, /* Meta-Control-m */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-n */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-o */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-p */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-q */
+  { ISFUNC, rl_revert_line },	/* Meta-Control-r */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-s */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-t */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-u */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-v */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-w */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-x */
+  { ISFUNC, rl_yank_nth_arg },	/* Meta-Control-y */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-z */
+
+  { ISFUNC, rl_complete },	/* Meta-Control-[ */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-\ */
+  { ISFUNC, rl_backward_char_search },	/* Meta-Control-] */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-^ */
+  { ISFUNC, (Function *)0x0 },	/* Meta-Control-_ */
+
+  /* The start of printing characters. */
+  { ISFUNC, rl_set_mark },	/* Meta-SPACE */
+  { ISFUNC, (Function *)0x0 },	/* Meta-! */
+  { ISFUNC, (Function *)0x0 },	/* Meta-" */
+  { ISFUNC, rl_insert_comment },/* Meta-# */
+  { ISFUNC, (Function *)0x0 },	/* Meta-$ */
+  { ISFUNC, (Function *)0x0 },	/* Meta-% */
+  { ISFUNC, rl_tilde_expand },	/* Meta-& */
+  { ISFUNC, (Function *)0x0 },	/* Meta-' */
+  { ISFUNC, (Function *)0x0 },	/* Meta-( */
+  { ISFUNC, (Function *)0x0 },	/* Meta-) */
+  { ISFUNC, rl_insert_completions },	/* Meta-* */
+  { ISFUNC, (Function *)0x0 },	/* Meta-+ */
+  { ISFUNC, (Function *)0x0 },	/* Meta-, */
+  { ISFUNC, rl_digit_argument }, /* Meta-- */
+  { ISFUNC, rl_yank_last_arg},	/* Meta-. */
+  { ISFUNC, (Function *)0x0 },	/* Meta-/ */
+
+  /* Regular digits. */
+  { ISFUNC, rl_digit_argument }, /* Meta-0 */
+  { ISFUNC, rl_digit_argument }, /* Meta-1 */
+  { ISFUNC, rl_digit_argument }, /* Meta-2 */
+  { ISFUNC, rl_digit_argument }, /* Meta-3 */
+  { ISFUNC, rl_digit_argument }, /* Meta-4 */
+  { ISFUNC, rl_digit_argument }, /* Meta-5 */
+  { ISFUNC, rl_digit_argument }, /* Meta-6 */
+  { ISFUNC, rl_digit_argument }, /* Meta-7 */
+  { ISFUNC, rl_digit_argument }, /* Meta-8 */
+  { ISFUNC, rl_digit_argument }, /* Meta-9 */
+
+  /* A little more punctuation. */
+  { ISFUNC, (Function *)0x0 },		/* Meta-: */
+  { ISFUNC, (Function *)0x0 },		/* Meta-; */
+  { ISFUNC, rl_beginning_of_history },	/* Meta-< */
+  { ISFUNC, rl_possible_completions },	/* Meta-= */
+  { ISFUNC, rl_end_of_history },	/* Meta-> */
+  { ISFUNC, rl_possible_completions },	/* Meta-? */
+  { ISFUNC, (Function *)0x0 },		/* Meta-@ */
+
+  /* Uppercase alphabet. */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-A */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-B */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-C */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-D */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-E */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-F */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-G */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-H */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-I */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-J */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-K */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-L */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-M */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-N */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-O */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-P */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-Q */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-R */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-S */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-T */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-U */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-V */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-W */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-X */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-Y */
+  { ISFUNC, rl_do_lowercase_version },	/* Meta-Z */
+
+  /* Some more punctuation. */
+  { ISFUNC, (Function *)0x0 },		/* Meta-[ */	/* was rl_arrow_keys */
+  { ISFUNC, rl_delete_horizontal_space },	/* Meta-\ */
+  { ISFUNC, (Function *)0x0 },		/* Meta-] */
+  { ISFUNC, (Function *)0x0 },		/* Meta-^ */
+  { ISFUNC, rl_yank_last_arg },		/* Meta-_ */
+  { ISFUNC, (Function *)0x0 },		/* Meta-` */
+
+  /* Lowercase alphabet. */
+  { ISFUNC, (Function *)0x0 },	/* Meta-a */
+  { ISFUNC, rl_backward_word },	/* Meta-b */
+  { ISFUNC, rl_capitalize_word }, /* Meta-c */
+  { ISFUNC, rl_kill_word },	/* Meta-d */
+  { ISFUNC, (Function *)0x0 },	/* Meta-e */
+  { ISFUNC, rl_forward_word },	/* Meta-f */
+  { ISFUNC, (Function *)0x0 },	/* Meta-g */
+  { ISFUNC, (Function *)0x0 },	/* Meta-h */
+  { ISFUNC, (Function *)0x0 },	/* Meta-i */
+  { ISFUNC, (Function *)0x0 },	/* Meta-j */
+  { ISFUNC, (Function *)0x0 },	/* Meta-k */
+  { ISFUNC, rl_downcase_word },	/* Meta-l */
+  { ISFUNC, (Function *)0x0 },	/* Meta-m */
+  { ISFUNC, rl_noninc_forward_search },	/* Meta-n */
+  { ISFUNC, (Function *)0x0 },	/* Meta-o */	/* was rl_arrow_keys */
+  { ISFUNC, rl_noninc_reverse_search },	/* Meta-p */
+  { ISFUNC, (Function *)0x0 },	/* Meta-q */
+  { ISFUNC, rl_revert_line },	/* Meta-r */
+  { ISFUNC, (Function *)0x0 },	/* Meta-s */
+  { ISFUNC, rl_transpose_words }, /* Meta-t */
+  { ISFUNC, rl_upcase_word },	/* Meta-u */
+  { ISFUNC, (Function *)0x0 },	/* Meta-v */
+  { ISFUNC, (Function *)0x0 },	/* Meta-w */
+  { ISFUNC, (Function *)0x0 },	/* Meta-x */
+  { ISFUNC, rl_yank_pop },	/* Meta-y */
+  { ISFUNC, (Function *)0x0 },	/* Meta-z */
+
+  /* Final punctuation. */
+  { ISFUNC, (Function *)0x0 },	/* Meta-{ */
+  { ISFUNC, (Function *)0x0 },	/* Meta-| */
+  { ISFUNC, (Function *)0x0 },	/* Meta-} */
+  { ISFUNC, rl_tilde_expand },	/* Meta-~ */
+  { ISFUNC, rl_backward_kill_word }, /* Meta-rubout */
+
+#if KEYMAP_SIZE > 128
+  /* Undefined keys. */
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 }
+#endif /* KEYMAP_SIZE > 128 */
+};
+
+KEYMAP_ENTRY_ARRAY emacs_ctlx_keymap = {
+
+  /* Control keys. */
+  { ISFUNC, (Function *)0x0 },		/* Control-@ */
+  { ISFUNC, (Function *)0x0 },		/* Control-a */
+  { ISFUNC, (Function *)0x0 },		/* Control-b */
+  { ISFUNC, (Function *)0x0 },		/* Control-c */
+  { ISFUNC, (Function *)0x0 },		/* Control-d */
+  { ISFUNC, (Function *)0x0 },		/* Control-e */
+  { ISFUNC, (Function *)0x0 },		/* Control-f */
+  { ISFUNC, rl_abort },			/* Control-g */
+  { ISFUNC, (Function *)0x0 },		/* Control-h */
+  { ISFUNC, (Function *)0x0 },		/* Control-i */
+  { ISFUNC, (Function *)0x0 },		/* Control-j */
+  { ISFUNC, (Function *)0x0 },		/* Control-k */
+  { ISFUNC, (Function *)0x0 },		/* Control-l */
+  { ISFUNC, (Function *)0x0 },		/* Control-m */
+  { ISFUNC, (Function *)0x0 },		/* Control-n */
+  { ISFUNC, (Function *)0x0 },		/* Control-o */
+  { ISFUNC, (Function *)0x0 },		/* Control-p */
+  { ISFUNC, (Function *)0x0 },		/* Control-q */
+  { ISFUNC, rl_re_read_init_file },	/* Control-r */
+  { ISFUNC, (Function *)0x0 },		/* Control-s */
+  { ISFUNC, (Function *)0x0 },		/* Control-t */
+  { ISFUNC, rl_undo_command },		/* Control-u */
+  { ISFUNC, (Function *)0x0 },		/* Control-v */
+  { ISFUNC, (Function *)0x0 },		/* Control-w */
+  { ISFUNC, rl_exchange_point_and_mark },/* Control-x */
+  { ISFUNC, (Function *)0x0 },		/* Control-y */
+  { ISFUNC, (Function *)0x0 },		/* Control-z */
+  { ISFUNC, (Function *)0x0 },		/* Control-[ */
+  { ISFUNC, (Function *)0x0 },		/* Control-\ */
+  { ISFUNC, (Function *)0x0 },		/* Control-] */
+  { ISFUNC, (Function *)0x0 },		/* Control-^ */
+  { ISFUNC, (Function *)0x0 },		/* Control-_ */
+
+  /* The start of printing characters. */
+  { ISFUNC, (Function *)0x0 },		/* SPACE */
+  { ISFUNC, (Function *)0x0 },		/* ! */
+  { ISFUNC, (Function *)0x0 },		/* " */
+  { ISFUNC, (Function *)0x0 },		/* # */
+  { ISFUNC, (Function *)0x0 },		/* $ */
+  { ISFUNC, (Function *)0x0 },		/* % */
+  { ISFUNC, (Function *)0x0 },		/* & */
+  { ISFUNC, (Function *)0x0 },		/* ' */
+  { ISFUNC, rl_start_kbd_macro },	/* ( */
+  { ISFUNC, rl_end_kbd_macro  },	/* ) */
+  { ISFUNC, (Function *)0x0 },		/* * */
+  { ISFUNC, (Function *)0x0 },		/* + */
+  { ISFUNC, (Function *)0x0 },		/* , */
+  { ISFUNC, (Function *)0x0 },		/* - */
+  { ISFUNC, (Function *)0x0 },		/* . */
+  { ISFUNC, (Function *)0x0 },		/* / */
+
+  /* Regular digits. */
+  { ISFUNC, (Function *)0x0 },		/* 0 */
+  { ISFUNC, (Function *)0x0 },		/* 1 */
+  { ISFUNC, (Function *)0x0 },		/* 2 */
+  { ISFUNC, (Function *)0x0 },		/* 3 */
+  { ISFUNC, (Function *)0x0 },		/* 4 */
+  { ISFUNC, (Function *)0x0 },		/* 5 */
+  { ISFUNC, (Function *)0x0 },		/* 6 */
+  { ISFUNC, (Function *)0x0 },		/* 7 */
+  { ISFUNC, (Function *)0x0 },		/* 8 */
+  { ISFUNC, (Function *)0x0 },		/* 9 */
+
+  /* A little more punctuation. */
+  { ISFUNC, (Function *)0x0 },	/* : */
+  { ISFUNC, (Function *)0x0 },	/* ; */
+  { ISFUNC, (Function *)0x0 },	/* < */
+  { ISFUNC, (Function *)0x0 },	/* = */
+  { ISFUNC, (Function *)0x0 },	/* > */
+  { ISFUNC, (Function *)0x0 },	/* ? */
+  { ISFUNC, (Function *)0x0 },	/* @ */
+
+  /* Uppercase alphabet. */
+  { ISFUNC, rl_do_lowercase_version },	/* A */
+  { ISFUNC, rl_do_lowercase_version },	/* B */
+  { ISFUNC, rl_do_lowercase_version },	/* C */
+  { ISFUNC, rl_do_lowercase_version },	/* D */
+  { ISFUNC, rl_do_lowercase_version },	/* E */
+  { ISFUNC, rl_do_lowercase_version },	/* F */
+  { ISFUNC, rl_do_lowercase_version },	/* G */
+  { ISFUNC, rl_do_lowercase_version },	/* H */
+  { ISFUNC, rl_do_lowercase_version },	/* I */
+  { ISFUNC, rl_do_lowercase_version },	/* J */
+  { ISFUNC, rl_do_lowercase_version },	/* K */
+  { ISFUNC, rl_do_lowercase_version },	/* L */
+  { ISFUNC, rl_do_lowercase_version },	/* M */
+  { ISFUNC, rl_do_lowercase_version },	/* N */
+  { ISFUNC, rl_do_lowercase_version },	/* O */
+  { ISFUNC, rl_do_lowercase_version },	/* P */
+  { ISFUNC, rl_do_lowercase_version },	/* Q */
+  { ISFUNC, rl_do_lowercase_version },	/* R */
+  { ISFUNC, rl_do_lowercase_version },	/* S */
+  { ISFUNC, rl_do_lowercase_version },	/* T */
+  { ISFUNC, rl_do_lowercase_version },	/* U */
+  { ISFUNC, rl_do_lowercase_version },	/* V */
+  { ISFUNC, rl_do_lowercase_version },	/* W */
+  { ISFUNC, rl_do_lowercase_version },	/* X */
+  { ISFUNC, rl_do_lowercase_version },	/* Y */
+  { ISFUNC, rl_do_lowercase_version },	/* Z */
+
+  /* Some more punctuation. */
+  { ISFUNC, (Function *)0x0 },		/* [ */
+  { ISFUNC, (Function *)0x0 },		/* \ */
+  { ISFUNC, (Function *)0x0 },		/* ] */
+  { ISFUNC, (Function *)0x0 },		/* ^ */
+  { ISFUNC, (Function *)0x0 },		/* _ */
+  { ISFUNC, (Function *)0x0 },		/* ` */
+
+  /* Lowercase alphabet. */
+  { ISFUNC, (Function *)0x0 },		/* a */
+  { ISFUNC, (Function *)0x0 },		/* b */
+  { ISFUNC, (Function *)0x0 },		/* c */
+  { ISFUNC, (Function *)0x0 },		/* d */
+  { ISFUNC, rl_call_last_kbd_macro },	/* e */
+  { ISFUNC, (Function *)0x0 },		/* f */
+  { ISFUNC, (Function *)0x0 },		/* g */
+  { ISFUNC, (Function *)0x0 },		/* h */
+  { ISFUNC, (Function *)0x0 },		/* i */
+  { ISFUNC, (Function *)0x0 },		/* j */
+  { ISFUNC, (Function *)0x0 },		/* k */
+  { ISFUNC, (Function *)0x0 },		/* l */
+  { ISFUNC, (Function *)0x0 },		/* m */
+  { ISFUNC, (Function *)0x0 },		/* n */
+  { ISFUNC, (Function *)0x0 },		/* o */
+  { ISFUNC, (Function *)0x0 },		/* p */
+  { ISFUNC, (Function *)0x0 },		/* q */
+  { ISFUNC, (Function *)0x0 },		/* r */
+  { ISFUNC, (Function *)0x0 },		/* s */
+  { ISFUNC, (Function *)0x0 },		/* t */
+  { ISFUNC, (Function *)0x0 },		/* u */
+  { ISFUNC, (Function *)0x0 },		/* v */
+  { ISFUNC, (Function *)0x0 },		/* w */
+  { ISFUNC, (Function *)0x0 },		/* x */
+  { ISFUNC, (Function *)0x0 },		/* y */
+  { ISFUNC, (Function *)0x0 },		/* z */
+
+  /* Final punctuation. */
+  { ISFUNC, (Function *)0x0 },		/* { */
+  { ISFUNC, (Function *)0x0 },		/* | */
+  { ISFUNC, (Function *)0x0 },		/* } */
+  { ISFUNC, (Function *)0x0 },		/* ~ */
+  { ISFUNC, rl_backward_kill_line },	/* RUBOUT */
+
+#if KEYMAP_SIZE > 128
+  /* Undefined keys. */
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 }
+#endif /* KEYMAP_SIZE > 128 */
+};
diff --git a/readline/examples/Inputrc b/readline/examples/Inputrc
new file mode 100644
--- /dev/null
+++ b/readline/examples/Inputrc
@@ -0,0 +1,65 @@
+# My ~/.inputrc file is in -*- text -*- for easy editing with Emacs.
+#
+# Notice the various bindings which are conditionalized depending
+# on which program is running, or what terminal is active.
+#
+
+# In all programs, all terminals, make sure this is bound.
+"\C-x\C-r": re-read-init-file
+
+# Hp terminals (and some others) have ugly default behaviour for C-h.
+"\C-h": backward-delete-char
+"\e\C-h": backward-kill-word
+"\C-xd": dump-functions
+
+# In xterm windows, make the arrow keys do the right thing.
+$if TERM=xterm
+"\e[A": previous-history
+"\e[B": next-history
+"\e[C": forward-char
+"\e[D": backward-char
+
+# alternate arrow key prefix
+"\eOA": previous-history
+"\eOB": next-history
+"\eOC": forward-char
+"\eOD": backward-char
+
+# Under Xterm in Bash, we bind local Function keys to do something useful.
+$if Bash
+"\e[11~": "Function Key 1"
+"\e[12~": "Function Key 2"
+"\e[13~": "Function Key 3"
+"\e[14~": "Function Key 4"
+"\e[15~": "Function Key 5"
+
+# I know the following escape sequence numbers are 1 greater than
+# the function key.  Don't ask me why, I didn't design the xterm terminal.
+"\e[17~": "Function Key 6"
+"\e[18~": "Function Key 7"
+"\e[19~": "Function Key 8"
+"\e[20~": "Function Key 9"
+"\e[21~": "Function Key 10"
+$endif
+$endif
+
+# For Bash, all terminals, add some Bash specific hacks.
+$if Bash
+"\C-xv": show-bash-version
+"\C-x\C-e": shell-expand-line
+
+# Here is one for editing my path.
+"\C-xp": "$PATH\C-x\C-e\C-e\"\C-aPATH=\":\C-b"
+
+# Make C-x r read my mail in emacs.
+# "\C-xr": "emacs -f rmail\C-j"
+$endif
+
+# For FTP, different hacks:
+$if Ftp
+"\C-xg": "get \M-?"
+"\C-xt": "put \M-?"
+"\M-.": yank-last-arg
+$endif
+
+" ": self-insert
diff --git a/readline/examples/Makefile.in b/readline/examples/Makefile.in
new file mode 100644
--- /dev/null
+++ b/readline/examples/Makefile.in
@@ -0,0 +1,37 @@
+# This is the Makefile for the examples subdirectory of readline. -*- text -*-
+#
+srcdir = @srcdir@
+VPATH = .:@srcdir@
+top_srcdir = @top_srcdir@
+BUILD_DIR = .
+
+DEFS = @DEFS@
+CC = @CC@
+CFLAGS = @CFLAGS@
+LOCAL_CFLAGS = @LOCAL_CFLAGS@
+CPPFLAGS = @CPPFLAGS@
+
+INCLUDES = -I $(srcdir) -I $(top_srcdir) -I..
+
+CCFLAGS  = $(DEFS) $(LOCAL_CFLAGS) $(CPPFLAGS) $(INCLUDES) $(CFLAGS)
+LDFLAGS = -g -L..
+
+.c.o:
+	$(CC) $(CCFLAGS) -c $<
+
+EXECUTABLES = fileman rltest rl
+
+all: $(EXECUTABLES)
+
+rl: rl.o
+	$(CC) $(LDFLAGS) -o $@ rl.o -lreadline -ltermcap
+
+fileman: fileman.o
+	$(CC) $(LDFLAGS) -o $@ fileman.o -lreadline -ltermcap
+
+rltest: rltest.o
+	$(CC) $(LDFLAGS) -o $@ rltest.o -lreadline -ltermcap
+
+fileman.o: $(srcdir)/fileman.c
+rltest.o: $(srcdir)/rltest.c
+rl.o: $(srcdir)/rl.c
diff --git a/readline/examples/fileman.c b/readline/examples/fileman.c
new file mode 100644
--- /dev/null
+++ b/readline/examples/fileman.c
@@ -0,0 +1,450 @@
+/* fileman.c -- A tiny application which demonstrates how to use the
+   GNU Readline library.  This application interactively allows users
+   to manipulate files and their modes. */
+/*
+ * Remove the next line if you're compiling this against an installed
+ * libreadline.a
+ */
+#define READLINE_LIBRARY
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sys/types.h>
+#ifdef HAVE_SYS_FILE_H
+#include <sys/file.h>
+#endif
+#include <sys/stat.h>
+
+#include <stdio.h>
+#include <errno.h>
+
+#if defined (HAVE_STRING_H)
+#  include <string.h>
+#else /* !HAVE_STRING_H */
+#  include <strings.h>
+#endif /* !HAVE_STRING_H */
+
+#ifdef READLINE_LIBRARY
+#  include "readline.h"
+#  include "history.h"
+#else
+#  include <readline/readline.h>
+#  include <readline/history.h>
+#endif
+
+extern char *getwd ();
+extern char *xmalloc ();
+
+/* The names of functions that actually do the manipulation. */
+int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
+int com_delete (), com_help (), com_cd (), com_quit ();
+
+/* A structure which contains information on the commands this program
+   can understand. */
+
+typedef struct {
+  char *name;			/* User printable name of the function. */
+  Function *func;		/* Function to call to do the job. */
+  char *doc;			/* Documentation for this function.  */
+} COMMAND;
+
+COMMAND commands[] = {
+  { "cd", com_cd, "Change to directory DIR" },
+  { "delete", com_delete, "Delete FILE" },
+  { "help", com_help, "Display this text" },
+  { "?", com_help, "Synonym for `help'" },
+  { "list", com_list, "List files in DIR" },
+  { "ls", com_list, "Synonym for `list'" },
+  { "pwd", com_pwd, "Print the current working directory" },
+  { "quit", com_quit, "Quit using Fileman" },
+  { "rename", com_rename, "Rename FILE to NEWNAME" },
+  { "stat", com_stat, "Print out statistics on FILE" },
+  { "view", com_view, "View the contents of FILE" },
+  { (char *)NULL, (Function *)NULL, (char *)NULL }
+};
+
+/* Forward declarations. */
+char *stripwhite ();
+COMMAND *find_command ();
+
+/* The name of this program, as taken from argv[0]. */
+char *progname;
+
+/* When non-zero, this global means the user is done using this program. */
+int done;
+
+char *
+dupstr (s)
+     char *s;
+{
+  char *r;
+
+  r = xmalloc (strlen (s) + 1);
+  strcpy (r, s);
+  return (r);
+}
+
+main (argc, argv)
+     int argc;
+     char **argv;
+{
+  char *line, *s;
+
+  progname = argv[0];
+
+  initialize_readline ();	/* Bind our completer. */
+
+  /* Loop reading and executing lines until the user quits. */
+  for ( ; done == 0; )
+    {
+      line = readline ("FileMan: ");
+
+      if (!line)
+        break;
+
+      /* Remove leading and trailing whitespace from the line.
+         Then, if there is anything left, add it to the history list
+         and execute it. */
+      s = stripwhite (line);
+
+      if (*s)
+        {
+          add_history (s);
+          execute_line (s);
+        }
+
+      free (line);
+    }
+  exit (0);
+}
+
+/* Execute a command line. */
+int
+execute_line (line)
+     char *line;
+{
+  register int i;
+  COMMAND *command;
+  char *word;
+
+  /* Isolate the command word. */
+  i = 0;
+  while (line[i] && whitespace (line[i]))
+    i++;
+  word = line + i;
+
+  while (line[i] && !whitespace (line[i]))
+    i++;
+
+  if (line[i])
+    line[i++] = '\0';
+
+  command = find_command (word);
+
+  if (!command)
+    {
+      fprintf (stderr, "%s: No such command for FileMan.\n", word);
+      return (-1);
+    }
+
+  /* Get argument to command, if any. */
+  while (whitespace (line[i]))
+    i++;
+
+  word = line + i;
+
+  /* Call the function. */
+  return ((*(command->func)) (word));
+}
+
+/* Look up NAME as the name of a command, and return a pointer to that
+   command.  Return a NULL pointer if NAME isn't a command name. */
+COMMAND *
+find_command (name)
+     char *name;
+{
+  register int i;
+
+  for (i = 0; commands[i].name; i++)
+    if (strcmp (name, commands[i].name) == 0)
+      return (&commands[i]);
+
+  return ((COMMAND *)NULL);
+}
+
+/* Strip whitespace from the start and end of STRING.  Return a pointer
+   into STRING. */
+char *
+stripwhite (string)
+     char *string;
+{
+  register char *s, *t;
+
+  for (s = string; whitespace (*s); s++)
+    ;
+    
+  if (*s == 0)
+    return (s);
+
+  t = s + strlen (s) - 1;
+  while (t > s && whitespace (*t))
+    t--;
+  *++t = '\0';
+
+  return s;
+}
+
+/* **************************************************************** */
+/*                                                                  */
+/*                  Interface to Readline Completion                */
+/*                                                                  */
+/* **************************************************************** */
+
+char *command_generator ();
+char **fileman_completion ();
+
+/* Tell the GNU Readline library how to complete.  We want to try to complete
+   on command names if this is the first word in the line, or on filenames
+   if not. */
+initialize_readline ()
+{
+  /* Allow conditional parsing of the ~/.inputrc file. */
+  rl_readline_name = "FileMan";
+
+  /* Tell the completer that we want a crack first. */
+  rl_attempted_completion_function = (CPPFunction *)fileman_completion;
+}
+
+/* Attempt to complete on the contents of TEXT.  START and END bound the
+   region of rl_line_buffer that contains the word to complete.  TEXT is
+   the word to complete.  We can use the entire contents of rl_line_buffer
+   in case we want to do some simple parsing.  Return the array of matches,
+   or NULL if there aren't any. */
+char **
+fileman_completion (text, start, end)
+     char *text;
+     int start, end;
+{
+  char **matches;
+
+  matches = (char **)NULL;
+
+  /* If this word is at the start of the line, then it is a command
+     to complete.  Otherwise it is the name of a file in the current
+     directory. */
+  if (start == 0)
+    matches = completion_matches (text, command_generator);
+
+  return (matches);
+}
+
+/* Generator function for command completion.  STATE lets us know whether
+   to start from scratch; without any state (i.e. STATE == 0), then we
+   start at the top of the list. */
+char *
+command_generator (text, state)
+     char *text;
+     int state;
+{
+  static int list_index, len;
+  char *name;
+
+  /* If this is a new word to complete, initialize now.  This includes
+     saving the length of TEXT for efficiency, and initializing the index
+     variable to 0. */
+  if (!state)
+    {
+      list_index = 0;
+      len = strlen (text);
+    }
+
+  /* Return the next name which partially matches from the command list. */
+  while (name = commands[list_index].name)
+    {
+      list_index++;
+
+      if (strncmp (name, text, len) == 0)
+        return (dupstr(name));
+    }
+
+  /* If no names matched, then return NULL. */
+  return ((char *)NULL);
+}
+
+/* **************************************************************** */
+/*                                                                  */
+/*                       FileMan Commands                           */
+/*                                                                  */
+/* **************************************************************** */
+
+/* String to pass to system ().  This is for the LIST, VIEW and RENAME
+   commands. */
+static char syscom[1024];
+
+/* List the file(s) named in arg. */
+com_list (arg)
+     char *arg;
+{
+  if (!arg)
+    arg = "";
+
+  sprintf (syscom, "ls -FClg %s", arg);
+  return (system (syscom));
+}
+
+com_view (arg)
+     char *arg;
+{
+  if (!valid_argument ("view", arg))
+    return 1;
+
+  sprintf (syscom, "more %s", arg);
+  return (system (syscom));
+}
+
+com_rename (arg)
+     char *arg;
+{
+  too_dangerous ("rename");
+  return (1);
+}
+
+com_stat (arg)
+     char *arg;
+{
+  struct stat finfo;
+
+  if (!valid_argument ("stat", arg))
+    return (1);
+
+  if (stat (arg, &finfo) == -1)
+    {
+      perror (arg);
+      return (1);
+    }
+
+  printf ("Statistics for `%s':\n", arg);
+
+  printf ("%s has %d link%s, and is %d byte%s in length.\n",
+	  arg,
+          finfo.st_nlink,
+          (finfo.st_nlink == 1) ? "" : "s",
+          finfo.st_size,
+          (finfo.st_size == 1) ? "" : "s");
+  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
+  printf ("      Last access at: %s", ctime (&finfo.st_atime));
+  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
+  return (0);
+}
+
+com_delete (arg)
+     char *arg;
+{
+  too_dangerous ("delete");
+  return (1);
+}
+
+/* Print out help for ARG, or for all of the commands if ARG is
+   not present. */
+com_help (arg)
+     char *arg;
+{
+  register int i;
+  int printed = 0;
+
+  for (i = 0; commands[i].name; i++)
+    {
+      if (!*arg || (strcmp (arg, commands[i].name) == 0))
+        {
+          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
+          printed++;
+        }
+    }
+
+  if (!printed)
+    {
+      printf ("No commands match `%s'.  Possibilties are:\n", arg);
+
+      for (i = 0; commands[i].name; i++)
+        {
+          /* Print in six columns. */
+          if (printed == 6)
+            {
+              printed = 0;
+              printf ("\n");
+            }
+
+          printf ("%s\t", commands[i].name);
+          printed++;
+        }
+
+      if (printed)
+        printf ("\n");
+    }
+  return (0);
+}
+
+/* Change to the directory ARG. */
+com_cd (arg)
+     char *arg;
+{
+  if (chdir (arg) == -1)
+    {
+      perror (arg);
+      return 1;
+    }
+
+  com_pwd ("");
+  return (0);
+}
+
+/* Print out the current working directory. */
+com_pwd (ignore)
+     char *ignore;
+{
+  char dir[1024], *s;
+
+  s = getwd (dir);
+  if (s == 0)
+    {
+      printf ("Error getting pwd: %s\n", dir);
+      return 1;
+    }
+
+  printf ("Current directory is %s\n", dir);
+  return 0;
+}
+
+/* The user wishes to quit using this program.  Just set DONE non-zero. */
+com_quit (arg)
+     char *arg;
+{
+  done = 1;
+  return (0);
+}
+
+/* Function which tells you that you can't do this. */
+too_dangerous (caller)
+     char *caller;
+{
+  fprintf (stderr,
+           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
+           caller);
+}
+
+/* Return non-zero if ARG is a valid argument for CALLER, else print
+   an error message and return zero. */
+int
+valid_argument (caller, arg)
+     char *caller, *arg;
+{
+  if (!arg || !*arg)
+    {
+      fprintf (stderr, "%s: Argument required.\n", caller);
+      return (0);
+    }
+
+  return (1);
+}
diff --git a/readline/examples/histexamp.c b/readline/examples/histexamp.c
new file mode 100644
--- /dev/null
+++ b/readline/examples/histexamp.c
@@ -0,0 +1,82 @@
+main ()
+{
+  char line[1024], *t;
+  int len, done = 0;
+
+  line[0] = 0;
+
+  using_history ();
+  while (!done)
+    {
+      printf ("history$ ");
+      fflush (stdout);
+      t = fgets (line, sizeof (line) - 1, stdin);
+      if (t && *t)
+        {
+          len = strlen (t);
+          if (t[len - 1] == '\n')
+            t[len - 1] = '\0';
+        }
+
+      if (!t)
+        strcpy (line, "quit");
+
+      if (line[0])
+        {
+          char *expansion;
+          int result;
+
+          using_history ();
+
+          result = history_expand (line, &expansion);
+          if (result)
+            fprintf (stderr, "%s\n", expansion);
+
+          if (result < 0 || result == 2)
+            {
+              free (expansion);
+              continue;
+            }
+
+          add_history (expansion);
+          strncpy (line, expansion, sizeof (line) - 1);
+          free (expansion);
+        }
+
+      if (strcmp (line, "quit") == 0)
+        done = 1;
+      else if (strcmp (line, "save") == 0)
+        write_history ("history_file");
+      else if (strcmp (line, "read") == 0)
+        read_history ("history_file");
+      else if (strcmp (line, "list") == 0)
+        {
+          register HIST_ENTRY **the_list;
+          register int i;
+
+          the_list = history_list ();
+          if (the_list)
+            for (i = 0; the_list[i]; i++)
+              printf ("%d: %s\n", i + history_base, the_list[i]->line);
+        }
+      else if (strncmp (line, "delete", 6) == 0)
+        {
+          int which;
+          if ((sscanf (line + 6, "%d", &which)) == 1)
+            {
+              HIST_ENTRY *entry = remove_history (which);
+              if (!entry)
+                fprintf (stderr, "No such entry %d\n", which);
+              else
+                {
+                  free (entry->line);
+                  free (entry);
+                }
+            }
+          else
+            {
+              fprintf (stderr, "non-numeric arg given to `delete'\n");
+            }
+        }
+    }
+}
diff --git a/readline/examples/manexamp.c b/readline/examples/manexamp.c
new file mode 100644
--- /dev/null
+++ b/readline/examples/manexamp.c
@@ -0,0 +1,94 @@
+/* manexamp.c -- The examples which appear in the documentation are here. */
+
+#include <stdio.h>
+#include <readline/readline.h>
+
+
+/* **************************************************************** */
+/*                                                                  */
+*   			How to Emulate gets ()			    */
+/*                                                                  */
+/* **************************************************************** */
+
+/* A static variable for holding the line. */
+static char *line_read = (char *)NULL;
+
+/* Read a string, and return a pointer to it.  Returns NULL on EOF. */
+char *
+rl_gets ()
+{
+  /* If the buffer has already been allocated, return the memory
+     to the free pool. */
+  if (line_read)
+    {
+      free (line_read);
+      line_read = (char *)NULL;
+    }
+
+  /* Get a line from the user. */
+  line_read = readline ("");
+
+  /* If the line has any text in it, save it on the history. */
+  if (line_read && *line_read)
+    add_history (line_read);
+
+  return (line_read);
+}
+
+/* **************************************************************** */
+/*                                                                  */
+/*        Writing a Function to be Called by Readline.              */
+/*                                                                  */
+/* **************************************************************** */
+
+/* Invert the case of the COUNT following characters. */
+invert_case_line (count, key)
+     int count, key;
+{
+  register int start, end;
+
+  start = rl_point;
+
+  if (count < 0)
+    {
+      direction = -1;
+      count = -count;
+    }
+  else
+    direction = 1;
+      
+  /* Find the end of the range to modify. */
+  end = start + (count * direction);
+
+  /* Force it to be within range. */
+  if (end > rl_end)
+    end = rl_end;
+  else if (end < 0)
+    end = -1;
+
+  if (start > end)
+    {
+      int temp = start;
+      start = end;
+      end = temp;
+    }
+
+  if (start == end)
+    return;
+
+  /* Tell readline that we are modifying the line, so save the undo
+     information. */
+  rl_modifying (start, end);
+
+  for (; start != end; start += direction)
+    {
+      if (uppercase_p (rl_line_buffer[start]))
+	rl_line_buffer[start] = to_lower (rl_line_buffer[start]);
+      else if (lowercase_p (rl_line_buffer[start]))
+	rl_line_buffer[start] = to_upper (rl_line_buffer[start]);
+    }
+
+  /* Move point to on top of the last character changed. */
+  rl_point = end - direction;
+}
+
diff --git a/readline/examples/rl.c b/readline/examples/rl.c
new file mode 100644
--- /dev/null
+++ b/readline/examples/rl.c
@@ -0,0 +1,115 @@
+/*
+ * rl - command-line interface to read a line from the standard input
+ *      (or another fd) using readline.
+ *
+ * usage: rl [-p prompt] [-u unit] [-d default]
+ */
+
+/*
+ * Remove the next line if you're compiling this against an installed
+ * libreadline.a
+ */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <sys/types.h>
+#include "posixstat.h"
+#include "readline.h"
+#include "history.h"
+
+extern int optind;
+extern char *optarg;
+
+extern char *strrchr();
+
+static char *progname;
+static char *deftext;
+
+static int
+set_deftext ()
+{
+  if (deftext)
+    {
+      rl_insert_text (deftext);
+      deftext = (char *)NULL;
+      rl_startup_hook = (Function *)NULL;
+    }
+}
+
+usage()
+{
+  fprintf (stderr, "%s: usage: %s [-p prompt] [-u unit] [-d default]\n",
+		progname, progname);
+}
+
+main (argc, argv)
+     int argc;
+     char **argv;
+{
+  char *temp, *prompt;
+  struct stat sb;
+  int done, opt, fd;
+  FILE *ifp;
+
+  progname = strrchr(argv[0], '/');
+  if (progname == 0)
+    progname = argv[0];
+  else
+    progname++;
+
+  /* defaults */
+  prompt = "readline$ ";
+  fd = 0;
+  deftext = (char *)0;
+
+  while ((opt = getopt(argc, argv, "p:u:d:")) != EOF)
+    {
+      switch (opt)
+	{
+	case 'p':
+	  prompt = optarg;
+	  break;
+	case 'u':
+	  fd = atoi(optarg);
+	  if (fd < 0)
+	    {
+	      fprintf (stderr, "%s: bad file descriptor `%s'\n", progname, optarg);
+	      exit (2);
+	    }
+	  break;
+	case 'd':
+	  deftext = optarg;
+	  break;
+	default:
+	  usage ();
+	  exit (2);
+	}
+    }
+
+  if (fd != 0)
+    {
+      if (fstat (fd, &sb) < 0)
+	{
+	  fprintf (stderr, "%s: %d: bad file descriptor\n", progname, fd);
+	  exit (1);
+	}
+      ifp = fdopen (fd, "r");
+      rl_instream = ifp;
+    }
+
+  if (deftext && *deftext)
+    rl_startup_hook = set_deftext;
+
+  temp = readline (prompt);
+
+  /* Test for EOF. */
+  if (temp == 0)
+    exit (1);
+
+  puts (temp);
+  exit (0);
+}
diff --git a/readline/examples/rltest.c b/readline/examples/rltest.c
new file mode 100644
--- /dev/null
+++ b/readline/examples/rltest.c
@@ -0,0 +1,64 @@
+/* **************************************************************** */
+/*								    */
+/*			Testing Readline			    */
+/*								    */
+/* **************************************************************** */
+
+/*
+ * Remove the next line if you're compiling this against an installed
+ * libreadline.a
+ */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <sys/types.h>
+#include "readline.h"
+#include "history.h"
+
+main ()
+{
+  HIST_ENTRY **history_list ();
+  char *temp = (char *)NULL;
+  char *prompt = "readline$ ";
+  int done = 0;
+
+  while (!done)
+    {
+      temp = readline (prompt);
+
+      /* Test for EOF. */
+      if (!temp)
+	exit (1);
+
+      /* If there is anything on the line, print it and remember it. */
+      if (*temp)
+	{
+	  fprintf (stderr, "%s\r\n", temp);
+	  add_history (temp);
+	}
+
+      /* Check for `command' that we handle. */
+      if (strcmp (temp, "quit") == 0)
+	done = 1;
+
+      if (strcmp (temp, "list") == 0)
+	{
+	  HIST_ENTRY **list = history_list ();
+	  register int i;
+	  if (list)
+	    {
+	      for (i = 0; list[i]; i++)
+		{
+		  fprintf (stderr, "%d: %s\r\n", i, list[i]->line);
+		  free (list[i]->line);
+		}
+	      free (list);
+	    }
+	}
+      free (temp);
+    }
+}
diff --git a/readline/funmap.c b/readline/funmap.c
new file mode 100644
--- /dev/null
+++ b/readline/funmap.c
@@ -0,0 +1,248 @@
+/* funmap.c -- attach names to functions. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+extern char *xmalloc (), *xrealloc ();
+
+#if !defined (BUFSIZ)
+#include <stdio.h>
+#endif /* BUFSIZ */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include "rlconf.h"
+#include "readline.h"
+
+extern int _rl_qsort_string_compare ();
+
+FUNMAP **funmap;
+static int funmap_size;
+static int funmap_entry;
+
+/* After initializing the function map, this is the index of the first
+   program specific function. */
+int funmap_program_specific_entry_start;
+
+static FUNMAP default_funmap[] = {
+  { "abort", rl_abort },
+  { "accept-line", rl_newline },
+  { "arrow-key-prefix", rl_arrow_keys },
+  { "backward-char", rl_backward },
+  { "backward-delete-char", rl_rubout },
+  { "backward-kill-line", rl_backward_kill_line },
+  { "backward-kill-word", rl_backward_kill_word },
+  { "backward-word", rl_backward_word },
+  { "beginning-of-history", rl_beginning_of_history },
+  { "beginning-of-line", rl_beg_of_line },
+  { "call-last-kbd-macro", rl_call_last_kbd_macro },
+  { "capitalize-word", rl_capitalize_word },
+  { "character-search", rl_char_search },
+  { "character-search-backward", rl_backward_char_search },
+  { "clear-screen", rl_clear_screen },
+  { "complete", rl_complete },
+  { "copy-backward-word", rl_copy_backward_word },
+  { "copy-forward-word", rl_copy_forward_word },
+  { "copy-region-as-kill", rl_copy_region_to_kill },
+  { "delete-char", rl_delete },
+  { "delete-horizontal-space", rl_delete_horizontal_space },
+  { "digit-argument", rl_digit_argument },
+  { "do-lowercase-version", rl_do_lowercase_version },
+  { "downcase-word", rl_downcase_word },
+  { "dump-functions", rl_dump_functions },
+  { "dump-macros", rl_dump_macros },
+  { "dump-variables", rl_dump_variables },
+  { "emacs-editing-mode", rl_emacs_editing_mode },
+  { "end-kbd-macro", rl_end_kbd_macro },
+  { "end-of-history", rl_end_of_history },
+  { "end-of-line", rl_end_of_line },
+  { "exchange-point-and-mark", rl_exchange_point_and_mark },
+  { "forward-char", rl_forward },
+  { "forward-search-history", rl_forward_search_history },
+  { "forward-word", rl_forward_word },
+  { "history-search-backward", rl_history_search_backward },
+  { "history-search-forward", rl_history_search_forward },
+  { "insert-comment", rl_insert_comment },
+  { "insert-completions", rl_insert_completions },
+  { "kill-whole-line", rl_kill_full_line },
+  { "kill-line", rl_kill_line },
+  { "kill-region", rl_kill_region },
+  { "kill-word", rl_kill_word },
+  { "next-history", rl_get_next_history },
+  { "non-incremental-forward-search-history", rl_noninc_forward_search },
+  { "non-incremental-reverse-search-history", rl_noninc_reverse_search },
+  { "non-incremental-forward-search-history-again", rl_noninc_forward_search_again },
+  { "non-incremental-reverse-search-history-again", rl_noninc_reverse_search_again },
+  { "possible-completions", rl_possible_completions },
+  { "previous-history", rl_get_previous_history },
+  { "quoted-insert", rl_quoted_insert },
+  { "re-read-init-file", rl_re_read_init_file },
+  { "redraw-current-line", rl_refresh_line},
+  { "reverse-search-history", rl_reverse_search_history },
+  { "revert-line", rl_revert_line },
+  { "self-insert", rl_insert },
+  { "set-mark", rl_set_mark },
+  { "start-kbd-macro", rl_start_kbd_macro },
+  { "tab-insert", rl_tab_insert },
+  { "tilde-expand", rl_tilde_expand },
+  { "transpose-chars", rl_transpose_chars },
+  { "transpose-words", rl_transpose_words },
+  { "tty-status", rl_tty_status },
+  { "undo", rl_undo_command },
+  { "universal-argument", rl_universal_argument },
+  { "unix-line-discard", rl_unix_line_discard },
+  { "unix-word-rubout", rl_unix_word_rubout },
+  { "upcase-word", rl_upcase_word },
+  { "yank", rl_yank },
+  { "yank-last-arg", rl_yank_last_arg },
+  { "yank-nth-arg", rl_yank_nth_arg },
+  { "yank-pop", rl_yank_pop },
+
+#if defined (VI_MODE)
+  { "vi-append-eol", rl_vi_append_eol },
+  { "vi-append-mode", rl_vi_append_mode },
+  { "vi-arg-digit", rl_vi_arg_digit },
+  { "vi-back-to-indent", rl_vi_back_to_indent },
+  { "vi-bWord", rl_vi_bWord },
+  { "vi-bracktype", rl_vi_bracktype },
+  { "vi-bword", rl_vi_bword },
+  { "vi-change-case", rl_vi_change_case },
+  { "vi-change-char", rl_vi_change_char },
+  { "vi-change-to", rl_vi_change_to },
+  { "vi-char-search", rl_vi_char_search },
+  { "vi-column", rl_vi_column },
+  { "vi-complete", rl_vi_complete },
+  { "vi-delete", rl_vi_delete },
+  { "vi-delete-to", rl_vi_delete_to },
+  { "vi-eWord", rl_vi_eWord },
+  { "vi-editing-mode", rl_vi_editing_mode },
+  { "vi-end-word", rl_vi_end_word },
+  { "vi-eof-maybe", rl_vi_eof_maybe },
+  { "vi-eword", rl_vi_eword },
+  { "vi-fWord", rl_vi_fWord },
+  { "vi-fetch-history", rl_vi_fetch_history },
+  { "vi-first-print", rl_vi_first_print },
+  { "vi-fword", rl_vi_fword },
+  { "vi-goto-mark", rl_vi_goto_mark },
+  { "vi-insert-beg", rl_vi_insert_beg },
+  { "vi-insertion-mode", rl_vi_insertion_mode },
+  { "vi-match", rl_vi_match },
+  { "vi-movement-mode", rl_vi_movement_mode },
+  { "vi-next-word", rl_vi_next_word },
+  { "vi-overstrike", rl_vi_overstrike },
+  { "vi-overstrike-delete", rl_vi_overstrike_delete },
+  { "vi-prev-word", rl_vi_prev_word },
+  { "vi-put", rl_vi_put },
+  { "vi-redo", rl_vi_redo },
+  { "vi-replace", rl_vi_replace },
+  { "vi-search", rl_vi_search },
+  { "vi-search-again", rl_vi_search_again },
+  { "vi-set-mark", rl_vi_set_mark },
+  { "vi-subst", rl_vi_subst },
+  { "vi-tilde-expand", rl_vi_tilde_expand },
+  { "vi-yank-arg", rl_vi_yank_arg },
+  { "vi-yank-to", rl_vi_yank_to },
+#endif /* VI_MODE */
+
+ {(char *)NULL, (Function *)NULL }
+};
+
+int
+rl_add_funmap_entry (name, function)
+     char *name;
+     Function *function;
+{
+  if (funmap_entry + 2 >= funmap_size)
+    {
+      funmap_size += 64;
+      funmap = (FUNMAP **)xrealloc (funmap, funmap_size * sizeof (FUNMAP *));
+    }
+  
+  funmap[funmap_entry] = (FUNMAP *)xmalloc (sizeof (FUNMAP));
+  funmap[funmap_entry]->name = name;
+  funmap[funmap_entry]->function = function;
+
+  funmap[++funmap_entry] = (FUNMAP *)NULL;
+  return funmap_entry;
+}
+
+static int funmap_initialized;
+
+/* Make the funmap contain all of the default entries. */
+void
+rl_initialize_funmap ()
+{
+  register int i;
+
+  if (funmap_initialized)
+    return;
+
+  for (i = 0; default_funmap[i].name; i++)
+    rl_add_funmap_entry (default_funmap[i].name, default_funmap[i].function);
+
+  funmap_initialized = 1;
+  funmap_program_specific_entry_start = i;
+}
+
+/* Produce a NULL terminated array of known function names.  The array
+   is sorted.  The array itself is allocated, but not the strings inside.
+   You should free () the array when you done, but not the pointrs. */
+char **
+rl_funmap_names ()
+{
+  char **result;
+  int result_size, result_index;
+
+  /* Make sure that the function map has been initialized. */
+  rl_initialize_funmap ();
+
+  for (result_index = result_size = 0, result = (char **)NULL; funmap[result_index]; result_index++)
+    {
+      if (result_index + 2 > result_size)
+	{
+	  result_size += 20;
+	  result = (char **)xrealloc (result, result_size * sizeof (char *));
+	}
+
+      result[result_index] = funmap[result_index]->name;
+      result[result_index + 1] = (char *)NULL;
+    }
+
+  qsort (result, result_index, sizeof (char *), _rl_qsort_string_compare);
+  return (result);
+}
+
+/* Things that mean `Control'. */
+char *possible_control_prefixes[] = {
+  "Control-", "C-", "CTRL-", (char *)NULL
+};
+
+char *possible_meta_prefixes[] = {
+  "Meta", "M-", (char *)NULL
+};
diff --git a/readline/histexpand.c b/readline/histexpand.c
new file mode 100644
--- /dev/null
+++ b/readline/histexpand.c
@@ -0,0 +1,1321 @@
+/* histexpand.c -- history expansion. */
+
+/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
+
+   This file contains the GNU History Library (the Library), a set of
+   routines for managing the text of previously typed lines.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#if defined (HAVE_STRING_H)
+#  include <string.h>
+#else
+#  include <strings.h>
+#endif /* !HAVE_STRING_H */
+
+#include "history.h"
+#include "histlib.h"
+
+static char error_pointer;
+
+static char *subst_lhs;
+static char *subst_rhs;
+static int subst_lhs_len;
+static int subst_rhs_len;
+
+static char *get_history_word_specifier ();
+static char *history_find_word ();
+
+extern int history_offset;
+
+extern char *single_quote ();
+static char *quote_breaks ();
+
+extern char *xmalloc (), *xrealloc ();
+
+/* Variables exported by this file. */
+/* The character that represents the start of a history expansion
+   request.  This is usually `!'. */
+char history_expansion_char = '!';
+
+/* The character that invokes word substitution if found at the start of
+   a line.  This is usually `^'. */
+char history_subst_char = '^';
+
+/* During tokenization, if this character is seen as the first character
+   of a word, then it, and all subsequent characters upto a newline are
+   ignored.  For a Bourne shell, this should be '#'.  Bash special cases
+   the interactive comment character to not be a comment delimiter. */
+char history_comment_char = '\0';
+
+/* The list of characters which inhibit the expansion of text if found
+   immediately following history_expansion_char. */
+char *history_no_expand_chars = " \t\n\r=";
+
+/* If set to a non-zero value, single quotes inhibit history expansion.
+   The default is 0. */
+int history_quotes_inhibit_expansion = 0;
+
+/* If set, this points to a function that is called to verify that a
+   particular history expansion should be performed. */
+Function *history_inhibit_expansion_function;
+
+/* **************************************************************** */
+/*								    */
+/*			History Expansion			    */
+/*								    */
+/* **************************************************************** */
+
+/* Hairy history expansion on text, not tokens.  This is of general
+   use, and thus belongs in this library. */
+
+/* The last string searched for by a !?string? search. */
+static char *search_string;
+
+/* The last string matched by a !?string? search. */
+static char *search_match;
+
+/* Return the event specified at TEXT + OFFSET modifying OFFSET to
+   point to after the event specifier.  Just a pointer to the history
+   line is returned; NULL is returned in the event of a bad specifier.
+   You pass STRING with *INDEX equal to the history_expansion_char that
+   begins this specification.
+   DELIMITING_QUOTE is a character that is allowed to end the string
+   specification for what to search for in addition to the normal
+   characters `:', ` ', `\t', `\n', and sometimes `?'.
+   So you might call this function like:
+   line = get_history_event ("!echo:p", &index, 0);  */
+char *
+get_history_event (string, caller_index, delimiting_quote)
+     char *string;
+     int *caller_index;
+     int delimiting_quote;
+{
+  register int i;
+  register char c;
+  HIST_ENTRY *entry;
+  int which, sign, local_index, substring_okay;
+  Function *search_func;
+  char *temp;
+
+  /* The event can be specified in a number of ways.
+
+     !!   the previous command
+     !n   command line N
+     !-n  current command-line minus N
+     !str the most recent command starting with STR
+     !?str[?]
+	  the most recent command containing STR
+
+     All values N are determined via HISTORY_BASE. */
+
+  i = *caller_index;
+
+  if (string[i] != history_expansion_char)
+    return ((char *)NULL);
+
+  /* Move on to the specification. */
+  i++;
+
+  sign = 1;
+  substring_okay = 0;
+
+#define RETURN_ENTRY(e, w) \
+	return ((e = history_get (w)) ? e->line : (char *)NULL)
+
+  /* Handle !! case. */
+  if (string[i] == history_expansion_char)
+    {
+      i++;
+      which = history_base + (history_length - 1);
+      *caller_index = i;
+      RETURN_ENTRY (entry, which);
+    }
+
+  /* Hack case of numeric line specification. */
+  if (string[i] == '-')
+    {
+      sign = -1;
+      i++;
+    }
+
+  if (_rl_digit_p (string[i]))
+    {
+      /* Get the extent of the digits and compute the value. */
+      for (which = 0; _rl_digit_p (string[i]); i++)
+	which = (which * 10) + _rl_digit_value (string[i]);
+
+      *caller_index = i;
+
+      if (sign < 0)
+	which = (history_length + history_base) - which;
+
+      RETURN_ENTRY (entry, which);
+    }
+
+  /* This must be something to search for.  If the spec begins with
+     a '?', then the string may be anywhere on the line.  Otherwise,
+     the string must be found at the start of a line. */
+  if (string[i] == '?')
+    {
+      substring_okay++;
+      i++;
+    }
+
+  /* Only a closing `?' or a newline delimit a substring search string. */
+  for (local_index = i; c = string[i]; i++)
+    if ((!substring_okay && (whitespace (c) || c == ':' ||
+	(history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||
+	string[i] == delimiting_quote)) ||
+	string[i] == '\n' ||
+	(substring_okay && string[i] == '?'))
+      break;
+
+  which = i - local_index;
+  temp = xmalloc (1 + which);
+  if (which)
+    strncpy (temp, string + local_index, which);
+  temp[which] = '\0';
+
+  if (substring_okay && string[i] == '?')
+    i++;
+
+  *caller_index = i;
+
+#define FAIL_SEARCH() \
+  do { \
+    history_offset = history_length; free (temp) ; return (char *)NULL; \
+  } while (0)
+
+  /* If there is no search string, try to use the previous search string,
+     if one exists.  If not, fail immediately. */
+  if (*temp == '\0' && substring_okay)
+    {
+      if (search_string)
+        {
+          free (temp);
+          temp = savestring (search_string);
+        }
+      else
+        FAIL_SEARCH ();
+    }
+
+  search_func = substring_okay ? history_search : history_search_prefix;
+  while (1)
+    {
+      local_index = (*search_func) (temp, -1);
+
+      if (local_index < 0)
+	FAIL_SEARCH ();
+
+      if (local_index == 0 || substring_okay)
+	{
+	  entry = current_history ();
+	  history_offset = history_length;
+	
+	  /* If this was a substring search, then remember the
+	     string that we matched for word substitution. */
+	  if (substring_okay)
+	    {
+	      FREE (search_string);
+	      search_string = temp;
+
+	      FREE (search_match);
+	      search_match = history_find_word (entry->line, local_index);
+	    }
+	  else
+	    free (temp);
+
+	  return (entry->line);
+	}
+
+      if (history_offset)
+	history_offset--;
+      else
+	FAIL_SEARCH ();
+    }
+#undef FAIL_SEARCH
+#undef RETURN_ENTRY
+}
+
+/* Function for extracting single-quoted strings.  Used for inhibiting
+   history expansion within single quotes. */
+
+/* Extract the contents of STRING as if it is enclosed in single quotes.
+   SINDEX, when passed in, is the offset of the character immediately
+   following the opening single quote; on exit, SINDEX is left pointing
+   to the closing single quote. */
+static void
+hist_string_extract_single_quoted (string, sindex)
+     char *string;
+     int *sindex;
+{
+  register int i;
+
+  for (i = *sindex; string[i] && string[i] != '\''; i++)
+    ;
+
+  *sindex = i;
+}
+
+static char *
+quote_breaks (s)
+     char *s;
+{
+  register char *p, *r;
+  char *ret;
+  int len = 3;
+
+  for (p = s; p && *p; p++, len++)
+    {
+      if (*p == '\'')
+	len += 3;
+      else if (whitespace (*p) || *p == '\n')
+	len += 2;
+    }
+
+  r = ret = xmalloc (len);
+  *r++ = '\'';
+  for (p = s; p && *p; )
+    {
+      if (*p == '\'')
+	{
+	  *r++ = '\'';
+	  *r++ = '\\';
+	  *r++ = '\'';
+	  *r++ = '\'';
+	  p++;
+	}
+      else if (whitespace (*p) || *p == '\n')
+	{
+	  *r++ = '\'';
+	  *r++ = *p++;
+	  *r++ = '\'';
+	}
+      else
+	*r++ = *p++;
+    }
+  *r++ = '\'';
+  *r = '\0';
+  return ret;
+}
+
+static char *
+hist_error(s, start, current, errtype)
+      char *s;
+      int start, current, errtype;
+{
+  char *temp, *emsg;
+  int ll, elen;
+
+  ll = current - start;
+
+  switch (errtype)
+    {
+    case EVENT_NOT_FOUND:
+      emsg = "event not found";
+      elen = 15;
+      break;
+    case BAD_WORD_SPEC:
+      emsg = "bad word specifier";
+      elen = 18;
+      break;
+    case SUBST_FAILED:
+      emsg = "substitution failed";
+      elen = 19;
+      break;
+    case BAD_MODIFIER:
+      emsg = "unrecognized history modifier";
+      elen = 29;
+      break;
+    default:
+      emsg = "unknown expansion error";
+      elen = 23;
+      break;
+    }
+
+  temp = xmalloc (ll + elen + 3);
+  strncpy (temp, s + start, ll);
+  temp[ll] = ':';
+  temp[ll + 1] = ' ';
+  strcpy (temp + ll + 2, emsg);
+  return (temp);
+}
+
+/* Get a history substitution string from STR starting at *IPTR
+   and return it.  The length is returned in LENPTR.
+
+   A backslash can quote the delimiter.  If the string is the
+   empty string, the previous pattern is used.  If there is
+   no previous pattern for the lhs, the last history search
+   string is used.
+
+   If IS_RHS is 1, we ignore empty strings and set the pattern
+   to "" anyway.  subst_lhs is not changed if the lhs is empty;
+   subst_rhs is allowed to be set to the empty string. */
+
+static char *
+get_subst_pattern (str, iptr, delimiter, is_rhs, lenptr)
+     char *str;
+     int *iptr, delimiter, is_rhs, *lenptr;
+{
+  register int si, i, j, k;
+  char *s = (char *) NULL;
+
+  i = *iptr;
+
+  for (si = i; str[si] && str[si] != delimiter; si++)
+    if (str[si] == '\\' && str[si + 1] == delimiter)
+      si++;
+
+  if (si > i || is_rhs)
+    {
+      s = xmalloc (si - i + 1);
+      for (j = 0, k = i; k < si; j++, k++)
+	{
+	  /* Remove a backslash quoting the search string delimiter. */
+	  if (str[k] == '\\' && str[k + 1] == delimiter)
+	    k++;
+	  s[j] = str[k];
+	}
+      s[j] = '\0';
+      if (lenptr)
+	*lenptr = j;
+    }
+
+  i = si;
+  if (str[i])
+    i++;
+  *iptr = i;
+
+  return s;
+}
+
+static void
+postproc_subst_rhs ()
+{
+  char *new;
+  int i, j, new_size;
+
+  new = xmalloc (new_size = subst_rhs_len + subst_lhs_len);
+  for (i = j = 0; i < subst_rhs_len; i++)
+    {
+      if (subst_rhs[i] == '&')
+	{
+	  if (j + subst_lhs_len >= new_size)
+	    new = xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
+	  strcpy (new + j, subst_lhs);
+	  j += subst_lhs_len;
+	}
+      else
+	{
+	  /* a single backslash protects the `&' from lhs interpolation */
+	  if (subst_rhs[i] == '\\' && subst_rhs[i + 1] == '&')
+	    i++;
+	  if (j >= new_size)
+	    new = xrealloc (new, new_size *= 2);
+	  new[j++] = subst_rhs[i];
+	}
+    }
+  new[j] = '\0';
+  free (subst_rhs);
+  subst_rhs = new;
+  subst_rhs_len = j;
+}
+
+/* Expand the bulk of a history specifier starting at STRING[START].
+   Returns 0 if everything is OK, -1 if an error occurred, and 1
+   if the `p' modifier was supplied and the caller should just print
+   the returned string.  Returns the new index into string in
+   *END_INDEX_PTR, and the expanded specifier in *RET_STRING. */
+static int
+history_expand_internal (string, start, end_index_ptr, ret_string, current_line)
+     char *string;
+     int start, *end_index_ptr;
+     char **ret_string;
+     char *current_line;	/* for !# */
+{
+  int i, n, starting_index;
+  int substitute_globally, want_quotes, print_only;
+  char *event, *temp, *result, *tstr, *t, c, *word_spec;
+  int result_len;
+
+  result = xmalloc (result_len = 128);
+
+  i = start;
+
+  /* If it is followed by something that starts a word specifier,
+     then !! is implied as the event specifier. */
+
+  if (member (string[i + 1], ":$*%^"))
+    {
+      char fake_s[3];
+      int fake_i = 0;
+      i++;
+      fake_s[0] = fake_s[1] = history_expansion_char;
+      fake_s[2] = '\0';
+      event = get_history_event (fake_s, &fake_i, 0);
+    }
+  else if (string[i + 1] == '#')
+    {
+      i += 2;
+      event = current_line;
+    }
+  else
+    {
+      int quoted_search_delimiter = 0;
+
+      /* If the character before this `!' is a double or single
+	 quote, then this expansion takes place inside of the
+	 quoted string.  If we have to search for some text ("!foo"),
+	 allow the delimiter to end the search string. */
+      if (i && (string[i - 1] == '\'' || string[i - 1] == '"'))
+	quoted_search_delimiter = string[i - 1];
+      event = get_history_event (string, &i, quoted_search_delimiter);
+    }
+	  
+  if (event == 0)
+    {
+      *ret_string = hist_error (string, start, i, EVENT_NOT_FOUND);
+      free (result);
+      return (-1);
+    }
+
+  /* If a word specifier is found, then do what that requires. */
+  starting_index = i;
+  word_spec = get_history_word_specifier (string, event, &i);
+
+  /* There is no such thing as a `malformed word specifier'.  However,
+     it is possible for a specifier that has no match.  In that case,
+     we complain. */
+  if (word_spec == (char *)&error_pointer)
+    {
+      *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);
+      free (result);
+      return (-1);
+    }
+
+  /* If no word specifier, than the thing of interest was the event. */
+  temp = word_spec ? savestring (word_spec) : savestring (event);
+  FREE (word_spec);
+
+  /* Perhaps there are other modifiers involved.  Do what they say. */
+  want_quotes = substitute_globally = print_only = 0;
+  starting_index = i;
+
+  while (string[i] == ':')
+    {
+      c = string[i + 1];
+
+      if (c == 'g')
+	{
+	  substitute_globally = 1;
+	  i++;
+	  c = string[i + 1];
+	}
+
+      switch (c)
+	{
+	default:
+	  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);
+	  free (result);
+	  free (temp);
+	  return -1;
+
+	case 'q':
+	  want_quotes = 'q';
+	  break;
+
+	case 'x':
+	  want_quotes = 'x';
+	  break;
+
+	  /* :p means make this the last executed line.  So we
+	     return an error state after adding this line to the
+	     history. */
+	case 'p':
+	  print_only++;
+	  break;
+
+	  /* :t discards all but the last part of the pathname. */
+	case 't':
+	  tstr = strrchr (temp, '/');
+	  if (tstr)
+	    {
+	      tstr++;
+	      t = savestring (tstr);
+	      free (temp);
+	      temp = t;
+	    }
+	  break;
+
+	  /* :h discards the last part of a pathname. */
+	case 'h':
+	  tstr = strrchr (temp, '/');
+	  if (tstr)
+	    *tstr = '\0';
+	  break;
+
+	  /* :r discards the suffix. */
+	case 'r':
+	  tstr = strrchr (temp, '.');
+	  if (tstr)
+	    *tstr = '\0';
+	  break;
+
+	  /* :e discards everything but the suffix. */
+	case 'e':
+	  tstr = strrchr (temp, '.');
+	  if (tstr)
+	    {
+	      t = savestring (tstr);
+	      free (temp);
+	      temp = t;
+	    }
+	  break;
+
+	/* :s/this/that substitutes `that' for the first
+	   occurrence of `this'.  :gs/this/that substitutes `that'
+	   for each occurrence of `this'.  :& repeats the last
+	   substitution.  :g& repeats the last substitution
+	   globally. */
+
+	case '&':
+	case 's':
+	  {
+	    char *new_event, *t;
+	    int delimiter, failed, si, l_temp;
+
+	    if (c == 's')
+	      {
+		if (i + 2 < (int)strlen (string))
+		  delimiter = string[i + 2];
+		else
+		  break;	/* no search delimiter */
+
+		i += 3;
+
+		t = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);
+		/* An empty substitution lhs with no previous substitution
+		   uses the last search string as the lhs. */
+		if (t)
+		  {
+		    FREE (subst_lhs);
+		    subst_lhs = t;
+		  }
+		else if (!subst_lhs)
+		  {
+		    if (search_string && *search_string)
+		      {
+			subst_lhs = savestring (search_string);
+			subst_lhs_len = strlen (subst_lhs);
+		      }
+		    else
+		      {
+			subst_lhs = (char *) NULL;
+			subst_lhs_len = 0;
+		      }
+		  }
+
+		/* If there is no lhs, the substitution can't succeed. */
+		if (subst_lhs_len == 0)
+		  {
+		    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
+		    free (result);
+		    free (temp);
+		    return -1;
+		  }
+
+		FREE (subst_rhs);
+		subst_rhs = get_subst_pattern (string, &i, delimiter, 1, &subst_rhs_len);
+
+		/* If `&' appears in the rhs, it's supposed to be replaced
+		   with the lhs. */
+		if (member ('&', subst_rhs))
+		  postproc_subst_rhs ();
+	      }
+	    else
+	      i += 2;
+
+	    l_temp = strlen (temp);
+	    /* Ignore impossible cases. */
+	    if (subst_lhs_len > l_temp)
+	      {
+		*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
+		free (result);
+		free (temp);
+		return (-1);
+	      }
+
+	    /* Find the first occurrence of THIS in TEMP. */
+	    si = 0;
+	    for (failed = 1; (si + subst_lhs_len) <= l_temp; si++)
+	      if (STREQN (temp+si, subst_lhs, subst_lhs_len))
+		{
+		  int len = subst_rhs_len - subst_lhs_len + l_temp;
+		  new_event = xmalloc (1 + len);
+		  strncpy (new_event, temp, si);
+		  strncpy (new_event + si, subst_rhs, subst_rhs_len);
+		  strncpy (new_event + si + subst_rhs_len,
+			   temp + si + subst_lhs_len,
+			   l_temp - (si + subst_lhs_len));
+		  new_event[len] = '\0';
+		  free (temp);
+		  temp = new_event;
+
+		  failed = 0;
+
+		  if (substitute_globally)
+		    {
+		      si += subst_rhs_len;
+		      l_temp = strlen (temp);
+		      substitute_globally++;
+		      continue;
+		    }
+		  else
+		    break;
+		}
+
+	    if (substitute_globally > 1)
+	      {
+		substitute_globally = 0;
+		continue;	/* don't want to increment i */
+	      }
+
+	    if (failed == 0)
+	      continue;		/* don't want to increment i */
+
+	    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);
+	    free (result);
+	    free (temp);
+	    return (-1);
+	  }
+	}
+      i += 2;
+    }
+  /* Done with modfiers. */
+  /* Believe it or not, we have to back the pointer up by one. */
+  --i;
+
+  if (want_quotes)
+    {
+      char *x;
+
+      if (want_quotes == 'q')
+	x = single_quote (temp);
+      else if (want_quotes == 'x')
+	x = quote_breaks (temp);
+      else
+	x = savestring (temp);
+
+      free (temp);
+      temp = x;
+    }
+
+  n = strlen (temp);
+  if (n >= result_len)
+    result = xrealloc (result, n + 2);
+  strcpy (result, temp);
+  free (temp);
+
+  *end_index_ptr = i;
+  *ret_string = result;
+  return (print_only);
+}
+
+/* Expand the string STRING, placing the result into OUTPUT, a pointer
+   to a string.  Returns:
+
+  -1) If there was an error in expansion.
+   0) If no expansions took place (or, if the only change in
+      the text was the de-slashifying of the history expansion
+      character)
+   1) If expansions did take place
+   2) If the `p' modifier was given and the caller should print the result
+
+  If an error ocurred in expansion, then OUTPUT contains a descriptive
+  error message. */
+
+#define ADD_STRING(s) \
+	do \
+	  { \
+	    int sl = strlen (s); \
+	    j += sl; \
+	    if (j >= result_len) \
+	      { \
+		while (j >= result_len) \
+		  result_len += 128; \
+		result = xrealloc (result, result_len); \
+	      } \
+	    strcpy (result + j - sl, s); \
+	  } \
+	while (0)
+
+#define ADD_CHAR(c) \
+	do \
+	  { \
+	    if (j >= result_len - 1) \
+	      result = xrealloc (result, result_len += 64); \
+	    result[j++] = c; \
+	    result[j] = '\0'; \
+	  } \
+	while (0)
+
+int
+history_expand (hstring, output)
+     char *hstring;
+     char **output;
+{
+  register int j;
+  int i, r, l, passc, cc, modified, eindex, only_printing;
+  char *string;
+
+  /* The output string, and its length. */
+  int result_len;
+  char *result;
+
+  /* Used when adding the string. */
+  char *temp;
+
+  /* Setting the history expansion character to 0 inhibits all
+     history expansion. */
+  if (history_expansion_char == 0)
+    {
+      *output = savestring (hstring);
+      return (0);
+    }
+    
+  /* Prepare the buffer for printing error messages. */
+  result = xmalloc (result_len = 256);
+  result[0] = '\0';
+
+  only_printing = modified = 0;
+  l = strlen (hstring);
+
+  /* Grovel the string.  Only backslash can quote the history escape
+     character.  We also handle arg specifiers. */
+
+  /* Before we grovel forever, see if the history_expansion_char appears
+     anywhere within the text. */
+
+  /* The quick substitution character is a history expansion all right.  That
+     is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,
+     that is the substitution that we do. */
+  if (hstring[0] == history_subst_char)
+    {
+      string = xmalloc (l + 5);
+
+      string[0] = string[1] = history_expansion_char;
+      string[2] = ':';
+      string[3] = 's';
+      strcpy (string + 4, hstring);
+      l += 4;
+    }
+  else
+    {
+      string = hstring;
+      /* If not quick substitution, still maybe have to do expansion. */
+
+      /* `!' followed by one of the characters in history_no_expand_chars
+	 is NOT an expansion. */
+      for (i = 0; string[i]; i++)
+	{
+	  cc = string[i + 1];
+	  if (string[i] == history_expansion_char)
+	    {
+	      if (!cc || member (cc, history_no_expand_chars))
+		continue;
+	      /* If the calling application has set
+		 history_inhibit_expansion_function to a function that checks
+		 for special cases that should not be history expanded,
+		 call the function and skip the expansion if it returns a
+		 non-zero value. */
+	      else if (history_inhibit_expansion_function &&
+			(*history_inhibit_expansion_function) (string, i))
+		continue;
+	      else
+		break;
+	    }
+	  else if (history_quotes_inhibit_expansion && string[i] == '\'')
+	    {
+	      /* If this is bash, single quotes inhibit history expansion. */
+	      i++;
+	      hist_string_extract_single_quoted (string, &i);
+	    }
+	  else if (history_quotes_inhibit_expansion && string[i] == '\\')
+	    {
+	      /* If this is bash, allow backslashes to quote single
+		 quotes and the history expansion character. */
+	      if (cc == '\'' || cc == history_expansion_char)
+		i++;
+	    }
+	}
+	  
+      if (string[i] != history_expansion_char)
+	{
+	  free (result);
+	  *output = savestring (string);
+	  return (0);
+	}
+    }
+
+  /* Extract and perform the substitution. */
+  for (passc = i = j = 0; i < l; i++)
+    {
+      int tchar = string[i];
+
+      if (passc)
+	{
+	  passc = 0;
+	  ADD_CHAR (tchar);
+	  continue;
+	}
+
+      if (tchar == history_expansion_char)
+	tchar = -3;
+
+      switch (tchar)
+	{
+	default:
+	  ADD_CHAR (string[i]);
+	  break;
+
+	case '\\':
+	  passc++;
+	  ADD_CHAR (tchar);
+	  break;
+
+	case '\'':
+	  {
+	    /* If history_quotes_inhibit_expansion is set, single quotes
+	       inhibit history expansion. */
+	    if (history_quotes_inhibit_expansion)
+	      {
+		int quote, slen;
+
+		quote = i++;
+		hist_string_extract_single_quoted (string, &i);
+
+		slen = i - quote + 2;
+		temp = xmalloc (slen);
+		strncpy (temp, string + quote, slen);
+		temp[slen - 1] = '\0';
+		ADD_STRING (temp);
+		free (temp);
+	      }
+	    else
+	      ADD_CHAR (string[i]);
+	    break;
+	  }
+
+	case -3:		/* history_expansion_char */
+	  cc = string[i + 1];
+
+	  /* If the history_expansion_char is followed by one of the
+	     characters in history_no_expand_chars, then it is not a
+	     candidate for expansion of any kind. */
+	  if (member (cc, history_no_expand_chars))
+	    {
+	      ADD_CHAR (string[i]);
+	      break;
+	    }
+
+#if defined (NO_BANG_HASH_MODIFIERS)
+	  /* There is something that is listed as a `word specifier' in csh
+	     documentation which means `the expanded text to this point'.
+	     That is not a word specifier, it is an event specifier.  If we
+	     don't want to allow modifiers with `!#', just stick the current
+	     output line in again. */
+	  if (cc == '#')
+	    {
+	      if (result)
+		{
+		  temp = xmalloc (1 + strlen (result));
+		  strcpy (temp, result);
+		  ADD_STRING (temp);
+		  free (temp);
+		}
+	      i++;
+	      break;
+	    }
+#endif
+
+	  r = history_expand_internal (string, i, &eindex, &temp, result);
+	  if (r < 0)
+	    {
+	      *output = temp;
+	      free (result);
+	      if (string != hstring)
+		free (string);
+	      return -1;
+	    }
+	  else
+	    {
+	      if (temp)
+		{
+		  modified++;
+		  if (*temp)
+		    ADD_STRING (temp);
+		  free (temp);
+		}
+	      only_printing = r == 1;
+	      i = eindex;
+	    }
+	  break;
+	}
+    }
+
+  *output = result;
+  if (string != hstring)
+    free (string);
+
+  if (only_printing)
+    {
+      add_history (result);
+      return (2);
+    }
+
+  return (modified != 0);
+}
+
+/* Return a consed string which is the word specified in SPEC, and found
+   in FROM.  NULL is returned if there is no spec.  The address of
+   ERROR_POINTER is returned if the word specified cannot be found.
+   CALLER_INDEX is the offset in SPEC to start looking; it is updated
+   to point to just after the last character parsed. */
+static char *
+get_history_word_specifier (spec, from, caller_index)
+     char *spec, *from;
+     int *caller_index;
+{
+  register int i = *caller_index;
+  int first, last;
+  int expecting_word_spec = 0;
+  char *result;
+
+  /* The range of words to return doesn't exist yet. */
+  first = last = 0;
+  result = (char *)NULL;
+
+  /* If we found a colon, then this *must* be a word specification.  If
+     it isn't, then it is an error. */
+  if (spec[i] == ':')
+    {
+      i++;
+      expecting_word_spec++;
+    }
+
+  /* Handle special cases first. */
+
+  /* `%' is the word last searched for. */
+  if (spec[i] == '%')
+    {
+      *caller_index = i + 1;
+      return (search_match ? savestring (search_match) : savestring (""));
+    }
+
+  /* `*' matches all of the arguments, but not the command. */
+  if (spec[i] == '*')
+    {
+      *caller_index = i + 1;
+      result = history_arg_extract (1, '$', from);
+      return (result ? result : savestring (""));
+    }
+
+  /* `$' is last arg. */
+  if (spec[i] == '$')
+    {
+      *caller_index = i + 1;
+      return (history_arg_extract ('$', '$', from));
+    }
+
+  /* Try to get FIRST and LAST figured out. */
+
+  if (spec[i] == '-')
+    first = 0;
+  else if (spec[i] == '^')
+    first = 1;
+  else if (_rl_digit_p (spec[i]) && expecting_word_spec)
+    {
+      for (first = 0; _rl_digit_p (spec[i]); i++)
+	first = (first * 10) + _rl_digit_value (spec[i]);
+    }
+  else
+    return ((char *)NULL);	/* no valid `first' for word specifier */
+
+  if (spec[i] == '^' || spec[i] == '*')
+    {
+      last = (spec[i] == '^') ? 1 : '$';	/* x* abbreviates x-$ */
+      i++;
+    }
+  else if (spec[i] != '-')
+    last = first;
+  else
+    {
+      i++;
+
+      if (_rl_digit_p (spec[i]))
+	{
+	  for (last = 0; _rl_digit_p (spec[i]); i++)
+	    last = (last * 10) + _rl_digit_value (spec[i]);
+	}
+      else if (spec[i] == '$')
+	{
+	  i++;
+	  last = '$';
+	}
+      else if (!spec[i] || spec[i] == ':')  /* could be modifier separator */
+	last = -1;		/* x- abbreviates x-$ omitting word `$' */
+    }
+
+  *caller_index = i;
+
+  if (last >= first || last == '$' || last < 0)
+    result = history_arg_extract (first, last, from);
+
+  return (result ? result : (char *)&error_pointer);
+}
+
+/* Extract the args specified, starting at FIRST, and ending at LAST.
+   The args are taken from STRING.  If either FIRST or LAST is < 0,
+   then make that arg count from the right (subtract from the number of
+   tokens, so that FIRST = -1 means the next to last token on the line).
+   If LAST is `$' the last arg from STRING is used. */
+char *
+history_arg_extract (first, last, string)
+     int first, last;
+     char *string;
+{
+  register int i, len;
+  char *result;
+  int size, offset;
+  char **list;
+
+  /* XXX - think about making history_tokenize return a struct array,
+     each struct in array being a string and a length to avoid the
+     calls to strlen below. */
+  if ((list = history_tokenize (string)) == NULL)
+    return ((char *)NULL);
+
+  for (len = 0; list[len]; len++)
+    ;
+
+  if (last < 0)
+    last = len + last - 1;
+
+  if (first < 0)
+    first = len + first - 1;
+
+  if (last == '$')
+    last = len - 1;
+
+  if (first == '$')
+    first = len - 1;
+
+  last++;
+
+  if (first >= len || last > len || first < 0 || last < 0 || first > last)
+    result = ((char *)NULL);
+  else
+    {
+      for (size = 0, i = first; i < last; i++)
+	size += strlen (list[i]) + 1;
+      result = xmalloc (size + 1);
+      result[0] = '\0';
+
+      for (i = first, offset = 0; i < last; i++)
+	{
+	  strcpy (result + offset, list[i]);
+	  offset += strlen (list[i]);
+	  if (i + 1 < last)
+	    {
+      	      result[offset++] = ' ';
+	      result[offset] = 0;
+	    }
+	}
+    }
+
+  for (i = 0; i < len; i++)
+    free (list[i]);
+  free (list);
+
+  return (result);
+}
+
+#define slashify_in_quotes "\\`\"$"
+
+/* Parse STRING into tokens and return an array of strings.  If WIND is
+   not -1 and INDP is not null, we also want the word surrounding index
+   WIND.  The position in the returned array of strings is returned in
+   *INDP. */
+static char **
+history_tokenize_internal (string, wind, indp)
+     char *string;
+     int wind, *indp;
+{
+  char **result;
+  register int i, start, result_index, size;
+  int len, delimiter;
+
+  /* Get a token, and stuff it into RESULT.  The tokens are split
+     exactly where the shell would split them. */
+  for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
+    {
+      delimiter = 0;
+
+      /* Skip leading whitespace. */
+      for (; string[i] && whitespace (string[i]); i++)
+	;
+      if (string[i] == 0 || string[i] == history_comment_char)
+	return (result);
+
+      start = i;
+      
+      if (member (string[i], "()\n"))
+	{
+	  i++;
+	  goto got_token;
+	}
+
+      if (member (string[i], "<>;&|$"))
+	{
+	  int peek = string[i + 1];
+
+	  if (peek == string[i] && peek != '$')
+	    {
+	      if (peek == '<' && string[i + 2] == '-')
+		i++;
+	      i += 2;
+	      goto got_token;
+	    }
+	  else
+	    {
+	      if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||
+		  ((peek == '>') && (string[i] == '&')) ||
+		  ((peek == '(') && (string[i] == '$')))
+		{
+		  i += 2;
+		  goto got_token;
+		}
+	    }
+	  if (string[i] != '$')
+	    {
+	      i++;
+	      goto got_token;
+	    }
+	}
+
+      /* Get word from string + i; */
+
+      if (member (string[i], "\"'`"))
+	delimiter = string[i++];
+
+      for (; string[i]; i++)
+	{
+	  if (string[i] == '\\' && string[i + 1] == '\n')
+	    {
+	      i++;
+	      continue;
+	    }
+
+	  if (string[i] == '\\' && delimiter != '\'' &&
+	      (delimiter != '"' || member (string[i], slashify_in_quotes)))
+	    {
+	      i++;
+	      continue;
+	    }
+
+	  if (delimiter && string[i] == delimiter)
+	    {
+	      delimiter = 0;
+	      continue;
+	    }
+
+	  if (!delimiter && (member (string[i], " \t\n;&()|<>")))
+	    break;
+
+	  if (!delimiter && member (string[i], "\"'`"))
+	    delimiter = string[i];
+	}
+
+    got_token:
+
+      /* If we are looking for the word in which the character at a
+	 particular index falls, remember it. */
+      if (indp && wind != -1 && wind >= start && wind < i)
+        *indp = result_index;
+
+      len = i - start;
+      if (result_index + 2 >= size)
+	result = (char **)xrealloc (result, ((size += 10) * sizeof (char *)));
+      result[result_index] = xmalloc (1 + len);
+      strncpy (result[result_index], string + start, len);
+      result[result_index][len] = '\0';
+      result[++result_index] = (char *)NULL;
+    }
+
+  return (result);
+}
+
+/* Return an array of tokens, much as the shell might.  The tokens are
+   parsed out of STRING. */
+char **
+history_tokenize (string)
+     char *string;
+{
+  return (history_tokenize_internal (string, -1, (int *)NULL));
+}
+
+/* Find and return the word which contains the character at index IND
+   in the history line LINE.  Used to save the word matched by the
+   last history !?string? search. */
+static char *
+history_find_word (line, ind)
+     char *line;
+     int ind;
+{
+  char **words, *s;
+  int i, wind;
+
+  words = history_tokenize_internal (line, ind, &wind);
+  if (wind == -1)
+    return ((char *)NULL);
+  s = words[wind];
+  for (i = 0; i < wind; i++)
+    free (words[i]);
+  for (i = wind + 1; words[i]; i++)
+    free (words[i]);
+  free (words);
+  return s;
+}
diff --git a/readline/histfile.c b/readline/histfile.c
new file mode 100644
--- /dev/null
+++ b/readline/histfile.c
@@ -0,0 +1,339 @@
+/* histfile.c - functions to manipulate the history file. */
+
+/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
+
+   This file contains the GNU History Library (the Library), a set of
+   routines for managing the text of previously typed lines.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+/* The goal is to make the implementation transparent, so that you
+   don't have to know what data types are used, just what functions
+   you can call.  I think I have done that. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+
+#include <sys/types.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#if defined (HAVE_STRING_H)
+#  include <string.h>
+#else
+#  include <strings.h>
+#endif /* !HAVE_STRING_H */
+
+#if defined (__EMX__)
+#  ifndef O_BINARY
+#    define O_BINARY 0
+#  endif
+#else /* !__EMX__ */
+   /* If we're not compiling for __EMX__, we don't want this at all.  Ever. */
+#  undef O_BINARY
+#  define O_BINARY 0
+#endif /* !__EMX__ */
+
+#include <errno.h>
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+#include "history.h"
+#include "histlib.h"
+
+/* Functions imported from shell.c */
+extern char *get_env_value ();
+
+extern char *xmalloc (), *xrealloc ();
+
+/* Return the string that should be used in the place of this
+   filename.  This only matters when you don't specify the
+   filename to read_history (), or write_history (). */
+static char *
+history_filename (filename)
+     char *filename;
+{
+  char *return_val, *home;
+  int home_len;
+
+  return_val = filename ? savestring (filename) : (char *)NULL;
+
+  if (return_val)
+    return (return_val);
+  
+  home = get_env_value ("HOME");
+
+  if (home == 0)
+    {
+      home = ".";
+      home_len = 1;
+    }
+  else
+    home_len = strlen (home);
+
+  return_val = xmalloc (2 + home_len + 8); /* strlen(".history") == 8 */
+  strcpy (return_val, home);
+  return_val[home_len] = '/';
+  strcpy (return_val + home_len + 1, ".history");
+
+  return (return_val);
+}
+
+/* Add the contents of FILENAME to the history list, a line at a time.
+   If FILENAME is NULL, then read from ~/.history.  Returns 0 if
+   successful, or errno if not. */
+int
+read_history (filename)
+     char *filename;
+{
+  return (read_history_range (filename, 0, -1));
+}
+
+/* Read a range of lines from FILENAME, adding them to the history list.
+   Start reading at the FROM'th line and end at the TO'th.  If FROM
+   is zero, start at the beginning.  If TO is less than FROM, read
+   until the end of the file.  If FILENAME is NULL, then read from
+   ~/.history.  Returns 0 if successful, or errno if not. */
+int
+read_history_range (filename, from, to)
+     char *filename;
+     int from, to;
+{
+  register int line_start, line_end;
+  char *input, *buffer = (char *)NULL;
+  int file, current_line;
+  struct stat finfo;
+
+  input = history_filename (filename);
+  file = open (input, O_RDONLY|O_BINARY, 0666);
+
+  if ((file < 0) || (fstat (file, &finfo) == -1))
+    goto error_and_exit;
+
+  buffer = xmalloc ((int)finfo.st_size + 1);
+
+  if (read (file, buffer, finfo.st_size) != finfo.st_size)
+    {
+  error_and_exit:
+      if (file >= 0)
+	close (file);
+
+      FREE (input);
+      FREE (buffer);
+
+      return (errno);
+    }
+
+  close (file);
+
+  /* Set TO to larger than end of file if negative. */
+  if (to < 0)
+    to = finfo.st_size;
+
+  /* Start at beginning of file, work to end. */
+  line_start = line_end = current_line = 0;
+
+  /* Skip lines until we are at FROM. */
+  while (line_start < finfo.st_size && current_line < from)
+    {
+      for (line_end = line_start; line_end < finfo.st_size; line_end++)
+	if (buffer[line_end] == '\n')
+	  {
+	    current_line++;
+	    line_start = line_end + 1;
+	    if (current_line == from)
+	      break;
+	  }
+    }
+
+  /* If there are lines left to gobble, then gobble them now. */
+  for (line_end = line_start; line_end < finfo.st_size; line_end++)
+    if (buffer[line_end] == '\n')
+      {
+	buffer[line_end] = '\0';
+
+	if (buffer[line_start])
+	  add_history (buffer + line_start);
+
+	current_line++;
+
+	if (current_line >= to)
+	  break;
+
+	line_start = line_end + 1;
+      }
+
+  FREE (input);
+  FREE (buffer);
+
+  return (0);
+}
+
+/* Truncate the history file FNAME, leaving only LINES trailing lines.
+   If FNAME is NULL, then use ~/.history. */
+int
+history_truncate_file (fname, lines)
+     char *fname;
+     register int lines;
+{
+  register int i;
+  int file, chars_read;
+  char *buffer, *filename;
+  struct stat finfo;
+
+  buffer = (char *)NULL;
+  filename = history_filename (fname);
+  file = open (filename, O_RDONLY|O_BINARY, 0666);
+
+  if (file == -1 || fstat (file, &finfo) == -1)
+    goto truncate_exit;
+
+  buffer = xmalloc ((int)finfo.st_size + 1);
+  chars_read = read (file, buffer, finfo.st_size);
+  close (file);
+
+  if (chars_read <= 0)
+    goto truncate_exit;
+
+  /* Count backwards from the end of buffer until we have passed
+     LINES lines. */
+  for (i = chars_read - 1; lines && i; i--)
+    {
+      if (buffer[i] == '\n')
+	lines--;
+    }
+
+  /* If this is the first line, then the file contains exactly the
+     number of lines we want to truncate to, so we don't need to do
+     anything.  It's the first line if we don't find a newline between
+     the current value of i and 0.  Otherwise, write from the start of
+     this line until the end of the buffer. */
+  for ( ; i; i--)
+    if (buffer[i] == '\n')
+      {
+	i++;
+	break;
+      }
+
+  /* Write only if there are more lines in the file than we want to
+     truncate to. */
+  if (i && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0666)) != -1))
+    {
+      write (file, buffer + i, finfo.st_size - i);
+      close (file);
+    }
+
+ truncate_exit:
+
+  FREE (buffer);
+
+  free (filename);
+  return 0;
+}
+
+/* Workhorse function for writing history.  Writes NELEMENT entries
+   from the history list to FILENAME.  OVERWRITE is non-zero if you
+   wish to replace FILENAME with the entries. */
+static int
+history_do_write (filename, nelements, overwrite)
+     char *filename;
+     int nelements, overwrite;
+{
+  register int i;
+  char *output;
+  int file, mode;
+
+  mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
+  output = history_filename (filename);
+
+  if ((file = open (output, mode, 0666)) == -1)
+    {
+      FREE (output);
+      return (errno);
+    }
+
+  if (nelements > history_length)
+    nelements = history_length;
+
+  /* Build a buffer of all the lines to write, and write them in one syscall.
+     Suggested by Peter Ho (peter@robosts.oxford.ac.uk). */
+  {
+    HIST_ENTRY **the_history;	/* local */
+    register int j;
+    int buffer_size;
+    char *buffer;
+
+    the_history = history_list ();
+    /* Calculate the total number of bytes to write. */
+    for (buffer_size = 0, i = history_length - nelements; i < history_length; i++)
+      buffer_size += 1 + strlen (the_history[i]->line);
+
+    /* Allocate the buffer, and fill it. */
+    buffer = xmalloc (buffer_size);
+
+    for (j = 0, i = history_length - nelements; i < history_length; i++)
+      {
+	strcpy (buffer + j, the_history[i]->line);
+	j += strlen (the_history[i]->line);
+	buffer[j++] = '\n';
+      }
+
+    write (file, buffer, buffer_size);
+    free (buffer);
+  }
+
+  close (file);
+
+  FREE (output);
+
+  return (0);
+}
+
+/* Append NELEMENT entries to FILENAME.  The entries appended are from
+   the end of the list minus NELEMENTs up to the end of the list. */
+int
+append_history (nelements, filename)
+     int nelements;
+     char *filename;
+{
+  return (history_do_write (filename, nelements, HISTORY_APPEND));
+}
+
+/* Overwrite FILENAME with the current history.  If FILENAME is NULL,
+   then write the history list to ~/.history.  Values returned
+   are as in read_history ().*/
+int
+write_history (filename)
+     char *filename;
+{
+  return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
+}
diff --git a/readline/histlib.h b/readline/histlib.h
new file mode 100644
--- /dev/null
+++ b/readline/histlib.h
@@ -0,0 +1,81 @@
+/* histlib.h -- internal definitions for the history library. */
+/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
+
+   This file contains the GNU History Library (the Library), a set of
+   routines for managing the text of previously typed lines.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (_HISTLIB_H_)
+#define _HISTLIB_H_
+
+/* Function pointers can be declared as (Function *)foo. */
+#if !defined (_FUNCTION_DEF)
+#  define _FUNCTION_DEF
+typedef int Function ();
+typedef void VFunction ();
+typedef char *CPFunction ();
+typedef char **CPPFunction ();
+#endif /* _FUNCTION_DEF */
+
+#define STREQ(a, b)	(((a)[0] == (b)[0]) && (strcmp ((a), (b)) == 0))
+#define STREQN(a, b, n)	(((a)[0] == (b)[0]) && (strncmp ((a), (b), (n)) == 0))
+
+#ifndef savestring
+#  ifndef strcpy
+extern char *strcpy ();
+#  endif
+#define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
+#endif
+
+#ifndef whitespace
+#define whitespace(c) (((c) == ' ') || ((c) == '\t'))
+#endif
+
+#ifndef _rl_digit_p
+#define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
+#endif
+
+#ifndef _rl_digit_value
+#define _rl_digit_value(c) ((c) - '0')
+#endif
+
+#ifndef member
+#  ifndef strchr
+extern char *strchr ();
+#  endif
+#define member(c, s) ((c) ? ((char *)strchr ((s), (c)) != (char *)NULL) : 0)
+#endif
+
+#ifndef FREE
+#  define FREE(x)	if (x) free (x)
+#endif
+
+/* Possible history errors passed to hist_error. */
+#define EVENT_NOT_FOUND 0
+#define BAD_WORD_SPEC	1
+#define SUBST_FAILED	2
+#define BAD_MODIFIER	3
+
+/* Possible definitions for history starting point specification. */
+#define ANCHORED_SEARCH 1
+#define NON_ANCHORED_SEARCH 0
+
+/* Possible definitions for what style of writing the history file we want. */
+#define HISTORY_APPEND 0
+#define HISTORY_OVERWRITE 1
+
+#endif /* !_HISTLIB_H_ */
diff --git a/readline/history.c b/readline/history.c
new file mode 100644
--- /dev/null
+++ b/readline/history.c
@@ -0,0 +1,385 @@
+/* History.c -- standalone history library */
+
+/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
+
+   This file contains the GNU History Library (the Library), a set of
+   routines for managing the text of previously typed lines.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+/* The goal is to make the implementation transparent, so that you
+   don't have to know what data types are used, just what functions
+   you can call.  I think I have done that. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#if defined (HAVE_STRING_H)
+#  include <string.h>
+#else
+#  include <strings.h>
+#endif /* !HAVE_STRING_H */
+
+#include "history.h"
+#include "histlib.h"
+
+extern char *xmalloc (), *xrealloc ();
+
+/* The number of slots to increase the_history by. */
+#define DEFAULT_HISTORY_GROW_SIZE 50
+
+/* **************************************************************** */
+/*								    */
+/*			History Functions			    */
+/*								    */
+/* **************************************************************** */
+
+/* An array of HIST_ENTRY.  This is where we store the history. */
+static HIST_ENTRY **the_history = (HIST_ENTRY **)NULL;
+
+/* Non-zero means that we have enforced a limit on the amount of
+   history that we save. */
+static int history_stifled;
+
+/* If HISTORY_STIFLED is non-zero, then this is the maximum number of
+   entries to remember. */
+int max_input_history;
+
+/* The current location of the interactive history pointer.  Just makes
+   life easier for outside callers. */
+int history_offset;
+
+/* The number of strings currently stored in the history list. */
+int history_length;
+
+/* The current number of slots allocated to the input_history. */
+static int history_size;
+
+/* The logical `base' of the history array.  It defaults to 1. */
+int history_base = 1;
+
+/* Return the current HISTORY_STATE of the history. */
+HISTORY_STATE *
+history_get_history_state ()
+{
+  HISTORY_STATE *state;
+
+  state = (HISTORY_STATE *)xmalloc (sizeof (HISTORY_STATE));
+  state->entries = the_history;
+  state->offset = history_offset;
+  state->length = history_length;
+  state->size = history_size;
+  state->flags = 0;
+  if (history_stifled)
+    state->flags |= HS_STIFLED;
+
+  return (state);
+}
+
+/* Set the state of the current history array to STATE. */
+void
+history_set_history_state (state)
+     HISTORY_STATE *state;
+{
+  the_history = state->entries;
+  history_offset = state->offset;
+  history_length = state->length;
+  history_size = state->size;
+  if (state->flags & HS_STIFLED)
+    history_stifled = 1;
+}
+
+/* Begin a session in which the history functions might be used.  This
+   initializes interactive variables. */
+void
+using_history ()
+{
+  history_offset = history_length;
+}
+
+/* Return the number of bytes that the primary history entries are using.
+   This just adds up the lengths of the_history->lines. */
+int
+history_total_bytes ()
+{
+  register int i, result;
+
+  result = 0;
+
+  for (i = 0; the_history && the_history[i]; i++)
+    result += strlen (the_history[i]->line);
+
+  return (result);
+}
+
+/* Returns the magic number which says what history element we are
+   looking at now.  In this implementation, it returns history_offset. */
+int
+where_history ()
+{
+  return (history_offset);
+}
+
+/* Make the current history item be the one at POS, an absolute index.
+   Returns zero if POS is out of range, else non-zero. */
+int
+history_set_pos (pos)
+     int pos;
+{
+  if (pos > history_length || pos < 0 || !the_history)
+    return (0);
+  history_offset = pos;
+  return (1);
+}
+ 
+/* Return the current history array.  The caller has to be carefull, since this
+   is the actual array of data, and could be bashed or made corrupt easily.
+   The array is terminated with a NULL pointer. */
+HIST_ENTRY **
+history_list ()
+{
+  return (the_history);
+}
+
+/* Return the history entry at the current position, as determined by
+   history_offset.  If there is no entry there, return a NULL pointer. */
+HIST_ENTRY *
+current_history ()
+{
+  return ((history_offset == history_length) || the_history == 0)
+		? (HIST_ENTRY *)NULL
+		: the_history[history_offset];
+}
+
+/* Back up history_offset to the previous history entry, and return
+   a pointer to that entry.  If there is no previous entry then return
+   a NULL pointer. */
+HIST_ENTRY *
+previous_history ()
+{
+  return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)NULL;
+}
+
+/* Move history_offset forward to the next history entry, and return
+   a pointer to that entry.  If there is no next entry then return a
+   NULL pointer. */
+HIST_ENTRY *
+next_history ()
+{
+  return (history_offset == history_length) ? (HIST_ENTRY *)NULL : the_history[++history_offset];
+}
+
+/* Return the history entry which is logically at OFFSET in the history array.
+   OFFSET is relative to history_base. */
+HIST_ENTRY *
+history_get (offset)
+     int offset;
+{
+  int local_index;
+
+  local_index = offset - history_base;
+  return (local_index >= history_length || local_index < 0 || !the_history)
+		? (HIST_ENTRY *)NULL
+		: the_history[local_index];
+}
+
+/* Place STRING at the end of the history list.  The data field
+   is  set to NULL. */
+void
+add_history (string)
+     char *string;
+{
+  HIST_ENTRY *temp;
+
+  if (history_stifled && (history_length == max_input_history))
+    {
+      register int i;
+
+      /* If the history is stifled, and history_length is zero,
+	 and it equals max_input_history, we don't save items. */
+      if (history_length == 0)
+	return;
+
+      /* If there is something in the slot, then remove it. */
+      if (the_history[0])
+	{
+	  free (the_history[0]->line);
+	  free (the_history[0]);
+	}
+
+      /* Copy the rest of the entries, moving down one slot. */
+      for (i = 0; i < history_length; i++)
+	the_history[i] = the_history[i + 1];
+
+      history_base++;
+    }
+  else
+    {
+      if (history_size == 0)
+	{
+	  history_size = DEFAULT_HISTORY_GROW_SIZE;
+	  the_history = (HIST_ENTRY **)xmalloc (history_size * sizeof (HIST_ENTRY *));
+	  history_length = 1;
+	}
+      else
+	{
+	  if (history_length == (history_size - 1))
+	    {
+	      history_size += DEFAULT_HISTORY_GROW_SIZE;
+	      the_history = (HIST_ENTRY **)
+		xrealloc (the_history, history_size * sizeof (HIST_ENTRY *));
+	    }
+	  history_length++;
+	}
+    }
+
+  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
+  temp->line = savestring (string);
+  temp->data = (char *)NULL;
+
+  the_history[history_length] = (HIST_ENTRY *)NULL;
+  the_history[history_length - 1] = temp;
+}
+
+/* Make the history entry at WHICH have LINE and DATA.  This returns
+   the old entry so you can dispose of the data.  In the case of an
+   invalid WHICH, a NULL pointer is returned. */
+HIST_ENTRY *
+replace_history_entry (which, line, data)
+     int which;
+     char *line;
+     char *data;
+{
+  HIST_ENTRY *temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
+  HIST_ENTRY *old_value;
+
+  if (which >= history_length)
+    return ((HIST_ENTRY *)NULL);
+
+  old_value = the_history[which];
+
+  temp->line = savestring (line);
+  temp->data = data;
+  the_history[which] = temp;
+
+  return (old_value);
+}
+
+/* Remove history element WHICH from the history.  The removed
+   element is returned to you so you can free the line, data,
+   and containing structure. */
+HIST_ENTRY *
+remove_history (which)
+     int which;
+{
+  HIST_ENTRY *return_value;
+
+  if (which >= history_length || !history_length)
+    return_value = (HIST_ENTRY *)NULL;
+  else
+    {
+      register int i;
+      return_value = the_history[which];
+
+      for (i = which; i < history_length; i++)
+	the_history[i] = the_history[i + 1];
+
+      history_length--;
+    }
+
+  return (return_value);
+}
+
+/* Stifle the history list, remembering only MAX number of lines. */
+void
+stifle_history (max)
+     int max;
+{
+  if (max < 0)
+    max = 0;
+
+  if (history_length > max)
+    {
+      register int i, j;
+
+      /* This loses because we cannot free the data. */
+      for (i = 0, j = history_length - max; i < j; i++)
+	{
+	  free (the_history[i]->line);
+	  free (the_history[i]);
+	}
+
+      history_base = i;
+      for (j = 0, i = history_length - max; j < max; i++, j++)
+	the_history[j] = the_history[i];
+      the_history[j] = (HIST_ENTRY *)NULL;
+      history_length = j;
+    }
+
+  history_stifled = 1;
+  max_input_history = max;
+}
+
+/* Stop stifling the history.  This returns the previous amount the 
+   history was stifled by.  The value is positive if the history was
+   stifled,  negative if it wasn't. */
+int
+unstifle_history ()
+{
+  if (history_stifled)
+    {
+      history_stifled = 0;
+      return (-max_input_history);
+    }
+
+  return (max_input_history);
+}
+
+int
+history_is_stifled ()
+{
+  return (history_stifled);
+}
+
+void
+clear_history ()
+{
+  register int i;
+
+  /* This loses because we cannot free the data. */
+  for (i = 0; i < history_length; i++)
+    {
+      free (the_history[i]->line);
+      free (the_history[i]);
+      the_history[i] = (HIST_ENTRY *)NULL;
+    }
+
+  history_offset = history_length = 0;
+}
diff --git a/readline/history.h b/readline/history.h
new file mode 100644
--- /dev/null
+++ b/readline/history.h
@@ -0,0 +1,223 @@
+/* History.h -- the names of functions that you can call in history. */
+/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
+
+   This file contains the GNU History Library (the Library), a set of
+   routines for managing the text of previously typed lines.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#ifndef _HISTORY_H_
+#define _HISTORY_H_
+
+#if !defined (_FUNCTION_DEF)
+#  define _FUNCTION_DEF
+typedef int Function ();
+typedef void VFunction ();
+typedef char *CPFunction ();
+typedef char **CPPFunction ();
+#endif
+
+/* The structure used to store a history entry. */
+typedef struct _hist_entry {
+  char *line;
+  char *data;
+} HIST_ENTRY;
+
+/* A structure used to pass the current state of the history stuff around. */
+typedef struct _hist_state {
+  HIST_ENTRY **entries;		/* Pointer to the entries themselves. */
+  int offset;			/* The location pointer within this array. */
+  int length;			/* Number of elements within this array. */
+  int size;			/* Number of slots allocated to this array. */
+  int flags;
+} HISTORY_STATE;
+
+/* Flag values for the `flags' member of HISTORY_STATE. */
+#define HS_STIFLED	0x01
+
+/* Initialization and state management. */
+
+/* Begin a session in which the history functions might be used.  This
+   just initializes the interactive variables. */
+extern void using_history ();
+
+/* Return the current HISTORY_STATE of the history. */
+extern HISTORY_STATE *history_get_history_state ();
+
+/* Set the state of the current history array to STATE. */
+extern void history_set_history_state ();
+
+/* Manage the history list. */
+
+/* Place STRING at the end of the history list.
+   The associated data field (if any) is set to NULL. */
+extern void add_history ();
+
+/* A reasonably useless function, only here for completeness.  WHICH
+   is the magic number that tells us which element to delete.  The
+   elements are numbered from 0. */
+extern HIST_ENTRY *remove_history ();
+
+/* Make the history entry at WHICH have LINE and DATA.  This returns
+   the old entry so you can dispose of the data.  In the case of an
+   invalid WHICH, a NULL pointer is returned. */
+extern HIST_ENTRY *replace_history_entry ();
+
+/* Clear the history list and start over. */
+extern void clear_history ();
+
+/* Stifle the history list, remembering only MAX number of entries. */
+extern void stifle_history ();
+
+/* Stop stifling the history.  This returns the previous amount the
+   history was stifled by.  The value is positive if the history was
+   stifled, negative if it wasn't. */
+extern int unstifle_history ();
+
+/* Return 1 if the history is stifled, 0 if it is not. */
+extern int history_is_stifled ();
+
+/* Information about the history list. */
+
+/* Return a NULL terminated array of HIST_ENTRY which is the current input
+   history.  Element 0 of this list is the beginning of time.  If there
+   is no history, return NULL. */
+extern HIST_ENTRY **history_list ();
+
+/* Returns the number which says what history element we are now
+   looking at.  */
+extern int where_history ();
+  
+/* Return the history entry at the current position, as determined by
+   history_offset.  If there is no entry there, return a NULL pointer. */
+HIST_ENTRY *current_history ();
+
+/* Return the history entry which is logically at OFFSET in the history
+   array.  OFFSET is relative to history_base. */
+extern HIST_ENTRY *history_get ();
+
+/* Return the number of bytes that the primary history entries are using.
+   This just adds up the lengths of the_history->lines. */
+extern int history_total_bytes ();
+
+/* Moving around the history list. */
+
+/* Set the position in the history list to POS. */
+int history_set_pos ();
+
+/* Back up history_offset to the previous history entry, and return
+   a pointer to that entry.  If there is no previous entry, return
+   a NULL pointer. */
+extern HIST_ENTRY *previous_history ();
+
+/* Move history_offset forward to the next item in the input_history,
+   and return the a pointer to that entry.  If there is no next entry,
+   return a NULL pointer. */
+extern HIST_ENTRY *next_history ();
+
+/* Searching the history list. */
+
+/* Search the history for STRING, starting at history_offset.
+   If DIRECTION < 0, then the search is through previous entries,
+   else through subsequent.  If the string is found, then
+   current_history () is the history entry, and the value of this function
+   is the offset in the line of that history entry that the string was
+   found in.  Otherwise, nothing is changed, and a -1 is returned. */
+extern int history_search ();
+
+/* Search the history for STRING, starting at history_offset.
+   The search is anchored: matching lines must begin with string. */
+extern int history_search_prefix ();
+
+/* Search for STRING in the history list, starting at POS, an
+   absolute index into the list.  DIR, if negative, says to search
+   backwards from POS, else forwards.
+   Returns the absolute index of the history element where STRING
+   was found, or -1 otherwise. */
+extern int history_search_pos ();
+
+/* Managing the history file. */
+
+/* Add the contents of FILENAME to the history list, a line at a time.
+   If FILENAME is NULL, then read from ~/.history.  Returns 0 if
+   successful, or errno if not. */
+extern int read_history ();
+
+/* Read a range of lines from FILENAME, adding them to the history list.
+   Start reading at the FROM'th line and end at the TO'th.  If FROM
+   is zero, start at the beginning.  If TO is less than FROM, read
+   until the end of the file.  If FILENAME is NULL, then read from
+   ~/.history.  Returns 0 if successful, or errno if not. */
+extern int read_history_range ();
+
+/* Write the current history to FILENAME.  If FILENAME is NULL,
+   then write the history list to ~/.history.  Values returned
+   are as in read_history ().  */
+extern int write_history ();
+
+/* Append NELEMENT entries to FILENAME.  The entries appended are from
+   the end of the list minus NELEMENTs up to the end of the list. */
+int append_history ();
+
+/* Truncate the history file, leaving only the last NLINES lines. */
+extern int history_truncate_file ();
+
+/* History expansion. */
+
+/* Expand the string STRING, placing the result into OUTPUT, a pointer
+   to a string.  Returns:
+
+   0) If no expansions took place (or, if the only change in
+      the text was the de-slashifying of the history expansion
+      character)
+   1) If expansions did take place
+  -1) If there was an error in expansion.
+   2) If the returned line should just be printed.
+
+  If an error ocurred in expansion, then OUTPUT contains a descriptive
+  error message. */
+extern int history_expand ();
+
+/* Extract a string segment consisting of the FIRST through LAST
+   arguments present in STRING.  Arguments are broken up as in
+   the shell. */
+extern char *history_arg_extract ();
+
+/* Return the text of the history event beginning at the current
+   offset into STRING. */
+extern char *get_history_event ();
+
+/* Return an array of tokens, much as the shell might.  The tokens are
+   parsed out of STRING. */
+extern char **history_tokenize ();
+
+/* Exported history variables. */
+extern int history_base;
+extern int history_length;
+extern int max_input_history;
+extern char history_expansion_char;
+extern char history_subst_char;
+extern char history_comment_char;
+extern char *history_no_expand_chars;
+extern char *history_search_delimiter_chars;
+extern int history_quotes_inhibit_expansion;
+
+/* If set, this function is called to decide whether or not a particular
+   history expansion should be treated as a special case for the calling
+   application and not expanded. */
+extern Function *history_inhibit_expansion_function;
+
+#endif /* !_HISTORY_H_ */
diff --git a/readline/histsearch.c b/readline/histsearch.c
new file mode 100644
--- /dev/null
+++ b/readline/histsearch.c
@@ -0,0 +1,197 @@
+/* histsearch.c -- searching the history list. */
+
+/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.
+
+   This file contains the GNU History Library (the Library), a set of
+   routines for managing the text of previously typed lines.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+#if defined (HAVE_STRING_H)
+#  include <string.h>
+#else
+#  include <strings.h>
+#endif /* !HAVE_STRING_H */
+
+#include "history.h"
+#include "histlib.h"
+
+/* Variables imported from other history library files. */
+extern int history_offset;
+
+/* The list of alternate characters that can delimit a history search
+   string. */
+char *history_search_delimiter_chars = (char *)NULL;
+
+/* Search the history for STRING, starting at history_offset.
+   If DIRECTION < 0, then the search is through previous entries, else
+   through subsequent.  If ANCHORED is non-zero, the string must
+   appear at the beginning of a history line, otherwise, the string
+   may appear anywhere in the line.  If the string is found, then
+   current_history () is the history entry, and the value of this
+   function is the offset in the line of that history entry that the
+   string was found in.  Otherwise, nothing is changed, and a -1 is
+   returned. */
+
+static int
+history_search_internal (string, direction, anchored)
+     char *string;
+     int direction, anchored;
+{
+  register int i, reverse;
+  register char *line;
+  register int line_index;
+  int string_len;
+  HIST_ENTRY **the_history; 	/* local */
+
+  i = history_offset;
+  reverse = (direction < 0);
+
+  /* Take care of trivial cases first. */
+  if (string == 0 || *string == '\0')
+    return (-1);
+
+  if (!history_length || ((i == history_length) && !reverse))
+    return (-1);
+
+  if (reverse && (i == history_length))
+    i--;
+
+#define NEXT_LINE() do { if (reverse) i--; else i++; } while (0)
+
+  the_history = history_list ();
+  string_len = strlen (string);
+  while (1)
+    {
+      /* Search each line in the history list for STRING. */
+
+      /* At limit for direction? */
+      if ((reverse && i < 0) || (!reverse && i == history_length))
+	return (-1);
+
+      line = the_history[i]->line;
+      line_index = strlen (line);
+
+      /* If STRING is longer than line, no match. */
+      if (string_len > line_index)
+	{
+	  NEXT_LINE ();
+	  continue;
+	}
+
+      /* Handle anchored searches first. */
+      if (anchored == ANCHORED_SEARCH)
+	{
+	  if (STREQN (string, line, string_len))
+	    {
+	      history_offset = i;
+	      return (0);
+	    }
+
+	  NEXT_LINE ();
+	  continue;
+	}
+
+      /* Do substring search. */
+      if (reverse)
+	{
+	  line_index -= string_len;
+
+	  while (line_index >= 0)
+	    {
+	      if (STREQN (string, line + line_index, string_len))
+		{
+		  history_offset = i;
+		  return (line_index);
+		}
+	      line_index--;
+	    }
+	}
+      else
+	{
+	  register int limit;
+
+	  limit = line_index - string_len + 1;
+	  line_index = 0;
+
+	  while (line_index < limit)
+	    {
+	      if (STREQN (string, line + line_index, string_len))
+		{
+		  history_offset = i;
+		  return (line_index);
+		}
+	      line_index++;
+	    }
+	}
+      NEXT_LINE ();
+    }
+}
+
+/* Do a non-anchored search for STRING through the history in DIRECTION. */
+int
+history_search (string, direction)
+     char *string;
+     int direction;
+{
+  return (history_search_internal (string, direction, NON_ANCHORED_SEARCH));
+}
+
+/* Do an anchored search for string through the history in DIRECTION. */
+int
+history_search_prefix (string, direction)
+     char *string;
+     int direction;
+{
+  return (history_search_internal (string, direction, ANCHORED_SEARCH));
+}
+
+/* Search for STRING in the history list.  DIR is < 0 for searching
+   backwards.  POS is an absolute index into the history list at
+   which point to begin searching. */
+int
+history_search_pos (string, dir, pos)
+     char *string;
+     int dir, pos;
+{
+  int ret, old;
+
+  old = where_history ();
+  history_set_pos (pos);
+  if (history_search (string, dir) == -1)
+    {
+      history_set_pos (old);
+      return (-1);
+    }
+  ret = where_history ();
+  history_set_pos (old);
+  return ret;
+}
diff --git a/readline/input.c b/readline/input.c
new file mode 100644
--- /dev/null
+++ b/readline/input.c
@@ -0,0 +1,449 @@
+/* input.c -- character input functions for readline. */
+
+/* Copyright (C) 1994 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 2, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <fcntl.h>
+#if defined (HAVE_SYS_FILE_H)
+#  include <sys/file.h>
+#endif /* HAVE_SYS_FILE_H */
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#if defined (HAVE_SELECT)
+#  if !defined (HAVE_SYS_SELECT_H) || !defined (M_UNIX)
+#    include <sys/time.h>
+#  endif
+#endif /* HAVE_SELECT */
+#if defined (HAVE_SYS_SELECT_H)
+#  include <sys/select.h>
+#endif
+
+#if defined (FIONREAD_IN_SYS_IOCTL)
+#  include <sys/ioctl.h>
+#endif
+
+#include <stdio.h>
+#include <errno.h>
+
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+/* Some standard library routines. */
+#include "readline.h"
+
+/* What kind of non-blocking I/O do we have? */
+#if !defined (O_NDELAY) && defined (O_NONBLOCK)
+#  define O_NDELAY O_NONBLOCK	/* Posix style */
+#endif
+
+/* Functions imported from other files in the library. */
+extern char *xmalloc (), *xrealloc ();
+
+/* Variables and functions from macro.c. */
+extern void _rl_add_macro_char ();
+extern void _rl_with_macro_input ();
+extern int _rl_next_macro_key ();
+extern int _rl_defining_kbd_macro;
+
+#if defined (VI_MODE)
+extern void _rl_vi_set_last ();
+extern int _rl_vi_textmod_command ();
+#endif /* VI_MODE */
+
+extern FILE *rl_instream, *rl_outstream;
+extern Function *rl_last_func;
+extern int rl_key_sequence_length;
+extern int rl_pending_input;
+extern int rl_editing_mode;
+
+extern Keymap _rl_keymap;
+
+extern int _rl_convert_meta_chars_to_ascii;
+
+#if defined (__GO32__)
+#  include <pc.h>
+#endif /* __GO32__ */
+
+/* Non-null means it is a pointer to a function to run while waiting for
+   character input. */
+Function *rl_event_hook = (Function *)NULL;
+
+Function *rl_getc_function = rl_getc;
+
+/* **************************************************************** */
+/*								    */
+/*			Character Input Buffering       	    */
+/*								    */
+/* **************************************************************** */
+
+static int pop_index, push_index;
+static unsigned char ibuffer[512];
+static int ibuffer_len = sizeof (ibuffer) - 1;
+
+#define any_typein (push_index != pop_index)
+
+int
+_rl_any_typein ()
+{
+  return any_typein;
+}
+
+/* Add KEY to the buffer of characters to be read. */
+int
+rl_stuff_char (key)
+     int key;
+{
+  if (key == EOF)
+    {
+      key = NEWLINE;
+      rl_pending_input = EOF;
+    }
+  ibuffer[push_index++] = key;
+  if (push_index >= ibuffer_len)
+    push_index = 0;
+  return push_index;
+}
+
+/* Make C be the next command to be executed. */
+int
+rl_execute_next (c)
+     int c;
+{
+  rl_pending_input = c;
+  return 0;
+}
+
+/* Return the amount of space available in the
+   buffer for stuffing characters. */
+static int
+ibuffer_space ()
+{
+  if (pop_index > push_index)
+    return (pop_index - push_index);
+  else
+    return (ibuffer_len - (push_index - pop_index));
+}
+
+/* Get a key from the buffer of characters to be read.
+   Return the key in KEY.
+   Result is KEY if there was a key, or 0 if there wasn't. */
+static int
+rl_get_char (key)
+     int *key;
+{
+  if (push_index == pop_index)
+    return (0);
+
+  *key = ibuffer[pop_index++];
+
+  if (pop_index >= ibuffer_len)
+    pop_index = 0;
+
+  return (1);
+}
+
+/* Stuff KEY into the *front* of the input buffer.
+   Returns non-zero if successful, zero if there is
+   no space left in the buffer. */
+static int
+rl_unget_char (key)
+     int key;
+{
+  if (ibuffer_space ())
+    {
+      pop_index--;
+      if (pop_index < 0)
+	pop_index = ibuffer_len - 1;
+      ibuffer[pop_index] = key;
+      return (1);
+    }
+  return (0);
+}
+
+/* If a character is available to be read, then read it
+   and stuff it into IBUFFER.  Otherwise, just return. */
+static void
+rl_gather_tyi ()
+{
+#if defined (__GO32__)
+  char input;
+
+  if (isatty (0) && kbhit () && ibuffer_space ())
+    {
+      int i;
+      i = (*rl_getc_function) (rl_instream);
+      rl_stuff_char (i);
+    }
+#else /* !__GO32__ */
+
+  int tty;
+  register int tem, result;
+  int chars_avail;
+  char input;
+#if defined(HAVE_SELECT)
+  fd_set readfds, exceptfds;
+  struct timeval timeout;
+#endif
+
+  tty = fileno (rl_instream);
+
+#if defined (HAVE_SELECT)
+  FD_ZERO (&readfds);
+  FD_ZERO (&exceptfds);
+  FD_SET (tty, &readfds);
+  FD_SET (tty, &exceptfds);
+  timeout.tv_sec = 0;
+  timeout.tv_usec = 100000;	/* 0.1 seconds */
+  if (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) <= 0)
+    return;	/* Nothing to read. */
+#endif
+
+  result = -1;
+#if defined (FIONREAD)
+  result = ioctl (tty, FIONREAD, &chars_avail);
+#endif
+
+#if defined (O_NDELAY)
+  if (result == -1)
+    {
+      tem = fcntl (tty, F_GETFL, 0);
+
+      fcntl (tty, F_SETFL, (tem | O_NDELAY));
+      chars_avail = read (tty, &input, 1);
+
+      fcntl (tty, F_SETFL, tem);
+      if (chars_avail == -1 && errno == EAGAIN)
+	return;
+    }
+#endif /* O_NDELAY */
+
+  /* If there's nothing available, don't waste time trying to read
+     something. */
+  if (chars_avail <= 0)
+    return;
+
+  tem = ibuffer_space ();
+
+  if (chars_avail > tem)
+    chars_avail = tem;
+
+  /* One cannot read all of the available input.  I can only read a single
+     character at a time, or else programs which require input can be
+     thwarted.  If the buffer is larger than one character, I lose.
+     Damn! */
+  if (tem < ibuffer_len)
+    chars_avail = 0;
+
+  if (result != -1)
+    {
+      while (chars_avail--)
+	rl_stuff_char ((*rl_getc_function) (rl_instream));
+    }
+  else
+    {
+      if (chars_avail)
+	rl_stuff_char (input);
+    }
+#endif /* !__GO32__ */
+}
+
+/* Is there input available to be read on the readline input file
+   descriptor?  Only works if the system has select(2) or FIONREAD. */
+int
+_rl_input_available ()
+{
+#if defined(HAVE_SELECT)
+  fd_set readfds, exceptfds;
+  struct timeval timeout;
+#endif
+#if defined(FIONREAD)
+  int chars_avail;
+#endif
+  int tty;
+
+  tty = fileno (rl_instream);
+
+#if defined (HAVE_SELECT)
+  FD_ZERO (&readfds);
+  FD_ZERO (&exceptfds);
+  FD_SET (tty, &readfds);
+  FD_SET (tty, &exceptfds);
+  timeout.tv_sec = 0;
+  timeout.tv_usec = 100000;	/* 0.1 seconds */
+  return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);
+#endif
+
+#if defined (FIONREAD)
+  if (ioctl (tty, FIONREAD, &chars_avail) == 0)
+    return (chars_avail);
+#endif
+
+  return 0;
+}
+
+void
+_rl_insert_typein (c)
+     int c;     
+{    	
+  int key, t, i;
+  char *string;
+
+  i = key = 0;
+  string = xmalloc (ibuffer_len + 1);
+  string[i++] = (char) c;
+
+  while ((t = rl_get_char (&key)) &&
+	 _rl_keymap[key].type == ISFUNC &&
+	 _rl_keymap[key].function == rl_insert)
+    string[i++] = key;
+
+  if (t)
+    rl_unget_char (key);
+
+  string[i] = '\0';
+  rl_insert_text (string);
+  free (string);
+}
+
+/* **************************************************************** */
+/*								    */
+/*			     Character Input			    */
+/*								    */
+/* **************************************************************** */
+
+/* Read a key, including pending input. */
+int
+rl_read_key ()
+{
+  int c;
+
+  rl_key_sequence_length++;
+
+  if (rl_pending_input)
+    {
+      c = rl_pending_input;
+      rl_pending_input = 0;
+    }
+  else
+    {
+      /* If input is coming from a macro, then use that. */
+      if (c = _rl_next_macro_key ())
+	return (c);
+
+      /* If the user has an event function, then call it periodically. */
+      if (rl_event_hook)
+	{
+	  while (rl_event_hook && rl_get_char (&c) == 0)
+	    {
+	      (*rl_event_hook) ();
+	      rl_gather_tyi ();
+	    }
+	}
+      else
+	{
+	  if (rl_get_char (&c) == 0)
+	    c = (*rl_getc_function) (rl_instream);
+	}
+    }
+
+  return (c);
+}
+
+int
+rl_getc (stream)
+     FILE *stream;
+{
+  int result, flags;
+  unsigned char c;
+
+#if defined (__GO32__)
+  if (isatty (0))
+    return (getkey () & 0x7F);
+#endif /* __GO32__ */
+
+  while (1)
+    {
+      result = read (fileno (stream), &c, sizeof (unsigned char));
+
+      if (result == sizeof (unsigned char))
+	return (c);
+
+      /* If zero characters are returned, then the file that we are
+	 reading from is empty!  Return EOF in that case. */
+      if (result == 0)
+	return (EOF);
+
+#if defined (EWOULDBLOCK)
+      if (errno == EWOULDBLOCK)
+	{
+	  if ((flags = fcntl (fileno (stream), F_GETFL, 0)) < 0)
+	    return (EOF);
+	  if (flags & O_NDELAY)
+	    {
+	      flags &= ~O_NDELAY;
+	      fcntl (fileno (stream), F_SETFL, flags);
+	      continue;
+	    }
+	  continue;
+	}
+#endif /* EWOULDBLOCK */
+
+#if defined (_POSIX_VERSION) && defined (EAGAIN) && defined (O_NONBLOCK)
+      if (errno == EAGAIN)
+	{
+	  if ((flags = fcntl (fileno (stream), F_GETFL, 0)) < 0)
+	    return (EOF);
+	  if (flags & O_NONBLOCK)
+	    {
+	      flags &= ~O_NONBLOCK;
+	      fcntl (fileno (stream), F_SETFL, flags);
+	      continue;
+	    }
+	}
+#endif /* _POSIX_VERSION && EAGAIN && O_NONBLOCK */
+
+#if !defined (__GO32__)
+      /* If the error that we received was SIGINT, then try again,
+	 this is simply an interrupted system call to read ().
+	 Otherwise, some error ocurred, also signifying EOF. */
+      if (errno != EINTR)
+	return (EOF);
+#endif /* !__GO32__ */
+    }
+}
diff --git a/readline/isearch.c b/readline/isearch.c
new file mode 100644
--- /dev/null
+++ b/readline/isearch.c
@@ -0,0 +1,418 @@
+/* **************************************************************** */
+/*								    */
+/*			I-Search and Searching			    */
+/*								    */
+/* **************************************************************** */
+
+/* Copyright (C) 1987,1989 Free Software Foundation, Inc.
+
+   This file contains the Readline Library (the Library), a set of
+   routines for providing Emacs style line input to programs that ask
+   for it.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#include <stdio.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif
+
+#include "rldefs.h"
+#include "readline.h"
+#include "history.h"
+
+/* Variables imported from other files in the readline library. */
+extern Keymap _rl_keymap;
+extern HIST_ENTRY *saved_line_for_history;
+extern int rl_line_buffer_len;
+extern int rl_point, rl_end;
+extern char *rl_line_buffer;
+
+extern void _rl_save_prompt ();
+extern void _rl_restore_prompt ();
+
+extern int rl_execute_next ();
+extern void rl_extend_line_buffer ();
+
+extern int _rl_input_available ();
+
+extern char *xmalloc (), *xrealloc ();
+
+static int rl_search_history ();
+
+/* Last line found by the current incremental search, so we don't `find'
+   identical lines many times in a row. */
+static char *prev_line_found;
+
+/* Search backwards through the history looking for a string which is typed
+   interactively.  Start with the current line. */
+int
+rl_reverse_search_history (sign, key)
+     int sign, key;
+{
+  return (rl_search_history (-sign, key));
+}
+
+/* Search forwards through the history looking for a string which is typed
+   interactively.  Start with the current line. */
+int
+rl_forward_search_history (sign, key)
+     int sign, key;
+{
+  return (rl_search_history (sign, key));
+}
+
+/* Display the current state of the search in the echo-area.
+   SEARCH_STRING contains the string that is being searched for,
+   DIRECTION is zero for forward, or 1 for reverse,
+   WHERE is the history list number of the current line.  If it is
+   -1, then this line is the starting one. */
+static void
+rl_display_search (search_string, reverse_p, where)
+     char *search_string;
+     int reverse_p, where;
+{
+  char *message;
+  int msglen, searchlen;
+
+  searchlen = (search_string && *search_string) ? strlen (search_string) : 0;
+
+  message = xmalloc (searchlen + 33);
+  msglen = 0;
+
+#if defined (NOTDEF)
+  if (where != -1)
+    {
+      sprintf (message, "[%d]", where + history_base);
+      msglen = strlen (message);
+    }
+#endif /* NOTDEF */
+
+  message[msglen++] = '(';
+
+  if (reverse_p)
+    {
+      strcpy (message + msglen, "reverse-");
+      msglen += 8;
+    }
+
+  strcpy (message + msglen, "i-search)`");
+  msglen += 10;
+
+  if (search_string)
+    {
+      strcpy (message + msglen, search_string);
+      msglen += searchlen;
+    }
+
+  strcpy (message + msglen, "': ");
+
+  rl_message ("%s", message, 0);
+  free (message);
+  (*rl_redisplay_function) ();
+}
+
+/* Search through the history looking for an interactively typed string.
+   This is analogous to i-search.  We start the search in the current line.
+   DIRECTION is which direction to search; >= 0 means forward, < 0 means
+   backwards. */
+static int
+rl_search_history (direction, invoking_key)
+     int direction, invoking_key;
+{
+  /* The string that the user types in to search for. */
+  char *search_string;
+
+  /* The current length of SEARCH_STRING. */
+  int search_string_index;
+
+  /* The amount of space that SEARCH_STRING has allocated to it. */
+  int search_string_size;
+
+  /* The list of lines to search through. */
+  char **lines, *allocated_line;
+
+  /* The length of LINES. */
+  int hlen;
+
+  /* Where we get LINES from. */
+  HIST_ENTRY **hlist;
+
+  register int i;
+  int orig_point, orig_line, last_found_line;
+  int c, found, failed, sline_len;
+
+  /* The line currently being searched. */
+  char *sline;
+
+  /* Offset in that line. */
+  int line_index;
+
+  /* Non-zero if we are doing a reverse search. */
+  int reverse;
+
+  orig_point = rl_point;
+  last_found_line = orig_line = where_history ();
+  reverse = direction < 0;
+  hlist = history_list ();
+  allocated_line = (char *)NULL;
+
+  /* Create an arrary of pointers to the lines that we want to search. */
+  maybe_replace_line ();
+  i = 0;
+  if (hlist)
+    for (i = 0; hlist[i]; i++);
+
+  /* Allocate space for this many lines, +1 for the current input line,
+     and remember those lines. */
+  lines = (char **)xmalloc ((1 + (hlen = i)) * sizeof (char *));
+  for (i = 0; i < hlen; i++)
+    lines[i] = hlist[i]->line;
+
+  if (saved_line_for_history)
+    lines[i] = saved_line_for_history->line;
+  else
+    {
+      /* Keep track of this so we can free it. */
+      allocated_line = xmalloc (1 + strlen (rl_line_buffer));
+      strcpy (allocated_line, &rl_line_buffer[0]);
+      lines[i] = allocated_line;
+    }
+
+  hlen++;
+
+  /* The line where we start the search. */
+  i = orig_line;
+
+  _rl_save_prompt ();
+
+  /* Initialize search parameters. */
+  search_string = xmalloc (search_string_size = 128);
+  *search_string = '\0';
+  search_string_index = 0;
+  prev_line_found = (char *)0;		/* XXX */
+
+  /* Normalize DIRECTION into 1 or -1. */
+  direction = (direction >= 0) ? 1 : -1;
+
+  rl_display_search (search_string, reverse, -1);
+
+  sline = rl_line_buffer;
+  sline_len = strlen (sline);
+  line_index = rl_point;
+
+  found = failed = 0;
+  for (;;)
+    {
+      Function *f = (Function *)NULL;
+
+      /* Read a key and decide how to proceed. */
+      c = rl_read_key ();
+
+      if (_rl_keymap[c].type == ISFUNC)
+	{
+	  f = _rl_keymap[c].function;
+
+	  if (f == rl_reverse_search_history)
+	    c = reverse ? -1 : -2;
+	  else if (f == rl_forward_search_history)
+	    c =  !reverse ? -1 : -2;
+	}
+
+      /* Let NEWLINE (^J) terminate the search for people who don't like
+	 using ESC.  ^M can still be used to terminate the search and
+	 immediately execute the command. */
+      if (c == ESC || c == NEWLINE)
+	{
+	  /* ESC still terminates the search, but if there is pending
+	     input or if input arrives within 0.1 seconds (on systems
+	     with select(2)) it is used as a prefix character
+	     with rl_execute_next.  WATCH OUT FOR THIS!  This is intended
+	     to allow the arrow keys to be used like ^F and ^B are used
+	     to terminate the search and execute the movement command. */
+	  if (c == ESC && _rl_input_available ())	/* XXX */
+	    rl_execute_next (ESC);
+	  break;
+	}
+
+      if (c >= 0 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT))
+	{
+	  rl_execute_next (c);
+	  break;
+	}
+
+      switch (c)
+	{
+	case -1:
+	  if (search_string_index == 0)
+	    continue;
+	  else if (reverse)
+	    --line_index;
+	  else if (line_index != sline_len)
+	    ++line_index;
+	  else
+	    ding ();
+	  break;
+
+	  /* switch directions */
+	case -2:
+	  direction = -direction;
+	  reverse = direction < 0;
+	  break;
+
+	case CTRL ('G'):
+	  strcpy (rl_line_buffer, lines[orig_line]);
+	  rl_point = orig_point;
+	  rl_end = strlen (rl_line_buffer);
+	  _rl_restore_prompt();
+	  rl_clear_message ();
+	  if (allocated_line)
+	    free (allocated_line);
+	  free (lines);
+	  return 0;
+
+	default:
+	  /* Add character to search string and continue search. */
+	  if (search_string_index + 2 >= search_string_size)
+	    {
+	      search_string_size += 128;
+	      search_string = xrealloc (search_string, search_string_size);
+	    }
+	  search_string[search_string_index++] = c;
+	  search_string[search_string_index] = '\0';
+	  break;
+	}
+
+      for (found = failed = 0;;)
+	{
+	  int limit = sline_len - search_string_index + 1;
+
+	  /* Search the current line. */
+	  while (reverse ? (line_index >= 0) : (line_index < limit))
+	    {
+	      if (STREQN (search_string, sline + line_index, search_string_index))
+		{
+		  found++;
+		  break;
+		}
+	      else
+		line_index += direction;
+	    }
+	  if (found)
+	    break;
+
+	  /* Move to the next line, but skip new copies of the line
+	     we just found and lines shorter than the string we're
+	     searching for. */
+	  do
+	    {
+	      /* Move to the next line. */
+	      i += direction;
+
+	      /* At limit for direction? */
+	      if (reverse ? (i < 0) : (i == hlen))
+		{
+		  failed++;
+		  break;
+		}
+
+	      /* We will need these later. */
+	      sline = lines[i];
+	      sline_len = strlen (sline);
+	    }
+	  while ((prev_line_found && STREQ (prev_line_found, lines[i])) ||
+		 (search_string_index > sline_len));
+
+	  if (failed)
+	    break;
+
+	  /* Now set up the line for searching... */
+	  line_index = reverse ? sline_len - search_string_index : 0;
+	}
+
+      if (failed)
+	{
+	  /* We cannot find the search string.  Ding the bell. */
+	  ding ();
+	  i = last_found_line;
+	  continue; 		/* XXX - was break */
+	}
+
+      /* We have found the search string.  Just display it.  But don't
+	 actually move there in the history list until the user accepts
+	 the location. */
+      if (found)
+	{
+	  int line_len;
+
+	  prev_line_found = lines[i];
+	  line_len = strlen (lines[i]);
+
+	  if (line_len >= rl_line_buffer_len)
+	    rl_extend_line_buffer (line_len);
+
+	  strcpy (rl_line_buffer, lines[i]);
+	  rl_point = line_index;
+	  rl_end = line_len;
+	  last_found_line = i;
+	  rl_display_search (search_string, reverse, (i == orig_line) ? -1 : i);
+	}
+    }
+
+  /* The searching is over.  The user may have found the string that she
+     was looking for, or else she may have exited a failing search.  If
+     LINE_INDEX is -1, then that shows that the string searched for was
+     not found.  We use this to determine where to place rl_point. */
+
+  /* First put back the original state. */
+  strcpy (rl_line_buffer, lines[orig_line]);
+
+  _rl_restore_prompt ();
+
+  /* Free the search string. */
+  free (search_string);
+
+  if (last_found_line < orig_line)
+    rl_get_previous_history (orig_line - last_found_line);
+  else
+    rl_get_next_history (last_found_line - orig_line);
+
+  /* If the string was not found, put point at the end of the line. */
+  if (line_index < 0)
+    line_index = strlen (rl_line_buffer);
+  rl_point = line_index;
+  rl_clear_message ();
+
+  if (allocated_line)
+    free (allocated_line);
+  free (lines);
+
+  return 0;
+}
diff --git a/readline/keymaps.c b/readline/keymaps.c
new file mode 100644
--- /dev/null
+++ b/readline/keymaps.c
@@ -0,0 +1,150 @@
+/* keymaps.c -- Functions and keymaps for the GNU Readline library. */
+
+/* Copyright (C) 1988,1989 Free Software Foundation, Inc.
+
+   This file is part of GNU Readline, a library for reading lines
+   of text with interactive input and history editing.
+
+   Readline is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 1, or (at your option) any
+   later version.
+
+   Readline is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Readline; see the file COPYING.  If not, write to the Free
+   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include "rlconf.h"
+#include "keymaps.h"
+#include "emacs_keymap.c"
+
+#if defined (VI_MODE)
+#include "vi_keymap.c"
+#endif
+
+extern int rl_do_lowercase_version ();
+extern int rl_rubout (), rl_insert ();
+
+extern char *xmalloc (), *xrealloc ();
+
+/* **************************************************************** */
+/*								    */
+/*		      Functions for manipulating Keymaps.	    */
+/*								    */
+/* **************************************************************** */
+
+
+/* Return a new, empty keymap.
+   Free it with free() when you are done. */
+Keymap
+rl_make_bare_keymap ()
+{
+  register int i;
+  Keymap keymap = (Keymap)xmalloc (KEYMAP_SIZE * sizeof (KEYMAP_ENTRY));
+
+  for (i = 0; i < KEYMAP_SIZE; i++)
+    {
+      keymap[i].type = ISFUNC;
+      keymap[i].function = (Function *)NULL;
+    }
+
+  for (i = 'A'; i < ('Z' + 1); i++)
+    {
+      keymap[i].type = ISFUNC;
+      keymap[i].function = rl_do_lowercase_version;
+    }
+
+  return (keymap);
+}
+
+/* Return a new keymap which is a copy of MAP. */
+Keymap
+rl_copy_keymap (map)
+     Keymap map;
+{
+  register int i;
+  Keymap temp = rl_make_bare_keymap ();
+
+  for (i = 0; i < KEYMAP_SIZE; i++)
+    {
+      temp[i].type = map[i].type;
+      temp[i].function = map[i].function;
+    }
+  return (temp);
+}
+
+/* Return a new keymap with the printing characters bound to rl_insert,
+   the uppercase Meta characters bound to run their lowercase equivalents,
+   and the Meta digits bound to produce numeric arguments. */
+Keymap
+rl_make_keymap ()
+{
+  register int i;
+  Keymap newmap;
+
+  newmap = rl_make_bare_keymap ();
+
+  /* All ASCII printing characters are self-inserting. */
+  for (i = ' '; i < 127; i++)
+    newmap[i].function = rl_insert;
+
+  newmap[TAB].function = rl_insert;
+  newmap[RUBOUT].function = rl_rubout;	/* RUBOUT == 127 */
+  newmap[CTRL('H')].function = rl_rubout;
+
+#if KEYMAP_SIZE > 128
+  /* Printing characters in some 8-bit character sets. */
+  for (i = 128; i < 160; i++)
+    newmap[i].function = rl_insert;
+
+  /* ISO Latin-1 printing characters should self-insert. */
+  for (i = 160; i < 256; i++)
+    newmap[i].function = rl_insert;
+#endif /* KEYMAP_SIZE > 128 */
+
+  return (newmap);
+}
+
+/* Free the storage associated with MAP. */
+void
+rl_discard_keymap (map)
+     Keymap (map);
+{
+  int i;
+
+  if (!map)
+    return;
+
+  for (i = 0; i < KEYMAP_SIZE; i++)
+    {
+      switch (map[i].type)
+	{
+	case ISFUNC:
+	  break;
+
+	case ISKMAP:
+	  rl_discard_keymap ((Keymap)map[i].function);
+	  break;
+
+	case ISMACR:
+	  free ((char *)map[i].function);
+	  break;
+	}
+    }
+}
diff --git a/readline/keymaps.h b/readline/keymaps.h
new file mode 100644
--- /dev/null
+++ b/readline/keymaps.h
@@ -0,0 +1,95 @@
+/* keymaps.h -- Manipulation of readline keymaps. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#ifndef _KEYMAPS_H_
+#define _KEYMAPS_H_
+
+#if defined (READLINE_LIBRARY)
+#  include "chardefs.h"
+#else
+#  include <readline/chardefs.h>
+#endif
+
+#if !defined (_FUNCTION_DEF)
+#  define _FUNCTION_DEF
+typedef int Function ();
+typedef void VFunction ();
+typedef char *CPFunction ();
+typedef char **CPPFunction ();
+#endif
+
+/* A keymap contains one entry for each key in the ASCII set.
+   Each entry consists of a type and a pointer.
+   POINTER is the address of a function to run, or the
+   address of a keymap to indirect through.
+   TYPE says which kind of thing POINTER is. */
+typedef struct _keymap_entry {
+  char type;
+  Function *function;
+} KEYMAP_ENTRY;
+
+/* This must be large enough to hold bindings for all of the characters
+   in a desired character set (e.g, 128 for ASCII, 256 for ISO Latin-x,
+   and so on). */
+#define KEYMAP_SIZE 256
+
+/* I wanted to make the above structure contain a union of:
+   union { Function *function; struct _keymap_entry *keymap; } value;
+   but this made it impossible for me to create a static array.
+   Maybe I need C lessons. */
+
+typedef KEYMAP_ENTRY KEYMAP_ENTRY_ARRAY[KEYMAP_SIZE];
+typedef KEYMAP_ENTRY *Keymap;
+
+/* The values that TYPE can have in a keymap entry. */
+#define ISFUNC 0
+#define ISKMAP 1
+#define ISMACR 2
+
+extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap, emacs_meta_keymap, emacs_ctlx_keymap;
+extern KEYMAP_ENTRY_ARRAY vi_insertion_keymap, vi_movement_keymap;
+
+/* Return a new, empty keymap.
+   Free it with free() when you are done. */
+extern Keymap rl_make_bare_keymap ();
+
+/* Return a new keymap which is a copy of MAP. */
+extern Keymap rl_copy_keymap ();
+
+/* Return a new keymap with the printing characters bound to rl_insert,
+   the lowercase Meta characters bound to run their equivalents, and
+   the Meta digits bound to produce numeric arguments. */
+extern Keymap rl_make_keymap ();
+
+extern void rl_discard_keymap ();
+
+/* Return the keymap corresponding to a given name.  Names look like
+   `emacs' or `emacs-meta' or `vi-insert'. */
+extern Keymap rl_get_keymap_by_name ();
+
+/* Return the current keymap. */
+extern Keymap rl_get_keymap ();
+
+/* Set the current keymap to MAP. */
+extern void rl_set_keymap ();
+
+#endif /* _KEYMAPS_H_ */
diff --git a/readline/kill.c b/readline/kill.c
new file mode 100644
--- /dev/null
+++ b/readline/kill.c
@@ -0,0 +1,552 @@
+/* kill.c -- kill ring management. */
+
+/* Copyright (C) 1994 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>           /* for _POSIX_VERSION */
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include <stdio.h>
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+/* Some standard library routines. */
+#include "readline.h"
+#include "history.h"
+
+extern int _rl_last_command_was_kill;
+extern int rl_editing_mode;
+extern int rl_explicit_arg;
+extern Function *rl_last_func;
+
+extern void _rl_init_argument ();
+extern int _rl_set_mark_at_pos ();
+extern void _rl_fix_point ();
+extern void _rl_abort_internal ();
+
+extern char *xmalloc (), *xrealloc ();
+
+/* **************************************************************** */
+/*								    */
+/*			Killing Mechanism			    */
+/*								    */
+/* **************************************************************** */
+
+/* What we assume for a max number of kills. */
+#define DEFAULT_MAX_KILLS 10
+
+/* The real variable to look at to find out when to flush kills. */
+static int rl_max_kills =  DEFAULT_MAX_KILLS;
+
+/* Where to store killed text. */
+static char **rl_kill_ring = (char **)NULL;
+
+/* Where we are in the kill ring. */
+static int rl_kill_index;
+
+/* How many slots we have in the kill ring. */
+static int rl_kill_ring_length;
+
+/* How to say that you only want to save a certain amount
+   of kill material. */
+int
+rl_set_retained_kills (num)
+     int num;
+{
+  return 0;
+}
+
+/* Add TEXT to the kill ring, allocating a new kill ring slot as necessary.
+   This uses TEXT directly, so the caller must not free it.  If APPEND is
+   non-zero, and the last command was a kill, the text is appended to the
+   current kill ring slot, otherwise prepended. */
+static int
+_rl_copy_to_kill_ring (text, append)
+     char *text;
+     int append;
+{
+  char *old, *new;
+  int slot;
+
+  /* First, find the slot to work with. */
+  if (_rl_last_command_was_kill == 0)
+    {
+      /* Get a new slot.  */
+      if (rl_kill_ring == 0)
+	{
+	  /* If we don't have any defined, then make one. */
+	  rl_kill_ring = (char **)
+	    xmalloc (((rl_kill_ring_length = 1) + 1) * sizeof (char *));
+	  rl_kill_ring[slot = 0] = (char *)NULL;
+	}
+      else
+	{
+	  /* We have to add a new slot on the end, unless we have
+	     exceeded the max limit for remembering kills. */
+	  slot = rl_kill_ring_length;
+	  if (slot == rl_max_kills)
+	    {
+	      register int i;
+	      free (rl_kill_ring[0]);
+	      for (i = 0; i < slot; i++)
+		rl_kill_ring[i] = rl_kill_ring[i + 1];
+	    }
+	  else
+	    {
+	      slot = rl_kill_ring_length += 1;
+	      rl_kill_ring = (char **)xrealloc (rl_kill_ring, slot * sizeof (char *));
+	    }
+	  rl_kill_ring[--slot] = (char *)NULL;
+	}
+    }
+  else
+    slot = rl_kill_ring_length - 1;
+
+  /* If the last command was a kill, prepend or append. */
+  if (_rl_last_command_was_kill && rl_editing_mode != vi_mode)
+    {
+      old = rl_kill_ring[slot];
+      new = xmalloc (1 + strlen (old) + strlen (text));
+
+      if (append)
+	{
+	  strcpy (new, old);
+	  strcat (new, text);
+	}
+      else
+	{
+	  strcpy (new, text);
+	  strcat (new, old);
+	}
+      free (old);
+      free (text);
+      rl_kill_ring[slot] = new;
+    }
+  else
+    rl_kill_ring[slot] = text;
+
+  rl_kill_index = slot;
+  return 0;
+}
+
+/* The way to kill something.  This appends or prepends to the last
+   kill, if the last command was a kill command.  if FROM is less
+   than TO, then the text is appended, otherwise prepended.  If the
+   last command was not a kill command, then a new slot is made for
+   this kill. */
+int
+rl_kill_text (from, to)
+     int from, to;
+{
+  char *text;
+
+  /* Is there anything to kill? */
+  if (from == to)
+    {
+      _rl_last_command_was_kill++;
+      return 0;
+    }
+
+  text = rl_copy_text (from, to);
+
+  /* Delete the copied text from the line. */
+  rl_delete_text (from, to);
+
+  _rl_copy_to_kill_ring (text, from < to);
+
+  _rl_last_command_was_kill++;
+  return 0;
+}
+
+/* Now REMEMBER!  In order to do prepending or appending correctly, kill
+   commands always make rl_point's original position be the FROM argument,
+   and rl_point's extent be the TO argument. */
+
+/* **************************************************************** */
+/*								    */
+/*			Killing Commands			    */
+/*								    */
+/* **************************************************************** */
+
+/* Delete the word at point, saving the text in the kill ring. */
+int
+rl_kill_word (count, key)
+     int count, key;
+{
+  int orig_point = rl_point;
+
+  if (count < 0)
+    return (rl_backward_kill_word (-count, key));
+  else
+    {
+      rl_forward_word (count, key);
+
+      if (rl_point != orig_point)
+	rl_kill_text (orig_point, rl_point);
+
+      rl_point = orig_point;
+    }
+  return 0;
+}
+
+/* Rubout the word before point, placing it on the kill ring. */
+int
+rl_backward_kill_word (count, ignore)
+     int count, ignore;
+{
+  int orig_point = rl_point;
+
+  if (count < 0)
+    return (rl_kill_word (-count, ignore));
+  else
+    {
+      rl_backward_word (count, ignore);
+
+      if (rl_point != orig_point)
+	rl_kill_text (orig_point, rl_point);
+    }
+  return 0;
+}
+
+/* Kill from here to the end of the line.  If DIRECTION is negative, kill
+   back to the line start instead. */
+int
+rl_kill_line (direction, ignore)
+     int direction, ignore;
+{
+  int orig_point = rl_point;
+
+  if (direction < 0)
+    return (rl_backward_kill_line (1, ignore));
+  else
+    {
+      rl_end_of_line (1, ignore);
+      if (orig_point != rl_point)
+	rl_kill_text (orig_point, rl_point);
+      rl_point = orig_point;
+    }
+  return 0;
+}
+
+/* Kill backwards to the start of the line.  If DIRECTION is negative, kill
+   forwards to the line end instead. */
+int
+rl_backward_kill_line (direction, ignore)
+     int direction, ignore;
+{
+  int orig_point = rl_point;
+
+  if (direction < 0)
+    return (rl_kill_line (1, ignore));
+  else
+    {
+      if (!rl_point)
+	ding ();
+      else
+	{
+	  rl_beg_of_line (1, ignore);
+	  rl_kill_text (orig_point, rl_point);
+	}
+    }
+  return 0;
+}
+
+/* Kill the whole line, no matter where point is. */
+int
+rl_kill_full_line (count, ignore)
+     int count, ignore;
+{
+  rl_begin_undo_group ();
+  rl_point = 0;
+  rl_kill_text (rl_point, rl_end);
+  rl_end_undo_group ();
+  return 0;
+}
+
+/* The next two functions mimic unix line editing behaviour, except they
+   save the deleted text on the kill ring.  This is safer than not saving
+   it, and since we have a ring, nobody should get screwed. */
+
+/* This does what C-w does in Unix.  We can't prevent people from
+   using behaviour that they expect. */
+int
+rl_unix_word_rubout (count, key)
+     int count, key;
+{
+  int orig_point;
+
+  if (rl_point == 0)
+    ding ();
+  else
+    {
+      orig_point = rl_point;
+      if (count <= 0)
+	count = 1;
+
+      while (count--)
+	{
+	  while (rl_point && whitespace (rl_line_buffer[rl_point - 1]))
+	    rl_point--;
+
+	  while (rl_point && (whitespace (rl_line_buffer[rl_point - 1]) == 0))
+	    rl_point--;
+	}
+
+      rl_kill_text (orig_point, rl_point);
+    }
+  return 0;
+}
+
+/* Here is C-u doing what Unix does.  You don't *have* to use these
+   key-bindings.  We have a choice of killing the entire line, or
+   killing from where we are to the start of the line.  We choose the
+   latter, because if you are a Unix weenie, then you haven't backspaced
+   into the line at all, and if you aren't, then you know what you are
+   doing. */
+int
+rl_unix_line_discard (count, key)
+     int count, key;
+{
+  if (rl_point == 0)
+    ding ();
+  else
+    {
+      rl_kill_text (rl_point, 0);
+      rl_point = 0;
+    }
+  return 0;
+}
+
+/* Copy the text in the `region' to the kill ring.  If DELETE is non-zero,
+   delete the text from the line as well. */
+static int
+region_kill_internal (delete)
+     int delete;
+{
+  char *text;
+
+  if (rl_mark == rl_point)
+    {
+      _rl_last_command_was_kill++;
+      return 0;
+    }
+
+  text = rl_copy_text (rl_point, rl_mark);
+  if (delete)
+    rl_delete_text (rl_point, rl_mark);
+  _rl_copy_to_kill_ring (text, rl_point < rl_mark);
+
+  _rl_last_command_was_kill++;
+  return 0;
+}
+
+/* Copy the text in the region to the kill ring. */
+int
+rl_copy_region_to_kill (count, ignore)
+     int count, ignore;
+{
+  return (region_kill_internal (0));
+}
+
+/* Kill the text between the point and mark. */
+int
+rl_kill_region (count, ignore)
+     int count, ignore;
+{
+  int r;
+
+  r = region_kill_internal (1);
+  _rl_fix_point (1);
+  return r;
+}
+
+/* Copy COUNT words to the kill ring.  DIR says which direction we look
+   to find the words. */
+static int
+_rl_copy_word_as_kill (count, dir)
+     int count, dir;
+{
+  int om, op, r;
+
+  om = rl_mark;
+  op = rl_point;
+
+  if (dir > 0)
+    rl_forward_word (count, 0);
+  else
+    rl_backward_word (count, 0);
+
+  rl_mark = rl_point;
+
+  if (dir > 0)
+    rl_backward_word (count, 0);
+  else
+    rl_forward_word (count, 0);
+
+  r = region_kill_internal (0);
+
+  rl_mark = om;
+  rl_point = op;
+
+  return r;
+}
+
+int
+rl_copy_forward_word (count, key)
+     int count, key;
+{
+  if (count < 0)
+    return (rl_copy_backward_word (-count, key));
+
+  return (_rl_copy_word_as_kill (count, 1));
+}
+
+int
+rl_copy_backward_word (count, key)
+     int count, key;
+{
+  if (count < 0)
+    return (rl_copy_forward_word (-count, key));
+
+  return (_rl_copy_word_as_kill (count, -1));
+}
+  
+/* Yank back the last killed text.  This ignores arguments. */
+int
+rl_yank (count, ignore)
+     int count, ignore;
+{
+  if (rl_kill_ring == 0)
+    {
+      _rl_abort_internal ();
+      return -1;
+    }
+
+  _rl_set_mark_at_pos (rl_point);
+  rl_insert_text (rl_kill_ring[rl_kill_index]);
+  return 0;
+}
+
+/* If the last command was yank, or yank_pop, and the text just
+   before point is identical to the current kill item, then
+   delete that text from the line, rotate the index down, and
+   yank back some other text. */
+int
+rl_yank_pop (count, key)
+     int count, key;
+{
+  int l, n;
+
+  if (((rl_last_func != rl_yank_pop) && (rl_last_func != rl_yank)) ||
+      !rl_kill_ring)
+    {
+      _rl_abort_internal ();
+      return -1;
+    }
+
+  l = strlen (rl_kill_ring[rl_kill_index]);
+  n = rl_point - l;
+  if (n >= 0 && STREQN (rl_line_buffer + n, rl_kill_ring[rl_kill_index], l))
+    {
+      rl_delete_text (n, rl_point);
+      rl_point = n;
+      rl_kill_index--;
+      if (rl_kill_index < 0)
+	rl_kill_index = rl_kill_ring_length - 1;
+      rl_yank (1, 0);
+      return 0;
+    }
+  else
+    {
+      _rl_abort_internal ();
+      return -1;
+    }
+}
+
+/* Yank the COUNTth argument from the previous history line. */
+int
+rl_yank_nth_arg (count, ignore)
+     int count, ignore;
+{
+  register HIST_ENTRY *entry;
+  char *arg;
+
+  entry = previous_history ();
+  if (entry)
+    next_history ();
+  else
+    {
+      ding ();
+      return -1;
+    }
+
+  arg = history_arg_extract (count, count, entry->line);
+  if (!arg || !*arg)
+    {
+      ding ();
+      return -1;
+    }
+
+  rl_begin_undo_group ();
+
+#if defined (VI_MODE)
+  /* Vi mode always inserts a space before yanking the argument, and it
+     inserts it right *after* rl_point. */
+  if (rl_editing_mode == vi_mode)
+    {
+      rl_vi_append_mode (1, ignore);
+      rl_insert_text (" ");
+    }
+#endif /* VI_MODE */
+
+  rl_insert_text (arg);
+  free (arg);
+
+  rl_end_undo_group ();
+  return 0;
+}
+
+/* Yank the last argument from the previous history line.  This `knows'
+   how rl_yank_nth_arg treats a count of `$'.  With an argument, this
+   behaves the same as rl_yank_nth_arg. */
+int
+rl_yank_last_arg (count, key)
+     int count, key;
+{
+  if (rl_explicit_arg)
+    return (rl_yank_nth_arg (count, key));
+  else
+    return (rl_yank_nth_arg ('$', key));
+}
diff --git a/readline/macro.c b/readline/macro.c
new file mode 100644
--- /dev/null
+++ b/readline/macro.c
@@ -0,0 +1,277 @@
+/* macro.c -- keyboard macros for readline. */
+
+/* Copyright (C) 1994 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>           /* for _POSIX_VERSION */
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include <stdio.h>
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+/* Some standard library routines. */
+#include "readline.h"
+#include "history.h"
+
+#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
+
+/* Forward definitions. */
+void _rl_push_executing_macro (), _rl_pop_executing_macro ();
+void _rl_add_macro_char ();
+
+/* Extern declarations. */
+extern int rl_explicit_arg;
+extern int rl_key_sequence_length;
+
+extern void _rl_abort_internal ();
+
+extern char *xmalloc (), *xrealloc ();
+
+/* **************************************************************** */
+/*								    */
+/*			Hacking Keyboard Macros 		    */
+/*								    */
+/* **************************************************************** */
+
+/* Non-zero means to save keys that we dispatch on in a kbd macro. */
+int _rl_defining_kbd_macro = 0;
+
+/* The currently executing macro string.  If this is non-zero,
+   then it is a malloc ()'ed string where input is coming from. */
+char *_rl_executing_macro = (char *)NULL;
+
+/* The offset in the above string to the next character to be read. */
+static int executing_macro_index;
+
+/* The current macro string being built.  Characters get stuffed
+   in here by add_macro_char (). */
+static char *current_macro = (char *)NULL;
+
+/* The size of the buffer allocated to current_macro. */
+static int current_macro_size;
+
+/* The index at which characters are being added to current_macro. */
+static int current_macro_index;
+
+/* A structure used to save nested macro strings.
+   It is a linked list of string/index for each saved macro. */
+struct saved_macro {
+  struct saved_macro *next;
+  char *string;
+  int sindex;
+};
+
+/* The list of saved macros. */
+static struct saved_macro *macro_list = (struct saved_macro *)NULL;
+
+/* Set up to read subsequent input from STRING.
+   STRING is free ()'ed when we are done with it. */
+void
+_rl_with_macro_input (string)
+     char *string;
+{
+  _rl_push_executing_macro ();
+  _rl_executing_macro = string;
+  executing_macro_index = 0;
+}
+
+/* Return the next character available from a macro, or 0 if
+   there are no macro characters. */
+int
+_rl_next_macro_key ()
+{
+  if (_rl_executing_macro == 0)
+    return (0);
+
+  if (_rl_executing_macro[executing_macro_index] == 0)
+    {
+      _rl_pop_executing_macro ();
+      return (_rl_next_macro_key ());
+    }
+
+  return (_rl_executing_macro[executing_macro_index++]);
+}
+
+/* Save the currently executing macro on a stack of saved macros. */
+void
+_rl_push_executing_macro ()
+{
+  struct saved_macro *saver;
+
+  saver = (struct saved_macro *)xmalloc (sizeof (struct saved_macro));
+  saver->next = macro_list;
+  saver->sindex = executing_macro_index;
+  saver->string = _rl_executing_macro;
+
+  macro_list = saver;
+}
+
+/* Discard the current macro, replacing it with the one
+   on the top of the stack of saved macros. */
+void
+_rl_pop_executing_macro ()
+{
+  struct saved_macro *macro;
+
+  if (_rl_executing_macro)
+    free (_rl_executing_macro);
+
+  _rl_executing_macro = (char *)NULL;
+  executing_macro_index = 0;
+
+  if (macro_list)
+    {
+      macro = macro_list;
+      _rl_executing_macro = macro_list->string;
+      executing_macro_index = macro_list->sindex;
+      macro_list = macro_list->next;
+      free (macro);
+    }
+}
+
+/* Add a character to the macro being built. */
+void
+_rl_add_macro_char (c)
+     int c;
+{
+  if (current_macro_index + 1 >= current_macro_size)
+    {
+      if (current_macro == 0)
+	current_macro = xmalloc (current_macro_size = 25);
+      else
+	current_macro = xrealloc (current_macro, current_macro_size += 25);
+    }
+
+  current_macro[current_macro_index++] = c;
+  current_macro[current_macro_index] = '\0';
+}
+
+void
+_rl_kill_kbd_macro ()
+{
+  if (current_macro)
+    {
+      free (current_macro);
+      current_macro = (char *) NULL;
+    }
+  current_macro_size = current_macro_index = 0;
+
+  if (_rl_executing_macro)
+    {
+      free (_rl_executing_macro);
+      _rl_executing_macro = (char *) NULL;
+    }
+  executing_macro_index = 0;
+
+  _rl_defining_kbd_macro = 0;
+}
+
+/* Begin defining a keyboard macro.
+   Keystrokes are recorded as they are executed.
+   End the definition with rl_end_kbd_macro ().
+   If a numeric argument was explicitly typed, then append this
+   definition to the end of the existing macro, and start by
+   re-executing the existing macro. */
+int
+rl_start_kbd_macro (ignore1, ignore2)
+     int ignore1, ignore2;
+{
+  if (_rl_defining_kbd_macro)
+    {
+      _rl_abort_internal ();
+      return -1;
+    }
+
+  if (rl_explicit_arg)
+    {
+      if (current_macro)
+	_rl_with_macro_input (savestring (current_macro));
+    }
+  else
+    current_macro_index = 0;
+
+  _rl_defining_kbd_macro = 1;
+  return 0;
+}
+
+/* Stop defining a keyboard macro.
+   A numeric argument says to execute the macro right now,
+   that many times, counting the definition as the first time. */
+int
+rl_end_kbd_macro (count, ignore)
+     int count, ignore;
+{
+  if (_rl_defining_kbd_macro == 0)
+    {
+      _rl_abort_internal ();
+      return -1;
+    }
+
+  current_macro_index -= rl_key_sequence_length - 1;
+  current_macro[current_macro_index] = '\0';
+
+  _rl_defining_kbd_macro = 0;
+
+  return (rl_call_last_kbd_macro (--count, 0));
+}
+
+/* Execute the most recently defined keyboard macro.
+   COUNT says how many times to execute it. */
+int
+rl_call_last_kbd_macro (count, ignore)
+     int count, ignore;
+{
+  if (current_macro == 0)
+    _rl_abort_internal ();
+
+  if (_rl_defining_kbd_macro)
+    {
+      ding ();		/* no recursive macros */
+      current_macro[--current_macro_index] = '\0';	/* erase this char */
+      return 0;
+    }
+
+  while (count--)
+    _rl_with_macro_input (savestring (current_macro));
+  return 0;
+}
+
+void
+rl_push_macro_input (macro)
+     char *macro;
+{
+  _rl_with_macro_input (macro);
+}
diff --git a/readline/nls.c b/readline/nls.c
new file mode 100644
--- /dev/null
+++ b/readline/nls.c
@@ -0,0 +1,227 @@
+/* nls.c -- skeletal internationalization code. */
+
+/* Copyright (C) 1996 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#if defined (HAVE_LOCALE_H)
+#  include <locale.h>
+#endif
+
+#include <ctype.h>
+
+#include "rldefs.h"
+
+extern int _rl_convert_meta_chars_to_ascii;
+extern int _rl_output_meta_chars;
+extern int _rl_meta_flag;
+
+/* Functions imported from shell.c */
+extern char *get_env_value ();
+
+#if !defined (HAVE_SETLOCALE)    
+/* A list of legal values for the LANG or LC_CTYPE environment variables.
+   If a locale name in this list is the value for the LC_ALL, LC_CTYPE,
+   or LANG environment variable (using the first of those with a value),
+   readline eight-bit mode is enabled. */
+static char *legal_lang_values[] =
+{
+ "iso88591",
+ "iso88592",
+ "iso88593",
+ "iso88594",
+ "iso88595",
+ "iso88596",
+ "iso88597",
+ "iso88598",
+ "iso88599",
+ "iso885910",
+ "koi8r",   
+  0
+};
+
+static char *normalize_codeset ();
+static char *find_codeset ();
+#endif /* !HAVE_SETLOCALE */
+
+/* Check for LC_ALL, LC_CTYPE, and LANG and use the first with a value
+   to decide the defaults for 8-bit character input and output.  Returns
+   1 if we set eight-bit mode. */
+int
+_rl_init_eightbit ()
+{
+/* If we have setlocale(3), just check the current LC_CTYPE category
+   value, and go into eight-bit mode if it's not C or POSIX. */
+#if defined (HAVE_SETLOCALE)
+  char *t;
+
+  /* Set the LC_CTYPE locale category from environment variables. */
+  t = setlocale (LC_CTYPE, "");
+  if (t && *t && (t[0] != 'C' || t[1]) && (STREQ (t, "POSIX") == 0))
+    {
+      _rl_meta_flag = 1;
+      _rl_convert_meta_chars_to_ascii = 0;
+      _rl_output_meta_chars = 1;
+      return (1);
+    }
+  else
+    return (0);
+
+#else /* !HAVE_SETLOCALE */
+  char *lspec, *t;
+  int i;
+
+  /* We don't have setlocale.  Finesse it.  Check the environment for the
+     appropriate variables and set eight-bit mode if they have the right
+     values. */
+  lspec = get_env_value ("LC_ALL");
+  if (lspec == 0) lspec = get_env_value ("LC_CTYPE");
+  if (lspec == 0) lspec = get_env_value ("LANG");
+  if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)
+    return (0);
+  for (i = 0; t && legal_lang_values[i]; i++)
+    if (STREQ (t, legal_lang_values[i]))
+      {
+	_rl_meta_flag = 1;
+	_rl_convert_meta_chars_to_ascii = 0;
+	_rl_output_meta_chars = 1;
+	break;
+      }
+  free (t);
+  return (legal_lang_values[i] ? 1 : 0);
+
+#endif /* !HAVE_SETLOCALE */
+}
+
+#if !defined (HAVE_SETLOCALE)
+static char *
+normalize_codeset (codeset)
+     char *codeset;
+{
+  size_t namelen, i;
+  int len, all_digits;
+  char *wp, *retval;
+
+  codeset = find_codeset (codeset, &namelen);
+
+  if (codeset == 0)
+    return (codeset);
+
+  all_digits = 1;
+  for (len = 0, i = 0; i < namelen; i++)
+    {
+      if (isalnum (codeset[i]))
+	{
+	  len++;
+	  all_digits &= isdigit (codeset[i]);
+	}
+    }
+
+  retval = (char *)malloc ((all_digits ? 3 : 0) + len + 1);
+  if (retval == 0)
+    return ((char *)0);
+
+  wp = retval;
+  /* Add `iso' to beginning of an all-digit codeset */
+  if (all_digits)
+    {
+      *wp++ = 'i';
+      *wp++ = 's';
+      *wp++ = 'o';
+    }
+
+  for (i = 0; i < namelen; i++)
+    if (isalpha (codeset[i]))
+      *wp++ = (isupper (codeset[i])) ? tolower (codeset[i]) : codeset[i];
+    else if (isdigit (codeset[i]))
+      *wp++ = codeset[i];
+  *wp = '\0';
+
+  return retval;
+}
+
+/* Isolate codeset portion of locale specification. */
+static char *
+find_codeset (name, lenp)
+     char *name;
+     size_t *lenp;
+{
+  char *cp, *language, *result;
+
+  cp = language = name;
+  result = (char *)0;
+
+  while (*cp && *cp != '_' && *cp != '@' && *cp != '+' && *cp != ',')
+    cp++;
+
+  /* This does not make sense: language has to be specified.  As
+     an exception we allow the variable to contain only the codeset
+     name.  Perhaps there are funny codeset names.  */
+  if (language == cp) 
+    {
+      *lenp = strlen (language);
+      result = language;
+    }
+  else
+    {
+      /* Next is the territory. */
+      if (*cp == '_')
+	do
+	  ++cp;
+	while (*cp && *cp != '.' && *cp != '@' && *cp != '+' && *cp != ',' && *cp != '_');
+
+      /* Now, finally, is the codeset. */
+      result = cp;
+      if (*cp == '.')
+	do
+	  ++cp;
+	while (*cp && *cp != '@');
+
+      if (cp - result > 2)
+	{
+	  result++;
+	  *lenp = cp - result;
+	}
+      else
+	{
+	  *lenp = strlen (language);
+	  result = language;
+	}
+    }
+
+  return result;
+}
+#endif /* !HAVE_SETLOCALE */
diff --git a/readline/parens.c b/readline/parens.c
new file mode 100644
--- /dev/null
+++ b/readline/parens.c
@@ -0,0 +1,156 @@
+/* parens.c -- Implementation of matching parentheses feature. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#include "rlconf.h"
+
+#if !defined (PAREN_MATCHING)
+extern int rl_insert ();
+
+int
+rl_insert_close (count, invoking_key)
+     int count, invoking_key;
+{
+  return (rl_insert (count, invoking_key));
+}
+
+#else /* PAREN_MATCHING */
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+#include <sys/types.h>
+
+#if defined (FD_SET) && !defined (HAVE_SELECT)
+#  define HAVE_SELECT
+#endif
+
+#if defined (HAVE_SELECT)
+#  include <sys/time.h>
+#endif /* HAVE_SELECT */
+#if defined (HAVE_SYS_SELECT_H)
+#  include <sys/select.h>
+#endif
+
+#if defined (HAVE_STRING_H)
+#  include <string.h>
+#else /* !HAVE_STRING_H */
+#  include <strings.h>
+#endif /* !HAVE_STRING_H */
+
+#if !defined (strchr) && !defined (__STDC__)
+extern char *strchr (), *strrchr ();
+#endif /* !strchr && !__STDC__ */
+
+#include "readline.h"
+
+extern int rl_explicit_arg;
+
+/* Non-zero means try to blink the matching open parenthesis when the
+   close parenthesis is inserted. */
+#if defined (HAVE_SELECT)
+int rl_blink_matching_paren = 1;
+#else /* !HAVE_SELECT */
+int rl_blink_matching_paren = 0;
+#endif /* !HAVE_SELECT */
+
+static int find_matching_open ();
+
+int
+rl_insert_close (count, invoking_key)
+     int count, invoking_key;
+{
+  if (rl_explicit_arg || !rl_blink_matching_paren)
+    rl_insert (count, invoking_key);
+  else
+    {
+#if defined (HAVE_SELECT)
+      int orig_point, match_point, ready;
+      struct timeval timer;
+      fd_set readfds;
+
+      rl_insert (1, invoking_key);
+      (*rl_redisplay_function) ();
+      match_point =
+	find_matching_open (rl_line_buffer, rl_point - 2, invoking_key);
+
+      /* Emacs might message or ring the bell here, but I don't. */
+      if (match_point < 0)
+	return -1;
+
+      FD_ZERO (&readfds);
+      FD_SET (fileno (rl_instream), &readfds);
+      timer.tv_sec = 1;
+      timer.tv_usec = 500;
+
+      orig_point = rl_point;
+      rl_point = match_point;
+      (*rl_redisplay_function) ();
+      ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
+      rl_point = orig_point;
+#else /* !HAVE_SELECT */
+      rl_insert (count, invoking_key);
+#endif /* !HAVE_SELECT */
+    }
+  return 0;
+}
+
+static int
+find_matching_open (string, from, closer)
+     char *string;
+     int from, closer;
+{
+  register int i;
+  int opener, level, delimiter;
+
+  switch (closer)
+    {
+    case ']': opener = '['; break;
+    case '}': opener = '{'; break;
+    case ')': opener = '('; break;
+    default:
+      return (-1);
+    }
+
+  level = 1;			/* The closer passed in counts as 1. */
+  delimiter = 0;		/* Delimited state unknown. */
+
+  for (i = from; i > -1; i--)
+    {
+      if (delimiter && (string[i] == delimiter))
+	delimiter = 0;
+      else if (rl_basic_quote_characters && strchr (rl_basic_quote_characters, string[i]))
+	delimiter = string[i];
+      else if (!delimiter && (string[i] == closer))
+	level++;
+      else if (!delimiter && (string[i] == opener))
+	level--;
+
+      if (!level)
+	break;
+    }
+  return (i);
+}
+
+#endif /* PAREN_MATCHING */
diff --git a/readline/posixdir.h b/readline/posixdir.h
new file mode 100644
--- /dev/null
+++ b/readline/posixdir.h
@@ -0,0 +1,49 @@
+/* posixdir.h -- Posix directory reading includes and defines. */
+
+/* Copyright (C) 1987,1991 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   Bash is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash; see the file COPYING.  If not, write to the Free
+   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+/* This file should be included instead of <dirent.h> or <sys/dir.h>. */
+
+#if !defined (_POSIXDIR_H_)
+#define _POSIXDIR_H_
+
+#if defined (HAVE_DIRENT_H)
+#  include <dirent.h>
+#  define D_NAMLEN(d)   (strlen ((d)->d_name))
+#else
+#  if defined (HAVE_SYS_NDIR_H)
+#    include <sys/ndir.h>
+#  endif
+#  if defined (HAVE_SYS_DIR_H)
+#    include <sys/dir.h>
+#  endif
+#  if defined (HAVE_NDIR_H)
+#    include <ndir.h>
+#  endif
+#  if !defined (dirent)
+#    define dirent direct
+#  endif /* !dirent */
+#  define D_NAMLEN(d)   ((d)->d_namlen)
+#endif /* !HAVE_DIRENT_H */
+
+#if defined (STRUCT_DIRENT_HAS_D_INO) && !defined (STRUCT_DIRENT_HAS_D_FILENO)
+#  define d_fileno d_ino
+#endif
+
+#endif /* !_POSIXDIR_H_ */
diff --git a/readline/posixjmp.h b/readline/posixjmp.h
new file mode 100644
--- /dev/null
+++ b/readline/posixjmp.h
@@ -0,0 +1,20 @@
+/* posixjmp.h -- wrapper for setjmp.h with changes for POSIX systems. */
+
+#ifndef _POSIXJMP_H_
+#define _POSIXJMP_H_
+
+#include <setjmp.h>
+
+/* This *must* be included *after* config.h */
+
+#if defined (HAVE_POSIX_SIGSETJMP)
+#  define procenv_t	sigjmp_buf
+#  undef setjmp
+#  define setjmp(x)	sigsetjmp((x), 1)
+#  undef longjmp
+#  define longjmp(x, n)	siglongjmp((x), (n))
+#else
+#  define procenv_t	jmp_buf
+#endif
+
+#endif /* _POSIXJMP_H_ */
diff --git a/readline/posixstat.h b/readline/posixstat.h
new file mode 100644
--- /dev/null
+++ b/readline/posixstat.h
@@ -0,0 +1,142 @@
+/* posixstat.h -- Posix stat(2) definitions for systems that
+   don't have them. */
+
+/* Copyright (C) 1987,1991 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   Bash is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash; see the file COPYING.  If not, write to the Free
+   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+/* This file should be included instead of <sys/stat.h>.
+   It relies on the local sys/stat.h to work though. */
+#if !defined (_POSIXSTAT_H_)
+#define _POSIXSTAT_H_
+
+#include <sys/stat.h>
+
+#if defined (STAT_MACROS_BROKEN)
+#  undef S_ISBLK
+#  undef S_ISCHR
+#  undef S_ISDIR
+#  undef S_ISFIFO
+#  undef S_ISREG
+#  undef S_ISLNK
+#endif /* STAT_MACROS_BROKEN */
+
+/* These are guaranteed to work only on isc386 */
+#if !defined (S_IFDIR) && !defined (S_ISDIR)
+#  define S_IFDIR 0040000
+#endif /* !S_IFDIR && !S_ISDIR */
+#if !defined (S_IFMT)
+#  define S_IFMT  0170000
+#endif /* !S_IFMT */
+
+/* Posix 1003.1 5.6.1.1 <sys/stat.h> file types */
+
+/* Some Posix-wannabe systems define _S_IF* macros instead of S_IF*, but
+   do not provide the S_IS* macros that Posix requires. */
+
+#if defined (_S_IFMT) && !defined (S_IFMT)
+#define S_IFMT _S_IFMT
+#endif
+#if defined (_S_IFIFO) && !defined (S_IFIFO)
+#define S_IFIFO _S_IFIFO
+#endif
+#if defined (_S_IFCHR) && !defined (S_IFCHR)
+#define S_IFCHR _S_IFCHR
+#endif
+#if defined (_S_IFDIR) && !defined (S_IFDIR)
+#define S_IFDIR _S_IFDIR
+#endif
+#if defined (_S_IFBLK) && !defined (S_IFBLK)
+#define S_IFBLK _S_IFBLK
+#endif
+#if defined (_S_IFREG) && !defined (S_IFREG)
+#define S_IFREG _S_IFREG
+#endif
+#if defined (_S_IFLNK) && !defined (S_IFLNK)
+#define S_IFLNK _S_IFLNK
+#endif
+#if defined (_S_IFSOCK) && !defined (S_IFSOCK)
+#define S_IFSOCK _S_IFSOCK
+#endif
+
+/* Test for each symbol individually and define the ones necessary (some
+   systems claiming Posix compatibility define some but not all). */
+
+#if defined (S_IFBLK) && !defined (S_ISBLK)
+#define	S_ISBLK(m)	(((m)&S_IFMT) == S_IFBLK)	/* block device */
+#endif
+
+#if defined (S_IFCHR) && !defined (S_ISCHR)
+#define	S_ISCHR(m)	(((m)&S_IFMT) == S_IFCHR)	/* character device */
+#endif
+
+#if defined (S_IFDIR) && !defined (S_ISDIR)
+#define	S_ISDIR(m)	(((m)&S_IFMT) == S_IFDIR)	/* directory */
+#endif
+
+#if defined (S_IFREG) && !defined (S_ISREG)
+#define	S_ISREG(m)	(((m)&S_IFMT) == S_IFREG)	/* file */
+#endif
+
+#if defined (S_IFIFO) && !defined (S_ISFIFO)
+#define	S_ISFIFO(m)	(((m)&S_IFMT) == S_IFIFO)	/* fifo - named pipe */
+#endif
+
+#if defined (S_IFLNK) && !defined (S_ISLNK)
+#define	S_ISLNK(m)	(((m)&S_IFMT) == S_IFLNK)	/* symbolic link */
+#endif
+
+#if defined (S_IFSOCK) && !defined (S_ISSOCK)
+#define	S_ISSOCK(m)	(((m)&S_IFMT) == S_IFSOCK)	/* socket */
+#endif
+
+/*
+ * POSIX 1003.1 5.6.1.2 <sys/stat.h> File Modes
+ */
+
+#if !defined (S_IRWXU)
+#  if !defined (S_IREAD)
+#    define S_IREAD	00400
+#    define S_IWRITE	00200
+#    define S_IEXEC	00100
+#  endif /* S_IREAD */
+
+#  if !defined (S_IRUSR)
+#    define S_IRUSR	S_IREAD			/* read, owner */
+#    define S_IWUSR	S_IWRITE		/* write, owner */
+#    define S_IXUSR	S_IEXEC			/* execute, owner */
+
+#    define S_IRGRP	(S_IREAD  >> 3)		/* read, group */
+#    define S_IWGRP	(S_IWRITE >> 3)		/* write, group */
+#    define S_IXGRP	(S_IEXEC  >> 3)		/* execute, group */
+
+#    define S_IROTH	(S_IREAD  >> 6)		/* read, other */
+#    define S_IWOTH	(S_IWRITE >> 6)		/* write, other */
+#    define S_IXOTH	(S_IEXEC  >> 6)		/* execute, other */
+#  endif /* !S_IRUSR */
+
+#  define S_IRWXU	(S_IRUSR | S_IWUSR | S_IXUSR)
+#  define S_IRWXG	(S_IRGRP | S_IWGRP | S_IXGRP)
+#  define S_IRWXO	(S_IROTH | S_IWOTH | S_IXOTH)
+#endif /* !S_IRWXU */
+
+/* These are non-standard, but are used in builtins.c$symbolic_umask() */
+#define S_IRUGO		(S_IRUSR | S_IRGRP | S_IROTH)
+#define S_IWUGO		(S_IWUSR | S_IWGRP | S_IWOTH)
+#define S_IXUGO		(S_IXUSR | S_IXGRP | S_IXOTH)
+
+#endif /* _POSIXSTAT_H_ */
diff --git a/readline/readline.c b/readline/readline.c
new file mode 100644
--- /dev/null
+++ b/readline/readline.c
@@ -0,0 +1,2087 @@
+/* readline.c -- a general facility for reading lines of input
+   with emacs style editing and completion. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+#include "posixstat.h"
+#include <fcntl.h>
+#if defined (HAVE_SYS_FILE_H)
+#  include <sys/file.h>
+#endif /* HAVE_SYS_FILE_H */
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#if defined (HAVE_LOCALE_H)
+#  include <locale.h>
+#endif
+
+#include <signal.h>
+#include <stdio.h>
+#include "posixjmp.h"
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+#if defined (__EMX__)
+#  define INCL_DOSPROCESS
+#  include <os2.h>
+#endif /* __EMX__ */
+
+/* Some standard library routines. */
+#include "readline.h"
+#include "history.h"
+
+#ifndef RL_LIBRARY_VERSION
+#  define RL_LIBRARY_VERSION "2.1-bash"
+#endif
+
+/* Evaluates its arguments multiple times. */
+#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
+
+/* NOTE: Functions and variables prefixed with `_rl_' are
+   pseudo-global: they are global so they can be shared
+   between files in the readline library, but are not intended
+   to be visible to readline callers. */
+
+/* Variables and functions imported from terminal.c */
+extern int _rl_init_terminal_io ();
+extern void _rl_enable_meta_key ();
+extern int _rl_output_character_function ();
+extern void _rl_get_screen_size ();
+
+extern int _rl_enable_meta;
+extern int _rl_term_autowrap;
+extern int screenwidth, screenheight, screenchars;
+
+/* Variables and functions imported from rltty.c. */
+extern void rl_prep_terminal (), rl_deprep_terminal ();
+extern void rltty_set_default_bindings ();
+
+/* Functions imported from util.c. */
+extern void _rl_abort_internal ();
+extern void rl_extend_line_buffer ();
+extern int alphabetic ();
+
+/* Functions imported from bind.c. */
+extern void _rl_bind_if_unbound ();
+extern int rl_set_keymap_from_edit_mode ();
+
+/* Functions imported from input.c. */
+extern int _rl_any_typein ();
+extern void _rl_insert_typein ();
+extern int rl_read_key ();
+
+/* Functions imported from nls.c */
+extern int _rl_init_eightbit ();
+
+/* Functions imported from shell.c */
+extern char *get_env_value ();
+
+/* External redisplay functions and variables from display.c */
+extern void _rl_move_vert ();
+extern void _rl_update_final ();
+extern void _rl_clear_to_eol ();
+extern void _rl_clear_screen ();
+
+extern void _rl_save_prompt ();
+extern void _rl_restore_prompt ();
+
+extern void _rl_erase_at_end_of_line ();
+extern void _rl_move_cursor_relative ();
+
+extern int _rl_vis_botlin;
+extern int _rl_last_c_pos;
+extern int _rl_horizontal_scroll_mode;
+extern int rl_display_fixed;
+extern int _rl_suppress_redisplay;
+extern char *rl_display_prompt;
+
+/* Variables imported from complete.c. */
+extern char *rl_completer_word_break_characters;
+extern char *rl_basic_word_break_characters;
+extern int rl_completion_query_items;
+extern int rl_complete_with_tilde_expansion;
+
+/* Variables and functions from macro.c. */
+extern void _rl_add_macro_char ();
+extern void _rl_with_macro_input ();
+extern int _rl_next_macro_key ();
+extern int _rl_defining_kbd_macro;
+
+#if defined (VI_MODE)
+/* Functions imported from vi_mode.c. */
+extern void _rl_vi_set_last ();
+extern void _rl_vi_reset_last ();
+extern void _rl_vi_done_inserting ();
+extern int _rl_vi_textmod_command ();
+extern void _rl_vi_initialize_line ();
+#endif /* VI_MODE */
+
+extern UNDO_LIST *rl_undo_list;
+extern int _rl_doing_an_undo;
+
+/* Forward declarations used in this file. */
+void _rl_free_history_entry ();
+
+int _rl_dispatch ();
+int _rl_init_argument ();
+
+static char *readline_internal ();
+static void readline_initialize_everything ();
+static void start_using_history ();
+static void bind_arrow_keys ();
+
+#if !defined (__GO32__)
+static void readline_default_bindings ();
+#endif /* !__GO32__ */
+
+#if defined (__GO32__)
+#  include <go32.h>
+#  include <pc.h>
+#  undef HANDLE_SIGNALS
+#endif /* __GO32__ */
+
+extern char *xmalloc (), *xrealloc ();
+
+/* **************************************************************** */
+/*								    */
+/*			Line editing input utility		    */
+/*								    */
+/* **************************************************************** */
+
+char *rl_library_version = RL_LIBRARY_VERSION;
+
+/* A pointer to the keymap that is currently in use.
+   By default, it is the standard emacs keymap. */
+Keymap _rl_keymap = emacs_standard_keymap;
+
+/* The current style of editing. */
+int rl_editing_mode = emacs_mode;
+
+/* Non-zero if we called this function from _rl_dispatch().  It's present
+   so functions can find out whether they were called from a key binding
+   or directly from an application. */
+int rl_dispatching;
+
+/* Non-zero if the previous command was a kill command. */
+int _rl_last_command_was_kill = 0;
+
+/* The current value of the numeric argument specified by the user. */
+int rl_numeric_arg = 1;
+
+/* Non-zero if an argument was typed. */
+int rl_explicit_arg = 0;
+
+/* Temporary value used while generating the argument. */
+int rl_arg_sign = 1;
+
+/* Non-zero means we have been called at least once before. */
+static int rl_initialized;
+
+/* If non-zero, this program is running in an EMACS buffer. */
+static int running_in_emacs;
+
+/* The current offset in the current input line. */
+int rl_point;
+
+/* Mark in the current input line. */
+int rl_mark;
+
+/* Length of the current input line. */
+int rl_end;
+
+/* Make this non-zero to return the current input_line. */
+int rl_done;
+
+/* The last function executed by readline. */
+Function *rl_last_func = (Function *)NULL;
+
+/* Top level environment for readline_internal (). */
+procenv_t readline_top_level;
+
+/* The streams we interact with. */
+FILE *_rl_in_stream, *_rl_out_stream;
+
+/* The names of the streams that we do input and output to. */
+FILE *rl_instream = (FILE *)NULL;
+FILE *rl_outstream = (FILE *)NULL;
+
+/* Non-zero means echo characters as they are read. */
+int readline_echoing_p = 1;
+
+/* Current prompt. */
+char *rl_prompt;
+int rl_visible_prompt_length = 0;
+
+/* The number of characters read in order to type this complete command. */
+int rl_key_sequence_length = 0;
+
+/* If non-zero, then this is the address of a function to call just
+   before readline_internal () prints the first prompt. */
+Function *rl_startup_hook = (Function *)NULL;
+
+/* What we use internally.  You should always refer to RL_LINE_BUFFER. */
+static char *the_line;
+
+/* The character that can generate an EOF.  Really read from
+   the terminal driver... just defaulted here. */
+int _rl_eof_char = CTRL ('D');
+
+/* Non-zero makes this the next keystroke to read. */
+int rl_pending_input = 0;
+
+/* Pointer to a useful terminal name. */
+char *rl_terminal_name = (char *)NULL;
+
+/* Non-zero means to always use horizontal scrolling in line display. */
+int _rl_horizontal_scroll_mode = 0;
+
+/* Non-zero means to display an asterisk at the starts of history lines
+   which have been modified. */
+int _rl_mark_modified_lines = 0;  
+
+/* The style of `bell' notification preferred.  This can be set to NO_BELL,
+   AUDIBLE_BELL, or VISIBLE_BELL. */
+int _rl_bell_preference = AUDIBLE_BELL;
+     
+/* String inserted into the line by rl_insert_comment (). */
+char *_rl_comment_begin;
+
+/* Keymap holding the function currently being executed. */
+Keymap rl_executing_keymap;
+
+/* Line buffer and maintenence. */
+char *rl_line_buffer = (char *)NULL;
+int rl_line_buffer_len = 0;
+
+/* Forward declarations used by the display and termcap code. */
+
+/* **************************************************************** */
+/*								    */
+/*			`Forward' declarations  		    */
+/*								    */
+/* **************************************************************** */
+
+/* Non-zero means do not parse any lines other than comments and
+   parser directives. */
+unsigned char _rl_parsing_conditionalized_out = 0;
+
+/* Non-zero means to convert characters with the meta bit set to
+   escape-prefixed characters so we can indirect through
+   emacs_meta_keymap or vi_escape_keymap. */
+int _rl_convert_meta_chars_to_ascii = 1;
+
+/* Non-zero means to output characters with the meta bit set directly
+   rather than as a meta-prefixed escape sequence. */
+int _rl_output_meta_chars = 0;
+
+/* **************************************************************** */
+/*								    */
+/*			Top Level Functions			    */
+/*								    */
+/* **************************************************************** */
+
+/* Non-zero means treat 0200 bit in terminal input as Meta bit. */
+int _rl_meta_flag = 0;	/* Forward declaration */
+
+/* Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
+   none.  A return value of NULL means that EOF was encountered. */
+char *
+readline (prompt)
+     char *prompt;
+{
+  char *value;
+
+  rl_prompt = prompt;
+
+  /* If we are at EOF return a NULL string. */
+  if (rl_pending_input == EOF)
+    {
+      rl_pending_input = 0;
+      return ((char *)NULL);
+    }
+
+  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
+
+  rl_initialize ();
+  (*rl_prep_term_function) (_rl_meta_flag);
+
+#if defined (HANDLE_SIGNALS)
+  rl_set_signals ();
+#endif
+
+  value = readline_internal ();
+  (*rl_deprep_term_function) ();
+
+#if defined (HANDLE_SIGNALS)
+  rl_clear_signals ();
+#endif
+
+  return (value);
+}
+
+#if defined (READLINE_CALLBACKS)
+#  define STATIC_CALLBACK
+#else
+#  define STATIC_CALLBACK static
+#endif
+
+STATIC_CALLBACK void
+readline_internal_setup ()
+{
+  _rl_in_stream = rl_instream;
+  _rl_out_stream = rl_outstream;
+
+  if (rl_startup_hook)
+    (*rl_startup_hook) ();
+
+  if (readline_echoing_p == 0)
+    {
+      if (rl_prompt)
+	{
+	  fprintf (_rl_out_stream, "%s", rl_prompt);
+	  fflush (_rl_out_stream);
+	}
+    }
+  else
+    {
+      rl_on_new_line ();
+      (*rl_redisplay_function) ();
+#if defined (VI_MODE)
+      if (rl_editing_mode == vi_mode)
+	rl_vi_insertion_mode (1, 0);
+#endif /* VI_MODE */
+    }
+}
+
+STATIC_CALLBACK char *
+readline_internal_teardown (eof)
+     int eof;
+{
+  char *temp;
+  HIST_ENTRY *entry;
+
+  /* Restore the original of this history line, iff the line that we
+     are editing was originally in the history, AND the line has changed. */
+  entry = current_history ();
+
+  if (entry && rl_undo_list)
+    {
+      temp = savestring (the_line);
+      rl_revert_line (1, 0);
+      entry = replace_history_entry (where_history (), the_line, (HIST_ENTRY *)NULL);
+      _rl_free_history_entry (entry);
+
+      strcpy (the_line, temp);
+      free (temp);
+    }
+
+  /* At any rate, it is highly likely that this line has an undo list.  Get
+     rid of it now. */
+  if (rl_undo_list)
+    free_undo_list ();
+
+  return (eof ? (char *)NULL : savestring (the_line));
+}
+
+STATIC_CALLBACK int
+#if defined (READLINE_CALLBACKS)
+readline_internal_char ()
+#else
+readline_internal_charloop ()
+#endif
+{
+  static int lastc, eof_found;
+  int c, code, lk;
+
+  lastc = -1;
+  eof_found = 0;
+
+#if !defined (READLINE_CALLBACKS)
+  while (rl_done == 0)
+    {
+#endif
+      lk = _rl_last_command_was_kill;
+
+      code = setjmp (readline_top_level);
+
+      if (code)
+	(*rl_redisplay_function) ();
+
+      if (rl_pending_input == 0)
+	{
+	  /* Then initialize the argument and number of keys read. */
+	  _rl_init_argument ();
+	  rl_key_sequence_length = 0;
+	}
+
+      c = rl_read_key ();
+
+      /* EOF typed to a non-blank line is a <NL>. */
+      if (c == EOF && rl_end)
+	c = NEWLINE;
+
+      /* The character _rl_eof_char typed to blank line, and not as the
+	 previous character is interpreted as EOF. */
+      if (((c == _rl_eof_char && lastc != c) || c == EOF) && !rl_end)
+	{
+#if defined (READLINE_CALLBACKS)
+	  return (rl_done = 1);
+#else
+	  eof_found = 1;
+	  break;
+#endif
+	}
+
+      lastc = c;
+      _rl_dispatch (c, _rl_keymap);
+
+      /* If there was no change in _rl_last_command_was_kill, then no kill
+	 has taken place.  Note that if input is pending we are reading
+	 a prefix command, so nothing has changed yet. */
+      if (rl_pending_input == 0 && lk == _rl_last_command_was_kill)
+	_rl_last_command_was_kill = 0;
+
+#if defined (VI_MODE)
+      /* In vi mode, when you exit insert mode, the cursor moves back
+	 over the previous character.  We explicitly check for that here. */
+      if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap)
+	rl_vi_check ();
+#endif /* VI_MODE */
+
+      if (rl_done == 0)
+	(*rl_redisplay_function) ();
+
+#if defined (READLINE_CALLBACKS)
+      return 0;
+#else
+    }
+
+  return (eof_found);
+#endif
+}
+
+#if defined (READLINE_CALLBACKS)
+static int
+readline_internal_charloop ()
+{
+  int eof;
+
+  while (rl_done == 0)
+    eof = readline_internal_char ();
+  return (eof);
+}
+#endif /* READLINE_CALLBACKS */
+
+/* Read a line of input from the global rl_instream, doing output on
+   the global rl_outstream.
+   If rl_prompt is non-null, then that is our prompt. */
+static char *
+readline_internal ()
+{
+  int eof;
+
+  readline_internal_setup ();
+  eof = readline_internal_charloop ();
+  return (readline_internal_teardown (eof));
+}
+
+void
+_rl_init_line_state ()
+{
+  rl_point = rl_end = 0;
+  the_line = rl_line_buffer;
+  the_line[0] = 0;
+}
+
+void
+_rl_set_the_line ()
+{
+  the_line = rl_line_buffer;
+}
+
+/* Do the command associated with KEY in MAP.
+   If the associated command is really a keymap, then read
+   another key, and dispatch into that map. */
+int
+_rl_dispatch (key, map)
+     register int key;
+     Keymap map;
+{
+  int r, newkey;
+  char *macro;
+  Function *func;
+
+  if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
+    {
+      if (map[ESC].type == ISKMAP)
+	{
+	  if (_rl_defining_kbd_macro)
+	    _rl_add_macro_char (ESC);
+	  map = FUNCTION_TO_KEYMAP (map, ESC);
+	  key = UNMETA (key);
+	  rl_key_sequence_length += 2;
+	  return (_rl_dispatch (key, map));
+	}
+      else
+	ding ();
+      return 0;
+    }
+
+  if (_rl_defining_kbd_macro)
+    _rl_add_macro_char (key);
+
+  r = 0;
+  switch (map[key].type)
+    {
+    case ISFUNC:
+      func = map[key].function;
+      if (func != (Function *)NULL)
+	{
+	  /* Special case rl_do_lowercase_version (). */
+	  if (func == rl_do_lowercase_version)
+	    return (_rl_dispatch (_rl_to_lower (key), map));
+
+	  rl_executing_keymap = map;
+
+#if 0
+	  _rl_suppress_redisplay = (map[key].function == rl_insert) && _rl_input_available ();
+#endif
+
+	  rl_dispatching = 1;
+	  r = (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
+	  rl_dispatching = 0;
+
+	  /* If we have input pending, then the last command was a prefix
+	     command.  Don't change the state of rl_last_func.  Otherwise,
+	     remember the last command executed in this variable. */
+	  if (!rl_pending_input && map[key].function != rl_digit_argument)
+	    rl_last_func = map[key].function;
+	}
+      else
+	{
+	  _rl_abort_internal ();
+	  return -1;
+	}
+      break;
+
+    case ISKMAP:
+      if (map[key].function != (Function *)NULL)
+	{
+	  rl_key_sequence_length++;
+	  newkey = rl_read_key ();
+	  r = _rl_dispatch (newkey, FUNCTION_TO_KEYMAP (map, key));
+	}
+      else
+	{
+	  _rl_abort_internal ();
+	  return -1;
+	}
+      break;
+
+    case ISMACR:
+      if (map[key].function != (Function *)NULL)
+	{
+	  macro = savestring ((char *)map[key].function);
+	  _rl_with_macro_input (macro);
+	  return 0;
+	}
+      break;
+    }
+#if defined (VI_MODE)
+  if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
+      _rl_vi_textmod_command (key))
+    _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);
+#endif
+  return (r);
+}
+
+/* **************************************************************** */
+/*								    */
+/*			Initializations 			    */
+/*								    */
+/* **************************************************************** */
+
+/* Initialize readline (and terminal if not already). */
+int
+rl_initialize ()
+{
+  /* If we have never been called before, initialize the
+     terminal and data structures. */
+  if (!rl_initialized)
+    {
+      readline_initialize_everything ();
+      rl_initialized++;
+    }
+
+  /* Initalize the current line information. */
+  _rl_init_line_state ();
+
+  /* We aren't done yet.  We haven't even gotten started yet! */
+  rl_done = 0;
+
+  /* Tell the history routines what is going on. */
+  start_using_history ();
+
+  /* Make the display buffer match the state of the line. */
+  rl_reset_line_state ();
+
+  /* No such function typed yet. */
+  rl_last_func = (Function *)NULL;
+
+  /* Parsing of key-bindings begins in an enabled state. */
+  _rl_parsing_conditionalized_out = 0;
+
+#if defined (VI_MODE)
+  if (rl_editing_mode == vi_mode)
+    _rl_vi_initialize_line ();
+#endif
+
+  return 0;
+}
+
+#if defined (__EMX__)
+static void
+_emx_build_environ ()
+{
+  TIB *tibp;
+  PIB *pibp;
+  char *t, **tp;
+  int c;
+
+  DosGetInfoBlocks (&tibp, &pibp);
+  t = pibp->pib_pchenv;
+  for (c = 1; *t; c++)
+    t += strlen (t) + 1;
+  tp = environ = (char **)xmalloc ((c + 1) * sizeof (char *));
+  t = pibp->pib_pchenv;
+  while (*t)
+    {
+      *tp++ = t;
+      t += strlen (t) + 1;
+    }
+  *tp = 0;
+}
+#endif /* __EMX__ */
+
+/* Initialize the entire state of the world. */
+static void
+readline_initialize_everything ()
+{
+#if defined (__EMX__)
+  if (environ == 0)
+    _emx_build_environ ();
+#endif
+
+  /* Find out if we are running in Emacs. */
+  running_in_emacs = get_env_value ("EMACS") != (char *)0;
+
+  /* Set up input and output if they are not already set up. */
+  if (!rl_instream)
+    rl_instream = stdin;
+
+  if (!rl_outstream)
+    rl_outstream = stdout;
+
+  /* Bind _rl_in_stream and _rl_out_stream immediately.  These values
+     may change, but they may also be used before readline_internal ()
+     is called. */
+  _rl_in_stream = rl_instream;
+  _rl_out_stream = rl_outstream;
+
+  /* Allocate data structures. */
+  if (rl_line_buffer == 0)
+    rl_line_buffer = xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
+
+  /* Initialize the terminal interface. */
+  _rl_init_terminal_io ((char *)NULL);
+
+#if !defined (__GO32__)
+  /* Bind tty characters to readline functions. */
+  readline_default_bindings ();
+#endif /* !__GO32__ */
+
+  /* Initialize the function names. */
+  rl_initialize_funmap ();
+
+  /* Decide whether we should automatically go into eight-bit mode. */
+  _rl_init_eightbit ();
+      
+  /* Read in the init file. */
+  rl_read_init_file ((char *)NULL);
+
+  /* XXX */
+  if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
+    {
+      screenwidth--;
+      screenchars -= screenheight;
+    }
+
+  /* Override the effect of any `set keymap' assignments in the
+     inputrc file. */
+  rl_set_keymap_from_edit_mode ();
+
+  /* Try to bind a common arrow key prefix, if not already bound. */
+  bind_arrow_keys ();
+
+  /* Enable the meta key, if this terminal has one. */
+  if (_rl_enable_meta)
+    _rl_enable_meta_key ();
+
+  /* If the completion parser's default word break characters haven't
+     been set yet, then do so now. */
+  if (rl_completer_word_break_characters == (char *)NULL)
+    rl_completer_word_break_characters = rl_basic_word_break_characters;
+}
+
+/* If this system allows us to look at the values of the regular
+   input editing characters, then bind them to their readline
+   equivalents, iff the characters are not bound to keymaps. */
+static void
+readline_default_bindings ()
+{
+  rltty_set_default_bindings (_rl_keymap);
+}
+
+static void
+bind_arrow_keys_internal ()
+{
+  Function *f;
+
+  f = rl_function_of_keyseq ("\033[A", _rl_keymap, (int *)NULL);
+  if (!f || f == rl_do_lowercase_version)
+    {
+      _rl_bind_if_unbound ("\033[A", rl_get_previous_history);
+      _rl_bind_if_unbound ("\033[B", rl_get_next_history);
+      _rl_bind_if_unbound ("\033[C", rl_forward);
+      _rl_bind_if_unbound ("\033[D", rl_backward);
+    }
+
+  f = rl_function_of_keyseq ("\033OA", _rl_keymap, (int *)NULL);
+  if (!f || f == rl_do_lowercase_version)
+    {
+      _rl_bind_if_unbound ("\033OA", rl_get_previous_history);
+      _rl_bind_if_unbound ("\033OB", rl_get_next_history);
+      _rl_bind_if_unbound ("\033OC", rl_forward);
+      _rl_bind_if_unbound ("\033OD", rl_backward);
+    }
+}
+
+/* Try and bind the common arrow key prefix after giving termcap and
+   the inputrc file a chance to bind them and create `real' keymaps
+   for the arrow key prefix. */
+static void
+bind_arrow_keys ()
+{
+  Keymap xkeymap;
+
+  xkeymap = _rl_keymap;
+
+  _rl_keymap = emacs_standard_keymap;
+  bind_arrow_keys_internal ();
+
+#if defined (VI_MODE)
+  _rl_keymap = vi_movement_keymap;
+  bind_arrow_keys_internal ();
+#endif
+
+  _rl_keymap = xkeymap;
+}
+
+
+/* **************************************************************** */
+/*								    */
+/*			Numeric Arguments			    */
+/*								    */
+/* **************************************************************** */
+
+/* Handle C-u style numeric args, as well as M--, and M-digits. */
+static int
+rl_digit_loop ()
+{
+  int key, c, sawminus, sawdigits;
+
+  _rl_save_prompt ();
+
+  sawminus = sawdigits = 0;
+  while (1)
+    {
+      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
+      key = c = rl_read_key ();
+
+      /* If we see a key bound to `universal-argument' after seeing digits,
+	 it ends the argument but is otherwise ignored. */
+      if (_rl_keymap[c].type == ISFUNC &&
+	  _rl_keymap[c].function == rl_universal_argument)
+	{
+	  if (sawdigits == 0)
+	    {
+	      rl_numeric_arg *= 4;
+	      continue;
+	    }
+	  else
+	    {
+	      key = rl_read_key ();
+	      _rl_restore_prompt ();
+	      rl_clear_message ();
+	      return (_rl_dispatch (key, _rl_keymap));
+	    }
+	}
+
+      c = UNMETA (c);
+
+      if (_rl_digit_p (c))
+	{
+	  rl_numeric_arg = rl_explicit_arg ? (rl_numeric_arg * 10) + c - '0' : c - '0';
+	  sawdigits = rl_explicit_arg = 1;
+	}
+      else if (c == '-' && rl_explicit_arg == 0)
+	{
+	  rl_numeric_arg = sawminus = 1;
+	  rl_arg_sign = -1;
+	}
+      else
+	{
+	  /* Make M-- command equivalent to M--1 command. */
+	  if (sawminus && rl_numeric_arg == 1 && rl_explicit_arg == 0)
+	    rl_explicit_arg = 1;
+	  _rl_restore_prompt ();
+	  rl_clear_message ();
+	  return (_rl_dispatch (key, _rl_keymap));
+	}
+    }
+
+  return 0;
+}
+
+/* Add the current digit to the argument in progress. */
+int
+rl_digit_argument (ignore, key)
+     int ignore, key;
+{
+  rl_pending_input = key;
+  return (rl_digit_loop ());
+}
+
+/* What to do when you abort reading an argument. */
+int
+rl_discard_argument ()
+{
+  ding ();
+  rl_clear_message ();
+  _rl_init_argument ();
+  return 0;
+}
+
+/* Create a default argument. */
+int
+_rl_init_argument ()
+{
+  rl_numeric_arg = rl_arg_sign = 1;
+  rl_explicit_arg = 0;
+  return 0;
+}
+
+/* C-u, universal argument.  Multiply the current argument by 4.
+   Read a key.  If the key has nothing to do with arguments, then
+   dispatch on it.  If the key is the abort character then abort. */
+int
+rl_universal_argument (count, key)
+     int count, key;
+{
+  rl_numeric_arg *= 4;
+  return (rl_digit_loop ());
+}
+
+/* **************************************************************** */
+/*								    */
+/*			Insert and Delete			    */
+/*								    */
+/* **************************************************************** */
+
+/* Insert a string of text into the line at point.  This is the only
+   way that you should do insertion.  rl_insert () calls this
+   function. */
+int
+rl_insert_text (string)
+     char *string;
+{
+  register int i, l = strlen (string);
+
+  if (rl_end + l >= rl_line_buffer_len)
+    rl_extend_line_buffer (rl_end + l);
+
+  for (i = rl_end; i >= rl_point; i--)
+    the_line[i + l] = the_line[i];
+  strncpy (the_line + rl_point, string, l);
+
+  /* Remember how to undo this if we aren't undoing something. */
+  if (!_rl_doing_an_undo)
+    {
+      /* If possible and desirable, concatenate the undos. */
+      if ((l == 1) &&
+	  rl_undo_list &&
+	  (rl_undo_list->what == UNDO_INSERT) &&
+	  (rl_undo_list->end == rl_point) &&
+	  (rl_undo_list->end - rl_undo_list->start < 20))
+	rl_undo_list->end++;
+      else
+	rl_add_undo (UNDO_INSERT, rl_point, rl_point + l, (char *)NULL);
+    }
+  rl_point += l;
+  rl_end += l;
+  the_line[rl_end] = '\0';
+  return l;
+}
+
+/* Delete the string between FROM and TO.  FROM is
+   inclusive, TO is not. */
+int
+rl_delete_text (from, to)
+     int from, to;
+{
+  register char *text;
+  register int diff, i;
+
+  /* Fix it if the caller is confused. */
+  if (from > to)
+    SWAP (from, to);
+
+  /* fix boundaries */
+  if (to > rl_end)
+    {
+      to = rl_end;
+      if (from > to)
+        from = to;
+    }
+
+  text = rl_copy_text (from, to);
+
+  /* Some versions of strncpy() can't handle overlapping arguments. */
+  diff = to - from;
+  for (i = from; i < rl_end - diff; i++)
+    the_line[i] = the_line[i + diff];
+
+  /* Remember how to undo this delete. */
+  if (_rl_doing_an_undo == 0)
+    rl_add_undo (UNDO_DELETE, from, to, text);
+  else
+    free (text);
+
+  rl_end -= diff;
+  the_line[rl_end] = '\0';
+  return (diff);
+}
+
+/* Fix up point so that it is within the line boundaries after killing
+   text.  If FIX_MARK_TOO is non-zero, the mark is forced within line
+   boundaries also. */
+
+#define _RL_FIX_POINT(x) \
+	do { \
+	if (x > rl_end) \
+	  x = rl_end; \
+	else if (x < 0) \
+	  x = 0; \
+	} while (0)
+
+void
+_rl_fix_point (fix_mark_too)
+     int fix_mark_too;
+{
+  _RL_FIX_POINT (rl_point);
+  if (fix_mark_too)
+    _RL_FIX_POINT (rl_mark);
+}
+#undef _RL_FIX_POINT
+
+/* **************************************************************** */
+/*								    */
+/*			Readline character functions		    */
+/*								    */
+/* **************************************************************** */
+
+/* This is not a gap editor, just a stupid line input routine.  No hair
+   is involved in writing any of the functions, and none should be. */
+
+/* Note that:
+
+   rl_end is the place in the string that we would place '\0';
+   i.e., it is always safe to place '\0' there.
+
+   rl_point is the place in the string where the cursor is.  Sometimes
+   this is the same as rl_end.
+
+   Any command that is called interactively receives two arguments.
+   The first is a count: the numeric arg pased to this command.
+   The second is the key which invoked this command.
+*/
+
+/* **************************************************************** */
+/*								    */
+/*			Movement Commands			    */
+/*								    */
+/* **************************************************************** */
+
+/* Note that if you `optimize' the display for these functions, you cannot
+   use said functions in other functions which do not do optimizing display.
+   I.e., you will have to update the data base for rl_redisplay, and you
+   might as well let rl_redisplay do that job. */
+
+/* Move forward COUNT characters. */
+int
+rl_forward (count, key)
+     int count, key;
+{
+  if (count < 0)
+    rl_backward (-count, key);
+  else if (count > 0)
+    {
+      int end = rl_point + count;
+#if defined (VI_MODE)
+      int lend = rl_end - (rl_editing_mode == vi_mode);
+#else
+      int lend = rl_end;
+#endif
+
+      if (end > lend)
+	{
+	  rl_point = lend;
+	  ding ();
+	}
+      else
+	rl_point = end;
+    }
+  return 0;
+}
+
+/* Move backward COUNT characters. */
+int
+rl_backward (count, key)
+     int count, key;
+{
+  if (count < 0)
+    rl_forward (-count, key);
+  else if (count > 0)
+    {
+      if (rl_point < count)
+	{
+	  rl_point = 0;
+	  ding ();
+	}
+      else
+        rl_point -= count;
+    }
+  return 0;
+}
+
+/* Move to the beginning of the line. */
+int
+rl_beg_of_line (count, key)
+     int count, key;
+{
+  rl_point = 0;
+  return 0;
+}
+
+/* Move to the end of the line. */
+int
+rl_end_of_line (count, key)
+     int count, key;
+{
+  rl_point = rl_end;
+  return 0;
+}
+
+/* Move forward a word.  We do what Emacs does. */
+int
+rl_forward_word (count, key)
+     int count, key;
+{
+  int c;
+
+  if (count < 0)
+    {
+      rl_backward_word (-count, key);
+      return 0;
+    }
+
+  while (count)
+    {
+      if (rl_point == rl_end)
+	return 0;
+
+      /* If we are not in a word, move forward until we are in one.
+	 Then, move forward until we hit a non-alphabetic character. */
+      c = the_line[rl_point];
+      if (alphabetic (c) == 0)
+	{
+	  while (++rl_point < rl_end)
+	    {
+	      c = the_line[rl_point];
+	      if (alphabetic (c))
+		break;
+	    }
+	}
+      if (rl_point == rl_end)
+	return 0;
+      while (++rl_point < rl_end)
+	{
+	  c = the_line[rl_point];
+	  if (alphabetic (c) == 0)
+	    break;
+	}
+      --count;
+    }
+  return 0;
+}
+
+/* Move backward a word.  We do what Emacs does. */
+int
+rl_backward_word (count, key)
+     int count, key;
+{
+  int c;
+
+  if (count < 0)
+    {
+      rl_forward_word (-count, key);
+      return 0;
+    }
+
+  while (count)
+    {
+      if (!rl_point)
+	return 0;
+
+      /* Like rl_forward_word (), except that we look at the characters
+	 just before point. */
+
+      c = the_line[rl_point - 1];
+      if (alphabetic (c) == 0)
+	{
+	  while (--rl_point)
+	    {
+	      c = the_line[rl_point - 1];
+	      if (alphabetic (c))
+		break;
+	    }
+	}
+
+      while (rl_point)
+	{
+	  c = the_line[rl_point - 1];
+	  if (alphabetic (c) == 0)
+	    break;
+	  else
+	    --rl_point;
+	}
+      --count;
+    }
+  return 0;
+}
+
+/* Clear the current line.  Numeric argument to C-l does this. */
+int
+rl_refresh_line ()
+{
+  int curr_line, nleft;
+
+  /* Find out whether or not there might be invisible characters in the
+     editing buffer. */
+  if (rl_display_prompt == rl_prompt)
+    nleft = _rl_last_c_pos - screenwidth - rl_visible_prompt_length;
+  else
+    nleft = _rl_last_c_pos - screenwidth;
+
+  if (nleft > 0)
+    curr_line = 1 + nleft / screenwidth;
+  else
+    curr_line = 0;
+
+  _rl_move_vert (curr_line);
+  _rl_move_cursor_relative (0, the_line);   /* XXX is this right */
+
+#if defined (__GO32__)
+  {
+    int row, col, width, row_start;
+
+    ScreenGetCursor (&row, &col);
+    width = ScreenCols ();
+    row_start = ScreenPrimary + (row * width);
+    memset (row_start + col, 0, (width - col) * 2);
+  }
+#else /* !__GO32__ */
+  _rl_clear_to_eol (0);		/* arg of 0 means to not use spaces */
+#endif /* !__GO32__ */
+
+  rl_forced_update_display ();
+  rl_display_fixed = 1;
+
+  return 0;
+}
+
+/* C-l typed to a line without quoting clears the screen, and then reprints
+   the prompt and the current input line.  Given a numeric arg, redraw only
+   the current line. */
+int
+rl_clear_screen (count, key)
+     int count, key;
+{
+  if (rl_explicit_arg)
+    {
+      rl_refresh_line ();
+      return 0;
+    }
+
+  _rl_clear_screen ();		/* calls termcap function to clear screen */
+  rl_forced_update_display ();
+  rl_display_fixed = 1;
+
+  return 0;
+}
+
+int
+rl_arrow_keys (count, c)
+     int count, c;
+{
+  int ch;
+
+  ch = rl_read_key ();
+
+  switch (_rl_to_upper (ch))
+    {
+    case 'A':
+      rl_get_previous_history (count, ch);
+      break;
+
+    case 'B':
+      rl_get_next_history (count, ch);
+      break;
+
+    case 'C':
+      rl_forward (count, ch);
+      break;
+
+    case 'D':
+      rl_backward (count, ch);
+      break;
+
+    default:
+      ding ();
+    }
+  return 0;
+}
+
+
+/* **************************************************************** */
+/*								    */
+/*			Text commands				    */
+/*								    */
+/* **************************************************************** */
+
+/* Insert the character C at the current location, moving point forward. */
+int
+rl_insert (count, c)
+     int count, c;
+{
+  register int i;
+  char *string;
+
+  if (count <= 0)
+    return 0;
+
+  /* If we can optimize, then do it.  But don't let people crash
+     readline because of extra large arguments. */
+  if (count > 1 && count <= 1024)
+    {
+      string = xmalloc (1 + count);
+
+      for (i = 0; i < count; i++)
+	string[i] = c;
+
+      string[i] = '\0';
+      rl_insert_text (string);
+      free (string);
+
+      return 0;
+    }
+
+  if (count > 1024)
+    {
+      int decreaser;
+      char str[1024+1];
+
+      for (i = 0; i < 1024; i++)
+	str[i] = c;
+
+      while (count)
+	{
+	  decreaser = (count > 1024 ? 1024 : count);
+	  str[decreaser] = '\0';
+	  rl_insert_text (str);
+	  count -= decreaser;
+	}
+
+      return 0;
+    }
+
+  /* We are inserting a single character.
+     If there is pending input, then make a string of all of the
+     pending characters that are bound to rl_insert, and insert
+     them all. */
+  if (_rl_any_typein ())
+    _rl_insert_typein (c);
+  else
+    {
+      /* Inserting a single character. */
+      char str[2];
+
+      str[1] = '\0';
+      str[0] = c;
+      rl_insert_text (str);
+    }
+  return 0;
+}
+
+/* Insert the next typed character verbatim. */
+int
+rl_quoted_insert (count, key)
+     int count, key;
+{
+  int c;
+
+  c = rl_read_key ();
+  return (rl_insert (count, c));  
+}
+
+/* Insert a tab character. */
+int
+rl_tab_insert (count, key)
+     int count, key;
+{
+  return (rl_insert (count, '\t'));
+}
+
+/* What to do when a NEWLINE is pressed.  We accept the whole line.
+   KEY is the key that invoked this command.  I guess it could have
+   meaning in the future. */
+int
+rl_newline (count, key)
+     int count, key;
+{
+  rl_done = 1;
+
+#if defined (VI_MODE)
+  if (rl_editing_mode == vi_mode)
+    {
+      _rl_vi_done_inserting ();
+      _rl_vi_reset_last ();
+    }
+#endif /* VI_MODE */
+
+  if (readline_echoing_p)
+    _rl_update_final ();
+  return 0;
+}
+
+/* What to do for some uppercase characters, like meta characters,
+   and some characters appearing in emacs_ctlx_keymap.  This function
+   is just a stub, you bind keys to it and the code in _rl_dispatch ()
+   is special cased. */
+int
+rl_do_lowercase_version (ignore1, ignore2)
+     int ignore1, ignore2;
+{
+  return 0;
+}
+
+/* Rubout the character behind point. */
+int
+rl_rubout (count, key)
+     int count, key;
+{
+  if (count < 0)
+    {
+      rl_delete (-count, key);
+      return 0;
+    }
+
+  if (!rl_point)
+    {
+      ding ();
+      return -1;
+    }
+
+  if (count > 1 || rl_explicit_arg)
+    {
+      int orig_point = rl_point;
+      rl_backward (count, key);
+      rl_kill_text (orig_point, rl_point);
+    }
+  else
+    {
+      int c = the_line[--rl_point];
+      rl_delete_text (rl_point, rl_point + 1);
+
+      if (rl_point == rl_end && isprint (c) && _rl_last_c_pos)
+	{
+	  int l;
+	  l = rl_character_len (c, rl_point);
+	  _rl_erase_at_end_of_line (l);
+	}
+    }
+  return 0;
+}
+
+/* Delete the character under the cursor.  Given a numeric argument,
+   kill that many characters instead. */
+int
+rl_delete (count, key)
+     int count, key;
+{
+  if (count < 0)
+    return (rl_rubout (-count, key));
+
+  if (rl_point == rl_end)
+    {
+      ding ();
+      return -1;
+    }
+
+  if (count > 1 || rl_explicit_arg)
+    {
+      int orig_point = rl_point;
+      rl_forward (count, key);
+      rl_kill_text (orig_point, rl_point);
+      rl_point = orig_point;
+      return 0;
+    }
+  else
+    return (rl_delete_text (rl_point, rl_point + 1));
+  
+}
+
+/* Delete all spaces and tabs around point. */
+int
+rl_delete_horizontal_space (count, ignore)
+     int count, ignore;
+{
+  int start = rl_point;
+
+  while (rl_point && whitespace (the_line[rl_point - 1]))
+    rl_point--;
+
+  start = rl_point;
+
+  while (rl_point < rl_end && whitespace (the_line[rl_point]))
+    rl_point++;
+
+  if (start != rl_point)
+    {
+      rl_delete_text (start, rl_point);
+      rl_point = start;
+    }
+  return 0;
+}
+
+#ifndef RL_COMMENT_BEGIN_DEFAULT
+#define RL_COMMENT_BEGIN_DEFAULT "#"
+#endif
+
+/* Turn the current line into a comment in shell history.
+   A K*rn shell style function. */
+int
+rl_insert_comment (count, key)
+     int count, key;
+{
+  rl_beg_of_line (1, key);
+  rl_insert_text (_rl_comment_begin ? _rl_comment_begin
+				    : RL_COMMENT_BEGIN_DEFAULT);
+  (*rl_redisplay_function) ();
+  rl_newline (1, '\n');
+  return (0);
+}
+
+/* **************************************************************** */
+/*								    */
+/*			Changing Case				    */
+/*								    */
+/* **************************************************************** */
+
+/* The three kinds of things that we know how to do. */
+#define UpCase 1
+#define DownCase 2
+#define CapCase 3
+
+static int rl_change_case ();
+
+/* Uppercase the word at point. */
+int
+rl_upcase_word (count, key)
+     int count, key;
+{
+  return (rl_change_case (count, UpCase));
+}
+
+/* Lowercase the word at point. */
+int
+rl_downcase_word (count, key)
+     int count, key;
+{
+  return (rl_change_case (count, DownCase));
+}
+
+/* Upcase the first letter, downcase the rest. */
+int
+rl_capitalize_word (count, key)
+     int count, key;
+{
+ return (rl_change_case (count, CapCase));
+}
+
+/* The meaty function.
+   Change the case of COUNT words, performing OP on them.
+   OP is one of UpCase, DownCase, or CapCase.
+   If a negative argument is given, leave point where it started,
+   otherwise, leave it where it moves to. */
+static int
+rl_change_case (count, op)
+     int count, op;
+{
+  register int start, end;
+  int inword, c;
+
+  start = rl_point;
+  rl_forward_word (count, 0);
+  end = rl_point;
+
+  if (count < 0)
+    SWAP (start, end);
+
+  /* We are going to modify some text, so let's prepare to undo it. */
+  rl_modifying (start, end);
+
+  for (inword = 0; start < end; start++)
+    {
+      c = the_line[start];
+      switch (op)
+	{
+	case UpCase:
+	  the_line[start] = _rl_to_upper (c);
+	  break;
+
+	case DownCase:
+	  the_line[start] = _rl_to_lower (c);
+	  break;
+
+	case CapCase:
+	  the_line[start] = (inword == 0) ? _rl_to_upper (c) : _rl_to_lower (c);
+	  inword = alphabetic (the_line[start]);
+	  break;
+
+	default:
+	  ding ();
+	  return -1;
+	}
+    }
+  rl_point = end;
+  return 0;
+}
+
+/* **************************************************************** */
+/*								    */
+/*			Transposition				    */
+/*								    */
+/* **************************************************************** */
+
+/* Transpose the words at point. */
+int
+rl_transpose_words (count, key)
+     int count, key;
+{
+  char *word1, *word2;
+  int w1_beg, w1_end, w2_beg, w2_end;
+  int orig_point = rl_point;
+
+  if (!count)
+    return 0;
+
+  /* Find the two words. */
+  rl_forward_word (count, key);
+  w2_end = rl_point;
+  rl_backward_word (1, key);
+  w2_beg = rl_point;
+  rl_backward_word (count, key);
+  w1_beg = rl_point;
+  rl_forward_word (1, key);
+  w1_end = rl_point;
+
+  /* Do some check to make sure that there really are two words. */
+  if ((w1_beg == w2_beg) || (w2_beg < w1_end))
+    {
+      ding ();
+      rl_point = orig_point;
+      return -1;
+    }
+
+  /* Get the text of the words. */
+  word1 = rl_copy_text (w1_beg, w1_end);
+  word2 = rl_copy_text (w2_beg, w2_end);
+
+  /* We are about to do many insertions and deletions.  Remember them
+     as one operation. */
+  rl_begin_undo_group ();
+
+  /* Do the stuff at word2 first, so that we don't have to worry
+     about word1 moving. */
+  rl_point = w2_beg;
+  rl_delete_text (w2_beg, w2_end);
+  rl_insert_text (word1);
+
+  rl_point = w1_beg;
+  rl_delete_text (w1_beg, w1_end);
+  rl_insert_text (word2);
+
+  /* This is exactly correct since the text before this point has not
+     changed in length. */
+  rl_point = w2_end;
+
+  /* I think that does it. */
+  rl_end_undo_group ();
+  free (word1);
+  free (word2);
+
+  return 0;
+}
+
+/* Transpose the characters at point.  If point is at the end of the line,
+   then transpose the characters before point. */
+int
+rl_transpose_chars (count, key)
+     int count, key;
+{
+  char dummy[2];
+
+  if (!count)
+    return 0;
+
+  if (!rl_point || rl_end < 2)
+    {
+      ding ();
+      return -1;
+    }
+
+  rl_begin_undo_group ();
+
+  if (rl_point == rl_end)
+    {
+      --rl_point;
+      count = 1;
+    }
+  rl_point--;
+
+  dummy[0] = the_line[rl_point];
+  dummy[1] = '\0';
+
+  rl_delete_text (rl_point, rl_point + 1);
+
+  rl_point += count;
+  _rl_fix_point (0);
+  rl_insert_text (dummy);
+
+  rl_end_undo_group ();
+  return 0;
+}
+
+/* **************************************************************** */
+/*								    */
+/*			Character Searching			    */
+/*								    */
+/* **************************************************************** */
+
+int
+_rl_char_search_internal (count, dir, schar)
+     int count, dir, schar;
+{
+  int pos, inc;
+
+  pos = rl_point;
+  inc = (dir < 0) ? -1 : 1;
+  while (count)
+    {
+      if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
+	{
+	  ding ();
+	  return -1;
+	}
+
+      pos += inc;
+      do
+	{
+	  if (rl_line_buffer[pos] == schar)
+	    {
+	      count--;
+	      if (dir < 0)
+	        rl_point = (dir == BTO) ? pos + 1 : pos;
+	      else
+		rl_point = (dir == FTO) ? pos - 1 : pos;
+	      break;
+	    }
+	}
+      while ((dir < 0) ? pos-- : ++pos < rl_end);
+    }
+  return (0);
+}
+
+/* Search COUNT times for a character read from the current input stream.
+   FDIR is the direction to search if COUNT is non-negative; otherwise
+   the search goes in BDIR. */
+static int
+_rl_char_search (count, fdir, bdir)
+     int count, fdir, bdir;
+{
+  int c;
+
+  c = rl_read_key ();
+  if (count < 0)
+    return (_rl_char_search_internal (-count, bdir, c));
+  else
+    return (_rl_char_search_internal (count, fdir, c));
+}
+
+int
+rl_char_search (count, key)
+     int count, key;
+{
+  return (_rl_char_search (count, FFIND, BFIND));
+}
+
+int
+rl_backward_char_search (count, key)
+     int count, key;
+{
+  return (_rl_char_search (count, BFIND, FFIND));
+}
+
+/* **************************************************************** */
+/*								    */
+/*			History Utilities			    */
+/*								    */
+/* **************************************************************** */
+
+/* We already have a history library, and that is what we use to control
+   the history features of readline.  This is our local interface to
+   the history mechanism. */
+
+/* While we are editing the history, this is the saved
+   version of the original line. */
+HIST_ENTRY *saved_line_for_history = (HIST_ENTRY *)NULL;
+
+/* Set the history pointer back to the last entry in the history. */
+static void
+start_using_history ()
+{
+  using_history ();
+  if (saved_line_for_history)
+    _rl_free_history_entry (saved_line_for_history);
+
+  saved_line_for_history = (HIST_ENTRY *)NULL;
+}
+
+/* Free the contents (and containing structure) of a HIST_ENTRY. */
+void
+_rl_free_history_entry (entry)
+     HIST_ENTRY *entry;
+{
+  if (entry == 0)
+    return;
+  if (entry->line)
+    free (entry->line);
+  free (entry);
+}
+
+/* Perhaps put back the current line if it has changed. */
+int
+maybe_replace_line ()
+{
+  HIST_ENTRY *temp;
+
+  temp = current_history ();
+  /* If the current line has changed, save the changes. */
+  if (temp && ((UNDO_LIST *)(temp->data) != rl_undo_list))
+    {
+      temp = replace_history_entry (where_history (), the_line, rl_undo_list);
+      free (temp->line);
+      free (temp);
+    }
+  return 0;
+}
+
+/* Put back the saved_line_for_history if there is one. */
+int
+maybe_unsave_line ()
+{
+  int line_len;
+
+  if (saved_line_for_history)
+    {
+      line_len = strlen (saved_line_for_history->line);
+
+      if (line_len >= rl_line_buffer_len)
+	rl_extend_line_buffer (line_len);
+
+      strcpy (the_line, saved_line_for_history->line);
+      rl_undo_list = (UNDO_LIST *)saved_line_for_history->data;
+      _rl_free_history_entry (saved_line_for_history);
+      saved_line_for_history = (HIST_ENTRY *)NULL;
+      rl_end = rl_point = strlen (the_line);
+    }
+  else
+    ding ();
+  return 0;
+}
+
+/* Save the current line in saved_line_for_history. */
+int
+maybe_save_line ()
+{
+  if (saved_line_for_history == 0)
+    {
+      saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
+      saved_line_for_history->line = savestring (the_line);
+      saved_line_for_history->data = (char *)rl_undo_list;
+    }
+  return 0;
+}
+
+/* **************************************************************** */
+/*								    */
+/*			History Commands			    */
+/*								    */
+/* **************************************************************** */
+
+/* Meta-< goes to the start of the history. */
+int
+rl_beginning_of_history (count, key)
+     int count, key;
+{
+  return (rl_get_previous_history (1 + where_history (), key));
+}
+
+/* Meta-> goes to the end of the history.  (The current line). */
+int
+rl_end_of_history (count, key)
+     int count, key;
+{
+  maybe_replace_line ();
+  using_history ();
+  maybe_unsave_line ();
+  return 0;
+}
+
+/* Move down to the next history line. */
+int
+rl_get_next_history (count, key)
+     int count, key;
+{
+  HIST_ENTRY *temp;
+  int line_len;
+
+  if (count < 0)
+    return (rl_get_previous_history (-count, key));
+
+  if (count == 0)
+    return 0;
+
+  maybe_replace_line ();
+
+  temp = (HIST_ENTRY *)NULL;
+  while (count)
+    {
+      temp = next_history ();
+      if (!temp)
+	break;
+      --count;
+    }
+
+  if (temp == 0)
+    maybe_unsave_line ();
+  else
+    {
+      line_len = strlen (temp->line);
+
+      if (line_len >= rl_line_buffer_len)
+	rl_extend_line_buffer (line_len);
+
+      strcpy (the_line, temp->line);
+      rl_undo_list = (UNDO_LIST *)temp->data;
+      rl_end = rl_point = strlen (the_line);
+#if defined (VI_MODE)
+      if (rl_editing_mode == vi_mode)
+	rl_point = 0;
+#endif /* VI_MODE */
+    }
+  return 0;
+}
+
+/* Get the previous item out of our interactive history, making it the current
+   line.  If there is no previous history, just ding. */
+int
+rl_get_previous_history (count, key)
+     int count, key;
+{
+  HIST_ENTRY *old_temp, *temp;
+  int line_len;
+
+  if (count < 0)
+    return (rl_get_next_history (-count, key));
+
+  if (count == 0)
+    return 0;
+
+  /* If we don't have a line saved, then save this one. */
+  maybe_save_line ();
+
+  /* If the current line has changed, save the changes. */
+  maybe_replace_line ();
+
+  temp = old_temp = (HIST_ENTRY *)NULL;
+  while (count)
+    {
+      temp = previous_history ();
+      if (temp == 0)
+	break;
+
+      old_temp = temp;
+      --count;
+    }
+
+  /* If there was a large argument, and we moved back to the start of the
+     history, that is not an error.  So use the last value found. */
+  if (!temp && old_temp)
+    temp = old_temp;
+
+  if (temp == 0)
+    ding ();
+  else
+    {
+      line_len = strlen (temp->line);
+
+      if (line_len >= rl_line_buffer_len)
+	rl_extend_line_buffer (line_len);
+
+      strcpy (the_line, temp->line);
+      rl_undo_list = (UNDO_LIST *)temp->data;
+      rl_end = rl_point = line_len;
+
+#if defined (VI_MODE)
+      if (rl_editing_mode == vi_mode)
+	rl_point = 0;
+#endif /* VI_MODE */
+    }
+  return 0;
+}
+
+/* **************************************************************** */
+/*								    */
+/*		   The Mark and the Region.			    */
+/*								    */
+/* **************************************************************** */
+
+/* Set the mark at POSITION. */
+int
+_rl_set_mark_at_pos (position)
+     int position;
+{
+  if (position > rl_end)
+    return -1;
+
+  rl_mark = position;
+  return 0;
+}
+
+/* A bindable command to set the mark. */
+int
+rl_set_mark (count, key)
+     int count, key;
+{
+  return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));
+}
+
+/* Exchange the position of mark and point. */
+int
+rl_exchange_point_and_mark (count, key)
+     int count, key;
+{
+  if (rl_mark > rl_end)
+    rl_mark = -1;
+
+  if (rl_mark == -1)
+    {
+      ding ();
+      return -1;
+    }
+  else
+    SWAP (rl_point, rl_mark);
+
+  return 0;
+}
+
+/* **************************************************************** */
+/*								    */
+/*			    Editing Modes			    */
+/*								    */
+/* **************************************************************** */
+/* How to toggle back and forth between editing modes. */
+int
+rl_vi_editing_mode (count, key)
+     int count, key;
+{
+#if defined (VI_MODE)
+  rl_editing_mode = vi_mode;
+  rl_vi_insertion_mode (1, key);
+#endif /* VI_MODE */
+  return 0;
+}
+
+int
+rl_emacs_editing_mode (count, key)
+     int count, key;
+{
+  rl_editing_mode = emacs_mode;
+  _rl_keymap = emacs_standard_keymap;
+  return 0;
+}
diff --git a/readline/readline.h b/readline/readline.h
new file mode 100644
--- /dev/null
+++ b/readline/readline.h
@@ -0,0 +1,408 @@
+/* Readline.h -- the names of functions callable from within readline. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (_READLINE_H_)
+#define _READLINE_H_
+
+#if defined (READLINE_LIBRARY)
+#  include "keymaps.h"
+#  include "tilde.h"
+#else
+#  include <readline/keymaps.h>
+#  include <readline/tilde.h>
+#endif
+
+/* Readline data structures. */
+
+/* Maintaining the state of undo.  We remember individual deletes and inserts
+   on a chain of things to do. */
+
+/* The actions that undo knows how to undo.  Notice that UNDO_DELETE means
+   to insert some text, and UNDO_INSERT means to delete some text.   I.e.,
+   the code tells undo what to undo, not how to undo it. */
+enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };
+
+/* What an element of THE_UNDO_LIST looks like. */
+typedef struct undo_list {
+  struct undo_list *next;
+  int start, end;		/* Where the change took place. */
+  char *text;			/* The text to insert, if undoing a delete. */
+  enum undo_code what;		/* Delete, Insert, Begin, End. */
+} UNDO_LIST;
+
+/* The current undo list for RL_LINE_BUFFER. */
+extern UNDO_LIST *rl_undo_list;
+
+/* The data structure for mapping textual names to code addresses. */
+typedef struct _funmap {
+  char *name;
+  Function *function;
+} FUNMAP;
+
+extern FUNMAP **funmap;
+
+/* Functions available to bind to key sequences. */
+extern int
+  rl_tilde_expand (), rl_set_mark (), rl_exchange_point_and_mark (),
+  rl_beg_of_line (), rl_backward (), rl_delete (), rl_end_of_line (),
+  rl_forward (), ding (), rl_newline (), rl_kill_line (),
+  rl_copy_region_to_kill (), rl_kill_region (), rl_char_search (),
+  rl_clear_screen (), rl_get_next_history (), rl_get_previous_history (),
+  rl_quoted_insert (), rl_reverse_search_history (), rl_transpose_chars (),
+  rl_unix_line_discard (), rl_unix_word_rubout (),
+  rl_yank (), rl_rubout (), rl_backward_word (), rl_kill_word (),
+  rl_forward_word (), rl_tab_insert (), rl_yank_pop (), rl_yank_nth_arg (),
+  rl_backward_kill_word (), rl_backward_kill_line (), rl_transpose_words (),
+  rl_complete (), rl_possible_completions (), rl_insert_completions (),
+  rl_do_lowercase_version (), rl_kill_full_line (),
+  rl_digit_argument (), rl_universal_argument (), rl_abort (),
+  rl_undo_command (), rl_revert_line (), rl_beginning_of_history (),
+  rl_end_of_history (), rl_forward_search_history (), rl_insert (),
+  rl_upcase_word (), rl_downcase_word (), rl_capitalize_word (),
+  rl_restart_output (), rl_re_read_init_file (),
+  rl_dump_functions (), rl_dump_variables (), rl_dump_macros (),
+  rl_delete_horizontal_space (), rl_history_search_forward (),
+  rl_history_search_backward (), rl_tty_status (), rl_yank_last_arg (),
+  rl_insert_comment (), rl_backward_char_search (),
+  rl_copy_forward_word (), rl_copy_backward_word ();
+
+/* Not available unless readline is compiled -DPAREN_MATCHING. */
+extern int rl_insert_close ();
+
+/* Not available unless READLINE_CALLBACKS is defined. */
+extern void rl_callback_handler_install ();
+extern void rl_callback_read_char ();
+extern void rl_callback_handler_remove ();
+
+/* These are *both* defined even when VI_MODE is not. */
+extern int rl_vi_editing_mode (), rl_emacs_editing_mode ();
+
+/* Non incremental history searching. */
+extern int
+  rl_noninc_forward_search (), rl_noninc_reverse_search (),
+  rl_noninc_forward_search_again (), rl_noninc_reverse_search_again ();
+
+/* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
+extern int rl_vi_check ();
+extern int
+  rl_vi_undo (), rl_vi_redo (), rl_vi_tilde_expand (),
+  rl_vi_movement_mode (), rl_vi_insertion_mode (), rl_vi_arg_digit (),
+  rl_vi_prev_word (), rl_vi_next_word (), rl_vi_char_search (),
+  rl_vi_eof_maybe (), rl_vi_append_mode (), rl_vi_put (),
+  rl_vi_append_eol (), rl_vi_insert_beg (), rl_vi_delete (),
+  rl_vi_first_print (), rl_vi_fword (), rl_vi_fWord (), rl_vi_bword (),
+  rl_vi_bWord (), rl_vi_eword (), rl_vi_eWord (), rl_vi_end_word (),
+  rl_vi_change_case (), rl_vi_match (), rl_vi_bracktype (),
+  rl_vi_change_char (), rl_vi_yank_arg (), rl_vi_search (),
+  rl_vi_search_again (),  rl_vi_subst (), rl_vi_overstrike (),
+  rl_vi_overstrike_delete (), rl_vi_replace(), rl_vi_column (),
+  rl_vi_delete_to (), rl_vi_change_to (), rl_vi_yank_to (),
+  rl_vi_complete (), rl_vi_fetch_history (), rl_vi_set_mark (),
+  rl_vi_goto_mark (), rl_vi_back_to_indent ();
+
+/* Keyboard macro commands. */
+extern int rl_start_kbd_macro (), rl_end_kbd_macro ();
+extern int rl_call_last_kbd_macro ();
+extern void rl_push_macro_input ();
+
+extern int rl_arrow_keys(), rl_refresh_line ();
+
+/* **************************************************************** */
+/*								    */
+/*			Well Published Functions		    */
+/*								    */
+/* **************************************************************** */
+
+/* Readline functions. */
+/* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
+extern char *readline ();
+
+/* These functions are from bind.c. */
+/* rl_add_defun (char *name, Function *function, int key)
+   Add NAME to the list of named functions.  Make FUNCTION
+   be the function that gets called.
+   If KEY is not -1, then bind it. */
+extern int rl_add_defun ();
+
+extern Keymap rl_make_bare_keymap ();
+extern Keymap rl_copy_keymap ();
+extern Keymap rl_make_keymap ();
+extern void rl_discard_keymap ();
+extern Keymap rl_get_keymap (), rl_get_keymap_by_name ();
+extern void rl_set_keymap ();
+extern char *rl_get_keymap_name ();
+
+extern int rl_bind_key (), rl_bind_key_in_map ();
+extern int rl_unbind_key (), rl_unbind_key_in_map ();
+extern int rl_set_key ();
+extern int rl_generic_bind ();
+extern int rl_parse_and_bind ();
+/* Backwards compatibility, use rl_generic_bind instead. */
+extern int rl_macro_bind (), rl_variable_bind ();
+
+extern int rl_read_init_file ();
+
+extern Function *rl_named_function (), *rl_function_of_keyseq ();
+extern char **rl_invoking_keyseqs (), **rl_invoking_keyseqs_in_map ();
+extern void rl_function_dumper ();
+extern void rl_variable_dumper ();
+extern void rl_macro_dumper ();
+extern void rl_list_funmap_names ();
+
+/* Undocumented in the texinfo manual; not really useful to programs. */
+extern int rl_translate_keyseq ();
+extern void rl_initialize_funmap ();
+
+/* Functions for undoing. */
+extern int rl_begin_undo_group (), rl_end_undo_group ();
+extern void rl_add_undo (), free_undo_list ();
+extern int rl_do_undo ();
+extern int rl_modifying ();
+
+/* Functions for redisplay. */
+extern void rl_redisplay ();
+extern int rl_forced_update_display ();
+extern int rl_clear_message ();
+extern int rl_reset_line_state ();
+extern int rl_on_new_line ();
+
+#if defined (__STDC__) && defined (USE_VARARGS) && defined (PREFER_STDARG)
+extern int rl_message (const char *, ...);
+#else
+extern int rl_message ();
+#endif
+
+/* Undocumented in texinfo manual. */
+extern int rl_character_len ();
+extern int rl_show_char ();
+extern int crlf ();
+
+/* Modifying text. */
+extern int rl_insert_text (), rl_delete_text ();
+extern int rl_kill_text ();
+extern char *rl_copy_text ();
+
+/* `Public' utility functions. */
+extern int rl_reset_terminal ();
+extern int rl_stuff_char ();
+extern int rl_read_key (), rl_getc ();
+
+extern int rl_initialize ();
+
+/* Undocumented. */
+extern int rl_expand_prompt ();
+extern int rl_set_signals (), rl_clear_signals ();
+extern int maybe_save_line (), maybe_unsave_line (), maybe_replace_line ();
+
+/* Completion functions. */
+/* These functions are from complete.c. */
+extern int rl_complete_internal ();
+
+/* Return an array of strings which are the result of repeatadly calling
+   FUNC with TEXT. */
+extern char **completion_matches ();
+extern char *username_completion_function ();
+extern char *filename_completion_function ();
+
+/* **************************************************************** */
+/*								    */
+/*			Well Published Variables		    */
+/*								    */
+/* **************************************************************** */
+
+/* The version of this incarnation of the readline library. */
+extern char *rl_library_version;
+
+/* The name of the calling program.  You should initialize this to
+   whatever was in argv[0].  It is used when parsing conditionals. */
+extern char *rl_readline_name;
+
+/* The prompt readline uses.  This is set from the argument to
+   readline (), and should not be assigned to directly. */
+extern char *rl_prompt;
+
+/* The line buffer that is in use. */
+extern char *rl_line_buffer;
+
+/* The location of point, and end. */
+extern int rl_point, rl_end;
+
+extern int rl_mark;
+
+extern int rl_done;
+
+extern int rl_pending_input;
+
+/* Non-zero if we called this function from _rl_dispatch().  It's present
+   so functions can find out whether they were called from a key binding
+   or directly from an application. */
+int rl_dispatching;
+
+/* The name of the terminal to use. */
+extern char *rl_terminal_name;
+
+/* The input and output streams. */
+extern FILE *rl_instream, *rl_outstream;
+
+/* If non-zero, then this is the address of a function to call just
+   before readline_internal () prints the first prompt. */
+extern Function *rl_startup_hook;
+
+/* The address of a function to call periodically while Readline is
+   awaiting character input, or NULL, for no event handling. */
+extern Function *rl_event_hook;
+
+extern Function *rl_getc_function;
+extern VFunction *rl_redisplay_function;
+extern VFunction *rl_prep_term_function;
+extern VFunction *rl_deprep_term_function;
+
+/* Dispatch variables. */
+extern Keymap rl_executing_keymap;
+extern Keymap rl_binding_keymap;
+
+/* Completion variables. */
+/* Pointer to the generator function for completion_matches ().
+   NULL means to use filename_entry_function (), the default filename
+   completer. */
+extern Function *rl_completion_entry_function;
+
+/* If rl_ignore_some_completions_function is non-NULL it is the address
+   of a function to call after all of the possible matches have been
+   generated, but before the actual completion is done to the input line.
+   The function is called with one argument; a NULL terminated array
+   of (char *).  If your function removes any of the elements, they
+   must be free()'ed. */
+extern Function *rl_ignore_some_completions_function;
+
+/* Pointer to alternative function to create matches.
+   Function is called with TEXT, START, and END.
+   START and END are indices in RL_LINE_BUFFER saying what the boundaries
+   of TEXT are.
+   If this function exists and returns NULL then call the value of
+   rl_completion_entry_function to try to match, otherwise use the
+   array of strings returned. */
+extern CPPFunction *rl_attempted_completion_function;
+
+/* The basic list of characters that signal a break between words for the
+   completer routine.  The initial contents of this variable is what
+   breaks words in the shell, i.e. "n\"\\'`@$>". */
+extern char *rl_basic_word_break_characters;
+
+/* The list of characters that signal a break between words for
+   rl_complete_internal.  The default list is the contents of
+   rl_basic_word_break_characters.  */
+extern char *rl_completer_word_break_characters;
+
+/* List of characters which can be used to quote a substring of the line.
+   Completion occurs on the entire substring, and within the substring   
+   rl_completer_word_break_characters are treated as any other character,
+   unless they also appear within this list. */
+extern char *rl_completer_quote_characters;
+
+/* List of quote characters which cause a word break. */
+extern char *rl_basic_quote_characters;
+
+/* List of characters that need to be quoted in filenames by the completer. */
+extern char *rl_filename_quote_characters;
+
+/* List of characters that are word break characters, but should be left
+   in TEXT when it is passed to the completion function.  The shell uses
+   this to help determine what kind of completing to do. */
+extern char *rl_special_prefixes;
+
+/* If non-zero, then this is the address of a function to call when
+   completing on a directory name.  The function is called with
+   the address of a string (the current directory name) as an arg. */
+extern Function *rl_directory_completion_hook;
+
+/* Backwards compatibility with previous versions of readline. */
+#define rl_symbolic_link_hook rl_directory_completion_hook
+
+/* Non-zero means that the results of the matches are to be treated
+   as filenames.  This is ALWAYS zero on entry, and can only be changed
+   within a completion entry finder function. */
+extern int rl_filename_completion_desired;
+
+/* Non-zero means that the results of the matches are to be quoted using
+   double quotes (or an application-specific quoting mechanism) if the
+   filename contains any characters in rl_word_break_chars.  This is
+   ALWAYS non-zero on entry, and can only be changed within a completion
+   entry finder function. */
+extern int rl_filename_quoting_desired;
+
+/* Set to a function to quote a filename in an application-specific fashion.
+   Called with the text to quote, the type of match found (single or multiple)
+   and a pointer to the quoting character to be used, which the function can
+   reset if desired. */
+extern CPFunction *rl_filename_quoting_function;
+
+/* Function to call to remove quoting characters from a filename.  Called
+   before completion is attempted, so the embedded quotes do not interfere
+   with matching names in the file system. */
+extern CPFunction *rl_filename_dequoting_function;
+
+/* Function to call to decide whether or not a word break character is
+   quoted.  If a character is quoted, it does not break words for the
+   completer. */
+extern Function *rl_char_is_quoted_p;
+
+/* Non-zero means to suppress normal filename completion after the
+   user-specified completion function has been called. */
+extern int rl_attempted_completion_over;
+
+/* Set to a character describing the type of completion being attempted by
+   rl_complete_internal; available for use by application completion
+   functions. */
+extern int rl_completion_type;
+
+/* Character appended to completed words when at the end of the line.  The
+   default is a space.  Nothing is added if this is '\0'. */
+extern int rl_completion_append_character;
+
+/* Up to this many items will be displayed in response to a
+   possible-completions call.  After that, we ask the user if she
+   is sure she wants to see them all.  The default value is 100. */
+extern int rl_completion_query_items;
+
+/* If non-zero, then disallow duplicates in the matches. */
+extern int rl_ignore_completion_duplicates;
+
+/* If this is non-zero, completion is (temporarily) inhibited, and the
+   completion character will be inserted as any other. */
+extern int rl_inhibit_completion;
+   
+/* Definitions available for use by readline clients. */
+#define RL_PROMPT_START_IGNORE	'\001'
+#define RL_PROMPT_END_IGNORE	'\002'
+
+/* Possible values for do_replace argument to rl_filename_quoting_function,
+   called by rl_complete_internal. */
+#define NO_MATCH        0
+#define SINGLE_MATCH    1
+#define MULT_MATCH      2
+
+#if !defined (savestring)
+extern char *savestring ();	/* XXX backwards compatibility */
+#endif
+
+#endif /* _READLINE_H_ */
diff --git a/readline/rlconf.h b/readline/rlconf.h
new file mode 100644
--- /dev/null
+++ b/readline/rlconf.h
@@ -0,0 +1,63 @@
+/* rlconf.h -- readline configuration definitions */
+
+/* Copyright (C) 1994 Free Software Foundation, Inc.
+
+   This file contains the Readline Library (the Library), a set of
+   routines for providing Emacs style line input to programs that ask
+   for it.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (_RLCONF_H_)
+#define _RLCONF_H_
+
+/* Define this if you want the vi-mode editing available. */
+#define VI_MODE
+
+/* Define this to get an indication of file type when listing completions. */
+#define VISIBLE_STATS
+
+/* If defined, readline shows opening parens and braces when closing
+   paren or brace entered. */
+/* #define PAREN_MATCHING */
+
+/* This definition is needed by readline.c, rltty.c, and signals.c. */
+/* If on, then readline handles signals in a way that doesn't screw. */
+#define HANDLE_SIGNALS
+
+/* Ugly but working hack for binding prefix meta. */
+#define PREFIX_META_HACK
+
+/* The final, last-ditch effort file name for an init file. */
+#define DEFAULT_INPUTRC "~/.inputrc"
+
+/* If defined, expand tabs to spaces. */
+#define DISPLAY_TABS
+
+/* If defined, use the terminal escape sequence to move the cursor forward
+   over a character when updating the line rather than rewriting it. */
+/* #define HACK_TERMCAP_MOTION */
+
+/* The string inserted by the `insert comment' command. */
+#define RL_COMMENT_BEGIN_DEFAULT "#"
+
+/* Define this if you want code that allows readline to be used in an
+   X `callback' style. */
+#if !defined (SHELL)
+#  define READLINE_CALLBACKS
+#endif
+
+#endif /* _RLCONF_H_ */
diff --git a/readline/rldefs.h b/readline/rldefs.h
new file mode 100644
--- /dev/null
+++ b/readline/rldefs.h
@@ -0,0 +1,135 @@
+/* rldefs.h -- an attempt to isolate some of the system-specific defines
+   for readline.  This should be included after any files that define
+   system-specific constants like _POSIX_VERSION or USG. */
+
+/* Copyright (C) 1987,1989 Free Software Foundation, Inc.
+
+   This file contains the Readline Library (the Library), a set of
+   routines for providing Emacs style line input to programs that ask
+   for it.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (_RLDEFS_H_)
+#define _RLDEFS_H_
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#if defined (_POSIX_VERSION) && !defined (TERMIOS_MISSING)
+#  define TERMIOS_TTY_DRIVER
+#else
+#  if defined (HAVE_TERMIO_H)
+#    define TERMIO_TTY_DRIVER
+#  else
+#    define NEW_TTY_DRIVER
+#  endif
+#endif
+
+/* Posix macro to check file in statbuf for directory-ness.
+   This requires that <sys/stat.h> be included before this test. */
+#if defined (S_IFDIR) && !defined (S_ISDIR)
+#  define S_ISDIR(m) (((m)&S_IFMT) == S_IFDIR)
+#endif
+
+/* Decide which flavor of the header file describing the C library
+   string functions to include and include it. */
+
+#if defined (HAVE_STRING_H)
+#  include <string.h>
+#else /* !HAVE_STRING_H */
+#  include <strings.h>
+#endif /* !HAVE_STRING_H */
+
+#if !defined (strchr) && !defined (__STDC__)
+extern char *strchr (), *strrchr ();
+#endif /* !strchr && !__STDC__ */
+
+#if defined (PREFER_STDARG)
+#  include <stdarg.h>
+#else
+#  if defined (PREFER_VARARGS)
+#    include <varargs.h>
+#  endif
+#endif
+
+#if defined (HAVE_STRCASECMP)
+#define _rl_stricmp strcasecmp
+#define _rl_strnicmp strncasecmp
+#else
+extern int _rl_stricmp (), _rl_strnicmp ();
+#endif
+
+#if !defined (emacs_mode)
+#  define no_mode -1
+#  define vi_mode 0
+#  define emacs_mode 1
+#endif
+
+/* If you cast map[key].function to type (Keymap) on a Cray,
+   the compiler takes the value of map[key].function and
+   divides it by 4 to convert between pointer types (pointers
+   to functions and pointers to structs are different sizes).
+   This is not what is wanted. */
+#if defined (CRAY)
+#  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)((int)map[key].function)
+#  define KEYMAP_TO_FUNCTION(data)	(Function *)((int)(data))
+#else
+#  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)(map[key].function)
+#  define KEYMAP_TO_FUNCTION(data)	(Function *)(data)
+#endif
+
+#ifndef savestring
+extern char *xmalloc ();
+#define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
+#endif
+
+/* Possible values for _rl_bell_preference. */
+#define NO_BELL 0
+#define AUDIBLE_BELL 1
+#define VISIBLE_BELL 2
+
+/* Definitions used when searching the line for characters. */
+/* NOTE: it is necessary that opposite directions are inverses */
+#define	FTO	 1		/* forward to */
+#define BTO	-1		/* backward to */
+#define FFIND	 2		/* forward find */
+#define BFIND	-2		/* backward find */
+
+/* Possible values for the found_quote flags word used by the completion
+   functions.  It says what kind of (shell-like) quoting we found anywhere
+   in the line. */
+#define RL_QF_SINGLE_QUOTE	0x1
+#define RL_QF_DOUBLE_QUOTE	0x2
+#define RL_QF_BACKSLASH		0x4
+
+/* Default readline line buffer length. */
+#define DEFAULT_BUFFER_SIZE 256
+
+#if !defined (STREQ)
+#define STREQ(a, b)	(((a)[0] == (b)[0]) && (strcmp ((a), (b)) == 0))
+#define STREQN(a, b, n)	(((a)[0] == (b)[0]) && (strncmp ((a), (b), (n)) == 0))
+#endif
+
+#if !defined (FREE)
+#  define FREE(x)	if (x) free (x)
+#endif
+
+/* CONFIGURATION SECTION */
+#include "rlconf.h"
+
+#endif /* !_RLDEFS_H_ */
diff --git a/readline/rltty.c b/readline/rltty.c
new file mode 100644
--- /dev/null
+++ b/readline/rltty.c
@@ -0,0 +1,728 @@
+/* rltty.c -- functions to prepare and restore the terminal for readline's
+   use. */
+
+/* Copyright (C) 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <signal.h>
+#include <errno.h>
+#include <stdio.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#include "rldefs.h"
+
+#if !defined (SHELL) && defined (GWINSZ_IN_SYS_IOCTL)
+#  include <sys/ioctl.h>
+#endif /* !SHELL && GWINSZ_IN_SYS_IOCTL */
+
+#include "rltty.h"
+#include "readline.h"
+
+#if !defined (errno)
+extern int errno;
+#endif /* !errno */
+
+extern int readline_echoing_p;
+extern int _rl_eof_char;
+
+extern int _rl_enable_keypad, _rl_enable_meta;
+
+extern void _rl_control_keypad ();
+
+#if defined (__GO32__)
+#  include <pc.h>
+#  undef HANDLE_SIGNALS
+#endif /* __GO32__ */
+
+/* Indirect functions to allow apps control over terminal management. */
+extern void rl_prep_terminal (), rl_deprep_terminal ();
+
+VFunction *rl_prep_term_function = rl_prep_terminal;
+VFunction *rl_deprep_term_function = rl_deprep_terminal;
+
+/* **************************************************************** */
+/*								    */
+/*			   Signal Management			    */
+/*								    */
+/* **************************************************************** */
+
+#if defined (HAVE_POSIX_SIGNALS)
+static sigset_t sigint_set, sigint_oset;
+#else /* !HAVE_POSIX_SIGNALS */
+#  if defined (HAVE_BSD_SIGNALS)
+static int sigint_oldmask;
+#  endif /* HAVE_BSD_SIGNALS */
+#endif /* !HAVE_POSIX_SIGNALS */
+
+static int sigint_blocked;
+
+/* Cause SIGINT to not be delivered until the corresponding call to
+   release_sigint(). */
+static void
+block_sigint ()
+{
+  if (sigint_blocked)
+    return;
+
+#if defined (HAVE_POSIX_SIGNALS)
+  sigemptyset (&sigint_set);
+  sigemptyset (&sigint_oset);
+  sigaddset (&sigint_set, SIGINT);
+  sigprocmask (SIG_BLOCK, &sigint_set, &sigint_oset);
+#else /* !HAVE_POSIX_SIGNALS */
+#  if defined (HAVE_BSD_SIGNALS)
+  sigint_oldmask = sigblock (sigmask (SIGINT));
+#  else /* !HAVE_BSD_SIGNALS */
+#    if defined (HAVE_USG_SIGHOLD)
+  sighold (SIGINT);
+#    endif /* HAVE_USG_SIGHOLD */
+#  endif /* !HAVE_BSD_SIGNALS */
+#endif /* !HAVE_POSIX_SIGNALS */
+  sigint_blocked = 1;
+}
+
+/* Allow SIGINT to be delivered. */
+static void
+release_sigint ()
+{
+  if (!sigint_blocked)
+    return;
+
+#if defined (HAVE_POSIX_SIGNALS)
+  sigprocmask (SIG_SETMASK, &sigint_oset, (sigset_t *)NULL);
+#else
+#  if defined (HAVE_BSD_SIGNALS)
+  sigsetmask (sigint_oldmask);
+#  else /* !HAVE_BSD_SIGNALS */
+#    if defined (HAVE_USG_SIGHOLD)
+  sigrelse (SIGINT);
+#    endif /* HAVE_USG_SIGHOLD */
+#  endif /* !HAVE_BSD_SIGNALS */
+#endif /* !HAVE_POSIX_SIGNALS */
+
+  sigint_blocked = 0;
+}
+
+/* **************************************************************** */
+/*								    */
+/*		      Saving and Restoring the TTY	    	    */
+/*								    */
+/* **************************************************************** */
+
+/* Non-zero means that the terminal is in a prepped state. */
+static int terminal_prepped;
+
+/* If non-zero, means that this process has called tcflow(fd, TCOOFF)
+   and output is suspended. */
+#if defined (__ksr1__)
+static int ksrflow;
+#endif
+
+#if !defined (SHELL) && defined (TIOCGWINSZ)
+/* Dummy call to force a backgrounded readline to stop before it tries
+   to get the tty settings. */
+static void
+set_winsize (tty)
+     int tty;
+{
+  struct winsize w;
+
+  if (ioctl (tty, TIOCGWINSZ, &w) == 0)
+      (void) ioctl (tty, TIOCSWINSZ, &w);
+}
+#else /* SHELL || !TIOCGWINSZ */
+#  define set_winsize(tty)
+#endif /* SHELL || !TIOCGWINSZ */
+
+#if defined (NEW_TTY_DRIVER)
+
+/* Values for the `flags' field of a struct bsdtty.  This tells which
+   elements of the struct bsdtty have been fetched from the system and
+   are valid. */
+#define SGTTY_SET	0x01
+#define LFLAG_SET	0x02
+#define TCHARS_SET	0x04
+#define LTCHARS_SET	0x08
+
+struct bsdtty {
+  struct sgttyb sgttyb;	/* Basic BSD tty driver information. */
+  int lflag;		/* Local mode flags, like LPASS8. */
+#if defined (TIOCGETC)
+  struct tchars tchars;	/* Terminal special characters, including ^S and ^Q. */
+#endif
+#if defined (TIOCGLTC)
+  struct ltchars ltchars; /* 4.2 BSD editing characters */
+#endif
+  int flags;		/* Bitmap saying which parts of the struct are valid. */
+};
+
+#define TIOTYPE struct bsdtty
+
+static TIOTYPE otio;
+
+static int
+get_tty_settings (tty, tiop)
+     int tty;
+     TIOTYPE *tiop;
+{
+  set_winsize (tty);
+
+  tiop->flags = tiop->lflag = 0;
+
+  ioctl (tty, TIOCGETP, &(tiop->sgttyb));
+  tiop->flags |= SGTTY_SET;
+
+#if defined (TIOCLGET)
+  ioctl (tty, TIOCLGET, &(tiop->lflag));
+  tiop->flags |= LFLAG_SET;
+#endif
+
+#if defined (TIOCGETC)
+  ioctl (tty, TIOCGETC, &(tiop->tchars));
+  tiop->flags |= TCHARS_SET;
+#endif
+
+#if defined (TIOCGLTC)
+  ioctl (tty, TIOCGLTC, &(tiop->ltchars));
+  tiop->flags |= LTCHARS_SET;
+#endif
+
+  return 0;
+}
+
+static int
+set_tty_settings (tty, tiop)
+     int tty;
+     TIOTYPE *tiop;
+{
+  if (tiop->flags & SGTTY_SET)
+    {
+      ioctl (tty, TIOCSETN, &(tiop->sgttyb));
+      tiop->flags &= ~SGTTY_SET;
+    }
+  readline_echoing_p = 1;
+
+#if defined (TIOCLSET)
+  if (tiop->flags & LFLAG_SET)
+    {
+      ioctl (tty, TIOCLSET, &(tiop->lflag));
+      tiop->flags &= ~LFLAG_SET;
+    }
+#endif
+
+#if defined (TIOCSETC)
+  if (tiop->flags & TCHARS_SET)
+    {
+      ioctl (tty, TIOCSETC, &(tiop->tchars));
+      tiop->flags &= ~TCHARS_SET;
+    }
+#endif
+
+#if defined (TIOCSLTC)
+  if (tiop->flags & LTCHARS_SET)
+    {
+      ioctl (tty, TIOCSLTC, &(tiop->ltchars));
+      tiop->flags &= ~LTCHARS_SET;
+    }
+#endif
+
+  return 0;
+}
+
+static void
+prepare_terminal_settings (meta_flag, otio, tiop)
+     int meta_flag;
+     TIOTYPE otio, *tiop;
+{
+#if !defined (__GO32__)
+  readline_echoing_p = (otio.sgttyb.sg_flags & ECHO);
+
+  /* Copy the original settings to the structure we're going to use for
+     our settings. */
+  tiop->sgttyb = otio.sgttyb;
+  tiop->lflag = otio.lflag;
+#if defined (TIOCGETC)
+  tiop->tchars = otio.tchars;
+#endif
+#if defined (TIOCGLTC)
+  tiop->ltchars = otio.ltchars;
+#endif
+  tiop->flags = otio.flags;
+
+  /* First, the basic settings to put us into character-at-a-time, no-echo
+     input mode. */
+  tiop->sgttyb.sg_flags &= ~(ECHO | CRMOD);
+  tiop->sgttyb.sg_flags |= CBREAK;
+
+  /* If this terminal doesn't care how the 8th bit is used, then we can
+     use it for the meta-key.  If only one of even or odd parity is
+     specified, then the terminal is using parity, and we cannot. */
+#if !defined (ANYP)
+#  define ANYP (EVENP | ODDP)
+#endif
+  if (((otio.sgttyb.sg_flags & ANYP) == ANYP) ||
+      ((otio.sgttyb.sg_flags & ANYP) == 0))
+    {
+      tiop->sgttyb.sg_flags |= ANYP;
+
+      /* Hack on local mode flags if we can. */
+#if defined (TIOCLGET)
+#  if defined (LPASS8)
+      tiop->lflag |= LPASS8;
+#  endif /* LPASS8 */
+#endif /* TIOCLGET */
+    }
+
+#if defined (TIOCGETC)
+#  if defined (USE_XON_XOFF)
+  /* Get rid of terminal output start and stop characters. */
+  tiop->tchars.t_stopc = -1; /* C-s */
+  tiop->tchars.t_startc = -1; /* C-q */
+
+  /* If there is an XON character, bind it to restart the output. */
+  if (otio.tchars.t_startc != -1)
+    rl_bind_key (otio.tchars.t_startc, rl_restart_output);
+#  endif /* USE_XON_XOFF */
+
+  /* If there is an EOF char, bind _rl_eof_char to it. */
+  if (otio.tchars.t_eofc != -1)
+    _rl_eof_char = otio.tchars.t_eofc;
+
+#  if defined (NO_KILL_INTR)
+  /* Get rid of terminal-generated SIGQUIT and SIGINT. */
+  tiop->tchars.t_quitc = -1; /* C-\ */
+  tiop->tchars.t_intrc = -1; /* C-c */
+#  endif /* NO_KILL_INTR */
+#endif /* TIOCGETC */
+
+#if defined (TIOCGLTC)
+  /* Make the interrupt keys go away.  Just enough to make people happy. */
+  tiop->ltchars.t_dsuspc = -1;	/* C-y */
+  tiop->ltchars.t_lnextc = -1;	/* C-v */
+#endif /* TIOCGLTC */
+#endif /* !__GO32__ */
+}
+
+#else  /* !defined (NEW_TTY_DRIVER) */
+
+#if !defined (VMIN)
+#  define VMIN VEOF
+#endif
+
+#if !defined (VTIME)
+#  define VTIME VEOL
+#endif
+
+#if defined (TERMIOS_TTY_DRIVER)
+#  define TIOTYPE struct termios
+#  define DRAIN_OUTPUT(fd)	tcdrain (fd)
+#  define GETATTR(tty, tiop)	(tcgetattr (tty, tiop))
+#  ifdef M_UNIX
+#    define SETATTR(tty, tiop)	(tcsetattr (tty, TCSANOW, tiop))
+#  else
+#    define SETATTR(tty, tiop)	(tcsetattr (tty, TCSADRAIN, tiop))
+#  endif /* !M_UNIX */
+#else
+#  define TIOTYPE struct termio
+#  define DRAIN_OUTPUT(fd)
+#  define GETATTR(tty, tiop)	(ioctl (tty, TCGETA, tiop))
+#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETA, tiop))
+#endif /* !TERMIOS_TTY_DRIVER */
+
+static TIOTYPE otio;
+
+#if defined (FLUSHO)
+#  define OUTPUT_BEING_FLUSHED(tp)  (tp->c_lflag & FLUSHO)
+#else
+#  define OUTPUT_BEING_FLUSHED(tp)  0
+#endif
+
+static void
+rltty_warning (msg)
+     char *msg;
+{
+  fprintf (stderr, "readline: warning: %s\n", msg);
+}
+
+#if defined (_AIX)
+void
+setopost(tp)
+TIOTYPE *tp;
+{
+  if ((tp->c_oflag & OPOST) == 0)
+    {
+      rltty_warning ("turning on OPOST for terminal\r");
+      tp->c_oflag |= OPOST|ONLCR;
+    }
+}
+#endif
+
+static int
+get_tty_settings (tty, tiop)
+     int tty;
+     TIOTYPE *tiop;
+{
+  int ioctl_ret;
+  set_winsize (tty);
+
+  while (1)
+    {
+      ioctl_ret = GETATTR (tty, tiop);
+      if (ioctl_ret < 0)
+	{
+	  if (errno != EINTR)
+	    return -1;
+	  else
+	    continue;
+	}
+      if (OUTPUT_BEING_FLUSHED (tiop))
+	{
+#if defined (FLUSHO) && defined (_AIX41)
+	  rltty_warning ("turning off output flushing");
+	  tiop->c_lflag &= ~FLUSHO;
+	  break;
+#else
+	  continue;
+#endif
+	}
+      break;
+    }
+
+#if defined (_AIX)
+  setopost(tiop);
+#endif
+
+  return 0;
+}
+
+static int
+set_tty_settings (tty, tiop)
+     int tty;
+     TIOTYPE *tiop;
+{
+  while (SETATTR (tty, tiop) < 0)
+    {
+      if (errno != EINTR)
+	return -1;
+      errno = 0;
+    }
+
+#if 0
+
+#if defined (TERMIOS_TTY_DRIVER)
+#  if defined (__ksr1__)
+  if (ksrflow)
+    {
+      ksrflow = 0;
+      tcflow (tty, TCOON);
+    }
+#  else /* !ksr1 */
+  tcflow (tty, TCOON);		/* Simulate a ^Q. */
+#  endif /* !ksr1 */
+#else
+  ioctl (tty, TCXONC, 1);	/* Simulate a ^Q. */
+#endif /* !TERMIOS_TTY_DRIVER */
+
+#endif
+
+  return 0;
+}
+
+static void
+prepare_terminal_settings (meta_flag, otio, tiop)
+     int meta_flag;
+     TIOTYPE otio, *tiop;
+{
+  readline_echoing_p = (otio.c_lflag & ECHO);
+
+  tiop->c_lflag &= ~(ICANON | ECHO);
+
+  if ((unsigned char) otio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
+    _rl_eof_char = otio.c_cc[VEOF];
+
+#if defined (USE_XON_XOFF)
+#if defined (IXANY)
+  tiop->c_iflag &= ~(IXON | IXOFF | IXANY);
+#else
+  /* `strict' Posix systems do not define IXANY. */
+  tiop->c_iflag &= ~(IXON | IXOFF);
+#endif /* IXANY */
+#endif /* USE_XON_XOFF */
+
+  /* Only turn this off if we are using all 8 bits. */
+  if (((tiop->c_cflag & CSIZE) == CS8) || meta_flag)
+    tiop->c_iflag &= ~(ISTRIP | INPCK);
+
+  /* Make sure we differentiate between CR and NL on input. */
+  tiop->c_iflag &= ~(ICRNL | INLCR);
+
+#if !defined (HANDLE_SIGNALS)
+  tiop->c_lflag &= ~ISIG;
+#else
+  tiop->c_lflag |= ISIG;
+#endif
+
+  tiop->c_cc[VMIN] = 1;
+  tiop->c_cc[VTIME] = 0;
+
+#if defined (FLUSHO)
+  if (OUTPUT_BEING_FLUSHED (tiop))
+    {
+      tiop->c_lflag &= ~FLUSHO;
+      otio.c_lflag &= ~FLUSHO;
+    }
+#endif
+
+  /* Turn off characters that we need on Posix systems with job control,
+     just to be sure.  This includes ^Y and ^V.  This should not really
+     be necessary.  */
+#if defined (TERMIOS_TTY_DRIVER) && defined (_POSIX_VDISABLE)
+
+#if defined (VLNEXT)
+  tiop->c_cc[VLNEXT] = _POSIX_VDISABLE;
+#endif
+
+#if defined (VDSUSP)
+  tiop->c_cc[VDSUSP] = _POSIX_VDISABLE;
+#endif
+
+#endif /* TERMIOS_TTY_DRIVER && _POSIX_VDISABLE */
+}
+#endif  /* NEW_TTY_DRIVER */
+
+/* Put the terminal in CBREAK mode so that we can detect key presses. */
+void
+rl_prep_terminal (meta_flag)
+     int meta_flag;
+{
+#if !defined (__GO32__)
+  int tty;
+  TIOTYPE tio;
+
+  if (terminal_prepped)
+    return;
+
+  /* Try to keep this function from being INTerrupted. */
+  block_sigint ();
+
+  tty = fileno (rl_instream);
+
+  if (get_tty_settings (tty, &tio) < 0)
+    {
+      release_sigint ();
+      return;
+    }
+
+  otio = tio;
+
+  prepare_terminal_settings (meta_flag, otio, &tio);
+
+  if (set_tty_settings (tty, &tio) < 0)
+    {
+      release_sigint ();
+      return;
+    }
+
+  if (_rl_enable_keypad)
+    _rl_control_keypad (1);
+
+  fflush (rl_outstream);
+  terminal_prepped = 1;
+
+  release_sigint ();
+#endif /* !__GO32__ */
+}
+
+/* Restore the terminal's normal settings and modes. */
+void
+rl_deprep_terminal ()
+{
+#if !defined (__GO32__)
+  int tty;
+
+  if (!terminal_prepped)
+    return;
+
+  /* Try to keep this function from being interrupted. */
+  block_sigint ();
+
+  tty = fileno (rl_instream);
+
+  if (_rl_enable_keypad)
+    _rl_control_keypad (0);
+
+  fflush (rl_outstream);
+
+  if (set_tty_settings (tty, &otio) < 0)
+    {
+      release_sigint ();
+      return;
+    }
+
+  terminal_prepped = 0;
+
+  release_sigint ();
+#endif /* !__GO32__ */
+}
+
+/* **************************************************************** */
+/*								    */
+/*			Bogus Flow Control      		    */
+/*								    */
+/* **************************************************************** */
+
+int
+rl_restart_output (count, key)
+     int count, key;
+{
+  int fildes = fileno (rl_outstream);
+#if defined (TIOCSTART)
+#if defined (apollo)
+  ioctl (&fildes, TIOCSTART, 0);
+#else
+  ioctl (fildes, TIOCSTART, 0);
+#endif /* apollo */
+
+#else /* !TIOCSTART */
+#  if defined (TERMIOS_TTY_DRIVER)
+#    if defined (__ksr1__)
+  if (ksrflow)
+    {
+      ksrflow = 0;
+      tcflow (fildes, TCOON);
+    }
+#    else /* !ksr1 */
+  tcflow (fildes, TCOON);		/* Simulate a ^Q. */
+#    endif /* !ksr1 */
+#  else /* !TERMIOS_TTY_DRIVER */
+#    if defined (TCXONC)
+  ioctl (fildes, TCXONC, TCOON);
+#    endif /* TCXONC */
+#  endif /* !TERMIOS_TTY_DRIVER */
+#endif /* !TIOCSTART */
+
+  return 0;
+}
+
+int
+rl_stop_output (count, key)
+     int count, key;
+{
+  int fildes = fileno (rl_instream);
+
+#if defined (TIOCSTOP)
+# if defined (apollo)
+  ioctl (&fildes, TIOCSTOP, 0);
+# else
+  ioctl (fildes, TIOCSTOP, 0);
+# endif /* apollo */
+#else /* !TIOCSTOP */
+# if defined (TERMIOS_TTY_DRIVER)
+#  if defined (__ksr1__)
+  ksrflow = 1;
+#  endif /* ksr1 */
+  tcflow (fildes, TCOOFF);
+# else
+#   if defined (TCXONC)
+  ioctl (fildes, TCXONC, TCOON);
+#   endif /* TCXONC */
+# endif /* !TERMIOS_TTY_DRIVER */
+#endif /* !TIOCSTOP */
+
+  return 0;
+}
+
+/* **************************************************************** */
+/*								    */
+/*			Default Key Bindings			    */
+/*								    */
+/* **************************************************************** */
+void
+rltty_set_default_bindings (kmap)
+     Keymap kmap;
+{
+  TIOTYPE ttybuff;
+  int tty = fileno (rl_instream);
+
+#if defined (NEW_TTY_DRIVER)
+
+#define SET_SPECIAL(sc, func) \
+  do \
+    { \
+      int ic; \
+      ic = sc; \
+      if (ic != -1 && kmap[ic].type == ISFUNC) \
+	kmap[ic].function = func; \
+    } \
+  while (0)
+
+  if (get_tty_settings (tty, &ttybuff) == 0)
+    {
+      if (ttybuff.flags & SGTTY_SET)
+	{
+	  SET_SPECIAL (ttybuff.sgttyb.sg_erase, rl_rubout);
+	  SET_SPECIAL (ttybuff.sgttyb.sg_kill, rl_unix_line_discard);
+	}
+
+#  if defined (TIOCGLTC)
+      if (ttybuff.flags & LTCHARS_SET)
+	{
+	  SET_SPECIAL (ttybuff.ltchars.t_werasc, rl_unix_word_rubout);
+	  SET_SPECIAL (ttybuff.ltchars.t_lnextc, rl_quoted_insert);
+	}
+#  endif /* TIOCGLTC */
+    }
+
+#else /* !NEW_TTY_DRIVER */
+
+#define SET_SPECIAL(sc, func) \
+  do \
+    { \
+      unsigned char uc; \
+      uc = ttybuff.c_cc[sc]; \
+      if (uc != (unsigned char)_POSIX_VDISABLE && kmap[uc].type == ISFUNC) \
+	kmap[uc].function = func; \
+    } \
+  while (0)
+
+  if (get_tty_settings (tty, &ttybuff) == 0)
+    {
+      SET_SPECIAL (VERASE, rl_rubout);
+      SET_SPECIAL (VKILL, rl_unix_line_discard);
+
+#  if defined (VLNEXT) && defined (TERMIOS_TTY_DRIVER)
+      SET_SPECIAL (VLNEXT, rl_quoted_insert);
+#  endif /* VLNEXT && TERMIOS_TTY_DRIVER */
+
+#  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)
+      SET_SPECIAL (VWERASE, rl_unix_word_rubout);
+#  endif /* VWERASE && TERMIOS_TTY_DRIVER */
+    }
+#endif /* !NEW_TTY_DRIVER */
+}
diff --git a/readline/rltty.h b/readline/rltty.h
new file mode 100644
--- /dev/null
+++ b/readline/rltty.h
@@ -0,0 +1,73 @@
+/* rltty.h - tty driver-related definitions used by some library files. */
+
+/* Copyright (C) 1995 Free Software Foundation, Inc.
+
+   This file contains the Readline Library (the Library), a set of
+   routines for providing Emacs style line input to programs that ask
+   for it.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (_RLTTY_H_)
+#define _RLTTY_H
+
+/* Posix systems use termios and the Posix signal functions. */
+#if defined (TERMIOS_TTY_DRIVER)
+#  include <termios.h>
+#endif /* TERMIOS_TTY_DRIVER */
+
+/* System V machines use termio. */
+#if defined (TERMIO_TTY_DRIVER)
+#  include <termio.h>
+#  if !defined (TCOON)
+#    define TCOON 1
+#  endif
+#endif /* TERMIO_TTY_DRIVER */
+
+/* Other (BSD) machines use sgtty. */
+#if defined (NEW_TTY_DRIVER)
+#  include <sgtty.h>
+#endif
+
+/* Stuff for `struct winsize' on various systems. */
+#if defined (HAVE_SYS_STREAM_H)
+#  include <sys/stream.h>
+#endif /* HAVE_SYS_STREAM_H */
+#if defined (HAVE_SYS_PTEM_H)
+#  include <sys/ptem.h>
+#  define _IO_PTEM_H		/* work around SVR4.2 1.1.4 bug */
+#endif /* HAVE_SYS_PTEM_H */
+#if defined (HAVE_SYS_PTE_H)
+#  include <sys/pte.h>
+#endif /* HAVE_SYS_PTE_H */
+
+/* Define _POSIX_VDISABLE if we are not using the `new' tty driver and
+   it is not already defined.  It is used both to determine if a
+   special character is disabled and to disable certain special
+   characters.  Posix systems should set to 0, USG systems to -1. */
+#if !defined (NEW_TTY_DRIVER) && !defined (_POSIX_VDISABLE)
+#  if defined (_SVR4_VDISABLE)
+#    define _POSIX_VDISABLE _SVR4_VDISABLE
+#  else
+#    if defined (_POSIX_VERSION)
+#      define _POSIX_VDISABLE 0
+#    else /* !_POSIX_VERSION */
+#      define _POSIX_VDISABLE -1
+#    endif /* !_POSIX_VERSION */
+#  endif /* !_SVR4_DISABLE */
+#endif /* !NEW_TTY_DRIVER && !_POSIX_VDISABLE */
+
+#endif /* _RLTTY_H_ */
diff --git a/readline/search.c b/readline/search.c
new file mode 100644
--- /dev/null
+++ b/readline/search.c
@@ -0,0 +1,378 @@
+/* search.c - code for non-incremental searching in emacs and vi modes. */
+
+/* Copyright (C) 1992 Free Software Foundation, Inc.
+
+   This file is part of the Readline Library (the Library), a set of
+   routines for providing Emacs style line input to programs that ask
+   for it.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <stdio.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif
+
+#include "rldefs.h"
+#include "readline.h"
+#include "history.h"
+
+#ifdef abs
+#  undef abs
+#endif
+#define abs(x)		(((x) >= 0) ? (x) : -(x))
+
+extern char *xmalloc (), *xrealloc ();
+
+/* Variables imported from readline.c */
+extern int rl_point, rl_end, rl_line_buffer_len;
+extern int rl_editing_mode;
+extern char *rl_prompt;
+extern char *rl_line_buffer;
+extern HIST_ENTRY *saved_line_for_history;
+extern Function *rl_last_func;
+
+/* Functions imported from the rest of the library. */
+extern int _rl_free_history_entry ();
+extern char *_rl_make_prompt_for_search ();
+extern void _rl_restore_prompt ();
+extern void rl_extend_line_buffer ();
+
+static char *noninc_search_string = (char *) NULL;
+static int noninc_history_pos;
+static char *prev_line_found = (char *) NULL;
+
+/* Search the history list for STRING starting at absolute history position
+   POS.  If STRING begins with `^', the search must match STRING at the
+   beginning of a history line, otherwise a full substring match is performed
+   for STRING.  DIR < 0 means to search backwards through the history list,
+   DIR >= 0 means to search forward. */
+static int
+noninc_search_from_pos (string, pos, dir)
+     char *string;
+     int pos, dir;
+{
+  int ret, old;
+
+  old = where_history ();
+  history_set_pos (pos);
+
+  if (*string == '^')
+    ret = history_search_prefix (string + 1, dir);
+  else
+    ret = history_search (string, dir);
+
+  if (ret != -1)
+    ret = where_history ();
+
+  history_set_pos (old);
+  return (ret);
+}
+
+/* Search for a line in the history containing STRING.  If DIR is < 0, the
+   search is backwards through previous entries, else through subsequent
+   entries. */
+static void
+noninc_dosearch (string, dir)
+     char *string;
+     int dir;
+{
+  int oldpos, pos, line_len;
+  HIST_ENTRY *entry;
+
+  if (string == 0 || *string == '\0' || noninc_history_pos < 0)
+    {
+      ding ();
+      return;
+    }
+
+  pos = noninc_search_from_pos (string, noninc_history_pos + dir, dir);
+  if (pos == -1)
+    {
+      /* Search failed, current history position unchanged. */
+      maybe_unsave_line ();
+      rl_clear_message ();
+      rl_point = 0;
+      ding ();
+      return;
+    }
+
+  noninc_history_pos = pos;
+
+  oldpos = where_history ();
+  history_set_pos (noninc_history_pos);
+  entry = current_history ();
+#if defined (VI_MODE)
+  if (rl_editing_mode != vi_mode)
+#endif
+  history_set_pos (oldpos);
+
+  line_len = strlen (entry->line);
+  if (line_len >= rl_line_buffer_len)
+    rl_extend_line_buffer (line_len);
+  strcpy (rl_line_buffer, entry->line);
+
+  rl_undo_list = (UNDO_LIST *)entry->data;
+  rl_end = strlen (rl_line_buffer);
+  rl_point = 0;
+  rl_clear_message ();
+
+  if (saved_line_for_history)
+    _rl_free_history_entry (saved_line_for_history);
+  saved_line_for_history = (HIST_ENTRY *)NULL;
+}
+
+/* Search non-interactively through the history list.  DIR < 0 means to
+   search backwards through the history of previous commands; otherwise
+   the search is for commands subsequent to the current position in the
+   history list.  PCHAR is the character to use for prompting when reading
+   the search string; if not specified (0), it defaults to `:'. */
+static void
+noninc_search (dir, pchar)
+     int dir;
+     int pchar;
+{
+  int saved_point, c;
+  char *p;
+
+  maybe_save_line ();
+  saved_point = rl_point;
+
+  /* Use the line buffer to read the search string. */
+  rl_line_buffer[0] = 0;
+  rl_end = rl_point = 0;
+
+  p = _rl_make_prompt_for_search (pchar ? pchar : ':');
+  rl_message (p, 0, 0);
+  free (p);
+
+#define SEARCH_RETURN _rl_restore_prompt (); return
+
+  /* Read the search string. */
+  while (c = rl_read_key ())
+    {
+      switch (c)
+	{
+	case CTRL('H'):
+	case RUBOUT:
+	  if (rl_point == 0)
+	    {
+	      maybe_unsave_line ();
+	      rl_clear_message ();
+	      rl_point = saved_point;
+	      SEARCH_RETURN;
+	    }
+	  rl_rubout (1, c);
+	  break;
+
+	case CTRL('W'):
+	  rl_unix_word_rubout (1, c);
+	  break;
+
+	case CTRL('U'):
+	  rl_unix_line_discard (1, c);
+	  break;
+
+	case RETURN:
+	case NEWLINE:
+	  goto dosearch;
+	  /* NOTREACHED */
+	  break;
+
+	case CTRL('C'):
+	case CTRL('G'):
+	  maybe_unsave_line ();
+	  rl_clear_message ();
+	  rl_point = saved_point;
+	  ding ();
+	  SEARCH_RETURN;
+
+	default:
+	  rl_insert (1, c);
+	  break;
+	}
+      (*rl_redisplay_function) ();
+    }
+
+ dosearch:
+  /* If rl_point == 0, we want to re-use the previous search string and
+     start from the saved history position.  If there's no previous search
+     string, punt. */
+  if (rl_point == 0)
+    {
+      if (!noninc_search_string)
+	{
+	  ding ();
+	  SEARCH_RETURN;
+	}
+    }
+  else
+    {
+      /* We want to start the search from the current history position. */
+      noninc_history_pos = where_history ();
+      if (noninc_search_string)
+	free (noninc_search_string);
+      noninc_search_string = savestring (rl_line_buffer);
+    }
+
+  _rl_restore_prompt ();
+  noninc_dosearch (noninc_search_string, dir);
+}
+
+/* Search forward through the history list for a string.  If the vi-mode
+   code calls this, KEY will be `?'. */
+int
+rl_noninc_forward_search (count, key)
+     int count, key;
+{
+  noninc_search (1, (key == '?') ? '?' : 0);
+  return 0;
+}
+
+/* Reverse search the history list for a string.  If the vi-mode code
+   calls this, KEY will be `/'. */
+int
+rl_noninc_reverse_search (count, key)
+     int count, key;
+{
+  noninc_search (-1, (key == '/') ? '/' : 0);
+  return 0;
+}
+
+/* Search forward through the history list for the last string searched
+   for.  If there is no saved search string, abort. */
+int
+rl_noninc_forward_search_again (count, key)
+     int count, key;
+{
+  if (!noninc_search_string)
+    {
+      ding ();
+      return (-1);
+    }
+  noninc_dosearch (noninc_search_string, 1);
+  return 0;
+}
+
+/* Reverse search in the history list for the last string searched
+   for.  If there is no saved search string, abort. */
+int
+rl_noninc_reverse_search_again (count, key)
+     int count, key;
+{
+  if (!noninc_search_string)
+    {
+      ding ();
+      return (-1);
+    }
+  noninc_dosearch (noninc_search_string, -1);
+  return 0;
+}
+
+static int
+rl_history_search_internal (count, direction)
+     int count, direction;
+{
+  HIST_ENTRY *temp, *old_temp;
+  int line_len;
+
+  maybe_save_line ();
+
+  temp = old_temp = (HIST_ENTRY *)NULL;
+  while (count)
+    {
+      temp = (direction < 0) ? previous_history () : next_history ();
+      if (temp == 0)
+        break;
+      /* On an empty prefix, make this the same as previous-history. */
+      if (rl_point == 0)
+	{
+	  count--;
+	  continue;
+	}
+      if (STREQN (rl_line_buffer, temp->line, rl_point))
+	{
+	  /* Don't find multiple instances of the same line. */
+	  if (prev_line_found && STREQ (prev_line_found, temp->line))
+	    continue;
+          if (direction < 0)
+            old_temp = temp;
+          prev_line_found = temp->line;
+          count--;
+	}
+    }
+
+  if (temp == 0)
+    {
+      if (direction < 0 && old_temp)
+	temp = old_temp;
+      else
+	{
+	  maybe_unsave_line ();
+	  ding ();
+	  return 1;
+	}
+    }
+
+  line_len = strlen (temp->line);
+  if (line_len >= rl_line_buffer_len)
+    rl_extend_line_buffer (line_len);
+  strcpy (rl_line_buffer, temp->line);
+  rl_undo_list = (UNDO_LIST *)temp->data;
+  rl_end = line_len;
+  return 0;
+}
+
+/* Search forward in the history for the string of characters
+   from the start of the line to rl_point.  This is a non-incremental
+   search. */
+int
+rl_history_search_forward (count, ignore)
+     int count, ignore;
+{
+  if (count == 0)
+    return (0);
+  if (rl_last_func != rl_history_search_forward)
+    prev_line_found = (char *)NULL;
+  return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));
+}
+
+/* Search backward through the history for the string of characters
+   from the start of the line to rl_point.  This is a non-incremental
+   search. */
+int
+rl_history_search_backward (count, ignore)
+     int count, ignore;
+{
+  if (count == 0)
+    return (0);
+  if (rl_last_func != rl_history_search_backward)
+    prev_line_found = (char *)NULL;
+  return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));
+}
diff --git a/readline/shell.c b/readline/shell.c
new file mode 100644
--- /dev/null
+++ b/readline/shell.c
@@ -0,0 +1,129 @@
+/* shell.c -- readline utility functions that are normally provided by
+	      bash when readline is linked as part of the shell. */
+
+/* Copyright (C) 1997 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+extern char *xmalloc (), *xrealloc ();
+
+#if !defined (SHELL)
+
+#ifdef savestring
+#undef savestring
+#endif
+
+/* Backwards compatibility, now that savestring has been removed from
+   all `public' readline header files. */
+char *
+savestring (s)
+     char *s;
+{
+  return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
+}
+
+/* Does shell-like quoting using single quotes. */
+char *
+single_quote (string)
+     char *string;
+{
+  register int c;
+  char *result, *r, *s;
+
+  result = (char *)xmalloc (3 + (3 * strlen (string)));
+  r = result;
+  *r++ = '\'';
+
+  for (s = string; s && (c = *s); s++)
+    {
+      *r++ = c;
+
+      if (c == '\'')
+	{
+	  *r++ = '\\';	/* insert escaped single quote */
+	  *r++ = '\'';
+	  *r++ = '\'';	/* start new quoted string */
+	}
+    }
+
+  *r++ = '\'';
+  *r = '\0';
+
+  return (result);
+}
+
+/* Set the environment variables LINES and COLUMNS to lines and cols,
+   respectively. */
+void
+set_lines_and_columns (lines, cols)
+     int lines, cols;
+{
+  char *b;
+
+#if defined (HAVE_PUTENV)
+  b = xmalloc (24);
+  sprintf (b, "LINES=%d", lines);
+  putenv (b);
+  b = xmalloc (24);
+  sprintf (b, "COLUMNS=%d", cols);
+  putenv (b);
+#else /* !HAVE_PUTENV */
+#  if defined (HAVE_SETENV)
+  b = xmalloc (8);
+  sprintf (b, "%d", lines);
+  setenv ("LINES", b, 1);
+  b = xmalloc (8);
+  sprintf (b, "%d", cols);
+  setenv ("COLUMNS", b, 1);
+#  endif /* HAVE_SETENV */
+#endif /* !HAVE_PUTENV */
+}
+
+char *
+get_env_value (varname)
+     char *varname;
+{
+  return ((char *)getenv (varname));
+}
+
+#else /* SHELL */
+extern char *get_string_value ();
+
+char *
+get_env_value (varname)
+     char *varname;
+{
+  return get_string_value (varname);
+}	
+#endif /* SHELL */
diff --git a/readline/signals.c b/readline/signals.c
new file mode 100644
--- /dev/null
+++ b/readline/signals.c
@@ -0,0 +1,363 @@
+/* signals.c -- signal handling support for readline. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <stdio.h>		/* Just for NULL.  Yuck. */
+#include <sys/types.h>
+#include <signal.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+#if defined (GWINSZ_IN_SYS_IOCTL)
+#  include <sys/ioctl.h>
+#endif /* GWINSZ_IN_SYS_IOCTL */
+
+#if defined (__GO32__)
+#  undef HANDLE_SIGNALS
+#endif /* __GO32__ */
+
+#if defined (HANDLE_SIGNALS)
+/* Some standard library routines. */
+#include "readline.h"
+#include "history.h"
+
+extern int readline_echoing_p;
+extern int rl_pending_input;
+extern int _rl_meta_flag;
+
+extern void free_undo_list ();
+extern void _rl_get_screen_size ();
+extern void _rl_redisplay_after_sigwinch ();
+extern void _rl_clean_up_for_exit ();
+extern void _rl_kill_kbd_macro ();
+extern void _rl_init_argument ();
+extern void rl_deprep_terminal (), rl_prep_terminal ();
+
+#if !defined (RETSIGTYPE)
+#  if defined (VOID_SIGHANDLER)
+#    define RETSIGTYPE void
+#  else
+#    define RETSIGTYPE int
+#  endif /* !VOID_SIGHANDLER */
+#endif /* !RETSIGTYPE */
+
+#if defined (VOID_SIGHANDLER)
+#  define SIGHANDLER_RETURN return
+#else
+#  define SIGHANDLER_RETURN return (0)
+#endif
+
+/* This typedef is equivalant to the one for Function; it allows us
+   to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
+typedef RETSIGTYPE SigHandler ();
+
+static SigHandler *rl_set_sighandler ();
+
+/* **************************************************************** */
+/*					        		    */
+/*			   Signal Handling                          */
+/*								    */
+/* **************************************************************** */
+
+/* If we're not being compiled as part of bash, initialize handlers for
+   and catch the job control signals (SIGTTIN, SIGTTOU, SIGTSTP) and
+   SIGTERM. */
+#if !defined (SHELL)
+#  define HANDLE_JOB_SIGNALS
+#  define HANDLE_SIGTERM
+#endif /* !SHELL */
+
+#if defined (HAVE_POSIX_SIGNALS)
+typedef struct sigaction sighandler_cxt;
+#  define rl_sigaction(s, nh, oh)	sigaction(s, nh, oh)
+#else
+typedef struct { SigHandler *sa_handler; } sighandler_cxt;
+#  define sigemptyset(m)
+#endif /* !HAVE_POSIX_SIGNALS */
+
+static sighandler_cxt old_int, old_alrm;
+
+#if defined (HANDLE_JOB_SIGNALS)
+static sighandler_cxt old_tstp, old_ttou, old_ttin;
+#endif /* HANDLE_JOB_SIGNALS */
+
+#if defined (HANDLE_SIGTERM)
+static sighandler_cxt old_term;
+#endif
+
+#if defined (SIGWINCH)
+static sighandler_cxt old_winch;
+#endif
+
+/* Readline signal handler functions. */
+
+static RETSIGTYPE
+rl_signal_handler (sig)
+     int sig;
+{
+#if defined (HAVE_POSIX_SIGNALS)
+  sigset_t set;
+#else /* !HAVE_POSIX_SIGNALS */
+#  if defined (HAVE_BSD_SIGNALS)
+  long omask;
+#  else /* !HAVE_BSD_SIGNALS */
+  sighandler_cxt dummy_cxt;	/* needed for rl_set_sighandler call */
+#  endif /* !HAVE_BSD_SIGNALS */
+#endif /* !HAVE_POSIX_SIGNALS */
+
+#if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)
+  /* Since the signal will not be blocked while we are in the signal
+     handler, ignore it until rl_clear_signals resets the catcher. */
+  if (sig == SIGINT || sig == SIGALRM)
+    rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);
+#endif /* !HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS */
+
+  switch (sig)
+    {
+    case SIGINT:
+      {
+	register HIST_ENTRY *entry;
+
+	free_undo_list ();
+
+	entry = current_history ();
+	if (entry)
+	  entry->data = (char *)NULL;
+      }
+      _rl_kill_kbd_macro ();
+      rl_clear_message ();
+      _rl_init_argument ();
+
+#if defined (SIGTSTP)
+    case SIGTSTP:
+    case SIGTTOU:
+    case SIGTTIN:
+#endif /* SIGTSTP */
+    case SIGALRM:
+    case SIGTERM:
+      _rl_clean_up_for_exit ();
+      (*rl_deprep_term_function) ();
+      rl_clear_signals ();
+      rl_pending_input = 0;
+
+#if defined (HAVE_POSIX_SIGNALS)
+      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);
+      sigdelset (&set, sig);
+#else /* !HAVE_POSIX_SIGNALS */
+#  if defined (HAVE_BSD_SIGNALS)
+      omask = sigblock (0);
+#  endif /* HAVE_BSD_SIGNALS */
+#endif /* !HAVE_POSIX_SIGNALS */
+
+      kill (getpid (), sig);
+
+      /* Let the signal that we just sent through.  */
+#if defined (HAVE_POSIX_SIGNALS)
+      sigprocmask (SIG_SETMASK, &set, (sigset_t *)NULL);
+#else /* !HAVE_POSIX_SIGNALS */
+#  if defined (HAVE_BSD_SIGNALS)
+      sigsetmask (omask & ~(sigmask (sig)));
+#  endif /* HAVE_BSD_SIGNALS */
+#endif /* !HAVE_POSIX_SIGNALS */
+
+      (*rl_prep_term_function) (_rl_meta_flag);
+      rl_set_signals ();
+    }
+
+  SIGHANDLER_RETURN;
+}
+
+#if defined (SIGWINCH)
+static RETSIGTYPE
+rl_handle_sigwinch (sig)
+     int sig;
+{
+  SigHandler *oh;
+
+#if defined (MUST_REINSTALL_SIGHANDLERS)
+  sighandler_cxt dummy_winch;
+
+  /* We don't want to change old_winch -- it holds the state of SIGWINCH
+     disposition set by the calling application.  We need this state
+     because we call the application's SIGWINCH handler after updating
+     our own idea of the screen size. */
+  rl_set_sighandler (SIGWINCH, rl_handle_sigwinch, &dummy_winch);
+#endif
+
+  if (readline_echoing_p)
+    {
+      _rl_get_screen_size (fileno (rl_instream), 1);
+      _rl_redisplay_after_sigwinch ();
+    }
+
+  /* If another sigwinch handler has been installed, call it. */
+  oh = (SigHandler *)old_winch.sa_handler;
+  if (oh &&  oh != (SigHandler *)SIG_IGN && oh != (SigHandler *)SIG_DFL)
+    (*oh) (sig);
+
+  SIGHANDLER_RETURN;
+}
+#endif  /* SIGWINCH */
+
+/* Functions to manage signal handling. */
+
+#if !defined (HAVE_POSIX_SIGNALS)
+static int
+rl_sigaction (sig, nh, oh)
+     int sig;
+     sighandler_cxt *nh, *oh;
+{
+  oh->sa_handler = signal (sig, nh->sa_handler);
+  return 0;
+}
+#endif /* !HAVE_POSIX_SIGNALS */
+
+/* Set up a readline-specific signal handler, saving the old signal
+   information in OHANDLER.  Return the old signal handler, like
+   signal(). */
+static SigHandler *
+rl_set_sighandler (sig, handler, ohandler)
+     int sig;
+     SigHandler *handler;
+     sighandler_cxt *ohandler;
+{
+#if defined (HAVE_POSIX_SIGNALS)
+  struct sigaction act;
+
+  act.sa_handler = handler;
+  act.sa_flags = 0;
+  sigemptyset (&act.sa_mask);
+  sigemptyset (&ohandler->sa_mask);
+  sigaction (sig, &act, ohandler);
+#else
+  ohandler->sa_handler = (SigHandler *)signal (sig, handler);
+#endif /* !HAVE_POSIX_SIGNALS */
+  return (ohandler->sa_handler);
+}
+
+int
+rl_set_signals ()
+{
+  sighandler_cxt dummy;
+  SigHandler *oh;
+
+#if defined (HAVE_POSIX_SIGNALS)
+  sigemptyset (&dummy.sa_mask);
+#endif
+
+  oh = rl_set_sighandler (SIGINT, rl_signal_handler, &old_int);
+  if (oh == (SigHandler *)SIG_IGN)
+    rl_sigaction (SIGINT, &old_int, &dummy);
+
+  oh = rl_set_sighandler (SIGALRM, rl_signal_handler, &old_alrm);
+  if (oh == (SigHandler *)SIG_IGN)
+    rl_sigaction (SIGALRM, &old_alrm, &dummy);
+#if defined (HAVE_POSIX_SIGNALS) && defined (SA_RESTART)
+  /* If the application using readline has already installed a signal
+     handler with SA_RESTART, SIGALRM will cause reads to be restarted
+     automatically, so readline should just get out of the way.  Since
+     we tested for SIG_IGN above, we can just test for SIG_DFL here. */
+  if (oh != (SigHandler *)SIG_DFL && (old_alrm.sa_flags & SA_RESTART))
+    rl_sigaction (SIGALRM, &old_alrm, &dummy);
+#endif /* HAVE_POSIX_SIGNALS */
+
+#if defined (HANDLE_JOB_SIGNALS)
+
+#if defined (SIGTSTP)
+  oh = rl_set_sighandler (SIGTSTP, rl_signal_handler, &old_tstp);
+  if (oh == (SigHandler *)SIG_IGN)
+    rl_sigaction (SIGTSTP, &old_tstp, &dummy);
+#else
+  oh = (SigHandler *)NULL;
+#endif /* SIGTSTP */
+
+#if defined (SIGTTOU)
+  rl_set_sighandler (SIGTTOU, rl_signal_handler, &old_ttou);
+  rl_set_sighandler (SIGTTIN, rl_signal_handler, &old_ttin);
+
+  if (oh == (SigHandler *)SIG_IGN)
+    {
+      rl_set_sighandler (SIGTTOU, SIG_IGN, &dummy);
+      rl_set_sighandler (SIGTTIN, SIG_IGN, &dummy);
+    }
+#endif /* SIGTTOU */
+
+#endif /* HANDLE_JOB_SIGNALS */
+
+#if defined (HANDLE_SIGTERM)
+  /* Handle SIGTERM if we're not being compiled as part of bash. */
+  rl_set_sighandler (SIGTERM, rl_signal_handler, &old_term);
+#endif /* HANDLE_SIGTERM */
+
+#if defined (SIGWINCH)
+  rl_set_sighandler (SIGWINCH, rl_handle_sigwinch, &old_winch);
+#endif /* SIGWINCH */
+
+  return 0;
+}
+
+int
+rl_clear_signals ()
+{
+  sighandler_cxt dummy;
+
+#if defined (HAVE_POSIX_SIGNALS)
+  sigemptyset (&dummy.sa_mask);
+#endif
+
+  rl_sigaction (SIGINT, &old_int, &dummy);
+  rl_sigaction (SIGALRM, &old_alrm, &dummy);
+
+#if defined (HANDLE_JOB_SIGNALS)
+
+#if defined (SIGTSTP)
+  rl_sigaction (SIGTSTP, &old_tstp, &dummy);
+#endif
+
+#if defined (SIGTTOU)
+  rl_sigaction (SIGTTOU, &old_ttou, &dummy);
+  rl_sigaction (SIGTTIN, &old_ttin, &dummy);
+#endif /* SIGTTOU */
+
+#endif /* HANDLE_JOB_SIGNALS */
+
+#if defined (HANDLE_SIGTERM)
+  rl_sigaction (SIGTERM, &old_term, &dummy);
+#endif /* HANDLE_SIGTERM */
+
+#if defined (SIGWINCH)
+  sigemptyset (&dummy.sa_mask);
+  rl_sigaction (SIGWINCH, &old_winch, &dummy);
+#endif
+
+  return 0;
+}
+#endif  /* HANDLE_SIGNALS */
diff --git a/readline/support/config.guess b/readline/support/config.guess
new file mode 100755
--- /dev/null
+++ b/readline/support/config.guess
@@ -0,0 +1,927 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
+#
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Written by Per Bothner <bothner@cygnus.com>.
+# The master version of this file is at the FSF in /home/gd/gnu/lib.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# The plan is that this can be called by configure scripts if you
+# don't specify an explicit system type (host/target name).
+#
+# Only a few systems have been added to this list; please add others
+# (but try to keep the structure clean).
+#
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 8/24/94.)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+elif (test -f /usr/5bin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/usr/5bin
+fi
+
+UNAME=`(uname) 2>/dev/null` || UNAME=unknown
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+RELEASE=`expr "$UNAME_RELEASE" : '[^0-9]*\([0-9]*\)'` # 4
+case "$RELEASE" in
+"")	RELEASE=0 ;;
+*)	RELEASE=`expr "$RELEASE" + 0` ;;
+esac
+REL_LEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.\([0-9]*\)'`    # 1
+REL_SUBLEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.[0-9]*.\([0-9]*\)'` # 2
+
+trap 'rm -f dummy.c dummy.o dummy; exit 1' 1 2 15
+
+# Some versions of i386 SVR4.2 make `uname' equivalent to `uname -n', which
+# is contrary to all other versions of uname
+if [ -n "$UNAME" ] && [ "$UNAME_S" != "$UNAME" ] && [ "$UNAME_S" = UNIX_SV ]; then
+	UNAME=UNIX_SV
+fi
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    # Begin cases added for Bash
+    alpha:NetBSD:*:*)
+	echo alpha-dec-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    alpha:OpenBSD:*:*)
+	echo alpha-dec-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:NetBSD:*:*)
+	echo ${UNAME_MACHINE}-pc-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    i?86:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-pc-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    i?86:FreeBSD:*:*)
+	echo ${UNAME_MACHINE}-pc-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit 0 ;;
+    sparc:NetBSD:*:*)
+	echo sparc-unknown-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sparc:OpenBSD:*:*)
+	echo sparc-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    vax:NetBSD:*:*)
+	echo vax-dec-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    vax:OpenBSD:*:*)
+	echo vax-dec-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:machten:*:*)
+	echo mac68k-apple-machten${UNAME_RELEASE}
+	exit 0 ;;
+    concurrent*:*:*:*)
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo concurrent-concurrent-sysv3
+	else
+		echo concurrent-concurrent-bsd
+	fi
+	exit 0 ;;
+    ppc*:SunOS:5.*:*)
+	echo ppc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sparc:UNIX_SV:4.*:*)
+	echo sparc-unknown-sysv${UNAME_RELEASE}
+	exit 0 ;;
+    mips:UNIX_SV:4.*:*)
+	echo mips-mips-sysv${UNAME_RELEASE}
+	exit 0 ;;
+    mips:OSF*1:*:*)
+	echo mips-mips-osf1
+	exit 0 ;;
+    mips:4.4BSD:*:*)
+	echo mips-mips-bsd4.4
+	exit 0 ;;
+    MIServer-S:SMP_DC.OSx:*:dcosx)
+	echo mips-pyramid-sysv4
+	exit 0 ;;
+    news*:NEWS*:*:*)
+	echo mips-sony-newsos${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:NEXTSTEP:*:*)
+	echo i386-next-nextstep${RELEASE}
+	exit 0 ;;
+    *680?0:NEXTSTEP:*:*)
+	echo m68k-next-nextstep${RELEASE}
+	exit 0 ;;    
+    *370:AIX:*:*)
+	echo ibm370-ibm-aix
+	exit 0 ;;
+    ksr1:OSF*1:*:*)
+	echo ksr1-ksr-osf1
+	exit 0 ;;
+    esa:OSF*1:*:* | ESA:OSF*:*:*)
+	echo esa-ibm-osf1
+	exit 0 ;;
+    DNP*:DNIX:*:*)
+	echo m68k-dnix-sysv
+	exit 0 ;;
+    *3b2*:*:*:*)
+	echo we32k-att-sysv3
+	exit 0 ;;
+    *:QNX:*:42*)
+	echo i386-qssl-qnx`echo ${UNAME_VERSION}`
+	exit 0 ;;
+    # end cases added for Bash
+    alpha:OSF1:*:*)
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	echo alpha-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//'`
+	exit 0 ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit 0 ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-cbm-sysv4
+	exit 0;;
+    amiga:NetBSD:*:*)
+	echo m68k-cbm-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    amiga:OpenBSD:*:*)
+	echo m68k-cbm-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit 0;;
+    Pyramid*:OSx*:*:*|MIS*:OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit 0 ;;
+    NILE:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit 0 ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    i86pc:SunOS:5.*:*)
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit 0 ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:NetBSD:*:*)
+	echo m68k-atari-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:OpenBSD:*:*)
+	echo m68k-atari-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3*:NetBSD:*:*)
+	echo m68k-sun-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3*:OpenBSD:*:*)
+	echo m68k-sun-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:NetBSD:*:*)
+	echo m68k-apple-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:OpenBSD:*:*)
+	echo m68k-apple-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit 0 ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit 0 ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	sed 's/^	//' << EOF >dummy.c
+	int main (argc, argv) int argc; char **argv; {
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	${CC-cc} dummy.c -o dummy \
+	  && ./dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
+	  && rm dummy.c dummy && exit 0
+	rm -f dummy.c dummy
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit 0 ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerux
+	exit 0 ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit 0 ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit 0 ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    AViiON:dgux:*:*)
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88110 ] ; then
+	if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
+	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	fi
+	else echo i586-dg-dgux${UNAME_RELEASE}
+	fi
+ 	exit 0 ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit 0 ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit 0 ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit 0 ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit 0 ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
+	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+    i?86:AIX:*:*)
+	echo i386-ibm-aix
+	exit 0 ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		sed 's/^		//' << EOF >dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		${CC-cc} dummy.c -o dummy && ./dummy && rm dummy.c dummy && exit 0
+		rm -f dummy.c dummy
+		echo rs6000-ibm-aix3.2.5
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit 0 ;;
+    *:AIX:*:4)
+	if /usr/sbin/lsattr -EHl proc0 | grep POWER >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	elif grep bos410 /usr/include/stdio.h >/dev/null 2>&1; then
+		IBM_REV=4.1
+	elif grep bos411 /usr/include/stdio.h >/dev/null 2>&1; then
+		IBM_REV=4.1.1
+	else
+		IBM_REV=4.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit 0 ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit 0 ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit 0 ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit 0 ;;                           # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit 0 ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit 0 ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit 0 ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit 0 ;;
+    9000/[3478]??:HP-UX:*:*)
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/7?? | 9000/8?[1679] ) HP_ARCH=hppa1.1 ;;
+	    9000/8?? )            HP_ARCH=hppa1.0 ;;
+	esac
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit 0 ;;
+    3050*:HI-UX:*:*)
+	sed 's/^	//' << EOF >dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	${CC-cc} dummy.c -o dummy && ./dummy && rm dummy.c dummy && exit 0
+	rm -f dummy.c dummy
+	echo unknown-hitachi-hiuxwe2
+	exit 0 ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit 0 ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit 0 ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit 0 ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit 0 ;;
+    i?86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-pc-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-pc-osf1
+	fi
+	exit 0 ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit 0 ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit 0 ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit 0 ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit 0 ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit 0 ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit 0 ;;
+    CRAY*X-MP:*:*:*)
+	echo xmp-cray-unicos
+        exit 0 ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE}
+	exit 0 ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
+	exit 0 ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE}
+	exit 0 ;;
+    CRAY-2:*:*:*)
+	echo cray2-cray-unicos
+        exit 0 ;;
+    F300:UNIX_System_V:*:*)
+	FUJITSU_SYS=`uname -p | tr [A-Z] [a-z] | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+	echo "f300-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit 0 ;;
+    F301:UNIX_System_V:*:*)
+	echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
+	exit 0 ;;
+    hp3[0-9][05]:NetBSD:*:*)
+	echo m68k-hp-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    hp3[0-9][05]:OpenBSD:*:*)
+	echo m68k-hp-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:BSD/386:*:* | *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    *:FreeBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit 0 ;;
+    *:NetBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    *:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    i*:CYGWIN*:*)
+	echo i386-pc-cygwin32
+	exit 0 ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin32
+	exit 0 ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    *:GNU:*:*)
+	echo `echo ${UNAME_MACHINE}|sed -e 's,/.*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit 0 ;;
+    *:Linux:*:*)
+	# The BFD linker knows what the default object file format is, so
+	# first see if it will tell us.
+	ld_help_string=`ld --help 2>&1`
+	if echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf_i.86"; then
+	  echo "${UNAME_MACHINE}-pc-linux-gnu" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i.86linux"; then
+	  echo "${UNAME_MACHINE}-pc-linux-gnuaout" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i.86coff"; then
+	  echo "${UNAME_MACHINE}-pc-linux-gnucoff" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68kelf"; then
+	  echo "${UNAME_MACHINE}-unknown-linux-gnu" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68klinux"; then
+	  echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0
+	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf32ppc"; then
+	  echo "powerpc-unknown-linux-gnu" ; exit 0
+	elif test "${UNAME_MACHINE}" = "alpha" ; then
+	  echo alpha-unknown-linux-gnu ; exit 0
+	elif test "${UNAME_MACHINE}" = "sparc" ; then
+	  echo sparc-unknown-linux-gnu ; exit 0
+	else
+	  # Either a pre-BFD a.out linker (linux-gnuoldld) or one that does not give us
+	  # useful --help.  Gcc wants to distinguish between linux-gnuoldld and linux-gnuaout.
+	  test ! -d /usr/lib/ldscripts/. \
+	    && echo "${UNAME_MACHINE}-pc-linux-gnuoldld" && exit 0
+	  # Determine whether the default compiler is a.out or elf
+	  cat >dummy.c <<EOF
+main(argc, argv)
+int argc;
+char *argv[];
+{
+#ifdef __ELF__
+  printf ("%s-pc-linux-gnu\n", argv[1]);
+#else
+  printf ("%s-pc-linux-gnuaout\n", argv[1]);
+#endif
+  return 0;
+}
+EOF
+	  ${CC-cc} dummy.c -o dummy 2>/dev/null && ./dummy "${UNAME_MACHINE}" && rm dummy.c dummy && exit 0
+	  rm -f dummy.c dummy
+	fi ;;
+# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
+# are messed up and put the nodename in both sysname and nodename.
+    i?86:DYNIX/ptx:4*:*)
+	echo i386-sequent-sysv4
+	exit 0 ;;
+    i?86:*:4.*:* | i?86:SYSTEM_V:4.*:* | i[34]86:UNIX_SV:4.*:*)
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
+	fi
+	exit 0 ;;
+    i?86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit 0 ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit 0 ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit 0 ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit 0 ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit 0 ;;
+    M68*:*:R3V[567]*:*)
+	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
+    3[34]??:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && echo i486-ncr-sysv4 && exit 0 ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit 0 ;;
+    m68*:LynxOS:2.*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:LynxOS:2.*:*)
+	echo i386-pc-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    *:LynxOS:*:*)
+	echo ${UNAME_MACHINE}-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit 0 ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit 0 ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit 0 ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit 0 ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit 0 ;;              
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit 0 ;;
+    R3000:*System_V*:*:* | R4000:UNIX_SYSV:*:*)
+	if [ -d /usr/nec ]; then
+		echo mips-nec-sysv${UNAME_RELEASE}
+	else
+		echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+	exit 0 ;;
+    PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                           # says <Richard.M.Bartel@ccMail.Census.GOV>
+	echo i586-unisys-sysv4 
+	exit 0 ;;              
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1>&2
+#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+
+cat >dummy.c <<EOF
+#ifdef _SEQUENT_
+# include <sys/types.h>
+# include <sys/utsname.h>
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+          "4"
+#else
+	  ""
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) && defined (__acorn) && defined (__unix)
+  printf ("arm-acorn-riscix\n"); exit (0);
+#endif
+
+#if defined (hp9000) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (hp300) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  printf ("%s-next-nextstep%d\n", __ARCHITECTURE__,  version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&un);
+
+    if (strncmp(un.version, "V2", 2) == 0) {
+	printf ("i386-sequent-ptx2\n"); exit (0);
+    }
+    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+	printf ("i386-sequent-ptx1\n"); exit (0);
+    }
+    printf ("i386-sequent-ptx\n"); exit (0);
+
+#endif
+
+#if defined (vax)
+#if !defined (ultrix)
+  printf ("vax-dec-bsd\n"); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+/* Begin cases added for Bash */
+#if defined (tahoe)
+  printf ("tahoe-cci-bsd\n"); exit (0);
+#endif
+
+#if defined (nec_ews)
+#  if defined (SYSTYPE_SYSV)
+  printf ("ews4800-nec-sysv4\n"); exit 0;
+#  else
+  printf ("ews4800-nec-bsd\n"); exit (0);
+#  endif
+#endif
+
+#if defined (sony)
+#  if defined (SYSTYPE_SYSV)
+  printf ("mips-sony-sysv4\n"); exit 0;
+#  else
+  printf ("mips-sony-bsd\n"); exit (0);
+#  endif
+#endif
+
+#if defined (ardent)
+  printf ("titan-ardent-bsd\n"); exit (0);
+#endif
+
+#if defined (stardent)
+  printf ("stardent-stardent-sysv\n"); exit (0);
+#endif
+
+#if defined (ibm032)
+  printf ("ibmrt-ibm-bsd4.3\n"); exit (0);
+#endif
+
+#if defined (sequent) && defined (i386)
+  printf ("i386-sequent-bsd\n"); exit (0);
+#endif
+
+#if defined (qnx) && defined (i386)
+  printf ("i386-pc-qnx\n"); exit (0);
+#endif
+
+#if defined (gould)
+  printf ("gould-gould-bsd\n"); exit (0);
+#endif
+
+#if defined (unixpc)
+  printf ("unixpc-att-sysv\n"); exit (0);
+#endif
+
+#if defined (att386)
+  printf ("i386-att-sysv3\n"); exit (0);
+#endif
+
+#if defined (__m88k) && defined (__UMAXV__)
+  printf ("m88k-encore-sysv3\n"); exit (0);
+#endif
+
+#if defined (drs6000)
+  printf ("drs6000-icl-sysv4.2\n"); exit (0);
+#endif
+
+#if defined (clipper)
+  printf ("clipper-orion-bsd\n"); exit (0);
+#endif
+
+#if defined (is68k)
+  printf ("m68k-isi-bsd\n"); exit (0);
+#endif
+
+#if defined (luna88k)
+  printf ("luna88k-omron-bsd\n"); exit (0);
+#endif
+
+#if defined (butterfly) && defined (BFLY1)
+  printf ("butterfly-bbn-mach\n"); exit (0);
+#endif
+
+#if defined (tower32)
+  printf ("tower32-ncr-sysv4\n"); exit (0);
+#endif
+
+#if defined (MagicStation)
+  printf ("magicstation-unknown-bsd\n"); exit (0);
+#endif
+
+#if defined (scs)
+  printf ("symmetric-scs-bsd4.2\n"); exit (0);
+#endif
+
+#if defined (tandem)
+  printf ("tandem-tandem-sysv\n"); exit (0);
+#endif
+
+#if defined (cadmus)
+  printf ("cadmus-pcs-sysv\n"); exit (0);
+#endif
+
+#if defined (masscomp)
+  printf ("masscomp-masscomp-sysv3\n"); exit (0);
+#endif
+
+#if defined (hbullx20)
+  printf ("hbullx20-bull-sysv3\n"); exit (0);
+#endif
+
+/* End cases added for Bash */
+
+  exit (1);
+}
+EOF
+
+${CC-cc} dummy.c -o dummy 2>/dev/null && ./dummy && rm dummy.c dummy && exit 0
+rm -f dummy.c dummy
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit 0 ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit 0 ;;
+    c34*)
+	echo c34-convex-bsd
+	exit 0 ;;
+    c38*)
+	echo c38-convex-bsd
+	exit 0 ;;
+    c4*)
+	echo c4-convex-bsd
+	exit 0 ;;
+    esac
+fi
+
+# Begin cases added for Bash
+case "$UNAME" in
+uts) echo uts-amdahl-sysv${UNAME_RELEASE}; exit 0 ;;
+esac
+
+if [ -d /usr/amiga ]; then
+	echo m68k-cbm-sysv${UNAME_RELEASE}; exit 0;
+fi
+
+if [ -f /bin/fxc.info ]; then
+	echo fxc-alliant-concentrix
+	exit 0
+fi
+# end cases added for Bash
+
+#echo '(Unable to guess system type)' 1>&2
+
+exit 1
diff --git a/readline/support/config.sub b/readline/support/config.sub
new file mode 100755
--- /dev/null
+++ b/readline/support/config.sub
@@ -0,0 +1,944 @@
+#! /bin/sh
+# Configuration validation subroutine script, version 1.1.
+#   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+if [ x$1 = x ]
+then
+	echo Configuration name missing. 1>&2
+	echo "Usage: $0 CPU-MFR-OPSYS" 1>&2
+	echo "or     $0 ALIAS" 1>&2
+	echo where ALIAS is a recognized configuration type. 1>&2
+	exit 1
+fi
+
+# First pass through any local machine types.
+case $1 in
+	*local*)
+		echo $1
+		exit 0
+		;;
+	*)
+	;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  linux-gnu*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple)
+		os=
+		basic_machine=$1
+		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco5)
+		os=sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	tahoe | i860 | m68k | m68000 | m88k | ns32k | arm \
+		| arme[lb] | pyramid \
+		| tron | a29k | 580 | i960 | h8300 | hppa | hppa1.0 | hppa1.1 \
+		| alpha | we32k | ns16k | clipper | i370 | sh \
+		| powerpc | powerpcle | 1750a | dsp16xx | mips64 | mipsel \
+		| pdp11 | mips64el | mips64orion | mips64orionel \
+		| sparc | sparclet | sparclite | sparc64)
+		basic_machine=$basic_machine-unknown
+		;;
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i[3456]86)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	vax-* | tahoe-* | i[3456]86-* | i860-* | m68k-* | m68000-* | m88k-* \
+	      | sparc-* | ns32k-* | fx80-* | arm-* | c[123]* \
+	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* | power-* \
+	      | none-* | 580-* | cray2-* | h8300-* | i960-* | xmp-* | ymp-* \
+	      | hppa-* | hppa1.0-* | hppa1.1-* | alpha-* | we32k-* | cydra-* | ns16k-* \
+	      | pn-* | np1-* | xps100-* | clipper-* | orion-* | sparclite-* \
+	      | pdp11-* | sh-* | powerpc-* | powerpcle-* | sparc64-* | mips64-* | mipsel-* \
+	      | mips64el-* | mips64orion-* | mips64orionel-* | f301-* \
+	      | butterfly-bbn* \
+	      | cadmus-* | ews*-nec | ibmrt-ibm* | masscomp-masscomp \
+	      | tandem-* | symmetric-* | drs6000-icl | *-*ardent | gould-gould \
+	      | concurrent-* | ksr1-* | esa-ibm | fxc-alliant | *370-amdahl \
+	      | *-convex)
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-cbm
+		;;
+	amigados)
+		basic_machine=m68k-cbm
+		os=-amigados
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-cbm
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	cray2)
+		basic_machine=cray2-cray
+		os=-unicos
+		;;
+	[ctj]90-cray)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	hbullx20-bull)
+		basic_machine=m68k-bull
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax | multimax)
+		basic_machine=ns32k-encore
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k7[0-9][0-9] | hp7[0-9][0-9] | hp9k8[0-9]7 | hp8[0-9]7)
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	ibm032-*)
+		basic_machine=ibmrt-ibm
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
+	i[3456]86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i[3456]86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i[3456]86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i[3456]86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	luna88k-omron* | m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magicstation*)
+		basic_machine=magicstation-unknown
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+        pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pentium | p5)
+		basic_machine=i586-intel
+		;;
+	pentiumpro | p6)
+		basic_machine=i686-intel
+		;;
+	pentium-* | p5-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	k5)
+		# We don't have specific support for AMD's K5 yet, so just call it a Pentium
+		basic_machine=i586-amd
+		;;
+	nexen)
+		# We don't have specific support for Nexgen yet, so just call it a Pentium
+		basic_machine=i586-nexgen
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=rs6000-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+	        ;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+	        ;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
+		;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	xmp)
+		basic_machine=xmp-cray
+		os=-unicos
+		;;
+        xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	mips)
+		basic_machine=mips-mips
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sparc)
+		basic_machine=sparc-sun
+		;;
+        cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+	# First match some system type aliases
+	# that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-unixware* | svr4*)
+		os=-sysv4
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -amigados* | -msdos* | -newsos* | -unicos* | -aof* | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
+	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -cygwin32* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -linux-gnu* | -uxpv* | -qnx* | -powerux)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-ns2 )
+	        os=-nextstep2
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+        pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-ibm)
+		os=-aix
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigados
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+        *-gould)
+		os=-sysv
+		;;
+        *-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+        *-sgi)
+		os=-irix
+		;;
+        *-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f301-fujitsu)
+		os=-uxpv
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-lynxos*)
+				vendor=lynx
+				;;
+			-aix*)
+				vendor=ibm
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-vxsim* | -vxworks*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
diff --git a/readline/support/install.sh b/readline/support/install.sh
new file mode 100755
--- /dev/null
+++ b/readline/support/install.sh
@@ -0,0 +1,235 @@
+#!/bin/sh
+#
+# install - install a program, script, or datafile
+# This comes from X11R5.
+#
+# $XConsortium: install.sh,v 1.2 89/12/18 14:47:22 jim Exp $
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+#
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit="${DOITPROG-}"
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+mkdirprog="${MKDIRPROG-mkdir}"
+
+tranformbasename=""
+transform_arg=""
+instcmd="$mvprog"
+chmodcmd="$chmodprog 0755"
+chowncmd=""
+chgrpcmd=""
+stripcmd=""
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+src=""
+dst=""
+dir_arg=""
+
+while [ x"$1" != x ]; do
+    case $1 in
+	-c) instcmd="$cpprog"
+	    shift
+	    continue;;
+
+	-d) dir_arg=true
+	    shift
+	    continue;;
+
+	-m) chmodcmd="$chmodprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-o) chowncmd="$chownprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-g) chgrpcmd="$chgrpprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-s) stripcmd="$stripprog"
+	    shift
+	    continue;;
+
+	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
+	    shift
+	    continue;;
+
+	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
+	    shift
+	    continue;;
+
+	*)  if [ x"$src" = x ]
+	    then
+		src=$1
+	    else
+		# this colon is to work around a 386BSD /bin/sh bug
+		:
+		dst=$1
+	    fi
+	    shift
+	    continue;;
+    esac
+done
+
+if [ x"$src" = x ]
+then
+	echo "install:	no input file specified"
+	exit 1
+else
+	true
+fi
+
+if [ x"$dir_arg" != x ]; then
+	dst=$src
+	src=""
+	
+	if [ -d $dst ]; then
+		instcmd=:
+	else
+		instcmd=mkdir
+	fi
+else
+
+# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
+# might cause directories to be created, which would be especially bad 
+# if $src (and thus $dsttmp) contains '*'.
+
+	if [ -f $src -o -d $src ]
+	then
+		true
+	else
+		echo "install:  $src does not exist"
+		exit 1
+	fi
+	
+	if [ x"$dst" = x ]
+	then
+		echo "install:	no destination specified"
+		exit 1
+	else
+		true
+	fi
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+	if [ -d $dst ]
+	then
+		dst="$dst"/`basename $src`
+	else
+		true
+	fi
+fi
+
+## this sed command emulates the dirname command
+dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
+
+# Make sure that the destination directory exists.
+#  this part is taken from Noah Friedman's mkinstalldirs script
+
+# Skip lots of stat calls in the usual case.
+if [ ! -d "$dstdir" ]; then
+defaultIFS='	
+'
+IFS="${IFS-${defaultIFS}}"
+
+oIFS="${IFS}"
+# Some sh's can't handle IFS=/ for some reason.
+IFS='%'
+set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
+IFS="${oIFS}"
+
+pathcomp=''
+
+while [ $# -ne 0 ] ; do
+	pathcomp="${pathcomp}${1}"
+	shift
+
+	if [ ! -d "${pathcomp}" ] ;
+        then
+		$mkdirprog "${pathcomp}"
+	else
+		true
+	fi
+
+	pathcomp="${pathcomp}/"
+done
+fi
+
+if [ x"$dir_arg" != x ]
+then
+	$doit $instcmd $dst &&
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
+else
+
+# If we're going to rename the final executable, determine the name now.
+
+	if [ x"$transformarg" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		dstfile=`basename $dst $transformbasename | 
+			sed $transformarg`$transformbasename
+	fi
+
+# don't allow the sed command to completely eliminate the filename
+
+	if [ x"$dstfile" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		true
+	fi
+
+# Make a temp file name in the proper directory.
+
+	dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+	$doit $instcmd $src $dsttmp &&
+
+	trap "rm -f ${dsttmp}" 0 &&
+
+# and set any options; do chmod last to preserve setuid bits
+
+# If any of these fail, we abort the whole thing.  If we want to
+# ignore errors from any of these, just make sure not to ignore
+# errors from the above "$doit $instcmd $src $dsttmp" command.
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
+
+# Now rename the file to the real destination.
+
+	$doit $rmcmd -f $dstdir/$dstfile &&
+	$doit $mvcmd $dsttmp $dstdir/$dstfile 
+
+fi &&
+
+
+exit 0
diff --git a/readline/support/mkdirs b/readline/support/mkdirs
new file mode 100755
--- /dev/null
+++ b/readline/support/mkdirs
@@ -0,0 +1,32 @@
+#! /bin/sh
+#
+# mkdirs - a work-alike for `mkdir -p'
+#
+# Chet Ramey
+# chet@po.cwru.edu
+
+for dir
+do
+
+	test -d "$dir" && continue
+
+	tomake=$dir
+	while test -n "$dir" ; do
+		# dir=${dir%/*}
+		# dir=`expr "$dir" ':' '\(/.*\)/[^/]*'`
+		if dir=`expr "$dir" ':' '\(.*\)/[^/]*'`; then
+			tomake="$dir $tomake"
+		else
+			dir=
+		fi
+	done
+
+	for d in $tomake
+	do
+		test -d "$d" && continue
+		echo mkdir "$d"
+		mkdir "$d"
+	done
+done
+
+exit 0
diff --git a/readline/support/mkdist b/readline/support/mkdist
new file mode 100755
--- /dev/null
+++ b/readline/support/mkdist
@@ -0,0 +1,100 @@
+#! /bin/bash -
+#
+# mkdist - make a distribution directory from a master manifest file
+#
+# usage: mkdist [-m manifest] [-s srcdir] [-r rootname] [-v] version
+#
+# SRCDIR defaults to src
+# MANIFEST defaults to $SRCDIR/MANIFEST
+#
+
+SRCDIR=src
+ROOTNAME=bash
+
+usage()
+{
+	echo usage: mkdist [-m manifest] [-s srcdir] [-r rootname] [-v] version 1>&2
+	exit 2
+}
+
+vmsg()
+{
+	if [ -n "$verbose" ]; then
+		echo mkdist: "$@"
+	fi
+}
+
+while getopts m:s:r:v name
+do
+	case $name in
+	m)	MANIFEST=$OPTARG ;;
+	s)	SRCDIR=$OPTARG ;;
+	r)	ROOTNAME=$OPTARG ;;
+	v)	verbose=yes ;;
+	?)	usage ;;
+	esac
+done
+
+: ${MANIFEST:=$SRCDIR/MANIFEST}
+
+vmsg using $MANIFEST
+
+shift $(( $OPTIND - 1 ))
+
+if [ $# -lt 1 ]; then
+	usage
+fi
+
+version=$1
+newdir=${ROOTNAME}-$version
+
+vmsg creating distribution for version $version in $newdir
+
+if [ ! -d $newdir ]; then
+	mkdir $newdir || { echo $0: cannot make directory $newdir 1>&2 ; exit 1; }
+fi
+
+dirmode=755
+filmode=644
+
+while read fname type mode
+do
+	[ -z "$fname" ] && continue
+
+	case "$fname" in
+	\#*)	continue ;;
+	esac
+
+	case "$type" in
+	d)	mkdir $newdir/$fname ;;
+	f)	cp -p $SRCDIR/$fname $newdir/$fname ;;
+	*)	echo "unknown file type $type" 1>&2 ;;
+	esac
+
+	if [ -n "$mode" ]; then
+		chmod $mode $newdir/$fname
+	fi
+
+done < $MANIFEST
+
+# cut off the `-alpha' in something like `2.0-alpha', leaving just the
+# numeric version
+#version=${version%%-*}
+
+#case "$version" in
+#*.*.*)	vers=${version%.*} ;;
+#*.*)	vers=${version} ;;
+#esac
+
+#echo $vers > $newdir/.distribution
+
+#case "$version" in
+#*.*.*)	plevel=${version##*.} ;;
+#*)	plevel=0 ;;
+#esac
+#[ -z "$plevel" ] && plevel=0
+#echo ${plevel} > $newdir/.patchlevel
+
+vmsg $newdir created
+
+exit 0
diff --git a/readline/tcap.h b/readline/tcap.h
new file mode 100644
--- /dev/null
+++ b/readline/tcap.h
@@ -0,0 +1,60 @@
+/* tcap.h -- termcap library functions and variables. */
+
+/* Copyright (C) 1996 Free Software Foundation, Inc.
+
+   This file contains the Readline Library (the Library), a set of
+   routines for providing Emacs style line input to programs that ask
+   for it.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (_RLTCAP_H_)
+#define _RLTCAP_H_
+
+#if defined (HAVE_CONFIG_H)
+#  include "config.h"
+#endif
+
+#if defined (HAVE_TERMCAP_H)
+#  if defined (__linux__) && !defined (SPEED_T_IN_SYS_TYPES)
+#    include "rltty.h"
+#  endif
+#  include <termcap.h>
+#else
+
+/* On Solaris2, sys/types.h #includes sys/reg.h, which #defines PC.
+   Unfortunately, PC is a global variable used by the termcap library. */
+#ifdef PC
+#  undef PC
+#endif
+
+extern char PC;
+extern char *UP, *BC;
+
+extern short ospeed;
+
+extern int tgetent ();
+extern int tgetflag ();
+extern int tgetnum ();
+extern char *tgetstr ();
+
+extern int tputs ();
+
+extern char *tgoto ();
+
+#endif /* HAVE_TERMCAP_H */
+
+#endif /* !_RLTCAP_H_ */
diff --git a/readline/terminal.c b/readline/terminal.c
new file mode 100644
--- /dev/null
+++ b/readline/terminal.c
@@ -0,0 +1,544 @@
+/* terminal.c -- controlling the terminal with termcap. */
+
+/* Copyright (C) 1996 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+#include "posixstat.h"
+#include <fcntl.h>
+#if defined (HAVE_SYS_FILE_H)
+#  include <sys/file.h>
+#endif /* HAVE_SYS_FILE_H */
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#if defined (HAVE_LOCALE_H)
+#  include <locale.h>
+#endif
+
+#include <signal.h>
+#include <stdio.h>
+#include <setjmp.h>
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+#if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
+#  include <sys/ioctl.h>
+#endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */
+
+#include "rltty.h"
+#include "tcap.h"
+
+/* Some standard library routines. */
+#include "readline.h"
+#include "history.h"
+
+/* Variables and functions imported from readline.c */
+extern FILE *_rl_in_stream, *_rl_out_stream;
+extern int readline_echoing_p;
+extern int _rl_bell_preference;
+extern Keymap _rl_keymap;
+
+/* Functions imported from bind.c */
+extern void _rl_bind_if_unbound ();
+
+/* Functions imported from shell.c */
+extern void set_lines_and_columns ();
+extern char *get_env_value ();
+
+/* **************************************************************** */
+/*								    */
+/*			Terminal and Termcap			    */
+/*								    */
+/* **************************************************************** */
+
+static char *term_buffer = (char *)NULL;
+static char *term_string_buffer = (char *)NULL;
+
+static int tcap_initialized;
+
+/* Non-zero means this terminal can't really do anything. */
+static int dumb_term;
+
+#if !defined (__linux__)
+#  if defined (__EMX__) || defined (NEED_EXTERN_PC)
+extern 
+#  endif /* __EMX__ || NEED_EXTERN_PC */
+char PC, *BC, *UP;
+#endif /* __linux__ */
+
+/* Some strings to control terminal actions.  These are output by tputs (). */
+char *term_goto, *term_clreol, *term_cr, *term_clrpag, *term_backspace;
+char *term_pc;
+
+/* Non-zero if we determine that the terminal can do character insertion. */
+int terminal_can_insert = 0;
+
+/* How to insert characters. */
+char *term_im, *term_ei, *term_ic, *term_ip, *term_IC;
+
+/* How to delete characters. */
+char *term_dc, *term_DC;
+
+#if defined (HACK_TERMCAP_MOTION)
+char *term_forward_char;
+#endif  /* HACK_TERMCAP_MOTION */
+
+/* How to go up a line. */
+char *term_up;
+
+/* A visible bell, if the terminal can be made to flash the screen. */
+static char *visible_bell;
+
+/* Non-zero means the terminal can auto-wrap lines. */
+int _rl_term_autowrap;
+
+/* Non-zero means that this terminal has a meta key. */
+static int term_has_meta;
+
+/* The sequences to write to turn on and off the meta key, if this
+   terminal    has one. */
+static char *term_mm, *term_mo;
+
+/* The key sequences output by the arrow keys, if this terminal has any. */
+static char *term_ku, *term_kd, *term_kr, *term_kl;
+
+/* How to initialize and reset the arrow keys, if this terminal has any. */
+static char *term_ks, *term_ke;
+
+/* The key sequences sent by the Home and End keys, if any. */
+static char *term_kh, *term_kH;
+
+/* Variables that hold the screen dimensions, used by the display code. */
+int screenwidth, screenheight, screenchars;
+
+/* Non-zero means the user wants to enable the keypad. */
+int _rl_enable_keypad;
+
+/* Non-zero means the user wants to enable a meta key. */
+int _rl_enable_meta = 1;
+
+/* Get readline's idea of the screen size.  TTY is a file descriptor open
+   to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
+   values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being
+   non-null serve to check whether or not we have initialized termcap. */
+void
+_rl_get_screen_size (tty, ignore_env)
+     int tty, ignore_env;
+{
+  char *ss;
+#if defined (TIOCGWINSZ)
+  struct winsize window_size;
+#endif /* TIOCGWINSZ */
+#if defined (__EMX__)
+  int sz[2];
+#endif
+
+#if defined (TIOCGWINSZ)
+  if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)
+    {
+      screenwidth = (int) window_size.ws_col;
+      screenheight = (int) window_size.ws_row;
+    }
+#endif /* TIOCGWINSZ */
+
+#if defined (__EMX__)
+  _scrsize (sz);
+  screenwidth = sz[0];
+  screenheight = sz[1];
+#endif
+
+  /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
+     is unset. */
+  if (screenwidth <= 0)
+    {
+      if (ignore_env == 0 && (ss = get_env_value ("COLUMNS")))
+	screenwidth = atoi (ss);
+
+      if (screenwidth <= 0 && term_string_buffer)
+	screenwidth = tgetnum ("co");
+    }
+
+  /* Environment variable LINES overrides setting of "li" if IGNORE_ENV
+     is unset. */
+  if (screenheight <= 0)
+    {
+      if (ignore_env == 0 && (ss = get_env_value ("LINES")))
+	screenheight = atoi (ss);
+
+      if (screenheight <= 0 && term_string_buffer)
+	screenheight = tgetnum ("li");
+    }
+
+  /* If all else fails, default to 80x24 terminal. */
+  if (screenwidth <= 1)
+    screenwidth = 80;
+
+  if (screenheight <= 0)
+    screenheight = 24;
+
+  /* If we're being compiled as part of bash, set the environment
+     variables $LINES and $COLUMNS to new values.  Otherwise, just
+     do a pair of putenv () or setenv () calls. */
+  set_lines_and_columns (screenheight, screenwidth);
+
+  if (!_rl_term_autowrap)
+    screenwidth--;
+
+  screenchars = screenwidth * screenheight;
+}
+
+void
+_rl_set_screen_size (rows, cols)
+     int rows, cols;
+{
+  screenheight = rows;
+  screenwidth = cols;
+
+  if (_rl_term_autowrap == 0)
+    screenwidth--;
+
+  screenchars = screenwidth * screenheight;
+}
+
+struct _tc_string {
+     char *tc_var;
+     char **tc_value;
+};
+
+/* This should be kept sorted, just in case we decide to change the
+   search algorithm to something smarter. */
+static struct _tc_string tc_strings[] =
+{
+  "DC", &term_DC,
+  "IC", &term_IC,
+  "ce", &term_clreol,
+  "cl", &term_clrpag,
+  "cr", &term_cr,
+  "dc", &term_dc,
+  "ei", &term_ei,
+  "ic", &term_ic,
+  "im", &term_im,
+  "kd", &term_kd,
+  "kh", &term_kh,	/* home */
+  "kH", &term_kH,	/* end */
+  "kl", &term_kl,
+  "kr", &term_kr,
+  "ku", &term_ku,
+  "ks", &term_ks,
+  "ke", &term_ke,
+  "le", &term_backspace,
+  "mm", &term_mm,
+  "mo", &term_mo,
+#if defined (HACK_TERMCAP_MOTION)
+  "nd", &term_forward_char,
+#endif
+  "pc", &term_pc,
+  "up", &term_up,
+  "vb", &visible_bell,
+};
+
+#define NUM_TC_STRINGS (sizeof (tc_strings) / sizeof (struct _tc_string))
+
+/* Read the desired terminal capability strings into BP.  The capabilities
+   are described in the TC_STRINGS table. */
+static void
+get_term_capabilities (bp)
+     char **bp;
+{
+  register int i;
+
+  for (i = 0; i < NUM_TC_STRINGS; i++)
+    *(tc_strings[i].tc_value) = tgetstr (tc_strings[i].tc_var, bp);
+  tcap_initialized = 1;
+}
+
+int
+_rl_init_terminal_io (terminal_name)
+     char *terminal_name;
+{
+#if defined (__GO32__)
+  screenwidth = ScreenCols ();
+  screenheight = ScreenRows ();
+  screenchars = screenwidth * screenheight;
+  term_cr = "\r";
+  term_im = term_ei = term_ic = term_IC = (char *)NULL;
+  term_up = term_dc = term_DC = visible_bell = (char *)NULL;
+
+  /* Does the __GO32__ have a meta key?  I don't know. */
+  term_has_meta = 0;
+  term_mm = term_mo = (char *)NULL;
+
+  /* It probably has arrow keys, but I don't know what they are. */
+  term_ku = term_kd = term_kr = term_kl = (char *)NULL;
+
+#if defined (HACK_TERMCAP_MOTION)
+  term_forward_char = (char *)NULL;
+#endif /* HACK_TERMCAP_MOTION */
+  terminal_can_insert = _rl_term_autowrap = 0;
+  return;
+#else /* !__GO32__ */
+
+  char *term, *buffer;
+  int tty;
+  Keymap xkeymap;
+
+  term = terminal_name ? terminal_name : get_env_value ("TERM");
+
+  if (term_string_buffer == 0)
+    term_string_buffer = xmalloc (2032);
+
+  if (term_buffer == 0)
+    term_buffer = xmalloc (4080);
+
+  buffer = term_string_buffer;
+
+  term_clrpag = term_cr = term_clreol = (char *)NULL;
+
+  if (term == 0)
+    term = "dumb";
+
+  if (tgetent (term_buffer, term) <= 0)
+    {
+      dumb_term = 1;
+      screenwidth = 79;
+      screenheight = 24;
+      screenchars = 79 * 24;
+      term_cr = "\r";
+      term_im = term_ei = term_ic = term_IC = (char *)NULL;
+      term_up = term_dc = term_DC = visible_bell = (char *)NULL;
+      term_ku = term_kd = term_kl = term_kr = (char *)NULL;
+#if defined (HACK_TERMCAP_MOTION)
+      term_forward_char = (char *)NULL;
+#endif
+      terminal_can_insert = 0;
+      return 0;
+    }
+
+  get_term_capabilities (&buffer);
+
+  /* Set up the variables that the termcap library expects the application
+     to provide. */
+  PC = term_pc ? *term_pc : 0;
+  BC = term_backspace;
+  UP = term_up;
+
+  if (!term_cr)
+    term_cr = "\r";
+
+  tty = rl_instream ? fileno (rl_instream) : 0;
+
+  screenwidth = screenheight = 0;
+
+  _rl_term_autowrap = tgetflag ("am") && tgetflag ("xn");
+
+  _rl_get_screen_size (tty, 0);
+
+  /* "An application program can assume that the terminal can do
+      character insertion if *any one of* the capabilities `IC',
+      `im', `ic' or `ip' is provided."  But we can't do anything if
+      only `ip' is provided, so... */
+  terminal_can_insert = (term_IC || term_im || term_ic);
+
+  /* Check to see if this terminal has a meta key and clear the capability
+     variables if there is none. */
+  term_has_meta = (tgetflag ("km") || tgetflag ("MT"));
+  if (!term_has_meta)
+    term_mm = term_mo = (char *)NULL;
+
+  /* Attempt to find and bind the arrow keys.  Do not override already
+     bound keys in an overzealous attempt, however. */
+  xkeymap = _rl_keymap;
+
+  _rl_keymap = emacs_standard_keymap;
+  _rl_bind_if_unbound (term_ku, rl_get_previous_history);
+  _rl_bind_if_unbound (term_kd, rl_get_next_history);
+  _rl_bind_if_unbound (term_kr, rl_forward);
+  _rl_bind_if_unbound (term_kl, rl_backward);
+
+  _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
+  _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
+
+#if defined (VI_MODE)
+  _rl_keymap = vi_movement_keymap;
+  _rl_bind_if_unbound (term_ku, rl_get_previous_history);
+  _rl_bind_if_unbound (term_kd, rl_get_next_history);
+  _rl_bind_if_unbound (term_kr, rl_forward);
+  _rl_bind_if_unbound (term_kl, rl_backward);
+
+  _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
+  _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
+#endif /* VI_MODE */
+
+  _rl_keymap = xkeymap;
+
+#endif /* !__GO32__ */
+  return 0;
+}
+
+char *
+rl_get_termcap (cap)
+     char *cap;
+{
+  register int i;
+
+  if (tcap_initialized == 0)
+    return ((char *)NULL);
+  for (i = 0; i < NUM_TC_STRINGS; i++)
+    {
+      if (tc_strings[i].tc_var[0] == cap[0] && strcmp (tc_strings[i].tc_var, cap) == 0)
+        return *(tc_strings[i].tc_value);
+    }
+  return ((char *)NULL);
+}
+
+/* Re-initialize the terminal considering that the TERM/TERMCAP variable
+   has changed. */
+int
+rl_reset_terminal (terminal_name)
+     char *terminal_name;
+{
+  _rl_init_terminal_io (terminal_name);
+  return 0;
+}
+
+/* A function for the use of tputs () */
+int
+_rl_output_character_function (c)
+     int c;
+{
+  return putc (c, _rl_out_stream);
+}
+
+/* Write COUNT characters from STRING to the output stream. */
+void
+_rl_output_some_chars (string, count)
+     char *string;
+     int count;
+{
+  fwrite (string, 1, count, _rl_out_stream);
+}
+
+/* Move the cursor back. */
+int
+_rl_backspace (count)
+     int count;
+{
+  register int i;
+
+#if !defined (__GO32__)
+  if (term_backspace)
+    for (i = 0; i < count; i++)
+      tputs (term_backspace, 1, _rl_output_character_function);
+  else
+#endif /* !__GO32__ */
+    for (i = 0; i < count; i++)
+      putc ('\b', _rl_out_stream);
+  return 0;
+}
+
+/* Move to the start of the next line. */
+int
+crlf ()
+{
+#if defined (NEW_TTY_DRIVER)
+  if (term_cr)
+    tputs (term_cr, 1, _rl_output_character_function);
+#endif /* NEW_TTY_DRIVER */
+  putc ('\n', _rl_out_stream);
+  return 0;
+}
+
+/* Ring the terminal bell. */
+int
+ding ()
+{
+  if (readline_echoing_p)
+    {
+#if !defined (__GO32__)
+      switch (_rl_bell_preference)
+        {
+	case NO_BELL:
+	default:
+	  break;
+	case VISIBLE_BELL:
+	  if (visible_bell)
+	    {
+	      tputs (visible_bell, 1, _rl_output_character_function);
+	      break;
+	    }
+	  /* FALLTHROUGH */
+	case AUDIBLE_BELL:
+	  fprintf (stderr, "\007");
+	  fflush (stderr);
+	  break;
+        }
+#else /* __GO32__ */
+      fprintf (stderr, "\007");
+      fflush (stderr);
+#endif /* __GO32__ */
+      return (0);
+    }
+  return (-1);
+}
+
+/* **************************************************************** */
+/*								    */
+/*	 	Controlling the Meta Key and Keypad		    */
+/*								    */
+/* **************************************************************** */
+
+static int
+outchar (c)
+     int c;
+{
+  return putc (c, rl_outstream);
+}
+
+void
+_rl_enable_meta_key ()
+{
+  if (term_has_meta && term_mm)
+    tputs (term_mm, 1, outchar);
+}
+
+void
+_rl_control_keypad (on)
+     int on;
+{
+  if (on && term_ks)
+    tputs (term_ks, 1, outchar);
+  else if (!on && term_ke)
+    tputs (term_ke, 1, outchar);
+}
diff --git a/readline/tilde.c b/readline/tilde.c
new file mode 100644
--- /dev/null
+++ b/readline/tilde.c
@@ -0,0 +1,463 @@
+/* tilde.c -- Tilde expansion code (~/foo := $HOME/foo). */
+
+/* Copyright (C) 1988,1989 Free Software Foundation, Inc.
+
+   This file is part of GNU Readline, a library for reading lines
+   of text with interactive input and history editing.
+
+   Readline is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 1, or (at your option) any
+   later version.
+
+   Readline is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Readline; see the file COPYING.  If not, write to the Free
+   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#if defined (HAVE_STRING_H)
+#  include <string.h>
+#else /* !HAVE_STRING_H */
+#  include <strings.h>
+#endif /* !HAVE_STRING_H */  
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include <sys/types.h>
+#include <pwd.h>
+
+#include "tilde.h"
+
+#ifdef SHELL
+#include "shell.h"
+#endif
+
+#if !defined (HAVE_GETPW_DECLS)
+extern struct passwd *getpwuid (), *getpwnam ();
+#endif /* !HAVE_GETPW_DECLS */
+
+#if !defined (savestring)
+extern char *xmalloc ();
+#  ifndef strcpy
+extern char *strcpy ();
+#  endif
+#define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
+#endif /* !savestring */
+
+#if !defined (NULL)
+#  if defined (__STDC__)
+#    define NULL ((void *) 0)
+#  else
+#    define NULL 0x0
+#  endif /* !__STDC__ */
+#endif /* !NULL */
+
+#if defined (TEST) || defined (STATIC_MALLOC)
+static char *xmalloc (), *xrealloc ();
+#else
+extern char *xmalloc (), *xrealloc ();
+#endif /* TEST || STATIC_MALLOC */
+
+/* The default value of tilde_additional_prefixes.  This is set to
+   whitespace preceding a tilde so that simple programs which do not
+   perform any word separation get desired behaviour. */
+static char *default_prefixes[] =
+  { " ~", "\t~", (char *)NULL };
+
+/* The default value of tilde_additional_suffixes.  This is set to
+   whitespace or newline so that simple programs which do not
+   perform any word separation get desired behaviour. */
+static char *default_suffixes[] =
+  { " ", "\n", (char *)NULL };
+
+/* If non-null, this contains the address of a function that the application
+   wants called before trying the standard tilde expansions.  The function
+   is called with the text sans tilde, and returns a malloc()'ed string
+   which is the expansion, or a NULL pointer if the expansion fails. */
+CPFunction *tilde_expansion_preexpansion_hook = (CPFunction *)NULL;
+
+/* If non-null, this contains the address of a function to call if the
+   standard meaning for expanding a tilde fails.  The function is called
+   with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
+   which is the expansion, or a NULL pointer if there is no expansion. */
+CPFunction *tilde_expansion_failure_hook = (CPFunction *)NULL;
+
+/* When non-null, this is a NULL terminated array of strings which
+   are duplicates for a tilde prefix.  Bash uses this to expand
+   `=~' and `:~'. */
+char **tilde_additional_prefixes = default_prefixes;
+
+/* When non-null, this is a NULL terminated array of strings which match
+   the end of a username, instead of just "/".  Bash sets this to
+   `:' and `=~'. */
+char **tilde_additional_suffixes = default_suffixes;
+
+/* Find the start of a tilde expansion in STRING, and return the index of
+   the tilde which starts the expansion.  Place the length of the text
+   which identified this tilde starter in LEN, excluding the tilde itself. */
+static int
+tilde_find_prefix (string, len)
+     char *string;
+     int *len;
+{
+  register int i, j, string_len;
+  register char **prefixes = tilde_additional_prefixes;
+
+  string_len = strlen (string);
+  *len = 0;
+
+  if (*string == '\0' || *string == '~')
+    return (0);
+
+  if (prefixes)
+    {
+      for (i = 0; i < string_len; i++)
+	{
+	  for (j = 0; prefixes[j]; j++)
+	    {
+	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
+		{
+		  *len = strlen (prefixes[j]) - 1;
+		  return (i + *len);
+		}
+	    }
+	}
+    }
+  return (string_len);
+}
+
+/* Find the end of a tilde expansion in STRING, and return the index of
+   the character which ends the tilde definition.  */
+static int
+tilde_find_suffix (string)
+     char *string;
+{
+  register int i, j, string_len;
+  register char **suffixes;
+
+  suffixes = tilde_additional_suffixes;
+  string_len = strlen (string);
+
+  for (i = 0; i < string_len; i++)
+    {
+      if (string[i] == '/' /* || !string[i] */)
+	break;
+
+      for (j = 0; suffixes && suffixes[j]; j++)
+	{
+	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
+	    return (i);
+	}
+    }
+  return (i);
+}
+
+#if !defined (SHELL)
+static char *
+get_string_value (varname)
+     char *varname;
+{
+  return ((char *)getenv (varname));
+}
+#endif
+
+/* Return a new string which is the result of tilde expanding STRING. */
+char *
+tilde_expand (string)
+     char *string;
+{
+  char *result;
+  int result_size, result_index;
+
+  result_index = result_size = 0;
+  if (result = strchr (string, '~'))
+    result = xmalloc (result_size = (strlen (string) + 16));
+  else
+    result = xmalloc (result_size = strlen (string));
+
+  /* Scan through STRING expanding tildes as we come to them. */
+  while (1)
+    {
+      register int start, end;
+      char *tilde_word, *expansion;
+      int len;
+
+      /* Make START point to the tilde which starts the expansion. */
+      start = tilde_find_prefix (string, &len);
+
+      /* Copy the skipped text into the result. */
+      if ((result_index + start + 1) > result_size)
+	result = xrealloc (result, 1 + (result_size += (start + 20)));
+
+      strncpy (result + result_index, string, start);
+      result_index += start;
+
+      /* Advance STRING to the starting tilde. */
+      string += start;
+
+      /* Make END be the index of one after the last character of the
+	 username. */
+      end = tilde_find_suffix (string);
+
+      /* If both START and END are zero, we are all done. */
+      if (!start && !end)
+	break;
+
+      /* Expand the entire tilde word, and copy it into RESULT. */
+      tilde_word = xmalloc (1 + end);
+      strncpy (tilde_word, string, end);
+      tilde_word[end] = '\0';
+      string += end;
+
+      expansion = tilde_expand_word (tilde_word);
+      free (tilde_word);
+
+      len = strlen (expansion);
+      if ((result_index + len + 1) > result_size)
+	result = xrealloc (result, 1 + (result_size += (len + 20)));
+
+      strcpy (result + result_index, expansion);
+      result_index += len;
+      free (expansion);
+    }
+
+  result[result_index] = '\0';
+
+  return (result);
+}
+
+/* Take FNAME and return the tilde prefix we want expanded.  If LENP is
+   non-null, the index of the end of the prefix into FNAME is returned in
+   the location it points to. */
+static char *
+isolate_tilde_prefix (fname, lenp)
+     char *fname;
+     int *lenp;
+{
+  char *ret;
+  int i;
+
+  ret = xmalloc (strlen (fname));
+  for (i = 1; fname[i] && fname[i] != '/'; i++)
+    ret[i - 1] = fname[i];
+  ret[i - 1] = '\0';
+  if (lenp)
+    *lenp = i;
+  return ret;
+}
+
+/* Return a string that is PREFIX concatenated with SUFFIX starting at
+   SUFFIND. */
+static char *
+glue_prefix_and_suffix (prefix, suffix, suffind)
+     char *prefix, *suffix;
+     int suffind;
+{
+  char *ret;
+  int plen, slen;
+
+  plen = (prefix && *prefix) ? strlen (prefix) : 0;
+  slen = strlen (suffix + suffind);
+  ret = xmalloc (plen + slen + 1);
+  if (prefix && *prefix)
+    strcpy (ret, prefix);
+  strcpy (ret + plen, suffix + suffind);
+  return ret;
+}
+
+static char *
+get_home_dir ()
+{
+  char *home_dir;
+
+#ifdef SHELL
+  home_dir = (char *)NULL;
+  if (current_user.home_dir == 0)
+    get_current_user_info ();
+  home_dir = current_user.home_dir;
+#else
+  struct passwd *entry;
+
+  home_dir = (char *)NULL;
+  entry = getpwuid (getuid ());
+  if (entry)
+    home_dir = entry->pw_dir;
+#endif
+  return (home_dir);
+}
+
+/* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
+   tilde.  If there is no expansion, call tilde_expansion_failure_hook.
+   This always returns a newly-allocated string, never static storage. */
+char *
+tilde_expand_word (filename)
+     char *filename;
+{
+  char *dirname, *expansion, *username;
+  int user_len;
+  struct passwd *user_entry;
+
+  if (filename == 0)
+    return ((char *)NULL);
+
+  if (*filename != '~')
+    return (savestring (filename));
+
+  /* A leading `~/' or a bare `~' is *always* translated to the value of
+     $HOME or the home directory of the current user, regardless of any
+     preexpansion hook. */
+  if (filename[1] == '\0' || filename[1] == '/')
+    {
+      /* Prefix $HOME to the rest of the string. */
+      expansion = get_string_value ("HOME");
+
+      /* If there is no HOME variable, look up the directory in
+	 the password database. */
+      if (expansion == 0)
+	expansion = get_home_dir ();
+
+      return (glue_prefix_and_suffix (expansion, filename, 1));
+    }
+
+  username = isolate_tilde_prefix (filename, &user_len);
+
+  if (tilde_expansion_preexpansion_hook)
+    {
+      expansion = (*tilde_expansion_preexpansion_hook) (username);
+      if (expansion)
+	{
+	  dirname = glue_prefix_and_suffix (expansion, filename, user_len);
+	  free (username);
+	  free (expansion);
+	  return (dirname);
+	}
+    }
+
+  /* No preexpansion hook, or the preexpansion hook failed.  Look in the
+     password database. */
+  dirname = (char *)NULL;
+  user_entry = getpwnam (username);
+  if (user_entry == 0)
+    {
+      /* If the calling program has a special syntax for expanding tildes,
+	 and we couldn't find a standard expansion, then let them try. */
+      if (tilde_expansion_failure_hook)
+	{
+	  expansion = (*tilde_expansion_failure_hook) (username);
+	  if (expansion)
+	    {
+	      dirname = glue_prefix_and_suffix (expansion, filename, user_len);
+	      free (expansion);
+	    }
+	}
+      free (username);
+      /* If we don't have a failure hook, or if the failure hook did not
+	 expand the tilde, return a copy of what we were passed. */
+      if (dirname == 0)
+	dirname = savestring (filename);
+    }
+  else
+    {
+      free (username);
+      dirname = glue_prefix_and_suffix (user_entry->pw_dir, filename, user_len);
+    }
+
+  endpwent ();
+  return (dirname);
+}
+
+
+#if defined (TEST)
+#undef NULL
+#include <stdio.h>
+
+main (argc, argv)
+     int argc;
+     char **argv;
+{
+  char *result, line[512];
+  int done = 0;
+
+  while (!done)
+    {
+      printf ("~expand: ");
+      fflush (stdout);
+
+      if (!gets (line))
+	strcpy (line, "done");
+
+      if ((strcmp (line, "done") == 0) ||
+	  (strcmp (line, "quit") == 0) ||
+	  (strcmp (line, "exit") == 0))
+	{
+	  done = 1;
+	  break;
+	}
+
+      result = tilde_expand (line);
+      printf ("  --> %s\n", result);
+      free (result);
+    }
+  exit (0);
+}
+
+static void memory_error_and_abort ();
+
+static char *
+xmalloc (bytes)
+     int bytes;
+{
+  char *temp = (char *)malloc (bytes);
+
+  if (!temp)
+    memory_error_and_abort ();
+  return (temp);
+}
+
+static char *
+xrealloc (pointer, bytes)
+     char *pointer;
+     int bytes;
+{
+  char *temp;
+
+  if (!pointer)
+    temp = (char *)malloc (bytes);
+  else
+    temp = (char *)realloc (pointer, bytes);
+
+  if (!temp)
+    memory_error_and_abort ();
+
+  return (temp);
+}
+
+static void
+memory_error_and_abort ()
+{
+  fprintf (stderr, "readline: out of virtual memory\n");
+  abort ();
+}
+
+/*
+ * Local variables:
+ * compile-command: "gcc -g -DTEST -o tilde tilde.c"
+ * end:
+ */
+#endif /* TEST */
diff --git a/readline/tilde.h b/readline/tilde.h
new file mode 100644
--- /dev/null
+++ b/readline/tilde.h
@@ -0,0 +1,65 @@
+/* tilde.h: Externally available variables and function in libtilde.a. */
+
+/* Copyright (C) 1992 Free Software Foundation, Inc.
+
+   This file contains the Readline Library (the Library), a set of
+   routines for providing Emacs style line input to programs that ask
+   for it.
+
+   The Library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 1, or (at your option)
+   any later version.
+
+   The Library is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (_TILDE_H_)
+#  define _TILDE_H_
+
+/* Function pointers can be declared as (Function *)foo. */
+#if !defined (_FUNCTION_DEF)
+#  define _FUNCTION_DEF
+typedef int Function ();
+typedef void VFunction ();
+typedef char *CPFunction ();
+typedef char **CPPFunction ();
+#endif /* _FUNCTION_DEF */
+
+/* If non-null, this contains the address of a function that the application
+   wants called before trying the standard tilde expansions.  The function
+   is called with the text sans tilde, and returns a malloc()'ed string
+   which is the expansion, or a NULL pointer if the expansion fails. */
+extern CPFunction *tilde_expansion_preexpansion_hook;
+
+/* If non-null, this contains the address of a function to call if the
+   standard meaning for expanding a tilde fails.  The function is called
+   with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
+   which is the expansion, or a NULL pointer if there is no expansion. */
+extern CPFunction *tilde_expansion_failure_hook;
+
+/* When non-null, this is a NULL terminated array of strings which
+   are duplicates for a tilde prefix.  Bash uses this to expand
+   `=~' and `:~'. */
+extern char **tilde_additional_prefixes;
+
+/* When non-null, this is a NULL terminated array of strings which match
+   the end of a username, instead of just "/".  Bash sets this to
+   `:' and `=~'. */
+extern char **tilde_additional_suffixes;
+
+/* Return a new string which is the result of tilde expanding STRING. */
+extern char *tilde_expand ();
+
+/* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
+   tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
+extern char *tilde_expand_word ();
+
+#endif /* _TILDE_H_ */
diff --git a/readline/undo.c b/readline/undo.c
new file mode 100644
--- /dev/null
+++ b/readline/undo.c
@@ -0,0 +1,260 @@
+/* readline.c -- a general facility for reading lines of input
+   with emacs style editing and completion. */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>           /* for _POSIX_VERSION */
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include <stdio.h>
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+/* Some standard library routines. */
+#include "readline.h"
+#include "history.h"
+
+#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
+
+/* Non-zero tells rl_delete_text and rl_insert_text to not add to
+   the undo list. */
+int _rl_doing_an_undo = 0;
+
+/* How many unclosed undo groups we currently have. */
+int _rl_undo_group_level = 0;
+
+/* The current undo list for THE_LINE. */
+UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;
+
+/* **************************************************************** */
+/*								    */
+/*			Undo, and Undoing			    */
+/*								    */
+/* **************************************************************** */
+
+/* Remember how to undo something.  Concatenate some undos if that
+   seems right. */
+void
+rl_add_undo (what, start, end, text)
+     enum undo_code what;
+     int start, end;
+     char *text;
+{
+  UNDO_LIST *temp = (UNDO_LIST *)xmalloc (sizeof (UNDO_LIST));
+  temp->what = what;
+  temp->start = start;
+  temp->end = end;
+  temp->text = text;
+  temp->next = rl_undo_list;
+  rl_undo_list = temp;
+}
+
+/* Free the existing undo list. */
+void
+free_undo_list ()
+{
+  while (rl_undo_list)
+    {
+      UNDO_LIST *release = rl_undo_list;
+      rl_undo_list = rl_undo_list->next;
+
+      if (release->what == UNDO_DELETE)
+	free (release->text);
+
+      free (release);
+    }
+  rl_undo_list = (UNDO_LIST *)NULL;
+}
+
+/* Undo the next thing in the list.  Return 0 if there
+   is nothing to undo, or non-zero if there was. */
+int
+rl_do_undo ()
+{
+  UNDO_LIST *release;
+  int waiting_for_begin = 0;
+  int start, end;
+
+#define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))
+
+  do
+    {
+      if (!rl_undo_list)
+	return (0);
+
+      _rl_doing_an_undo = 1;
+
+      /* To better support vi-mode, a start or end value of -1 means
+	 rl_point, and a value of -2 means rl_end. */
+      if (rl_undo_list->what == UNDO_DELETE || rl_undo_list->what == UNDO_INSERT)
+	{
+	  start = TRANS (rl_undo_list->start);
+	  end = TRANS (rl_undo_list->end);
+	}
+
+      switch (rl_undo_list->what)
+	{
+	/* Undoing deletes means inserting some text. */
+	case UNDO_DELETE:
+	  rl_point = start;
+	  rl_insert_text (rl_undo_list->text);
+	  free (rl_undo_list->text);
+	  break;
+
+	/* Undoing inserts means deleting some text. */
+	case UNDO_INSERT:
+	  rl_delete_text (start, end);
+	  rl_point = start;
+	  break;
+
+	/* Undoing an END means undoing everything 'til we get to a BEGIN. */
+	case UNDO_END:
+	  waiting_for_begin++;
+	  break;
+
+	/* Undoing a BEGIN means that we are done with this group. */
+	case UNDO_BEGIN:
+	  if (waiting_for_begin)
+	    waiting_for_begin--;
+	  else
+	    ding ();
+	  break;
+	}
+
+      _rl_doing_an_undo = 0;
+
+      release = rl_undo_list;
+      rl_undo_list = rl_undo_list->next;
+      free (release);
+    }
+  while (waiting_for_begin);
+
+  return (1);
+}
+#undef TRANS
+
+int
+_rl_fix_last_undo_of_type (type, start, end)
+     int type, start, end;
+{
+  UNDO_LIST *rl;
+
+  for (rl = rl_undo_list; rl; rl = rl->next)
+    {
+      if (rl->what == type)
+	{
+	  rl->start = start;
+	  rl->end = end;
+	  return 0;
+	}
+    }
+  return 1;
+}
+
+/* Begin a group.  Subsequent undos are undone as an atomic operation. */
+int
+rl_begin_undo_group ()
+{
+  rl_add_undo (UNDO_BEGIN, 0, 0, 0);
+  _rl_undo_group_level++;
+  return 0;
+}
+
+/* End an undo group started with rl_begin_undo_group (). */
+int
+rl_end_undo_group ()
+{
+  rl_add_undo (UNDO_END, 0, 0, 0);
+  _rl_undo_group_level--;
+  return 0;
+}
+
+/* Save an undo entry for the text from START to END. */
+int
+rl_modifying (start, end)
+     int start, end;
+{
+  if (start > end)
+    {
+      SWAP (start, end);
+    }
+
+  if (start != end)
+    {
+      char *temp = rl_copy_text (start, end);
+      rl_begin_undo_group ();
+      rl_add_undo (UNDO_DELETE, start, end, temp);
+      rl_add_undo (UNDO_INSERT, start, end, (char *)NULL);
+      rl_end_undo_group ();
+    }
+  return 0;
+}
+
+/* Revert the current line to its previous state. */
+int
+rl_revert_line (count, key)
+     int count, key;
+{
+  if (!rl_undo_list)
+    ding ();
+  else
+    {
+      while (rl_undo_list)
+	rl_do_undo ();
+    }
+  return 0;
+}
+
+/* Do some undoing of things that were done. */
+int
+rl_undo_command (count, key)
+     int count, key;
+{
+  if (count < 0)
+    return 0;	/* Nothing to do. */
+
+  while (count)
+    {
+      if (rl_do_undo ())
+	count--;
+      else
+	{
+	  ding ();
+	  break;
+	}
+    }
+  return 0;
+}
diff --git a/readline/util.c b/readline/util.c
new file mode 100644
--- /dev/null
+++ b/readline/util.c
@@ -0,0 +1,302 @@
+/* util.c -- readline utility functions */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <fcntl.h>
+#include "posixjmp.h"
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>           /* for _POSIX_VERSION */
+#endif /* HAVE_UNISTD_H */
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#include <stdio.h>
+#include <ctype.h>
+
+/* System-specific feature definitions and include files. */
+#include "rldefs.h"
+
+#if defined (TIOCSTAT_IN_SYS_IOCTL)
+#  include <sys/ioctl.h>
+#endif /* TIOCSTAT_IN_SYS_IOCTL */
+
+/* Some standard library routines. */
+#include "readline.h"
+
+#define SWAP(s, e)  do { int t; t = s; s = e; e = t; } while (0)
+
+/* Pseudo-globals imported from readline.c */
+extern int readline_echoing_p;
+extern procenv_t readline_top_level;
+extern int rl_line_buffer_len;
+extern Function *rl_last_func;
+
+extern int _rl_defining_kbd_macro;
+extern char *_rl_executing_macro;
+
+/* Pseudo-global functions imported from other library files. */
+extern void _rl_pop_executing_macro ();
+extern void _rl_set_the_line ();
+extern void _rl_init_argument ();
+
+extern char *xmalloc (), *xrealloc ();
+
+/* **************************************************************** */
+/*								    */
+/*			Utility Functions			    */
+/*								    */
+/* **************************************************************** */
+
+/* Return 0 if C is not a member of the class of characters that belong
+   in words, or 1 if it is. */
+
+int _rl_allow_pathname_alphabetic_chars = 0;
+static char *pathname_alphabetic_chars = "/-_=~.#$";
+
+int
+alphabetic (c)
+     int c;
+{
+  if (ALPHABETIC (c))
+    return (1);
+
+  return (_rl_allow_pathname_alphabetic_chars &&
+	    strchr (pathname_alphabetic_chars, c) != NULL);
+}
+
+/* How to abort things. */
+int
+_rl_abort_internal ()
+{
+  ding ();
+  rl_clear_message ();
+  _rl_init_argument ();
+  rl_pending_input = 0;
+
+  _rl_defining_kbd_macro = 0;
+  while (_rl_executing_macro)
+    _rl_pop_executing_macro ();
+
+  rl_last_func = (Function *)NULL;
+  longjmp (readline_top_level, 1);
+  return (0);
+}
+
+int
+rl_abort (count, key)
+     int count, key;
+{
+  return (_rl_abort_internal ());
+}
+
+int
+rl_tty_status (count, key)
+     int count, key;
+{
+#if defined (TIOCSTAT)
+  ioctl (1, TIOCSTAT, (char *)0);
+  rl_refresh_line ();
+#else
+  ding ();
+#endif
+  return 0;
+}
+
+/* Return a copy of the string between FROM and TO.
+   FROM is inclusive, TO is not. */
+char *
+rl_copy_text (from, to)
+     int from, to;
+{
+  register int length;
+  char *copy;
+
+  /* Fix it if the caller is confused. */
+  if (from > to)
+    SWAP (from, to);
+
+  length = to - from;
+  copy = xmalloc (1 + length);
+  strncpy (copy, rl_line_buffer + from, length);
+  copy[length] = '\0';
+  return (copy);
+}
+
+/* Increase the size of RL_LINE_BUFFER until it has enough space to hold
+   LEN characters. */
+void
+rl_extend_line_buffer (len)
+     int len;
+{
+  while (len >= rl_line_buffer_len)
+    {
+      rl_line_buffer_len += DEFAULT_BUFFER_SIZE;
+      rl_line_buffer = xrealloc (rl_line_buffer, rl_line_buffer_len);
+    }
+
+  _rl_set_the_line ();
+}
+
+/* **************************************************************** */
+/*								    */
+/*			String Utility Functions		    */
+/*								    */
+/* **************************************************************** */
+
+/* Determine if s2 occurs in s1.  If so, return a pointer to the
+   match in s1.  The compare is case insensitive. */
+char *
+_rl_strindex (s1, s2)
+     register char *s1, *s2;
+{
+  register int i, l, len;
+
+  for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)
+    if (_rl_strnicmp (s1 + i, s2, l) == 0)
+      return (s1 + i);
+  return ((char *)NULL);
+}
+
+#if !defined (HAVE_STRCASECMP)
+/* Compare at most COUNT characters from string1 to string2.  Case
+   doesn't matter. */
+int
+_rl_strnicmp (string1, string2, count)
+     char *string1, *string2;
+     int count;
+{
+  register char ch1, ch2;
+
+  while (count)
+    {
+      ch1 = *string1++;
+      ch2 = *string2++;
+      if (_rl_to_upper(ch1) == _rl_to_upper(ch2))
+	count--;
+      else
+        break;
+    }
+  return (count);
+}
+
+/* strcmp (), but caseless. */
+int
+_rl_stricmp (string1, string2)
+     char *string1, *string2;
+{
+  register char ch1, ch2;
+
+  while (*string1 && *string2)
+    {
+      ch1 = *string1++;
+      ch2 = *string2++;
+      if (_rl_to_upper(ch1) != _rl_to_upper(ch2))
+	return (1);
+    }
+  return (*string1 - *string2);
+}
+#endif /* !HAVE_STRCASECMP */
+
+/* Stupid comparison routine for qsort () ing strings. */
+int
+_rl_qsort_string_compare (s1, s2)
+  char **s1, **s2;
+{
+#if defined (HAVE_STRCOLL)
+  return (strcoll (*s1, *s2));
+#else
+  int result;
+
+  result = **s1 - **s2;
+  if (result == 0)
+    result = strcmp (*s1, *s2);
+
+  return result;
+#endif
+}
+
+/* Function equivalents for the macros defined in chartypes.h. */
+#undef _rl_uppercase_p
+int
+_rl_uppercase_p (c)
+     int c;
+{
+  return (isupper (c));
+}
+
+#undef _rl_lowercase_p
+int
+_rl_lowercase_p (c)
+     int c;
+{
+  return (islower (c));
+}
+
+#undef _rl_pure_alphabetic
+int
+_rl_pure_alphabetic (c)
+     int c;
+{
+  return (isupper (c) || islower (c));
+}
+
+#undef _rl_digit_p
+int
+_rl_digit_p (c)
+     int c;
+{
+  return (isdigit (c));
+}
+
+#undef _rl_to_lower
+int
+_rl_to_lower (c)
+     int c;
+{
+  return (isupper (c) ? tolower (c) : c);
+}
+
+#undef _rl_to_upper
+int
+_rl_to_upper (c)
+     int c;
+{
+  return (islower (c) ? toupper (c) : c);
+}
+
+#undef _rl_digit_value
+int
+_rl_digit_value (c)
+     int c;
+{
+  return (isdigit (c) ? c - '0' : c);
+}
diff --git a/readline/vi_keymap.c b/readline/vi_keymap.c
new file mode 100644
--- /dev/null
+++ b/readline/vi_keymap.c
@@ -0,0 +1,877 @@
+/* vi_keymap.c -- the keymap for vi_mode in readline (). */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if !defined (BUFSIZ)
+#include <stdio.h>
+#endif /* !BUFSIZ */
+
+#include "readline.h"
+
+#if 0
+extern KEYMAP_ENTRY_ARRAY vi_escape_keymap;
+#endif
+
+/* The keymap arrays for handling vi mode. */
+KEYMAP_ENTRY_ARRAY vi_movement_keymap = {
+  /* The regular control keys come first. */
+  { ISFUNC, (Function *)0x0 },		/* Control-@ */
+  { ISFUNC, (Function *)0x0 },		/* Control-a */
+  { ISFUNC, (Function *)0x0 },		/* Control-b */
+  { ISFUNC, (Function *)0x0 },		/* Control-c */
+  { ISFUNC, rl_vi_eof_maybe },		/* Control-d */
+  { ISFUNC, rl_emacs_editing_mode },	/* Control-e */
+  { ISFUNC, (Function *)0x0 },		/* Control-f */
+  { ISFUNC, rl_abort },			/* Control-g */
+  { ISFUNC, rl_backward },		/* Control-h */
+  { ISFUNC, (Function *)0x0 },		/* Control-i */
+  { ISFUNC, rl_newline },		/* Control-j */
+  { ISFUNC, rl_kill_line },		/* Control-k */
+  { ISFUNC, rl_clear_screen },		/* Control-l */
+  { ISFUNC, rl_newline },		/* Control-m */
+  { ISFUNC, rl_get_next_history },	/* Control-n */
+  { ISFUNC, (Function *)0x0 },		/* Control-o */
+  { ISFUNC, rl_get_previous_history },	/* Control-p */
+  { ISFUNC, rl_quoted_insert },		/* Control-q */
+  { ISFUNC, rl_reverse_search_history }, /* Control-r */
+  { ISFUNC, rl_forward_search_history }, /* Control-s */
+  { ISFUNC, rl_transpose_chars },	/* Control-t */
+  { ISFUNC, rl_unix_line_discard },	/* Control-u */
+  { ISFUNC, rl_quoted_insert },		/* Control-v */
+  { ISFUNC, rl_unix_word_rubout },	/* Control-w */
+  { ISFUNC, (Function *)0x0 },		/* Control-x */
+  { ISFUNC, rl_yank },			/* Control-y */
+  { ISFUNC, (Function *)0x0 },		/* Control-z */
+
+  { ISFUNC, (Function *)0x0 },		/* Control-[ */	/* vi_escape_keymap */
+  { ISFUNC, (Function *)0x0 },		/* Control-\ */
+  { ISFUNC, (Function *)0x0 },		/* Control-] */
+  { ISFUNC, (Function *)0x0 },		/* Control-^ */
+  { ISFUNC, rl_vi_undo },		/* Control-_ */
+
+  /* The start of printing characters. */
+  { ISFUNC, rl_forward },		/* SPACE */
+  { ISFUNC, (Function *)0x0 },		/* ! */
+  { ISFUNC, (Function *)0x0 },		/* " */
+  { ISFUNC, rl_insert_comment },	/* # */
+  { ISFUNC, rl_end_of_line },		/* $ */
+  { ISFUNC, rl_vi_match },		/* % */
+  { ISFUNC, rl_vi_tilde_expand },	/* & */
+  { ISFUNC, (Function *)0x0 },		/* ' */
+  { ISFUNC, (Function *)0x0 },		/* ( */
+  { ISFUNC, (Function *)0x0 },		/* ) */
+  { ISFUNC, rl_vi_complete },		/* * */
+  { ISFUNC, rl_get_next_history},	/* + */
+  { ISFUNC, rl_vi_char_search },	/* , */
+  { ISFUNC, rl_get_previous_history },	/* - */
+  { ISFUNC, rl_vi_redo },		/* . */
+  { ISFUNC, rl_vi_search },		/* / */
+
+  /* Regular digits. */
+  { ISFUNC, rl_beg_of_line },		/* 0 */
+  { ISFUNC, rl_vi_arg_digit },		/* 1 */
+  { ISFUNC, rl_vi_arg_digit },		/* 2 */
+  { ISFUNC, rl_vi_arg_digit },		/* 3 */
+  { ISFUNC, rl_vi_arg_digit },		/* 4 */
+  { ISFUNC, rl_vi_arg_digit },		/* 5 */
+  { ISFUNC, rl_vi_arg_digit },		/* 6 */
+  { ISFUNC, rl_vi_arg_digit },		/* 7 */
+  { ISFUNC, rl_vi_arg_digit },		/* 8 */
+  { ISFUNC, rl_vi_arg_digit },		/* 9 */
+
+  /* A little more punctuation. */
+  { ISFUNC, (Function *)0x0 },		/* : */
+  { ISFUNC, rl_vi_char_search },	/* ; */
+  { ISFUNC, (Function *)0x0 },		/* < */
+  { ISFUNC, rl_vi_complete },		/* = */
+  { ISFUNC, (Function *)0x0 },		/* > */
+  { ISFUNC, rl_vi_search },		/* ? */
+  { ISFUNC, (Function *)0x0 },		/* @ */
+
+  /* Uppercase alphabet. */
+  { ISFUNC, rl_vi_append_eol },		/* A */
+  { ISFUNC, rl_vi_prev_word},		/* B */
+  { ISFUNC, rl_vi_change_to },		/* C */
+  { ISFUNC, rl_vi_delete_to },		/* D */
+  { ISFUNC, rl_vi_end_word },		/* E */
+  { ISFUNC, rl_vi_char_search },	/* F */
+  { ISFUNC, rl_vi_fetch_history },	/* G */
+  { ISFUNC, (Function *)0x0 },		/* H */
+  { ISFUNC, rl_vi_insert_beg },		/* I */
+  { ISFUNC, (Function *)0x0 },		/* J */
+  { ISFUNC, (Function *)0x0 },		/* K */
+  { ISFUNC, (Function *)0x0 },		/* L */
+  { ISFUNC, (Function *)0x0 },		/* M */
+  { ISFUNC, rl_vi_search_again },	/* N */
+  { ISFUNC, (Function *)0x0 },		/* O */
+  { ISFUNC, rl_vi_put },		/* P */
+  { ISFUNC, (Function *)0x0 },		/* Q */
+  { ISFUNC, rl_vi_replace },		/* R */
+  { ISFUNC, rl_vi_subst },		/* S */
+  { ISFUNC, rl_vi_char_search },	/* T */
+  { ISFUNC, rl_revert_line },		/* U */
+  { ISFUNC, (Function *)0x0 },		/* V */
+  { ISFUNC, rl_vi_next_word },		/* W */
+  { ISFUNC, rl_rubout },		/* X */
+  { ISFUNC, rl_vi_yank_to },		/* Y */
+  { ISFUNC, (Function *)0x0 },		/* Z */
+
+  /* Some more punctuation. */
+  { ISFUNC, (Function *)0x0 },		/* [ */
+  { ISFUNC, rl_vi_complete },		/* \ */
+  { ISFUNC, (Function *)0x0 },		/* ] */
+  { ISFUNC, rl_vi_first_print },	/* ^ */
+  { ISFUNC, rl_vi_yank_arg },		/* _ */
+  { ISFUNC, rl_vi_goto_mark },		/* ` */
+
+  /* Lowercase alphabet. */
+  { ISFUNC, rl_vi_append_mode },	/* a */
+  { ISFUNC, rl_vi_prev_word },		/* b */
+  { ISFUNC, rl_vi_change_to },		/* c */
+  { ISFUNC, rl_vi_delete_to },		/* d */
+  { ISFUNC, rl_vi_end_word },		/* e */
+  { ISFUNC, rl_vi_char_search },	/* f */
+  { ISFUNC, (Function *)0x0 },		/* g */
+  { ISFUNC, rl_backward },		/* h */
+  { ISFUNC, rl_vi_insertion_mode },	/* i */
+  { ISFUNC, rl_get_next_history },	/* j */
+  { ISFUNC, rl_get_previous_history },	/* k */
+  { ISFUNC, rl_forward },		/* l */
+  { ISFUNC, rl_vi_set_mark },		/* m */
+  { ISFUNC, rl_vi_search_again },	/* n */
+  { ISFUNC, (Function *)0x0 },		/* o */
+  { ISFUNC, rl_vi_put },		/* p */
+  { ISFUNC, (Function *)0x0 },		/* q */
+  { ISFUNC, rl_vi_change_char },	/* r */
+  { ISFUNC, rl_vi_subst },		/* s */
+  { ISFUNC, rl_vi_char_search },	/* t */
+  { ISFUNC, rl_vi_undo },		/* u */
+  { ISFUNC, (Function *)0x0 },		/* v */
+  { ISFUNC, rl_vi_next_word },		/* w */
+  { ISFUNC, rl_vi_delete },		/* x */
+  { ISFUNC, rl_vi_yank_to },		/* y */
+  { ISFUNC, (Function *)0x0 },		/* z */
+
+  /* Final punctuation. */
+  { ISFUNC, (Function *)0x0 },		/* { */
+  { ISFUNC, rl_vi_column },		/* | */
+  { ISFUNC, (Function *)0x0 },		/* } */
+  { ISFUNC, rl_vi_change_case },	/* ~ */
+  { ISFUNC, (Function *)0x0 },		/* RUBOUT */
+
+#if KEYMAP_SIZE > 128
+  /* Undefined keys. */
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 }
+#endif /* KEYMAP_SIZE > 128 */
+};
+
+
+KEYMAP_ENTRY_ARRAY vi_insertion_keymap = {
+  /* The regular control keys come first. */
+  { ISFUNC, (Function *)0x0 },		/* Control-@ */
+  { ISFUNC, rl_insert },		/* Control-a */
+  { ISFUNC, rl_insert },		/* Control-b */
+  { ISFUNC, rl_insert },		/* Control-c */
+  { ISFUNC, rl_vi_eof_maybe },		/* Control-d */
+  { ISFUNC, rl_insert },		/* Control-e */
+  { ISFUNC, rl_insert },		/* Control-f */
+  { ISFUNC, rl_insert },		/* Control-g */
+  { ISFUNC, rl_rubout },		/* Control-h */
+  { ISFUNC, rl_complete },		/* Control-i */
+  { ISFUNC, rl_newline },		/* Control-j */
+  { ISFUNC, rl_insert },		/* Control-k */
+  { ISFUNC, rl_insert },		/* Control-l */
+  { ISFUNC, rl_newline },		/* Control-m */
+  { ISFUNC, rl_insert },		/* Control-n */
+  { ISFUNC, rl_insert },		/* Control-o */
+  { ISFUNC, rl_insert },		/* Control-p */
+  { ISFUNC, rl_insert },		/* Control-q */
+  { ISFUNC, rl_reverse_search_history }, /* Control-r */
+  { ISFUNC, rl_forward_search_history }, /* Control-s */
+  { ISFUNC, rl_transpose_chars },	/* Control-t */
+  { ISFUNC, rl_unix_line_discard },	/* Control-u */
+  { ISFUNC, rl_quoted_insert },		/* Control-v */
+  { ISFUNC, rl_unix_word_rubout },	/* Control-w */
+  { ISFUNC, rl_insert },		/* Control-x */
+  { ISFUNC, rl_yank },			/* Control-y */
+  { ISFUNC, rl_insert },		/* Control-z */
+
+  { ISFUNC, rl_vi_movement_mode },	/* Control-[ */
+  { ISFUNC, rl_insert },		/* Control-\ */
+  { ISFUNC, rl_insert },		/* Control-] */
+  { ISFUNC, rl_insert },		/* Control-^ */
+  { ISFUNC, rl_vi_undo },		/* Control-_ */
+
+  /* The start of printing characters. */
+  { ISFUNC, rl_insert },		/* SPACE */
+  { ISFUNC, rl_insert },		/* ! */
+  { ISFUNC, rl_insert },		/* " */
+  { ISFUNC, rl_insert },		/* # */
+  { ISFUNC, rl_insert },		/* $ */
+  { ISFUNC, rl_insert },		/* % */
+  { ISFUNC, rl_insert },		/* & */
+  { ISFUNC, rl_insert },		/* ' */
+  { ISFUNC, rl_insert },		/* ( */
+  { ISFUNC, rl_insert },		/* ) */
+  { ISFUNC, rl_insert },		/* * */
+  { ISFUNC, rl_insert },		/* + */
+  { ISFUNC, rl_insert },		/* , */
+  { ISFUNC, rl_insert },		/* - */
+  { ISFUNC, rl_insert },		/* . */
+  { ISFUNC, rl_insert },		/* / */
+
+  /* Regular digits. */
+  { ISFUNC, rl_insert },		/* 0 */
+  { ISFUNC, rl_insert },		/* 1 */
+  { ISFUNC, rl_insert },		/* 2 */
+  { ISFUNC, rl_insert },		/* 3 */
+  { ISFUNC, rl_insert },		/* 4 */
+  { ISFUNC, rl_insert },		/* 5 */
+  { ISFUNC, rl_insert },		/* 6 */
+  { ISFUNC, rl_insert },		/* 7 */
+  { ISFUNC, rl_insert },		/* 8 */
+  { ISFUNC, rl_insert },		/* 9 */
+
+  /* A little more punctuation. */
+  { ISFUNC, rl_insert },		/* : */
+  { ISFUNC, rl_insert },		/* ; */
+  { ISFUNC, rl_insert },		/* < */
+  { ISFUNC, rl_insert },		/* = */
+  { ISFUNC, rl_insert },		/* > */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* @ */
+
+  /* Uppercase alphabet. */
+  { ISFUNC, rl_insert },		/* A */
+  { ISFUNC, rl_insert },		/* B */
+  { ISFUNC, rl_insert },		/* C */
+  { ISFUNC, rl_insert },		/* D */
+  { ISFUNC, rl_insert },		/* E */
+  { ISFUNC, rl_insert },		/* F */
+  { ISFUNC, rl_insert },		/* G */
+  { ISFUNC, rl_insert },		/* H */
+  { ISFUNC, rl_insert },		/* I */
+  { ISFUNC, rl_insert },		/* J */
+  { ISFUNC, rl_insert },		/* K */
+  { ISFUNC, rl_insert },		/* L */
+  { ISFUNC, rl_insert },		/* M */
+  { ISFUNC, rl_insert },		/* N */
+  { ISFUNC, rl_insert },		/* O */
+  { ISFUNC, rl_insert },		/* P */
+  { ISFUNC, rl_insert },		/* Q */
+  { ISFUNC, rl_insert },		/* R */
+  { ISFUNC, rl_insert },		/* S */
+  { ISFUNC, rl_insert },		/* T */
+  { ISFUNC, rl_insert },		/* U */
+  { ISFUNC, rl_insert },		/* V */
+  { ISFUNC, rl_insert },		/* W */
+  { ISFUNC, rl_insert },		/* X */
+  { ISFUNC, rl_insert },		/* Y */
+  { ISFUNC, rl_insert },		/* Z */
+
+  /* Some more punctuation. */
+  { ISFUNC, rl_insert },		/* [ */
+  { ISFUNC, rl_insert },		/* \ */
+  { ISFUNC, rl_insert },		/* ] */
+  { ISFUNC, rl_insert },		/* ^ */
+  { ISFUNC, rl_insert },		/* _ */
+  { ISFUNC, rl_insert },		/* ` */
+
+  /* Lowercase alphabet. */
+  { ISFUNC, rl_insert },		/* a */
+  { ISFUNC, rl_insert },		/* b */
+  { ISFUNC, rl_insert },		/* c */
+  { ISFUNC, rl_insert },		/* d */
+  { ISFUNC, rl_insert },		/* e */
+  { ISFUNC, rl_insert },		/* f */
+  { ISFUNC, rl_insert },		/* g */
+  { ISFUNC, rl_insert },		/* h */
+  { ISFUNC, rl_insert },		/* i */
+  { ISFUNC, rl_insert },		/* j */
+  { ISFUNC, rl_insert },		/* k */
+  { ISFUNC, rl_insert },		/* l */
+  { ISFUNC, rl_insert },		/* m */
+  { ISFUNC, rl_insert },		/* n */
+  { ISFUNC, rl_insert },		/* o */
+  { ISFUNC, rl_insert },		/* p */
+  { ISFUNC, rl_insert },		/* q */
+  { ISFUNC, rl_insert },		/* r */
+  { ISFUNC, rl_insert },		/* s */
+  { ISFUNC, rl_insert },		/* t */
+  { ISFUNC, rl_insert },		/* u */
+  { ISFUNC, rl_insert },		/* v */
+  { ISFUNC, rl_insert },		/* w */
+  { ISFUNC, rl_insert },		/* x */
+  { ISFUNC, rl_insert },		/* y */
+  { ISFUNC, rl_insert },		/* z */
+
+  /* Final punctuation. */
+  { ISFUNC, rl_insert },		/* { */
+  { ISFUNC, rl_insert },		/* | */
+  { ISFUNC, rl_insert },		/* } */
+  { ISFUNC, rl_insert },		/* ~ */
+  { ISFUNC, rl_rubout },		/* RUBOUT */
+
+#if KEYMAP_SIZE > 128
+  /* Pure 8-bit characters (128 - 159).
+     These might be used in some
+     character sets. */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },	/* ? */
+
+  /* ISO Latin-1 characters (160 - 255) */
+  { ISFUNC, rl_insert },	/* No-break space */
+  { ISFUNC, rl_insert },	/* Inverted exclamation mark */
+  { ISFUNC, rl_insert },	/* Cent sign */
+  { ISFUNC, rl_insert },	/* Pound sign */
+  { ISFUNC, rl_insert },	/* Currency sign */
+  { ISFUNC, rl_insert },	/* Yen sign */
+  { ISFUNC, rl_insert },	/* Broken bar */
+  { ISFUNC, rl_insert },	/* Section sign */
+  { ISFUNC, rl_insert },	/* Diaeresis */
+  { ISFUNC, rl_insert },	/* Copyright sign */
+  { ISFUNC, rl_insert },	/* Feminine ordinal indicator */
+  { ISFUNC, rl_insert },	/* Left pointing double angle quotation mark */
+  { ISFUNC, rl_insert },	/* Not sign */
+  { ISFUNC, rl_insert },	/* Soft hyphen */
+  { ISFUNC, rl_insert },	/* Registered sign */
+  { ISFUNC, rl_insert },	/* Macron */
+  { ISFUNC, rl_insert },	/* Degree sign */
+  { ISFUNC, rl_insert },	/* Plus-minus sign */
+  { ISFUNC, rl_insert },	/* Superscript two */
+  { ISFUNC, rl_insert },	/* Superscript three */
+  { ISFUNC, rl_insert },	/* Acute accent */
+  { ISFUNC, rl_insert },	/* Micro sign */
+  { ISFUNC, rl_insert },	/* Pilcrow sign */
+  { ISFUNC, rl_insert },	/* Middle dot */
+  { ISFUNC, rl_insert },	/* Cedilla */
+  { ISFUNC, rl_insert },	/* Superscript one */
+  { ISFUNC, rl_insert },	/* Masculine ordinal indicator */
+  { ISFUNC, rl_insert },	/* Right pointing double angle quotation mark */
+  { ISFUNC, rl_insert },	/* Vulgar fraction one quarter */
+  { ISFUNC, rl_insert },	/* Vulgar fraction one half */
+  { ISFUNC, rl_insert },	/* Vulgar fraction three quarters */
+  { ISFUNC, rl_insert },	/* Inverted questionk mark */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with tilde */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin capital letter a with ring above */
+  { ISFUNC, rl_insert },	/* Latin capital letter ae */
+  { ISFUNC, rl_insert },	/* Latin capital letter c with cedilla */
+  { ISFUNC, rl_insert },	/* Latin capital letter e with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter e with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter e with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter e with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin capital letter i with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter i with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter i with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter i with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin capital letter eth (Icelandic) */
+  { ISFUNC, rl_insert },	/* Latin capital letter n with tilde */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with tilde */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with diaeresis */
+  { ISFUNC, rl_insert },	/* Multiplication sign */
+  { ISFUNC, rl_insert },	/* Latin capital letter o with stroke */
+  { ISFUNC, rl_insert },	/* Latin capital letter u with grave */
+  { ISFUNC, rl_insert },	/* Latin capital letter u with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter u with circumflex */
+  { ISFUNC, rl_insert },	/* Latin capital letter u with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin capital letter Y with acute */
+  { ISFUNC, rl_insert },	/* Latin capital letter thorn (Icelandic) */
+  { ISFUNC, rl_insert },	/* Latin small letter sharp s (German) */
+  { ISFUNC, rl_insert },	/* Latin small letter a with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter a with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter a with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter a with tilde */
+  { ISFUNC, rl_insert },	/* Latin small letter a with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin small letter a with ring above */
+  { ISFUNC, rl_insert },	/* Latin small letter ae */
+  { ISFUNC, rl_insert },	/* Latin small letter c with cedilla */
+  { ISFUNC, rl_insert },	/* Latin small letter e with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter e with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter e with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter e with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin small letter i with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter i with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter i with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter i with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin small letter eth (Icelandic) */
+  { ISFUNC, rl_insert },	/* Latin small letter n with tilde */
+  { ISFUNC, rl_insert },	/* Latin small letter o with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter o with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter o with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter o with tilde */
+  { ISFUNC, rl_insert },	/* Latin small letter o with diaeresis */
+  { ISFUNC, rl_insert },	/* Division sign */
+  { ISFUNC, rl_insert },	/* Latin small letter o with stroke */
+  { ISFUNC, rl_insert },	/* Latin small letter u with grave */
+  { ISFUNC, rl_insert },	/* Latin small letter u with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter u with circumflex */
+  { ISFUNC, rl_insert },	/* Latin small letter u with diaeresis */
+  { ISFUNC, rl_insert },	/* Latin small letter y with acute */
+  { ISFUNC, rl_insert },	/* Latin small letter thorn (Icelandic) */
+  { ISFUNC, rl_insert }		/* Latin small letter y with diaeresis */
+#endif /* KEYMAP_SIZE > 128 */
+};
+
+/* Unused for the time being. */
+#if 0
+KEYMAP_ENTRY_ARRAY vi_escape_keymap = {
+  /* The regular control keys come first. */
+  { ISFUNC, (Function *)0x0 },		/* Control-@ */
+  { ISFUNC, (Function *)0x0 },		/* Control-a */
+  { ISFUNC, (Function *)0x0 },		/* Control-b */
+  { ISFUNC, (Function *)0x0 },		/* Control-c */
+  { ISFUNC, (Function *)0x0 },		/* Control-d */
+  { ISFUNC, (Function *)0x0 },		/* Control-e */
+  { ISFUNC, (Function *)0x0 },		/* Control-f */
+  { ISFUNC, (Function *)0x0 },		/* Control-g */
+  { ISFUNC, (Function *)0x0 },		/* Control-h */
+  { ISFUNC, rl_tab_insert},		/* Control-i */
+  { ISFUNC, rl_emacs_editing_mode},	/* Control-j */
+  { ISFUNC, rl_kill_line },		/* Control-k */
+  { ISFUNC, (Function *)0x0 },		/* Control-l */
+  { ISFUNC, rl_emacs_editing_mode},	/* Control-m */
+  { ISFUNC, (Function *)0x0 },		/* Control-n */
+  { ISFUNC, (Function *)0x0 },		/* Control-o */
+  { ISFUNC, (Function *)0x0 },		/* Control-p */
+  { ISFUNC, (Function *)0x0 },		/* Control-q */
+  { ISFUNC, (Function *)0x0 },		/* Control-r */
+  { ISFUNC, (Function *)0x0 },		/* Control-s */
+  { ISFUNC, (Function *)0x0 },		/* Control-t */
+  { ISFUNC, (Function *)0x0 },		/* Control-u */
+  { ISFUNC, (Function *)0x0 },		/* Control-v */
+  { ISFUNC, (Function *)0x0 },		/* Control-w */
+  { ISFUNC, (Function *)0x0 },		/* Control-x */
+  { ISFUNC, (Function *)0x0 },		/* Control-y */
+  { ISFUNC, (Function *)0x0 },		/* Control-z */
+
+  { ISFUNC, rl_vi_movement_mode },	/* Control-[ */
+  { ISFUNC, (Function *)0x0 },		/* Control-\ */
+  { ISFUNC, (Function *)0x0 },		/* Control-] */
+  { ISFUNC, (Function *)0x0 },		/* Control-^ */
+  { ISFUNC, rl_vi_undo },		/* Control-_ */
+
+  /* The start of printing characters. */
+  { ISFUNC, (Function *)0x0 },		/* SPACE */
+  { ISFUNC, (Function *)0x0 },		/* ! */
+  { ISFUNC, (Function *)0x0 },		/* " */
+  { ISFUNC, (Function *)0x0 },		/* # */
+  { ISFUNC, (Function *)0x0 },		/* $ */
+  { ISFUNC, (Function *)0x0 },		/* % */
+  { ISFUNC, (Function *)0x0 },		/* & */
+  { ISFUNC, (Function *)0x0 },		/* ' */
+  { ISFUNC, (Function *)0x0 },		/* ( */
+  { ISFUNC, (Function *)0x0 },		/* ) */
+  { ISFUNC, (Function *)0x0 },		/* * */
+  { ISFUNC, (Function *)0x0 },		/* + */
+  { ISFUNC, (Function *)0x0 },		/* , */
+  { ISFUNC, (Function *)0x0 },		/* - */
+  { ISFUNC, (Function *)0x0 },		/* . */
+  { ISFUNC, (Function *)0x0 },		/* / */
+
+  /* Regular digits. */
+  { ISFUNC, rl_vi_arg_digit },		/* 0 */
+  { ISFUNC, rl_vi_arg_digit },		/* 1 */
+  { ISFUNC, rl_vi_arg_digit },		/* 2 */
+  { ISFUNC, rl_vi_arg_digit },		/* 3 */
+  { ISFUNC, rl_vi_arg_digit },		/* 4 */
+  { ISFUNC, rl_vi_arg_digit },		/* 5 */
+  { ISFUNC, rl_vi_arg_digit },		/* 6 */
+  { ISFUNC, rl_vi_arg_digit },		/* 7 */
+  { ISFUNC, rl_vi_arg_digit },		/* 8 */
+  { ISFUNC, rl_vi_arg_digit },		/* 9 */
+
+  /* A little more punctuation. */
+  { ISFUNC, (Function *)0x0 },		/* : */
+  { ISFUNC, (Function *)0x0 },		/* ; */
+  { ISFUNC, (Function *)0x0 },		/* < */
+  { ISFUNC, (Function *)0x0 },		/* = */
+  { ISFUNC, (Function *)0x0 },		/* > */
+  { ISFUNC, (Function *)0x0 },		/* ? */
+  { ISFUNC, (Function *)0x0 },		/* @ */
+
+  /* Uppercase alphabet. */
+  { ISFUNC, rl_do_lowercase_version },	/* A */
+  { ISFUNC, rl_do_lowercase_version },	/* B */
+  { ISFUNC, rl_do_lowercase_version },	/* C */
+  { ISFUNC, rl_do_lowercase_version },	/* D */
+  { ISFUNC, rl_do_lowercase_version },	/* E */
+  { ISFUNC, rl_do_lowercase_version },	/* F */
+  { ISFUNC, rl_do_lowercase_version },	/* G */
+  { ISFUNC, rl_do_lowercase_version },	/* H */
+  { ISFUNC, rl_do_lowercase_version },	/* I */
+  { ISFUNC, rl_do_lowercase_version },	/* J */
+  { ISFUNC, rl_do_lowercase_version },	/* K */
+  { ISFUNC, rl_do_lowercase_version },	/* L */
+  { ISFUNC, rl_do_lowercase_version },	/* M */
+  { ISFUNC, rl_do_lowercase_version },	/* N */
+  { ISFUNC, rl_do_lowercase_version },	/* O */
+  { ISFUNC, rl_do_lowercase_version },	/* P */
+  { ISFUNC, rl_do_lowercase_version },	/* Q */
+  { ISFUNC, rl_do_lowercase_version },	/* R */
+  { ISFUNC, rl_do_lowercase_version },	/* S */
+  { ISFUNC, rl_do_lowercase_version },	/* T */
+  { ISFUNC, rl_do_lowercase_version },	/* U */
+  { ISFUNC, rl_do_lowercase_version },	/* V */
+  { ISFUNC, rl_do_lowercase_version },	/* W */
+  { ISFUNC, rl_do_lowercase_version },	/* X */
+  { ISFUNC, rl_do_lowercase_version },	/* Y */
+  { ISFUNC, rl_do_lowercase_version },	/* Z */
+
+  /* Some more punctuation. */
+  { ISFUNC, rl_arrow_keys },		/* [ */
+  { ISFUNC, (Function *)0x0 },		/* \ */
+  { ISFUNC, (Function *)0x0 },		/* ] */
+  { ISFUNC, (Function *)0x0 },		/* ^ */
+  { ISFUNC, (Function *)0x0 },		/* _ */
+  { ISFUNC, (Function *)0x0 },		/* ` */
+
+  /* Lowercase alphabet. */
+  { ISFUNC, (Function *)0x0 },		/* a */
+  { ISFUNC, (Function *)0x0 },		/* b */
+  { ISFUNC, (Function *)0x0 },		/* c */
+  { ISFUNC, (Function *)0x0 },		/* d */
+  { ISFUNC, (Function *)0x0 },		/* e */
+  { ISFUNC, (Function *)0x0 },		/* f */
+  { ISFUNC, (Function *)0x0 },		/* g */
+  { ISFUNC, (Function *)0x0 },		/* h */
+  { ISFUNC, (Function *)0x0 },		/* i */
+  { ISFUNC, (Function *)0x0 },		/* j */
+  { ISFUNC, (Function *)0x0 },		/* k */
+  { ISFUNC, (Function *)0x0 },		/* l */
+  { ISFUNC, (Function *)0x0 },		/* m */
+  { ISFUNC, (Function *)0x0 },		/* n */
+  { ISFUNC, rl_arrow_keys },		/* o */
+  { ISFUNC, (Function *)0x0 },		/* p */
+  { ISFUNC, (Function *)0x0 },		/* q */
+  { ISFUNC, (Function *)0x0 },		/* r */
+  { ISFUNC, (Function *)0x0 },		/* s */
+  { ISFUNC, (Function *)0x0 },		/* t */
+  { ISFUNC, (Function *)0x0 },		/* u */
+  { ISFUNC, (Function *)0x0 },		/* v */
+  { ISFUNC, (Function *)0x0 },		/* w */
+  { ISFUNC, (Function *)0x0 },		/* x */
+  { ISFUNC, (Function *)0x0 },		/* y */
+  { ISFUNC, (Function *)0x0 },		/* z */
+
+  /* Final punctuation. */
+  { ISFUNC, (Function *)0x0 },		/* { */
+  { ISFUNC, (Function *)0x0 },		/* | */
+  { ISFUNC, (Function *)0x0 },		/* } */
+  { ISFUNC, (Function *)0x0 },		/* ~ */
+  { ISFUNC, rl_backward_kill_word },	/* RUBOUT */
+
+#if KEYMAP_SIZE > 128
+  /* Undefined keys. */
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 },
+  { ISFUNC, (Function *)0x0 }
+#endif /* KEYMAP_SIZE > 128 */
+};
+#endif
diff --git a/readline/vi_mode.c b/readline/vi_mode.c
new file mode 100644
--- /dev/null
+++ b/readline/vi_mode.c
@@ -0,0 +1,1378 @@
+/* vi_mode.c -- A vi emulation mode for Bash.
+   Derived from code written by Jeff Sparkes (jsparkes@bnr.ca).  */
+
+/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.
+
+   This file is part of the GNU Readline Library, a library for
+   reading lines of text with interactive input and history editing.
+
+   The GNU Readline Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version 1, or
+   (at your option) any later version.
+
+   The GNU Readline Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   The GNU General Public License is often shipped with GNU software, and
+   is generally kept in a file called COPYING or LICENSE.  If you do not
+   have a copy of the license, write to the Free Software Foundation,
+   675 Mass Ave, Cambridge, MA 02139, USA. */
+#define READLINE_LIBRARY
+
+/* **************************************************************** */
+/*								    */
+/*			VI Emulation Mode			    */
+/*								    */
+/* **************************************************************** */
+#include "rlconf.h"
+
+#if defined (VI_MODE)
+
+#if defined (HAVE_CONFIG_H)
+#  include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+#if defined (HAVE_UNISTD_H)
+#  include <unistd.h>
+#endif
+
+#include <stdio.h>
+
+/* Some standard library routines. */
+#include "rldefs.h"
+#include "readline.h"
+#include "history.h"
+
+#ifndef _rl_digit_p
+#define _rl_digit_p(c)  ((c) >= '0' && (c) <= '9')
+#endif
+
+#ifndef _rl_digit_value
+#define _rl_digit_value(c) ((c) - '0')
+#endif
+
+#ifndef member
+#define member(c, s) ((c) ? (char *)strchr ((s), (c)) != (char *)NULL : 0)
+#endif
+
+#ifndef isident
+#define isident(c) ((_rl_pure_alphabetic (c) || _rl_digit_p (c) || c == '_'))
+#endif
+
+#ifndef exchange
+#define exchange(x, y) do {int temp = x; x = y; y = temp;} while (0)
+#endif
+
+extern char *xmalloc (), *xrealloc ();
+
+/* Variables imported from readline.c */
+extern int rl_point, rl_end, rl_mark, rl_done;
+extern FILE *rl_instream;
+extern int rl_line_buffer_len, rl_explicit_arg, rl_numeric_arg;
+extern Keymap _rl_keymap;
+extern char *rl_prompt;
+extern char *rl_line_buffer;
+extern int rl_arg_sign;
+
+extern int _rl_doing_an_undo;
+extern int _rl_undo_group_level;
+
+extern void _rl_dispatch ();
+extern int _rl_char_search_internal ();
+
+extern void rl_extend_line_buffer ();
+extern int rl_vi_check ();
+
+/* Non-zero means enter insertion mode. */
+static int _rl_vi_doing_insert;
+
+/* Command keys which do movement for xxx_to commands. */
+static char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
+
+/* Keymap used for vi replace characters.  Created dynamically since
+   rarely used. */
+static Keymap vi_replace_map;
+
+/* The number of characters inserted in the last replace operation. */
+static int vi_replace_count;
+
+/* If non-zero, we have text inserted after a c[motion] command that put
+   us implicitly into insert mode.  Some people want this text to be
+   attached to the command so that it is `redoable' with `.'. */
+static int vi_continued_command;
+static char *vi_insert_buffer;
+static int vi_insert_buffer_size;
+
+static int _rl_vi_last_command = 'i';	/* default `.' puts you in insert mode */
+static int _rl_vi_last_repeat = 1;
+static int _rl_vi_last_arg_sign = 1;
+static int _rl_vi_last_motion;
+static int _rl_vi_last_search_char;
+static int _rl_vi_last_replacement;
+
+static int _rl_vi_last_key_before_insert;
+
+static int vi_redoing;
+
+/* Text modification commands.  These are the `redoable' commands. */
+static char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
+
+/* Arrays for the saved marks. */
+static int vi_mark_chars[27];
+
+static int rl_digit_loop1 ();
+
+void
+_rl_vi_initialize_line ()
+{
+  register int i;
+
+  for (i = 0; i < sizeof (vi_mark_chars) / sizeof (int); i++)
+    vi_mark_chars[i] = -1;
+}
+
+void
+_rl_vi_reset_last ()
+{
+  _rl_vi_last_command = 'i';
+  _rl_vi_last_repeat = 1;
+  _rl_vi_last_arg_sign = 1;
+  _rl_vi_last_motion = 0;
+}
+
+void
+_rl_vi_set_last (key, repeat, sign)
+     int key, repeat, sign;
+{
+  _rl_vi_last_command = key;
+  _rl_vi_last_repeat = repeat;
+  _rl_vi_last_arg_sign = sign;
+}
+
+/* Is the command C a VI mode text modification command? */
+int
+_rl_vi_textmod_command (c)
+     int c;
+{
+  return (member (c, vi_textmod));
+}
+
+static void
+_rl_vi_stuff_insert (count)
+     int count;
+{
+  rl_begin_undo_group ();
+  while (count--)
+    rl_insert_text (vi_insert_buffer);
+  rl_end_undo_group ();
+}
+
+/* Bound to `.'.  Called from command mode, so we know that we have to
+   redo a text modification command.  The default for _rl_vi_last_command
+   puts you back into insert mode. */
+int
+rl_vi_redo (count, c)
+     int count, c;
+{
+  if (!rl_explicit_arg)
+    {
+      rl_numeric_arg = _rl_vi_last_repeat;
+      rl_arg_sign = _rl_vi_last_arg_sign;
+    }
+
+  vi_redoing = 1;
+  /* If we're redoing an insert with `i', stuff in the inserted text
+     and do not go into insertion mode. */
+  if (_rl_vi_last_command == 'i' && vi_insert_buffer && *vi_insert_buffer)
+    {
+      _rl_vi_stuff_insert (count);
+      /* And back up point over the last character inserted. */
+      if (rl_point > 0)
+	rl_point--;
+    }
+  else
+    _rl_dispatch (_rl_vi_last_command, _rl_keymap);
+  vi_redoing = 0;
+
+  return (0);
+}
+
+/* A placeholder for further expansion. */
+int
+rl_vi_undo (count, key)
+     int count, key;
+{
+  return (rl_undo_command (count, key));
+}
+    
+/* Yank the nth arg from the previous line into this line at point. */
+int
+rl_vi_yank_arg (count, key)
+     int count, key;
+{
+  /* Readline thinks that the first word on a line is the 0th, while vi
+     thinks the first word on a line is the 1st.  Compensate. */
+  if (rl_explicit_arg)
+    rl_yank_nth_arg (count - 1, 0);
+  else
+    rl_yank_nth_arg ('$', 0);
+
+  return (0);
+}
+
+/* With an argument, move back that many history lines, else move to the
+   beginning of history. */
+int
+rl_vi_fetch_history (count, c)
+     int count, c;
+{
+  int wanted;
+
+  /* Giving an argument of n means we want the nth command in the history
+     file.  The command number is interpreted the same way that the bash
+     `history' command does it -- that is, giving an argument count of 450
+     to this command would get the command listed as number 450 in the
+     output of `history'. */
+  if (rl_explicit_arg)
+    {
+      wanted = history_base + where_history () - count;
+      if (wanted <= 0)
+        rl_beginning_of_history (0, 0);
+      else
+        rl_get_previous_history (wanted, c);
+    }
+  else
+    rl_beginning_of_history (count, 0);
+  return (0);
+}
+
+/* Search again for the last thing searched for. */
+int
+rl_vi_search_again (count, key)
+     int count, key;
+{
+  switch (key)
+    {
+    case 'n':
+      rl_noninc_reverse_search_again (count, key);
+      break;
+
+    case 'N':
+      rl_noninc_forward_search_again (count, key);
+      break;
+    }
+  return (0);
+}
+
+/* Do a vi style search. */
+int
+rl_vi_search (count, key)
+     int count, key;
+{
+  switch (key)
+    {
+    case '?':
+      rl_noninc_forward_search (count, key);
+      break;
+
+    case '/':
+      rl_noninc_reverse_search (count, key);
+      break;
+
+    default:
+      ding ();
+      break;
+    }
+  return (0);
+}
+
+/* Completion, from vi's point of view. */
+int
+rl_vi_complete (ignore, key)
+     int ignore, key;
+{
+  if ((rl_point < rl_end) && (!whitespace (rl_line_buffer[rl_point])))
+    {
+      if (!whitespace (rl_line_buffer[rl_point + 1]))
+	rl_vi_end_word (1, 'E');
+      rl_point++;
+    }
+
+  if (key == '*')
+    rl_complete_internal ('*');	/* Expansion and replacement. */
+  else if (key == '=')
+    rl_complete_internal ('?');	/* List possible completions. */
+  else if (key == '\\')
+    rl_complete_internal (TAB);	/* Standard Readline completion. */
+  else
+    rl_complete (0, key);
+
+  if (key == '*' || key == '\\')
+    {
+      _rl_vi_set_last (key, 1, rl_arg_sign);
+      rl_vi_insertion_mode (1, key);
+    }
+  return (0);
+}
+
+/* Tilde expansion for vi mode. */
+int
+rl_vi_tilde_expand (ignore, key)
+     int ignore, key;
+{
+  rl_tilde_expand (0, key);
+  _rl_vi_set_last (key, 1, rl_arg_sign);	/* XXX */
+  rl_vi_insertion_mode (1, key);
+  return (0);
+}
+
+/* Previous word in vi mode. */
+int
+rl_vi_prev_word (count, key)
+     int count, key;
+{
+  if (count < 0)
+    return (rl_vi_next_word (-count, key));
+
+  if (rl_point == 0)
+    {
+      ding ();
+      return (0);
+    }
+
+  if (_rl_uppercase_p (key))
+    rl_vi_bWord (count);
+  else
+    rl_vi_bword (count);
+
+  return (0);
+}
+
+/* Next word in vi mode. */
+int
+rl_vi_next_word (count, key)
+     int count, key;
+{
+  if (count < 0)
+    return (rl_vi_prev_word (-count, key));
+
+  if (rl_point >= (rl_end - 1))
+    {
+      ding ();
+      return (0);
+    }
+
+  if (_rl_uppercase_p (key))
+    rl_vi_fWord (count);
+  else
+    rl_vi_fword (count);
+  return (0);
+}
+
+/* Move to the end of the ?next? word. */
+int
+rl_vi_end_word (count, key)
+     int count, key;
+{
+  if (count < 0)
+    {
+      ding ();
+      return -1;
+    }
+
+  if (_rl_uppercase_p (key))
+    rl_vi_eWord (count);
+  else
+    rl_vi_eword (count);
+  return (0);
+}
+
+/* Move forward a word the way that 'W' does. */
+int
+rl_vi_fWord (count)
+     int count;
+{
+  while (count-- && rl_point < (rl_end - 1))
+    {
+      /* Skip until whitespace. */
+      while (!whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
+	rl_point++;
+
+      /* Now skip whitespace. */
+      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
+	rl_point++;
+    }
+  return (0);
+}
+
+int
+rl_vi_bWord (count)
+     int count;
+{
+  while (count-- && rl_point > 0)
+    {
+      /* If we are at the start of a word, move back to whitespace so
+	 we will go back to the start of the previous word. */
+      if (!whitespace (rl_line_buffer[rl_point]) &&
+	  whitespace (rl_line_buffer[rl_point - 1]))
+	rl_point--;
+
+      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
+	rl_point--;
+
+      if (rl_point > 0)
+	{
+	  while (--rl_point >= 0 && !whitespace (rl_line_buffer[rl_point]));
+	  rl_point++;
+	}
+    }
+  return (0);
+}
+
+int
+rl_vi_eWord (count)
+     int count;
+{
+  while (count-- && rl_point < (rl_end - 1))
+    {
+      if (!whitespace (rl_line_buffer[rl_point]))
+	rl_point++;
+
+      /* Move to the next non-whitespace character (to the start of the
+	 next word). */
+      while (++rl_point < rl_end && whitespace (rl_line_buffer[rl_point]));
+
+      if (rl_point && rl_point < rl_end)
+	{
+	  /* Skip whitespace. */
+	  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
+	    rl_point++;
+
+	  /* Skip until whitespace. */
+	  while (rl_point < rl_end && !whitespace (rl_line_buffer[rl_point]))
+	    rl_point++;
+
+	  /* Move back to the last character of the word. */
+	  rl_point--;
+	}
+    }
+  return (0);
+}
+
+int
+rl_vi_fword (count)
+     int count;
+{
+  while (count-- && rl_point < (rl_end - 1))
+    {
+      /* Move to white space (really non-identifer). */
+      if (isident (rl_line_buffer[rl_point]))
+	{
+	  while (isident (rl_line_buffer[rl_point]) && rl_point < rl_end)
+	    rl_point++;
+	}
+      else /* if (!whitespace (rl_line_buffer[rl_point])) */
+	{
+	  while (!isident (rl_line_buffer[rl_point]) &&
+		 !whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
+	    rl_point++;
+	}
+
+      /* Move past whitespace. */
+      while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)
+	rl_point++;
+    }
+  return (0);
+}
+
+int
+rl_vi_bword (count)
+     int count;
+{
+  while (count-- && rl_point > 0)
+    {
+      int last_is_ident;
+
+      /* If we are at the start of a word, move back to whitespace
+	 so we will go back to the start of the previous word. */
+      if (!whitespace (rl_line_buffer[rl_point]) &&
+	  whitespace (rl_line_buffer[rl_point - 1]))
+	rl_point--;
+
+      /* If this character and the previous character are `opposite', move
+	 back so we don't get messed up by the rl_point++ down there in
+	 the while loop.  Without this code, words like `l;' screw up the
+	 function. */
+      last_is_ident = isident (rl_line_buffer[rl_point - 1]);
+      if ((isident (rl_line_buffer[rl_point]) && !last_is_ident) ||
+	  (!isident (rl_line_buffer[rl_point]) && last_is_ident))
+	rl_point--;
+
+      while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))
+	rl_point--;
+
+      if (rl_point > 0)
+	{
+	  if (isident (rl_line_buffer[rl_point]))
+	    while (--rl_point >= 0 && isident (rl_line_buffer[rl_point]));
+	  else
+	    while (--rl_point >= 0 && !isident (rl_line_buffer[rl_point]) &&
+		   !whitespace (rl_line_buffer[rl_point]));
+	  rl_point++;
+	}
+    }
+  return (0);
+}
+
+int
+rl_vi_eword (count)
+     int count;
+{
+  while (count-- && rl_point < rl_end - 1)
+    {
+      if (!whitespace (rl_line_buffer[rl_point]))
+	rl_point++;
+
+      while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
+	rl_point++;
+
+      if (rl_point < rl_end)
+	{
+	  if (isident (rl_line_buffer[rl_point]))
+	    while (++rl_point < rl_end && isident (rl_line_buffer[rl_point]));
+	  else
+	    while (++rl_point < rl_end && !isident (rl_line_buffer[rl_point])
+		   && !whitespace (rl_line_buffer[rl_point]));
+	}
+      rl_point--;
+    }
+  return (0);
+}
+
+int
+rl_vi_insert_beg (count, key)
+     int count, key;
+{
+  rl_beg_of_line (1, key);
+  rl_vi_insertion_mode (1, key);
+  return (0);
+}
+
+int
+rl_vi_append_mode (count, key)
+     int count, key;
+{
+  if (rl_point < rl_end)
+    rl_point++;
+  rl_vi_insertion_mode (1, key);
+  return (0);
+}
+
+int
+rl_vi_append_eol (count, key)
+     int count, key;
+{
+  rl_end_of_line (1, key);
+  rl_vi_append_mode (1, key);
+  return (0);
+}
+
+/* What to do in the case of C-d. */
+int
+rl_vi_eof_maybe (count, c)
+     int count, c;
+{
+  return (rl_newline (1, '\n'));
+}
+
+/* Insertion mode stuff. */
+
+/* Switching from one mode to the other really just involves
+   switching keymaps. */
+int
+rl_vi_insertion_mode (count, key)
+     int count, key;
+{
+  _rl_keymap = vi_insertion_keymap;
+  _rl_vi_last_key_before_insert = key;
+  return (0);
+}
+
+static void
+_rl_vi_save_insert (up)
+      UNDO_LIST *up;
+{
+  int len, start, end;
+
+  start = up->start;
+  end = up->end;
+  len = end - start + 1;
+  if (len >= vi_insert_buffer_size)
+    {
+      vi_insert_buffer_size += (len + 32) - (len % 32);
+      vi_insert_buffer = xrealloc (vi_insert_buffer, vi_insert_buffer_size);
+    }
+  strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);
+  vi_insert_buffer[len-1] = '\0';
+}
+    
+void
+_rl_vi_done_inserting ()
+{
+  if (_rl_vi_doing_insert)
+    {
+      rl_end_undo_group ();
+      /* Now, the text between rl_undo_list->next->start and
+	 rl_undo_list->next->end is what was inserted while in insert
+	 mode.  It gets copied to VI_INSERT_BUFFER because it depends
+	 on absolute indices into the line which may change (though they
+	 probably will not). */
+      _rl_vi_doing_insert = 0;
+      _rl_vi_save_insert (rl_undo_list->next);
+      vi_continued_command = 1;
+    }
+  else
+    {
+      if (_rl_vi_last_key_before_insert == 'i' && rl_undo_list)
+        _rl_vi_save_insert (rl_undo_list);
+      /* XXX - Other keys probably need to be checked. */
+      else if (_rl_vi_last_key_before_insert == 'C')
+	rl_end_undo_group ();
+      while (_rl_undo_group_level > 0)
+	rl_end_undo_group ();
+      vi_continued_command = 0;
+    }
+}
+
+int
+rl_vi_movement_mode (count, key)
+     int count, key;
+{
+  if (rl_point > 0)
+    rl_backward (1, key);
+
+  _rl_keymap = vi_movement_keymap;
+  _rl_vi_done_inserting ();
+  return (0);
+}
+
+int
+rl_vi_arg_digit (count, c)
+     int count, c;
+{
+  if (c == '0' && rl_numeric_arg == 1 && !rl_explicit_arg)
+    return (rl_beg_of_line (1, c));
+  else
+    return (rl_digit_argument (count, c));
+}
+
+int
+rl_vi_change_case (count, ignore)
+     int count, ignore;
+{
+  char c = 0;
+
+  /* Don't try this on an empty line. */
+  if (rl_point >= rl_end)
+    return (0);
+
+  while (count-- && rl_point < rl_end)
+    {
+      if (_rl_uppercase_p (rl_line_buffer[rl_point]))
+	c = _rl_to_lower (rl_line_buffer[rl_point]);
+      else if (_rl_lowercase_p (rl_line_buffer[rl_point]))
+	c = _rl_to_upper (rl_line_buffer[rl_point]);
+      else
+	{
+	  /* Just skip over characters neither upper nor lower case. */
+	  rl_forward (1, c);
+	  continue;
+	}
+
+      /* Vi is kind of strange here. */
+      if (c)
+	{
+	  rl_begin_undo_group ();
+	  rl_delete (1, c);
+	  rl_insert (1, c);
+	  rl_end_undo_group ();
+	  rl_vi_check ();
+        }
+      else
+	rl_forward (1, c);
+    }
+  return (0);
+}
+
+int
+rl_vi_put (count, key)
+     int count, key;
+{
+  if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))
+    rl_point++;
+
+  rl_yank ();
+  rl_backward (1, key);
+  return (0);
+}
+
+int
+rl_vi_check ()
+{
+  if (rl_point && rl_point == rl_end)
+    rl_point--;
+  return (0);
+}
+
+int
+rl_vi_column (count, key)
+     int count, key;
+{
+  if (count > rl_end)
+    rl_end_of_line (1, key);
+  else
+    rl_point = count - 1;
+  return (0);
+}
+
+int
+rl_vi_domove (key, nextkey)
+     int key, *nextkey;
+{
+  int c, save;
+  int old_end;
+
+  rl_mark = rl_point;
+  c = rl_read_key ();
+  *nextkey = c;
+
+  if (!member (c, vi_motion))
+    {
+      if (_rl_digit_p (c))
+	{
+	  save = rl_numeric_arg;
+	  rl_numeric_arg = _rl_digit_value (c);
+	  rl_digit_loop1 ();
+	  rl_numeric_arg *= save;
+	  c = rl_read_key ();	/* real command */
+	  *nextkey = c;
+	}
+      else if (key == c && (key == 'd' || key == 'y' || key == 'c'))
+	{
+	  rl_mark = rl_end;
+	  rl_beg_of_line (1, c);
+	  _rl_vi_last_motion = c;
+	  return (0);
+	}
+      else
+	return (-1);
+    }
+
+  _rl_vi_last_motion = c;
+
+  /* Append a blank character temporarily so that the motion routines
+     work right at the end of the line. */
+  old_end = rl_end;
+  rl_line_buffer[rl_end++] = ' ';
+  rl_line_buffer[rl_end] = '\0';
+
+  _rl_dispatch (c, _rl_keymap);
+
+  /* Remove the blank that we added. */
+  rl_end = old_end;
+  rl_line_buffer[rl_end] = '\0';
+  if (rl_point > rl_end)
+    rl_point = rl_end;
+
+  /* No change in position means the command failed. */
+  if (rl_mark == rl_point)
+    return (-1);
+
+  /* rl_vi_f[wW]ord () leaves the cursor on the first character of the next
+     word.  If we are not at the end of the line, and we are on a
+     non-whitespace character, move back one (presumably to whitespace). */
+  if ((_rl_to_upper (c) == 'W') && rl_point < rl_end && rl_point > rl_mark &&
+      !whitespace (rl_line_buffer[rl_point]))
+    rl_point--;
+
+  /* If cw or cW, back up to the end of a word, so the behaviour of ce
+     or cE is the actual result.  Brute-force, no subtlety. */
+  if (key == 'c' && rl_point >= rl_mark && (_rl_to_upper (c) == 'W'))
+    {
+      /* Don't move farther back than where we started. */
+      while (rl_point > rl_mark && whitespace (rl_line_buffer[rl_point]))
+	rl_point--;
+
+      /* Posix.2 says that if cw or cW moves the cursor towards the end of
+	 the line, the character under the cursor should be deleted. */
+      if (rl_point == rl_mark)
+        rl_point++;
+      else
+	{
+	  /* Move past the end of the word so that the kill doesn't
+	     remove the last letter of the previous word.  Only do this
+	     if we are not at the end of the line. */
+	  if (rl_point >= 0 && rl_point < (rl_end - 1) && !whitespace (rl_line_buffer[rl_point]))
+	    rl_point++;
+	}
+    }
+
+  if (rl_mark < rl_point)
+    exchange (rl_point, rl_mark);
+
+  return (0);
+}
+
+/* A simplified loop for vi. Don't dispatch key at end.
+   Don't recognize minus sign? */
+static int
+rl_digit_loop1 ()
+{
+  int key, c;
+
+  while (1)
+    {
+      rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg, 0);
+      key = c = rl_read_key ();
+
+      if (_rl_keymap[c].type == ISFUNC &&
+	  _rl_keymap[c].function == rl_universal_argument)
+	{
+	  rl_numeric_arg *= 4;
+	  continue;
+	}
+
+      c = UNMETA (c);
+      if (_rl_digit_p (c))
+	{
+	  if (rl_explicit_arg)
+	    rl_numeric_arg = (rl_numeric_arg * 10) + _rl_digit_value (c);
+	  else
+	    rl_numeric_arg = _rl_digit_value (c);
+	  rl_explicit_arg = 1;
+	}
+      else
+	{
+	  rl_clear_message ();
+	  rl_stuff_char (key);
+	  break;
+	}
+    }
+  return (0);
+}
+
+int
+rl_vi_delete_to (count, key)
+     int count, key;
+{
+  int c;
+
+  if (_rl_uppercase_p (key))
+    rl_stuff_char ('$');
+  else if (vi_redoing)
+    rl_stuff_char (_rl_vi_last_motion);
+
+  if (rl_vi_domove (key, &c))
+    {
+      ding ();
+      return -1;
+    }
+
+  /* These are the motion commands that do not require adjusting the
+     mark. */
+  if ((strchr (" l|h^0bB", c) == 0) && (rl_mark < rl_end))
+    rl_mark++;
+
+  rl_kill_text (rl_point, rl_mark);
+  return (0);
+}
+
+int
+rl_vi_change_to (count, key)
+     int count, key;
+{
+  int c, start_pos;
+
+  if (_rl_uppercase_p (key))
+    rl_stuff_char ('$');
+  else if (vi_redoing)
+    rl_stuff_char (_rl_vi_last_motion);
+
+  start_pos = rl_point;
+
+  if (rl_vi_domove (key, &c))
+    {
+      ding ();
+      return -1;
+    }
+
+  /* These are the motion commands that do not require adjusting the
+     mark.  c[wW] are handled by special-case code in rl_vi_domove(),
+     and already leave the mark at the correct location. */
+  if ((strchr (" l|hwW^0bB", c) == 0) && (rl_mark < rl_end))
+    rl_mark++;
+
+  /* The cursor never moves with c[wW]. */
+  if ((_rl_to_upper (c) == 'W') && rl_point < start_pos)
+    rl_point = start_pos;
+
+  if (vi_redoing)
+    {
+      if (vi_insert_buffer && *vi_insert_buffer)
+	rl_begin_undo_group ();
+      rl_delete_text (rl_point, rl_mark);
+      if (vi_insert_buffer && *vi_insert_buffer)
+	{
+	  rl_insert_text (vi_insert_buffer);
+	  rl_end_undo_group ();
+	}
+    }
+  else
+    {
+      rl_begin_undo_group ();		/* to make the `u' command work */
+      rl_kill_text (rl_point, rl_mark);
+      /* `C' does not save the text inserted for undoing or redoing. */
+      if (_rl_uppercase_p (key) == 0)
+        _rl_vi_doing_insert = 1;
+      _rl_vi_set_last (key, count, rl_arg_sign);
+      rl_vi_insertion_mode (1, key);
+    }
+
+  return (0);
+}
+
+int
+rl_vi_yank_to (count, key)
+     int count, key;
+{
+  int c, save = rl_point;
+
+  if (_rl_uppercase_p (key))
+    rl_stuff_char ('$');
+
+  if (rl_vi_domove (key, &c))
+    {
+      ding ();
+      return -1;
+    }
+
+  /* These are the motion commands that do not require adjusting the
+     mark. */
+  if ((strchr (" l|h^0%bB", c) == 0) && (rl_mark < rl_end))
+    rl_mark++;
+
+  rl_begin_undo_group ();
+  rl_kill_text (rl_point, rl_mark);
+  rl_end_undo_group ();
+  rl_do_undo ();
+  rl_point = save;
+
+  return (0);
+}
+
+int
+rl_vi_delete (count, key)
+     int count, key;
+{
+  int end;
+
+  if (rl_end == 0)
+    {
+      ding ();
+      return -1;
+    }
+
+  end = rl_point + count;
+
+  if (end >= rl_end)
+    end = rl_end;
+
+  rl_kill_text (rl_point, end);
+  
+  if (rl_point > 0 && rl_point == rl_end)
+    rl_backward (1, key);
+  return (0);
+}
+
+int
+rl_vi_back_to_indent (count, key)
+     int count, key;
+{
+  rl_beg_of_line (1, key);
+  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))
+    rl_point++;
+  return (0);
+}
+
+int
+rl_vi_first_print (count, key)
+     int count, key;
+{
+  return (rl_vi_back_to_indent (1, key));
+}
+
+int
+rl_vi_char_search (count, key)
+     int count, key;
+{
+  static char target;
+  static int orig_dir, dir;
+
+  if (key == ';' || key == ',')
+    dir = key == ';' ? orig_dir : -orig_dir;
+  else
+    {
+      if (vi_redoing)
+	target = _rl_vi_last_search_char;
+      else
+	_rl_vi_last_search_char = target = rl_getc (rl_instream);
+
+      switch (key)
+        {
+        case 't':
+          orig_dir = dir = FTO;
+          break;
+
+        case 'T':
+          orig_dir = dir = BTO;
+          break;
+
+        case 'f':
+          orig_dir = dir = FFIND;
+          break;
+
+        case 'F':
+          orig_dir = dir = BFIND;
+          break;
+        }
+    }
+
+  return (_rl_char_search_internal (count, dir, target));
+}
+
+/* Match brackets */
+int
+rl_vi_match (ignore, key)
+     int ignore, key;
+{
+  int count = 1, brack, pos;
+
+  pos = rl_point;
+  if ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0)
+    {
+      while ((brack = rl_vi_bracktype (rl_line_buffer[rl_point])) == 0 &&
+	     rl_point < rl_end - 1)
+	rl_forward (1, key);
+
+      if (brack <= 0)
+	{
+	  rl_point = pos;
+	  ding ();
+	  return -1;
+	}
+    }
+
+  pos = rl_point;
+
+  if (brack < 0)
+    {
+      while (count)
+	{
+	  if (--pos >= 0)
+	    {
+	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
+	      if (b == -brack)
+		count--;
+	      else if (b == brack)
+		count++;
+	    }
+	  else
+	    {
+	      ding ();
+	      return -1;
+	    }
+	}
+    }
+  else
+    {			/* brack > 0 */
+      while (count)
+	{
+	  if (++pos < rl_end)
+	    {
+	      int b = rl_vi_bracktype (rl_line_buffer[pos]);
+	      if (b == -brack)
+		count--;
+	      else if (b == brack)
+		count++;
+	    }
+	  else
+	    {
+	      ding ();
+	      return -1;
+	    }
+	}
+    }
+  rl_point = pos;
+  return (0);
+}
+
+int
+rl_vi_bracktype (c)
+     int c;
+{
+  switch (c)
+    {
+    case '(': return  1;
+    case ')': return -1;
+    case '[': return  2;
+    case ']': return -2;
+    case '{': return  3;
+    case '}': return -3;
+    default:  return  0;
+    }
+}
+
+int
+rl_vi_change_char (count, key)
+     int count, key;
+{
+  int c;
+
+  if (vi_redoing)
+    c = _rl_vi_last_replacement;
+  else
+    _rl_vi_last_replacement = c = rl_getc (rl_instream);
+
+  if (c == '\033' || c == CTRL ('C'))
+    return -1;
+
+  while (count-- && rl_point < rl_end)
+    {
+      rl_begin_undo_group ();
+
+      rl_delete (1, c);
+      rl_insert (1, c);
+      if (count == 0)
+	rl_backward (1, c);
+
+      rl_end_undo_group ();
+    }
+  return (0);
+}
+
+int
+rl_vi_subst (count, key)
+     int count, key;
+{
+  rl_begin_undo_group ();
+
+  if (_rl_uppercase_p (key))
+    {
+      rl_beg_of_line (1, key);
+      rl_kill_line (1, key);
+    }
+  else
+    rl_delete_text (rl_point, rl_point+count);
+
+  rl_end_undo_group ();
+
+  _rl_vi_set_last (key, count, rl_arg_sign);
+
+  if (vi_redoing)
+    {
+      int o = _rl_doing_an_undo;
+
+      _rl_doing_an_undo = 1;
+      if (vi_insert_buffer && *vi_insert_buffer)
+	rl_insert_text (vi_insert_buffer);
+      _rl_doing_an_undo = o;
+    }
+  else
+    {
+      rl_begin_undo_group ();
+      _rl_vi_doing_insert = 1;
+      rl_vi_insertion_mode (1, key);
+    }
+
+  return (0);
+}
+
+int
+rl_vi_overstrike (count, key)
+     int count, key;
+{
+  int i;
+
+  if (_rl_vi_doing_insert == 0)
+    {
+      _rl_vi_doing_insert = 1;
+      rl_begin_undo_group ();
+    }
+
+  for (i = 0; i < count; i++)
+    {
+      vi_replace_count++;
+      rl_begin_undo_group ();
+
+      if (rl_point < rl_end)
+	{
+	  rl_delete (1, key);
+	  rl_insert (1, key);
+	}
+      else
+	rl_insert (1, key);
+
+      rl_end_undo_group ();
+    }
+  return (0);
+}
+
+int
+rl_vi_overstrike_delete (count, key)
+     int count, key;
+{
+  int i, s;
+
+  for (i = 0; i < count; i++)
+    {
+      if (vi_replace_count == 0)
+	{
+	  ding ();
+	  break;
+	}
+      s = rl_point;
+
+      if (rl_do_undo ())
+	vi_replace_count--;
+
+      if (rl_point == s)
+	rl_backward (1, key);
+    }
+
+  if (vi_replace_count == 0 && _rl_vi_doing_insert)
+    {
+      rl_end_undo_group ();
+      rl_do_undo ();
+      _rl_vi_doing_insert = 0;
+    }
+  return (0);
+}
+
+int
+rl_vi_replace (count, key)
+     int count, key;
+{
+  int i;
+
+  vi_replace_count = 0;
+
+  if (!vi_replace_map)
+    {
+      vi_replace_map = rl_make_bare_keymap ();
+
+      for (i = ' '; i < KEYMAP_SIZE; i++)
+	vi_replace_map[i].function = rl_vi_overstrike;
+
+      vi_replace_map[RUBOUT].function = rl_vi_overstrike_delete;
+      vi_replace_map[ESC].function = rl_vi_movement_mode;
+      vi_replace_map[RETURN].function = rl_newline;
+      vi_replace_map[NEWLINE].function = rl_newline;
+
+      /* If the normal vi insertion keymap has ^H bound to erase, do the
+         same here.  Probably should remove the assignment to RUBOUT up
+         there, but I don't think it will make a difference in real life. */
+      if (vi_insertion_keymap[CTRL ('H')].type == ISFUNC &&
+	  vi_insertion_keymap[CTRL ('H')].function == rl_rubout)
+	vi_replace_map[CTRL ('H')].function = rl_vi_overstrike_delete;
+
+    }
+  _rl_keymap = vi_replace_map;
+  return (0);
+}
+
+#if 0
+/* Try to complete the word we are standing on or the word that ends with
+   the previous character.  A space matches everything.  Word delimiters are
+   space and ;. */
+int
+rl_vi_possible_completions()
+{
+  int save_pos = rl_point;
+
+  if (rl_line_buffer[rl_point] != ' ' && rl_line_buffer[rl_point] != ';')
+    {
+      while (rl_point < rl_end && rl_line_buffer[rl_point] != ' ' &&
+	     rl_line_buffer[rl_point] != ';')
+	rl_point++;
+    }
+  else if (rl_line_buffer[rl_point - 1] == ';')
+    {
+      ding ();
+      return (0);
+    }
+
+  rl_possible_completions ();
+  rl_point = save_pos;
+
+  return (0);
+}
+#endif
+
+/* Functions to save and restore marks. */
+int
+rl_vi_set_mark (count, key)
+     int count, key;
+{
+  int ch;
+
+  ch = rl_read_key ();
+  if (_rl_lowercase_p (ch) == 0)
+    {
+      ding ();
+      return -1;
+    }
+  ch -= 'a';
+  vi_mark_chars[ch] = rl_point;
+  return 0;
+}
+
+int
+rl_vi_goto_mark (count, key)
+     int count, key;
+{
+  int ch;
+
+  ch = rl_read_key ();
+  if (ch == '`')
+    {
+      rl_point = rl_mark;
+      return 0;
+    }
+  else if (_rl_lowercase_p (ch) == 0)
+    {
+      ding ();
+      return -1;
+    }
+
+  ch -= 'a';
+  if (vi_mark_chars[ch] == -1)
+    {
+      ding ();
+      return -1;
+    }
+  rl_point = vi_mark_chars[ch];
+  return 0;
+}
+
+#endif /* VI_MODE */
diff --git a/readline/xmalloc.c b/readline/xmalloc.c
new file mode 100644
--- /dev/null
+++ b/readline/xmalloc.c
@@ -0,0 +1,87 @@
+/* xmalloc.c -- safe versions of malloc and realloc */
+
+/* Copyright (C) 1991 Free Software Foundation, Inc.
+
+   This file is part of GNU Readline, a library for reading lines
+   of text with interactive input and history editing.
+
+   Readline is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 1, or (at your option) any
+   later version.
+
+   Readline is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Readline; see the file COPYING.  If not, write to the Free
+   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if defined (HAVE_CONFIG_H)
+#include <config.h>
+#endif
+
+#include <stdio.h>
+
+#if defined (HAVE_STDLIB_H)
+#  include <stdlib.h>
+#else
+#  include "ansi_stdlib.h"
+#endif /* HAVE_STDLIB_H */
+
+static void memory_error_and_abort ();
+
+/* **************************************************************** */
+/*								    */
+/*		   Memory Allocation and Deallocation.		    */
+/*								    */
+/* **************************************************************** */
+
+/* Return a pointer to free()able block of memory large enough
+   to hold BYTES number of bytes.  If the memory cannot be allocated,
+   print an error message and abort. */
+char *
+xmalloc (bytes)
+     int bytes;
+{
+  char *temp;
+
+  temp = (char *)malloc (bytes);
+  if (temp == 0)
+    memory_error_and_abort ("xmalloc");
+  return (temp);
+}
+
+char *
+xrealloc (pointer, bytes)
+     char *pointer;
+     int bytes;
+{
+  char *temp;
+
+  temp = pointer ? (char *)realloc (pointer, bytes) : (char *)malloc (bytes);
+
+  if (temp == 0)
+    memory_error_and_abort ("xrealloc");
+  return (temp);
+}
+
+static void
+memory_error_and_abort (fname)
+     char *fname;
+{
+  fprintf (stderr, "%s: out of virtual memory\n", fname);
+  exit (2);
+}
+
+/* Use this as the function to call when adding unwind protects so we
+   don't need to know what free() returns. */
+void
+xfree (string)
+     char *string;
+{
+  if (string)
+    free (string);
+}
