# HG changeset patch
# User jwe
# Date 847342014 0
#      Thu Nov 07 04:46:54 1996 +0000
# Node ID 1d7925d6bede67cbe16036e8d58bfc0ee1873c23
# Parent  b8c53143581b28d3970f9d2d3feb334a87fe8ee3
[project @ 1996-11-07 04:36:00 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+Wed Nov  6 16:26:39 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in: Add checks for group stuff.
+
 Tue Nov  5 12:32:30 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in: Add checks for geteuid, getuid.
 
 	* configure.in: Comment out code to handle --enable-readline since
 	it doesn't work yet.
 
 	* aclocal.m4 (OCTAVE_SIGNAL_CHECK, OCTAVE_REINSTALL_SIGHANDLERS):
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -301,18 +301,20 @@ Summary of changes for version 2.0:
 
       dup2     -- duplicate a file descriptor
       exec     -- replace current process with a new process
       fcntl    -- control open file descriptors
       fork     -- create a copy of the current process
       getpgrp  -- return the process group id of the current process
       getpid   -- return the process id of the current process
       getppid  -- return the process id of the parent process
-      geteuid  -- return the effective uid of the current process
-      getuid   -- return the uid of the current process
+      getuid   -- return the real user id of the current process
+      getgid   -- return the real group id of the current process
+      geteuid  -- return the effective user id of the current process
+      getegid  -- return the effective group id of the current process
       pipe     -- create an interprocess channel
 
   * Other new functions:
 
       tmpnam              -- replaces octave_tmp_file_name
       atexit              -- register functions to be called when Octave exits
       putenv              -- define an environment variable
       meshgrid            -- compatible with Matlab's meshgrid function
diff --git a/PROJECTS b/PROJECTS
--- a/PROJECTS
+++ b/PROJECTS
@@ -504,16 +504,28 @@ Programming:
 
   * Move toward using more stuff from standard C++ library.
 
   * More C++/Fortran cleanups.
 
   * It is likely that there are still some memory leaks.  Hunt then down
     and plug them. 
 
+  * Better error messages for missing operators?
+
+  * Eliminate duplicate enums in pt-exp.cc, pt-const.cc, and ov.cc.
+
+  * Handle octave_print_internal() stuff at the liboctave level.  Then
+    the octave_value classes could just call on the print() methods
+    for the underlying classes.
+
+  * As much as possible, eliminate explicit checks for the types of
+    octave_value objects so that user-defined types will automatically
+    do the right thing in more cases.
+
   * Only include config.h in files that actually need it, instead of
     including it in every .cc file.  Unfortunately, this might not be
     so easy to figure out.
 
   * GNU coding standards:
 
     -- Add a `Makefile' target to the Makefiles.
     -- Comments on #else and #endif preprocessor commands.
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -15,17 +15,17 @@ dnl Copyright (C) 1996 John W. Eaton
 ### ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
-AC_REVISION($Revision: 1.227 $)
+AC_REVISION($Revision: 1.228 $)
 AC_PREREQ(2.9)
 AC_INIT(src/octave.cc)
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1)
 
 AC_CANONICAL_HOST
 if test -z "$host"; then
@@ -649,20 +649,20 @@ AC_SUBST(CXXLIB_PATH)
 ### Checks for header files.
 
 AC_HEADER_STDC
 AC_HEADER_DIRENT
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
 
 AC_CHECK_HEADERS(assert.h curses.h fcntl.h float.h floatingpoint.h \
-		 limits.h memory.h pwd.h sgtty.h stdlib.h string.h \
-		 sys/param.h sys/resource.h sys/select.h sys/stat.h \
-		 sys/time.h sys/times.h sys/types.h sys/utsname.h \
-		 termcap.h termio.h termios.h unistd.h varargs.h) 
+  grp.h limits.h memory.h pwd.h sgtty.h stdlib.h string.h sys/param.h \
+  sys/resource.h sys/select.h sys/stat.h sys/time.h sys/times.h \
+  sys/types.h sys/utsname.h termcap.h termio.h termios.h unistd.h \
+  varargs.h)
 
 if test "$ac_cv_header_termios_h" = yes \
     || test "$ac_cv_header_termio_h" = yes \
     || test "$ac_cv_header_sgtty_h" = yes; then
   true
 else
   AC_MSG_ERROR([I couldn't find termios.h, termio.h, or sgtty.h!])
 fi
@@ -690,24 +690,23 @@ if test -f $srcdir/libcruft/fsqp/fsqpd.f
   AC_MSG_RESULT(yes)
 else
   AC_MSG_RESULT(no)
   AC_DEFINE(FSQP_MISSING, 1)
 fi
 
 ### Checks for functions and variables.
 
-AC_CHECK_FUNCS(atexit bcopy bzero dup2 endpwent execvp fcntl fork \
-	       getcwd geteuid gethostname getpgrp getpid getppid \
-	       getpwent getpwnam getpwuid getuid lstat memmove mkdir \
-	       mkfifo on_exit pipe putenv rename rindex rmdir \
-	       setpwent setvbuf sigaction sigpending sigprocmask \
-	       sigsuspend stat strcasecmp strdup strerror stricmp \
-	       strncasecmp strnicmp tempnam umask unlink vfprintf \
-	       vsprintf waitpid)
+AC_CHECK_FUNCS(atexit bcopy bzero dup2 endgrent endpwent execvp fcntl \
+  fork getcwd getegid geteuid getgid getgrent getgrgid getgrnam \
+  gethostname getpgrp getpid getppid getpwent getpwnam getpwuid getuid \
+  lstat memmove mkdir mkfifo on_exit pipe putenv rename rindex rmdir \
+  setgrent setpwent setvbuf sigaction sigpending sigprocmask \
+  sigsuspend stat strcasecmp strdup strerror stricmp strncasecmp \
+  strnicmp tempnam umask unlink vfprintf vsprintf waitpid)
 
 OCTAVE_SMART_PUTENV
 OCTAVE_PROGRAM_INVOCATION_NAME
 
 LIBDLFCN=
 DLFCN_INCFLAGS=
 if test "$WITH_DL" = yes || test "$WITH_DL" = maybe; then
   case "$canonical_host_type" in
@@ -1064,28 +1063,28 @@ export CC
 export CXX
 export F77
 
 AC_CONFIG_SUBDIRS(glob kpathsea scripts $INFO_DIR $PLPLOT_DIR $READLINE_DIR)
 
 ### Do the substitutions in all the Makefiles.
 
 AC_OUTPUT(Makefile octMakefile Makeconf test/Makefile dlfcn/Makefile
-	  doc/Makefile doc/faq/Makefile doc/interpreter/Makefile
-	  doc/liboctave/Makefile doc/refcard/Makefile examples/Makefile
-	  liboctave/Makefile src/Makefile src/mk-oct-links
-	  libcruft/Makefile libcruft/Makerules libcruft/blas/Makefile
-	  libcruft/balgen/Makefile libcruft/dassl/Makefile
-	  libcruft/eispack/Makefile libcruft/fftpack/Makefile
-	  libcruft/fsqp/Makefile libcruft/lapack/Makefile
-	  libcruft/linpack/Makefile libcruft/minpack/Makefile
-	  libcruft/misc/Makefile libcruft/npsol/Makefile
-	  libcruft/odepack/Makefile libcruft/qpsol/Makefile
-	  libcruft/quadpack/Makefile libcruft/ranlib/Makefile
-	  libcruft/slatec-fn/Makefile libcruft/villad/Makefile)
+  doc/Makefile doc/faq/Makefile doc/interpreter/Makefile
+  doc/liboctave/Makefile doc/refcard/Makefile examples/Makefile
+  liboctave/Makefile src/Makefile src/mk-oct-links libcruft/Makefile
+  libcruft/Makerules libcruft/blas/Makefile libcruft/balgen/Makefile
+  libcruft/dassl/Makefile libcruft/eispack/Makefile
+  libcruft/fftpack/Makefile libcruft/fsqp/Makefile
+  libcruft/lapack/Makefile libcruft/linpack/Makefile
+  libcruft/minpack/Makefile libcruft/misc/Makefile
+  libcruft/npsol/Makefile libcruft/odepack/Makefile
+  libcruft/qpsol/Makefile libcruft/quadpack/Makefile
+  libcruft/ranlib/Makefile libcruft/slatec-fn/Makefile
+  libcruft/villad/Makefile)
 
 ### Print a summary so that important information isn't missed.
 
 CXX_EXTRAS="$HOST_CXXFLAGS $NO_IMPLICIT_TEMPLATES $GCC_IEEE_FP_FLAG"
 
 if test -z "$F77"; then
   FORT="$F2C $F2CFLAGS"
 else
diff --git a/doc/interpreter/system.texi b/doc/interpreter/system.texi
--- a/doc/interpreter/system.texi
+++ b/doc/interpreter/system.texi
@@ -11,16 +11,17 @@ still running, and use this information 
 you can get information about environment variables, the current time,
 and even start other programs from the Octave prompt.
 
 @menu
 * Timing Utilities::            
 * Filesystem Utilities::        
 * Interacting with the OS::     
 * Password Database Functions::  
+* Group Database Functions::    
 * System Information::          
 * Other Functions::             
 @end menu
 
 @node Timing Utilities, Filesystem Utilities, System Utilities, System Utilities
 @section Timing Utilities
 
 @deftypefn {Loadable Function} {} time ()
@@ -397,16 +398,32 @@ Return the process group id of the curre
 @deftypefn {Built-in Function} {} getpid ()
 Return the process id of the current process.
 @end deftypefn
 
 @deftypefn {Built-in Function} {} getppid ()
 Return the process id of the parent process.
 @end deftypefn
 
+@deftypefn {Built-in Function} {} geteuid ()
+Return the effective user id of the current process.
+@end deftypefn
+
+@deftypefn {Built-in Function} {} getuid ()
+Return the real user id of the current process.
+@end deftypefn
+
+@deftypefn {Built-in Function} {} getegid ()
+Return the effective group id of the current process.
+@end deftypefn
+
+@deftypefn {Built-in Function} {} getgid ()
+Return the real group id of the current process.
+@end deftypefn
+
 @deftypefn {Built-in Function} {} mkfifo       
 Create a FIFO special file.
 @end deftypefn
 
 @deftypefn {Built-in Function} {} waitpid      
 Check the status of or wait for subprocesses.
 @end deftypefn
 
@@ -526,17 +543,17 @@ total 12
 -rw-r--r--   1 jwe      users        1315 Aug 17 23:14 bar.m
 @end example
 
 The @code{dir} and @code{ls} commands are implemented by calling your
 system's directory listing command, so the available options may vary
 from system to system.
 @end deffn
 
-@node Password Database Functions, System Information, Interacting with the OS, System Utilities
+@node Password Database Functions, Group Database Functions, Interacting with the OS, System Utilities
 @section Password Database Functions
 
 Octave's password database functions return information in a structure
 with the following fields.
 
 @table @code
 @item name
 The user name.
@@ -580,17 +597,62 @@ Return the first entry from the password
 @deftypefn {Loadable Function} {} setpwent ()
 Return the internal pointer to the beginning of the password database.
 @end deftypefn
 
 @deftypefn {Loadable Function} {} endpwent ()
 Close the password database.
 @end deftypefn
 
-@node System Information, Other Functions, Password Database Functions, System Utilities
+@node Group Database Functions, System Information, Password Database Functions, System Utilities
+@section Group Database Functions
+
+Octave's group database functions return information in a structure
+with the following fields.
+
+@table @code
+@item name
+The user name.
+
+@item passwd
+The encrypted password, if available.
+
+@item gid
+The numeric group id.
+
+@item mem
+The members of the group.
+@end table
+
+@deftypefn {Loadable Function} {group_struct =} getgrent ()
+Return an entry from the group database, opening it if necessary.
+Once the end of the data has been reached, @code{getgrent} returns 0.
+@end deftypefn
+
+@deftypefn {Loadable Function} {group_struct =} getgrgid (@var{gid}).
+Return the first entry from the group database with the group ID
+@var{gid}.  If the group ID does not exist in the database,
+@code{getgrgid} returns 0.
+@end deftypefn
+
+@deftypefn {Loadable Function} {group_struct =} getgrnam (@var{name})
+Return the first entry from the group database with the group name
+@var{name}.  If the group name does not exist in the database,
+@code{getgrname} returns 0.
+@end deftypefn
+
+@deftypefn {Loadable Function} {} setgrent ()
+Return the internal pointer to the beginning of the group database.
+@end deftypefn
+
+@deftypefn {Loadable Function} {} endgrent ()
+Close the group database.
+@end deftypefn
+
+@node System Information, Other Functions, Group Database Functions, System Utilities
 @section System Information
 
 @deftypefn {Built-in Function} {} computer ()
 Returns a string of the form @var{cpu}-@var{vendor}-@var{os} that
 identifies the kind of computer Octave is running on.  For example,
 
 @example
 octave:13> computer
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -34,18 +34,18 @@ MATRIX_INC := Array.h Array2.h Array3.h 
 	dbleCHOL.h dbleDET.h dbleGEPBAL.h dbleHESS.h dbleLU.h dbleQR.h \
 	dbleQRP.h dbleSCHUR.h dbleSVD.h
 
 INCLUDES := Bounds.h CollocWt.h DAE.h DAEFunc.h DASSL.h FEGrid.h FSQP.h \
 	LinConst.h LP.h LPsolve.h LSODE.h NLConst.h NLEqn.h NLFunc.h \
 	NLP.h NPSOL.h ODE.h ODEFunc.h Objective.h QP.h QPSOL.h Quad.h \
 	Range.h base-de.h base-min.h byte-swap.h cmd-hist.h data-conv.h \
 	dir-ops.h file-ops.h f77-fcn.h getopt.h idx-vector.h lo-error.h \
-	lo-ieee.h lo-mappers.h lo-utils.h mach-info.h oct-cmplx.h \
-	oct-glob.h oct-math.h oct-term.h pathsearch.h \
+	lo-ieee.h lo-mappers.h lo-utils.h mach-info.h oct-alloc.h \
+	oct-cmplx.h oct-glob.h oct-math.h oct-term.h pathsearch.h \
 	prog-args.h statdefs.h str-vec.h sun-utils.h sysdir.h \
 	$(MATRIX_INC)
 
 TEMPLATE_SRC := Array.cc Array2.cc Array3.cc DiagArray2.cc \
 	MArray.cc MArray2.cc MDiagArray2.cc base-lu.cc
 
 TI_SRC := Array-C.cc Array-ch.cc Array-i.cc Array-d.cc Array-s.cc \
 	Array-str.cc \
@@ -60,18 +60,19 @@ MATRIX_SRC := Array-flags.cc CColVector.
 	dbleQR.cc dbleQRP.cc dbleSCHUR.cc dbleSVD.cc
 
 SOURCES := Bounds.cc CollocWt.cc DAE.cc DASSL.cc FEGrid.cc FSQP.cc \
 	LinConst.cc LPsolve.cc LSODE.cc NLEqn.cc NPSOL.cc QPSOL.cc \
 	Quad.cc Range.cc acosh.c asinh.c atanh.c cmd-hist.cc \
 	data-conv.cc dir-ops.cc erf.c erfc.c f77-fcn.c file-ops.cc \
 	filemode.c gamma.c getopt.c getopt1.c idx-vector.cc lgamma.c \
 	lo-ieee.cc lo-mappers.cc lo-utils.cc mach-info.cc mkdir.c \
-	oct-glob.cc oct-term.cc pathsearch.cc prog-args.cc rename.c \
-	rmdir.c str-vec.cc sun-utils.cc tempname.c tempnam.c \
+	oct-alloc.cc oct-glob.cc oct-term.cc pathsearch.cc \
+	prog-args.cc rename.c rmdir.c str-vec.cc sun-utils.cc \
+	tempname.c tempnam.c \
 	$(TEMPLATE_SRC) \
 	$(TI_SRC) \
 	$(MATRIX_SRC)
 
 EXTRAS := mx-inlines.cc
 
 DISTFILES := Makefile.in ChangeLog safe-xstat.cin safe-xstat.hin \
 	$(SOURCES) $(INCLUDES) $(EXTRAS)
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-alloc.cc
@@ -0,0 +1,110 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <new>
+
+#include "oct-alloc.h"
+
+void *
+octave_allocator::alloc (size_t size)
+{
+  if (size != item_size)
+    return ::new char [size];
+
+  if (! head)
+    {
+      if (! grow ())
+	return 0;
+    }
+
+  link *tmp = head;
+  head = head->next;
+  return tmp;
+}
+
+void
+octave_allocator::free (void *p, size_t size)
+{
+  if (size != item_size)
+    ::delete [] ((char *) p);
+  else
+    {
+      link *tmp = (link *) p;
+      tmp->next = head;
+      head = tmp;
+    }
+}
+
+// Return TRUE for successful allocation, FALSE otherwise.
+
+bool
+octave_allocator::grow (void)
+{
+  bool retval = true;
+
+  char *start = new char [grow_size * item_size];
+
+  if (start)
+    {
+      char *last = &start[(grow_size - 1) * item_size];
+
+      char *p = start;
+      while (p < last)
+	{
+	  char *next = p + item_size;
+	  ((link *) p) -> next = (link *) next;
+	  p = next;
+	}
+
+      ((link *) last) -> next = 0;
+
+      head = (link *) start;
+    }
+  else
+    {
+      typedef void (*error_handler_function) (void);
+
+      error_handler_function f = set_new_handler (0);
+      set_new_handler (f);
+
+      if (f)
+	f ();
+
+      retval = false;
+    }
+
+  return retval;
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/oct-alloc.h b/liboctave/oct-alloc.h
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-alloc.h
@@ -0,0 +1,68 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_oct_alloc_h)
+#define octave_oct_alloc_h 1
+
+class
+octave_allocator
+{
+public:
+
+  octave_allocator (size_t item_sz, int grow_sz = 256)
+    : head (0), grow_size (grow_sz),
+      item_size (item_sz > sizeof (link *) ? item_sz : sizeof (link *))
+  { }
+
+  // Get an object from the free list, possibly increasing the size of
+  // the free list.
+  void *alloc (size_t size);
+
+  // Put objects back on the free list.
+  void free (void *p, size_t size);
+
+private:
+
+  // Structure for internal free list management.
+  struct link { link *next; };
+
+  // Front of the free list.
+  link *head;
+
+  // How many objects to get each time we call the global operator new.
+  int grow_size;
+
+  // The size of each item on the list (or, if that is smaller than
+  // the size of list*, the size of list*.
+  size_t item_size;
+
+  // How to grow the free list.
+  bool grow (void);
+};
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,32 @@
 Wed Nov  6 12:32:48 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* pt-const.h (tree_constant::allocator) New static member.
+	(tree_constant::operator new, tree_constant::operator delete):
+	Implement with custom allocator.
+
+	* syscalls.cc (Fgetgid, Fgetegid): New functions.
+
+	* sighandlers.cc (sigchld_handler): If necessary, reinstall
+	handler after call to waitpid().
+
+	* pager.cc (pager_death_handler): Don't use warning() to print
+	message.
+
+	* getgrent.cc: New file.
+	* Makefile.in (DLD_SRC): Add it.
+
+	* ov.cc (octave_value::print_with_name): Call is_map() instead of
+	print_as_structure().
+	* ov-struct.cc (octave_struct::print): Likewise.
+
+	* ov.h, ov.cc, pt-const.h: Delete force_numeric(), make_numeric(),
+	convert_to_matrix_type(), print_as_structure() member functions.
+
 	* variables.cc (is_function_file): Call gobble_leading_whitespace
 	here to strip all leading whitespace and comments.
 	(parse_fcn_file): If reading a function file, call
 	gobble_leading_whitespace again after resetting parser state to
 	grab help text.
 
 Tue Nov  5 13:00:35 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -57,18 +57,18 @@ ifeq ($(OCTAVE_LITE), true)
 	    $(OCTAVE_LFLAGS) \
 	    $(OCTAVE_LIBS) \
 	    $(FLIBS) $(LEXLIB) $(TERMLIBS) $(LIBS) -lg++
   endif
 endif
 
 DLD_SRC := balance.cc chol.cc colloc.cc dassl.cc det.cc eig.cc \
 	   expm.cc fft.cc fft2.cc filter.cc find.cc fsolve.cc \
-	   fsqp.cc getpwent.cc getrusage.cc givens.cc hess.cc \
-	   ifft.cc ifft2.cc inv.cc log.cc lpsolve.cc lsode.cc \
+	   fsqp.cc getgrent.cc getpwent.cc getrusage.cc givens.cc \
+	   hess.cc ifft.cc ifft2.cc inv.cc log.cc lpsolve.cc lsode.cc \
 	   lu.cc minmax.cc npsol.cc pinv.cc qpsol.cc qr.cc quad.cc \
 	   qzval.cc rand.cc schur.cc sort.cc svd.cc syl.cc time.cc 
 
 DLD_OBJ := $(patsubst %.cc, %.o, $(DLD_SRC))
 
 ifeq ($(OCTAVE_LITE), true)
   OCT_FILES := $(patsubst %.o, %.oct, $(DLD_OBJ))
   ifdef CXXPICFLAG
diff --git a/src/getgrent.cc b/src/getgrent.cc
new file mode 100644
--- /dev/null
+++ b/src/getgrent.cc
@@ -0,0 +1,230 @@
+/*
+
+Copyright (C) 1996 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string>
+
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#ifdef HAVE_GRP_H
+#include <grp.h>
+#endif
+
+#include "defun-dld.h"
+#include "error.h"
+#include "gripes.h"
+#include "help.h"
+#include "oct-map.h"
+#include "ov.h"
+#include "oct-obj.h"
+#include "utils.h"
+
+// Group file functions.  (Why not?)
+
+static octave_value
+mk_gr_map (struct group *gr)
+{
+  octave_value retval;
+
+  if (gr)
+    {
+      Octave_map m;
+
+      m ["name"] = gr->gr_name;
+      m ["passwd"] = gr->gr_passwd;
+      m ["gid"] = STATIC_CAST (double, gr->gr_gid);
+
+      if (gr->gr_mem)
+	{
+	  // XXX FIXME XXX -- maybe there should be a string_vector
+	  // constructor that takes a NULL terminated list of C
+	  // strings.
+
+	  char **tmp = gr->gr_mem;
+
+	  int k = 0;
+	  while (*tmp++)
+	    k++;
+
+	  if (k > 0)
+	    {
+	      tmp = gr->gr_mem;
+
+	      string_vector members (k);
+
+	      for (int i = 0; i < k; i++)
+		members[i] = tmp[i];
+
+	      m ["mem"] = members;
+	    }
+	  else
+	    m ["mem"] = "";
+	}
+
+      retval = m;
+    }
+  else
+    retval = 0.0;
+
+  return retval;
+}
+
+DEFUN_DLD (getgrent, args, ,
+ "getgrent ()\n\
+\n\
+Read an entry from the group-file stream, opening it if necessary.")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 0)
+    {
+#ifdef HAVE_GETGRENT
+      retval = mk_gr_map (getgrent ());
+#else
+      gripe_not_supported ("getgrent");
+#endif
+    }
+  else
+    print_usage ("getgrent");
+
+  return retval;
+}
+
+DEFUN_DLD (getgrgid, args, ,
+  "getgrgid (GID)\n\
+\n\
+Search for a group entry with a matching group ID.")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    {
+#ifdef HAVE_GETGRGID
+      double dval = args(0).double_value ();
+
+      if (! error_state)
+	{
+	  if (D_NINT (dval) == dval)
+	    {
+	      gid_t gid = STATIC_CAST (gid_t, dval);
+
+	      retval = mk_gr_map (getgrgid (gid));
+	    }
+	  else
+	    error ("getgrgid: argument must be an integer");
+	}
+#else
+      gripe_not_supported ("getgrgid");
+#endif
+    }
+  else
+    print_usage ("getgrgid");
+
+  return retval;
+}
+
+DEFUN_DLD (getgrnam, args, ,
+  "getgrnam (NAME)\n\
+\n\
+Search for group entry with a matching group name.")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    {
+#ifdef HAVE_GETGRNAM
+      string s = args(0).string_value ();
+
+      if (! error_state)
+	retval = mk_gr_map (getgrnam (s.c_str ()));
+#else
+      gripe_not_supported ("getgrnam");
+#endif
+    }
+  else
+    print_usage ("getgrnam");
+
+  return retval;
+}
+
+DEFUN_DLD (setgrent, args, ,
+  "setgrent ()\n\
+\n\
+Rewind the group-file stream.")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 0)
+    {
+#ifdef HAVE_SETGRENT
+      setgrent ();
+#else
+      gripe_not_supported ("setgrent");
+#endif
+    }
+  else
+    print_usage ("setgrent");
+
+  return retval;
+}
+
+DEFUN_DLD (endgrent, args, ,
+  "endgrent ()\n\
+\n\
+Close the group-file stream.")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 0)
+    {
+#ifdef HAVE_ENDGRENT
+      endgrent ();
+#else
+      gripe_not_supported ("endgrent");
+#endif
+    }
+  else
+    print_usage ("endgrent");
+
+  return retval;
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/src/getpwent.cc b/src/getpwent.cc
--- a/src/getpwent.cc
+++ b/src/getpwent.cc
@@ -72,129 +72,135 @@ mk_pw_map (struct passwd *pw)
 
 DEFUN_DLD (getpwent, args, ,
  "getpwent ()\n\
 \n\
 Read an entry from the password-file stream, opening it if necessary.")
 {
   octave_value retval;
 
-#ifdef HAVE_GETPWENT
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = mk_pw_map (getpwent ());
+    {
+#ifdef HAVE_GETPWENT
+      retval = mk_pw_map (getpwent ());
+#else
+      gripe_not_supported ("getpwent");
+#endif
+    }
   else
     print_usage ("getpwent");
-#else
-  gripe_not_supported ("getpwent");
-#endif
 
   return retval;
 }
 
 DEFUN_DLD (getpwuid, args, ,
   "getpwuid (UID)\n\
 \n\
 Search for a password entry with a matching user ID.")
 {
   octave_value retval;
 
-#ifdef HAVE_GETPWUID
   int nargin = args.length ();
 
   if (nargin == 1)
     {
+#ifdef HAVE_GETPWUID
       double dval = args(0).double_value ();
 
       if (! error_state)
 	{
 	  if (D_NINT (dval) == dval)
 	    {
 	      uid_t uid = STATIC_CAST (uid_t, dval);
 
 	      retval = mk_pw_map (getpwuid (uid));
 	    }
 	  else
 	    error ("getpwuid: argument must be an integer");
 	}
+#else
+      gripe_not_supported ("getpwuid");
+#endif
     }
   else
     print_usage ("getpwuid");
-#else
-  gripe_not_supported ("getpwuid");
-#endif
 
   return retval;
 }
 
 DEFUN_DLD (getpwnam, args, ,
   "getpwnam (NAME)\n\
 \n\
 Search for password entry with a matching username.")
 {
   octave_value retval;
 
-#ifdef HAVE_GETPWNAM
   int nargin = args.length ();
 
   if (nargin == 1)
     {
+#ifdef HAVE_GETPWNAM
       string s = args(0).string_value ();
 
       if (! error_state)
 	retval = mk_pw_map (getpwnam (s.c_str ()));
+#else
+      gripe_not_supported ("getpwnam");
+#endif
     }
   else
     print_usage ("getpwnam");
-#else
-  gripe_not_supported ("getpwnam");
-#endif
 
   return retval;
 }
 
 DEFUN_DLD (setpwent, args, ,
   "setpwent ()\n\
 \n\
 Rewind the password-file stream.")
 {
   octave_value retval;
 
-#ifdef HAVE_SETPWENT
   int nargin = args.length ();
 
   if (nargin == 0)
-    setpwent ();
+    {
+#ifdef HAVE_SETPWENT
+      setpwent ();
+#else
+      gripe_not_supported ("setpwent");
+#endif
+    }
   else
     print_usage ("setpwent");
-#else
-  gripe_not_supported ("setpwent");
-#endif
 
   return retval;
 }
 
 DEFUN_DLD (endpwent, args, ,
   "endpwent ()\n\
 \n\
 Close the password-file stream.")
 {
   octave_value retval;
 
-#ifdef HAVE_ENDPWENT
   int nargin = args.length ();
 
   if (nargin == 0)
-    endpwent ();
+    {
+#ifdef HAVE_ENDPWENT
+      endpwent ();
+#else
+      gripe_not_supported ("endpwent");
+#endif
+    }
   else
     print_usage ("endpwent");
-#else
-  gripe_not_supported ("endpwent");
-#endif
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -88,17 +88,17 @@ octave_struct::print (ostream& os, bool)
 	  octave_value val = map.contents (p);
 
 	  map.next (p);
 
 	  os.form ("%*s%s =", struct_indent, "", key.c_str ());
 
 	  if (val.print_as_scalar ())
 	    os << " ";
-	  else if (val.print_as_structure ())
+	  else if (val.is_map ())
 	    {
 	      if (p)
 		pad_after = true;
 	    }
 	  else
 	    {
 	      if (p)
 		pad_after = true;
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -511,17 +511,17 @@ octave_value::print_with_name (ostream& 
 			       bool print_padding) 
 {
   bool pad_after = false;
 
   if (Vprint_answer_id_name)
     {
       if (print_as_scalar ())
 	output_buf << name << " = ";
-      else if (print_as_structure ())
+      else if (is_map ())
 	{
 	  pad_after = true;
 	  output_buf << name << " =";
 	}
       else
 	{
 	  pad_after = true;
 	  output_buf << name << " =\n\n";
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -372,41 +372,25 @@ public:
 
   void print_with_name (ostream& os, const string& name,
 			bool print_padding = true);
 
   virtual int type_id (void) const { return rep->type_id (); }
 
   virtual string type_name (void) const { return rep->type_name (); }
 
-  virtual void convert_to_matrix_type (bool make_complex)
-    { rep->convert_to_matrix_type (make_complex); }
-
-  // Can we make these go away?
-
-  // These need better names, since a range really is a numeric type.
-
-  virtual void force_numeric (bool frc_str_conv = false)
-    { rep->force_numeric (frc_str_conv); }
-
-  octave_value make_numeric (bool) const
-    {
-      warning ("octave_value::make_numeric() is a no-op");
-      return *this;
-    }
-
-  bool print_as_scalar (void);
-
-  bool print_as_structure (void) { return is_map (); }
-
   // Binary and unary operations.
 
   friend octave_value do_binary_op (octave_value& a, octave_value& b,
 				    tree_expression::type t);
 
+  // Can we make these go away?
+
+  bool print_as_scalar (void);
+
 protected:
 
   octave_value (const octave_xvalue&) : rep (0) { }
 
 private:
 
   union
     {
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -97,23 +97,32 @@ clear_external_pager (void)
 
 static void
 pager_death_handler (pid_t pid, int status)
 {
   if (pid > 0)
     {
       if (WIFEXITED (status) || WIFSIGNALLED (status))
 	{
-	  octave_pager_pid = -1;
+	  if (external_pager)
+	    clear_external_pager ();
 
 	  // Don't call error() here because we don't want to set
 	  // the error state.
 
-	  warning ("connection to external pager lost --");
-	  warning ("pending computations and output have been discarded");
+	  // XXX FIXME XXX -- something is wrong with the way that
+	  // we are cleaning up the pager in the event of a SIGCHLD.
+	  // If this message is printed with warning(), we eventually
+	  // crash.
+
+	  cout
+	    << "warning: connection to external pager (pid = "
+	    << pid << ") lost --" << endl
+	    << "warning: pending computations and output have been discarded"
+	    << endl;
 	}
     }
 }
 
 static void
 do_sync (const char *msg, bool bypass_pager)
 {
   if (msg && *msg)
@@ -204,21 +213,21 @@ octave_pager_buf::sync (void)
 
       bool bypass_pager = (! interactive
 			   || ! Vpage_screen_output
 			   || (really_flush_to_pager
 			       && Vpage_screen_output
 			       && ! Vpage_output_immediately
 			       && ! more_than_a_screenful (buf)));
 
+      seekoff (0, ios::beg);
+
       do_sync (buf, bypass_pager);
 
       octave_diary << buf;
-
-      seekoff (0, ios::beg);
     }
 
   return 0;
 }
 
 int
 octave_diary_buf::sync (void)
 {
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -55,16 +55,20 @@ Software Foundation, 59 Temple Place - S
 #include "pr-output.h"
 #include "sysdep.h"
 #include "pt-const.h"
 #include "pt-walk.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
+// We are likely to have a lot of tree_constants to allocate, so make
+// the grow_size large.
+octave_allocator tree_constant::allocator (sizeof (tree_constant), 1024);
+
 Octave_map
 tree_constant::map_value (void) const
 {
   return val.map_value ();
 }
 
 void
 tree_constant::print (void)
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -28,16 +28,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <string>
 
 class ostream;
 
 #include "Range.h"
 #include "mx-base.h"
+#include "oct-alloc.h"
 #include "str-vec.h"
 
 #include "pt-fvc.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
@@ -151,20 +152,21 @@ public:
       if (this != &a)
 	{
 	  tree_fvc::operator = (a);
 	  val = a.val;
 	}
       return *this;
     }
 
-#if 0
-  void *operator new (size_t size);
-  void operator delete (void *p, size_t size);
-#endif
+  void *operator new (size_t size)
+    { return allocator.alloc (size); }
+
+  void operator delete (void *p, size_t size)
+    { allocator.free (p, size); }
 
   // Indexed assignment.
 
   octave_value index (const octave_value_list& idx) const
     { return val.index (idx); }
 
   octave_value& reference (void)
     {
@@ -342,35 +344,24 @@ public:
   string original_text (void) { return orig_text; }
 
   void accept (tree_walker& tw);
 
   string type_name (void) const { return val.type_name (); }
 
 private:
 
+  // For custom memory management.
+  static octave_allocator allocator;
+
+  // The actual value that this constant refers to.
   octave_value val;
 
+  // The original text form of this constant.
   string orig_text;
-
-  void convert_to_matrix_type (bool make_complex)
-    { val.convert_to_matrix_type (make_complex); }
-
-  // Can we make these go away?
-
-  // These need better names, since a range really is a numeric type.
-
-  void force_numeric (bool frc_str_conv = false)
-    { val.force_numeric (frc_str_conv); }
-
-  octave_value make_numeric (bool frc_str_conv = false) const;
-
-  bool print_as_scalar (void) { return val.print_as_scalar (); }
-
-  bool print_as_structure (void) { return val.print_as_structure (); }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -135,20 +135,16 @@ generic_sig_handler (int sig)
   SIGHANDLER_RETURN (0);
 }
 
 // Handle SIGCHLD.
 
 static RETSIGTYPE
 sigchld_handler (int /* sig */)
 {
-#ifdef MUST_REINSTALL_SIGHANDLERS
-  octave_set_signal_handler (SIGCHLD, sigchld_handler);
-#endif
-
   int n = octave_child_list::length ();
 
   for (int i = 0; i < n; i++)
     {
       octave_child& elt = octave_child_list::elem (i);
 
       pid_t pid = elt.pid;
 
@@ -158,23 +154,27 @@ sigchld_handler (int /* sig */)
 
 	  if (waitpid (pid, &status, WNOHANG) > 0)
 	    {
 	      elt.pid = -1;
 
 	      octave_child::dead_child_handler f = elt.handler;
 
 	      if (f)
-		(*f) (pid, status);
+		f (pid, status);
 
 	      break;
 	    }
 	}
     }
 
+#ifdef MUST_REINSTALL_SIGHANDLERS
+  octave_set_signal_handler (SIGCHLD, sigchld_handler);
+#endif
+
   SIGHANDLER_RETURN (0);
 }
 
 #if defined (__alpha__)
 static RETSIGTYPE
 sigfpe_handler (int /* sig */)
 {
 #ifdef MUST_REINSTALL_SIGHANDLERS
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -85,21 +85,21 @@ mk_stat_map (const file_stat& fs)
   return m;
 }
 
 DEFUN (dup2, args, ,
  "fid = dup2 (old, new): duplicate a file descriptor")
 {
   double retval = -1.0;
 
-#if defined (HAVE_DUP2)
   int nargin = args.length ();
 
   if (nargin == 2)
     {
+#if defined (HAVE_DUP2)
       double d_old = args(0).double_value ();
       double d_new = args(1).double_value ();
 
       if (! error_state)
 	{
 	  if (D_NINT (d_old) == d_old && D_NINT (d_new) == d_new)
 	    {
 	      int i_old = NINT (d_old);
@@ -109,36 +109,36 @@ DEFUN (dup2, args, ,
 	      if (i_old >= 0 && i_new >= 0)
 		retval = (double) dup2 (i_old, i_new);
 	      else
 		error ("dup2: invalid file id");
 	    }
 	  else
 	    error ("dup2: arguments must be integer values");
 	}
+#else
+      gripe_not_supported ("dup2");
+#endif
     }
   else
     print_usage ("dup2");
-#else
-  gripe_not_supported ("dup2");
-#endif
 
   return retval;
 }
 
 DEFUN (exec, args, ,
  "exec (file, args): replace current process with a new process")
 {
   double retval = -1.0;
 
-#if defined (HAVE_EXECVP)
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
+#if defined (HAVE_EXECVP)
       string exec_file = args(0).string_value ();
 
       if (! error_state)
 	{
 	  char **exec_args = 0;
 
 	  if (nargin == 2)
 	    {
@@ -177,36 +177,36 @@ DEFUN (exec, args, ,
 	      exec_args[1] = 0;
 	    }
 
 	  if (! error_state)
 	    execvp (exec_file.c_str (), exec_args);
 	}
       else
 	error ("exec: first argument must be a string");
+#else
+      gripe_not_supported ("exec");
+#endif
     }
   else
     print_usage ("exec");
-#else
-  gripe_not_supported ("exec");
-#endif
 
   return retval;
 }
 
 DEFUN (fcntl, args, ,
  "fcntl (fid, request, argument): control open file descriptors")
 {
   double retval = -1.0;
 
-#if defined (HAVE_FCNTL)
   int nargin = args.length ();
 
   if (nargin == 3)
     {
+#if defined (HAVE_FCNTL)
       double d_fid = args(0).double_value ();
       double d_req = args(1).double_value ();
       double d_arg = args(2).double_value ();
 
       if (! error_state
 	  && D_NINT (d_fid) == d_fid
 	  && D_NINT (d_req) == d_req
 	  && D_NINT (d_arg) == d_arg)
@@ -218,136 +218,190 @@ DEFUN (fcntl, args, ,
 	  // XXX FIXME XXX -- Need better checking here?
 	  if (fid < 0)
 	    error ("fcntl: invalid file id");
 	  else
 	    retval = fcntl (fid, req, arg);
 	}
       else
 	error ("fcntl: file id must be an integer");
+#else
+      gripe_not_supported ("fcntl");
+#endif
     }
   else
     print_usage ("fcntl");
-#else
-  gripe_not_supported ("fcntl");
-#endif
 
   return retval;
 }
 
 DEFUN (fork, args, ,
  "fork (): create a copy of the current process")
 {
   double retval = -1.0;
 
-#if defined (HAVE_FORK)
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = fork ();
+    {
+#if defined (HAVE_FORK)
+      retval = fork ();
+#else
+      gripe_not_supported ("fork");
+#endif
+    }
   else
     print_usage ("fork");
-#else
-  gripe_not_supported ("fork");
-#endif
 
   return retval;
 }
 
 DEFUN (getpgrp, args, ,
   "pgid = getpgrp (): return the process group id of the current process")
 {
   double retval = -1.0;
 
-#if defined (HAVE_GETPGRP)
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = getpgrp ();
+    {
+#if defined (HAVE_GETPGRP)
+      retval = getpgrp ();
+#else
+      gripe_not_supported ("getpgrp");
+#endif
+    }
   else
     print_usage ("getpgrp");
-#else
-  gripe_not_supported ("getpgrp");
-#endif
 
   return retval;
 }
 
 DEFUN (getpid, args, ,
   "pid = getpid (): return the process id of the current process")
 {
   double retval = -1.0;
 
-#if defined (HAVE_GETPID)
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = getpid ();
+    {
+#if defined (HAVE_GETPID)
+      retval = getpid ();
+#else
+      gripe_not_supported ("getpid");
+#endif
+    }
   else
     print_usage ("getpid");
-#else
-  gripe_not_supported ("getpid");
-#endif
 
   return retval;
 }
 
 DEFUN (getppid, args, ,
   "pid = getppid (): return the process id of the parent process")
 {
   double retval = -1.0;
 
+  int nargin = args.length ();
+
+  if (nargin == 0)
+    {
 #if defined (HAVE_GETPPID)
+      retval = getppid ();
+#else
+      gripe_not_supported ("getppid");
+#endif
+    }
+  else
+    print_usage ("getppid");
+
+  return retval;
+}
+
+DEFUN (getegid, args, ,
+  "gid = getegid (): return the effective group id of the current process")
+{
+  double retval = -1.0;
+
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = getppid ();
+    {
+#if defined (HAVE_GETEGID)
+      retval = getegid ();
+#else
+      gripe_not_supported ("getegid");
+#endif
+    }
   else
-    print_usage ("getppid");
+    print_usage ("getegid");
+
+  return retval;
+}
+
+DEFUN (getgid, args, ,
+  "gid = getgid (): return the real group id of the current process")
+{
+  double retval = -1.0;
+
+  int nargin = args.length ();
+
+  if (nargin == 0)
+    {
+#if defined (HAVE_GETGID)
+      retval = getgid ();
 #else
-  gripe_not_supported ("getppid");
+      gripe_not_supported ("getgid");
 #endif
+    }
+  else
+    print_usage ("getgid");
 
   return retval;
 }
 
 DEFUN (geteuid, args, ,
   "uid = geteuid (): return the effective user id of the current process")
 {
   double retval = -1.0;
 
-#if defined (HAVE_GETEUID)
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = geteuid ();
+    {
+#if defined (HAVE_GETEUID)
+      retval = geteuid ();
+#else
+      gripe_not_supported ("geteuid");
+#endif
+    }
   else
     print_usage ("geteuid");
-#else
-  gripe_not_supported ("geteuid");
-#endif
 
   return retval;
 }
 
 DEFUN (getuid, args, ,
   "uid = getuid (): return the real user id of the current process")
 {
   double retval = -1.0;
 
-#if defined (HAVE_GETUID)
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = getuid ();
+    {
+#if defined (HAVE_GETUID)
+      retval = getuid ();
+#else
+      gripe_not_supported ("getuid");
+#endif
+    }
   else
     print_usage ("getuid");
-#else
-  gripe_not_supported ("getuid");
-#endif
 
   return retval;
 }
 
 DEFUN (lstat, args, ,
   "[S, ERR, MSG] = lstat (NAME)\n\
 \n\
 Like [S, ERR, MSG] = stat (NAME), but if NAME refers to a symbolic\n\
@@ -423,21 +477,21 @@ DEFUN (mkfifo, args, ,
   return retval;
 }
 
 DEFUN (pipe, args, ,
   "[file_ids, status] = pipe (): create an interprocess channel")
 {
   octave_value_list retval (2, octave_value (-1.0));
 
-#if defined (HAVE_PIPE)
   int nargin = args.length ();
 
   if (nargin == 0)
     {
+#if defined (HAVE_PIPE)
       int fid[2];
 
       if (pipe (fid) >= 0)
 	{
 	  FILE *in_file = fdopen (fid[0], "r");
 	  FILE *out_file = fdopen (fid[1], "w");
 
 	  octave_istdiostream *is
@@ -449,22 +503,22 @@ DEFUN (pipe, args, ,
 	  Matrix file_ids (1, 2);
 
 	  file_ids (0, 0) = octave_stream_list::insert (is);
 	  file_ids (0, 1) = octave_stream_list::insert (os);
 
           retval(0) = file_ids;
 	  retval(1) = 0.0;
 	}	  
+#else
+      gripe_not_supported ("pipe");
+#endif
     }
   else
     print_usage ("pipe");
-#else
-  gripe_not_supported ("pipe");
-#endif
 
   return retval;
 }
 
 DEFUN (stat, args, ,
   "[S, ERR, MSG] = stat (NAME)\n\
 \n\
   Given the name of a file, return a structure S with the following
@@ -575,21 +629,21 @@ DEFUN (waitpid, args, ,
 \n\
   STATUS is:\n\
 \n\
      -1 : if an error occured\n\
     > 0 : the process ID of the child process that exited")
 {
   double retval = -1.0;
 
-#if defined (HAVE_WAITPID)
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
+#if defined (HAVE_WAITPID)
       double pid_num = args(0).double_value ();
   
       if (! error_state)
 	{
 	  if (D_NINT (pid_num) != pid_num)
 	    error ("waitpid: PID must be an integer value");
 	  else
 	    {
@@ -613,22 +667,22 @@ DEFUN (waitpid, args, ,
 			}
 		    }
 		}
 
 	      if (! error_state)
 		retval = waitpid (pid, 0, options);
 	    }
 	}
+#else
+      gripe_not_supported ("waitpid");
+#endif
     }
   else
     print_usage ("waitpid");
-#else
-  gripe_not_supported ("waitpid");
-#endif
 
   return retval;
 }
 
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -750,33 +750,33 @@ do_octave_atexit (void)
 DEFUN (atexit, args, ,
   "atexit (NAME): register NAME as a function to call when Octave exits\n\
 \n\
 Functions are called with no arguments in the reverse of the order in
 which they were registered with atexit()")
 {
   octave_value_list retval;
 
-#if defined (HAVE_ATEXIT) || defined (HAVE_ON_EXIT)
   int nargin = args.length ();
 
   if (nargin == 1)
     {
+#if defined (HAVE_ATEXIT) || defined (HAVE_ON_EXIT)
       string arg = args(0).string_value ();
 
       if (! error_state)
 	octave_atexit_functions.push (arg);
       else
 	error ("atexit: argument must be a string");
+#else
+      gripe_not_supported ("atexit");
+#endif
     }
   else
     print_usage ("atexit");
-#else
-  gripe_not_supported ("atexit");
-#endif
 
   return retval;
 }
 
 DEFUN (octave_config_info, , ,
   "return a structure containing configuration information")
 {
   Octave_map m;
