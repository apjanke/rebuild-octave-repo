# HG changeset patch
# User jwe
# Date 1160496631 0
#      Tue Oct 10 16:10:31 2006 +0000
# Node ID 34f96dd5441b4521c2d8efc5752ba2d524808c7d
# Parent  421d8a903df7d525fc7780611d87300f5bba2b49
[project @ 2006-10-10 16:10:25 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,13 +1,261 @@
+2006-10-10  Bill Denney  <denney@seas.upenn.edu>
+
+	* audio/lin2mu.m, audio/loadaudio.m, audio/mu2lin.m,
+	audio/playaudio.m, audio/record.m, audio/saveaudio.m,
+	audio/setaudio.m, audio/wavread.m, audio/wavwrite.m,
+	control/base/__bodquist__.m, control/base/__freqresp__.m,
+	control/base/are.m, control/base/bode.m, control/base/ctrb.m,
+	control/base/damp.m, control/base/dare.m, control/base/dcgain.m,
+	control/base/dre.m, control/base/impulse.m, control/base/lqg.m,
+	control/base/lsim.m, control/base/lyap.m, control/base/nichols.m,
+	control/base/nyquist.m, control/base/obsv.m, control/base/pzmap.m,
+	control/base/rlocus.m, control/base/step.m, control/base/tzero.m,
+	control/hinf/h2norm.m, control/hinf/h2syn.m,
+	control/hinf/hinfnorm.m, control/hinf/hinfsyn.m,
+	control/hinf/is_dgkf.m, control/hinf/wgt1o.m,
+	control/obsolete/dezero.m, control/system/__sysdefioname__.m,
+	control/system/buildssic.m, control/system/c2d.m,
+	control/system/cellidx.m, control/system/d2c.m,
+	control/system/dmr2d.m, control/system/fir2sys.m,
+	control/system/is_abcd.m, control/system/is_controllable.m,
+	control/system/is_detectable.m, control/system/is_digital.m,
+	control/system/is_observable.m, control/system/is_siso.m,
+	control/system/is_stabilizable.m, control/system/is_stable.m,
+	control/system/jet707.m, control/system/listidx.m,
+	control/system/ord2.m, control/system/parallel.m,
+	control/system/ss.m, control/system/ss2zp.m,
+	control/system/starp.m, control/system/sys2ss.m,
+	control/system/sys2tf.m, control/system/sys2zp.m,
+	control/system/sysadd.m, control/system/sysappend.m,
+	control/system/syschtsam.m, control/system/sysconnect.m,
+	control/system/syscont.m, control/system/sysdimensions.m,
+	control/system/sysdisc.m, control/system/sysdup.m,
+	control/system/sysgetsignals.m, control/system/sysgettsam.m,
+	control/system/sysgroup.m, control/system/sysidx.m,
+	control/system/sysmin.m, control/system/sysmult.m,
+	control/system/sysout.m, control/system/sysprune.m,
+	control/system/sysscale.m, control/system/syssetsignals.m,
+	control/system/syssub.m, control/system/sysupdate.m,
+	control/system/tf.m, control/system/tfout.m,
+	control/system/ugain.m, control/system/zp.m,
+	control/system/zpout.m, control/util/__outlist__.m,
+	control/util/__zgpbal__.m, control/util/prompt.m,
+	control/util/sortcom.m, control/util/strappend.m,
+	deprecated/com2str.m, elfun/acot.m, elfun/acoth.m, elfun/acsc.m,
+	elfun/acsch.m, elfun/asec.m, elfun/asech.m, elfun/cot.m,
+	elfun/coth.m, elfun/csc.m, elfun/csch.m, elfun/lcm.m, elfun/sec.m,
+	elfun/sech.m, finance/fv.m, finance/fvl.m, finance/irr.m,
+	finance/nper.m, finance/npv.m, finance/pmt.m, finance/pv.m,
+	finance/pvl.m, finance/rate.m, finance/vol.m,
+	general/__isequal__.m, general/bitcmp.m, general/bitget.m,
+	general/bitset.m, general/blkdiag.m, general/cart2sph.m,
+	general/cell2mat.m, general/circshift.m, general/cplxpair.m,
+	general/cumtrapz.m, general/deal.m, general/diff.m,
+	general/flipdim.m, general/fliplr.m, general/flipud.m,
+	general/ind2sub.m, general/int2str.m,
+	general/is_duplicate_entry.m, general/isdefinite.m,
+	general/isequal.m, general/isequalwithequalnans.m,
+	general/isscalar.m, general/issquare.m, general/issymmetric.m,
+	general/isvector.m, general/logical.m, general/logspace.m,
+	general/mod.m, general/nargchk.m, general/nextpow2.m,
+	general/perror.m, general/postpad.m, general/prepad.m,
+	general/randperm.m, general/rem.m, general/repmat.m,
+	general/rot90.m, general/rotdim.m, general/shift.m,
+	general/shiftdim.m, general/sph2cart.m, general/strerror.m,
+	general/sub2ind.m, general/trapz.m, general/tril.m,
+	general/triu.m, image/gray.m, image/gray2ind.m, image/hsv2rgb.m,
+	image/image.m, image/imagesc.m, image/ind2gray.m, image/ind2rgb.m,
+	image/loadimage.m, image/ntsc2rgb.m, image/ocean.m,
+	image/rgb2hsv.m, image/rgb2ntsc.m, image/saveimage.m, io/beep.m,
+	linear-algebra/commutation_matrix.m, linear-algebra/cond.m,
+	linear-algebra/cross.m, linear-algebra/dmult.m,
+	linear-algebra/dot.m, linear-algebra/duplication_matrix.m,
+	linear-algebra/krylov.m, linear-algebra/krylovb.m,
+	linear-algebra/logm.m, linear-algebra/norm.m,
+	linear-algebra/null.m, linear-algebra/orth.m,
+	linear-algebra/qzhess.m, linear-algebra/rank.m,
+	linear-algebra/trace.m, linear-algebra/vec.m,
+	linear-algebra/vech.m, miscellaneous/bincoeff.m,
+	miscellaneous/delete.m, miscellaneous/dir.m, miscellaneous/dos.m,
+	miscellaneous/fileattrib.m, miscellaneous/fileparts.m,
+	miscellaneous/flops.m, miscellaneous/fullfile.m,
+	miscellaneous/ispc.m, miscellaneous/isunix.m,
+	miscellaneous/menu.m, miscellaneous/not.m, miscellaneous/popen2.m,
+	miscellaneous/single.m, miscellaneous/unix.m, miscellaneous/ver.m,
+	miscellaneous/xor.m, optimization/glpk.m, optimization/glpkmex.m,
+	optimization/qp.m, optimization/sqp.m, plot/__axis_label__.m,
+	plot/__errplot__.m, plot/__plr1__.m, plot/__plr2__.m,
+	plot/__plr__.m, plot/__plt1__.m, plot/__plt2__.m,
+	plot/__plt2mm__.m, plot/__plt2mv__.m, plot/__plt2ss__.m,
+	plot/__plt2vm__.m, plot/__plt2vv__.m, plot/__pltopt1__.m,
+	plot/__pltopt__.m, plot/bar.m, plot/bottom_title.m, plot/close.m,
+	plot/contour.m, plot/errorbar.m, plot/figure.m, plot/fplot.m,
+	plot/grid.m, plot/hist.m, plot/hold.m, plot/ishold.m,
+	plot/loglogerr.m, plot/mesh.m, plot/meshdom.m, plot/meshgrid.m,
+	plot/multiplot.m, plot/orient.m, plot/polar.m, plot/replot.m,
+	plot/semilogxerr.m, plot/semilogyerr.m, plot/sombrero.m,
+	plot/stairs.m, plot/subplot.m, plot/subwindow.m, plot/title.m,
+	plot/top_title.m, polynomial/compan.m, polynomial/conv.m,
+	polynomial/deconv.m, polynomial/mkpp.m, polynomial/poly.m,
+	polynomial/polyder.m, polynomial/polyderiv.m,
+	polynomial/polyfit.m, polynomial/polygcd.m,
+	polynomial/polyinteg.m, polynomial/polyout.m,
+	polynomial/polyreduce.m, polynomial/polyval.m,
+	polynomial/polyvalm.m, polynomial/ppval.m, polynomial/residue.m,
+	polynomial/roots.m, polynomial/unmkpp.m, quaternion/quaternion.m,
+	set/complement.m, set/create_set.m, set/intersect.m,
+	set/ismember.m, set/setdiff.m, set/setxor.m, set/union.m,
+	set/unique.m, signal/arch_fit.m, signal/arch_rnd.m,
+	signal/arma_rnd.m, signal/autocor.m, signal/autoreg_matrix.m,
+	signal/bartlett.m, signal/blackman.m, signal/detrend.m,
+	signal/diffpara.m, signal/durbinlevinson.m, signal/fftconv.m,
+	signal/fftfilt.m, signal/fftshift.m, signal/filter2.m,
+	signal/freqz.m, signal/hamming.m, signal/hanning.m,
+	signal/hurst.m, signal/ifftshift.m, signal/sinetone.m,
+	signal/sinewave.m, signal/spencer.m, signal/stft.m,
+	signal/synthesis.m, signal/unwrap.m, sparse/gplot.m,
+	sparse/spfun.m, sparse/sprand.m, sparse/sprandn.m,
+	sparse/sprandsym.m, sparse/spstats.m, specfun/beta.m,
+	specfun/betai.m, specfun/betaln.m, specfun/erfinv.m,
+	specfun/gammai.m, specfun/log2.m, specfun/pow2.m,
+	special-matrix/hankel.m, special-matrix/hilb.m,
+	special-matrix/invhilb.m, special-matrix/sylvester_matrix.m,
+	special-matrix/toeplitz.m, special-matrix/vander.m,
+	statistics/base/center.m, statistics/base/cloglog.m,
+	statistics/base/cor.m, statistics/base/corrcoef.m,
+	statistics/base/cov.m, statistics/base/cut.m,
+	statistics/base/gls.m, statistics/base/iqr.m,
+	statistics/base/kendall.m, statistics/base/kurtosis.m,
+	statistics/base/logit.m, statistics/base/mahalanobis.m,
+	statistics/base/mean.m, statistics/base/meansq.m,
+	statistics/base/median.m, statistics/base/moment.m,
+	statistics/base/ols.m, statistics/base/ppplot.m,
+	statistics/base/probit.m, statistics/base/qqplot.m,
+	statistics/base/range.m, statistics/base/ranks.m,
+	statistics/base/run_count.m, statistics/base/skewness.m,
+	statistics/base/spearman.m, statistics/base/statistics.m,
+	statistics/base/std.m, statistics/base/studentize.m,
+	statistics/base/table.m, statistics/base/values.m,
+	statistics/base/var.m, statistics/distributions/betacdf.m,
+	statistics/distributions/betainv.m,
+	statistics/distributions/betapdf.m,
+	statistics/distributions/betarnd.m,
+	statistics/distributions/binocdf.m,
+	statistics/distributions/binoinv.m,
+	statistics/distributions/binopdf.m,
+	statistics/distributions/binornd.m,
+	statistics/distributions/cauchy_cdf.m,
+	statistics/distributions/cauchy_inv.m,
+	statistics/distributions/cauchy_pdf.m,
+	statistics/distributions/cauchy_rnd.m,
+	statistics/distributions/chi2cdf.m,
+	statistics/distributions/chi2inv.m,
+	statistics/distributions/chi2pdf.m,
+	statistics/distributions/chi2rnd.m,
+	statistics/distributions/discrete_cdf.m,
+	statistics/distributions/discrete_inv.m,
+	statistics/distributions/discrete_pdf.m,
+	statistics/distributions/discrete_rnd.m,
+	statistics/distributions/empirical_rnd.m,
+	statistics/distributions/expcdf.m,
+	statistics/distributions/expinv.m,
+	statistics/distributions/exppdf.m,
+	statistics/distributions/exprnd.m,
+	statistics/distributions/fcdf.m, statistics/distributions/finv.m,
+	statistics/distributions/fpdf.m, statistics/distributions/frnd.m,
+	statistics/distributions/gamcdf.m,
+	statistics/distributions/gaminv.m,
+	statistics/distributions/gampdf.m,
+	statistics/distributions/gamrnd.m,
+	statistics/distributions/geocdf.m,
+	statistics/distributions/geoinv.m,
+	statistics/distributions/geopdf.m,
+	statistics/distributions/geornd.m,
+	statistics/distributions/hygecdf.m,
+	statistics/distributions/hygeinv.m,
+	statistics/distributions/hygepdf.m,
+	statistics/distributions/hygernd.m,
+	statistics/distributions/kolmogorov_smirnov_cdf.m,
+	statistics/distributions/laplace_cdf.m,
+	statistics/distributions/laplace_inv.m,
+	statistics/distributions/laplace_pdf.m,
+	statistics/distributions/laplace_rnd.m,
+	statistics/distributions/logistic_cdf.m,
+	statistics/distributions/logistic_inv.m,
+	statistics/distributions/logistic_pdf.m,
+	statistics/distributions/logistic_rnd.m,
+	statistics/distributions/logncdf.m,
+	statistics/distributions/logninv.m,
+	statistics/distributions/lognpdf.m,
+	statistics/distributions/lognrnd.m,
+	statistics/distributions/normcdf.m,
+	statistics/distributions/norminv.m,
+	statistics/distributions/normpdf.m,
+	statistics/distributions/normrnd.m,
+	statistics/distributions/pascal_cdf.m,
+	statistics/distributions/pascal_inv.m,
+	statistics/distributions/pascal_pdf.m,
+	statistics/distributions/pascal_rnd.m,
+	statistics/distributions/poisscdf.m,
+	statistics/distributions/poissinv.m,
+	statistics/distributions/poisspdf.m,
+	statistics/distributions/poissrnd.m,
+	statistics/distributions/stdnormal_cdf.m,
+	statistics/distributions/stdnormal_inv.m,
+	statistics/distributions/stdnormal_pdf.m,
+	statistics/distributions/stdnormal_rnd.m,
+	statistics/distributions/tcdf.m, statistics/distributions/tinv.m,
+	statistics/distributions/tpdf.m, statistics/distributions/trnd.m,
+	statistics/distributions/unifcdf.m,
+	statistics/distributions/unifinv.m,
+	statistics/distributions/unifpdf.m,
+	statistics/distributions/unifrnd.m,
+	statistics/distributions/wblcdf.m,
+	statistics/distributions/wblinv.m,
+	statistics/distributions/wblpdf.m,
+	statistics/distributions/wblrnd.m,
+	statistics/distributions/wienrnd.m, statistics/tests/anova.m,
+	statistics/tests/bartlett_test.m,
+	statistics/tests/chisquare_test_homogeneity.m,
+	statistics/tests/chisquare_test_independence.m,
+	statistics/tests/cor_test.m, statistics/tests/f_test_regression.m,
+	statistics/tests/hotelling_test.m,
+	statistics/tests/hotelling_test_2.m,
+	statistics/tests/kolmogorov_smirnov_test.m,
+	statistics/tests/kolmogorov_smirnov_test_2.m,
+	statistics/tests/kruskal_wallis_test.m, statistics/tests/manova.m,
+	statistics/tests/mcnemar_test.m, statistics/tests/prop_test_2.m,
+	statistics/tests/run_test.m, statistics/tests/sign_test.m,
+	statistics/tests/t_test.m, statistics/tests/t_test_2.m,
+	statistics/tests/t_test_regression.m, statistics/tests/u_test.m,
+	statistics/tests/var_test.m, statistics/tests/welch_test.m,
+	statistics/tests/wilcoxon_test.m, statistics/tests/z_test.m,
+	statistics/tests/z_test_2.m, strings/base2dec.m, strings/blanks.m,
+	strings/deblank.m, strings/dec2base.m, strings/dec2bin.m,
+	strings/dec2hex.m, strings/findstr.m, strings/hex2dec.m,
+	strings/index.m, strings/isletter.m, strings/lower.m,
+	strings/rindex.m, strings/split.m, strings/str2mat.m,
+	strings/str2num.m, strings/strcat.m, strings/strcmpi.m,
+	strings/strfind.m, strings/strjust.m, strings/strmatch.m,
+	strings/strncmp.m, strings/strncmpi.m, strings/strrep.m,
+	strings/strtrunc.m, strings/strvcat.m, strings/substr.m,
+	strings/upper.m, testfun/assert.m, testfun/demo.m,
+	testfun/example.m, testfun/fail.m, testfun/speed.m,
+	testfun/test.m, time/asctime.m, time/calendar.m, time/ctime.m,
+	time/datenum.m, time/datestr.m, time/datevec.m, time/eomday.m,
+	time/etime.m, time/is_leap_year.m:
+	Use print_usage instead of usage.
+
 2006-10-09  David Bateman  <dbateman@free.fr>
 
 	* time/datevec.m: Add additional compatible default parsing strings.
 
-2006-10-09  Bill Denney  <denney@seas.upenn.edu>
+2006-10-09  Bill Denney  <denney@seas.upenn.edu><
 
 	* pkg/pkg.m: Remove trailing "\n" from error messages.
 	Remove compare_versions subfunction.
 
 	* miscellaneous/compare_versions.m: New function to compare
 	version numbers as strings with any boolean operators.
 
 	* miscellaneous/untar.m: Check more rigorously to see if the tar
diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -44,17 +44,17 @@ function y = lin2mu (x, bit)
     else
       bit = 16;
     endif
   elseif (nargin == 2)
     if (bit != 0 && bit != 8 && bit != 16)
       error ("lin2mu: bit must be either 0, 8 or 16");
     endif
   else
-    usage ("y = lin2mu (x, bit)");
+    print_usage ();
   endif
 
   ## Transform real and n-bit format to 16-bit.
   if (bit == 0)
     ## [-1,1] -> [-32768, 32768]
     x = 32768 * x;
   elseif (bit != 16)
     x = 2^(16-bit) .* x;
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -35,17 +35,17 @@
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 10 April 1994
 ## Adapted-By: jwe
 
 function X = loadaudio (name, ext, bit)
 
   if (nargin == 0 || nargin > 3)
-    usage ("loadaudio (name, ext, bit)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     ext = "lin";
   endif
 
   if (nargin < 3)
     bit = 8;
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -35,17 +35,17 @@ function y = mu2lin (x, bit)
   if (nargin == 1)
     ## COMPATIBILITY -- bps defaults to 8 for octave, 0 for Matlab
     bit = 8;
   elseif (nargin == 2)
     if (bit != 0 && bit != 8 && bit != 16)
       error ("mu2lin: bit must be either 0, 8 or 16");
     endif
   else
-    usage ("y = mu2lin (x, bit)");
+    print_usage ();
   endif
 
   ulaw = [32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956, \
 	  23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764, \
 	  15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412, \
 	  11900, 11388, 10876, 10364,  9852,  9340,  8828,  8316, \
 	   7932,  7676,  7420,  7164,  6908,  6652,  6396,  6140, \
 	   5884,  5628,  5372,  5116,  4860,  4604,  4348,  4092, \
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -26,18 +26,16 @@
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 11 April 1994
 ## Adapted-By: jwe
 
 function playaudio (name, ext)
 
-  usage_msg = "playaudio (name, ext)  or  playaudio (X)";
-
   if (nargin == 1 && isvector (name) && ! ischar (name))
     ## play a vector
     [nr, nc] = size (name);
     if (nc != 1)
       if (nr == 1)
         name = name';
         nr = nc;
       else
@@ -56,23 +54,23 @@ function playaudio (name, ext)
     end_unwind_protect
   elseif (nargin >= 1 && ischar (name))
     ## play a file
     if (nargin == 1)
       name = [name, ".lin"];
     elseif (nargin == 2)
       name = [name, ".", ext];
     else
-      usage (usage_msg);
+      print_usage ();
     endif
     if (strcmp (ext, "lin") || strcmp (ext, "raw"))
       system (sprintf ("cat \"%s\" > /dev/dsp", name));
     elseif (strcmp (ext, "mu") || strcmp (ext, "au")
 	    || strcmp (ext, "snd") || strcmp (ext, "ul"))
       system (sprintf ("cat \"%s\" > /dev/audio", name));
     else
       error ("playaudio does not support given extension");
     endif
   else
-    usage (usage_msg);
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/audio/record.m b/scripts/audio/record.m
--- a/scripts/audio/record.m
+++ b/scripts/audio/record.m
@@ -30,17 +30,17 @@
 ## Created: 19 September 1994
 ## Adapted-By: jwe
 
 function X = record (sec, sampling_rate)
 
   if (nargin == 1)
     sampling_rate = 8000;
   elseif (nargin != 2)
-    usage ("X = record (sec [, sampling_rate])");
+    print_usage ();
   endif
 
   unwind_protect
 
     file = tmpnam ();
 
     input ("Please hit ENTER and speak afterwards!\n", 1);
 
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -29,17 +29,17 @@
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 5 September 1994
 ## Adapted-By: jwe
 
 function saveaudio (name, X, ext, bit)
 
   if (nargin < 2 || nargin > 4)
-    usage ("saveaudio (X, name, ext, bit)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     ext = "lin";
   endif
 
   if (nargin < 4)
     bit = 8;
diff --git a/scripts/audio/setaudio.m b/scripts/audio/setaudio.m
--- a/scripts/audio/setaudio.m
+++ b/scripts/audio/setaudio.m
@@ -30,12 +30,12 @@ function setaudio (w_type, value)
 
   if (nargin == 0)
     system ("mixer");
   elseif (nargin == 1)
     system (sprintf ("mixer %s", w_type));
   elseif (nargin == 2)
     system (sprintf ("mixer %s %d", w_type, value));
   else
-    usage ("setaudio (w_type, value)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -44,17 +44,17 @@
 
 function [y, samples_per_sec, bits_per_sample] = wavread (filename, param)
 
   FORMAT_PCM        = 0x0001;   # PCM (8/16/32 bit)
   FORMAT_IEEE_FLOAT = 0x0003;   # IEEE float (32/64 bit)
   BYTEORDER         = "ieee-le";
 
   if (nargin < 1 || nargin > 2)
-    usage ("wavread (filename, param)");
+    print_usage ();
   endif
 
   if (! ischar (filename))
     error ("wavwrite: expecting filename to be a character string");
   endif
 
   # open file for binary reading
   [fid, msg] = fopen (filename, "rb");
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -34,17 +34,17 @@
 ## Author: Michael Zeising <michael.zeising@stud.uni-erlangen.de>
 ## Created: 06 December 2005
 
 function wavwrite (filename, y, samples_per_sec, bits_per_sample)
 
   BYTEORDER = "ieee-le";
   
   if (nargin < 2 || nargin > 4)
-    usage ("wavwrite (filename, y, samples_per_sec, bits_per_sample)");
+    print_usage ();
   endif
 
   ## parse arguments
   if (nargin < 3)
     warning ("wavwrite: sample rate set to 8000 Hz");
     samples_per_sec = 8000;
   endif
 
diff --git a/scripts/control/base/__bodquist__.m b/scripts/control/base/__bodquist__.m
--- a/scripts/control/base/__bodquist__.m
+++ b/scripts/control/base/__bodquist__.m
@@ -50,17 +50,17 @@
 ## response.  Only the way the response is plotted is different between the
 ## these functions.
 ## @end deftypefn
 
 function [f, w, rsys] = __bodquist__ (sys, w, outputs, inputs, rname)
 
   ## check number of input arguments given
   if (nargin != 5)
-    usage ("[f, w] = __bodquist__ (sys, w, outputs, inputs, rname)");
+    print_usage ();
   endif
 
   ## check each argument to see if it's in the correct form
   if (!isstruct(sys))
     error("sys must be a system data structure");
   endif
 
   ## let __freqresp__ determine w if it's not already given
diff --git a/scripts/control/base/__freqresp__.m b/scripts/control/base/__freqresp__.m
--- a/scripts/control/base/__freqresp__.m
+++ b/scripts/control/base/__freqresp__.m
@@ -44,17 +44,17 @@
 ## Created: July 11, 1994
 
 function [ff, w] = __freqresp__ (sys, USEW, w);
 
   ## SYS_INTERNAL accesses members of system data structure
 
   ## Check Args
   if ((nargin < 2) || (nargin > 4))
-    usage ("[ff, w] = __freqresp__ (sys, USEW, w)");
+    print_usage ();
   elseif (USEW & (nargin < 3) )
     error ("USEW = 1 but w was not passed.");
   elseif (USEW & isempty(w))
     warning("USEW = 1 but w is empty; setting USEW=0");
     USEW = 0;
   endif
 
   DIGITAL = is_digital(sys);
diff --git a/scripts/control/base/are.m b/scripts/control/base/are.m
--- a/scripts/control/base/are.m
+++ b/scripts/control/base/are.m
@@ -110,12 +110,12 @@ function x = are (a, b, c, opt)
 
     [d, h] = balance ([a, -b; -c, -a'], opt);
     [u, s] = schur (h, "A");
     u = d * u;
     n1 = n + 1;
     n2 = 2 * n;
     x = u (n1:n2, 1:n) / u (1:n, 1:n);
   else
-    usage ("x = are (a, b, c)")
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/control/base/bode.m b/scripts/control/base/bode.m
--- a/scripts/control/base/bode.m
+++ b/scripts/control/base/bode.m
@@ -104,17 +104,17 @@
 ## Modified by David Clem November 13, 1994
 ## again by A. S. Hodel July 1995 (smart plot range, etc.)
 ## Modified by Kai P. Mueller September 28, 1997 (multiplot mode)
 
 function [mag_r, phase_r, w_r] = bode (sys, w, outputs, inputs, plot_style)
 
   ## check number of input arguments given
   if (nargin < 1 | nargin > 5)
-    usage("[mag,phase,w] = bode(sys[,w,outputs,inputs,plot_style])");
+    print_usage ();
   endif
   if(nargin < 2)
     w = [];
   endif
   if(nargin < 3)
     outputs = [];
   endif
   if(nargin < 4)
diff --git a/scripts/control/base/ctrb.m b/scripts/control/base/ctrb.m
--- a/scripts/control/base/ctrb.m
+++ b/scripts/control/base/ctrb.m
@@ -47,17 +47,17 @@
 function Qs = ctrb (sys, b)
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && isstruct(sys))
     sysupdate(sys,"ss");
     [a,b] = sys2ss(sys);
   else
-    usage("ctrb(sys [, b])")
+    print_usage ();
   endif
 
   if (!is_abcd(a,b))
     Qs = [];
   else
     ## no need to check dimensions, we trust is_abcd().
     [na, ma] = size(a);
     ## using imb avoids name conflict with the "mb" function
diff --git a/scripts/control/base/damp.m b/scripts/control/base/damp.m
--- a/scripts/control/base/damp.m
+++ b/scripts/control/base/damp.m
@@ -31,17 +31,17 @@
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 29, 1997.
 
 function damp (p, tsam)
 
   ## assume a continuous system
   DIGITAL = 0;
   if(nargin < 1 || nargin > 2)
-    usage("damp(p,[ tsamp])")
+    print_usage ();
   endif
   if(isstruct(p))
     if (nargin != 1)
       error("damp: when p is a system, tsamp parameter is not allowed.");
     endif
     [aa, b, c, d, t_samp] = sys2ss(p);
     DIGITAL = is_digital(p);
   else
diff --git a/scripts/control/base/dare.m b/scripts/control/base/dare.m
--- a/scripts/control/base/dare.m
+++ b/scripts/control/base/dare.m
@@ -114,12 +114,12 @@ function x = dare (a, b, q, r, opt)
     s2 = [eye(n), (b/r)*b' ; zeros(n), a'];
     [c,d,s1,s2] = balance(s1,s2,opt);
     [aa,bb,u,lam] = qz(s1,s2,"S");
     u = d*u;
     n1 = n+1;
     n2 = 2*n;
     x = u (n1:n2, 1:n)/u(1:n, 1:n);
   else
-    usage ("x = dare (a, b, q, r {,opt})");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/control/base/dcgain.m b/scripts/control/base/dcgain.m
--- a/scripts/control/base/dcgain.m
+++ b/scripts/control/base/dcgain.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 1, 1997
 
 function gm = dcgain (sys, tol)
 
   if((nargin < 1) || (nargin > 2) || (nargout > 1))
-    usage("[gm, ok] = dcgain(sys[, tol])");
+    print_usage ();
   endif
   if(!isstruct(sys))
     error("dcgain: first argument is not a system data structure.")
   endif
   sys = sysupdate(sys, "ss");
   [aa,bb,cc,dd] = sys2ss(sys);
   if (is_digital(sys))  aa = aa - eye(size(aa));  endif
   if (nargin == 1)  tol = 1.0e-10;  endif
diff --git a/scripts/control/base/dre.m b/scripts/control/base/dre.m
--- a/scripts/control/base/dre.m
+++ b/scripts/control/base/dre.m
@@ -93,17 +93,17 @@
 ## @end example
 ## @end ifinfo
 ## for every @var{i} between 2 and length(@var{tvals}).
 ## @end deftypefn
 
 function [tvals, Plist] = dre (sys, Q, R, Qf, t0, tf, Ptol, maxits)
 
   if(nargin < 6 | nargin > 8 | nargout != 2)
-    usage("[tvals,Plist] = dre(sys,Q,R,Qf,t0,tf{,Ptol})");
+    print_usage ();
   elseif(!isstruct(sys))
     error("sys must be a system data structure")
   elseif(is_digital(sys))
     error("sys must be a continuous time system")
   elseif(!ismatrix(Q) | !ismatrix(R) | !ismatrix(Qf))
     error("Q, R, and Qf must be matrices.");
   elseif(!isscalar(t0) | !isscalar(tf))
     error("t0 and tf must be scalars")
diff --git a/scripts/control/base/impulse.m b/scripts/control/base/impulse.m
--- a/scripts/control/base/impulse.m
+++ b/scripts/control/base/impulse.m
@@ -52,21 +52,21 @@
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 ## modified by
 
 function [y, t] = impulse (sys, inp, tstop, n)
 
   if ((nargin < 1) || (nargin > 4))
-    usage ("[y, u] = impulse (sys, inp, tstop, n)");
+    print_usage ();
   endif
 
   if (nargout > 2)
-    usage ("[y, u] = impulse (sys, inp, tstop, n)");
+    print_usage ();
   endif
 
   if (! isstruct (sys))
     error ("impulse: sys must be a system data structure.");
   endif
 
   if (nargout == 0)
     switch (nargin)
diff --git a/scripts/control/base/lqg.m b/scripts/control/base/lqg.m
--- a/scripts/control/base/lqg.m
+++ b/scripts/control/base/lqg.m
@@ -66,17 +66,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## revised for new system format August 1996
 
 function [K, Q1, P1, Ee, Er] = lqg (sys, Sigw, Sigv, Q, R, input_list)
 
   if ( (nargin < 5) | (nargin > 6))
-    usage("[K,Q1,P1,Ee,Er] = lqg(sys,Sigw, Sigv,Q,R{,input_list})");
+    print_usage ();
 
   elseif(!isstruct(sys) )
     error("sys must be in system data structure");
   endif
 
   DIG = is_digital(sys);
   [A,B,C,D,tsam,n,nz,stname,inname,outname] = sys2ss(sys);
   [n,nz,nin,nout] = sysdimensions(sys);
diff --git a/scripts/control/base/lsim.m b/scripts/control/base/lsim.m
--- a/scripts/control/base/lsim.m
+++ b/scripts/control/base/lsim.m
@@ -36,17 +36,17 @@
 ## Author: David Clem
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1995
 ## modified by John Ingram for system format August 1996
 
 function [y, x] = lsim (sys, u, t, x0)
 
   if((nargin < 3)||(nargin > 4))
-    usage("[y,x] = lsim(sys,u,t[,x0])");
+    print_usage ();
   endif
 
   if(!isstruct(sys))
     error("sys must be in system data structure");
   endif
 
   sys = sysupdate(sys,"ss");
 
diff --git a/scripts/control/base/lyap.m b/scripts/control/base/lyap.m
--- a/scripts/control/base/lyap.m
+++ b/scripts/control/base/lyap.m
@@ -78,17 +78,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function x = lyap (a, b, c)
 
   if (nargin != 3 && nargin != 2)
-    usage ("lyap (a, b {,c})");
+    print_usage ();
   endif
 
   if ((n = issquare(a)) == 0)
     error ("lyap: a is not square");
   endif
 
   if (nargin == 2)
 
diff --git a/scripts/control/base/nichols.m b/scripts/control/base/nichols.m
--- a/scripts/control/base/nichols.m
+++ b/scripts/control/base/nichols.m
@@ -81,17 +81,17 @@
 ## @end ifinfo
 ## and phase information is not computed.
 ## @end deftypefn
 
 function [mag, phase, w] = nichols (sys, w, outputs, inputs)
 
   ## check number of input arguments given
   if (nargin < 1 | nargin > 4)
-    usage("[mag,phase,w] = nichols(sys[,w,outputs,inputs])");
+    print_usage ();
   endif
   if(nargin < 2)
     w = [];
   endif
   if(nargin < 3)
     outputs = [];
   endif
   if(nargin < 4)
diff --git a/scripts/control/base/nyquist.m b/scripts/control/base/nyquist.m
--- a/scripts/control/base/nyquist.m
+++ b/scripts/control/base/nyquist.m
@@ -101,17 +101,17 @@ function [realp, imagp, w] = nyquist (sy
   ## Both bode and nyquist share the same introduction, so the common
   ## parts are in a file called __bodquist__.m.  It contains the part that
   ## finds the number of arguments, determines whether or not the system
   ## is SISO, andd computes the frequency response.  Only the way the
   ## response is plotted is different between the two functions.
 
   ## check number of input arguments given
   if (nargin < 1 | nargin > 5)
-    usage("[realp,imagp,w] = nyquist(sys[,w,outputs,inputs,atol])");
+    print_usage ();
   endif
   if(nargin < 2)
     w = [];
   endif
   if(nargin < 3)
     outputs = [];
   endif
   if(nargin < 4)
diff --git a/scripts/control/base/obsv.m b/scripts/control/base/obsv.m
--- a/scripts/control/base/obsv.m
+++ b/scripts/control/base/obsv.m
@@ -53,17 +53,17 @@
 function Qb = obsv (sys, c)
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && isstruct(sys))
     sysupdate(sys,"ss");
     [a,b,c] = sys2ss(sys);
   else
-    usage("obsv(sys [, c])")
+    print_usage ();
   endif
 
   if (!is_abcd(a,c'))
     Qb = [];
   else
     ## no need to check dimensions, we trust is_abcd().
     [na, ma] = size(a);
     [nc, mc] = size(c);
diff --git a/scripts/control/base/pzmap.m b/scripts/control/base/pzmap.m
--- a/scripts/control/base/pzmap.m
+++ b/scripts/control/base/pzmap.m
@@ -35,17 +35,17 @@
 ## otherwise, @var{pol} and @var{zer} are returned as the 
 ## system poles and zeros (see @command{sys2zp} for a preferable function call).
 ## @end table
 ## @end deftypefn
 
 function [zer, pol]=pzmap (sys)
 
   if(nargin != 1)
-    usage("pzmap(sys) or [zer,pol] = pzmap(sys)");
+    print_usage ();
   elseif (!isstruct(sys));
     error("sys must be in system format");
   endif
 
   [zer,pol] = sys2zp(sys);
 
   ## force to column vectors, split into real, imaginary parts
   zerdata = poldata = [];
diff --git a/scripts/control/base/rlocus.m b/scripts/control/base/rlocus.m
--- a/scripts/control/base/rlocus.m
+++ b/scripts/control/base/rlocus.m
@@ -64,17 +64,17 @@
 ## Author: David Clem
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Updated by Kristi McGowan July 1996 for intelligent gain selection
 ## Updated by John Ingram July 1996 for systems
 
 function [rldata, k_break, rlpol, gvec, real_ax_pts] = rlocus (sys, increment, min_k, max_k)
 
   if (nargin < 1) | (nargin > 4)
-    usage("rlocus(sys[,inc,mink,maxk])");
+    print_usage ();
   endif
 
   ## Convert the input to a transfer function if necessary
 
   [num,den] = sys2tf(sys);               # extract numerator/denom polyomials
   lnum = length(num);      lden = length(den);
   if(lden < 2)
     error(sprintf("length of derivative=%d, doesn't make sense",lden));
diff --git a/scripts/control/base/step.m b/scripts/control/base/step.m
--- a/scripts/control/base/step.m
+++ b/scripts/control/base/step.m
@@ -53,21 +53,21 @@
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 30, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = step (sys, inp, tstop, n)
 
   if ((nargin < 1) || (nargin > 4))
-    usage ("[y, u] = step(sys, inp, tstop, n)");
+    print_usage ();
   endif
 
   if (nargout > 2)
-    usage ("[y, u] = step (sys, inp, tstop, n)");
+    print_usage ();
   endif
 
   if (! isstruct (sys))
     error ("step: sys must be a system data structure.");
   endif
 
   if (nargout == 0)
     switch (nargin)
diff --git a/scripts/control/base/tzero.m b/scripts/control/base/tzero.m
--- a/scripts/control/base/tzero.m
+++ b/scripts/control/base/tzero.m
@@ -68,19 +68,19 @@
 ## A. S. Hodel Aug 1995: allow for MIMO and system data structures
 
 function [zer, gain] = tzero (A, B, C, D)
 
   ## get A,B,C,D and Asys variables, regardless of initial form
   if(nargin == 4)
     Asys = ss(A,B,C,D);
   elseif( (nargin == 1) && (! isstruct(A)))
-    usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
+    print_usage ();
   elseif(nargin != 1)
-    usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
+    print_usage ();
   else
     Asys = A;
     [A,B,C,D] = sys2ss(Asys);
   endif
 
   Ao = Asys;                    # save for leading coefficient
   siso = is_siso(Asys);
   digital = is_digital(Asys);   # check if it's mixed or not
diff --git a/scripts/control/hinf/h2norm.m b/scripts/control/hinf/h2norm.m
--- a/scripts/control/hinf/h2norm.m
+++ b/scripts/control/hinf/h2norm.m
@@ -45,17 +45,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## updated for system data structure by John Ingram November 1996
 
 function h2gain = h2norm (sys)
 
   if((nargin != 1))
-    usage("h2gain = h2norm(sys)");
+    print_usage ();
   elseif(!isstruct(sys))
     error("Sys must be in system data structure");
   end
   dflg = is_digital(sys);
 
   if(!is_stable(sys))
     warning("h2norm: unstable input system; returning Inf");
     h2gain = Inf;
diff --git a/scripts/control/hinf/h2syn.m b/scripts/control/hinf/h2syn.m
--- a/scripts/control/hinf/h2syn.m
+++ b/scripts/control/hinf/h2syn.m
@@ -75,17 +75,17 @@
 ## @end table
 ## @end deftypefn
 
 ## Updated for System structure December 1996 by John Ingram
 
 function [K, gain, Kc, Kf, Pc, Pf] = h2syn (Asys, nu, ny, tol)
 
   if ((nargin < 3) | (nargin > 4))
-    usage("[K,gain, Kc, Kf, Pc, Pf] = h2syn(Asys,nu,ny[,tol])");
+    print_usage ();
   elseif(nargin == 3 )
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny);
   elseif(nargin == 4)
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny,tol);
   endif
 
   if (!chkdgkf )
     disp("h2syn: system does not meet required assumptions")
diff --git a/scripts/control/hinf/hinfnorm.m b/scripts/control/hinf/hinfnorm.m
--- a/scripts/control/hinf/hinfnorm.m
+++ b/scripts/control/hinf/hinfnorm.m
@@ -111,17 +111,17 @@
 ## @end ifinfo
 ## @cite{control}, Int. J. Control, vol 54, no. 5, 1991;
 ## Zhou, Doyle, Glover, @cite{Robust and Optimal Control}, Prentice-Hall, 1996.
 ## @end deftypefn
 
 function [g, gmin, gmax] = hinfnorm (sys, tol, gmin, gmax, ptol)
 
   if((nargin == 0) || (nargin > 4))
-    usage("[g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])");
+    print_usage ();
   elseif(!isstruct(sys))
     error("Sys must be a system data structure");
   endif
 
   ## set defaults where applicable
   if(nargin < 5)
     ptol = 1e-9;        # pole tolerance
   endif
diff --git a/scripts/control/hinf/hinfsyn.m b/scripts/control/hinf/hinfsyn.m
--- a/scripts/control/hinf/hinfsyn.m
+++ b/scripts/control/hinf/hinfsyn.m
@@ -127,17 +127,17 @@
 ##
 ## Revised by Kai P. Mueller April 1998 to solve the general H_infinity
 ## problem using unitary transformations Q (on w and z)
 ## and non-singular transformations R (on u and y).
 
 function [K, g, GW, Xinf, Yinf] = hinfsyn (Asys, nu, ny, gmin, gmax, gtol, ptol, tol)
 
   if( (nargin < 1) | (nargin > 8) )
-    usage("[K,g,GW,Xinf,Yinf] = hinfsyn(Asys,nu,ny,gmin,gmax,gtol,ptol,tol)");
+    print_usage ();
   endif
   ## set default arguments
   if(nargin < 8)
     tol = 200*eps;
   elseif(!is_sample(tol))
     error("tol must be a positive scalar.")
   endif
   if(nargin < 7)
diff --git a/scripts/control/hinf/is_dgkf.m b/scripts/control/hinf/is_dgkf.m
--- a/scripts/control/hinf/is_dgkf.m
+++ b/scripts/control/hinf/is_dgkf.m
@@ -127,17 +127,17 @@
 ##     21   21  21  21
 ##
 ## This transformation together with the algorithm in [1] solves
 ## the general problem (see [2] for example).
 
 function [retval, dgkf_struct] = is_dgkf (Asys, nu, ny, tol)
 
   if (nargin < 3) | (nargin > 4)
-    usage("[retval,dgkf_struct] = is_dgkf(Asys,nu,ny{,tol})");
+    print_usage ();
   elseif (! isscalar(nu) | ! isscalar(ny) )
     error("is_dgkf: arguments 2 and 3 must be scalars")
   elseif (! isstruct(Asys) )
     error("Argument 1 must be a system data structure");
   endif
   if(nargin < 4)
     tol = 200*eps;
   elseif( !is_sample(tol) )
diff --git a/scripts/control/hinf/wgt1o.m b/scripts/control/hinf/wgt1o.m
--- a/scripts/control/hinf/wgt1o.m
+++ b/scripts/control/hinf/wgt1o.m
@@ -52,21 +52,21 @@
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 30, 1997
 
 function wsys = wgt1o (vl, vh, fc)
 
   if (nargin != 3)
-    usage("wsys = wgt1o(vl, vh, fc)");
+    print_usage ();
   endif
 
   if(nargout > 1)
-    usage("wsys = wgt1o(vl, vh, fc)");
+    print_usage ();
   endif
 
   if (vl == vh)
       a = [];
       b = [];
       c = [];
   else
       a = [-2*pi*fc];
diff --git a/scripts/control/obsolete/dezero.m b/scripts/control/obsolete/dezero.m
--- a/scripts/control/obsolete/dezero.m
+++ b/scripts/control/obsolete/dezero.m
@@ -30,17 +30,17 @@
 ##      where my sister did her PhD research)
 
 function t = dezero (s)
 
   ## delete the next line if you're stubbornly going to use dezero.
   error("dezero is no longer supported.");
 
   if (nargin != 1)
-    usage ("dezero (s)");
+    print_usage ();
   elseif (ischar (s))
 
     [nr, nc] = size (s);
     len = nr * nc;
 
     if (len == 0)
       t = s;
     else
diff --git a/scripts/control/system/__sysdefioname__.m b/scripts/control/system/__sysdefioname__.m
--- a/scripts/control/system/__sysdefioname__.m
+++ b/scripts/control/system/__sysdefioname__.m
@@ -35,17 +35,17 @@
 ##   [3] = u_5
 ## )
 ## @end example
 ## @end deftypefn
 
 function ioname = __sysdefioname__ (n, str, m)
 
   if (nargin < 2 | nargin > 3)
-    usage ("ioname = __sysdefioname__ (n, str, m)");
+    print_usage ();
   endif
 
   if (nargin == 2)           m = min(1,n);            endif
 
   ioname = {};
   jj = 1;
   if(n > 0 & m > 0 & m <= n)
     for ii = m:n
diff --git a/scripts/control/system/buildssic.m b/scripts/control/system/buildssic.m
--- a/scripts/control/system/buildssic.m
+++ b/scripts/control/system/buildssic.m
@@ -156,17 +156,17 @@
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function sys = buildssic (Clst, Ulst, Olst, Ilst, s1, s2, s3, s4, s5, s6, s7, s8)
 
   if((nargin < 5) || (nargin > 12))
-    usage("sys = buildssic(Clst,Ulst,Olst,Ilst,s1,s2,s3,s4,s5,s6,s7,s8)");
+    print_usage ();
   endif
   if (nargin >= 5)
     if (!isstruct(s1))
       error("---> s1 must be a structed system.");
     endif
     s1 = sysupdate(s1, "ss");
     [n, nz, m, p] = sysdimensions(s1);
     if (!n && !nz)
diff --git a/scripts/control/system/c2d.m b/scripts/control/system/c2d.m
--- a/scripts/control/system/c2d.m
+++ b/scripts/control/system/c2d.m
@@ -97,17 +97,17 @@
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: October 1993
 ## Updated by John Ingram for system data structure August 1996
 
 function dsys = c2d (sys, opt, T)
   ## parse input arguments
   if(nargin < 1 | nargin > 3)
-    usage("dsys=c2d(sys[,T])");
+    print_usage ();
   elseif (!isstruct(sys))
     error("sys must be a system data structure");
   elseif (nargin == 1)
     opt = "ex";
   elseif (nargin == 2 & !ischar(opt) )
     T = opt;
     opt = "ex";
   endif
diff --git a/scripts/control/system/cellidx.m b/scripts/control/system/cellidx.m
--- a/scripts/control/system/cellidx.m
+++ b/scripts/control/system/cellidx.m
@@ -32,17 +32,17 @@
 ## an error message is returned in @var{errmsg}.  If only one output
 ## argument is requested, then @var{cellidx} prints @var{errmsg} to the
 ## screen and exits with an error.
 ## @end deftypefn
 
 function [idxvec,errmsg]  = cellidx(listvar,strlist)
 
 if(nargin != 2)
-  usage("idxvec = cellidx(listvar,strlist)");
+  print_usage ();
 endif
 
 if(ischar(strlist))
   tmp = strlist;
   strlist = {};
   for kk=1:rows(tmp)
     strlist{kk} = deblank(tmp(kk,:));
   endfor
diff --git a/scripts/control/system/d2c.m b/scripts/control/system/d2c.m
--- a/scripts/control/system/d2c.m
+++ b/scripts/control/system/d2c.m
@@ -62,17 +62,17 @@
 ## Created: August 23, 1994
 ## Updated by John Ingram for system data structure  August 1996
 
 function csys = d2c (sys, opt)
 
   ## SYS_INTERNAL accesses members of system data structure
 
   if( (nargin != 1) & (nargin != 2) )
-    usage("csys = d2c(sys[,tol]), csys = d2c(sys,opt)");
+    print_usage ();
   elseif (!isstruct(sys))
     error("sys must be in system data structure");
   elseif(nargin == 1)
     opt = "log";
     tol = 1e-12;
   elseif(ischar(opt))   # all remaining cases are for nargin == 2
     tol = 1e-12;
     if( !(strcmp(opt,"log") | strcmp(opt,"bi") ) )
diff --git a/scripts/control/system/dmr2d.m b/scripts/control/system/dmr2d.m
--- a/scripts/control/system/dmr2d.m
+++ b/scripts/control/system/dmr2d.m
@@ -72,17 +72,17 @@
 ## @end deftypefn
 
 ## Adapted from c2d by a.s.hodel@eng.auburn.edu
 
 function [dsys, fidx] = dmr2d (sys, idx, sprefix, Ts2, cuflg)
 
   ## parse input arguments
   if(nargin != 4 | nargout > 2)
-    usage("[dsys,fidx] = dmr2d (sys, idx, sprefix, Ts2 {,cuflg})");
+    print_usage ();
 
   elseif (!isstruct(sys))
     error("sys must be in system data structure form");
 
   elseif(!is_digital(sys))
     error("sys must be discrete-time; continuous time passed");
   
   endif
diff --git a/scripts/control/system/fir2sys.m b/scripts/control/system/fir2sys.m
--- a/scripts/control/system/fir2sys.m
+++ b/scripts/control/system/fir2sys.m
@@ -83,17 +83,17 @@
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
 ## adapted from tf2sys july 1996
 
 function sys = fir2sys (num, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
   if (nargin < 1 | nargin > 4)
-    usage ("sys = fir2sys(num [, tsam, inname, outname])");
+    print_usage ();
   endif
 
   ## let tf do the argument checking
   den = [1,zeros(1,length(num)-1)];
 
   ## check sampling interval (if any)
   if (nargin <= 1)
     tsam = 1;           # default
diff --git a/scripts/control/system/is_abcd.m b/scripts/control/system/is_abcd.m
--- a/scripts/control/system/is_abcd.m
+++ b/scripts/control/system/is_abcd.m
@@ -86,13 +86,13 @@ function retval = is_abcd (a, b, c, d)
         disp("B and D row dimensions not compatible.")
         return;
       endif
       if (nc != nd)
         disp("C and D column dimensions not compatible.")
         return;
       endif
     otherwise
-      usage("retval = is_abcd(a [, b, c, d])")
+      print_usage ();
   endswitch
   ## all tests passed, signal ok.
   retval = 1;
 endfunction
diff --git a/scripts/control/system/is_controllable.m b/scripts/control/system/is_controllable.m
--- a/scripts/control/system/is_controllable.m
+++ b/scripts/control/system/is_controllable.m
@@ -61,33 +61,32 @@
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
 
 function [retval, U] = is_controllable (a, b, tol)
 
   deftol = 1;    # assume default tolerance
   if(nargin < 1 | nargin > 3)
-    usage("[retval,U] = %s\n\t%s", "is_controllable(a {, b, tol})", ...
-        "is_controllable(sys{,tol})");
+    print_usage ();
   elseif(isstruct(a))
     ## system structure passed.
     sys = sysupdate(a,"ss");
     [a,bs] = sys2ss(sys);
     if(nargin > 2)
-      usage("[retval,U] = is_controllable(sys{,tol})");
+      print_usage ();
     elseif(nargin == 2)
       tol = b;          % get tolerance
       deftol = 0;
     endif
     b = bs;
   else
     ## a,b arguments sent directly.
     if(nargin < 2)
-      usage("[retval,U] = is_controllable(a {, b ,tol})");
+      print_usage ();
     else
       deftol = 1;
     endif
   endif
 
   ## check for default tolerance
   if(deftol) tol = 1000*eps; endif
 
diff --git a/scripts/control/system/is_detectable.m b/scripts/control/system/is_detectable.m
--- a/scripts/control/system/is_detectable.m
+++ b/scripts/control/system/is_detectable.m
@@ -34,29 +34,29 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_detectable (a, c, tol, dflg)
 
   if( nargin < 1)
-    usage("retval = is_detectable(a , {c , tol, dlfg})");
+    print_usage ();
   elseif(isstruct(a))
     ## system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
-      usage("retval = is_detectable(sys {, tol})");
+      print_usage ();
     endif
     dflg = is_digital(a);
     [a,b,c] = sys2ss(a);
   else
     if ((nargin > 4)||(nargin == 1))
-      usage("retval = is_detectable(a , {c , tol, dflg})");
+      print_usage ();
     endif
     if (~exist("dflg"))
       dflg = 0;
     end
   end
 
   if(~exist("tol"))
     tol = 200*eps;
diff --git a/scripts/control/system/is_digital.m b/scripts/control/system/is_digital.m
--- a/scripts/control/system/is_digital.m
+++ b/scripts/control/system/is_digital.m
@@ -49,17 +49,17 @@ function DIGITAL = is_digital (sys, eflg
 
   switch(nargin)
   case(1),  eflg = 0;
   case(2),
     if( isempty(find(eflg == [0, 1, 2])) )
       error("invalid value of eflg=%d (%e)",eflg,eflg);
     endif
   otherwise,
-    usage("DIGITAL = is_digital(sys{,eflg})");
+    print_usage ();
   endswitch
 
   ## checked for sampled data system (mixed)
   ## discrete system
   sysyd = sysgetsignals(sys,"yd");
   [nn,nz] = sysdimensions(sys);
   cont = sum(sysyd == 0) + nn;
   tsam = sysgettsam(sys);
diff --git a/scripts/control/system/is_observable.m b/scripts/control/system/is_observable.m
--- a/scripts/control/system/is_observable.m
+++ b/scripts/control/system/is_observable.m
@@ -34,27 +34,27 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
 
 function [retval, U] = is_observable (a, c, tol)
 
   if( nargin < 1)
-    usage("[retval,U] = is_observable(a , c {, tol})");
+    print_usage ();
   elseif(isstruct(a))
     ## system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
-      usage("[retval,U] = is_observable(sys {, tol})");
+      print_usage ();
     endif
     [a,b,c] = sys2ss(a);
   elseif(nargin > 3)
-    usage("[retval,U] = is_observable(a , c {, tol})");
+    print_usage ();
   endif
   if(exist("tol"))
     [retval,U] = is_controllable (a', c', tol);
   else
     [retval,U] = is_controllable (a', c');
   endif
 
 endfunction
diff --git a/scripts/control/system/is_siso.m b/scripts/control/system/is_siso.m
--- a/scripts/control/system/is_siso.m
+++ b/scripts/control/system/is_siso.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996, 1998
 
 function  SISO = is_siso (sys)
 
   if (nargin != 1)
-    usage ("SISO = is_siso (sys)");
+    print_usage ();
   elseif (! isstruct (sys))
     error ("input must be a system structure (see ss, tf, zp)");
   endif
 
   [n, nz, m, p] = sysdimensions (sys);
 
   SISO = (m == 1 && p == 1);
 
diff --git a/scripts/control/system/is_stabilizable.m b/scripts/control/system/is_stabilizable.m
--- a/scripts/control/system/is_stabilizable.m
+++ b/scripts/control/system/is_stabilizable.m
@@ -42,30 +42,30 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
 
 function retval = is_stabilizable (a, b, tol, dflg)
 
   if(nargin < 1)        
-    usage("[retval,U] = is_stabilizable(a {, b ,tol, dflg})");
+    print_usage ();
   elseif(isstruct(a))
     ## system passed.
     if(nargin == 2)
       tol = b;          % get tolerance
     elseif(nargin > 2)
-      usage("retval = is_stabilizable(sys{,tol})");
+      print_usage ();
     endif
     disc = is_digital(a);
     [a,b] = sys2ss(a);
   else
     ## a,b arguments sent directly.
     if ((nargin > 4)||(nargin == 1))
-      usage("retval = is_stabilizable(a {, b ,tol, dflg})");
+      print_usage ();
     endif
     if(exist("dflg"))
       disc = dflg;
     else
       disc = 0;
     end
   endif
 
diff --git a/scripts/control/system/is_stable.m b/scripts/control/system/is_stable.m
--- a/scripts/control/system/is_stable.m
+++ b/scripts/control/system/is_stable.m
@@ -43,17 +43,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1993
 ## Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
 ## Updated to simpler form by a.s.hodel 1998
 
 function retval = is_stable (a, tol, disc)
 
-  if( (nargin < 1) | (nargin > 3) )   usage("is_stable(a {,tol,disc})");
+  if( (nargin < 1) | (nargin > 3) )   print_usage ();
   elseif(isstruct(a))
     ## system was passed
     if(nargin < 3)                      disc = is_digital(a);
     elseif(disc != is_digital(a))
       warning("is_stable: disc =%d does not match system",disc)
     endif
     sys = sysupdate(a,"ss");
     a = sys2ss(sys);
diff --git a/scripts/control/system/jet707.m b/scripts/control/system/jet707.m
--- a/scripts/control/system/jet707.m
+++ b/scripts/control/system/jet707.m
@@ -39,20 +39,20 @@
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 28, 1997
 
 function outsys = jet707 ()
 
   if (nargin != 0)
-    usage("outsys = jet707()")
+    print_usage ();
   endif
   if (nargin > 1)
-    usage("outsys = jet707()")
+    print_usage ();
   endif
 
   a = [ -0.46E-01,            0.10681415316, 0.0,   -0.17121680433;
         -0.1675901504661613, -0.515,         1.0,    0.6420630320636088E-02;
          0.1543104215347786, -0.547945,     -0.906, -0.1521689385990753E-02;
          0.0,                 0.0,           1.0,    0.0 ];
   b = [ 0.1602300107479095,      0.2111848453E-02;
         0.8196877780963616E-02, -0.3025E-01;
diff --git a/scripts/control/system/listidx.m b/scripts/control/system/listidx.m
--- a/scripts/control/system/listidx.m
+++ b/scripts/control/system/listidx.m
@@ -33,17 +33,17 @@
 ## argument is requested, then @var{listidx} prints @var{errmsg} to the
 ## screen and exits with an error.
 ## @end deftypefn
 
 function [idxvec,errmsg]  = listidx(listvar,strlist)
   error("listidx: don't use this anymore, ok?\n");
 
 if(nargin != 2)
-  usage("idxvec = listidx(listvar,strlist)");
+  print_usage ();
 endif
 
 if(ischar(strlist))
   tmp = strlist;
   strlist = list();
   for kk=1:rows(tmp)
     strlist(kk) = deblank(tmp(kk,:));
   endfor
diff --git a/scripts/control/system/ord2.m b/scripts/control/system/ord2.m
--- a/scripts/control/system/ord2.m
+++ b/scripts/control/system/ord2.m
@@ -62,20 +62,20 @@
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: September 28, 1997
 
 function outsys = ord2 (nfreq, damp, gain)
 
   ## Updates
 
   if(nargin != 2 & nargin != 3)
-    usage("outsys = ord2(nfreq, damp[, gain])")
+    print_usage ();
   endif
   if (nargout > 1)
-    usage("outsys = ord2(nfreq, damp[, gain])")
+    print_usage ();
   endif
   if (nargin == 2)
     gain = 1.0;
   endif
 
   w = 2.0 * pi * nfreq;
   outsys = ss ([-2.0*w*damp, -w; w, 0], [w; 0], [0, gain]);
 endfunction
diff --git a/scripts/control/system/parallel.m b/scripts/control/system/parallel.m
--- a/scripts/control/system/parallel.m
+++ b/scripts/control/system/parallel.m
@@ -39,17 +39,17 @@
 ## Author: David Clem
 ## Created: August 15, 1994
 ## completely rewritten Oct 1996 a s hodel
 ## SYS_INTERNAL accesses members of system structure
 
 function sysp = parallel (Asys, Bsys)
 
   if(nargin != 2)
-    usage("sysp = parallel(Asys,Bsys)");
+    print_usage ();
   endif
   if(! isstruct(Asys) )
     error("1st input argument is not a system data structure")
   elseif (! isstruct(Bsys) )
     error("2nd input argument is not a system data structure")
   endif
   [Ann,Anz,mA] = sysdimensions(Asys);
   [Bnn,Bnz,mB] = sysdimensions(Bsys);
diff --git a/scripts/control/system/ss.m b/scripts/control/system/ss.m
--- a/scripts/control/system/ss.m
+++ b/scripts/control/system/ss.m
@@ -186,17 +186,17 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 20, 1996
 
 function retsys = ss (a, b, c, d, tsam, n, nz, stname, inname, outname, outlist)
 
   ## Test for correct number of inputs
   if ((nargin < 3) | (nargin > 11))
-    usage("retsys = ss  (a,b,c{,d,tsam,n,nz,stname,inname,outname,outlist})");
+    print_usage ();
   endif
 
   ## verify A, B, C, D arguments
   ## If D is not specified, set it to a zero matrix of appriate dimension.
   if (nargin == 3)          d = zeros(rows(c) , columns(b));
   elseif (isempty(d))       d = zeros(rows(c) , columns(b));      endif
 
   ## Check the dimensions
diff --git a/scripts/control/system/ss2zp.m b/scripts/control/system/ss2zp.m
--- a/scripts/control/system/ss2zp.m
+++ b/scripts/control/system/ss2zp.m
@@ -28,17 +28,17 @@
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Hodel: changed order of output arguments to zer, pol, k. July 1996
 ## a s hodel: added argument checking, allow for pure gain blocks aug 1996
 
 function [zer, pol, k] = ss2zp (a, b, c, d)
 
   if(nargin != 4)
-    usage("[zer,pol,k] = ss2zp(a,b,c,d)");
+    print_usage ();
   endif
 
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1)
     error("ss2tf: Non compatible matrix arguments");
   elseif ( (m != 1) | (p != 1))
     error(["ss2tf: not SISO system: m=",num2str(m)," p=",num2str(p)]);
   endif
diff --git a/scripts/control/system/starp.m b/scripts/control/system/starp.m
--- a/scripts/control/system/starp.m
+++ b/scripts/control/system/starp.m
@@ -49,17 +49,17 @@
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: May 1998
 
 function sys = starp (P, K, ny, nu);
 
   if((nargin != 2) && (nargin != 4))
-    usage("sys = starp(P, K, ny, nu)");
+    print_usage ();
   endif
   if (!isstruct(P))
     error("---> P must be in system data structure");
   endif
   if (!isstruct(K))
     error("---> K must be in system data structure");
   endif
 
diff --git a/scripts/control/system/sys2ss.m b/scripts/control/system/sys2ss.m
--- a/scripts/control/system/sys2ss.m
+++ b/scripts/control/system/sys2ss.m
@@ -74,22 +74,22 @@
 
 ## Author: David Clem
 ## Created: August 19, 1994
 ## Updates by John Ingram July 14, 1996
 
 function [a, b, c, d, tsam, n, nz, stname, inname, outname, yd] = sys2ss (sys)
 
   if(nargin != 1)
-    usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
+    print_usage ();
   endif
 
   if (nargout > 11)
     warning(["sys2ss: ",num2str(nargout)," out arguments exceeds max=11"])
-    usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
+    print_usage ();
   endif
 
   if( ! isstruct(sys) )
     error("input argument must be a system data structure");
   endif
 
   sys = sysupdate(sys,"ss");        # make sure state space data is there
   [n,nz,m,p] = sysdimensions(sys);
diff --git a/scripts/control/system/sys2tf.m b/scripts/control/system/sys2tf.m
--- a/scripts/control/system/sys2tf.m
+++ b/scripts/control/system/sys2tf.m
@@ -35,17 +35,17 @@
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: June 24, 1994
 ## modified to make sys2tf by A. S. Hodel Aug 1995
 ## modified again for updated system format by John Ingram July 1996
 
 function [num, den, tsam, inname, outname] = sys2tf (Asys)
 
   if(nargin != 1)
-    usage("[num,den,tsam,inname,outname] = sys2tf(Asys)");
+    print_usage ();
   endif
 
   if( !isstruct(Asys))
     error("Asys must be a system data structure (see ss, tf, zp)");
   elseif (! is_siso(Asys) )
     [n, nz, m, p] = sysdimensions(Asys);
     error(["system is not SISO (",num2str(m)," inputs, ...
         ", num2str(p)," outputs"]);
diff --git a/scripts/control/system/sys2zp.m b/scripts/control/system/sys2zp.m
--- a/scripts/control/system/sys2zp.m
+++ b/scripts/control/system/sys2zp.m
@@ -37,17 +37,17 @@
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 15, 1996
 
 function [zer, pol, k, tsam, inname, outname] = sys2zp (sys)
 
   if(nargin != 1)
-    usage("[zer,pol,k,tsam,inname,outname] = sys2zp(sys)");
+    print_usage ();
   elseif( !isstruct(sys))
     error("sysconnect: sys must be in system data structure form")
   elseif (! is_siso(sys) )
     [n, nz, m, p] = sysdimensions(sys);
     error(["system is not SISO (",num2str(m)," inputs, ...
         ", num2str(p)," outputs"]);
   endif
 
diff --git a/scripts/control/system/sysadd.m b/scripts/control/system/sysadd.m
--- a/scripts/control/system/sysadd.m
+++ b/scripts/control/system/sysadd.m
@@ -42,17 +42,17 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## Updated for variable number of arguments July 1999 A. S. Hodel
 
 function sys = sysadd (varargin)
 
   if(nargin < 1)
-    usage("sysadd: sys = sysysadd(Gsys{,Hsys, ...})");
+    print_usage ();
   endif
 
   ## collect all arguments
   arglist = {};
   for kk=1:nargin
     arglist{kk} = varargin{kk};
     if(!isstruct(arglist{kk}))
       error("sysadd: argument %d is not a data structure",kk);
diff --git a/scripts/control/system/sysappend.m b/scripts/control/system/sysappend.m
--- a/scripts/control/system/sysappend.m
+++ b/scripts/control/system/sysappend.m
@@ -79,17 +79,17 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = sysappend (sys, b, c, d, outname, inname, yd)
 
   ## check input arguments
   if ( (nargin < 2) | (nargin > 7) | (!isstruct(sys)))
-    usage("retsys = sysappend(sys,b,c[,d,outname,inname,yd]) ");
+    print_usage ();
   elseif(!isstruct(sys))
     error("sys must be a system data structure");
   endif
 
   ## default system type must be state space form
   [Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,Ayd] = sys2ss(sys);
   [Ann,Anz,Am,Ap] = sysdimensions(sys);
 
diff --git a/scripts/control/system/syschtsam.m b/scripts/control/system/syschtsam.m
--- a/scripts/control/system/syschtsam.m
+++ b/scripts/control/system/syschtsam.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = syschtsam (sys, tsam)
 
   if (nargin != 2)
-    usage ("retsys = syschtsam (sys, tsam)");
+    print_usage ();
   elseif (! isstruct (sys))
     error ("sys must be in system data structure form");
   elseif (! isscalar (tsam))
     disp ("syschtsam:")
     tsam
     error ("tsam must be a scalar")
   elseif (! (is_sample (tsam) || tsam <= 0))
     error ("tsam must be real, scalar, and greater than zero");
diff --git a/scripts/control/system/sysconnect.m b/scripts/control/system/sysconnect.m
--- a/scripts/control/system/sysconnect.m
+++ b/scripts/control/system/sysconnect.m
@@ -71,17 +71,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 
 function sys = sysconnect (sys, output_list, input_list, order, tol)
 
   if( (nargin < 3) | (nargin > 5) )
-    usage("retsys = sysconnect(sys,output_list,input_list[,order,tol])");
+    print_usage ();
   endif
 
   ## check order
   if(nargin <= 3)
     order = 0;
   elseif( (order != 0) & (order != 1) )
     error("sysconnect: order must be either 0 or 1")
   endif
diff --git a/scripts/control/system/syscont.m b/scripts/control/system/syscont.m
--- a/scripts/control/system/syscont.m
+++ b/scripts/control/system/syscont.m
@@ -41,17 +41,17 @@
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function [csys, Acd, Ccd] = syscont (sys)
 
   if (nargin != 1)
-    usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
+    print_usage ();
   elseif (!isstruct(sys))
     error("sys must be in system data structure form");
   endif
 
   sys = sysupdate (sys, "ss");
   [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
diff --git a/scripts/control/system/sysdimensions.m b/scripts/control/system/sysdimensions.m
--- a/scripts/control/system/sysdimensions.m
+++ b/scripts/control/system/sysdimensions.m
@@ -64,19 +64,19 @@
 ## @math{yd(ii) = 0} if output @var{ii} is continous
 ## @end table
 ## @seealso{sysgetsignals, sysgettsam}
 ## @end deftypefn
 
 function [n, nz, m, p, yd] = sysdimensions (sys, opt)
 
   if(nargout > 5 | nargin < 1 | nargin > 2)
-    usage("[n,nz,m,p[,yd]] = sysdimensions(sys{,opt})");
+    print_usage ();
   elseif(!isstruct(sys))
-    usage("[n,nz,m,p] = sysdimensions(sys)");
+    print_usage ();
   elseif(nargin == 1)
     opt = "all";
   endif
 
   n = sys.n;
   nz = sys.nz;
   m = length(sysgetsignals(sys,"in"));
   p = length(sysgetsignals(sys,"out"));
diff --git a/scripts/control/system/sysdisc.m b/scripts/control/system/sysdisc.m
--- a/scripts/control/system/sysdisc.m
+++ b/scripts/control/system/sysdisc.m
@@ -36,17 +36,17 @@
 ## Connections from continuous states to discrete states and discrete.
 ## outputs, respectively.
 ## @end table
 ## @end deftypefn
 
 function [dsys, Adc, Cdc] = sysdisc (sys)
 
   if (nargin != 1)
-    usage("[dsys,Adc,Cdc] = sysdisc(sys)");
+    print_usage ();
   elseif (!isstruct(sys))
     error("sys must be in system data structure form");
   endif
 
   sys = sysupdate (sys, "ss");
   [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
diff --git a/scripts/control/system/sysdup.m b/scripts/control/system/sysdup.m
--- a/scripts/control/system/sysdup.m
+++ b/scripts/control/system/sysdup.m
@@ -57,17 +57,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 
 function retsys = sysdup (Asys, output_list, input_list)
 
   if( nargin != 3)
-    usage("retsys = sysdup(Asys,output_list,input_list)");
+    print_usage ();
   endif
 
   if( !isstruct(Asys))
     error("Asys must be a system data structure (see ss, tf, or zp)")
   endif
 
   Asys = sysupdate(Asys,"ss");
   [nn,nz,mm,pp] = sysdimensions(Asys);
diff --git a/scripts/control/system/sysgetsignals.m b/scripts/control/system/sysgetsignals.m
--- a/scripts/control/system/sysgetsignals.m
+++ b/scripts/control/system/sysgetsignals.m
@@ -142,19 +142,19 @@
 ## @end example
 ## @end deftypefn
 
 function [stname, inname, outname, yd] = sysgetsignals (sys, sigid, signum, strflg)
 
   ## Adapted from ss
 
   if(nargin < 1 | nargin > 4 | nargout > 4)
-    usage("[stname{,inname,outname,yd}] = sysgetsignals(sys{,sigid,signum})")
+    print_usage ();
   elseif(nargin > 1 & nargout > 1)
-    usage("sig = sysgetsignals(sys,sigid{,signum,strflg})")
+    print_usage ();
   elseif( ! isstruct(sys) )
     error("input argument must be a system data structure");
   endif
   if(nargin < 4)  strflg = 0; endif
   if(nargin == 1)
     sys = sysupdate(sys,"ss");          #make sure ss is up to date
     stname = sysgetsignals(sys,"st");
     inname = sysgetsignals(sys,"in");
diff --git a/scripts/control/system/sysgettsam.m b/scripts/control/system/sysgettsam.m
--- a/scripts/control/system/sysgettsam.m
+++ b/scripts/control/system/sysgettsam.m
@@ -20,14 +20,14 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sysgettsam (@var{sys})
 ## Return the sampling time of the system @var{sys}.
 ## @end deftypefn
 
 function T = sysgettsam (sys)
 
   if (! isstruct (sys))
-    usage ("T = sysgettsam (sys)");
+    print_usage ();
   endif
 
   T = sys.tsam;
 
 endfunction
diff --git a/scripts/control/system/sysgroup.m b/scripts/control/system/sysgroup.m
--- a/scripts/control/system/sysgroup.m
+++ b/scripts/control/system/sysgroup.m
@@ -55,17 +55,17 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram July 1996
 ## A. S. Hodel: modified for variable number of arguments 1999
 
 function sys = sysgroup (varargin)
 
   if(nargin < 1)
-    usage("sys = sysgroup(Asys{,Bsys,...})");
+    print_usage ();
   endif
 
   ## collect all arguments
   arglist = {};
   for kk=1:nargin
     arglist(kk) = varargin{kk};
     if(!isstruct(arglist{kk}))
 	error("sysgroup: argument %d is not a data structure",kk);
diff --git a/scripts/control/system/sysidx.m b/scripts/control/system/sysidx.m
--- a/scripts/control/system/sysidx.m
+++ b/scripts/control/system/sysidx.m
@@ -23,17 +23,17 @@
 ## inputs given a system data structure @var{sys}, a signal type to be
 ## selected @var{sigtype} (@code{"in"}, @code{"out"}, @code{"st"}), and
 ## a list of desired signal names @var{signamelist}.
 ## @end deftypefn
 
 function idxvec = sysidx (sys, sigtype, signamelist)
 
   if (nargin != 3)
-    usage ("idxvec = sysidx (sys, sigtype, signamelist)");
+    print_usage ();
   elseif (! isstruct (sys))
     error ("sys must be a system data structure");
   elseif (! ischar (sigtype))
     error ("sigtype must be a string");
   elseif (rows (sigtype) != 1)
     [nr, nc] = size (sigtype);
     error ("sigtype (%d x %d) must be a single string", nr, nc);
   endif
diff --git a/scripts/control/system/sysmin.m b/scripts/control/system/sysmin.m
--- a/scripts/control/system/sysmin.m
+++ b/scripts/control/system/sysmin.m
@@ -50,17 +50,17 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 
 function [retsys, nc, no, cflg, oflg] = sysmin (sys, flg)
 
   switch(nargin)
   case(1), flg = 0;
   case(2), jnk = flg;    # dummy operation
   otherwise,
-    usage("[retsys,nc,no] = sysmin(sys{,flg})");
+    print_usage ();
   endswitch
   dflg = is_digital(sys,2);
   [n,nz,m,p] = sysdimensions(sys);
   if(n*nz > 0)
     # both continuous and discrete states
     [aa,bb,cc,dd,tsam,n,nz,stnam,innam,outnam,yd] = sys2ss(sys);
     crng = 1:n;
     drng = n+(1:nz);
diff --git a/scripts/control/system/sysmult.m b/scripts/control/system/sysmult.m
--- a/scripts/control/system/sysmult.m
+++ b/scripts/control/system/sysmult.m
@@ -35,17 +35,17 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## updated for variable number of arguments by A. S. Hodel July 1999
 
 function sys = sysmult (varargin)
 
   if(nargin < 1)
-    usage("sysmult: sys = sysmult(Asys{,Bsys,...})");
+    print_usage ();
   endif
 
   ## collect all arguments
   arglist = {};
   for kk=1:nargin
     arglist{kk} = varargin{kk};
     if(!isstruct(arglist{kk}))
       error("sysadd: argument %d is not a data structure",kk);
diff --git a/scripts/control/system/sysout.m b/scripts/control/system/sysout.m
--- a/scripts/control/system/sysout.m
+++ b/scripts/control/system/sysout.m
@@ -41,17 +41,17 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: 1995-1996
 
 function retsys = sysout (sys, opt)
 
   if( (nargin < 1) || (nargin > 2) )
-    usage("sysout(sys[,opt])");
+    print_usage ();
   endif
 
   if(isempty(sys))
     retsys = sys;
     warning("sysout: empty system")
     return;
   endif
 
diff --git a/scripts/control/system/sysprune.m b/scripts/control/system/sysprune.m
--- a/scripts/control/system/sysprune.m
+++ b/scripts/control/system/sysprune.m
@@ -56,17 +56,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## Updated by John Ingram 7-15-96
 
 function sys = sysprune (sys, output_idx, input_idx, state_idx)
 
   if( nargin < 3 | nargin > 4  )
-    usage("retsys = sysprune(sys,output_idx,input_idx{,state_idx})");
+    print_usage ();
   elseif(nargin < 4)
     state_idx = [];
   endif
 
   ## default: no action
   [nn,nz,mm,pp] = sysdimensions(sys);
   if(isempty(output_idx)) output_idx = 1:pp; endif
   if(isempty(input_idx)) input_idx = 1:mm; endif
diff --git a/scripts/control/system/sysscale.m b/scripts/control/system/sysscale.m
--- a/scripts/control/system/sysscale.m
+++ b/scripts/control/system/sysscale.m
@@ -55,17 +55,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: August 1995
 ## modified by John Ingram 7-15-96
 
 function sys = sysscale (sys, outscale, inscale, outname, inname)
 
   if( (nargin < 3) || (nargin > 5)  )
-    usage("retsys = sysscale(Asys,output_list,input_list{,inname,outname})");
+    print_usage ();
   elseif (!isstruct(sys))
     error("sys must be a structured system");
   endif
 
   [nn,nz,mm,pp] = sysdimensions(sys);
 
   ## check for omitted scales
   if(isempty(outscale))    outscale = eye(pp);     endif
diff --git a/scripts/control/system/syssetsignals.m b/scripts/control/system/syssetsignals.m
--- a/scripts/control/system/syssetsignals.m
+++ b/scripts/control/system/syssetsignals.m
@@ -91,17 +91,17 @@
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: August 1996
 
 function retsys = syssetsignals (sys, opt, names, sig_idx)
 
   if (nargin < 3 | nargin > 4)
-    usage("retsys=syssetsignals(sys,opt,names{,sig_idx})");
+    print_usage ();
   elseif (!isstruct(sys))
     error("sys must be a system data structure");
   elseif (isempty(opt))
     opt = "out";
   elseif( ! ischar(opt)  )
     error("opt must be a string");
   elseif( ! (strcmp(opt,"out") + strcmp(opt,"yd") + ...
     strcmp(opt,"in") + strcmp(opt,"st") ) )
diff --git a/scripts/control/system/syssub.m b/scripts/control/system/syssub.m
--- a/scripts/control/system/syssub.m
+++ b/scripts/control/system/syssub.m
@@ -43,17 +43,17 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 1996
 ## updated for variable numbers of input arguments by July 1999 A. S. Hodel
 
 function sys = syssub (varargin)
 
   if(nargin < 1)
-    usage("syssub: sys = syssub(Gsys{,Hsys,...})");
+    print_usage ();
   endif
 
   ## collect all arguments
   arglist = {};
   for kk=1:nargin
     arglist{kk} = varargin{kk};
     if(!isstruct(arglist{kk}))
       error("syssub: argument %d is not a data structure",kk);
diff --git a/scripts/control/system/sysupdate.m b/scripts/control/system/sysupdate.m
--- a/scripts/control/system/sysupdate.m
+++ b/scripts/control/system/sysupdate.m
@@ -53,17 +53,17 @@
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 9, 1996
 
 function sys = sysupdate (sys, opt)
 
   ## check for correct number of inputs
   if (nargin != 2)
-    usage("newsys = sysupdate(sys,opt)");
+    print_usage ();
   elseif(! isstruct(sys) )
    error("1st argument must be system data structure")
   elseif(! (strcmp(opt,"tf") + strcmp(opt,"zp") + ...
         strcmp(opt,"ss") + strcmp(opt,"all")) )
     error("2nd argument must be \"tf\", \"zp\", \"ss\", or \"all\"");
   endif
 
   ## check to make sure not trying to make a SISO system out of a MIMO sys
diff --git a/scripts/control/system/tf.m b/scripts/control/system/tf.m
--- a/scripts/control/system/tf.m
+++ b/scripts/control/system/tf.m
@@ -57,17 +57,17 @@
 ## Created: July 29, 1994
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
 
 function outsys = tf (num, den, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
   if ((nargin < 2) || (nargin > 5))
-    usage ("outsys = tf (num, den [, tsam, inname, outname])");
+    print_usage ();
     return
   endif
 
   ## check input format
   if( ! ( (isvector(num) || isscalar(num)) && ...
         (isvector(den) || isscalar(den))) )
     error(["num (",num2str(rows(num)),"x",num2str(columns(num)), ...
       ") and den (",num2str(rows(den)),"x",num2str(columns(den)), ...
diff --git a/scripts/control/system/tfout.m b/scripts/control/system/tfout.m
--- a/scripts/control/system/tfout.m
+++ b/scripts/control/system/tfout.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function tfout (num, denom, x)
 
   if (nargin < 2 ) | (nargin > 3) | (nargout != 0 )
-    usage("tfout(num,denom[,x])");
+    print_usage ();
   endif
 
   if ( (!isvector(num)) | (!isvector(denom)) )
     error("tfout: first two argument must be vectors");
   endif
 
   if (nargin == 2)
     x = "s";
diff --git a/scripts/control/system/ugain.m b/scripts/control/system/ugain.m
--- a/scripts/control/system/ugain.m
+++ b/scripts/control/system/ugain.m
@@ -28,13 +28,13 @@
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function outsys = ugain (n)
 
   if (nargin != 1 || nargout > 1)
-    usage ("outsys = ugain(n)");
+    print_usage ();
   endif
   outsys = ss ([], [], [], eye (n));
 
 endfunction
diff --git a/scripts/control/system/zp.m b/scripts/control/system/zp.m
--- a/scripts/control/system/zp.m
+++ b/scripts/control/system/zp.m
@@ -55,17 +55,17 @@
 ## @end deftypefn
 
 ## Modified by John Ingram  July 20, 1996
 
 function outsys = zp (zer, pol, k, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
   if ((nargin < 3) || (nargin > 6))
-    usage("outsys = zp(zer,pol,k[,tsam,inname,outname])");
+    print_usage ();
   endif
 
   ## check input format
   if( ! (isvector(zer) | isempty(zer) ) )
     error("zer must be a vector or empty");
   endif
   if(!isempty(zer))
     zer = reshape(zer,1,length(zer));           # make it a row vector
diff --git a/scripts/control/system/zpout.m b/scripts/control/system/zpout.m
--- a/scripts/control/system/zpout.m
+++ b/scripts/control/system/zpout.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function zpout (zer, pol, k, x)
 
   if (nargin < 3 ) | (nargin > 4) | (nargout != 0 )
-    usage("zpout(zer,pol,k[,x])");
+    print_usage ();
   endif
 
   if( !(isvector(zer) | isempty(zer)) | !(isvector(pol) | isempty(pol)) )
     error("zer, pol must be vectors or empty");
   endif
 
   if(!isscalar(k))
     error("zpout: argument k must be a scalar.")
diff --git a/scripts/control/util/__outlist__.m b/scripts/control/util/__outlist__.m
--- a/scripts/control/util/__outlist__.m
+++ b/scripts/control/util/__outlist__.m
@@ -43,17 +43,17 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: December 1995
 
 function str_val = __outlist__ (name_list, tabchar, yd, ilist)
 
   if( nargin < 1 | nargin > 4 )
-    usage("str_val = outlist(x[,tabchar,yd,ilist])");
+    print_usage ();
   endif
 
   m = length(name_list);
   if(nargin < 4)
     ilist = 1:m;
   endif
   if(nargin ==1)
     tabchar = "";
diff --git a/scripts/control/util/__zgpbal__.m b/scripts/control/util/__zgpbal__.m
--- a/scripts/control/util/__zgpbal__.m
+++ b/scripts/control/util/__zgpbal__.m
@@ -41,17 +41,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 24, 1992
 ## Conversion to Octave by R. Bruce Tenison July 3, 1994
 
 function retsys = __zgpbal__ (Asys)
 
   if( (nargin != 1) | (!isstruct(Asys)))
-    usage("retsys = __zgpbal__ (Asys)");
+    print_usage ();
   endif
 
   Asys = sysupdate(Asys,"ss");
   [a,b,c,d] = sys2ss(Asys);
 
   [nn,mm,pp] = abcddim(a,b,c,d);
 
   np1 = nn+1;
diff --git a/scripts/control/util/prompt.m b/scripts/control/util/prompt.m
--- a/scripts/control/util/prompt.m
+++ b/scripts/control/util/prompt.m
@@ -33,17 +33,17 @@
 
 ## Author: David Clem
 ## Created: August 15, 1994
 ## Modified A. S. Hodel June 1995
 
 function prompt (str)
 
   if (nargin > 1)
-    usage ("prompt ([str])");
+    print_usage ();
   elseif (nargin == 0)
     str = "\n ---- Press a key to continue ---";
   elseif (! ischar (str) )
     error ("prompt: input must be a string");
   endif
 
   disp (str);
   fflush (stdout);
diff --git a/scripts/control/util/sortcom.m b/scripts/control/util/sortcom.m
--- a/scripts/control/util/sortcom.m
+++ b/scripts/control/util/sortcom.m
@@ -49,17 +49,17 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function [yy, idx] = sortcom (xx, opt)
 
   if( nargin < 1 | nargin > 2 )
-     usage("yy = sortcom(xx[,opt]");
+     print_usage ();
   elseif( !(isvector(xx) | isempty(xx) ))
     error("sortcom: first argument must be a vector");
   endif
 
   if(nargin == 1)         opt = "re";
   else
     if (!ischar(opt))
       error("sortcom: second argument must be a string");
diff --git a/scripts/control/util/strappend.m b/scripts/control/util/strappend.m
--- a/scripts/control/util/strappend.m
+++ b/scripts/control/util/strappend.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} strappend (@var{strlist}, @var{suffix})
 ## Append string @var{suffix} to each string in the list @var{strlist}.
 ## @end deftypefn
 
 function retval = strappend (strlist, suffix);
 
   if (nargin != 2 || nargout > 1)
-    usage ("retval = strappend (strlist, suffix)");
+    print_usage ();
   elseif (! is_signal_list (strlist))
     error ("strlist must be a list of strings (see is_signal_list)");
   elseif (! (ischar (suffix) && rows (suffix) == 1))
     error ("suffix must be a single string");
   endif
 
   retval = {};
 
diff --git a/scripts/deprecated/com2str.m b/scripts/deprecated/com2str.m
--- a/scripts/deprecated/com2str.m
+++ b/scripts/deprecated/com2str.m
@@ -31,17 +31,17 @@
 ## 0 (default):            -1, 0, 1,   1i,   1 + 0.5i
 ## 1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
 ## @end table
 ## @end deftypefn
 
 function retval = com2str (zz, flg)
 
   if (nargin < 1 || nargin > 2)
-    usage ("com2str (zz, flg)");
+    print_usage ();
   endif
   if (nargin == 1)
     flg = 0;
   endif
 
   if (! (isscalar (zz) && isscalar (flg)))
     error ("com2str: arguments must be a scalar");
   endif
diff --git a/scripts/elfun/acot.m b/scripts/elfun/acot.m
--- a/scripts/elfun/acot.m
+++ b/scripts/elfun/acot.m
@@ -22,14 +22,14 @@
 ## Compute the inverse cotangent of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = acot (z)
 
   if (nargin != 1)
-    usage ("acot (z)");
+    print_usage ();
   endif
 
   w = atan (1./z);
 
 endfunction
diff --git a/scripts/elfun/acoth.m b/scripts/elfun/acoth.m
--- a/scripts/elfun/acoth.m
+++ b/scripts/elfun/acoth.m
@@ -22,14 +22,14 @@
 ## Compute the inverse hyperbolic cotangent of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = acoth (z)
 
   if (nargin != 1)
-    usage ("acoth (z)");
+    print_usage ();
   endif
 
   w = atanh (1 ./ z);
 
 endfunction
diff --git a/scripts/elfun/acsc.m b/scripts/elfun/acsc.m
--- a/scripts/elfun/acsc.m
+++ b/scripts/elfun/acsc.m
@@ -22,14 +22,14 @@
 ## Compute the inverse cosecant of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = acsc (z)
 
   if (nargin != 1)
-    usage ("acsc (z)");
+    print_usage ();
   endif
 
   w = asin (1 ./ z);
 
 endfunction
diff --git a/scripts/elfun/acsch.m b/scripts/elfun/acsch.m
--- a/scripts/elfun/acsch.m
+++ b/scripts/elfun/acsch.m
@@ -22,14 +22,14 @@
 ## Compute the inverse hyperbolic cosecant of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = acsch (z)
 
   if (nargin != 1)
-    usage ("acsch (z)");
+    print_usage ();
   endif
 
   w = asinh (1 ./ z);
 
 endfunction
diff --git a/scripts/elfun/asec.m b/scripts/elfun/asec.m
--- a/scripts/elfun/asec.m
+++ b/scripts/elfun/asec.m
@@ -22,14 +22,14 @@
 ## Compute the inverse secant of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = asec (z)
 
   if (nargin != 1)
-    usage ("asec (z)");
+    print_usage ();
   endif
 
   w = acos (1 ./ z);
 
 endfunction
diff --git a/scripts/elfun/asech.m b/scripts/elfun/asech.m
--- a/scripts/elfun/asech.m
+++ b/scripts/elfun/asech.m
@@ -22,14 +22,14 @@
 ## Compute the inverse hyperbolic secant of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = asech (z)
 
   if (nargin != 1)
-    usage ("acosh (z)");
+    print_usage ();
   endif
 
   w = acosh (1 ./ z);
 
 endfunction
diff --git a/scripts/elfun/cot.m b/scripts/elfun/cot.m
--- a/scripts/elfun/cot.m
+++ b/scripts/elfun/cot.m
@@ -22,14 +22,14 @@
 ## Compute the cotangent of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = cot (z)
 
   if (nargin != 1)
-    usage ("cot (z)");
+    print_usage ();
   endif
 
   w = 1 ./ tan(z);
 
 endfunction
diff --git a/scripts/elfun/coth.m b/scripts/elfun/coth.m
--- a/scripts/elfun/coth.m
+++ b/scripts/elfun/coth.m
@@ -22,14 +22,14 @@
 ## Compute the hyperbolic cotangent of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = coth (z)
 
   if (nargin != 1)
-    usage ("coth (z)");
+    print_usage ();
   endif
 
   w = 1 ./ tanh (z);
 
 endfunction
diff --git a/scripts/elfun/csc.m b/scripts/elfun/csc.m
--- a/scripts/elfun/csc.m
+++ b/scripts/elfun/csc.m
@@ -22,14 +22,14 @@
 ## Compute the cosecant of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = csc (z)
 
   if (nargin != 1)
-    usage ("csc (z)");
+    print_usage ();
   endif
 
   w = 1 ./ sin(z);
 
 endfunction
diff --git a/scripts/elfun/csch.m b/scripts/elfun/csch.m
--- a/scripts/elfun/csch.m
+++ b/scripts/elfun/csch.m
@@ -22,14 +22,14 @@
 ## Compute the hyperbolic cosecant of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = csch (z)
 
   if (nargin != 1)
-    usage ("csch (z)");
+    print_usage ();
   endif
 
   w = 1 ./ sinh(z);
 
 endfunction
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -39,17 +39,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 16 September 1994
 ## Adapted-By: jwe
 
 function l = lcm (varargin)
 
   if (nargin == 0)
-    usage ("lcm (a, ...)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     a = varargin{1};
 
     if (round (a) != a)
       error ("lcm: all arguments must be integer");
     endif
diff --git a/scripts/elfun/sec.m b/scripts/elfun/sec.m
--- a/scripts/elfun/sec.m
+++ b/scripts/elfun/sec.m
@@ -22,14 +22,14 @@
 ## Compute the secant of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = sec (z)
 
   if (nargin != 1)
-    usage ("sec (z)");
+    print_usage ();
   endif
 
   w = 1 ./ cos(z);
 
 endfunction
diff --git a/scripts/elfun/sech.m b/scripts/elfun/sech.m
--- a/scripts/elfun/sech.m
+++ b/scripts/elfun/sech.m
@@ -22,14 +22,14 @@
 ## Compute the hyperbolic secant of each element of @var{x}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function w = sech (z)
 
 if (nargin != 1)
-    usage ("sech (z)");
+    print_usage ();
   endif
 
   w = 1 ./ cosh(z);
 
 endfunction
diff --git a/scripts/finance/fv.m b/scripts/finance/fv.m
--- a/scripts/finance/fv.m
+++ b/scripts/finance/fv.m
@@ -35,17 +35,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Future value of an investment
 
 function v = fv (r, n, p, l, m)
 
   if ((nargin < 3) || (nargin > 5))
-    usage ("fv (r, n, p, l, method)");
+    print_usage ();
   endif
 
   if (! (isscalar (r) && (r > -1)))
     error ("fv: r must be a scalar > -1");
   elseif (! (isscalar (n) && (n > 0)))
     error ("fv: n must be a positive scalar");
   elseif (! isscalar (p))
     error ("fv: p must be a scalar");
diff --git a/scripts/finance/fvl.m b/scripts/finance/fvl.m
--- a/scripts/finance/fvl.m
+++ b/scripts/finance/fvl.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Future value of an initial lump sum investment
 
 function v = fvl (r, n, l)
 
   if (nargin != 3)
-    usage ("fvl (r, n, l)");
+    print_usage ();
   endif
 
   if (! (isscalar (r) && (r > -1)))
     error ("fvl: r has to be a scalar > -1");
   elseif (! (isscalar (n) && (n > 0)))
     error ("fvl: n has to be a positive scalar");
   elseif (! isscalar (l))
     error ("fvl: l has to be a scalar");
diff --git a/scripts/finance/irr.m b/scripts/finance/irr.m
--- a/scripts/finance/irr.m
+++ b/scripts/finance/irr.m
@@ -29,17 +29,17 @@
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Internal rate of return of an investment
 
 function r = irr (p, i)
 
   if (nargin == 1)
     i = 0;
   elseif (! (nargin == 2))
-    usage ("irr (p, i)");
+    print_usage ();
   endif
 
   if (! (isvector (p)))
     error ("irr: p must be a vector");
   else
     p_string = strcat ("[", sprintf ("%.15f, ", p), "]");
   endif
 
diff --git a/scripts/finance/nper.m b/scripts/finance/nper.m
--- a/scripts/finance/nper.m
+++ b/scripts/finance/nper.m
@@ -35,17 +35,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Number of payments needed for amortizing a loan
 
 function n = nper (r, p, a, l, m)
 
   if ((nargin < 3) || (nargin > 5))
-    usage ("nper (r, p, a, l, method)");
+    print_usage ();
   endif
 
   if (! (isscalar (r) && (r > -1)))
     error ("nper: r must be a scalar > -1");
   elseif (! isscalar (p))
     error ("nper: p must be a scalar");
   elseif (! isscalar (a))
     error ("nper: a must be a scalar");
diff --git a/scripts/finance/npv.m b/scripts/finance/npv.m
--- a/scripts/finance/npv.m
+++ b/scripts/finance/npv.m
@@ -34,17 +34,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Net present value of a series of payments
 
 function v = npv (r, p, i)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("npv (r, p, i");
+    print_usage ();
   endif
 
   if (! (isvector (p)))
     error ("npv: p has to be a vector");
   else
     n = length (p);
     p = reshape (p, 1, n);
   endif
diff --git a/scripts/finance/pmt.m b/scripts/finance/pmt.m
--- a/scripts/finance/pmt.m
+++ b/scripts/finance/pmt.m
@@ -32,17 +32,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Amount of periodic payment needed to amortize a loan
 
 function p = pmt (r, n, a, l, m)
 
   if (nargin < 3 || nargin > 5)
-    usage ("pmt (r, n, a, l, method)");
+    print_usage ();
   endif
 
   if (! (isscalar (r) && r > -1))
     error ("pmt: rate must be a scalar > -1");
   elseif (! (isscalar (n) && n > 0))
     error ("pmt: n must be a positive scalar");
   elseif (! (isscalar (a) && a > 0))
     error ("pmt: a must be a positive scalar");
diff --git a/scripts/finance/pv.m b/scripts/finance/pv.m
--- a/scripts/finance/pv.m
+++ b/scripts/finance/pv.m
@@ -35,17 +35,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Present value of an investment
 
 function v = pv (r, n, p, l, m)
 
   if ((nargin < 3) || (nargin > 5))
-    usage ("pv (r, n, p, l, method)");
+    print_usage ();
   endif
 
   if (! (isscalar (r) && (r > -1)))
     error ("pv: r must be a scalar > -1");
   elseif (! (isscalar (n) && (n > 0)))
     error ("pv: n must be a positive scalar");
   elseif (! isscalar (p))
     error ("pv: p must be a scalar");
diff --git a/scripts/finance/pvl.m b/scripts/finance/pvl.m
--- a/scripts/finance/pvl.m
+++ b/scripts/finance/pvl.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Present value of an investment that pays off at the end
 
 function v = pvl (r, n, p)
 
   if (nargin != 3)
-    usage ("pvl (r, n, p)");
+    print_usage ();
   endif
 
   if (! (isscalar (r) && (r > -1)))
     error ("pvl: r has to be a scalar > -1");
   elseif (! (isscalar (n) && (n > 0)))
     error ("pvl: n has to be a positive scalar");
   elseif (! isscalar (p))
     error ("pvl: p has to be a scalar");
diff --git a/scripts/finance/rate.m b/scripts/finance/rate.m
--- a/scripts/finance/rate.m
+++ b/scripts/finance/rate.m
@@ -32,17 +32,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Rate of return of an investment
 
 function r = rate (n, p, v, l, m)
 
   if ((nargin < 3) || (nargin > 5))
-    usage ("rate (n, p, v, l, method)");
+    print_usage ();
   endif
 
   if (! (isscalar (n) && (n > 0)))
     error ("rate: n must be a positive scalar");
   elseif (! isscalar (p))
     error ("rate: p must be a scalar");
   elseif (! isscalar (v))
     error ("rate: p must be a scalar");
diff --git a/scripts/finance/vol.m b/scripts/finance/vol.m
--- a/scripts/finance/vol.m
+++ b/scripts/finance/vol.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Volatility of financial time series data
 
 function retval = vol (X, m, n)
 
   if (nargin < 2)
-    usage ("vol (X, m, n)");
+    print_usage ();
   endif
 
   [xr, xc] = size (X);
 
   if (nargin > 2)
     if (n * m > xr)
       error ("vol: I need more data!");
     endif
diff --git a/scripts/general/__isequal__.m b/scripts/general/__isequal__.m
--- a/scripts/general/__isequal__.m
+++ b/scripts/general/__isequal__.m
@@ -40,17 +40,17 @@
 ##    b. cell/list  compare each member by order (recursive)
 ##    c. char       compare each member with strcmp
 ##    d. <other>    compare each nonzero member, and assume NaN == NaN
 ##                  if nans_compare_equal is nonzero.
 
 function t = __isequal__ (nans_compare_equal, x, varargin)
 
   if (nargin < 3)
-    usage ("__isequal__ (nans_compare_equal, x1, x2, ...)");
+    print_usage ();
   endif
 
   l_v = nargin - 2;
 
   if (isstruct (x))
 
     n_x = length (fieldnames (x));
 
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -31,17 +31,17 @@
 ## @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function X = bitcmp (A, n)
   
   if (nargin < 1 || nargin > 2)
-    usage ("bitcmp (A, n)");
+    print_usage ();
   endif
 
   if (isa (A, "double"))
     Bmax = bitmax;
     Amax = log2 (Bmax) + 1;
     _conv = @double;
   else
     if (isa (A, "uint8"))
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -27,17 +27,17 @@
 ## @seealso{bitand, bitor, bitxor, bitset, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function X = bitget (A, n)
 
   if (nargin != 2)
-    usage ("bitget (A, n)");
+    print_usage ();
   endif
 
   if (isa (A, "double"))
     Amax = log2 (bitmax) + 1;
     _conv = @double;
   else
     if (isa (A, "uint8"))
       Amax = 8;
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -29,17 +29,17 @@
 ## @seealso{bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function X = bitset (A, n, value)
 
   if (nargin < 2 || nargin > 3)
-    usage ("bitset (A, n, v)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     value = 1;
   endif
   
   if (isa (A, "double"))
     Bmax = bitmax;
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: Daniel Calvelo
 ## Modified by: William Poetra Yoga Hadisoeseno
 
 function retval = blkdiag (varargin)
 
   if (nargin < 1)
-    usage ("blkdiag (a, b, c, ...)");
+    print_usage ();
   endif
 
   if (! all (cellfun (@isnumeric, varargin)))
     error ("blkdiag: all arguments must be numeric");
   endif
 
   ## Note: trailing singletons are automatically (correctly) ignored.
   if (! all (cellfun ("ndims", varargin) == 2))
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [Theta, Phi, R] = cart2sph (X, Y, Z)
 
   if (nargin != 3)
-    usage ("[Theta, Phi, R] = cart2sph (X, Y, Z)")
+    print_usage ();
   endif
 
   if ((! (ismatrix (X) && ismatrix (Y) && ismatrix (Z)))
       || size (X) != size (Y)
       || size (X) != size (Z))
     error ("cart2sph: arguments must be matrices of same size");
   endif
 
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -22,17 +22,17 @@
 ## be numeric, logical or char, and @code{cat} must be able to
 ## concatenate them together.
 ## @seealso{mat2cell, num2cell}
 ## @end deftypefn
 
 function m = cell2mat (c)
 
   if (nargin != 1)
-    usage ("m = cell2mat (c)");
+    print_usage ();
   endif
 
   if (! iscell (c))
     error ("cell2mat: c is not a cell array");
   endif
   
   nb = numel (c);
 
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -75,11 +75,11 @@ function y = circshift (x, n)
 	idx{i} = [(sz(i)-nn+1):sz(i), 1:(sz(i)-nn)];
       endif
     endfor
     for i = (length(n) + 1) : nd
       idx{i} = 1:sz(i);
     endfor
     y = x(idx{:});
   else
-    usage ("circshift (x, n)");
+    print_usage ();
   endif
 endfunction
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -46,17 +46,17 @@
 ## TODO:    it in Matlab?  The reason is that complex pairs are supposed
 ## TODO:    to be exact conjugates, and not rely on a tolerance test.
 
 ## 2006-05-12 David Bateman - Modified for NDArrays
 
 function y = cplxpair (z, tol, dim)
 
   if nargin < 1 || nargin > 3
-    usage ("z = cplxpair (z, tol, dim);"); 
+    print_usage ();
   endif
 
   if (length (z) == 0)
     y = zeros (size (z));
     return; 
   endif
 
   if (nargin < 2 || isempty (tol))
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -35,17 +35,17 @@
 ## Author:	Kai Habel <kai.habel@gmx.de>
 ##
 ## also: June 2000 Paul Kienzle (fixes,suggestions) 
 ## 2006-05-12 David Bateman - Modified for NDArrays
 
 function z = cumtrapz (x, y, dim)	
 
   if (nargin < 1) || (nargin > 3)
-    usage ("cumtrapz (x, y, dim)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
 
   have_x = false;
   have_dim = false;
   if (nargin == 3)
diff --git a/scripts/general/deal.m b/scripts/general/deal.m
--- a/scripts/general/deal.m
+++ b/scripts/general/deal.m
@@ -60,17 +60,17 @@
 ## Author: Ariel Tankus
 ## Author: Paul Kienzle and Etienne Grossman
 ## Created: 13.11.98
 ## Adapted-by: jwe
 
 function [varargout] = deal (varargin)
 
   if (nargin == 0)
-    usage ("[a, b, c, d] = deal (x, y, z, a)");
+    print_usage ();
   elseif (nargin == 1 || nargin == nargout)
     varargout(1:nargout) = varargin;
   else
     error ("deal: nargin > 1 and nargin != nargout");
   endif
 
 endfunction
 
diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -49,17 +49,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 2 February 1995
 ## Adapted-By: jwe
 
 function x = diff (x, k, dim)
 
   if (nargin < 1 || nargin > 3)
-    usage ("diff (x, k");
+    print_usage ();
   endif
 
   if (nargin < 2 || isempty(k))
     k = 1;
   else
     if (! (isscalar (k) && k == round (k) && k >= 0))
       error ("diff: k must be a nonnegative integer");
     elseif (k == 0)
diff --git a/scripts/general/flipdim.m b/scripts/general/flipdim.m
--- a/scripts/general/flipdim.m
+++ b/scripts/general/flipdim.m
@@ -32,17 +32,17 @@
 ## @seealso{fliplr, flipud, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: David Bateman
 
 function y = flipdim (x, dim)
 
   if (nargin != 1 && nargin != 2)
-    usage ("flipdim (x, dim)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin == 1)
     ## Find the first non-singleton dimension.
     dim = 1;
     while (dim < nd + 1 && sz(dim) == 1)
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -35,17 +35,17 @@
 ## @seealso{flipud, flipdim, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = fliplr (x)
 
   if (nargin != 1)
-    usage ("fliplr (x)");
+    print_usage ();
   endif
 
   if (ndims (x) > 2)
     error ("fliplr: Only works with 2-D arrays")
   endif
 
   nc = columns (x);
   y = x (:, nc:-1:1);
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -36,17 +36,17 @@
 ## @seealso{fliplr, flipdim, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = flipud (x)
 
   if (nargin != 1)
-    usage ("flipud (x)");
+    print_usage ();
   endif
 
   if (ndims (x) > 2)
     error ("flipud: Only works with 2-d arrays")
   endif
 
   nr = rows (x);
   y = x (nr:-1:1, :);
diff --git a/scripts/general/ind2sub.m b/scripts/general/ind2sub.m
--- a/scripts/general/ind2sub.m
+++ b/scripts/general/ind2sub.m
@@ -63,13 +63,13 @@ function varargout = ind2sub (dims, ind)
 	endif
       else
 	error ("ind2sub: expecting integer-valued index argument");
       endif
     else
       error ("ind2sub: expecting dims to be an integer vector");
     endif
   else
-    usage ("ind2sub (dims, ind)");
+    print_usage ();
   endif
 
 
 endfunction
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -48,17 +48,17 @@ function retval = int2str (x)
       fmt = strcat (ifmt, repmat (rfmt, 1, nc-1), "\n")
     else
       fmt = strcat (get_fmt (x, 0), "\n");
     endif
     tmp = sprintf (fmt, permute (x, [2, 1, 3 : nd]));
     tmp(end) = "";
     retval = split (tmp, "\n");
   else
-    usage ("int2str (x)");
+    print_usage ();
   endif
 
 endfunction
 
 function fmt = get_fmt (x, sep)
 
   t = x(:);
   t = t(t != 0);
diff --git a/scripts/general/is_duplicate_entry.m b/scripts/general/is_duplicate_entry.m
--- a/scripts/general/is_duplicate_entry.m
+++ b/scripts/general/is_duplicate_entry.m
@@ -33,13 +33,13 @@ function retval = is_duplicate_entry (x)
       lx1 = lx-1;
       x = sort (reshape (x, 1, lx));
       dx = x(1:lx1) - x(2:lx);
       retval = sum (dx == 0);
     else
       error ("is_duplicate_entry: expecting matrix argument");
     endif
   else
-    usage ("is_duplicate_entry (x)");
+    print_usage ();
   endif
 
 endfunction
 
diff --git a/scripts/general/isdefinite.m b/scripts/general/isdefinite.m
--- a/scripts/general/isdefinite.m
+++ b/scripts/general/isdefinite.m
@@ -46,12 +46,12 @@ function retval = isdefinite (x, tol)
 	retval = 0;
       else
 	retval = -1;
       end
     else
       error ("isdefinite: matrix x must be symmetric");
     endif
   else
-    usage ("isdefinite (x,tol)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/general/isequal.m b/scripts/general/isequal.m
--- a/scripts/general/isequal.m
+++ b/scripts/general/isequal.m
@@ -23,13 +23,13 @@
 ## @seealso{isequalwithequalnans}
 ## @end deftypefn
 
 function retval = isequal (x, varargin)
 
   if (nargin > 1)
     retval = __isequal__ (0, x, varargin{:});
   else
-    usage ("isequal (x1, x2, ...)");
+    print_usage ();
   endif
 
 endfunction
 
diff --git a/scripts/general/isequalwithequalnans.m b/scripts/general/isequalwithequalnans.m
--- a/scripts/general/isequalwithequalnans.m
+++ b/scripts/general/isequalwithequalnans.m
@@ -24,13 +24,13 @@
 ## @seealso{isequal}
 ## @end deftypefn
 
 function retval = isequalwithequalnans (x, varargin)
 
   if (nargin > 1)
     retval = __isequal__ (1, x, varargin{:});
   else
-    usage ("isequalwithequalnans (x1, x2, ...)");
+    print_usage ();
   endif
 
 endfunction
 
diff --git a/scripts/general/isscalar.m b/scripts/general/isscalar.m
--- a/scripts/general/isscalar.m
+++ b/scripts/general/isscalar.m
@@ -25,12 +25,12 @@
 
 ## Author: jwe
 
 function retval = isscalar (x)
 
   if (nargin == 1)
     retval = prod (size (x)) == 1;
   else
-    usage ("isscalar (x)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/general/issquare.m b/scripts/general/issquare.m
--- a/scripts/general/issquare.m
+++ b/scripts/general/issquare.m
@@ -35,12 +35,12 @@ function retval = issquare (x)
   if (nargin == 1)
     if (ismatrix (x) && ndims (x) < 3)
       [nr, nc] = size (x);
       if (nr == nc && nr > 0)
         retval = nr;
       endif
     endif
   else
-    usage ("issquare (x)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/general/issymmetric.m b/scripts/general/issymmetric.m
--- a/scripts/general/issymmetric.m
+++ b/scripts/general/issymmetric.m
@@ -39,12 +39,12 @@ function retval = issymmetric (x,tol)
         tol = eps;
       endif
       norm_x = norm (x);
       if (norm_x != 0 && norm (x - x') / norm_x > tol)
         retval = 0;
       endif
     endif
   else
-    usage ("issymmetric (x {,tol})");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/general/isvector.m b/scripts/general/isvector.m
--- a/scripts/general/isvector.m
+++ b/scripts/general/isvector.m
@@ -28,12 +28,12 @@
 function retval = isvector (x)
 
   retval = 0;
 
   if (nargin == 1)
     sz = size (x);
     retval = (ndims (x) == 2 && (sz(1) == 1 || sz(2) == 1));
   else
-    usage ("isvector (x)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/general/logical.m b/scripts/general/logical.m
--- a/scripts/general/logical.m
+++ b/scripts/general/logical.m
@@ -41,12 +41,12 @@ function y = logical (x)
     if (islogical (x) || isempty (x))
       y = x;
     elseif (isnumeric (x))
       y = x != 0;
     else
       error ("logical not defined for type `%s'", typeinfo (x));
     endif
   else
-    usage ("logical (x)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -69,17 +69,17 @@ function retval = logspace (x1, x2, n)
     npoints = 50;
   elseif (nargin == 3)
     if (length (n) == 1)
       npoints = fix (n);
     else
       error ("logspace: arguments must be scalars");
     endif
   else
-    usage ("logspace (x1, x2, n)");
+    print_usage ();
   endif
 
   if (npoints < 2)
     error ("logspace: npoints must be greater than 2");
   endif
 
   if (length (x1) == 1 && length (x2) == 1)
     x2_tmp = x2;
diff --git a/scripts/general/mod.m b/scripts/general/mod.m
--- a/scripts/general/mod.m
+++ b/scripts/general/mod.m
@@ -36,17 +36,17 @@
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Modified by: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Adapted by: jwe
 
 function r = mod (x, y)
 
   if (nargin != 2)
-    usage ("r = mod (x, y)");
+    print_usage ();
   endif
 
   if (((ndims (x) != ndims (y)) || any (size (x) != size (y))) &&
 	 ! (isscalar (x) || isscalar (y)))
     error ("mod: argument sizes must agree");
   endif
 
   ## Matlab allows complex arguments, but as far as I can tell, that's a
diff --git a/scripts/general/nargchk.m b/scripts/general/nargchk.m
--- a/scripts/general/nargchk.m
+++ b/scripts/general/nargchk.m
@@ -27,17 +27,17 @@
 ## to a function is within an acceptable range.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = nargchk (nargin_min, nargin_max, n)
 
   if (nargin != 3)
-    usage ("nargchk (nargin_min, nargin_max, n)");
+    print_usage ();
   endif
 
   if (nargin_min > nargin_max)
     error  ("nargchk: nargin_min > nargin_max");
   endif
 
   if (n < nargin_min)
     retval = "nargchk: N is less than nargin_min";
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -35,17 +35,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 7 October 1994
 ## Adapted-By: jwe
 
 function n = nextpow2 (x)
 
   if (nargin != 1)
-    usage ("nextpow2 (x)");
+    print_usage ();
   endif
 
   if (! (isscalar (x) || isvector (x)))
     error ("nextpow2: x must be a scalar or a vector");
   endif
 
   t = length (x);
   if (t > 1)
diff --git a/scripts/general/perror.m b/scripts/general/perror.m
--- a/scripts/general/perror.m
+++ b/scripts/general/perror.m
@@ -26,14 +26,14 @@
 ## @seealso{strerror}
 ## @end deftypefn
 
 ## Author: jwe
 
 function perror (name, err)
 
   if (nargin != 2)
-    usage ("perror (name, err)");
+    print_usage ();
   else
     printf (strerror (name, err));
   endif
 
 endfunction
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -23,17 +23,17 @@
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 
 function y = postpad (x, l, c, dim)
 
   if (nargin < 2 || nargin > 4)
-    usage ("postpad (x, l, [c, [dim]])");
+    print_usage ();
   endif
 
   if (nargin < 3 || isempty (c))
     c = 0;
   else
     if (! isscalar (c))
       error ("postpad: third argument must be empty or a scalar");
     endif
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -36,17 +36,17 @@
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 
 function y = prepad (x, l, c, dim)
 
   if (nargin < 2 || nargin > 4)
-    usage ("prepad (x, l, [c, [dim]])");
+    print_usage ();
   endif
 
   if (nargin < 3 || isempty (c))
     c = 0;
   else
     if (! isscalar (c))
       error ("prepad: third argument must be empty or a scalar");
     endif
diff --git a/scripts/general/randperm.m b/scripts/general/randperm.m
--- a/scripts/general/randperm.m
+++ b/scripts/general/randperm.m
@@ -30,12 +30,12 @@ function retval = randperm (n)
 
   if (nargin == 1 && isscalar (n) && floor (n) == n)
     if (n >= 0)
       [junk, retval] = sort (rand (1, n));
     else
       error ("randperm: argument must be non-negative");
     endif
   else
-    usage ("randperm (n)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/general/rem.m b/scripts/general/rem.m
--- a/scripts/general/rem.m
+++ b/scripts/general/rem.m
@@ -31,17 +31,17 @@
 ## @seealso{mod, round}
 ## @end deftypefn
 
 ## Author: jwe
 
 function r = rem (x, y)
 
   if (nargin != 2)
-    usage ("rem (x, y)");
+    print_usage ();
   endif
 
   if (((ndims (x) != ndims (y)) || any (size (x) != size (y))) &&
 	 ! (isscalar (x) || isscalar (y)))
     error ("rem: argument sizes must agree");
   endif
 
   ## Matlab allows complex arguments, but as far as I can tell, that's a
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Created: July 2000
 
 function x = repmat (a, m, n)
 
   if (nargin < 2 || nargin > 3)
-    usage ("repmat (a, m, n)");
+    print_usage ();
   endif
 
   if (nargin == 3)
     if (! (isscalar (m) && isscalar (n)))
       error ("repmat: with 3 arguments m and n must be scalar");
     endif
     idx = [m, n];
   else 
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -81,12 +81,12 @@ function y = rot90 (x, k)
     elseif (k == 2)
       y = flipud (fliplr (x));
     elseif (k == 3)
       y = (flipud (x)).';
     else
       error ("rot90: internal error!");
     endif
   else
-    usage ("rot90 (x, k)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -50,17 +50,17 @@
 ## @end group
 ## @end example
 ## @seealso{rot90, flipud, fliplr, flipdim}
 ## @end deftypefn
 
 function y = rotdim (x, k, plane)
   
   if (nargin < 1 || nargin > 3)
-    usage ("rotdim (x, k, plane)");
+    print_usage ();
   endif
 
   if (nargin > 1 && ! isempty(k))
     if (imag (k) != 0 || fix (k) != k)
       error ("rotdim: k must be an integer");
     endif
   else
     k = 1;
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -30,17 +30,17 @@
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 14 September 1994
 ## Adapted-By: jwe
 
 function y = shift (x, b, dim)
 
   if (nargin != 2 && nargin != 3)
-    usage ("shift (X, b, dim)");
+    print_usage ();
   endif
 
   if (! (isscalar (b) && b == round (b)))
     error ("shift: b must be an integer");
   endif
 
   nd = ndims (x);
   sz = size (x);
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -46,17 +46,17 @@
 ## @end group
 ## @end example
 ## @seealso {reshape, permute, ipermute, circshift, squeeze}
 ## @end deftypefn
 
 function [y, ns]  = shiftdim (x, n)
 
   if (nargin < 1 || nargin > 2)
-    usage ("shiftdim (x, n) or [b, ns] = shiftdim (x)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   orig_dims = size (x);
 
   if (nargin == 1)
     ## Find the first singleton dimension.
     n = 0;
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [X, Y, Z] = sph2cart (Theta, Phi, R)
 
   if (nargin != 3)
-    usage ("[X, Y, Z] = sph2cart (Theta, Phi, R)");
+    print_usage ();
   endif
 
   if ((! (ismatrix (Theta) && ismatrix (Phi) && ismatrix (R)))
       || size (Theta) != size (Phi)
       || size (Theta) != size (R))
     error ("sph2cart: arguments must be matrices of same size");
   endif
 
diff --git a/scripts/general/strerror.m b/scripts/general/strerror.m
--- a/scripts/general/strerror.m
+++ b/scripts/general/strerror.m
@@ -25,17 +25,17 @@
 ## return numeric error codes.
 ## @end deftypefn
 
 ## Author: jwe
 
 function msg = strerror (name, err)
 
   if (nargin != 2)
-    usage ("strerror (name, err)");
+    print_usage ();
   endif
 
   if (! ischar (name))
     error ("strerror: first argument must be a string");
   endif
 
   if (! isscalar (err))
     error ("strerror: second argument must be a scalar");
diff --git a/scripts/general/sub2ind.m b/scripts/general/sub2ind.m
--- a/scripts/general/sub2ind.m
+++ b/scripts/general/sub2ind.m
@@ -59,13 +59,13 @@ function ind = sub2ind (dims, varargin)
 	else
 	  error ("sub2ind: expecting integer-valued index arguments");
 	endif
       endfor
     else
       error ("sub2ind: expecting dims to be an integer vector");
     endif
   else
-    usage ("sub2ind (dims, i1, i2, ..., iN)");
+    print_usage ();
   endif
 
 
 endfunction
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -35,17 +35,17 @@
 ##
 ## also: June 2000 - Paul Kienzle (fixes,suggestions) 
 ## 2006-05-12 David Bateman - Modified for NDArrays
 
 function z = trapz (x, y, dim)
 	
 
   if (nargin < 1) || (nargin > 3)
-    usage ("trapz (x, y, dim)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
 
   have_x = false;
   have_dim = false;
   if (nargin == 3)
diff --git a/scripts/general/tril.m b/scripts/general/tril.m
--- a/scripts/general/tril.m
+++ b/scripts/general/tril.m
@@ -73,17 +73,17 @@ function retval = tril (x, k)
 
   if (nargin == 1)
     k = 0;
   elseif (nargin == 2)
     if ((k > 0 && k > nc) || (k < 0 && k < -nr))
       error ("tril: requested diagonal out of range");
     endif
   else
-    usage ("tril (x, k)");
+    print_usage ();
   endif
 
   for j = 1 : min (nc, nr+k)
     nr_limit = max (1, j-k);
     retval (nr_limit:nr, j) = x (nr_limit:nr, j);
   endfor
 
 endfunction
diff --git a/scripts/general/triu.m b/scripts/general/triu.m
--- a/scripts/general/triu.m
+++ b/scripts/general/triu.m
@@ -33,17 +33,17 @@ function retval = triu (x, k)
 
   if (nargin == 1)
     k = 0;
   elseif (nargin == 2)
     if ((k > 0 && k > nc) || (k < 0 && k < -nr))
       error ("triu: requested diagonal out of range");
     endif
   else
-    usage ("triu (x, k)");
+    print_usage ();
   endif
 
   for j = max (1, k+1) : nc
     nr_limit = min (nr, j-k);
     retval (1:nr_limit, j) = x (1:nr_limit, j);
   endfor
 
 endfunction
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -28,16 +28,16 @@
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function map = gray (number)
 
   if (nargin == 0)
     number = 64;
   elseif (nargin > 1)
-    usage ("gray (number)");
+    print_usage ();
   endif
 
   gr = [0:(number-1)]';
 
   map = [ gr, gr, gr ] / (number - 1);
 
 endfunction
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -24,17 +24,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [X, map] = gray2ind (I, n)
 
   if (nargin < 1 || nargin > 2)
-    usage ("gray2ind (I, n)");
+    print_usage ();
   elseif (nargin == 1)
     n = 64;
   endif
 
   map = gray (n);
 
   X = round (I*(n-1)) + 1;
 
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -29,17 +29,17 @@
 function rgb_map = hsv2rgb (hsv_map)
 
 ## each color value x=(r,g,b) is calculated with
 ## x = (1-sat)*val+sat*val*f_x(hue)
 ## where f_x(hue) is a piecewise defined function for
 ## each color with f_r(hue-2/3) = f_g(hue) = f_b(hue-1/3)
 
   if (nargin != 1)
-    usage ("rgb_map = hsv2rgb (hsv_map)");
+    print_usage ();
   endif
 
   if (! ismatrix (hsv_map) || columns (hsv_map) != 3)
     error ("hsv2rgb: argument must be a matrix of size nx3");
   endif
 
   ## set values <0 to 0 and >1 to 1
   hsv_map = (hsv_map >= 0 & hsv_map <= 1) .* hsv_map \
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -49,17 +49,17 @@ function image (x, y, A, zoom)
     x = y = [];
   elseif (nargin == 2)
     A = x;
     zoom = y;
     x = y = [];
   elseif (nargin == 3)
     zoom = [];
   elseif (nargin > 4)
-    usage ("image (matrix, zoom) or image (x, y, matrix, zoom)");
+    print_usage ();
   endif
 
   if isempty(zoom)
     ## Find an integer scale factor which sets the image to
     ## approximately the size of the screen.
     zoom = min ([350/rows(A), 600/columns(A), 4]);
     if (zoom >= 1)
       zoom = floor (zoom);
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -39,17 +39,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function ret = imagesc (x, y, A, zoom, limits)
 
   if (nargin < 1 || nargin > 5)
-    usage ("B = imagesc ([x, y,] matrix [,limits] [,zoom])");
+    print_usage ();
   elseif (nargin == 1)
     A = x;
     zoom = x = y = limits = [];
   elseif (nargin == 2)
     A = x;
     zoom = y;
     x = y = limits = [];
   elseif (nargin == 3)
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -27,17 +27,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function Y = ind2gray (X, map)
 
   if (nargin < 1 || nargin > 2)
-    usage ("ind2gray (X, map)");
+    print_usage ();
   elseif (nargin == 1)
     map = colormap ();
   endif
 
   [rows, cols] = size (X);
 
   ## Convert colormap to intensity values (the first column of the
   ## result of the call to rgb2ntsc) and then replace indices in
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -26,17 +26,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [R, G, B] = ind2rgb (X, map)
 
   if (nargin < 1 || nargin > 2)
-    usage ("ind2rgb (X, map)");
+    print_usage ();
   elseif (nargin == 1)
     map = colormap ();
   endif
 
   [hi, wi] = size (X);
 
   ## FIXME -- we should check size of X and map.
 
diff --git a/scripts/image/loadimage.m b/scripts/image/loadimage.m
--- a/scripts/image/loadimage.m
+++ b/scripts/image/loadimage.m
@@ -26,17 +26,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [img_retval, map_retval] = loadimage (filename)
 
   if (nargin != 1)
-    usage ("[img, map] = loadimage (filename)");
+    print_usage ();
   elseif (! ischar (filename))
     error ("loadimage: expecting filename as a string");
   endif
 
   file = file_in_path (IMAGE_PATH, filename);
 
   if (isempty (file))
     error ("loadimage: unable to find image file");
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -24,17 +24,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function rgb = ntsc2rgb (yiq)
 
   if (nargin != 1)
-    usage ("ntsc2rgb (yiq)");
+    print_usage ();
   endif
 
   trans = [ 1.0,      1.0,      1.0;
             0.95617, -0.27269, -1.10374;
             0.62143, -0.64681, 1.70062 ];
 
   rgb = yiq * trans;
 
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -31,17 +31,17 @@ function map = ocean (number)
 
   if (nargin == 0)
     number = 64;
   elseif (nargin == 1)
     if (! isscalar (number))
       error ("ocean: argument must be a scalar");
     endif
   else
-    usage ("ocean (number)");
+    print_usage ();
   endif
 
   cutin = fix (number/3);
 
   dr = (number - 1) / cutin;
 
   r = prepad ([0:dr:(number-1)], number)';
 
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -31,17 +31,17 @@
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function hsval = rgb2hsv (rgb)
 
   if (nargin != 1)
-    usage ("hsv_map = rgb2hsv (rgb_map)");
+    print_usage ();
   endif
 
   if (! ismatrix (rgb) || columns (rgb) != 3)
     error ("rgb2hsv: argument must be a matrix of size n x 3");
   endif
 
   ## get the max and min
   s = min (rgb')';
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -24,17 +24,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function yiq = rgb2ntsc (rgb)
 
   if (nargin != 1)
-    usage ("rgb2ntsc (rgb)");
+    print_usage ();
   endif
 
   trans = [ 0.299,  0.596,  0.211;
             0.587, -0.274, -0.523;
             0.114, -0.322,  0.312 ];
 
   yiq = rgb * trans;
 
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -72,17 +72,17 @@
 ## that the above copyright notice appear in all copies and that both that
 ## copyright notice and this permission notice appear in supporting
 ## documentation.  This software is provided "as is" without express or
 ## implied warranty.
 
 function saveimage (filename, img, img_form, map)
 
   if (nargin < 2 || nargin > 4)
-    usage ("saveimage (filename, matrix, [format, [colormap]])");
+    print_usage ();
   endif
 
   if (nargin < 4)
     map = colormap ();
   endif
 
   [map_nr, map_nc] = size (map);
 
diff --git a/scripts/io/beep.m b/scripts/io/beep.m
--- a/scripts/io/beep.m
+++ b/scripts/io/beep.m
@@ -25,12 +25,12 @@
 
 ## Author: jwe
 
 function beep ()
 
   if (nargin == 0)
     puts ("\a");
   else
-    usage ("beep ()");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -82,17 +82,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
 
 function k = commutation_matrix (m, n)
 
   if (nargin < 1 || nargin > 2)
-    usage ("commutation_matrix (m, n)");
+    print_usage ();
   else
     if (! (isscalar (m) && m == round (m) && m > 0))
       error ("commutation_matrix: m must be a positive integer");
     endif
     if (nargin == 1)
       n = m;
     elseif (! (isscalar (n) && n == round (n) && n > 0))
       error ("commutation_matrix: n must be a positive integer");
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -46,12 +46,12 @@ function retval = cond (a)
       sigma_n = sigma(length (sigma));
       if (sigma_1 == 0 || sigma_n == 0)
         retval = Inf;
       else
         retval = sigma_1 / sigma_n;
       endif
     endif
   else
-    usage ("cond (a)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -37,17 +37,17 @@
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 15 October 1994
 ## Adapted-By: jwe
 
 function z = cross (x, y, dim)
 	
   if (nargin != 2 && nargin != 3)
-    usage ("cross (x, y, dim)");
+    print_usage ();
   endif
 
   if (ndims (x) < 3 && ndims (y) < 3 && nargin < 3)
     ## COMPATIBILITY -- opposite behaviour for cross(row,col)
     ## Swap x and y in the assignments below to get the matlab behaviour.
     ## Better yet, fix the calling code so that it uses conformant vectors.
     if (columns (x) == 1 && rows (y) == 1)
       warning ("cross: taking cross product of column by row");
diff --git a/scripts/linear-algebra/dmult.m b/scripts/linear-algebra/dmult.m
--- a/scripts/linear-algebra/dmult.m
+++ b/scripts/linear-algebra/dmult.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Rescale the rows of a matrix
 
 function M = dmult (a, B)
 
   if (nargin != 2)
-    usage ("dmult (a, B)");
+    print_usage ();
   endif
  if (! isvector (a))
     error ("dmult: a must be a vector of length rows (B)");
   endif
   a = a(:);
   sb = size (B);
   sb(1) = 1;
   M = repmat (a(:), sb) .* B;
diff --git a/scripts/linear-algebra/dot.m b/scripts/linear-algebra/dot.m
--- a/scripts/linear-algebra/dot.m
+++ b/scripts/linear-algebra/dot.m
@@ -25,17 +25,17 @@
 ## given, calculate the dot-product along this dimension.
 ## @end deftypefn
 
 ## Author: jwe
 
 function z = dot (x, y, dim)
 
   if (nargin != 2 && nargin != 3)
-    usage ("dot (x, y, dim)");
+    print_usage ();
   endif
 
   if (nargin < 3)
     if isvector (x)
       x = x(:);
     endif
     if isvector (y)
       y = y(:);
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -71,17 +71,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 8 May 1995
 ## Adapged-By: jwe
 
 function d = duplication_matrix (n)
 
   if (nargin != 1)
-    usage ("duplication_matrix (n)");
+    print_usage ();
   endif
 
   if (! (isscalar (n) && n == round (n) && n > 0))
     error ("duplication_matrix: n must be a positive integer");
   endif
 
   d = zeros (n * n, n * (n + 1) / 2);
 
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -50,17 +50,17 @@
 
 ## Author: A. Scottedward Hodel <a.s.hodel@eng.auburn.edu>
 
 function [Uret, H, nu] = krylov (A, V, k, eps1, pflg);
 
   defeps = 1e-12;
 
   if (nargin < 3 || nargin > 5)
-    usage ("[U, nu] = krylov (A, V, k, eps1, pflg)")
+    print_usage ();
   elseif (nargin < 5)
     pflg = 0;        # default permutation flag
   endif
 
   if(nargin < 4)
     eps1 = defeps;    # default tolerance parameter
   endif
 
diff --git a/scripts/linear-algebra/krylovb.m b/scripts/linear-algebra/krylovb.m
--- a/scripts/linear-algebra/krylovb.m
+++ b/scripts/linear-algebra/krylovb.m
@@ -27,12 +27,12 @@ function [Uret, Ucols] = krylovb (A, V, 
   switch (nargin)
     case (3)
       [Uret, H, Ucols] = krylov (A, V, k);
     case (4)
       [Uret, H, Ucols] = krylov (A, V, k, eps1);
     case (5)
       [Uret, H, Ucols] = krylov (A, V, k, eps1, pflg);
     otherwise
-      usage ("[Uret, Ucols] = krylovb (A, V, k ,eps1, pflg)");
+      print_usage ();
   endswitch
 
 endfunction
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -22,15 +22,15 @@
 ## Compute the matrix logarithm of the square matrix @var{a}.  Note that
 ## this is currently implemented in terms of an eigenvalue expansion and
 ## needs to be improved to be more robust.
 ## @end deftypefn
 
 function B = logm (A)
 
   if (nargin != 1)
-    usage ("B = logm (A)");
+    print_usage ();
   endif
 
   [V, D] = eig (A);
   B = V * diag (log (diag (D))) * inv (V);
 
 endfunction
diff --git a/scripts/linear-algebra/norm.m b/scripts/linear-algebra/norm.m
--- a/scripts/linear-algebra/norm.m
+++ b/scripts/linear-algebra/norm.m
@@ -55,17 +55,17 @@
 ## @seealso{cond, svd}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = norm (x, p)
 
   if (nargin < 1 || nargin > 2)
-    usage ("norm (x, p)");
+    print_usage ();
   endif
 
   if (isempty (x))
     retval = [];
     return;
   endif
 
   if (ndims (x) > 2)
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -49,17 +49,17 @@ function retval = null (A, tol)
       s = S(1);
     else
       s = diag (S);
     endif
 
     if (nargin == 1)
       tol = max (size (A)) * s (1) * eps;
     elseif (nargin != 2)
-      usage ("null (A, tol)");
+      print_usage ();
     endif
 
     rank = sum (s > tol);
 
     if (rank < cols)
       retval = V (:, rank+1:cols);
     else
       retval = zeros (cols, 0);
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -59,13 +59,13 @@ function retval = orth (A, tol)
     if (rank > 0)
       retval = -U (:, 1:rank);
     else
       retval = zeros (rows, 0);
     endif
 
   else
 
-    usage ("orth (a, tol");
+    print_usage ();
 
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -44,17 +44,17 @@
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function [aa, bb, q, z] = qzhess (a, b)
 
   if (nargin != 2)
-    usage ("[aa, bb, q, z] = qzhess (a, b)");
+    print_usage ();
   endif
 
   [na, ma] = size (a);
   [nb, mb] = size (b);
   if (na != ma || na != nb || nb != mb)
     error ("qzhess: incompatible dimensions");
   endif
 
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -43,14 +43,14 @@ function retval = rank (A, tol)
       tolerance = 0;
     else
       tolerance = max (size (A)) * sigma (1) * eps;
     endif
   elseif (nargin == 2)
     sigma = svd (A);
     tolerance = tol;
   else
-    usage ("rank (A)");
+    print_usage ();
   endif
 
   retval = sum (sigma > tolerance);
 
 endfunction
diff --git a/scripts/linear-algebra/trace.m b/scripts/linear-algebra/trace.m
--- a/scripts/linear-algebra/trace.m
+++ b/scripts/linear-algebra/trace.m
@@ -22,17 +22,17 @@
 ## Compute the trace of @var{a}, @code{sum (diag (@var{a}))}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = trace (x)
 
   if (nargin != 1)
-    usage ("trace (x)");
+    print_usage ();
   endif
 
   [nr, nc] = size (x);
   if (nr == 1 || nc == 1)
     y = x(1);
   else
     y = sum (diag (x));
   endif
diff --git a/scripts/linear-algebra/vec.m b/scripts/linear-algebra/vec.m
--- a/scripts/linear-algebra/vec.m
+++ b/scripts/linear-algebra/vec.m
@@ -28,14 +28,14 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
 
 function v = vec (x)
 
   if (nargin != 1)
-    usage ("vec (x)");
+    print_usage ();
   endif
 
   v = x(:);
 
 endfunction
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -29,17 +29,17 @@
 
 ## Author KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 8 May 1995
 ## Adapted-By: jwe
 
 function v = vech (x)
 
   if (nargin != 1)
-    usage ("vech (x)");
+    print_usage ();
   endif
 
   if (! issquare (x))
     error ("vech: x must be square");
   endif
 
   ## This should be quicker than having an inner `for' loop as well.
   ## Ideally, vech should be written in C++.
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -52,17 +52,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 8 October 1994
 ## Adapted-By: jwe
 
 function b = bincoeff (n, k)
 
   if (nargin != 2)
-    usage ("bincoeff (n, k)");
+    print_usage ();
   endif
 
   [retval, n, k] = common_size (n, k);
   if (retval > 0)
     error ("bincoeff: n and k must be of common size or scalars");
   endif
 
   sz = size (n);
diff --git a/scripts/miscellaneous/delete.m b/scripts/miscellaneous/delete.m
--- a/scripts/miscellaneous/delete.m
+++ b/scripts/miscellaneous/delete.m
@@ -26,12 +26,12 @@
 
 ## Author: jwe
 
 function delete (file)
 
   if (nargin == 1)
     unlink (file);
   else
-    usage ("delete (file)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -48,17 +48,17 @@
 ## FIXME -- this is quite slow for large directories, so perhaps
 ## it should be converted to C++.
 
 function retval = dir (file)
 
   if (nargin == 0)
     file = ".";
   elseif (nargin > 1)
-    usage ("dir (file)");
+    print_usage ();
   endif
 
   ## Prep the retval.
   info = struct (zeros (0, 1));
 
   if (ischar (file))
     if (strcmp (file, "*"))
       file = ".";
diff --git a/scripts/miscellaneous/dos.m b/scripts/miscellaneous/dos.m
--- a/scripts/miscellaneous/dos.m
+++ b/scripts/miscellaneous/dos.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: octave-forge ???
 ## Adapted by: jwe
 
 function [status, text] = dos (cmd, echo_arg)
 
   if (nargin < 1 || nargin > 2)
-    usage ( "[status, text] = dos (cmd, '-echo')");
+    print_usage ();
   elseif (! isunix ())
     [status, text] = system (cmd);
     if (nargin > 1 || nargout == 0)
       printf ("%s\n", text);
     endif
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/fileattrib.m b/scripts/miscellaneous/fileattrib.m
--- a/scripts/miscellaneous/fileattrib.m
+++ b/scripts/miscellaneous/fileattrib.m
@@ -127,12 +127,12 @@ function [status, msg, msgid] = fileattr
 		  "OtherWrite", r_o_w, "OtherExecute", r_o_x);
       if (nargout == 0)
 	status = r;
       else
 	msg = r;
       endif
     endif
   else
-    usage ("fileattrib (file)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -41,12 +41,12 @@ function [directory, name, extension, ve
       else
 	extension = "";
       endif
       version = "";
     else
       error ("fileparts: expecting filename argument to be a string");
     endif
   else
-    usage ("fileparts (filename)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/flops.m b/scripts/miscellaneous/flops.m
--- a/scripts/miscellaneous/flops.m
+++ b/scripts/miscellaneous/flops.m
@@ -23,16 +23,16 @@
 ## actually do anything.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = flops ()
 
   if (nargin > 1)
-    usage ("flops () or flops (n)");
+    print_usage ();
   endif
 
   warning ("flops is a flop, always returning zero");
 
   retval = 0;
 
 endfunction
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -39,12 +39,12 @@ function filename = fullfile (varargin)
 	tmp(1) = "";
       endif
       if (i < nargin && strcmp (tmp(end), filesep))
 	tmp(end) = "";
       endif
       filename = strcat (filename, filesep, tmp);
     endfor
   else
-    usage ("fullfile (dir1, dir2, ..., file)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/ispc.m b/scripts/miscellaneous/ispc.m
--- a/scripts/miscellaneous/ispc.m
+++ b/scripts/miscellaneous/ispc.m
@@ -22,12 +22,12 @@
 ## Return 1 if Octave is running on a Windows system and 0 otherwise.
 ## @end deftypefn
 
 function retval = ispc ()
 
   if (nargin == 0)
     retval = octave_config_info ("windows");
   else
-    usage ("ispc ()");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/isunix.m b/scripts/miscellaneous/isunix.m
--- a/scripts/miscellaneous/isunix.m
+++ b/scripts/miscellaneous/isunix.m
@@ -22,12 +22,12 @@
 ## Return 1 if Octave is running on a Unix-like system and 0 otherwise.
 ## @end deftypefn
 
 function retval = isunix ()
 
   if (nargin == 0)
     retval = octave_config_info ("unix");
   else
-    usage ("isunix ()");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -28,17 +28,17 @@
 ## @seealso{disp, printf, input}
 ## @end deftypefn
 
 ## Author: jwe
 
 function num = menu (t, varargin)
 
   if (nargin < 2)
-    usage ("menu (title, opt1, ...)");
+    print_usage ();
   endif
 
   ## Force pending output to appear before the menu.
 
   fflush (stdout);
 
   ## Don't send the menu through the pager since doing that can cause
   ## major confusion.
diff --git a/scripts/miscellaneous/not.m b/scripts/miscellaneous/not.m
--- a/scripts/miscellaneous/not.m
+++ b/scripts/miscellaneous/not.m
@@ -23,12 +23,12 @@
 ## @code{! val}.
 ## @end deftypefn
 
 function retval = not (val)
 
   if (nargin == 1)
     retval = ! val;
   else
-    usage ("not (val)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/popen2.m b/scripts/miscellaneous/popen2.m
--- a/scripts/miscellaneous/popen2.m
+++ b/scripts/miscellaneous/popen2.m
@@ -116,12 +116,12 @@ function [in, out, pid] = popen2 (comman
         endif
       else
         error ("popen2: pipe creation failed");
       endif
     else
       error ("popen2: file name must be a string");
     endif
   else
-    usage ("[in, out, pid] = popen2 (command, args)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/single.m b/scripts/miscellaneous/single.m
--- a/scripts/miscellaneous/single.m
+++ b/scripts/miscellaneous/single.m
@@ -26,12 +26,12 @@
 ## type.
 ## @end deftypefn
 
 function retval = single (val)
 
   if (nargin == 1 && isnumeric (val))
     retval = val;
   else
-    usage ("single (val)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/unix.m b/scripts/miscellaneous/unix.m
--- a/scripts/miscellaneous/unix.m
+++ b/scripts/miscellaneous/unix.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: octave-forge ???
 ## Adapted by: jwe
 
 function [status, text] = unix (cmd, echo_arg)
 
   if (nargin < 1 || nargin > 2)
-    usage ( "[status, text] = unix (cmd, '-echo')");
+    print_usage ();
   elseif (isunix ())
     [status, text] = system (cmd);
     if (nargin > 1 || nargout == 0)
       printf ("%s\n", text);
     endif
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -25,17 +25,17 @@
 ## @seealso{license, version}
 ## @end deftypefn
 
 ## Author: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function ver ()
 
   if (nargin > 0)
-    usage ("ver");
+    print_usage ();
   endif
 
   octave_license = license ();
 
   [unm, status] = uname ();
 
   if (status < 0)
     os_string = "unknown";
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -33,12 +33,12 @@ function z = xor (x, y)
 
   if (nargin == 2)
     if (isscalar (x) || isscalar (y) || size (x) == size (y))
       z = logical ((x | y) - (x & y));
     else
       error ("xor: x and y must be of common size or scalars");
     endif
   else
-    usage ("xor (x, y)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -391,17 +391,17 @@
 
 ## Author: Nicolo' Giorgetti <giorgetti@dii.unisi.it>
 ## Adapted-by: jwe
 
 function [xopt, fmin, status, extra] = glpk (c, a, b, lb, ub, ctype, vartype, sense, param)
 
   ## If there is no input output the version and syntax
   if (nargin < 3 || nargin > 9)
-    usage ("[xopt, fopt, status, extra] = glpk (c, a, b, lb, ub, ctype, vartype, sense, param)");
+    print_usage ();
     return;
   endif
 
   if (all (size (c) > 1) || iscomplex (c) || ischar (c))
     error ("C must be a real vector");
     return;
   endif
   nx = length (c);
diff --git a/scripts/optimization/glpkmex.m b/scripts/optimization/glpkmex.m
--- a/scripts/optimization/glpkmex.m
+++ b/scripts/optimization/glpkmex.m
@@ -23,17 +23,17 @@
 ## interface to the GNU GLPK library.  For Octave code, you should use
 ## the @code{glpk} function instead.
 ## @end deftypefn
 
 function [xopt, fopt, status, extra] = glpkmex (varargin)
 
   ## If there is no input output the version and syntax
   if (nargin < 4 || nargin > 11)
-    usage ("[xopt, fopt, status, extra] = glpkmex (sense, c, a, b, ctype, lb, ub, vartype, param, lpsolver, savepb");
+    print_usage ();
     return;
   endif
 
   ## reorder args:
   ##
   ##     glpkmex    glpk
   ##
   ##  1   sense      c
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -270,12 +270,12 @@ function [x, obj, INFO, lambda] = qp (x0
       x = x0;
       lambda = [];
     endif
     obj = 0.5 * x' * H * x + q' * x;
     INFO.solveiter = iter;
     INFO.info = info;
 
   else
-    usage ("[x, obj, info, lambda] = qp (x0, H, q, A, b, lb, ub, A_lb, Ain, A_ub)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -416,17 +416,17 @@ function [x, obj, info, iter, nf, lambda
     if (iter >= iter_max)
       info = 103;
     endif
 
     nf = nfun;
 
   else
 
-    usage ("[x, obj, info, iter, nf, lambda] = sqp (x, objf, cef, cif)");
+    print_usage ();
 
   endif
 
 ### endfunction
 
 
 function [merit, obj] = phi_L1 (obj, obj_fun, ce_fun, ci_fun, x, mu)
 
diff --git a/scripts/plot/__axis_label__.m b/scripts/plot/__axis_label__.m
--- a/scripts/plot/__axis_label__.m
+++ b/scripts/plot/__axis_label__.m
@@ -22,17 +22,17 @@
 ## Utility function for @code{xlabel}, @code{ylabel}, and @code{zlabel}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = __axis_label__ (caller, text)
 
   if (nargin == 0)
-    usage ("__axis_label__ (caller, text)");
+    print_usage ();
   elseif (nargin == 2)
     if (ischar (text))
       __gnuplot_raw__ (sprintf ("set %s \"%s\";\n", caller,
 				undo_string_escapes (text)));
       if (automatic_replot)
 	replot ();
       endif
     else
diff --git a/scripts/plot/__errplot__.m b/scripts/plot/__errplot__.m
--- a/scripts/plot/__errplot__.m
+++ b/scripts/plot/__errplot__.m
@@ -35,17 +35,17 @@
 
 function __errplot__ (fstr, a1, a2, a3, a4, a5, a6)
 
   __plot_globals__;
 
   __setup_plot__ ("__gnuplot_plot__");
 
   if (nargin < 3 || nargin > 7) # at least three data arguments needed
-    usage ("__errplot__ (fmt, arg1, ...)");
+    print_usage ();
   endif
 
   j = __plot_data_offset__{__current_figure__}(__multiplot_xi__,__multiplot_yi__);
 
   fmt = __pltopt__ ("__errplot__", fstr);
 
   nplots = size (a1, 2);
   len = size (a1, 1);
diff --git a/scripts/plot/__plr1__.m b/scripts/plot/__plr1__.m
--- a/scripts/plot/__plr1__.m
+++ b/scripts/plot/__plr1__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} __plr1__ (@var{theta}, @var{fmt})
 ## @end deftypefn
 
 ## Author: jwe
 
 function __plr1__ (theta, fmt)
 
   if (nargin != 2)
-    usage ("__plr1__ (theta, fmt)");
+    print_usage ();
   endif
 
   [nr, nc] = size (theta);
   if (nr == 1)
     theta = theta';
     tmp = nr;
     nr = nc;
     nc = tmp;
diff --git a/scripts/plot/__plr2__.m b/scripts/plot/__plr2__.m
--- a/scripts/plot/__plr2__.m
+++ b/scripts/plot/__plr2__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} __plr2__ (@var{theta}, @var{rho}, @var{fmt})
 ## @end deftypefn
 
 ## Author: jwe
 
 function __plr2__ (theta, rho, fmt)
 
   if (nargin != 3)
-    usage ("__plr2__ (theta, rho, fmt)");
+    print_usage ();
   endif
 
   if (any (imag (theta)))
     theta = real (theta);
   endif
 
   if (any (imag (rho)))
     rho = real (rho);
diff --git a/scripts/plot/__plr__.m b/scripts/plot/__plr__.m
--- a/scripts/plot/__plr__.m
+++ b/scripts/plot/__plr__.m
@@ -125,12 +125,12 @@ function __plr__ (theta, rho, fmt)
           error ("polar: matrix dimensions must match");
         endif
         x = rho .* cos (theta);
         y = rho .* sin (theta);
         __plt__ ("polar", x, y, fmt);
       endif
     endif
   else
-    usage ("__plr__ (x, y)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/__plt1__.m b/scripts/plot/__plt1__.m
--- a/scripts/plot/__plt1__.m
+++ b/scripts/plot/__plt1__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {[data, fmtstr] =} __plt1__ (@var{x1}, @var{fmt})
 ## @end deftypefn
 
 ## Author: jwe
 
 function [data, fmtstr] = __plt1__ (x1, fmt)
 
   if (nargin < 1 || nargin > 2 || nargout != 2)
-    usage ("[data, fmtstr] = __plt1__ (x1, fmt)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     fmt = "";
   endif
 
   if (! ischar (fmt))
     error ("__plt1__: fmt must be a string");
diff --git a/scripts/plot/__plt2__.m b/scripts/plot/__plt2__.m
--- a/scripts/plot/__plt2__.m
+++ b/scripts/plot/__plt2__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {[data, fmtstr] =} __plt2__ (@var{x1}, @var{x2}, @var{fmt})
 ## @end deftypefn
 
 ## Author: jwe
 
 function [data, fmtstr] = __plt2__ (x1, x2, fmt)
 
   if (nargin < 2 || nargin > 3 || nargout != 2)
-    usage ("[data, fmtstr] = __plt2__ (x1, x2, fmt)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     fmt = "";
   endif
 
   if (! ischar (fmt))
     error ("__plt2__: fmt must be a string");
diff --git a/scripts/plot/__plt2mm__.m b/scripts/plot/__plt2mm__.m
--- a/scripts/plot/__plt2mm__.m
+++ b/scripts/plot/__plt2mm__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {[data, fmtstr] =} __plt2mm__ (@var{x}, @var{y}, @var{fmt})
 ## @end deftypefn
 
 ## Author: jwe
 
 function [data, fmtstr] = __plt2mm__ (x, y, fmt)
 
   if (nargin < 2 || nargin > 3 || nargout != 2)
-    usage ("[data, fmtstr] = __plt2mm__ (x, y, fmt)");
+    print_usage ();
   elseif (nargin == 2 || isempty (fmt))
     fmt = " ";  ## Yes, this is intentionally not an empty string!
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   k = 1;
diff --git a/scripts/plot/__plt2mv__.m b/scripts/plot/__plt2mv__.m
--- a/scripts/plot/__plt2mv__.m
+++ b/scripts/plot/__plt2mv__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {[data, fmtstr] =} __plt2mv__ (@var{x}, @var{y}, @var{fmt})
 ## @end deftypefn
 
 ## Author: jwe
 
 function [data, fmtstr] = __plt2mv__ (x, y, fmt)
 
   if (nargin < 2 || nargin > 3 || nargout != 2)
-    usage ("[data, fmtstr] = __plt2mv__ (x, y, fmt)");
+    print_usage ();
   elseif (nargin == 2 || isempty (fmt))
     fmt = " ";  ## Yes, this is intentionally not an empty string!
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (y_nr == 1)
diff --git a/scripts/plot/__plt2ss__.m b/scripts/plot/__plt2ss__.m
--- a/scripts/plot/__plt2ss__.m
+++ b/scripts/plot/__plt2ss__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {[data, fmtstr] =} __plt2ss__ (@var{x}, @var{y}, @var{fmt})
 ## @end deftypefn
 
 ## Author: jwe
 
 function [data, fmtstr] = __plt2ss__ (x, y, fmt)
 
   if (nargin < 2 || nargin > 3 || nargout != 2)
-    usage ("[data, fmtstr] = __plt2ss__ (x, y, fmt)");
+    print_usage ();
   elseif (nargin == 2)
     fmt = "";
   elseif (rows (fmt) > 1)
     fmt = fmt (1, :);
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
diff --git a/scripts/plot/__plt2vm__.m b/scripts/plot/__plt2vm__.m
--- a/scripts/plot/__plt2vm__.m
+++ b/scripts/plot/__plt2vm__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {[data, fmtstr] =} __plt2vm__ (@var{x}, @var{y}, @var{fmt})
 ## @end deftypefn
 
 ## Author: jwe
 
 function [data, fmtstr] = __plt2vm__ (x, y, fmt)
 
   if (nargin < 2 || nargin > 3 || nargout != 2)
-    usage ("[data, fmtstr] = __plt2vm__ (x, y, fmt)");
+    print_usage ();
   elseif (nargin == 2 || isempty (fmt))
     fmt = " ";  ## Yes, this is intentionally not an empty string!
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (x_nr == 1)
diff --git a/scripts/plot/__plt2vv__.m b/scripts/plot/__plt2vv__.m
--- a/scripts/plot/__plt2vv__.m
+++ b/scripts/plot/__plt2vv__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {[data, fmtstr] =} __plt2vv__ (@var{x}, @var{y}, @var{fmt})
 ## @end deftypefn
 
 ## Author: jwe
 
 function [data, fmtstr] = __plt2vv__ (x, y, fmt)
 
   if (nargin < 2 || nargin > 3 || nargout != 2)
-    usage ("[data, fmtstr] = __plt2vv__ (x, y, fmt)");
+    print_usage ();
   elseif (nargin == 2)
     fmt = "";
   elseif (rows (fmt) > 1)
     fmt = fmt (1, :);
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
diff --git a/scripts/plot/__pltopt1__.m b/scripts/plot/__pltopt1__.m
--- a/scripts/plot/__pltopt1__.m
+++ b/scripts/plot/__pltopt1__.m
@@ -56,17 +56,17 @@ function fmt = __pltopt1__ (caller, opt)
   IMPULSES = "i";
   STEPS = "s";
   YERRORBARS = "yerr";
   XERRORBARS = "xerr";
   XYERRORBARS = "xyerr";
   TITLE = "title";
 
   if (nargin != 2)
-    usage ("__pltopt1__ (caller, opt)");
+    print_usage ();
   endif
 
   if (! ischar (opt))
     error ("__pltopt1__: argument must be a string");
   endif
 
   while (more_opts)
 
diff --git a/scripts/plot/__pltopt__.m b/scripts/plot/__pltopt__.m
--- a/scripts/plot/__pltopt__.m
+++ b/scripts/plot/__pltopt__.m
@@ -106,17 +106,17 @@
 ## @seealso{__pltopt1__}
 ## @end deftypefn
 
 ## Author: jwe
 
 function fmt = __pltopt__ (caller, opt)
 
   if (! ischar (opt))
-    usage ("__pltopt__ (caller, opt)");
+    print_usage ();
   endif
 
   nr = rows (opt);
   fmt = "";
   for i = 1:nr
     t = __pltopt1__ (caller, deblank (opt(i,:)));
     fmt(i,1:length(t)) = t;
   endfor
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -106,17 +106,17 @@ function [xb, yb] = bar (x, y)
         endfor
       else
         error ("bar: arguments must be the same length");
       endif
     else
       error ("bar: arguments must be vectors");
     endif
   else
-    usage ("[xb, yb] = bar (x, y)");
+    print_usage ();
   endif
 
   if (nargout == 0)
     plot (tmp_xb, tmp_yb);
   else
     xb = tmp_xb;
     yb = tmp_yb;
   endif
diff --git a/scripts/plot/bottom_title.m b/scripts/plot/bottom_title.m
--- a/scripts/plot/bottom_title.m
+++ b/scripts/plot/bottom_title.m
@@ -23,17 +23,17 @@
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
 
 function bottom_title (text)
 
   if (nargin != 1)
-    usage ("bottom_title (text)");
+    print_usage ();
   endif
 
   if (ischar (text))
     __gnuplot_raw__ ("set top_title;\n");
     __gnuplot_raw__ ("set title;\n");
     __gnuplot_raw__ (sprintf ("set bottom_title \"%s\";\n",
 			      undo_string_escapes (text)));
   else
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -55,16 +55,16 @@ function retval = close (arg1, arg2)
 	warning ("close: unable to close plot windows by handle");
       endif
     endif
   elseif (nargin == 2
 	  && ischar (arg1) && strcmp (arg1, "all")
 	  && ischar (arg2) && strcmp (arg2, "hidden"))
     closeplot;
   else
-    usage ("close [all]");
+    print_usage ();
   endif
 
   if (nargout > 0)
     retval = 1;
   endif
 
 endfunction
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -128,12 +128,12 @@ function contour (x, y, z, n)
 	__plt3__ (zz, "", "", [gnuplot_command_with, " l 1"]);
       unwind_protect_cleanup
 	__gnuplot_set__ noparametric;
       end_unwind_protect
     else
       error ("contour: x and y must be vectors and z must be a matrix");
     endif
   else
-    usage ("contour (x, y, z, levels) or contour (z, levels)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -107,17 +107,17 @@
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function errorbar (varargin)
 
   if (nargin < 2)
-    usage ("errorbar (...)");
+    print_usage ();
   endif
 
   __gnuplot_raw__ ("set nologscale x;\n");
   __gnuplot_raw__ ("set nologscale y;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   __errcomm__ ("errorbar", varargin{:});
 
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -48,12 +48,12 @@ function f = figure (n)
     endif
     figure_list = union (figure_list, f);
   elseif (rem (nargin, 2) == 0)
     if (! figure_called)
       figure_called = 1;
       warning ("figure: setting figure properties is unsupported");
     endif
   else
-    usage ("figure (n)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -30,17 +30,17 @@
 ## @example
 ##    fplot('cos',[0,2*pi])
 ##    fplot('[cos(x),sin(x)]',[0,2*pi])
 ## @end example
 ## @end deftypefn
 
 function fplot (fn, limits, n)
   if (nargin < 2 || nargin > 3)
-    usage ("fplot (fn, limits, n)");
+    print_usage ();
   endif
 
   if (nargin < 3) 
     n = 100; 
   endif
 
   x = linspace (limits(1), limits(2), n)';
 
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -38,18 +38,16 @@
 ## PKG_ADD: mark_as_command grid
 
 function grid (x, y)
 
   persistent grid_on = false;
   persistent minor_on = false;
   persistent minor_tics = 5;
 
-  usage_msg = "grid (\"on\" | \"off\")";
-
   do_replot = false;
 
   if (nargin == 0)
     grid_on = ! grid_on;
     if (grid_on)
       __gnuplot_raw__ ("set grid;\n");
     else
       __gnuplot_raw__ ("set nogrid;\n");
@@ -79,17 +77,17 @@ function grid (x, y)
             __gnuplot_raw__ ("set grid xtics nomxtics ytics nomxtics;\n");
 	  else
 	    __gnuplot_raw__ ("set grid noxtics nomxtics noytics nomxtics;\n");
 	  endif
 	  minor_on = false;
 	endif
 	do_replot = true;
       else
-	usage (usage_msg);
+	print_usage ();
       endif
     else
       error ("grid: argument must be a string");
     endif
   elseif (nargin == 2)
     if (ischar (x))
       if (strcmp ("minor", x))
 	d = str2num (y);
@@ -104,40 +102,40 @@ function grid (x, y)
 	  elseif (strcmp ("on", y))
 	    cmd = sprintf ("set mxtics %d;\n", minor_tics);
 	    __gnuplot_raw__ (cmd);
 	    cmd = sprintf ("set mytics %d;\n", minor_tics);
 	    __gnuplot_raw__ (cmd);
             __gnuplot_raw__ ("set grid xtics mxtics ytics mxtics;\n");
 	    minor_on = true;
 	  else
-	    usage (usage_msg);
+	    print_usage ();
 	  endif
 	  do_replot = true;
 	else
 	  if (isscalar(d) && ! isnan (d) && ! isinf (d))
 	    minor_tics = max (floor (d), 0);
 	    cmd = sprintf ("set mxtics %d;\n", minor_tics);
 	    __gnuplot_raw__ (cmd);
 	    cmd = sprintf("set mytics %d;\n", minor_tics);
 	    __gnuplot_raw__ (cmd);
             __gnuplot_raw__ ("set grid xtics mxtics ytics mxtics;\n");
 	    minor_on = true;
 	    do_replot = true;
 	  else
-	    usage (usage_msg);
+	    print_usage ();;
 	  endif
 	endif
       else
-	usage (usage_msg);
+	print_usage ();;
       endif
     else
-      usage (usage_msg);
+      print_usage ();;
     endif    
   else
-    usage (usage_msg);
+    print_usage ();;
   endif    
 
   if (do_replot && automatic_replot)
     replot ();
   endif
 
 endfunction
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -41,17 +41,17 @@
 ## @seealso{bar}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [nn, xx] = hist (y, x, norm)
 
   if (nargin < 1 || nargin > 3)
-    usage ("[nn, xx] = hist (y, x, norm)");
+    print_usage ();
   endif
 
   arg_is_vector = isvector (y);
 
   if (rows (y) == 1)
     y = y(:);
   endif
 
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -49,25 +49,23 @@ function hold (arg)
   if (isempty (__hold_state__))
     __hold_state__ = false;
   endif
 
   if (length (__hold_state__) < __current_figure__)
     __hold_state__(__current_figure__) = false;
   endif
 
-  usage_msg = "hold (\"on\") or hold (\"off\")";
-
   if (nargin == 0)
     __hold_state__(__current_figure__) = ! __hold_state__(__current_figure__);
   elseif (nargin == 1)
     if (strcmp (arg, "on"))
       __hold_state__(__current_figure__) = true;
     elseif (strcmp (arg, "off"))
       __hold_state__(__current_figure__) = false;
     else
-      usage (usage_msg);
+      print_usage ();
     endif
   else
-    usage (usage_msg);
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/ishold.m b/scripts/plot/ishold.m
--- a/scripts/plot/ishold.m
+++ b/scripts/plot/ishold.m
@@ -38,12 +38,12 @@ function retval = ishold ()
 
   if (length (__hold_state__) < __current_figure__)
     __hold_state__(__current_figure__) = false;
   endif
 
   if (nargin == 0)
     retval = __hold_state__(__current_figure__);
   else
-    usage ("ishold ()");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -38,17 +38,17 @@
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function loglogerr (varargin)
 
   if (nargin < 2)
-    usage ("loglogerr(...)");
+    print_usage ();
   endif
 
   __gnuplot_raw__ ("set logscale x;\n");
   __gnuplot_raw__ ("set logscale y;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   __errcomm__ ("loglogerr", varargin{:});
 
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -113,12 +113,12 @@ function mesh (x, y, z)
 	end_unwind_protect
       else
         error ("mesh: x, y, and z must have same dimensions");
       endif
     else
       error ("mesh: x and y must be vectors and z must be a matrix");
     endif
   else
-    usage ("mesh (z)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/meshdom.m b/scripts/plot/meshdom.m
--- a/scripts/plot/meshdom.m
+++ b/scripts/plot/meshdom.m
@@ -33,12 +33,12 @@ function [xx, yy] = meshdom (x, y)
   if (nargin == 2)
     if (isvector (x) && isvector (y))
       xx = ones (length (y), 1) * x(:).';
       yy = flipud (y(:)) * ones (1, length (x));
     else
       error ("meshdom: arguments must be vectors");
     endif
   else
-    usage ("[xx, yy] = meshdom (x, y)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -32,17 +32,17 @@
 ## @seealso{mesh, contour}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [xx, yy, zz] = meshgrid (x, y, z)
 
   if (nargin == 0 || nargin > 3)
-    usage ("[xx, yy, zz] = meshgrid (x, y, z)");
+    print_usage ();
   endif
 
   if (nargin < 2)
     y = x;
   endif
 
   if (nargout < 3)
     if (isvector (x) && isvector (y))
diff --git a/scripts/plot/multiplot.m b/scripts/plot/multiplot.m
--- a/scripts/plot/multiplot.m
+++ b/scripts/plot/multiplot.m
@@ -39,17 +39,17 @@ function multiplot (xn, yn)
   global __multiplot_xsize__;
   global __multiplot_ysize__;
   global __multiplot_xn__;
   global __multiplot_yn__;
   global __multiplot_xi__;
   global __multiplot_yi__;
 
   if (nargin != 2)
-    usage ("multiplot (xn, yn)");
+    print_usage ();
   endif
 
   if (! (isscalar (xn) && isscalar (yn)))
     error ("multiplot: xn and yn have to be scalars");
   endif
 
   xn = round (xn);
   yn = round (yn);
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -37,17 +37,17 @@ function retval = orient (orientation)
     retval = __print_orientation__;
   elseif (nargin == 1)
     if (strcmp (orientation, "landscape") || strcmp (orientation, "portrait"))
       __print_orientation__ = orientation;
     else
       error ("orient: unknown orientation");
     endif
   else
-    usage("orient ([\"portrait\"|\"landscape\"])  OR  ret = orient ()");
+    print_usage ();
   endif
 
 endfunction
 
 %!assert(orient,"landscape") # default
 %!test orient('portrait')
 %!assert(orient,"portrait")  # change to portrait
 %!test orient('landscape')
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -49,12 +49,12 @@ function polar (x1, x2, fmt)
     else
       fmt = "";
       __plr2__ (x1, x2, fmt);
     endif
   elseif (nargin == 1)
     fmt = "";
     __plr1__ (x1, fmt);
   else
-    usage ("polar (theta, rho, fmt)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/replot.m b/scripts/plot/replot.m
--- a/scripts/plot/replot.m
+++ b/scripts/plot/replot.m
@@ -31,12 +31,12 @@ function replot ()
   if (nargin == 0)
     if (! isempty (__plot_command__{__current_figure__}{__multiplot_xi__,__multiplot_yi__}))
       if (__multiplot_mode__)
 	__gnuplot_raw__ ("clear\n");
       endif
       eval (__plot_command__{__current_figure__}{__multiplot_xi__,__multiplot_yi__});
     endif
   else
-    usage ("replot ()");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -38,17 +38,17 @@
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function semilogxerr (varargin)
 
   if (nargin < 2)
-    usage ("semilogxerr (...)");
+    print_usage ();
   endif
 
   __gnuplot_raw__ ("set logscale x;\n");
   __gnuplot_raw__ ("set nologscale y;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   __errcomm__ ("semilogxerr", varargin{:});
 
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -38,17 +38,17 @@
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function semilogyerr (varargin)
 
   if (nargin < 2)
-    usage ("semilogyerr (...)");
+    print_usage ();
   endif
 
   __gnuplot_raw__ ("set nologscale x;\n");
   __gnuplot_raw__ ("set logscale y;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   __errcomm__ ("semilogyerr", varargin{:});
 
diff --git a/scripts/plot/sombrero.m b/scripts/plot/sombrero.m
--- a/scripts/plot/sombrero.m
+++ b/scripts/plot/sombrero.m
@@ -42,12 +42,12 @@ function sombrero (n)
       [xx, yy] = meshgrid (x, y);
       r = sqrt (xx .^ 2 + yy .^ 2) + eps;
       z = sin (r) ./ r;
       mesh (x, y, z);
     else
       error ("sombrero: number of grid lines must be greater than 1");
     endif
   else
-    usage ("sombrero (n)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -90,17 +90,17 @@ function [xs, ys] = stairs (x, y)
         tmp_ys(len) = y(ylen);
       else
         error ("stairs: arguments must be the same length");
       endif
     else
       error ("stairs: arguments must be vectors");
     endif
   else
-    usage ("[xs, ys] = stairs (x, y)");
+    print_usage ();
   endif
 
   if (nargout == 0)
     plot (tmp_xs, tmp_ys);
   else
     xs = tmp_xs;
     ys = tmp_ys;
   endif
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -81,17 +81,17 @@
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
 
 function subplot (rows, columns, index)
 
   __plot_globals__;
 
   if (nargin != 3 && nargin != 1)
-    usage ("subplot (rows, columns, index) or subplot (rcn)");
+    print_usage ();
   endif
 
   if (nargin == 1)
 
     if (! (isscalar (rows) && rows >= 0))
       error ("subplot: input rcn has to be a positive scalar");
     endif
 
diff --git a/scripts/plot/subwindow.m b/scripts/plot/subwindow.m
--- a/scripts/plot/subwindow.m
+++ b/scripts/plot/subwindow.m
@@ -37,17 +37,17 @@ function subwindow (xn, yn)
   global __multiplot_xsize__;
   global __multiplot_ysize__;
   global __multiplot_xn__;
   global __multiplot_yn__;
 
   ## check calling argument count
 
   if (nargin != 2)
-    usage ("subwindow (xn, yn)");
+    print_usage ();
   endif
 
   ## check for scalar inputs
 
   if (! (isscalar (xn) && isscalar (yn)))
     error ("subwindow: xn and yn have to be scalars");
   endif
 
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -24,17 +24,17 @@
 ## bar, stairs, replot, xlabel, ylabel}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = title (text)
 
   if (nargin != 1)
-    usage ("title (text)");
+    print_usage ();
   endif
 
   if (ischar (text))
     __gnuplot_raw__ (sprintf ("set title \"%s\";\n",
 			      undo_string_escapes (text)));
     if (automatic_replot)
       replot ();
     endif
diff --git a/scripts/plot/top_title.m b/scripts/plot/top_title.m
--- a/scripts/plot/top_title.m
+++ b/scripts/plot/top_title.m
@@ -25,17 +25,17 @@
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Created: 3 July 95
 ## Adapted-By: jwe
 
 function top_title (text)
 
   if (nargin != 1)
-    usage ("top_title (text)");
+    print_usage ();
   endif
 
   if (ischar (text))
     __gnuplot_raw__ ("set bottom_title;\n")
     __gnuplot_raw__ ("set title;\n")
     __gnuplot_raw__ (sprintf ("set top_title \"%s\";\n",
 			      undo_string_escapes (text)));
     if (automatic_replot)
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -57,17 +57,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function A = compan (c)
 
   if (nargin != 1)
-    usage ("compan (vector)");
+    print_usage ();
   endif
 
   if (! isvector (c))
     error ("compan: expecting a vector argument");
   endif
 
   ## Ensure that c is a row vector.
 
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -30,17 +30,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = conv (a, b)
 
   if (nargin != 2)
-    usage ("conv(a, b)");
+    print_usage ();
   endif
 
   if (! (isvector (a) && isvector (b)))
     error("conv: both arguments must be vectors");
   endif
 
   la = length (a);
   lb = length (b);
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -32,17 +32,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [b, r] = deconv (y, a)
 
   if (nargin != 2)
-    usage ("deconv (y, a)");
+    print_usage ();
   endif
 
   if (! (isvector (y) && isvector (a)))
     error("conv: both arguments must be vectors");
   endif
 
   la = length (a);
   ly = length (y);
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -37,17 +37,17 @@
 ## last dimension. If @var{d} is not specified it will be computed as
 ## @code{round (rows (@var{p}) / (length (@var{x}) - 1)) instead.
 ##
 ## @seealso{unmkpp, ppval, spline}
 ## @end deftypefn
 
 function pp = mkpp (x, P, d)
   if (nargin < 2 || nargin > 3)
-    usage ("pp = mkpp(x,P,d)");
+    print_usage ();
   endif
   pp.x = x(:);
   pp.P = P;
   pp.n = length (x) - 1;
   pp.k = columns (P);
   if (nargin < 3)
     d = round (rows (P) / pp.n); 
   endif
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -28,30 +28,30 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function y = poly (x)
 
   if (nargin != 1)
-    usage ("poly (x)");
+    print_usage ();
   endif
 
   m = min (size (x));
   n = max (size (x));
   if (m == 0)
     y = 1;
     return;
   elseif (m == 1)
     v = x;
   elseif (m == n)
     v = eig (x);
   else
-    usage ("poly (x), where x is a vector or a square matrix");
+    print_usage ();
   endif
 
   y = zeros (1, n+1);
   y(1) = 1;
   for j = 1:n;
     y(2:(j+1)) = y(2:(j+1)) - v(j) .* y(1:j);
   endfor
 
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -32,12 +32,12 @@ function [q, r] = polyder (p, a)
     q = polyderiv (p);
   elseif (nargin == 2)
     if (nargout == 2)
       [q, r] = polyderiv (p, a);
     else
       q = polyderiv (p, a);
     endif
   else
-    usage ("q = polyder (p) or q = polyder (b, a) or [q, r] = polyder (b, a)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -81,13 +81,13 @@ function [q, r] = polyderiv (p, a)
       endif
 
       ## Force P to be a row vector.
       p = p(:).';
 
       q = p(1:(lp-1)) .* [(lp-1):-1:1];
     endif
   else
-    usage ("q = polyderiv (p) or q = polyderiv (b, a) or [q, r] = polyderiv (b, a)");
+    print_usage ();
   endif
 
 
 endfunction
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -56,17 +56,17 @@
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 13 December 1994
 ## Adapted-By: jwe
 
 function [p, s, mu] = polyfit (x, y, n)
 
 
   if (nargin != 3)
-    usage ("polyfit (x, y, n)");
+    print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y) && size (x) == size (y)))
     error ("polyfit: x and y must be vectors of the same size");
   endif
 
   if (! (isscalar (n) && n >= 0 && ! isinf (n) && n == round (n)))
     error ("polyfit: n must be a nonnegative integer");
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -62,12 +62,12 @@ function x = polygcd (b, a, tol)
 	else
 	  r = r(nz(1):length(r));
 	endif
 	b = a;
 	a = r / r(1);
       endwhile
     endif
   else
-    usage ("x = polygcd (b, a [,tol])");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/polynomial/polyinteg.m b/scripts/polynomial/polyinteg.m
--- a/scripts/polynomial/polyinteg.m
+++ b/scripts/polynomial/polyinteg.m
@@ -29,17 +29,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyinteg (p)
 
   if(nargin != 1)
-    usage ("polyinteg (vector)");
+    print_usage ();
   endif
 
   if (! (isvector (p) || isempty (p)))
     error ("argument must be a vector");
   endif
 
   lp = length (p);
 
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -39,17 +39,17 @@
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: May 1995
 ## Nov 1998: Correctly handles complex coefficients
 
 function y = polyout (c, x)
 
   if (nargin < 1) || (nargin > 2) || (nargout < 0) || (nargout > 1)
-    usage("polyout (c, x)");
+    print_usage ();
   endif
 
   if (! isvector (c))
     error("polyout: first argument must be a vector");
   endif
 
   if (nargin == 1)
     x = "s";
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -27,17 +27,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function p = polyreduce (p)
 
   if (nargin != 1)
-    usage ("polyreduce (p)");
+    print_usage ();
   endif
 
   if (! (isvector (p) || isempty (p)))
     error ("polyreduce: argument must be a vector");
   endif
 
   if (! isempty (p) )
 
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -32,17 +32,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyval (c, x)
 
   if (nargin != 2)
-    usage ("polyval (c, x)");
+    print_usage ();
   endif
 
   if (! (isvector (c) || isempty (c)))
     error ("polyval: first argument must be a vector");
   endif
 
   if (isempty (x))
     y = [];
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -32,17 +32,17 @@
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyvalm (c, x)
 
   if (nargin != 2)
-    usage ("polyvalm (c, x)");
+    print_usage ();
   endif
 
   if (! (isvector (c) || isempty (c)))
     error ("polyvalm: first argument must be a vector");
   endif
 
   if (! issquare (x))
     error ("polyvalm: second argument must be a square matrix");
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -24,17 +24,17 @@
 ## then the returned value @var{yi} will be an array that is 
 ## @code{d1, d1, @dots{}, dk, length (@var{xi})]}.
 ## @seealso{mkpp, unmkpp, spline}
 ## @end deftypefn 
 
 function yi = ppval (pp, xi)
 
   if (nargin != 2)
-    usage ("yi = ppval(pp, xi)")
+    print_usage ();
   endif
   if (! isstruct (pp))
     error ("ppval: expects a pp structure");
   endif
   if (isempty (xi))
     yi = [];
   else
     transposed = (columns (xi) == 1);
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -165,17 +165,17 @@ function [r, p, k, e] = residue (b, a, t
   ##
   ## | 4|   | 1 0 0 |   | r(1) |
   ## | 1| = | 0 0 1 | * | r(2) |
   ## |-2|   | 0 1 1 |   | r(3) |
   ##
   ## We then solve for the residues using matrix division.
 
   if (nargin < 2 || nargin > 3)
-    usage ("residue (b, a, toler)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     toler = .001;
   endif
 
   ## Make sure both polynomials are in reduced form.
 
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -39,17 +39,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function r = roots (v)
 
   if (min (size (v)) > 1 || nargin != 1)
-    usage ("roots (v), where v is a vector");
+    print_usage ();
   endif
 
   n = length (v);
   v = reshape (v, 1, n);
 
   ## If v = [ 0 ... 0 v(k+1) ... v(k+l) 0 ... 0 ], we can remove the
   ## leading k zeros and n - k - l roots of the polynomial are zero.
 
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -43,17 +43,17 @@
 ## Number of polynomials defined for each interval.
 ## @end table
 ##
 ## @seealso{mkpp, ppval, spline}
 ## @end deftypefn
 
 function [x, P, n, k, d] = unmkpp (pp)
   if (nargin == 0)
-    usage ("[x, P, n, k, d] = unmkpp(pp)")
+    print_usage ();
   endif
   if (! isstruct (pp))
     error ("unmkpp: expecting piecewise polynomial structure");
   endif
   x = pp.x;
   P = pp.P;
   n = pp.n;
   k = pp.k;
diff --git a/scripts/quaternion/quaternion.m b/scripts/quaternion/quaternion.m
--- a/scripts/quaternion/quaternion.m
+++ b/scripts/quaternion/quaternion.m
@@ -65,22 +65,22 @@ function [a, b, c, d] = quaternion (w, x
 	  if (sin_th_2 != 0)
 	    vv = [a, b, c] / sin_th_2;
 	  else
 	    vv = [a, b, c];
 	  endif
 	  a = vv;
 	  b = theta;
 	otherwise
-	  usage ("[a, b, c, d] = quaternion (w) or [vv, theta] = quaternion (w)");
+	  print_usage ();
       endswitch
 
   case(2)
     if (nargout != 1)
-      usage ("w = quaterion (vv, theta)");
+      print_usage ();
     endif
     vv = w;
     theta = x;
 
     if (! isvector (vv) || length (vv) != 3)
       error ("vv must be a length three vector");
     elseif (! isscalar (theta))
       error ("theta must be a scalar");
@@ -96,21 +96,21 @@ function [a, b, c, d] = quaternion (w, x
       theta = rem (theta, 2*pi);
     endif
     vv = vv * sin (theta / 2);
     d = cos (theta / 2);
     a = quaternion (vv(1), vv(2), vv(3), d);
 
   case(4)
     if (nargout != 1)
-      usage ("w = quaterion (a, b, c, d)");
+      print_usage ();
     endif
     if (! (isscalar (w) && isscalar (x) && isscalar (y) && isscalar (z)))
       error ("input values must be scalars");
     endif
     a = [w, x, y, z];
 
   otherwise
-    usage ("[a, b, c, d] = quaternion (w) or a = quaternion (w, x, y, z)");
+    print_usage ();
 
   endswitch
 
 endfunction
diff --git a/scripts/set/complement.m b/scripts/set/complement.m
--- a/scripts/set/complement.m
+++ b/scripts/set/complement.m
@@ -31,17 +31,17 @@
 ## @seealso{create_set, union, intersection}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = complement (a, b)
 
   if (nargin != 2)
-    usage ("complement(a,b)");
+    print_usage ();
   endif
 
   if (isempty (a))
     y = create_set(b);
   elseif (isempty (b))
     y = [];
   else
     a = create_set (a);
diff --git a/scripts/set/create_set.m b/scripts/set/create_set.m
--- a/scripts/set/create_set.m
+++ b/scripts/set/create_set.m
@@ -31,17 +31,17 @@
 ## @seealso{union, intersection, complement}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = create_set(x)
 
   if (nargin != 1)
-    usage ("create_set(x)");
+    print_usage ();
   endif
 
   if (isempty(x))
     y = [];
   else
     nel = numel (x);
     y = sort (reshape (x, 1, nel));
     els = find (y(1:nel-1) != y(2:nel));
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -28,17 +28,17 @@
 ## Return index vectors @var{ia} and @var{ib} such that @code{a(ia)==c} and
 ## @code{b(ib)==c}.
 ##
 ## @end deftypefn
 ## @seealso{unique, union, setxor, setdiff, ismember}
 
 function [c, ia, ib] = intersect (a, b)
   if (nargin != 2)
-    usage ("intersect (a, b)");
+    print_usage ();
   endif
 
   if (isempty (a) || isempty (b))
     c = ia = ib = [];
   else
     ## form a and b into sets
     [a, ja] = unique (a);
     [b, jb] = unique (b);
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Adapted-by: jwe
 
 function c = ismember (a, S)
 
   if (nargin != 2)
-    usage ("ismember (A, S)");
+    print_usage ();
   endif
 
   [ra, ca] = size (a);
   if (isempty (a) || isempty (S))
     c = zeros (ra, ca);
   else
     if (iscell (a) && ! iscell (S))
       tmp{1} = S;
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -30,17 +30,17 @@
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Adapted-by: jwe
 
 function c = setdiff (a, b, byrows)
 
   if (nargin < 2 || nargin > 3)
-    usage ("setdiff (a, b) or setdiff (a, b, \"rows\")");
+    print_usage ();
   endif
 
   if (nargin == 3)
     if (! strcmpi (byrows, "rows"))
       error ("expecting third argument to be \"rows\"");
     else
       byrows = true;
     endif
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -24,17 +24,17 @@
 ## order. If @var{a} and @var{b} are both column vectors return a column
 ## vector, otherwise return a row vector.
 ##
 ## @seealso{unique, union, intersect, setdiff, ismember}
 ## @end deftypefn
 
 function c = setxor (a, b)
   if (nargin != 2)
-    usage ("setxor(a,b)");
+    print_usage ();
   endif
 
   ## Form A and B into sets.
   a = unique (a);
   b = unique (b);
 
   if (isempty (a))
     c = b;
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -31,17 +31,17 @@
 ## @seealso{create_set, intersection, complement}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = union(a,b)
 
   if (nargin != 2)
-    usage ("union(a,b)");
+    print_usage ();
   endif
 
   if (isempty (a))
     y = create_set (b);
   elseif (isempty (b))
     y = create_set (a);
   else
     y = create_set ([a(:); b(:)]);
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -31,17 +31,17 @@
 ## Return index vectors @var{i} and @var{j} such that @code{x(i)==y} and
 ## @code{y(j)==x}.
 ## @seealso{union, intersect, setdiff, setxor, ismember}
 ## @end deftypefn
 
 function [y, i, j] = unique (x, r)
 
   if (nargin < 1 || nargin > 2 || (nargin == 2 && ! strcmp (r, "rows")))
-    usage ("unique (x) or unique (x, 'rows')");
+    print_usage ();
   endif
 
   if (nargin == 1)
     n = prod (size (x));
   else
     n = size (x, 1);
   endif
 
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -47,17 +47,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Fit an ARCH regression model
 
 function [a, b] = arch_fit (y, X, p, ITER, gamma, a0, b0)
 
   if ((nargin < 3) || (nargin == 6) || (nargin > 7))
-    usage ("arch_fit (y, X, p, ITER, gamma, a0, b0)");
+    print_usage ();
   endif
 
   if (! (isvector (y)))
     error ("arch_test: y must be a vector");
   endif
 
   T   = length (y);
   y   = reshape (y, T, 1);
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -37,17 +37,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Simulate an ARCH process
 
 function y = arch_rnd (a, b, T)
 
   if (nargin != 3)
-    usage ("arch_rnd (a, b, T)");
+    print_usage ();
   endif
 
   if (! ((min (size (a)) == 1) && (min (size (b)) == 1)))
     error ("arch_rnd: a and b must both be scalars or vectors");
   endif
   if (! (isscalar (T) && (T > 0) && (rem (T, 1) == 0)))
     error ("arch_rnd: T must be a positive integer");
   endif
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -44,17 +44,17 @@ function x = arma_rnd (a, b, v, t, n)
 
   if (nargin == 4)
     n = 100;
   elseif (nargin == 5)
     if (!isscalar (t))
       error ("arma_rnd: n must be a scalar");
     endif
   else
-    usage ("arma_rnd (a, b, v, t, n)");
+    print_usage ();
   endif
 
   if ((min (size (a)) > 1) || (min (size (b)) > 1))
     error ("arma_rnd: a and b must not be matrices");
   endif
 
   if (!isscalar (t))
     error ("arma_rnd: t must be a scalar");
diff --git a/scripts/signal/autocor.m b/scripts/signal/autocor.m
--- a/scripts/signal/autocor.m
+++ b/scripts/signal/autocor.m
@@ -30,17 +30,17 @@
 
 function retval = autocor (X, h)
 
   if (nargin == 1)
     retval = autocov (X);
   elseif (nargin == 2)
     retval = autocov (X, h);
   else
-    usage ("autocor (X, h)");
+    print_usage ();
   endif
 
   if (min (retval (1,:)) != 0)
     retval = retval ./ (ones (rows (retval), 1) * retval(1,:));
   endif
 
 endfunction
 
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Design matrix for autoregressions
 
 function X = autoreg_matrix (y, k)
 
   if (nargin != 2)
-    usage ("autoreg_matrix (y, k)");
+    print_usage ();
   endif
 
   if (! (isvector (y)))
     error ("autoreg_matrix: y must be a vector");
   endif
 
   T = length (y);
   y = reshape (y, T, 1);
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Bartlett (triangular) window
 
 function c = bartlett (m)
 
   if (nargin != 1)
-    usage ("bartlett (m)");
+    print_usage ();
   endif
 
   if (! (isscalar (m) && (m == round (m)) && (m > 0)))
     error ("bartlett: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Blackman window
 
 function c = blackman (m)
 
   if (nargin != 1)
-    usage ("blackman (m)");
+    print_usage ();
   endif
 
   if (! (isscalar (m) && (m == round (m)) && (m > 0)))
     error ("blackman: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -37,17 +37,17 @@ function y = detrend (x, p)
 
   if (nargin == 1)
     p = 1;
   elseif (nargin == 2)
     if (! (isscalar (p) && p == round (p) && p >= 0))
       error ("detrend: p must be a nonnegative integer");
     endif
   else
-    usage ("detrend (x, p)");
+    print_usage ();
   endif
 
   [m, n] = size (x);
   if (m == 1)
     x = x';
   endif
 
   r = rows (x);
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -38,17 +38,17 @@
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Estimate the fractional differencing parameter
 
 function [d, D] = diffpara (X, a, b)
 
   if ((nargin < 1) || (nargin > 3))
-    usage ("[d, D] = diffpara (X, a, b)");
+    print_usage ();
   else
     if (isvector (X))
       n = length (X);
       k = 1;
       X = reshape (X, n, 1);
     else
       [n, k] = size(X);
     endif
diff --git a/scripts/signal/durbinlevinson.m b/scripts/signal/durbinlevinson.m
--- a/scripts/signal/durbinlevinson.m
+++ b/scripts/signal/durbinlevinson.m
@@ -31,17 +31,17 @@
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Perform one step of the Durbin-Levinson algorithm
 
 function [newphi, newv] = durbinlevinson (c, oldphi, oldv)
 
   if (! ((nargin == 1) || (nargin == 3)))
-    usage ("durbinlevinson (c, oldphi, oldv)");
+    print_usage ();
   endif
 
   if (columns (c) > 1)
     c=c';
   endif
 
   newphi = 0;
   newv = 0;
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -30,17 +30,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
 function c = fftconv (a, b, N)
 
   if (nargin < 2 || nargin > 3)
-    usage ("fftconv (b, x, N)");
+    print_usage ();
   endif
 
   if (! (isvector (a) && isvector (b)))
     error ("fftconv: both a and b should be vectors");
   endif
   la = length (a);
   lb = length (b);
   if ((la == 1) || (lb == 1))
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -37,17 +37,17 @@ function y = fftfilt (b, x, N)
 
   ## If N is not specified explicitly, we do not use the overlap-add
   ## method at all because loops are really slow.  Otherwise, we only
   ## ensure that the number of points in the FFT is the smallest power
   ## of two larger than N and length(b).  This could result in length
   ## one blocks, but if the user knows better ...
 
   if (nargin < 2 || nargin > 3)
-    usage (" fftfilt (b, x, N)");
+    print_usage ();
   endif
 
   transpose = (rows (x) == 1);
 
   if (transpose)
     x = x.';
   endif
 
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -43,17 +43,17 @@
 ## Created: July 1997
 ## Adapted-By: jwe
 
 function retval = fftshift (V, dim)
 
   retval = 0;
 
   if (nargin != 1 && nargin != 2)
-    usage ("usage: fftshift (X, dim)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     if (!isscalar (dim))
       error ("fftshift: dimension must be an integer scalar");
     endif
     nd = ndims (V);
     sz = size (V);
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -40,17 +40,17 @@
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## 2001-02-08 
 ##    * initial release
 
 function Y = filter2 (B, X, shape)
 
   if (nargin < 2 || nargin > 3)
-    usage ("Y = filter2 (B, X [, 'shape'])");
+    print_usage ();
   endif
   if (nargin < 3)
     shape = "same";
   endif
 
   [nr, nc] = size(B);
   Y = conv2 (X, B(nr:-1:1, nc:-1:1), shape);
 endfunction
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -68,17 +68,17 @@
 ## than returning them.
 ## @end deftypefn
 
 ## Author: jwe ???
 
 function [h_r, f_r] = freqz (b, a, n, region, Fs)
 
   if (nargin < 1 || nargin > 5)
-    usage ("[h, w] = freqz (b, a, n [, \"whole\"] [, Fs])");
+    print_usage ();
   elseif (nargin == 1)
     ## Response of an FIR filter.
     a = n = region = Fs = [];
   elseif (nargin == 2)
     ## Response of an IIR filter
     n = region = Fs = [];
   elseif (nargin == 3)
     region = Fs = [];
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Hamming window
 
 function c = hamming (m)
 
   if (nargin != 1)
-    usage ("hamming (m)");
+    print_usage ();
   endif
 
   if (! (isscalar (m) && (m == round (m)) && (m > 0)))
     error ("hamming: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Coefficients of the Hanning window
 
 function c = hanning (m)
 
   if (nargin != 1)
-    usage ("hanning (m)");
+    print_usage ();
   endif
 
   if (! (isscalar (m) && (m == round (m)) && (m > 0)))
     error ("hanning: m has to be an integer > 0");
   endif
 
   if (m == 1)
     c = 1;
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Estimate the Hurst parameter
 
 function H = hurst (x)
 
   if (nargin != 1)
-    usage ("hurst (x)");
+    print_usage ();
   endif
 
   if (isscalar (x))
     error ("hurst: x must not be a scalar")
   elseif (isvector (x))
     x = reshape (x, length (x), 1);
   end
 
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -29,17 +29,17 @@
 ## Modified-By: Paul Kienzle, converted from fftshift
 ## Modified-By: David Bateman, add NDArray capability and option dim arg
 
 function retval = ifftshift (V, dim)
 
   retval = 0;
 
   if (nargin != 1 && nargin != 2)
-    usage ("usage: ifftshift (X, dim)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     if (!isscalar (dim))
       error ("ifftshift: dimension must be an integer scalar");
     endif
     nd = ndims (V);
     sz = size (V);
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -36,17 +36,17 @@ function retval = sinetone (f, r, s, a)
     s = 1;
     a = 64;
   elseif (nargin == 2)
     s = 1;
     a = 64;
   elseif (nargin == 3)
     a = 64;
   elseif ((nargin < 1) || (nargin > 4))
-    usage ("sinetone (freq, rate, sec, ampl)");
+    print_usage ();
   endif
 
   [err, f, a] = common_size (f, a);
   if (err || ! isvector (f))
     error ("sinetone: freq and ampl must be vectors of common size");
   endif
 
   if (! (isscalar (r) && isscalar (s)))
diff --git a/scripts/signal/sinewave.m b/scripts/signal/sinewave.m
--- a/scripts/signal/sinewave.m
+++ b/scripts/signal/sinewave.m
@@ -35,12 +35,12 @@ function x = sinewave (m, n, d)
     if (nargin < 3)
       d = 0;
     endif
     if (nargin < 2)
       n = m;
     endif
     x = sin (((1 : m) + d - 1) * 2 * pi / n);
   else
-    usage ("sinewave (m, n, d)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Apply Spencer's 15-point MA filter
 
 function retval = spencer (X)
 
   if (nargin != 1)
-    usage ("spencer (X)");
+    print_usage ();
   endif
 
   [xr, xc] = size(X);
 
   n = xr;
   c = xc;
 
   if (isvector(X))
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -76,17 +76,17 @@ function [Y, c] = stft(X, win, inc, coef
         w_type = 2;
       elseif (strcmp (w_type, "rectangle"))
         w_type = 3;
       else
         error ("stft: unknown window type `%s'", w_type);
       endif
     endif
   else
-    usage ("[Y, c] = stft(X, win_size, inc, num_coef, w_type)");
+    print_usage ();
   endif
 
   ## check whether X is a vector
   [nr, nc] = size (X);
   if (nc != 1)
     if (nr == 1)
       X = X';
       nr = nc;
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -31,17 +31,17 @@
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Recover a signal from its short-term Fourier transform
 
 function X = synthesis (Y, c)
 
   if (nargin != 2)
-    usage ("X = synthesis (Y, c)");
+    print_usage ();
   endif
 
   [nr, nc] = size (c);
   if (nr * nc != 3)
     error ("synthesis: c must contain exactly 3 elements");
   endif
 
   ## not necessary, enables better reading
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -28,17 +28,17 @@
 ## which case the data will be unwrapped along this dimension
 ## @end deftypefn
 
 ## Author: Bill Lash <lash@tellabs.com>
 
 function retval = unwrap (a, tol, dim)
         
   if (nargin < 1 || nargin > 3)
-    usage ("unwrap (a [, tol [, dim]])")
+    print_usage ();
   endif
 
   nd = ndims (a);
   sz = size (a);
 
   if (nargin == 3)
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
 	dim < (nd + 1))
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -29,17 +29,17 @@
 ## directly.  Otherwise, return the coordinates of the plot in @var{x}
 ## and @var{y}.
 ## @seealso{treeplot, etreeplot, spy}
 ## @end deftypefn
 
 function [x, y] = gplot (A, xy, line_style)
 
   if (nargin < 2 || nargin > 3 || nargout > 2)
-    usage ("gplot (a, xy, line_style)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     line_style = "1;;";
   endif
 
   [i, j] = find (A);
   xcoord = [xy(i,1), xy(j,1), NaN * ones(length(i),1)]'(:);
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -20,17 +20,17 @@
 ## Compute @code{f(@var{x})} for the non-zero values of @var{x}.
 ## This results in a sparse matrix with the same structure as 
 ## @var{x}. The function @var{f} can be passed as a string, a
 ## function handle or an inline function.
 ## @end deftypefn
 
 function t = spfun(f,s)
   if (nargin != 2)
-    usage ("spfun(f,s)")
+    print_usage ();
   endif
 
   if issparse(s)
     [i,j,v,m,n] = spfind(s);
   else
     [i,j,v] = find(s);
     [m,n] = size(s);
   end
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -47,11 +47,11 @@ function S = sprand (m, n, d)
     j = floor((idx(1:k)-1)/m);
     i = idx(1:k) - j*m;
     if isempty(i)
       S = sparse(m,n);
     else
       S = sparse(i,j+1,rand(k,1),m,n);
     endif
   else
-    usage("sprand(m,n,density) OR sprand(S)");
+    print_usage ();
   endif
 endfunction
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -39,11 +39,11 @@ function S = sprandn(m,n,d)
     j = floor((idx(1:k)-1)/m);
     i = idx(1:k) - j*m;
     if isempty(i)
       S = sparse(m,n);
     else
       S = sparse(i,j+1,randn(k,1),m,n);
     endif
   else
-    usage("sprandn(m,n,density) OR sprandn(S)");
+    print_usage ();
   endif
 endfunction
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -65,11 +65,11 @@ function S = sprandsym(n,d)
       S = sparse(n,n);
     else
       S1 = sparse(i1,j1+1,randn(k1,1),m1,n1);
       S = [tril(S1), sparse(m1,m1); ...
 	   sparse(i2,j2+1,randn(k2,1),n2,n2), triu(S1,1)'];
       S = S + tril(S,-1)';
     endif
   else
-    usage("sprandsym(n,density) OR sprandsym(S)");
+    print_usage ();
   endif
 endfunction
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -13,17 +13,17 @@
 ## Called with two input arguments, if @var{s} is the data and @var{j}
 ## is the bin number for the data, compute the stats for each bin.  In 
 ## this case, bins can contain data values of zero, whereas with 
 ## @code{spstats (@var{s})} the zeros may disappear.
 ## @end deftypefn
 
 function [count,mean,var] = spstats(S,j)
   if nargin < 1 || nargin > 2
-    usage("[count, mean, var] = spstats(S)  OR  spstats(x,j)");
+    print_usage ();
   endif
 
   if nargin == 1
     [i,j,v] = find (S);
   else
     v = S;    
     i = 1:length (v);
     S = sparse (i, j, v);
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -37,14 +37,14 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 13 June 1993
 ## Adapted-By: jwe
 
 function retval = beta (a, b)
 
   if (nargin != 2)
-    usage ("beta (a, b)");
+    print_usage ();
   endif
 
   retval = exp (gammaln (a) + gammaln (b) - gammaln (a+b));
 
 endfunction
diff --git a/scripts/specfun/betai.m b/scripts/specfun/betai.m
--- a/scripts/specfun/betai.m
+++ b/scripts/specfun/betai.m
@@ -29,12 +29,12 @@
 ## Author: jwe
 ## Created: 30 Jan 1998
 
 function retval = betai (a, b, x)
 
   if (nargin == 3)
     retval = betainc (x, a, b);
   else
-    usage ("betai (a, b, x)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -37,17 +37,17 @@
 ## @end deftypefn
 
 ## Author:   Nicol N. Schraudolph <nic@idsia.ch>
 ## Created:  06 Aug 1998
 ## Keywords: log beta special function
 
 function retval = betaln (a, b)
   if (nargin != 2)
-    usage ("betaln (a, b)");
+    print_usage ();
   endif
 
   retval = gammaln (a) + gammaln (b) - gammaln (a + b);
 endfunction
 
 %!assert (betaln(3,4),log(beta(3,4)),eps)
 
 %!error (betaln(1.))
diff --git a/scripts/specfun/erfinv.m b/scripts/specfun/erfinv.m
--- a/scripts/specfun/erfinv.m
+++ b/scripts/specfun/erfinv.m
@@ -25,17 +25,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 27 September 1994
 ## Adapted-By: jwe
 
 function [y, iterations] = erfinv (x)
 
   if (nargin != 1)
-    usage ("erfinv (x)");
+    print_usage ();
   endif
 
   maxit = 100;
   tol = eps;
 
   iterations = 0;
 
   sz = size (x);
diff --git a/scripts/specfun/gammai.m b/scripts/specfun/gammai.m
--- a/scripts/specfun/gammai.m
+++ b/scripts/specfun/gammai.m
@@ -29,12 +29,12 @@
 ## Author: jwe
 ## Created: 30 Jan 1998
 
 function retval = gammai (a, x)
 
   if (nargin == 2)
     retval = gammainc (x, a);
   else
-    usage ("gammai (a, x)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/specfun/log2.m b/scripts/specfun/log2.m
--- a/scripts/specfun/log2.m
+++ b/scripts/specfun/log2.m
@@ -35,17 +35,17 @@
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function [f, e] = log2 (x)
 
   if (nargin != 1)
-    usage ("y = log2 (x) or [f, e] = log2 (x)");
+    print_usage ();
   endif
 
   if (nargout < 2)
     f = log (x) / log (2);
   elseif (nargout == 2)
     ## Only deal with the real parts ...
     x = real (x);
     ## Since log (0) gives problems, 0 entries are replaced by 1.
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -47,12 +47,12 @@
 
 function y = pow2 (f, e)
 
   if (nargin == 1)
     y = 2 .^ f;
   elseif (nargin == 2)
     y = f .* (2 .^ e);
   else
-    usage ("y = pow2 (f, e)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -48,17 +48,17 @@
 
 ## Author: jwe
 
 function retval = hankel (c, r)
 
   if (nargin == 1)
     r = resize (resize (c, 0), size(c));
   elseif (nargin != 2)
-    usage ("hankel (c, r)");
+    print_usage ();
   endif
 
   [c_nr, c_nc] = size (c);
   [r_nr, r_nc] = size (r);
 
   if ((c_nr != 1 && c_nc != 1) || (r_nr != 1 && r_nc != 1))
     error ("hankel: expecting vector arguments");
   endif
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -46,17 +46,17 @@
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = hilb (n)
 
 
   if (nargin != 1)
-    usage ("hilb (n)");
+    print_usage ();
   endif
 
   nmax = length (n);
   if (nmax == 1)
     retval = zeros (n);
     tmp = 1:n;
     for i = 1:n
       retval (i, :) = 1.0 ./ (tmp + (i - 1));
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -64,17 +64,17 @@
 ## @seealso{hankel, vander, sylvester_matrix, hilb, toeplitz}
 ## @end deftypefn
 
 ## Author: Dirk Laurie <dlaurie@na-net.ornl.gov>
 
 function retval = invhilb (n)
 
   if (nargin != 1)
-    usage ("invhilb (n)");
+    print_usage ();
   endif
 
   nmax = length (n);
   if (nmax == 1)
 
     ## The point about the second formula above is that when vectorized,
     ## p(k) is evaluated for k=1:n which involves O(n) calls to bincoeff 
     ## instead of O(n^2).
diff --git a/scripts/special-matrix/sylvester_matrix.m b/scripts/special-matrix/sylvester_matrix.m
--- a/scripts/special-matrix/sylvester_matrix.m
+++ b/scripts/special-matrix/sylvester_matrix.m
@@ -31,17 +31,17 @@
 ## @seealso{hankel, vander, hilb, invhilb, toeplitz}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = sylvester_matrix (k)
 
   if (nargin != 1)
-    usage ("sylvester_matrix (n)");
+    print_usage ();
   endif
 
   if (isscalar (k))
     if (k < 1)
       retval = 1;
     else
       tmp = sylvester_matrix (k-1);
       retval = [tmp, tmp; tmp, -tmp];
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -56,17 +56,17 @@
 
 ## Author: jwe
 
 function retval = toeplitz (c, r)
 
   if (nargin == 1)
     r = c;
   elseif (nargin != 2)
-    usage ("toeplitz (c, r)");
+    print_usage ();
   endif
 
   [c_nr, c_nc] = size (c);
   [r_nr, r_nc] = size (r);
 
   if ((c_nr != 1 && c_nc != 1) || (r_nr != 1 && r_nc != 1))
     error ("toeplitz: expecting vector arguments");
   endif
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -48,17 +48,17 @@
 ## @seealso{hankel, sylvester_matrix, hilb, invhilb, toeplitz}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = vander (c)
 
   if (nargin != 1)
-    usage ("vander (c)");
+    print_usage ();
   endif
 
   if (isvector (c))
     n = length (c);
     retval = zeros (n, n);
     j = 1:n;
     for i = 1:n
       retval(i,:) = c(i) .^ (n - j);
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Center by subtracting means
 
 function retval = center (x, varargin)
 
   if (nargin != 1 && nargin != 2)
-    usage ("center (x)");
+    print_usage ();
   endif
 
   if (isvector (x))
     retval = x - mean (x, varargin{:});
   elseif (ismatrix (x))
     if nargin < 2
       dim = find (size (x) > 1, 1);
       if isempty (dim), 
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -27,14 +27,14 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Complementary log-log function
 
 function y = cloglog (x)
 
   if (nargin != 1)
-    usage ("cloglog (x)");
+    print_usage ();
   endif
 
   y = - log (- log (x));
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/cor.m b/scripts/statistics/base/cor.m
--- a/scripts/statistics/base/cor.m
+++ b/scripts/statistics/base/cor.m
@@ -30,17 +30,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute correlations
 
 function retval = cor (x, y)
 
   if (nargin < 1 || nargin > 2)
-    usage ("cor (x, y)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     c = cov (x, y);
     s = std (x)' * std (y);
     retval = c ./ s;
   elseif (nargin == 1)
     c = cov (x);
diff --git a/scripts/statistics/base/corrcoef.m b/scripts/statistics/base/corrcoef.m
--- a/scripts/statistics/base/corrcoef.m
+++ b/scripts/statistics/base/corrcoef.m
@@ -28,17 +28,17 @@
 
 ## Author: Kurt Hornik <hornik@wu-wien.ac.at>
 ## Created: March 1993
 ## Adapted-By: jwe
 
 function retval = corrcoef (x, y)
 
   if (nargin < 1 || nargin > 2)
-    usage ("corrcoef (x, y)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     c = cov (x, y);
     s = std (x)' * std (y);
     retval = c ./ s;
   elseif (nargin == 1)
     c = cov (x);
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute covariances
 
 function c = cov (x, y)
 
   if (nargin < 1 || nargin > 2)
-    usage ("cov (x, y)");
+    print_usage ();
   endif
 
   if (rows (x) == 1)
     x = x';
   endif
   n = rows (x);
 
   if (nargin == 2)
diff --git a/scripts/statistics/base/cut.m b/scripts/statistics/base/cut.m
--- a/scripts/statistics/base/cut.m
+++ b/scripts/statistics/base/cut.m
@@ -33,17 +33,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Cut data into intervals
 
 function group = cut (X, BREAKS)
 
   if (nargin != 2)
-    usage ("cut (X, BREAKS)");
+    print_usage ();
   endif
 
   if (! isvector (X))
     error ("cut: X must be a vector");
   endif
   if isscalar (BREAKS)
     BREAKS = linspace (min (X), max (X), BREAKS + 1);
     BREAKS(1) = BREAKS(1) - 1;
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -64,17 +64,17 @@
 
 ## Author: Teresa Twaroch <twaroch@ci.tuwien.ac.at>
 ## Created: May 1993
 ## Adapted-By: jwe
 
 function [BETA, v, R] = gls (Y, X, O)
 
   if (nargin != 3)
-    usage ("[BETA, v, R] = gls (Y, X, O)");
+    print_usage ();
   endif
 
   [rx, cx] = size (X);
   [ry, cy] = size (Y);
   if (rx != ry)
     error ("gls: incorrect matrix dimensions");
   endif
 
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Interquartile range
 
 function y = iqr (x, dim)
 
   if (nargin != 1 && nargin != 2)
-    usage ("iqr (x, dim)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
   nel = numel (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim  = 1;
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -65,17 +65,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Kendall's rank correlation tau
 
 function tau = kendall (x, y)
 
   if ((nargin < 1) || (nargin > 2))
-    usage ("kendall (x, y)");
+    print_usage ();
   endif
 
   if (rows (x) == 1)
     x = x';
   endif
   [n, c] = size (x);
 
   if (nargin == 2)
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -43,17 +43,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
 
 function retval = kurtosis (x, dim)
 
   if (nargin != 1 && nargin != 2)
-    usage ("kurtosis (x, dim)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim  = 1;
     while (dim < nd + 1 && sz(dim) == 1)
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -26,12 +26,12 @@
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Logit transformation
 
 function y = logit (p)
 
   if (nargin == 1)
     y = logistic_inv (p);
   else
-    usage ("logit (p)");
+    print_usage ();
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/mahalanobis.m b/scripts/statistics/base/mahalanobis.m
--- a/scripts/statistics/base/mahalanobis.m
+++ b/scripts/statistics/base/mahalanobis.m
@@ -27,17 +27,17 @@
 
 ## Author: Friedrich Leisch <leisch@ci.tuwien.ac.at>
 ## Created: July 1993
 ## Adapted-By: jwe
 
 function retval = mahalanobis (X, Y)
 
   if (nargin != 2)
-    usage ("mahalanobis (X, Y)");
+    print_usage ();
   endif
 
   [xr, xc] = size (X);
   [yr, yc] = size (Y);
 
   if (xc != yc)
     error ("mahalanobis: X and Y must have the same number of columns");
   endif
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -76,20 +76,20 @@ function y = mean (x, opt1, opt2)
   elseif (nargin == 3)
     if (ischar (opt1))
       opt = opt1;
       dim = opt2;
     elseif (ischar (opt2))
       opt = opt2;
       dim = opt1;
     else
-      usage ("mean: expecting opt to be a string");
+      error ("mean: expecting opt to be a string");
     endif
   else
-    usage ("mean (x, dim, opt) or mean (x, dim, opt)");
+    print_usage ();
   endif
 
   if (need_dim)
     t = find (size (x) != 1);
     if (isempty (t))
       dim = 1;
     else
       dim = t(1);
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -27,14 +27,14 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute mean square
 
 function y = meansq (x, varargin)
 
   if (nargin != 1 && nargin != 2)
-    usage ("meansq (x)");
+    print_usage ();
   endif
 
   y = mean (x.^2, varargin{:});
 
 endfunction
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -45,17 +45,17 @@
 ## @seealso{std, mean}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = median (a, dim)
 
   if (nargin != 1 && nargin != 2)
-    usage ("median (a, dim)");
+    print_usage ();
   endif
   if (nargin < 2)
     dim = find (size (a) > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   endif
 
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -43,17 +43,17 @@
 ## as well, but how does the general case work?
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute moments
 
 function m = moment (x, p, opt1, opt2)
 
   if ((nargin < 2) || (nargin > 4))
-    usage ("moment (x, p, type, dim)");
+    print_usage ();
   endif
 
   need_dim = 0;
 
   if (nargin == 2)
     opt = "";
     need_dim = 1;
   elseif (nargin == 3)
@@ -67,20 +67,20 @@ function m = moment (x, p, opt1, opt2)
   elseif (nargin == 4)
     if (ischar (opt1))
       opt = opt1;
       dim = opt2;
     elseif (ischar (opt2))
       opt = opt2;
       dim = opt1;
     else
-      usage ("moment: expecting opt to be a string");
+      error ("moment: expecting opt to be a string");
     endif
   else
-    usage ("moment (x, p, dim, opt)");
+    print_usage ();
   endif
 
   if (need_dim)
     t = find (size (x) != 1);
     if (isempty (t))
       dim = 1;
     else
       dim = t(1);
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -75,17 +75,17 @@
 
 ## Author: Teresa Twaroch <twaroch@ci.tuwien.ac.at>
 ## Created: May 1993
 ## Adapted-By: jwe
 
 function [BETA, SIGMA, R] = ols (Y, X)
 
   if (nargin != 2)
-    usage ("[BETA, SIGMA, R] = ols (Y, X)");
+    print_usage ();
   endif
 
   [nr, nc] = size (X);
   [ry, cy] = size (Y);
   if (nr != ry)
     error ("ols: incorrect matrix dimensions");
   endif
 
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -41,17 +41,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Perform a PP-plot (probability plot)
 
 function [p, y] = ppplot (x, dist, varargin)
 
   if (nargin < 1)
-    usage ("ppplot (x, dist, params)");
+    print_usage ();
   endif
 
   if (! isvector (x))
     error ("ppplot: x must be a vector");
   endif
 
   s = sort (x);
   n = length (x);
diff --git a/scripts/statistics/base/probit.m b/scripts/statistics/base/probit.m
--- a/scripts/statistics/base/probit.m
+++ b/scripts/statistics/base/probit.m
@@ -26,12 +26,12 @@
 ## Written by KH <Kurt.Hornik@wu-wien.ac.at> on 1995/02/04
 ## Description: Probit transformation
 
 function y = probit (p)
 
   if (nargin == 1)
     y = stdnormal_inv (p);
   else
-    usage ("probit (p)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -43,17 +43,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Perform a QQ-plot (quantile plot)
 
 function [q, s] = qqplot (x, dist, varargin)
 
   if (nargin < 1)
-    usage ("qqplot (x, dist, params)");
+    print_usage ();
   endif
 
   if (! (isvector(x)))
     error ("qqplot: x must be a vector");
   endif
 
   s = sort (x);
   n = length (x);
diff --git a/scripts/statistics/base/range.m b/scripts/statistics/base/range.m
--- a/scripts/statistics/base/range.m
+++ b/scripts/statistics/base/range.m
@@ -30,14 +30,14 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute range
 
 function y = range (x, varargin)
 
   if (nargin != 1 && nargin != 2)
-    usage ("range (x, dim)");
+    print_usage ();
   endif
 
   y = max (x, varargin{:}) - min (x, varargin{:});
 
 endfunction
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -32,17 +32,17 @@
 
 ## This code was rather ugly, since it didn't use sort due to the
 ## fact of how to deal with ties. Now it does use sort and its
 ## even uglier!!! At least it handles NDArrays..
 
 function y = ranks (x, dim)
 
   if (nargin != 1 && nargin != 2)
-    usage ("ranks (x, dim)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim  = 1;
     while (dim < nd + 1 && sz(dim) == 1)
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Count upward runs
 
 function retval = run_count (x, n, dim)
 
   if (nargin != 2 && nargin != 3)
-    usage ("run_count (x, n) or run_count (x, n, dim)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin != 3)
     ## Find the first non-singleton dimension.
     dim  = 1;
     while (dim < nd + 1 && sz(dim) == 1)
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -42,17 +42,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
 
 function retval = skewness (x, dim)
 
   if (nargin != 1 && nargin != 2)
-    usage ("skewness (x, dim)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim  = 1;
     while (dim < nd + 1 && sz(dim) == 1)
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/base/spearman.m
--- a/scripts/statistics/base/spearman.m
+++ b/scripts/statistics/base/spearman.m
@@ -37,17 +37,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Spearman's rank correlation rho
 
 function rho = spearman (x, y)
 
   if ((nargin < 1) || (nargin > 2))
-    usage ("spearman (x, y)");
+    print_usage ();
   endif
 
   if (rows (x) == 1)
     x = x';
   endif
   n = rows (x);
 
   if (nargin == 1)
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute basic statistics
 
 function S = statistics (X, dim)
 
   if (nargin != 1 && nargin != 2)
-    usage ("S = statistics (X, dim)");
+    print_usage ();
   endif
 
   nd = ndims (X);
   sz = size (X);
   nel = numel (X);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim  = 1;
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -58,17 +58,17 @@
 ## @seealso{mean, median}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = std (a, opt, dim)
 
   if (nargin < 1 || nargin > 3)
-    usage ("std (a, opt, dim)");
+    print_usage ();
   endif
   if nargin < 3
     dim = find (size (a) > 1, 1);
     if isempty(dim), dim=1; endif;
   endif
   if ((nargin < 2) || isempty(opt))
     opt = 0;
   endif
diff --git a/scripts/statistics/base/studentize.m b/scripts/statistics/base/studentize.m
--- a/scripts/statistics/base/studentize.m
+++ b/scripts/statistics/base/studentize.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Subtract mean and divide by standard deviation
 
 function t = studentize (x, dim)
 
   if (nargin != 1 && nargin != 2)
-    usage ("studentize (x, dim)");
+    print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim  = 1;
     while (dim < nd + 1 && sz(dim) == 1)
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -47,12 +47,12 @@ function [t, v, w] = table (x, y)
     w = values (y);
     for i = 1 : length (v)
       for j = 1 : length (w)
         t(i,j) = sum ((x == v(i) | isnan (v(i)) * isnan (x)) &
                       (y == w(j) | isnan (w(j)) * isnan (y)));
       endfor
     endfor
   else
-    usage ("[t, l_x, ...] = table (x, ...)");
+    print_usage ();
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/base/values.m b/scripts/statistics/base/values.m
--- a/scripts/statistics/base/values.m
+++ b/scripts/statistics/base/values.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Extract unique elements
 
 function v = values (x)
 
   if (nargin != 1)
-    usage ("values (x)");
+    print_usage ();
   endif
 
   if (! (isvector (x)))
     error ("values: x must be a vector");
   endif
 
   i = any (isnan (x));
   x = x(find(!isnan (x)));      # HACK!
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -39,17 +39,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute variance
 
 function y = var (x, opt, dim)
 
   if (nargin < 1 || nargin > 3)
-    usage ("var (x, opt, sim)");
+    print_usage ();
   endif
   if (nargin < 3)
     dim = find (size (x) > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   endif
   if (nargin < 2 || isempty (opt))
diff --git a/scripts/statistics/distributions/betacdf.m b/scripts/statistics/distributions/betacdf.m
--- a/scripts/statistics/distributions/betacdf.m
+++ b/scripts/statistics/distributions/betacdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Beta distribution
 
 function cdf = betacdf (x, a, b)
 
   if (nargin != 3)
-    usage ("betacdf (a, b, x)");
+    print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("betacdf: x, a and b must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
--- a/scripts/statistics/distributions/betainv.m
+++ b/scripts/statistics/distributions/betainv.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Beta distribution
 
 function inv = betainv (x, a, b)
 
   if (nargin != 3)
-    usage ("betainv (x, a, b)");
+    print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("betainv: x, a and b must be of common size or scalars");
     endif
   endif
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
--- a/scripts/statistics/distributions/betapdf.m
+++ b/scripts/statistics/distributions/betapdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Beta distribution
 
 function pdf = betapdf (x, a, b)
 
   if (nargin != 3)
-    usage ("betapdf (a, b, x)");
+    print_usage ();
   endif
   
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("betapdf: x, a and b must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -67,17 +67,17 @@ function rnd = betarnd (a, b, r, c)
 
     if (any (size (a) != 1)
 	&& (length (size (a)) != length (sz) || any (size (a) != sz)))
       error ("betarnd: a and b must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
-    usage ("betarnd (a, b, r, c)");
+    print_usage ();
   endif
 
   if (isscalar(a) && isscalar(b))
     if (find (!(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf)))
       rnd = NaN * ones (sz);
     else
       rnd = betainv (rand(sz), a, b);
     endif
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
--- a/scripts/statistics/distributions/binocdf.m
+++ b/scripts/statistics/distributions/binocdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the binomial distribution
 
 function cdf = binocdf (x, n, p)
 
   if (nargin != 3)
-    usage ("binocdf (x, n, p)");
+    print_usage ();
   endif
 
   if (!isscalar (n) || !isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("binocdf: x, n and p must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the binomial distribution
 
 function inv = binoinv (x, n, p)
 
   if (nargin != 3)
-    usage ("binoinv (x, n, p)");
+    print_usage ();
   endif
 
   if (!isscalar (n) || !isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("binoinv: x, n and p must be of common size or scalars");
     endif
   endif
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the binomial distribution
 
 function pdf = binopdf (x, n, p)
 
   if (nargin != 3)
-    usage ("binopdf (x, n, p)");
+    print_usage ();
   endif
 
   if (! isscalar (n) || ! isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("binopdf: x, n and p must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -67,17 +67,17 @@ function rnd = binornd (n, p, r, c)
 
     if (any (size (n) != 1)
 	&& (length (size (n)) != length (sz) || any (size (n) != sz)))
       error ("binornd: n and must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(n);
   else
-    usage ("binornd (n, p, r, c)");
+    print_usage ();
   endif
 
   if (isscalar (n) && isscalar (p))
     if (find (!(n > 0) | !(n < Inf) | !(n == round (n)) |
               !(p >= 0) | !(p <= 1)))
       rnd = NaN * ones (sz);
     else
       nel = prod (sz);
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Cauchy distribution
 
 function cdf = cauchy_cdf (x, location, scale)
 
   if (! (nargin == 1 || nargin == 3))
-    usage ("cauchy_cdf (x, lambda, sigma)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   if (!isscalar (location) || !isscalar (scale)) 
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Cauchy distribution
 
 function inv = cauchy_inv (x, location, scale)
 
   if (! (nargin == 1 || nargin == 3))
-    usage ("cauchy_inv (x, lambda, sigma)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   if (!isscalar (location) || !isscalar (scale)) 
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Cauchy distribution
 
 function pdf = cauchy_pdf (x, location, scale)
 
   if (! (nargin == 1 || nargin == 3))
-    usage ("cauchy_pdf (x, lambda, sigma)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   if (!isscalar (location) || !isscalar (scale)) 
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -66,17 +66,17 @@ function rnd = cauchy_rnd (l, scale, r, 
 
     if (any (size (l) != 1)
 	&& (length (size (l)) != length (sz) ||	any (size (l) != sz)))
       error ("cauchy_rnd: lambda and sigma must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(l);
   else
-    usage ("cauchy_rnd (lambda, sigma, r, c)");
+    print_usage ();
   endif
 
   if (isscalar (l) && isscalar (scale)) 
     if (find (!(l > -Inf) | !(l < Inf) | !(scale > 0) | !(scale < Inf)))
       rnd = NaN * ones (sz);
     else
       rnd = l - cot (pi * rand (sz)) .* scale;
     endif
diff --git a/scripts/statistics/distributions/chi2cdf.m b/scripts/statistics/distributions/chi2cdf.m
--- a/scripts/statistics/distributions/chi2cdf.m
+++ b/scripts/statistics/distributions/chi2cdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: CDF of the chi-square distribution
 
 function cdf = chi2cdf (x, n)
 
   if (nargin != 2)
-    usage ("chi2cdf (x, n)");
+    print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("chi2cdf: x and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/chi2inv.m b/scripts/statistics/distributions/chi2inv.m
--- a/scripts/statistics/distributions/chi2inv.m
+++ b/scripts/statistics/distributions/chi2inv.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: Quantile function of the chi-square distribution
 
 function inv = chi2inv (x, n)
 
   if (nargin != 2)
-    usage ("chi2inv (x, n)");
+    print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("chi2inv: x and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/chi2pdf.m b/scripts/statistics/distributions/chi2pdf.m
--- a/scripts/statistics/distributions/chi2pdf.m
+++ b/scripts/statistics/distributions/chi2pdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: PDF of the chi-square distribution
 
 function pdf = chi2pdf (x, n)
 
   if (nargin != 2)
-    usage ("chi2pdf (x, n)");
+    print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("chi2pdf: x and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -57,17 +57,17 @@ function rnd = chi2rnd (n, r, c)
 
     if (any (size (n) != 1)
 	&& (length (size (n)) != length (sz) || any (size (n) != sz)))
       error ("chi2rnd: n must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size(n);
   else
-    usage ("chi2rnd (n, r, c)");
+    print_usage ();
   endif
 
   if (isscalar (n))
      if (find (!(n > 0) | !(n < Inf)))
        rnd = NaN * ones (sz);
      else
        rnd =  chi2inv (rand (sz), n);
      endif
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of a discrete distribution
 
 function cdf = discrete_cdf (x, v, p)
 
   if (nargin != 3)
-    usage ("discrete_cdf (x, v, p)");
+    print_usage ();
   endif
 
   sz = size (x);
 
   if (! isvector (v))
     error ("discrete_cdf: v must be a vector");
   elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_cdf: p must be a vector with length (v) elements");
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of a discrete distribution
 
 function inv = discrete_inv (x, v, p)
 
   if (nargin != 3)
-    usage ("discrete_inv (x, v, p)");
+    print_usage ();
   endif
 
   sz = size (x);
 
   if (! isvector (v))
     error ("discrete_inv: v must be a vector");
   elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_inv: p must be a vector with length (v) elements");
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: pDF of a discrete distribution
 
 function pdf = discrete_pdf (x, v, p)
 
   if (nargin != 3)
-    usage ("discrete_pdf (x, v, p)");
+    print_usage ();
   endif
 
   sz = size (x);
 
   if (! isvector (v))
     error ("discrete_pdf: v must be a vector");
   elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_pdf: p must be a vector with length (v) elements");
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -58,17 +58,17 @@ function rnd = discrete_rnd (v, p, r, c)
 	sz = [r, r];
       elseif (isvector(r) && all (r > 0))
 	sz = r(:)';
       else
 	error ("discrete_rnd: r must be a postive integer or vector");
       endif
     endif
   else
-    usage ("discrete_rnd (n, v, p) | discrete_rnd (v, p, r, c)");
+    print_usage ();
   endif
 
   if (! isvector (v))
     error ("discrete_rnd: v must be a vector");
   elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_rnd: p must be a vector with length (v) elements");
   elseif (! (all (p >= 0) && any (p)))
     error ("discrete_rnd: p must be a nonzero, nonnegative vector");
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -36,17 +36,17 @@ function rnd = empirical_rnd (data, r, c
 
   if (nargin == 2)
     if (isscalar(data))
       c = data;
       data = r;
       r = 1;
     endif
   elseif (nargin != 3)
-    usage ("empirical_rnd (n, data) | empirical_rnd (data, r, c)");
+    print_usage ();
   endif
 
   if (! isvector (data))
     error ("empirical_rnd: data must be a vector");
   endif
 
   rnd = discrete_rnd (data, ones (size (data)) / length (data), r, c);
 
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
--- a/scripts/statistics/distributions/expcdf.m
+++ b/scripts/statistics/distributions/expcdf.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the exponential distribution
 
 function cdf = expcdf (x, l)
 
   if (nargin != 2)
-    usage ("expcdf (x, lambda)");
+    print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar(l))
     [retval, x, l] = common_size (x, l);
     if (retval > 0)
       error ("expcdf: x and lambda must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
--- a/scripts/statistics/distributions/expinv.m
+++ b/scripts/statistics/distributions/expinv.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the exponential distribution
 
 function inv = expinv (x, l)
 
   if (nargin != 2)
-    usage ("expinv (x, lambda)");
+    print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar(l))
     [retval, x, l] = common_size (x, l);
     if (retval > 0)
       error ("expinv: x and lambda must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
--- a/scripts/statistics/distributions/exppdf.m
+++ b/scripts/statistics/distributions/exppdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the exponential distribution
 
 function pdf = exppdf (x, l)
 
   if (nargin != 2)
-    usage ("exppdf (x, lambda)");
+    print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar(l))
     [retval, x, l] = common_size (x, l);
     if (retval > 0)
       error ("exppdf: x and lambda must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -58,17 +58,17 @@ function rnd = exprnd (l, r, c)
 
     if (any (size (l) != 1) && 
 	((length (size (l)) != length (sz)) || any (size (l) != sz)))
       error ("exprnd: lambda must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (l);
   else
-    usage ("exprnd (lambda, r, c)");
+    print_usage ();
   endif
 
 
   if (isscalar (l))
     if ((l > 0) && (l < Inf))
       rnd = - log (1 - rand (sz)) ./ l;
     else
       rnd = NaN * ones (sz);
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
--- a/scripts/statistics/distributions/fcdf.m
+++ b/scripts/statistics/distributions/fcdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the F distribution
 
 function cdf = fcdf (x, m, n)
 
   if (nargin != 3)
-    usage ("fcdf (x, m, n)");
+    print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (n))
     [retval, x, m, n] = common_size (x, m, n);
     if (retval > 0)
       error ("fcdf: x, m and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
--- a/scripts/statistics/distributions/finv.m
+++ b/scripts/statistics/distributions/finv.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the F distribution
 
 function inv = finv (x, m, n)
 
   if (nargin != 3)
-    usage ("finv (x, m, n)");
+    print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (n))
     [retval, x, m, n] = common_size (x, m, n);
     if (retval > 0)
       error ("finv: x, m and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
--- a/scripts/statistics/distributions/fpdf.m
+++ b/scripts/statistics/distributions/fpdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the F distribution
 
 function pdf = fpdf (x, m, n)
 
   if (nargin != 3)
-    usage ("fpdf (x, m, n)");
+    print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (n))
     [retval, x, m, n] = common_size (x, m, n);
     if (retval > 0)
       error ("fpdf: x, m and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -69,17 +69,17 @@ function rnd = frnd (m, n, r, c)
 
     if (any (size (m) != 1) && 
 	((length (size (m)) != length (sz)) || any (size (m) != sz)))
       error ("frnd: m and n must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
-    usage ("frnd (m, n, r, c)");
+    print_usage ();
   endif
 
 
   if (isscalar (m) && isscalar (n))
     if ((m > 0) && (m < Inf) && (n > 0) && (n < Inf))
       rnd =  finv (rand (sz), m, n);
     else
       rnd = NaN * ones (sz);
diff --git a/scripts/statistics/distributions/gamcdf.m b/scripts/statistics/distributions/gamcdf.m
--- a/scripts/statistics/distributions/gamcdf.m
+++ b/scripts/statistics/distributions/gamcdf.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: CDF of the Gamma distribution
 
 function cdf = gamcdf (x, a, b)
 
   if (nargin != 3)
-    usage ("gamcdf (x, a, b)");
+    print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("gamcdf: x, a and b must be of common size or scalars");
     endif
   endif
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
--- a/scripts/statistics/distributions/gaminv.m
+++ b/scripts/statistics/distributions/gaminv.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Gamma distribution
 
 function inv = gaminv (x, a, b)
 
   if (nargin != 3)
-    usage ("gaminv (x, a, b)");
+    print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("gaminv: x, a and b must be of common size or scalars");
     endif
   endif
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
--- a/scripts/statistics/distributions/gampdf.m
+++ b/scripts/statistics/distributions/gampdf.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: PDF of the Gamma distribution
 
 function pdf = gampdf (x, a, b)
 
   if (nargin != 3)
-    usage ("gampdf (x, a, b)");
+    print_usage ();
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("gampdf: x, a and b must be of common size or scalars");
     endif
   endif
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -68,17 +68,17 @@ function rnd = gamrnd (a, b, r, c)
 
     if (any (size (a) != 1)
 	&& (length (size (a)) != length (sz) || any (size (a) != sz)))
       error ("gamrnd: a and b must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
-    usage ("gamrnd (a, b, r, c)");
+    print_usage ();
   endif
 
   rnd = zeros (sz);
 
   if (isscalar (a) && isscalar(b))
     if (find (!(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf)))
       rnd = NaN * ones (sz);
     else
diff --git a/scripts/statistics/distributions/geocdf.m b/scripts/statistics/distributions/geocdf.m
--- a/scripts/statistics/distributions/geocdf.m
+++ b/scripts/statistics/distributions/geocdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the geometric distribution
 
 function cdf = geocdf (x, p)
 
   if (nargin != 2)
-    usage ("geocdf (x, p)");
+    print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar (p))
     [retval, x, p] = common_size (x, p);
     if (retval > 0)
       error ("geocdf: x and p must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/geoinv.m b/scripts/statistics/distributions/geoinv.m
--- a/scripts/statistics/distributions/geoinv.m
+++ b/scripts/statistics/distributions/geoinv.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the geometric distribution
 
 function inv = geoinv (x, p)
 
   if (nargin != 2)
-    usage ("geoinv (x, p)");
+    print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar (p))
     [retval, x, p] = common_size (x, p);
     if (retval > 0)
       error ("geoinv: x and p must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/geopdf.m b/scripts/statistics/distributions/geopdf.m
--- a/scripts/statistics/distributions/geopdf.m
+++ b/scripts/statistics/distributions/geopdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the geometric distribution
 
 function pdf = geopdf (x, p)
 
   if (nargin != 2)
-    usage ("geopdf (x, p)");
+    print_usage ();
   endif
 
   if (!isscalar (x) && !isscalar (p))
     [retval, x, p] = common_size (x, p);
     if (retval > 0)
       error ("geopdf: x and p must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -58,17 +58,17 @@ function rnd = geornd (p, r, c)
 
     if (any (size (p) != 1) && ((length (size (p)) != length (sz)) ||
 				any (size (p) != sz)))
       error ("geornd: n must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size(n);
   elseif (nargin != 1)
-    usage ("geornd (p, r, c)");
+    print_usage ();
   endif
 
 
   if (isscalar (p))
     if (!(p >= 0) || !(p <= 1))
       rnd = NaN * ones (sz);
     elseif (p == 0)
       rnd = Inf * ones (sz);
diff --git a/scripts/statistics/distributions/hygecdf.m b/scripts/statistics/distributions/hygecdf.m
--- a/scripts/statistics/distributions/hygecdf.m
+++ b/scripts/statistics/distributions/hygecdf.m
@@ -31,17 +31,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the hypergeometric distribution
 
 function cdf = hygecdf (x, m, t, n)
 
   if (nargin != 4)
-    usage ("hygecdf (x, m, t, n)");
+    print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (t) || !isscalar (n))
     error ("hygecdf: m, t and n must all be positive integers");
   endif
 
   if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
       (t != round (t)) | (n != round (n)) | (m > t) | (n > t))
diff --git a/scripts/statistics/distributions/hygeinv.m b/scripts/statistics/distributions/hygeinv.m
--- a/scripts/statistics/distributions/hygeinv.m
+++ b/scripts/statistics/distributions/hygeinv.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the hypergeometric distribution
 
 function inv = hygeinv (x, m, t, n)
 
   if (nargin != 4)
-    usage ("hygeinv (x, m, t, n)");
+    print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (t) || !isscalar (n))
     error ("hygeinv: m, t and n must all be positive integers");
   endif
 
   if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
       (t != round (t)) | (n != round (n)) | (m > t) | (n > t))
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the hypergeometric distribution
 
 function pdf = hygepdf (x, m, t, n)
 
   if (nargin != 4)
-    usage ("hygepdf (x, m, t, n)");
+    print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (t) || !isscalar (n))
     [retval, x, m, t, n] = common_size (x, m, t, n);
     if (retval > 0)
       error ("hygepdf: x, m, t, and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
--- a/scripts/statistics/distributions/hygernd.m
+++ b/scripts/statistics/distributions/hygernd.m
@@ -52,17 +52,17 @@ function rnd = hygernd (m, t, n, r, c)
       t = n;
       n = r;
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("hygernd: r must be a vector of positive integers");
     endif
   else
-    usage ("hygernd (N, m, t, n) | hygernd (m, t, n, r, c)");
+    print_usage ();
   endif
 
   if (!isscalar (m) || !isscalar (t) || !isscalar (n))
     error ("hygernd: m, t and n must all be positive integers");
   endif
 
   if ((m < 0) | (t < 0) | (n <= 0) | (m != round (m)) |
       (t != round (t)) | (n != round (n)) | (m > t) | (n > t))
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -41,17 +41,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Kolmogorov-Smirnov distribution
 
 function cdf = kolmogorov_smirnov_cdf (x, tol)
 
   if (nargin < 1 || nargin > 2)
-    usage ("kolmogorov_smirnov_cdf (x, tol)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     tol = eps;
   else
     if (! isscalar (tol) || ! (tol > 0))
       error ("kolmogorov_smirnov_cdf: tol has to be a positive scalar");
     endif
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ b/scripts/statistics/distributions/laplace_cdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Laplace distribution
 
 function cdf = laplace_cdf (x)
 
   if (nargin != 1)
-    usage ("laplace_cdf (x)");
+    print_usage ();
   endif
 
   cdf = zeros (size (x));
 
   k = find (isnan (x));
   if (any (k))
     cdf(k) = NaN;
   endif
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
--- a/scripts/statistics/distributions/laplace_inv.m
+++ b/scripts/statistics/distributions/laplace_inv.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Laplace distribution
 
 function inv = laplace_inv (x)
 
   if (nargin != 1)
-    usage ("laplace_inv (x)");
+    print_usage ();
   endif
 
   inv = (-Inf) * ones (size (x));
 
   k = find (isnan (x) | (x < 0) | (x > 1));
   if (any (k))
     inv(k) = NaN;
   endif
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ b/scripts/statistics/distributions/laplace_pdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Laplace distribution
 
 function pdf = laplace_pdf (x)
 
   if (nargin != 1)
-    usage ("laplace_pdf (x)");
+    print_usage ();
   endif
 
   pdf = zeros (size (x));
 
   k = find (isnan (x));
   if (any (k))
     pdf(k) = NaN;
   endif
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -42,16 +42,16 @@ function rnd = laplace_rnd (r, c)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("laplace_rnd: r must be a postive integer or vector");
     endif
   else
-    usage ("laplace_rnd (r, c)");
+    print_usage ();
   endif
 
   tmp = rand (sz);
   rnd = ((tmp < 1/2) .* log (2 * tmp)
          - (tmp > 1/2) .* log (2 * (1 - tmp)));
 
 endfunction
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ b/scripts/statistics/distributions/logistic_cdf.m
@@ -24,14 +24,14 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the logistic distribution
 
 function cdf = logistic_cdf (x)
 
   if (nargin != 1)
-    usage ("logistic_cdf (x)");
+    print_usage ();
   endif
 
   cdf = 1 ./ (1 + exp (- x));
 
 endfunction
diff --git a/scripts/statistics/distributions/logistic_inv.m b/scripts/statistics/distributions/logistic_inv.m
--- a/scripts/statistics/distributions/logistic_inv.m
+++ b/scripts/statistics/distributions/logistic_inv.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the logistic distribution
 
 function inv = logistic_inv (x)
 
   if (nargin != 1)
-    usage ("logistic_inv (x)");
+    print_usage ();
   endif
 
   inv = zeros (size (x));
 
   k = find ((x < 0) | (x > 1) | isnan (x));
   if (any (k))
     inv(k) = NaN;
   endif
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ b/scripts/statistics/distributions/logistic_pdf.m
@@ -24,15 +24,15 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the logistic distribution
 
 function pdf = logistic_pdf (x)
 
   if (nargin != 1)
-    usage ("logistic_pdf (x)");
+    print_usage ();
   endif
 
   cdf = logistic_cdf (x);
   pdf = cdf .* (1 - cdf);
 
 endfunction
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -43,14 +43,14 @@ function rnd = logistic_rnd (r, c)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("logistic_rnd: r must be a postive integer or vector");
     endif
   else
-    usage ("logistic_rnd (r, c)");
+    print_usage ();
   endif
 
   rnd = - log (1 ./ rand (sz) - 1);
 
 endfunction
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
--- a/scripts/statistics/distributions/logncdf.m
+++ b/scripts/statistics/distributions/logncdf.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the log normal distribution
 
 function cdf = logncdf (x, mu, sigma)
 
   if (! ((nargin == 1) || (nargin == 3)))
-    usage ("logncdf (x, mu, sigma)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     mu = 0;
     sigma = 1;
   endif
 
   ## The following "straightforward" implementation unfortunately does
diff --git a/scripts/statistics/distributions/logninv.m b/scripts/statistics/distributions/logninv.m
--- a/scripts/statistics/distributions/logninv.m
+++ b/scripts/statistics/distributions/logninv.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the log normal distribution
 
 function inv = logninv (x, mu, sigma)
 
   if (! ((nargin == 1) || (nargin == 3)))
-    usage ("logninv (x, mu, sigma)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     mu = 0;
     sigma = 1;
   endif
 
   ## The following "straightforward" implementation unfortunately does
diff --git a/scripts/statistics/distributions/lognpdf.m b/scripts/statistics/distributions/lognpdf.m
--- a/scripts/statistics/distributions/lognpdf.m
+++ b/scripts/statistics/distributions/lognpdf.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the log normal distribution
 
 function pdf = lognpdf (x, mu, sigma)
 
   if (! ((nargin == 1) || (nargin == 3)))
-    usage ("lognpdf (x, mu, sigma)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     mu = 0;
     sigma = 1;
   endif
 
   ## The following "straightforward" implementation unfortunately does
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -69,17 +69,17 @@ function rnd = lognrnd (mu, sigma, r, c)
 
     if (any (size (mu) != 1) && 
 	((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
       error ("lognrnd: mu and sigma must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(mu);
   else
-    usage ("lognrnd (mu, sigma, r, c)");
+    print_usage ();
   endif
 
   if (isscalar (mu) && isscalar (sigma))
     if  (!(mu > 0) | !(mu < Inf) | !(sigma > 0) | !(sigma < Inf))
       rnd = NaN * ones (sz);
     elseif find ((mu > 0) & (mu < Inf) & (sigma > 0) & (sigma < Inf));
       rnd = exp (mu) * exp (sigma .* randn (sz));
     else
diff --git a/scripts/statistics/distributions/normcdf.m b/scripts/statistics/distributions/normcdf.m
--- a/scripts/statistics/distributions/normcdf.m
+++ b/scripts/statistics/distributions/normcdf.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: CDF of the normal distribution
 
 function cdf = normcdf (x, m, v)
 
   if (! ((nargin == 1) || (nargin == 3)))
-    usage ("normcdf (x, m, v)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     m = 0;
     v = 1;
   endif
 
   if (!isscalar (m) || !isscalar(v))
diff --git a/scripts/statistics/distributions/norminv.m b/scripts/statistics/distributions/norminv.m
--- a/scripts/statistics/distributions/norminv.m
+++ b/scripts/statistics/distributions/norminv.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the normal distribution
 
 function inv = norminv (x, m, v)
 
   if (nargin != 1 && nargin != 3)
-    usage ("norminv (x, m, v)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     m = 0;
     v = 1;
   endif
 
   if (!isscalar (m) || !isscalar(v))
diff --git a/scripts/statistics/distributions/normpdf.m b/scripts/statistics/distributions/normpdf.m
--- a/scripts/statistics/distributions/normpdf.m
+++ b/scripts/statistics/distributions/normpdf.m
@@ -27,17 +27,17 @@
 ## @end deftypefn
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: PDF of the normal distribution
 
 function pdf = normpdf (x, m, v)
 
   if (nargin != 1 && nargin != 3)
-    usage ("normpdf (x, m, v)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     m = 0;
     v = 1;
   endif
 
   if (!isscalar (m) || !isscalar(v))
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -67,17 +67,17 @@ function rnd = normrnd (m, v, r, c)
 
     if (any (size (m) != 1)
 	&& (length (size (m)) != length (sz) || any (size (m) != sz)))
       error ("normrnd: m and v must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(m);
   else
-    usage ("normrnd (m, v, r, c)");
+    print_usage ();
   endif
 
   if (isscalar (m) && isscalar (v))
     if (find (isnan (m) | isinf (m) | !(v > 0) | !(v < Inf)))
       rnd = NaN * ones (sz);
     else
       rnd =  m + sqrt (v) .* randn (sz);
     endif
diff --git a/scripts/statistics/distributions/pascal_cdf.m b/scripts/statistics/distributions/pascal_cdf.m
--- a/scripts/statistics/distributions/pascal_cdf.m
+++ b/scripts/statistics/distributions/pascal_cdf.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Pascal (negative binomial) distribution
 
 function cdf = pascal_cdf (x, n, p)
 
   if (nargin != 3)
-    usage ("pascal_cdf (x, n, p)");
+    print_usage ();
   endif
 
   if (!isscalar(n) || !isscalar(p)) 
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("pascal_cdf: x, n and p must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/pascal_inv.m b/scripts/statistics/distributions/pascal_inv.m
--- a/scripts/statistics/distributions/pascal_inv.m
+++ b/scripts/statistics/distributions/pascal_inv.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Pascal distribution
 
 function inv = pascal_inv (x, n, p)
 
   if (nargin != 3)
-    usage ("pascal_inv (x, n, p)");
+    print_usage ();
   endif
 
   if (!isscalar(n) || !isscalar(p)) 
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("pascal_inv: x, n and p must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/pascal_pdf.m b/scripts/statistics/distributions/pascal_pdf.m
--- a/scripts/statistics/distributions/pascal_pdf.m
+++ b/scripts/statistics/distributions/pascal_pdf.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Pascal (negative binomial) distribution
 
 function pdf = pascal_pdf (x, n, p)
 
   if (nargin != 3)
-    usage ("pascal_pdf (x, n, p)");
+    print_usage ();
   endif
 
   if (!isscalar(n) || !isscalar(p)) 
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("pascal_pdf: x, n and p must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/pascal_rnd.m b/scripts/statistics/distributions/pascal_rnd.m
--- a/scripts/statistics/distributions/pascal_rnd.m
+++ b/scripts/statistics/distributions/pascal_rnd.m
@@ -68,17 +68,17 @@ function rnd = pascal_rnd (n, p, r, c)
 
     if (any (size (n) != 1) && 
 	((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("pascal_rnd: n and p must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(n);
   else
-    usage ("pascal_rnd (n, p, r, c)");
+    print_usage ();
   endif
 
   if (isscalar (n) && isscalar (p))
     if ((n < 1) || (n == Inf) || (n != round (n)) || (p <= 0) || (p > 1));
       rnd = NaN * ones (sz)
     elseif ((n > 0) && (n < Inf) && (n == round (n)) && 
 	    (p > 0) && (p <= 1))
       L = prod (sz);
diff --git a/scripts/statistics/distributions/poisscdf.m b/scripts/statistics/distributions/poisscdf.m
--- a/scripts/statistics/distributions/poisscdf.m
+++ b/scripts/statistics/distributions/poisscdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Poisson distribution
 
 function cdf = poisscdf (x, l)
 
   if (nargin != 2)
-    usage ("poisscdf (x, lambda)");
+    print_usage ();
   endif
 
   if (!isscalar (l))
     [retval, x, l] = common_size (x, l);
     if (retval > 0)
       error ("poisscdf: x and lambda must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Poisson distribution
 
 function inv = poissinv (x, l)
 
   if (nargin != 2)
-    usage ("poissinv (x, lambda)");
+    print_usage ();
   endif
 
   if (!isscalar (l))
     [retval, x, l] = common_size (x, l);
     if (retval > 0)
       error ("poissinv: x and lambda must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/poisspdf.m b/scripts/statistics/distributions/poisspdf.m
--- a/scripts/statistics/distributions/poisspdf.m
+++ b/scripts/statistics/distributions/poisspdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Poisson distribution
 
 function pdf = poisspdf (x, l)
 
   if (nargin != 2)
-    usage ("poisspdf (x, lambda)");
+    print_usage ();
   endif
 
   if (!isscalar (l))
     [retval, x, l] = common_size (x, l);
     if (retval > 0)
       error ("poisspdf: x and lambda must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -56,17 +56,17 @@ function rnd = poissrnd (l, r, c)
 
     if (any (size (l) != 1) && 
 	((length (size (l)) != length (sz)) || any (size (l) != sz)))
       error ("poissrnd: lambda must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (l);
   else
-    usage ("poissrnd (lambda, r, c)");
+    print_usage ();
   endif
 
   if (isscalar (l))
 
     if (!(l >= 0) | !(l < Inf))
       rnd = NaN * ones (sz);
     elseif ((l > 0) & (l < Inf))
       num = zeros (sz);
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the standard normal distribution
 
 function cdf = stdnormal_cdf (x)
 
   if (nargin != 1)
-    usage ("stdnormal_cdf (x)");
+    print_usage ();
   endif
 
   sz = size (x);
   if (numel(x) == 0)
     error ("stdnormal_cdf: x must not be empty");
   endif
 
   cdf = (ones (sz) + erf (x / sqrt (2))) / 2;
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -24,14 +24,14 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the standard normal distribution
 
 function inv = stdnormal_inv (x)
 
   if (nargin != 1)
-    usage ("stdnormal_inv (x)");
+    print_usage ();
   endif
 
   inv = sqrt (2) * erfinv (2 * x - 1);
 
 endfunction
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ b/scripts/statistics/distributions/stdnormal_pdf.m
@@ -24,17 +24,17 @@
 ## @end deftypefn
 
 ## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
 ## Description: PDF of the standard normal distribution
 
 function pdf = stdnormal_pdf (x)
 
   if (nargin != 1)
-    usage ("stdnormal_pdf (x)");
+    print_usage ();
   endif
 
   sz = size(x);
   pdf = zeros (sz);
 
   k = find (isnan (x));
   if (any (k))
     pdf(k) = NaN;
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the standard normal distribution
 
 function rnd = stdnormal_rnd (r, c)
 
   if (nargin != 1 && nargin != 2)
-    usage ("stdnormal_rnd (r, c)");
+    print_usage ();
   endif
 
   if (nargin == 2)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("stdnormal_rnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("stdnormal_rnd: c must be a positive integer");
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
--- a/scripts/statistics/distributions/tcdf.m
+++ b/scripts/statistics/distributions/tcdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the t distribution
 
 function cdf = tcdf (x, n)
 
   if (nargin != 2)
-    usage ("tcdf (x, n)");
+    print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("tcdf: x and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
--- a/scripts/statistics/distributions/tinv.m
+++ b/scripts/statistics/distributions/tinv.m
@@ -29,17 +29,17 @@
 ## directly.
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the t distribution
 
 function inv = tinv (x, n)
 
   if (nargin != 2)
-    usage ("tinv (x, n)");
+    print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("tinv: x and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the t distribution
 
 function pdf = tpdf (x, n)
 
   if (nargin != 2)
-    usage ("tpdf (x, n)");
+    print_usage ();
   endif
 
   if (!isscalar (n))
     [retval, x, n] = common_size (x, n);
     if (retval > 0)
       error ("tpdf: x and n must be of common size or scalar");
     endif
   endif
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -58,17 +58,17 @@ function rnd = trnd (n, r, c)
 
     if (any (size (n) != 1) && 
 	((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("trnd: n must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (n);
   else
-    usage ("trnd (n, r, c)");
+    print_usage ();
   endif
 
   if (isscalar (n))
     if (!(n > 0) || !(n < Inf))
       rnd = NaN * ones (sz);
     elseif ((n > 0) && (n < Inf))
       rnd = tinv (rand (sz), n);
     else
diff --git a/scripts/statistics/distributions/unifcdf.m b/scripts/statistics/distributions/unifcdf.m
--- a/scripts/statistics/distributions/unifcdf.m
+++ b/scripts/statistics/distributions/unifcdf.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the uniform distribution
 
 function cdf = unifcdf (x, a, b)
 
   if (nargin != 1 && nargin != 3)
-    usage ("unifcdf (x, a, b)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   if (!isscalar (a) || !isscalar(b))
diff --git a/scripts/statistics/distributions/unifinv.m b/scripts/statistics/distributions/unifinv.m
--- a/scripts/statistics/distributions/unifinv.m
+++ b/scripts/statistics/distributions/unifinv.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the uniform distribution
 
 function inv = unifinv (x, a, b)
 
   if (nargin != 1 && nargin != 3)
-    usage ("unifinv (x, a, b)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   if (!isscalar (a) || !isscalar(b))
diff --git a/scripts/statistics/distributions/unifpdf.m b/scripts/statistics/distributions/unifpdf.m
--- a/scripts/statistics/distributions/unifpdf.m
+++ b/scripts/statistics/distributions/unifpdf.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the uniform distribution
 
 function pdf = unifpdf (x, a, b)
 
   if (nargin != 1 && nargin != 3)
-    usage ("unifpdf (x, a, b)");
+    print_usage ();
   endif
 
   if (nargin == 1)
     a = 0;
     b = 1;
   endif
 
   if (!isscalar (a) || !isscalar(b))
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -66,17 +66,17 @@ function rnd = unifrnd (a, b, r, c)
 
     if (any (size (a) != 1)
 	&& (length (size (a)) != length (sz) || any (size (a) != sz)))
       error ("unifrnd: a and b must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
-    usage ("unifrnd (a, b, r, c)");
+    print_usage ();
   endif
 
   if (isscalar(a) && isscalar(b))
     if (find (!(-Inf < a) | !(a < b) | !(b < Inf)))
       rnd = NaN * ones(sz);
     else
       rnd =  a + (b - a) .* rand (sz);
     endif
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
--- a/scripts/statistics/distributions/wblcdf.m
+++ b/scripts/statistics/distributions/wblcdf.m
@@ -32,17 +32,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Weibull distribution
 
 function cdf = wblcdf (x, scale, shape)
 
   if (nargin < 1 || nargin > 3)
-    usage ("wblcdf (x, scale, shape)");
+    print_usage ();
   endif
 
   if (nargin < 3)
     shape = 1;
   endif
 
   if (nargin < 2)
     scale = 1;
diff --git a/scripts/statistics/distributions/wblinv.m b/scripts/statistics/distributions/wblinv.m
--- a/scripts/statistics/distributions/wblinv.m
+++ b/scripts/statistics/distributions/wblinv.m
@@ -25,17 +25,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Weibull distribution
 
 function inv = wblinv (x, scale, shape)
 
   if (nargin < 1 || nargin > 3)
-    usage ("wblinv (x, scale, shape)");
+    print_usage ();
   endif
 
   if (nargin < 3)
     shape = 1;
   endif
 
   if (nargin < 2)
     scale = 1;
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -32,17 +32,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Weibull distribution
 
 function pdf = wblpdf (x, scale, shape)
 
   if (nargin < 1 || nargin > 3)
-    usage ("wblpdf (x, scale, shape)");
+    print_usage ();
   endif
 
   if (nargin < 3)
     shape = 1;
   endif
 
   if (nargin < 2)
     scale = 1;
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -69,17 +69,17 @@ function rnd = wblrnd (scale, shape, r, 
     if (any (size (scale) != 1) && 
 	((length (size (scale)) != length (sz)) ||
 	 any (size (scale) != sz)))
       error ("wblrnd: shape and scale must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(shape);
   else
-    usage ("wblrnd (alpha, sigma, r, c)");
+    print_usage ();
   endif
 
   if (isscalar (shape) && isscalar (scale))
     if ((shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf))
       rnd = (scale * (- log (1 - rand (sz))) .^ (1 / shape));
     else
       rnd = NaN * ones (sz);
     endif
diff --git a/scripts/statistics/distributions/wienrnd.m b/scripts/statistics/distributions/wienrnd.m
--- a/scripts/statistics/distributions/wienrnd.m
+++ b/scripts/statistics/distributions/wienrnd.m
@@ -35,17 +35,17 @@
 function retval = wienrnd (t, d, n)
 
   if (nargin == 1)
     d = 1;
     n = 1000;
   elseif (nargin == 2)
     n = 1000;
   elseif (nargin > 3)
-    usage ("wienrnd (t, d, n)");
+    print_usage ();
   endif
 
   if (!isscalar (t) || !isscalar (d) || !isscalar (n))
     error ("wienrnd: t, d and n must all be positive integers");
   endif
 
   retval = randn (n * t, d);
   retval = cumsum (retval) / sqrt (n);
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
--- a/scripts/statistics/tests/anova.m
+++ b/scripts/statistics/tests/anova.m
@@ -43,17 +43,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: One-way analysis of variance (ANOVA)
 
 function [pval, f, df_b, df_w] = anova (y, g)
 
   if ((nargin < 1) || (nargin > 2))
-    usage ("anova (y, g)");
+    print_usage ();
   elseif (nargin == 1)
     if (isvector (y))
       error ("anova: for `anova (y)', y must not be a vector");
     endif
     [group_count, k] = size (y);
     n = group_count * k;
     group_mean = mean (y);
   else
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -34,17 +34,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Bartlett test for homogeneity of variances
 
 function [pval, chisq, df] = bartlett_test (varargin)
 
   k = nargin;
   if (k < 2)
-    usage ("[pval, chisq, df] = bartlett_test (x1, ...)");
+    print_usage ();
   endif
 
   f = zeros (k, 1);
   v = zeros (k, 1);
 
   for i = 1 : k;
     x = varargin{i};
     if (! isvector (x))
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -35,17 +35,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Chi-square test for homogeneity
 
 function [pval, chisq, df] = chisquare_test_homogeneity (x, y, c)
 
   if (nargin != 3)
-    usage ("[pval, chisq, df] = chisquare_test_homogeneity (x, y, c)");
+    print_usage ();
   endif
 
   if (! (isvector(x) && isvector(y) && isvector(c)))
     error ("chisquare_test_homogeneity: x, y and c must be vectors");
   endif
   ## Now test c for strictly increasing entries
   df = length (c);
   if (any ((c(2 : df) - c(1 : (df - 1))) <= 0))
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -31,17 +31,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Chi-square test for independence
 
 function [pval, chisq, df] = chisquare_test_independence (X)
 
   if (nargin != 1)
-    usage ("chisquare_test_independence (X)");
+    print_usage ();
   endif
 
   [r, s] = size (X);
   df = (r - 1) * (s - 1);
   n = sum (sum (X));
   Y = sum (X')' * sum (X) / n;
   X = (X - Y) .^2 ./ Y;
   chisq = sum (sum (X));
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -59,17 +59,17 @@
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Adapted-by: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test for zero correlation
 
 function t = cor_test (X, Y, ALTERNATIVE, METHOD)
 
   if ((nargin < 2) || (nargin > 4))
-    usage ("cor_test (X, Y, ALTERNATIVE, METHOD)")
+    print_usage ();
   endif
 
   if (!isvector (X) || !isvector (Y) || length (X) != length (Y))
     error ("cor_test: X and Y must be vectors of the same length")
   endif
 
   if (nargin < 3)
     ALTERNATIVE = "!=";
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -34,17 +34,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test linear hypotheses in linear regression model
 
 function [pval, f, df_num, df_den] = f_test_regression (y, X, R, r)
 
   if (nargin < 3 || nargin > 4)
-    usage ("[pval, f, df_num, df_den] = f_test_regression (y, X, R, r)");
+    print_usage ();
   endif
 
   [T, k] = size (X);
   if (! (isvector (y) && (length (y) == T)))
     error ("f_test_regression: y must be a vector of length rows (X)");
   endif
   y = reshape (y, T, 1);
 
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
--- a/scripts/statistics/tests/hotelling_test.m
+++ b/scripts/statistics/tests/hotelling_test.m
@@ -34,17 +34,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test for mean of a multivariate normal
 
 function [pval, Tsq] = hotelling_test (x, m)
 
   if (nargin != 2)
-    usage ("hotelling_test (x, m)");
+    print_usage ();
   endif
 
   if (isvector (x))
     if (! isscalar (m))
       error ("hotelling_test: if x is a vector, m must be a scalar");
     endif
     n = length (x);
     p = 1;
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -41,17 +41,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compare means of two multivariate normals
 
 function [pval, Tsq] = hotelling_test_2 (x, y)
 
   if (nargin != 2)
-    usage ("hotelling_test_2 (x, y)");
+    print_usage ();
   endif
 
   if (isvector (x))
     n_x = length (x);
     if (! isvector (y))
       error ("hotelling_test_2: if x is a vector, y must also be a vector");
     else
       n_y = length (y);
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -48,17 +48,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: One-sample Kolmogorov-Smirnov test
 
 function [pval, ks] = kolmogorov_smirnov_test (x, dist, varargin)
 
   if (nargin < 2)
-    usage ("[pval, ks] = kolmogorov_smirnov_test (x, dist,, params, alt)");
+    print_usage ();
   endif
 
   if (! isvector (x))
     error ("kolmogorov_smirnov_test: x must be a vector");
   endif
 
   n = length (x);
   s = sort (x);
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -44,17 +44,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Two-sample Kolmogorov-Smirnov test
 
 function [pval, ks, d] = kolmogorov_smirnov_test_2 (x, y, alt)
 
   if (nargin < 2 || nargin > 3)
-    usage ("[pval, ks] = kolmogorov_smirnov_test_2 (x, y, tol)");
+    print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("kolmogorov_smirnov_test_2: both x and y must be vectors");
   endif
 
   if (nargin == 2)
     alt = "!=";
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -37,17 +37,17 @@
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Kruskal-Wallis test
 
 function [pval, k, df] = kruskal_wallis_test (varargin)
 
   m = nargin;
   if (m < 2)
-    usage ("[pval, k, df] = kruskal_wallis_test (x1, ...)");
+    print_usage ();
   endif
 
   n = [];
   p = [];
 
   for i = 1 : m;
     x = varargin{i};
     if (! isvector (x))
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -39,17 +39,17 @@
 
 ## Author: TF <Thomas.Fuereder@ci.tuwien.ac.at>
 ## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: One-way multivariate analysis of variance (MANOVA)
 
 function manova (Y, g)
 
   if (nargin != 2)
-    usage ("manova (Y, g)");
+    print_usage ();
   endif
 
   if (isvector (Y))
     error ("manova: Y must not be a vector");
   endif
 
   [n, p] = size (Y);
 
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
--- a/scripts/statistics/tests/mcnemar_test.m
+++ b/scripts/statistics/tests/mcnemar_test.m
@@ -33,17 +33,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: McNemar's test for symmetry
 
 function [pval, chisq, df] = mcnemar_test (x)
 
   if (nargin != 1)
-    usage ("mcnemar_test (x)");
+    print_usage ();
   endif
 
   if (! (min (size (x)) > 1) && issquare (x))
     error ("mcnemar_test: x must be a square matrix of size > 1");
   elseif (! (all (all (x >= 0)) && all (all (x == round (x)))))
     error ("mcnemar_test: all entries of x must be nonnegative integers");
   endif
 
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -39,17 +39,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compare two proportions
 
 function [pval, z] = prop_test_2 (x1, n1, x2, n2, alt)
 
   if ((nargin < 4) || (nargin > 5))
-        usage ("[pval, z] = prop_test_2 (x1, n1, x2, n2, alt)");
+        print_usage ();
   endif
 
   ## Could do sanity checking on x1, n1, x2, n2 here
 
   p1  = x1 / n1;
   p2  = x2 / n2;
   pc  = (x1 + x2) / (n1 + n2);
 
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
--- a/scripts/statistics/tests/run_test.m
+++ b/scripts/statistics/tests/run_test.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Run test for independence
 
 function [pval, chisq] = run_test (x)
 
   if (nargin != 1)
-    usage ("run_test (x)");
+    print_usage ();
   endif
 
   A = [4529.4,  9044.9, 13568,  18091,  22615,  27892;
        9044.4, 18097,   27139,  36187,  45234,  55789;
       13568,   27139,   40721,  54281,  67852,  83685;
       18091,   36187,   54281,  72414,  90470, 111580;
       22615,   45234,   67852,  90470, 113262, 139476;
       27892,   55789,   83685, 111580, 139476, 172860];
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -41,17 +41,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Sign test
 
 function [pval, b, n] = sign_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, b, n] = sign_test (x, y, alt)");
+    print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
     error ("sign_test: x and y must be vectors of the same length");
   endif
 
   n   = length (x);
   x   = reshape (x, 1, n);
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -40,17 +40,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Student's one-sample t test
 
 function [pval, t, df] = t_test (x, m, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, t, df] = t_test (x, m, alt)");
+    print_usage ();
   endif
 
   if (! isvector (x))
     error ("t_test: x must be a vector");
   endif
   if (! isscalar (m))
     error ("t_test: m must be a scalar");
   endif
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -40,17 +40,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Student's two-sample t test
 
 function [pval, t, df] = t_test_2 (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-        usage ("[pval, t, df] = t_test_2 (x, y, alt)");
+        print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("t_test_2: both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -50,17 +50,17 @@ function [pval, t, df] = t_test_regressi
   elseif (nargin == 4)
     if (ischar (r))
       alt = r;
       r   = 0;
     else
       alt = "!=";
     endif
   elseif (! (nargin == 5))
-    usage ("[pval, t, df] = t_test_regression (y, X, R, r, alt)");
+    print_usage ();
   endif
 
   if (! isscalar (r))
     error ("t_test_regression: r must be a scalar");
   elseif (! ischar (alt))
     error ("t_test_regression: alt must be a string");
   endif
 
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -42,17 +42,17 @@
 ## the normal approximation is rather bad ...
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Mann-Whitney U-test
 
 function [pval, z] = u_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, z] = u_test (x, y, alt)");
+    print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("u_test: both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -39,17 +39,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: F test to compare two variances
 
 function [pval, f, df_num, df_den] = var_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, f, df_num, df_den] = var_test (x, y, alt)");
+    print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("var_test: both x and y must be vectors");
   endif
 
   df_num = length (x) - 1;
   df_den = length (y) - 1;
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -39,17 +39,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Welch two-sample t test
 
 function [pval, t, df] = welch_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, t, df] = welch_test (x, y, alt)");
+    print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error ("welch_test: both x and y must be vectors");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -38,17 +38,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Wilcoxon signed-rank test
 
 function [pval, z] = wilcoxon_test (x, y, alt)
 
   if ((nargin < 2) || (nargin > 3))
-    usage ("[pval, z] = wilcoxon_test (x, y, alt)");
+    print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
     error ("wilcoxon_test: x and y must be vectors of the same length");
   endif
 
   n = length (x);
   x = reshape (x, 1, n);
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -40,17 +40,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test for mean of a normal sample with known variance
 
 function [pval, z] = z_test (x, m, v, alt)
 
   if ((nargin < 3) || (nargin > 4))
-    usage ("[pval, z] = z_test (x, m, v, alt)");
+    print_usage ();
   endif
 
   if (! isvector (x))
     error ("z_test: x must be a vector");
   endif
   if (! isscalar (m))
     error ("z_test: m must be a scalar");
   endif
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -40,17 +40,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compare means of two normal samples with known variances
 
 function [pval, z] = z_test_2 (x, y, v_x, v_y, alt)
 
   if ((nargin < 4) || (nargin > 5))
-    usage ("[pval, z] = z_test_2 (x, y, v_x, v_y, alt)");
+    print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
     error("z_test_2: both x and y must be vectors");
   elseif (! (isscalar (v_x) && (v_x > 0)
              && isscalar (v_y) && (v_y > 0)))
     error ("z_test_2: both v_x and v_y must be positive scalars");
   endif
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -44,17 +44,17 @@
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function out = base2dec (d, base)
 
   if (nargin != 2)
-    usage ("n = base2dec('d', base)");
+    print_usage ();
   endif
 
   symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
   if (ischar (base))
     symbols = base;
     base = length (symbols);
     if (any (diff (sort (toascii (symbols))) == 0))
       error ("base2dec: symbols representing digits must be unique.");
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -23,17 +23,17 @@
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function s = blanks (n)
 
   if (nargin != 1)
-    usage ("blanks (n)");
+    print_usage ();
   endif
 
   if (isscalar (n) && n == round (n))
     s = char (ones (1, n) * toascii (" "));
   else
     error ("blanks: n must be a non-negative integer");
   endif
 
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function s = deblank (s)
 
   if (nargin != 1)
-    usage ("deblank (s)");
+    print_usage ();
   endif
 
   if (ischar (s))
 
     k = find (! isspace (s) & s != "\0");
     if (isempty (s) || isempty (k))
       s = "";
     else
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -45,17 +45,17 @@
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function retval = dec2base (n, base, len)
 
   if (nargin < 2 || nargin > 3)
-    usage ("dec2base (n, base [, len])");
+    print_usage ();
   endif
 
   if (prod (size (n)) != length (n))
     n = n(:);
   elseif (any (n < 0 | n != fix (n)))
     error ("dec2base: can only convert non-negative integers")
   endif
 
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -40,12 +40,12 @@
 
 function retval = dec2bin (n, len)
 
   if (nargin == 1)
     retval = dec2base (n, 2);
   elseif (nargin == 2)
     retval = dec2base (n, 2, len);
   else
-    usage ("dec2bin (n [, len])");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -40,12 +40,12 @@
 
 function retval = dec2hex (n, len)
 
   if (nargin == 1)
     retval = dec2base (n, 16);
   elseif (nargin == 2)
     retval = dec2base (n, 16, len);
   else
-    usage ("dec2hex (n [, len])");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -36,17 +36,17 @@
 ## than the first, so try to put the longer one first.
 ##
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function v = findstr (s, t, overlap)
 
   if (nargin < 2 || nargin > 3)
-    usage ("findstr (s, t, overlap)");
+    print_usage ();
   endif
 
   if (all (size (s) > 1) || all (size (t) > 1))
     error ("findstr: arguments must have only one non-singleton dimension");
   endif
 
   if (nargin == 2)
     overlap = 1;
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -35,14 +35,14 @@
 ## @end deftypefn
 
 ## Author: Daniel Calvelo <dcalvelo@yahoo.com>
 ## Adapted-by: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 
 function d = hex2dec (h)
 
   if (nargin != 1)
-    usage ("hex2dec (b)");
+    print_usage ();
   else
     d = base2dec (h, 16);
   endif
 
 endfunction
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -33,17 +33,17 @@
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function n = index (s, t)
 
   ## This is patterned after the AWK function of the same name.
 
   if (nargin != 2)
-    usage ("index (s, t)");
+    print_usage ();
   endif
   
   if (!ischar (s) || !ischar (t) || all (size (s) > 1) || all (size (t) > 1) )
     error ("index: expecting string arguments");
   endif
 
   l_s = length (s);
   l_t = length (t);
diff --git a/scripts/strings/isletter.m b/scripts/strings/isletter.m
--- a/scripts/strings/isletter.m
+++ b/scripts/strings/isletter.m
@@ -23,14 +23,14 @@
 ## @seealso{isalpha}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = isletter (s)
 
   if (nargin != 1)
-    usage ("isletter (s)");
+    print_usage ();
   endif
 
   retval = isalpha (s);
 
 endfunction
diff --git a/scripts/strings/lower.m b/scripts/strings/lower.m
--- a/scripts/strings/lower.m
+++ b/scripts/strings/lower.m
@@ -24,17 +24,17 @@
 ## @seealso{upper, tolower, toupper}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = lower (s)
 
   if (nargin != 1)
-    usage ("lower (s)");
+    print_usage ();
   endif
 
   if (ischar (s))
     retval = tolower (s);
   elseif (iscellstr (s))
     retval = cellfun (@tolower, s, "UniformOutput", false);
   else
     error ("lower: `s' must be a string or cell array of strings");
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -33,17 +33,17 @@
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function n = rindex (s, t)
 
   ## This is patterned after the AWK function of the same name.
 
   if (nargin != 2)
-    usage ("rindex (s, t)");
+    print_usage ();
   endif
 
   if (!ischar (s) || !ischar (t) || all (size (s) > 1) || all (size (t) > 1) )
     error ("rindex: expecting string arguments");
   endif
 
   l_s = length (s);
   l_t = length (t);
diff --git a/scripts/strings/split.m b/scripts/strings/split.m
--- a/scripts/strings/split.m
+++ b/scripts/strings/split.m
@@ -90,12 +90,12 @@ function m = split (s, t, n)
       for i = 1:length (ind)
 	tmp = ind2(i):(ind(i)-1);
 	m(i,1:length(tmp)) = s(tmp);
       endfor
     else
       error ("split: both s and t must be strings");
     endif
   else
-    usage ("split (s, t, n)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/strings/str2mat.m b/scripts/strings/str2mat.m
--- a/scripts/strings/str2mat.m
+++ b/scripts/strings/str2mat.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function retval = str2mat (varargin)
 
   if (nargin == 0)
-    usage ("str2mat (s1, ...)");
+    print_usage ();
   endif
 
   nc = 0;
   nr = 0;
 
   nr = zeros (nargin, 1);
   nc = zeros (nargin, 1);
   for k = 1 : nargin
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -31,12 +31,12 @@ function m = str2num (s)
     sep = ";";
     sep = sep (ones (nr, 1), 1);
     s = sprintf ("m = [%s];", reshape ([s, sep]', 1, nr * (nc + 1)));
     eval (s, "m = [];");
     if (ischar (m))
       m = [];
     endif
   else
-    usage ("str2num (s)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -47,14 +47,14 @@ function st = strcat (s, varargin)
       tmp = varargin{k++};
       if (ischar (tmp))
 	tmpst = [tmpst, tmp];
       else
 	error ("strcat: all arguments must be strings");
       endif
     endwhile
   else
-    usage ("strcat (s, t, ...)");
+    print_usage ();
   endif
 
   st = tmpst;
 
 endfunction
diff --git a/scripts/strings/strcmpi.m b/scripts/strings/strcmpi.m
--- a/scripts/strings/strcmpi.m
+++ b/scripts/strings/strcmpi.m
@@ -43,12 +43,12 @@ function retval = strcmpi (s1, s2)
     if ((ischar(s1) || iscellstr(s1)) && (ischar(s2) || iscellstr(s2)))
       ## Note that we don't use tolower here because we need to be able
       ## to handle cell arrays of strings.
       retval = strcmp (lower (s1), lower (s2));
     else
       retval = false;
     endif
   else
-    usage ("strcmpi (s1, s2)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/strings/strfind.m b/scripts/strings/strfind.m
--- a/scripts/strings/strfind.m
+++ b/scripts/strings/strfind.m
@@ -31,17 +31,17 @@
 
 ## Author: alois schloegl <a.schloegl@ieee.org>
 ## Created: 1 November 2004
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function idx = strfind (text, pattern)
 
   if (nargin != 2)
-    usage ("idx = strfind (text, pattern)");
+    print_usage ();
   elseif (! ischar (pattern))
     error ("strfind: pattern must be a string value");
   endif
 
   lp = length (pattern);
 
   if (ischar (text))
     idx = __strfind_string__ (text, pattern, lp);
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -23,17 +23,17 @@
 ## the string.  If @var{s} is a string array, justify each string in the
 ## array.  Null characters are replaced by blanks.  If no justification
 ## is specified, then all rows are right-justified.
 ## @end deftypefn
 
 function x = strjust (x, just)
 
   if (nargin < 1 || nargin > 2)
-    usage ("strjust (s, ['left'|'right'|'center'])");
+    print_usage ();
   endif
 
   if (nargin == 1)
     just = "right";
   endif
 
   just = tolower (just);
 
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -28,17 +28,17 @@
 ## @end deftypefn
 
 ## Author: Paul Kienzle, Alois Schloegl
 ## Adapted-by: jwe
 
 function idx = strmatch (s, A, exact)
 
   if (nargin < 2 || nargin > 3)
-    usage ("strmatch (s, A, \"exact\")");
+    print_usage ();
   endif
 
   [nr, nc] = size (A);
   nel = numel (A);
   if (iscell (A))
     match = zeros (nel, 1);
     if (nargin > 2)
       for k = 1:nel
diff --git a/scripts/strings/strncmp.m b/scripts/strings/strncmp.m
--- a/scripts/strings/strncmp.m
+++ b/scripts/strings/strncmp.m
@@ -34,12 +34,12 @@
 ## @seealso{strcmp, strcmpi, strncmpi}
 ## @end deftypefn
 
 function retval = strncmp (s1, s2, n)
 
   if (nargin == 3)
     retval = strcmp (strtrunc (s1, n), strtrunc (s2, n));
   else
-    usage ("strncmp (s1, s2, n)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/strings/strncmpi.m b/scripts/strings/strncmpi.m
--- a/scripts/strings/strncmpi.m
+++ b/scripts/strings/strncmpi.m
@@ -36,12 +36,12 @@
 
 function retval = strncmpi (s1, s2, n)
 
   if (nargin == 3)
     ## Note that we don't use tolower here because we need to be able to
     ## handle cell arrays of strings.
     retval = strcmp (lower (strtrunc (s1, n)), lower (strtrunc (s2, n)));
   else
-    usage ("strncmpi (s1, s2, n)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/strings/strrep.m b/scripts/strings/strrep.m
--- a/scripts/strings/strrep.m
+++ b/scripts/strings/strrep.m
@@ -30,17 +30,17 @@
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 11 November 1994
 ## Adapted-By: jwe
 
 function t = strrep (s, x, y)
 
   if (nargin != 3)
-    usage ("strrep (s, x, y)");
+    print_usage ();
   endif
 
   if (! (ischar (s) && ischar (x) && ischar (y)))
     error ("strrep: all arguments must be strings");
   endif
 
   if (length (x) > length (s) || isempty (x))
     t = s;
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -24,17 +24,17 @@
 ##
 ## If @var{s} is a cell array of strings, then the operation is performed
 ## on its members and the new cell array is returned.
 ## @end deftypefn
 
 function s = strtrunc (s, n)
 
   if (nargin != 2)
-    usage ("strtrunc (s, n)");
+    print_usage ();
   endif
 
   if (ischar (s))
     s_was_char = true;
     s = {s};
   else
     s_was_char = false;
   endif
diff --git a/scripts/strings/strvcat.m b/scripts/strings/strvcat.m
--- a/scripts/strings/strvcat.m
+++ b/scripts/strings/strvcat.m
@@ -33,17 +33,17 @@
 ##           ignores empty strings.
 ## Modified by Alois Schloegl <a.schloegl@ieee.org> Mar 2005
 ##	     added support for cell-strings 
 ## Modifed by David Bateman for NDArrays
 
 function retval = strvcat (varargin)
 
   if (nargin == 0)
-    usage ("strvcat (s1, ...)");
+    print_usage ();
   endif
 
   nr = zeros (nargin, 1);
   nc = zeros (nargin, 1);
   K = 0; 
   nd = ndims (varargin {1});
   sz = size (varargin {1});
   for k = 1 : nargin
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -40,17 +40,17 @@
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function t = substr (s, offset, len)
 
   if (nargin < 2 || nargin > 3)
-    usage ("substr (s, offset, len)");
+    print_usage ();
   endif
 
   if (ischar (s))
     nc = columns (s);
     if (abs (offset) > 0 && abs (offset) <= nc)
       if (offset > 0)
         beg = offset;
       else
diff --git a/scripts/strings/upper.m b/scripts/strings/upper.m
--- a/scripts/strings/upper.m
+++ b/scripts/strings/upper.m
@@ -24,17 +24,17 @@
 ## @seealso{lower, tolower, toupper}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = upper (s)
 
   if (nargin != 1)
-    usage ("upper (s)");
+    print_usage ();
   endif
 
   if (ischar (s))
     retval = toupper (s);
   elseif (iscellstr (s))
     retval = cellfun (@toupper, s, "UniformOutput", false);
   else
     error ("upper: `s' must be a string or cell array of strings");
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -44,17 +44,17 @@
 
 ## TODO: Output throttling: don't print out the entire 100x100 matrix,
 ## TODO: but instead give a summary; don't print out the whole list, just
 ## TODO: say what the first different element is, etc.  To do this, make
 ## TODO: the message generation type specific.
 function assert(cond, expected, tol)
 
   if (nargin < 1 || nargin > 3)
-    usage("assert (cond) or assert (v, expected_v [,tol])");
+    print_usage ();
   endif
 
   if (nargin < 3)
     tol = 0;
   endif
 
   if exist("argn") == 0, argn=" "; endif
   in = deblank(argn(1,:));
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -73,17 +73,17 @@
 ## TODO: use the current figure window but pause if not plotting in the
 ## TODO: first subplot.
 
 ## PKG_ADD: mark_as_command demo
 
 function demo(name, n)
 
   if (nargin < 1 || nargin > 2)
-    usage("demo('name')  or demo('name, n)");
+    print_usage ();
   endif
 
   if (nargin < 2)
     n = 0;
   endif
 
   [code, idx] = test (name, 'grabdemo');
   if (length(idx) == 0)
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -31,17 +31,17 @@
 ## @seealso{demo, test}
 ## @end deftypefn
 
 ## PKG_ADD: mark_as_command example
 
 function [code_r, idx_r] = example(name, n)
 
   if (nargin < 1 || nargin > 2)
-    usage("example('name')  or example('name', n)");
+    print_usage ();
   endif
   if (nargin < 2)
     n = 0;
   endif
 
   [code, idx] = test (name, 'grabdemo');
   if (nargout > 0)
     if (n > 0)
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 ## This program is public domain
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 ## PKG_ADD mark_as_command fail
 function ret=fail(code,pattern,warning_pattern)
   if nargin < 1 || nargin > 3
-    usage("fail(code [, 'warning'] [, pattern])");
+    print_usage ();
   endif
 
   ## sort out arguments
   test_warning =  (nargin > 1 && strcmp(pattern,'warning'));
   if nargin == 3
     pattern = warning_pattern;
   elseif nargin == 1 || (nargin==2 && test_warning)
     pattern = "";
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -139,17 +139,17 @@
 ## @code{demo('speed')}. Instead use, @code{eval(example('speed',1))}
 ## and @code{eval(example('speed',2))}.
 ## @end deftypefn
 
 ## TODO: consider two dimensional speedup surfaces for functions like kron.
 function [__order, __test_n, __tnew, __torig] ...
 	= speed (__f1, __init, __max_n, __f2, __tol)
   if nargin < 1 || nargin > 6, 
-    usage("speed_test(f, init, max_n, f2, tol)");
+    print_usage ();
   endif
   if nargin < 2 || isempty(__init), 
     __init = "x = randn(n, 1);";
   endif
   if nargin < 3 || isempty(__max_n), __max_n = 100; endif
   if nargin < 4, __f2 = []; endif
   if nargin < 5 || isempty(__tol), __tol = eps; endif
 
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -84,20 +84,20 @@ function [__ret1, __ret2] = test (__name
   if (nargin < 2 || isempty(__flag))
     __flag = "quiet";
   endif
   if (nargin < 3) 
     __fid = []; 
   endif
   if (nargin < 1 || nargin > 3 ...
       || (!ischar(__name) && !isempty(__name)) || !ischar(__flag))
-    usage("success = test('name', ['quiet'|'normal'|'verbose'], fid)");
+    print_usage ();
   endif
   if (isempty(__name) && (nargin != 3 || !strcmp(__flag, "explain")))
-    usage("test([], 'explain', fid)");
+    print_usage ();
   endif
   __batch = (!isempty(__fid));
 
   ## decide if error messages should be collected
   __close_fid = 0;
   if (__batch)
     if (ischar(__fid))
       __fid = fopen(__fid, "wt");
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -34,12 +34,12 @@
 
 ## Author: jwe
 
 function retval = asctime (t)
 
   if (nargin == 1)
     retval = strftime ("%a %b %d %H:%M:%S %Y\n", t);
   else
-    usage ("asctime (TMSTRUCT)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/time/calendar.m b/scripts/time/calendar.m
--- a/scripts/time/calendar.m
+++ b/scripts/time/calendar.m
@@ -53,17 +53,17 @@ function varargout = calendar (varargin)
       y = v(1);
       m = v(2);
       d = v(3);
     case 2
       y = varargin{1};
       m = varargin{2};
       d = [];
     otherwise
-      usage ("calendar () or c = calendar (d) or c = calendar (y, m)");
+      print_usage ();
   endswitch
 
   c = zeros (7, 6);
   dayone = datenum (y, m, 1);
   ndays = eomday (y, m);
   c(weekday (dayone) - 1 + [1:ndays]) = 1:ndays;
 
   if (nargout > 0)
diff --git a/scripts/time/ctime.m b/scripts/time/ctime.m
--- a/scripts/time/ctime.m
+++ b/scripts/time/ctime.m
@@ -34,12 +34,12 @@
 
 ## Author: jwe
 
 function retval = ctime (t)
 
   if (nargin == 1)
     retval = asctime (localtime (t));
   else
-    usage ("ctime (TIME)");
+    print_usage ();
   endif
 
 endfunction
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -62,17 +62,17 @@
 ## Author: pkienzle <pkienzle@users.sf.net>
 
 function [days, secs] = datenum (Y, M, D, h, m, s)
 
   ## Days until start of month assuming year starts March 1.
   persistent monthstart = [306; 337; 0; 31; 61; 92; 122; 153; 184; 214; 245; 275];
 
   if (nargin == 0 || (nargin > 2  && ischar (Y)) || nargin > 6)
-    usage ("n = datenum ('date' [, P]) or n = datenum (Y, M, D [, h, m [, s]])");
+    print_usage ();
   endif
   if (ischar (Y))
     if (nargin < 2)
       M = [];
     endif
     [Y, M, D, h, m, s] = datevec (Y, M);
   else
     if (nargin < 6) s = 0; endif
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -179,17 +179,17 @@ function retval = datestr (date, f, p)
 
     names_ddd = {"Sun"; "Mon"; "Tue"; "Wed"; "Thu"; "Fri"; "Sat"};
 
     names_d = {"S"; "M"; "T"; "W"; "T"; "F"; "S"};
 
   endif
 
   if (nargin < 1 || nargin > 3)
-    usage("str = datestr (date, [f, [p]])");
+    print_usage ();
   endif
 
   if (nargin < 2)
     f = [];
   endif
   if (nargin < 3)
     p = [];
   endif
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -75,17 +75,17 @@ function [y, m, d, h, mi, s] = datevec (
     std_formats{++nfmt} = "mmm.dd.yyyy";
 
    # custom formats
     std_formats{++nfmt} = "mmmyy";                  # 12
     std_formats{++nfmt} = "mm/dd/yyyy HH:MM";
   endif
 
   if (nargin < 1 || nargin > 3)
-    usage("v = datevec (...) or [y, m, d, h, mi, s] = datevec (...)");
+    print_usage ();
   endif
 
   switch (nargin)
   case 1
     f = [];
     p = [];
   case 2
     if (ischar (varargin{1}))
diff --git a/scripts/time/eomday.m b/scripts/time/eomday.m
--- a/scripts/time/eomday.m
+++ b/scripts/time/eomday.m
@@ -25,17 +25,17 @@
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Created: 25 July 2004
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
 function e = eomday (y, m)
 
   if (nargin != 2)
-    usage ("e = eomday (y, m)");
+    print_usage ();
   endif
 
   eom = [31, 28, 31, 30 ,31, 30, 31, 31, 30, 31, 30, 31];
   e = eom(m);
   e += (m == 2) & (mod (y, 4) == 0 & (mod (y, 100) != 0 | mod (y, 400) == 0));
 
 endfunction
 
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -34,17 +34,17 @@
 ## @seealso{tic, toc, clock, cputime}
 ## @end deftypefn
 
 ## Author: jwe
 
 function secs = etime (t1, t0)
 
   if (nargin != 2)
-    usage ("etime (t1, t0)");
+    print_usage ();
   endif
 
   [d1, s1] = datenum (t1);
   [d0, s0] = datenum (t0);
 
   secs = s1 - s0;
 
 endfunction
diff --git a/scripts/time/is_leap_year.m b/scripts/time/is_leap_year.m
--- a/scripts/time/is_leap_year.m
+++ b/scripts/time/is_leap_year.m
@@ -31,17 +31,17 @@
 ## @end example
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = is_leap_year (year)
 
   if (nargin > 1)
-    usage ("is_leap_year (year)");
+    print_usage ();
   endif
 
   if (nargin == 0)
     t = clock ();
     year = t (1);
   endif
 
   retval = ((rem (year, 4) == 0 & rem (year, 100) != 0) ...
