# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1549497835 0
#      Thu Feb 07 00:03:55 2019 +0000
# Node ID 581d01526b34d7c1a52c701e9985b33291b1d096
# Parent  466e9b261689d67af8b31259491bd0ff890a121d
eliminate unnecessary tree_funcall class

The tree_funcall class was only used to handled generated calls to
internal functions used by classdef superclass reference and metaclass
query operations.  This change replaces those function calls by
something more direct.

* pt-classdef.h, pt-classdef.cc (tree_superclass_ref,
tree_metaclass_query): New classes.

* pt-walk.h (tree_walker::visit_tree_funcall): Delete.  Update all
derived classes.
(tree_walker::visit_superclass_ref,
tree_walker::visit_metaclass_query): New virtual functions.
* pt-pr-code.h, pt-pr-code.cc (tree_print_code::visit
(tree_print_code::visit_superclass_ref,
tree_print_code::visit_metaclass_query):
Correctly print these parse tree elements.

* oct-parse.yy (superclass_identifier, meta_identifier): Use new
tree_superclass_ref tree_metaclass_query classes instead of
tree_funcall to represent these language elements.

* lex.ll (base_lexer::handle_superclass_identifier): Attempt to make
intent of code clearer.  Save line and column info in token.

* pt-eval.h, pt-eval.cc (tree_evaluator::visit_funcall): Delete.
(tree_evaluator::visit_superclass_ref,
tree_evaluator::visit_metaclass_query): New functions.  Handle
superclass reference and metaclass query operations more directly.

* ov-classdef.h, ov-classdef.cc (F__superclass_reference__,
F__meta_class_query__): Delete.
(class octave_classdef_superclass_ref): Work directly with
method or object and class names as strings instead of octave_value
objects.
(octave_classdef::superclass_ref, octave_classdef::metaclass_query):
New static functions.

* token.h, token.cc: Attempt to use clearer names for superclass
reference tokens.

* pt-funcall.h, pt-funcall.cc: Delete.
* libinterp/parse-tree/module.mk: Update.
* pt-all.h: Update.

diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -31,20 +31,20 @@ along with Octave; see the file COPYING.
 #include "interpreter-private.h"
 #include "interpreter.h"
 #include "load-path.h"
 #include "ov-builtin.h"
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-typeinfo.h"
 #include "ov-usr-fcn.h"
+#include "parse.h"
 #include "pt-assign.h"
 #include "pt-classdef.h"
 #include "pt-eval.h"
-#include "pt-funcall.h"
 #include "pt-idx.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "symtab.h"
 
 // Define to 1 to enable debugging statements.
 #define DEBUG_TRACE 0
@@ -1120,18 +1120,21 @@ private:
 
 //----------------------------------------------------------------------------
 
 class octave_classdef_superclass_ref : public octave_function
 {
 public:
   octave_classdef_superclass_ref (void) = delete;
 
-  octave_classdef_superclass_ref (const octave_value_list& a)
-    : octave_function (), args (a) { }
+  octave_classdef_superclass_ref (const std::string& meth_or_obj,
+                                  const std::string& cls)
+    : octave_function (), m_method_or_object_name (meth_or_obj),
+      m_class_name (cls)
+  { }
 
   octave_classdef_superclass_ref (const octave_classdef_superclass_ref&) = delete;
 
   octave_classdef_superclass_ref& operator = (const octave_classdef_superclass_ref&) = delete;
 
   ~octave_classdef_superclass_ref (void) = default;
 
   bool is_classdef_superclass_ref (void) const { return true; }
@@ -1147,18 +1150,18 @@ public:
     bool in_constructor;
     cdef_class ctx;
 
     ctx = get_class_context (meth_name, in_constructor);
 
     if (! ctx.ok ())
       error ("superclass calls can only occur in methods or constructors");
 
-    std::string mname = args(0).string_value ();
-    std::string cname = args(1).string_value ();
+    std::string mname = m_method_or_object_name;
+    std::string cname = m_class_name;
 
     cdef_class cls = lookup_class (cname);
 
     if (in_constructor)
       {
         if (! is_direct_superclass (cls, ctx))
           error ("`%s' is not a direct superclass of `%s'",
                  cname.c_str (), ctx.get_name ().c_str ());
@@ -1227,19 +1230,34 @@ private:
               return (ret_list->front ()->name () == nm);
           }
       }
 
     return false;
   }
 
 private:
-  octave_value_list args;
+
+  std::string m_method_or_object_name;
+  std::string m_class_name;
 };
 
+octave_value
+octave_classdef::superclass_ref (const std::string& meth_or_obj,
+                                 const std::string& cls)
+{
+  return octave_value (new octave_classdef_superclass_ref (meth_or_obj, cls));
+}
+
+octave_value
+octave_classdef::metaclass_query (const std::string& cls)
+{
+  return to_ov (lookup_class (cls));
+}
+
 //----------------------------------------------------------------------------
 
 void
 cdef_object_rep::release (const cdef_object& obj)
 {
   // We need to be careful to keep a reference to the object if we are
   // calling the delete method.  The object is passed to the delete
   // method as an argument and if the count is already zero when we
@@ -1974,44 +1992,16 @@ public:
     t.right_hand_side ()->accept (*this);
   }
 
   void visit_index_expression (octave::tree_index_expression& t)
   {
     t.expression ()->accept (*this);
   }
 
-  void visit_funcall (octave::tree_funcall& t)
-  {
-    octave_value fcn = t.function ();
-
-    if (fcn.is_function ())
-      {
-        octave_function *of = fcn.function_value (true);
-
-        if (of)
-          {
-            if (of->name () == "__superclass_reference__")
-              {
-                octave_value_list args = t.arguments ();
-
-                if (args(0).string_value () == obj_name)
-                  {
-                    std::string class_name = args(1).string_value ();
-
-                    cdef_class cls = lookup_class (class_name, false);
-
-                    if (cls.ok ())
-                      ctor_list.push_back (cls);
-                  }
-              }
-          }
-      }
-  }
-
   std::list<cdef_class> get_constructor_list (void) const
   { return ctor_list; }
 
   // NO-OP
   void visit_anon_fcn_handle (octave::tree_anon_fcn_handle&) { }
   void visit_argument_list (octave::tree_argument_list&) { }
   void visit_binary_expression (octave::tree_binary_expression&) { }
   void visit_break_command (octave::tree_break_command&) { }
@@ -2042,16 +2032,29 @@ public:
   void visit_prefix_expression (octave::tree_prefix_expression&) { }
   void visit_return_command (octave::tree_return_command&) { }
   void visit_return_list (octave::tree_return_list&) { }
   void visit_try_catch_command (octave::tree_try_catch_command&) { }
   void visit_unwind_protect_command (octave::tree_unwind_protect_command&) { }
   void visit_while_command (octave::tree_while_command&) { }
   void visit_do_until_command (octave::tree_do_until_command&) { }
 
+  void visit_superclass_ref (octave::tree_superclass_ref& t)
+  {
+    if (t.method_or_object_name () == obj_name)
+      {
+        std::string class_name = t.class_name ();
+
+        cdef_class cls = lookup_class (class_name, false);
+
+        if (cls.ok ())
+          ctor_list.push_back (cls);
+      }
+  }
+
 private:
   // The name of the constructor being analyzed.
   std::string who;
 
   // The name of the first output argument of the constructor.
   std::string obj_name;
 
   // The list of superclass constructors that are explicitly called.
@@ -3906,45 +3909,16 @@ Undocumented internal function.
   if (args.length () != 1)
     print_usage ();
 
   std::string cname = args(0).xstring_value ("PACKAGE_NAME must be a string");
 
   return to_ov (lookup_package (cname));
 }
 
-DEFUN (__superclass_reference__, args, ,
-       doc: /* -*- texinfo -*-
-@deftypefn {} {} __superclass_reference__ ()
-Undocumented internal function.
-@end deftypefn */)
-{
-  return ovl (new octave_classdef_superclass_ref (args));
-}
-
-DEFUN (__meta_class_query__, args, ,
-       doc: /* -*- texinfo -*-
-@deftypefn {} {} __meta_class_query__ ()
-Undocumented internal function.
-@end deftypefn */)
-{
-#if DEBUG_TRACE
-  std::cerr << "__meta_class_query__ ("
-            << args(0).string_value () << ')'
-            << std::endl;
-#endif
-
-  if (args.length () != 1)
-    print_usage ();
-
-  std::string cls = args(0).xstring_value ("CLASS_NAME must be a string");
-
-  return to_ov (lookup_class (cls));
-}
-
 DEFUN (metaclass, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} metaclass (obj)
 Returns the meta.class object corresponding to the class of @var{obj}.
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -1555,16 +1555,21 @@ public:
   }
 
   octave_value
   get_property (octave_idx_type idx, const std::string& name) const
   {
     return object.get_property (idx, name);
   }
 
+  static octave_value superclass_ref (const std::string& meth_or_obj,
+                                      const std::string& cls);
+
+  static octave_value metaclass_query (const std::string& cls);
+
 public:
   int type_id (void) const { return t_id; }
   std::string type_name (void) const { return t_name; }
   std::string class_name (void) const { return object.class_name (); }
 
   static int static_type_id (void) { return t_id; }
   static std::string static_type_name (void) { return t_name; }
   static std::string static_class_name (void) { return "<unknown>"; }
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -2960,38 +2960,39 @@ namespace octave
 
     return (space_before && ! space_after
             && previous_token_may_be_command ());
   }
 
   int
   base_lexer::handle_superclass_identifier (void)
   {
-    std::string meth = flex_yytext ();
-
-    size_t pos = meth.find ("@");
-    std::string cls = meth.substr (pos + 1);
-    meth = meth.substr (0, pos);
-
-    bool kw_token = (is_keyword_token (meth)
+    std::string txt = flex_yytext ();
+
+    size_t pos = txt.find ("@");
+
+    std::string meth_or_obj = txt.substr (0, pos);
+    std::string cls = txt.substr (pos + 1);
+
+    bool kw_token = (is_keyword_token (meth_or_obj)
                      || fq_identifier_contains_keyword (cls));
 
     if (kw_token)
       {
         token *tok
           = new token (LEXICAL_ERROR,
                        "method, class, and package names may not be keywords",
                        m_input_line_number, m_current_input_column);
 
         push_token (tok);
 
         return count_token_internal (LEXICAL_ERROR);
       }
 
-    push_token (new token (SUPERCLASSREF, meth, cls,
+    push_token (new token (SUPERCLASSREF, meth_or_obj, cls,
                            m_input_line_number, m_current_input_column));
 
     m_current_input_column += flex_yyleng ();
 
     return SUPERCLASSREF;
   }
 
   int
diff --git a/libinterp/parse-tree/module.mk b/libinterp/parse-tree/module.mk
--- a/libinterp/parse-tree/module.mk
+++ b/libinterp/parse-tree/module.mk
@@ -22,17 +22,16 @@ PARSE_TREE_INC = \
   %reldir%/pt-cmd.h \
   %reldir%/pt-colon.h \
   %reldir%/pt-const.h \
   %reldir%/pt-decl.h \
   %reldir%/pt-eval.h \
   %reldir%/pt-except.h \
   %reldir%/pt-exp.h \
   %reldir%/pt-fcn-handle.h \
-  %reldir%/pt-funcall.h \
   %reldir%/pt-id.h \
   %reldir%/pt-idx.h \
   %reldir%/pt-jit.h \
   %reldir%/pt-jump.h \
   %reldir%/pt-loop.h \
   %reldir%/pt-mat.h \
   %reldir%/pt-misc.h \
   %reldir%/pt-pr-code.h \
@@ -72,17 +71,16 @@ PARSE_TREE_SRC = \
   %reldir%/pt-classdef.cc \
   %reldir%/pt-colon.cc \
   %reldir%/pt-const.cc \
   %reldir%/pt-decl.cc \
   %reldir%/pt-eval.cc \
   %reldir%/pt-except.cc \
   %reldir%/pt-exp.cc \
   %reldir%/pt-fcn-handle.cc \
-  %reldir%/pt-funcall.cc \
   %reldir%/pt-id.cc \
   %reldir%/pt-idx.cc \
   %reldir%/pt-jit.cc \
   %reldir%/pt-loop.cc \
   %reldir%/pt-mat.cc \
   %reldir%/pt-misc.cc \
   %reldir%/pt-pr-code.cc \
   %reldir%/pt-select.cc \
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -70,17 +70,16 @@ along with Octave; see the file COPYING.
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "ov-null-mat.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt-all.h"
 #include "pt-eval.h"
-#include "pt-funcall.h"
 #include "symtab.h"
 #include "token.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // oct-parse.h must be included after pt-all.h
 #include "oct-parse.h"
@@ -145,17 +144,18 @@ static void yyerror (octave::base_parser
   // Types for the nonterminals we generate.
   char punct_type;
   octave::tree *tree_type;
   octave::tree_matrix *tree_matrix_type;
   octave::tree_cell *tree_cell_type;
   octave::tree_expression *tree_expression_type;
   octave::tree_constant *tree_constant_type;
   octave::tree_fcn_handle *tree_fcn_handle_type;
-  octave::tree_funcall *tree_funcall_type;
+  octave::tree_superclass_ref *tree_superclass_ref_type;
+  octave::tree_metaclass_query *tree_metaclass_query_type;
   octave::tree_function_def *tree_function_def_type;
   octave::tree_anon_fcn_handle *tree_anon_fcn_handle_type;
   octave::tree_identifier *tree_identifier_type;
   octave::tree_index_expression *tree_index_expression_type;
   octave::tree_colon_expression *tree_colon_expression_type;
   octave::tree_argument_list *tree_argument_list_type;
   octave::tree_parameter_list *tree_parameter_list_type;
   octave::tree_command *tree_command_type;
@@ -243,17 +243,18 @@ static void yyerror (octave::base_parser
 %type <tree_anon_fcn_handle_type> anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
 %type <tree_matrix_type> matrix_rows
 %type <tree_cell_type> cell_rows
 %type <tree_expression_type> matrix cell
 %type <tree_expression_type> primary_expr oper_expr power_expr expr_no_assign
 %type <tree_expression_type> simple_expr colon_expr assign_expr expression
 %type <tree_identifier_type> identifier fcn_name magic_tilde
-%type <tree_funcall_type> superclass_identifier meta_identifier
+%type <tree_superclass_ref_type> superclass_identifier
+%type <tree_metaclass_query_type> meta_identifier
 %type <tree_index_expression_type> word_list_cmd
 %type <tree_argument_list_type> arg_list word_list assign_lhs
 %type <tree_argument_list_type> cell_or_matrix_row
 %type <tree_parameter_list_type> opt_param_list param_list
 %type <tree_parameter_list_type> param_list1 param_list2
 %type <tree_parameter_list_type> return_list return_list1
 %type <tree_command_type> command select_command loop_command
 %type <tree_command_type> jump_command except_command
@@ -320,17 +321,18 @@ static void yyerror (octave::base_parser
 %destructor { } <>
 
 %destructor { delete $$; } <tree_type>
 %destructor { delete $$; } <tree_matrix_type>
 %destructor { delete $$; } <tree_cell_type>
 %destructor { delete $$; } <tree_expression_type>
 %destructor { delete $$; } <tree_constant_type>
 %destructor { delete $$; } <tree_fcn_handle_type>
-%destructor { delete $$; } <tree_funcall_type>
+%destructor { delete $$; } <tree_superclass_ref_type>
+%destructor { delete $$; } <tree_metaclass_query_type>
 %destructor { delete $$; } <tree_function_def_type>
 %destructor { delete $$; } <tree_anon_fcn_handle_type>
 %destructor { delete $$; } <tree_identifier_type>
 %destructor { delete $$; } <tree_index_expression_type>
 %destructor { delete $$; } <tree_argument_list_type>
 %destructor { delete $$; } <tree_parameter_list_type>
 %destructor { delete $$; } <tree_command_type>
 %destructor { delete $$; } <tree_if_command_type>
@@ -507,28 +509,32 @@ identifier      : NAME
                                                       $1->line (),
                                                       $1->column ());
                   }
                 ;
 
 superclass_identifier
                 : SUPERCLASSREF
                   {
-                    std::string method_nm = $1->superclass_method_name ();
-                    std::string class_nm = $1->superclass_class_name ();
-
-                    $$ = parser.make_superclass_ref (method_nm, class_nm);
+                    std::string meth_or_obj
+                      = $1->superclass_method_or_object_name ();
+                    std::string cls = $1->superclass_class_name ();
+
+                    $$ = new octave::tree_superclass_ref (meth_or_obj, cls,
+                                                          $1->line (),
+                                                          $1->column ());
                   }
                 ;
 
 meta_identifier : METAQUERY
                   {
-                    std::string class_nm = $1->text ();
-
-                    $$ = parser.make_meta_class_query (class_nm);
+                    std::string cls = $1->text ();
+
+                    $$ = new octave::tree_metaclass_query (cls, $1->line (),
+                                                           $1->column ());
                   }
                 ;
 
 string          : DQ_STRING
                   { $$ = parser.make_constant (DQ_STRING, $1); }
                 | SQ_STRING
                   { $$ = parser.make_constant (SQ_STRING, $1); }
                 ;
@@ -3543,50 +3549,16 @@ namespace octave
     m_function_scopes.pop ();
 
     m_lexer.m_defining_func--;
     m_lexer.m_parsed_function_name.pop ();
     m_lexer.m_looking_at_return_list = false;
     m_lexer.m_looking_at_parameter_list = false;
   }
 
-  tree_funcall *
-  base_parser::make_superclass_ref (const std::string& method_nm,
-                                    const std::string& class_nm)
-  {
-    octave_value_list args;
-
-    args(1) = class_nm;
-    args(0) = method_nm;
-
-    symbol_table& symtab
-      = __get_symbol_table__ ("base_parser::make_superclass_ref");
-
-    octave_value fcn
-      = symtab.find_built_in_function ("__superclass_reference__");
-
-    return new tree_funcall (fcn, args);
-  }
-
-  tree_funcall *
-  base_parser::make_meta_class_query (const std::string& class_nm)
-  {
-    octave_value_list args;
-
-    args(0) = class_nm;
-
-    symbol_table& symtab
-      = __get_symbol_table__ ("base_parser::make_meta_class_query");
-
-    octave_value fcn
-      = symtab.find_built_in_function ("__meta_class_query__");
-
-    return new tree_funcall (fcn, args);
-  }
-
   // A CLASSDEF block defines a class that has a constructor and other
   // methods, but it is not an executable command.  Parsing the block
   // makes some changes in the symbol table (inserting the constructor
   // and methods, and adding to the list of known objects) and creates
   // a parse tree containing meta information about the class.
 
   tree_classdef *
   base_parser::make_classdef (token *tok_val,
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -63,17 +63,16 @@ namespace octave
   class tree_classdef_superclass_list;
   class tree_colon_expression;
   class tree_command;
   class tree_constant;
   class tree_decl_command;
   class tree_decl_init_list;
   class tree_expression;
   class tree_fcn_handle;
-  class tree_funcall;
   class tree_function_def;
   class tree_identifier;
   class tree_if_clause;
   class tree_if_command;
   class tree_if_command_list;
   class tree_index_expression;
   class tree_matrix;
   class tree_matrix;
@@ -299,23 +298,16 @@ namespace octave
     finish_function (tree_parameter_list *ret_list,
                      octave_user_function *fcn, comment_list *lc,
                      int l, int c);
 
     // Reset state after parsing function.
     void
     recover_from_parsing_function (void);
 
-    tree_funcall *
-    make_superclass_ref (const std::string& method_nm,
-                         const std::string& class_nm);
-
-    tree_funcall *
-    make_meta_class_query (const std::string& class_nm);
-
     tree_classdef *
     make_classdef (token *tok_val, tree_classdef_attribute_list *a,
                    tree_identifier *id, tree_classdef_superclass_list *sc,
                    tree_classdef_body *body, token *end_tok,
                    comment_list *lc);
 
     tree_classdef_properties_block *
     make_classdef_properties_block (token *tok_val,
diff --git a/libinterp/parse-tree/pt-all.h b/libinterp/parse-tree/pt-all.h
--- a/libinterp/parse-tree/pt-all.h
+++ b/libinterp/parse-tree/pt-all.h
@@ -35,17 +35,16 @@ along with Octave; see the file COPYING.
 #include "pt-classdef.h"
 #include "pt-cmd.h"
 #include "pt-colon.h"
 #include "pt-const.h"
 #include "pt-decl.h"
 #include "pt-except.h"
 #include "pt-exp.h"
 #include "pt-fcn-handle.h"
-#include "pt-funcall.h"
 #include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-jump.h"
 #include "pt-loop.h"
 #include "pt-mat.h"
 #include "pt-cell.h"
 #include "pt-misc.h"
 #include "pt-pr-code.h"
diff --git a/libinterp/parse-tree/pt-anon-scopes.cc b/libinterp/parse-tree/pt-anon-scopes.cc
--- a/libinterp/parse-tree/pt-anon-scopes.cc
+++ b/libinterp/parse-tree/pt-anon-scopes.cc
@@ -297,21 +297,16 @@ namespace octave
   }
 
   void
   tree_anon_scopes::visit_fcn_handle (tree_fcn_handle& /* fh */)
   {
   }
 
   void
-  tree_anon_scopes::visit_funcall (tree_funcall& /* fc */)
-  {
-  }
-
-  void
   tree_anon_scopes::visit_parameter_list (tree_parameter_list&)
   {
     // In visit_anon_fcn_handle we only accept/visit the body of
     // anonymous function definitions, not the parameter list.
 
     panic_impossible ();
   }
 
diff --git a/libinterp/parse-tree/pt-anon-scopes.h b/libinterp/parse-tree/pt-anon-scopes.h
--- a/libinterp/parse-tree/pt-anon-scopes.h
+++ b/libinterp/parse-tree/pt-anon-scopes.h
@@ -109,18 +109,16 @@ namespace octave
     void visit_multi_assignment (tree_multi_assignment&);
 
     void visit_no_op_command (tree_no_op_command&);
 
     void visit_constant (tree_constant&);
 
     void visit_fcn_handle (tree_fcn_handle&);
 
-    void visit_funcall (tree_funcall&);
-
     void visit_parameter_list (tree_parameter_list&);
 
     void visit_postfix_expression (tree_postfix_expression&);
 
     void visit_prefix_expression (tree_prefix_expression&);
 
     void visit_return_command (tree_return_command&);
 
diff --git a/libinterp/parse-tree/pt-bp.cc b/libinterp/parse-tree/pt-bp.cc
--- a/libinterp/parse-tree/pt-bp.cc
+++ b/libinterp/parse-tree/pt-bp.cc
@@ -272,22 +272,16 @@ namespace octave
 
   void
   tree_breakpoint::visit_fcn_handle (tree_fcn_handle&)
   {
     panic_impossible ();
   }
 
   void
-  tree_breakpoint::visit_funcall (tree_funcall&)
-  {
-    panic_impossible ();
-  }
-
-  void
   tree_breakpoint::visit_parameter_list (tree_parameter_list&)
   {
     panic_impossible ();
   }
 
   void
   tree_breakpoint::visit_postfix_expression (tree_postfix_expression&)
   {
diff --git a/libinterp/parse-tree/pt-bp.h b/libinterp/parse-tree/pt-bp.h
--- a/libinterp/parse-tree/pt-bp.h
+++ b/libinterp/parse-tree/pt-bp.h
@@ -110,18 +110,16 @@ namespace octave
     void visit_no_op_command (tree_no_op_command&);
 
     void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
     void visit_constant (tree_constant&);
 
     void visit_fcn_handle (tree_fcn_handle&);
 
-    void visit_funcall (tree_funcall&);
-
     void visit_parameter_list (tree_parameter_list&);
 
     void visit_postfix_expression (tree_postfix_expression&);
 
     void visit_prefix_expression (tree_prefix_expression&);
 
     void visit_return_command (tree_return_command&);
 
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -335,20 +335,16 @@ namespace octave
   tree_checker::visit_constant (tree_constant& /* val */)
   { }
 
   void
   tree_checker::visit_fcn_handle (tree_fcn_handle& /* fh */)
   { }
 
   void
-  tree_checker::visit_funcall (tree_funcall& /* fc */)
-  { }
-
-  void
   tree_checker::visit_parameter_list (tree_parameter_list& lst)
   {
     auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_decl_elt *elt = *p++;
 
diff --git a/libinterp/parse-tree/pt-check.h b/libinterp/parse-tree/pt-check.h
--- a/libinterp/parse-tree/pt-check.h
+++ b/libinterp/parse-tree/pt-check.h
@@ -95,18 +95,16 @@ namespace octave
     void visit_no_op_command (tree_no_op_command&);
 
     void visit_anon_fcn_handle (tree_anon_fcn_handle&);
 
     void visit_constant (tree_constant&);
 
     void visit_fcn_handle (tree_fcn_handle&);
 
-    void visit_funcall (tree_funcall&);
-
     void visit_parameter_list (tree_parameter_list&);
 
     void visit_postfix_expression (tree_postfix_expression&);
 
     void visit_prefix_expression (tree_prefix_expression&);
 
     void visit_return_command (tree_return_command&);
 
diff --git a/libinterp/parse-tree/pt-classdef.cc b/libinterp/parse-tree/pt-classdef.cc
--- a/libinterp/parse-tree/pt-classdef.cc
+++ b/libinterp/parse-tree/pt-classdef.cc
@@ -24,16 +24,39 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "ov-classdef.h"
 #include "pt-classdef.h"
 
 namespace octave
 {
+  tree_superclass_ref *
+  tree_superclass_ref::dup (symbol_scope&) const
+  {
+    tree_superclass_ref *new_scr
+      = new tree_superclass_ref (m_method_or_object_name, m_class_name,
+                                 line (), column ());
+
+    new_scr->copy_base (*this);
+
+    return new_scr;
+  }
+
+  tree_metaclass_query *
+  tree_metaclass_query::dup (symbol_scope&) const
+  {
+    tree_metaclass_query *new_mcq
+      = new tree_metaclass_query (m_class_name, line (), column ());
+
+    new_mcq->copy_base (*this);
+
+    return new_mcq;
+  }
+
   // Classdef attribute
 
   // Classdef attribute_list
 
   tree_classdef_attribute_list::~tree_classdef_attribute_list (void)
   {
     while (! empty ())
       {
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -36,16 +36,88 @@ class octave_value;
 #include "base-list.h"
 
 #include <list>
 
 namespace octave
 {
   class interpreter;
 
+  class tree_superclass_ref : public tree_expression
+  {
+  public:
+
+    tree_superclass_ref (void) = delete;
+
+    tree_superclass_ref (const std::string& meth_or_obj,
+                         const std::string& cls, int l = -1, int c = -1)
+      : tree_expression (l, c), m_method_or_object_name (meth_or_obj),
+        m_class_name (cls)
+    { }
+
+    // No copying!
+
+    tree_superclass_ref (const tree_superclass_ref&) = delete;
+
+    tree_superclass_ref& operator = (const tree_superclass_ref&) = delete;
+
+    std::string method_or_object_name (void) const
+    {
+      return m_method_or_object_name;
+    }
+
+    std::string class_name (void) const { return m_class_name; }
+
+    bool has_magic_end (void) const { return false; }
+
+    tree_superclass_ref * dup (symbol_scope& scope) const;
+
+    void accept (tree_walker& tw)
+    {
+      tw.visit_superclass_ref (*this);
+    }
+
+  private:
+
+    std::string m_method_or_object_name;
+    std::string m_class_name;
+  };
+
+  class tree_metaclass_query : public tree_expression
+  {
+  public:
+
+    tree_metaclass_query (void) = delete;
+
+    tree_metaclass_query (const std::string& cls, int l = -1, int c = -1)
+      : tree_expression (l, c), m_class_name (cls)
+    { }
+
+    // No copying!
+
+    tree_metaclass_query (const tree_metaclass_query&) = delete;
+
+    tree_metaclass_query& operator = (const tree_metaclass_query&) = delete;
+
+    std::string class_name (void) const { return m_class_name; }
+
+    bool has_magic_end (void) const { return false; }
+
+    tree_metaclass_query * dup (symbol_scope& scope) const;
+
+    void accept (tree_walker& tw)
+    {
+      tw.visit_metaclass_query (*this);
+    }
+
+  private:
+
+    std::string m_class_name;
+  };
+
   class tree_classdef_attribute
   {
   public:
 
     tree_classdef_attribute (tree_identifier *i = nullptr,
                              tree_expression *e = nullptr)
       : m_id (i), m_expr (e), m_neg (false)
     { }
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -41,16 +41,17 @@ along with Octave; see the file COPYING.
 #include "errwarn.h"
 #include "input.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
+#include "parse.h"
 #include "profiler.h"
 #include "pt-all.h"
 #include "pt-anon-scopes.h"
 #include "pt-eval.h"
 #include "pt-tm-const.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
@@ -2692,48 +2693,16 @@ namespace octave
     std::string nm = expr.name ();
 
     octave_value fh = make_fcn_handle (nm);
 
     push_result (fh);
   }
 
   void
-  tree_evaluator::visit_funcall (tree_funcall& expr)
-  {
-    octave_value_list retval;
-
-    octave_value fcn = expr.function ();
-
-    octave_value_list args = expr.arguments ();
-
-    int nargout = m_nargout_stack.top ();
-
-    retval = feval (fcn.function_value (), args, nargout);
-
-    if (retval.length () == 1 && retval(0).is_function ())
-      {
-        // The return object is a function.  We may need to re-index it
-        // using the same logic as for identifier.  This is primarily
-        // used for superclass references in classdef.
-
-        octave_value val = retval(0);
-        octave_function *f = val.function_value (true);
-
-        if (f && ! (expr.is_postfix_indexed ()
-                    && f->accepts_postfix_index (expr.postfix_index ())))
-          {
-            retval = f->call (*this, nargout);
-          }
-      }
-
-    push_result (retval);
-  }
-
-  void
   tree_evaluator::visit_parameter_list (tree_parameter_list&)
   {
     panic_impossible ();
   }
 
   void
   tree_evaluator::visit_postfix_expression (tree_postfix_expression& expr)
   {
@@ -3421,16 +3390,55 @@ namespace octave
 
         m_call_stack.set_location (until_line, until_column);
 
         if (is_logically_true (expr, "do-until"))
           break;
       }
   }
 
+  void
+  tree_evaluator::visit_superclass_ref (tree_superclass_ref& expr)
+  {
+    std::string meth_or_obj = expr.method_or_object_name ();
+    std::string cls = expr.class_name ();
+
+    octave_value tmp = octave_classdef::superclass_ref (meth_or_obj, cls);
+
+    if (! expr.is_postfix_indexed ())
+      {
+        // There was no index, so this superclass_ref object is not
+        // part of an index expression.  It is also not an identifier in
+        // the syntax tree but we need to handle it as if it were.  So
+        // call the function here.
+
+        octave_function *f = tmp.function_value (true);
+
+        assert (f);
+
+        int nargout = m_nargout_stack.top ();
+
+        push_result (f->call (*this, nargout));
+        return;
+      }
+
+    // The superclass_ref function object will be indexed as part of the
+    // enclosing index expression.
+
+    push_result (tmp);
+  }
+
+  void
+  tree_evaluator::visit_metaclass_query (tree_metaclass_query& expr)
+  {
+    std::string cls = expr.class_name ();
+
+    push_result (octave_classdef::metaclass_query (cls));
+  }
+
   void tree_evaluator::bind_ans (const octave_value& val, bool print)
   {
     static std::string ans = "ans";
 
     if (val.is_defined ())
       {
         if (val.is_cs_list ())
           {
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -226,18 +226,16 @@ namespace octave
     void visit_multi_assignment (tree_multi_assignment&);
 
     void visit_no_op_command (tree_no_op_command&);
 
     void visit_constant (tree_constant&);
 
     void visit_fcn_handle (tree_fcn_handle&);
 
-    void visit_funcall (tree_funcall&);
-
     void visit_parameter_list (tree_parameter_list&);
 
     void visit_postfix_expression (tree_postfix_expression&);
 
     void visit_prefix_expression (tree_prefix_expression&);
 
     void visit_return_command (tree_return_command&);
 
@@ -259,16 +257,19 @@ namespace octave
 
     void do_unwind_protect_cleanup_code (tree_statement_list *list);
 
     void visit_unwind_protect_command (tree_unwind_protect_command&);
 
     void visit_while_command (tree_while_command&);
     void visit_do_until_command (tree_do_until_command&);
 
+    void visit_superclass_ref (tree_superclass_ref&);
+    void visit_metaclass_query (tree_metaclass_query&);
+
     void bind_ans (const octave_value& val, bool print);
 
     bool statement_printing_enabled (void);
 
     void reset_debug_state (void);
 
     void reset_debug_state (bool mode);
 
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
deleted file mode 100644
--- a/libinterp/parse-tree/pt-funcall.cc
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
-
-Copyright (C) 2012-2019 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software: you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-Octave is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<https://www.gnu.org/licenses/>.
-
-*/
-
-#if defined (HAVE_CONFIG_H)
-#  include "config.h"
-#endif
-
-#include "ov-fcn.h"
-#include "pt-funcall.h"
-#include "pt-walk.h"
-
-namespace octave
-{
-  // Function call objects.
-
-  void
-  tree_funcall::print (std::ostream& os, bool pr_as_read_syntax,
-                       bool pr_orig_text)
-  {
-    print_raw (os, pr_as_read_syntax, pr_orig_text);
-  }
-
-  void
-  tree_funcall::print_raw (std::ostream& os, bool pr_as_read_syntax,
-                           bool pr_orig_text)
-  {
-    if (pr_orig_text)
-      {
-        os << original_text ();
-      }
-    else
-      {
-        octave_function *fp = m_fcn.function_value ();
-        std::string nm = (fp ? fp->name () : "<invalid-function>");
-
-        os << nm << " (";
-
-        octave_idx_type n = m_args.length ();
-        for (octave_idx_type i = 0; i < n; i++)
-          {
-            m_args(i).print_raw (os, pr_as_read_syntax);
-
-            if (i < n - 1)
-              os << ", ";
-          }
-
-        os << ')';
-      }
-  }
-
-  tree_funcall *
-  tree_funcall::dup (symbol_scope&) const
-  {
-    tree_funcall *new_fc
-      = new tree_funcall (m_fcn, m_args, line (), column ());
-
-    new_fc->copy_base (*this);
-
-    return new_fc;
-  }
-}
diff --git a/libinterp/parse-tree/pt-funcall.h b/libinterp/parse-tree/pt-funcall.h
deleted file mode 100644
--- a/libinterp/parse-tree/pt-funcall.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-
-Copyright (C) 2012-2019 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software: you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-Octave is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<https://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_tree_funcall_h)
-#define octave_tree_funcall_h 1
-
-#include "octave-config.h"
-
-#include "ov.h"
-#include "ovl.h"
-#include "parse.h"
-#include "pt-exp.h"
-#include "pt-walk.h"
-
-namespace octave
-{
-  // Function call.  This class only represents function calls that have
-  // known functions (most useful for calls to built-in functions that
-  // are generated by the parser) and fixed argument lists, known at
-  // compile time.
-
-  class tree_funcall : public tree_expression
-  {
-  public:
-
-    tree_funcall (const octave_value& f, const octave_value_list& a,
-                  int l = -1, int c = -1)
-      : tree_expression (l, c), m_fcn (f), m_args (a)
-    {
-      if (! m_fcn.is_function ())
-        error ("tree_funcall: invalid function");
-    }
-
-    // No copying!
-
-    tree_funcall (const tree_funcall&) = delete;
-
-    tree_funcall& operator = (const tree_funcall&) = delete;
-
-    ~tree_funcall (void) = default;
-
-    bool has_magic_end (void) const { return false; }
-
-    void print (std::ostream& os, bool pr_as_read_syntax = false,
-                bool pr_orig_txt = true);
-
-    void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
-                    bool pr_orig_txt = true);
-
-    tree_funcall * dup (symbol_scope& scope) const;
-
-    octave_value function (void) const { return m_fcn; }
-
-    octave_value_list arguments (void) const { return m_args; }
-
-    void accept (tree_walker& tw)
-    {
-      tw.visit_funcall (*this);
-    }
-
-  private:
-
-    // Function to call.  Error if not a valid function at time of
-    // construction.
-    octave_value m_fcn;
-
-    // Argument list.
-    octave_value_list m_args;
-  };
-}
-
-#endif
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -736,22 +736,16 @@ namespace octave
 
   void
   jit_convert::visit_fcn_handle (tree_fcn_handle&)
   {
     throw jit_fail_exception ("No visit_fcn_handle implementation");
   }
 
   void
-  jit_convert::visit_funcall (tree_funcall&)
-  {
-    throw jit_fail_exception ();
-  }
-
-  void
   jit_convert::visit_parameter_list (tree_parameter_list&)
   {
     throw jit_fail_exception ("No visit_parameter_list implementation");
   }
 
   void
   jit_convert::visit_postfix_expression (tree_postfix_expression& tpe)
   {
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -128,18 +128,16 @@ namespace octave
     void visit_multi_assignment (tree_multi_assignment&);
 
     void visit_no_op_command (tree_no_op_command&);
 
     void visit_constant (tree_constant&);
 
     void visit_fcn_handle (tree_fcn_handle&);
 
-    void visit_funcall (tree_funcall&);
-
     void visit_parameter_list (tree_parameter_list&);
 
     void visit_postfix_expression (tree_postfix_expression&);
 
     void visit_prefix_expression (tree_prefix_expression&);
 
     void visit_return_command (tree_return_command&);
 
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -727,28 +727,16 @@ namespace octave
     print_parens (fh, "(");
 
     fh.print_raw (m_os, true, m_print_original_text);
 
     print_parens (fh, ")");
   }
 
   void
-  tree_print_code::visit_funcall (tree_funcall& fc)
-  {
-    indent ();
-
-    print_parens (fc, "(");
-
-    fc.print_raw (m_os, true, m_print_original_text);
-
-    print_parens (fc, ")");
-  }
-
-  void
   tree_print_code::visit_parameter_list (tree_parameter_list& lst)
   {
     auto p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_decl_elt *elt = *p++;
 
@@ -1140,16 +1128,28 @@ namespace octave
 
     if (expr)
       expr->accept (*this);
 
     newline ();
   }
 
   void
+  tree_print_code::visit_superclass_ref (tree_superclass_ref& scr)
+  {
+    m_os << scr.method_or_object_name () << "@" << scr.class_name ();
+  }
+
+  void
+  tree_print_code::visit_metaclass_query (tree_metaclass_query& mcq)
+  {
+    m_os << "?" << mcq.class_name ();
+  }
+
+  void
   tree_print_code::print_fcn_handle_body (tree_expression *e)
   {
     if (e)
       {
         m_suppress_newlines++;
         e->accept (*this);
         m_suppress_newlines--;
       }
diff --git a/libinterp/parse-tree/pt-pr-code.h b/libinterp/parse-tree/pt-pr-code.h
--- a/libinterp/parse-tree/pt-pr-code.h
+++ b/libinterp/parse-tree/pt-pr-code.h
@@ -112,18 +112,16 @@ namespace octave
     void visit_multi_assignment (tree_multi_assignment&);
 
     void visit_no_op_command (tree_no_op_command&);
 
     void visit_constant (tree_constant&);
 
     void visit_fcn_handle (tree_fcn_handle&);
 
-    void visit_funcall (tree_funcall&);
-
     void visit_parameter_list (tree_parameter_list&);
 
     void visit_postfix_expression (tree_postfix_expression&);
 
     void visit_prefix_expression (tree_prefix_expression&);
 
     void visit_return_command (tree_return_command&);
 
@@ -144,16 +142,20 @@ namespace octave
     void visit_try_catch_command (tree_try_catch_command&);
 
     void visit_unwind_protect_command (tree_unwind_protect_command&);
 
     void visit_while_command (tree_while_command&);
 
     void visit_do_until_command (tree_do_until_command&);
 
+    void visit_superclass_ref (tree_superclass_ref&);
+
+    void visit_metaclass_query (tree_metaclass_query&);
+
     void print_fcn_handle_body (tree_expression *);
 
   private:
 
     std::ostream& m_os;
 
     std::string m_prefix;
 
diff --git a/libinterp/parse-tree/pt-walk.h b/libinterp/parse-tree/pt-walk.h
--- a/libinterp/parse-tree/pt-walk.h
+++ b/libinterp/parse-tree/pt-walk.h
@@ -60,30 +60,31 @@ namespace octave
   class tree_switch_command;
   class tree_index_expression;
   class tree_matrix;
   class tree_cell;
   class tree_multi_assignment;
   class tree_no_op_command;
   class tree_constant;
   class tree_fcn_handle;
-  class tree_funcall;
   class tree_parameter_list;
   class tree_postfix_expression;
   class tree_prefix_expression;
   class tree_return_command;
   class tree_return_list;
   class tree_simple_assignment;
   class tree_statement;
   class tree_statement_list;
   class tree_try_catch_command;
   class tree_unwind_protect_command;
   class tree_while_command;
   class tree_do_until_command;
 
+  class tree_superclass_ref;
+  class tree_metaclass_query;
   class tree_classdef_attribute;
   class tree_classdef_attribute_list;
   class tree_classdef_superclass;
   class tree_classdef_superclass_list;
   class tree_classdef_property;
   class tree_classdef_property_list;
   class tree_classdef_properties_block;
   class tree_classdef_methods_list;
@@ -199,19 +200,16 @@ namespace octave
 
     virtual void
     visit_constant (tree_constant&) = 0;
 
     virtual void
     visit_fcn_handle (tree_fcn_handle&) = 0;
 
     virtual void
-    visit_funcall (tree_funcall&) = 0;
-
-    virtual void
     visit_parameter_list (tree_parameter_list&) = 0;
 
     virtual void
     visit_postfix_expression (tree_postfix_expression&) = 0;
 
     virtual void
     visit_prefix_expression (tree_prefix_expression&) = 0;
 
@@ -238,16 +236,22 @@ namespace octave
 
     virtual void
     visit_while_command (tree_while_command&) = 0;
 
     virtual void
     visit_do_until_command (tree_do_until_command&) = 0;
 
     virtual void
+    visit_superclass_ref (tree_superclass_ref&) { } /* = 0; */
+
+    virtual void
+    visit_metaclass_query (tree_metaclass_query&) { } /* = 0; */
+
+    virtual void
     visit_classdef_attribute (tree_classdef_attribute&) { } /* = 0; */
 
     virtual void
     visit_classdef_attribute_list (tree_classdef_attribute_list&) { } // = 0;
 
     virtual void
     visit_classdef_superclass (tree_classdef_superclass&) { } // = 0;
 
diff --git a/libinterp/parse-tree/token.cc b/libinterp/parse-tree/token.cc
--- a/libinterp/parse-tree/token.cc
+++ b/libinterp/parse-tree/token.cc
@@ -68,21 +68,21 @@ namespace octave
   { }
 
   token::token (int tv, const symbol_record& sr, int l, int c)
     : m_maybe_cmd (false), m_tspc (false), m_line_num (l), m_column_num (c),
       m_tok_val (tv), m_type_tag (sym_rec_token), m_tok_info (sr),
       m_orig_text ()
   { }
 
-  token::token (int tv, const std::string& method_nm,
-                const std::string& class_nm, int l, int c)
+  token::token (int tv, const std::string& meth_or_obj,
+                const std::string& cls, int l, int c)
     : m_maybe_cmd (false), m_tspc (false), m_line_num (l), m_column_num (c),
       m_tok_val (tv), m_type_tag (scls_name_token),
-      m_tok_info (method_nm, class_nm), m_orig_text ()
+      m_tok_info (meth_or_obj, cls), m_orig_text ()
   { }
 
   token::~token (void)
   {
     if (m_type_tag == string_token)
       delete m_tok_info.m_str;
     else if (m_type_tag == sym_rec_token)
       delete m_tok_info.m_sr;
@@ -127,27 +127,27 @@ namespace octave
   symbol_record
   token::sym_rec (void) const
   {
     assert (m_type_tag == sym_rec_token);
     return *m_tok_info.m_sr;
   }
 
   std::string
-  token::superclass_method_name (void) const
+  token::superclass_method_or_object_name (void) const
   {
     assert (m_type_tag == scls_name_token);
-    return m_tok_info.m_superclass_info->m_method_nm;
+    return m_tok_info.m_superclass_info->m_method_or_object_name;
   }
 
   std::string
   token::superclass_class_name (void) const
   {
     assert (m_type_tag == scls_name_token);
-    return m_tok_info.m_superclass_info->m_class_nm;
+    return m_tok_info.m_superclass_info->m_class_name;
   }
 
   std::string
   token::text_rep (void) const
   {
     return m_orig_text;
   }
 }
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -115,17 +115,17 @@ namespace octave
 
     std::string text (void) const;
     std::string symbol_name (void) const;
     double number (void) const;
     token_type ttype (void) const;
     end_tok_type ettype (void) const;
     symbol_record sym_rec (void) const;
 
-    std::string superclass_method_name (void) const;
+    std::string superclass_method_or_object_name (void) const;
     std::string superclass_class_name (void) const;
 
     std::string text_rep (void) const;
 
   private:
 
     bool m_maybe_cmd;
 
@@ -150,18 +150,18 @@ namespace octave
       tok_info (double num) : m_num (num) { }
 
       tok_info (end_tok_type et) : m_et (et) { }
 
       tok_info (const symbol_record& sr)
         : m_sr (new symbol_record (sr))
       { }
 
-      tok_info (const std::string& method_nm, const std::string& class_nm)
-        : m_superclass_info (new superclass_info (method_nm, class_nm))
+      tok_info (const std::string& meth_or_obj, const std::string& cls)
+        : m_superclass_info (new superclass_info (meth_or_obj, cls))
       { }
 
       tok_info (const tok_info&) = delete;
 
       tok_info& operator = (const tok_info&) = delete;
 
       ~tok_info (void) { }
 
@@ -172,29 +172,29 @@ namespace octave
       end_tok_type m_et;
 
       symbol_record *m_sr;
 
       struct superclass_info
       {
         superclass_info (void) = delete;
 
-        superclass_info (const std::string& method_nm,
-                         const std::string& class_nm)
-          : m_method_nm (method_nm), m_class_nm (class_nm)
+        superclass_info (const std::string& meth_or_obj,
+                         const std::string& cls)
+          : m_method_or_object_name (meth_or_obj), m_class_name (cls)
         { }
 
         superclass_info (const superclass_info&) = delete;
 
         superclass_info& operator = (const superclass_info&) = delete;
 
         ~superclass_info (void) = default;
 
-        std::string m_method_nm;
-        std::string m_class_nm;
+        std::string m_method_or_object_name;
+        std::string m_class_name;
       };
 
       superclass_info *m_superclass_info;
     };
 
     tok_info m_tok_info;
 
     std::string m_orig_text;
